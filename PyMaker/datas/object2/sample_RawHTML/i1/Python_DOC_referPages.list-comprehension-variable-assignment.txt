<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/533905/get-the-cartesian-product-of-a-series-of-lists">Get the cartesian product of a series of lists?</a>
<span class="question-originals-answer-count">
                    11 answers
                </span>
</li>
</ul>
</div>
<p>I am attempting to create a 4d array and assign variables to each of the cells.</p>
<p>Typically I would use four "for loops" but this is very messy and takes up a lot of space.</p>
<p>What i'm currently doing:</p>
<pre><code>for x in range(2):
    for y in range(2):
        for j in range(2):
            for k in range(2):
                array[x,y,j,k] = 1 #will be a function in reality
</code></pre>
<p>I've tried using list comprehension but this only creates the list and does not assign variables to each cell.</p>
<p>Are there space-efficient ways to run through multiple for loops and assign variables with only a few lines of code?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you've already created an empty (numpy?) array, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> to fill it with values:</p>
<pre><code>import itertools

for x, y, j, k in itertools.product(range(2), repeat=4):
    arr[x,y,j,k] = 1
</code></pre>
<p>If not all of the array's dimensions are equal, you can list them individually:</p>
<pre><code>for x, y, j, k in itertools.product(range(2), range(2), range(2), range(2)):
    arr[x,y,j,k] = 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may however be wondering <em>how</em> <code>itertools.product</code> does the trick. Or maybe you want to encode a different transformation in your recursive expansion. Below, I'll share <em>one possible solution</em> using Python's generators -</p>
<pre><code>def product (*iters):
  def loop (prod, first = [], *rest):
    if not rest:
      for x in first:
        yield prod + (x,)
    else:
      for x in first:
        yield from loop (prod + (x,), *rest)
  yield from loop ((), *iters)

for prod in product ("ab", "xyz"):
  print (prod)

# ('a', 'x')
# ('a', 'y')
# ('a', 'z')
# ('b', 'x')
# ('b', 'y')
# ('b', 'z')
</code></pre>
<p>Because <code>product</code> accepts a a list of <em>iterables</em>, any iterable input can be used in the product. They can even be mixed as demonstrated here -</p>
<pre><code>print (list (product (['@', '%'], range (2), "xy")))
# [ ('@', 0, 'x')
# , ('@', 0, 'y')
# , ('@', 1, 'x')
# , ('@', 1, 'y')
# , ('%', 0, 'x')
# , ('%', 0, 'y')
# , ('%', 1, 'x')
# , ('%', 1, 'y')
# ]
</code></pre>
<p>We could make a program <code>foo</code> that provides the output posted in your question -</p>
<pre><code>def foo (n, m):
  ranges = [ range (m) ] * n
  yield from product (*ranges)

for prod in foo (4, 2):
  print (prod)

# (0, 0, 0, 0)
# (0, 0, 0, 1)
# (0, 0, 1, 0)
# (0, 0, 1, 1)
# (0, 1, 0, 0)
# (0, 1, 0, 1)
# (0, 1, 1, 0)
# (0, 1, 1, 1)
# (1, 0, 0, 0)
# (1, 0, 0, 1)
# (1, 0, 1, 0)
# (1, 0, 1, 1)
# (1, 1, 0, 0)
# (1, 1, 0, 1)
# (1, 1, 1, 0)
# (1, 1, 1, 1)
</code></pre>
<p>Or use destructuring assignment to create bindings for individual elements of the product. In your program, simply replace <code>print</code> with your real function -</p>
<pre><code>for (w, x, y, z) in foo (4, 2):
  print ("w", w, "x", x, "y", y, "z", z)

# w 0 x 0 y 0 z 0
# w 0 x 0 y 0 z 1
# w 0 x 0 y 1 z 0
# w 0 x 0 y 1 z 1
# w 0 x 1 y 0 z 0
# w 0 x 1 y 0 z 1
# w 0 x 1 y 1 z 0
# w 0 x 1 y 1 z 1
# w 1 x 0 y 0 z 0
# w 1 x 0 y 0 z 1
# w 1 x 0 y 1 z 0
# w 1 x 0 y 1 z 1
# w 1 x 1 y 0 z 0
# w 1 x 1 y 0 z 1
# w 1 x 1 y 1 z 0
# w 1 x 1 y 1 z 1
</code></pre>
<p>Because <code>product</code> is defined as a generator, we are afforded much flexibility even when writing more complex programs. Consider this program that finds right triangles made up whole numbers, a <a href="https://en.wikipedia.org/wiki/Pythagorean_triple" rel="nofollow noreferrer">Pythagorean triple</a>. Also note that <code>product</code> allows you to repeat an iterable as input as see in <code>product (r, r, r)</code> below</p>
<pre><code>def is_triple (a, b, c):
  return a * a + b * b == c * c

def solver (n):
  r = range (1, n)
  for p in product (r, r, r):
    if is_triple (*p):
      yield p

print (list (solver (20)))
# (3, 4, 5)
# (4, 3, 5)
# (5, 12, 13)
# (6, 8, 10)
# (8, 6, 10)
# (8, 15, 17)
# (9, 12, 15)
# (12, 5, 13)
# (12, 9, 15)
# (15, 8, 17)
</code></pre>
<p>For additional explanation and a way to see how to do this without using generators, view <a href="https://stackoverflow.com/a/49719355/633183">this answer</a>.</p>
</div>
<span class="comment-copy">"I've tried using list comprehension but this only creates the list and does not assign variables to each cell." - a list comprehension can do everything your quadruply-nested loop is doing. Either you screwed up your comprehension, or you don't quite understand what your loops are doing.</span>
<span class="comment-copy">When you say "array", what exactly do you mean? A numpy array? A list of lists?</span>
<span class="comment-copy">List comprehensions are for <i>lists</i>. <code>array</code> would appear to be a NumPy array (or possibly a <code>dict</code>).</span>
<span class="comment-copy">From what i've seen list comprehension is mostly used for initialising a list, but is NOT used for assigning variables to list indices- am i wrong about his?</span>
<span class="comment-copy">List comprehensions are used to <i>create</i> new lists, yes.</span>
<span class="comment-copy">This is exactly what I am looking for! I've searched far to long to find this answer! out of curiosity, is this actually called list comprehension or something else?</span>
<span class="comment-copy">Wouldn't <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.indices.html" rel="nofollow noreferrer"><code>numpy.indices()</code></a> be more appropriate?</span>
<span class="comment-copy">Also, numpy arrays can be iterated over directly <a href="https://docs.scipy.org/doc/numpy/reference/arrays.nditer.html" rel="nofollow noreferrer">complete with indices and a writeable reference</a>.</span>
<span class="comment-copy">@MartijnPieters Well, I wasn't sure if it's really a numpy array, so...</span>
