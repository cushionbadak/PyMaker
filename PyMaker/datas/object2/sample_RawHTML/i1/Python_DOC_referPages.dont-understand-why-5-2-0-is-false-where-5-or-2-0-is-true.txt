<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3845018/boolean-operators-vs-bitwise-operators">Boolean operators vs Bitwise operators</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<p>This is a pretty trivial question that I haven't been able to find the answer to. </p>
<p>Here is the problem. I have the following array:</p>
<pre><code>vals = [-5, 2]
</code></pre>
<p>And I want to check whether <code>val[0]</code> or <code>val[1]</code> is greater than 0. If either is true, then I should output True.</p>
<p>My immediate thought was to use; <code>(vals[1] or vals[0]) &gt; 0)</code> but I'm finding that <code>(5 | -2) &gt; 0</code> is False where <code>(5 or -2) &gt; 0</code> is True</p>
<p>Any clarification would be much appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<h2>What is the difference between <code>or</code> and <code>|</code>?</h2>
<p><code>or</code> is a logical or and <code>|</code> is a bitwise or logical inclusive or.</p>
<h3>The logical or</h3>
<p><a href="https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not" rel="noreferrer">The logical or in python returns the first value that is true.</a></p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; None or False or 5
5
&gt;&gt;&gt; -5 or 2
-5
</code></pre>
<h3>The bitwise or logical inclusive or</h3>
<p>The bitwise or logical inclusive or is represented by the <code>|</code> operator in python and creates a <a href="https://docs.python.org/3/library/stdtypes.html#bitwise-operations-on-integer-types" rel="noreferrer">number where all bits are set that are set in at least one of the given numbers</a>.</p>
<p>Example:</p>
<ul>
<li>2 is in binary <code>0010</code></li>
<li>4 is in binary <code>0100</code></li>
</ul>
<p>A logical or between the two results in <code>0110</code> which is 6.</p>
<pre><code>&gt;&gt;&gt; 2 | 4
6
</code></pre>
<p>How a negative number is stored is generally implementation specific. However on most systems a negative number is stored by creating the <a href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="noreferrer">two's complement</a> of the positive number by inverting each bit and adding 1.</p>
<p>That number in bitwise ore two any other number still results in a negative number:</p>
<pre><code>&gt;&gt;&gt; -5 | 2
-5
</code></pre>
<p><strong>Neither of the two solves your problem</strong></p>
<p>While using </p>
<pre><code>(vals[1] or vals[0]) &gt; 0
</code></pre>
<p>seems to work, it fails when you flip the values:</p>
<pre><code>&gt;&gt;&gt; vals = [2, -5]
&gt;&gt;&gt; (vals[1] or vals[0]) &gt; 0
False
</code></pre>
<p>You should check both values seperatly</p>
<pre><code>&gt;&gt;&gt; vals = [-5, 2]
&gt;&gt;&gt; vals[0] &gt; 0 or vals[1] &gt; 0
True
</code></pre>
<p>For a larger input this may be inconvenient. You should use <a href="https://docs.python.org/3/library/functions.html#any" rel="noreferrer">any</a> with a generator expression:</p>
<pre><code>&gt;&gt;&gt; any(x &gt; 0 for x in vals)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You want the <code>any</code> function:</p>
<pre><code>&gt;&gt;&gt; any(x &gt; 0 for x in vals)
</code></pre>
<p><code>x | y</code> computes the bitwise <code>OR</code> of the two values, while <code>x or y</code> evaluates to the first "truthy" value. In both cases, the <em>result</em> is then compared to <code>0</code>: <code>(x or y) &gt; 0</code> and <code>(x | y) &gt; 0</code>.</p>
<p>What you want to compare <em>each</em> value to zero (as necessary), with</p>
<pre><code>vals[0] &gt; 0 or vals[1] &gt; 0
</code></pre>
<p>If you had three values, you'd write</p>
<pre><code>vals[0] &gt; 0 or vals[1] &gt; 0 or vals[2] &gt; 0
</code></pre>
<p>The <code>any</code> function generalizes this to a list of any size, without the need to decide how many terms to <code>or</code> together based on the size of the list.</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer this question, I have to explain about Two's Complement.</p>
<h1>BINARY REPRESENTATION OF NUMBERS</h1>
<p>So you know how internally, an integer like 5 is represented as a binary string</p>
<pre><code>00000000000000000000000000000101
</code></pre>
<p>How do you imagine you'd represent a negative number?</p>
<p>Well, here's what we want to do:</p>
<ul>
<li><p>Addition should work the same with negative numbers and positive numbers; i.e. you do the same  steps to add 4 + 9 as 4 + -9.</p></li>
<li><p>Integer overflow shouldn't break mathematics; i.e. <code>MAX_VALUE + 1 == MIN_VALUE</code>, <code>MIN_VALUE - 1 == MAX_VALUE</code></p></li>
</ul>
<p>So what we do is called "Two's Complement."</p>
<h2>TWO'S COMPLEMENT</h2>
<p>To represent a negative number, take its absolute value, bitflip every bit, and add 1.</p>
<p>So if the positive number is 5</p>
<pre><code>00000000000000000000000000000101
</code></pre>
<p>the negative number -5 is</p>
<pre><code>11111111111111111111111111111011
</code></pre>
<p>Essentially, this means we pick the number <code>01111111111111111111111111111111</code> to be the largest positive number, and all numbers after that are negative.</p>
<h1>SO WHAT DOES (5 | -2) MEAN?</h1>
<p>The <code>|</code> is the bitwise or operator. Given two numbers, it takes every bit and or's them together, constructing a new number where a digit is 1 if the digit in that position in wither or both of the two original numbers is 1, and 0 otherwise. The calculation looks like this:</p>
<pre><code>   5 -&gt; 00000000000000000000000000000101
| -2 -&gt; 11111111111111111111111111111110
----    --------------------------------
        11111111111111111111111111111111 -&gt; -1
</code></pre>
<p>So as you can see, 5 | -2 = -1 &lt; 0.</p>
<h1>WHAT ABOUT (5 or -2)?</h1>
<p>The "or" operator takes two values, <strong>casts them to booleans</strong> and or's them together. This is important: it doesn't or the values, it returns the first value that is "truthy" -- in other words, if you put it in an if statement, it would run.</p>
<p>The only integer that isn't "truthy" is 0. Therefore (5 or -2) returns the first non-zero integer of 5 and 2, which is 5 &gt; 0. So 5 or -2 = 5 &gt; 0.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>|</code> is a <a href="https://en.wikipedia.org/wiki/Bitwise_operation" rel="nofollow noreferrer">bitwise</a> OR, and Python uses <a href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="nofollow noreferrer">two's complement</a> representation for integers.  Evaluating <code>5 | -2</code> gives:</p>
<pre><code>  ... 0000 0000 0000 0101 (+5)
| ... 1111 1111 1111 1110 (-2)
──────────────────────────────
= ... 1111 1111 1111 1111 (-1)
</code></pre>
<p>And -1 is not greater than zero, so <code>(5 | -2) &gt; 0</code> is false.</p>
<p><code>or</code> is a logical OR.  Unlike in other languages where this operator returns a Boolean (True/False) value, Python defines <code>x or y</code> as being equivalent to <code>x if x else y</code> (except that x is evaluated only once).  Note that any nonzero numeric value is “truthy” in Python, so if x≠0, then <code>x or y</code> evaluates to <code>x</code>.</p>
<pre><code>&gt;&gt;&gt; 5 or -2
5
&gt;&gt;&gt; -2 or 5
-2
</code></pre>
<p>That <code>(5 or -2) &gt; 0</code> evaluates to True was a stroke of luck from having the positive number first.  In the other order, you would have gotten False.</p>
<p>In general <code>(x or y) &gt; 0</code> is <em>not</em> equivalent to <code>(x &gt; 0) or (y &gt; 0)</code>, which is what you meant.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you do <code>(5 | -2)</code>, you're doing a bitwise-OR. That will preserve the negation bit in the numbers. Therefore, you'll still have a negative number.</p>
<p>The <code>(5 or -2)</code> is a logical-OR, to the Python interpreter will extend that to the next logical operator (the greater-than).</p>
</div>
<div class="post-text" itemprop="text">
<p>They are two completely different operations so that is expected.</p>
<p>To illustrate, here's a small shell log:</p>
<pre><code>In [1]: 5 or -2
Out[1]: 5

In [2]: 5 | -2
Out[2]: -1
</code></pre>
<p>The <code>or</code> operator returns the first non-zero (non-<code>None</code>, non-<code>False</code>, etc.) value.</p>
<p>The <code>|</code> operator does a bitwise or. To illustrate:</p>
<pre><code>In [3]: bin(5)
Out[3]: '0b101'

In [4]: bin(-2)
Out[4]: '-0b10'

In [5]: bin(5 | -2)
Out[5]: '-0b1'
</code></pre>
</div>
<span class="comment-copy"><code>|</code> is a bitwise operator, not the logical <code>or</code>.</span>
<span class="comment-copy"><code>x or y == x</code> for any non-zero <code>x</code>.</span>
<span class="comment-copy">@chepner Indeed! Don't assume operator precedence, nor that the interpreter knows what you mean.</span>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/15112125/how-to-test-multiple-variables-against-a-value">How to test multiple variables against a value?</a></span>
<span class="comment-copy">These are Python ints, not native CPU integers; I'm pretty sure they're explicitly specified to use two's complement. (That said, I'm having a surprisingly hard time locating such a specification. The closest I've found is <a href="https://wiki.python.org/moin/BitwiseOperators" rel="nofollow noreferrer">this wiki page</a>, which is explicit enough but perhaps not fully authoritative, and <a href="https://docs.python.org/3/reference/expressions.html#unary-arithmetic-and-bitwise-operations" rel="nofollow noreferrer">an oblique remark in the docs</a> saying that "The bitwise inversion of <code>x</code> is defined as <code>-(x+1)</code>.")</span>
<span class="comment-copy">Yeah, the <a href="https://docs.python.org/3/library/stdtypes.html" rel="nofollow noreferrer">docs for the built-in types</a> have several hints suggesting that.</span>
<span class="comment-copy">Good find. In fact, that page explicitly says that "The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits."</span>
<span class="comment-copy">One of those times when going to school for CS is actually useful, isn't it? Nice, complete answer. Welcome to SO!</span>
<span class="comment-copy">Brilliant explanation! One thing missing; how do you do the thing OP wanted?</span>
<span class="comment-copy">You could say vals[0] &gt; 0 or vals[1] &gt; 0, which might work best as a helper function:</span>
<span class="comment-copy">def atLeastOnePositive(vals): for val in vals: if val &gt; 0: return True</span>
<span class="comment-copy">return False # outside the for loop, if no element is &gt; 0</span>
<span class="comment-copy">I feel dumb, but why is all <code>1</code>s equal to <code>-1</code> and not 2^16 or whatever?</span>
<span class="comment-copy">@user1717828 because the usual convention is that the most significant bit is taken as negative; so -2^31 for a 4-byte integer.  This allows for the storage of a good range of positive and negative numbers.  If all the bits were taken as positive, you'd only be able to represent positive numbers, which in many contexts would be less useful.</span>
<span class="comment-copy">Also, Python takes this to the extreme; <code>-1</code> is represented by an <i>infinite number</i> of <code>1</code>s. (It's compressed in memory, in the CPython (reference) implementation.)</span>
