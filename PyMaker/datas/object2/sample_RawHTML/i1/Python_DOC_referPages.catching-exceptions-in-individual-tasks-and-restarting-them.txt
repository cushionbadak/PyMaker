<div class="post-text" itemprop="text">
<p>If I create a series of <code>asyncio</code> tasks in a top level class, all of which should essentially run forever, like so:</p>
<pre class="lang-py prettyprint-override"><code>self.event_loop.create_task(...)
self.event_loop.create_task(...)
self.event_loop.create_task(...)
...

self.event_loop.run_forever()

# Once we fall out of the event loop, collect all remaining tasks,
# cancel them, and terminate the asyncio event loop
tasks = asyncio.Task.all_tasks()
group = asyncio.gather(*tasks, return_exceptions=True)
group.cancel()
self.event_loop.run_until_complete(group)
self.event_loop.close()
</code></pre>
<p>The above code doesn't handle the following situation, which I'm finding I need more and more, and I haven't seen an example in Googling or in the <code>asyncio</code> docs:</p>
<p>If one of the tasks fails with an exception, the exception doesn't get handled - all of the other tasks proceed, but that one task simply halts silently (other than the exception output).</p>
<p>So, how can I:</p>
<ul>
<li>Set up for the exception to be handled, so that the failure isn't silent any more</li>
<li>Most importantly, restart the failed task, effectively running <code>self.event_loop.create_task(...)</code> again, just for that task? This would seem to require finding the task that received the exception in the event loop, removing it, and adding a new one - how to do that is not clear to me.</li>
<li>Allow the tasks that didn't have issues to continue uninterrupted.  Want to avoid any side effects of handling the task that received the exception.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Uncaught exceptions are attached to the task object, and could be retrieved from it via the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.exception" rel="nofollow noreferrer"><code>Task.exception()</code> method</a>. The <code>self.event_loop.create_task(...)</code> call returns the task object, so you'd want to collect those to inspect exceptions.</p>
<p>If you want to reschedule a task whenever an exception has occurred, then you'd want to do that in a new task (because you'd want it to run in the event loop), or use a wrapper co-routine that catches exceptions and just re-runs the given coroutine again.</p>
<p>The latter could look something like:</p>
<pre><code>import traceback

def rerun_on_exception(coro, *args, **kwargs):
    while True:
        try:
            await coro(*args, **kwargs)
        except asyncio.CancelledError:
            # don't interfere with cancellations
            raise
        except Exception:
            print("Caught exception")
            traceback.print_exc()
</code></pre>
<p>then wrap your coroutines with the above coroutine when scheduling them as a task:</p>
<pre><code>self.event_loop.create_task(rerun_on_exception(coroutine_uncalled, arg1value, ... kwarg1=value, ...)
</code></pre>
<p>e.g. passing in the arguments to create the coroutine each time there is an exception.</p>
<p>The other option is to use <a href="https://docs.python.org/3/library/asyncio-task.html#waiting-primitives" rel="nofollow noreferrer"><code>asyncio.wait()</code></a> in a separate task so you can monitor for exceptions as the loop runs, and make decisions on how to handle exceptions there and then:</p>
<pre><code>def exception_aware_scheduler(*task_definitions, loop=None):
    if loop is None:
        loop = asyncio.get_event_loop()

    task_arguments = {
        loop.create_task(coro(*args, **kwargs)): (coro, args, kwargs)
        for coro, args, kwargs in task_definitions
    }
    while tasks:
        done, pending = await asyncio.wait(
            tasks.keys(), loop=loop, return_when=asyncio.FIRST_EXCEPTION
        )
        for task in done:
            if task.exception() is not None:
                print('Task exited with exception:')
                task.print_stack()
                print('Rescheduling the task\n')
                coro, args, kwargs = tasks.pop(task)
                tasks[loop.create_task(coro(*args, **kwargs))] = coro, args, kwargs
</code></pre>
<p>The <code>asyncio.wait()</code> call is given control again by the event loop when when any one of the tasks scheduled exited due to an exception, but until that happens, tasks could have been cancelled or simply completed their work. When a task did exit because of an exception, you need a way to create the same coroutine again (with the same arguments), hence the <code>*args, **kwargs</code> setup above.</p>
<p>You'd schedule just the <code>exception_aware_scheduler()</code>, passing in the tasks you wanted to pass in:</p>
<pre><code>tasks = (
    (coro1, (), {}),  # no arguments
    (coro2, ('arg1', 'arg2'), {}),
    # ...
)
loop.create_task(exception_aware_scheduler(*task_definitions, loop=loop))
</code></pre>
</div>
<span class="comment-copy">Two options - wonderful!  I'll work on this and get back to you on which one fits, or if I have anything further, but I think this looks like just what I'm after.  Stay tuned.</span>
