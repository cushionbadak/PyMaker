<div class="post-text" itemprop="text">
<p>Consider the following two short programs.</p>
<p><strong>normal_test.py</strong>:</p>
<pre><code>import time

if __name__ == '__main__':
    t_end = time.time() + 1
    loop_iterations = 0
    while time.time() &lt; t_end:
        loop_iterations += 1

    print(loop_iterations)
</code></pre>
<p><strong>Output</strong> (on my machine):</p>
<pre><code>4900677
</code></pre>
<p><strong>mp_test.py</strong>:</p>
<pre><code>from multiprocessing import Process
from multiprocessing import Manager
import time


def loop1(ns):
    t_end = time.time() + 1
    while time.time() &lt; t_end:
        ns.loop_iterations1 += 1


def loop2(ns):
    t_end = time.time() + 1
    while time.time() &lt; t_end:
        ns.loop_iterations2 += 1


if __name__ == '__main__':
    manager = Manager()
    ns = manager.Namespace()
    ns.loop_iterations1 = 0
    ns.loop_iterations2 = 0

    p1 = Process(target=loop1, args=(ns,))
    p2 = Process(target=loop2, args=(ns,))
    p1.start()
    p2.start()

    p1.join()
    p2.join()

    print(ns.loop_iterations1)
    print(ns.loop_iterations2)
</code></pre>
<p><strong>Output</strong> (on my machine):</p>
<pre><code>5533
5527
</code></pre>
<p>I am hoping to use Python multiprocessing on a Raspberry Pi to read values from multiple ADCs in parallel. As such, speed is important. The laptop I ran these two programs on has four cores, so I can't understand why the processes created in the second program are only able to run nearly 900 times less iterations than the single process in the first program. Am I using the Python multiprocessing library incorrectly? How can I make the processes faster?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Am I using the Python multiprocessing library incorrectly? </p>
</blockquote>
<p>Incorrectly?  No.  Inefficiently?  Yes.</p>
<p>Remember that multiprocessing creates cooperative, but otherwise independent, instances of Python.  Think of them as workers in a factory, or friends working on a big job.</p>
<p>If only <em>one</em> person is working on a project, that one person is free to move about the factory floor, pick up a tool, use it, put it down, move somewhere else, pick up the next tool, and so on.  Add a second person—or worse, more people, perhaps even hundreds of people—and the person must now coordinate: if some area is shared, or some tool is shared, Bob can't just go grab something, he has to ask Alice first if she's done with it.</p>
<p>A <code>Manager</code> object is Python multiprocessing's general wrapper for sharing.  Putting variables in a Manager <code>Namespace</code> means <em>these are shared, so automatically check with everyone else before you use them</em>.  (More precisely, they're held in one location—one process—and accessed or changed from others via proxies.)</p>
<p>Here, you have done the metaphorical equivalent of replacing "Bob: count as fast as you can" with "Bob: constantly interrupt Alice to ask if she's counting, then count; Alice: count, but be constantly interrupted by Bob."  Bob and Alice are now spending most, by far, of their time talking to each other, rather than counting.</p>
<p>As <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">the documentation says</a>:</p>
<blockquote>
<p>... when doing concurrent programming it is usually best to avoid using shared state as far as possible. This is particularly true when using multiple processes.</p>
</blockquote>
<p>(it starts with the phrase "as mentioned above" but it's not mentioned above!).</p>
<p>There are a bunch of standard tricks, such as <em>batching</em> to get a lot of work done <em>between</em> sharing events, or using <em>shared memory</em> to speed up the sharing—but with shared memory you introduce the need to <em>lock</em> items.</p>
</div>
<span class="comment-copy">Replacing the namespace with two <code>num1 = Value('d', 0.0)</code> improves it but still slower. The problem probably is the overhead of managing the shared state</span>
<span class="comment-copy">#H4kor Yeah, unfortunately I need the shared state because I have flags that both processes need access to. I might need to rethink my design then.</span>
<span class="comment-copy">I understand that shared state isn't needed in the program in my question, but in my actual code, I have global flags that both processes need access to.</span>
<span class="comment-copy">If they only need <i>read</i> access, make copies. If they need <i>read and write</i> access, consider copies-and-batching: e.g., generate 1000 results on the assumption that the flags have not changed. Then, if the flags changed, throw away that work and start over with new flags.</span>
