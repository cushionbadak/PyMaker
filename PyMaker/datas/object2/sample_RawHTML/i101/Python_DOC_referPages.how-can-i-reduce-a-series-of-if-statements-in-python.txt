<div class="post-text" itemprop="text">
<p>I want to write a function in Python that returns different fixed values based on the value of an input index.  </p>
<p>In other languages I would use a <code>switch</code> or <code>case</code> statement, but Python does not appear to have a <code>switch</code> statement.  What are the recommended Python solutions in this scenario?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a dictionary:</p>
<pre><code>def f(x):
    return {
        'a': 1,
        'b': 2,
    }[x]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you'd like defaults you could use the dictionary <a href="https://docs.python.org/2/library/stdtypes.html#dict.get" rel="noreferrer"><code>get(key[, default])</code></a> method:</p>
<pre><code>def f(x):
    return {
        'a': 1,
        'b': 2
    }.get(x, 9)    # 9 is default if x not found
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've always liked doing it this way</p>
<pre><code>result = {
  'a': lambda x: x * 5,
  'b': lambda x: x + 7,
  'c': lambda x: x - 2
}[value](x)
</code></pre>
<p><a href="http://blog.simonwillison.net/post/57956755106/switch" rel="noreferrer">From here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the dictionary methods (which I really like, BTW), you can also use if-elif-else to obtain the switch/case/default functionality:</p>
<pre><code>if x == 'a':
    # Do the thing
elif x == 'b':
    # Do the other thing
if x in 'bc':
    # Fall-through by not using elif, but now the default case includes case 'a'!
elif x in 'xyz':
    # Do yet another thing
else:
    # Do the default
</code></pre>
<p>This of course is not identical to switch/case - you cannot have fall-through as easily as leaving off the break; statement, but you can have a more complicated test.  Its formatting is nicer than a series of nested ifs, even though functionally that's what it is closer to.</p>
</div>
<div class="post-text" itemprop="text">
<p>My favorite Python recipe for switch/case is:</p>
<pre><code>choices = {'a': 1, 'b': 2}
result = choices.get(key, 'default')
</code></pre>
<p>Short and simple for simple scenarios. </p>
<p>Compare to 11+ lines of C code:</p>
<pre><code>// C Language version of a simple 'switch/case'.
switch( key ) 
{
    case 'a' :
        result = 1;
        break;
    case 'b' :
        result = 2;
        break;
    default :
        result = -1;
}
</code></pre>
<p>You can even assign multiple variables by using tuples:</p>
<pre><code>choices = {'a': (1, 2, 3), 'b': (4, 5, 6)}
(result1, result2, result3) = choices.get(key, ('default1', 'default2', 'default3'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class switch(object):
    value = None
    def __new__(class_, value):
        class_.value = value
        return True

def case(*args):
    return any((arg == switch.value for arg in args))
</code></pre>
<p>Usage:</p>
<pre><code>while switch(n):
    if case(0):
        print "You typed zero."
        break
    if case(1, 4, 9):
        print "n is a perfect square."
        break
    if case(2):
        print "n is an even number."
    if case(2, 3, 5, 7):
        print "n is a prime number."
        break
    if case(6, 8):
        print "n is an even number."
        break
    print "Only single-digit numbers are allowed."
    break
</code></pre>
<p>Tests:</p>
<pre><code>n = 2
#Result:
#n is an even number.
#n is a prime number.
n = 11
#Result:
#Only single-digit numbers are allowed.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's a pattern that I learned from Twisted Python code.</p>
<pre><code>class SMTP:
    def lookupMethod(self, command):
        return getattr(self, 'do_' + command.upper(), None)
    def do_HELO(self, rest):
        return 'Howdy ' + rest
    def do_QUIT(self, rest):
        return 'Bye'

SMTP().lookupMethod('HELO')('foo.bar.com') # =&gt; 'Howdy foo.bar.com'
SMTP().lookupMethod('QUIT')('') # =&gt; 'Bye'
</code></pre>
<p>You can use it any time you need to dispatch on a token and execute extended piece of code. In a state machine you would have <code>state_</code> methods, and dispatch on <code>self.state</code>. This switch can be cleanly extended by inheriting from base class and defining your own <code>do_</code> methods. Often times you won't even have <code>do_</code> methods in the base class.</p>
<p><em>Edit: how exactly is that used</em></p>
<p>In case of SMTP you will receive <code>HELO</code> from the wire. The relevant code (from <code>twisted/mail/smtp.py</code>, modified for our case) looks like this</p>
<pre><code>class SMTP:
    # ...

    def do_UNKNOWN(self, rest):
        raise NotImplementedError, 'received unknown command'

    def state_COMMAND(self, line):
        line = line.strip()
        parts = line.split(None, 1)
        if parts:
            method = self.lookupMethod(parts[0]) or self.do_UNKNOWN
            if len(parts) == 2:
                return method(parts[1])
            else:
                return method('')
        else:
            raise SyntaxError, 'bad syntax'

SMTP().state_COMMAND('   HELO   foo.bar.com  ') # =&gt; Howdy foo.bar.com
</code></pre>
<p>You'll receive <code>'  HELO   foo.bar.com '</code> (or you might get <code>'QUIT'</code> or <code>'RCPT TO: foo'</code>). This is tokenized into <code>parts</code> as <code>['HELO', 'foo.bar.com']</code>. The actual method lookup name is taken from <code>parts[0]</code>.</p>
<p>(The original method is also called <code>state_COMMAND</code>, because it uses the same pattern to implement a state machine, i.e. <code>getattr(self, 'state_' + self.mode)</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>My favorite one is a really nice <a href="http://code.activestate.com/recipes/410692/" rel="nofollow noreferrer">recipe</a>. You'll really like it. It's the closest one I've seen to actual switch case statements, especially in features.</p>
<pre class="lang-py prettyprint-override"><code>class switch(object):
    def __init__(self, value):
        self.value = value
        self.fall = False

    def __iter__(self):
        """Return the match method once, then stop"""
        yield self.match
        raise StopIteration

    def match(self, *args):
        """Indicate whether or not to enter a case suite"""
        if self.fall or not args:
            return True
        elif self.value in args: # changed for v1.5, see below
            self.fall = True
            return True
        else:
            return False
</code></pre>
<p>Here's an example:</p>
<pre class="lang-py prettyprint-override"><code># The following example is pretty much the exact use-case of a dictionary,
# but is included for its simplicity. Note that you can include statements
# in each suite.
v = 'ten'
for case in switch(v):
    if case('one'):
        print 1
        break
    if case('two'):
        print 2
        break
    if case('ten'):
        print 10
        break
    if case('eleven'):
        print 11
        break
    if case(): # default, could also just omit condition or 'if True'
        print "something else!"
        # No need to break here, it'll stop anyway

# break is used here to look as much like the real thing as possible, but
# elif is generally just as good and more concise.

# Empty suites are considered syntax errors, so intentional fall-throughs
# should contain 'pass'
c = 'z'
for case in switch(c):
    if case('a'): pass # only necessary if the rest of the suite is empty
    if case('b'): pass
    # ...
    if case('y'): pass
    if case('z'):
        print "c is lowercase!"
        break
    if case('A'): pass
    # ...
    if case('Z'):
        print "c is uppercase!"
        break
    if case(): # default
        print "I dunno what c was!"

# As suggested by Pierre Quentel, you can even expand upon the
# functionality of the classic 'case' statement by matching multiple
# cases in a single shot. This greatly benefits operations such as the
# uppercase/lowercase example above:
import string
c = 'A'
for case in switch(c):
    if case(*string.lowercase): # note the * for unpacking as arguments
        print "c is lowercase!"
        break
    if case(*string.uppercase):
        print "c is uppercase!"
        break
    if case('!', '?', '.'): # normal argument passing style also applies
        print "c is a sentence terminator!"
        break
    if case(): # default
        print "I dunno what c was!"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-py prettyprint-override"><code>class Switch:
    def __init__(self, value):
        self.value = value

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        return False # Allows a traceback to occur

    def __call__(self, *values):
        return self.value in values


from datetime import datetime

with Switch(datetime.today().weekday()) as case:
    if case(0):
        # Basic usage of switch
        print("I hate mondays so much.")
        # Note there is no break needed here
    elif case(1,2):
        # This switch also supports multiple conditions (in one line)
        print("When is the weekend going to be here?")
    elif case(3,4):
        print("The weekend is near.")
    else:
        # Default would occur here
        print("Let's go have fun!") # Didn't use case for example purposes
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's say you don't want to just return a value, but want to use methods that change something on an object. Using the approach stated here would be:</p>
<pre><code>result = {
  'a': obj.increment(x),
  'b': obj.decrement(x)
}.get(value, obj.default(x))
</code></pre>
<p>What happens here is that python evaluates all methods in the dictionary.
So even if your value is 'a', the object will get incremented <strong>and</strong> decremented by x.</p>
<p>Solution:</p>
<pre><code>func, args = {
  'a' : (obj.increment, (x,)),
  'b' : (obj.decrement, (x,)),
}.get(value, (obj.default, (x,)))

result = func(*args)
</code></pre>
<p>So you get a list containing a function and its arguments. This way, only the function pointer and the argument list get returned, <em>not</em> evaluated. 'result' then evaluates the returned function call.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm just going to drop my two cents in here.  The reason there isn't a case/switch statement in Python is because Python follows the principle of 'Theres only one right way to do something'.   So obviously you could come up with various ways of recreating switch/case functionality, but the Pythonic way of accomplishing this is the if/elif construct. ie</p>
<pre><code>if something:
    return "first thing"
elif somethingelse:
    return "second thing"
elif yetanotherthing:
    return "third thing"
else:
    return "default thing"
</code></pre>
<p>I just felt PEP 8 deserved a nod here.  One of the beautiful things about Python is its simplicity and elegance.  That is largely derived from principles laid our in PEP 8, including "There's only one right way to do something"</p>
</div>
<div class="post-text" itemprop="text">
<p>expanding on the "dict as switch" idea. if you want to use a default value for your switch:</p>
<pre><code>def f(x):
    try:
        return {
            'a': 1,
            'b': 2,
        }[x]
    except KeyError:
        return 'default'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have a complicated case block you can consider using a function dictionary lookup table... </p>
<p>If you haven't done this before its a good idea to step into your debugger and view exactly how the dictionary looks up each function.  </p>
<p>NOTE: Do <em>not</em> use "()" inside the case/dictionary lookup or it will call each of your functions as the dictionary / case block is created.  Remember this because you only want to call each function once using a hash style lookup.</p>
<pre><code>def first_case():
    print "first"

def second_case():
    print "second"

def third_case():
    print "third"

mycase = {
'first': first_case, #do not use ()
'second': second_case, #do not use ()
'third': third_case #do not use ()
}
myfunc = mycase['first']
myfunc()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're searching extra-statement, as "switch", I built a python module that extends Python. It's called <a href="https://web.archive.org/web/20111103124355/http://elp.chronocv.fr/articles.php?lng=en&amp;pg=19" rel="nofollow noreferrer">ESPY</a> as "Enhanced Structure for Python" and it's available for both Python 2.x and Python 3.x.</p>
<p>For example, in this case, a switch statement could be performed by the following code:</p>
<pre><code>macro switch(arg1):
    while True:
        cont=False
        val=%arg1%
        socket case(arg2):
            if val==%arg2% or cont:
                cont=True
                socket
        socket else:
            socket
        break
</code></pre>
<p>that can be used like this:</p>
<pre><code>a=3
switch(a):
    case(0):
        print("Zero")
    case(1):
        print("Smaller than 2"):
        break
    else:
        print ("greater than 1")
</code></pre>
<p>so espy translate it in Python as:</p>
<pre><code>a=3
while True:
    cont=False
    if a==0 or cont:
        cont=True
        print ("Zero")
    if a==1 or cont:
        cont=True
        print ("Smaller than 2")
        break
    print ("greater than 1")
    break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I didn't find the simple answer I was looking for anywhere on Google search. But I figured it out anyway. It's really quite simple. Decided to post it, and maybe prevent a few less scratches on someone else's head. The key is simply "in" and tuples. Here is the switch statement behavior with fall-through, including RANDOM fall-through.</p>
<pre><code>l = ['Dog', 'Cat', 'Bird', 'Bigfoot',
     'Dragonfly', 'Snake', 'Bat', 'Loch Ness Monster']

for x in l:
    if x in ('Dog', 'Cat'):
        x += " has four legs"
    elif x in ('Bat', 'Bird', 'Dragonfly'):
        x += " has wings."
    elif x in ('Snake',):
        x += " has a forked tongue."
    else:
        x += " is a big mystery by default."
    print(x)

print()

for x in range(10):
    if x in (0, 1):
        x = "Values 0 and 1 caught here."
    elif x in (2,):
        x = "Value 2 caught here."
    elif x in (3, 7, 8):
        x = "Values 3, 7, 8 caught here."
    elif x in (4, 6):
        x = "Values 4 and 6 caught here"
    else:
        x = "Values 5 and 9 caught in default."
    print(x)
</code></pre>
<p>Provides:</p>
<pre><code>Dog has four legs
Cat has four legs
Bird has wings.
Bigfoot is a big mystery by default.
Dragonfly has wings.
Snake has a forked tongue.
Bat has wings.
Loch Ness Monster is a big mystery by default.

Values 0 and 1 caught here.
Values 0 and 1 caught here.
Value 2 caught here.
Values 3, 7, 8 caught here.
Values 4 and 6 caught here
Values 5 and 9 caught in default.
Values 4 and 6 caught here
Values 3, 7, 8 caught here.
Values 3, 7, 8 caught here.
Values 5 and 9 caught in default.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found that a common switch structure:</p>
<pre><code>switch ...parameter...
case p1: v1; break;
case p2: v2; break;
default: v3;
</code></pre>
<p>can be expressed in Python as follows:</p>
<pre><code>(lambda x: v1 if p1(x) else v2 if p2(x) else v3)
</code></pre>
<p>or formatted in a clearer way:</p>
<pre><code>(lambda x:
     v1 if p1(x) else
     v2 if p2(x) else
     v3)
</code></pre>
<p>Instead of being a statement, the python version is an expression, which evaluates to a value.</p>
</div>
<div class="post-text" itemprop="text">
<p>The solutions I use: </p>
<p>A combination of 2 of the solutions posted here, which is relatively easy to read and supports defaults.</p>
<pre><code>result = {
  'a': lambda x: x * 5,
  'b': lambda x: x + 7,
  'c': lambda x: x - 2
}.get(whatToUse, lambda x: x - 22)(value)
</code></pre>
<p>where</p>
<pre><code>.get('c', lambda x: x - 22)(23)
</code></pre>
<p>looks up <code>"lambda x: x - 2"</code> in the dict and uses it with <code>x=23</code> </p>
<pre><code>.get('xxx', lambda x: x - 22)(44)
</code></pre>
<p>doesn't find it in the dict and uses the default <code>"lambda x: x - 22"</code> with <code>x=44</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code># simple case alternative

some_value = 5.0

# this while loop block simulates a case block

# case
while True:

    # case 1
    if some_value &gt; 5:
        print ('Greater than five')
        break

    # case 2
    if some_value == 5:
        print ('Equal to five')
        break

    # else case 3
    print ( 'Must be less than 5')
    break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Most of the answers here are pretty old, and especially the accepted ones, so it seems worth updating.</p>
<p>First, the official <a href="https://docs.python.org/3/faq/design.html#why-isn-t-there-a-switch-or-case-statement-in-python" rel="noreferrer">Python FAQ</a> covers this, and recommends the <code>elif</code> chain for simple cases and the <code>dict</code> for larger or more complex cases. It also suggests a set of <code>visit_</code> methods (a style used by many server frameworks) for some cases:</p>
<pre><code>def dispatch(self, value):
    method_name = 'visit_' + str(value)
    method = getattr(self, method_name)
    method()
</code></pre>
<p>The FAQ also mentions <a href="https://www.python.org/dev/peps/pep-0275/" rel="noreferrer">PEP 275</a>, which was written to get an official once-and-for-all decision on adding C-style switch statements. But that PEP was actually deferred to Python 3, and it was only officially rejected as a separate proposal, <a href="https://www.python.org/dev/peps/pep-3103/" rel="noreferrer">PEP 3103</a>. The answer was, of course, no—but the two PEPs have links to additional information if you're interested in the reasons or the history.</p>
<hr/>
<p>One thing that came up multiple times (and can be seen in PEP 275, even though it was cut out as an actual recommendation) is that if you're really bothered by having 8 lines of code to handle 4 cases, vs. the 6 lines you'd have in C or Bash, you can always write this:</p>
<pre><code>if x == 1: print('first')
elif x == 2: print('second')
elif x == 3: print('third')
else: print('did not place')
</code></pre>
<p>This isn't exactly encouraged by PEP 8, but it's readable and not too unidiomatic.</p>
<hr/>
<p>Over the more than a decade since PEP 3103 was rejected, the issue of C-style case statements, or even the slightly more powerful version in Go, has been considered dead; whenever anyone brings it up on python-ideas or -dev, they're referred to the old decision.</p>
<p>However, the idea of full ML-style pattern matching arises every few years, especially since languages like Swift and Rust have adopted it. The problem is that it's hard to get much use out of pattern matching without algebraic data types. While Guido has been sympathetic to the idea, nobody's come up with a proposal that fits into Python very well. (You can read <a href="http://stupidpythonideas.blogspot.com/2014/08/a-pattern-matching-case-statement-for.html" rel="noreferrer">my 2014 strawman</a> for an example.) This could change with <code>dataclass</code> in 3.7 and some sporadic proposals for a more powerful <code>enum</code> to handle sum types, or with various proposals for different kinds of statement-local bindings (like <a href="https://www.python.org/dev/peps/pep-3150/" rel="noreferrer">PEP 3150</a>, or the set of proposals currently being discussed on -ideas). But so far, it hasn't.</p>
<p>There are also occasionally proposals for Perl 6-style matching, which is basically a mishmash of everything from <code>elif</code> to regex to single-dispatch type-switching.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def f(x):
    dictionary = {'a':1, 'b':2, 'c':3}
    return dictionary.get(x,'Not Found') 
##Returns the value for the letter x;returns 'Not Found' if x isn't a key in the dictionary
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I liked <a href="https://stackoverflow.com/a/60215/1766716">Mark Bies's answer</a></p>
<p>Since the <code>x</code> variable must used twice, I modified the lambda functions to parameterless.</p>
<p>I have to run with  <code>results[value](value)</code></p>
<pre><code>In [2]: result = {
    ...:   'a': lambda x: 'A',
    ...:   'b': lambda x: 'B',
    ...:   'c': lambda x: 'C'
    ...: }
    ...: result['a']('a')
    ...: 
Out[2]: 'A'

In [3]: result = {
    ...:   'a': lambda : 'A',
    ...:   'b': lambda : 'B',
    ...:   'c': lambda : 'C',
    ...:   None: lambda : 'Nothing else matters'

    ...: }
    ...: result['a']()
    ...: 
Out[3]: 'A'
</code></pre>
<p><strong>Edit:</strong> I noticed that I can use <code>None</code> type with with dictionaries. So this would emulate <code>switch ; case else</code></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def f(x):
     return 1 if x == 'a' else\
            2 if x in 'bcd' else\
            0 #default
</code></pre>
<p>Short and easy to read, has a default value and supports expressions in both conditions and return values.</p>
<p>However, it is less efficient than the solution with a dictionary. For example, Python has to scan through all the conditions before returning the default value.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the best way is to <strong>use the python language idioms to keep your code testable</strong>. As showed in previous answers, I use dictionaries to <strong>take advantage of python structures and language</strong> and keep the "case" code isolated in different methods. Below there is a class, but you can use directly a module, globals and functions. The class has methods that <strong>can be tested with isolation</strong>.
Dependending to your needs, you can play with static methods and attributes too.</p>
<pre><code>class ChoiceManager:

    def __init__(self):
        self.__choice_table = \
        {
            "CHOICE1" : self.my_func1,
            "CHOICE2" : self.my_func2,
        }

    def my_func1(self, data):
        pass

    def my_func2(self, data):
        pass

    def process(self, case, data):
        return self.__choice_table[case](data)

ChoiceManager().process("CHOICE1", my_data)
</code></pre>
<p>It is possible to <strong>take advantage of this method using also classes as keys</strong> of "__choice_table". In this way you can avoid <em>isinstance abuse</em> and keep all clean and testable.</p>
<p>Supposing you have to process a lot of messages or packets from the net or your MQ. Every packet has its own structure and its management code (in a generic way).
With the above code it is possible to do something like this:</p>
<pre><code>class PacketManager:

    def __init__(self):
        self.__choice_table = \
        {
            ControlMessage : self.my_func1,
            DiagnosticMessage : self.my_func2,
        }

    def my_func1(self, data):
        # process the control message here
        pass

    def my_func2(self, data):
        # process the diagnostic message here
        pass

    def process(self, pkt):
        return self.__choice_table[pkt.__class__](pkt)

pkt = GetMyPacketFromNet()
PacketManager().process(pkt)


# isolated test or isolated usage example
def test_control_packet():
    p = ControlMessage()
    PacketManager().my_func1(p)
</code></pre>
<p>So <strong>complexity is not spread in the code flow but it is rendered in code structure</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I made this small and clean solution </p>
<pre><code>result = {
    'case1':     foo1, 
    'case2':     foo2,
    'case3':     foo3,
    'default':   default,
}.get(option)()
</code></pre>
<p>where foo1(), foo2(), foo3() and default() are functions</p>
</div>
<div class="post-text" itemprop="text">
<p>you can use a dispatched dict:</p>
<pre><code>#!/usr/bin/env python


def case1():
    print("This is case 1")

def case2():
    print("This is case 2")

def case3():
    print("This is case 3")


token_dict = {
    "case1" : case1,
    "case2" : case2,
    "case3" : case3,
}


def main():
    cases = ("case1", "case3", "case2", "case1")
    for case in cases:
        token_dict[case]()


if __name__ == '__main__':
    main()
</code></pre>
<p>Output:</p>
<pre><code>This is case 1
This is case 3
This is case 2
This is case 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Defining:</p>
<pre><code>def switch1(value, options):
  if value in options:
    options[value]()
</code></pre>
<p>allows you to use a fairly straightforward syntax, with the cases bundled into a map:</p>
<pre><code>def sample1(x):
  local = 'betty'
  switch1(x, {
    'a': lambda: print("hello"),
    'b': lambda: (
      print("goodbye," + local),
      print("!")),
    })
</code></pre>
<p>I kept trying to redefine switch in a way that would let me get rid of the "lambda:", but gave up.  Tweaking the definition:</p>
<pre><code>def switch(value, *maps):
  options = {}
  for m in maps:
    options.update(m)
  if value in options:
    options[value]()
  elif None in options:
    options[None]()
</code></pre>
<p>Allowed me to map multiple cases to the same code, and to supply a default option:</p>
<pre><code>def sample(x):
  switch(x, {
    _: lambda: print("other") 
    for _ in 'cdef'
    }, {
    'a': lambda: print("hello"),
    'b': lambda: (
      print("goodbye,"),
      print("!")),
    None: lambda: print("I dunno")
    })
</code></pre>
<p>Each replicated case has to be in its own dictionary; switch() consolidates the dictionaries before looking up the value.  It's still uglier than I'd like, but it has the basic efficiency of using a hashed lookup on the expression, rather than a loop through all the keys.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't worry losing syntax highlight inside the case suites, you can do the following:</p>
<pre><code>exec {
    1: """
print ('one')
""", 
    2: """
print ('two')
""", 
    3: """
print ('three')
""",
}.get(value, """
print ('None')
""")
</code></pre>
<p>Where <code>value</code> is the value. In C, this would be:</p>
<pre><code>switch (value) {
    case 1:
        printf("one");
        break;
    case 2:
        printf("two");
        break;
    case 3:
        printf("three");
        break;
    default:
        printf("None");
        break;
}
</code></pre>
<p>We can also create a helper function to do this:</p>
<pre><code>def switch(value, cases, default):
    exec cases.get(value, default)
</code></pre>
<p>So we can use it like this for the example with one, two and three:</p>
<pre><code>switch(value, {
    1: """
print ('one')
    """, 
    2: """
print ('two')
    """, 
    3: """
print ('three')
    """,
}, """
print ('None')
""")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Expanding on <a href="https://stackoverflow.com/a/60211/3106539">Greg Hewgill's answer</a> - We can encapsulate the dictionary-solution using a decorator:</p>
<pre><code>def case(callable):
    """switch-case decorator"""
    class case_class(object):
        def __init__(self, *args, **kwargs):
            self.args = args
            self.kwargs = kwargs

        def do_call(self):
            return callable(*self.args, **self.kwargs)

return case_class

def switch(key, cases, default=None):
    """switch-statement"""
    ret = None
    try:
        ret = case[key].do_call()
    except KeyError:
        if default:
            ret = default.do_call()
    finally:
        return ret
</code></pre>
<p>This can then be used with the <code>@case</code>-decorator</p>
<pre><code>@case
def case_1(arg1):
    print 'case_1: ', arg1

@case
def case_2(arg1, arg2):
    print 'case_2'
    return arg1, arg2

@case
def default_case(arg1, arg2, arg3):
    print 'default_case: ', arg1, arg2, arg3

ret = switch(somearg, {
    1: case_1('somestring'),
    2: case_2(13, 42)
}, default_case(123, 'astring', 3.14))

print ret
</code></pre>
<p>The good news are that this has already been done in <a href="https://pypi.python.org/pypi/NeoPySwitch/0.2.0" rel="nofollow noreferrer">NeoPySwitch</a>-module. Simply install using pip:</p>
<pre><code>pip install NeoPySwitch
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I was quite confused after reading the answer, but this cleared it all up:</p>
<pre><code>def numbers_to_strings(argument):
    switcher = {
        0: "zero",
        1: "one",
        2: "two",
    }
    return switcher.get(argument, "nothing")
</code></pre>
<p>This code is analogous to:</p>
<pre><code>function(argument){
    switch(argument) {
        case 0:
            return "zero";
        case 1:
            return "one";
        case 2:
            return "two";
        default:
            return "nothing";
    }
}
</code></pre>
<p>Check the <a href="https://www.pydanny.com/why-doesnt-python-have-switch-case.html" rel="nofollow noreferrer">Source</a> for more about dictionary mapping to functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>A solution I tend to use which also makes use of dictionaries is : </p>
<pre><code>def decision_time( key, *args, **kwargs):
    def action1()
        """This function is a closure - and has access to all the arguments"""
        pass
    def action2()
        """This function is a closure - and has access to all the arguments"""
        pass
    def action3()
        """This function is a closure - and has access to all the arguments"""
        pass

   return {1:action1, 2:action2, 3:action3}.get(key,default)()
</code></pre>
<p>This has the advantage that it doesn't try to evaluate the functions every time, and you just have to ensure that the outer function gets all the information that the inner functions need.</p>
</div>
<span class="comment-copy">Related PEP, authored by Guido himself: <a href="http://www.python.org/dev/peps/pep-3103/" rel="nofollow noreferrer">PEP 3103</a></span>
<span class="comment-copy">@chb In that PEP, Guido doesn't mention that if/elif chains are also a classic source of error.  It's a very fragile construct.</span>
<span class="comment-copy">Missing from all solutions here is detection of <b>duplicate case values</b>.  As a fail-fast principle, this may be a more important loss than performance or the fallthrough feature.</span>
<span class="comment-copy">All provided solutions are really ugly... switch case is so clean when reading. Cannot understand why it is not implemented in Python.</span>
<span class="comment-copy"><code>switch</code> is actually more "versatile" than something returning different fixed values based on the value of an input index. It allows for different pieces of code to be executed. It actually does not even need to return a value. I wonder if some of the answers here are good replacements for a general <code>switch</code> statement, or only for the case of returning values with no possibility of executing general pieces of code.</span>
<span class="comment-copy">What happens if x is not found?</span>
<span class="comment-copy">@nick: you can use defaultdict</span>
<span class="comment-copy">I'd recommend putting the dict outside of the function if performance is an issue, so it doesn't re-build the dict on every function call</span>
<span class="comment-copy">@EliBendersky, Using the <code>get</code> method would probably be more normal than using a <code>collections.defaultdict</code> in this case.</span>
<span class="comment-copy">@Nick, An exception is thrown—do <code>}.get(x, default)</code> instead if there should be a default. (Note: this is a lot nicer than what happens if you leave the default off a switch statement!)</span>
<span class="comment-copy">What if 'a' and 'b' match 1, and 'c' and 'd' match 2?</span>
<span class="comment-copy">@JM: Well, obviously dictionary lookups don't support fall-throughs. You could do a double dictionary lookup. I.e. 'a' &amp; 'b' point to answer1 and 'c' and 'd' point to answer2, which are contained in a second dictionary.</span>
<span class="comment-copy">this is better to pass a default value</span>
<span class="comment-copy">There is a problems with this approach, first each time you call f you going to create the dict again second if you have more complex value you can get an exceptions ex. if x is a tuple and we are want to do something like this x = ('a') def f(x): return { 'a': x[0], 'b': x[1] }.get(x[0], 9) This will raise IndexError</span>
<span class="comment-copy">@Idan: The question was to replicate switch. I'm sure I could break this code too if I tried putting in odd values. Yes, it will recreate, but it is simple to fix.</span>
<span class="comment-copy">great method, combined with get() to handle default is my best choice too</span>
<span class="comment-copy">it maybe isn't a good idea to use lambda in this case because lambda is actually called each time the dictionary is built.</span>
<span class="comment-copy">Sadly this is the closest people are going to get. Methods which use <code>.get()</code> (like the current highest answers) will need to eagerly evaluate all possibilities before dispatching, and therefore not only are (not just very but) extremely inefficient and also cannot have side-effects; this answer gets around that issue, but is more verbose. I would just use if/elif/else, and even those take just as long to write as 'case'.</span>
<span class="comment-copy">wouldn't this evaluate all the functions/lambdas every time in all cases, even if it is only returning one of the results?</span>
<span class="comment-copy">@slf No, when the control flow reaches that piece of code, it will build 3 functions (through the use of the 3 lambdas) and then build a dictionary with those 3 functions as values, but they remain uncalled (<i>evaluate</i> is slightly ambiguous in that context) at first. Then the dictionary gets indexed via <code>[value]</code>, which will return only one of the 3 functions (assuming <code>value</code> is one of the 3 keys). The function hasn't been called at that point, yet. Then <code>(x)</code> calls the just returned function with <code>x</code> as argument (and the result goes to <code>result</code>). The other 2 functions won't be called.</span>
<span class="comment-copy">i'd really prefer this, it uses a standart language construct and doesn't throw a KeyError if no matching case is found</span>
<span class="comment-copy">I thought about the dictionary / <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><code>get</code></a> way, but the standard way is simply more readable.</span>
<span class="comment-copy">Doesn't exactly operate like a switch statement but very close. In my opinion closest thing</span>
<span class="comment-copy">This is the cleanest solution. It's most common that each <code>switch</code> has a <code>break</code> and the most common use for fall-through that I see is to match multiple elements, as in <code>if x in 'bc':</code>.</span>
<span class="comment-copy">Nice, the "Fall-through by not using elif " is a bit confusing, though. What about this: forget about "fall through" and just accept it as two <code>if/elif/else</code>'s?</span>
<span class="comment-copy">I find this to be a more robust answer than the accepted.</span>
<span class="comment-copy">@some user: C requires that the return value be the same type for all cases. Python does not. I wanted to highlight this flexibility of Python just in case someone had a situation that warranted such usage.</span>
<span class="comment-copy">@some user: Personally, I find {}.get(,) readable. For extra readability for Python beginners you may want to use <code>default = -1; result = choices.get(key, default)</code>.</span>
<span class="comment-copy">compare with 1 line of c++ <code>result=key=='a'?1:key==b?2:-1</code></span>
<span class="comment-copy">@Jasen one can argue that you can do it in one line of Python as well: <code>result = 1 if key == 'a' else (2 if key == 'b' else 'default')</code>. but is the one liner readable?</span>
<span class="comment-copy">This is not threat safe. If several switches are hit at the same time all switches take the value of the last switch.</span>
<span class="comment-copy">While @francescortiz likely means thread safe, it's also not threat safe. It threatens the values of the variables!</span>
<span class="comment-copy">The thread safety problem could likely be worked around by using <a href="https://docs.python.org/2/library/threading.html#threading.local" rel="nofollow noreferrer">thread-local storage</a>. Or it could be avoided altogether by returning an instance and using that instance for the case comparisons.</span>
<span class="comment-copy">@blubberdiblub But then isn't it just more efficient to use a standard <code>if</code> statement?</span>
<span class="comment-copy">This is also not safe if used in multiple functions.  In the example given, if the <code>case(2)</code> block called another function that uses switch(), then when doing <code>case(2, 3, 5, 7)</code> etc to look for the next case to execute, it will use the switch value set by the other function not the one set by the current switch statement.</span>
<span class="comment-copy">I don't see the benefit from this pattern over just calling the methods directly: SMTP().do_HELO('foo.bar.com') OK, there can be common code in the lookupMethod, but since that also can be overwritten by the subclass I don't see what you gain from the indirection.</span>
<span class="comment-copy">You wouldn't know what method to call in advance, that is to say 'HELO' comes from a variable. i've added usage example to the original post</span>
<span class="comment-copy">May I suggest simply:  eval('SMTP().do_' + command)('foo.bar.com')</span>
<span class="comment-copy">Also, why instantiate a new SMTP object for each method call? That's what global functions are for.</span>
<span class="comment-copy">eval? seriously? and instead of instantiating one method per call, we can very well instantiate once and use it in all calls provided it has no internal state.</span>
<span class="comment-copy">I would substitute <code>for case in switch()</code> with <code>with switch() as case</code>, makes more sense, since it need s to run only once.</span>
<span class="comment-copy">@Skirmantas: Note that <code>with</code> doesn’t allow for <code>break</code> though, so the fallthrough option is taken away.</span>
<span class="comment-copy">Apologies for not putting more effort in to determine this myself: a similar answer above is not thread safe. Is this?</span>
<span class="comment-copy">@DavidWiniecki The code components missing from the above (and possibly copyright by activestate) appear to be thread safe.</span>
<span class="comment-copy">would another version of this be something like <code>if c in set(range(0,9)): print "digit" elif c in set(map(chr, range(ord('a'), ord('z')))): print "lowercase"</code>?</span>
<span class="comment-copy">Using context managers is a good creative solution. I'd recommend adding a bit of explanation and maybe a link to some information on Context Managers to give this post some, well, context ;)</span>
<span class="comment-copy">I don't like if/elif chains much but this is both the most creative and the most practical of all the solutions I've seen using Python's existing syntax.</span>
<span class="comment-copy">This is really nice.  One suggested improvement is to add a (public) <code>value</code> property to the Switch class so that you can reference the <code>case.value</code> within the statement.</span>
<span class="comment-copy">So why does Python have for loops and while loops? Everything you can do with a for loop you can implement with a while loop.</span>
<span class="comment-copy">True. Switch/case are too often abused by beginning programmers. What they really want is the <i>strategy pattern</i>.</span>
<span class="comment-copy">Sounds like Python wishes it was Clojure</span>
<span class="comment-copy">@T.W.R.Cole I don't think so, Python was doing it first. Python has been around since 1990 and Clojure since 2007.</span>
<span class="comment-copy">There's only one right way to do something. Python 2.7 or Python 3? Lol.</span>
<span class="comment-copy">I think it's clearer to use .get() on the dict with the default specified.  I prefer to leave Exceptions for exceptional circumstances, and it cuts three lines of code and a level of indentation without being obscure.</span>
<span class="comment-copy">This <b>is</b> an exceptional circumstance. It may or may not be a <i>rare</i> circumstance depending on useful, but it's definitely an exception (fall back on <code>'default'</code>) from the rule (get something from this dict). By design, Python programs use exceptions at the drop of a hat. That being said, using <code>get</code> could potentially make the code a bit nicer.</span>
<span class="comment-copy">I like your solution. But, what if I just need to pass some variables or objects?</span>
<span class="comment-copy">Very cool, but what's the point of the <code>while True:</code> at the top of the generated Python code? It'll inevitably hit the <code>break</code> at the bottom of the generated Python code, so it seems to me that both the <code>while True:</code> and <code>break</code> could be removed. Further, is ESPY smart enough to change the name of <code>cont</code> if the user uses that same name in their own code? In any event, I want to use vanilla Python so I won't use this, but it's cool none-the-less. +1 for sheer coolness.</span>
<span class="comment-copy">@ArtOfWarfare The reason for the <code>while True:</code> and <code>break</code>s is to allow but not require fall-through.</span>
<span class="comment-copy">Is this module still available?</span>
<span class="comment-copy">Where exactly is fallthrough here?</span>
<span class="comment-copy">switch(n){ case</span>
<span class="comment-copy">Oops!  There is fall through there, but I'm not contributing to Stack Overflow anymore.  Don't like THEM at all.  I like the contributions by others, but just not Stackoverflow.  If you're using fall through for FUNCTIONALITY then you want to CATCH certain conditions in all in one case statement in a switch (a catch all), until you reach a break statement in a switch.</span>
<span class="comment-copy">Here both the values "Dog" and "Cat" FALL THROUGH and are handled by the SAME functionality, which is they are defined as having "four legs."  It's an ABSTRACT equivalent to fall through and different values handled by the SAME case statement where a break occurs.</span>
<span class="comment-copy">@JDGraham I think Jonas meant another aspect of fallthrough, which happens when programmer occasionally forget to write <code>break</code> in the end of the code for a <code>case</code>. But I think we don't need <i>such</i> "fallthrough" :)</span>
<span class="comment-copy">Also instead of ...parameter... and p1(x) how about <code>parameter</code> and <code>p1==parameter</code></span>
<span class="comment-copy">@BobStein-VisiBone hi, here is an example that runs in my python session: <code>f = lambda x: 'a' if x==0 else 'b' if x==1 else 'c'</code>. When I later called <code>f(2)</code>, I got <code>'c'</code>; <code>f(1)</code>, <code>'b'</code>; and <code>f(0)</code>, <code>'a'</code>. As for p1(x), it denotes a predicate; as long as it returns <code>True</code> or <code>False</code>, no matter it is a function call or a expression, it's fine.</span>
<span class="comment-copy">@BobStein-VisiBone Yes, you are right! Thank :) For the multi-line expression to work, parentheses should be placed, either as in your suggestion, or as in my modified example.</span>
<span class="comment-copy">Excellent.  Now I'll <a href="http://meta.stackexchange.com/q/248179/209317">delete all my comments</a> about the parens.</span>
<span class="comment-copy">hmmm, is it duplicity answer of <a href="http://stackoverflow.com/a/6606540/2901002">stackoverflow.com/a/6606540/2901002</a>?</span>
<span class="comment-copy">Consider including a short description of your code and how it solves the posted question</span>
<span class="comment-copy">Okay, I've added a comment for that now.</span>
<span class="comment-copy">Doesn't the None case emulate simply <code>result[None]()</code> ?</span>
<span class="comment-copy">Yes, exactly. I mean <code>result = {'a': 100, None:5000}; result[None]</code></span>
<span class="comment-copy">Just checking that no one is thinking <code>None:</code> behaves like <code>default:</code>.</span>
<span class="comment-copy">Can you show an example of this in use? I've not had enough coffee...</span>
<span class="comment-copy">Really ugly... switch case is so clean when reading. Cannot understand why it is not implemented in Python.</span>
<span class="comment-copy">@AndyClifton: I'm sorry... an example? Think of every time you need to have multiple decision branching code and you can apply this method.</span>
<span class="comment-copy">@jmcollin92: the switch statement is confortable, I agree. However the programmer tends to write very long statements and code which is not reusable. The way I described is cleaner to test and more reusable, IMHO.</span>
<span class="comment-copy">@AndyClifton: I'm sorry, I'm late but I posted some example case.</span>
<span class="comment-copy">Wouldn't that execute all of the functions?  A proper <code>switch</code> replacement would only run the option that was needed...</span>
<span class="comment-copy">Yes, for example if your variable option=="case2" your result=foo2()</span>
<span class="comment-copy">and so and so forth.</span>
<span class="comment-copy">omit the () inside the dictionary. use <code>get(option)()</code>. problem solved.</span>
<span class="comment-copy">Excellent the use of () is a grate solution, I made a gist to test it <a href="https://gist.github.com/aquintanar/01e9920d8341c5c6252d507669758fe5" rel="nofollow noreferrer">gist.github.com/aquintanar/01e9920d8341c5c6252d507669758fe5</a></span>
