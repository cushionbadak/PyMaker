<div class="post-text" itemprop="text">
<p>I'm currently using the following set up to manage a variable set of methods that could be applied to data, but when I try and mock the method to make sure it is returning any list (I have already set up tests of the methods themselves), I end up with KeyErrors. </p>
<p>Is there something I'm missing here in my understanding of how mocking works in Python? I had figured if I mock a method, it shouldn't matter if I pass in an empty dictionary or not; that it should just return True at that point. </p>
<p>File 1</p>
<pre><code>def method_1(data):
    return data['header_1'] &gt; 1

def method_2(data):
    return data['header_2'] &gt; 1

def method_3(data):
    return data['header_3'] &gt; 1
</code></pre>
<p>File 2</p>
<pre><code>from module import file1 as f1

method_dict = {
    'method_1' : f1.method1,
    'method_2' : f1.method2,
    'method_3' : f1.method3
}

tasks_1 = ['method_1']
tasks_2 = ['method_2', 'method_3']

def function_A(data, tasks):
    results = [method_dict[task](data) for task in tasks]
    index = [i for i, result in enumerate(results) if result is True]
    return [tasks[i] for i in index] 
</code></pre>
<p>Test File</p>
<pre><code>from module import file2 as f2
from unittest import TestCase
from unittest.mock import patch

class TestFile2(TestCase):
    @patch('module.file1.method_1')
    def test_file_2(self, mock_method_1):
        mock_method_1.return_value = True
        results = f2.function_A({}, 'tasks_1')
        expected = ['method_1']
        self.assertEqual(results, expected)
. . .
</code></pre>
<p>Error</p>
<pre><code>test/test_determine_failure_modes.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
module/file2.py:82: in function_A
    results = [task[task](data) for task in tasks]
module/file2.py:82: in &lt;listcomp&gt;
    results = [tasks[task](data) for task in tasks]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {}

    def method_1(data):
&gt;       return data['header_1'] &gt; 1
E       KeyError: 'header_1'

module/file1.py:2: KeyError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your patch should read <code>@patch('module.file2.f1.method_1')</code></p>
<p>I'll walk you through why:</p>
<p><code>test_determine_failure_modes.py</code> imports <code>file1 as f1</code>. Then <code>file1</code> is read and it defines <code>method1</code> in it's locals. That becomes available on the symbol <code>f1</code>.</p>
<p>So the symbol tables look like:</p>
<pre><code>file1: {'method1': &lt;function&gt;, &lt;METHOD_1&gt;, ...}
f1: {'method1': &lt;function&gt;, &lt;METHOD_1&gt;, ...}
</code></pre>
<p>Then you patch <code>file1.method1</code> and you get this symbol table</p>
<pre><code>file1: {'method1': &lt;function&gt;, MOCK, ...}
f1: {'method1': &lt;function&gt;, &lt;METHOD_1&gt;, ...}
</code></pre>
<p>Then you call <code>f1.method1</code> and get the actual function.</p>
<p>It looks like you use <code>method_dict</code> to reference the function, so you still need to go a little deeper. Fortunately, <a href="https://docs.python.org/3/library/unittest.mock.html#patch-dict" rel="nofollow noreferrer"><code>unittest.mock.patch</code></a> has a utility for mocking dict contents like so:</p>
<pre><code>with patch.dict(f2.method_dict, {'method1': your_mock_here}):
    your_test_here()
</code></pre>
<p>One other way is to defer resolving the method name until after it's mocked.</p>
<pre><code>method_dict = {
    'method_1' : lambda data: f1.method1(data),
    'method_2' : lambda data: f1.method2(data),
    'method_3' : lambda data: f1.method3(data)
}
</code></pre>
<p>Here, the lookup for f1.method1 doesn't happen until after it has been mocked. In the earlier case, you put a reference to the function when file2 was read. Here the reference isn't resolved until the method is actually called.</p>
</div>
<span class="comment-copy">None of this code actually uses <code>method_dict</code>.</span>
<span class="comment-copy">@user2357112 Ah my bad, it actually does in the real stuff, but in getting rid of all the confusing jargon of the project, I guess I got rid of the actual part I'm worried about. I just fixed it. (The first <code>tasks</code> in <code>function_A</code> should have been <code>method_dict</code>.)</span>
<span class="comment-copy">I tried this but got the same <code>KeyError</code></span>
<span class="comment-copy">I see you have another level of indirection in <code>method_dict</code>. Patching that might be a little tricky, but I've made an edit that might make it a little simpler, if you're able to edit the method_dict. If not, I'll see if we can get the direct patch working.</span>
<span class="comment-copy">The lambda method work! Thank you! I guess I'm interested here in understanding 2 things then: 1) How does using <code>lambda</code> work to fix this patching issue? and 2) Is there a way to do this without <code>lamba</code>, via "direct" patching?</span>
<span class="comment-copy">I updated it to not include a lambda in a way that's hopefully a little cleaner. It works because the reference to <code>method1</code> isn't resolved until after the lambda function is called.</span>
<span class="comment-copy">This makes so much sense. I feel like the <code>patch.dict</code> method leaves the actual code a little cleaner, so I went with that, and I have a bit more reading to do to fully understand this, but I think I get it now. Thank you.</span>
