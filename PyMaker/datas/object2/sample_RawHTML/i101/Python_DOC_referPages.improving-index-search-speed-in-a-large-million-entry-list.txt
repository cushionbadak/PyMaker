<div class="post-text" itemprop="text">
<p>I have a list which is a million items long of random, repeatable integers. I need to sort that list, and then find the index of the first iteration of every unique element in the list. When I do this, I am running into run time &gt;5 minutes long. Can anyone give me any suggestions to speed up my code? An example of my process is shown below.</p>
<pre><code>import random

a = []
for x in range(1000000):
    a.append(random.randint(1,10000))
unique_a = set(a)
inds=[0]
inds = [a.index(i) for i in sorted(unique_a) if i not in inds]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>inds = [a.index(i) for i in sorted(unique_a) if i not in inds]</code> is implicitly quadratic is <code>a.index(i)</code> is linear. Use a dictionary to grab the indices in one pass over the sorted list:</p>
<pre><code>a =sorted([0,4,3,5,21,5,6,3,1,23,4,6,1,93,34,10])
unique_a = set(a)
first_inds = {}
for i,x in enumerate(a):
    if not x in first_inds:
        first_inds[x] = i
my_inds = [first_inds[x] for x in sorted(unique_a)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just store the first position for every unique element:</p>
<pre><code>first_position = {}
for i, value in enumerate(a):
    if value not in first_position:
        first_position[value] = i
</code></pre>
<p>And then replace <code>a.index(i)</code> for <code>first_position[i]</code></p>
<p>Or just use:</p>
<p><code>_, indices = zip(*sorted(first_position.items()))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>bisect_left</code> function from the standard library's <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer">bisect</a> module to do this.  On a sorted list, a bisection search is faster than searching through the list as <code>index</code> does.</p>
<pre><code>&gt;&gt;&gt; L = [random.randint(0, 10) for _ in range(100)]
&gt;&gt;&gt; L.sort()
&gt;&gt;&gt; L.index(9)
83
&gt;&gt;&gt; bisect.bisect_left(L, 9)
83

&gt;&gt;&gt; timeit.timeit(setup="from __main__ import L", stmt="L.index(9)")
2.1408978551626205
&gt;&gt;&gt; timeit.timeit(setup="from __main__ import L;from bisect import bisect_left", stmt="bisect_left(L, 9)")
0.5187544231303036
</code></pre>
<p>On my machine, using bisect.bisect_left is faster than iterating over the list and accumulating indexes on the way:</p>
<pre><code>&gt;&gt;&gt; L = [random.randint(0, 100) for _ in range(10000)]
&gt;&gt;&gt; L.sort()
&gt;&gt;&gt; def iterative_approach(list_):
...     unique = set(list_)
...     first_inds = {}
...     for i, x in enumerate(list_):
...         if x not in first_inds:
...             first_inds[x] = i
...     return [first_inds[x] for x in sorted(unique)]
... 
&gt;&gt;&gt; ia = iterative_approach(L)

&gt;&gt;&gt; bisect_left = bisect.bisect_left
&gt;&gt;&gt; def bisect_approach(list_):
...     unique = set(list_)
...     out = {}
...     for x in unique:
...         out[x] = bisect_left(list_, x)
...     return [out[x] for x in sorted(unique)]
... 
&gt;&gt;&gt; ba = bisect_approach(L)
&gt;&gt;&gt; ia == ba
True


&gt;&gt;&gt; timeit.timeit(setup="from __main__ import L, iterative_approach", stmt="iterative_approach(L)")
1488.956467495067
&gt;&gt;&gt; timeit.timeit(setup="from __main__ import L, bisect_approach", stmt="bisect_approach(L)")
407.6803469741717
</code></pre>
</div>
<span class="comment-copy">Do not use <code>a.index</code>  that will take O(N) for every iteration and will never end. Use a dict to save the first ocurrence of every number of <code>a</code> instead.</span>
