<div class="post-text" itemprop="text">
<p>I have a ctypes field that is a <code>POINTER(c_char)</code> (it had to be, per the documentation, c_char_p didn't work for my application: <a href="https://docs.python.org/3.7/library/ctypes.html#ctypes.c_char_p" rel="nofollow noreferrer">https://docs.python.org/3.7/library/ctypes.html#ctypes.c_char_p</a>)</p>
<blockquote>
<p>For a general character pointer that may also point to binary data, POINTER(c_char) must be used.</p>
</blockquote>
<p>However, this usage recommended by ctypes itself seems to have the downside that, it claims to be a pointer to a single character, however, it isn't, it's a pointer to an array of bytes. </p>
<p>How can I read the array returned by the ctypes fucntion (I know the <code>length</code>) in Python? Trying to index it like <code>foo[0:len]</code> where <code>foo</code> is a <code>POINTER(c_char)</code> blows up with <code>TypeError: 'c_char' object is not subscriptable</code></p>
<p>I can print the first character of the bytestring using either <code>print(foo)</code> or <code>print(foo[0])</code></p>
<p>I was thinking that <code>ctypes.cast</code> might work, however I don't know how to pass it the length of the cast (as in interpret the first N bytes from address foo as a <code>bytes</code> object)</p>
<p>EDIT: some code.</p>
<p>So I have a structure:</p>
<pre><code>class foo(Structure):
_fields_ = [("state", c_int),
            ("type", c_int),
            ("len", c_int),
            ("payload", POINTER(c_char))]  # according to th following the python bytes are already unsinged https://bytes.com/topic/python/answers/695078-ctypes-unsigned-char
</code></pre>
<p>And I have another function that returns a <code>POINTER(foo)</code></p>
<pre><code>lib3 = CDLL(....so)
f = lib3.f
f.restype = POINTER(foo)
</code></pre>
<p>I call <code>f</code>, which returns a <code>POINTER(foo)</code>:</p>
<pre><code>ptrf = f(....)
</code></pre>
<p>And then I was trying to access <code>ptrf.payload</code>. The following code works:</p>
<pre><code>def get_payload(ptr_to_foo):

    val = cast(ptr_to_foo.contents.payload, c_char_p).value
    return val[:ptr_to_foo.contents.len]
</code></pre>
<p>So I do </p>
<pre><code> ptrf = f(....)
 get_payload(ptrf)
</code></pre>
<p>I was wondering whether the <code>get_payload</code> function would be written more easily. </p>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer">[Python 3]: ctypes - A foreign function library for Python</a> states, you must <strong>not</strong> use <em>c_char_p</em> with binary data. <br/>Of course that can be ignored, but then surprises (string silently truncated) may occur.</p>
<p>Although it could be exemplified in <em>~5</em> lines of code, pasting the whole thing:</p>
<p><em>dll.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include &lt;stdlib.h&gt;

#if defined(_WIN32)
#  define DLL_EXPORT __declspec(dllexport)
#else
#  define DLL_EXPORT
#endif

#define LEN 5


typedef struct CharPtrWrapperTag {
    int len;
    char *data;
} CharPtrWrapper;


DLL_EXPORT CharPtrWrapper *get() {
    CharPtrWrapper *ret = malloc(sizeof(CharPtrWrapper));
    ret-&gt;len = LEN;
    ret-&gt;data = malloc(LEN * sizeof(char));
    ret-&gt;data[0] = 'A';
    ret-&gt;data[1] = 'B';
    ret-&gt;data[2] = 0;
    ret-&gt;data[3] = 'C';
    ret-&gt;data[4] = 'D';
    return ret;
}


DLL_EXPORT void release(CharPtrWrapper *pWrap) {
    if (pWrap) {
        free(pWrap-&gt;data);
        pWrap-&gt;data = NULL;
        pWrap-&gt;len = 0;
        free(pWrap);
    }
}
</code></pre>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import ctypes


DLL_NAME = "./dll.dll"
CharPtr = ctypes.POINTER(ctypes.c_char)

class CharPtrWrapper(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int),
        ("data", CharPtr),
    ]


CharPtrWrapperPtr = ctypes.POINTER(CharPtrWrapper)


def main():
    dll = ctypes.CDLL(DLL_NAME)
    get = dll.get
    get.restype = CharPtrWrapperPtr
    release = dll.release
    release.argtypes = [CharPtrWrapperPtr]
    wrap_ptr = get()
    wrap = wrap_ptr.contents
    print("{:}\n    Len: {:d}".format(wrap, wrap.len))
    for idx in range(wrap.len):
        print("        {:d}: {:}".format(idx, wrap.data[idx]))

    s = ctypes.cast(wrap.data, ctypes.c_char_p).value[:wrap.len]
    print("\nctypes.c_char_p cast: {:}".format(s))

    CharArr = ctypes.c_char * wrap.len
    char_arr = CharArr(*wrap.data[:wrap.len])
    print("CharArr: {:}".format(char_arr.raw))
    release(wrap_ptr)
    print("\nDone.")


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre class="lang-bat prettyprint-override"><code>[cfati@CFATI-5510-0:e:\Work\Dev\StackOverflow\q055103298]&gt; sopr.bat
*** Set shorter prompt to better fit when pasted in StackOverflow (or other) pages ***

[prompt]&gt; "c:\Install\x86\Microsoft\Visual Studio Community\2015\vc\vcvarsall.bat" x64

[prompt]&gt; dir /b
code.py
dll.c

[prompt]&gt; cl /nologo /DDLL /MD dll.c  /link /NOLOGO /DLL /OUT:dll.dll
dll.c
   Creating library dll.lib and object dll.exp

[prompt]&gt; dir /b
code.py
dll.c
dll.dll
dll.exp
dll.lib
dll.obj

[prompt]&gt; "e:\Work\Dev\VEnvs\py_064_03.06.08_test0\Scripts\python.exe" code.py
Python 3.6.8 (tags/v3.6.8:3c6b436a57, Dec 24 2018, 00:16:47) [MSC v.1916 64 bit (AMD64)] on win32

&lt;__main__.CharPtrWrapper object at 0x000001279250D248&gt;
    Len: 5
        0: b'A'
        1: b'B'
        2: b'\x00'
        3: b'C'
        4: b'D'

ctypes.c_char_p cast: b'AB'
CharArr: b'AB\x00CD'

Done.
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>If you truly have a <code>POINTER(c_char)</code> type, it is subscriptable.  In the future provide code that reproduces your issue:</p>
<pre><code>&gt;&gt;&gt; p = cast(create_string_buffer(b'Hello, world!'),POINTER(c_char))
&gt;&gt;&gt; p
&lt;ctypes.LP_c_char object at 0x000001C2F6B58848&gt;
&gt;&gt;&gt; p[0]
b'H'
&gt;&gt;&gt; p[:14]
b'Hello, world!\x00'
&gt;&gt;&gt; cast(p,c_char_p).value  # only if known to be nul-terminated
b'Hello, world!'
</code></pre>
</div>
<span class="comment-copy">Can you share some code / details (how the func is called what args are being passed to it, who allocates the array)? Maybe the whole approach is wrong. The <i>TypeError</i> that you get denotes that <i>foo</i> is a <i>c_char</i> (not a pointer). I am able to index a <code>ctypes.LP_c_char</code> (which was created from a char array).</span>
<span class="comment-copy">@CristiFati question updated to include more code</span>
<span class="comment-copy">this most definitely saved me from a huge gotcha! This works great thank you</span>
<span class="comment-copy">You're welcome! :)</span>
<span class="comment-copy">there is some magical stuff going on here, *wrap.data[:wrap.len] looks like a pointer dereference but it isn't. I modified your answer slightly to return <code>char_arr[0:len]</code>, instead of printing it. Maybe I should also try this <code>raw</code> attribute.</span>
<span class="comment-copy">That's <i>tuple unpacking</i> (<a href="https://stackoverflow.com/questions/2238355/what-is-the-pythonic-way-to-unpack-tuples" title="what is the pythonic way to unpack tuples">stackoverflow.com/questions/2238355/â€¦</a>). No need the slice <code>[0:len]</code> (which is the same as <code>[:len]</code> btw :) ), because <i>char_arr</i> will not be longer than <i>len</i>.</span>
<span class="comment-copy">but returning without the <code>[0:len]</code> returns a ctypes char_array object, whereas slicing it seems to return a <code>bytes</code> object. The caller is expecting the bytes object, not the ctypes representation.</span>
<span class="comment-copy">question updated to include more code</span>
