<div class="post-text" itemprop="text">
<p>I want <code>a</code> to be rounded to <em>13.95</em>.</p>
<pre><code>&gt;&gt;&gt; a
13.949999999999999
&gt;&gt;&gt; round(a, 2)
13.949999999999999
</code></pre>
<p>The <a href="https://docs.python.org/2/library/functions.html#round" rel="noreferrer"><code>round</code></a> function does not work the way I expected.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are running into the old problem with floating point numbers that all numbers cannot be represented. The command line is just showing you the full floating point form from memory.</p>
<p>In floating point your rounded version is the same number. Since computers are binary, they store floating point numbers as an integer and then divide it by a power of two so 13.95 will be represented in a similar fashion to 125650429603636838/(2**53).</p>
<p>Double precision numbers have 53 bits (16 digits) of precision and regular floats have 24 bits (8 digits) of precision. The <a href="http://docs.python.org/tutorial/floatingpoint.html" rel="noreferrer">floating point in Python uses double precision</a> to store the values.</p>
<p>For example,</p>
<pre><code>  &gt;&gt;&gt; 125650429603636838/(2**53)
  13.949999999999999

  &gt;&gt;&gt; 234042163/(2**24)
  13.949999988079071

  &gt;&gt;&gt; a=13.946
  &gt;&gt;&gt; print(a)
  13.946
  &gt;&gt;&gt; print("%.2f" % a)
  13.95
  &gt;&gt;&gt; round(a,2)
  13.949999999999999
  &gt;&gt;&gt; print("%.2f" % round(a,2))
  13.95
  &gt;&gt;&gt; print("{0:.2f}".format(a))
  13.95
  &gt;&gt;&gt; print("{0:.2f}".format(round(a,2)))
  13.95
  &gt;&gt;&gt; print("{0:.15f}".format(round(a,2)))
  13.949999999999999
</code></pre>
<p>If you are after only two decimal places as in currency then you have a couple of better choices: 1) Use integers and store values in cents, not dollars and then divide by 100 to convert to dollars. 2) Or use a fixed point number like <a href="http://docs.python.org/library/decimal.html" rel="noreferrer">decimal</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are new format specifications, <a href="http://docs.python.org/library/string.html#format-specification-mini-language" rel="noreferrer"><strong>String Format Specification Mini-Language</strong></a>:</p>
<p>You can do the same as:</p>
<pre><code>"{0:.2f}".format(13.949999999999999)
</code></pre>
<p><strong>Note</strong> that the above returns a string. In order to get as float, simply wrap with <code>float(...)</code>:</p>
<pre><code>float("{0:.2f}".format(13.949999999999999))
</code></pre>
<p><strong>Note</strong> that wrapping with <code>float()</code> doesn't change anything:</p>
<pre><code>&gt;&gt;&gt; x = 13.949999999999999999
&gt;&gt;&gt; x
13.95
&gt;&gt;&gt; g = float("{0:.2f}".format(x))
&gt;&gt;&gt; g
13.95
&gt;&gt;&gt; x == g
True
&gt;&gt;&gt; h = round(x, 2)
&gt;&gt;&gt; h
13.95
&gt;&gt;&gt; x == h
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The built-in <code>round()</code> works just fine in Python 2.7 or later.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; round(14.22222223, 2)
14.22
</code></pre>
<p>Check out <a href="https://docs.python.org/3/library/functions.html#round" rel="noreferrer">the documentation</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I feel that the simplest approach is to use the <code>format()</code> function.</p>
<p>For example:</p>
<pre><code>a = 13.949999999999999
format(a, '.2f')

13.95
</code></pre>
<p>This produces a float number as a string rounded to two decimal points.</p>
</div>
<div class="post-text" itemprop="text">
<p>Most numbers cannot be exactly represented in floats. If you want to round the number because that's what your mathematical formula or algorithm requires, then you want to use round. If you just want to restrict the display to a certain precision, then don't even use round and just format it as that string. (If you want to display it with some alternate rounding method, and there are tons, then you need to mix the two approaches.)</p>
<pre><code>&gt;&gt;&gt; "%.2f" % 3.14159
'3.14'
&gt;&gt;&gt; "%.2f" % 13.9499999
'13.95'
</code></pre>
<p>And lastly, though perhaps most importantly, if you want <em>exact</em> math then you don't want floats at all. The usual example is dealing with money and to store 'cents' as an integer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use</p>
<pre><code>print"{:.2f}".format(a)
</code></pre>
<p>instead of</p>
<pre><code>print"{0:.2f}".format(a)
</code></pre>
<p>Because the latter may lead to output errors when trying to output multiple variables (see comments).</p>
</div>
<div class="post-text" itemprop="text">
<p>Try the code below:</p>
<pre><code>&gt;&gt;&gt; a = 0.99334
&gt;&gt;&gt; a = int((a * 100) + 0.5) / 100.0 # Adding 0.5 rounds it up
&gt;&gt;&gt; print a
0.99
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With Python &lt; 3 (e.g. 2.6 or 2.7), there are two ways to do so.</p>
<pre><code># Option one 
older_method_string = "%.9f" % numvar

# Option two (note ':' before the '.9f')
newer_method_string = "{:.9f}".format(numvar)
</code></pre>
<p>But note that for Python versions above 3 (e.g. 3.2 or 3.3), option two is <a href="http://docs.python.org/2/library/stdtypes.html#str.format" rel="nofollow noreferrer">preferred</a>.</p>
<p>For more information on option two, I suggest this link on <a href="http://docs.python.org/2/library/string.html#formatstrings" rel="nofollow noreferrer">string formatting from the Python documentation</a>.</p>
<p>And for more information on option one, <a href="http://docs.python.org/2/library/stdtypes.html#string-formatting" rel="nofollow noreferrer">this link will suffice and has information on the various flags</a>.</p>
<p>Reference: <em><a href="https://stackoverflow.com/questions/15263597/convert-floating-point-number-to-certain-precision-then-copy-to-string">Convert floating point number to a certain precision, and then copy to string</a></em></p>
</div>
<div class="post-text" itemprop="text">
<p>You can modify the output format:</p>
<pre><code>&gt;&gt;&gt; a = 13.95
&gt;&gt;&gt; a
13.949999999999999
&gt;&gt;&gt; print "%.2f" % a
13.95
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>TLDR ;)</h2>
<p>The rounding problem of input / output has been <strong>solved definitively by Python 2.7.0</strong> and <strong>3.1</strong>.</p>
<p>A correctly rounded number can be reversibly converted back and forth:<br/>
<code>str -&gt; float() -&gt; repr() -&gt; float() ...</code> or <code>Decimal -&gt; float -&gt; str -&gt; Decimal</code><br/>
A Decimal type is not necessary for storage anymore.</p>
<p>(Naturally, it can be necessary to round a result of addition or subtraction of rounded numbers to eliminate the accumulated last bit errors. An explicit Decimal arithmetic can be still handy, but a conversion to string by <code>str()</code> (that is with rounding to 12 valid digits) is good enough usually if no extreme accuracy or no extreme number of successive arithmetic operations is required.)</p>
<p>Infinite test:</p>
<pre><code>import random
from decimal import Decimal
for x in iter(random.random, None):           # Verify FOREVER that rounding is fixed :-)
    assert float(repr(x)) == x                # Reversible repr() conversion.
    assert float(Decimal(repr(x))) == x
    assert len(repr(round(x, 10))) &lt;= 12      # Smart decimal places in repr() after round.
    if x &gt;= 0.1:                              # Implicit rounding to 12 significant digits
        assert str(x) == repr(round(x, 12))   # by str() is good enough for small errors.
        y = 1000 * x                             # Decimal type is excessive for shopping
        assert str(y) == repr(round(y, 12 - 3))  # in a supermaket with Python 2.7+ :-)
</code></pre>
<h2>Documentation</h2>
<p>See the <a href="https://docs.python.org/2.7/whatsnew/2.7.html#other-language-changes" rel="nofollow noreferrer">Release notes Python 2.7 - Other Language Changes</a> the fourth paragraph:</p>
<blockquote>
<p><strong>Conversions</strong> between floating-point numbers and strings are now <strong>correctly rounded</strong> on most platforms. These conversions occur in many different places: str() on floats and complex numbers; the float and complex constructors; numeric formatting; serializing and de-serializing floats and complex numbers using the <code>marshal</code>, <code>pickle</code> and <code>json</code> modules; parsing of float and imaginary literals in Python code; and Decimal-to-float conversion.</p>
<p>Related to this, the <strong>repr()</strong> of a floating-point number x now returns a result based on the <strong>shortest decimal string that’s guaranteed to round back to x</strong> under correct rounding (with round-half-to-even rounding mode). Previously it gave a string based on rounding x to 17 decimal digits.</p>
</blockquote>
<p><a href="https://bugs.python.org/issue7117" rel="nofollow noreferrer">The related issue</a></p>
<hr/>
<p><strong>More information:</strong> The formatting of <code>float</code> before Python 2.7 was similar to the current <code>numpy.float64</code>. Both types use the same 64 bit <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="nofollow noreferrer">IEEE 754</a> double precision with 52 bit mantissa. A big difference is that <code>np.float64.__repr__</code> is formatted frequently with an excessive decimal number so that no bit can be lost, but no valid IEEE 754 number exists between 13.949999999999999 and 13.950000000000001. The result is not nice and the conversion <code>repr(float(number_as_string))</code> is not reversible with numpy. On the other hand: <code>float.__repr__</code> is formatted so that every digit is important; the sequence is without gaps and the conversion is reversible. Simply: If you perhaps have a numpy.float64 number, convert it to normal float in order to be formatted for humans, not for numeric processors, otherwise nothing more is necessary with Python 2.7+.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.7:</p>
<pre><code>a = 13.949999999999999
output = float("%0.2f"%a)
print output
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The Python tutorial has an appendix called <em><a href="http://docs.python.org/tutorial/floatingpoint.html" rel="nofollow noreferrer">Floating Point Arithmetic: Issues and Limitations</a></em>. Read it. It explains what is happening and why Python is doing its best. It has even an example that matches yours. Let me quote a bit:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; 0.1
0.10000000000000001
</code></pre>
<p>you may be tempted to use the <code>round()</code>
  function to chop it back to the single
  digit you expect. But that makes no
  difference:</p>
<pre><code>&gt;&gt;&gt; round(0.1, 1)
0.10000000000000001
</code></pre>
<p>The problem is that the binary
  floating-point value stored for <code>“0.1”</code>
  was already the best possible binary
  approximation to <code>1/10</code>, so trying to
  round it again can’t make it better:
  it was already as good as it gets.</p>
<p>Another consequence is that since <code>0.1</code>
  is not exactly <code>1/10</code>, summing ten
  values of <code>0.1</code> may not yield exactly
  <code>1.0</code>, either:</p>
<pre><code>&gt;&gt;&gt; sum = 0.0
&gt;&gt;&gt; for i in range(10):
...     sum += 0.1
...
&gt;&gt;&gt; sum
0.99999999999999989
</code></pre>
</blockquote>
<p>One alternative and solution to your problems would be using the <a href="http://docs.python.org/library/decimal.html" rel="nofollow noreferrer"><code>decimal</code></a> module.</p>
</div>
<div class="post-text" itemprop="text">
<p>Nobody here seems to have mentioned it yet, so let me give an example in Python 3.6's f-string/template-string format, which I think is beautifully neat:</p>
<pre><code>&gt;&gt;&gt; f'{a:.2f}'
</code></pre>
<p>It works well with longer examples too, with operators and not needing parens:</p>
<pre><code>&gt;&gt;&gt; print(f'Completed in {time.time() - start:.2f}s')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's doing exactly what you told it to do and is working correctly. Read more about <a href="http://www.lahey.com/float.htm" rel="nofollow noreferrer">floating point confusion</a> and maybe try <a href="http://docs.python.org/library/decimal.html" rel="nofollow noreferrer">decimal</a> objects instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>As @Matt pointed out, <strong><em>Python 3.6 provides f-strings</em></strong>, and they can also use <strong><a href="https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals" rel="noreferrer">nested parameters</a></strong>:</p>
<pre><code>value = 2.34558
precision = 2
width = 4

print(f'result: {value:{width}.{precision}f}')
</code></pre>
<p>which will display <code>result: 2.35</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <strong>format</strong> operator for rounding the value up to 2 decimal places in python:</p>
<pre><code>print(format(14.4499923, '.2f')) // output is 14.45
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For fixing the floating point in type-dynamic languages such as Python and JavaScript, I use this technique</p>
<pre><code># For example:
a = 70000
b = 0.14
c = a * b

print c # Prints 980.0000000002
# Try to fix
c = int(c * 10000)/100000
print c # Prints 980
</code></pre>
<p>You can also use Decimal as following:</p>
<pre><code>from decimal import *
getcontext().prec = 6
Decimal(1) / Decimal(7)
# Results in 6 precision -&gt; Decimal('0.142857')

getcontext().prec = 28
Decimal(1) / Decimal(7)
# Results in 28 precision -&gt; Decimal('0.1428571428571428571428571429')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>orig_float = 232569 / 16000.0
</code></pre>
<blockquote>
<p>14.5355625</p>
</blockquote>
<pre><code>short_float = float("{:.2f}".format(orig_float)) 
</code></pre>
<blockquote>
<p>14.54</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>from decimal import Decimal


def round_float(v, ndigits=2, rt_str=False):
    d = Decimal(v)
    v_str = ("{0:.%sf}" % ndigits).format(round(d, ndigits))
    if rt_str:
        return v_str
    return Decimal(v_str)
</code></pre>
<p>Results:</p>
<pre><code>Python 3.6.1 (default, Dec 11 2018, 17:41:10)
&gt;&gt;&gt; round_float(3.1415926)
Decimal('3.14')
&gt;&gt;&gt; round_float(3.1445926)
Decimal('3.14')
&gt;&gt;&gt; round_float(3.1455926)
Decimal('3.15')
&gt;&gt;&gt; round_float(3.1455926, rt_str=True)
'3.15'
&gt;&gt;&gt; str(round_float(3.1455926))
'3.15'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To round a number to a resolution, the best way is the following one, which can work with any resolution (0.01 for two decimals or even other steps):</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; value = 13.949999999999999
&gt;&gt;&gt; resolution = 0.01
&gt;&gt;&gt; newValue = int(np.round(value/resolution))*resolution
&gt;&gt;&gt; print newValue
13.95

&gt;&gt;&gt; resolution = 0.5
&gt;&gt;&gt; newValue = int(np.round(value/resolution))*resolution
&gt;&gt;&gt; print newValue
14.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's simple like 1,2,3:</p>
<ol>
<li><p>use <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer">decimal</a> module for fast correctly-rounded decimal floating point arithmetic:</p>
<p>d=Decimal(10000000.0000009)</p></li>
</ol>
<p>to achieve rounding:</p>
<pre><code>   d.quantize(Decimal('0.01'))
</code></pre>
<p>will results with <code>Decimal('10000000.00')</code></p>
<ol start="2">
<li>make above DRY:</li>
</ol>
<pre><code>    def round_decimal(number, exponent='0.01'):
        decimal_value = Decimal(number)
        return decimal_value.quantize(Decimal(exponent))
</code></pre>
<p>OR</p>
<pre><code>    def round_decimal(number, decimal_places=2):
        decimal_value = Decimal(number)
        return decimal_value.quantize(Decimal(10) ** -decimal_places)
</code></pre>
<ol start="3">
<li>upvote this answer :)</li>
</ol>
<p>PS: critique of others: formatting is not rounding.</p>
</div>
<div class="post-text" itemprop="text">
<p>The method I use is that of string slicing. It's relatively quick and simple.</p>
<p>First, convert the float to a string, the choose the length you would like it to be.</p>
<pre><code>float = str(float)[:5]
</code></pre>
<p>In the single line above, we've converted the value to a string, then kept the string only to its first four digits or characters (inclusive).</p>
<p>Hope that helps!</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/249467/what-is-a-simple-example-of-floating-point-rounding-error" title="what is a simple example of floating point rounding error">stackoverflow.com/questions/249467/…</a></span>
<span class="comment-copy">Hmm... Are you trying to represent currency? If so, you should not be using floats for dollars. You could probably use floats for pennies, or whatever the smallest common unit of currency you're trying to model happens to be, but the best practice is to use a decimal representation, as HUAGHAGUAH suggested in his answer.</span>
<span class="comment-copy">It is important not to represent currency in float. Floats are not precise. But penny or cent amounts are integers. Therefore integers are the correct way of representing currency.</span>
<span class="comment-copy">@DavoudTaghawi-Nejad or more to the point... The <a href="http://docs.python.org/2/library/decimal.html" rel="nofollow noreferrer">Decimal Type</a></span>
<span class="comment-copy">I'm coming probably too late here, but I wanted to ask, have the developers of Python solved this problem? Because when I do round(13.949999999999999, 2), I simply get 13.95. I've tried it in Python 2.7.6, as well as 3.4. It works. Not sure if 2.7 even was there in 2009. Maybe it's a Python 2.5 thing?</span>
<span class="comment-copy">@Christian There's a fundamental difference between the value stored and how you <i>display</i> that value. Formatting the output should allow you to add padding as required, as well as adding comma separators, etc.</span>
<span class="comment-copy">worth mention that <code>"%.2f" % round(a,2)</code> you can put in not only in printf, but also in such things like <code>str()</code></span>
<span class="comment-copy">why is it that people always assume currency on floating-point rounding? sometimes you just want to work with less precision.</span>
<span class="comment-copy">@radtek: You need to understand that the binary value (of type <code>float</code>) is just the closest available approximation of the decimal number (that you are familiar with as a human being). There is no such (finitely representable) binary value as 0.245. It simply does not exist, and mathematically <b>cannot</b> exist. The binary value which is closest to 0.245 is slightly <b>less than</b> 0.245, so naturally it rounds down. Likewise, there is no such thing as 0.225 in binary, but the binary value which is closest to 0.225 is slightly <b>greater than</b> 0.225, so naturally it rounds up.</span>
<span class="comment-copy">@radtek: You did literally ask for an explanation. The most straightforward solution is indeed to use <code>Decimal</code>, and that was one of the solutions presented in this answer. The other was to convert your quantities to integer and use integer arithmetic. Both of these approaches also appeared in other answers and comments.</span>
<span class="comment-copy">That will give you a string. Not a number.</span>
<span class="comment-copy">to add commas as well you can <code>'{0:,.2f}'.format(1333.949999999)</code> which prints <code>'1,333.95'</code>.</span>
<span class="comment-copy">@JossefHarush you can wrap it with float(), but you haven't gained anything.  Now you have a float again, with all the same imprecision.  13.9499999999999 and 13.95 are the same float.</span>
<span class="comment-copy">@NedBatchelder: i agree that they are equal, but this limits the float to two decimal points :)</span>
<span class="comment-copy">By the way, since Python 3.6 we can use f-strings: <code>f"Result is {result:.2f}"</code></span>
<span class="comment-copy">So am I to understand that this is a Python 2.7 fail?  Why would such a fundamental function yield different results from v 2.7 to v 3?</span>
<span class="comment-copy">but <code>round(2.16, 1)</code> give <code>2.2</code> why python just offer a <code>truncate</code> func</span>
<span class="comment-copy">This works in Python 2.7 too. Best answer for this question, in my opinion.</span>
<span class="comment-copy">For example, if you try to round the value 2.675 to two decimal places, you get this <code>&gt;&gt;&gt; round(2.675, 2) 2.67</code> <a href="https://docs.python.org/2/tutorial/floatingpoint.html" rel="nofollow noreferrer">docs.python.org/2/tutorial/floatingpoint.html</a></span>
<span class="comment-copy">@Dap <code>float(format(a, '.2f'))</code></span>
<span class="comment-copy">This is nonsense. The two statements given behave identically on Python 2.7, and only the second statement is valid on Python 2.6. (Neither statement is valid in Python 3 or Python &lt; 2.6.) The first form has no advantage besides brevity.</span>
<span class="comment-copy">I mean, print"{0:.2f} {0:.2f}".format(a, b) will lead to mistake in output - it will output 'a' value twice. While print"{:.2f} {:.2f}".format(a, b) will output 'a' and 'b' values.</span>
<span class="comment-copy">For Python 3, you just need to add brackets print(...). And within them all I wrote is right.</span>
<span class="comment-copy">"I mean, print"{0:.2f} {0:.2f}".format(a, b) will lead to mistake in output ". Ah. Well, that's quite a different statement! Maybe you should edit your answer? (What does "raise error" mean in the current answer, for example? Can you give an example of a case where the second statement raises an exception but the first doesn't?)</span>
<span class="comment-copy">You would be after print("{0:.2f} {1:.2f}".format(a, b)) if you have two variables</span>
<span class="comment-copy">But be cautioned, value of a is still an imprecise float. Take a look here - <a href="http://repl.it/LJs" rel="nofollow noreferrer">repl.it/LJs</a> (Click "Run Session" on the top of the Right section).</span>
<span class="comment-copy">If you go with this approach, you should add a 0.5 for a more accurate representation. int(a * 100 + 0.5) / 100.0 ; Using math.ceil is another option.</span>
<span class="comment-copy">@ShashankSawant: Well, for one thing, the answer as presented does not round, it truncates. The suggestion to add half at the end will round, but then there is no benefit to doing this over just using the <code>round</code> function in the first place. For another thing, because this solution still uses floating point, the OP's original problem remains, even for the "corrected" version of this "solution".</span>
<span class="comment-copy">-1, this is just an unnecessary reimplementation of the <code>round</code> function (which was used in the question).</span>
<span class="comment-copy">@interjay which is necessary if the <code>round()</code> doesn't work as the OP mentioned.</span>
<span class="comment-copy">How do you represent an integer? If I use "{i3}".format(numvar) I get an error.</span>
<span class="comment-copy">This is what I mean: If <code>numvar=12.456</code>, then <code>"{:.2f}".format(numvar)</code> yields <code>12.46</code> but <code>"{:2i}".format(numvar)</code> gives an error and I'm expecting <code>12</code>.</span>
<span class="comment-copy">Why downvoted? The question was about Python <code>float</code> (double precision) and normal <code>round</code>, not about numpy.double and its conversion to string. Plain Python rounding really can not be done better than in Python 2.7. The most of answers has been written before 2.7, but they are obsoleted, though they were very good originally. This is the reason of my answer.</span>
<span class="comment-copy">53 bits when you include the "hidden bit", which is implicitly <code>1</code>, except during "gradual underflow".</span>
<span class="comment-copy">It's not round's fault, it's the display fault.</span>
<span class="comment-copy">Yes, it's well known. I miss however a context if you object to something in Python 2.7 Release notes or in my text or to nothing at all. It is more complicated than was necessary the purpose of this question. It should be added that also conversion from string to float has been fixed in Python 2.7 due to <a href="https://bugs.python.org/issue2937" rel="nofollow noreferrer">rounding bug on certain 32-bit Intel chips</a> and that "The round() function is also <b>now</b> correctly rounded." (<a href="https://docs.python.org/2.7/whatsnew/2.7.html#python-3-1-features" rel="nofollow noreferrer">Release notes -  3.1 features backported to 2.7</a>). Can you agree?</span>
<span class="comment-copy">Oops, that was <code>a*b</code> vs <code>b*a</code>.  Thanks for the links -- Nostalgia.</span>
<span class="comment-copy">This doesn't help at all. <code>output</code> has the <i>exact same</i> value as <code>a</code>, so you might as well have written <code>print a</code> instead of <code>print output</code> in the last line.</span>
<span class="comment-copy">@MarkDickinson Could you please try again. Because It is running as expected in my compiler.</span>
<span class="comment-copy">You're missing my point. Yes, your code prints <code>13.95</code>. But so does <code>print a</code>, for this particular value of <code>a</code>, in Python 2.7, so it's not really clear what the point of the formatting step was.</span>
<span class="comment-copy">@MarkDickinson I have edited the code. I agree that 'print a' does print the same value as "print output". But if you compare "a==output", the result will be "False" because formatting step does round off the floating value "a" to two decimal points.</span>
<span class="comment-copy">Did you actually try <code>a == output</code> for the code you show? It gives <code>True</code> for me, and I suspect it does for you, too.</span>
<span class="comment-copy">This returns string</span>
<span class="comment-copy"><code>getcontext().prec = 6</code> works for just the scope of the function or all places?</span>
<span class="comment-copy">Contexts are environments for arithmetic operations. They govern precision, set rules for rounding, determine which signals are treated as exceptions, and limit the range for exponents.  Each thread has its own current context @JulioMarins</span>
<span class="comment-copy">doesn't work for me on python 3.4.3 and numpy 1.9.1 ? &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; res = 0.01 &gt;&gt;&gt; value = 0.184 &gt;&gt;&gt; np.round(value/res) * res 0.17999999999999999</span>
<span class="comment-copy">Looking for documentation I see the problem comes from <code>numpy.round</code> accuracy/precision. So it requires to define it as int before multiplication with resolution. I updated the code. Thank you for that!</span>
<span class="comment-copy">The only necessary is to convert <code>numpy.float64</code> result of np.round to <code>float</code> or simply to use <code>round(value, 2)</code>. No valid IEEE 754 number exists between 13.949999999999999 (= 1395 / 100.) and 3.950000000000001 (= 1395 * .01). Why do you think that your method is the best? The original value 13.949999999999999289 (= value = round(value, 2)) is even more exact than your 13.95000000000000178 (printed by np.float96). More info also for numpy is now added to <a href="http://stackoverflow.com/a/35117668/448474">my answer</a> that you probably downvoted by mistake. It wasn't about numpy originally.</span>
<span class="comment-copy">@hynekcer I do not think that my answer is the best. Just wanted to add an example of limit float to n decimals but the nearest of a defined resolution. I checked as you said, that instead of <code>int</code>you can also use <code>float</code>for @szeitlin example. Thank you for your extra comment. (Sorry but I did not downvote you)</span>
<span class="comment-copy">Please don't post identical answers to multiple questions.</span>
<span class="comment-copy">WOW... tdh... Please never make any accounting software... What happens if the number happen to be 113.94 ?? this would result in 113.9 ... leaving 0.04 missing....  Also this already has answers from over 5 years ago....</span>
