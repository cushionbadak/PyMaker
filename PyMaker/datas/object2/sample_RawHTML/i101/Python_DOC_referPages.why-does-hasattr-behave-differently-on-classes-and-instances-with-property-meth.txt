<div class="post-text" itemprop="text">
<p>I implemented a <strong>write-only</strong> property in my class with <code>@property</code>. The weird thing is that <code>hasattr</code> behaves differently on the class and corresponding instance with this property.</p>
<pre class="lang-py prettyprint-override"><code>from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import UserMixin


class User(Base, UserMixin):
    # codes omitted...

    @property
    def password(self):
        raise AttributeError("password is a write-only attribute!")

    @password.setter
    def password(self, password):
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password):
        return check_password_hash(self.password_hash, password)
</code></pre>
<pre class="lang-py prettyprint-override"><code>In [6]: hasattr(User,'password')
Out[6]: True

In [7]: u1=User()

In [9]: hasattr(u1,'password')
Out[9]: False

In [12]: getattr(User,'password')
Out[12]: &lt;property at 0x1118a84a8&gt;

In [13]: getattr(u1,'password')
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-13-b1bb8901adc7&gt; in &lt;module&gt;
----&gt; 1 getattr(u1,'password')

~/workspace/python/flask_web_development/fisher/app/models.py in password(self)
     82     @property
     83     def password(self):
---&gt; 84         raise AttributeError("password is a write-only attribute!")
     85
     86     @password.setter

AttributeError: password is a write-only attribute!
</code></pre>
<p>From the result of <code>getattr</code>, <code>getattr(u1, 'password')</code> tries to execute the method and raises an error, while <code>getattr(User, 'password')</code> doesn't execute the <code>@property</code> method. Why do they behave differently?</p>
</div>
<div class="post-text" itemprop="text">
<p>Adding to what @timgeb mentioned, there is lot happening in the background than what it appears.</p>
<p>Properties are implemented as Descriptors and the way attribute lookup happens is different when you access an attribute with <code>object</code> and <code>class</code>. When you access the attribute with object like <code>obj.attr</code> basically the rules for attribute lookup are as follows</p>
<ol>
<li>Looks inside <code>__class__.__dict__</code> and see if this attribute is a data descriptor, if yes then the call the <code>__get__</code>, this translates to <code>type(obj).__dict__['attr'].__get__(obj, type(obj))</code>.</li>
<li>Look in the <code>__dict__</code> of the object and return <code>obj.__dict__['attr']</code></li>
<li>If the attribute is a non-data descriptor, call its <code>__get__</code>, this again translates to <code>type(obj).__dict__['attr'].__get__(obj, type(obj))</code>.</li>
<li>Fetch the attribute from <code>__dict__</code> of the class.</li>
<li>Call the default implementation of <code>getattr</code>.</li>
</ol>
<p>Now when you try to access the same attribute with <code>class.attr</code> the same rules apply with a slight difference that this time <code>metaclass</code> of the class is also involved, so here it looks</p>
<ol>
<li>Does the metaclass has data descriptor defined for this attribute, if yes then call return <code>type(class).__dict__['attr']__get__(class, type(class))</code> on it.</li>
<li><p>Look inside <code>__dict__</code> of the class and see if this attribute is a descriptor of any type, if yes then fetch the attribute calling the <code>__get__</code>, if it is not a descriptor fetch the value from <code>__dict__</code> of the class.</p></li>
<li><p>If the attribute is a non-data descriptor in the metalcass, call its <code>__get__</code>.</p></li>
<li>Fetch the attribute from <code>__dict__</code> of the metaclass.</li>
<li>Call the default implementation of <code>getattr</code>. </li>
</ol>
<p>Further the default implementation of <code>__get__</code> for properties has a check that when you access the attribute with the class, it returns the descriptor instance itself, however when you access the attribute with object it actually fires the code inside the <code>__get__</code>. </p>
<pre><code>def __get__(self, instnace, class):
    if instance is None:
        return self
    else:
        # code
</code></pre>
<p>This also explains why <code>hasattr(User, 'password')</code> returns <code>True</code> because since you are calling the attribute with class the <code>else</code> is not getting executed and hence <code>exception</code> is not being raised and <code>hasattr(u1, 'password')</code> returns <code>False</code> as it encounters exception.</p>
</div>
<div class="post-text" itemprop="text">
<p>Properties are <a href="https://docs.python.org/3.7/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>.</p>
<hr/>
<p>Regarding <code>getattr</code>:</p>
<p>When you access an attribute via <code>getattr</code> or the dot-notation on an object (<code>u1</code>) and the class of that object (<code>User</code>) happens to have a descriptor going by the name you are trying to access, that descriptor's <code>__get__</code> method is called<sup>1</sup>, as happens when you issue <code>getattr(u1, 'password')</code>. In your specific case, the logic you defined in your getter (raising the <code>AttributeError</code>) will be executed.</p>
<p>With <code>getattr(User, 'password')</code> the instance passed to the <code>__get__</code> method is <code>None</code>, in which case <code>__get__</code> just returns the descriptor itself instead of executing the getter logic you implemented.</p>
<p><sup>1</sup>There are some special rules depending on whether you have a data or a non-data descriptor, as explained in the Descriptor HowTo.</p>
<hr/>
<p>Regarding <code>hasattr</code>:</p>
<p><code>hasattr(u1, 'password')</code> returns <code>False</code> because <code>getattr(u1, 'password')</code> raises an error. See <a href="https://stackoverflow.com/questions/30143957/why-does-hasattr-execute-the-property-decorator-code-block">this</a> question.</p>
</div>
<span class="comment-copy">Are you asking about <code>hasattr</code> or <code>getattr</code>? When you <code>getattr</code> on the class you get the actual <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor</a> object, its <code>__get__</code> method is only invoked when you <code>getattr</code> on the <i>instance</i>. See also e.g. <a href="https://stackoverflow.com/q/30143957/3001761">stackoverflow.com/q/30143957/3001761</a></span>
<span class="comment-copy">That's <i>write</i>-only, not read-only.</span>
<span class="comment-copy">Descriptor handling <i>does</i> happen for <code>getattr(User, 'password')</code>. <code>property</code> just implements handling that does the same thing as if it wasn't a descriptor for that case. (It's much more obvious that descriptor handling still happens for things like <code>classmethod</code>, which actually do something other than returning the descriptor directly when accessed on the class.)</span>
