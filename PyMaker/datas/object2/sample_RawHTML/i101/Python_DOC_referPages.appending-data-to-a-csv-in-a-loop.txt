<div class="post-text" itemprop="text">
<p>I have up to 8 seperate Python processes creating temp files in a shared folder.  Then I'd like the controlling process to append all the temp files in a certain order into one big file.  What's the quickest way of doing this at an os agnostic shell level?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just using simple file IO:</p>
<pre><code># tempfiles is a list of file handles to your temp files. Order them however you like
f = open("bigfile.txt", "w")
for tempfile in tempfiles:
    f.write(tempfile.read())
</code></pre>
<p>That's about as OS agnostic as it gets. It's also fairly simple, and the performance ought to be about as good as using anything else.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not aware of any shell-level commands for appending one file to another. But appending at 'python level' is sufficiently easy that I am guessing python developers did not think it necessary to add it to the library.</p>
<p>The solution depends on the size and structure of the temp files you are appending. If they are all small enough that you don't mind reading each of them into memory, then the answer from Rafe Kettler (copied from his answer and repeated below) does the job with the least amount of code.</p>
<pre><code># tempfiles is an ordered list of temp files (open for reading)
f = open("bigfile.txt", "w")
for tempfile in tempfiles:
    f.write(tempfile.read())
</code></pre>
<p>If reading files fully into memory is not possible or not an appropriate solution, you will want to loop through each file and read them piece-wise. If your temp file contains newline-terminated lines which can be read individually into memory, you might do something like this</p>
<pre><code># tempfiles is an ordered list of temp files (open for reading)
f = open("bigfile.txt", "w")
for tempfile in tempfiles:
    for line in tempfile
        f.write(line)
</code></pre>
<p>Alternatively - something which will always work - you may choose a buffer size and just read the file piece-wise, e.g.</p>
<pre><code># tempfiles is an ordered list of temp files (open for reading)
f = open("bigfile.txt", "w")
for tempfile in tempfiles:
    while True:
        data = tempfile.read(65536)
        if data:
            f.write(data)
        else:
            break
</code></pre>
<p>The input/output <a href="http://docs.python.org/tutorial/inputoutput.html">tutorial</a> has a lot of good info.</p>
</div>
<div class="post-text" itemprop="text">
<p>Rafe's answer was lacking proper open/close statements, e.g.</p>
<pre><code># tempfiles is a list of file handles to your temp files. Order them however you like
with open("bigfile.txt", "w") as fo:
     for tempfile in tempfiles:
          with open(tempfile,'r') as fi: fo.write(fi.read())
</code></pre>
<p>However, be forewarned that if you want to sort the contents of the bigfile, this method does not catch instances where the last line in one or more of your temp files has a different EOL format, which will cause some strange sort results.  In this case, you will want to strip the tempfile lines as you read them, and then write consistent EOL lines to the bigfile (i.e. involving an extra line of code).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
str = os.listdir("./")

for i in str:
    f = open(i)
    f2 = open("temp.txt", "a")
    for line in f.readlines():
        f2.write(line)
</code></pre>
<p>We can use above code to read all the contents from all the file present in current directory and store into temp.txt file.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/fileinput.html#module-fileinput" rel="nofollow">fileinput</a>:</p>
<pre><code>with open("bigfile.txt", "w") as big_file:
    with fileinput.input(files=tempfiles) as inputs:
        for line in inputs:
            big_file.write(line)
</code></pre>
<p>This is more memory efficient than @RafeKettler's answer as it doesn't need to read the whole file into memory before writing to <code>big_file</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this.  It's very fast (much faster than line-by-line, and shouldn't cause a VM thrash for large files), and should run on about anything, including CPython 2.x, CPython 3.x, Pypy, Pypy3 and Jython.  Also it should be highly OS-agnostic.  Also, it makes no assumptions about file encodings.</p>
<pre><code>#!/usr/local/cpython-3.4/bin/python3

'''Cat 3 files to one: example code'''

import os

def main():
    '''Main function'''
    input_filenames = ['a', 'b', 'c']

    block_size = 1024 * 1024

    if hasattr(os, 'O_BINARY'):
        o_binary = getattr(os, 'O_BINARY')
    else:
        o_binary = 0
    output_file = os.open('output-file', os.O_WRONLY | o_binary)
    for input_filename in input_filenames:
        input_file = os.open(input_filename, os.O_RDONLY | o_binary)
        while True:
            input_block = os.read(input_file, block_size)
            if not input_block:
                break
            os.write(output_file, input_block)
        os.close(input_file)
    os.close(output_file)

main()
</code></pre>
<p>There is one (nontrivial) optimization I've left out: It's better to not assume anything about a good blocksize, instead using a bunch of random ones, and slowly backing off the randomization to focus on the good ones (sometimes called "simulated annealing").  But that's a lot more complexity for little actual performance benefit.</p>
<p>You could also make the os.write keep track of its return value and restart partial writes, but that's only really necessary if you're expecting to receive (nonterminal) *ix signals.</p>
</div>
<div class="post-text" itemprop="text">
<p>In this code, you can indicate the path and name of the input/output files, and it will create the final big file in that path:</p>
<pre><code>import os

dir_name = "Your_Desired_Folder/Goes_Here"    #path
input_files_names = ["File1.txt", "File2.txt", "File3.txt"]     #input files
file_name_out = "Big_File.txt"     #choose a name for the output file
file_output = os.path.join(dir_name, file_name_out)
fout = open(file_output, "w")

for tempfile in input_files_names:
    inputfile = os.path.join(dir_name, tempfile)
    fin = open(inputfile, 'r')
    for line in fin:
        fout.write(line)

fin.close()    
fout.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple &amp; Efficient way to copy data from multiple files to one big file, Before that you need to rename your files to (int) eg. 1,2,3,4...etc, Code:</p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>#Rename Files First

import os

path = 'directory_name'
files = os.listdir(path)
i = 1
for file in files:
    os.rename(os.path.join(path, file), os.path.join(path, str(i)+'.txt'))

    i = i+1</code></pre>
</div>
</div>
</p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code># Code For Copying Data from Multiple files

import os

i = 1
while i&lt;50:

    filename = i
    for filename in os.listdir("directory_name"):

        # %s is your filename # .txt is file extension 
        f = open("%s.txt" % i,'r') 
        fout = open("output_filename", "a")

    for line in f:
        fout.write(line)
    i += 1</code></pre>
</div>
</div>
</p>
</div>
<span class="comment-copy">You want to do this with shell commands? Is file IO okay?</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/1001538/how-do-i-concatenate-files-in-python" title="how do i concatenate files in python">stackoverflow.com/questions/1001538/â€¦</a></span>
<span class="comment-copy">using f.write(tempfile.read()) turns out to be slightly faster than other ways of copying.</span>
<span class="comment-copy">f.write(tempfile.read()) may be fast for small files, but it's awful for big files.</span>
<span class="comment-copy">I'll test this and <a href="http://docs.python.org/library/shutil.html" rel="nofollow noreferrer">docs.python.org/library/shutil.html</a></span>
<span class="comment-copy">This would only work if each individual file is small enough to be read into memory.  There's also worse performance if you can read &amp; write in parallel (e.g. different disks or architecture allows for such) as you'll be waiting for the file to be read before you start anything.  You'll probably be better off using shutil.copyfileobj</span>
<span class="comment-copy">Perhaps should use binary I/O.</span>
<span class="comment-copy">thanks for the pointer to the tutorial.</span>
<span class="comment-copy">would be interesting to know when one solution would be more appropriate, how much memory a file uses before <code>f.write(tempfile.read())</code> becomes inappropriate</span>
