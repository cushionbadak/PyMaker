<div class="post-text" itemprop="text">
<pre><code>import queue

qq = queue.Queue()
qq.put('hi')

class MyApp():

    def __init__(self, q):
        self._queue = q

    def _process_item(self, item):
        print(f'Processing this item: {item}')

    def get_item(self):
        try:
            item = self._queue.get_nowait()
            self._process_item(item)
        except queue.Empty:
            pass

    async def listen_for_orders(self):  
        '''
        Asynchronously check the orders queue for new incoming orders
        '''
        while True:
            self.get_item()
            await asyncio.sleep(0)      

a = MyApp(qq)

loop = asyncio.get_event_loop()

loop.run_until_complete(a.listen_for_orders())
</code></pre>
<p>Using Python 3.6.</p>
<p>I'm trying to write an event handler that constantly listens for messages in the <code>queue</code>, and processes them (prints them in this case). But it must be <strong>asynchronous</strong> - I need to be able to run it in a terminal (IPython) and manually feed things to the <code>queue</code> (at least initially, for testing).</p>
<p>This code does not work - it blocks forever.</p>
<p>How do I make this run forever but return control after each iteration of the <code>while</code> loop?</p>
<p>Thanks.</p>
<p><em>side note:</em>
To make the event loop work with IPython (version 7.2), I'm using <a href="https://github.com/erdewit/ib_insync/blob/master/ib_insync/util.py#L372" rel="nofollow noreferrer">this</a> code from the <code>ib_insync</code> library, I'm using this library for the real-world problem in the example above.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to make your queue an <code>asyncio.Queue</code>, and add things to the queue in a thread-safe manner. For example:</p>
<pre><code>qq = asyncio.Queue()

class MyApp():
    def __init__(self, q):
        self._queue = q

    def _process_item(self, item):
        print(f'Processing this item: {item}')

    async def get_item(self):
        item = await self._queue.get()
        self._process_item(item)

    async def listen_for_orders(self):  
        '''
        Asynchronously check the orders queue for new incoming orders
        '''
        while True:
            await self.get_item()

a = MyApp(qq)

loop = asyncio.get_event_loop()

loop.run_until_complete(a.listen_for_orders())
</code></pre>
<p>Your other thread must put stuff in the queue like this:</p>
<pre><code>loop.call_soon_threadsafe(qq.put_nowait, &lt;item&gt;)
</code></pre>
<p><code>call_soon_threadsafe</code> will ensure correct locking, and also that the event loop is woken up when a new queue item is ready.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is not an async queue.  You need to use <a href="https://docs.python.org/3/library/asyncio-queue.html" rel="nofollow noreferrer">asyncio.Queue</a></p>
<pre><code>qq = queue.Queue()
</code></pre>
<p>Async is an event loop.  You call the loop transferring control to it and it loops until your function is complete which never happens:</p>
<pre><code>loop.run_until_complete(a.listen_for_orders())
</code></pre>
<p>You commented:</p>
<blockquote>
<p>I have another Thread that polls an external network resource for data (I/O intensive) and dumps the incoming messages into this thread. </p>
</blockquote>
<p>Write that code async - so you'd have:</p>
<pre><code>async def run():
    while 1:
        item = await get_item_from_network()
        process_item(item)

loop = asyncio.get_event_loop()
loop.run_until_complete( run() )
</code></pre>
<p>If you don't want to do that what you can do is step through the loop though you don't want to do this.  </p>
<pre><code>import asyncio


def run_once(loop):
    loop.call_soon(loop.stop)
    loop.run_forever()


loop = asyncio.get_event_loop()

for x in range(100):
    print(x)
    run_once(loop)
</code></pre>
<p>Then you simply call your async function and each time you call run_once it will check your (asyncio queue) and pass control to your listen for orders function if the queue has an item in it. </p>
</div>
<span class="comment-copy">having a <code>while True</code> is bad in general, what you should do instead is when you add something to the queue (using a method) you should call another method to take an element from the queue, do its things and at the end check the queue again for more elements, if there arent any, terminate it is also easier to use threads for stuff like this</span>
<span class="comment-copy">I'm not clear on what you're trying to do. Your method <i>does</i> appear to be synchronous, though of course <code>loop.run_until_complete()</code> <i>will</i> block. I don't see where messages are being put <i>into</i> the queue except at the top. You mention feeding messages in manually... what does that mean?</span>
<span class="comment-copy">@NikolasStevenson-Molnar I have another Thread that polls an external network resource for data (I/O intensive) and dumps the incoming messages into this thread. This is the handler to receive the incoming data.</span>
<span class="comment-copy">In that case, it seems like you're using asyncio in the wrong place. It's awesome for network I/O, but doesn't seem to be doing any good in your use here (at least from what's shown in your code example); you've basically constructed an async routine that essentially acts like a <i>synchronous</i> one.</span>
<span class="comment-copy">This is good, but when I call <code>loop.run_until_complete(a.listen_for_orders()) </code> it blocks me from inputting more commands into the python console. I need it to not block</span>
<span class="comment-copy">@JoshD Then run <code>run_until_complete</code> in an background thread, and read from the console in the main thread. The code should work regardless of which thread the event loop is run in, as long as you use <code>call_soon_threadsafe</code> to add stuff to the queue.</span>
<span class="comment-copy">Thanks. It's not exactly solving my problem though, I suspect I have something wrong with my overall architecture if I'm combining threads and async. I see from your other answers that you have a great grasp of async, would you mind if I contacted you offline for assistance with this? Are you available? Thanks.</span>
<span class="comment-copy">Thanks, but my <code>get_item_from_network()</code> is not <code>awaitable</code> - it's a call to Azure Storage Queue Python SDK to get messages from the queue, and I believe it's built on top of <code>requests</code> which is blocking. So that's why I run the code that gets those messages in a separate thread and transfer to a <code>queue.Queue</code></span>
