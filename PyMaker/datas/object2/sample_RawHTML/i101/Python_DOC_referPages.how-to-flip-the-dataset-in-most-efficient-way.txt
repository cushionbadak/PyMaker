<div class="post-text" itemprop="text">
<p>Assume we have a dataset like:</p>
<pre><code>a: 1,2,3,5,6
b: 4,1,2
c: 1,4
</code></pre>
<p>Now we want to transform this dataset to:</p>
<pre><code>1: a,b,c
2: a,b
3: a
4: b,c
5: a
6: a
</code></pre>
<p>This transform could be done by a dictionary but is there a way to do this more efficiently  </p>
<p>Currently I do as below:</p>
<pre><code>uFile = open("t/u.txt","r")
uDic = dict()
for cnt1, line in enumerate(uFile):
    lineAr = line.strip().split(' ')
    for item in lineAr:
        if item not in uDic.keys():
           uDic[item] = []
        uDic[item].append(cnt1)
</code></pre>
<p>And then save the output.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use defaultdict for this:</p>
<pre><code>from collections import defaultdict
d = {'a': [1, 2, 3, 5, 6], 'b': [4, 1, 2], 'c': [1, 4]}
o = defaultdict(list)

for k, v in d.items():
    for vv in v:
        o[vv].append(k)

print(dict(o))
{1: ['a', 'b', 'c'],
 2: ['a', 'b'],
 3: ['a'],
 5: ['a'],
 6: ['a'],
 4: ['b', 'c']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The dictionary approach is probably fastest. I'll show what I did, and why I think it's fastest.</p>
<pre><code>// store old data
dOld = {}
dOld['a'] = [1,2,3,5,6]
dOld['b'] = [4,1,2]
dOld['c'] = [1,4]

// create dictionary for new data
dNew = {}

// go through letters
for key in dOld:
        // go through numbers
        for listItem in dOld[key]:
                // put each letter in the list of letters
                // for the current number
                if listItem in dNew:
                        dNew[listItem].append(key)
                else:
                        dNew[listItem] = [key]

// check work by printings things out
for i in dNew:
        print(i, end="")
        print(dNew[i])
</code></pre>
<p>We have to loop through each number for each letter it has at least once to get it out of the old dictionary, and put it in the new dictionary. And with this code, we do exactly that - we don't look at any data more than we have to. I am a bit confused though - you formatted your answer in terms of dictionaries, so I assumed the input and output have to be in dictionary form.</p>
<p>Could you elaborate on the exact formatting you'd like? Additionally, because things are taking so long, it could be that file I/O is taking a really long time. That's what I've had happen - unless you switch languages, that's unavoidable.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would go with a simpler way as following:</p>
<pre><code>In [2]: d 
Out[2]: {'a': [1, 2, 3, 5, 6], 'b': [4, 1, 2], 'c': [1, 4]}

In [3]: dd = {}

In [4]: for k,v in d.items():
   ...:     for e in v:
   ...:         val = dd.get(str(e), [])
   ...:         dd[str(e)] = val + [k]
   ...:         

In [5]: dd
Out[5]: 
{'1': ['a', 'b', 'c'],
 '2': ['a', 'b'],
 '3': ['a'],
 '5': ['a'],
 '6': ['a'],
 '4': ['b', 'c']}
</code></pre>
<p>This link may help to understand why the keys are turned into <code>strings</code>:
<a href="https://docs.python.org/3/faq/design.html#why-must-dictionary-keys-be-immutable" rel="nofollow noreferrer">why-must-dictionary-keys-be-immutable</a></p>
</div>
<span class="comment-copy">What is inefficient about your approach? What is your approach, exactly? What exactly are you trying to improve?</span>
<span class="comment-copy">@juanpa.arrivillaga Mostly time but memory usage is a concern to. We could make a dictionary which the columns(1,2,3,4,5,6) are keys and indices(a,b,c) are values</span>
<span class="comment-copy">What, exactly are you doing?</span>
<span class="comment-copy">No, <b>what exactly are you doing</b>. A <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a></span>
<span class="comment-copy">@Justice_Lords that wont' work here, but something similarly fast would. Using a <code>defaultdict(list)</code> would probably be the fastest.</span>
