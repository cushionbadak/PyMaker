<div class="post-text" itemprop="text">
<p>My problem is that</p>
<pre><code>np.array([2**31], dtype=np.uint32) &gt;&gt; 32
</code></pre>
<p>does not return <code>0</code>, but returns <code>array([2147483648], dtype=uint32)</code> instead. The same is true for</p>
<pre><code>np.right_shift(np.array([2**31], dtype=np.uint32), 32)
</code></pre>
<p>(so I believe this is simply how <code>&gt;&gt;</code> is implemented).</p>
<p>Interestingly, all these alternatives seem to work as expected, returning some kind of <code>0</code>:</p>
<pre><code>print(
    2**31 &gt;&gt; 32,
    np.uint32(2**31) &gt;&gt; 32,
    np.array(2**31, dtype=np.uint32) &gt;&gt; 32,
    np.right_shift(2**31, 32),
    np.right_shift([2**31], 32),
    np.right_shift(np.uint32(2**31), 32),
    np.right_shift(np.array(2**31, dtype=np.uint32), 32),
)
</code></pre>
<p>In particular, what is different between Numpy arrays representing <code>2147483648</code> and <code>[2147483648]</code>?</p>
<p>I have seen this issue in JavaScript (<a href="https://stackoverflow.com/questions/24288111/why-does-32-not-result-in-0-in-javascript">Why does &lt;&lt; 32 not result in 0 in javascript?</a>) and C++ (<a href="https://stackoverflow.com/questions/3394259/weird-behavior-of-right-shift-operator-1-32">Weird behavior of right shift operator (1 &gt;&gt; 32)</a>, <a href="https://stackoverflow.com/questions/31217053/why-is-int-32-not-always-zero">Why is `int &gt;&gt; 32` not always zero?</a>), but not yet in Python/Numpy. In fact, neither Python nor Numpy docs seem to be documenting this behavior:</p>
<ul>
<li><p><a href="https://docs.python.org/3/reference/expressions.html#shifting-operations" rel="noreferrer">https://docs.python.org/3/reference/expressions.html#shifting-operations</a></p></li>
<li><p><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.right_shift.html" rel="noreferrer">https://docs.scipy.org/doc/numpy/reference/generated/numpy.right_shift.html</a></p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>While not documented, numpy is mostly implemented in C and the shift operator in C (and C++) is not defined for shifts greater than or equal to the number of bits. So the result can be arbitrary.</p>
<p>If you look at the types of the examples that work you'll see why they work:</p>
<pre><code>print(
    type(2**31 &gt;&gt; 32),
    type(np.uint32(2**31) &gt;&gt; 32),
    type(np.array(2**31, dtype=np.uint32) &gt;&gt; 32),
    type(np.right_shift(2**31, 32)),
    np.right_shift([2**31], 32).dtype,
    type(np.right_shift(np.uint32(2**31), 32)),
    type(np.right_shift(np.array(2**31, dtype=np.uint32), 32)),
)
</code></pre>
<blockquote>
<p>&lt;class 'int'&gt; &lt;class 'numpy.int64'&gt; &lt;class 'numpy.int64'&gt; &lt;class 'numpy.int64'&gt; int64 &lt;class 'numpy.int64'&gt; &lt;class 'numpy.int64'&gt;</p>
</blockquote>
<p>The first uses Python's own <code>int</code> type, while the others are all converted to <code>numpy.int64</code>, where the behavior for a 32-bit shift is correct.
This is mostly due to the fact that scalar (zero-dimensional) arrays behave differently. And in the <code>list</code> case that the default integer type for numpy is <em>not</em> <code>numpy.uint32</code>.</p>
<p>On the other hand</p>
<pre><code>print((np.array([2**31], dtype=np.uint32) &gt;&gt; 32).dtype)
</code></pre>
<blockquote>
<p>uint32</p>
</blockquote>
<p>So you run into the undefined behavior here.</p>
</div>
<span class="comment-copy">That's quite strange ya, and i can't give you a reason for that, but note that doing <code>&gt;&gt; 31</code> returns you 1 and <code>&lt;&lt; 16</code> returns you 0 which are expected results. Maybe by doing <code>&gt;&gt; 32</code> it changes its type into a double or a thing like that</span>
<span class="comment-copy">Actually any number shifted by &gt;&gt;32 remains the same.  So <code>np.array([123], dtype=np.uint32) &gt;&gt; 32</code> equals <code>np.array([123], dtype=np.uint32)</code> And even more <code>(np.array([123], dtype=np.uint32) &gt;&gt; 33)</code> equals <code>(np.array([123], dtype=np.uint32) &gt;&gt; 1)</code> Really not expected.</span>
<span class="comment-copy">As <code>type(np.uint32(2**31)</code> is numpy.int64, so <code>np.array(2**31, dtype=np.uint32) &gt;&gt; 64</code> will give non zero again.</span>
<span class="comment-copy">@LeonidMednikov yes, if you start shifting those 64-bit integers by 64 bits or more you will run into similar issues.</span>
<span class="comment-copy">Thanks for the explanation, good idea to look at types. I get that the observed effect <i>may be</i> due to undefined behavior, but should it be undefined at all? Shouldn't the definition of the language be independent of its implementation? In other words, shouldn't at least the definition (= documentation) of the language be amended?</span>
<span class="comment-copy">"This is mostly due to the fact that scalar (zero-dimensional) arrays behave differently." This is true independent of shifts - I was not aware of that: <code>(np.array(1, dtype=np.uint32) + 1).dtype</code> is <code>int64</code>, while <code>(np.array([1], dtype=np.uint32) + 1).dtype</code> is <code>uint32</code>. Got it.</span>
<span class="comment-copy">@bers I think this should be considered a bug in NumPy so I have <a href="https://github.com/numpy/numpy/issues/13106" rel="nofollow noreferrer">reported it</a>.</span>
