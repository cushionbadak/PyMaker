<div class="post-text" itemprop="text">
<p>I'm trying to match all of the "words" with an intrusive asterisk in it, including at the beginning and the end (but no other punctuation). </p>
<p>For example, I'm expecting seven matches below. Instead, I got two.</p>
<pre><code>text = "star *tar s*ar st*r sta* (*tar) (sta*) sta*."
p = re.compile(r"\b\w*\*+\w*\b")
p.findall(text) # ['s*ar', 'st*r']
# Expected ['*tar', 's*ar', 'st*r', 'sta*', '*tar', 'sta*', 'sta*']
</code></pre>
<p>I understand that the reason is the asterisk is not considered part of a word bounded by the <code>\b</code> meta-character, but after reading all of Python's <a href="https://docs.python.org/3/howto/regex.html#regex-howto" rel="nofollow noreferrer">How-to</a>, I still don't quite know how to get what I want.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need the word boundaries with <code>re.findall</code> since it will find all the matches in a string for your specified regex. You also need to ensure that the match includes at least one word character so you don't match a single asterisk. For example:</p>
<pre><code>import re

text = 'star *tar s*ar st*r sta* (*tar) (sta*) sta*.'

matches = re.findall(r'\w+\*\w*|\w*\*\w+', text)
print(matches)
# ['*tar', 's*ar', 'st*r', 'sta*', '*tar', 'sta*', 'sta*']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for editing in the expected output.</p>
<p>So, in addition to the excellent solution by @benvc, this one takes recursion into account so if you are looking to capture when the text has multiple <code>*</code>'s the entire found string will be captured and won't ignore other <code>*</code>'s</p>
<pre><code>#Acting on your original text string
&gt;&gt;&gt; text = "star *tar s*ar st*r sta* (*tar) (sta*) sta*."
&gt;&gt;&gt; re.findall('((?:[a-z\*]*(?:\*)(?:[a-z\*]*)))+', text)
['*tar', 's*ar', 'st*r', 'sta*', '*tar', 'sta*', 'sta*']



#Acting on a slightly **MORE COMPLEX** string and returning it accurately
&gt;&gt;&gt; text = "*tar *tar* star s*a**r *st*r* sta* (*tar) st*r** (sta**) s*ta*."
&gt;&gt;&gt; re.findall('((?:[a-z\*]*(?:\*)(?:[a-z\*]*)))+', text)
['*tar', '*tar*', 's*a**r', '*st*r*', 'sta*', '*tar', 'st*r**', 'sta**', 's*ta*']
</code></pre>
<p>.</p>
<p>Let me know if you want me to explain how this works if you might need it for future reference.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try using this regex:</p>
<p><code>(\w*\*+\w*)+</code></p>
<p>First off, I suggest using an online tool to test your regexs like regexr.com.</p>
<p>Second, \b looks for a word boundary or the end of a word. What you want is the word character \w.
The regex shown above finds either word characters or asterisks, then the + causes it to match entire words instead of just individual letters. Note that this cannot be the asterisk quantifier as each word must have at least one letter.
Finally, the expression is wrapped in a capturing group for later use.</p>
<p>Python code:</p>
<pre><code>import re

pattern = r”(\w*\*+\w*)+”
text = “star *tar s*ar st*r sta* (*tar) (sta*) sta*”
p = re.findall(pattern, text)
</code></pre>
<p>Edit: thanks to @benvc, I was able to update my expression to exclude ‘star’.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try this one. It is even simpler.</p>
<pre><code>import re

text = 'star *tar s*ar st*r sta* (*tar) (sta*) sta*.'

p = re.findall(r'[\w*]+', text)
print(p)
</code></pre>
<p>Output:</p>
<pre><code>['star', '*tar', 's*ar', 'st*r', 'sta*', '*tar', 'sta*', 'sta*']
</code></pre>
</div>
<span class="comment-copy">Thanks, but I do <i>not</i> want the parentheses, nor any other punctuations. I just want the "word".</span>
<span class="comment-copy">@bongbang - in that case, you are really close. You just don't need the word boundaries with <code>re.findall</code>. See edit.</span>
<span class="comment-copy">Thank you. Your answer gave me ideas, even though it unfortunately will match "words" with only asterisks such as <code>*</code> and <code>****</code>, which, as @benvc intuits, is not desired.</span>
<span class="comment-copy">You brought up a great point about the possibility of non-consecutive asterisks in a word, though. I do want such a word captured. I'm going with your solution and dealing w/ asterisk-only cases outside regex.</span>
<span class="comment-copy">Wow. I hadn't thought to test <code>***</code>. Hmmm... getting rid of that will be quite the challenge, but at the very least you can likely use another regex to test to see if there are any letter in the string and if not, discard it.</span>
<span class="comment-copy">Why do you need those three non-capturing groups? I don't see what they add to the pattern. <code>'([a-z\*]*\*[a-z\*]*)+'</code> seems to yield the same result.</span>
<span class="comment-copy">They aren't absolutely necessary. I use them due to force of habit to design for scalability. As long as <code>(?:\*)</code>, <code>\*</code>, or <code>[\*]+</code>, appears in the middle, it should work fine as you mention.</span>
<span class="comment-copy">Note that this will match the word "star" with no asterisk since you are matching any of either a word character or asterisk but it does not require both of those to be present in the match.</span>
<span class="comment-copy">@benvc you’re right. Thanks for catching that.</span>
<span class="comment-copy">Note that this will match the word "star" with no asterisk since you are matching any of either a word character or asterisk but it does not require both of those to be present in the match, but OP's expected output excludes the word "star".</span>
<span class="comment-copy">Ah, I didn't read the question clearly. Thanks. So, you can change with this <code>(\w*\*+\w*)+</code></span>
