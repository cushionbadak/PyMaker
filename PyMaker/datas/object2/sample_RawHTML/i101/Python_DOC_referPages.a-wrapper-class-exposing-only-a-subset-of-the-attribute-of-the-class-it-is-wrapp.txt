<div class="post-text" itemprop="text">
<p>I was wondering if there is a more elegant way of exposing attributes of the wrapped class other than what I have now:</p>
<pre><code>class WrapperClass:
    EXPOSED_ATTRIBUTES = ["a"]

    def __init__(self):
        self.wrapped_class = Foo()

    def print_a(self):
        print(f"The value of a is :{self.wrapped_class.a}")

    def __getattr__(self, item):
        if item in self.EXPOSED_ATTRIBUTES:
            return getattr(self.wrapped_class, item)
        elif item in self.__dict__:
            return getattr(self, item)
        else:
            raise AttributeError


class Foo:
    def __init__(self):
        self.a = 1
        self.b = 2
</code></pre>
<p>EDIT: It seems like I wasn't clear in my intentions. The purpose of the wrapper class is to create the boundary between my code, and a third party library. I simply want to decrease the number of attributes, and methods exposed to my code.</p>
</div>
<div class="post-text" itemprop="text">
<p>If all you're trying to do with the wrapper class is limit the number of exposed fields, you should take advantage of Python's ability to generate classes dynamically. That is, create a factory that generates new classes with only the exposed fields available on them.</p>
<p>Currently, the <code>EXPOSED_ATTRIBUTES</code> lookup is using an array and is (relatively) slower than a direct lookup since it has to iterate the entire array each time <code>__getattr_()</code> is called, to ensure the attribute is exposed. By generating a class dynamically, your access times will be the same as any other class and it will handle all the <code>AttributeError</code> exceptions for you.</p>
<p>You can use the <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer"><code>type(name, bases, attributes)</code></a> command to create new types (aka: classes). In your case, you could write a simple factory function like this:</p>
<pre><code>def wrap(wrapped, name, exposed_attributes=[]):
  attributes = {attr:wrapped[attr] for attr in exposed_attributes}
  return type(name, (object,), attributes)
</code></pre>
<p>This would be used like this</p>
<pre><code>class SomeClass(object):
  def __init__(self):
    self.name = 'Joe Blow'
    self.age  = 27

WrappedClass = wrap(SomeClass, 'WrappedClass', ['name'])
wrapped_class = WrappedClass()
wrapped_class.name # 'Joe Blow'
wrapped_class.age  # AttributeError

# another wrapper on the same class
AnotherWrappedClass = wrap(SomeClass, 'AnotherWrappedClass', ['age'])
another_wrapped_class = AnotherWrappedClass()
wrapped_class.age  # 27
wrapped_class.name # AttributeError
</code></pre>
<p>In the code we use a dictionary comprehension to build a dict of attributes. Each attribute points to an attribute on the wrapped class. The new type is returned and you can then create instances of it. Only the exposed fields exist on the new class so trying to access any other attribute throws an <code>AttributeError</code> like you'd expect.</p>
</div>
<span class="comment-copy">You're asking a question that skirts very closely to an opinion and could result in suggestions, rather than answers. What are you hoping to get out of this?</span>
<span class="comment-copy">Why donâ€™t you use a property for a? Do you want to dynamically define which attributes to forward for which class? Currently, your setup is entirely static and trivial - you can just write the forwarding explicitly.</span>
