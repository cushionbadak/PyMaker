<div class="post-text" itemprop="text">
<p>From the pymunk examples I've seen that there's a difference between the pymunk coordinates and pygame coordinates. Also, that pymunk is meant just for the 2D physics, while pygame is for rendering objects/sprites on the screen.  </p>
<p>So when searching for how to build an environment where the camera follows the player, people (including me) end up <a href="https://www.sololearn.com/Discuss/1144458/please-who-knows-how-does-a-2d-camera-in-a-side-scroller-is-implemented" rel="nofollow noreferrer">getting confused</a>. I've seen the examples <a href="https://stackoverflow.com/questions/14354171/add-scrolling-to-a-platformer-in-pygame">here</a>, <a href="https://gamedev.stackexchange.com/questions/105532/pygame-implementing-a-scrolling-camera">here</a>, <a href="https://stackoverflow.com/questions/19073382/pygame-infinite-scrolling-camera">here</a> and <a href="https://stackoverflow.com/questions/31041480/using-scrolling-camera-in-pygame">here</a> (even surprised that nobody answered <a href="https://stackoverflow.com/questions/53507912/how-to-camera-scroll-python-pygame">this</a>), but given the number of questions related to the same topic being asked repeatedly, I honestly feel the answers do not adequately explain the concept and request that the simplest possible example be shown to the community, where all the code is explained with comments.  </p>
<p>I've worked in 3D environments like OGRE and OSG where the camera was a proper concept that could be defined with a view frustum, but I'm surprised the 2D world does not have a pre-defined function for it. So:  </p>
<p><strong>If not in the official tutorials of pymunk or pygame, at least could a simple example be provided (with a pymunk body as the player and few pymunk bodies in the world) as an answer here, where a player moves around in a 2D pymunk+pygame world and the camera follows the player?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>OK, I'll try to make this simple (I assume basic pygame knowledge).</p>
<p>First, let's start with something basic. A little sprite that you can move around the world:</p>
<pre><code>import pygame
import random

class Player(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.image = pygame.Surface((32, 32))
        self.image.fill(pygame.Color('dodgerblue'))
        self.rect = self.image.get_rect()
        self.pos = pygame.Vector2((100, 200))

    def update(self, events, dt):
        pressed = pygame.key.get_pressed()
        move = pygame.Vector2((0, 0))
        if pressed[pygame.K_w]: move += (0, -1)
        if pressed[pygame.K_a]: move += (-1, 0)
        if pressed[pygame.K_s]: move += (0, 1)
        if pressed[pygame.K_d]: move += (1, 0)
        if move.length() &gt; 0: move.normalize_ip()
        self.pos += move*(dt/5)
        self.rect.center = self.pos

def main():
    pygame.init()
    screen = pygame.display.set_mode((500, 500))
    clock = pygame.time.Clock()
    dt = 0
    player = Player()
    sprites = pygame.sprite.Group(player)
    background = screen.copy()
    background.fill((30, 30, 30))
    for _ in range(1000):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        pygame.draw.rect(background, pygame.Color('green'), (x, y, 2, 2))

    while True:
        events = pygame.event.get()
        for e in events:
            if e.type == pygame.QUIT:
                return
        sprites.update(events, dt)
        screen.blit(background, (0, 0))
        sprites.draw(screen)
        pygame.display.update()
        dt = clock.tick(60)

if __name__ == '__main__':
    main()
</code></pre>
<p><a href="https://i.stack.imgur.com/3l8cO.gif" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/3l8cO.gif"/></a></p>
<p>Nothing crazy so far.</p>
<hr/>
<p>So, what is a "camera"? It's just a <code>x</code> and an <code>y</code> value we use to move the entire "world" (e.g. everything that is not UI). It's an abstraction between the coordinates of our game objects and the screen.</p>
<p>In our example above, when a game object (the player, or the background) wants to be drawn at position <code>(x, y)</code>, we draw them at the screen at this very position.</p>
<p>Now, if we want to move around a "camera", we simply create another <code>x, y</code>-pair, and add this to the game object's coordinates to determine the actual position on the screen. We start to distinguish between <em>world coordinates</em> (what the game logic thinks where the position of an object is) and the <em>screen coordinates</em> (the <em>actual</em>) position of an object on the screen.</p>
<p>Here's our example with a "camera" ("camera" in quotes) because it's really just two values:</p>
<pre><code>import pygame
import random

class Player(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.image = pygame.Surface((32, 32))
        self.image.fill(pygame.Color('dodgerblue'))
        self.rect = self.image.get_rect()
        self.pos = pygame.Vector2((100, 200))

    def update(self, events, dt):
        pressed = pygame.key.get_pressed()
        move = pygame.Vector2((0, 0))
        if pressed[pygame.K_w]: move += (0, -1)
        if pressed[pygame.K_a]: move += (-1, 0)
        if pressed[pygame.K_s]: move += (0, 1)
        if pressed[pygame.K_d]: move += (1, 0)
        if move.length() &gt; 0: move.normalize_ip()
        self.pos += move*(dt/5)
        self.rect.center = self.pos

def main():
    pygame.init()
    screen = pygame.display.set_mode((500, 500))
    clock = pygame.time.Clock()
    dt = 0
    player = Player()
    sprites = pygame.sprite.Group(player)
    # the "world" is now bigger than the screen
    # so we actually have anything to move the camera to
    background = pygame.Surface((1500, 1500))
    background.fill((30, 30, 30))

    # a camera is just two values: x and y
    # we use a vector here because it's easier to handle than a tuple
    camera = pygame.Vector2((0, 0))

    for _ in range(3000):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        pygame.draw.rect(background, pygame.Color('green'), (x, y, 2, 2))

    while True:
        events = pygame.event.get()
        for e in events:
            if e.type == pygame.QUIT:
                return

        # copy/paste because I'm lazy
        # just move the camera around
        pressed = pygame.key.get_pressed()
        camera_move = pygame.Vector2()
        if pressed[pygame.K_UP]: camera_move += (0, 1)
        if pressed[pygame.K_LEFT]: camera_move += (1, 0)
        if pressed[pygame.K_DOWN]: camera_move += (0, -1)
        if pressed[pygame.K_RIGHT]: camera_move += (-1, 0)
        if camera_move.length() &gt; 0: camera_move.normalize_ip()
        camera += camera_move*(dt/5)

        sprites.update(events, dt)

        # before drawing, we shift everything by the camera's x and y values
        screen.blit(background, camera)
        for s in sprites:
            screen.blit(s.image, s.rect.move(*camera))

        pygame.display.update()
        dt = clock.tick(60)

if __name__ == '__main__':
    main()
</code></pre>
<p><a href="https://i.stack.imgur.com/A5bH6.gif" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/A5bH6.gif"/></a></p>
<p>Now you can move the camera with the arrow keys.</p>
<p>That's it. We just move everything a little bit before blitting it to the screen.</p>
<p>For a more complete example (supporting sprites, stopping at the edge of the world, smooth movement), see this <a href="https://stackoverflow.com/questions/14354171/add-scrolling-to-a-platformer-in-pygame">question</a>.</p>
<hr/>
<p>And for using pymunk: it just works. It's not affected by drawing stuff to another position, since it works with the <em>world coordinates</em>, not the <em>screen coordinates</em>. The only pitfall is that pymunk's y-axis is flipped compared to pygame's y-axis, but you probably know this already.</p>
<p>Here's an example:</p>
<pre><code>import pygame
import random
import pymunk

class Player(pygame.sprite.Sprite):
    def __init__(self, space):
        super().__init__()
        self.space = space
        self.image = pygame.Surface((32, 32))
        self.image.fill(pygame.Color('dodgerblue'))
        self.rect = self.image.get_rect()
        self.pos = pygame.Vector2((100, 200))
        self.body = pymunk.Body(1,1666)
        self.body.position = self.pos
        self.poly = pymunk.Poly.create_box(self.body)
        self.space.add(self.body, self.poly)

    def update(self, events, dt):
        pressed = pygame.key.get_pressed()
        move = pygame.Vector2((0, 0))
        if pressed[pygame.K_w]: move += (0, 1)
        if pressed[pygame.K_a]: move += (-1, 0)
        if pressed[pygame.K_s]: move += (0, -1)
        if pressed[pygame.K_d]: move += (1, 0)
        if move.length() &gt; 0: move.normalize_ip()
        self.body.apply_impulse_at_local_point(move*5)

        # if you used pymunk before, you'll probably already know
        # that you'll have to invert the y-axis to convert between
        # the pymunk and the pygame coordinates.
        self.pos = pygame.Vector2(self.body.position[0], -self.body.position[1]+500)
        self.rect.center = self.pos

def main():
    pygame.init()
    screen = pygame.display.set_mode((500, 500))
    clock = pygame.time.Clock()
    dt = 0

    space = pymunk.Space()
    space.gravity = 0,-100

    player = Player(space)
    sprites = pygame.sprite.Group(player)

    # the "world" is now bigger than the screen
    # so we actually have anything to move the camera to
    background = pygame.Surface((1500, 1500))
    background.fill((30, 30, 30))

    # a camera is just two values: x and y
    # we use a vector here because it's easier to handle than a tuple
    camera = pygame.Vector2((0, 0))

    for _ in range(3000):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        pygame.draw.rect(background, pygame.Color('green'), (x, y, 2, 2))

    while True:
        events = pygame.event.get()
        for e in events:
            if e.type == pygame.QUIT:
                return

        # copy/paste because I'm lazy
        # just move the camera around
        pressed = pygame.key.get_pressed()
        camera_move = pygame.Vector2()
        if pressed[pygame.K_UP]: camera_move += (0, 1)
        if pressed[pygame.K_LEFT]: camera_move += (1, 0)
        if pressed[pygame.K_DOWN]: camera_move += (0, -1)
        if pressed[pygame.K_RIGHT]: camera_move += (-1, 0)
        if camera_move.length() &gt; 0: camera_move.normalize_ip()
        camera += camera_move*(dt/5)

        sprites.update(events, dt)

        # before drawing, we shift everything by the camera's x and y values
        screen.blit(background, camera)
        for s in sprites:
            screen.blit(s.image, s.rect.move(*camera))

        pygame.display.update()
        dt = clock.tick(60)
        space.step(dt/1000)

if __name__ == '__main__':
    main()
</code></pre>
<p><a href="https://i.stack.imgur.com/ONQkK.gif" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/ONQkK.gif"/></a></p>
<hr/>
<p>Note that when you use <code>pymunk.Space.debug_draw</code>, you won't be able to translate the world coordinates to screen coordinates, so it would be best to simply draw the pymunk stuff to another <code>Surface</code>, and <em>translate</em> that very <code>Surface</code>.</p>
<p>Here's pymunk's <code>pygame_util_demo.py</code> with a moving camera:</p>
<pre><code>import sys

import pygame
from pygame.locals import *

import pymunk
from pymunk.vec2d import Vec2d
import pymunk.pygame_util

import shapes_for_draw_demos

def main():
    pygame.init()
    screen = pygame.display.set_mode((1000,700)) 
    pymunk_layer = pygame.Surface((1000,700))
    pymunk_layer.set_colorkey((12,12,12))
    pymunk_layer.fill((12,12,12))
    camera = pygame.Vector2((0, 0))
    clock = pygame.time.Clock()
    font = pygame.font.SysFont("Arial", 16)

    space = pymunk.Space()

    captions = shapes_for_draw_demos.fill_space(space)

    # Info
    color = pygame.color.THECOLORS["black"]

    options = pymunk.pygame_util.DrawOptions(pymunk_layer)

    while True:
        for event in pygame.event.get():
            if event.type == QUIT or \
                event.type == KEYDOWN and (event.key in [K_ESCAPE, K_q]):  
                return 
            elif event.type == KEYDOWN and event.key == K_p:
                pygame.image.save(screen, "pygame_util_demo.png")                

        # copy/paste because I'm lazy
        pressed = pygame.key.get_pressed()
        camera_move = pygame.Vector2()
        if pressed[pygame.K_UP]: camera_move += (0, 1)
        if pressed[pygame.K_LEFT]: camera_move += (1, 0)
        if pressed[pygame.K_DOWN]: camera_move += (0, -1)
        if pressed[pygame.K_RIGHT]: camera_move += (-1, 0)
        if camera_move.length() &gt; 0: camera_move.normalize_ip()
        camera += camera_move*5

        screen.fill(pygame.color.THECOLORS["white"])
        pymunk_layer.fill((12,12,12))
        space.debug_draw(options)
        screen.blit(pymunk_layer, camera)
        screen.blit(font.render("Demo example of pygame_util.DrawOptions()", 1, color), (205, 680))
        for caption in captions:
            x, y = caption[0]
            y = 700 - y
            screen.blit(font.render(caption[1], 1, color), camera + (x,y))
        pygame.display.flip()

        clock.tick(30)

if __name__ == '__main__':
    sys.exit(main())
</code></pre>
<p><a href="https://i.stack.imgur.com/bnKSk.gif" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/bnKSk.gif"/></a></p>
</div>
<span class="comment-copy">Thanks. The explanation was helpful. I think it's the verbal statement of pymunk's coordinates that would be a lot clearer to newbies if it could be shown in code where the player is a pymunk body and there are few other pymunk bodies on the screen.</span>
<span class="comment-copy">@Nav I added a simple pymunk example.</span>
<span class="comment-copy">Brilliant! You've shown how to control the player and camera separately. This is going to become a valuable reference for everyone. I'll try creating a tutorial based on this. Thank you.</span>
<span class="comment-copy">A great answer @Sloth.  Why do you divide <code>dt</code> by <code>5</code> when using it for movement?  (<code>dt</code> is calculated by <code>clock.tick()</code>, and is the time used between frames, in milliseconds).</span>
<span class="comment-copy">@Kingsley just to slow it down. Try changing the value and see the effect. Diving dt by 5 ist arbitary choosen.</span>
