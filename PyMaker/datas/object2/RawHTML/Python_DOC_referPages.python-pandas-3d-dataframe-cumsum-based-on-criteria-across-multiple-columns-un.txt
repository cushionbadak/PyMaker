<div class="post-text" itemprop="text">
<p>I am having some difficulty getting the cumulative sum of a 3D dataframe in python. </p>
<p>A sample dataframe I created is:</p>
<pre><code>import numpy as np
import pandas as pd

arr=np.array([[[23, 10],
        [ 24,  5],
        [ 28,  8],
        [ 30, 11],
        [ 31, 1]],

       [[20, 11],
        [21, 3],
        [22, 5],
        [29, 15],
        [30, 10]],

       [[22, 26],
        [23, 29],
        [25, 32],
        [33, 10],
        [34, 15]]])

names = ['x', 'y', 'z']
index = pd.MultiIndex.from_product([range(s)for s in arr.shape], names=names)
df = pd.DataFrame({'Day': arr.flatten()}, index=index)['Day']
df = df.unstack(level='z')
df.columns = ['Price', 'Qty']
df.index.names = ['DATE', 'i']
</code></pre>
<p>Within a specified range of dates, I want to find the sum of the quantity of items if the price is cheaper than a certain value (x). But I will stop when the sum is exceeds a certain figure (y), regardless of whether there are still any in other shops or later dates that meet the min. price criteria. I will start summing up first from the earliest date and on each date, start summing from the lowest price. Then I will find the weighted average price up until the stopping point.</p>
<p>In the above dataframe, say my criteria are (1) Dates 0 and 1, (2) Prices equal to or below 25, (3) Stop when the sum of quantity first exceeds 20. In this case, the relevant data are price 23 and 24 in Date 0, and price 20 in Date 1. This is because the sum of qty for price 23 and 24 in Date 0 is 15, thus less than 20 but adding the qty for price 20 in Date 1, the cumsum becomes 26 and hence the process stops. The weighted average is thus (23*10)+(24*5)+(20*5) / 20</p>
<p>My current method is too cumbersome by using while loops to go through the time axis, and use another while loop for each date such that if the price is cheaper than my criteria, I will add the quantity and price-weighted quantity to a tracking sum. When the tracking sum is greater than a value specified, I will stop the process and compute the weighted average. I can also then return the position where the process stops. </p>
<p>Would love to get some advice on how this can be achieved in a more efficient way?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a custom function that does this, just plug in your variables as in the example.</p>
<pre><code>def weighted_average(df, dates, price_limit, stop_sum):
    # filter multiindex for your dates, plus price_limits
    tmp = df.loc[dates].loc[df['Price'] &lt;= price_limit]
    # find index of halting cumsum condition, take tmp until there
    tmp = tmp.loc[:(tmp['Qty'].cumsum() &gt; stop_sum).idxmax()]
    # update last value
    tmp.iat[-1, df.columns.get_loc('Qty')] -= tmp['Qty']sum() - stop_sum
    # return the weighted average
    return tmp.product(axis=1).sum() / stop_sum

dates = [0, 1]
price_limit = 25
stop_sum = 20

weighted_average(df, dates, price_limit, stop_sum)
&gt; 22.5
</code></pre>
<p>A (possibly more performant, for a big dataset) alternative to the filter (<code>tmp = df.loc[dates].loc[df['Price'] &lt;= price_limit]</code>) is</p>
<pre><code>tmp = df[(df.index.get_level_values(0).isin(dates)) &amp; (df['Price'] &lt;= price_limit)]
</code></pre>
</div>
<span class="comment-copy">Easily done, but you'll be far more likely to get an answer if you supply an  <a href="https://stackoverflow.com/help/mcve">MCVE</a> with desired output</span>
<span class="comment-copy">Hi Josh, thank you for the advice. I have now included a code to generate a sample dataframe and put some numbers on the desired output. Hopefully that will help make things clearer?</span>
<span class="comment-copy">Hi Josh, thank you very much for this! It definitely gets me almost to where i wanted. To answer your question, the reason I divide by 20 is because my stop_sum is 20, hence for Date 1 Price 20, I only count 5 as the quantity instead of the 11 indicated in the df, thus my weighted average includes 20*5 instead of 20*11 and then i divide the entire weighted sum by 20. I will try to work with the code you provided to get to that state but thanks for providing a good starting point!</span>
<span class="comment-copy">OK got it. So in that case you can just divide by stop_sum, since you'll always reach it. Edited accordingly. Glad it helped!</span>
<span class="comment-copy">Thanks Josh. What I still need to change is to replace the last qty (qty for price 20) to be 5 instead of the original 11.That way the weighted average will be computed correctly. I am thinking of doing it like this:  <code>tmp['Qty'][-1]= stop_sum - tmp['Qty'][:-1].sum()</code>  Do you think that is efficient enough or there is a better way to do that?</span>
<span class="comment-copy">better to use <code>iloc</code> (or <code>iat </code>, which is specifically for scalars) for changing values, I've edited the code to show this</span>
<span class="comment-copy">Hi Josh, thank you once again for this. I realise that sometimes, stop_sum is greater than the cumsum of the ['Qty'] column. In those cases, I will just get the last row instead. However,  <code>tmp = tmp.loc[:(tmp['Qty'].cumsum() &gt; stop_sum).idxmax()]</code> currently returns the first row. Are you able to advice how I can get the last row id in this special case but continue to use  <code>tmp = tmp.loc[:(tmp['Qty'].cumsum() &gt; stop_sum).idxmax()]</code> for the rest?</span>
