<div class="post-text" itemprop="text">
<p>I use the following simple Python script to compress a large text file (say, <strong>10GB</strong>) on an EC2 m3.large instance. However, I always got a <code>MemoryError</code>:</p>
<pre><code>import gzip

with open('test_large.csv', 'rb') as f_in:
    with gzip.open('test_out.csv.gz', 'wb') as f_out:
        f_out.writelines(f_in)
        # or the following:
        # for line in f_in:
        #     f_out.write(line)
</code></pre>
<p>The traceback I got is:</p>
<pre><code>Traceback (most recent call last):
  File "test.py", line 8, in &lt;module&gt;
    f_out.writelines(f_in)
MemoryError
</code></pre>
<p>I have read some discussion about this issue, but still not quite clear how to handle this. Can someone give me a more understandable answer about how to deal with this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>That's odd. I would expect this error if you tried to compress a large binary file that didn't contain many newlines, since such a file could contain a "line" that was too big for your RAM, but it shouldn't happen on a line-structured .csv file.</p>
<p>But anyway, it's not very efficient to compress files line by line. Even though the OS buffers disk I/O it's generally <em>much</em> faster to read and write larger blocks of data, eg 64 kB.</p>
<p>I have 2GB of RAM on this machine, and I just successfully used the program below to compress a 2.8GB tar archive. </p>
<pre><code>#! /usr/bin/env python

import gzip
import sys

blocksize = 1 &lt;&lt; 16     #64kB

def gzipfile(iname, oname, level):
    with open(iname, 'rb') as f_in:
        f_out = gzip.open(oname, 'wb', level)
        while True:
            block = f_in.read(blocksize)
            if block == '':
                break
            f_out.write(block)
        f_out.close()
    return


def main():
    if len(sys.argv) &lt; 3:
        print "gzip compress in_file to out_file"
        print "Usage:\n%s in_file out_file [compression_level]" % sys.argv[0]
        exit(1)

    iname = sys.argv[1]
    oname = sys.argv[2]
    level = int(sys.argv[3]) if len(sys.argv) &gt; 3 else 6

    gzipfile(iname, oname, level)


if __name__ == '__main__':  
    main()
</code></pre>
<p>I'm running Python 2.6.6 and <code>gzip.open()</code> doesn't support <code>with</code>.</p>
<hr/>
<p>As Andrew Bay notes in the comments, <code>if block == '':</code> won't work correctly in Python 3, since <code>block</code> contains bytes, not a string, and an empty bytes object doesn't compare as equal to an empty text string. We <em>could</em> check the block length, or compare to <code>b''</code> (which will also work in Python 2.6+), but the simple way is <code>if not block:</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem here has nothing to do with gzip, and everything to do with reading line by line from a 10GB file with no newlines in it:</p>
<blockquote>
<p>As an additional note, the file I used to test the Python gzip functionality is generated by fallocate -l 10G bigfile_file. </p>
</blockquote>
<p>That gives you a 10GB sparse file made entirely of 0 bytes. Meaning there are no newline bytes. Meaning the first line is 10GB long. Meaning it will take 10GB to read the first line. (Or possibly even 20 or 40GB, if you're using pre-3.3 Python and trying to read it as Unicode.)</p>
<p>If you want to copy binary data, don't copy line by line. Whether it's a normal file, a <code>GzipFile</code> that's decompressing for you on the fly, a <code>socket.makefile()</code>, or anything else, you will have the same problem.</p>
<p>The solution is to copy chunk by chunk. Or just use <a href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobj" rel="noreferrer"><code>copyfileobj</code></a>, which does that for you automatically.</p>
<pre><code>import gzip
import shutil

with open('test_large.csv', 'rb') as f_in:
    with gzip.open('test_out.csv.gz', 'wb') as f_out:
        shutil.copyfileobj(f_in, f_out)
</code></pre>
<p>By default, <code>copyfileobj</code> uses a chunk size optimized to be often very good and never very bad. In this case, you might actually want a smaller size, or a larger one; it's hard to predict which a priori.* So, test it by using <code>timeit</code> with different <code>bufsize</code> arguments (say, powers of 4 from 1KB to 8MB) to <code>copyfileobj</code>. But the default 16KB will probably be good enough unless you're doing a lot of this.</p>
<p><sub>* If the buffer size is too big, you may end up alternating long chunks of I/O and long chunks of processing. If it's too small, you may end up needing multiple reads to fill a single gzip block.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>It is weird to get a memory error even when reading a file line by line. I suppose it is because you have very little available memory and very large lines. You should then use binary reads :</p>
<pre><code>import gzip

#adapt size value : small values will take more time, high value could cause memory errors
size = 8096

with open('test_large.csv', 'rb') as f_in:
    with gzip.open('test_out.csv.gz', 'wb') as f_out:
        while True:
            data = f_in.read(size)
            if data == '' : break
            f_out.write(data)
</code></pre>
</div>
<span class="comment-copy">What is the exact error with Mark's solution ? It cannot be on <code>f_out.writelines</code>, since you use <code>write</code> ...</span>
<span class="comment-copy">The error will be like this: <code>Traceback (most recent call last):   File "test.py", line 8, in &lt;module&gt;     for line in f_in: MemoryError</code></span>
<span class="comment-copy">Thanks for your answer, it's clear and works very well:)</span>
<span class="comment-copy">As an additional note, the file I used to test the Python gzip functionality is generated by <code>fallocate -l 10G bigfile_file</code>. Python can not gzip such big files by the file iteratable (it seems to be a bug since long time ago?).</span>
<span class="comment-copy">@shihpeng: I'm not familiar with <code>fallocate</code>, so this is just a guess, but maybe Python's gzip doesn't like such files because they don't contain any actual data. I can't test it since I'm still using ext3 on this system, which doesn't support <code>fallocate</code>. However, my program works ok using a big file created using <code>truncate</code>, which creates sparse files.</span>
<span class="comment-copy">"Even though the OS buffers disk I/O it's generally much faster to read and write larger blocks of data, eg 64 kB." <code>GzipFile</code> uses buffered I/O (either C stdio buffers in Python 2.x, or Python <code>io</code> buffers in 3.x). It only read from disk when it tries to uncompress another zlib block and that block goes beyond the buffer. So it's already doing everything you're trying to do here. The only difference is that you're using a larger blocksize; if that actually helps, you can just open the file manually and construct a <code>GzipFile</code> from it instead of using <code>gzip.open</code>.</span>
<span class="comment-copy">In Python 3.x, instead of using the <code>if block == ''</code> use the length of the block to determine if the block is empty. This is due to the fact that the string is unicode and cannot be compared to the block.</span>
<span class="comment-copy">Yes, m3.large only have 2 vcpu and 7gb memory, which is very limited if there are some other processes or servers running on the same instance.</span>
<span class="comment-copy">This only copies the first 8KB.</span>
<span class="comment-copy">@abarnert You are right ! Fixed...</span>
<span class="comment-copy">Now it will loop forever, writing empty strings forever after EOF.</span>
<span class="comment-copy">@SergeBallesta: You should see some of the 180-line monstrosities I've written and spent hours debugging only to realize I'd duplicated something that came with the stdlib for free. :)</span>
