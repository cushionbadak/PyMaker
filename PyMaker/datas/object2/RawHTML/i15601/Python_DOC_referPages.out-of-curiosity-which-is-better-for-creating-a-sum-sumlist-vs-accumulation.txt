<div class="post-text" itemprop="text">
<p>I am calculating the total distance of a route (for a traveling salesman problem) and I am curious about which is better:  summing a list of integers, or using total += value (not sure what the technical term for this is.. concatenation I believe?).  In other words:</p>
<pre><code>totalDistance = [distance(location, location+1) for location in route]
return sum(totalDistance)
</code></pre>
<p>or</p>
<pre><code>totalDistance = 0
for location in route:
    totalDistance += distance(location, location+1)
return totalDistance
</code></pre>
<p>distance() returns an <code>int</code> value, and the number of locations varies between about 0 to 100 for different routes.
Thoughts on either method (or a completely different way) appreciated!</p>
<p>Edit:</p>
<p>Accumulation , not Concatenation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not use a <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression" rel="nofollow">generator expression</a> with <code>sum</code>:</p>
<pre><code>return sum(distance(location, location+1) for location in route)
</code></pre>
<p>This solution avoids creating an unnecessary list like the first solution (saves on memory consumption) and is also a lot more concise than the second (cleanliness counts).</p>
<p>That said, you could always merge the first solution into a one-liner:</p>
<pre><code>return sum([distance(location, location+1) for location in route])
</code></pre>
<p>But then, as I said above, why create a list just to throw it away?</p>
</div>
<div class="post-text" itemprop="text">
<p>Best is to just use a generator expression with <code>sum</code></p>
<pre><code>return sum(distance(location, location+1) for location in route)
</code></pre>
<p>This saves the overhead of creating a list.
totalDistance = [distance(location, location+1) for location in route]</p>
<p>The <code>for</code> loop version also doesn't create a list. It's fine, just a little verbose compared to using <code>sum</code>. <code>sum</code> exists precisely for cases like this</p>
<p>How does <code>location+1</code> work? Seems like it should be the next item from route</p>
<hr/>
<p>For interest I compared @iCodez examples in PyPy 2.2.1. First run of each function is to allow the JIT to compile the function</p>
<pre><code>&gt;&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt;&gt; def f():
....     number = 0
....     for i in range(100):
....         number += 1
.... 
&gt;&gt;&gt;&gt; timeit(f)
0.3245859146118164
&gt;&gt;&gt;&gt; timeit(f)
0.2913198471069336

&gt;&gt;&gt;&gt; def g():
....     lst = [i for i in range(100)]
....     sum(lst)
.... 
&gt;&gt;&gt;&gt; timeit(g)
0.8840188980102539
&gt;&gt;&gt;&gt; timeit(g)
0.8698201179504395

&gt;&gt;&gt;&gt; def h():
....     sum(i for i in range(100))
.... 
&gt;&gt;&gt;&gt; timeit(h)
2.8281970024108887
&gt;&gt;&gt;&gt; timeit(h)
2.8702847957611084
</code></pre>
<p>Wow..genexp performance is much worse</p>
</div>
<div class="post-text" itemprop="text">
<p>On my machine, iterate through a generator is slower than a list:</p>
<pre><code>from timeit import timeit

# just for simulation
def distance(la, lb):
    return abs(la-lb)

# for simulation, too    
def route():
    return xrange(10000)

# the longer(code) and faster but wasteful(memory) way
def longer_faster_wasteful():
    return sum([distance(location, location+1) for location in route()])

# the shorter(code) and saving(memory) but slower way
def shorter_slower_saving():
    return sum(distance(location, location+1) for location in route())

# print 2.01163072818 on my machine
print timeit(longer_faster_wasteful, number=100)

# print 2.91834802689 on my machine
print timeit(shorter_slower_saving, number=100)
</code></pre>
</div>
<span class="comment-copy">I think you mean <i>accumulation</i> instead of <i>concatenation</i>. What do you mean by <i>better</i>, faster?</span>
<span class="comment-copy">That's the word I was looking for!  And by better, I guess I mean faster, cleaner and less intensive on memory.</span>
<span class="comment-copy">"Faster" can be profiled, but my money's on the list comp. "Cleaner" is subjective -- people like to see things differently. "Memory-intensive" is most definitely summing a generator expression e.g. <code>total_dist = sum(distance(location, location+1) for location in route)</code></span>
<span class="comment-copy">@AdamSmith, why do you think generator expressions are more memory intensive than lists? (apart from very small lists)</span>
<span class="comment-copy">@josibake, <code>+=</code> generally works differently for mutable vs immutable objects. <code>int</code> are immutable, so it's necessary to create a new object each time (There are exceptions - such as small ints in cpython).</span>
<span class="comment-copy">Did you profile this? I had the impression that list comprehensions/generator expressions where in general faster than <code>for</code> loops.</span>
<span class="comment-copy">I like this.. I didn't realize you could sum a generator expression all on the same line!</span>
<span class="comment-copy">I think the generator expression is faster</span>
<span class="comment-copy">@PadraicCunningham - True, my inputs were small.  I went and ran the tests again and got mixed results, so I'm guessing that something interfered before (not sure what though). I'm going to take down my comments on speed for now.  gnibbler's answer though shows that my statements were at least correct in PyPy. :*)</span>
<span class="comment-copy">@josibake - It is reassigning the name <code>number</code> 100 times.  But as gnibbler's test shows, it is still the fastest solution for some implementations such as PyPy.  Others however have the generator expression as the fastest (the comments on my answer show this).  However, placing speed aside, the list comprehension creates an unnecessary list (wastes memory) and the for-loop is unnecessarily verbose as well as a little tedious to type.  Thus, I would still use the generator expression.</span>
<span class="comment-copy">That wasn't my actual code - just kind of a rough idea.  What I have written is <code>distance(locations[i], locations[i+1] for i in range(len(locations)-1)</code></span>
