<div class="post-text" itemprop="text">
<p>This is more or less how I would track the number of class instances, since <code>__new__</code> is called every time one is made:</p>
<pre><code>class MyClass():
    def __new__(klass):
        try:
            klass.__instances = klass.__instances + 1
        except NameError:
            klass.__instances = 1
        return super(MyClass,klass).__new__(klass)
</code></pre>
<p>Is there a magic method that is called when a new reference to a <em>specific instance</em> of a class is made? If not, is there a straight forward way to implement one? For example: </p>
<pre><code>class MyClass():
    def __init__(self):
        self.__ref = 1
        print(self,"created.")
    def __new_reference(self):
        self.__ref = self.__ref + 1
        print("Reference to",self,"added.")
    def __del_reference(self):
        self.__ref = self.__ref - 1
        print("Reference to",self,"deleted.")
</code></pre>
<p>So now:</p>
<pre><code>L1 = []
L2 = []
L1.append(MyClass()) #&lt;MyClass object&gt; created
L1[0].__ref          #1
L2.append(L1[0])     #Reference to &lt;MyClass object&gt; added.
L2[0].__ref          #2
L1.pop(0)            #Reference to &lt;MyClass object&gt; deleted.
L2[0].__ref          #1
</code></pre>
<p>Edit:</p>
<p><a href="https://stackoverflow.com/questions/27051119/automatically-delete-class-instance-when-one-of-its-attributes-becomes-dead/27053247">Here's the problem</a> I thought I would try to solve using reference tracking. </p>
<p>My idea is to have an object <code>A</code> instance that contains multiple (weak) references to object <code>B</code>s. There is a separate list containing all valid <code>B</code>s. There is a list of all the <code>A</code>s as well (thousands). The desired behavior is that when any one <code>B</code> is removed from the <code>B</code> list, for any object <code>A</code> to become <code>None</code> if it contained a reference to that particular <code>B</code> removed from the <code>B</code> list. </p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I know there is no magic method that does this, but maybe you could use <a href="https://docs.python.org/3/library/sys.html#sys.getrefcount" rel="nofollow"><code>sys.getrefcount()</code></a>:</p>
<blockquote>
<p>Return the reference count of the object. The count returned is generally one higher than you might expect, because it includes the (temporary) reference as an argument to <code>getrefcount()</code>.</p>
</blockquote>
<p>Using your example:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; class MyClass: pass
... 
&gt;&gt;&gt; L1 = []
&gt;&gt;&gt; L2 = []
&gt;&gt;&gt; L1.append(MyClass())
&gt;&gt;&gt; sys.getrefcount(L1[0])
2
&gt;&gt;&gt; L2.append(L1[0])
&gt;&gt;&gt; sys.getrefcount(L1[0])
3
&gt;&gt;&gt; del L1[0]
&gt;&gt;&gt; sys.getrefcount(L2[0])
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I just thought of a simple way to almost accomplish this, and it's probably good enough for my situation. </p>
<p>All I have to do is be sure to call the object every time it is referenced. This isn't quite as neat and tidy as I was hoping for, but it does allow tracking of the number of references <em>that I'm interested in</em> (though it does not track <em>all</em> references). </p>
<p>Here's a code sample to illustrate:</p>
<pre><code>class MyClass():
    def __init__(self):
        self._ref = 1
        print(self,"created.")
    def __call__(self, new_ref=True):
        if new_ref is True: self.__new_reference()
        elif new_ref is False: self.__del_reference()
        return self
    def __new_reference(self):
        self._ref = self._ref + 1
        print("Reference to",self,"added.")
    def __del_reference(self):
        self._ref = self._ref - 1
        print("Reference to",self,"deleted.")
</code></pre>
<p>Now I can do this:</p>
<pre><code>L1 = []
L2 = []
L1.append(MyClass())   #&lt;MyClass object&gt; created.
print(L1[0]._ref)      #1
L2.append(L1[0](True)) #Reference to &lt;MyClass object&gt; added.
print(L2[0]._ref)      #2
L1.pop(0)(False)       #Reference to &lt;MyClass object&gt; deleted.
print(L2[0]._ref)      #1
</code></pre>
<p>I just have to remember to call my special object every time I add or delete it. </p>
<p>Alternatively, I could subclass a special container class for the special objects that calls the object with the appropriate argument when it is added or removed. Not sure if it's worth the effort to do this though. </p>
</div>
<span class="comment-copy">The short answer is no, there is not.  Objects don't get to know what references them.  Why do you feel you need this?</span>
<span class="comment-copy">I believe this is the sort of thing that would more often be handled using the Observer pattern (Events and event handlers). <a href="http://stackoverflow.com/questions/1092531/event-system-in-python/1092617#1092617" title="event system in python">stackoverflow.com/questions/1092531/event-system-in-python/â€¦</a> That is, a <code>B</code> can implement a <code>__del__</code> method which notifies all the <code>A</code>s that reference it. When <code>A</code> is created it can register itself with all the <code>B</code> that is has references to. And so on for the containers that have references to an <code>A</code>.</span>
<span class="comment-copy">I am profoundly ignorant when it comes to design patterns. Time to learn! This is a wonderful suggestion thank you.</span>
<span class="comment-copy"><code>sys.getrefcount</code> and its ilk are the nearest thing, but you'd have to constantly poll them in a loop or something in order to "monitor" new references to a particular object.</span>
<span class="comment-copy">sounds like i should find another approach to my problem, then. thanks!</span>
<span class="comment-copy">It's worth it!  Otherewise you'll spend a bunch of time trying to find the spot where you forgot.  ;)</span>
