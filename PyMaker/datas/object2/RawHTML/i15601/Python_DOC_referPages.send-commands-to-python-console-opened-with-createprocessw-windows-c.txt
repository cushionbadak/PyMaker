<div class="post-text" itemprop="text">
<p>I try to redirect in windows the cmd.exe stdout&amp;stdin (with CreateProcess()). It works fine as long as I run simple commands or open GUI apps, but if I try running a software like python, it does not give me it's output anymore (nor getting the input through stdin).</p>
<p>Code example:</p>
<p><div class="snippet" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>#include &lt;windows.h&gt; 
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;

using namespace std;

HANDLE child_input_read;
HANDLE child_input_write;
HANDLE child_output_read;
HANDLE child_output_write;

void writeToPipe()
{
	while (true)
	{
		DWORD bytes_written;
		string msg;
		getline(cin, msg);
		msg += '\n';
		BOOL success = WriteFile(child_input_write, msg.c_str(), msg.size(), &amp;bytes_written, NULL);
		if (!success)
		{
			break;
		}
	}
}
void readFromPipe()
{
	while (true)
	{
		DWORD bytes_read;
		char buffer[512];
		BOOL success = ReadFile(child_output_read, buffer, sizeof(buffer)-1, &amp;bytes_read, NULL);
		buffer[bytes_read] = 0;
		if (!success)
		{
			break;
		}
		cout &lt;&lt; buffer;
	}
}
void createCmdProcess()
{
	PROCESS_INFORMATION process_info;
	STARTUPINFO startup_info;
	SECURITY_ATTRIBUTES security_attributes;

	// Set the security attributes for the pipe handles created 
	security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	security_attributes.bInheritHandle = TRUE;
	security_attributes.lpSecurityDescriptor = NULL;
	CreatePipe(&amp;child_output_read, &amp;child_output_write, &amp;security_attributes, 0);
	CreatePipe(&amp;child_input_read, &amp;child_input_write, &amp;security_attributes, 0);

	// Create the child process
	ZeroMemory(&amp;process_info, sizeof(PROCESS_INFORMATION));
	ZeroMemory(&amp;startup_info, sizeof(STARTUPINFO));
	startup_info.cb = sizeof(STARTUPINFO);
	startup_info.hStdInput = child_input_read;
	startup_info.hStdOutput = child_output_write;
	startup_info.hStdError = child_output_write;
	startup_info.dwFlags |= STARTF_USESTDHANDLES;
	CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &amp;startup_info, &amp;process_info);
}

int main()
{
	createCmdProcess();
	thread t(writeToPipe);
	thread t2(readFromPipe);
	t.join();
	t2.join();
	system("pause");
}</code></pre>
</div>
</div>
</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not a bug, it's a feature. :-)</p>
<p>From <a href="https://docs.python.org/3/using/cmdline.html#interface-options" rel="nofollow noreferrer">Python Setup &amp; Usage, section 1.1.1, Interface options</a> (emphasis added):</p>
<blockquote>
<p>The interpreter interface resembles that of the UNIX shell, but provides some additional methods of invocation:</p>
<p>When called with standard input <strong>connected to a tty device</strong>, it prompts for commands and executes them until an EOF (an end-of-file character, you can produce that with Ctrl-D on UNIX or Ctrl-Z, Enter on Windows) is read.</p>
<p>When called with a file name argument <strong>or with a file as standard input</strong>, it reads and executes a script from that file.</p>
</blockquote>
<p>A pipe is neither a file nor a tty device, but it looks like a file as far as the C standard library (and hence Python) is concerned.  So the second behaviour kicks in, and Python attempts to read to the end of file.  Since we never close our end of the pipe, that never happens.</p>
<p>This behaviour isn't particularly sensible in my opinion (or at least not in Windows) and you could file a bug if you wanted.  I would guess that such a proposal would be rejected, since any change would break backwards compatibility, but I could be wrong.</p>
<p>You can work around the problem by providing the <code>-i</code> option on the command line:</p>
<pre><code>python -i
</code></pre>
<p>That makes Python enter interactive mode, despite the fact that stdin isn't a terminal.</p>
<p><a href="https://stackoverflow.com/questions/11516258/what-is-the-equivalent-of-unbuffer-program-on-windows">Unfortunately, there is no known way to make a pipe that looks like a terminal on Windows.</a></p>
</div>
<span class="comment-copy">By default, a console process gets the same stdin and stdout as its parent.  However, there's no way to force a process to use the stdin and stdout that it's been given.  I'd be surprised if Python misbehaved in this respect, though; are you sure you're running the console version?  Where does the output actually wind up?</span>
<span class="comment-copy">I'm sure I run the cmd.exe, but there is simply no output when I start python.</span>
<span class="comment-copy">If I start the cmd.exe from run and call python it works, but if I redirect cmd output it doesn't. I don't think the version of python has anything to do with the problem.</span>
<span class="comment-copy">Thank you Harry for your replies so far. I've edited my post and included the code (a sample which also doesn't work for me). It's compiled with visual c++ 2013, and running in win8.1.</span>
<span class="comment-copy">OK, I think I see what you mean; <code>cmd.exe</code> works, and so do Python commands, but Python's interactive mode doesn't.</span>
