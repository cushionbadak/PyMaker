<div class="post-text" itemprop="text">
<p>The structure of my modules: </p>
<pre><code>foo: 
  - load()  # from DB


bar:
  - check() # with user
  - take_action() 
</code></pre>
<p>I want to test take_action (which basically loads values and checks with user before taking action) by mocking both load and check.</p>
<p>Here are the mocks: </p>
<pre><code>mock_load  = Mock(side_effects=[&lt;&gt;, &lt;&gt;, &lt;&gt;]) # different data sets
mock_check = Mock(return_value=True)  # User approval
</code></pre>
<p>How do I use patch.multiple to achieve this? </p>
<pre><code>with patch.multiple(??):
    # proceed to test
    take_action
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The short answer is no you cannot use <code>patch.multiple()</code> to do it. As described in <a href="https://docs.python.org/3/library/unittest.mock.html#patch-multiple" rel="noreferrer">patch.multiple</a> all arguments will be applied to all created mocks and all arguments MUST be attribute of the same object. You MUST do it one of the time by single patch calls.</p>
<p>Unfortunately you are using python 2.6 so you can use just <code>nested</code> fron <code>contextlib</code> like pointed in <a href="https://stackoverflow.com/questions/3024925/python-create-a-with-block-on-several-context-managers/3025119#3025119">python: create a "with" block on several context managers</a> and <a href="https://stackoverflow.com/questions/7745164/multiple-context-with-statement-in-python-2-6/7745206#7745206">Multiple context `with` statement in Python 2.6</a>.</p>
<p>Maybe the more cleaner and simple way to do it is use <code>@patch</code> as decorator:</p>
<pre><code>@patch("foo.load",side_effects=["a","b","c"])
@patch("bar.check",return_value=True)
def test_mytest(mock_check,mock_load):
    take_action()
    assert mock_load.called
    assert mock_check.called
</code></pre>
<p>If you need it in all tests of a test class you can decorate the class and use the mocks in all test methods:</p>
<pre><code>@patch("foo.load",side_effects=["a","b","c"])
@patch("bar.check",return_value=True)
class TestMyTest(unittest.TestCase)
    def test_mytestA(self,mock_check,mock_load):
        take_action()
        self.assertTrue(mock_load.called)
        self.assertTrue(mock_check.called)

    def test_mytestA(self,mock_check,mock_load):
        mock_check.return_value = False
        take_action()
        self.assertTrue(mock_load.called)
        self.assertTrue(mock_check.called)
</code></pre>
<p>Finally you can do it by using <code>with</code> and <code>contextlib</code> and the first example become:</p>
<pre><code>from contextlib import nested

with nested(patch("foo.load",side_effects=["a","b","c"]), patch("bar.check",return_value=True)) as (mock_load, mock_check):
    take_action()
    assert mock_load.called
    assert mock_check.called
</code></pre>
<p>... Or nest it by hand ....</p>
<pre><code>with patch("foo.load",side_effects=["a","b","c"]) as mock_load:
    with patch("bar.check",return_value=True)) as mock_check:
        take_action()
        assert mock_load.called
        assert mock_check.called
</code></pre>
<p>My feel is that decorators are the most readable and simple to use.</p>
</div>
<span class="comment-copy">python (2.6) (--------)</span>
