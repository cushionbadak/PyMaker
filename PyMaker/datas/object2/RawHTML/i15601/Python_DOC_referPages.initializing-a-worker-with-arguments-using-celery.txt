<div class="post-text" itemprop="text">
<p>I'm having issues finding something that seems like it would be relatively simple to me. </p>
<p>I'm using Celery 3.1 with Python 3 and am wanting to initialize my workers with arguments so that they can use these details for setup.</p>
<p>In specific: These workers will be consuming tasks which require interacting with a third-party API using authentication credentials. It's necessary for the worker to pass the authentication details to API server prior to consuming any tasks (authentication details are stored in cookies after the first authentication request).</p>
<p>I would like to pass these login credentials to the worker when it is started from the CLI. I would then like the worker to authenticate using them and store the session for use when consuming future tasks (ideally this would be stored in an attribute that can be accessed from tasks). </p>
<p>Is this possible with Celery?</p>
<p>As a side note, I have considered passing a <code>requests.session</code> object (from the Python <code>requests</code> library) as a task argument but that would require serializing which looks like is frowned upon.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest using an abstract task base class and caching the <code>requests.session</code>.</p>
<p>From the Celery docs:</p>
<blockquote>
<p>A task is not instantiated for every request, but is registered in the task registry as a global instance.</p>
<p>This means that the __init__ constructor will only be called once per process, and that the task class is semantically closer to an Actor.</p>
<p>This can also be useful to cache resources...</p>
</blockquote>
<pre><code>import requests
from celery import Task

class APITask(Task):
    """API requests task class."""

    abstract = True

    # the cached requests.session object
    _session = None

    def __init__(self):
        # since this class is instantiated once, use this method
        # to initialize and cache resources like a requests.session
        # or use a property like the example below which will create
        # a requests.session only the first time it's accessed

    @property
    def session(self):
        if self._session is None:
            # store the session object for the first time
            session = requests.Session()
            session.auth = ('user', 'pass')

            self._session = session

        return self._session
</code></pre>
<p>Now when you create the tasks that will make API requests:</p>
<pre><code>@app.task(base=APITask, bind=True)
def call_api(self, url):
    # self will refer to the task instance (because we're using bind=True)
    self.session.get(url)
</code></pre>
<p>Also you can pass the API authentication options using the <code>app.task</code> decorator as an extra argument which will be set on the <code>__dict__</code> of the task, for example:</p>
<pre><code># pass a custom auth argument
@app.task(base=APITask, bind=True, auth=('user', 'pass'))
def call_api(self, url):
    pass
</code></pre>
<p>And make the base class use the passed authentication options:</p>
<pre><code>class APITask(Task):
    """API requests task class."""

    abstract = True

    # the cached requests.session object
    _session = None

   # the API authentication
   auth = ()

    @property
    def session(self):
        if self._session is None:
            # store the session object for the first time
            session = requests.Session()
            # use the authentication that was passed to the task
            session.auth = self.auth

            self._session = session

        return self._session
</code></pre>
<p>You can read more on the Celery docs site:</p>
<ul>
<li><a href="http://celery.readthedocs.org/en/latest/userguide/tasks.html#instantiation">Tasks Instantiation</a></li>
<li><a href="http://celery.readthedocs.org/en/latest/userguide/tasks.html#abstract-classes">Task Abstract Classes</a></li>
</ul>
<p>Now back to your original question which is passing extra arguments to the worker from the command line:</p>
<p>There is a section about this in the Celery docs <a href="http://celery.readthedocs.org/en/latest/userguide/extending.html#adding-new-command-line-options">Adding new command-line options</a>, here's an example of passing a username and a password to the worker from the command line:</p>
<pre><code>$ celery worker -A appname --username user --password pass
</code></pre>
<p>The code:</p>
<pre><code>from celery import bootsteps
from celery.bin import Option


app.user_options['worker'].add(
    Option('--username', dest='api_username', default=None, help='API username.')
)

app.user_options['worker'].add(
    Option('--password', dest='api_password', default=None, help='API password.')
)


class CustomArgs(bootsteps.Step):

    def __init__(self, worker, api_username, api_password, **options):
        # store the api authentication
        APITask.auth = (api_username, api_password)


app.steps['worker'].add(CustomArgs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would think you could call the script you wrote using command line arguments. Something like the following:</p>
<pre><code>my_script.py username password
</code></pre>
<p>Inside your script, you can have your main function wrapped in an <code>@celery.task</code> or <code>@app.task</code> decorator. </p>
<pre><code>import sys

from celery import Celery

cel = Celery() # put whatever config info you need in here

@celery.task
def main():
    username, password = sys.argv[1], sys.argv[2]
</code></pre>
<p>Something like that should get you started. Be sure to also check out Python's <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow">argparse</a> for more sophisticated argument parsing.</p>
</div>
<span class="comment-copy">Excellent, I was having a hard time deciphering all that from the documentation. Thanks for laying it out so well.</span>
<span class="comment-copy">Sorry to dig this up one more time, would you be able to clarify how to pass the command-line arguments from the Boostep to the task initialization (so that I can initialize the Task session object with the username and password provided from the command-line). The goal is to not store my API credentials in plain-text.</span>
<span class="comment-copy">@JoshuaGilman sorry for the delay, I updated the answer with an example.</span>
<span class="comment-copy">@Pierre I have something similar requirement as this question have where I want to attach some additional property to wroker instead of Task, here is link to stack overflow question <a href="http://stackoverflow.com/questions/42834227/accessing-celery-worker-instance-inside-the-task" title="accessing celery worker instance inside the task">stackoverflow.com/questions/42834227/â€¦</a></span>
<span class="comment-copy">Thanks, but you can't start a worker process by calling the python script. You must invoke celery like so: <code>celery -A proj worker -l info</code></span>
<span class="comment-copy">We must have a really strange setup here then...because that's how it looked like it worked. I'll have to study what we're doing some more.</span>
