<div class="post-text" itemprop="text">
<p>I am working on a chat program. But right now it can only except one client. How would I make it to where it can accept two clients? I am still a bit of a noob when it comes to sockets so can you explain very thoroughly?</p>
<p>Server Code:</p>
<pre><code>import socket

def mainFunc():
    host = ""
    port = 50000

    ipList = []
    nickNameList = []
    num = True

    s = socket.socket()
    s.bind((host, port))

    s.listen(1)
    c, addr = s.accept()

    print("Connection from: " + str(addr) + "\n")
    ipList.insert(0, str(addr))

    while True:
        data = c.recv(1024)
        if not data:
            break

        if num == True:
            nickNameList.insert(0, str(data))
            num = False
        else:
            print("From " + nickNameList[0] + ": " + str(data) + "\n")

            message = raw_input("Message you want to send: ")
            print("\n")

            c.send(message)

    c.close()
</code></pre>
<p>I have tried changing the s.listen(1) to s.listen(2). But that did not seem to allow a second person to connect. Can someone explain why?</p>
</div>
<div class="post-text" itemprop="text">
<p>One call to <code>accept</code> accepts one connection. To accept two connections, call <code>accept</code> twice.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want two connections in sequence, but never more than one at a time, you just need a loop around the <code>c, addr = s.accept()</code> and everything that follows it. Then it'll accept one connection, handle it until the socket closes and your <code>break</code> executes, then handle the second connection, and so on.</p>
<p>In this case, the <code>listen</code> backlog—the 2 in your <code>s.listen(2)</code>—means it'll queue up no more than 2 waiting connections while you're processing the first one; anyone after that will get rejected.</p>
<hr/>
<p>If you want two simultaneous connections, you have to do one of two things:</p>
<ul>
<li>Multithreading, with a thread for each connection. (Multiprocessing, and magic green-threading a la <code>gevent</code>, are basically the same idea.)</li>
<li>Multiplexing, with a reactor or proactor handling non-blocking or asynchronous I/O for all of the connections instead of just directly calling a socket with a single connection. (There are many variations on this idea, from coroutine schedulers like <code>asyncio</code> to simple loops around <code>select</code>.)</li>
</ul>
<p>In this case, the <code>listen</code> backlog is really only important if your program is too slow to keep up with connections as they come in. When that happens, it's usually better to refuse new connections than to accept them and slow things down even further, so keeping a small backlog is a good idea.</p>
<p>But since your connection handler blocks on <code>raw_input</code> after each socket messages, this is going to be a weird design, to say the least. (Not the blocking part—you can fix that by assigning a thread, <code>select</code> entry, coroutine, etc. to stdin. But what actually <em>happens</em> with the input. You've got 8 connections, and only 1 input. Which connection gets the result when the user types something?)</p>
<hr/>
<p>Here's a simple threaded server:</p>
<pre><code>def connection(c, addr):
    while True:
        # your existing while True loop

while True:
    c, addr = s.accept()
    t = threading.Thread(target=connection, args=(c, addr))
    t.start()
</code></pre>
<p>However, for a realistic server that you want to be able to shut down in some way, you're going to want to provide some way to shut down the connection threads. Also, for servers that interact between clients (like sending one user's chat messages to all of the other users), you need some way to pass messages between the threads, or to share information between them. Often you end up needing two threads per connection—one to block on <code>c.recv</code>, and another one to block on a queue and call <code>c.send</code> with other users' messages.</p>
<hr/>
<p>For a multiplexing server, the different approaches look very different, but there are good examples for all of them. See <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow"><code>asyncio</code></a>, <a href="https://docs.python.org/3/library/selectors.html" rel="nofollow"><code>selectors</code></a> for their examples, <a href="https://docs.python.org/3/howto/sockets.html" rel="nofollow">Socket Programming HOWTO</a> for the <code>select</code> examples, and Google for examples for third-party libraries like Twisted, gevent, etc.</p>
<hr/>
<p>As a side note, you seem to be expecting that <code>send</code> is guaranteed to send an entire message in one go, and that the other side's <code>recv</code> will receive that entire message and nothing else. TCP guarantees no such thing. See <a href="http://stupidpythonideas.blogspot.com/2013/05/sockets-are-byte-streams-not-message.html" rel="nofollow">Sockets are byte streams, not message streams</a> for more details.</p>
<p>Also, in <code>nickNameList.insert(0, str(data))</code>, what is the <code>str</code> for? In Python 2.x, <code>data</code> is already a <code>str</code>, so this just wastefully makes an extra copy for no good reason. In Python 3.x, <code>data</code> is a <code>bytes</code>, so this converts that into its string representation, like <code>"b'0Cool'"</code> instead of <code>"0Cool"</code>, which is almost certainly not what you want.</p>
</div>
<span class="comment-copy">I don't know if you can use <code>SocketServer</code>... Just in case, you might wanna take a look to this: <a href="https://docs.python.org/2/library/socketserver.html#asynchronous-mixins" rel="nofollow noreferrer">docs.python.org/2/library/socketserver.html#asynchronous-mixins</a></span>
<span class="comment-copy">You want both connections simultaneously, or in sequence?</span>
<span class="comment-copy">@abarnert One user will connect and the other can connect anytime. Which is what I was having problems with.</span>
<span class="comment-copy">@0Cool: If the other user can connect anytime, while the first one is already connection, you can't just have your whole program blocking forever on the first user's <code>c.recv</code>, or on <code>raw_input</code>, or you're not dealing with the other user. This is why you need multithreading or multiplexing.</span>
<span class="comment-copy">Where would I add the second accept? Because the clients do not connect at the same time. Will that affect it any?</span>
<span class="comment-copy">That totally depends on your goals. You may want to wait until all clients connected before handling them, or have an accept-handle-close in a loop, or something completely different.</span>
<span class="comment-copy">Could you show me a minimal example please?</span>
<span class="comment-copy">@0Cool: Of which of the three possibilities? They're very different.</span>
<span class="comment-copy">The first one where you loop until all people are conencted</span>
<span class="comment-copy">@0Cool: No, that's not what the first one does. The first one loops until the first user is done and disconnected, then accepts the second user and loops until he's done, and so on. Is that actually what you want? Or do you want all people connected at the same time? Because in that case, you can't use the first one.</span>
<span class="comment-copy">Can you show me a example of the first one then please?</span>
