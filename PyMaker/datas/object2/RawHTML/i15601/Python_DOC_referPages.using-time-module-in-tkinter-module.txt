<div class="post-text" itemprop="text">
<pre><code>from tkinter import *

import time

root = Tk()

class Cycle(Frame):

    def __init__(self):
        Frame.__init__(self)
        self.master.title("Cycle")
        self.grid()
        self.__pic1 = PhotoImage(file = "Bar.png")
        self.__pic2 = PhotoImage(file = "bell.gif")
        self.__pic1Label = Label(image = self.__pic1)
        self.__pic2Label = Label(image = self.__pic2)
        self.__pic1Label.grid(row=0, column=0)
        time.sleep(1)
        self.__pic2Label.grid(row=0, column=0)

Cycle()
</code></pre>
<p>Instead of displaying the first image, waiting a second, and displaying the second image over the first one, it waits a second and then the box pops up and displays both at the same time.  </p>
</div>
<div class="post-text" itemprop="text">
<p><code>time.sleep</code> cannot be called in the same thread as the Tkinter event loop is operating in.  It will block Tkinter's loop and thereby cause the program to freeze.</p>
<p>You should be using the <a href="http://effbot.org/tkinterbook/widget.htm#Tkinter.Widget.after-method" rel="nofollow"><code>.after</code></a> method to schedule the operation to run in the background after 1000 milliseconds (or one second):</p>
<pre><code>self.after(1000, lambda: self.__pic2Label.grid(row=0, column=0))
</code></pre>
<p>Also, I used a <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-lambda_expr" rel="nofollow">lambda expression</a> for the sake of brevity.  However, <code>.after</code> accepts normal function objects as well:</p>
<pre><code>self.after(1000, self.my_method)
</code></pre>
</div>
<span class="comment-copy">Thanks so much :)</span>
