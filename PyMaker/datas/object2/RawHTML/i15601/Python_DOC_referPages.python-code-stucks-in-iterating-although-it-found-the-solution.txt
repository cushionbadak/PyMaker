<div class="post-text" itemprop="text">
<p>I'm trying to write a python code to find the prime factors of any given number  </p>
<pre><code>def pf(n):
    for i in range(2,n):
        if n%i==0: #find the factors
            for j in range(2,i): #check if the factor is prime
                if i%j==0:
                    break
            else: #find the prime ones
                print(i)
</code></pre>
<p>My problem is that this code works fine with small numbers however with big numbers i have to interrupt the execution<br/>
for example:  </p>
<pre><code>pf(600851475143)
71
839
1471
6857
Traceback (most recent call last):
  File "&lt;pyshell#11&gt;", line 1, in &lt;module&gt;
    pf(600851475143)
  File "&lt;pyshell#1&gt;", line 2, in pf
    for i in range(2,n):
KeyboardInterrupt  
</code></pre>
<p>the prime factors of this big number were found in less than a second, so my question is how to tweak <strong>this</strong> code to stop unnecessary iterations after finding the factors with the use of the <em>for</em> not the <em>while</em> loop</p>
</div>
<div class="post-text" itemprop="text">
<p>You can speed things up by dividing <code>n</code> by the obtained value in each iteration step. This way you decrease the number you are iterating. I would implement something like this (not yet sure if this is optimal and results in the lowest number of operations):</p>
<pre><code>from math import sqrt

def pf(n):
    if n == 1: 
        return
    if n % 2 == 0:
        print(2)
        pf(n/2)
        return
    for i in range(3, int(sqrt(n))+1, 2):
        if n % i == 0:
            for j in range(3, int(sqrt(i))+1, 2):
                if i % j == 0:
                    break
            else:
                print(i)
                pf(n/i)
                return
    print(n)
</code></pre>
<p>Note, if using the improvement of looping until the root of the number we omit the case that the number itself is a prime number. However, if the function does not result any prime factors it is save to assume that the input is a prime number itself. </p>
<p>The <code>return</code> statements stop the main loop (and the function) after the recursive call. So each call of the function only results in one value and a call for the function on the result of the division of the number by its found prime.</p>
<p>If you make a set with all the prime numbers and check if the value is in this set you will win some time, instead of looping over all values.</p>
<p>Compared to the <a href="https://stackoverflow.com/a/27148932/3001761">non-recursive solution by jonrsharpe</a> this one is almost four times as fast:</p>
<pre><code>&gt;&gt;&gt; print timeit.timeit("pf(600851475143)", setup="from __main__ import pf", number=1)
71
839
1471
6857
0.00985789299011
&gt;&gt;&gt; print timeit.timeit("pf2(600851475143)", setup="from __main__ import pf2", number=1)
71
839
1471
6857
0.0450129508972
</code></pre>
<p>The implementation is limited by the overflow limit of <code>range()</code>, which results in an overflow for the input value <code>(600851475143**2)+1</code>. More details on the maximum size for <code>range</code> can be found in this question:  <a href="https://stackoverflow.com/questions/3247973/python-range-maximum-size-dynamic-or-static">Python: Range() maximum size; dynamic or static?</a></p>
<p>A possible issue with this solution could be that the maximum recursion depth is achieved. For more details on that visit this question: <a href="https://stackoverflow.com/questions/3323001/maximum-recursion-depth">Maximum recursion depth</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could try adding prime factors to a list as you find them, and see if they multiply to make the number you are trying to factorize, but I think that might add more time than it would save.</p>
<p>As suggested in the comments, you could also stop at the square root of the number - using <code>for i in range(2, sqrt(n) + 1):</code>.</p>
<p>In terms of generally speeding it up you could also try creating a set of primes, and adding to it when you find them in the 5th line. Example:</p>
<pre><code>if i in primes:
   print(i)
else:
    for j in range(2,i):   # check if the factor is prime
        if i%j==0:
            break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One further point - use xrange() rather than range(), so you do not internally create the list of all numbers to iterate: (if you are using Python 2 !)</p>
<p><a href="https://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x">What is the difference between range and xrange functions in Python 2.X?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>just iterate square root of value, this is how you can iterate through less nombers and
use <code>generators</code> to skip repeated iteration usinf <code>for else</code></p>
<pre><code>from math import sqrt
def pf(n):
    n = int(sqrt(n))
    for i in xrange(2, n): # in python2 use `range` for python3
        for j in xrange(2,i):
            if i%j == 0:
                break
        else:
            yield i # this will return when prime nomber will found.

print list(pf(4356750))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's how I would do it:</p>
<pre><code>from math import sqrt

def pf(n):
    """Print the prime factors of n."""
    if n % 2 == 0:
        print(2)
    for i in range(3, int(sqrt(n))+1, 2):
        if n % i == 0: # i is a factor of n
            for j in range(3, int(sqrt(i))+1, 2):
                if i % j == 0:
                    break
            else: # i is also prime
                print(i)
</code></pre>
<p>By factoring out the checks for <code>2</code> you can almost halve the search space, and using the fact that all prime factors must be below the square root of a number you cut it down even further. This takes about a quarter of a second for <code>600851475143</code>:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit("pf(600851475143)", setup="from __main__ import pf", number=1)
71
839
1471
6857
0.27306951168483806
</code></pre>
<p>Another option would be to use a prime sieve to generate all primes below <code>n</code>, then filter out those that are also factors of <code>n</code> (effectively the reverse operation).</p>
</div>
<span class="comment-copy">Well how do you know you <i>have</i> found all the prime factors? For a start, note that you can stop at e.g. <code>sqrt(i)</code>, and that <code>2</code> is the only even prime.</span>
<span class="comment-copy">because no matter you wait it's the same result, after 1 second or 30 minutes</span>
<span class="comment-copy">You could start by finding the factors of very small numbers and see if it works there</span>
<span class="comment-copy">@Dear_user sorry, I mean: <i>"how do you decide <b>programatically</b> that you've found them all?"</i> To tell a computer to do something, you need to be able to do it yourself. You <i>could</i> code that if no more have been found in some defined time period, stop there, for example - that would be how to model your current thought process.</span>
<span class="comment-copy">@jonrsharpe: i got you the 1st time, i can't know that it found them all, for this one by testing only</span>
<span class="comment-copy">i used this trick too when i used to list the answers in a list and it took a long time too</span>
<span class="comment-copy">@tvandenbrande testing for e.g. <code>pf(360)</code> (hint: or any even <code>n</code>) causes <code>UnboundLocalError: local variable 'i' referenced before assignment</code>. Also, you will hit the recursion limit for numbers with large numbers of prime factors.</span>
<span class="comment-copy">Yes, your revision works fine for me - the recursive approach is very neat. Note that you can make it faster by adopting the <code>range</code> arguments used in my answer - <code>for i in range(3, int(sqrt(n))+1, 2):</code> and <code>for j in range(3, int(sqrt(i)+1), 2):</code>. Also, using <code>for: else:</code> (see <a href="https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops" rel="nofollow noreferrer">docs.python.org/3/tutorial/â€¦</a>) is neater than having a <code>prime</code> flag. With these revisions I get 0.03s for recursive vs 0.04s for yours unmodified and 0.14s for mine. Note another slight difference - mine prints only unique prime factors.</span>
<span class="comment-copy">I would prefer to get the full decomposition and not the unique primes. This way you can recompose the input and check if your result is correct.  Good hint about the <code>for: else:</code> notation. It even improves speed (from 11.9 ms to 9.9 ms on my system)</span>
<span class="comment-copy">Was googling a bit on your comment (is the prime check necessary) and found this interesting wiki with an example code that is even faster: <a href="http://rosettacode.org/wiki/Prime_decomposition#Python" rel="nofollow noreferrer">rosettacode.org/wiki/Prime_decomposition#Python</a></span>
<span class="comment-copy">and how long the list of primes should be?  and about the sqrt(n) suggestion is relatively helpful (for example what is i want pf(n**2), your first suggestion is the best and i have to write a code to multiply the factors each time and compare it to the number inside the loop</span>
<span class="comment-copy">i am using python3</span>
<span class="comment-copy">The presence of parentheses in the <code>print</code> statement is <i>usually</i> indicative of Python3.</span>
<span class="comment-copy">@Dear_user check the solution.</span>
<span class="comment-copy">Why use <code>xrange</code> for one loop and <code>range</code> for the other?</span>
<span class="comment-copy">for the sqrt it is not always helpful, suppose the original number is squared, and for xrange i am using python3</span>
<span class="comment-copy">@Dear_user still after squaring you will have to search till that nomber, and <code>range</code> is same as <code>xrange</code> in python3.</span>
<span class="comment-copy">@jonrsharpe thanks to remind me.</span>
<span class="comment-copy">thanks this one is helpful for example number (12-digits number) however i tried it for (600851475143**2)+1 and it stuck</span>
<span class="comment-copy">@Dear_user no kidding - that's 3.6e23, for which you have to check through <code>600851475144</code> candidate factors and <code>24</code> actual factors; its <a href="http://www.wolframalpha.com/input/?i=prime+factors+of+(600851475143%2A%2A2)%2B1" rel="nofollow noreferrer">largest prime factor is <code>171015606064053029</code></a>, to determine the primality of which you have to check <code>413540332</code> candidate divisors. If factoring numbers that large were easy, <a href="http://en.wikipedia.org/wiki/Public-key_cryptography" rel="nofollow noreferrer">public-key cryptography</a> would be in serious trouble.</span>
<span class="comment-copy">A problem I noticed, also with my answer is that if n itself is a prime, the result is not included.</span>
<span class="comment-copy">@tvandenbrande this has the same issue - one fix would be to return a list of prime factors, rather than printing within the function; if that's empty, you know <code>n</code> is itself prime. This also makes the function more useful in other contexts.</span>
<span class="comment-copy">i don't have enough rep to vote</span>
