<div class="post-text" itemprop="text">
<p>I have the following string:</p>
<pre><code>&gt;&gt;&gt; x
'Content Type: TV Mini-Series\n\n\n                    &amp;nbsp;-&amp;nbsp;705 min&amp;nbsp;-&amp;nbsp;Action|Drama|History |'
</code></pre>
<p>I want to pull out the value "Mini-Series", without anything before or after it. This is what I have so far:</p>
<pre><code>&gt;&gt;&gt; re.match(r'.+TV Mini-Series', x).group(0)
'Content Type: TV Mini-Series'
</code></pre>
<p>How would I only get the "TV Mini-Series" text?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to search based on <code>Mini-Series</code> and want <code>'TV Mini-Series</code> you can put a possible leading with a space in your pattern .so as <code>TV</code> is upper case letters <code>[A-Z]*</code> could match any combine of uppercase letters before <code>Mini-Series</code>! </p>
<pre><code>&gt;&gt;&gt; re.search(r'[A-Z]* Mini-Series',x).group(0)
'TV Mini-Series'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>re.search</code> would be better suited to this:</p>
<pre><code>&gt;&gt;&gt; re.search(r'TV Mini-Series', x).group(0)
'TV Mini-Series'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Regex seems like an overkill when you can simply use <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow"><code>str.split</code></a>:</p>
<pre><code>&gt;&gt;&gt; x = 'Content Type: TV Mini-Series\n\n\n                    &amp;nbsp;-&amp;nbsp;705 min&amp;nbsp;-&amp;nbsp;Action|Drama|History |'
&gt;&gt;&gt; x.split('\n', 1)[0].split(maxsplit=2)[2]
'TV Mini-Series'
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>re.match(r'.+ (TV Mini-Series)', x).group(1)<br/>
  =&gt; 'TV Mini-Series'</p>
</blockquote>
<p>Note: you want to use group(1) because group(0) is defined to capture the whole string</p>
</div>
<span class="comment-copy"><code>re.match(r'.+TV Mini-Series', x).group(0).split(': ')[1]</code>?</span>
<span class="comment-copy">Just use a normal HTTP parser and forget about buggy solutions, will you?</span>
