<div class="post-text" itemprop="text">
<p>I am trying to write and read as quickly as Python will let me through the serial port. The problem is that I am writing to fast and it is not working. I believe the problem has to do serial buffer and that I might be over writing my input buffer. Can I increase the input and output buffer? Is their any method or function or flag that tells when the buffer is full, empty, or busy? I am trying send these two command over and over and over as quickly as possible</p>
<pre><code>ser = serial.Serial(port=2,baudrate=28800, timeout = 1)
#print ser

ser.flushInput()  #flush input buffer, discarding all its contents
ser.flushOutput() #flush output buffer, aborting current output
                  #and discard all that is in buffer    


ON = ":00000008f8"
PGMMEM0 = ":01f0000011FE" #program one memory location

start = timeit.default_timer()

for i in range(10):

   ser.write(ON)

   end = timeit.default_timer() - start
   print end

   ser.write(PGMMEM0)

   end = timeit.default_timer() - start
   print end
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can use the <a href="http://pyserial.sourceforge.net/pyserial_api.html#serial.Serial.outWaiting" rel="nofollow"><code>Serial.outWaiting()</code></a> method to check how much data is still waiting to be sent.</p>
<p>I'm not sure exactly how the <code>Serial.write()</code> method behaves, if it just adds the data to the internal buffer before returning. It would have to be that way in order for the above to be needed, but on the other hand there's <a href="http://pyserial.sourceforge.net/pyserial_api.html#serial.Serial.nonblocking" rel="nofollow"><code>nonblocking()</code></a> to make it non-blocking. It's a bit confusing.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem may be with the baud rate. You can set up baud rate in the <a href="http://pyserial.sourceforge.net/pyserial_api.html" rel="nofollow">constructor</a>, make sure that both serial link partners are configured:</p>
<pre><code>ser = serial.Serial(baudrate=9600)
</code></pre>
<p>If the delay after <strong>write</strong> operation works, you may create a wrapper class for serial port interaction, for example:</p>
<pre><code>class RS232(object):

  def __init__ (self):
      self.ser = serial.Serial(port=2,baudrate=28800, timeout = 1)

  def write(self,s):
      self.ser.write(s)
      time.sleep(0.5)

myRS232 = RS232()
myRS232.write('whatever')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you run your code on Windows platform, you simply need to add a line in your code</p>
<pre><code>ser.set_buffer_size(rx_size = 12800, tx_size = 12800)
</code></pre>
<p>Where 12800 is an arbitraery number I chose. You can make receiving(rx) and transmitting(tx) buffer as big as 2147483647</p>
<p>See also:</p>
<p><a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow noreferrer">https://docs.python.org/3/library/ctypes.html</a></p>
<p><a href="https://msdn.microsoft.com/en-us/library/system.io.ports.serialport.readbuffersize(v=vs.110).aspx" rel="nofollow noreferrer">https://msdn.microsoft.com/en-us/library/system.io.ports.serialport.readbuffersize(v=vs.110).aspx</a></p>
<p>You might be able to setup the serial port from the DLL
            // Setup serial</p>
<pre><code> mySerialPort.BaudRate = 9600;
 mySerialPort.PortName = comPort;
 mySerialPort.Parity = Parity.None;
 mySerialPort.StopBits = StopBits.One;
 mySerialPort.DataBits = 8;
 mySerialPort.Handshake = Handshake.None;
 mySerialPort.RtsEnable = true;
 mySerialPort.ReadBufferSize = 32768;
</code></pre>
<p>Property Value
Type: System.Int32
The buffer size, in bytes. The default value is 4096; the maximum value is that of a positive int, or 2147483647</p>
<p>And then open and use it in Python</p>
</div>
<span class="comment-copy">Can you post your code here? It would be much easier to help you!</span>
<span class="comment-copy">updated with code</span>
<span class="comment-copy">can you explain how the inWait and outWait works? I dont understand how each of these methods work</span>
<span class="comment-copy">sorry for got to add beginning stuff, I would like baudrate at 28800 because trying to send faster. IF I add 0.5 delay after my writes it works, but I am trying to avoid doing that</span>
<span class="comment-copy">Either select lower speed or specify delay (so the partner device may process it). You may wrap 'read' operation with adding delay and invoke the wrapper once you want to write</span>
<span class="comment-copy">why do I need a delay, because with a virtual port I don't have delays in my code and it works? Can I create a bigger input or output buffer. is their any flags that I can check for when the buffer is busy processing because I don't like putting 0.5s delay because it might be longer depending on the length of instruction?</span>
<span class="comment-copy">What is your partner device?</span>
<span class="comment-copy">I create a usb device with uart-bridge and 8051 microcontroller. I feel confident that this is not a hardware issue but serial buffer issue</span>
