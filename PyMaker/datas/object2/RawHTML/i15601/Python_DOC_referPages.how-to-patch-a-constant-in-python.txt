<div class="post-text" itemprop="text">
<p>I have two different modules in my project. One is a config file which contains</p>
<pre><code>LOGGING_ACTIVATED = False
</code></pre>
<p>This constant is used in the second module (lets call it main) like the following:</p>
<pre><code>if LOGGING_ACTIVATED:
    amqp_connector = Connector()
</code></pre>
<p>In my test class for the main module i would like to patch this constant with the value</p>
<pre><code>True
</code></pre>
<p>Unfortunately the following doesn't work</p>
<pre><code>@patch("config.LOGGING_ACTIVATED", True)
</code></pre>
<p>nor does this work:</p>
<pre><code>@patch.object("config.LOGGING_ACTIVATED", True)
</code></pre>
<p>Does anybody know how to patch a constant from different modules?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the <code>if LOGGING_ACTIVATED:</code> test happens at the <em>module level</em>, you need to make sure that that module is not yet imported first. Module-level code runs just once (the first time the module is imported anywhere), you cannot test code that won't run again.</p>
<p>If the test is in a function, note that the global name used is <code>LOGGING_ACTIVATED</code>, <em>not</em> <code>config.LOGGING_ACTIVATED</code>. As such you need to patch out <code>main.LOGGING_ACTIVATED</code> here:</p>
<pre><code>@patch("main.LOGGING_ACTIVATED", True)
</code></pre>
<p>as that's the actual reference you wanted to replace.</p>
<p>Also see the <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch"><em>Where to patch</em> section</a> of the <code>mock</code> documentation.</p>
<p>You should consider refactoring module-level code to something more testable. Although you can force a reload of module code by deleting the module object from the <code>sys.modules</code> mapping, it is plain cleaner to move code you want to be testable into a function.</p>
<p>So if your code now looks something like this:</p>
<pre><code>if LOGGING_ACTIVATED:
    amqp_connector = Connector()
</code></pre>
<p>consider using a function instead:</p>
<pre><code>def main():
    global amqp_connector
    if LOGGING_ACTIVATED:
        amqp_connector = Connector()

main()
</code></pre>
<p>or produce an object with attributes even.</p>
</div>
<span class="comment-copy">Beat me to it, I was busy trying to figure out whether <code>patch()</code> is capable of patching the <code>__main__</code> module, just in case that is what was meant by "call it main".</span>
<span class="comment-copy">@SteveJessop: for the record: yes it is. <code>__main__</code> is just another module as far as Python is concerned so <code>patch('__main__.somename', somevalue)</code> works.</span>
<span class="comment-copy">thanks for the fast answer. The if statement is indeed on module level.  And in my test class I import the module. So there is no chance to rewrite it for single test methods?</span>
<span class="comment-copy">@d.a.d.a: You can force a reload of the module by deleting it from <code>sys.modules</code>. <code>if 'main' in sys.modules: del sys.modules['main']</code>.</span>
<span class="comment-copy">@d.a.d.a: however, I'd refactor the module to use a function instead, ran from the top-level with a single call. That way you can test the <i>function</i> instead.</span>
