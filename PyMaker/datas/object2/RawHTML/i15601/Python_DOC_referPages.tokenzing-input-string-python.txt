<div class="post-text" itemprop="text">
<p>Okay so I'm asking a follow up question for tokenizing a string. It's almost working however I missing this one edge case.</p>
<p>Right now my function is:</p>
<pre><code>def tokenize(text):
    return re.findall('[\\!"#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~]|\w+', text)
</code></pre>
<p>And it almost does what I want it do except for the input: </p>
<pre><code>&gt;&gt;&gt; tokenize('Break/\\ is almost? ? soon')
Output: ['Break', '/','is', 'almost', '?', '?', 'soon']

Expected Output:
['Break', '/', '\\', 'is', 'almost', '?', '?', 'soon']
</code></pre>
<p>I guess its something to do with escaping but i thought i matched it in my regex. Any suggestions? </p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that the only backslashes inside your character classes are being interpreted as escape characters. The <code>\\!</code> is parsed by Python into <code>\!</code>, and then by the regexp engine into an escaped <code>!</code>. Likewise, the <code>\\]</code> is parsed by Python into <code>\]</code>, and then by the regexp engine into an escaped <code>]</code>. So, there's nothing to match a backslash.</p>
<p>You could double-escape the first backslashes, so the <code>\\\\!</code> will get parsed by Python into <code>\\!</code> and then by the regexp engine into a <code>\</code> followed by a <code>!</code>. Of course you'd leave the <code>\\]</code> alone, because you <em>want</em> that to be parsed as an escaped <code>]</code>. And you'd want to escape the backslash before <code>w</code> as well; you happen to get away with that one because Python (at least as of 2.7 and 3.4) doesn't have a <code>\w</code> escape sequence, but it's not a good idea to count on that.</p>
<p>But really, your life will be a lot easier if you use <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow">raw string literals</a>, to prevent Python from interpreting any backslashes, so you know they all get to the regexp engine. This is explained in the <a href="https://docs.python.org/3/howto/regex.html#the-backslash-plague" rel="nofollow">Regular Expression HOWTO</a>.</p>
<pre><code>re.findall(r'[\\!"#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~]|\w+', text)
</code></pre>
<p>Now, the <code>\\!</code> is not touched by Python, so the regexp engine interprets it as a literal <code>\</code> and a <code>!</code>. Also note that I've removed the double backslash before <code>]</code>, because we <em>don't</em> want to escape that one, we want it to escape the <code>]</code>.</p>
<pre><code>[\\!"#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~]|\w+
</code></pre>
<p><img alt="Regular expression visualization" src="https://www.debuggex.com/i/L_QiCOiBkQfWLndH.png"/></p>
<p><a href="https://www.debuggex.com/r/L_QiCOiBkQfWLndH" rel="nofollow">Debuggex Demo</a></p>
</div>
<div class="post-text" itemprop="text">
<p>off topic but this also works</p>
<pre><code>list(filter(str.strip,re.split('(\W)','Break/\\ is almost? ? soon')))
</code></pre>
</div>
<span class="comment-copy">I must be missing something... what is the difference between the produced output and your expected output? I'm apparently no good at the "Spot the difference" game today.</span>
<span class="comment-copy">If you're having problems with escaping, your life will be a whole lot easier if you use raw string literals. That's what they're for.</span>
<span class="comment-copy">Also, I can see at least one missing escape: <code>\w</code> should be <code>\\w</code>. But you happen to get away with that one, because (at least in 2.7 and 3.4) <code>\w</code> isn't a backslash escape sequence, so that can't be your problem.</span>
<span class="comment-copy">sorry i had messed up the output. updated it now. what do you mean by using raw string literals?</span>
<span class="comment-copy">@user3750474: If you prefix a string literal with <code>r</code>, it leaves all backslashes between the quotes alone, so you can write <code>r'[\!"#$â€¦'</code> and trust that the `` will get through to the regex parser instead of being interpreted by Python itself.</span>
<span class="comment-copy">Great thanks you</span>
<span class="comment-copy">Follow up: Is the a way to treat the input text where you matching against raw string literals?</span>
<span class="comment-copy">@user3750474: I don't understand the followup. If your problem is that the input string is a literal in your Python source code so its backslashes are being escaped, then yes, just stick a <code>r</code> before the open quotes and the problem will go away. If the input string came from somewhere else, it's not a literal; you get the bytes the way they were stored in the file or sent over the socket or calculated by the function or whatever, and there's no way to retroactively change what the editor/server/whatever did from your code. If you have a specific example you might want to create a new question.</span>
