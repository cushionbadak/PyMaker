<div class="post-text" itemprop="text">
<p>I am trying out the <code>map</code> function and it is giving me unexpected output:</p>
<pre><code>map(lambda x: x, range(3))
&lt;builtins.map at 0x7fc3f6c0ab70&gt;
</code></pre>
<p>When I try to call it with <code>map(lambda x: x, range(3))()</code>, it says <code>map</code> is not callable.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think what you're looking for is</p>
<pre><code>&gt;&gt;&gt; list(map(lambda x: x, range(3)))
[0, 1, 2]
</code></pre>
<p><code>map</code> returns an iterator. The message you are seeing is simply the object type for which you have just created an instance</p>
<pre><code>&gt;&gt;&gt; map(lambda x: x, range(3))
&lt;map object at 0x02E11F10&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That is not an error.  </p>
<p>Instead, it is a representation of the <code>map</code> object (an iterator) returned by <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow"><code>map</code> in Python 3.x</a>:</p>
<pre><code>&gt;&gt;&gt; # Python 3.x interpreter
&gt;&gt;&gt; map(lambda x: x, range(3))
&lt;map object at 0x01AAA2F0&gt;
&gt;&gt;&gt; type(map(lambda x: x, range(3)))
&lt;class 'map'&gt;
&gt;&gt;&gt;
</code></pre>
<p>Note that my output is not exactly the same because I am using a different implementation.  Still, the same principle applies.</p>
<p><a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow"><code>map</code> in Python 2.x</a> meanwhile returns a list:</p>
<pre><code>&gt;&gt;&gt; # Python 2.x intepreter
&gt;&gt;&gt; map(lambda x: x, range(3))
[0, 1, 2]
&gt;&gt;&gt;
</code></pre>
<p>But in modern Python, if you want a list result, you need to explicitly convert the <code>map</code> object into one:</p>
<pre><code>&gt;&gt;&gt; # Python 3.x interpreter
&gt;&gt;&gt; list(map(lambda x: x, range(3)))
[0, 1, 2]
&gt;&gt;&gt;
</code></pre>
<p>You can read about this as well as similar changes on Python's <a href="https://docs.python.org/3/whatsnew/3.0.html" rel="nofollow">What's New in Python 3.0</a> page.</p>
</div>
<span class="comment-copy">As of python 3, <code>map</code> is no longer considered 'pythonic' (see <a href="https://docs.python.org/3.0/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="nofollow noreferrer">docs.python.org/3.0/whatsnew/â€¦</a>). The 'correct' implementation would now be a list comprehension; i.e. <code>[x for x in range(3)]</code>.</span>
<span class="comment-copy">@PWhite what is the best solution for lazy evaluation? I want to use <code>yield from</code> and <code>yield from (lambda x: for i in range(x): yield i)()</code> looks ugly</span>
<span class="comment-copy">I'm not sure I understand what you're asking, but <code>yield from (x for x in range(3))</code> works in the context of a generator as the <code>(...)</code> syntax returns a generator.</span>
<span class="comment-copy">@yayu in Python 3.x, <code>range</code> returns a generator, so it already is lazy evaluation, in Python 2.x it used to evaluate the list all at once.</span>
<span class="comment-copy">@Cyber <code>range</code> in 3.x is indeed lazy and in for most intents and purposes can be considered one, but is not, strictly, a generator (it's more similar to a lazy list).</span>
<span class="comment-copy">oh.. that's why I thought it was strange. And all online tutorials were giving me the old behaviour.</span>
<span class="comment-copy">ok, another question.. I know now that its an iterator so I can use next(), can I use <code>yield from</code> with the map object?</span>
<span class="comment-copy">Yes.  Try <code>def f(): yield from map(str, [1, 2, 3])</code> for example.</span>
