<div class="post-text" itemprop="text">
<p>I have a list with keys and I wish to get the key values from a dict as they occur. Momentarily I have a function which takes a list with keys, but it only returns one occurrence for the same key although the same key occurs numerous of times in the list.</p>
<p>For instance <code>[1,2,3]</code> instead of <code>[1,2,2,2,1,1,3,3]</code></p>
<p>Here is my code:</p>
<pre><code>key_list = [1,2,2,2,1,1,3,3]

dict_ = {1:'a', 2:b, 3:'c'}

# current function that only returns one occurence per key in the list with keys, key_list`
def get_values_from_dict(dict_, key_list):
    return [v for k, v in dict_.items() if k in key_list]
</code></pre>
<p>And here is my expected output:</p>
<pre><code>['a', 'b', 'b', 'b', 'a', 'a', 'c', 'c']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your list comprehension should be indexing <code>dict_</code> with each value in <code>key_list</code>:</p>
<pre><code>&gt;&gt;&gt; key_list = [1,2,2,2,1,1,3,3]
&gt;&gt;&gt; dict_ = {1:'a', 2:'b', 3:'c'}
&gt;&gt;&gt; def get_values_from_dict(dict_, key_list):
...     return [dict_[x] for x in key_list]
...
&gt;&gt;&gt; get_values_from_dict(dict_, key_list)
['a', 'b', 'b', 'b', 'a', 'a', 'c', 'c']
&gt;&gt;&gt;
</code></pre>
<p>Your current code is incorrect because it is doing something different: it is getting all the values in <code>dict_</code> that have keys which are in <code>key_list</code>.  In other words, it is filtering the values by <code>key_list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is already built in to the standard library—it's what <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow"><code>itemgetter</code></a> does when you give it multiple keys:</p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt; key_list = [1,2,2,2,1,1,3,3]
&gt;&gt;&gt; dict_ = {1:'a', 2:'b', 3:'c'}
&gt;&gt;&gt; operator.itemgetter(*key_list)(dict)
('a', 'b', 'b', 'b', 'a', 'a', 'c', 'c')
</code></pre>
<p>If you need a list instead of a tuple, just convert it:</p>
<pre><code>&gt;&gt;&gt; list(operator.itemgetter(*key_list)(dict))
['a', 'b', 'b', 'b', 'a', 'a', 'c', 'c']
</code></pre>
<p>From the docs:</p>
<blockquote>
<p>Return a callable object that fetches item from its operand using the operand’s <code>__getitem__()</code> method. If multiple items are specified, returns a tuple of lookup values.</p>
</blockquote>
<p>The cool thing about this is that you can store <code>itemgetter(key_list)</code> and repeatedly apply it to different dictionaries, or pass it as a <code>key</code> function to a <code>sort</code> call, etc. But if you don't need any of that, you can call it directly, as I did above.</p>
<p>The docs also show you how to write the same thing yourself:</p>
<pre><code>tuple(obj[item] for item in items)
</code></pre>
<p>And here, if you want a list, just use a list comprehension instead of a generator expression and the <code>tuple</code> function:</p>
<pre><code>[obj[item] for item in items]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you want is a one-to-one mapping of your input to output, using the dictionary to do the translation/mapping. Hence, you should iterate on your input list not on the dict items. Code below. </p>
<pre><code>def get_values_from_dict(dict_, key_list):
    return [dict_[k] for k in key_list]
</code></pre>
</div>
<span class="comment-copy">What do you mean "<i>momentarily</i> I have a function"?</span>
<span class="comment-copy">Didn't see this one coming. Nice library usage.</span>
