<div class="post-text" itemprop="text">
<p>In languages that use static binding like java you can define multiple functions all having the same name but different parameters. Learning Python, until now I considered the lack of this mainly as "safety issue" (like <code>bool_parameter="False"</code> might be interpreted as <code>True</code> because of the quotes). I thought I would simply need to be more careful.</p>
<p>Now I found a situation, where the lack of static binding is simply inconvenient. Please consider this tupel:</p>
<pre><code>var = ((1, "foo"), (2, "bar"), (3, "potato"))
</code></pre>
<p>To remove an item from <code>var</code> with static binding one could do something like this(pseudocode:</p>
<pre><code>def del_item(int i):
    # search item with (x == i, *)
    # remove this item

def del_item(String s):
    # search item with (*, x == s)
    # remove this item
</code></pre>
<p>I find this very convenient, because no conditions are needed to select the right action to perform. Furthermore this code makes overloading easier, as one can decide to just overload one of the functions or both.</p>
<p>Trying to deal with a situation like this in Python, I only find inconvenient solutions like some if-clauses that check for the type.</p>
<p>Is there a better way?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python doesn't have overloading of methods so you're going to have to check the type of the argument sorry.</p>
<pre><code>def del_item(item):
    if type(item) is int:
        # search item with (x == item, *)
        # remove this item
    elif type(item) is str:
        # search item with (*, x == s)
        # remove this item
    else:
        # Maybe raise an exception?
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>check out this question: <a href="https://stackoverflow.com/questions/1549801/differences-between-isinstance-and-type-in-python">Differences between isinstance() and type() in python</a></p>
<p>If you end up doing the if type approach suggested, you may want to consider duck typing or isinstance alternatives</p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem could be tackled by using generic methods/functions. These don't come built-in with python, but can be roped in by either a 3rd-party library, or you write one yourself.</p>
<p>I have been working happily with PEAK rules a few years ago, but while it should still work, it seems to have fallen out of favour a bit.</p>
<p>The new PEP 443 (single argument dispatch) is accompanied by external implementation, singledispatch. <a href="https://pypi.python.org/pypi/singledispatch/3.4.0.3" rel="nofollow">https://pypi.python.org/pypi/singledispatch/3.4.0.3</a></p>
<p>With that, your problem could be solved like this:</p>
<pre><code> from functools import partial
 from singledispatch import singledispatch


 var = ((1, "foo"), (2, "bar"), (3, "potato"))


 @singledispatch
 def del_predicate(value):
     pass


 @del_predicate.register(int)
 def _(v, candidate):
     return v == candidate[0]

 @del_predicate.register(str)
 def _(v, candidate):
     return v == candidate[1]


 def neg(f):
     def _f(*args):
         return not f(*args)
     return _f

 print filter(neg(partial(del_predicate, "foo")), var)
 print filter(neg(partial(del_predicate, 2)), var)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The particular case you give seems like one where overloading is not needed anyway.</p>
<pre><code>def del_item(id):
    return tuple(item for item in var if not id in item)
</code></pre>
<p>Another option is to use optional keyword arguments</p>
<pre><code>def del_item(string_id=None, number_id=None):
    if string_id is not None:
        return tuple(item for item in var if not item[1] == string_id)
    return tuple(item for item in var if not item[0] == number_id)
</code></pre>
<p>There are lots of previous questions on python overloading, and <a href="https://stackoverflow.com/a/733385/567595">this is one answer</a> that might help understand why it's not seen as a problem not to have it.</p>
</div>
<span class="comment-copy">you could always have the delete operation on a class instead, so you just ask it to delete and it's internals take care of what specific delete is done.</span>
<span class="comment-copy">these are two distinct deletes. The first looks for the first element the second for the second argument. Normally this to deletes occur in totally different situations,so a del_on_first_element and del_on_second_element method is much clearer than type-overloading.</span>
<span class="comment-copy">I like this answer as it points out, that my assumption (it is originally not intended) is in fact the case. However, @deets shows a workaround, which is also nice. I will think a little more which of these answer I should rather accept...</span>
<span class="comment-copy">So in principle, there is problem is not really to be easily addressed in Python. However, you provide a nice workaround. I like your answer and @DanielGibbs answer as well. I will think a little more which answer I should rather accept.</span>
<span class="comment-copy">I would make the decision dependent on how frequent an issue like that occurs so it justifies introducing a new idiomatic way to solve it. Code is read more often than it's written - and Daniel's answer can be understood with no further knowledge type-based dispatch. Make that your judge on this.</span>
<span class="comment-copy">I also heard rumors some kind of optional static typing will be introduced in python3. However, I didn't find a real evidence about that.</span>
<span class="comment-copy">These rumors are wrong - what exists is an (optional) type annotation system: <a href="https://docs.python.org/3/tutorial/controlflow.html#function-annotations" rel="nofollow noreferrer">docs.python.org/3/tutorial/â€¦</a> An optimizing compiler could use this, and a generic function mechanism as well - but I'm not aware of either being actually used.</span>
