<div class="post-text" itemprop="text">
<p>I have such script:</p>
<pre><code>import argparse

parser = argparse.ArgumentParser(
                description='Text file conversion.'
                )
parser.add_argument("inputfile",   help="file to process", type=str)
parser.add_argument("-o", "--out", default="output.txt",
                    help="output name")
parser.add_argument("-t", "--type", default="detailed",
                    help="Type of processing")

args = parser.parse_args()

for arg in args:
    print(arg)
</code></pre>
<p>But it doesnt work. I get error:</p>
<pre><code>TypeError: 'Namespace' object is not iterable
</code></pre>
<p>How to iterate over arguments and their value?</p>
</div>
<div class="post-text" itemprop="text">
<p>Please add 'vars' if you wanna iterate over namespace object:</p>
<pre><code> for arg in vars(args):
     print arg, getattr(args, arg)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/argparse.html#argparse.Namespace" rel="noreferrer"><code>Namespace</code></a> objects aren't iterable, the standard docs suggest doing the following if you want a dictionary:</p>
<pre><code>&gt;&gt;&gt; vars(args)
{'foo': 'BAR'}
</code></pre>
<p>So </p>
<pre><code>for key,value in vars(args).iteritems():
    # do stuff
</code></pre>
<p>To be honest I'm not sure why you want to iterate over the arguments. That somewhat defeats the purpose of having an argument parser.</p>
</div>
<div class="post-text" itemprop="text">
<p>After</p>
<pre><code>args = parser.parse_args()
</code></pre>
<p>to display the arguments, use:</p>
<pre><code>print args # or print(args) in python3
</code></pre>
<p>The <code>args</code> object (of type <code>argparse.Namespace</code>) isn't iterable (i.e. not a list), but it has a <code>.__str__</code> method, which displays the values nicely.</p>
<p><code>args.out</code> and <code>args.type</code> give the values of the 2 arguments you defined.  This works most of the time.  <code>getattr(args, key)</code> the most general way of accessing the values, but usually isn't needed.</p>
<pre><code>vars(args)
</code></pre>
<p>turns the namespace into a dictionary, which you can access with all the dictionary methods.  This is spelled out in the <code>docs</code>.</p>
<p>ref: the Namespace paragraph of the docs - <a href="https://docs.python.org/2/library/argparse.html#the-namespace-object" rel="noreferrer">https://docs.python.org/2/library/argparse.html#the-namespace-object</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I'm using <code>args.__dict__</code>, which lets you access the underlying dict structure.
Then, its a simple key-value iteration:</p>
<pre><code>for k in args.__dict__:
  print k, args.__dict__[k]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Parsing the _actions from your parser seems like a decent idea. Instead of running parse_args() and then trying to pick stuff out of your Namespace.</p>
<pre><code>import argparse

parser = argparse.ArgumentParser(
                description='Text file conversion.')
parser.add_argument("inputfile", help="file to process", type=str)
parser.add_argument("-o", "--out", default="output.txt",
                help="output name")
parser.add_argument("-t", "--type", default="detailed",
                help="Type of processing")
options = parser._actions
for k in options:
    print(getattr(k, 'dest'), getattr(k, 'default'))  
</code></pre>
<p>You can modify the 'dest' part to be 'choices' for example if you need the preset defaults for a parameter in another script (by returning the options in a function for example).</p>
</div>
<div class="post-text" itemprop="text">
<p><code>ArgumentParser.parse_args</code> returns a <code>Namespace</code> object instead of an iterable arrays.</p>
<p>For your reference, <a href="https://docs.python.org/3/library/argparse.html#parsing-arguments" rel="nofollow">https://docs.python.org/3/library/argparse.html#parsing-arguments</a></p>
<pre><code>ArgumentParser parses arguments through the parse_args() method. This will inspect the command line, convert each argument to the appropriate type and then invoke the appropriate action.
</code></pre>
<p>And it is not supposed to be used like that. Consider your use case, in the doc, it says <em><code>argparse</code> will figure out how to parse those out of <code>sys.argv</code>.</em>, which means you don't have to iterate over those arguments.</p>
</div>
<span class="comment-copy">a typical usage for this is implementing a <code>debug-input</code> mode where a script prints out all the input arguments and exits; useful for stuff like making sure datetime input values got interpreted correctly</span>
<span class="comment-copy">Note, <code>iteritems()</code> in Python 2.x, <code>items()</code> in Python 3.x.</span>
<span class="comment-copy">With regards to the last remark, you could have a metaprogram that parses command line arguments based on a configuration file</span>
<span class="comment-copy">Thanks for the nice write up!</span>
