<div class="post-text" itemprop="text">
<p><strong>TL;TR</strong> <em>Looking for idioms and patterns to unpack positional and keyword arguments into <strong>ordered sequence</strong> of positional arguments, based on simple specification, e.g. a list of names. The idea seems similar to scanf-like parsing.</em></p>
<p>I'm wrapping functions of a Python module, called <code>someapi</code>.
Functions of <code>someapi</code> only expect <strong>positional arguments</strong>, which are in pain <strong>numbers</strong> in most cases.
I'd like to enable callers with flexibility of how they can pass arguments to my wrappers.
Here are examples of the wrappers invocations I'd like to allow:</p>
<pre><code># foo calls someapi.foo()
foo(1, 2, 3, 4)
foo(1, 2, 3, 4, 5) # but forward only 1st 4 to someapi.foo
foo([1, 2, 3, 4])
foo([1, 2, 3, 4, 5, 6]) # but forward only 1st 4 to someapi.foo
foo({'x':1, 'y':2, 'z':3, 'r':4})
foo(x=1, y=2, z=3, r=4)
foo(a=0, b=0, x=1, y=2, z=3, r=4) # but forward only x,y,z,r someapi.foo
</code></pre>
<p>I don't see any need to support convoluted case of mixed positional and keyword arguments:</p>
<pre><code>foo(3, 4, x=1, y=2)
</code></pre>
<p>Here is my first stab at implementing such arguments handling for the <code>foo</code> wrapper calling <code>someapi.foo</code>:</p>
<pre><code>def foo(*args, **kwargs):
    # BEGIN arguments un/re-packing
    a = None
    kwa = None
    if len(args) &gt; 1:
        # foo(1, 2, 3, 4)
        a = args
    elif len(args) == 1:
        if isinstance(args[0], (list, tuple)) and len(args[0]) &gt; 1:
            # foo([1, 2, 3, 4])
            a = args[0]
        if isinstance(args[0], dict):
            # foo({'x':1, 'y':2, 'z':3, 'r':4})
            kwa = args[0]
    else:
        # foo(x=1, y=2, z=3, r=4)
        kwa = kwargs

    if a:
        (x, y, z, r) = a
    elif kwa:
        (x, y, z, r) = (kwa['x'], kwa['y'], kwa['z'], kwa['r'])
    else:
        raise ValueError("invalid arguments")
    # END arguments un/re-packing

    # make call forwarding unpacked arguments 
    someapi.foo(x, y, z, r)
</code></pre>
<p>It does the job as expected, as far as I can tell, but it there are two issues:</p>
<ol>
<li>Can I do it better in more <strong>Python idiomatic</strong> fashion?</li>
<li>I have dozen(s) of <code>someapi</code> functions to wrap, so how to avoid copying and adjusting the whole block between <strong>BEGIN/END</strong> marks in every wrapper?</li>
</ol>
<p>I don't know the answer for the question 1, yet.</p>
<p>Here, however, is my attempt to address the issue 2.</p>
<p>So, I defined a generic handler for arguments based on the simple specification of <code>names</code>.
The <code>names</code> specify a couple of things, depending on the actual wrapper invocation:</p>
<ul>
<li>How many arguments to unpack from <code>*args</code>? (see <code>len(names)</code> test below)</li>
<li>What keyword arguments are expected in <code>**kwargs</code>? (see <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow">generator expression</a> returning tuple below)</li>
</ul>
<p>Here is new version:</p>
<pre><code>def unpack_args(names, *args, **kwargs):
    a = None
    kwa = None
    if len(args) &gt;= len(names):
        # foo(1, 2, 3, 4...)
        a = args
    elif len(args) == 1:
        if isinstance(args[0], (list, tuple)) and len(args[0]) &gt;= len(names):
            # foo([1, 2, 3, 4...])
            a = args[0]
        if isinstance(args[0], dict):
            # foo({'x':1, 'y':2, 'z':3, 'r':4...})
            kwa = args[0]
    else:
        # foo(x=1, y=2, z=3, r=4)
        kwa = kwargs
    if a:
        return a
    elif kwa:
        if all(name in kwa.keys() for name in names):
            return (kwa[n] for n in names)
        else:
            raise ValueError("missing keys:", \
                [name for name in names if name not in kwa.keys()])
    else:
        raise ValueError("invalid arguments")
</code></pre>
<p>This allows me to implement the wrapper functions in the following way:</p>
<pre><code>def bar(*args, **kwargs):
    # arguments un/re-packing according to given of names
    zargs = unpack_args(('a', 'b', 'c', 'd', 'e', 'f'), *args, **kwargs)
    # make call forwarding unpacked arguments 
    someapi.bar(*zargs)
</code></pre>
<p>I think I have achieved all the advantages over the <code>foo</code> version above that I was looking for:</p>
<ul>
<li><p>Enable callers with the requested flexibility.</p></li>
<li><p>Compact form, cut down on copy-and-paste.</p></li>
<li><p>Flexible protocol for positional arguments: <code>bar</code> can be called with 7, 8 and more positional arguments or a long list of numbers, but only first 6 are taken into account. For example, it would allow iterations processing long list of numbers (e.g. think of geometry coordinates):</p></li>
</ul>
<pre><code>    # meaw expects 2 numbers
    n = [1,2,3,4,5,6,7,8]
    for i in range(0, len(n), 2):
        meaw(n[i:i+2])
</code></pre>
<ul>
<li>Flexible protocol for keyword arguments: more keywords may be specified than actually used or dictionary can have more items than used.</li>
</ul>
<p>Getting back to the question 1 above, can I do better and make it more Pythonic?</p>
<p>Also, I'd like to ask for review of my solution: you see any bugs? have I overlooked anything? how to improve it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python is a very powerful language that allows you manipulate code in any way you want, but understanding what you're doing is hard.  For this you can use the <code>inspect</code> module.  So an example of how to wrap a function in <code>someapi</code>.  <strong>I'll only consider positional arguments in this example, you can intuit how to extend this further.</strong>  You can do it like this:</p>
<pre><code>import inspect
import someapi

def foo(args*):
    argspec = inspect.getargspec(someapi.foo)

    if len(args) &gt; len(argspec.args):
        args = args[:len(argspec.args)]

    return someapi.foo(*args)
</code></pre>
<p>This will detect if the number of arguments given to <code>foo</code> is too many and if so, it will get rid of the excess arguments.  On the other hand, if there are too few arguments then it will just do nothing and let <code>foo</code> handle the errors.</p>
<p>Now to make it more pythonic.  The ideal way to wrap many functions using the same template is to use <em>decorator syntax</em> (familiarity with this subject is assumed, if you want to learn more then see the docs at <a href="http://www.python.org/doc" rel="nofollow">http://www.python.org/doc</a>).  Although since <em>decorator syntax</em> is mostly used on functions that are in development rather than wrapping another API, we'll make a decorator but just use it as a factory (the factory pattern) for our API.  To make this factory we'll make use of the <code>functools</code> module to help us out (so the wrapped function looks as it should).  So we can turn our example into:</p>
<pre><code>import inspect
import functools
import someapi

def my_wrapper_maker(func):
    @functools.wraps(func)
    def wrapper(args*):
        argspec = inspect.getargspec(func)

        if len(args) &gt; len(argspec.args):
            args = args[:len(argspec.args)]

        return func(*args)
    return wrapper

foo = my_wrapper_maker(someapi.foo)
</code></pre>
<p>Finally, if <code>someapi</code> has a relatively large API that could change between versions (or we just want to make our source file more modular so it can wrap any API) then we can automate the application of <code>my_wrapper_maker</code> to everything exported by the module <code>someapi</code>.  We'll do this like so:</p>
<pre><code>__all__ = ['my_wrapper_maker']

# Add the entire API of someapi to our program.
for func in someapi.__all__:
    # Only add in bindings for functions.
    if callable(getattr(someapi, func)):
        globals()[func] = my_wrapper_maker(getattr(someapi, func))
        __all__.append(func)
</code></pre>
<p>This probably considered the most <em>pythonic</em> way to implement this, it makes full use of Python's meta-programming resources and allows the programmer to use this API everywhere they want without depending on a specific <code>someapi</code>.</p>
<p><strong>Note:</strong> Whether this is most <em>idiomatic</em> way to do this is really up to opinion.  I personally believe that this follows the philosophy set out in "The Zen of Python" quite well and so to me it is very idiomatic.</p>
</div>
<span class="comment-copy">This is a strange desired behavior. As the caller, if I call a function with <code>foo(1, 2, 3, 4, 5)</code> I would be surprised to find that one of my arguments was being disregarded. I would not think twice about calling <code>foo(1, 2, 3)</code> and having a 4th default parameter, for example, but removing arguments is strange. Why do you expect that users of this API are calling the functions with the incorrect number of arguments?</span>
<span class="comment-copy">@Cyber I understand your reasoning. Two things: 1) such extended protocol is a secondary advantage 2) but, if available, there are use cases for it. I have added example with <code>meaw</code> function that illustrates one such use case. So, it's not about disregarding arguments, but I'd think of it more as implicit slicing. Ceratinly, it would have to be documented so user of my wrapper is aware of such feature.</span>
<span class="comment-copy">What should happen if the user add both positional and keyword parameters? "invalid arguments" I guess?</span>
<span class="comment-copy">BTW, the user would get a KeyError if he doesn't specify all the spected keyword arguments, like <code>foo(x=1, yismissing=2, z=3, r=4)</code>. Not sure what's the intended behaviour here.</span>
<span class="comment-copy">I don't have anything to add to the comments above other than my opinion that maximum caller flexibility is a YAGNI and maybe even a bug. Requiring callers to do <code>foo(*[1,2,3,4,5])</code> or <code>foo(**{'x':1,'y':2})</code> isn't too onerous and eliminates code and documentation needs.</span>
<span class="comment-copy">I'm happy to accept your answer. You've proposed solution that is fairly new to me, especially the use of inspect in this case. Certainly, I consider it an elegant and Pythonic alternative to what I proposed. If it's idiomatic or not, I'm not experienced enough to judge, but I'm satisfied. Thanks!</span>
