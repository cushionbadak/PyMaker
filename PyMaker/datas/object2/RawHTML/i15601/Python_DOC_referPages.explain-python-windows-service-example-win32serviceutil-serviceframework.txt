<div class="post-text" itemprop="text">
<p>Most python windows service examples based on the <strong>win32serviceutil.ServiceFramework</strong> use the <strong>win32event</strong> for synchronization.</p>
<p>For example:</p>
<ul>
<li><a href="http://tools.cherrypy.org/wiki/WindowsService" rel="nofollow">http://tools.cherrypy.org/wiki/WindowsService</a> (the example for cherrypy 3.0)</li>
<li>(sorry I dont have the reputation to post more links, but many similar examples can be googled)</li>
</ul>
<p>Can somebody clearly explain why the win32events are necessary (self.stop_event in the above example)? </p>
<p>I guess its necessary to use the win32event due to different threads calling svcStop and svcRun? But I'm getting confused, there are so many other things happening: the split between python.exe and pythonservice.exe, system vs local threads (?), python GIL..</p>
</div>
<div class="post-text" itemprop="text">
<p>For the top of <code>PythonService.cpp</code></p>
<blockquote>
<pre><code>PURPOSE:  An executable that hosts Python services.
         This source file is used to compile 2 discrete targets:
          * servicemanager.pyd - A Python extension that contains
            all the functionality.
          * PythonService.exe - This simply loads servicemanager.pyd, and
            calls a public function.  Note that PythonService.exe may one
            day die - it is now possible for python.exe to directly host
            services.
</code></pre>
</blockquote>
<p>What exactly do you mean by system threads vs local threads? You mean threads created directly from C outside the <a href="https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock" rel="nofollow">GIL</a>?</p>
<p>The <code>PythonService.cpp</code> just related the names to callable python objects and a bunch of properties, like the accepted methods.</p>
<p>For example a the accepted controls from the ServiceFramework:</p>
<pre><code>def GetAcceptedControls(self):
    # Setup the service controls we accept based on our attributes. Note
    # that if you need to handle controls via SvcOther[Ex](), you must
    # override this.
    accepted = 0
    if hasattr(self, "SvcStop"): accepted = accepted | win32service.SERVICE_ACCEPT_STOP
    if hasattr(self, "SvcPause") and hasattr(self, "SvcContinue"):
        accepted = accepted | win32service.SERVICE_ACCEPT_PAUSE_CONTINUE
    if hasattr(self, "SvcShutdown"): accepted = accepted | win32service.SERVICE_ACCEPT_SHUTDOWN
    return accepted
</code></pre>
<p>I suppose the events are recommended because that way you could interrupt the interpreter from outside the GIL, even if python is in a blocking call from the main thread, e.g.: <code>time.sleep(10)</code> you could interrupt from those points outside the GIL and avoid having an unresponsive service.</p>
<p>Most of the win32 services calls are in between the python c macros:</p>
<p>Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS</p>
</div>
<div class="post-text" itemprop="text">
<p>It may be that, being examples, they don't have anything otherwise interesting to do in SvcDoRun. SvcStop will be called from another thread, so using an event is just an easy way to do the cross-thread communication to have SvcDoRun exit at the appropriate time. </p>
<p>If there were some service-like functionality <em>that blocks</em> in SvcDoRun, they wouldn't necessarily need the events. Consider the second example in the CherryPy page that you linked to. It starts the web server in blocking mode, so there's no need to wait on an event.</p>
</div>
