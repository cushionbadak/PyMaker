<div class="post-text" itemprop="text">
<p>How can I find the closest match using python netaddr for same prefixlength?</p>
<pre><code>&gt;&gt;&gt; l = ['172.27.145.130/25', '172.27.145.129/25', '172.27.145.131/25']
&gt;&gt;&gt; myip = '172.27.145.129'
&gt;&gt;&gt; netaddr.IPAddress(myip) in netaddr.IPNetwork(l[0])
True
&gt;&gt;&gt; netaddr.IPAddress(myip) in netaddr.IPNetwork(l[1])
True
&gt;&gt;&gt; netaddr.IPAddress(myip) in netaddr.IPNetwork(l[2])
True
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You seem to be missing a key point here: You say that "all the three ip subnets are part of the same network 172.27.145.128/25", but that's not true; all of them <em>are</em> that same network, just different nonstandard names for it. That's the way IP networking works: for an N-bit network, the last N bits of the base address don't matter. So there is no way to contrast them with each other and pick out which one is a "longest" or "closest" or any other kind of match, because they will all be exactly the same match.</p>
<p>It's possible that you mean these to be <em>interfaces</em>, not networks. An interface has an address within a networkâ€”for example, address <code>172.27.145.130</code> in network <code>172.27.145.128/25</code>. And you can specify that with the shorthand <code>127.27.145.130/25</code>. Yes, the shorthand form for interfaces looks the same as the shorthand form for networks, but they're not the same thing.</p>
<p>If you still don't get the difference between addresses, networks, and interfaces, the 3.3+ Python docs have a great <a href="https://docs.python.org/3/howto/ipaddress.html" rel="nofollow">HOWTO</a>.</p>
<p>While <code>netaddr</code> doesn't have any support for interfaces, the stdlib's <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow"><code>ipaddress</code></a> and the third-party <a href="https://pypi.python.org/pypi/ipaddress/1.0.7" rel="nofollow"><code>ipaddress</code></a> backport for Python 2.6-2.7, do. For example:</p>
<pre><code>&gt;&gt;&gt; l = ['172.27.145.130/25', '172.27.145.129/25', '172.27.145.131/25']
&gt;&gt;&gt; interfaces = [ipaddress.ip_interface(x) for x in l]
&gt;&gt;&gt; interfaces[0]
IPv4Interface('172.27.145.130/25')
&gt;&gt;&gt; interfaces[0].ip, interfaces[0].network
(IPv4Address('172.27.145.130'), IPv4Network('172.27.145.128/25'))
</code></pre>
<p>So, maybe what you're asking is which interface shares the most bits in common with a given address? (I'm still not sure if this is what you mean by "closest match" or "longest match", but it seems like a reasonable guess.)</p>
<p>That's still an ambiguous question. You could either be asking which interface's address shares more bits period, or which one shares more bits within the subnet. But since they're all in the same subnet, that doesn't matter.</p>
<p>And that means that we can even use the <code>netaddr</code> network objects as ersatz interface objects (although really, you'd be better off using <code>ipaddress</code> or another library that actually supports interface objects).</p>
<p>So:</p>
<pre><code>&gt;&gt;&gt; l = ['172.27.145.130/25', '172.27.145.129/25', '172.27.145.131/25']
&gt;&gt;&gt; interfaces = [netaddr.IPNetwork(interface) for interface in l]
&gt;&gt;&gt; addresses = [interface.ip for interface in interfaces]
&gt;&gt;&gt; bits = [address.bits() for address in addresses]
&gt;&gt;&gt; bits
['10101100.00011011.10010001.10000010',
 '10101100.00011011.10010001.10000001',
 '10101100.00011011.10010001.10000011']
&gt;&gt;&gt; myip = '172.27.145.129'
&gt;&gt;&gt; myaddress = netaddr.IPAddress(myip)
&gt;&gt;&gt; mybits = myaddress.bits()
'10101100.00011011.10010001.10000001'
</code></pre>
<p>(Obviously you can merge together most of those steps so the whole thing is just two or three lines.)</p>
<p>And now we're just comparing strings.</p>
<p>But <code>netaddr.IPAddress</code> also has an <code>&amp;</code> operator, so we can make it even simpler:</p>
<pre><code>&gt;&gt;&gt; common_bits = [(address &amp; myaddress).bits() for address in addresses]
&gt;&gt;&gt; common_bits
['10101100.00011011.10010001.10000000',
 '10101100.00011011.10010001.10000001',
 '10101100.00011011.10010001.10000001']
&gt;&gt;&gt; common_bit_counts = [bits.count('1') for bits in common_bits]
&gt;&gt;&gt; common_bit_counts
[12, 13, 13]
</code></pre>
<p>There are other ways to tackle this. For example, the <code>value</code> of each <code>IPAddress</code> is a 32-bit int, so you can just and those together and count the bits numerically instead of as a string. But hopefully this shows things explicitly.</p>
</div>
<span class="comment-copy">What do you mean by "closest match"? Those are all either illegal networks, or different names for the same network, depending on how strict you want to define things, so none of them are any closer than any other.</span>
<span class="comment-copy">well by closest match i meant longest match. sorry for confusion</span>
<span class="comment-copy">OK, so what does "longest match" mean? Again, all three of those are defining either the exact same CIDR network 172.27.145.128/25, or nothing at all, so I don't know what different results you're expecting out of them.</span>
<span class="comment-copy">thing is... all the three ip subnets are part of same network 172.27.145.128/25. Thats why netaddr returns True, which makes sense. But I guess I was asking if there is a way to compare just the IP addresses bit by bit to find the closest match. its not entirely a "is IP in subnet" question; but more of do the IP addresses match. From the looks of it, I guess I need to compare the network and host bits. anyways, thanks for ur help.</span>
