<div class="post-text" itemprop="text">
<p>I have the following project structure:</p>
<pre><code>server/
   server.py
   __init__.py

   sockets/
      module.py
      __init__.py
</code></pre>
<p>I set <code>PYTHONPATH</code> to one directory above server (for example <code>/home/user/server</code> contains server, <code>PYTHONPATH</code> is set <code>/home/user</code>).</p>
<p>The main file is <code>server.py</code>; it imports modules:</p>
<pre><code>import sockets
from sockets.module import Module
</code></pre>
<p>When I run <code>python3 $PYTHONPATH/server/server.py</code> directly it works perfectly.
However when I call <code>python3 -m server.server.py</code> it fails, despite the fact that it is explicitly recommended to avoid Python path hell, but it fails to find the the module, with an ugly message:</p>
<pre><code>/usr/bin/python3: Error while finding spec for 'server.server.py' (&lt;class 'ImportError'&gt;: No module named 'sockets')
</code></pre>
<p>Why does the module import fail to import submodules?
How to properly setup sub-packages?</p>
</div>
<div class="post-text" itemprop="text">
<p>The behaviour is entirely correct; <code>sockets</code> is not a <em>top-level module</em>. However, when you use <code>$PYTHONPATH/server/server.py</code>, Python also adds <code>$PYTHONPATH/server/</code> to the Python search path, so now <code>sockets</code> <em>is</em> a top-level module. You should never directly run files in a package.</p>
<p>Import <code>sockets</code> relative to the current package:</p>
<pre><code>from . import sockets
from .sockets.module import Module 
</code></pre>
<p>or use fully-qualified imports:</p>
<pre><code>from server import sockets
from server.sockets.module import Module 
</code></pre>
<p>Also see the <a href="https://docs.python.org/3//using/cmdline.html#interface-options" rel="nofollow"><em>Interface Options</em> section</a> of the Python Setup and Usage section in the fine manual:</p>
<blockquote>
<p>If the script name refers directly to a Python file, the <strong>directory containing that file is added to the start of <code>sys.path</code></strong>, and the file is executed as the <code>__main__</code> module.</p>
</blockquote>
<p>Note that the <code>-m</code> switch takes a <em>python identifier</em>, not a filename, so use:</p>
<pre><code>python -m server.server
</code></pre>
<p>leaving of the <code>.py</code> extension.</p>
</div>
<span class="comment-copy">Thanks as I thought I missed something simple, though I believed for some reason that it includes it with -m import.</span>
<span class="comment-copy">@IBr: when using <code>python -m</code> the current working directory is also added to the path, so you can change directories to <code>$PYTHONPATH</code> and then use <code>python -m server.server</code> and <code>$PYTHONPATH</code> will be added to your path automatically.</span>
