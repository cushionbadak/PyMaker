<div class="post-text" itemprop="text">
<p>I'm in a slightly tricky situation with a list subclass.</p>
<p>The list class I'm using has overridden <code>__iter__</code> and <code>__getitem__</code> in order to return something slightly different from what's actually stored internally (this is because this requires processing time which was wanted to be only done when the item is first directly accessed)</p>
<p>My issue comes up in the following use case. Let's say, for the use of this example, that the overridden methods turn the internal values into strings.</p>
<pre><code>&gt;&gt;&gt; myList = MyList([1, 2, 3])
&gt;&gt;&gt; standardList = list(["a", "b", "c"])
&gt;&gt;&gt;
&gt;&gt;&gt; for item in myList:
&gt;&gt;&gt;     print item
"1"
"2"
"3"
&gt;&gt;&gt; newList = standardList + myList
&gt;&gt;&gt; for item in newList:
&gt;&gt;&gt;     print item
"a"
"b"
"c"
1
2
3
</code></pre>
<p>So what I'm after here is how the values are pulled from <code>myList</code> when <code>standardList + myList</code> is run, so that I can ensure that <code>newList</code> has had the relevant modifications made.</p>
<p>Incidentally, I'm well aware that I could get this working if I overrode <code>MyList.__add__</code> and then did <code>myList + standardList</code>, but this is in a module that is used elsewhere, and I'd rather ensure that it works the right way in both directions.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>To ensure if works in both directions you should define both override both <code>__add__</code> and <code>__radd__</code> in your <code>MyList</code> class. Quoting from <a href="https://docs.python.org/2/reference/datamodel.html#coercion-rules" rel="nofollow noreferrer">data model page</a>(7th bullet point)*:</p>
<blockquote>
<p>Exception to the previous item: if the left operand is an instance of
  a built-in type or a new-style class, and the right operand is an
  instance of a proper subclass of that type or class and overrides the
  base’s <code>__rop__()</code> method, the right operand’s <code>__rop__()</code> method is tried
  before the left operand’s <code>__op__()</code> method.</p>
</blockquote>
<p>So, your code will look like:</p>
<pre><code>class MyList(list):

    def __radd__(self, other):
        return MyList(list.__add__(other, self))
</code></pre>
<hr/>
<p>*Note that the <strong>proper subclass</strong> thing mentioned in Python 2 docs is actually a <a href="https://stackoverflow.com/a/24920403/846892">documentation bug</a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__ror__" rel="nofollow noreferrer">they fixed it in Python 3</a>:</p>
<blockquote>
<p>If the right operand’s type is a subclass of the left operand’s type
  and that subclass provides the reflected method for the operation,
  this method will be called before the left operand’s non-reflected
  method. This behavior allows subclasses to override their ancestors’
  operations.</p>
</blockquote>
<p></p>
</div>
<div class="post-text" itemprop="text">
<p>You can simply pass the result of list addition as in the constructor of MyList, like:</p>
<pre><code>newList = MyList(standardList + myList)
</code></pre>
</div>
<span class="comment-copy">I did a bit of looking into it - <code>__radd__</code> only works if the left operand doesn't support <code>__add__</code>, which, in this case, it does. I could just make <code>MyList</code> not be a subclass of list, though, and just re-implement the list functions...</span>
<span class="comment-copy">Except I'm fine with the resulting list being a list, the elements of myList just need to be modified first.</span>
