<div class="post-text" itemprop="text">
<h1>Algorithm from Hacker's Delight 2nd Edition</h1>
<h1>Ported to python</h1>
<p>A simple Hilbert curve class.</p>
<pre><code>class Hilbert():

    def __init__(self,order=1):

            self.x = -1 
            self.y = 0     
            self._step(0)
            self._hil(0, 1, order)

    def _hil(self, dirs, rot, order):
        if (order == 0): 
            return

        dirs += rot
        self._hil(dirs, -rot, (order-1))
        self._step(dirs)
        dirs -= rot
        self._hil(dirs, rot, (order-1))
        self._step(dirs)
        self._hil(dirs, rot, (order-1))
        dirs -= rot
        self._step(dirs)
        self._hil(dirs, -rot, (order-1))


    def _step(self, dirs):
        dirs %= 4

        if dirs == 0:
            self.x += 1
        elif dirs == 1:
            self.y += 1
        elif dirs == 2:
            self.x -= 1
        else:
            self.y -= 1 
        #prints all points 
        #print(self.x,self.y)
        #Could I "iterate" from here.
</code></pre>
<p>So what I want is something that gives a (x,y) every time next() is called. I tried doing this myself but can't get it to work so any help would be appreciated. Would I have to rewrite this to work with a generator? 
<a href="http://www.hackersdelight.org/" rel="nofollow">Source</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I think at least part of what you're trying to do is to turn <code>_hil</code> into a generator function, which yields the <code>x, y</code> pairs after each call to <code>_step</code>? If so, that's pretty easy.</p>
<p>The hard part is those recursive calls. But that's not really hard at all. That's exactly what <a href="https://www.python.org/dev/peps/pep-0380" rel="nofollow"><code>yield from</code></a> is for:* Take some iterator (like a recursive call to a generator function) and yield each of its values.**</p>
<p>Then there's the easy part, the non-recursive yielding of the <code>x, y</code> pairs after each call to <code>_step</code>. You can do that with an explicit <code>yield self.x, self.y</code> after each call. Or you can change <code>_step</code> to add a <code>return self.x, self.y</code>, so you can just <code>yield self._step(dirs)</code>. But you can also change <code>_step</code> to an iterator that only iterates one value, and then you can <code>yield from</code> it as well. (There's no real advantage to that here, but I think it's worth showing so you can think through how it works—especially since you asked "can I iterate from here?" in <code>_step</code>.)</p>
<pre><code>def _hil(self, dirs, rot, order):
    if (order == 0): 
        return

    dirs += rot
    yield from self._hil(dirs, -rot, (order-1))
    yield from self._step(dirs)
    dirs -= rot
    yield from self._hil(dirs, rot, (order-1))
    yield from self._step(dirs)
    yield from self._hil(dirs, rot, (order-1))
    dirs -= rot
    yield from self._step(dirs)
    yield from self._hil(dirs, -rot, (order-1))

def _step(self, dirs):
    # existing code
    yield self.x, self.y
</code></pre>
<hr/>
<p>But now you've got that <code>__init__</code> that just calls <code>_hil</code> and does nothing with the result. That's not very useful. Maybe you're trying to turn the <code>Hilbert</code> class itself into an iterator class?</p>
<p>In that case, the easiest thing to do is store the generator iterator and delegate to it:</p>
<pre><code>def __init__(self, order=1):
    self.x = -1 
    self.y = 0     
    self._step(0)
    self.iter = self._hil(0, 1, order)

def __iter__(self):
    return self

def __next__(self):
    return next(self.iter)
</code></pre>
<hr/>
<p>However, at this point, I'm not sure why you need this to be a class at all. The <code>x</code> and <code>y</code> aren't really part of the object's state, they're part of the generator state, which Python would take care of magically if you just used local variables in <code>_hil</code> (and normal parameter-and-return passing in <code>_step</code>). And the only other state is <code>self.iter</code>, which is only necessary because you're writing a class instead of a function.</p>
<hr/>
<p><sub>* Actually, it turns out to be good for a lot more than that, as <a href="http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/" rel="nofollow">Greg Ewing describes amazingly well</a>; we wouldn't have <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow"><code>asyncio</code></a> without it. But the original reason for adding it to the language was as "Syntax for Delegating to a Subgenerator".</sub></p>
<p>** Note that this only works if you <em>have</em> <code>yield from</code>—meaning Python 3.3 or later. If you're still using Python 2.x, and <code>yield from</code> isn't enough to get you to upgrade, you can simulate <em>some</em> uses of it—including this one—by changing every <code>yield from eggs</code> into <code>for egg in eggs: yield egg</code>. It won't be as readable, and it will be significantly slower, but it will work.</p>
</div>
<span class="comment-copy">Are you trying to make <code>Hilbert._step</code> into a generator function (a function that returns a generator-iterator), or to make <code>Hilbert</code> itself into an iterator class (a class whose instances are iterators)? If you don't understand that question, just write us a couple of lines of code that show how you'd like to be able to use a <code>Hilbert</code> object.</span>
<span class="comment-copy">Yes, like you said, I wanted to create a generator class. Your explanation was very helpful to me. Thank you.</span>
<span class="comment-copy">@James: Part of the problem is that there is really no such thing as a generator class. You could argue that a class that fits the entire generator protocol (which includes <code>send</code> and <code>throw</code>) deserves to be called a generator class, but its instances still wouldn't pass, e.g., <code>inspect.isgenerator</code>. What you want is an <i>iterator</i> class. Generators are a subtype of iterators, not the same thing.</span>
<span class="comment-copy">@James: PS, don't feel too bad about not getting the terminology straight; people on python-dev and -ideas, even Python core devs, sometimes stumble over it. It's one of those cases where you so rarely actually need to name these things that it's hard to keep them straight…</span>
<span class="comment-copy">Good question and intelligent answer.</span>
