<div class="post-text" itemprop="text">
<p>I am in the process of trying to create a program to randomly deal two cards. However, it keeps popping up with the error:</p>
<pre><code>AttributeError: type object `CardPack` has no attribute `suits`
</code></pre>
<p>I am not sure, but I think this means that the class <code>CardPack</code> does not have a value <code>suits</code>. But, in the <code>__init__</code> function, it is defined. I am completely stumped.</p>
<p>Class Code:</p>
<pre><code>import random

class CardPack:
    def __init__(self):
        self.cardsClubs = ["A C", "2 C", "3 C", "4 C", "5 C", "6 C", "7 C", "8 C", "9 C", "10 C", "J C", "Q C", "K C"]
        self.cardsSpades = ["A S", "2 S", "3 S", "4 S", "5 S", "6 S", "7 S", "8 S", "9 S", "10 S", "J S", "Q S", "K S"]
        self.cardsHearts = ["A H", "2 H", "3 H", "4 H", "5 H", "6 H", "7 H", "8 H", "9 H", "10 H", "J H", "Q H", "K H"]
        self.cardsDiamonds = ["A D", "2 D", "3 D", "4 D", "5 D", "6 D", "7 D", "8 D", "9 D", "10 D", "J D", "Q D", "K D"]
        self.cardsDealt = []
        self.suits = ["C", "S", "H", "D"]

    def getRandomCards(self):
        card = ""
        if random.choice(self.suits) == "C":
            card = random.choice(self.cardsClubs)

        elif random.choice(self.suits) == "S":
            card = random.choice(self.cardsSpades)

        elif random.choice(self.suits) == "H":
            card = random.choice(self.cardsHearts)

        elif random.choice(self.suits) == "D":
            card = random.choice(self.cardsDiamonds)
        else:
            pass

        return card

    def deal(self):
        cards = 1

        while cards != 3:
            self.cardsDealt[cards] = self.getRandomCards(self)

        return self.cardsDealt
</code></pre>
<p>File that runs creates instance:</p>
<pre><code>#DEALING TEST
from DeckDealer import CardPack

Dealer = CardPack

cards = Dealer.deal(CardPack)

print("Your cards are %s and %s!" % (cards[1], cards[2]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>Dealer = CardPack
</code></pre>
<p>This line does not create an instance of your <code>CardPack</code> type, it merely copies a reference to it. So when you then call <code>Dealer.deal()</code>, you are essentially doing <code>CardPack.deal()</code> which does not have access to the instance properties.</p>
<p>Instead, you should create an instance, and then call the method on that instance:</p>
<pre><code>dealer = CardPack()
cards = dealer.deal()
</code></pre>
<p>In that context, it’s also important to note that, to call a method, you do <strong>not</strong> pass a value for <code>self</code>. The <code>self</code> is implicitely set when you call the method on the instance. So when you do <code>dealer.deal()</code>, the <code>self</code> is automatically set to the dealer instance. If you were to call <code>dealer.deal(dealer)</code>, you would pass a <em>second</em> parameter which the method does not have, so you would get an error. This is also a problem with your <code>getRandomCards</code> call in <code>deal</code>: <code>self.getRandomCards(self)</code> will set <code>self</code> as the <em>second</em> parameter, giving you an error. Just doing <code>self.getRandomCards()</code> is what you want to do.</p>
<p>That being said, note that your <code>deal</code> method will have an infinite loop, as you keep iterating as long as <code>cards</code> is not 3—but you never change the value of <code>cards</code>. So you probably want to increment the value in the loop. But even then, accessing <code>cardsDealt[cards]</code> on an empty list will result in an IndexError, so you want to fix that too. You could reset the list first, and then just <code>append</code> new cards to it, but even better is to just create just a new list with 3 cards at once. You can use a list comprehension to make this simple and short:</p>
<pre><code>def deal(self):
    self.cardsDealt = [self.getRandomCards() for card in range(3)]
    return self.cardsDealt
</code></pre>
<hr/>
<p>Finally, your <code>getRandomCards</code> might not do exactly what you expect it to do. Usually, you would expect every card to have the same chance. The way you do it however is that a Club card has a chance of 1/4, a Spades card a chance of 3/16, a Hearts card a chance of 9/64, and a Diamonds card a chance of 27/256. This leaves a chance of 81/256 to get <em>no card</em>. This is obviously not correct.</p>
<p>The reason this happens it that you make a random choice for every test. So to test whether you get a Clubs card, you make a choice (1/4 chance). If you don’t get one (3/4 chance), you make another choice to get a Spades card (1/4 chance; so 3/4*1/4 in total), etc. Instead, you would want to make a choice <em>just once</em> and then reuse that result for the subcategory:</p>
<pre><code>def getRandomCards(self):
    # only make *one* random choice for the suit
    suit = random.choice(self.suits)

    if suit == "C":
        return random.choice(self.cardsClubs)
    elif suit == "S":
        return random.choice(self.cardsSpades)
    elif suit == "H":
        return random.choice(self.cardsHearts)
    elif suit == "D":
        return random.choice(self.cardsDiamonds)
</code></pre>
<p>This also makes it impossible that you don’t get a random card from the method, since you always get one of the four suits.</p>
<hr/>
<p>Finally 2, as gboffi mentioned in the comments, you don’t have any protection in place that prevents you from getting multiple identical cards. It’s possible (unlikely but still possible) to get three times the same card from <code>getRandomCards()</code>, which is—in most games—not possible.</p>
<p>To prevent this, you could use <a href="https://docs.python.org/3/library/random.html#random.sample" rel="nofollow"><code>random.sample</code></a> on a list of all cards. This will get you three (or any number) cards that are definitely distinct. It also allows you to have a real “deck” which you draw cards from which stay out of the deck then until you restart the game.</p>
<p>With your setup, you could make a new deck like this:</p>
<pre><code>self.deck = self.cardsClubs + self.cardsSpades + self.cardsHearts + self.cardsDiamonds
</code></pre>
<p>This essentially just combines all the four card lists, creating a new one which you can then draw from. To draw three from them, you could use <code>random.sample</code> like this:</p>
<pre><code>drawnCards = random.sample(self.deck, 3)
</code></pre>
<p>And then you could remove those cards from the deck:</p>
<pre><code>for card in drawnCards:
    self.deck.remove(card)
</code></pre>
<p>Another way would be to follow the real way a bit more closely. Instead of drawing random cards form the (sorted) deck, you could just shuffle the deck first, and then draw cards from the top. To shuffle a list, you can use <a href="https://docs.python.org/3/library/random.html#random.shuffle" rel="nofollow"><code>random.shuffle</code></a>, and to draw and remove a card from the list, you can use <code>list.pop</code>:</p>
<pre><code># create the deck
self.deck = self.cardsClubs + self.cardsSpades + self.cardsHearts + self.cardsDiamonds

# shuffle the deck
random.shuffle(self.deck)

# and then draw three cards from it
drawnCards = [self.deck.pop() for i in range(3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are not creating an <em>instance</em> here:</p>
<pre><code>Dealer = CardPack
</code></pre>
<p>That's just another reference to the class (a <em>type</em>), so the <code>__init__</code> method isn't called either.</p>
<p><em>Call</em> the class to produce an instance:</p>
<pre><code>Dealer = CardPack()
</code></pre>
</div>
<span class="comment-copy">I think you meant <code>Dealer = CardPack()</code></span>
<span class="comment-copy">Consider using a  <code>dict</code> to store a pack of cards, <code>self.cards = {'C':['A C', '2 C', ...], 'S':[...],}</code> and later <code>suit=random.choice(('C', 'S', 'H', 'D')); card = random.choice(self.cards[suit])</code>.  Further, nothing in your code against dealing the same card twice (or more if one's is playing against the computer).</span>
<span class="comment-copy">Another code review remark, DO NOT repeat the random choice of suit in your if-stack! you want to choose once the suit and use the suit value in the if-stack...</span>
<span class="comment-copy">Nice work, Poke. I guess there's no point me posting my answer now. :)</span>
<span class="comment-copy">Welp, that answer turned out longer than expected. Oh well :D</span>
