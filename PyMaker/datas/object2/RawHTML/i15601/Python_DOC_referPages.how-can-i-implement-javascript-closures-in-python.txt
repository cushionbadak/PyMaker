<div class="post-text" itemprop="text">
<p>I am trying to implement Javascript closures in Python 2.7.</p>
<p>Consider the following code:</p>
<pre><code>var = {'upper_scope':None}

def f1():
    print var

def f2():
    var = {'upper_scope': var}
</code></pre>
<p>The first function works fine. The second one fails on its first line:</p>
<pre><code>UnboundLocalError: local variable 'var' referenced before assignment. 
</code></pre>
<p>I would like to read the value of <code>var</code> from the upper scope and place it inside a local dictionary named <code>var</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't work in f2(), because you are locally overwriting the global definition of var.
If you rename var in f2(), it will work:</p>
<pre><code>def f2():
   other_var = {'upper_scope': var}
</code></pre>
<p>Alternatively, you could define it as global, but then the change of var's value would be applied to the global variable, too, like so:</p>
<pre><code>def f2():
   global var
   var = {'upper_scope': var}
</code></pre>
<p>That being said, it's always a better approach to pass variables as parameters to functions, unless you really need it in several places and/or need to change its value.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is probably the only way of doing that. I used this method in my JavaScript to Python converter and it does it's job.</p>
<pre><code>var = {'upper_scope':None}
def first(var=var):
    var = {'upper_scope': var}
    def second(var=var):
        var = {'upper_scope': var } 
        def third(var=var):
             var = ...
</code></pre>
<p>Now each function 'remembers' its upper scope - its stored a as its default argument. Also note that the function automatically creates local scope when called (<code>var = {'upper_scope': var}</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>There is <a href="https://docs.python.org/3/reference/simple_stmts.html#grammar-token-nonlocal_stmt" rel="nofollow">nonlocal statement</a> in python3 syntax which was invented exactly for what you asked: for <a href="https://www.python.org/dev/peps/pep-3104" rel="nofollow">access to names in outer scope</a>.</p>
<p>For access global varible in nest of functions you can do something like this(works in both python2 and python3):</p>
<pre><code>var = {'upper_scope':None}
def first():
    global var
    var = {'upper_scope': var}
    def second():
        global var
        var = {'upper_scope': var } 
        def third():
            global var
            var = ...
</code></pre>
<p>In all of these functions will exist only one example of variable <code>var</code> â€” the global one.
So every changes in inner scope will be available on higher level and vice versa.</p>
</div>
<span class="comment-copy">Maybe it is possible but I would never use a variablename twice in the same file/class. I'm not sure but it might be against the pip rules.</span>
<span class="comment-copy">Why do you want to implement JavaScript closures in Python, why not Python functions?</span>
<span class="comment-copy">Man, that title. Is writing a proper title for a question a lost art now?</span>
<span class="comment-copy">I am writing a translator and JavaScript has a bit different closures.</span>
<span class="comment-copy">Basically inside one function you can have var be a local variable or a global variable, but you can't have it mean both things in the same function.</span>
<span class="comment-copy">And why was this downvoted?</span>
<span class="comment-copy">It has to have the same name, this is the point. And global will not work for nested functions.</span>
<span class="comment-copy">@PiotrDabkowski: If you're trying to make your translator work without variable renaming, you're making things a lot harder for yourself than you need to. What happens when you need to translate a variable named <code>$foo</code>?</span>
<span class="comment-copy">Its all stored inside var which represents scope :). so $foo=4  will translate to  var.put('$foo', Js(4))</span>
<span class="comment-copy">@PiotrDabkowski: You can just number the <code>var</code>s according to the nesting level and have your translator use the right name for each access.</span>
<span class="comment-copy">I am using python 2.7 nonlocal is not implemented here :(</span>
<span class="comment-copy">sorry, this also will not work in python3, because there is only global <code>var</code> exists and no others.</span>
<span class="comment-copy">I fix my answer. It will work for closures of global variables.</span>
