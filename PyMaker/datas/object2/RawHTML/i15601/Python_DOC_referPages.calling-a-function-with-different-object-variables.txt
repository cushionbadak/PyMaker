<div class="post-text" itemprop="text">
<p>In Python, I have a list of objects, each of which has two variables:</p>
<pre><code>class a_object:
    def __init__(self, input1, input2):
        self.data1=input1
        self.data2=input2

a_list=[]

for i in range(5):
    a_list.append(a_object(i,i+5))
</code></pre>
<p>I would like to be able to call a function with this list, and the function would have an argument that would determine whether to act on data1 or data2.</p>
<p>Ex:</p>
<pre><code>def find_sum(list_name, variable_name):
    total=0
    for i in range(len(list_name)):
        total=total+list_name[i].variable_name
    return total

total1=find_sum(a_list,data1)  #0+1+2+3+4
total2=find_sum(a_list,data2)  #5+6+7+8+9
</code></pre>
<p>I could just make the variable_name argument an integer, and have a version of the function code contained in an if statement for each integer value, but that is much less general.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I would like to be able to call a function with this list, and the function would have an argument that would determine whether to act on data1 or data2.</p>
</blockquote>
<p>In that case, you do not want attributes named <code>data1</code> and <code>data2</code>, you want a single attribute named <code>data</code>, which is a list or other collection of two values.</p>
<p>Attributes are for things that you reference statically, using names hardcoded into your code. You can tell that you used elements when you should have used attributes, because you end up having to write <code>spam['eggs']</code> instead of <code>spam.eggs</code> all over the place, which is ugly.</p>
<p>Elements are for things that you reference dynamically, using names (or indices) passed in variables. You can tell that you used attributes when you should have used elements, because you end up having to write <code>getattr(spam, 'eggs')</code> instead of <code>spam['eggs']</code> all over the place, which is even uglier. (Or, for novices, you end up not even knowing how to write the code in the first place—but <a href="https://stackoverflow.com/a/27136855/908494">iCodez's answer</a> explains how.)</p>
<p>For example:</p>
<pre><code>class AObject(object):
    def __init__(self, *data):
        self.data = data
    def find_sum(self, values, data_index):
        total=0
        for i in range(len(values)):
            total=total+values[i].data[data_index]
        return total
</code></pre>
<p>If you want to use names instead of indexes, use a dict instead of a list. For example:</p>
<pre><code>def __init__(self, data1, data2):
    self.data = {'data1': data1, 'data2': data2}
def find_sum(self, values, data_name):
    total=0
    for i in range(len(values)):
        total=total+values[i].data[data_name]
    return total
</code></pre>
<p>Or maybe use indexes, but name them:</p>
<pre><code>data1, data2 = 0, 1
</code></pre>
<p>(Or, even better, use an <code>enum.IntEnum</code>.)</p>
<p>See <a href="http://nedbatchelder.com/blog/201112/keep_data_out_of_your_variable_names.html" rel="nofollow noreferrer">Keep data out of your variable names</a> and <a href="http://stupidpythonideas.blogspot.com/2013/05/why-you-dont-want-to-dynamically-create.html" rel="nofollow noreferrer">Why you don't want to dynamically create variables</a> for further explanation.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow"><code>getattr</code></a> and pass the attribute names as strings:</p>
<pre><code>def find_sum(list_name, variable_name):
    total=0
    for i in range(len(list_name)):
        total += getattr(list_name[i], variable_name)
    return total
</code></pre>
<p>Or, a little more concisely:</p>
<pre><code>def find_sum(list_name, variable_name):
    return sum(getattr(x, variable_name) for x in list_name)
</code></pre>
<p>Below is a demonstration:</p>
<pre><code>&gt;&gt;&gt; class a_object:
...     def __init__(self, input1, input2):
...         self.data1=input1
...         self.data2=input2
...
&gt;&gt;&gt; a_list=[]
&gt;&gt;&gt; for i in range(5):
...     a_list.append(a_object(i,i+5))
...
&gt;&gt;&gt; def find_sum(list_name, variable_name):
...     return sum(getattr(x, variable_name) for x in list_name)
...
&gt;&gt;&gt; find_sum(a_list, 'data1')
10
&gt;&gt;&gt; find_sum(a_list, 'data2')
35
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">class a_object ?? Is that valid?</span>
<span class="comment-copy">Well, it's <i>valid</i>, assuming <code>input1</code> and <code>input2</code> are global variables whose values meet the <code>type</code> protocol, and <code>self</code> is a global variable with a <code>__dict__</code>… but it's not exactly <i>useful</i></span>
<span class="comment-copy">@gosom - I think the OP was posting pseudocode.  I edited his answer to have proper syntax.</span>
<span class="comment-copy">Thank you for fixing that.</span>
<span class="comment-copy">You <i>can</i> do this, but you probably <i>shouldn't</i>.</span>
<span class="comment-copy">I'll admit, your answer is cleaner.  :)  I posted this solution though because I don't know if the OP can/wants to make <code>find_sum</code> a method.  If this is not the case and he needs to access the attributes dynamically, then he is is stuck with <code>getattr</code>.</span>
<span class="comment-copy">I did link to your answer for the cases where this is appropriate. But so many people ask for this when they really shouldn't be, that I think it's important to cover that part.</span>
