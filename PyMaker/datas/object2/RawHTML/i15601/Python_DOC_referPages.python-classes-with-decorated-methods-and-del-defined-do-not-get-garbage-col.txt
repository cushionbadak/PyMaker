<div class="post-text" itemprop="text">
<p>I'm running into a problem with Python3.2. If a class decorates a function from the parent class and also has a destructor then instances of that class are never garbage collected.</p>
<p>Here's some sample code that illustrates the problem:</p>
<pre><code>def super_simple_decorator(func):
    def f(*args, **kwds):
        return func(*args, **kwds)
    return f

class Parent():
    def foo(self):
        pass

class Child(Parent):
    def __del__(self):
        print('In Child.__del__')
    def __init__(self):
        self.foo = super_simple_decorator(self.foo)

x = Child()
del x

import gc
_ = gc.collect()
print(gc.garbage)
</code></pre>
<p>If you are so inclined, you could also monkey-patch in a decorator at run-time and see the same thing:</p>
<pre><code>class Garbage():
    def foo(self):
        pass
    def __del__(self):
        print('In Garbage.__del__')

g=Garbage()
g.foo = super_simple_decorator(g.foo)
del g
</code></pre>
<p>In each case, there is uncollected garbage, presumably because there is a bound reference to <code>self</code> in the decorated method.</p>
<p>Upgrading to Python3.4 isn't really an option for me at this point, so I'm looking for a way to let objects like these get garbage collected.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not the decorator that causes this problem. It is the fact that you store a <em>method</em> on the instance they are bound to. The decorator is only the means here, not the actual cause.</p>
<p>Methods hold a reference to the instance in <code>__self__</code>, and you then created a circular reference by storing the method in a closure with the decorator object, back onto <code>self.foo</code>. <em>Don't do that</em>. Python 3.3 and before won't garbage collect circular references with objects with <code>__del__</code> methods.</p>
<p>Unwrap the method and store the original function:</p>
<pre><code>self.foo = super_simple_decorator(self.foo.__func__)
</code></pre>
<p><code>foo</code> will no longer be bound however, methods are only bound if looked up on the class, not the instance.</p>
<p>Or actually apply the decorator <em>at the class level</em>:</p>
<pre><code>class Child(Parent):
    def __del__(self):
        print('In Child.__del__')
    foo = super_simple_decorator(Parent.foo)
</code></pre>
<p>If neither is an option, use a weak reference to track the instance, rather than reference the method, then rebind as needed:</p>
<pre><code>import weakref

def super_simple_decorator(method):
    instance = weakref.ref(method.__self__)
    func = method.__func__
    def f(*args, **kwds):
        self = instance()  # can return None
        return func(self, *args, **kwds)
    return f
</code></pre>
</div>
<span class="comment-copy">Does it help to wrap the <code>self.foo</code> reference in <a href="https://docs.python.org/3/library/weakref.html#weakref.ref" rel="nofollow noreferrer">weakref.ref</a>?</span>
<span class="comment-copy">I thought about that, but then wouldn't it have to be called with <code>g.foo()()</code>?</span>
<span class="comment-copy">Never-mind, I see the answer from @Martijn-Pieters now. I'll give those a try.</span>
<span class="comment-copy">Applying the decorator at the class level isn't really an option for my less simplified scenario. The <code>__func__</code> option ends up with <code>TypeError: foo() takes exactly 1 argument (0 given)</code> and the <code>weakref</code> options gives <code>UnboundLocalError: local variable 'self' referenced before assignment</code>.</span>
<span class="comment-copy">The <code>weakref</code> issue with <code>UnboundLocalError</code> can be fixed by not re-using the name <code>self</code>.</span>
<span class="comment-copy">@TrevorWiley yes, sorry about that, fixed now.</span>
