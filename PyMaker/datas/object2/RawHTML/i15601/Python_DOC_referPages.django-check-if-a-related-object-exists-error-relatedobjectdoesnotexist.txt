<div class="post-text" itemprop="text">
<p>I have a method <code>has_related_object</code> in my model that needs to check if a related object exists</p>
<pre><code>class Business(base):
      name =  models.CharField(max_length=100, blank=True, null=True)

  def has_related_object(self):
        return (self.customers is not None) and (self.car is not None)


class Customer(base):
      name =  models.CharField(max_length=100, blank=True, null=True)
      person = models.OneToOneField('Business', related_name="customer")
</code></pre>
<p>But I get the error:</p>
<blockquote>
<p>Business.has_related_object()</p>
<p>RelatedObjectDoesNotExist: Business has no customer.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This is because the ORM has to go to the database to check to see if <code>customer</code> exists. Since it doesn't exist, it raises an exception.</p>
<p>You'll have to change your method to the following:</p>
<pre><code>def has_related_object(self):
    has_customer = False
    try:
        has_customer = (self.customers is not None)
    except Customer.DoesNotExist:
        pass
    return has_customer and (self.car is not None)
</code></pre>
<p>I don't know the situation with <code>self.car</code> so I'll leave it to you to adjust it if it needs it.</p>
<p>Side note:
If you were doing this on a model that has the ForeignKeyField or OneToOneField on it, you would be able to do the following as a shortcut to avoid the database query.</p>
<pre><code>def has_business(self):
    return self.business_id is not None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>hasattr(self, 'customers')</code> to avoid the exception check as <a href="https://docs.djangoproject.com/en/1.10/topics/db/examples/one_to_one/" rel="noreferrer">recommended in Django docs</a>:</p>
<pre><code>def has_related_object(self):
    return hasattr(self, 'customers') and self.car is not None
</code></pre>
</div>
<span class="comment-copy">Note that according to the doc (<a href="https://docs.djangoproject.com/en/1.9/ref/models/fields/#database-representation" rel="nofollow noreferrer">docs.djangoproject.com/en/1.9/ref/models/fields/…</a>), "[...] your code should never have to deal with the database column name, unless you write custom SQL. You’ll always deal with the field names of your model object.".</span>
<span class="comment-copy">This is approach is faster than the other answer, because it doesn't require talking to the database.</span>
<span class="comment-copy">@AntoinePinsard, using the column name in this case is faster because Django won't try to do a join in the underlying query.  Django encourages these practices for necessary optimizations.  <a href="https://docs.djangoproject.com/en/2.1/topics/db/optimization/#use-foreign-key-values-directly" rel="nofollow noreferrer">docs.djangoproject.com/en/2.1/topics/db/optimization/…</a></span>
<span class="comment-copy">Generally speaking in python it's EAFP.  <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">docs.python.org/3/glossary.html#term-eafp</a></span>
