<div class="post-text" itemprop="text">
<p>I have two sets:</p>
<pre><code>&gt;&gt;&gt; a = {1,2,3}
&gt;&gt;&gt; b = {2,3,4,5,6}
</code></pre>
<p>And I would like to get <strong>two</strong> new sets with <strong>non</strong> common elements, first set containing elements from <code>a</code> and second from <code>b</code>, like <code>({1}, {4,5,6})</code>, or like:</p>
<pre><code>&gt;&gt;&gt; c = a&amp;b # Common elements
&gt;&gt;&gt; d = a^b # Symmetric difference
&gt;&gt;&gt; (a-b, b-a)
({1}, {4, 5, 6})
&gt;&gt;&gt; (a-c, b-c)
({1}, {4, 5, 6})
&gt;&gt;&gt; (a&amp;d, b&amp;d)
({1}, {4, 5, 6})
</code></pre>
<p>My problem is that I'm going to use this on large number of sha1 hashes and I'm worried about performance. <em>What is proper way of doing this efficiently</em>?</p>
<p>Note: <code>a</code> and <code>b</code> are going to have around 95% of elements common, 1% will be in <code>a</code> and 4% in <code>b</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Methods I've mentioned in the question has following performance:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('a-b; b-a', 'a=set(range(0,1500000)); b=set(range(1000000, 2000000))', number=1000)
135.45828826893307
&gt;&gt;&gt; timeit.timeit('c=a&amp;b; a-c; b-c', 'a=set(range(0,1500000)); b=set(range(1000000, 2000000))', number=1000)
189.98522938665735
&gt;&gt;&gt; timeit.timeit('d=a^b; a&amp;d; b&amp;d', 'a=set(range(0,1500000)); b=set(range(1000000, 2000000))', number=1000)
238.35084129583106
</code></pre>
<p>So most effective way seems to be using <code>(a-b, b-a)</code> method.</p>
<p><em>I'm posting this as a reference so other answers would add new methods, not compare the ones I've found.</em></p>
<hr/>
<h3>Python implemented function</h3>
<p>Just out of curiosity I've tried implementing own python function to do this (that works on pre-sorted iterators):</p>
<pre><code>def symmetric_diff(l1,l2):
    # l1 and l2 has to be sorted and contain comparable elements
    r1 = []
    r2 = []
    i1 = iter(l1)
    i2 = iter(l2)

    try:
        e1 = next(i1)
    except StopIteration: return ([], list(i2))
    try:
        e2 = next(i2)
    except StopIteration: return ([e1] + list(i1), [])

    try:
        while True: 
            if e1 == e2:
                e1 = next(i1)
                e2 = next(i2)
            elif e1 &gt; e2:
                r2.append(e2)
                e2 = next(i2)
            else:
                r1.append(e1)
                e1 = next(i1)

    except StopIteration:
        if e1==e2:
            return (r1+list(i1), r2+list(i2))
        elif e1 &gt; e2:
            return (r1+[e1]+list(i1), r2+list(i2))
        else:   
            return (r1+list(i1), r2+[e2]+list(i2))
</code></pre>
<p>Compared to other methods, this one has quite low performance:</p>
<pre><code>t = timeit.Timer(lambda: symmetric_diff(a,b))
&gt;&gt;&gt; t.timeit(1000)
542.3225249653769
</code></pre>
<p>So unless some other method is implemented somewhere (some library for working with sets) I think using two sets difference <em>is</em> the most efficient way of doing this.</p>
</div>
<span class="comment-copy"><code>a-b, b-a</code> is the way I have done this in the past, but it was for readability more than performance.  why don't you try a few of the methods and run them each through <code>timeit</code>?</span>
<span class="comment-copy">I don't think you will be able to beat <code>a-b, b-a</code>.  All Python has to do is evaluate the names <code>a</code> and <code>b</code> and then do a binary subtract with <code>-</code> (you can see the exact breakdown with <a href="https://docs.python.org/3/library/dis.html#dis.dis" rel="nofollow noreferrer"><code>dis.dis</code></a>).  The actual function however that creates the new sets is written in C, which will outperform anything written in Python.</span>
<span class="comment-copy">I think <code>a-b, b-a</code> will be O(n) and I can't imagine any way to get better than <code>O(n)</code> anyway.  Doing it with one iteration as opposed to twice will not change the complexity.</span>
<span class="comment-copy">It is an interesting question anyway, I often need to do this when finding out which elements to add / modify / delete when updating a many-to-many on relational databases</span>
