<div class="post-text" itemprop="text">
<p>Is there a quick way to replace part of the path in python? </p>
<p>for example:</p>
<pre><code>old_path='/abc/dfg/ghi/f.txt'
</code></pre>
<p>I don't know the beginning of the path (<code>/abc/dfg/</code>), so what I'd really like to tell python to keep everything that comes after <code>/ghi/</code> (inclusive) and replace everything before <code>/ghi/</code> with <code>/jkl/mno/</code>:</p>
<pre><code>&gt;&gt;&gt; new_path
    '/jkl/mno/ghi/f.txt/'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the index of <code>ghi</code>:</p>
<pre><code>old_path.replace(old_path[:old_path.index("ghi")],"/jkl/mno/")
In [4]: old_path.replace(old_path[:old_path.index("ghi")],"/jkl/mno/" )
Out[4]: '/jkl/mno/ghi/f.txt'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python 3.4+, or willing to install the <a href="https://pypi.python.org/pypi/pathlib2/" rel="noreferrer">backport</a>, consider using <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a> instead of <code>os.path</code>:</p>
<pre><code>path = pathlib.Path(old_path)
index = p.parts.index('ghi')
new_path = pathlib.Path('/jkl/mno').joinpath(*p.parts[index:])
</code></pre>
<hr/>
<p>If you just want to stick with the 2.7 or 3.3 stdlib, there's no <em>direct</em> way to do this, but you can get the equivalent of <code>parts</code> by looping over <code>os.path.split</code>. For example, keeping each path component until you find the first <code>ghi</code>, and then tacking on the new prefix, will replace everything before the last <code>ghi</code> (if you want to replace everything before the <em>first</em> <code>ghi</code>, it's not hard to change things):</p>
<pre><code>path = old_path
new_path = ''
while True:
    path, base = os.path.split(path)
    new_path = os.path.join(base, new_path)
    if base == 'ghi':
        break
new_path = os.path.join('/jkl/mno', new_path)
</code></pre>
<p>This is a bit clumsy, so you might want to consider writing a simple function that gives you a list or tuple of the path components, so you can just use <code>find</code>, then join it all back together, as with the <code>pathlib</code> version.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import os.path
&gt;&gt;&gt; old_path='/abc/dfg/ghi/f.txt'
</code></pre>
<p>First grab the relative path from the starting directory of your choice using <a href="https://docs.python.org/2/library/os.path.html#os.path.relpath" rel="noreferrer"><code>os.path.relpath</code></a></p>
<pre><code>&gt;&gt;&gt; rel = os.path.relpath(old_path, '/abc/dfg/')
&gt;&gt;&gt; rel
'ghi\\f.txt'
</code></pre>
<p>Then add the new first part of the path to this relative path using <a href="https://docs.python.org/2/library/os.path.html#os.path.join" rel="noreferrer"><code>os.path.join</code></a></p>
<pre><code>&gt;&gt;&gt; new_path = os.path.join('jkl\mno', rel)
&gt;&gt;&gt; new_path
'jkl\\mno\\ghi\\f.txt'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A rather naive approach, but does the job:</p>
<p>Function:</p>
<pre><code>def replace_path(path, frm, to):
    pre, match, post = s.rpartition(frm)
    return ''.join((to if match else pre, match, post))
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; replace_path(s, '/ghi/', '/jkl/mno')
'/jkl/mno/ghi/f.txt'
&gt;&gt;&gt; replace_path(s, '/whatever/', '/jkl/mno')
'/abc/dfg/ghi/f.txt'
</code></pre>
</div>
<span class="comment-copy">I did not downvote, but this is not a great answer TBH. What if the sequence 'ghi' is repeated in the prefix? For instance, it won't work on <code>/fooghi/bar/ghi/baz</code>. Splitting into parts first could be better.</span>
<span class="comment-copy">@TheDataScientician, the OP wanted to replace a  full directory in the path, i.e <code>/ghi/</code>. Replacing a substring in the directory name is a very different thing.</span>
<span class="comment-copy">pathlib looks great, suppose there isn't an equivalent in Python 2.7?</span>
<span class="comment-copy">@HappyPy: Yes, there is. Not in the stdlib, but, like many of the new features of 3.x, there's a <a href="https://pypi.python.org/pypi/pathlib2/" rel="nofollow noreferrer">semi-official backport</a> on PyPI that has all of the features that make sense in 2.x. (I believe this means everything but the stuff about converting to locale-based bytes names on Unix and Unicode str names on Windows; instead, you just get plain unspecified str on both platforms.)</span>
<span class="comment-copy">For python &gt;3.4: You have to do an <code>import pathlib</code> and the first line of the example should be: <code>p = pathlib.Path(old_path)</code> instead of <code>path = pathlib.Path(old_path)</code>. Because it's referenced as <code>p</code> in the following lines. [Btw: the example helped a lot !]</span>
<span class="comment-copy">Sorry, forgot to mention that I don't know what the beginning of the path is, so ideally I would like to be able to tell python to select only the part of the path starting from /ghi/ and replace anything that comes before with /jkl/mno/. Is this possible somehow?</span>
<span class="comment-copy">That might be ambiguous though, what if you have <code>foo/bar/foo/folder/f.txt</code> and want to start at <code>foo</code>, which <code>foo</code> is it? Do you at least know how far up you want to go? like will it always be one folder up from the file location?</span>
<span class="comment-copy">Yes, I'm sure there are no repeated folder names within the path. So, it would be a sort of split. I want python to select everything from '/ghi/' (in my example that is /ghi/f.txt) and replace whatever comes before with /jkl/mno/.</span>
