<div class="post-text" itemprop="text">
<p>How to create <code>N</code> "random" strings of length <code>K</code> using the probability table? <code>K</code> would be some even number.</p>
<pre><code>prob_table = {'aa': 0.2, 'ab': 0.3, 'ac': 0.5}
</code></pre>
<p>Let's say <code>K = 6</code>, there would be a higher probability of <code>'acacab'</code> than <code>'aaaaaa'</code>.</p>
<p>This is sub-problem of a larger problem that I’m using to generate synthetic sequences based on a probability table.  I’m not sure how to use the probability table to generate “random” strings? </p>
<p>What I have so far:</p>
<pre><code>def seq_prob(fprob_table,K= 6, N= 10):
    #fprob_table is the probability dictionary that you input
    #K is the length of the sequence
    #N is the amount of sequences
    seq_list = []
    #possibly using itertools or random to generate the semi-"random" strings based on the probabilities 
    return seq_list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are some good approaches to making weighted random choices described <a href="https://docs.python.org/3/library/random.html#examples-and-recipes" rel="nofollow">at the end of the documentation for the builtin <code>random</code> module</a>:</p>
<blockquote>
<p>A common task is to make a random.choice() with weighted probabilities.</p>
<p>If the weights are small integer ratios, a simple technique is to build a sample population with repeats:</p>
</blockquote>
<pre><code>&gt;&gt;&gt; weighted_choices = [('Red', 3), ('Blue', 2), ('Yellow', 1), ('Green', 4)]
&gt;&gt;&gt; population = [val for val, cnt in weighted_choices for i in range(cnt)]
&gt;&gt;&gt; random.choice(population)
'Green'
</code></pre>
<blockquote>
<p>A more general approach is to arrange the weights in a cumulative distribution with itertools.accumulate(), and then locate the random value with bisect.bisect():</p>
</blockquote>
<pre><code>&gt;&gt;&gt; choices, weights = zip(*weighted_choices)
&gt;&gt;&gt; cumdist = list(itertools.accumulate(weights))
&gt;&gt;&gt; x = random.random() * cumdist[-1]
&gt;&gt;&gt; choices[bisect.bisect(cumdist, x)]
'Blue'
</code></pre>
<p>To adapt that latter approach to your specific problem, I'd do:</p>
<pre><code>import random
import itertools
import bisect

def seq_prob(fprob_table, K=6, N=10):
    choices, weights = fprob_table.items()
    cumdist = list(itertools.accumulate(weights))

    results = []
    for _ in range(N):
        s = ""
        while len(s) &lt; K:
            x = random.random() * cumdist[-1]
            s += choices[bisect.bisect(cumdist, x)]
        results.append(s)

    return results
</code></pre>
<p>This assumes that the key strings in your probability table are all the same length If they have multiple different lengths, this code will sometimes (perhaps most of the time!) give answers that are longer than <code>K</code> characters. I suppose it also assumes that <code>K</code> is an exact multiple of the key length, though it will actually work if that's not true (it just will give result strings that are all longer than <code>K</code> characters, since there's no way to get <code>K</code> exactly).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>random.random</code>:</p>
<pre><code>from random import random
def seq_prob(fprob_table, K=6, N=10):
    #fprob_table is the probability dictionary that you input
    #K is the length of the sequence
    #N is the amount of sequences
    seq_list = []
    s = ""
    while len(seq_list) &lt; N:
        for k, v in fprob_table.items():
            if len(s) == K:
                seq_list.append(s)
                s = ""
                break
            rn = random()
            if rn &lt;=  v:
                s += k
    return seq_list
</code></pre>
<p>This can be no doubt be improved upon but the  <code>random.random</code> is useful when dealing with probability. </p>
</div>
<div class="post-text" itemprop="text">
<p>I'm sure there is a <em>cleaner</em>/better way, but here is one easy way to do this.</p>
<p>Here we're filling <code>pick_list</code> with the 100 separate character-pair values, the number of values determined by the probability.  In this case, there are 20 <code>'aa'</code>, 30 <code>'ab'</code> and 50 <code>'ac'</code> entries within <code>pick_list</code>.  Then <code>random.choice(pick_list)</code> uniformly pulls a random entry from the list.</p>
<pre><code>import random

prob_table = {'aa': 0.2, 'ab': 0.3, 'ac': 0.5}


def seq_prob(fprob_table, K=6, N=10):
    #fprob_table is the probability dictionary that you input

    # fill list with number of items based on the probabilities
    pick_list = []
    for key, prob in fprob_table.items():
        pick_list.extend([key] * int((prob * 100)))    

    #K is the length of the sequence
    #N is the amount of sequences
    seq_list = []
    for i in range(N):
        sub_seq = "".join(random.choice(pick_list) for _ in range(int(K/2)))
        seq_list.append(sub_seq)
    return seq_list
</code></pre>
<p>With results:</p>
<pre><code> seq_prob(prob_table)
['ababac',
 'aaacab',
 'aaaaac',
 'acacac',
 'abacac',
 'acaaac',
 'abaaab',
 'abaaab',
 'aaabaa',
 'aaabaa']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your tables or sequences are large, using numpy may be helpful as it will probably be significantly faster.  Also, numpy is built for this sort of problem, and the approach is easy to understand and just 3 or 4 lines.</p>
<p>The idea would be to convert the probabilities into cumulative probabilities, ie, mapping <code>(.2, .5, .3)</code> to <code>(.2, .7, 1.)</code>, and then random numbers generated along the flat distribution from <code>0</code> to <code>1</code> will fall within the bins of the cumulative sum with a frequency corresponding to the weights.  Numpy's <code>searchsorted</code> can be used to quickly find which bin the random values lie within.  That is,</p>
<pre><code>import numpy as np

prob_table = {'aa': 0.2, 'ab': 0.3, 'ac': 0.5}
N = 10
k = 3   # number of strings (not number of characters)

rvals = np.random.random((N, k))         # generate a bunch of random values
string_indices = np.searchsorted(np.cumsum(prob_table.values()), rvals)   # weighted indices
x = np.array(prob_table.keys())[string_indices]     # get the strings associated with the indices
y = ["".join(x[i,:]) for i in range(x.shape[0])]    # convert this to a list of strings

# y = ['acabab', 'acacab', 'acabac', 'aaacaa', 'acabac', 'acacab', 'acabaa', 'aaabab', 'abacac', 'aaabab']
</code></pre>
<p>Here I used <code>k</code> as the number of strings you would need, rather than <code>K</code> as the number of characters, since the problem statement is ambiguous about strings/characters.</p>
</div>
<span class="comment-copy">this is a good question, random model sequences would be really useful!</span>
<span class="comment-copy">just a heads up: <code>itertools.accumulate()</code> is new in Python 3.2.</span>
<span class="comment-copy">I like this better than building a list as I did.  However, I think you need to make sure the probabilities are sorted.  Something like this should work, <code>ordered_probs = sorted((prob, char_pair) for char_pair, prob in fprob_table.items())</code>.</span>
