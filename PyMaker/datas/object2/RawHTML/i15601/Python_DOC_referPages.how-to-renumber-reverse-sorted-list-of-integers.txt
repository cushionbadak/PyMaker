<div class="post-text" itemprop="text">
<p>I have a list of numbers like this:</p>
<pre><code>[687, 687, 683, 683, 677, 662....] 
</code></pre>
<p>It is sorted in descending order and has many numbers.</p>
<p>I want to represent it like, the greater the number in the list, I want to give it the smallest value and so on. Like 687 becomes 0, then 683 becomes 1, then 677 becomes 2 and so on.</p>
<p>Is there a way to do this?</p>
<p>EDIT:</p>
<p>Actually, I want to represent the new_list as <code>[0,0,4,4,10,25..]</code> such that highest element gets 0, then the next element is the difference of the two numbers in the original list + the previous number in the new_list, like we get 4 by doing <code>(687-683) + 0</code> and so on. How to do that?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>myList = [687, 687, 683, 683, 677, 662]
unique_sorted_list = sorted(list(set(myList)), reverse = True)
result = []
for i in range(len(unique_sorted_list)):
    if i == 0:
        result.append((unique_sorted_list[i], i))
    else:
        result.append((unique_sorted_list[i], unique_sorted_list[i-1] - unique_sorted_list[i] + result[i-1][1]))

result = [j[1] for i in myList for j in result if i==j[0]]  
print result
</code></pre>
<p>And we get Output as:</p>
<pre><code>[0, 0, 4, 4, 10, 25]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Create a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>Counter</code></a> out of the list, replace the keys of the sorted result, and turn that back into a list:</p>
<pre><code>from collections import Counter
from itertools import count

# Get counts of each element in the list
original_counter = Counter([687, 687, 683, 683, 677, 662])

# Get only the unique values, in descending order
values = (v for k, v in sorted(original_counter.items(), reverse=True))

# Create a new counter out of 0, 1, 2, … and the sorted, unique values
new_counter = Counter(dict(zip(count(), values)))

# Retrieve a sorted list from the new counter
new_list = sorted(new_counter.elements())

print(new_list) # [0, 0, 1, 1, 2, 3]
</code></pre>
<p>This doesn’t require the original list to be sorted, either. It makes for a compact function:</p>
<pre><code>from collections import Counter
from itertools import count

def enumerate_unique(iterable):
    return sorted(Counter(dict(zip(count(),
        (v for k, v in sorted(Counter(iterable).items(), reverse=True)))))
        .elements())
</code></pre>
<p>On second thought, though, the straightforward way isn’t bad. It’s also a bit more efficient.</p>
<pre><code>def enumerate_unique(iterable):
    seen = {}
    counter = 0

    for x in iterable:
        i = seen.get(x)

        if i is None:
            seen[x] = counter
            yield counter
            counter += 1
        else:
            yield i
</code></pre>
<p>That one works on any list. Since you have a sorted list, though, there’s a very nice O(n):</p>
<pre><code>def enumerate_unique(sorted_iterable):
    last = None
    counter = -1

    for x in sorted_iterable:
        if x != last:
            counter += 1

        yield counter
</code></pre>
<p>To skip numbers as described, you could do this:</p>
<pre><code>def enumerate_unique(sorted_iterable):
    last = None
    last_index = -1

    for i, x in enumerate(sorted_iterable):
        if x != last:
            last_index = i

        yield last_index
</code></pre>
</div>
<span class="comment-copy">just iterate the list.</span>
<span class="comment-copy">@LindaSu I'm glad that I could help. If answer was helpful you can accept it or raise it. Thanks.</span>
<span class="comment-copy">@LindaSu Thanks Linda</span>
<span class="comment-copy">Perfect! Thanks a lot.</span>
<span class="comment-copy">One question though, is it possible to add numbers starting from 0 and the next number be the difference of the two number in the original list + previous number in the new_list? Like for the example, it be: [0,0,4,4,10,25]?</span>
<span class="comment-copy">@LindaSu: Sure! See update.</span>
