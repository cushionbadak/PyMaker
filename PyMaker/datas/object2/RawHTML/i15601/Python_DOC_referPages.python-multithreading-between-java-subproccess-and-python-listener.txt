<div class="post-text" itemprop="text">
<p>I am monitoring and Minecraft server and I am making a setup file in Python. I need to be able to run two threads, one running the minecraft_server.jar in the console window, while a second thread is constantly checking the output of the minecraft_server. Also, how would I input into the console from Python after starting the Java process?</p>
<p>Example:</p>
<pre><code>thread1 = threading.Thread(target=listener)
thread2 = minecraft_server.jar

def listener():
    if minecraft_server.jarOutput == "Server can't keep up!":
        sendToTheJavaProccessAsUserInputSomeCommandsToRestartTheServer
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's pretty hard to tell here, but I <em>think</em> what you're asking is how to:</p>
<ul>
<li>Launch a program in the background.</li>
<li>Send it input, as if it came from a user on the console.</li>
<li>Read its output that it tries to display to a user on the console.</li>
<li>At the same time, run another thread that does other stuff.</li>
</ul>
<p>The last one is pretty easy; in fact, you've mostly written it, you just need to add a <code>thread1.start()</code> somewhere.</p>
<p>The <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow"><code>subprocess</code></a> module lets you launch a program and control its input and output. It's easiest if you want to just feed in all the input at once, wait until it's done, then process all the output, but obviously that's not your case here, so it's a bit more involved:</p>
<pre><code>minecraft = subprocess.Popen(['java', 'path/to/minecraft_server.jar', '-other', 'args],
                             stdin=subprocess.PIPE, 
                             stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
</code></pre>
<p>I'm merging stdout and stderr together into one pipe; if you want to read them separately, or send stderr to /dev/null, or whatever, see the docs; it's all pretty simple. While we're making assumptions here, I'm going to assume that <code>minecraft_server</code> uses a simple line-based protocol, where every command, every response, and every info message is exactly one line (that is, under 1K of text ending in a <code>\n</code>).</p>
<p>Now, to send it input, you just do this:</p>
<pre><code>minecraft.stdin.write('Make me a sandwich\n')
</code></pre>
<p>Or, in Python 3.x:</p>
<pre><code>minecraft.stdin.write(b'Make me a sandwich\n')
</code></pre>
<p>To read its output, you do this:</p>
<pre><code>response = minecraft.stdout.readline()
</code></pre>
<hr/>
<p>That works just like a regular file. But note that it works like a <em>binary</em> file. In Python 2.x, the only difference is that newlines don't get automatically converted, but in Python 3.x, it means you can only write <code>bytes</code> (and compatible objects), not <code>str</code>s, and you will receive <code>bytes</code> back. There are good reasons for that, but if you want to get pipes that act like text files instead, see the <code>universal_newlines</code> (and possibly <code>bufsize</code>) arguments under <a href="https://docs.python.org/3/library/subprocess.html#frequently-used-arguments" rel="nofollow">Frequently Used Arguments</a> and <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="nofollow"><code>Popen</code> Constructor</a>.</p>
<hr/>
<p>Also, it works like a <em>blocking</em> file. With a regular file, this rarely matters, but with a pipe, it's quite possible that there will be data later, but there isn't data yet (because the server hasn't written it yet). So, if there is no output yet (or not a complete line's worth, since I used <code>readline()</code>), your thread just blocks, waiting until there is.</p>
<p>If you don't want that, you probably want to create another thread to service stdout. And its function can actually look pretty similar to what you've got:</p>
<pre><code>def listener():
    for line in minecraft.stdout:
        if line.strip() == "Server can't keep up!":
            minecraft.stdin.write("Restart Universe\n")
</code></pre>
<p>Now that thread can block all day and there's no problem, because your other threads are still going.</p>
<hr/>
<p>Well, not quite <em>no</em> problem. </p>
<p>First it's going to be hard to cleanly shut down your program. </p>
<p>More seriously, the pipes between processes have a fixed size; if you don't service stdout fast enough, or the child doesn't service stdin fast enough, the pipe can block. And, the way I've written things, if the stdin pipe blocks, we'll be blocked forever in that <code>stdin.write</code> and won't get to the next read off <code>stdout</code>, so that can block too, and suddenly we're both waiting on each other forever.</p>
<p>You can solve this by having another thread to service stdout. The <code>subprocess</code> module itself includes an example, in the <a href="https://hg.python.org/cpython/file/3.4/Lib/subprocess.py#l1175" rel="nofollow"><code>Popen._communicate</code></a> function used by all the higher-level functions. (Make sure to look at Python 3.3 or later, because earlier versions had bugs.)</p>
<p>If you're in Python 3.4+ (or 3.3 with a backport off PyPI), you can instead use <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.create_subprocess_exec" rel="nofollow"><code>asyncio</code></a> to rewrite your program around an event loop and handle the input and output the same way you'd write a reactor-based network server. That's what all the cool kids are doing in 2017, but back in late 2014 many people still thought it looked new and scary.</p>
<hr/>
<p>If all of this is sounding like a lot more work than you signed on for, you may want to consider using <a href="https://pexpect.readthedocs.org/en/latest/" rel="nofollow"><code>pexpect</code></a>, which wraps up a lot of the tedious details, and makes some simplifying assumptions that are probably true in your case.</p>
</div>
<span class="comment-copy">What do you mean by "input into the console from Python"? You want to feed input into <code>minecraft_server.jar</code> as if your program were its console? Or share the real console's stdin with the server and somehow multiplex between the two so you can get user input? Orâ€¦?</span>
<span class="comment-copy">I want to feed input into minecraft_server.jar as if my program where its console. @abarnert</span>
<span class="comment-copy">Exactly what I was looking for, thanks for such a thorough runthrough of how everything should work.</span>
<span class="comment-copy">I am trying to use minecraft.stdin.write("say hello world\n") but I keep getting a type error saying that str is not supported by the buffer type? Any idea why?  Specs: Windows 7 Python 3.4.2  @abarnert</span>
<span class="comment-copy">@TheMountainFurnaceGabriel: Do you not know about the difference between <code>str</code> and <code>bytes</code>, and text and binary file objects? Let me edit the answer.</span>
<span class="comment-copy">Should I just convert the string to bytes and that will fix the problem? bytes("say hello world\n", 'utf-8')</span>
<span class="comment-copy">@TheMountainFurnaceGabriel: Of course if you're really just sending literals like that, and they're always pure ASCII, there's no reason to write them as Unicode <code>str</code> literals and then encode them; just write them as <code>bytes</code> literals: <code>b'say hello world\n'</code>.</span>
