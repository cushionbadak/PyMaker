<div class="post-text" itemprop="text">
<p>I've been trying to figure something out, easiest way to explain is using an example:</p>
<pre><code>a = [[1, 2, 4], [2, 5], [0, 3, 7, 8], [12, 3, 6], [18, 14]]
</code></pre>
<p>This is the kind of list I start from.
I need to end up with a list that contains lists of all the lists in a that contain overlapping elements added together.</p>
<pre><code>result = [[1, 2, 4, 5], [0, 3, 6, 7, 8, 12], [14, 18]]
</code></pre>
<p>How would I go about this?</p>
<p>Kind regards,
Daquicker</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = [[1, 2, 4], [2, 5], [0, 3, 7, 8], [12, 3, 6], [18, 14]]

result = []
for s in a:
    s = set(s)
    for t in result:
        if t &amp; s:
            t.update(s)
            break
    else:
        result.append(s)
</code></pre>
<p>This will go one-by-one through the list and create a set from the current sublist (<code>s</code>). Then it will check in the results, if there is another set <code>t</code> that has a non-empty intersection with it. If that’s the case, the items from <code>s</code> are added to that set <code>t</code>. If there is no <code>t</code> with a non-empty intersection, then <code>s</code> is a new independent result and can be appended to the result list.</p>
<p>A problem like this is also a good example for a <a href="http://en.wikipedia.org/wiki/Fixed-point_iteration" rel="nofollow">fixed-point iteration</a>. In this case, you would look at the list and continue to merge sublists as long as you could still find lists that overlap. You could implement this using <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow"><code>itertools.combinations</code></a> to look at pairs of sublists:</p>
<pre><code>result = [set(x) for x in a] # start with the original list of sets
fixedPoint = False # whether we found a fixed point
while not fixedPoint:
    fixedPoint = True
    for x, y in combinations(result, 2): # search all pairs …
        if x &amp; y: # … for a non-empty intersection
            x.update(y)
            result.remove(y)

            # since we have changed the result, we haven’t found the fixed point
            fixedPoint = False

            # abort this iteration
            break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way I can think of doing this is through recursion. Start with one item, then loop until you find every number it's connected to. For each of these numbers, you must do the same. Hence the recursion. To make it more efficient, store numbers you've visited in a list and check it at the beginning of each recursive sequence to make sure you don't repeat any explorations.</p>
</div>
<div class="post-text" itemprop="text">
<p>A two liner:</p>
<pre><code>a_set = [set(x) for x in a]
result = [list(x.union(y)) for i,x in enumerate(a_set) for y in a_set[i:] 
          if x.intersection(y) and x != y]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have left the last step for you:</p>
<pre><code>a = [[1, 2, 4], [2, 5], [0, 3, 7, 8], [12, 3, 6], [18, 14]]
result = [[1, 2, 4, 5], [0, 3, 6, 7, 8, 12], [14, 18]]
# each sub list
result2 = []
count = 0
print a
for sub_list in a:
    print count
    print "sub_list: " + str(sub_list)
    a.pop(count)
    print "a: " + str(a)
    #each int
    sub_list_extend_flag = False
    for int_in_sub_list in sub_list:
        print "int_in_sub_list: " + str(int_in_sub_list)
        for other_sub_list in a:
            print "current_other_sub_list: " + str(other_sub_list)
            if int_in_sub_list in other_sub_list:
                sub_list_extend_flag = True
                other_sub_list.extend(sub_list)

                result2.append(list(set(other_sub_list)))
    if not sub_list_extend_flag:
        result2.append(sub_list)
    count += 1
print result2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple answer:</p>
<pre><code> a = [[1, 2, 4], [2, 5], [0, 3, 7, 8], [12, 3, 6], [18, 14]]
for x in a:
    for y in x:
        print y
</code></pre>
<p>its more simple than first one:</p>
<pre><code>box=[]
a = [[1, 2, 4], [2, 5], [0, 3, 7, 8], [12, 3, 6], [18, 14]]
for x in a:
    for y in x:
        box.append(y)
print box
</code></pre>
<p><strong>Result:</strong>[1, 2, 4, 2, 5, 0, 3, 7, 8, 12, 3, 6, 18, 14]</p>
<p>And with this, you can compare the numbers:</p>
<pre><code>box=[]
box2=""
a = [[1, 2, 4], [2, 5], [0, 3, 7, 8], [12, 3, 6], [18, 14]]
for x in a:
    for y in x:
        box.append(y)
print box

for a in box:
    box2+=str(a)
print box2
</code></pre>
<p><strong>Result:</strong> 12425037812361814</p>
<p>Also you can make it more cute:</p>
<pre><code>print " ".join(box2)
</code></pre>
<p><strong>Result:</strong> 1 2 4 2 5 0 3 7 8 1 2 3 6 1 8 1 4</p>
</div>
<span class="comment-copy">Could all the subsists be stored as lists?</span>
<span class="comment-copy">The number of sublists is not known beforehand.</span>
<span class="comment-copy">One (perhaps unnecessarily convoluted) way of looking at this problem is as finding the connected components of the bipartite graph, with one set of nodes being the sublists of <code>a</code> and the other set being their entries.</span>
<span class="comment-copy">@qqvc (via <a href="http://stackoverflow.com/review/suggested-edits/6336403">suggested edit</a>): Please don't edit a question to include the answer.  Post it as an answer.</span>
<span class="comment-copy">Seems to work nicely, Thankyou!</span>
<span class="comment-copy">This drops <code>{14, 18}</code> though since it doesn’t intersect with anything else.</span>
<span class="comment-copy">This also doesn’t work at all for a list of lists, where <i>more than two</i> lists are overlapping each. For example <code>[[1, 2], [2, 3], [3, 4]]</code>.</span>
<span class="comment-copy">@poke, why should <code>{14, 18}</code> be included? The question says "a list that contains lists of all the lists in a that contain overlapping elements added together". <code>{14, 18}</code> doesn't have any overlapping element with another sublist.</span>
<span class="comment-copy">If you look at OP’s example, you can clearly see that <code>[14, 18]</code> is included in the desired output. The result should be all lists from the input, but with those sublists combined where there are overlapping elements.</span>
<span class="comment-copy">This gives <code>[[1, 2, 4, 5], [1, 2, 4, 5], [0, 3, 6, 7, 8, 12], [0, 3, 6, 7, 8, 12], [0, 3, 6, 7, 8, 12], [18, 14]]</code> for me which is not the desired result. Ignoring the duplicated lists in the results, this also doesn’t work for lists of sublists where <i>more than two</i> or <i>none</i> are overlapping. For example <code>[[1, 2], [2, 3], [3, 4], [5, 6]]</code>.</span>
<span class="comment-copy">Did you read the question at all?</span>
