<div class="post-text" itemprop="text">
<p>How do I get a response from the server?</p>
<p>Client side:</p>
<pre><code>#CLIENT
import socket
import time

host = "localhost"
port = 5454

data_c = input()
c = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)


c.sendto(bytes(data_c, 'utf-8'),(host,port))
print( data_c )

print( c.recv(1024).decode('utf-8'))
</code></pre>
<p>SERVER side:</p>
<pre><code>#SERVER
import socket
import time

host = "localhost" 
port = 5454

data_s = "ACKNOWLEDGMENT"
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)       
s.bind((host, port))

print(s.recv(1024).decode('utf-8'))
</code></pre>
<p>I can send a message from the server that the client will receive, but can not seem to get communication (like an ACK.) to make it back to the server. </p>
<p>(yes UDP is not a good way to be doing this i'm pretty sure, but that was a specific for the project)  </p>
</div>
<div class="post-text" itemprop="text">
<p>for question 1: to send the ACK, you could replicate what you have in the reverse direction. </p>
</div>
<div class="post-text" itemprop="text">
<p>Since UDP is connection-less you don't know beforehand you receive a packet where the packet will come from, so you have to use <a href="https://docs.python.org/3/library/socket.html#socket.socket.recvfrom" rel="nofollow"><code>recvfrom</code></a> to get both the packet <em>and</em> the peer (address/port) the packet came from. Then you have to use that address to send data back.</p>
<p>What you're doing now in your client (but what really looks like the server) in the loop is send the same data over and over <em>to itself</em>. Instead in the loop you should receive packets using the previously mentions <code>recvfrom</code> then send replies to the peer you received the packet from.</p>
<p>So something like the following <em>pseudo</em> code</p>
<pre><code>while True:
    peer = recvfrom(...)
    sendto(..., peer)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After many attempts to get a simple acknowledgment reply from my server this did it. 
Beyond literally starting completely over each round, the time.sleep(.1) function was the only missing key.  It allowed the server and client both time to close the current socket connection so that there was not an error of trying to bind multiple bodies to a single location or something.</p>
<pre><code>OSError: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is     normally permitted
</code></pre>
<p>Working result:</p>
<pre><code>#SERVER
import socket
import time

host = "localhost" 
port = 5454   
data_s = "ACKNOWLEDGMENT"


while 1:
   s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
   s.bind((host, port))    
   received = print("Client: " + s.recv(1024).decode('utf-8'))   #waiting to receive
   s.close
   s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
   time.sleep(.1)



   s.sendto(bytes(data_s, 'utf-8'),(host,port))    #sending acknowledgment
   print("Server: " + data_s)
   s.close        # close out so that nothing sketchy happens 
   time.sleep(.1) # the delay keeps the binding from happening to quickly
</code></pre>
<p>Server Command Window:</p>
<pre><code>&gt;&gt;&gt; 
Client: hello
Server: ACKNOWLEDGMENT
</code></pre>
<p>Client:</p>
<pre><code>#CLIENT
import socket
import time

host = "localhost"
port = 5454
c = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

while 1:
    data_c = input("Client: ")
    c = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    c.sendto(bytes(data_c, 'utf-8'),(host,port))    #send message
    c.close
   # time.sleep()



    c = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    c.bind((host, port))
    print("Server: " + c.recv(1024).decode('utf-8'))    # waiting for acknowledgment
    c.close
    c = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    time.sleep(.1)
</code></pre>
<p>Client Command Window:</p>
<pre><code>&gt;&gt;&gt;
Client: hello
Client: hello
Server: ACKNOWLEDGMENT
</code></pre>
<p>I did finally remove the redundant input("Client: ") there at the top. 
A special thanks @JoachimPileborg for helping, but I have to give it to the little guy just because it was the path I ended up taking. </p>
</div>
<span class="comment-copy">Questions on SO should be specific, only one question per question so to say. If you have multiple problems, post multiple questions, each with as much detail as possible, including what you have tried (i.e. show some <i>relevant</i> code), how it worked or not worked, expected and actual output for some specific input, etc.</span>
<span class="comment-copy">this is a school project that is aimed at replicating a simple ftp</span>
<span class="comment-copy">Do you really feel like reimplementing TCP/SCTP? I highly doubt this is within the scope of a school assignment.</span>
<span class="comment-copy">The fact that you think that and and also that we only started our first python program a few weeks ago probably means that you are right.  However it was very specific that this has to be done over UDP. I even left out the part where the files being transfered have to be secured so its really SFTP we are recreating.</span>
<span class="comment-copy">I think you switched place of the client and server code.</span>
<span class="comment-copy">ahhh I see what you mean by they look swapped, and how i'm sending the client back to the client. I'm going to try and do some shuffling and try the recvfrom() I had been using it but started to assume they were the same</span>
<span class="comment-copy">could you possibly be more specific on the syntax for this. I'm noob to python and have tried this method in several ways but cant seem to get it.</span>
