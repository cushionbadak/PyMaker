<div class="post-text" itemprop="text">
<p>I am trying to open <a href="https://developer.uspto.gov/product/patent-application-full-text-dataxml" rel="nofollow noreferrer">bulk data from the USPTO</a>. The xml files within the zips are concatenated xml files containing multiple xml declarations and are quiet large. I am trying to only read lines from the xml until i get to the next xml declaration. I found <a href="https://stackoverflow.com/questions/5687056/parsing-a-file-with-multiple-xmls-in-it">this</a> related question, without code.</p>
<p>What I want to create is a function that does the following:</p>
<ol>
<li>For each *.zip file</li>
<li>Extract all xml file(s) (or open xml file(s) for reading)</li>
<li>Read lines from the xml file(s)</li>
<li>Append each line until the next xml declaration</li>
<li>Return the string</li>
</ol>
<p>So far, I've been able to open the zip file, find all the xml file(s) and extract each xml file. I would prefer to not write the xml file to disk, but instead create a string that is a single xml document that I then further parse. </p>
<pre><code>def main():
path = 'bulk/'
allFiles = glob.glob(path + '*.zip')
allFiles.sort()

for file in allFiles:
    try:
        with zipfile.ZipFile(file, mode = 'r', allowZip64 = True) as fin:
            print(fin, '- ok')
            print(fin.namelist())
            for name in fin.namelist():
                if name.endswith('xml'):
                    print(name) # all files that end in 'xml'
                    fin.extract(name, path='bulk/')
                    print('extracted ', name)
                    # TODO function to read lines of the xml file and




    except zipfile.BadZipFile:
            print(file,'- Bad zip file')

if __name__ == '__main__': main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile.read" rel="nofollow noreferrer"><code>read</code></a> instead of <code>extract</code>. It returns the bytes of a file in the zip, given a name. It's important to understand that you're essentially extracting the archive to memory, so be aware of how much data is actually going to be extracted and your limitations in that regard.</p>
<p>For example, the following function returns a dict with the names of a zip archive's files as keys, and the files' contents as values:</p>
<pre><code>from zipfile import ZipFile

def extract(f):
    zf = ZipFile(f)
    return {name: zf.read(name) for name in zf.namelist()}
</code></pre>
</div>
