<div class="post-text" itemprop="text">
<p>In Python's <code>typing</code> module, it seems that anything that is not a <a href="https://docs.python.org/3/library/typing.html#generics" rel="nofollow noreferrer">generic</a> type does not support subscripting:</p>
<pre><code>&gt;&gt;&gt; import typing
&gt;&gt;&gt; from yarl import URL

&gt;&gt;&gt; StrOrURL = typing.Union[URL, str]
&gt;&gt;&gt; typing.List[StrOrURL]                # OK; List is generic
typing.List[typing.Union[yarl.URL, str]]

&gt;&gt;&gt; SetOrDict = typing.Union[set, dict]
&gt;&gt;&gt; SetOrDict[StrOrURL]                  # Raises
TypeError: typing.Union[set, dict] is not a generic class
</code></pre>
<p>This will be the case whether <code>SetOrDict</code> is defined with <code>typing.Union</code> or <code>typing.TypeVar</code>.  (In Python 3.7, at least.)</p>
<p>It looks like there is a way to subclass <code>Generic</code>, presumably like:</p>
<pre><code>class SetOrDict(typing.Generic[StrOrURL]):
    # ...
</code></pre>
<p>But this will immediately raise <code>TypeError: Parameters to Generic[...] must all be type variables</code>.</p>
<p>Is there a way to accommodate the above?  I.e., what is the recommended practice for subscripting user-defined (non-generic) typedefs?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't use a <code>Union[...]</code>, alias or otherwise, as a generic type, no. Your union <em>contents</em> are also not generic, you can't state what types a <code>dict</code> or <code>set</code> object can contain by using <code>dict</code> or <code>set</code> directly, you'd use <a href="https://docs.python.org/3/library/typing.html#typing.Set" rel="nofollow noreferrer"><code>Set</code></a> or <a href="https://docs.python.org/3/library/typing.html#typing.Dict" rel="nofollow noreferrer"><code>Dict</code></a>. </p>
<p>You have a new union:</p>
<pre><code>URLorStrSetOrDict = typing.Union[Set[StrOrUrl], Dict[StrOrUrl, Any]]
</code></pre>
<p>Note that a dictionary has <em>keys and values</em>, you need to provide information on both. If this used as the input for an API, then consider using the more generic and immutable <code>AbstractSet</code> and <code>Mapping</code> types; this makes it clear that your API only needs to <em>read</em> information.</p>
<p>Personally, I'd look hard at refactoring a codebase that is this muddy about what kinds of objects it can accept. Requiring that an API accepts only sets and existing code has to pass in <code>set(dictionary)</code> instead of <code>dictionary</code> is not an arduous requirement, or perhaps the API really would work with any <em>iterable</em> of <code>StrOrUrl</code>.</p>
</div>
<span class="comment-copy">You really would want to refactor code that accepts either sets or dictionaries, <i>anyway</i>.</span>
<span class="comment-copy">Normally I would agree - in this case it's basically just a reminder that the input should support O(1) membership testing @MartijnPieters.  But thank you, I will consider that.</span>
<span class="comment-copy">I'd steer away from trying to capture that in type hinting. If you require membership testing to work, use <code>Container</code>. Performance choices are separate from correctness checking.</span>
