<div class="post-text" itemprop="text">
<p>I have data like --</p>
<pre><code>sample 1, domain 1, value 1
sample 1, domain 2, value 1
sample 2, domain 1, value 1
sample 2, domain 3, value 1
</code></pre>
<p>-- stored in a dictionary --</p>
<pre><code>dict_1 = {('sample 1','domain 1'): value 1, ('sample 1', 'domain 2'): value 1} 
</code></pre>
<p>-- etc.</p>
<p>Now, I have a different kind of value, named value 2 --</p>
<pre><code>sample 1, domain 1, value 2
sample 1, domain 2, value 2
sample 2, domain 1, value 2
sample 2, domain 3, value 2
</code></pre>
<p>-- which I again put in a dictionary, </p>
<pre><code>dict_2 = {('sample 1','domain 1'): value 2, ('sample 1', 'domain 2'): value 2}
</code></pre>
<p>How can I merge these two dictionaries in python? The keys, for instance <code>('sample 1', 'domain 1')</code> are the same for both dictionaries.</p>
<p>I expect it to look like --</p>
<pre><code>final_dict = {('sample 1', 'domain 1'): (value 1, value 2), ('sample 1', 'domain 2'): (value 1, value 2)}
</code></pre>
<p>-- etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>The closest you're likely to get to this would be a <code>dict</code> of <code>list</code>s (or <code>set</code>s). For simplicity, you usually <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">go with <code>collections.defaultdict(list)</code></a> so you're not constantly checking if the key already exists. You need to map to some collection type as a value because <code>dict</code>s have unique keys, so you need some way to group the multiple values you want to store for each key.</p>
<pre><code>from collections import defaultdict

final_dict = defaultdict(list)

for d in (dict_1, dict_2):
    for k, v in d.items():
        final_dict[k].append(v)
</code></pre>
<p>Or equivalently <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer">with <code>itertools.chain</code></a>, you just change the loop to:</p>
<pre><code>from itertools import chain

for k, v in chain(dict_1.items(), dict_2.items()):
    final_dict[k].append(v)
</code></pre>
<p>Side-note: If you really need it to be a proper <code>dict</code> at the end, and/or insist on the values being <code>tuple</code>s rather than <code>list</code>s, a final pass can convert to such at the end:</p>
<pre><code>final_dict = {k: tuple(v) for k, v in final_dict.items()}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use set intersection of keys to do this:</p>
<pre><code>dict_1 = {('sample 1','domain 1'): 'value 1', ('sample 1', 'domain 2'): 'value 1'} 
dict_2 = {('sample 1','domain 1'): 'value 2', ('sample 1', 'domain 2'): 'value 2'} 

result = {k: (dict_1.get(k), dict_2.get(k)) for k in dict_1.keys() &amp; dict_2.keys()}

print(result)
# {('sample 1', 'domain 1'): ('value 1', 'value 2'), ('sample 1', 'domain 2'): ('value 1', 'value 2')}
</code></pre>
<p>The above uses <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><code>dict.get()</code></a> to avoid possibilities of a <a href="https://docs.python.org/3/library/exceptions.html#KeyError" rel="nofollow noreferrer">KeyError</a> being raised(very unlikely), since it will just return <code>None</code> by default. </p>
<p>As <a href="https://stackoverflow.com/questions/54094401/merging-two-dictionaries-with-a-key-consisting-of-two-values/#comment95021386_54094511">@ShadowRanger</a> suggests in the comments, If a key is for some reason not found, you could replace from the opposite dictionary:</p>
<pre><code>{k: (dict_1.get(k, dict_2.get(k)), dict_2.get(k, dict_1.get(k))) for k in dict_1.keys() | dict_2.keys()}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Does something handcrafted like this work for you?</p>
<pre><code>dict3 = {} 
for i in dict1: 
    dict3[i] = (dict1[i], dict2[i]) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import defaultdict
from itertools import chain
dict_1 = {('sample 1','domain 1'): 1, ('sample 1', 'domain 2'): 2} 
dict_2 = {('sample 1','domain 1'): 3, ('sample 1', 'domain 2'): 4}

new_dict_to_process = defaultdict(list)
dict_list=[dict_1.items(),dict_2.items()]
for k,v in chain(*dict_list):
     new_dict_to_process[k].append(v)
</code></pre>
<p>Output will be </p>
<pre><code>{('sample 1', 'domain 1'): [1, 3],
 ('sample 1', 'domain 2'): [2, 4]})
</code></pre>
</div>
<span class="comment-copy">what do you expect these two dictionaries "merged" should look like?</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/38987/how-to-merge-two-dictionaries-in-a-single-expression">How to merge two dictionaries in a single expression?</a></span>
<span class="comment-copy">@JaredSmith: Not a duplicate (of that question in any event); this one seems to want to preserve the values from both <code>dict</code>s, not keep the last value for a given key.</span>
<span class="comment-copy">What do you mean by "merge"?  What is the expected output (concrete example)?</span>
<span class="comment-copy">Without seeing both SPARQL queries, it's impossible to say whether a single query would be possible ...</span>
<span class="comment-copy">This would be the cleanest way to do it without suffering from KeyErrors. +1</span>
<span class="comment-copy">The first solution seems to be working for me (strangely, the second does not). I merely need to have the values be ready for plotting against each other.  Massive thanks!</span>
<span class="comment-copy">@Dymphy: To be clear, the second block should still include the import for <code>defaultdict</code> and the initialization of the empty <code>final_dict</code> from the first block. I omitted them for brevity, but <code>final_dict</code> still needs to be a <code>defaultdict(list)</code> in both cases. The second block is just showing a way to reduce the level of loop nesting. If adding the imports and initial definition of <code>final_dict</code> doesn't make the second loop work, let me know (and provide the error), because it should be exactly equivalent.</span>
<span class="comment-copy">Yes, that was indeed the problem. Thank you for your help!</span>
<span class="comment-copy">Yeah, that's nice. What happens to a key that's not in both dicts?</span>
<span class="comment-copy">@MarkMeyer I see your point. I guess you could call <code>dict.get()</code> instead, which will just put <code>None</code> instead of raising <code>KeyError</code>? But I have a hard time seeing this happening, since the <code>&amp;</code> will only bring up intersecting keys(both keys must exist in both dictionaries), so a <code>KeyError</code> shouldn't happen.</span>
<span class="comment-copy">@RoadRunner: Or for amusement (or seriously for some really esoteric scenarios), you could make each <code>get</code>'s default the value from the other <code>dict</code>, so if only one dict has the key, you get a <code>tuple</code> with the same value twice: <code>{k: (dict_1.get(k, dict_2.get(k)), dict_2.get(k, dict_1.get(k))) for k in dict_1.keys() | dict_2.keys()}</code> :-) A little wasteful, but harmless.</span>
<span class="comment-copy">I have tried this, but it did not work.</span>
<span class="comment-copy">Sorry for that. Have you tried to replace dict1 and dict2 with your dictionaries name? Are you sure that the two dictionaries have the same keys?</span>
<span class="comment-copy">That's not how <code>chain</code> works... The nested loop structure makes no sense at all here.</span>
<span class="comment-copy">@ShadowRanger Was still editing.</span>
