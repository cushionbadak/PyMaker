<div class="post-text" itemprop="text">
<p>I have a complex list that contains another list. Each list forms part of a set (In another part of the program it reads in 3 values at a time, if you have 2 loads of 3 values it then sets them each up in a single set. 
So for example below my first set of inputs were:</p>
<pre><code>12, 11, 1
12, 6, 2
8, 7, 1
</code></pre>
<p>then my second set of input was:</p>
<pre><code>6, 6, 1
</code></pre>
<p>So effectively each input would be part of a set:</p>
<pre><code>Set 1:
12, 11, 1
12, 6, 2
8, 7, 1

Set 2:
6, 6, 1
</code></pre>
<p>This gets set to a "History" variable that remembers all the sets and their inputs until cleared, stored as a [[inputs]setnumber] where the outer item is the set number and the inner items are the inputs that were received on that set:</p>
<pre><code>[[12, 11, 1], 1]
[[12, 6, 2], 1]
[[8, 7, 1], 1]
[[6, 6, 1], 2]
</code></pre>
<p>What I need to do is print them out in a format of:</p>
<pre><code>Starting with set 1:
12, 11, 1
12, 6, 2
8, 7, 1

Starting with set 2: 
6, 6, 1
</code></pre>
<p>Instead, what I get is:</p>
<pre><code>Starting with set 1
The Following appear:12,11,1
Starting with set 1
The Following appear:12,6,2
Starting with set 1
The Following appear:8,7,1
Starting with set 2
The Following appear:6,6,1
</code></pre>
<p>No matter how hard I try or how many times I play around with some if statements, while loops (This one just makes things worse) I cannot get it to behave like I expect it to. Currently my base code is below. </p>
<p>I am so sure I am missing something simple or using the wrong type of object, but for the life of me the solution has eluded me and is driving me mad. </p>
<pre><code>SetHistory = [[[12, 11, 1], 1], [[12, 6, 2], 1], [[8, 7, 1], 1], [[6, 6, 1], 2]]

for Results, Set_Number in SetHistory:
    UnpackResults = [Results]
    UnpackSet = [Set_Number]
    for i in UnpackSet:
        print(f'Starting with set {Set_Number}')
        for i, v, x in UnpackResults:
            print(f'The Following appear:{i},{v},{x} ')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to group the "inputs" by your "sets" numbers like this:</p>
<pre><code>from itertools import groupby
from operator import itemgetter


set_history = [[[12, 11, 1], 1], [[12, 6, 2], 1], [[8, 7, 1], 1], [[6, 6, 1], 2]]

for key, group in groupby(set_history, key=itemgetter(1)):
    print(f'Starting with set {key}:')
    for item in group:
        print(*item[0], sep=", ")
</code></pre>
<p>gives:</p>
<pre><code>Starting with set 1:
12, 11, 1
12, 6, 2
8, 7, 1
Starting with set 2:
6, 6, 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's solve this using a dictionary. </p>
<pre><code>SetHistory = [[[12, 11, 1], 1], [[12, 6, 2], 1], [[8, 7, 1], 1], [[6, 6, 1], 2]]

set_dict = {}
for Results, Set_Number in SetHistory:
    if Set_Number in set_dict: 
        set_dict[Set_Number].append(Results)
    else:
        set_dict[Set_Number] = [Results]
for a_set in sorted(set_dict): 
    print('Set '+str(a_set))
    for val_list in set_dict[a_set]:
        print(*val_list)
</code></pre>
<p>This way, each entry in a dictionary is a set number. It contains a list of lists for that number, so you know what the set number before you process each list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using your approach, you could solve that by storing temporarily the complete "set" (it's actually a list here):</p>
<pre><code>SetHistory = [[[12, 11, 1], 1], [[12, 6, 2], 1], [[8, 7, 1], 1], [[6, 6, 1], 2]]

UnpackResults = []
Set_Number_old = 1
for Results, Set_Number in SetHistory:
    if Set_Number_old == Set_Number:
        UnpackResults.append(Results)
    else:
        print('Starting with set {}'.format(Set_Number_old))
        for i, v, x in UnpackResults:
            print('The Following appear:{},{},{} '.format(i, v, x))

        Set_Number_old = Set_Number
        UnpackResults = [Results]

print('Starting with set {}'.format(Set_Number_old))
for i, v, x in UnpackResults:
    print('The Following appear:{},{},{} '.format(i, v, x))
</code></pre>
<p>Your <code>SetHistory</code> is of shape (4,2). in <code>for Results, Set_Number in SetHistory:</code> you just get the the number of the set in every iteration and then you immediately print it. You actually want to store all the results corresponding to that specific set and print it once you get to the next set. 
I recommend to use a dictionary (<a href="https://docs.python.org/3/tutorial/datastructures.html?highlight=dictionary" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html?highlight=dictionary</a> see 5.5) for your case.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's my approach based on dictionary:</p>
<pre><code>d = dict()
for res, n in SetHistory:
    d[n] = d.get(n, []) + [res]

for k, v in d.items():
    print(f'set {k}:')
    print(v)

# set 1:
# [[12, 11, 1], [12, 6, 2], [8, 7, 1]]                       
# set 2:                                                     
# [[6, 6, 1]]                                    
</code></pre>
</div>
<span class="comment-copy">This worked like a charm! Thank you so much. It worked exactly as I needed and I can further unpack the group items to play with the individual results in each set and subset! Thank you!</span>
<span class="comment-copy">This worked as well and I should have really thought of converting to a dictionary. Makes a lot of sense. I really liked Georgy's answer however by using itertools.groupby to group the sets. It's small and concise. I do wish I could set 2 answers though</span>
