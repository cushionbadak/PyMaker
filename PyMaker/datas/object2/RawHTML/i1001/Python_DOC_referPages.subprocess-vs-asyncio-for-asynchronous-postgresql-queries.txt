<div class="post-text" itemprop="text">
<p>I want to perform a number of operations on a postgresql database. These operations carry out a select on a table and then insert the resulting rows into a new table which has primary keys, ignoring rows which violate the primary key constraints. There are a large number of large tables in the database to be processed, and it seems that this sort of task should be run asynchronously. </p>
<p>It strikes me that one way to go about this would be to use the <code>subprocess</code> module in Python to run bash scripts which perform these operations, using something like <code>subprocess.Popen</code>. I can open many terminal sessions and execute queries in parallel and to my understanding this approach is imitating this. </p>
<p>To borrow an example from <a href="https://shuzhanfan.github.io/2017/12/parallel-processing-python-subprocess/" rel="nofollow noreferrer">here</a>:</p>
<pre><code>from subprocess import Popen, PIPE
import glob

f_list = glob.glob('./*bz2')
cmds_list = [['./bunzip2_file.py', file_name] for file_name in f_list]
procs_list = [Popen(cmd, stdout=PIPE, stderr=PIPE) for cmd in cmds_list]
for proc in procs_list:
    proc.wait()
</code></pre>
<p>My questions are:</p>
<ol>
<li><p>Are there any obvious issues with calling many postgres queries using <code>subprocess</code>? </p></li>
<li><p>Under what circumstances might I instead consider using <code>asyncio</code>? Does it provide any advantages to the method discussed above?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Note, that <code>asyncio</code> itself is about controlling execution flow in the first place. It means, for example, you can flexibly <a href="https://docs.python.org/3/library/asyncio-subprocess.html#subprocesses" rel="nofollow noreferrer">manage subprocesses using asyncio</a>. So your question is actually about using processes vs. PostgreSQL async driver.</p>
<p>First of all you probably don't need processes: if your bash scripts don't contain much calculations you can <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" rel="nofollow noreferrer">use threads</a>, they're cheaper.</p>
<p>When it come to <code>asyncio</code> vs. threads both solve main performance bottleneck - network I/O. You probably won't see any performance difference unless you're spawning thousands of threads (see this <a href="https://stackoverflow.com/q/53260688/1113207">question</a> and <a href="https://stackoverflow.com/a/53261628/1113207">answer</a> for an example).</p>
</div>
