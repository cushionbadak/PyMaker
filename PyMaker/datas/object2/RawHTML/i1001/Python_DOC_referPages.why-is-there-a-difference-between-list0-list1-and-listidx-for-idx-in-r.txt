<div class="post-text" itemprop="text">
<p>I have a function that sorts a list of lists by the first list. When I use the function with the variables like so:</p>
<pre><code>sort_lists(IN[0],IN[1],IN[2])
</code></pre>
<p>it works perfectly. Although, as I don't know how many lists my input contains, I want to use this as my variable:</p>
<pre><code>sort_lists(IN[idx] for idx in range(len(IN)))
</code></pre>
<p>Although this returns a sorting of one list (the superlist). Why is there a difference between these variables, and how can I improve the code?</p>
<p>Here is the function if decisive (here IN[0] is the input with a number of sublists):</p>
<pre><code>def sort_lists(*args):
    zipped_list= zip(*sorted(zip(*args)))
    return [list(l) for l in zipped_list]

OUT = sort_lists(data_sort[0],data_sort[1],data_sort[2])
</code></pre>
<p>I want to use this output:</p>
<pre><code>OUT = sort_lists(data_sort[idx] for idx in range(len(IN[0])))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Two things to understand here: </p>
<ul>
<li><code>*args</code> will give you all function parameters <a href="https://stackoverflow.com/questions/36901/what-does-double-star-asterisk-and-star-asterisk-do-for-parameters">as a tuple</a></li>
<li><code>IN[idx] for idx in range(len(IN))</code> is a <a href="https://docs.python.org/3/glossary.html#term-generator-expression" rel="nofollow noreferrer">generator expression</a></li>
</ul>
<p>You can see how your inputs are different if you simply add <code>print</code> statement in your function:</p>
<pre><code>def sort_lists(*args):
    print(args)
    zipped_list= zip(*sorted(zip(*args)))
    return [list(l) for l in zipped_list]
</code></pre>
<p>Let the input list of lists be: <code>lists = [[2, 1, 3], [1, 3, 4], [5, 4, 2]]</code>.</p>
<pre><code>sort_lists(lists[0], lists[1], lists[2])
</code></pre>
<p>will print: <code>([2, 1, 3], [1, 3, 4], [5, 4, 2])</code>. That's a tuple of inner lists.  </p>
<p>Though, if you call it like this:</p>
<pre><code>sort_lists(lists[idx] for idx in range(len(lists)))
</code></pre>
<p>or </p>
<pre><code>sort_lists(sublist for sublist in lists)
</code></pre>
<p>this will print <code>(&lt;generator object &lt;genexpr&gt; at 0x0000007001D3FBA0&gt;,)</code>, a one-element tuple of a generator. </p>
<p>You can make your function work with a generator by accepting only one parameter:</p>
<pre><code>def sort_lists(arg):
    zipped_list= zip(*sorted(zip(*arg)))
    return [list(l) for l in zipped_list]

sort_lists(lists[idx] for idx in range(len(lists)))
# [[1, 2, 3], [3, 1, 4], [4, 5, 2]]
</code></pre>
<p>but I suggest to leave your function as is, and <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">unpack</a> your lists in the place where you call it instead:</p>
<pre><code>&gt;&gt;&gt; sort_lists(*lists)
[[1, 2, 3], [3, 1, 4], [4, 5, 2]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just change the function to accept list of lists, is it problem? This piece of code:</p>
<blockquote>
<pre><code>IN[idx] for idx in range(len(IN))
</code></pre>
</blockquote>
<p>returns again list of lists</p>
</div>
<div class="post-text" itemprop="text">
<p>As Georgy pointed out, the difference is between the arguments being a generator or list. I would also like to point out that this is an opportunity to use and practice the <code>map</code> method. <code>map</code> applies the same function to each entry in a list. The function can be a built-in like <code>sorted</code>.</p>
<pre><code>list_a = [[2, 1, 3], [1, 3, 4], [5, 4, 2]]
sorted_list_a = list(map(sorted, list_a)) # sorted is the python built-in function
print(sorted_list_a)
</code></pre>
<p>Returns:</p>
<pre><code>[[1, 2, 3], [1, 3, 4], [2, 4, 5]]
</code></pre>
<p>You'll notice that you'll have to pass your <code>map</code> to the <code>list</code> function because <code>map</code> returns a map object, so you have to turn it into a list. </p>
<p>The <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer">map documentation is here</a>. And a <a href="http://book.pythontips.com/en/latest/map_filter.html" rel="nofollow noreferrer">good example of it is here</a>.</p>
</div>
<span class="comment-copy">It’s the difference between arguments: <code>foo(a, b, c)</code> and one argument that’s a list: <code>foo([a, b, c])</code>. You’re already using <code>*args</code>, though – do you know what it does?</span>
<span class="comment-copy">@Ry- I know that *args enables me to have an ungiven number of arguments as my input. Although how do i use that in my output?</span>
<span class="comment-copy">I am not completely sure what you try to do with your function. Can you provide an example for IN and the corresponding expected OUT? But as @Ry- already mentioned, the first time your are passing 3 separate lists, and the second time, you are basically giving a generator object as the lone argument to the function.</span>
<span class="comment-copy">@DocDriven  What I wanna do (and am able to do now with a known number of inputs) is to sort a number of lists by the first list's sorting pattern. Say, I have an IN[0]=[2,4,3,1], and an in IN[1]=["two", "four", "three", "one"]. My output is OUT=[1,2,3,4],["one","two","three","four"].</span>
<span class="comment-copy">Oh wow. Thanks for the answer! I just unpacked my lists in the output and it works as I wanted it to now.</span>
<span class="comment-copy">How would you do that? Apologies but I'm new to Python.</span>
