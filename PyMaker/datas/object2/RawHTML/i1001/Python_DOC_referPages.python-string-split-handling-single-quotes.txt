<div class="post-text" itemprop="text">
<p>I am trying to split a string by ",". 
'split' function works fine for the following 'example1' as expected.</p>
<pre><code>example1 = "1,'aaa',337.5,17195,.02,0,0,'yes','abc'"
example1.split(",")
Result: ['1', "'aaa'", '337.5', '17195', '.02', '0', '0', "'yes'", "'abc'"]
</code></pre>
<p>But, here i have a scenario, where there are commas within the single quotes, on which i do not want to split on. </p>
<pre><code>example2 = "1,'aaa',337.5,17195,.02,0,0,'yes','abc, def, xyz'"
example2.split(",")
Result: ["1,'aaa',337.5,17195,.02,0,0,'yes','abc,", 'def,', "xyz'"]
</code></pre>
<p>But I am trying to get this result instead:</p>
<pre><code>['1', "'aaa'", '337.5', '17195', '.02', '0', '0', "'yes'", "'abc, def, xyz'"]
</code></pre>
<p>How can I achieve this with string split function?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should first try to use built-ins or the standard library to read in your data <em>as a list</em>, for instance directly from a CSV file via the <a href="https://docs.python.org/3/library/csv.html" rel="noreferrer"><code>csv</code></a> module.</p>
<p>If your string is from a source you cannot control, adding opening and closing square brackets gives a valid <code>list</code>, so you can use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="noreferrer"><code>ast.literal_eval</code></a>:</p>
<pre><code>from ast import literal_eval

example2 = "1,'aaa',337.5,17195,.02,0,0,'yes','abc, def, xyz'"

res = literal_eval(f'[{example2}]')

# [1, 'aaa', 337.5, 17195, 0.02, 0, 0, 'yes', 'abc, def, xyz']
</code></pre>
<p>This does convert numeric data to integers / floats as appropriate. If you would like to keep them as strings, as per @JonClements' comment, you can pass to <code>csv.reader</code>:</p>
<pre><code>import csv

res = next(csv.reader([example2], quotechar="'")) 

# ['1', 'aaa', '337.5', '17195', '.02', '0', '0', 'yes', 'abc, def, xyz']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that you want to keep those <code>'</code>s around the elements (<code>"'aaa'"</code> instead of <code>'aaa'</code> as in your expected output), here's how you may do it with a function:</p>
<pre><code>def spl(st, ch):
  res = []
  temp = []
  in_quote = False
  for x in st:
    if (x == "'"):
      in_quote = not in_quote

    if (not in_quote and x == ch):
      res.append("".join(temp))
      temp = []
    else:
      temp.append(x)

  res.append("".join(temp))
  return res




example2 = "1,'aaa',337.5,17195,.02,0,0,'yes','abc, def, xyz'"

print(spl(example2, ','))
</code></pre>
<p>Output:</p>
<pre><code>['1', "'aaa'", '337.5', '17195', '.02', '0', '0', "'yes'", "'abc, def, xyz'"]
</code></pre>
</div>
<span class="comment-copy"><code>list(ast.literal_eval(example2))</code> should work; that's a valid Python tuple literal. But some context would help figure out the best solution. Where does that string come from?</span>
<span class="comment-copy">Is that some sort of established format like CSV? If not, why not? If you have control over this, you should switch to using established formats, probably JSON, precisely to avoid reinventing this wheel.</span>
<span class="comment-copy">Note you can also use: <code>next(csv.reader([example2], quotechar="'"))</code> if preserving the elements as strings is definitely required - as opposed to <code>ast.literal_eval</code> which'll convert to other Python types.</span>
<span class="comment-copy">@JonClements, Excellent point. I made the assumption OP wants numeric data as numbers.</span>
<span class="comment-copy">Well - that makes more sense to me as well... but just going by their <i>But I am trying to get this result instead:</i></span>
<span class="comment-copy">Thanks jpp and @JonClements.. currently preserving them as strings, but converting it to appropriate types is good as well. I will explore that option.</span>
<span class="comment-copy">@ArunNalpet <code>literal_eval</code> will work fine... you just can't use Python f-strings (3.6+)... try: <code>res = literal_eval('[{}]'.format(example2))</code> instead...</span>
