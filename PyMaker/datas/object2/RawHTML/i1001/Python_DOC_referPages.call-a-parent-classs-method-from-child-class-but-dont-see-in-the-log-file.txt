<div class="post-text" itemprop="text">
<p>I would like to call a parent class's method from child class but I don't see the logging entry in the log file when I run the following command:</p>
<pre><code>python.exe B.py
</code></pre>
<p>If I call the <code>printA()</code> method in the <code>A.py</code> code then I see the logging entry.</p>
<p>The following piece of Python code is <code>A.py</code> file:</p>
<pre><code>#!/usr/bin/env python
import logging
import logging.config
import yaml

with open('logging.yaml', 'r') as f:
    config = yaml.safe_load(f.read())
    logging.config.dictConfig(config)
logger = logging.getLogger(__name__)

class A:
    def __init__(self, name, value):
        self.name = name
        self.value = value

    def printA(self):
        logger.info('Name: {}'.format(self.name))
        logger.info('Value: {}'.format(self.value))
</code></pre>
<p><code>B.py</code> file:</p>
<pre><code>#!/usr/bin/env python
from A import *
import logging
import logging.config
import yaml


with open('logging.yaml', 'r') as f:
    config = yaml.safe_load(f.read())
    logging.config.dictConfig(config)
logger = logging.getLogger(__name__)

class B(A):
    def __init__(self, name, value):
        super(B, self).__init__(name, value + 1)      

b = B('Name', 1)
b.printA()
</code></pre>
<p><code>logging.yaml</code> file:</p>
<pre><code>version: 1
formatters:
  simple:
    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
handlers:
  console:
    class: logging.StreamHandler
    level: DEBUG
    formatter: simple
    stream: ext://sys.stdout
  debug_file_handler:
    class: logging.handlers.RotatingFileHandler
    level: DEBUG
    formatter: simple
    filename: debug.log
    maxBytes: 10485760 # 10MB
    backupCount: 20
    encoding: utf8
root:
  level: DEBUG
  handlers: [console, debug_file_handler]
</code></pre>
<p>Actual result is an empty log file. The question is what should I change on my source code to make the logging function complete?
Will be grateful for any help.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are configuring and re-configuring the <code>logging</code> module, and each time you call <code>logging.config.dictConfig()</code> you leave the <code>disable_existing_loggers</code> parameter to <code>dictConfig()</code> to <code>True</code>. See the <a href="https://docs.python.org/3/library/logging.config.html#dictionary-schema-details" rel="nofollow noreferrer"><em>Dictionary Schema Details</em> section</a> of the documentation:</p>
<blockquote>
<p><code>disable_existing_loggers</code> - whether any existing loggers are to be disabled. This setting mirrors the parameter of the same name in <code>fileConfig()</code>. If absent, this parameter defaults to True. This value is ignored if <code>incremental</code> is True.</p>
</blockquote>
<p>So each time you call <code>dictConfig()</code> any <code>logging.Logger()</code> instances are being <em>disabled</em>.</p>
<p>Your code works if you only call <code>dictConfig()</code> <em>once</em>, before you use <code>logging.getLogger(__name__)</code> to create your single <code>Logging()</code> object. But when you expanded to two modules, your <code>from A import *</code> line imports <code>A</code>, executes <code>dictConfig()</code> and creates a <code>Logger()</code> before control returns to the <code>B</code> module, which then again runs <code>dictConfig()</code> (the <code>logger</code> reference you create in <code>B</code> is otherwise unused anywhere).</p>
<p>You only need to configure logging <em>once</em>, preferably as early as possible from the main entry point (the script you run with Python), and if your code has already created <code>Logger()</code> instances you want to continue to use, you either need to set <code>incremental</code> to True (but understand [that only a <a href="https://docs.python.org/3/library/logging.config.html#logging-config-dict-incremental" rel="nofollow noreferrer">subset of your configuration</a> will be applied then), or set <code>disable_existing_loggers</code> to <code>False</code>.</p>
<p>Remember that you can always update the dictionary you load from the <code>.yaml</code> file, so you could just use:</p>
<pre><code>config['disable_existing_loggers'] = False
</code></pre>
<p>before you pass <code>config</code> to <code>logging.config.dictConfig()</code>.</p>
<p>I'd use a <code>if __name__ == '__main__':</code> guard to ensure that you only configure logging at that point. Don't run top-level code in a module that alters global configuration without such a guard:</p>
<pre><code>if __name__ == '__main__':
    # this module is used as a script, configure logging
    with open('logging.yaml', 'r') as f:
        config = yaml.safe_load(f.read())
    # do not disable any logger objects already created before this point
    config['disable_existing_loggers'] = False
    logging.config.dictConfig(config)
</code></pre>
</div>
<span class="comment-copy">Your code has syntax errors; <code>class</code> is <i>lowercase</i> in Python, and there is no <code>new</code> keyword (you create instances without <code>new</code>), and you didn't pass any arguments into the <code>B()</code> call, which requires 2 arguments. Please make sure that the code you post actually can be run and reproduces the issue.</span>
<span class="comment-copy">is the code executing with out any errors?</span>
<span class="comment-copy">@Nagashayan: yes, when I put these lines in A.py: 'a = A('Name', 1) a.printA() ' then I see this: 2019-01-04 16:20:52,164 - <b>main</b> - INFO - Name: Name 2019-01-04 16:20:52,164 - <b>main</b> - INFO - Value: 1</span>
<span class="comment-copy">The class <code>A.A</code> uses <code>A.logger</code>; class <code>B.B</code>, since it doesn't define its own <code>printA</code> method, <i>also</i> uses <code>A.logger</code>, not <code>B.logger</code>. Globals in Python are <i>module</i>-level globals, not process-level.</span>
