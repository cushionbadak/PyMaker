<div class="post-text" itemprop="text">
<p>I have a very simple code that is supposed to print out '2' every time the microsecond of the current time is 2, or once per second. However, when I run this code, it returns nothing. How can I fix this?</p>
<pre><code>import datetime
while True:
    if datetime.datetime.now().microsecond == 2:
        print (datetime.datetime.now().microsecond)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't reliably build a loop that will only print exactly every second at the point where the number of microseconds in the current time is equal to 2.</p>
<p>Computer clocks don't necessarily tick <em>every single microsecond</em>, nor is Python always fast enough to produce a <code>datetime</code> instance for a given microsecond. On many systems, calling <code>datetime.now()</code> will produce the exact same value for several microseconds at a stretch, all the way up to only producing a new, distinct time once a second. Your code also creates multiple <code>datetime</code> objects, so after you test for the <code>microsecond</code> attribute, the next one created when you call <code>print()</code> may easily have a higher <code>microsecond</code> value.</p>
<p>See the <a href="https://docs.python.org/3/library/time.html" rel="nofollow noreferrer"><code>time</code> module</a> which documents available clocks in a little more detail. <code>datetime</code> uses the same clock as <code>time.time</code>:</p>
<blockquote>
<p>The precision of the various real-time functions may be less than suggested by the units in which their value or argument is expressed. E.g. on most Unix systems, the clock “ticks” only 50 or 100 times a second.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>Note that even though the time is always returned as a floating point number, not all systems provide time with a better precision than 1 second. While this function normally returns non-decreasing values, it can return a lower value than a previous call if the system clock has been set back between the two calls.</p>
</blockquote>
<p>It depends both on your OS and your computer hardware what the <em>precision</em> of your system clock is; it is not the <em>resolution</em> of the clock that matters (how much information can be given in the clock value) but rather how often that value is refreshed.</p>
<p>If you want to limit printing to once a second, just track the last time you printed and make sure the new time is at least 1 second newer:</p>
<pre><code>import datetime

last = datetime.datetime.now()
while True:
    now = datetime.datetime.now()
    if (now - last).total_seconds() &gt;= 1:
        print(now)
</code></pre>
</div>
<span class="comment-copy">Why that specific microsecond? Your OS clock would need to be very precise, not all computer clocks tick every microsecond.</span>
<span class="comment-copy">Have you tried printing <code>datetime.datetime.now().microsecond</code> to see what it actually looks like?</span>
<span class="comment-copy">I think there are easier ways than this to make something happen once per second. How do you feel about <code>time.sleep</code>?</span>
<span class="comment-copy">Microsends can be in the range of 0-999999, making unlikely to encounter a 2 (it takes some seconds on my system). Even when true, by the time <code>print</code> is executed time has likely advanced by more than one microsecond, making it extremely unlikely to ever get 2 as output (usually 4 on my system).</span>
<span class="comment-copy">Yes, i have tried time.sleep(), but in actuality my code is longer, and it has some delay within itself. I have also tried printing datetime.datetime.now().microsecond, and it doesn't have any problem, even if i use a clock in tkinter.</span>
