<div class="post-text" itemprop="text">
<p>I have a simple test program written and executed in python 3.6.3 below. It is being executed on a machine with 4 cores.</p>
<pre><code>import multiprocessing
import time

def f(num):
  print(multiprocessing.current_process(), num)
  time.sleep(1)
  if (num % 2):
    raise Exception


pool = multiprocessing.Pool(5)

try:
  pool.map(f, range(1,20))
except Exception as e:
  print("EXCEPTION")

pool.close()
pool.join()
</code></pre>
<p>Output with <code>pool = multiprocessing.Pool(5)</code>:</p>
<pre class="lang-none prettyprint-override"><code>&lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt; 1
&lt;ForkProcess(ForkPoolWorker-2, started daemon)&gt; 2
&lt;ForkProcess(ForkPoolWorker-3, started daemon)&gt; 3
&lt;ForkProcess(ForkPoolWorker-4, started daemon)&gt; 4
&lt;ForkProcess(ForkPoolWorker-5, started daemon)&gt; 5
&lt;ForkProcess(ForkPoolWorker-2, started daemon)&gt; 6
&lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt; 7
&lt;ForkProcess(ForkPoolWorker-4, started daemon)&gt; 8
&lt;ForkProcess(ForkPoolWorker-3, started daemon)&gt; 9
&lt;ForkProcess(ForkPoolWorker-5, started daemon)&gt; 10
&lt;ForkProcess(ForkPoolWorker-2, started daemon)&gt; 11
&lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt; 12
&lt;ForkProcess(ForkPoolWorker-4, started daemon)&gt; 13
&lt;ForkProcess(ForkPoolWorker-3, started daemon)&gt; 14
&lt;ForkProcess(ForkPoolWorker-5, started daemon)&gt; 15
&lt;ForkProcess(ForkPoolWorker-2, started daemon)&gt; 16
&lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt; 17
&lt;ForkProcess(ForkPoolWorker-3, started daemon)&gt; 18
&lt;ForkProcess(ForkPoolWorker-4, started daemon)&gt; 19
EXCEPTION
</code></pre>
<p>But if I change the process count of the pool to be equal to or less than the number of cores on my machine, each call to <code>f()</code> where <code>num</code> is even does not print.</p>
<p>output with <code>pool = multiprocessing.Pool(4)</code>:</p>
<pre class="lang-none prettyprint-override"><code>&lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt; 1
&lt;ForkProcess(ForkPoolWorker-2, started daemon)&gt; 3
&lt;ForkProcess(ForkPoolWorker-3, started daemon)&gt; 5
&lt;ForkProcess(ForkPoolWorker-2, started daemon)&gt; 7
&lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt; 9
&lt;ForkProcess(ForkPoolWorker-3, started daemon)&gt; 11
&lt;ForkProcess(ForkPoolWorker-3, started daemon)&gt; 13
&lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt; 15
&lt;ForkProcess(ForkPoolWorker-2, started daemon)&gt; 17
&lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt; 19
EXCEPTION
</code></pre>
<p>I don't understand why these processes are being killed, especially when the exception isn't even thrown until after the print statement in the function. I <em>really</em> don't understand why it only happens when the process count in the pool is equal to or less than the number of cores on the machine.</p>
</div>
<div class="post-text" itemprop="text">
<p>referring to the specification of <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map" rel="nofollow noreferrer"><code>multiprocessing.Pool.map</code></a>
you can see one optional argument <code>chunksize</code>, if you specify it to 1, i.e. <code>pool.map(f, range(1,20), 1)</code>, then you would yield the expected result.</p>
<p>if you increase the chunk size (= 6 for example), you might see:</p>
<pre><code>&lt;SpawnProcess(SpawnPoolWorker-1, started daemon)&gt; 1
&lt;SpawnProcess(SpawnPoolWorker-4, started daemon)&gt; 7
&lt;SpawnProcess(SpawnPoolWorker-3, started daemon)&gt; 13
&lt;SpawnProcess(SpawnPoolWorker-2, started daemon)&gt; 19
</code></pre>
<p>this suggests that number of <code>chunksize</code> of tasks are assigned to a single thread in the Pool, when you raise exception during each thread, of course the tasks in the remaining chuck would not be executed.</p>
<p>From here you can know that the default value for <code>chunksize</code> is 2 in your case, the reason of existence of such variable, to be seen fairly easily, is to reduce the number of new threads which need to be initialized (which might save both resources and processing time, when you have appropriate chunksize).</p>
</div>
<span class="comment-copy">if you're running windows, start by protecting your code with <code>if __name__ == '__main__':</code></span>
<span class="comment-copy">note: they're not threads, they are <i>processes</i>.</span>
<span class="comment-copy">This is running on centos7. I didn't include the protective if statement at the bottom in the original code, but tested it again just now and it is the same behavior.</span>
<span class="comment-copy">you could change <code>raise Exception</code> to <code>raise Exception(str(num))</code> to identify which process is raising the error. Anyway it's clearly a race condition</span>
<span class="comment-copy">related: <a href="https://stackoverflow.com/a/24894997/6451573">stackoverflow.com/a/24894997/6451573</a></span>
<span class="comment-copy">Nice answer.  To elaborate a bit - calling <code>.map()</code> spawns the tasks with <code>.submit()</code>, but it doesn't join them (unless you use <code>pool</code> as a context manager - then the joining will happen on <code>__exit__</code>).  Hence the exceptions do happen but don't "show up" because <code>.map()</code> returns an iterator over Future objects.</span>
<span class="comment-copy">Also, as you point out, the chunksize is 2 in this specific case and the calculation for that is found <a href="https://github.com/python/cpython/blob/master/Lib/multiprocessing/pool.py#L413" rel="nofollow noreferrer">here</a>, with some explanation <a href="https://stackoverflow.com/q/53751050/7954504">here</a></span>
