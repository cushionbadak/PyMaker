<div class="post-text" itemprop="text">
<p>This question is spurred from the answers and discussions of <a href="https://stackoverflow.com/questions/53984116/why-does-if-none-eq-a-evaluate-to-true">this question</a>.  The following snippet shows the crux of the question:</p>
<pre><code>&gt;&gt;&gt; bool(NotImplemented)
True
</code></pre>
<p>The questions I have are the following:</p>
<ol>
<li>Why was it decided that the <code>bool</code> value of <code>NotImplemented</code> should be <code>True</code>?  It feels unpythonic.</li>
<li>Is there a good reason I am unaware of?  The documentation seems to just say, "because it is".</li>
<li>Are there any examples where this is used in a reasonable manner?</li>
</ol>
<p>Reasoning behind why I believe it's unintuitive (please disregard the lack of best practice):</p>
<pre><code>&gt;&gt;&gt; class A:
...     def something(self):
...         return NotImplemented
...
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.something()
NotImplemented
&gt;&gt;&gt; if a.something():
...     print("this is unintuitive")
...
this is unintuitive
</code></pre>
<p>It seems an odd behavior that something with such a negative connotation (lack of implementation) would be considered truthy.</p>
<p>Relevant text from:</p>
<blockquote>
<h3>NotImplemented</h3>
<p>Special value which should be returned by the binary special methods (e.g. <code>__eq__()</code>, <code>__lt__()</code>, <code>__add__()</code>, <code>__rsub__()</code>, etc.) to indicate that the operation is not implemented with respect to the other type; may be returned by the in-place binary special methods (e.g. <code>__imul__()</code>, <code>__iand__()</code>, etc.) for the same purpose. Its truth value is true.</p>
<p><sup>â€” From the <a href="https://docs.python.org/3/library/constants.html#NotImplemented" rel="nofollow noreferrer">Python Docs</a></sup></p>
</blockquote>
<h1>Edit 1</h1>
<p>To clarify my position, I feel that <code>NotImplemented</code> being able to evaluate to a boolean is an anti-pattern by itself.  I feel like an Exception makes more sense, but the prevailing idea is that the constant singleton was chosen for performance reasons when evaluating comparisons between different objects.  I suppose I'm looking for convincing reasons as to why this is "the way" that was chosen.</p>
</div>
<div class="post-text" itemprop="text">
<p>By default, an object is considered truthy (<code>bool(obj) == True</code>) unless its class provides a way to override its truthiness. In the case of <code>NotImplemented</code>, no one has ever provided a compelling use-case for <code>bool(NotImplemented)</code> to return <code>False</code>, and so <code>&lt;class 'NotImplementedType'&gt;</code> has never provided an override.</p>
</div>
<div class="post-text" itemprop="text">
<p>As the <a href="https://stackoverflow.com/a/54134571/5090527">accepted answer</a> already explains, all classes in python are considered truthy (<code>bool(obj) returns True</code>) unless they specifically change that via <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">Truth Value Testing</a>. It makes sense in some cases to override that, like an empty list, <code>0</code>, or <code>False</code> (see a good list <a href="https://stackoverflow.com/a/39984051/5090527">here</a>).</p>
<p>However there is no compelling case for <a href="https://docs.python.org/3/library/constants.html#NotImplemented" rel="nofollow noreferrer"><code>NotImplemented</code></a> to be falsy. It's a special value used by the interpreter, it should only be returned by special methods, and shouldn't reach regular python code.</p>
<blockquote>
<p>Special value which should be returned by the binary special methods (e.g. <code>__eq__()</code>, <code>__lt__()</code>, <code>__add__()</code>, <code>__rsub__()</code>, etc.) to indicate that the operation is not implemented with respect to the other type.</p>
<p>Incorrectly returning <code>NotImplemented</code> will result in a misleading error message or the <code>NotImplemented</code> value being returned to Python code.</p>
</blockquote>
<p>It's used by the interpreter to choose between methods, or to otherwise influence behaviour, as is the case with with the <a href="https://stackoverflow.com/a/53984203/5090527">comparison operator <code>==</code></a> or <code>bool()</code> itself (it checks <code>__bool__</code> first and then, if it returns <code>NotImplemented</code>, <code>__len__</code>). </p>
<p>Note that a <a href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" rel="nofollow noreferrer"><code>NotImplementedError</code></a> exception exists, presumably for when it actually is an error that an operation isn't implemented. In your specific example, <code>something</code> of <code>class A</code> should probably raise this exception instead.</p>
</div>
<span class="comment-copy"><code>True</code> is the default (<code>bool(object())</code> is <code>True</code>), and there isn't a compelling reason to change it.</span>
<span class="comment-copy"><i>All</i> objects are truthy unless the class provides for false-y objects. The question is, is there a good reason for <code>NotImplemented</code> to <i>not</i> be truthy?</span>
<span class="comment-copy">"3. Are there any examples where this is used in a reasonable manner?" Are there any examples where it makes sense to apply a boolean test to it at all? What motivated the question?</span>
<span class="comment-copy">The reasoning in your example code snippet is entirely unconvincing.  Why would entering <code>if not a.something()</code> be any more intuitive than entering <code>if a.something()</code>?</span>
<span class="comment-copy">If <code>NotImplemented</code> didn't exist, how would <a href="https://docs.python.org/3/reference/datamodel.html#object.__radd__" rel="nofollow noreferrer"><code>__radd__</code> and all the other reflected operations</a> in the datamodel work?  They use this singleton to indicate "I don't support this operation, but the other operand might".</span>
<span class="comment-copy">Relevant <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">documentation</a></span>
<span class="comment-copy">Although I want to fervently disagree about not having a compelling use-case, I believe you have answered the question.  How do you feel about the edited example I added to my original question and something that might justify changing NotImplemented to falsy?</span>
<span class="comment-copy">@Julian: Nothing would justify changing it to falsy. Your use of it is in error (it's only for binary operator overloads, to trigger delegation to the other object being operated on, not intended for indicating a method hasn't been implemented yet). Correct code would use <code>raise NotImplementedError("msg")</code> to avoid silently treating the result as <i>either</i> truthy or falsy. IMO, the only reasonable change would be to make <code>NotImplementedType.__bool__</code> raise <code>TypeError</code>, so people couldn't accidentally misuse it in a boolean context <a href="https://bugs.python.org/issue21408" rel="nofollow noreferrer">the way Python used to</a>.</span>
<span class="comment-copy">@ShadowRanger I completely get that this isn't the right way to use the <code>NotImplemented</code> singleton, but that's kind of the point I am getting at.  The zen of python states that "There should be one-- and preferably only one --obvious way to do it", which I think the <code>NotImplemented</code> singleton violates quite egregiously.  The purpose of the question isn't "why can't I do this this way?" so much as it is to point out the ambiguity of the reasoning behind this singleton and how it is nebulous in its purpose (unless you're deeply knowledgable about the underlying datamodel logic).</span>
<span class="comment-copy">@ShadowRanger I believe wholeheartedly that the raising of an error is the proper way to fix the code example I used.  The reason I suggested making <code>bool(NotImplemented) == True</code> is that it would then make logical sense regardless of the context and the underlying datamodel could simply update it's logic to use this updated singleton without causing undue confusion for people unaware of the idiosyncrasies of <code>NotImplemented</code> and <code>NotImplementedError</code></span>
