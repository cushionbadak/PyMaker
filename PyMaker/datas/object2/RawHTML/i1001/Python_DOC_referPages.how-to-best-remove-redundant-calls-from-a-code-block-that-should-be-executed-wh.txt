<div class="post-text" itemprop="text">
<p>I'm trying to simplify the following code (removing the redundant prints), but can't find a satisfying way to do this:</p>
<h1>original code</h1>
<pre><code>def main():
    if expression1:
        print("1")
        print("always_do_this")
        return
    if expression2:
        print("2")
        print("always_do_this")
        return
    # ... possibly more expressions and thus redundancy

    print("always_do_this")

    # do something else
</code></pre>
<p>My first idea was a <code>try-(except-)else</code> combination, but the <code>else</code> is not executed on a return in the <code>try</code>-block.</p>
<h1>Solution 1 - extracting into a separate function</h1>
<pre><code>def func():
    if expression1:
        print("1")
        return True
    if expression2:
        print("2")
        return True
    return False

def main():        
    result = func()

    print("always_do_this")

    if result:
        return

    # do something else
</code></pre>
<h1>Solution 2 - workaround using finally</h1>
<pre><code>def main():

    error = False
    try:
        if expression1:
            print("1")
            return
        if expression2:
            print("2")
            return
    except:
        error = True
        raise
    finally:
        if not error:
            print("always_do_this")

    # do something else
</code></pre>
<p>Surely there must be a better way to achieve this in python?</p>
<p>PS: Also any ideas for a better title would be appreciated...<br/>
PPS: I'm not directly asking about (subjective) codestyle, but wondering if there is a way to write this that I didn't consider (e.g. a language construct/pattern, that also makes the code more concise/cleaner; obviously there are a lot worse ways).</p>
</div>
<div class="post-text" itemprop="text">
<p>Check if your flow did not enter the first two <code>if</code> blocks by checking for the opposite of the first two <code>if</code> statements joined by an <code>and</code>so that you can execute "do something else" only if the first two if statements failed. Return at the end instead of in the middle of the if statements.</p>
<pre><code>def main():
    expression1 = True
    expression2 = False

    if expression1:
        print("1")
    elif expression2:
        print("2")

    print("always_do_this")

    if not expression1 and not expression2:
        # do something else

    return
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the thing you always want to do is closing a file, I would use a <code>with</code> statement. In a more general case you can create your own context manager to have full control of what gets run at the end.</p>
<p>Sample code:</p>
<pre><code>class my_closer:
   def __enter__(self):
      return True
   def __exit__(self, type, value, traceback):
      if type is None:
          print("always_do_this")
      else
          print("An exception was raised: {}".format(type))

def main():
   with my_closer() as c:
      if someexpr:
         print("1")
         return
      if someexpr:
         print("2")
         return
</code></pre>
<p>I added a superfluous <code>else</code> to print something about the exception in case of error, but leave it out to reproduce your original code more accurately.</p>
<p>This code is not shorter than yours with the trivial <code>print</code> statement, but I like this method for more complex "closer" code.</p>
<p>You can also define the context manager this way using the <code>contextlib</code> library:</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def my_closer(*args, **kwds):
   try:
      yield True
   except:
      #print("some error happened")
      raise
   else:
      print("always_do_this")
</code></pre>
<p>References:</p>
<ul>
<li><a href="http://effbot.org/zone/python-with-statement.htm" rel="nofollow noreferrer">http://effbot.org/zone/python-with-statement.htm</a></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#typecontextmanager" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#typecontextmanager</a></li>
<li><a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" rel="nofollow noreferrer">https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager</a></li>
</ul>
</div>
<span class="comment-copy">Sorry, I am not understanding exactly which lines you want executed and which you do not. Could you put some comments or more detailed <code>print</code> statements so that we know how you want to control your flow?</span>
<span class="comment-copy">I just realized that myself and added additional prints. Did you already see this edit?</span>
<span class="comment-copy">Still confusing, but I am closer... lol. Do you mean to say <code>if someexpr:</code> and then <code>if not someexpr:</code>? Why do you test for boolean of someexpr twice? and you want the <code>main()</code> to <code>return</code> inside those if statements in your original code so that it doesn't execute anything outside of it if it enters that if block?</span>
<span class="comment-copy">Oh, I see your problem. I tried to explain this in the first comment, but will edit it. And yes <code>main</code> should return, but not before <code>print("always_do_this")</code>.</span>
<span class="comment-copy">This does not do an early exit if <code>expression1</code> is <code>True</code> and doesn't scale with a higher number of expressions.</span>
<span class="comment-copy">Fixed it to <code>elif</code> to avoid running <code>print('2')</code>. As for scaling, there will always be an <code>if</code> statement to test for boolean and an expression with it. You could also use a <code>flag = False</code> and set it to <code>True</code> inside any of the initial <code>if elif</code> block, then test for the <code>flag</code> in the end for the <code>#do something else</code> block.</span>
<span class="comment-copy">Yeah, a flag is probably the best idea here, but not much different than a simple function call (could easily remove the parameters in the original code with <code>functools.partial</code>). I was just hoping that I missed something else...</span>
<span class="comment-copy">This does not behave the same way as the original code as it is now equivalent to my try-finally solution if it didn't have the <code>error</code> variable.</span>
<span class="comment-copy">Question: if there is an error, do you want the always-do-this code to get run or not? I tested and if I raise an exception within the <code>with</code> statement the line does get printed. This is what you would want for closing a resource, but maybe it's not with your code?</span>
<span class="comment-copy">Correct, it should only be executed for successful exists, as the title says. (Even though it is some kind of ressource, it has to be handled differently in case of an error)</span>
<span class="comment-copy">Sorry, I missed that part of your question. In this case, I think your try/except/finally is the best way to do it.</span>
<span class="comment-copy">I take it back, the <code>type</code> argument is <code>None</code> on normal exit, but has the exception when there is an error. I'll edit my answer to have the behaviour you want.</span>
