<div class="post-text" itemprop="text">
<p>I am writing a framework, and I want my base class to use different functions for renaming in the child classes. I figured the best way would be to use a class attribute, like in case of <code>A</code>, but I got <code>TypeError</code>s when running it like in <code>rename_columns()</code>. However it worked with implementation like <code>B</code></p>
<pre><code>import pandas as pd

class A:
    my_func_mask = str.lower
    foo = 'bar'

    def rename_columns(self, data):
        return data.rename(columns=self.my_func_mask)

class B(A):

    def rename_columns(self, data):
        return data.rename(columns=self.__class__.my_func_mask)
</code></pre>
<p>So I experimented with the above a bit, and I get the following:</p>
<pre><code>a = A()
a.foo # Works fine, gives back 'bar'
a.__class__.my_func_mask # Works as expected `a.__class__.my_func_mask is str.lower` is true
a.my_func_mask # throws TypeError: descriptor 'lower' for 'str' objects doesn't apply to 'A' object
</code></pre>
<p>My questions would be why can I use regular typed (int, str, etc.) values as class attributes and access them on the instance as well, while I cannot do that for functions?
What happens during the attribute lookup in these cases? What is the difference in the attribute resolution process?
Actually both <code>foo</code> and <code>my_func_mask</code> is in <code>__class__.__dict__</code> so I am a bit puzzled. Thanks for the clarifications!</p>
</div>
<div class="post-text" itemprop="text">
<p>You are storing an unbound built-in method on your class, meaning it is a <a href="https://docs.python.org/3/howto/descriptor.html" rel="noreferrer"><em>descriptor</em> object</a>. When you then try to access that on <code>self</code>, descriptor binding applies but the <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="noreferrer"><code>__get__</code> method</a> called to complete the binding tells you that it can't be bound to your custom class instances, because the method would only work on <code>str</code> instances. That's a strict limitation of most methods of built-in types.</p>
<p>You need to store it in a different manner; putting it inside another container, such as a list or dictionary, would avoid binding. Or you could wrap it in a <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="noreferrer"><code>staticmethod</code> descriptor</a> to have <em>it</em> be bound and return the original. Another option is to not store this as a class attribute, and simply create an instance attribute in <code>__init__</code>.</p>
<p>But in this case, I'd <em>not store <code>str.lower</code> as an attribute value</em>, at all. I'd store <code>None</code> and fall back to <code>str.lower</code> when you still encounter <code>None</code>:</p>
<pre><code>return data.rename(columns=self.my_func_mask or str.lower)
</code></pre>
<p>Setting <code>my_func_mask</code> to <code>None</code> is a better indicator that a default is going to be used, clearly distinguishable from explicitly setting <code>str.lower</code> as the mask.</p>
</div>
<div class="post-text" itemprop="text">
<p>Everything that is placed in the class definition is bound to the class, but you can't bind a built-in to your own class.</p>
<p>Essentially, all code that you place in a class is executed when the class is created. All items in <code>locals()</code> are then bound to your class at the end of the class. That's why this also works to bind a method to your class:</p>
<pre><code>def abc(self):
    print('{} from outside the class'.format(self))

class A:
    f1 = abc
    f2 = lambda self: print('{} from lambda'.format(self))
    def f3(self):
        print('{} from method'.format(self))
</code></pre>
<p>To not have the function bound to your class, you have to place it in the <code>__init__</code> method of your class:</p>
<pre><code>class A:
    def __init__(self):
        self.my_func_mask = str.lower
</code></pre>
</div>
<span class="comment-copy"><code>my_func_mask</code> is turned into a bound method when you instantiate the class. There's something about that process, but I couldn't tell you what exactly.</span>
<span class="comment-copy">I guess <code>data.rename(columns=A.my_func_mask)</code> would work.</span>
<span class="comment-copy">@Sraw yep, that will work, but that doesnt answer the question</span>
<span class="comment-copy">Thanks, that is very clear, I just got I question left, as you say that it is a limitation on built-in types, but it seems it is not when using custom class methods or functions in place of <code>str.lower</code>. What regulates what can become a bounded method and what cannot?</span>
<span class="comment-copy">@HodossySzabolcs: functions defined in Python code don't have any restrictions on what they can be bound on, but obviously they break when they don't expect the first argument to be an instance or if that instance doesn't have any of the expected state. That's a good reason not to put arbitrary functions on a class anyway. Built-in methods are stricter because they access state at the native level (so via C code in case of CPython, the default Python implementation). That can be dangerous as accessing the wrong state likely leads to a crash or worse, data corruption.</span>
<span class="comment-copy">@HodossySzabolcs: so built-in methods usually are restricted to the class they are defined for and subclasses (and in the latter case, may just ignore anything at the Python level if subclassed in Python, it depends on the exact implementation details).</span>
<span class="comment-copy">Just that the OP is not calling <code>a.my_func_mask</code> (not doing <code>a.my_func_mask()</code>)</span>
<span class="comment-copy">Oh right, overlooked that</span>
