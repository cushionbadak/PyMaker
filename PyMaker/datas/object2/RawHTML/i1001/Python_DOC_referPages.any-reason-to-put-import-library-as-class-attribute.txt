<div class="post-text" itemprop="text">
<p>may I know what is main reason for me to make decision if I should put <code>datetime</code> as class attribution or not? lets say if I know <code>class Test2</code> is single class and definitely does not have plan to be inherited by any class</p>
<p>Is it correct to use as class <code>Test2</code> does where it does not set any <code>import</code> as class attribute or ?</p>
<h2>test1.py</h2>
<pre><code>import datetime

class Test1:
    datetime = datetime
    def getnow(self):
        return self.datetime.time()
</code></pre>
<h2>test2.py</h2>
<pre><code>import datetime

datetime = datetime
class Test2:
    def getnow(self):
        return datetime.time()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Neither of these implementations has any real benefit.</p>
<p>In test2.py, <code>datetime = datetime</code> is essentially a no-op. It does not change the state of the module. This is completely useless.</p>
<p>test1.py doesn't actually behave particularly differently, either. It just sets <code>datetime</code> as a class attribute, which means that it looks to the class to find <code>datetime</code> instead of the module. This <em>might</em> perform better in some very heavy load circumstances, but not enough that you should be worried about it unless you already know what you're doing.</p>
<p>The fact they invoke <code>self.datetime.time()</code>, though, suggests to me that the author's (assuming you saw someone doing this in their own code) intention was that <code>datetime</code> could be <em>temporarily replaced</em> at runtime, like this:</p>
<pre><code>class FakeDatetime:
    def time(self):
        return 'from fake datetime'

t = Test1()
t.datetime = FakeDatetime()
print(t.getnow()) # Prints "from fake datetime"
</code></pre>
<p>To me, this looks like a misguided attempt to enable using a <strong>mock</strong> or <strong>stub</strong> for automated tests. They probably intend for it to be used something like this:</p>
<pre><code>import unittest
from test1 import Test1

class TestStringMethods(unittest.TestCase):
    def test_my_method():
        mock = MyMock()
        expected_value = 'my value'
        # Set up code to make mock.time() return expected value

        t = Test1()
        t.datetime = mock
        assert t.time() == expected_value
</code></pre>
<p>The standard solution to mocking in Python is the <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>unittest.mock</code> module</a> (or the <a href="https://pypi.org/project/mock/" rel="nofollow noreferrer"><code>mock</code> package</a> if using Python 3.2 or older). This module encourages <em>patching</em> to replace dependencies, rather than something manual like the code you presented:</p>
<p><strong>test3.py</strong></p>
<pre><code>import datetime

class Test3:
    def getnow(self):
        return datetime.time()
</code></pre>
<p><strong>test3tests.py</strong></p>
<pre><code>import unittest
from unittest import mock
from test3 import Test3

class TestStringMethods(unittest.TestCase):
    @mock.patch('test3.datetime')
    def test_my_method(datetime_mock):
        expected_value = 'my value'
        datetime_mock.time.return_value = expected_value

        t = Test3()
        assert t.time() == expected_value
        # Original datetime is restored by patch automatically when method exits
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on the subject did you mean?</p>
<p><strong>this</strong></p>
<pre><code>import datetime

class Test1:
    datetime = datetime
    def getnow(self):
        return self.datetime.time()
</code></pre>
<p><strong>vs. this</strong></p>
<pre><code>class Test2:
import datetime

    datetime = datetime
    def getnow(self):
        return self.datetime.time()
</code></pre>
<p>It appears your imports should be at the top of your python file.  So, in that case, Test1 is the correct way to go.</p>
<p><a href="https://stackoverflow.com/questions/3095071/in-python-what-happens-when-you-import-inside-of-a-function">In Python, what happens when you import inside of a function?</a></p>
<p>"In general practice, it's probably not that beneficial. In fact, most Python style guides encourage programmers to place all imports at the beginning of the module file."</p>
</div>
<span class="comment-copy">Test2 is better, there's no point in making a class variable something that you're going to use as a global anyway. However in Test2 do note that <code>datetime = datetime</code> is superfluous.</span>
<span class="comment-copy">Why did you think there <i>would</i> be a reason to do that?</span>
<span class="comment-copy">short answer - no reason</span>
<span class="comment-copy">I don't understand either example. Why <code>datetime = datetime</code>in test2?</span>
<span class="comment-copy">yap... there should not have any reason for <code>datetime = datetime</code> neither</span>
<span class="comment-copy">Neither case serves any purpose, though. There is no need to do this.</span>
<span class="comment-copy">I wasn't focusing on what the code was doing.   I was simply looking at it from a language syntax and best practice standpoint.   Where do the imports got?</span>
<span class="comment-copy">The import goes at the top of the file, and then all other re-binding of <code>datetime</code> can go. If you want <code>getnow</code> to return the current time, just <code>return datetime.datetime.now()</code> but there's no need for it to be a class attribute.</span>
<span class="comment-copy">So you are saying that this can be accomplished with two lines of code. &lt;br/&gt;&lt;br/&gt;    <code>import datetime  &lt;br/&gt;return self.datetime.time()</code></span>
<span class="comment-copy">Well, 1 after the import, depending on whether you even need your own class. The user-defined class isn't necessary at all. But I'm not sure why exactly you are asking; I'm not suggesting that you need change your answer, but are you unsure about this yourself?</span>
