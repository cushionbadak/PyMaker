<div class="post-text" itemprop="text">
<p>I'm trying to convert this nested loop into a list comprehension but i'm not sure it's possible as there is different values possible for item in "tmp" list. Is it the best way to do this ? Thanks !</p>
<pre><code>final = []
for a in range(-13, 1):
    for b in range(0,4):
        for c in range(6, 49):
            for d in range(48, 94):
                tmp = [0 for i in range(100)]
                for i in range(100):
                    if raw_x[i] &gt;= b and raw_y[i] &gt;= d:
                        tmp [i] = -1
                    if raw_x[i] &lt;= a and raw_y[i] &lt;= c:
                        tmp [i] = 1
                final.append(tmp)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be done in one expression although I'm not sure readability is improved:</p>
<pre><code>final = [
    [
        +1 if x &lt;= a and y &lt;= c
        else -1 if x &gt;= b and y &gt;= d
        else 0
        for x, y in zip( raw_x, raw_y )
    ]
    for a in range(-13, 1)
    for b in range(0, 4)
    for c in range(6, 49)
    for d in range(48, 94)
]
</code></pre>
<p>Note that I've assumed you want to go through the <em>whole</em> of <code>raw_x</code> and <code>raw_y</code> rather than exactly 100 elements every time: the question implies 100-every-time but if the intention is really to go through the whole sequence, then it's better not to hard-code the 100 in there.  If I'm wrong about the intention, you can change that inner-comprehension <code>for</code> loop to <code>for i in range(100)</code> and use <code>raw_x[i]</code> and <code>raw_y[i]</code> in the conditional expression instead of <code>x</code> and <code>y</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>nested comprehensions are not very readable </p>
<p>a simple </p>
<pre><code>[something for something in container if something &gt; 9]
</code></pre>
<p>is awesome, but a nested one is often confusing</p>
<p>you can simply move the loops into a generator function - it will still be readable and allow for lazy iteration</p>
<pre><code>def no_idea_what_this_represents():
    for a in range(-13, 1):
        for b in range(0,4):
            for c in range(6, 49):
                for d in range(48, 94):
                    tmp = [0 for i in range(100)]
                    for i in range(100):
                        if raw_x[i] &gt;= b and raw_y[i] &gt;= d:
                            tmp [i] = -1
                        if raw_x[i] &lt;= a and raw_y[i] &lt;= c:
                            tmp [i] = 1
                    yield tmp

final = [signs for signs in no_idea_what_this_represents()]
</code></pre>
<p>EDIT: just an opinionated addendum - this way the complicated nested loop can be named ( I named it <code>no_idea_what_this_represents</code> for obvious reasons ) but when a programmer sees</p>
<pre><code>possible_views = [matrix for matrix in camera_matrices()]
</code></pre>
<p>he immediately knows what that means while something like</p>
<pre><code>possible_views = [device.matrix 
                  for devices in itertools.chain(connected_devices(), buffered_devices()
                  for device in devices
                  if device.type=='camera']
</code></pre>
<p>makes the programmer read a lot of lines and it is not obvious what is going on</p>
</div>
<div class="post-text" itemprop="text">
<p>Your algorithm has large time complexity. First see if this is <em>actually</em> what you require. Once you are sure you need a nested <code>for</code> loop with 4 nesting levels, you can define a function to use <em>within</em> your list comprehension.</p>
<p>In this case, notice built-in <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> can accept multiple iterable arguments. <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a> allows you to define functions with pre-set arguments.</p>
<pre><code>from functools import partial

def get_val(x, y, a, b, c, d):
    if x &lt;= a and y &lt;= c:
        return 1
    if x &gt;= b and y &gt;= d:
        return -1
    return 0

final = [list(map(partial(get_val, a=a, b=b, c=c, d=d), raw_x, raw_y)) \
         for a in range(-13, 1) \
         for b in range(0, 4) \
         for c in range(6, 49) \
         for d in range(48, 94)]
</code></pre>
</div>
<span class="comment-copy">thanks, that's what i wanted to know, even if the readability is not that improved</span>
<span class="comment-copy">Although it doesn't answer the actual question (turns out OP literally did just want to learn about complex comprehension expressions) this challenge to the premise makes a <i>very</i> good point about readability.  -1 and +1.</span>
<span class="comment-copy">@tobias_k  <code>map</code> handles the unpacking of the lists <code>raw_x</code> and <code>raw_y</code> into elements <code>x</code> and <code>y</code></span>
<span class="comment-copy">@jez Ah, right, did not see that (and apparantly did not read the description).</span>
<span class="comment-copy">Note that, strictly, the order of precedence of -1 and +1 should be swapped if you want to match the question.   In the question,  if <code>x &lt;=a and y&lt;=c</code> then the value +1 overwrites the previous value, even if it was previously set to -1</span>
<span class="comment-copy">@jez, Thanks for pointing out. Yes, that is true, since OP is potentially overwriting values in each <code>if</code> statement (intentionally or not, it's not clear). Corrected now.</span>
<span class="comment-copy">@TmSmth in that case be aware that my answer replicates the question's +1 -over- -1 precedence as well</span>
