<div class="post-text" itemprop="text">
<p>I am expecting the list to be sorted and then duplicates will be spaced by increments of 0.1. Why is my code below not working? Here is what I am expecting to get versus what my program is returning:</p>
<blockquote>
<p><strong>Expected Output</strong>: <code>[11, 15, 15.1, 20, 20.1, 20.2, 20.3, 20.4, 30,
  30.1, 40, 40.1, 50, 50.1]</code></p>
<p><strong>Actual output</strong>:<code>[11, 15, 15.1, 20, 20.1, 20.1, 20.1, 20.1, 30, 30.1, 40,
  40.1, 50, 50.1]</code></p>
</blockquote>
<h1>Python Code:</h1>
<pre><code>my_list = [20,20,20,30,20,30,40,50,15,11,20,40,50,15]
my_list.sort()
dup_list = []


for i in range (len(my_list)):
    if my_list[i] not in dup_list:
        dup_list.append(my_list[i])
    else:
        my_list[i] = my_list[i] + 0.10

    dup_list.append(my_list[i])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>here is the solution according to your code.
your code is right what you were lacking was the case when <code>my_list[i]+0.1*i</code>
value is already present. ie in example when 20 is there you increase it to 
20.1 (happening) but you miss that but when 20.1 is there . you just checking
only for 20 not for 20.1 . that is why 20.1 is coming in your solution not 20.2.</p>
<pre><code>my_list = [20,20,20,30,20,30,40,50,15,11,20,40,50,15]
my_list.sort()
dup_list = []


for i in range (len(my_list)):
    if my_list[i] not in dup_list:
        dup_list.append(my_list[i])
    else:
        j=1
        res = True
        while res:
            val = my_list[i]+j*0.1
            if val  not in dup_list:
                dup_list.append(val)
                res = False
            j+=1 

print(dup_list)

#output [11, 15, 15.1, 20, 20.1, 20.2, 20.3, 20.4, 30, 30.1, 40, 40.1, 50, 50.1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a> to group equal consecutive elements:</p>
<pre><code>from itertools import groupby

my_list = [20,20,20,30,20,30,40,50,15,11,20,40,50,15]
my_list.sort()
result = [g + i * 0.1 for k, group in groupby(my_list) for i, g in enumerate(group)]
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[11.0, 15.0, 15.1, 20.0, 20.1, 20.2, 20.3, 20.4, 30.0, 30.1, 40.0, 40.1, 50.0, 50.1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I can propose simple fix to the original code:</p>
<pre><code>my_list = [20,20,20,30,20,30,40,50,15,11,20,40,50,15]
my_list.sort()
dup_list = []

for i in range (len(my_list)):
    if my_list[i] not in dup_list:
        dup_list.append(my_list[i])
    else:
        dup_list.append(dup_list[i-1]+0.1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is you are only incrementing it once. You are not keeping a count of how many times a number has appeared before. </p>
<p>What you need is some kind of frequency dictionary that will store how many times this number has appeared. Using that frequency <code>f</code> you add <code>f-1</code> increments to the number.</p>
<pre><code>my_list = [20,20,20,30,20,30,40,50,15,11,20,40,50,15]
my_list.sort()
dup_list = []
feq = {}

for i in range (len(my_list)):
    if my_list[i] not in feq:
        feq[my_list[i]] = 1
    else:
        feq[my_list[i]] += 1

    dup_list.append(my_list[i] + (feq[my_list[i]]-1)*0.1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this improved code:</p>
<pre><code>my_list = [20,20,20,30,20,30,40,50,15,11,20,40,50,15]
my_list.sort()
out_list = []

for value in my_list:
    if value in out_list:
        while value in out_list:
            value += .1
    out_list.append(value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>defaultdict</code>:</p>
<pre><code>from collections import defaultdict

my_list = [20,20,20,30,20,30,40,50,15,11,20,40,50,15]
my_list.sort()
dup_list = []
occurrences = defaultdict(int)

for elmt in my_list:
    dup_list.append(elmt + occurrences[elmt] * 0.10)
    occurrences[elmt] += 1
</code></pre>
<p>Output:</p>
<pre><code>[11.0, 15.0, 15.1, 20.0, 20.1, 20.2, 20.3, 20.4, 30.0, 30.1, 40.0, 40.1, 50.0, 50.1]
</code></pre>
<p>If you need the original values to still be integers, comment below and I'll change that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another (more advanced) option is to write a cusom generator:</p>
<pre><code>from itertools import count

def gen(value):
    """Returns a generator that first yields `value` and then `value + x * 0.10` (where x is 1, 2, ...).
    """
    yield value
    yield from map(lambda x: value + x * 0.10, count(1))

my_list = [20, 20, 20, 30, 20, 30, 40, 50, 15, 11, 20, 40, 50, 15]

# create a generator for each distinct value in my_list
generators = {k: gen(k) for k in set(my_list)}

# calculate the result list
dup_list = [next(generators[elmt]) for elmt in sorted(my_list)]

print(dup_list)
</code></pre>
<p>IMO, this is not the easiest solution. I'm sharing it anyways because it might help others understand generators, especially <code>yield from</code>.</p>
</div>
<span class="comment-copy">What should happen if there are more than 10 duplicates for a given number ?</span>
<span class="comment-copy">Have you tried to debug it ? The problem is you do not track how many times a number is duplicated. For example every time you read 20, your code don't know if it's the second time or the fourth, so it only add 0.10.</span>
<span class="comment-copy">Your solution leads to small inaccuracies because you're adding <code>0.1</code> multiple times instead of adding <code>0.X</code> (where X is the number of occurances) once. Try <code>20 + 0.1 + 0.1 + 0.1</code> and <code>20 + 0.1 * 3</code> in the interpreter to see the difference.</span>
