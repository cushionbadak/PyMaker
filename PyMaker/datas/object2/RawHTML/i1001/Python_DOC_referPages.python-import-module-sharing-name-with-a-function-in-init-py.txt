<div class="post-text" itemprop="text">
<p>My tree looks like</p>
<pre><code>parent/
|--__init__.py
\--a.py
</code></pre>
<p>And the content of <code>__init__.py</code> is</p>
<pre><code>import parent.a as _a
a = 'some string'
</code></pre>
<p>When I open up a Python at the top level and <code>import parent.a</code>, I would get the string instead of module. For example <code>import parent.a as the_a; type(the_a) == str</code>.</p>
<p>So I think OK probably <code>import</code> is importing the name from the <code>parent</code> namespace, and it's now overridden. So I figure I can go <code>import parent._a as a_module</code>. But this doesn't work as there is "No module named _a".</p>
<p>This is very confusing. A function can override a module with the same name, but a module cannot take on a new name and "reexport".</p>
<p>Is there any explanation I'm not aware of? Or is this documented feature?</p>
<p>Even more confusing, if I remove the <code>import</code> statement in <code>__init__.py</code>, everything is back normal again (<code>import parent.a; type(parent.a) is module</code>). But why is this different? The <code>a</code> name in <code>parent</code> namespace is still a string.</p>
<p>(I ran on Python 3.5.3 and 2.7.13 with the same results)</p>
</div>
<div class="post-text" itemprop="text">
<p>In an <code>import</code> statement, the module reference <em>never</em> uses attribute lookups. The statements</p>
<pre><code>import parent.a  # as ...
</code></pre>
<p>and</p>
<pre><code>from parent.a import ...  # as ...
</code></pre>
<p>will always look for <code>parent.a</code> in the <code>sys.modules</code> namespace before trying to further initiate module loading from disk.</p>
<p>However, for <code>from ... import name</code> statements, Python does look at attributes of the resolved module to find <code>name</code>, before looking for submodules.</p>
<p>Module globals and the attributes on a module object are the same thing. On import, Python adds submodules as attributes (so globals) to the parent module, but you are free to overwrite those attributes, as you did in your code. However, when you then use an import with the <code>parent.a</code> module path, attributes do not come into play.</p>
<p>From the <a href="https://docs.python.org/3/reference/import.html#submodules" rel="nofollow noreferrer"><em>Submodules</em> section of the Python import system reference documentation</a>:</p>
<blockquote>
<p>When a submodule is loaded using any mechanism [...] a binding is placed in the parent moduleâ€™s namespace to the submodule object. For example, if package <code>spam</code> has a submodule <code>foo</code>, after importing <code>spam.foo</code>, <code>spam</code> will have an attribute <code>foo</code> which is bound to the submodule.</p>
</blockquote>
<p>Your <code>import parent.a as _a</code> statement adds <em>two</em> names to the <code>parent</code> namespace; first <code>a</code> is added pointing to the <code>parent.a</code> submodule, and then <code>_a</code> is also set, pointing to the same object.</p>
<p>Your next line replaces the name <code>a</code> with a binding to the <code>'some string'</code> object.</p>
<p>The <a href="https://docs.python.org/3/reference/import.html#searching" rel="nofollow noreferrer"><em>Searching</em> section of the same</a> details how Python goes about finding a module when you import:</p>
<blockquote>
<p>To begin the search, Python needs the fully qualified name of the module [...] being imported.</p>
<p>[...]</p>
<p>This name will be used in various phases of the import search, and it may be the dotted path to a submodule, e.g. <code>foo.bar.baz</code>. In this case, Python first tries to import <code>foo</code>, then <code>foo.bar</code>, and finally <code>foo.bar.baz</code>. If any of the intermediate imports fail, a <code>ModuleNotFoundError</code> is raised.</p>
</blockquote>
<p>then further on</p>
<blockquote>
<p>The first place checked during import search is <code>sys.modules</code>. This mapping serves as a cache of all modules that have been previously imported, including the intermediate paths. So if <code>foo.bar.baz</code> was previously imported, <code>sys.modules</code> will contain entries for <code>foo</code>, <code>foo.bar</code>, and <code>foo.bar.baz</code>. Each key will have as its value the corresponding module object.</p>
<p>During import, the module name is looked up in <code>sys.modules</code> and if present, the associated value is the module satisfying the import, and the process completes. [...]  If the module name is missing, Python will continue searching for the module.</p>
</blockquote>
<p>So when trying to import <code>parent.a</code> all that matters is that <code>sys.modules['parent.a']</code> exists. <code>sys.modules['parent'].a</code> is not consulted.</p>
<p>Only <code>from module import ...</code> would ever look at attributes. From the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-import-statement" rel="nofollow noreferrer"><code>import</code> statement documentation</a>:</p>
<blockquote>
<p>The <code>from</code> form uses a slightly more complex process:</p>
<ol>
<li>find the module specified in the from clause, loading and initializing it if necessary;</li>
<li>for each of the identifiers specified in the import clauses:
  
  <ol>
<li>check if the imported module has an attribute by that name</li>
<li>if not, attempt to import a submodule with that name and then check the imported module again for that attribute</li>
<li>[...]</li>
</ol></li>
</ol>
</blockquote>
<p>So <code>from parent import _a</code> would work, as would <code>from parent import a</code>, and you'd get the <code>parent.a</code> submodule and the <code>'some string'</code> object, respectively.</p>
<p>Note that <code>sys.modules</code> is writable, if you <em>must</em> have <code>import parent._a</code> work, you can always just alter <code>sys.modules</code> directly:</p>
<pre><code>sys.modules['parent._a'] = sys.modules['parent.a']  # make parent._a an alias for parent.a
import parent._a  # works now
</code></pre>
</div>
<span class="comment-copy">This is just a hunch, but try <code>import parent.a as a_</code> (put the underscore not in the beginning). See the docs <a href="https://docs.python.org/3/tutorial/modules.html#more-on-modules" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">@RunOrVeith same problem, unfortunately..</span>
<span class="comment-copy">According to your answer, if I do <code>import parent.a</code> from outside, it should find the module <code>a</code> but not the string. But then if I do <code>import parent.a as the_a; type(the_a)</code> it still shows me the string</span>
<span class="comment-copy">@Hot.PxL: ack, indeed. Python does use attribute traversal there, contrary to the specs. I'm out of time for now, will revisit this later.</span>
