<div class="post-text" itemprop="text">
<p>Initially, I've a simple program to print out the whole output to the console.</p>
<p><strong>Initial Code to display output in the console only</strong></p>
<pre><code>import os, subprocess

print("1. Before")
os.system('ver')                            
subprocess.run('whoami')        
print('\n2. After')
</code></pre>
<p><strong>Output in console</strong></p>
<pre><code>1. Before

Microsoft Windows [Version 10]
user01

2. After
</code></pre>
<p>Then, I decided to have a copy on a log file (log.txt) too while maintaining the original output to the console.</p>
<p>So, this is the new code.</p>
<pre><code>import os, subprocess, sys

old_stdout = sys.stdout
log_file = open("log.txt","w")
sys.stdout = log_file

print("1. Before")          # This appear in message.log only, but NOT in console
os.system('ver')            # This appear in console only, but NOT in message.log
subprocess.run('whoami')    # This appear in console only, but NOT in message.log
print('\n2. After')         # This appear in message.log only, but NOT in console

sys.stdout = old_stdout
log_file.close()
</code></pre>
<p>Unfortunately, this didn't really work as expected. Some of the output only displayed on the console (<code>os.system('ver')</code> and <code>subprocess.run('whoami')</code>) while the <code>print()</code> function was only displayed on <code>log.txt</code> file and not in the console anymore.</p>
<p><strong>Output in console</strong></p>
<pre><code>Microsoft Windows [Version 10]
user01
</code></pre>
<p><strong>Output in <code>log.txt</code> file</strong></p>
<pre><code>1. Before

2. After
</code></pre>
<p>I was hoping to get similar output on both console and <code>log.txt</code> file. Is this possible?
What's wrong with my new code? Please let me know how to fix this.</p>
<p><strong>Desired Output in both console and <code>log.txt</code> file</strong></p>
<pre><code>1. Before

Microsoft Windows [Version 10]
user01

2. After
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The most appropriate way to handle this is with logging.  Here's an example:</p>
<p>This is the python 2.6+ and 3.x version of how you can do it.  (Can't override <code>print()</code> before 2.6)</p>
<pre><code>log = logging.getLogger()
log.setLevel(logging.INFO)

# How should our message appear?
formatter = logging.Formatter('%(message)s')

# This prints to screen
ch = log.StreamHandler()
ch.setLevel(logging.INFO)
ch.setFormatter(formatter)
log.addHandler(ch)

# This prints to file
fh = log.FileHandler('/path/to/output_file.txt')
fh.setLevel(logging.DEBUG)
fh.setFormatter(formatter)
log.addHandler(fh)

def print(*args, **kwargs):
    log.DEBUG(*args)
</code></pre>
<p>That option allows you the capability of using logging levels.  For instance, you can put debug logging throughout your code for when the application starts acting funky.  Swap <code>logLevel</code> to <code>logging.DEBUG</code> and suddenly, you're getting that output to screen.  Notice in the above example, we have 2 different logging levels, one for screen and another for file.  Yes, this will produce different output to each destination.  You can remedy this by changing both to use <code>logging.INFO</code> (or <code>logging.DEBUG</code>, etc).  (<a href="https://docs.python.org/3/library/logging.html#levels" rel="nofollow noreferrer">See full docs relating to log levels here.</a>)</p>
<p>In the above example, I've overridden <code>print()</code>, but I'd recommend instead that you just reference your framework using <code>log.DEBUG('Variable xyz: {}'.format(xyz))</code> or <code>log.INFO('Some stuff that you want printed.)</code></p>
<p><a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer">Full <code>logging</code> documentation.</a></p>
<p>There's another, easier way to do it with overriding, but not quite so robust:</p>
<pre><code>try:
    # Python 2
    import __builtin__
except ImportError:
    # Python 3
    import builtins as __builtin__
logfile = '/path/to/logging_file.log'

def print(*args, **kwargs):
    """Your custom print() function."""
    with open(logfile) as f_out:
        f_out.write(args[0])
        f_out.write('\n')
        # Uncomment the below line if you want to tail the log or something where you need that info written to disk ASAP.
        # f_out.flush()
    return __builtin__.print(*args, **kwargs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no magic done by system, <strong>file pointer</strong> such as <strong>stdout</strong> and <strong>stderr</strong> need to be treated differently by your code. For example,  <strong>stdout</strong> is one of the file pointer, you can do it in below:</p>
<pre><code>log_file_pointer = open('log.txt', 'wt')
print('print_to_fp', file=log_file_pointer)
# Note: the print function will actually call log_file_pointer.write('print_to_fp')
</code></pre>
<p>Based on your requirement, you want to make the magic function to handle more than one file pointer in single line, you need a wrapper function in below:</p>
<pre><code>def print_fps(content, files=[]):
    for fi in files:
        print(content, file=fi)
# the argument `file` of print does zero magic, it can only handle one file pointer once. 
</code></pre>
<p>Then, you can make the magic happen now (make the output in both screen and file.)</p>
<pre><code>import sys

log_file_pointer = open('log.txt', 'wt')
print_fps('1. Before', files=[log_file_pointer, sys.stdout])
print_fps('\n2. After', files=[log_file_pointer, sys.stdout])
</code></pre>
<p>After finishing the <code>print</code> part, let's move on to system call. Running any command in the operating system, you will get the return in default system file pointers: <strong>stdout</strong> and <strong>stderr</strong>. In python3, you can get those result in <strong>bytes</strong> by <strong>subprocess.Popen</strong>. And while running below code, what you want should be the result in <strong>stdout</strong>.</p>
<pre><code>import subprocess

p = subprocess.Popen("whoami", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
stdout, stderr = p.communicate()

# stdout: b'user01'
# stdout: b''
</code></pre>
<p>Yet again, you can call the wrapper function written in above and make output in both stdout and targeted file_pointer.</p>
<pre><code>print_fps(stdout, files=[log_file_pointer, sys.stdout])
</code></pre>
<p>Finally, combining all the code in above. (Plus one more convenient function.)</p>
<pre><code>import subprocess, sys

def print_fps(content, files=[]):
    for fi in files:
        print(content, file=fi)

def get_stdout(command):
    p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = p.communicate()
    # Note: Original idea is to return raw stdout 
    # return stdout
    # Based on the scenario of the @Sabrina, the raw bytes of stdout needs decoding in utf-8 plus replacing newline '\r\n' to be pure
    return stdout.decode().replace('\r\n', '')

log_file_pointer = open('log.txt', 'wt')
print_fps('1. Before', files=[log_file_pointer, sys.stdout])
print_fps(get_stdout('ver'), files=[log_file_pointer, sys.stdout])
print_fps(get_stdout('whoami'), files=[log_file_pointer, sys.stdout])
print_fps('\n2. After', files=[log_file_pointer, sys.stdout])
</code></pre>
<ul>
<li>Note: because the output of Popen is in bytes, you might need to do decode to remove <strong>b''</strong>. You can run <strong>stdout.decode()</strong> to decode bytes to utf-8 decoded str.*</li>
</ul>
</div>
<span class="comment-copy">If you don't mind creating a "wrapper" running your original program piped to <code>tee logfile</code> , see here <a href="https://en.wikipedia.org/wiki/Tee_(command)" rel="nofollow noreferrer">en.wikipedia.org/wiki/Tee_(command)</a></span>
<span class="comment-copy">Thanks UtahJarhead, I tried to run your code but getting so much error.   e.g.  <code>formatter = log.Formatter('%(message)s') AttributeError: 'RootLogger' object has no attribute 'Formatter'</code>   Previous code provided by @Kir Chou almost perfect, but there is some unwanted character in the output such as <code>b'\r\n</code>.</span>
<span class="comment-copy">This doesn't handle the case of <code>os.system</code> which simply uses the stdout and stderr file descriptors directly. But there is no good reason to use <code>os.system</code> anyway; this is one of many, many reasons to always prefer <code>subprocess.run</code>.</span>
<span class="comment-copy">@Sabrina, valid point.  I had a typo.  Instead of <code>log.Formatter()</code> it needed to be <code>logging.formatter()</code>.  My bad.</span>
<span class="comment-copy">@tripleee, Agreed, but I preferr <code>subprocess.Popen()</code> or <code>subprocess.check_output()</code></span>
<span class="comment-copy">As per the Python documentation, you should generally avoid <code>Popen</code> if one of the higher-level wrapper functions does what you need. <code>subprocess.run</code> is more versatile than the legacy <code>check_*</code> functions though I suppose they still have their place.</span>
<span class="comment-copy">With regard to decoding program output, unfortunately with the Windows command line, programs may output text as the console input or output codepage (defaults to system locale OEM), the system locale OEM or ANSI codepage, the user locale OEM or ANSI codepage, the user's preferred UI language, UTF-8, or even UTF-16. You have to know what the program does on a case by case basic. It's complete chaos. We're in luck if all text happens to be (7-bit) ASCII.</span>
<span class="comment-copy">Thats not windows specific. On Linux it is the LC_* madness. Try displaying a Linux ext4 filename correctly...</span>
<span class="comment-copy">Thanks @Kir Chou, your code is working, but there is some unwanted char such as <code>b'\r\nMicrosoft Windows [Version 10]\r\n'</code> ... would it be possible to remove <code>b'\r\n</code>?</span>
<span class="comment-copy">@Sabrina The reason why it returned with <code>\r\n</code> was because the stdout got the raw output without any decoding. In your case, you can post process the data by <code>stdout.decode().replace('\r\n', '')</code>. This should work if the returned stdout can be decoded in utf8. Knowing that dealing str and bytes is another big topic in Python, iâ€™m not going to explain deeply here.</span>
<span class="comment-copy">You really want to avoid raw <code>Popen</code> for all scenarios which the much simpler and more robust hich-level wrapper <code>subprocess.run</code> can handle.</span>
