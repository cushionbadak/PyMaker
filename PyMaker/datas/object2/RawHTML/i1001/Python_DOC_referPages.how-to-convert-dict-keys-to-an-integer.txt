<div class="post-text" itemprop="text">
<p>I have a dictionary where the keys are integers, and are in sequence.  From time to time, I need to remove older entries from the dictionary.  However, when I try to do this, I run into a "dict_keys" error.  </p>
<pre><code>    '&lt;=' not supported between instances of 'dict_keys' and 'int'
</code></pre>
<p>When I try to cast the value to an int, I'm told that's not supported.</p>
<pre><code>    int() argument must be a string, a bytes-like object or a number, not 'dict_keys'
</code></pre>
<p>I see answers here saying to use a list comprehension.  However, as there may be a million entries in this dictionary, I'm hoping there is some way to perform the cast without having to perform it on the entire list of keys.</p>
<pre><code>
    import numpy as np

    d = dict()
    for i in range(100):
        d[i] = i+10

    minId = int(np.min(d.keys()))
    while(minId &lt;= 5):
        d.pop(minId)
        minId += 1

</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to convert <code>dict_keys</code> to <code>int</code>. That's not a thing that makes sense, anyway. Your problem is that <code>np.min</code> needs a sequence, and the return value of <code>d.keys()</code> is not a sequence.</p>
<p>For taking the minimum of an iterable, use the regular Python <a href="https://docs.python.org/3/library/functions.html#min" rel="nofollow noreferrer"><code>min</code></a>, not <code>np.min</code>. However, calling <code>min</code> in a loop is an inefficient way to do things. <a href="https://docs.python.org/3/library/heapq.html#heapq.nsmallest" rel="nofollow noreferrer"><code>heapq.nsmallest</code></a> could help, or you could find a better data structure than a dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>You want a list is you want to use numpy:</p>
<pre><code>minId = np.min(list(d))
</code></pre>
<p>but actually you can use the builtin <code>min</code> here, which nows how to iterate, and for a dict, the iteration happens over keys anyway</p>
<pre><code>minId = min(d)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use an <a href="https://docs.python.org/3/library/collections.html#ordereddict-objects" rel="nofollow noreferrer">OrderedDict</a> and <code>pop</code> the oldest key-value pair. An advantage to use an <code>OrderedDict</code> is that it remembers the order that keys were first inserted. In this code, the first key will always be the minimum in the <code>OrderedDict</code> d. When you use <code>popitem(last=False)</code>, it simply removes the oldest or first key-value pair.</p>
<pre><code>from collections import OrderedDict

d = OrderedDict()
for i in range(100):
    d[i] = i+10
d.popitem(last=False) #removes the earliest key-value pair from the dict
print(d) 
</code></pre>
<p>If you'd like to remove the oldest 5 key-value pairs, extract these key-value pairs into a list of tuples and then use <code>popitem(last=False)</code> again to remove them from the top(heap analogy):</p>
<pre><code>a = list(d.items())[:5] #get the first 5 key-value pairs in a list of tuples
for i in a:
    if i in d.items():        
        print("Item {} popped from dictionary.".format(i))
        d.popitem(last=False)

#Output:
Item (0, 10) popped from dictionary.
Item (1, 11) popped from dictionary.
Item (2, 12) popped from dictionary.
Item (3, 13) popped from dictionary.
Item (4, 14) popped from dictionary.
</code></pre>
</div>
<span class="comment-copy">Did you look at the output of <code>np.min(d.keys())</code>? It doesn't return a scalar.</span>
<span class="comment-copy">I would only be calling pop inside a loop.  But using standard min will fix it.  I saw the min(a,b) variant in the docs, but somehow missed the min(iterable).</span>
<span class="comment-copy">I don't have enough reputation to up-vote.  It's good to know about the OrderedDict, though for my situation, I think python min() on a regular dictionary will suffice.</span>
