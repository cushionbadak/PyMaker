<div class="post-text" itemprop="text">
<p>I have a dataframe with two columns <code>A</code> and <code>B</code> that contains lists:</p>
<pre><code>import pandas as pd

df = pd.DataFrame({"A" : [[1,5,10],  [], [2], [1,2]],
                   "B" : [[15, 2],   [], [6], []]})
</code></pre>
<p>I want to construct a third column <code>C</code> that is defined such that it is equal to the smallest possible difference between list-elements in <code>A</code> and <code>B</code> if they are non-empty, and 0 if one or both of them are empty. </p>
<p>For the first row the smallest difference is 1 (we take absolute value..), for the second row it is 0 due to lists being empty, third row is 4 and fourth row is 0 again due to one empty list, so we ultimately end up with:</p>
<pre><code>df["C"] = [1, 0, 4, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This isn't easily vectorisable, since you have <code>object</code> dtype series of lists. You can use a list comprehension with <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a>:</p>
<pre><code>from itertools import product

zipper = zip(df['A'], df['B'])
df['C'] = [min((abs(x - y) for x, y in product(*vals)), default=0) for vals in zipper]

# alternative:
# df['C'] = [min((abs(x - y) for x, y in product(*vals)), default=0) \
#            for vals in df[['A', 'B']].values]

print(df)
#             A        B  C
# 0  [1, 5, 10]  [15, 2]  1
# 1          []       []  0
# 2         [2]      [6]  4
# 3      [1, 2]       []  0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the following list comprehension, checking for the <code>min</code> difference of the cartesian product (<a href="https://docs.python.org/2/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a>) from both columns</p>
<pre><code>[min(abs(i-j) for i,j in product(*a)) if all(a) else 0 for a in df.values]
[1, 0, 4, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>df['C'] = df.apply(lambda row: min([abs(x - y) for x in row['A'] for y in row['B']], default=0), axis=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I just want to introduce the <a href="https://stackoverflow.com/a/53218939/7964527">unnesting</a> again </p>
<pre><code>df['Diff']=unnesting(df[['B']],['B']).join(unnesting(df[['A']],['A'])).eval('C=B-A').C.abs().min(level=0)
df.Diff=df.Diff.fillna(0).astype(int)
df
Out[60]: 
            A        B  Diff
0  [1, 5, 10]  [15, 2]     1
1          []       []     0
2         [2]      [6]     4
3      [1, 2]       []     0
</code></pre>
<hr/>
<p>FYI </p>
<pre><code>def unnesting(df, explode):
    idx=df.index.repeat(df[explode[0]].str.len())
    df1=pd.concat([pd.DataFrame({x:np.concatenate(df[x].values)} )for x in explode],axis=1)
    df1.index=idx
    return df1.join(df.drop(explode,1),how='left')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think this works</p>
<pre><code>def diff(a,b):    
    if len(a) &gt; 0 and len(b) &gt; 0:
        return min([abs(i-j) for i in a for j in b])
    return 0

df['C'] = df.apply(lambda x: diff(x.A, x.B), axis=1)
df

           A        B   C
0   [1, 5, 10]  [15, 2] 1
1           []       [] 0
2          [2]      [6] 4
3       [1, 2]       [] 0
</code></pre>
</div>
<span class="comment-copy">Is it possible to convert the dtype-series to a difference format so that it can be vectorized?</span>
<span class="comment-copy">@N08, Since you have variable length lists, not easily, no. NumPy / Pandas works best when each dimension has the same number of values. You may end up with lots of empty values, which is also inefficient.</span>
<span class="comment-copy">@jpp, nice one,  what is zipper here.</span>
<span class="comment-copy">Just realized that was precisely what you had in your solution :-), left it as it was with the ternary if. Thanks for the tips anyways</span>
<span class="comment-copy">@yatu, No probs, always like to help :)</span>
<span class="comment-copy"><code>min</code> can take an iterable (so you can use a generator expression, no extra list creation required). In addition, <code>tolist()</code> isn't required when iterating <code>df.values</code>. Finally, <code>min</code> has a default value which removes the need for a ternary statement.</span>
<span class="comment-copy">Awesome @Filipe +1.</span>
<span class="comment-copy">@pygo notice this will slow than jpp and yatu 's solution . :-)</span>
<span class="comment-copy">@W-B,  already heads up &amp; +1 for both solution as well. :-)</span>
