<div class="post-text" itemprop="text">
<p>I have a list of tuples which I would like to import into a dictionary. Those tuples consist of two strings. I would like to convert those tuples into integers. i.e</p>
<pre><code>myList = ['0,1', '0,2', '0,3']
</code></pre>
<p>The resulting list should be:</p>
<pre><code>resList = [(0,1), (0,2), (0,3)]
</code></pre>
<p>I have tried using:</p>
<pre><code>list(map(int, myList))
</code></pre>
<p>But that doesn't seem to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>eval</code> function to get the tuples, like this. Works in both python2, and python3.</p>
<pre><code>&gt;&gt;&gt; myList = ['0,1', '0,2', '0,3']
&gt;&gt;&gt; list(map(eval, myList))
[(0, 1), (0, 2), (0, 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You also need to split your strings by <code>','</code>.</p>
<pre><code>&gt;&gt;&gt; [tuple(map(int, s.split(','))) for s in myList]                                                                               
[(0, 1), (0, 2), (0, 3)]
</code></pre>
<p>Another option is to use the <code>csv</code> module.</p>
<pre><code>&gt;&gt;&gt; import csv                                                                                                                    
&gt;&gt;&gt; list(csv.reader(myList))                                                                                                      
[['0', '1'], ['0', '2'], ['0', '3']]
&gt;&gt;&gt; [tuple(map(int, row)) for row in csv.reader(myList)]                                                                          
[(0, 1), (0, 2), (0, 3)]
</code></pre>
<p>If it's not terribly important the the inner elements of the result are tuples and that they are of type <code>int</code>, we can simplify the <code>csv</code> solution to</p>
<pre><code>&gt;&gt;&gt; list(csv.reader(myList, quoting=csv.QUOTE_NONNUMERIC))                                                                        
[[0.0, 1.0], [0.0, 2.0], [0.0, 3.0]]
</code></pre>
<hr/>
<p><strong>~edit~</strong></p>
<p><a href="https://stackoverflow.com/a/54052465/3620003">thelogicalkoan's answer</a> reminded me of <code>ast.literal_eval</code> which provides the most elegant (and safe) solution here.</p>
<pre><code>&gt;&gt;&gt; from ast import literal_eval                                                                                                  
&gt;&gt;&gt; [literal_eval(x) for x in myList]                                                                                             
[(0, 1), (0, 2), (0, 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternative solution is to use <code>ast.literal_eval</code> (instead of <code>eval</code> which can be considered unsafe):</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.literal_eval('0,1')
(0, 1)
</code></pre>
<p>So, you can do:</p>
<pre><code>&gt;&gt;&gt; my_list = ['0,1', '0,2', '0,3']
&gt;&gt;&gt; result = [ast.literal_eval(x) for x in my_list]
&gt;&gt;&gt; result
[(0, 1), (0, 2), (0, 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#str.partition" rel="nofollow noreferrer">str.partition</a> can be used to do this.</p>
<pre><code>&gt;&gt;&gt; [(int(x), int(y)) for x, _, y in (z.partition(',') for z in myList)]
[(0, 1), (0, 2), (0, 3)]
</code></pre>
<p>The generator expression <code>(z.partition(',') for z in myList)</code> produces the output of <code>str.partition</code> on each element of the list, and then we call <code>int</code> on the parts that we require. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is a different option:</p>
<pre><code>myList = ['0,1', '0,2', '0,3']

def tSet(list): 
    return tuple([int(i) for i in list])

resList  = [tSet(i.split(",")) for i in myList]

print(resList) #Output: [(0, 1), (0, 2), (0, 3)]
</code></pre>
</div>
<span class="comment-copy">Seems to have done the trick for me! Thanks!</span>
<span class="comment-copy"><code>ast.literal_eval</code> is too powerful for this use case. In particular, it will happily parse lines with other valid python structures in them. I would argue it is marginally less safe than splitting and parsing via <code>int</code>.</span>
