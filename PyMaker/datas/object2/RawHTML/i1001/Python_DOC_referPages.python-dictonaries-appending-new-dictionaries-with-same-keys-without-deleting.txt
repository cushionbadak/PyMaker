<div class="post-text" itemprop="text">
<p>A simple example for what I want to do:</p>
<p>I have two (or more) dictionaries with same keys:</p>
<pre><code>a = {"animal" : "elefant"}
b = {"animal" : "dog"}
</code></pre>
<p>and I would like to have a new dictionary containing both, looking like this:</p>
<pre><code>c = { {"animal" : "elefant"}, {"animal" : "dog"} }
</code></pre>
<p>of course, I have multiple dictionaries and I would like to add them to one big dictionary for example in a for loop. </p>
<p>I don't want to map all values to one key, maybe its not a dictionary of dictionarys, but a list of dictionaries? (This is why I am asking..)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can map the same key to multiple values with a <code>collections.defaultdict()</code>:</p>
<pre><code>from collections import defaultdict

a = {"animal" : "elefant"}
b = {"animal" : "dog"}

d = defaultdict(list)
d["animal"].append(a["animal"])
d["animal"].append(b["animal"])

print(d)
# defaultdict(&lt;class 'list'&gt;, {'animal': ['elefant', 'dog']})
</code></pre>
<p>If you want to keep the same dictionaries together in nested lists:</p>
<pre><code>from collections import defaultdict

lst = [{"animal": "elefant"}, {"animal": "dog"}, {"human": "John"}, {"human": "Jane"}]

data = defaultdict(list)
for dic in lst:
    k = tuple(dic)[0]
    data[k].append(dic)

print(list(data.values()))
# [[{'animal': 'elefant'}, {'animal': 'dog'}], [{'human': 'John'}, {'human': 'Jane'}]]
</code></pre>
<p>Or you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code></a>:</p>
<pre><code>from itertools import groupby

key_func = lambda x: tuple(x)[0]

print([list(g) for _, g in groupby(sorted(lst, key=key_func), key=key_func)])
# [[{'animal': 'elefant'}, {'animal': 'dog'}], [{'human': 'John'}, {'human': 'Jane'}]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the extend or update methods: </p>
<pre><code>first = {1: 1, 2: 2}
second = {2: 'ha!', 3: 3}
first.update(second)
</code></pre>
<p>output: </p>
<pre><code>first:
{1: 1, 2: 'ha!', 3: 3}
</code></pre>
<p>this is the default, but it can be implemented differently to turn a dictionary in to a dictionary of dictionaries</p>
<h1>edit:</h1>
<pre><code>def update_without_overwriting(d, x):
    dict.update({k: v for k, v in x.items() if k not in d})
</code></pre>
<p>to get around any potential overwriting</p>
</div>
<span class="comment-copy">Are you aware that you have a set and not a dict? Can you prove an example of what happens to c if you add a new dict like this ? <code>{"fruit": "banana"}</code></span>
<span class="comment-copy"><code>c</code> is not a dictionary but a set of dictionaries, which doesn't exist since dicts aren't hashable. What is your expected <i>valid</i> output ?</span>
<span class="comment-copy">you mean to have animal as key and a <i>list</i> of animals as value probably?</span>
<span class="comment-copy">I suggest to use a list <code>c =[ {"animal" : "elefant"}, {"animal" : "dog"} ]</code>. I think that  it is more easy to use them</span>
<span class="comment-copy">Hm, ok I thought this was possible.. What I have is a lot of dictionaries containing  same keys with different values, and I would like to have something like that: c = { dict1, dict2, ... }, something like "append" just for dictionaries</span>
<span class="comment-copy">if this is the answer, then the question is a duplicate</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre Very true. I guess we should go on the lookout for an appropriate duplicate and I will take my answer down.</span>
<span class="comment-copy">This is what I don't want.. (look my comment above)</span>
<span class="comment-copy">but it's unclear ATM, not a duplicate yet :) see? :)</span>
<span class="comment-copy">@Magdaanne Why? You can't make a <code>{ {"animal" : "elefant"}, {"animal" : "dog"} }</code>? There's no keys for the sub dictionaries. It seems pretty intuitive keep to a single key that maps to multiple values for your use case.</span>
<span class="comment-copy">that doesn't work, it overwrites the old keys</span>
<span class="comment-copy">the extend method doesnt</span>
<span class="comment-copy">Even in your own example it is overwriting the value stored against 2... it can't <i>not</i>, this is a fundamental property of dictionaries</span>
<span class="comment-copy">check the last edit</span>
