<div class="post-text" itemprop="text">
<p>Consider a right-angle triangle, which has the properties</p>
<ul>
<li>Hypotenuse (side)</li>
<li>Adjacent (side)</li>
<li>Opposite (side)</li>
<li>Area</li>
</ul>
<p><img alt="triangles" src="https://www.mathsteacher.com.au/year10/ch15_trigonometry/01_ratios/Image3119.gif"/></p>
<p>Given any 2 of these properties, it is always possible to calculate the value of the other 2. My question relates to what the most efficient/elegant way of doing this is.</p>
<p>At present, the only way of doing this that I can think of is to use (4C2)*2 = 12 case statements, each relating to a possible combination of inputsa that may be provided.</p>
<p>For example, using python you might have something like</p>
<pre><code>class RightAngleTriangle():
    def __init__(this, propertyType1, propertyValue1, propertyType2, propertyValue2):
        this.adjacent = 0
        this.opposite = 0
        this.hypotenuse = 0
        this.area = 0
    if (propertyType1 == "adjacent" and propertyType2 == "opposite"):
        this.adjacent = propertyValue1
        this.opposite = propertyValue2
        this.hypotenuse = (propertyValue1**2 + propertyValue2**2)**0.5
        this.area = (propertyValue1 * propertyValue2)/2
    elif (propertyType1 == "opposite" and propertyType2 == "adjacent"):
        this.adjacent = propertyValue2
        this.opposite = propertyValue1
        this.hypotenuse = (propertyValue1**2 + propertyValue2**2)**0.5
        this.area = (propertyValue1 * propertyValue2)/2
    elif (propertyType1 == "adjacent" and propertyType2 == "hypotenuse"):
        this.adjacent = propertyValue1
        this.hypotenuse = propertyValue2
        this.opposite = (propertyValue2**2 + propertyValue1**2)**0.5
        this.area = (this.opposite * this.adjacent)/2
</code></pre>
<p>...and so on...</p>
<p>You could then create your triangle object, and print its four properties, using code (in this case python) like the below.</p>
<pre><code>t1 = RightAngleTriangle("adjacent", 10, "opposite", 12)
print(t1.adjacent)
print(t1.opposite)
print(t1.hypotenuse)
print(t1.area)
</code></pre>
<p>This is hideous. Is there a more eligant solution to this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, at least two - one using args and one using key word args. So:</p>
<pre><code>class RightAngleTriangle():
    def __init__(self, *args):
        self.adjacent = 0
        self.opposite = 0
        self.hypotenuse = 0
        self.area = 0
        for property_type, property_value in zip(args[::2], args[1::2]):
            setattr(self, property_type, property_value)
        if not self.adjacent:
           # calculate
        elif not self.opposite:
           # calculate
        elif not self.hypotenuse:
           # calculate
        self.area = (this.opposite * this.adjacent) / 2
</code></pre>
<p>This would work with your current input, but let's agree - it's still not very elegant solution. So, let's use kwargs:</p>
<pre><code>class RightAngleTriangle():
    def __init__(self, adjacent=0, opposite=0, hypotenuse=0):
        self.adjacent = adjacent
        self.opposite = opposite
        self.hypotenuse = hypotenuse
        self.area = 0
        if not self.adjacent:
           # calculate
        elif not self.opposite:
           # calculate
        elif not self.hypotenuse:
           # calculate
        self.area = (this.opposite * this.adjacent) / 2
</code></pre>
<p>And now you can simply call this code as:
<code>t1 = RightAngleTriangle(adjacent=10, opposite=12)</code></p>
</div>
<span class="comment-copy"><i>"more elegant"</i> is inevitably opinion-based, but I'd use <a href="https://www.python.org/dev/peps/pep-3102/" rel="nofollow noreferrer">keyword-only arguments</a> and <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">properties</a>. Maybe look at <a href="https://codereview.stackexchange.com">Code Review</a>.</span>
<span class="comment-copy">Well, you could cut your number of cases in half by sorting the givens - if <code>propertyType1 &gt; propertyType2</code>, then swap the types and values.  That way, you wouldn't have to implement both adjacent/opposite and opposite/adjacent, for example.</span>
<span class="comment-copy">Cheers for the response. However, would you not need case statements within each calculation to deduce which pieces of information are avaliable to do the calculation?</span>
<span class="comment-copy">Good point, in this case I did the optimistic assumption that user will provide at least two values properly. However, if before calculations we would check that at most one variable is equal 0, than we can easily use the remaining two to calculate the last missing - we will know they were provided. E.g. <code>if sum([v == 0 for v in [self.adjacent, self.opposite, self.hypotenuse]]) &gt; 1: raise ValueError("Can't calculate!")</code> and then the calculation.</span>
<span class="comment-copy">Cheers again - but there will be 2 missing values (the area is also a potential input)! That means we can't deduce the inputs provided by checking for a single 0.</span>
<span class="comment-copy">Alright, from your example I assumed that the area will not be an input anytime. I will rethink it and try to come back with a proper edit for the answer.</span>
