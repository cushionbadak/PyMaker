<div class="post-text" itemprop="text">
<p>When <code>yield</code>ing from the below generator, is the postgres connection kept active or does the <code>yield</code> need to be less indented such that a new connection is made on every <code>next()</code>?</p>
<pre><code>def getData(start, end):
    with psycopg2.connect("dbname='test' user='user' host='localhost' password='password'") as conn:
        time = start
        while time&lt;end:
            with conn.cursor() as cur:
                cur.execute(query.format(start, time))
                data = cur.fetchall()
            time += one_week
            yield data
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, the context manager is kept active. <code>yield</code> <em>pauses</em> the function, nothing is exited.</p>
<p><code>yield</code> doesn't alter the order of execution inside a function. The function is merely 'paused', frozen at the point where the <code>yield</code> expression has executed and produced a value. When the generator is later on resumed (by calling <code>__next__</code> on the iterator), the function continues at that point again. A <code>with</code> statement <code>__exit__</code> method can't be called when a generator is paused, so the context manager <em>can't</em> be exited until the generator is resumed, anyway.</p>
<p>You can see this happen if you create a simple context manager with the <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" rel="noreferrer"><code>@contextmanager</code> decorator</a> (itself relying on a generator for the implementation!):</p>
<pre><code>import sys
from contextlib import contextmanager

@contextmanager
def loud_contextmanager():
    print("Context entered!")
    try:
        yield "value to bind the 'as' target to"
    finally:
        exc_info = sys.exc_info()
        if exc_info:
            print("Context exited with an exception!", exc_info)
        else:
            print("Context exited!")

def generator_stages():
    yield "First yield, outside of a context manage"
    with loud_contextmanager() as cm_as_value:
        yield f"Inside of the with block, received {cm_as_value}"
    yield "Outside of with block, last yield"
</code></pre>
<p>And when you pull values from the generator to print, you'll see this:</p>
<pre><code>&gt;&gt;&gt; gen = generator_stages()
&gt;&gt;&gt; print(next(gen))
First yield, outside of a context manage
&gt;&gt;&gt; print(next(gen))
Context entered!
Inside of the with block, received value to bind the 'as' target to
&gt;&gt;&gt; print(next(gen))
Context exited with an exception! (None, None, None)
Outside of with block, last yield
&gt;&gt;&gt; next(gen, "generator was done")
'generator was done'
</code></pre>
<p>Note that the context is not exited until we retrieve the 3rd value! After the second <code>next()</code> call the code is paused at a point inside of the <code>with</code> block, and only when unpaused can the context be exited, and the <code>finally</code> suite of the <code>loud_contextmanager()</code> function can be run.</p>
</div>
