<div class="post-text" itemprop="text">
<p>I'm using an API that has an endpoint that can be filtered by date. The date needs to be in timestamp in seconds since epoch and it must be in UTC so that the API can be properly filtered </p>
<p>This is what I've tried as of today</p>
<pre><code>first_day = datetime.utcnow().replace(day=1)
first_day = first_day.replace(hour=0, minute=0, second=0, microsecond=0)
print(first_day, int(first_day.timestamp()))

last_day =    datetime.utcnow().replace(day=calendar.monthrange(datetime.utcnow().year,     datetime.utcnow().month)[1])
last_day = last_day.replace(hour=0, minute=0, second=0, microsecond=0)
print(last_day, int(last_day.timestamp()))
</code></pre>
<p>This is my output</p>
<pre><code>2019-01-01 00:00:00 1546318800
2019-01-31 00:00:00 1548910800
</code></pre>
<p>And then when I take the gotten timestamp 1546318800 for the first day of January and then I go to <a href="https://www.epochconverter.com/" rel="nofollow noreferrer">https://www.epochconverter.com/</a> and paste it to human date I get the following:</p>
<p>GMT: Tuesday, January 1, 2019 5:00:00 AM
Your time zone: Tuesday, January 1, 2019 12:00:00 AM GMT-05:00 </p>
<p>I want the GMT time to be January 1, 2019 12:00:00 AM</p>
<p>How can I accomplish this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are working with <em>naive</em> <code>datetime</code> objects. For a naive <code>datetime</code> object, the time is assumed to be in <em>local</em> time, and so your local system timezone offset is first applied. From the <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp" rel="nofollow noreferrer">`datetime.timestamp() documentation</a>:</p>
<blockquote>
<p>Naive <code>datetime</code> instances are assumed to represent local time and this method relies on the platform C <code>mktime()</code> function to perform the conversion.</p>
</blockquote>
<p>and further on:</p>
<blockquote>
<p><strong>Note</strong>: There is no method to obtain the POSIX timestamp directly from a naive <code>datetime</code> instance representing UTC time. If your application uses this convention and your system timezone is not set to UTC, you can obtain the POSIX timestamp by supplying <code>tzinfo=timezone.utc</code>:</p>
<pre><code>timestamp = dt.replace(tzinfo=timezone.utc).timestamp()
</code></pre>
</blockquote>
<p>Note that you can make your date calculation logic much easier by working with <code>daetime.date</code> objects and using <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.combine" rel="nofollow noreferrer"><code>datetime.combine()</code></a>; this method also accepts a new timezone value, so you can pass in the <code>timezone.utc</code> timezone at this stage:</p>
<pre><code>from datetime import datetime, date, time, timedelta, timezone

# create first and last day of the month
first_day = date.today().replace(day=1)
last_day = (first_day + timedelta(days=31)).replace(day=1) - timedelta(days=1)
first_day = int(datetime.combine(first_day, time.min, tzinfo=timezone.utc).timestamp())
last_day = int(datetime.combine(last_day, time.min, tzinfo=timezone.utc).timestamp())
</code></pre>
<p>The above calculates the last day of the month by first adding 31 days (guaranteed to reach the next month whatever the current), then dropping that new date down to the first day of the month and then subtracting one day.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime, date, time, timedelta, timezone
&gt;&gt;&gt; first_day = date.today().replace(day=1)
&gt;&gt;&gt; last_day = (first_day + timedelta(days=31)).replace(day=1) - timedelta(days=1)
&gt;&gt;&gt; first_day, last_day
(datetime.date(2019, 1, 1), datetime.date(2019, 1, 31))
&gt;&gt;&gt; int(datetime.combine(first_day, time.min, tzinfo=timezone.utc).timestamp())
1546300800
&gt;&gt;&gt; int(datetime.combine(last_day, time.min, tzinfo=timezone.utc).timestamp())
1548892800
</code></pre>
<p>Note that midnight on the 31st of January leaves another 24 hours of the month left uncovered. You may want to remove the <code>- timedelta(days=1)</code> subtraction off of the <code>last_day</code> calculation above to switch to February 1st midnight (1548979200), or use <code>time.max</code> to shift the timestamp to 23:23:59 (1 second before midnight) on the 31st (1548979199).</p>
</div>
<span class="comment-copy">Why the whole dance with removing the time? <code>datetime.datetime.combine(datetime.date.today(), datetime.time.min)</code> gets you there faster.</span>
<span class="comment-copy">Check this: <a href="https://stackoverflow.com/questions/8777753/converting-datetime-date-to-utc-timestamp-in-python/8778548" title="converting datetime date to utc timestamp in python">stackoverflow.com/questions/8777753/…</a> or <a href="https://stackoverflow.com/questions/5067218/get-utc-timestamp-in-python-with-datetime" title="get utc timestamp in python with datetime">stackoverflow.com/questions/5067218/…</a></span>
<span class="comment-copy">Why midnight on the 31st? There is another 24 hours left in the month at that point. Why not midnight on the 1st of February? Or 23:23:59 on the 31st?</span>
