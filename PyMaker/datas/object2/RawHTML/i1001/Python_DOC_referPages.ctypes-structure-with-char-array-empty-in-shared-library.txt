<div class="post-text" itemprop="text">
<p>I have a shared C library with a struct I would like to use in my python code</p>
<pre><code>struct my_struct {
  char name[64];
};
</code></pre>
<p>so in python I recreate it with</p>
<pre><code>class MyStruct(ctypes.Structure):
  _fields_ = [
    ("name", ctypes.c_char*64)
  ]
</code></pre>
<p>when I check the type of MyStruct.name i get 'str', whereas I expected 'c_char_Array_64'.</p>
<pre><code>s=MyStruct()
print type(s.name) # &lt;type 'str'&gt;
</code></pre>
<p>So when I set the 'name' and try to use it, C sees it as blank.</p>
<pre><code>s.name="Martin"
lib=ctypes.cdll.LoadLibrary('./mylib.so')
lib.my_func(s) # prints ''
</code></pre>
<p>where lib is the shared C library loaded with ctypes and my_func simply prints struct-&gt;name</p>
<pre><code>void my_func(struct my_struct *s){
  printf("Hello %s\n", s-&gt;name);
}
</code></pre>
<p>I would like to know why ctypes.Structure converts the char-array to a string and how to use it in the case specified above.</p>
<p>Thank you</p>
<h2>Update &amp; Solution</h2>
<p>Tnanks to @CristiFati for the help on debugging this problem. I have marked his answer as correct as it is in fact the answer to the question posted. In my case the problem was that the Structs were NOT of <strong>equal lengths</strong> in the Python and C program. So to whoever stumbles upon this question in the future, be very meticulous in checking that your Structs are in fact defined equally.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're doing something wrong, but without looking at the full code I can't say what. So I prepared a small example that works. <br/>I'm also posting <a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer">[Python 3]: ctypes - A foreign function library for Python</a> as a reference.</p>
<p><em>dll.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 

#if defined(_WIN32)
#  define DLL_EXPORT __declspec(dllexport)
#else
#  define DLL_EXPORT
#endif


typedef struct Struct0_ {
    char name[64];
} Struct0;


DLL_EXPORT void test(Struct0 *ps0){
    printf("Hello %s\n", ps0-&gt;name);
}
</code></pre>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import ctypes


DLL = "./dll.dll"

CharArr64 = ctypes.c_char * 64

class Struct0(ctypes.Structure):
    _fields_ = [
        ("name", CharArr64),
    ]


def main():
    dll_dll = ctypes.CDLL(DLL)
    test_func = dll_dll.test
    test_func.argtypes = [ctypes.POINTER(Struct0)]

    s0 = Struct0()
    s0.name = b"Martin"
    res = test_func(ctypes.pointer(s0))


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>(py_064_03.06.08_test0) e:\Work\Dev\StackOverflow\q054089371&gt;"c:\Install\x86\Microsoft\Visual Studio Community\2015\vc\vcvarsall.bat" x64

(py_064_03.06.08_test0) e:\Work\Dev\StackOverflow\q054089371&gt;dir /b
code.py
dll.c

(py_064_03.06.08_test0) e:\Work\Dev\StackOverflow\q054089371&gt;cl /nologo /DDLL /MD dll.c  /link /NOLOGO /DLL /OUT:dll.dll
dll.c
   Creating library dll.lib and object dll.exp

(py_064_03.06.08_test0) e:\Work\Dev\StackOverflow\q054089371&gt;dir /b
code.py
dll.c
dll.dll
dll.exp
dll.lib
dll.obj

(py_064_03.06.08_test0) e:\Work\Dev\StackOverflow\q054089371&gt;"e:\Work\Dev\VEnvs\py_064_03.06.08_test0\Scripts\python.exe" code.py
Python 3.6.8 (tags/v3.6.8:3c6b436a57, Dec 24 2018, 00:16:47) [MSC v.1916 64 bit (AMD64)] on win32

Hello Martin

(py_064_03.06.08_test0) e:\Work\Dev\StackOverflow\q054089371&gt;rem Also run with Python 2.7 ... Not recommended.

(py_064_03.06.08_test0) e:\Work\Dev\StackOverflow\q054089371&gt;"e:\Work\Dev\VEnvs\py_064_02.07.15_test0\Scripts\python.exe" code.py
Python 2.7.15 (v2.7.15:ca079a3ea3, Apr 30 2018, 16:30:26) [MSC v.1500 64 bit (AMD64)] on win32

Hello Martin
</code></pre>
</blockquote>
</div>
<span class="comment-copy">Can you show how my_func is defined in C and wrapped in ctypes/python?</span>
<span class="comment-copy">It is already shown above</span>
<span class="comment-copy">You need to define <i>argtypes</i> (and <i>restype</i>) for your function in <i>Python</i> (<code>lib.my_func.argtypes = [ctypes.POINTER(MyStruct)]</code>, and call it: <code>lib.my_func(ctypes.pointer(s))</code>). Most of the <i>ctypes</i> failures are due to this reason. Check <a href="https://stackoverflow.com/questions/53182796/python-ctypes-issue-on-different-oses/53185316#53185316" title="python ctypes issue on different oses">stackoverflow.com/questions/53182796/…</a> (and tons of other questions) for more details.</span>
<span class="comment-copy">Thank you @CristiFati, I will try this</span>
<span class="comment-copy">Sorry @CristiFati, s-&gt;name is still blank. Have any additional approaches I can try?</span>
<span class="comment-copy">My best guess is OP didn't set the argtypes for the function and so the struct is being passed by value and not by pointer. That is, the function is interpreting the string <code>'Martin\0\0'</code> as pointer to <code>MyStruct</code>. eg. compare <code>libc.printf(b'hello %sn', s)</code> and <code>libc.printf(b'hello %s\n', ctypes.byref(s))</code>.  The former prints garbage, whilst the latter works as it passes a pointer to <code>s</code> as the second argument (which just so happens to be the same as the pointer to <code>s-&gt;name</code>).</span>
<span class="comment-copy">@Dunes: I specified in one comment how the function should be called, and according to the next comment, that was done. Then I really wanted to see if I could reproduce it, and I posted the answer.</span>
<span class="comment-copy">@CristiFati I've tried your code and it works perfectly. Even tried porting it back to what my code looks like and it still works. I haven't posted 'the entire code' as it is a massive project I'm building on top of, and I thought what I posted would be enough to find the issue. But it is not. There must be somewhere else in the code that interferes with how the 'pass by reference works?' I appreciate the help</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value" title="whats the difference between passing by reference vs passing by value">stackoverflow.com/questions/373419/…</a>. In this scenario it has everything to do with how the function is called from <i>Python</i>. In the code there are 2 places: <code>ctypes.POINTER</code> and <code>ctypes.pointer</code>, those are the key, you probably missed one of them. Or it could be that you did the changes (in <i>C</i> sources), but forgot to rebuild.</span>
<span class="comment-copy">SOLVED. @CristiFati. I found and issue and as you said "without seeing the entire code...". It turns out the structs were not equal lengths in python and C which created a mismatch in where the data were actually located. I will still accept your answer as it is in fact the answer to the question stated. Thank you for your help.</span>
