<div class="post-text" itemprop="text">
<p>I've got a function <code>f()</code> that makes an API call and I want to call it multiple times asynchronously. I use the <code>asyncio</code> lib like that:</p>
<pre><code>async def main():
    loop = asyncio.get_event_loop()
    futures = [loop.run_in_executor(None, f) for i in range(10)]
    await asyncio.gather(*futures)
    return futures

result = asyncio.get_event_loop().run_until_complete(main())
</code></pre>
<p>The problem is that sometimes <code>f()</code> raises an <code>Exception</code> and I'm not sure how to handle it. The doc says that <code>Futures</code> can contain an <code>Exception</code>, but that's not the case here, error is raised and program crashes.</p>
<p>How do I achieve that ? I think I could write a wrapper for <code>f()</code> and <code>try: catch:</code> the Exception, but that seems ugly if the feature is provided by the lib.</p>
<p>Thanks in advance for help,</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>The problem is that sometimes <code>f()</code> raises an <code>Exception</code> and I'm not sure how to handle it.</p>
</blockquote>
<p>That will depend on what you want to do when an exception occurs. Remember that <code>asyncio.gather()</code> is convenience API that propagates exceptions by default to avoid blindly continuing in case of error. If you <em>want</em> to proceed in case of exception, you have other options:</p>
<ul>
<li><p>Pass <code>return_exceptions=True</code> to <code>gather</code> - this will cause <code>gather</code> to return the exception objects along with other results. Convenient and easy to use, but mixes exceptions with regular results, which is a bit messy.</p></li>
<li><p>Use <code>asyncio.wait()</code> instead of <code>asyncio.gather()</code>. It returns a set of <em>futures</em>, for which you can test whether they completed by raising or by producing a result.</p></li>
<li><p>Wrap <code>f()</code> in your own function that catches the exception as you see fit. You considered and rejected this, but in some cases it's exactly the right approach.</p></li>
</ul>
</div>
<span class="comment-copy">Thanks a lot for your answer, that's what I was looking for. I ran a few tests don't see clearly the difference between the first 2 options, it seems to me that <code>gather(*futures, return_exceptions=True)</code> does the same thing than <code>wait(futures)</code> (except that <code>wait</code> does not respect order), in both cases exceptions are mixed with results right ? (It's not a problem for my usecase, just to understand. Marked as solved)</span>
<span class="comment-copy">@MeanStreet The difference is that <code>wait()</code> returns sets of <a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future" rel="nofollow noreferrer"><i>futures</i></a>. Given a future, you can extract its result with <code>result()</code>, which will either return the result or re-raise the exception if there was one. But you can also call <a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future.exception" rel="nofollow noreferrer"><code>exception()</code></a> to test whether an exception was raised. This allows you to distinguish between a function that raised an exception and one that (for whatever reason) happened to <i>return</i> an <code>Exception</code> instance.</span>
<span class="comment-copy">Oh I got it, that's what you meant by "mixes exceptions with regular results". Thanks</span>
