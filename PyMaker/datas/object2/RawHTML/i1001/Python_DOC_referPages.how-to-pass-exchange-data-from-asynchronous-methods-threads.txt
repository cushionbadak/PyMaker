<div class="post-text" itemprop="text">
<p>Could someone explain the concept behind how to pass data between asynchronous calls in python?</p>
<p>I have this scenario:<br/>
I have a main procedure (mainthread) and then I run another async call that adds two numbers() and sleeps for some time.  The expectation is to have main thread wait until calc and sleeping are done.  In terms of pseudo code this might look like this:</p>
<pre><code>def example():
    def my_calc(x,y):
        z = x+ y
        time.sleep(2)
        return z  #this should get pushed to queue, but for simplicity we use 'return z'

    z = asyncSomething.callInThread(my_calc, 2, 20)  #assume we get z from queue
    return z+10

def runner():  #our main function
    print 'start'
    z = example()
    print 'result is {0}'.format(z)
</code></pre>
<p>How do I made the last <code>print</code> wait for <code>z</code>?  I tried to use threading.Event() and played with <code>set</code>, <code>wait</code>, and <code>clear</code>, but they block everything.</p>
<p>I do not think my case is unique and there has to be a neat systematic way of doing it.  I looked into twisted reactor but it was partially successful.  My actual code involved GUI that has to wait for results from async processes and then self- and auto- update...but I think the example depicts the bulk of the problem</p>
<p>I think I am missing the actual concept of how to work asynchronously in python.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using multi-threading, you should use <a href="https://docs.python.org/3/library/concurrent.futures.html#future-objects" rel="nofollow noreferrer">futures</a> to encapsulate your results. Specifically, the <code>future.result(timeout=None)</code> would be used in your situation:</p>
<blockquote>
<p>Return the value returned by the call. If the call hasn’t yet completed then this method will wait up to timeout seconds. If the call hasn’t completed in timeout seconds, then a concurrent.futures.TimeoutError will be raised. timeout can be an int or float. If timeout is not specified or None, there is no limit to the wait time.</p>
</blockquote>
<p>As mentioned in the comments above, if you are not using multi-threading (and are using asynchronous programming), then callbacks would be the way to go.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your main thread has progressed as far as it meaningfully can without the result from the worker thread and you want to block, you can either use a <code>threading.Event</code> to wait for a certain point in the worker thread's execution or <code>thread.join</code> (where <code>thread</code> is a <code>threading.Thread</code> instance) to wait for the worker thread to complete:</p>
<pre><code>class Example(object):
    def my_calc(self, x, y):
        time.sleep(2)
        self._z = x + y # or push the result to a queue

    def example(self):
        thread = threading.Thread(target=self.my_calc, args=(2, 20))
        thread.start()
        # any other useful work could go here while the worker runs
        thread.join()
        return self._z + 10 # or grab the result from a queue

def runner():
    print "start"
    z = Example().example()
    print "result is {0}".format(z)
</code></pre>
<p>However, in the context of a GUI, it is unlikely that your main thread has progressed as far as it can -- it is probably constantly busy keeping the GUI responsive. In that case, as was mentioned in the comments on the question, it's better to just pack anything you want done after the worker's calculation is finished into a callback for the worker thread to call:</p>
<pre><code>def my_calc(x, y):
    time.sleep(2)
    return x + y

def my_calc_thread(x, y, callback):
    z = my_calc(x, y)
    # depending on your GUI framework, you may need to do something
    # like call_in_main_thread(callback, z) if callback touches GUI
    # elements
    callback(z)

def example():
    def finish(z):
        print "result is {0}".format(z)
    t = threading.Thread(target=my_calc_thread, args=(2, 20, finish))
    t.start()

def runner():
    print "start"
    example()
</code></pre>
</div>
<span class="comment-copy">Are you using Python 2? Looks like Python 3's async and await keywords can't help here ._.</span>
<span class="comment-copy">@Geetransit, it is 2.7.  I used 'async' figuratively not literally</span>
<span class="comment-copy">my MainThread hosts GUI ie GUI uses the main thread. I launch another frame (status frame) out MainThread, it is also in MainThread. in the python flavor that we have we can only launch GUI into MainThread. Then I use twisted reactor to get another thread going to do calcs and update status frame simultaneously. All works, except mainThread does not appear to wait for twisted thread (which makes total sense). when I stall mainThread (via .wait()) then entire execution stalls (both main and twisted threads) –</span>
