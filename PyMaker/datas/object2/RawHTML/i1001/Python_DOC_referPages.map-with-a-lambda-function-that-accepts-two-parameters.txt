<div class="post-text" itemprop="text">
<p>I would like to fetch i'th element from all the sub lists in a list of lists.I tried using map and lambda function as below</p>
<pre><code>extract = lambda x,i :x[i]
a = [[1,2,3],[4,5,6],[6,7,8]]
b = list(map(extract(i = 1),a))
</code></pre>
<p>I expect b to be [2,5,7]
but I know the last line doesn't work. How should I approach this with map and lambda</p>
</div>
<div class="post-text" itemprop="text">
<p>You <strong>do not</strong> need to hard code the index.                </p>
<p>IMHO, you should return a lambda function from <code>extract</code> method by doing something like this perhaps:                  </p>
<pre><code>def extract(i):
    return lambda x : x[i]

a = [[1,2,3],[4,5,6],[6,7,8]]

b = list(map(extract(1), a))

print(b)          
</code></pre>
<p>Output:      </p>
<pre><code>[2, 5, 7]      
</code></pre>
<p>Note: Better(read pythonic) approach will be to use list comprehension like this:        </p>
<pre><code>a = [[1,2,3],[4,5,6],[6,7,8]]

b = [li[1] for li in a]

print(b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can hard code in the <code>1</code>:</p>
<pre><code>extract = lambda x: x[1]
a = [[1,2,3],[4,5,6],[6,7,8]]
b = list(map(extract,a))

print(b)
# [2, 5, 7]
</code></pre>
<p>You normally don't want to store a <code>lambda</code> to a variable, this is better:</p>
<pre><code>def extract(x):
    return x[1]

b = list(map(extract, a))
</code></pre>
<p>Or simply this:</p>
<pre><code>b = list(map(lambda x: x[1], a))
</code></pre>
<p>You can also use a list comprehension, which I personally think is the best option:</p>
<pre><code>c = [x[1] for x in a]

print(b == c)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <em>underlying</em> problem is your first function argument needs to be specified when you call <code>extract</code>. This is possible via <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a>:</p>
<pre><code>from functools import partial
b = list(map(partial(extract, i=1), a))  # [2, 5, 7]
</code></pre>
<p>But this is relatively inefficient, since a new function is created for each iteration of <code>a</code>. Instead, as others have advised, use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a>:</p>
<pre><code>from operator import itemgetter
b = list(map(itemgetter(1), a))          # [2, 5, 7]
</code></pre>
<p>As an aside, <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP 8</a> advises against naming <code>lambda</code> functions; define explicitly instead:</p>
<pre><code>def extract(x, i):
    return x[i]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest using <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a> here to fetch the second item of each sublist:</p>
<pre><code>from operator import itemgetter

a = [[1,2,3],[4,5,6],[6,7,8]]

print(list(map(itemgetter(1), a)))
# [2, 5, 7]
</code></pre>
<p>Or using <code>lambda</code>:</p>
<pre><code>a = [[1,2,3],[4,5,6],[6,7,8]]

print(list(map(lambda x: x[1], a)))
# [2, 5, 7]
</code></pre>
<p>Your anonymous function:</p>
<pre><code>extract = lambda x,i :x[i]
</code></pre>
<p>Needs to instead map specifically an index:</p>
<pre><code>extract = lambda x: x[1]
</code></pre>
<p>Then you can simply map this function to your list with <code>map(extract(1), a)</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>I also vote for the 'for' solution. 
Functional programming syntax looks beautiful but its too much overhead sometimes.</p>
<pre><code>a = [[1,2,3],[4,5,6],[6,7,8]]
b = list(map(lambda x: x[1], a)) #  Brr, how many types conversions involved
c = [x[1] for x in a] # Looks more lightweight
</code></pre>
<p>Lets just check:</p>
<pre><code>import timeit
timeit.timeit('a = [[1,2,3],[4,5,6],[6,7,8]]; b = [x[1] for x in a]', number=10000)
&gt; 0.01244497299194336
timeit.timeit('a = [[1,2,3],[4,5,6],[6,7,8]]; b = list(map(lambda x: x[1], a))', number=10000)
&gt; 0.021031856536865234
</code></pre>
<p>2 times slower.</p>
</div>
<span class="comment-copy">Note that naming a <code>lambda</code> is considered bad form - if it isn't anonymous, use a proper <code>def</code>.</span>
<span class="comment-copy">As per <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP8</a>: "Always use a def statement instead of an assignment statement that binds a lambda expression directly to an identifier."</span>
<span class="comment-copy">@jonrsharpe I realize that, but I was trying to keep as much code from the original question as possible. I'll edit.</span>
<span class="comment-copy">Sorry, hadn't spotted it was in the question too; I've moved the comment.</span>
