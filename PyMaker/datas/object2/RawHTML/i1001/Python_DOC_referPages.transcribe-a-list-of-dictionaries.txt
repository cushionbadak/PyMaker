<div class="post-text" itemprop="text">
<p>I have this kind of list of dictionary in python</p>
<pre><code>[
  {
    "compania": "Fiat",
    "modelo": "2014",    
    "precio": "1000"
  },
  {
    "compania": "Renault",
    "modelo": "2014",    
    "precio": "2000"
  },
  {
    "compania": "Volkwagen",
    "modelo": "2014",    
    "precio": "3000"
  },
  {
    "compania": "Chevrolet",
     "modelo": "2014",    
     "precio": "1000"    
  },
  {
    "compania": "Peugeot",
    "modelo": "2014",    
    "precio": "2000"
  } 
]  
</code></pre>
<p>That I'd like to transform into this kind of list of list of dictionary</p>
<pre><code>{   
  "Fiat": {
    "modelo": "2014",    
    "precio": "1000"
  },
  "Renault": {
    "modelo": "2014",    
    "precio": "2000"
  },
  "Volkwagen": {
    "modelo": "2014",    
    "precio": "3000"
  },
  "Chevrolet": {
    "modelo": "2014",    
    "precio": "1000"
  },
  "Peugeot": {
    "modelo": "2014",    
    "precio": "2000"
  }  
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can use dict comprehension</p>
<pre><code>{a.get('compania'): {k: v for k, v in a.items() if k != 'compania'} for a in c}

{'Fiat': {'modelo': '2014', 'precio': '1000'},
 'Renault': {'modelo': '2014', 'precio': '2000'},
 'Volkwagen': {'modelo': '2014', 'precio': '3000'},
 'Chevrolet': {'modelo': '2014', 'precio': '1000'},
 'Peugeot': {'modelo': '2014', 'precio': '2000'}}
</code></pre>
<p>where <code>c</code> is your original data</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a dictionary by iterating over the elements of your original list. Assuming your list is called <code>car_list</code>:</p>
<pre><code>d = { x["compania"]: {"modelo": x["modelo"], "precio": x["precio"] } for x in car_list }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming your list is called <code>l</code>, you could accomplish this using simple iteration and building a new dictionary <code>d</code>:</p>
<pre><code>d = {}

for sub in l:
  d[sub.pop('compania')] = sub
</code></pre>
<p>This produces in the dictionary <code>d</code>:</p>
<pre><code>{'Chevrolet': {'modelo': '2014', 'precio': '1000'},
 'Fiat': {'modelo': '2014', 'precio': '1000'},
 'Peugeot': {'modelo': '2014', 'precio': '2000'},
 'Renault': {'modelo': '2014', 'precio': '2000'},
 'Volkwagen': {'modelo': '2014', 'precio': '3000'}}
</code></pre>
<p>Explanation: For each dictionary in that list (<code>sub</code>): <code>sub.pop('compania')</code> deletes the entry of the key 'compania' in <code>sub</code> and returns it's associated value. We are then updating the dictionary <code>d</code> to have a key of what was just returned and we are associating with that key, the remainder of <code>sub</code> after the deletion of that entry.</p>
</div>
<div class="post-text" itemprop="text">
<p>with a mapper function to return a new customized list of dicts</p>
<pre><code>a=[
  {
    "compania": "Fiat",
    "modelo": "2014",    
    "precio": "1000"
  },
  {
    "compania": "Renault",
    "modelo": "2014",    
    "precio": "2000"
  },
  {
    "compania": "Volkwagen",
    "modelo": "2014",    
    "precio": "3000"
  },
  {
    "compania": "Chevrolet",
     "modelo": "2014",    
     "precio": "1000"    
  },
  {
    "compania": "Peugeot",
    "modelo": "2014",    
    "precio": "2000"
  } 
]  

def mapper(temp): # define a mapper
    new_temp={}
    new_temp[temp['compania']]={k:v for k,v in temp.items() if k!='compania'}
    return new_temp

map(mapper,a) # call map function with mapper and list as argument
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>result = {}
for d in l:
    # Store the value of the key 'compania' before popping it from the small dictionary d
    compania = d['compania']
    d.pop('compania')
    # Construct new dictionary with key of the compania and value of the small dictionary without the compania key/value pair
    result[compania] = d
print(result)
</code></pre>
<p>Output:</p>
<pre><code>{'Chevrolet': {'modelo': '2014', 'precio': '1000'},
 'Fiat': {'modelo': '2014', 'precio': '1000'},
 'Peugeot': {'modelo': '2014', 'precio': '2000'},
 'Renault': {'modelo': '2014', 'precio': '2000'},
 'Volkwagen': {'modelo': '2014', 'precio': '3000'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would share simple solution:</p>
<pre><code>&gt;&gt;&gt; {d.pop("compania"):d for d in dd}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use dictionary <a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow noreferrer">update</a> which can then produce a new dictionary of your preference. </p>
<pre><code>from pprint import PrettyPrinter as pp
d={}
for i in l: # 'l' represents your list of dictionary 
    d.update({i['compania']:{"modelo":i['modelo'],"precio":i['precio']}})
print(pp(indent=4).pprint(d))
</code></pre>
<blockquote>
<p>ouput:</p>
</blockquote>
<pre><code>{   'Chevrolet': {'modelo': '2014', 'precio': '1000'},
'Fiat': {'modelo': '2014', 'precio': '1000'},
'Peugeot': {'modelo': '2014', 'precio': '2000'},
'Renault': {'modelo': '2014', 'precio': '2000'},
'Volkwagen': {'modelo': '2014', 'precio': '3000'}}
</code></pre>
</div>
<span class="comment-copy">What have you tried, and what exactly is the problem with it? Also note that your output is a dictionary mapping strings to dictionaries, not a list of list of dictionaries.</span>
<span class="comment-copy">So what have you tried? This seems fairly easy, just taking out the <code>d['compania']</code>  from each element of the list and creating a dictionary with it and with rest of the key value pairs being its contents.</span>
<span class="comment-copy">Yes, I am very noob  with these issues. Thanks</span>
<span class="comment-copy">Thanks, I work, some book or paper that deals with these issues, I am very new.</span>
<span class="comment-copy">Why would you use a destructive operations like <code>.pop</code> here? Is there any advantage? In general, unless you are trying to remove things, I would err on the side of <i>not</i> removing things.</span>
<span class="comment-copy">@juanpa.arrivillaga simply because <code>pop</code> succinctly returns the key we want for the new dictionary, and after it is carried out, leaves behind what the value associated to that key should be. I do see where you are coming from though :)</span>
<span class="comment-copy">don't use <code>.pop</code> in a comprehension construct, it has a side effect, and you should avoid side-effects in functional constructs.</span>
<span class="comment-copy">Precisely because the solution uses a side effect it is short in this particular case.</span>
