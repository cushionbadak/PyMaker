<div class="post-text" itemprop="text">
<p>I wrote a python program to print the ascii value of up to every 3 numbers in a string or <code>"ERROR"</code> if the length is not divisible by three. I was golf the code when I ran into a <code>SyntaxError</code>. </p>
<p>Code:</p>
<pre><code>c=input()
p=len(c)
c=[int(c[i:i+3])for i in range(0,len(c),3)]
print("ERROR"if p%3else*map(chr,c),sep='')#SyntaxError here
</code></pre>
<p>But this works:</p>
<pre><code>c=input()
p=len(c)
c=[int(c[i:i+3])for i in range(0,len(c),3)]
print(*map(chr,c),sep='')
</code></pre>
<p>Putting a space before the <code>*</code> or after the <code>3</code> doesn't work. I could just use <code>''.join</code> but it's one character longer. My question is why can't I use a starred expression in a ternary operator?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because the <code>*</code> has to apply to the whole expression that produces the set of arguments, not a part of it, and not conditionally. Internally, CPython uses different bytecodes for calling with unpacking vs. normal calls, so your conditional would require it to change the byte code to call <code>print</code> based on the arguments to <code>print</code>, essentially rewriting what you wrote into pseudocode like:</p>
<pre><code>if p % 3:
    call(print, "ERROR", sep='')
else:
    call_varargs(print, *map(chr, c), sep='')
</code></pre>
<p>which is beyond the compiler's capability.</p>
<p>If you wanted to make this work, you could do the following:</p>
<pre><code>print(*(("ERROR",) if p%3 else map(chr,c)), sep='')
</code></pre>
<p>which ensures the whole ternary evaluates to an unpackable sequence and unpacks whatever survives unconditionally, avoiding the confusion.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>print(*(["ERROR"] if p%3 else map(chr,c)),sep="!")
</code></pre>
<p>keep it outside of the ternary</p>
</div>
<span class="comment-copy">Because <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow noreferrer">the grammar</a> says so. Just move it: <code>print(*(("ERROR",) if p % 3 else ... ))</code>.</span>
<span class="comment-copy">You can not use the argument expansion in every expression, only if you are expanding arguments. And BTW Python developers love spaces, you should use them wherever they are useful.</span>
<span class="comment-copy">@KlausD.: Well, thanks to <a href="https://www.python.org/dev/peps/pep-0448/" rel="nofollow noreferrer">PEP448</a>, you can use unpacking for expanding initializers in container literals too, e.g. <code>newset = {*set1, *set2}</code>, but yes, it's still limited to a single fixed choice of <code>*</code> or not-<code>*</code> for each comma separated component; you can't conditionally choose <code>*</code> vs. not-<code>*</code> for a given component.</span>
<span class="comment-copy">No need to bracket as the sep is '' :)</span>
