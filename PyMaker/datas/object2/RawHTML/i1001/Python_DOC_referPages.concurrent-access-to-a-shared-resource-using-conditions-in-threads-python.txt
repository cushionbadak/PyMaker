<div class="post-text" itemprop="text">
<p>I have the below sample  pretty basic code for working with conditions in Python:</p>
<pre><code>import threading
import random
import time

class Producer(threading.Thread):
    """
    Produces random integers to a list
    """

    def __init__(self, integers, condition):
        """
        Constructor.

        @param integers list of integers
        @param condition condition synchronization object
        """
        threading.Thread.__init__(self)
        self.integers = integers
        self.condition = condition

    def run(self):
        """
        Thread run method. Append random integers to the integers list
        at random time.
        """
        while True:
            integer = random.randint(0, 256)
            self.condition.acquire()
            print 'condition acquired by %s' % self.name
            self.integers.append(integer) 
            print '%d appended to list by %s' % (integer, self.name)
            print 'condition notified by %s' % self.name
            self.condition.notify()
            print 'condition released by %s' % self.name
            self.condition.release()
            time.sleep(1)

class Consumer(threading.Thread):
    """
    Consumes random integers from a list
    """

    def __init__(self, integers, condition):
        """
        Constructor.

        @param integers list of integers
        @param condition condition synchronization object
        """
        threading.Thread.__init__(self)
        self.integers = integers
        self.condition = condition

    def run(self):
        """
        Thread run method. Consumes integers from list
        """
        while True:
            self.condition.acquire()
            print 'condition acquired by %s' % self.name
            while True:
                if self.integers:
                    integer = self.integers.pop()
                    print '%d popped from list by %s' % (integer, self.name)
                    break
                print 'condition wait by %s' % self.name
                self.condition.wait()
            print 'condition released by %s' % self.name
            self.condition.release()

def main():
    integers = []
    condition = threading.Condition()
    t1 = Producer(integers, condition)
    t2 = Consumer(integers, condition)
    t1.start()
    t2.start()
    t1.join()
    t2.join()

if __name__ == '__main__':
    main()
</code></pre>
<p>As per my understanding when the consumer calls the <code>wait()</code> method it would release the condition and go into sleep.</p>
<p>When the producer notifies the threads after it calls <code>notify()</code> it seems that neither of the consumers are reacquiring the condition before they try to pop from the integer list. </p>
<p>Is this not a race condition ?</p>
</div>
<div class="post-text" itemprop="text">
<p>The consumers do not need to reacquire the condition after being woken up from <code>wait()</code> because they do not release it until after resuming from <code>wait()</code>.<br/>
What they release is a lock that is always associated with the condition, either explicitly or implicitly.<br/>
From the <a href="https://docs.python.org/3/library/threading.html#condition-objects" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>A condition variable is always associated with some kind of lock; this can be passed in or one will be created by default. <em>[...]</em> The lock is part of the condition object: you donâ€™t have to track it separately.</p>
</blockquote>
<p>The lock is acquired and released implictly by acquiring / releasing the condition, as well as when calling <a href="https://docs.python.org/3/library/threading.html#threading.Condition.wait" rel="nofollow noreferrer"><code>wait()</code></a> resp. waking up from it.</p>
<blockquote>
<p>The acquire() and release() methods also call the corresponding methods of the associated lock.
  <br/><em>[..]</em> <br/>The wait() method releases the lock, and then blocks until another thread awakens it by calling notify() or notify_all(). Once awakened, wait() re-acquires the lock and returns.</p>
</blockquote>
<p>So there is always a maximum of one thread that can hold the lock, and thus modify the shared resource safely at any given point in time.</p>
</div>
<span class="comment-copy">So just a small doubt. What the notifyall method would do is wake up all the threads which are waiting for that condition. Once all of them wakes up then what happens. How to decide which one starts execution first.</span>
<span class="comment-copy">@user1867151 The thread that first gets a hold of the lock will resume execution. All other threads remain in <code>wait()</code>. It's stated as a note in the docs for <a href="https://docs.python.org/3/library/threading.html#threading.Condition.notify" rel="nofollow noreferrer"><code>notfy</code></a>. <code>Note: an awakened thread does not actually return from its wait() call until it can reacquire the lock.</code></span>
<span class="comment-copy">Thanks a lot ! This makes much sense now.</span>
