<div class="post-text" itemprop="text">
<p>I am writing a Flask API that calls docker containers which execute Selenium web scraping scripts. I have tested this in dev and it works fine (python3 -m run flask  host=0.0.0.0) and I have made sure that the user (ubuntu) is in the docker group and the group has been reset (newgrp docker) however its still gets a permission error when attempting to run. I have checked the PID and the user is ubuntu for the gunicorn process, the image is available in docker, what else might be needed to provide permission? My flask code is below</p>
<pre><code>import docker
import os
from flask import Flask, render_template

app = Flask(__name__)


@app.route('/civitek/&lt;f_name&gt;/&lt;l_name&gt;/&lt;ref_url&gt;')
def civitek(f_name, l_name, ref_url):
    client = docker.from_env()
    container = client.containers.create('qxf2rohand/qxf2_pom_essentials',command="/bin/bash", environment=["F_NAME={}".format(f_name), "L_NAME={}".format(l_name),"REF_URL={}".format(ref_url)], volumes={os.path.join(os.getcwd(),'florida'):{'bind':'/florida','mode':'rw'}}, stdin_open=True, auto_remove=False)
    container.start()
    container.exec_run('pip install pytz selenium pillow captcha2upload pyvirtualdisplay requests')
    container.exec_run('python florida/civitek_scraper.py')
    civi = open(str(os.path.join(os.getcwd(),'florida/output/output.html')))
    output = civi.read()
    container.stop()
    container.remove()
    return output

@app.route('/indiana/&lt;ref_url&gt;')
def indiana(ref_url):
    client = docker.from_env()
    container = client.containers.create('qxf2rohand/qxf2_pom_essentials',command="/bin/bash", environment=["REF_URL={}".format(ref_url)], volumes={os.path.join(os.getcwd(),'indiana'):{'bind':'/indiana','mode':'rw'}}, stdin_open=True, auto_remove=False)
    container.start()
    container.exec_run('pip install pytz selenium bs4 pyvirtualdisplay requests')
    container.exec_run('python indiana/in_scraper.py')
    indy = open(str(os.path.join(os.getcwd(),'indiana/output/output.html')))
    output = indy.read()
    container.stop()
    container.remove()
    return render_template('in_master_template.html', results=output)

if __name__ == '__main__':
    app.run()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The code you show should be extremely straightforward to set up without using Docker, since you're running Python code from a Python script.  You should add the long list of pip packages you're installing to your own application's <code>setup.py</code> or <code>requirements.txt</code> file, and then use the ordinary <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer"><code>subprocess</code></a> module to launch the scripts:</p>
<pre class="lang-py prettyprint-override"><code>@app.route('/civitek/&lt;f_name&gt;/&lt;l_name&gt;/&lt;ref_url&gt;')
def civitek(f_name, l_name, ref_url):
  p = subprocess.run([sys.executable, './florida/civitek_scraper.py'],
                     env={'F_NAME': f_name, 'L_NAME': l_name, 'REF_URL': ref_url})
  with open('florida/output/output.html') as f:
    return f.read()
</code></pre>
<p>(Using <code>sys.executable</code> here will use the same Python in your active virtual environment; it may not necessarily be the first Python in <code>$PATH</code>.)</p>
<p>Adding Docker to this adds a huge amount of complexity and security considerations: if you get this wrong, you're opening up the possibility of a very straightforward remote root exploit.</p>
<p>If you're getting permission errors than your user or group doesn't have permission to access the Docker socket file.  Check the output of <code>id</code> and <code>ls -l /var/run/docker.sock</code>.</p>
<p>Both the use of <code>exec</code> you show and installing new software in a container after startup are anti-patterns.  (Should your HTTP request just fail if packages.python.org has a temporary outage?)  Write a custom Docker image that includes all of the dependencies for your script, and run that script as the main container process, if you need to run this in a container at all.</p>
</div>
<span class="comment-copy">Thank you David, I attempted to conform it to your method (which does make more sense) but now the returned html is all scrambled, which is unfortunate i will have to try and determine why. The docker method still works, but the only server i have functional is the dev server. I am not too worried about security as requests will only be made from a range of ip's within my org. due to the nature of my work speed is required so i am using an external docker image for the moment and will build my own later. I will try to rebuild the prod server and explore the user issues, ill get back to you</span>
<span class="comment-copy">I was able to get the docker method to function by manually chmod rw=a for docker.sock. I will be changing this API for the security considerations mentioned by David and for a more streamlined code.</span>
