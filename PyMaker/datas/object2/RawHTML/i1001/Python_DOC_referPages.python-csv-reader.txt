<div class="post-text" itemprop="text">
<p>I have a CSV from a system that has a load of rubbish at the top of the file, so the header row is about row 5 or could even be 14 depending on the gibberish the report puts out. </p>
<p>I used to use: </p>
<pre><code>idx = next(idx for idx, row in enumerate(csvreader) if len(row) &gt; 2)
</code></pre>
<p>to go through the rows that had less than 2 columns, then when it hit the col headers, of which there are 12, it would stop, and then I could use idx with skiprows when reading the CSV file.</p>
<p>The system has had an update and someone thought it would be good to have the CSV file valid by adding in 11 blank commas after their gibberish to align the header count.</p>
<p>so now I have a CSV like:</p>
<pre><code>sadjfhasdkljfhasd,,,,,,,,,,
dsfasdgasfg,,,,,,,,,,
time,date,code,product 
</code></pre>
<p>etc.. </p>
<p>I tried: </p>
<pre><code>idx = next(idx for idx, row in enumerate(csvreader) if row in (None, "") &gt; 2)
</code></pre>
<p>but I think that's a Pandas thing and it just fails. </p>
<p>Any ideas on how i can get to my header row?</p>
<p>CODE: </p>
<pre><code>lmf = askopenfilename(filetypes=(("CSV Files",".csv"),("All Files","*.*")))
    # Section gets row number where headers start
    with open(lmf, 'r') as fin:
        csvreader = csv.reader(fin)
        print(csvreader)
        input('hold')
        idx = next(idx for idx, row in enumerate(csvreader) if len(row) &gt; 2)

    # Reopens file parsing the number for the row headers
    lmkcsv = pd.read_csv(lmf, skiprows=idx)
    lm = lm.append(lmkcsv)
    print(lm)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since your <code>csv</code> is now a valid file and you just want to filter out the header rows without a certain amount of columns, you can just do that in <code>pandas</code> directly.</p>
<pre><code>import pandas as pd
minimum_cols_required = 3
lmkcsv = pd.read_csv()
lmkcsv = lmkcsv.dropna(thresh=minimum_cols_required, inplace=True)
</code></pre>
<p>If your <code>csv</code> data have a lot of empty values as well that gets caught in this threshold, then just slightly modify your code:</p>
<pre><code>idx = next(idx for idx, row in enumerate(csvreader) if len(set(row)) &gt; 3)
</code></pre>
<p>I'm not sure in what case a <code>None</code> would return, so the <code>set(row)</code> should do.  If your headers for whatever are duplicates as well, do this:</p>
<pre><code>from collections import Counter
# ...
idx = next(idx for idx, row in enumerate(csvreader) if len(row) - Counter(row)[''] &gt; 2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>And how about erasing the starting lines, doing some logic, like checking many ',' exist's or some word. Something like:</p>
<pre><code>f = open("target.txt","r+")
d = f.readlines()
f.seek(0)
for i in d:
    if "sadjfhasdkljfhasd" not in i:
        f.write(i)
f.truncate()

f.close()
</code></pre>
<p>after that, read normaly the file.</p>
</div>
<span class="comment-copy">How do <i>you</i> determine the header row? First one where all values are non-empty? The one that starts with "time"?</span>
<span class="comment-copy">What is this supposed to do? <code>if row in (None, "") &gt; 2</code>? Is this the "pandas thing"? <a href="https://docs.python.org/3/reference/expressions.html#comparisons" rel="nofollow noreferrer">This is actually a chained comparison</a>, which will get interpreted as <code>row in (None, "") and (None, "") &gt; 2</code>, which will <i>always</i> be false.</span>
<span class="comment-copy">Thank you, I used the "Set()" just in case, as i don't know what the dataset could look like on a regular basis.</span>
<span class="comment-copy">So if there are N unrelated lines OP will have to do N comparison? What if the "values" in the lines are different each time? How would you catch that?</span>
