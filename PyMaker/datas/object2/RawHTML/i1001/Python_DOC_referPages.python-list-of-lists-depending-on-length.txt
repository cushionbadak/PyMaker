<div class="post-text" itemprop="text">
<p>I have the lists below and I need to assign the strings from fruit list into stall list depending on their length. </p>
<pre><code>fruit = ['an', 'king', 'be', 'brave']
stall = [[],[],[],[]]
</code></pre>
<p>So the result should be like this</p>
<pre><code>stall = [[ ],['an', 'be'],[ ],['king', 'brave']] 
</code></pre>
<p>Iâ€™ve tried so many ways and even attempted to create a new list to see where I am going wrong but not even this is populating anything. Can someone please point me where I am going wrong? I've never had to append to list of lists before.</p>
<pre><code>i = 0
s = stall[i]
for j in fruit:
    if(len(j)) == i+1:
        s.append(j)
        i += 1
print(stall)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you want as many inner lists as you need to put in all words correctly:</p>
<pre><code>fruit = ['an', 'king', 'be', 'brave']

stall = [
    [element for element in fruit if len(element) == i+1]
    for i in range(len(fruit) + 1)
]
</code></pre>
<p><code>stall</code> will now be <code>[[], ['an', 'be'], [], ['king'], ['brave']]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure if classifying <em>king</em> and <em>brave</em> together, as your question does, was deliberate or not. I'm assuming deliberate.</p>
<pre><code>fruit = ['an', 'king', 'be', 'brave']
stall = [[],[],[],[]]
for f in fruit:
        stall[min(len(f),4)-1].append(f)
</code></pre>
<p>This will give you</p>
<pre><code>&gt;&gt;&gt; stall
[[], ['an', 'be'], [], ['king', 'brave']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple <em>O(n)</em> approach:</p>
<pre><code>fruit = ['an', 'king', 'be', 'brave']

lookup = {}
for word in fruit:
    lookup.setdefault(len(word), []).append(word)

stall = [lookup.get(i, []) for i in range(1, max(lookup) + 1)]

print(stall)
</code></pre>
<p>An alternative using using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a>:</p>
<pre><code>from collections import defaultdict

fruit = ['an', 'king', 'be', 'brave']

lookup = defaultdict(list)
for word in fruit:
    lookup[len(word)].append(word)

stall = [lookup.get(i, []) for i in range(1, max(lookup) + 1)]

print(stall)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[[], ['an', 'be'], [], ['king'], ['brave']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way could be following. First you get the size of the empty list <code>stall</code> from the dimensions of the largest string in your <code>fruit</code>. Then you simply append the fruits to the corresponding position in your nested lists.</p>
<p>The <code>len(f)-1</code> is used because the indexing in python starts from 0. </p>
<pre><code>fruit = ['an', 'king', 'be', 'brave']
stall = [[] for _ in range(len(max(fruit, key=len)))]

for f in fruit:
    stall[len(f)-1].append(f)

print (stall)
# [[], ['an', 'be'], [], ['king'], ['brave']]
</code></pre>
</div>
<span class="comment-copy">Why are <code>king</code> and <code>brave</code> in the same list in your expected output? <code>brave</code> has 5 characters.</span>
<span class="comment-copy">I just guess something like <code>itertools.groupby(iterable, key=len)</code> will be solution but it will return dict instead of list</span>
<span class="comment-copy">clear and correct, I like it ;P</span>
<span class="comment-copy">This is very slow for long lists</span>
<span class="comment-copy">@DanielMesejo It's easy optimize such constructs: <code>itertools</code> and friends</span>
<span class="comment-copy">@Ingaz No, this approach is quadratic.</span>
<span class="comment-copy">I wrote it like: <code>[[el for el in fruit if len(el)==cur_len] for cur_len in range(max(map(len, fruit)))]</code>. Optimization is not a concern in OP question. BUT: if needed one just substitute list of lists into generator of generators. A little more complicated but .. just a little</span>
