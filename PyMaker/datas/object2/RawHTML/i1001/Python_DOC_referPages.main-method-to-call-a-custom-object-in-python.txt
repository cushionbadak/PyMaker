<div class="post-text" itemprop="text">
<p>I was trying to fix something related to what an object returns when you use an object as an argument.</p>
<p>For example, I have a custom object and I want to use it as a parent for another tkinter widget, so I need to return a tkinter object to place the new tkinter object into my custom object, but my custom object returns that is an object of a custom class.</p>
<p>I can explain this much better on code:</p>
<pre><code>class CustomFrame(object):
    def __init__(self,**args):
        #code that works

        #The next is an external object that have a variable that I need to call externally.
        #The variable is "interior"
        self.externalobject = anotherobject('random')

cfr1 = CustomFrame()

label1 = Label(cfr1)
</code></pre>
<p>Now I want to use the "self.externalobject.interior" as the parent for label1
But I want to make it friendly just calling "cfr1" instead of "self.externalobject.interior"</p>
<p>I know that if I use the <strong>call</strong> method and I return the value that I need it will work if I pass "cfr1" as a function, but I want to make it the more Pythonic as possible.</p>
<p>So I need to know if there's another special method or something to modify what it returns.</p>
<p>EDIT:
So, this is part of the code I am using:</p>
<p>This is the code of the vertical scrolled frame (not my code).</p>
<pre><code>class VerticalScrolledFrame(Frame):
    """A pure Tkinter scrollable frame that actually works!
    * Use the 'interior' attribute to place widgets inside the scrollable frame
    * Construct and pack/place/grid normally
    * This frame only allows vertical scrolling

    """
    def __init__(self, parent, bg, *args, **kw):
        Frame.__init__(self, parent, *args, **kw)            

        # create a canvas object and a vertical scrollbar for scrolling it
        vscrollbar = Scrollbar(self, orient=VERTICAL)
        canvas = Canvas(self, bd=0, highlightthickness=0,
                        yscrollcommand=vscrollbar.set,bg=bg)
        vscrollbar.config(command=canvas.yview)
        canvas.pack(side=LEFT, fill=BOTH, expand=TRUE)

        # reset the view
        canvas.xview_moveto(0)
        canvas.yview_moveto(0)

        # create a frame inside the canvas which will be scrolled with it
        self.interior = interior = Frame(canvas,bg=bg)
        interior_id = canvas.create_window(0, 0, window=interior,
                                           anchor=NW)

        a = Frame(self.interior,height=10,bg=dynamicBackground())
        a.pack()

        def canvasscroll(event):
            canvas.yview('scroll',int(-1*(event.delta/120)), "units")

        def _configure_canvas(event):
            a.configure(height=10)
            a.update()
            mylist = interior.winfo_children()
            for i in mylist:
                lasty=i.winfo_height()+i.winfo_y()
            a.configure(height=lasty)
            if interior.winfo_reqwidth() != canvas.winfo_width():
                # update the inner frame's width to fill the canvas
                canvas.itemconfigure(interior_id, width=canvas.winfo_width())
            if canvas.winfo_height()&lt;lasty:
                vscrollbar.pack(fill=Y, side=RIGHT, expand=FALSE)
                canvas.config(scrollregion=(0,0,0,lasty))
                canvas.bind_all("&lt;MouseWheel&gt;", canvasscroll)
            else:
                canvas.unbind_all("&lt;MouseWheel&gt;")
                try:
                    vscrollbar.pack_forget()
                except:
                    pass
                canvas.config(scrollregion=(0,0,0,0))


        canvas.bind('&lt;Configure&gt;', _configure_canvas)
</code></pre>
<p>And this is the code for my custom object:</p>
<pre><code>class UtilityPanel(object):
    def __init__(self,parent='*',title='Main Title',state='normal',bg='red'):
        super().__init__()
        if parent != '*':
            self.parent=parent
        else:
            raise TypeError('You must specify a parent for this widget.')
        self.title=title

        global subpanels

        if len(subpanels) == 0:
            self.panelid = 'sp-1'
            subpanels.append('sp-1')
        else:
            self.panelid = 'sp-'+str(int(subpanels[-1].split('-')[1])+1)
            subpanels.append(self.panelid)

        self.panel = VerticalScrolledFrame(self.parent,bg=bg,width=600,height=200,name=self.panelid)

    def __call__(self,name):
        return(self.panel.interior)

    def pack(self):
        self.panel.place(x=300)
        global activepanel
        activepanel = self.panelid
</code></pre>
<p>So, if i pass the argument like <code>label1 = Label(cfr1.panel.interior)</code> it works, but I want it to make it work just passing cfr1 as an argument.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think I understand the issue the OP is having here. They are unable to use the frame as the container for their label and that is because they are missing <code>super()</code> and need to inherit from Frame.</p>
<p>Change this:</p>
<pre><code>class CustomFrame(object):
    def __init__(self,**args):
</code></pre>
<p>To this:</p>
<pre><code>class CustomFrame(Frame):
    def __init__(self,**args):
        super().__init__()
</code></pre>
<p>And you should be able to use the customer frame as the container for your label.</p>
<p>Based on your comments below try this:</p>
<pre><code>class CustomFrame(anotherobject):
    def __init__(self,**args):
        super().__init__()
</code></pre>
<p>This should inherit all methods and attributes of that object.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to implicitly cast/coerce one type of object to another.</p>
<p>If you want to be "pythonic", recall, </p>
<pre><code>&gt;&gt;&gt; import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
...
</code></pre>
<p>Implicitly doing things can cause trouble.</p>
<p>I see nothing wrong with using the <code>call</code> magic function to get the attribute you want, or start looking at properties and decorators.</p>
<p>There's a full list of magic methods <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You <em>could</em> probably achieve what you want if you created your own custom subclass of <code>tk.Label</code> that basically does the unpacking for you.</p>
<p><em>(Disclaimer: I have never used tkinter, so I cannot tell if this actually works in the context of that framework. This example is merely to demonstrate the concept I am trying to outline here.)</em></p>
<pre><code>class CustomLabel(tk.Label):

    def __init__(self, master, **options):
        if isinstance(master, CustomFrame):
            master = master.externalobject.interior
        super().__init__(master=master, **options)
</code></pre>
<p>With that you should be able to use <code>CustomLabel(cfr1)</code>.</p>
<p>However, I strongly support the message that @doctorlove conveys in their answer. IMHO, the most pythonic way would indeed be <code>Label(cfr1.externalobject.interior)</code>, your suggested approach using <code>__call__</code> or a property inside <code>CustomFrame</code> that provides a shortcut to <code>externalobject.interior</code>:</p>
<pre><code>@property
def interior(self):
    return self.externalobject.interior
</code></pre>
<p>which you would use like so <code>Label(crf1.interior)</code></p>
</div>
<span class="comment-copy">I think there's a good question in here, but it's hard to read, partly because you've put some of it as comments in the code. (I didn't downvote BTW).</span>
<span class="comment-copy">The only thing that can be the parent of a Tkinter widget is another Tkinter widget.  For your custom object to fulfill that role, it needs to derive from a Tkinter class - I suppose <code>Frame</code> in your case.</span>
<span class="comment-copy">Ahhhh ok. Can you tell me what <code>interior</code> is exactly. Is it another container or just some variable holding a value?</span>
<span class="comment-copy">I see you are using the code from <a href="https://stackoverflow.com/questions/16188420/python-tkinter-scrollbar-for-frame">this post</a>. I am not sure if there is a way to link to the <code>interior</code> frame without doing <code>cfr1.externalobject.interior</code>. If there is all the testing I have done has failed and I am just unaware of the correct method to do this. Good luck. I hope someone knows the solution if there is one. I am curious myself to see if there is a way to do this.</span>
<span class="comment-copy">If you want to use this custom object as a parent to another widget, why aren't you inheriting from a widget such as Frame? That makes this problem trivial. Anything else will result in confusing code that others will find hard to understand.</span>
<span class="comment-copy">Ok, I think I haven't explained correctly, but this is close to what I want. I explain  a little more, I have an external custom object that is a scrollable frame for tkinter, and I have created a new object to give it new properties and  act as a new object. This custom scrollable frame have the attribute interior, which is what I need to pass to a widget as a parent to fit in it. But I need to do make it like any widget in tkinter</span>
<span class="comment-copy">So, I need to, return this interior attribute of the scrollable frame, that is inside my new custom object, just passing the name of the custom object... Sorry, if I still don't explaining well, but it's difficult to me due to the language.</span>
<span class="comment-copy">Then instead of inheriting from <code>Frame</code> you can inherit from your customer object. That should work here.</span>
<span class="comment-copy">It is a little unclear what you want. It almost sounds like you want to be able to use <code>CustomFrame()</code> as a way to pass another object as the container. So say <code>CustomFrame</code> inherits from <code>OtherObject</code> and you want to do <code>Label(CustomeFrame)</code> resulting in basically <code>Label(OtherObject)</code>. Is that correct?</span>
<span class="comment-copy">I know what you're saying, but doesn't work because I define the scrollable frame into the custom object, so I can't inherit the property from an object that is created inside.</span>
