<div class="post-text" itemprop="text">
<p>I know that in Python I can easly create a list containing all permutations of a given string, using the <code>permutations()</code> function. Now imagine if I wanted to generate only the permutations of the string <code>"3212323"</code> that do not contain the string<code>"33"</code>. How can I achieve this result ?</p>
<p>Example:</p>
<ul>
<li>"3231322"</li>
<li>"3332122"  &lt;-- I don't want you</li>
<li>"3213223"</li>
<li>"3223213"</li>
<li>"2223313"  &lt;-- I don't want you</li>
<li>"2322313"</li>
<li>"2312332"  &lt;-- I don't want you</li>
<li>ecc...</li>
</ul>
<p><strong>Note</strong>: I know that I could generate all the permutations first, and then remove the specified ones from the list, but what I need is to not generate these permutations at all, so discard them while creating the permutations list.</p>
<p>Any suggestion will be appreciated. Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Solution with custom filter</p>
<pre><code>from itertools import permutations
a="3212323"
def my_filter(temp):
    if '33' not in ''.join(temp):
        return temp
filter(my_filter,(permutations(a)))
</code></pre>
<p>It's python so you can see the source code and modify it</p>
<pre><code>def permutations1(iterable, r=None):
    # permutations('ABCD', 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) --&gt; 012 021 102 120 201 210
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    if r &gt; n:
        return
    indices = range(n)
    cycles = range(n, n-r, -1)
    yield tuple(pool[i] for i in indices[:r]) 
    while n:
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices[i:] = indices[i+1:] + indices[i:i+1]
                cycles[i] = n - i
            else:
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                temp=tuple(pool[i] for i in indices[:r])
                if '33' not in ''.join(temp):
                    yield temp
                break
        else:
            return

list((permutations1(a)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use generators:</p>
<pre><code>original = "3212323"
excluded_substring = '33'
p = (''.join(x) for x in permutations(original))
p = (x for x in p if excluded_substring not in x)

# Or as a one-liner
p = (x for x in (''.join(parts) for parts in permutations(original)) if excluded_substring not in x)
</code></pre>
<p>All of those are generators, that way you won't have all possible combinations at once in you memory. If you want to have as a list just change the second line (or the outermost in the one-liner) parentheses to square brackets.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you look at the documentation for <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer">permutations</a>, they give you what the function is essentially. You can modify this to exclude <code>'33'</code></p>
<pre><code>def permutations(iterable, r=None):
    # permutations('ABCD', 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) --&gt; 012 021 102 120 201 210
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    if r &gt; n:
        return
    indices = list(range(n))
    cycles = list(range(n, n-r, -1))
    yield tuple(pool[i] for i in indices[:r])
    while n:
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices[i:] = indices[i+1:] + indices[i:i+1]
                cycles[i] = n - i
            else:
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                seq = tuple(pool[i] for i in indices[:r])

                # Check if '33' is in sequence
                if '33' not in ''.join(seq):
                    yield seq
                break
        else:
            return
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Similar to <a href="https://stackoverflow.com/a/54045821/8219391">_mads</a> first option, you can also use the <a href="https://docs.python.org/3/library/itertools.html#itertools.filterfalse" rel="nofollow noreferrer">filterfalse(predicate, iterable)</a> function from itertools:</p>
<pre><code>from itertools import permutations, filterfalse

_str = "3212323"

def predicate(iterable):
    return '33' in ''.join(iterable)

filterfalse(predicate, permutations(_str)))
</code></pre>
</div>
<span class="comment-copy">First generate all string with only one <code>3</code> then put <code>3</code> in positions that are not near another <code>3</code>.</span>
<span class="comment-copy">In your first option you can also use <a href="https://docs.python.org/3/library/itertools.html#itertools.filterfalse" rel="nofollow noreferrer">filterfalse(predicate, iterable)</a> function from itertools and change the filter function to <code>return '33' in ''.join(temp)</code>   checking if an item exists in the iterable should be faster than checking if it's not in it</span>
<span class="comment-copy">@Oleg Sure you can post it another answer</span>
<span class="comment-copy">Thank you! That helped me a lot.</span>
