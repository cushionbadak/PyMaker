<div class="post-text" itemprop="text">
<p>I want to do the following in Python 2.7.13:</p>
<ul>
<li>Convert int-value to hex (<code>58829405413336430</code> should become <code>d101085402656e</code>)</li>
<li>Add a "payload" (Simple string like c1234) to the created hex</li>
<li>Write <strong>pure</strong> hex to a file</li>
</ul>
<p>My code currently looks like this:</p>
<pre><code>mime=58829405413336430
payload="c9999"

fw_file=open('testhex', 'wb')
fw_file.write("%x" % mime)
fw_file.write(str(payload).encode("hex"))
fw_file.close()
</code></pre>
<p>And I get the following file (Using <code>xxd</code> on Debian):</p>
<pre class="lang-none prettyprint-override"><code>xxd HACKEDTOGETHER
00000000: 6431 3031 3038 3534 3032 3635 3665 3633  d101085402656e63
00000010: 3339 3339 3339 3339                      39393939
</code></pre>
<p>which is <strong>not</strong> what i need. I need a file that looks like this:</p>
<pre class="lang-none prettyprint-override"><code>xxd WORKING
00000000: d101 0854 0265 6e63 3939 3939            ...T.enc9999
</code></pre>
<p>My understanding is the following:</p>
<p><code>"%x" % mime</code> converted my int to hex, but it was written as a String. <code>encode</code> did it correctly, but that doesn't work with integers. How can I circumvent this behavior and write "pure" hex to my file? If it is not possible to do it in Python 2 i can also use Python 3.</p>
<p>As this is my first question on StackOverflow please tell me if I should do anything different.</p>
</div>
<div class="post-text" itemprop="text">
<p>Part of the problem is that the result of <code>"%x" % mime</code> is a string of the pairs of hexadecimal <em>characters</em> — <code>"d101085402656e"</code>in this case — which represents the value of the integer <code>mime</code> in that format, so that's what is being written to the file. However what's needed are the actual byte values that comprise the integer itself.</p>
<p>In Python 3, this could be easily solved by instead using a built-in method called <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="nofollow noreferrer"><code>to_bytes()</code></a> that was added to the <code>int</code> type in that version, but in Python 2.x it has to be done another way.</p>
<p>There's similar issue due to your use of <code>str(payload).encode("hex")</code> which is also returning a hexadecimal string representation — not the actual byte values of each the characters already in <code>payload</code>, which is what is needed. Fortunately in this case what needs to be can be easily accomplished by using the built-in <a href="https://docs.python.org/2/library/functions.html#bytearray" rel="nofollow noreferrer"><code>bytearray</code></a> class Python 2.x has.</p>
<p>Below a version I wrote of a function posted as part of an <a href="https://stackoverflow.com/a/44803688/355230">answer</a> to a related <a href="https://stackoverflow.com/questions/44803084/convert-2-integers-to-hex-byte-array">question</a> that can deal with the issue with the <code>mime</code> value.</p>
<p>Following that function definition is code showing how to use it in this case, along with the <code>bytearray</code> class, to get the proper binary data written to the file.</p>
<pre><code>def int_to_bytes(n, minlen=0):
    """ Convert integer to bytearray with optional minimum length. 
    """
    if n &gt; 0:
        arr = []
        while n:
            n, rem = n &gt;&gt; 8, n &amp; 0xff
            arr.append(rem)
        b = bytearray(reversed(arr))
    elif n == 0:
        b = bytearray(b'\x00')
    else:
        raise ValueError('Only non-negative values supported')

    if minlen &gt; 0 and len(b) &lt; minlen: # zero padding needed?
        b = (minlen-len(b)) * '\x00' + b
    return b

mime = 58829405413336430
payload = 'c9999'

with open('testhex', 'wb') as fw_file:
    fw_file.write(int_to_bytes(mime))
    fw_file.write(bytearray(payload))
</code></pre>
<p>Here's a hex dump of contents of the <code>testhex</code> file it produced (with Python 2.7.15):</p>
<pre class="lang-none prettyprint-override"><code>00000000h: D1 01 08 54 02 65 6E 63 39 39 39 39             ; Ñ..T.enc9999
</code></pre>
</div>
<span class="comment-copy">hexadecimal is only a way of <i>representing</i> an integer number. So it is not a "conversion"</span>
<span class="comment-copy">I don't think they wanted the payload converted to ASCII hex. And you could replace <code>divmod(n, 256)</code> with <code>n&gt;&gt;8, n&amp;0xff</code>.</span>
<span class="comment-copy">@Mark: Thanks for the heads-up on the payload issue. I updated my answer accordingly, but I left the <code>divmod()</code> in because although what you say seems reasonable, a while ago I actual timed the difference and surprisingly it was faster.</span>
<span class="comment-copy">I just timed it in 3.6 and I get the opposite result: <code>divmod</code> is 0.13, and <code>&gt;&gt; &amp;</code> is 0.10.</span>
<span class="comment-copy">@Mark: Can't argue with that...answer further updated. Thanks again for the insight. I think I was confusing the use of <code>divmod()</code> with the use of another built-in (<code>math.hypot()</code> which isn't relevant here).</span>
