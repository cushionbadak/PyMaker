<div class="post-text" itemprop="text">
<p>I have the following server program in Python which simulates a chat-room. The code accepts connections from clients and for each of them it launches a new thread. This thread will wait for messages from this client. The messages can be <code>L</code> so that the server will respond with a list of connected clients, <code>ip:port msg</code> the server will send the message <code>msg</code> to the client <code>ip:port</code>. </p>
<p>On client side there will be 2 threads, one for receiving messages from the server, the other for sending. </p>
<pre><code>import socket
from threading import Thread
#from SocketServer import ThreadingMixIn
import signal
import sys
import errno

EXIT = False
address = []
address2 = []

# handler per il comando Ctrl+C
def sig_handler(signum, frame):
    if (signum == 2):
        print("Called SIGINT")
        EXIT = True

signal.signal(signal.SIGINT, sig_handler) # setto l'handler per i segnali


# Multithreaded Python server : TCP Server Socket Thread Pool
class ClientThread(Thread):

    def __init__(self,conn,ip,port):
        Thread.__init__(self)
        self.conn = conn
        self.ip = ip
        self.port = port
        print ("[+] New server socket thread started for " + ip + ":" + str(port))
    def run(self):
        while True:
            data = self.conn.recv(1024)
            print ("Server received data:", data)
            if (data=='L'):
                #print "QUI",address2
                tosend = ""
                for i in address2:
                    tosend = tosend + "ip:"+str(i[0]) + "port:"+str(i[1])+"\n"
                self.conn.send(tosend)
                #mandare elenco client connessi
            else:
                #manda ip:port msg
                st = data.split(" ")
                msg = st[1:]
                msg = ' '.join(msg)
                print ("MSG 2 SEND: ",msg)
                ipport = st[0].split(":")
                ip = ipport[0]
                port = ipport[1]
                flag = False
                print ("Address2:",address2)
                print ("ip:",ip)
                print ("port:",port)
                for i in address2:
                    print (i[0],ip,type(i[0]),type(ip),i[1],type(i[1]),port,type(port))
                    if str(i[0])==str(ip) and str(i[1])==str(port):
                        i[2].send(msg)
                        self.conn.send("msg inviato")
                        flag = True
                        break
                if flag == False:
                    self.conn.send("client non esistente")


if __name__ == '__main__':
    # Multithreaded Python server : TCP Server Socket Program Stub
    TCP_IP = '127.0.0.1'
    TCP_PORT = 2004
    TCP_PORTB = 2005
    BUFFER_SIZE = 1024  # Usually 1024, but we need quick response

    tcpServer = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcpServer.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    tcpServer.bind((TCP_IP, TCP_PORT))

    tcpServerB = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcpServerB.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    tcpServerB.bind((TCP_IP, TCP_PORTB))
    threads = []

    tcpServer.listen(4)
    tcpServerB.listen(4)

    while True:
        print("Multithreaded Python server : Waiting for connections from TCP clients...")
        try:
            (conn, (ip,port)) = tcpServer.accept()
        except socket.error as e: #(code, msg):
            if e.errno != errno.EINTR:
                raise
            else:
                break
        address.append((ip,port,conn))

        (conn2, (ip2,port2)) = tcpServerB.accept()
        address2.append((ip2,port2,conn2))

        newthread = ClientThread(conn,ip,port)
        newthread.start()
        threads.append(newthread)
        if EXIT==True:
            break

    print ("SERVER EXIT")

    for t in threads:
        t.join()
</code></pre>
<p>The code has a signal handler for <code>SIGINT</code> to make the exit cleaner (closing connections, sending a message to the client (still to be implemented) and so on ). The handler writes a global flag <code>EXIT</code> to make the infinite loops terminate.</p>
<ol>
<li>The code runs both in Python2 and Python3. However there are some problems with <code>SIGINT</code> signal generated by CTRL-C. When there is no client connected the program launched with Python2 exits correctly while the one in Python3 does not. Why this behavioural difference?</li>
<li>Considering only running the program in Python2, when a client connects and I press CTRL-C, the main while exits, like the signal is catched always by the main thread and this interrupts the blocking system call <code>accept</code>. However the other threads do not, I think because of the blocking underlying system call <code>data = self.conn.recv(1024)</code>. In C I would block <code>SIGINT</code> signals for one thread and then call <code>pthread_cancel</code> from the other thread. How to exit from all threads when <code>SIGINT</code> is generated in Python?</li>
</ol>
<p>The client program that for the moment works in Python2 only and suffers from the same problem is:</p>
<pre><code># Python TCP Client A
import socket
from threading import Thread

class ClientThread(Thread):

    def __init__(self,conn):
        Thread.__init__(self)
        self.conn = conn

    def run(self):
        while True:
            data = self.conn.recv(1024)
            print "Ricevuto msg:",data

host = socket.gethostname()
print "host:",host
port = 2004
portB = 2005
BUFFER_SIZE = 2000

tcpClientA = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcpClientB = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcpClientA.connect(('127.0.0.1', port))
tcpClientB.connect(('127.0.0.1', portB))

newthread = ClientThread(tcpClientB)
newthread.start()


while(True):
    msg = raw_input("Inserisci comando: ")
    tcpClientA.send (msg)
    data = tcpClientA.recv(BUFFER_SIZE)
    print "data received:",data

tcpClientA.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As for the difference in behavior with <code>accept()</code> in Python 3, look at the full description in the <a href="https://docs.python.org/3/library/socket.html#socket.socket.accept" rel="nofollow noreferrer">docs</a>. I think this is the key statement:</p>
<blockquote>
<p>Changed in version 3.5: If the system call is interrupted and the signal handler does not raise an exception, the method now retries the system call instead of raising an InterruptedError exception (see PEP 475 for the rationale).</p>
</blockquote>
<p>The other problem, stated in your penultimate sentence:</p>
<blockquote>
<p>How to exit from all threads when SIGINT is generated in Python 2?</p>
</blockquote>
<p>Take a look at the <a href="https://docs.python.org/2/library/threading.html" rel="nofollow noreferrer">threading</a> documentation:</p>
<blockquote>
<p>A thread can be flagged as a “daemon thread”. The significance of this flag is that the entire Python program exits when only daemon threads are left. The initial value is inherited from the creating thread. The flag can be set through the daemon property.</p>
</blockquote>
</div>
<span class="comment-copy">Your assignment of <code>EXIT = False</code> is creating a local variable; you need to declare it <code>global EXIT</code> in <code>sig_handler</code>; at least in python2... this could account for some of your problems.</span>
<span class="comment-copy">Also, your client threads don't have a mechanism to be notified that the server is shutting down. You are joining, but there appears to be no termination condition (except, perhaps remote disconnects, which may be your intent). It would be good to set timeouts in any case - otherwise your process will live as long as the remote connection is open.</span>
<span class="comment-copy">Yes that is still to be implemented, but I am resolving this first.</span>
<span class="comment-copy">Right about global though. I had corrected it before but then I lost my correction. Thanks</span>
