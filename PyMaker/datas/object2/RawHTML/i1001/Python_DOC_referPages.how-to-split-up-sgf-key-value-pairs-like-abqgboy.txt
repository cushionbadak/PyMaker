<div class="post-text" itemprop="text">
<p>In Python, I'm trying to split a string with SGF key/value pairs into a list or match object like so:</p>
<pre><code>'A[B][q]G[boy]' --&gt; ['A[B][q]', 'G[boy]']
</code></pre>
<p>(Keys are 'A' and 'G', values are '[B][q]' and '[boy]', respectively.)</p>
<p>I've tried splitting them up with this regex pattern</p>
<pre><code>pattern = r'([A-Z]\[.+\])[A-Z]'
</code></pre>
<p>But this fails when there's only one key/value such as 'A[B]'</p>
<p>Any suggestions? Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>With <a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow noreferrer"><strong><code>re.finditer</code></strong></a> function:</p>
<pre><code>import re

def find_sgf_groups(s: str):
    sgf_groups = []
    for m in re.finditer(r'[A-Z](\[[a-zA-Z]+\])+', s):
        sgf_groups.append(m.group())

    return sgf_groups

print(find_sgf_groups('A[B][q]'))
print(find_sgf_groups('A[B][q]G[boy]'))
</code></pre>
<p>The output (sequentially):</p>
<pre><code>['A[B][q]']
['A[B][q]', 'G[boy]']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use this regex for split based solution,</p>
<pre><code>(?&lt;=])(?=[A-Z])
</code></pre>
<p><strong><a href="https://regex101.com/r/RnUfJY/1" rel="nofollow noreferrer">Demo for split based</a></strong></p>
<p>Sample python code for split based solution,</p>
<pre><code>import re

arr = ['A[B][q]G[boy]','A[B][q]']

for s in arr:
 splittedstr = re.split('(?&lt;=])(?=[A-Z])', s)
 print(splittedstr)
</code></pre>
<p>Prints,</p>
<pre><code>['A[B][q]', 'G[boy]']
['A[B][q]']
</code></pre>
<p>If you want match based solution, you can use this regex,</p>
<pre><code>[A-Z](?:\[\w+])*
</code></pre>
<p><strong><a href="https://regex101.com/r/5hsRSn/1" rel="nofollow noreferrer">Demo for match based</a></strong></p>
<p>Sample python codes for match based solution,</p>
<pre><code>import re

arr = ['A[B][q]G[boy]','A[B][q]']

for s in arr:
 print(re.findall(r'[A-Z](?:\[\w+])*',s))
</code></pre>
<p>Prints,</p>
<pre><code>['A[B][q]', 'G[boy]']
['A[B][q]']
</code></pre>
<p>Use any that suits you best.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your regex does not match all the formats because <code>\[.+\]</code> and <code>[A-Z]</code> require a match. <code>.+</code> is also a greedy match and will match until the last occurence of <code>]</code></p>
<p>You could use <a href="https://docs.python.org/2/library/re.html?highlight=re%20findall#re.findall" rel="nofollow noreferrer">re.findall</a> and make the value between the first square brackets optional and repeat the last part 0+ times:</p>
<pre><code>[A-Z](?:\[[A-Z]\])?(?:\[[a-z]+\])*
</code></pre>
<p><strong>Explanation</strong></p>
<ul>
<li><code>[A-Z]</code> Match uppercase char</li>
<li><code>(?:\[[A-Z]\])?</code> Optional non capturing group that matches <code>[</code> uppercase char <code>]</code></li>
<li><code>(?:\[[a-z]+\])*</code> Repeat 0+ times <code>[</code> 1+ lowercase chars <code>]</code></li>
</ul>
<p><a href="https://regex101.com/r/cTeCJJ/1" rel="nofollow noreferrer">Regex demo</a> | <a href="https://ideone.com/Es1lJw" rel="nofollow noreferrer">Python demo</a></p>
<p>Example</p>
<pre><code>import re
strings = ["A[B][q]G[boy]", "A[B][q]", "A[B]"]
for s in strings:
    print(re.findall(r"[A-Z](?:\[[A-Z]\])?(?:\[[a-z]+\])*", s))
</code></pre>
<p>Result</p>
<pre><code>['A[B][q]', 'G[boy]']
['A[B][q]']
['A[B]']
</code></pre>
<p>Note</p>
<p>If you want to match more than one uppercase chars you could use a quantifier <code>[A-Z]+</code> and you can adjust what you want to match in the <a href="https://www.regular-expressions.info/charclass.html" rel="nofollow noreferrer">character class</a> accordingly.</p>
</div>
<span class="comment-copy">Do you mean like this? <a href="https://ideone.com/dAGz43" rel="nofollow noreferrer">ideone.com/dAGz43</a></span>
<span class="comment-copy">Thanks for your comment. Your regex pattern seems to work for multiple key/value inputs like 'A[B][q]G[boy]' but didn't work on single ones like, 'A[B][q]'. Any thoughts?</span>
<span class="comment-copy">In that case you could make the last part optional <code>([A-Z]\[[A-Z]\]\[[a-z]\])([A-Z]\[[a-z]+\])?</code> using a question mark.</span>
<span class="comment-copy">This is what I needed. Didn't know re.finditer existed. Thanks!</span>
