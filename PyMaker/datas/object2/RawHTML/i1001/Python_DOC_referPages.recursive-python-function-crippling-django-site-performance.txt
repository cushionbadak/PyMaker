<div class="post-text" itemprop="text">
<p>I have a Django site with a <code>Category</code> model, each instance of which can hold zero to <code>n</code> subcategories.</p>
<pre><code>class Category(models.Model):
    ...
    parent = models.ForeignKey('self', on_delete=models.CASCADE, blank=True, null=True, related_name='subcategories')
</code></pre>
<p>The categories are stored in a MySQL database. I need to build a nested HTML list of all categories.</p>
<p>As a down and dirty way of getting this off the ground, I initially did this via a recursive function.</p>
<p>This worked fine initially, but now there are over 800 categories and it's causing requests to slow down drastically. When running the development server, it's taking at least 60 seconds a go.</p>
<p>Here's the function, simplified slightly:</p>
<pre><code>def get_category_map(categories, root=False):
    category_map = ''
    if categories:
        if root:
            category_map += '&lt;ul id="root"&gt;'
        else:
            category_map += '&lt;ul&gt;'
        for category in categories:
            category_map += '&lt;li&gt;'
            subcategories = category.subcategories.all()
            if subcategories.count() == 0:
                category_map += '&lt;a class="category-link" href="' + reverse('my_app:category_page', args=(category.pk, category.slug)) + '"&gt;' + category.title + '&lt;/a&gt;'
            else:
                category_map += '&lt;span class="category-drop-down"&gt;' + category.title + '&lt;/span&gt;'
                # Recursive call here cripples performance.
                category_map += get_category_map(subcategories)
            category_map += '&lt;/li&gt;'
        category_map += '&lt;/ul&gt;'
    return category_map
</code></pre>
<p>with the function initially called as follows:</p>
<pre><code>get_category_map(Category.objects.filter(parent=None), root=True)
</code></pre>
<p>It generates the result I want, but at the expense of efficiency and time.</p>
<p>I understand the basic performance issues with Python and recursion, but can this be salvaged or does it require a fundamentally different approach?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is an educated guess: the performance issue you're experiencing is most likely due to the number of queries hitting the database, not to the recursive function to generate the template.</p>
<p><code>subcategories = category.subcategories.all()</code></p>
<p>Since you're not using any prefetching, the line above will trigger a query for each category you recursively visit, so with 800 top level categories you'll get 800 just to start with. Additionally, you're also performing a count query for each one:</p>
<p><code>if subcategories.count() == 0:</code></p>
<p>You could improve things a bit by using Django built-in eager loading for model relationships.
Consider though that efficiently storing and querying a tree structure in a relational DB requires some clever algorithms. 
So I suggest to use (or at least draw inspiration from) this Django package:</p>
<p><a href="https://django-treebeard.readthedocs.io/en/latest/" rel="nofollow noreferrer">https://django-treebeard.readthedocs.io/en/latest/</a></p>
<p>This is used by a Wagtail, a popular Django CMS that supports nested categories.</p>
<p>This package implements three different strategies to store and query tree structures:</p>
<ul>
<li>Adjacency List</li>
<li>Materialized Path</li>
<li>Nested Sets</li>
</ul>
<p>Another popular alternative is this one:</p>
<p><a href="https://github.com/django-mptt/django-mptt" rel="nofollow noreferrer">https://github.com/django-mptt/django-mptt</a></p>
<p>I would recommend against a "home-made" solution in your case as you already have a considerable number of categories to handle, so performance already matters in your case). Implementing these algorithms by yourself from scratch wouldn't be trivial at all.</p>
</div>
<span class="comment-copy">Three comments: 1. Don't write HTML from python. That's why django has templates. 2. Define max depth. 3. Use ORM to return a union between the 1st ... Nth level in one query.</span>
<span class="comment-copy">Python recursion is not particularly slow (when compared to the rest of Python). The likely culprit is the multiple database queries, and the accompanying Python object instantiation. <a href="https://docs.python.org/3/library/profile.html" rel="nofollow noreferrer">Profiling</a> would help. But in general, grabbing all the categories in one query (especially with <code>values_list</code>, but that may be a premature microoptimisation) and then stitching them into a hierarchy in Python would speed it up considerably.</span>
<span class="comment-copy">@Amadan Yes, seems like it was the significant number of database queries in quick succession.</span>
<span class="comment-copy">Another popular alternative is django-mptt.</span>
<span class="comment-copy">@DanielRoseman indeed, I've added it to my answer, thanks.</span>
<span class="comment-copy">I've integrated <code>django-mptt</code> and performance seems to be good so far, so hopefully this will improve things when I run the migrations on the live database.</span>
