<div class="post-text" itemprop="text">
<p>I have two lists in python <code>list_a</code> and <code>list_b</code>. The <code>list_a</code> have some images links, and the <code>list_b</code> too. 99% of the items are the same, but i have to know this 1%. The all surplus items are in <code>list_a</code>, that means all items in <code>list_b</code> are in <code>list_a</code>. My initial idea is subtract all items:
<code>list_a - list_b = list_c</code>, where the <code>list_c</code> are my surplus items. My code is:</p>
<pre><code>list_a = []
list_b = []
list_c = []

arq_b = open('list_b.txt','r')
for b in arq_b:
    list_b.append(b)

arq_a = open('list_a.txt','r')
for a in arq_a:
    if a not in arq_b:
        list_c.append(a)

arq_c = open('list_c.txt','w')
for c in list_c:
    arq_c.write(c)
</code></pre>
<p>I think the logic is right, if i have some items, the code is run fast. But i dont have 10 items, or 1.000, or even 100.000. I have <strong><code>78.514.022</code></strong> items in my <code>list_b.txt</code> and <strong><code>78.616.777</code></strong> in my list <code>list_a.txt</code>. I dont't know the cost of this expression: <code>if a not in arq_b</code>. But if i execute this code, i think wont finish in this year.</p>
<p>My pc have 8GB, and i allocate 15gb for swap to not explode my RAM.</p>
<p>My question is, there's another way to make this operation more efficiently(Faster)?</p>
<ul>
<li>The <code>list_a</code> is ordinate but the <code>list_b</code> not.</li>
<li>Each item have this size: <code>images/00000cd9fc6ae2fe9ec4bbdb2bf27318f2babc00.png</code></li>
<li>The order doesnt matter, i want know the surplus.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>you can create one set of the first file contents, then just use <code>difference</code> or <code>symmetric_difference</code> depending on what you call a difference</p>
<pre><code>with open("list_a.txt") as f:
    set_a = set(f)

with open("list_b.txt") as f:
    diffs = set_a.difference(f)
</code></pre>
<p>if <code>list_b.txt</code> contains more items than <code>list_a.txt</code> you want to swap them or use <code>set_a.symmetric_difference(f)</code> instead, depending on what you need.</p>
<p><code>difference(f)</code> works but still has to construct a new <code>set</code> internally. Not a great performance gain (see <a href="https://stackoverflow.com/questions/50728117/set-issubset-performance-difference-depending-on-the-argument-type">set issubset performance difference depending on the argument type</a>), but it's shorter.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try using sets:</p>
<pre><code>with open("list_a.txt") as f:
    set_a = set(f)

with open("list_b.txt") as f:
    set_b = set(f)

set_c = set_a - set_b

with open("list_c.txt","w") as f:
    for c in set_c:
        f.write(c)
</code></pre>
<p>The complexity of subtracting two sets <a href="https://wiki.python.org/moin/TimeComplexity" rel="noreferrer">is O(n) in the size of the set a</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To extend the comment of @L3viathan
If order of element is not important set is the rigth way.
here a dummy example you can adapt:</p>
<pre><code>l1 = [0,1,2,3,4,5]
l2 = [3,4,5]
setL1 = set(l1)  # transform the list into a set
setL2 = set(l2)
setDiff = setl1 - setl2  # make the difference 
listeDiff = list(setDiff)  # if you want to have your element back in a list
</code></pre>
<p>as you see is pretty straightforward in python.</p>
</div>
<div class="post-text" itemprop="text">
<p>In case order matters you can presort the lists together with item indices and then iterate over them together:</p>
<pre><code>list_2 = sorted(list_2)
diff_idx = []
j = 0
for i, x in sorted(enumerate(list_1), key=lambda x: x[1]):
    if x != list_2[j]:
        diff_idx.append(i)
    else:
        j += 1
diff = [list_1[i] for i in sorted(diff_idx)]
</code></pre>
<p>This has time complexity of the sorting algorithm, i.e. O(n*log n).</p>
</div>
<span class="comment-copy">Does the order matter? If not, try using sets. With sets, subtraction should be linear: <code>set_c = set_a - set_b</code>.</span>
<span class="comment-copy">But is possible make this in python?</span>
<span class="comment-copy">The python will use the most efficient way to make this operation?</span>
<span class="comment-copy">Yes, I mean the Python datatype <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer"><code>set</code></a>.</span>
<span class="comment-copy">@tripleee It's not a duplicate of that - that question is about mapping subtraction over a list, this question is about the difference between what's included in the lists.</span>
<span class="comment-copy">Nice, this avoids having to allocate space for the second set.</span>
<span class="comment-copy">Well, not really, because internally a <code>set</code> is created, then thrown away. but it's thrown away <i>faster</i></span>
<span class="comment-copy">But the complexity is the same of subtract sets?</span>
<span class="comment-copy">@ViniciusMorais The time complexity is the same, the space complexity (apparently), too.</span>
<span class="comment-copy">@L3viathan In case the original list (the original set) is not needed anymore you can use <code>difference_update</code>. This should not require to allocate a new set internally.</span>
<span class="comment-copy">You know - an open file is an iterator - therefore you can simply do <code>set_a = set(open("list_a.txt"))</code></span>
<span class="comment-copy">yes but doing <code>set(f)</code> in with block ensures that it closes the file</span>
