<div class="post-text" itemprop="text">
<p>What is the most "pythonic" way to create a class member which is an instance of that class? I.e. something like this:</p>
<pre><code>class MyClass:

    # error! (and this is to be expected as MyClass is not yet fully defined)
    instance_as_member = MyClass()

    def __init__(self):
        print("MyClass instance created!")
</code></pre>
<p>One can solve this by adding a member after the class definition:</p>
<pre><code>class MyClass:
    ...
MyClass.instance_as_member = MyClass()
</code></pre>
<p>but this seems a little wrong; naturally, class members should be defined <em>in</em> that class.</p>
<p>Is there a better way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>That is not "A little wrong" - it is the simple and obvious way to do that.
One line of code, readable by everyone and obvious "what it is". </p>
<p>Still it does not "feel" elegant. 
So, if you don't want to do that just for the looks, and perhaps, if there are many classes like this, not repeating code, it could be done with a class decorator:</p>
<pre><code>def instance_as_member(attr_name='instance_as_member', *init_args, **init_kwargs):
    def decorator(cls):
        instance = cls(*init_args, **init_kwargs)
        setattr(cls, attr_name, instance)
        return cls
    return decorator

@instance_as_member()
class MyClass:
    ...
</code></pre>
<p>Decorators are ok for that, as they get the cls to be modified as a parmater after it is fully created. With metaclasses, that would be tricky because some steps of class instantiating, like calling <code>__init_subclass__</code> are performed <em>after</em> any explicit metaclass methods that can be overriden, so, one could have problems trying to create an instance inside a metaclass initialization method (<code>__init__</code>, <code>__new__</code>, or meta-meta-class' <code>__call__</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>It appears that you want a <code>setUp</code> type of functionality.  Here's a "slightly dirty" way to do it from within the class: set a class-variable flag to denote the first use of the class.  Check the flag on instantiation; if this is the first access, then clear the flag and run the set-up method.</p>
<pre><code>class MyClass:

    first_touch = True

    def __init__(self, id=0):

        if MyClass.first_touch:
            MyClass.setUp(id)
        print("MyClass instance created!", id)

    @classmethod
    def setUp(self, id):
        MyClass.first_touch = False
        MyClass.instance_as_member = MyClass(-999)


print("Start")
local_obj = MyClass(1)
local_obj = MyClass(2)
local_obj = MyClass(3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While the class isn't defined within the body, it <em>is</em> defined when inside <code>__init__</code></p>
<p>However, there's a problem that instantiating the class inside <code>__init__</code> is recursive, so you need to track whether <code>instance_as_member</code> has been made yet.</p>
<p>Something like the following works:</p>
<pre><code>class Foo:
    member_added = False
    instance_as_member = None

    def __init__(self):
        if not Foo.member_added:
            Foo.member_added = True
            Foo.instance_as_member = Foo()

print(Foo.instance_as_member)
Foo()
print(Foo.instance_as_member)
</code></pre>
<p>This results in:</p>
<blockquote>
<p>None<br/>
  &lt;__main__.Foo object at 0x7fcd9f68f3c8&gt;</p>
</blockquote>
<p>(<em>As to whether this is a good idea is an entirely different question!</em>)</p>
</div>
<span class="comment-copy">Well, since the class <i>doesn't exist yet</i> inside the class body, you have to find a point <b>after</b> the class body has completed.</span>
<span class="comment-copy">Makes sense. So the proposed solution is the only way to do it I suppose.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/2035423/python-how-to-refer-to-the-class-from-within-it-like-the-recursive-function">Related</a></span>
<span class="comment-copy">@RobertR: there are <a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__" rel="nofollow noreferrer">other</a> <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow noreferrer">hooks</a> <a href="https://www.python.org/dev/peps/pep-3129/" rel="nofollow noreferrer">available</a>, but sometimes it is just simpler to just add it after the class has been created.</span>
<span class="comment-copy">Neat idea using the decorator, but I think your first comment is accurate: it is probably better to just do the assignment after the class definition for sake of readability.</span>
<span class="comment-copy">Same problem with match's answer: this would only work if the member instance is only ever accessed after another instance is created. Thanks for the suggestion though!</span>
<span class="comment-copy">Yeah I thought about this too, but then the member instance is only available after another instance has been created.</span>
