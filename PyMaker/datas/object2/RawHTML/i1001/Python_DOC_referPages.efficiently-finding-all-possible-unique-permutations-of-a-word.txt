<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6284396/permutations-with-unique-values">permutations with unique values</a>
<span class="question-originals-answer-count">
                    15 answers
                </span>
</li>
</ul>
</div>
<p>Lets say I have the following word : "aabb" then all possible unique permutations are : "aabb","abab","baba","abba","baab" and "bbaa". Notice that that there are not 4! = 24 ways to do so but 4 choose 2 = 6. What I currently have is a naive approach : finding all permutations, including the duplicates, and afterwards deleting the duplicates :</p>
<pre><code>def permutations(l):
    if len(l) &lt;=1:
        yield l
    else:
        for p in permutations(l[1:]):
            for i in range(len(l)):
                yield p[:i] + l[0] + p[i:]

print(set(permutations("aabb")))
</code></pre>
<p>My question is if their exists a more efficient way to find all these permutations?</p>
<p>EDIT : i do NOT want an approach which follows the inefficient idea of finding all permutations and afterwards deleting the duplicates. My code sample does this already!</p>
<p>EDIT : coldspeed correctly marked my question as duplicate. The correct answer would be to use sympy's multiset_permutations function :</p>
<pre><code>&gt;&gt;&gt; from sympy.utilities.iterables import multiset_permutations
&gt;&gt;&gt; list(multiset_permutations([1,1,1]))
[[1, 1, 1]]
&gt;&gt;&gt; list(multiset_permutations([1,1,2]))
[[1, 1, 2], [1, 2, 1], [2, 1, 1]]
</code></pre>
<p>, per @Bill Bell.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>permutations</code> from <code>itertools</code>. The <code>set</code> returns you the unique elements and then you use <code>join</code> to get the strings as a single element. The list comprehension way to do this is following.</p>
<pre><code>from itertools import permutations
result = [''.join(lst) for lst in set((permutations("aabb")))]
print (result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['aabb', 'baba', 'bbaa', 'abab', 'abba', 'baab']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Can use <a href="https://docs.python.org/2/library/itertools.html#itertools.permutations" rel="nofollow noreferrer">permutations</a> and <code>set()</code> to remove duplicates</p>
<pre><code>from itertools import permutations
res=set()
for i in permutations('aabb'):
    res.add(i)
</code></pre>
<p>Output</p>
<pre><code>set([('b', 'a', 'b', 'a'), ('b', 'b', 'a', 'a'), ('a', 'b', 'b', 'a'), ('a', 'a', 'b', 'b'), ('b', 'a', 'a', 'b'), ('a', 'b', 'a', 'b')])
</code></pre>
<p>If list of strings is desired result</p>
<pre><code>map(''.join,set(permutations('aabb')))
</code></pre>
<p>Output</p>
<pre><code>['baba', 'bbaa', 'abba', 'aabb', 'baab', 'abab']
</code></pre>
</div>
<span class="comment-copy">Do you want to get all the permutations or just their total number? In the latter case there is a simple formula for that</span>
<span class="comment-copy">I want them all. I know of multinomial coefficients.</span>
<span class="comment-copy">This is exactly the same as my implementation?</span>
<span class="comment-copy">This is an inbuilt module in itertools which does the same task at the end as you are doing. I do not exactly know under the hood algorithm. You can have a look <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">OP's current method is faster than this.(14 µs) This answer takes 15.7 µs</span>
<span class="comment-copy">This is also the same as my implementation.</span>
<span class="comment-copy">@DanielScott: That depends on the size of the strings. For ex. try comparing the times for this string <code>"aabbcdahgfa"</code> instead of <code>'aabb'</code>. Here my answer took 5.66 seconds and OP's method took 21.5 seconds</span>
