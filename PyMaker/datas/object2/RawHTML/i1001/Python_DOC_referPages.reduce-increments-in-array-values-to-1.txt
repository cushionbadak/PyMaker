<div class="post-text" itemprop="text">
<p>I am trying to create a list (say <code>B</code>) which increments only when there is a difference in values of another list (say <code>A</code>), for example:</p>
<p><code>[1,1,2,2,4,4]</code> to <code>[0,0,1,1,2,2]</code> or</p>
<p><code>[1,1,1,1,4,4,4,4]</code> to <code>[0,0,0,0,1,1,1,1]</code> etc.</p>
<p>The following code does it:</p>
<pre><code>boxes=[1,1,1,1,4,4,4,4]
positions=[0]
position=0
for psn,box in list(enumerate(boxes))[:-1]:
    if boxes[psn+1]-box ==0:
        increment=0
    else:
        increment=1
    position=position+increment
    positions.append(position)
print(positions)
</code></pre>
<p>Can anybody give suggestions to do it using list comprehensions (preferable using <code>lambda</code> functions)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a way using <code>nummpy</code>:</p>
<pre><code>a = [1,1,2,2,4,4]
[0] + np.cumsum(np.clip(np.diff(a), 0, 1)).tolist()
[0, 0, 1, 1, 2, 2]
</code></pre>
<p>Or for the other example:</p>
<pre><code>a = [1,1,1,1,4,4,4,4]
[0] + np.cumsum(np.clip(np.diff(a), 0, 1)).tolist()
[0, 0, 0, 0, 1, 1, 1, 1]
</code></pre>
<p><b> Details </b></p>
<pre><code>a = [1,1,2,2,4,4]
</code></pre>
<p>Get the first difference of the array with <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.diff.html" rel="noreferrer"><code>np.diff</code></a></p>
<pre><code>np.diff(a)
array([0, 1, 0, 2, 0]) 
</code></pre>
<p>And use <a href="https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.clip.html" rel="noreferrer"><code>np.clip</code></a> to limit the values between <code>0</code> and <code>1</code>:</p>
<pre><code>np.clip(np.diff(a), 0, 1)
array([0, 1, 0, 1, 0])
</code></pre>
<p>Finally take the <a href="https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.cumsum.html" rel="noreferrer"><code>np.cumsum</code></a> and add a <code>0</code> at the beginning as the difference will give you an array of length <code>n-1</code>:</p>
<pre><code>[0] + np.cumsum(np.clip(np.diff(a), 0, 1)).tolist()
[0, 0, 1, 1, 2, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer">itertools.groupby</a>:</p>
<pre><code>from itertools import groupby

a = [1,1,2,2,4,4]

result = [i for i, (_, group) in enumerate(groupby(a)) for _ in group]
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[0, 0, 1, 1, 2, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I see numpy solutions, so here we go.</p>
<p><code>digitize</code></p>
<pre><code>np.digitize(A, np.unique(A)) - 1
# array([0, 0, 0, 0, 1, 1, 1, 1])
</code></pre>
<hr/>
<p><code>factorize</code></p>
<pre><code>import pandas 
pd.factorize(A)[0]
# array([0, 0, 0, 0, 1, 1, 1, 1])
</code></pre>
<hr/>
<p><code>groupby</code> and <code>ngroup</code></p>
<pre><code>pd.Series(A).groupby(A).ngroup()

0    0
1    0
2    0
3    0
4    1
5    1
6    1
7    1
dtype: int64
</code></pre>
<hr/>
<p><code>unique</code></p>
<pre><code>np.unique(A, return_inverse=True)[1]
# array([0, 0, 0, 0, 1, 1, 1, 1])
</code></pre>
<hr/>
<p>Using list comprehension with <code>itertools.accumulate</code>:</p>
<pre><code>from itertools import accumulate
from operator import add

list(accumulate([0] + [x != y for x, y in zip(A, A[1:])], add))
# [0, 0, 0, 0, 1, 1, 1, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't do this with a traditional list comprehensions because they can't <a href="https://stackoverflow.com/questions/47803002/list-comprehensions-in-python-with-mutable-state-between-iterations/47803229">share a mutable state between iterations</a>.</p>
<p>In this case, using <code>itertools.groupby</code>, <code>numpy</code>, or a plain python loop (as in your code) is recommended. </p>
<p>BUT if you really wanted to use a list comprehension, one way would be to rely side effects.</p>
<p>For example:</p>
<pre><code>boxes=[1,1,1,1,4,4,4,4]
positions = [0]
throwaway = [
    positions.append(positions[-1] + 0 if boxes[psn+1]-box == 0 else 1) 
    for psn, box in enumerate(boxes[:-1])
]
print(positions)
#[0, 0, 0, 0, 1, 1, 1, 1]
</code></pre>
<p>You are using the list comprehension to create a list called <code>throwaway</code>, but the actual contents of <code>throwaway</code> are not useful at all. We use the iterations to call <code>append</code> on <code>positions</code>. Since <code>append</code> returns <code>None</code>, the following is the actual result of the list comprehension.</p>
<pre><code>print(throwaway)
#[None, None, None, None, None, None, None]
</code></pre>
<p>However, relying on the side effects like this is not considered good practice.</p>
</div>
<div class="post-text" itemprop="text">
<p>Method using <code>zip</code> and list comprehension and slicing</p>
<pre><code>a = [1,1,2,2,4,4]
increments = [bool(i[1]-i[0]) for i in zip(a,a[1:])]
b = [sum(increments[:i]) for i in range(len(increments)+1)]
print(b) #prints [0, 0, 1, 1, 2, 2]
</code></pre>
<p>Explanation: this solution, rely on that in Python:</p>
<p>any number other than <code>0</code> (or <code>0.0</code>) is evaluated as <code>True</code> when feed to <code>bool</code> function</p>
<p>when such need arises <code>True</code> and <code>False</code> values are turned into <code>1</code> and <code>0</code> respectively</p>
<p>how <code>sum</code> function works: in reality something like <code>sum([3,4])</code> means calculate <code>0+3+4</code> thus <code>sum([True,True])</code> means calculate <code>0+True+True</code>, which is translated into <code>0+1+1</code></p>
</div>
<span class="comment-copy">Thank you so much, but the motive is to know how it can be done using lamda functions.</span>
<span class="comment-copy">Actually, I misunderstood. <code>numpy.diff</code> is not what you're looking for.</span>
<span class="comment-copy">It's not going to be easy (without side-effects or nested loops) to do this using a list comprehension.</span>
