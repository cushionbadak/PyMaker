<div class="post-text" itemprop="text">
<p>I have a repository that is best characterized as a specialized application rather than a library.</p>
<p>Here's an example structure:</p>
<pre><code>logtest/
    logtest/
        __init__.py
        a.py
        b.py
        ...
        e.py
        f.py
    LICENSE
    README
    .gitignore, etc
</code></pre>
<p>I would like to use an instance of <code>logging.handlers.RotatingFileHandler</code> for each module and each standard <a href="https://docs.python.org/3/library/logging.html#logging-levels" rel="nofollow noreferrer">severity level</a> found in the logging package.  </p>
<p>Each <code>.py</code> file currently contains just <code>logger = logging.getLogger(__name__)</code>; for <code>a.py</code> this would produce <code>logger.name == 'logtest.a'</code>.  What I would like to achieve is to set up multiple handlers for each logger:</p>
<ul>
<li>One that pertains to just the respective module, i.e. <code>/tmp/mod-a.log</code>.  The level of this handler should be NOTSET.</li>
<li>Five that pertain to the five logging levels besides <code>NOTSET</code>, i.e. levels 10 thru 50.  Each of these has the appropriate <code>.level</code> to filter only log records of that severity, but the source may come from any logger instance.</li>
</ul>
<p>A picture probably says a lot more:</p>
<pre><code>logtest/a.py  --&gt;  /tmp/a.log  # Any severity level
logtest/b.py  --&gt;  /tmp/b.log
... 
logtest/e.py  --&gt;  /tmp/e.log

logtest/a.py  __
logtest/b.py  __\___ `/tmp/level-critical.log` (if level is logging.CRITICAL)
logtest/e.py  __/

logtest/a.py  __
logtest/b.py  __\___ `/tmp/level-error.log` (if level is logging.ERROR)
logtest/e.py  __/
</code></pre>
<p>(Yes, I realize this will log messages redundantly.)</p>
<p>What is the recommended and efficient way to design such as setup?  It seems like <code>logging.config.dictConfig</code> would be useful, except that gets away from the <code>logging.getLogger(__name__)</code> calls. </p>
<hr/>
<p>If the above is a bit unclear: I have a <code>logger</code> instance for each module besides <code>__init__.py</code>, each of which is created via <code>logging.getLogger(__name__)</code>.  I realize that I can add 5 filehandlers to the root logger, because all of the other loggers inherit from that.  However, is there a more programmatic way to add the "module-level" file handler for each logger?</p>
<p>I know that the adding of severity-level handlers could be done like this:</p>
<pre><code>_levels = ("debug", "info", "warning", "error", "critical")
_level_handlers = {
    level: {
        "class": "logging.handlers.RotatingFileHandler",
        "filename": "/tmp/level-{}.log".format(level),
        "maxBytes": 750000,
        "backupCount": 5,
        "level": level.upper()
    } for level in _levels
}

LOGGING = {
    "version": 1,
    "loggers": {
        # Root - all other logger.getLogger(__name__) instances are children
        "": {
            "handlers": _levels,
        }
    }
}

LOGGING['handlers'] = _level_handlers
logging.config.dictConfig(LOGGING)
</code></pre>
<p>But am unsure of how to treat the second part.</p>
</div>
<div class="post-text" itemprop="text">
<p>My current solution has two parts (still certainly appreciate other approaches):</p>
<ul>
<li>Set up the level-based handlers within <code>__init__</code>, and add them to a parent logger there.  As pointed out by @Sraw, this should be <code>__name__</code>, not the root logger, from which other packages might inherit.</li>
<li>Add a helper function <code>getModuleLogger()</code> that mimics <code>getLogger()</code> within <code>__init__</code>, but also add a file handler specific to the module there.</li>
</ul>
<p>Each module then calls <code>getModuleLogger(__name__)</code> just as it would normally call <code>logging.getLogger(__name__)</code>, and no additional setup is required.</p>
<p>From <code>__init__.py</code>:</p>
<pre><code>__all__ = ()

import logging
import logging.config
import logging.handlers
import os

_levels = ("debug", "info", "warning", "error", "critical")
_level_handlers = {
    level: {
        "class": "logging.handlers.RotatingFileHandler",
        "filename": "/tmp/level-{}.log".format(level),
        "maxBytes": 750_000,
        "backupCount": 5,
        "level": level.upper()
    } for level in _levels
}

LOGGING = {
    "version": 1,
    "loggers": {
        # Using the package name means modules in the package are nested
        # as children of this parent logger and will inherit its handlers
        __name__: {
            "handlers": _levels,
        }
    }
}

LOGGING['handlers'] = _level_handlers
logging.config.dictConfig(LOGGING)


def getModuleLogger(name):
    """Call this from modules instead of standard logging.getLogger()."""
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    handler = logging.handlers.RotatingFileHandler(
        filename="/tmp/module-{}.log".format(name),
        maxBytes=750_000, backupCount=5
    )
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    return logger
</code></pre>
<p>From <code>a.py</code> (similar structure for others):</p>
<pre><code>from logtest import getModuleLogger

logger = getModuleLogger(__name__)

def test_a():
    logger.info("info from a.py")
    logger.critical("critical from a.py")
</code></pre>
<p>Illustration:</p>
<pre><code>&gt;&gt;&gt; from logtest import a, b
&gt;&gt;&gt; a.test_a()
&gt;&gt;&gt; b.test_b()
&gt;&gt;&gt; from logtest.a import logger
&gt;&gt;&gt; logger.handlers
[&lt;RotatingFileHandler /tmp/module-logtest.a.log (DEBUG)&gt;]
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(logger.parent.handlers)
[&lt;RotatingFileHandler /tmp/level-debug.log (DEBUG)&gt;,
 &lt;RotatingFileHandler /tmp/level-info.log (INFO)&gt;,
 &lt;RotatingFileHandler /tmp/level-warning.log (WARNING)&gt;,
 &lt;RotatingFileHandler /tmp/level-error.log (ERROR)&gt;,
 &lt;RotatingFileHandler /tmp/level-critical.log (CRITICAL)&gt;]
&gt;&gt;&gt; exit()

[logtest/] $ cat /tmp/module-logtest.a.log 
info from a.py
critical from a.py
[logtest/] $ cat /tmp/module-logtest.b.log 
info from b.py
critical from b.py
[logtest/] $ cat /tmp/level-critical.log 
critical from a.py
critical from b.py
</code></pre>
</div>
<span class="comment-copy">What's wrong with having a unique logger for each module, and multiple handlers for each logger?</span>
<span class="comment-copy">That's precisely want I want to do @wom.  My question is whether that entails, within each .py file, setting up another RotatingFileHandler instance that uses the <code>__name__</code> from that module.  I would like to know if there's a way to do that configuration all from one place.</span>
<span class="comment-copy">How about creating a helper for this purpose? Something like <code>logHelper.getLogger(__name__)</code>, and then inside the function you can detect if the logger is configged. If it is, just return it. If it isn't, then config it correspondingly. In your case, I believe you need <code>module_numer + 5</code> instances of <code>RotatingFileHandler</code>. If you like this idea, I will post an answer about the details.</span>
<span class="comment-copy">That's what I'm working on also right now @Sraw</span>
<span class="comment-copy">@BradSolomon I mean you can add the same handler instance to different submodules. It would be more flexible and safer than adding to root handler(Which is showed in your question).</span>
<span class="comment-copy">You really shouldn't use root logger in this way. Image if you use another third-part lib such as flask. It has its own logger and that logger will also be affected by your config of root logger. Which causes all other logs are logged into your files. I believe that is not what you want.</span>
<span class="comment-copy">@Sraw You're right, good point.  But I could just replace <code>""</code> with <code>__name__</code> in <code>__init__.py</code> then, no? - see edit.</span>
<span class="comment-copy">Well, it looks great. I cannot make it better.</span>
<span class="comment-copy">Thanks man @Sraw</span>
