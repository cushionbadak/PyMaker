<div class="post-text" itemprop="text">
<p>I have an array of 0's and 1's as such</p>
<pre><code>[0,0,1,1,1,0,0,0,0,1,1,0,0]
</code></pre>
<p>I want to define a function that will take this array as input and output an array of the same length, with the count of adjacent 1's in the index where the first 1 appeared (and 0 otherwise). So the output would be</p>
<pre><code>[0,0,3,0,0,0,0,0,0,2,0,0,0]
</code></pre>
<p>because 1 appeared in the 2nd index 3 consecutive times and 1 appeared in the 9th index 2 consecutive times.</p>
<p>Is there a way to do this using numpy? If not, is there some (efficient) pythonic way to do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution using pure vectorized operations and no list iterations:</p>
<pre><code>import numpy as np

data = np.array([0,0,1,1,1,0,0,0,0,1,1,0,0])
output = np.zeros_like(data)

where = np.where(np.diff(data))[0]
vals = where[1::2] - where[::2]
idx = where[::2] + 1

output[idx] = vals
output
# array([0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the <code>itertools</code> module:</p>
<pre><code>from itertools import chain, groupby

A = [0,0,1,1,1,0,0,0,0,1,1,0,0]

def get_lst(x):
    values = list(x[1])
    return [len(values)] + [0]*(len(values) - 1) if x[0] else values

res = list(chain.from_iterable(map(get_lst, groupby(A))))

# [0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">groupby</a> to group the consecutive elements:</p>
<pre><code>from itertools import groupby

a = [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0]


def groups(lst):
    result = []
    for key, group in groupby(lst):
        if not key:  # is a group of zeroes
            result.extend(list(group))
        else:  # is a group of ones
            count = sum(1 for _ in group)
            if count &gt; 1:  # if more than one
                result.append(count)
                result.extend(0 for _ in range(count - 1))
            else:
                result.append(0)
    return result


print(groups(a))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0]
</code></pre>
<p>A shorter (more <em>pythonic</em>?) is the following:</p>
<pre><code>def groups(lst):
    for key, group in groupby(lst):
        count = sum(1 for _ in group)
        if key and count &gt; 1:
            yield count
        yield from (0 for _ in range(count - key))


print(list(groups(a)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use pandas, take advantage in pandas <code>count</code> counts non-NaN values.  Create NaNs using <code>mask</code> then groupby changes in values of s.</p>
<pre><code>import pandas as pd
l = [0,0,1,1,1,0,0,0,0,1,1,0,0]
s = pd.Series(l)
g = s.diff().ne(0).cumsum()
s.mask(s==0).groupby(g).transform('count').mask(g.duplicated(), 0).tolist()
</code></pre>
<p>Output:</p>
<pre><code>[0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way using numpy and a list comprehension:</p>
<pre><code>In [23]: a = np.array([0,0,1,1,1,0,0,0,0,1,1,0,0])
In [24]: np.hstack([x.sum() if x[0] == 1 else x for x in np.split(a, np.where(np.diff(a) != 0)[0]+1)])
Out[24]: array([0, 0, 3, 0, 0, 0, 0, 2, 0, 0])
</code></pre>
<p>The logic:</p>
<ol>
<li>Find leading and trailing indices of where you have consequence 1s.</li>
<li>Split your array from those indices</li>
<li>sum those sub lists that have one and  leave sub lists with zero the way they are</li>
<li>flatten the result using <code>np.hstack</code>.</li>
</ol>
<p>If you want to replace the remained ones with 0 just do the following:</p>
<pre><code>In [28]: np.hstack([[x.sum(), *[0]*(len(x) -1)]  if x[0] == 1 else x for x in np.split(a, np.where(np.diff(a) != 0)[0]+1)])
Out[28]: array([0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0])
</code></pre>
<p><code>[0]*(len(x) -1)</code> will create the expected 0s for you and using an in-place unpacking you'll be able to place them beside the <code>sum(x)</code>.</p>
<p>If you ever wanted a pure Python approach here's one way using <code>itertools.groupby</code>:</p>
<pre><code>In [63]: def summ_cons(li):
    ...:     for k,g in groupby(li) :
    ...:            if k:
    ...:               s = sum(g)
    ...:               yield s
    ...:               yield from (0 for _ in range(s-1))
    ...:            yield from g
    ...:            


In [65]: list(summ_cons(a))
Out[65]: [0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>using <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">groupby</a></p>
<pre><code>from itertools import groupby
a=[0,0,1,1,1,0,0,0,0,1,1,0,0]
lst_of_tuples=[]
for k,v in groupby(a):
    lst_of_tuples.append((k,len(list(v))))
ans=[]
for k,v in lst_of_tuples:
    temp=[v if k==1 else k]
    for i in range(v-1):
        temp.append(0)
    ans=ans+temp
</code></pre>
<p>output</p>
<pre><code>[0,0,3,0,0,0,0,0,0,2,0,0,0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>TL;DR: this gives you the output you want:</h1>
<pre><code>import itertools

input = [0,0,1,1,1,0,0,0,0,1,1,0,0]   
result = []

for k, g in itertools.groupby(input):
    if k == 1:
        ll = len(list(g))
        result.extend([ll,] + [0 for _ in range(ll-1)])
    else:
        result.extend(list(g)) 
</code></pre>
<p>will give you:</p>
<pre><code>[0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0]
</code></pre>
<h1>explanation:</h1>
<p>itertools has the <code>groupby</code> function to split runs of "the same"</p>
<pre><code>for k, g in itertools.groupby(input):
    print(g, list(k))
</code></pre>
<p>will give you:</p>
<pre><code>0 [0, 0]
1 [1, 1, 1]
0 [0, 0, 0, 0]
1 [1, 1]
0 [0, 0]
</code></pre>
<p>so <code>k</code> is the key, the element in the input sequence and <code>g</code> is the group. </p>
<p>so the if conditions appends either (in case of a 0) the series of 0's from the input, or the length if the run of 1's plus zeros to fill up for the length of the 1-run.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Other option with no dependencies:</strong></p>
<p>The good old <code>while</code> loop accessing by index (sometimes faster than numpy):</p>
<pre><code>def count_same_adjacent_non_zeros(iterable):
  i, x, size = 0, 0, len(iterable)
  while i &lt; size-1:
    if iterable[i] != iterable[i+1]:
      tmp = iterable[x:i+1]
      if not iterable[i] == 0:
        tmp = [len(tmp)] + [0 for _ in range(i-x)]
      for e in tmp: yield e
      x = i + 1
    i += 1
  for e in iterable[x:size]: yield e


print(list(count_same_adjacent_non_zeros(array)))

#=&gt; [0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0]
</code></pre>
<p>It works also with <code>array = [0,0,4,4,4,0,0,0,0,5,5,0,0]</code></p>
</div>
<span class="comment-copy">can you share what you have tried so far?</span>
<span class="comment-copy">Since it's not clear what you have tried, perhaps look into <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">groupby</a>?</span>
<span class="comment-copy">What is the output for a non-adjacent '1', e.g. <code>[0, 1, 0]</code>?  is it <code>[0, 0, 0]</code> or <code>[0, 1, 0]</code>?  Your explanation implies the former, but only indirectly.</span>
<span class="comment-copy">Note that this fails if <code>data</code> ends with a 1.</span>
<span class="comment-copy">It also fails if <code>data</code> begins with <code>1</code>. I think it works if <code>data[0]</code> and <code>data[-1]</code> are the same</span>
<span class="comment-copy">Considering that OP has used <code>numpy</code> and that there are also many similar and better generator/itertools answers here this one is very inefficient. If you want to use <code>itertools</code> or in general Python, there are already better and faster ways to do this.</span>
<span class="comment-copy">@Kasr√¢mvd, Completely agree. I'd advise OP to choose a NumPy alternative should one be offered.</span>
<span class="comment-copy">This produces an array that's shorter than the input array.</span>
<span class="comment-copy">@fuglede Just added that case too</span>
<span class="comment-copy">Your second example is perfect since it works for cases where the array start and end with 0 or 1... this is a great solution....  np.hstack([[x.sum(), *[0]*(len(x) -1)]  if x[0] == 1 else x for x in np.split(a, np.where(np.diff(a) != 0)[0]+1)])</span>
<span class="comment-copy">The output array length does not match the input array length.</span>
<span class="comment-copy">you are right, @fuglede - updated</span>
