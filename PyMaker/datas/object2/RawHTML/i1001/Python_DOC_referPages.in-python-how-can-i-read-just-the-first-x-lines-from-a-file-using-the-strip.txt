<div class="post-text" itemprop="text">
<p>See code below where I try to use 2 different functions to read different parts from a text file (essentially a save file for a game board). The first one tries to read the first 5 lines and assign them to a matrix (list of lists). The second one tries to read the 6th line and assign it to a string. However I can't seem to get the code to work. Any ideas?</p>
<pre><code>def load_board():
    with open("savefile.txt","r") as savefile:
        loadBoard = [line.strip().split(",") for line in savefile]
        return loadBoard

def load_side():
    with open("savefile.txt","r") as savefile:
        loadBoard = [line.strip() for line in savefile]
        loadSide = loadBoard.pop()
        return loadSide
</code></pre>
<p>savefile.txt looks like this:</p>
<pre><code>R,R,R,M,R
R,R,R,R,-
R,R,M,R,R
R,R,R,R,R
M,R,R,R,R
M
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>in both functions you are reading complete file. You need read all lines and then use required lines , see below example:</p>
<pre><code>def load_board():
    with open("savefile.txt","r") as savefile:
        lines = savefile.readlines()
        loadBoard = [line.strip().split(",") for line in lines[:5]]
        loadside = lines[6]
        return loadBoard, loadside
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of opening the file in each function, take an already open file as an argument:</p>
<pre><code>import itertools

# Pre-condition: the input is at the beginning of the file
def load_board(savefile):
    return [line.strip().split(",") for line in itertools.islice(savefile, 5)]


# Pre-condition: the first 5 lines have already been read
def load_side(savefile):
    return next(savefile).strip()
</code></pre>
<p>Then open the file <em>once</em> before calling each function. Note that <code>load_from_file</code> should be used to ensure that <code>load_board</code> and <code>load_side</code> are called in the correct order and with no other reads from <code>savefile</code> to break the pre-conditions.</p>
<pre><code>def load_from_file(fname):
    with open(fname) as savefile:
        board = load_board(savefile)
        side = load_side(savefile)
    return board, side

loadBoard, loadSide = load_from_file("savefile.txt")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>savefile</code> as in code, is a file instance, not a list of lines. Instead, use <code>savefile.readlines()</code> for all the lines. Also, </p>
<pre><code>loadBoard = [line.strip().split(",") for line in savefile.readlines()]
</code></pre>
<p>would give you all 6 lines, not just 5. So <code>loadBoard[-1]</code> would be <code>[M]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not load the file once and then use the output to parse out what you want?</p>
<pre class="lang-py prettyprint-override"><code>def load_save(save_filename):
    with open(save_filename, 'r') as save_file:
        return save_file.read().split('\n')  # Return a list of all lines from the save file

def load_board(save_lines):
    return [line.strip().split(',') for line in save_lines[:5]]  # Won't include last line (side line)

def load_side(save_lines):
    return [save_lines[5:].strip()] # Just the last line
</code></pre>
<p>This can be used like so:</p>
<pre class="lang-py prettyprint-override"><code>save_lines = load_save('savefile.txt')
board = load_board(save_lines)
side = load_side(save_lines)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate</a> over the file object.</p>
<pre><code>def load_board():
    with open("savefile.txt","r") as savefile:
        loadBoard = [line.strip().split(",") for i, line in enumerate(savefile) if i&lt;=4]
        return loadBoard

def load_side():
    with open("savefile.txt","r") as savefile:
        loadBoard = [line.strip() for i, line in enumerate(savefile) if i==5]  #only 6th ( index starts at 0 )
        loadSide = loadBoard.pop()
        return loadSide

print(load_board())
print(load_side())
</code></pre>
<p>Output</p>
<pre><code>[['R', 'R', 'R', 'M', 'R'], ['R', 'R', 'R', 'R', '-'], ['R', 'R', 'M', 'R', 'R'], ['R', 'R', 'R', 'R', 'R'], ['M', 'R', 'R', 'R', 'R']]
M
</code></pre>
</div>
<span class="comment-copy">What are the outputs of both? Do you get any error messages?</span>
<span class="comment-copy">What does itertools do?</span>
<span class="comment-copy">Nothing at the time you saw it :) The edit finally makes use of it.</span>
<span class="comment-copy">Edit: I was missing parenthesis for call to <code>read()</code> in <code>load_save</code></span>
