<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/26910708/merging-dictionary-value-lists-in-python">Merging dictionary value lists in python</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>I have the following two toy dicts</p>
<pre><code>d1 = {
 'a': [2,4,5,6,8,10],
 'b': [1,2,5,6,9,12],
 'c': [0,4,5,8,10,21]
 }
d2 = {
 'a': [12,15],
 'b': [14,16],
 'c': [23,35]
  }
</code></pre>
<p>and I would like get a unique dictionary where I stack the second dictionary values after the first ones, within the same square brackets.</p>
<p>I tried the following code</p>
<pre><code>d_comb = {key:[d1[key], d2[key]] for key in d1}
</code></pre>
<p>but the output I obtain has two lists within a list for each key, i.e.</p>
<pre><code>{'a': [[2, 4, 5, 6, 8, 10], [12, 15]],
 'b': [[1, 2, 5, 6, 9, 12], [14, 16]],
 'c': [[0, 4, 5, 8, 10, 21], [23, 35]]}
</code></pre>
<p>whereas I would like to obtain</p>
<pre><code>{'a': [2, 4, 5, 6, 8, 10, 12, 15],
 'b': [1, 2, 5, 6, 9, 12, 14, 16],
 'c': [0, 4, 5, 8, 10, 21, 23, 35]}
</code></pre>
<p>How can I do that with a line or two of code?</p>
</div>
<div class="post-text" itemprop="text">
<p>You almost had it, instead use <code>+</code> to append both lists:</p>
<pre><code>{key: d1[key] + d2[key] for key in d1}

{'a': [2, 4, 5, 6, 8, 10, 12, 15],
 'b': [1, 2, 5, 6, 9, 12, 14, 16],
 'c': [0, 4, 5, 8, 10, 21, 23, 35]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if not all the keys from <code>d2</code> are in <code>d1</code>, then the simplest thing is using set union and <code>dict.get</code>:</p>
<pre><code>combined_keys = d1.keys() | d2.keys()
d_comb = {key: d1.get(key, []) + d2.get(key, []) for key in combined_keys}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://www.python.org/dev/peps/pep-3132/" rel="noreferrer">extended iterable unpacking</a>:</p>
<pre><code>d1 = {
 'a': [2,4,5,6,8,10],
 'b': [1,2,5,6,9,12],
 'c': [0,4,5,8,10,21]
 }
d2 = {
 'a': [12,15],
 'b': [14,16],
 'c': [23,35]
  }

d_comb = {key:[*d1[key], *d2[key]] for key in d1}

print(d_comb)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>{'c': [0, 4, 5, 8, 10, 21, 23, 35], 'b': [1, 2, 5, 6, 9, 12, 14, 16], 'a': [2, 4, 5, 6, 8, 10, 12, 15]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The code will work irrespective of whether <code>d1</code> or <code>d2</code> have the same set of keys. I have added a key <code>'e'</code> in <code>d1</code> and <code>'d'</code> in <code>d2</code>.</p>
<pre><code>d1 = {'a': [2, 4, 5, 6, 8, 10], 'b': [1, 2, 5, 6, 9, 12], 'c': [0, 4, 5, 8, 10, 21], 'e':[0,0,0]}
d2 = {'a': [12, 15], 'b': [14, 16], 'c': [23, 35], 'd': [13, 3]}

d2_keys_not_in_d1 = d2.keys() - d1.keys()
d1_keys_not_in_d2 = d1.keys() - d2.keys()
common_keys = d2.keys() &amp; d1.keys()

for i in common_keys:
    d[i]=d1[i]+d2[i]
for i in d1_keys_not_in_d2:
    d[i]=d1[i]
for i in d2_keys_not_in_d1:
    d[i]=d2[i]
d
{'a': [2, 4, 5, 6, 8, 10, 12, 15],
 'b': [1, 2, 5, 6, 9, 12, 14, 16],
 'c': [0, 4, 5, 8, 10, 21, 23, 35],
 'd': [13, 3],
 'e': [0, 0, 0]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain</code></a> to efficiently construct a single list from input lists:</p>
<pre><code>from itertools import chain
d_comb = {key: list(chain(d1[key], d2[key])) for key in d1}
</code></pre>
<p>For the more general case covering an arbitrary number of dictionaries and keys which are not equal across dictionaries, see <a href="https://stackoverflow.com/a/54108746/9209546">Merging dictionary value lists in python</a>.</p>
</div>
<span class="comment-copy">Are we sure that both <code>d1</code> and <code>d2</code> have same set of keys?</span>
<span class="comment-copy">In this example and according to my present needs, yes.  Of course I'm sure that with different sets of keys in the two dictionaries the code will be different.</span>
<span class="comment-copy">Damn, it was the plus sign, not the comma.. I knew it was easy but it didn't come to mind! Thanks</span>
<span class="comment-copy">this fails if there are keys in <code>d1</code> that are not in <code>d2</code>, and <code>d2_keys_not_in_d1 </code> can be expressed simpler as <code>d2.keys() - d1.keys()</code></span>
<span class="comment-copy">Thanks Maarten for your feedback. Very appreciated. I have changed the code accordingly and used your expression, which was lot more succinct never the less.</span>
<span class="comment-copy">the common keys can be expressed as ` d2.keys() &amp; d1.keys()`</span>
<span class="comment-copy">Thanks a lot Maarten. Very helpful. I have learnt something :)</span>
