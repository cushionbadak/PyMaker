<div class="post-text" itemprop="text">
<p>I'm trying to merge three dictionaries, which all have the same keys, and either lists of values, or single values.</p>
<pre><code>one={'a': [1, 2], 'c': [5, 6], 'b': [3, 4]}
two={'a': [2.4, 3.4], 'c': [5.6, 7.6], 'b': [3.5, 4.5]}
three={'a': 1.2, 'c': 3.4, 'b': 2.3}
</code></pre>
<p>What I need is for all the items in the values to be added to one list.</p>
<pre><code>result={'a': [1, 2, 2.4, 3.4, 1.2], 'c': [5, 6, 5.6, 7.6, 2.3], 'b': [3, 4, 3.5, 4.5, 3.4]}
</code></pre>
<p>I have tried several things, but most put the values into nested lists. 
E.g.</p>
<pre><code>out=dict((k, [one[k], two.get(k), three.get(k)]) for k in one)
{'a': [[1, 2], [2.4, 3.4], 1.2], 'c': [[5, 6], [5.6, 7.6], 3.4], 'b': [[3, 4], [3.5, 4.5], 2.3]}
</code></pre>
<p>I tried updating it by looping through the values:</p>
<pre><code>out.update((k, [x for x in v]) for k,v in out.iteritems())
</code></pre>
<p>but the results was exactly the same.
I have tried to simply add the lists, but because the third dictionary has only a float, I couldn't do it. </p>
<pre><code>check=dict((k, [one[k]+two[k]+three[k]]) for k in one)
</code></pre>
<p>So I tried to first add the lists in values of one and two, and then append the value of three. Adding the lists worked well, but then when I tried to append the float from the third dictionary, suddenly the whole value went to 'None'</p>
<pre><code>check=dict((k, [one[k]+two[k]]) for k in one)
{'a': [[1, 2, 2.4, 3.4]], 'c': [[5, 6, 5.6, 7.6]], 'b': [[3, 4, 3.5, 4.5]]}
new=dict((k, v.append(three[k])) for k,v in check.items())
{'a': None, 'c': None, 'b': None}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As a one-liner, with a dictionary comprehension:</p>
<pre><code>new = {key: value + two[key] + [three[key]] for key, value in one.iteritems()}
</code></pre>
<p>This creates new lists, concatenating the list from <code>one</code> with the corresponding list from <code>two</code>, putting the single value in <code>three</code> into a temporary list to make concatenating easier.</p>
<p>Or with a <code>for</code> loop updating <code>one</code> in-place:</p>
<pre><code>for key, value in one.iteritems():
    value.extend(two[key])
    value.append(three[key])
</code></pre>
<p>This uses <code>list.extend()</code> to update original list in-place with the list from <code>two</code>, and <code>list.append()</code> to add the single value from <code>three</code>.</p>
<p>Where you went wrong:</p>
<ul>
<li><p>your first attempt creates a new list with the values from <code>one</code>, <code>two</code> and <code>three</code> nested within rather than concatenating the existing lists. Your attempt to clean that up just copied those nested lists across.</p></li>
<li><p>Your second attempt didn't work because the value in <code>three</code> is not a list so could not be concatenated. I created a new list just for that one value.</p></li>
<li><p>Your last attempt should not have used <code>list.append()</code> in a generator expression, because you store the <em>return value</em> of that method, which is always <code>None</code> (its change is stored in <code>v</code> directly and the list doesn't need returning again).</p></li>
</ul>
<p>Demo of the first approach:</p>
<pre><code>&gt;&gt;&gt; one={'a': [1, 2], 'c': [5, 6], 'b': [3, 4]}
&gt;&gt;&gt; two={'a': [2.4, 3.4], 'c': [5.6, 7.6], 'b': [3.5, 4.5]}
&gt;&gt;&gt; three={'a': 1.2, 'c': 3.4, 'b': 2.3}
&gt;&gt;&gt; {key: value + two[key] + [three[key]] for key, value in one.iteritems()}
{'a': [1, 2, 2.4, 3.4, 1.2], 'c': [5, 6, 5.6, 7.6, 3.4], 'b': [3, 4, 3.5, 4.5, 2.3]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Arbitrary dictionary number and keys</h3>
<p>The issues with your attempt are covered by <a href="https://stackoverflow.com/a/26910761/9209546">@MartijnPieters' solution</a>.</p>
<p>For a <em>generalised</em> solution, consider using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain</code></a> to chain multiple dictionaries. You can also use a <a href="https://docs.python.org/3.7/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> for the more general case where you do not find the same keys in each dictionary.</p>
<pre><code>from collections import defaultdict
from itertools import chain
from operator import methodcaller

# dictionaries with non-equal keys, values all lists for simplicity
one = {'a': [1, 2], 'c': [5, 6], 'b': [3, 4], 'e': [6.2]}
two = {'a': [2.4, 3.4], 'c': [5.6, 7.6], 'b': [3.5, 4.5], 'f': [1.3]}
three = {'a': [1.2], 'c': [3.4], 'b': [2.3], 'e': [3.1]}

# initialise defaultdict of lists
dd = defaultdict(list)

# iterate dictionary items
dict_items = map(methodcaller('items'), (one, two, three))
for k, v in chain.from_iterable(dict_items):
    dd[k].extend(v)

print(dd)

# defaultdict(list,
#             {'a': [1, 2, 2.4, 3.4, 1.2],
#              'b': [3, 4, 3.5, 4.5, 2.3],
#              'c': [5, 6, 5.6, 7.6, 3.4],
#              'e': [6.2, 3.1],
#              'f': [1.3]})
</code></pre>
<p>Note <code>defaultdict</code> is a subclass of <code>dict</code> so there's generally no need to convert the result to a regular <code>dict</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>See this help or not:  </p>
<pre><code>&gt;&gt;&gt; dic={}
&gt;&gt;&gt; k=[]
&gt;&gt;&gt; for i in 'abc':
    k=one[i]+two[i]
    k.append(three[i])
    dic[i]=k


&gt;&gt;&gt; dic
{'c': [5, 6, 5.6, 7.6, 3.4], 'a': [1, 2, 2.4, 3.4, 1.2], 'b': [3, 4, 3.5, 4.5, 2.3]}
</code></pre>
</div>
<span class="comment-copy">Thank you very much! It works perfectly of course! Double thanks for the explanation, very helpful!</span>
<span class="comment-copy">I'm working on a similar problem and this was <i>very</i> helpful.</span>
