<div class="post-text" itemprop="text">
<p>I'm trying to use <code>queue.PriorityQueue</code> in Python 3(.6).</p>
<p>I would like to store objects with a given priority.  But if two objects have the same priority, I don't mind <code>PriorityQueue.get</code> to return either.  In other words, my objects can't be compared at integers, it won't make sense to allow them to be, I just care about the priority.</p>
<p>In <a href="https://docs.python.org/3.7/library/queue.html" rel="nofollow noreferrer">Python 3.7's documentation</a>, there's a solution involving <code>dataclasses</code>.  And I quote:</p>
<blockquote>
<p>If the data elements are not comparable, the data can be wrapped in a class that ignores the data item and only compares the priority number:</p>
</blockquote>
<pre><code>from dataclasses import dataclass, field
from typing import Any

@dataclass(order=True)
class PrioritizedItem:
    priority: int
    item: Any=field(compare=False)
</code></pre>
<p>Alas, I'm using Python 3.6.  In <a href="https://docs.python.org/3.6/library/queue.html" rel="nofollow noreferrer">the documentation of this version of Python</a>, there's no comment on using <code>PriorityQueue</code> for the priorities, not bothering about the "object value" which wouldn't be logical in my case.</p>
<p>Is there a better way than to define <code>__le__</code> and other comparison methods on my custom class?  I find this solution particularly ugly and counter-intuitive, but that might be me.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>dataclasses</code> is just a convenience method to avoid having to create a lot of boilerplate code.</p>
<p>You don't actually <em>have</em> to create a class. A tuple with a unique counter value too:</p>
<pre><code>from itertools import count

unique = count()

q.put((priority, next(unique), item))
</code></pre>
<p>so that ties between equal priority are broken by the integer that follows; because it is always unique the <code>item</code> value is never consulted.</p>
<p>You can also create a class using straight-up rich comparison methods, made simpler with <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow noreferrer"><code>@functools.total_ordering</code></a>:</p>
<pre><code>from functools import total_ordering

@total_ordering
class PrioritizedItem:
    def __init__(self, priority, item):
        self.priority = priority
        self.item = item

    def __eq__(self, other):
        if not isinstance(other, __class__):
            return NotImplemented
        return self.priority == other.priority

    def __lt__(self, other):
        if not isinstance(other, __class__):
            return NotImplemented
        return self.priority &lt; other.priority
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See <a href="https://docs.python.org/3.7/library/heapq.html#priority-queue-implementation-notes" rel="nofollow noreferrer">priority queue implementation notes</a> - just before the section you quoted (regarding using <code>dataclasses</code>) it tells you how to do it <em>whitout</em> them:</p>
<blockquote>
<p>... is to store entries as 3-element list including the priority, an entry count, and the task. The entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were added. And since no two entry counts are the same, the tuple comparison will never attempt to directly compare two tasks.</p>
</blockquote>
<p>So simply add your items as <em>3rd</em> element in a tuple <code>(Prio, Count, YourElem)</code> when adding to your queue. </p>
<p>Contreived example:</p>
<pre><code>from queue import PriorityQueue

class CompareError(ValueError): pass

class O:
    def __init__(self,n):
        self.n = n

    def __lq__(self):
        raise CompareError

    def __repr__(self): return str(self)
    def __str__(self): return self.n

def add(prioqueue,prio,item):
    """Adds the 'item' with 'prio' to the 'priorqueue' adding a unique value that
    is stored as member of this method 'add.n' which is incremented on each usage."""
    prioqueue.put( (prio, add.n, item))
    add.n += 1

# no len() on PrioQueue - we ensure our unique integer via method-param
# if you forget to declare this, you get an AttributeError
add.n = 0

h = PriorityQueue()

add(h, 7, O('release product'))
add(h, 1, O('write spec 3'))
add(h, 1, O('write spec 2'))
add(h, 1, O('write spec 1'))
add(h, 3, O('create tests'))

for _ in range(4):
    item = h.get()
    print(item)
</code></pre>
<p>Using <code>h.put( (1, O('write spec 1')) )</code>  leads to </p>
<pre><code>TypeError: '&lt;' not supported between instances of 'O' and 'int'`
</code></pre>
<p>Using <code>def add(prioqueue,prio,item):</code> pushes triplets as items wich have guaranteed distinct 2nd values so our <code>O()</code>-instances are never used as tie-breaker.</p>
<p>Output:</p>
<pre><code>(1, 2, write spec 3)
(1, 3, write spec 2)
(1, 4, write spec 1)
(3, 5, create tests)
</code></pre>
<hr/>
<p>see <a href="https://stackoverflow.com/users/100297/martijn-pieters">MartijnPieters</a> answer <a href="https://stackoverflow.com/a/54028394/7505395">@here</a> for a nicer unique 2nd element.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's assume that we don't want to write a decorator with equivalent functionality to <code>dataclass</code>. The problem is that we don't want to have to define <strong>all</strong> of the comparison operators in order to make our custom class comparable based on priority. The <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow noreferrer"><code>@functools.total_ordering</code></a> decorator can help. Excerpt:</p>
<blockquote>
<p>Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations:</p>
<p>The class must define one of <code>__lt__()</code>, <code>__le__()</code>, <code>__gt__()</code>, or <code>__ge__()</code>. In addition, the class should supply an <code>__eq__()</code> method.</p>
</blockquote>
<p>Using the provided example:</p>
<pre><code>from functools import total_ordering

@total_ordering
class PrioritizedItem:
    # ...

    def __eq__(self, other):
        return self.priority == other.priority

    def __lt__(self, other):
        return self.priority &lt; other.priority
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All you need is a wrapper class that implements <code>__lt__</code> in order for <code>PriorityQueue</code> to work correctly. This is noted <a href="https://docs.python.org/3/howto/sorting.html#odd-and-ends" rel="nofollow noreferrer">here</a>:</p>
<blockquote>
<p>The sort routines are guaranteed to use <code>__lt__()</code> when making comparisons between two objects. So, it is easy to add a standard sort order to a class by defining an <code>__lt__()</code> method</p>
</blockquote>
<p>It's as simple as something like this</p>
<pre><code>class PriorityElem:
    def __init__(self, elem_to_wrap):
        self.wrapped_elem = elem_to_wrap

    def __lt__(self, other):
        return self.wrapped_elem.priority &lt; other.wrapped_elem.priority
</code></pre>
<p>If your elements do not have priorities then it's as simple as:</p>
<pre><code>class PriorityElem:
    def __init__(self, elem_to_wrap, priority):
        self.wrapped_elem = elem_to_wrap
        self.priority = other.priority

    def __lt__(self, other):
        return self.priority &lt;  other.priority
</code></pre>
<p>Now you can use <code>PriorityQueue</code> like so</p>
<pre><code>queue = PriorityQueue()
queue.put(PriorityElem(my_custom_class1, 10))
queue.put(PriorityElem(my_custom_class2, 10))
queue.put(PriorityElem(my_custom_class3, 30))

first_returned_elem = queue.get()
# first_returned_elem is PriorityElem(my_custom_class1, 10)
second_returned_elem = queue.get()
# second_returned_elem is PriorityElem(my_custom_class2, 10)
third_returned_elem = queue.get()
# third_returned_elem is PriorityElem(my_custom_class3, 30)
</code></pre>
<p>Getting at your original elements in that case would be as simple as </p>
<pre><code>elem = queue.get().wrapped_elem
</code></pre>
<p>Since you don't care about sort stability that's all you need.</p>
<p>Edit: As noted in the comments and <a href="https://docs.python.org/3.7/library/heapq.html#basic-examples" rel="nofollow noreferrer">confirmed here</a>, <code>heappush</code> is not stable: </p>
<blockquote>
<p>unlike sorted(), this implementation is not stable.</p>
</blockquote>
</div>
<span class="comment-copy">Do your objects actually throw an exception if you compare them to each other?  If not, then there's nothing to worry about.</span>
<span class="comment-copy">@jasonharper just because two objects compare without an error being thrown does not mean that the objects are sorting in a reasonable order. Look at this question: <a href="https://stackoverflow.com/questions/6252758/python-default-comparison" title="python default comparison">stackoverflow.com/questions/6252758/python-default-comparison</a></span>
<span class="comment-copy">very elegant way to get the distinguishing element</span>
<span class="comment-copy">I really like the <code>counter()</code> solution.  It has the advantage of avoiding to create a class (some lines of code, but not much) and the added benefit that it doesn't require to create instances just for the priority counter.  This is a performance issue and probably a very minor issue except when dealing with millions of objects, but I still find this solution more elegant.  Thanks!</span>
<span class="comment-copy">Note that your handling of the counter is not thread-safe; the <code>queue</code> module is explicitly thread-safe (I personally use the <code>heapq</code> module directly when thread-safety is not required), so this not being thread-safe could be a big issue.</span>
<span class="comment-copy">Why are you delving into <code>heappush</code> when this question is specifically about using <code>queue.PriorityQueue</code>?</span>
<span class="comment-copy">@NickChapman  I what? heappush? where?  :o) thanks for hinting my blunder</span>
<span class="comment-copy">Thanks a lot, I find this solution much more elegant and optimized.  A <code>Counter</code> object actually allows to reduce the boiler-plate code even more.  That proves: I don't read the documentation right!</span>
<span class="comment-copy">@vincent-lg well, that documentation is part of the <code>heapq</code> module. It so happens that <code>queue.PriorityQueue</code> is implemented on top op <code>heapq</code>, but it takes some thorough reading to get from the <code>queue</code> documentation to that advice in the <code>heapq</code> module docs.</span>
<span class="comment-copy">@MartijnPieters heapq is referenced on top of the site that he quoted from:  <code>With a priority queue, the entries are kept sorted (using the heapq module) and the lowest valued entry is retrieved first</code> thats why I landed there</span>
<span class="comment-copy">you only need <code>__lt__</code> in order to sort so you don't even need to worry about generating the rest of the rich comparison operators.</span>
<span class="comment-copy">@NickChapman: <code>list.sort</code> promises to only use <code>&lt;</code>, but the fact that <code>heapq</code> or <code>queue.PriorityQueue</code> only use <code>&lt;</code> is an implementation detail. Also, relying on <code>&lt;</code>-only comparisons is a recipe for weird surprises anyway. It's best to provide all comparison operations.</span>
<span class="comment-copy">Also, you should really return <code>NotImplemented</code> when <code>other</code> is of an unrecognized type instead of just unconditionally accessing <code>other.priority</code>.</span>
<span class="comment-copy">@user2357112 can you explain why it should be that way? Also wouldn't a <code>TypeError</code> be more appropriate?</span>
<span class="comment-copy">@ChrisHunt: Explicit type checking. In this kind of situation, you usually care about the actual type, not what attributes the argument has.</span>
<span class="comment-copy"><code>list.sort</code> and <code>sorted</code> may be stable, but <code>queue.PriorityQueue</code> is based on a heap, and the heap implementation isn't stable.</span>
<span class="comment-copy">The current <code>heapq</code> implementation indeed only uses <code>&lt;</code> to make comparisons, but this is an <i>implementation detail</i>. I'd not rely on such details and instead provide more comparison methods.</span>
<span class="comment-copy">@MartijnPieters if it is an implementation detail then we should create an issue against the documentation excerpted in the post which guarantees that it will only use <code>__lt__()</code>.</span>
<span class="comment-copy">@ChrisHunt: a priority queue <b>doesn't sort</b>. It is built using the <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer"><code>heapq</code></a> module, it's a binary tree stored in a list.</span>
<span class="comment-copy">Also see <a href="//stackoverflow.com/a/8796908">Is it safe to just implement __lt__ for a class that will be sorted?</a>, where Raymond Hettinger points out you should not really only on <code>__lt__</code>. I'll look at why the HOWTO still claims <code>__lt__</code> is enough, because no other Python documentation page makes the same claim.</span>
