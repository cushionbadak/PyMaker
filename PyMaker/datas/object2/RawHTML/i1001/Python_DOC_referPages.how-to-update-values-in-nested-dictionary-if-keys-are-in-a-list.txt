<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/14692690/access-nested-dictionary-items-via-a-list-of-keys">Access nested dictionary items via a list of keys?</a>
<span class="question-originals-answer-count">
                    14 answers
                </span>
</li>
</ul>
</div>
<p>Let's say i have a list of keys</p>
<pre><code>key_lst = ["key1", "key2", "key3"]
</code></pre>
<p>and i have a value</p>
<pre><code>value = "my_value"
</code></pre>
<p>and an example dict <code>my_dict</code> with this structure</p>
<pre><code>{
"key1": {
    "key2": {
        "key3": "some_value"
        }
    },
}
</code></pre>
<p>How can i dynamically assign the new value in variable <code>value</code> to <code>my_dict["key1"]["key2"]["key3"]</code> by going thru / looping over my <code>key_lst</code>?</p>
<p>I can not just say <code>my_dict["key1"]["key2"]["key3"] = value</code> since the keys and the number of keys is changing. I always get the keys (the path that i have to save the value at) in a list...</p>
<p>I'm using Python 3.7</p>
</div>
<div class="post-text" itemprop="text">
<h3>Predefined dictionary structure: <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a></h3>
<p>You can define a function using <code>functools.reduce</code> to apply <code>getitem</code> repeatedly and then set a supplied value:</p>
<pre><code>from functools import reduce
from operator import getitem

def set_nested_item(dataDict, mapList, val):
    """Set item in nested dictionary"""
    reduce(getitem, mapList[:-1], dataDict)[mapList[-1]] = val
    return dataDict

key_lst = ["key1", "key2", "key3"]
value = "my_value"
d = {"key1": {"key2": {"key3": "some_value"}}}

d = set_nested_item(d, key_lst, value)

print(d)
# {'key1': {'key2': {'key3': 'my_value'}}}
</code></pre>
<p>Note <code>operator.getitem</code> is used to access <code>dict.__getitem__</code>, or its more commonly used syntactic sugar <code>dict[]</code>. In this instance, <code>functools.reduce</code> calls <code>getitem</code> recursively on <code>dataDict</code>, successively using each value in <code>mapList[:-1]</code> as an argument. With <code>[:-1]</code>, we intentionally leave out the last value, so we can use <code>__setitem__</code> via <code>dict[key] = value</code> for the final key.</p>
<hr/>
<h3>Arbitrary dictionary nesting: <a href="https://docs.python.org/3.7/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a></h3>
<p>If you wish to add items at arbitrary branches not yet been defined, you can construct a <code>defaultdict</code>. For this, you can first <a href="https://stackoverflow.com/a/50013806/9209546"><code>defaultify</code></a> your regular dictionary input, then use <code>set_nested_item</code> as before:</p>
<pre><code>from collections import defaultdict

def dd_rec():
    return defaultdict(dd_rec)

def defaultify(d):
    if not isinstance(d, dict):
        return d
    return defaultdict(dd_rec, {k: defaultify(v) for k, v in d.items()})

dd = defaultify(d)

key_lst = ["key1", "key2", "key5", "key6"]
value = "my_value2"
dd = set_nested_item(dd, key_lst, value)

print(dd)

# defaultdict(&lt;function __main__.&lt;lambda&gt;&gt;,
#             {'key1': defaultdict(&lt;function __main__.&lt;lambda&gt;&gt;,
#                          {'key2': defaultdict(&lt;function __main__.&lt;lambda&gt;&gt;,
#                                       {'key3': 'my_value',
#                                        'key5': defaultdict(&lt;function __main__.&lt;lambda&gt;&gt;,
#                                                    {'key6': 'my_value2'})})})})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can iteratively build/access levels using <code>setdefault</code> in a loop:</p>
<pre><code>d = {}
d2 = d
for k in key_lst[:-1]:
    d2 = d2.setdefault(k, {})

d2[key_lst[-1]] = value
print(d)
# {'key1': {'key2': {'key3': 'my_value'}}}
</code></pre>
<p><code>d</code> is the reference to your dictionary, and <code>d2</code> is a throw-away reference that accesses inner levels at each iteration.</p>
</div>
<div class="post-text" itemprop="text">
<p>I guess you can loop through your keys like this :</p>
<pre><code>d = {}
a = d
for i in key_lst: 
    a[i] = {}
    if i == key_lst[-1]:
        a[i] = value
    else:
        a = a[i]
print(d)
# {'key1': {'key2': {'key3': 'my_value'}}}
</code></pre>
<p>Edit: I guess I misread the question and answered as if the dictionnary wasn't already existing. <a href="https://stackoverflow.com/a/54138200/5050917">jpp answer</a> is pretty neat otherwise I guess!</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what you want:</p>
<pre><code>def update(d, key_lst , val):
    for k in key_lst[:-1]:
        if k not in d:
            d[k] = {}
        d = d[k]
    d[key_lst[-1]] = val

d = {}

update(d, list('qwer'), 0)
# d = {'q': {'w': {'e': {'r': 0}}}}
</code></pre>
<p>You could use <code>defaultdict</code> too, it's neat in a sense but prints rather ugly...:</p>
<pre><code>from collections import defaultdict

nest = lambda: defaultdict(nest)
d = nest()

def update(d, key_lst , val):
    for k in key_lst[:-1]:
        d = d[k]
    d[key_lst[-1]] = val

update(d, 'qwer', 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>key_lst = ["key1", "key2", "key3"]
my_dict={
"key1": {
    "key2": {
        "key3": "some_value"
        }
    },
}

val=my_dict
#loop gets second to last key in chain(path) and assigns it to val
for x in key_lst[:-1]:
    val=val[x]
#now we can update value of last key, cause dictionary key is passed by reference
val[key_lst[-1]]="new value"

print (my_dict)

#{'key1': {'key2': {'key3': 'new value'}}}
</code></pre>
</div>
<span class="comment-copy">Use a for loop?</span>
<span class="comment-copy">what is the output you want?</span>
<span class="comment-copy">@Julien: did you try it? It's not as easy as you think :-)</span>
<span class="comment-copy">@Jundullah: I want to save the value in the dict</span>
<span class="comment-copy">@Endogen it's not as hard as you think either :)</span>
<span class="comment-copy">This is a pretty cool answer. Mind explaining a bit more on your <code>set_nested_item</code> function for me?</span>
<span class="comment-copy">But this assumes the particular structure already exists. What about setting new values? You will need a defaultdict, right? This cannot handle KeyErrors as it is.</span>
<span class="comment-copy">@hqkhan, Added an explanation.</span>
<span class="comment-copy">@coldspeed, Agreed, this doesn't handle <code>KeyError</code>. That said, not sure whether this is relevant for OP's requirements. For example, it's conceivable that the dictionary structure is <i>given</i> and you only want to set values; hence <code>KeyError</code> is what you <i>want</i>.</span>
<span class="comment-copy">JESUS CHRIST! That's a nice solution. Dict structure is actually given and i would expect a <code>KeyError</code> if the key is not in there. BTW: Not a requirement but this is more than three times faster than @coldspeed's answer. This is the one, thanks.</span>
<span class="comment-copy">Yes works perfectly. Awesome.</span>
<span class="comment-copy">@Julien what is half broken?</span>
<span class="comment-copy">@Julien thats right thanks, but i can't see possibility of non existing key in question</span>
<span class="comment-copy">I take that back. OP has clarified the dict structure is given in a comment to another answer... (wasn't the downvoter in the first place but upvoted to balance out :)</span>
<span class="comment-copy">@Julien thanks, i was thinking to delete my answer,you know i'm new and i was late to submit this answer and didn't know there's similar answer. next time i'll submit carefully :)</span>
<span class="comment-copy">Please add some comments around it explaining why this is an answer, and/or what problem this code solves.</span>
