<div class="post-text" itemprop="text">
<p>I am trying to put in a sum within some modeling in Python. The mathematical formula is:</p>
<blockquote>
<p>sum(f_i*c_i) for i=1 until i=5</p>
</blockquote>
<p>How can I put in that sum in Python without typing in every single term? I defined <code>f1</code> to <code>f5</code> and <code>c1</code> to <code>c5</code> before.</p>
</div>
<div class="post-text" itemprop="text">
<p>The variable name <code>f_i</code> doesn't become the variable name <code>f1</code> just because it is in the vicinity of a definition of another variable called <code>i</code>. What you want to do is compute the name of the variable based on the value of <code>i</code>. The way to do that in Python is to use a list:</p>
<pre><code>f = [1,2,3,4,5]
c = [2,4,6,8,10]
</code></pre>
<p>After you have done this, <code>f[1]</code> (not <code>f1</code>) has the value 2 (and not 1, because list indexes are zero based).</p>
<p>Then you can do </p>
<pre><code>sum(f[i] * c[i] for i in range(5))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to do a summation of many variables is to store them in a <code>list</code> and loop over the list using a for-loop. I assume you have all the <code>c</code> and <code>f</code> variables declared.</p>
<pre><code>c_numbers = [c1, c2, c3, c4, c5]
f_numbers = [f1, f2, f3, f4, f5]

result = 0
for i in range(len(c_numbers)):
  result += c_numbers[i]*f_numbers[i]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Creating lists beforehand seems to be what you need to do.</p>
<pre><code>f = [1,2,3,4]
c = [3,4,5,6]
my_sum = 0

for i in range(5):
        my_sum = my_sum+f[i]*c[i]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want the freedom of changing the intervals between f and c (e.g. <code>f[1:5]</code> and <code>c[5:9]</code>) you can use zipped slices. Keep in mind that iterables are zero-indexed in Python and that a slice contains the starting point but not the ending point. As such <code>f[1:5]</code> contains four items, starting from index <code>1</code>.</p>
<pre><code>f = [1,2,3,4,5,6,7,8,9]
c = [10,11,12,13,14,15,16,17,18,19]

print(sum([i*j for i, j in zip(f[1:5], c[1:5])]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In general, it's a common rookie idea that you can have an index in the variable name. This actually causes more problems than it's worth, since variable names are strings. Aside from the relative difficulty of accessing variables by dynamically generated names, you have things like <code>a_2</code> coming after <code>a_10</code> and having to decide if the variable name is <code>a_10</code> or <code>a_0010</code>.</p>
<p>To that end you have a data structure called a list, which allows you to access elements using an actual integer froma single location. You could store your numbers in a pair of lists:</p>
<pre><code>c = [1, 2, 3, 4, 5]
f = [0.1, 0.3, 0.2, 0.5, 0.4]
</code></pre>
<p>Now you can access the data <code>c[0]</code>, ..., <code>c[4]</code>, rather than <code>c_1</code>, ..., <code>c_5</code>. The index is zero-based.</p>
<p>If your data are always paired like that, you could also choose to reflect that in the structure. Instead of having two lists, you could choose to have a single list of two-tuples:</p>
<pre><code>cf = [(1, 0.1), (2, 0.3), (3, 0.2), (4, 0.5), (5, 0.4)]
</code></pre>
<p>Now what you called <code>c_1</code> before will be the first element of the first tuple: <code>cf[0][0]</code>. Similarly, <code>f_5</code> will be the second element of the last tuple: <code>cf[4][1]</code>.</p>
<p>The sum of products you are trying to compute can be computed from either arrangement of the data:</p>
<pre><code>sum(i * j for i, j in zip(f, c))
</code></pre>
<p>OR</p>
<pre><code>sum(i * j for i, j in fc)
</code></pre>
<p>The expression that we pass to <code>sum</code> is called a generator expression. It would normally be enclosed in parentheses, except when it is the sole argument to a function. The expression will lazily yield the computed product from each element pair.</p>
<p>If you are doing lots of data analysis, you may want to look into Python's computational libraries. The most fundamental one of these is numpy, which allows you to store data in densely packed arrays and perform fast vectorized operations on them.</p>
<p>To convert a list into an array:</p>
<pre><code> f = np.array(f)
 c = np.array(c)
</code></pre>
<p>The sum of products is now just a for product:</p>
<pre><code>c.dot(f)
</code></pre>
<p>Or you could compute it "manually":</p>
<pre><code>(c * f).sum()
</code></pre>
<p>Alternatively, you could do</p>
<pre><code>fc = np.array(fc)
</code></pre>
<p><code>fc</code> will now be a matrix of two columns, so you can do something like:</p>
<pre><code>fc[:, 0].dot(fc[:, 1])
</code></pre>
<p>OR</p>
<pre><code>fc.prod(axis=1).sum()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Apart from using lists, if you have a large dataset, you can also make use of NumPy arrays which allow an element wise multiplication simply using the multiplication operator <code>*</code>. Then you can sum the values using <code>np.sum</code>. Below is an example using a small dataset. </p>
<pre><code>import numpy as np

a = np.array([1,2,3,4,5])
b = np.array([10, 11, 12, 13, 14])

total = np.sum(a*b)

# 190
</code></pre>
<p>As suggested by <a href="https://stackoverflow.com/users/2988730/mad-physicist">@Mad Physicist</a>, what you want it basically the dot product. So you can also do, </p>
<pre><code>a.dot(b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A "pythonic" way to do it would be to use the built-in <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> and <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer"><code>sum()</code></a> functions to produce pairs of each term and calculate the total.</p>
<pre><code>f1, f2, f3, f4, f5 = 1, 2, 3, 4, 5
c1, c2, c3, c4, c5 = 6, 7, 8, 9, 10

f = [f1, f2, f3, f4, f5]
c = [c1, c2, c3, c4, c5]

print( sum(fi * ci for fi, ci in zip(f, c)) )  # -&gt; 130
</code></pre>
<p>Obviously it would be more concise to have the data stored directly in the two lists if feasible:</p>
<pre><code>f = [1, 2, 3, 4, 5]
c = [6, 7, 8, 9, 10]
</code></pre>
</div>
<span class="comment-copy">Instead of defining <code>fn, cn</code> as separate variables, add them to lists. You can then use <code>sum</code> and <code>zip</code>  to iterate over them in pairs.</span>
<span class="comment-copy">Don't create separate variables. Use lists, so you can easily reference individual values (using indexing or iteration).</span>
<span class="comment-copy">Basically just <code>sum(f[i]*c[i]) for i in range(5))</code>, provided that <code>f</code> and <code>c</code> are lists of 5 elements. Or <code>sum(fi*ci for fi, ci in zip(f, c))</code></span>
<span class="comment-copy">Did you try to run this code and see if it even works?</span>
<span class="comment-copy">nope... I forgot to check. added the indexes</span>
<span class="comment-copy">A piece of advice: Avoid using in-built functions and the variable names</span>
<span class="comment-copy"><code>f[1:5]</code> will contain only 4 elements.</span>
<span class="comment-copy">@tobias_k I know, that was the point. I am unsure whether OP intended an inclusive or exclusive approach but I'm sure they can figure out how to adjust the slice.</span>
<span class="comment-copy">Why unsure? Mathematical sum notation <i>always</i> includes the limits. So sum over [:5] (which changes the indices from 1..5 to 0..4), or sum over 1..5 by ending the range on 6.</span>
<span class="comment-copy">I guess this discussion is irrelevant. Just include a line in your answer that 1:5 means 4 elements and [1:6] means 5 elements and 0 is the first index and 1 is the second index. That way all are happy. The OP can decide for himself/herself what he/she actually needs</span>
<span class="comment-copy">Why not <code>a.dot(b)</code>? Downvote not mine, but it's unlikely that you will get a meaningful response from a downvoter that doesn't want to leave one.</span>
<span class="comment-copy">@MadPhysicist: Great suggestion. I will add it :) Thanks</span>
