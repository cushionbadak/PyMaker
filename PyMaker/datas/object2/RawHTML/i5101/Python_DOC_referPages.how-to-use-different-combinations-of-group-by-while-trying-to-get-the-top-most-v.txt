<div class="post-text" itemprop="text">
<p>Am trying to get the top most rating using groupby of multiple columns and if there is no combination of that particular groupby, its throwing me an error . how to do multiple combinations ?</p>
<p>data : </p>
<pre><code>maritalstatus   gender age_range occ    rating
ma                 M    young   student  PG
ma                 F    adult   teacher  R
sin                M    young   student  PG
sin                M    adult   teacher  R
ma                 M    young   student  PG
sin                F    adult   teacher  R
</code></pre>
<p>code : </p>
<pre><code>def get_top( maritalstatus, gender,age_range, occ):        
    m = df.groupby(['maritalstatus',' gender', 'age_range', 'occ'])
    ['rating'].apply(lambda x: x.value_counts().index[0 ])      
    mpaa = m[maritalstatus][gender][age_range][occ]    
    return mpaa
</code></pre>
<p>input : </p>
<pre><code>get_top('ma', 'M', 'young','teacher)
</code></pre>
<p>output: 
    throws me an error as there is no such combination.</p>
<p>Here if there is no such combination my function should limit to, married, male and young and not teacher as there is no such combination.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is one non-pandas solution. <code>Counter.most_common()</code> orders results by most common descending counts.</p>
<pre><code>from collections import Counter

def get_top(maritalstatus=None, gender=None, age_range=None, occ=None):

    cols = ['maritalstatus', 'gender', 'age_range', 'occ']
    values = [maritalstatus, gender, age_range, occ]

    c = Counter(df.query(' &amp; '.join((('({0} ==  "{1}")').format(i, j)) \
                for i, j in zip(cols, values) if j))['rating'])

    return c.most_common()

get_top(maritalstatus='ma', gender='M', age_range='young')  # [('PG', 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://stackoverflow.com/q/36901/2901002"><code>*args</code></a> for dynamic input, (ordering of values cannot be changed)  with <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.query.html" rel="nofollow noreferrer"><code>query</code></a> for filtering:</p>
<pre><code>def get_top(*args):     
    c = ['maritalstatus', 'gender', 'age_range', 'occ']
    m = (df.groupby(c)['rating'].apply(lambda x: x.value_counts().index[0])
           .reset_index())
    args = list(args)
    while True:
        d = dict(zip(c, args))
        #https://stackoverflow.com/a/48371587/2901002
        q = ' &amp; '.join((('({} ==  "{}")').format(i, j)) for i, j in d.items())
        m1 = m.query(q)['rating']  
        if m1.empty and len(args) &gt; 1:
            args.pop()
        else:
            return m1

print(get_top('ma', 'M', 'young','teacher'))
1    PG
Name: rating, dtype: object
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://pandas.pydata.org/" rel="nofollow noreferrer"><code>pandas</code></a> is definitely the goto library for handling detailed tabular data.  For those seeking a non-<code>pandas</code> option, you can build your own <em>mapping</em> and <em>reduction</em> functions.  I use these terms to mean the following:</p>
<ul>
<li><em>mapping</em>: reorganize data grouped by a desired query</li>
<li><em>reduction</em>: an aggregation function, used to tally or condense many values to one</li>
</ul>
<p><code>pandas</code> analogous <em>groupby</em>/<em>aggregation</em> concepts.</p>
<p><strong>Given</strong></p>
<p>Cleaned data where multiple spaces have been replaced with a single delimiter, e.g. <code>","</code>.</p>
<pre><code>%%file "test.txt"
status,gender,age_range,occ,rating
ma,M,young,student,PG
ma,F,adult,teacher,R
sin,M,young,student,PG
sin,M,adult,teacher,R
ma,M,young,student,PG
sin,F,adult,teacher,R
</code></pre>
<p><strong>Code</strong></p>
<pre><code>import csv
import collections as ct
</code></pre>
<p><em>Step 1: Read data</em></p>
<p></p>
<pre><code>def read_file(fname):
    with open(fname, "r") as f:
        reader = csv.DictReader(f)
        for line in reader:
            yield line


iterable = [line for line in read_file("test.txt")]
iterable
</code></pre>
<p>Output</p>
<pre><code>[OrderedDict([('status', 'ma'),
              ('gender', 'M'),
              ('age_range', 'young'),
              ('occ', 'student'),
              ('rating', 'PG')]),
 OrderedDict([('status', 'ma'),
              ('gender', 'F'),
              ('age_range', 'adult'),
              ...]
 ...
] 
</code></pre>
<p></p>
<p><em>Step 2: Remap data</em></p>
<p></p>
<pre><code>def mapping(data, column):
    """Return a dict of regrouped data."""
    dd = ct.defaultdict(list)
    for d in data:
        key = d[column]
        value = {k: v for k, v in d.items() if k != column}
        dd[key].append(value)
    return dict(dd)


mapping(iterable, "gender")
</code></pre>
<p>Output</p>
<pre><code>{'M': [
   {'age_range': 'young', 'occ': 'student', 'rating': 'PG', ...},
   ...]
 'F': [
   {'status': 'ma', 'age_range': 'adult', ...},
   ...]
} 
</code></pre>
<p></p>
<p><em>Step 3: Reduce data</em></p>
<p></p>
<pre><code>def reduction(data):
    """Return a reduced mapping of Counters."""
    final = {}
    for key, val in data.items():
        agg = ct.defaultdict(ct.Counter)
        for d in val:
            for k, v in d.items():
                agg[k][v] += 1
        final[key] = dict(agg)
    return final

reduction(mapping(iterable, "gender"))
</code></pre>
<p>Output</p>
<pre><code>{'F': {
   'age_range': Counter({'adult': 2}),
   'occ': Counter({'teacher': 2}),
   'rating': Counter({'R': 2}),
   'status': Counter({'ma': 1, 'sin': 1})},
 'M': {
   'age_range': Counter({'adult': 1, 'young': 3}),
   'occ': Counter({'student': 3, 'teacher': 1}),
   'rating': Counter({'PG': 3, 'R': 1}),
   'status': Counter({'ma': 2, 'sin': 2})}
 }
</code></pre>
<p></p>
<p><strong>Demo</strong></p>
<p>With these tools in place, you can build a data pipeline and to query the data, feeding results from one function into another:</p>
<pre><code># Find the top age range amoung males
pipeline = reduction(mapping(iterable, "gender"))
pipeline["M"]["age_range"].most_common(1)
# [('young', 3)]

# Find the top ratings among teachers
pipeline = reduction(mapping(iterable, "occ"))
pipeline["teacher"]["rating"].most_common()
# [('R', 3)]

# Find the number of married people
pipeline = reduction(mapping(iterable, "gender"))
sum(v["status"]["ma"] for k, v in pipeline.items())
# 3
</code></pre>
<p>Overall, you tailor your output based on how you define your reduction function.  </p>
<p>Note, the code from this generalized process is more verbose than a <a href="https://stackoverflow.com/questions/48680608/function-to-return-the-highest-count-value-using-a-rule">former example</a> despite its powerful application to many data columns.  <code>pandas</code> succinctly encapsulates these concepts.  Although the learning curve may initially be more steep, it can greatly expedite data analysis.</p>
<hr/>
<p><strong>Details</strong></p>
<ol>
<li><em>Read data</em> - we parse each line of a <em>cleaned file</em> using <a href="https://docs.python.org/3/library/csv.html#csv.DictReader" rel="nofollow noreferrer"><code>csv.DictReader</code></a>, which maintains the header names as keys of a dictionary.  This structure facilitates easier column access by name.</li>
<li><em>Remap data</em> - we group data as a dictionary.  

<ul>
<li>The keys are items in the selected/queried column, e.g. <code>"M"</code>, <code>"F"</code>.  </li>
<li>The values are each a list of dictionaries.  Each dictionary represents a row of all remaining columnar data (excluding the key).</li>
</ul></li>
<li><em>Reduce data</em> - we aggregate the values of the remapped data by tabulating related entries for all listed dictionaries.  Together the <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> and <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> combination build an excellent reducing data structure where new entries to the <code>defaultdict</code> initialize a <code>Counter</code> and repeated entries simply tally observations.</li>
</ol>
<p><strong>Application</strong></p>
<p>Pipelines are optional.  Here we will build a single function that processes serial requests:</p>
<pre><code>def serial_reduction(iterable, val_queries):
    """Return a `Counter` that is reduced after serial queries."""
    q1, *qs = val_queries 
    val_to_key = {v:k for k, v in iterable[0].items()}
    values_list = mapping(iterable, val_to_key[q1])[q1]

    counter = ct.Counter()
    # Process queries for dicts in each row and build a counter
    for q in qs:    
        try:
            for row in values_list[:]:
                if val_to_key[q] not in row:
                    continue
                else:
                    reduced_vals = {v for v in row.values() if v not in qs}
            for val in reduced_vals:
                counter[val] += 1
        except KeyError:
            raise ValueError("'{}' not found. Try a new query.".format(q))
    return counter


c = serial_reduction(iterable, "ma M young".split())
c.most_common()
# [('student', 2), ('PG', 2)]
serial_reduction(iterable, "ma M young teacher".split())
# ValueError: 'teacher' not found. Try a new query.
</code></pre>
</div>
<span class="comment-copy">Protip: Tag your pandas question with <code>pandas</code> if you want the right people to see it.</span>
<span class="comment-copy">Thanks Aran for the tip.</span>
<span class="comment-copy">Do you need solution which should be working with <code>get_top('ma', 'M', 'teacher)</code> or <code>get_top('M', 'young','teacher)</code> or <code>get_top('ma', 'teacher)</code> ?</span>
<span class="comment-copy">first, it should look at a sequence, get_top('ma', 'm', 'young', 'teacher'), if its not there then get_top('ma', 'm', 'young') if this isnt there, then, get_top('ma', 'm')</span>
<span class="comment-copy">What is your expected output?</span>
<span class="comment-copy">what if I dont have that combination? suppose, it  stopped at marital status, gender and age range ..it should only return me until there</span>
<span class="comment-copy">@pylearner, see update. <code>q</code> is an arbitrary list of tuples, which can be fed in from a function.</span>
<span class="comment-copy">can use that multiple columns ?</span>
<span class="comment-copy">yes, my example uses 3 columns!</span>
<span class="comment-copy">yea, so how do I list of columns to q ? say, a,b,c,d are my columns... in a sequence i can only use a,b,c as  a,b,c,d doesnt combine. ..so q should only have a,b,c ...how do i get it ?</span>
<span class="comment-copy">d = dict(zip(cols, args)),  I dont see cols anywhere, can you let me know where did you take it from ?</span>
<span class="comment-copy">oops, it is <code>c</code></span>
<span class="comment-copy">Series([], Name: rating, dtype: object), thats my output.</span>
<span class="comment-copy">With sample data?</span>
<span class="comment-copy">Can you test <code>df = pd.DataFrame({'maritalstatus': ['ma', 'ma', 'sin', 'sin', 'ma', 'sin'], 'gender': ['M', 'F', 'M', 'M', 'M', 'F'], 'age_range': ['young', 'adult', 'young', 'adult', 'young', 'adult'], 'occ': ['student', 'teacher', 'student', 'teacher', 'student', 'teacher'], 'rating': ['PG', 'R', 'PG', 'R', 'PG', 'R']})</code> ?</span>
