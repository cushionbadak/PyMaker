<div class="post-text" itemprop="text">
<p>So, the title pretty much says it all.</p>
<p>for instance let's look at the below example code:</p>
<pre><code>## How can I obtain a dict/list (like locals()) of all the variables in second and/or third layer scopes via a command 
# coming from the first layer?
## Or another example would be how could I obtain the variables "locals() style" from the thirdlayer via a 
# command from the second layer?
# essentially can a parent function/class access a list/dict of a child function
# or class??

def firstLayer():
     a = 4.7
     q = locals()
     print(q)
     # local vars of 1st layer
     def secondlayer():
          b = 7
          r = locals()
          print(r)
          # local vars of 2nd layer
          def thirdlayer():
               c = False
               s = locals()
               i = globals()
               print('c:\n', c, "\nglobals from 3rd layer:\n\t", i)
              # local vars of 3rd layer
          thirdlayer()

     secondlayer()
firstLayer()

sample_var = globals()
print(sample_var)
# returns the list of global variables
</code></pre>
<p>to reiterate what I said in the comments in the code, essentially is their any way I can get a list of all the variables local to a 'child' scope? I know functions are shut off, but if their is no way to do this is their any more complicated code that could achieve this and I could integrate it into a function or class if necessary.</p>
<p>EDIT:
To elaborate further; here's the situation i'm in.</p>
<pre><code>def varsfunc():
    font1 = "Harlow Solid"
    grey = '#454545'
    font2 = 'Mistral'
    font3 = 'Italic 35px Times New Roman'
    pnk = 'pink'
    grn = 'green'
    return locals()
</code></pre>
<p>Essentially, I am creating a module and the user must create some type of function that they list all of they variables they would like to declare to be used to modify a css file. Essentially, I would like to allow the user to not have to type "return locals()". I want to achieve it by having the end-users wrap the above example function in a decorator that will do the equivalent of returning locals() of the exact scope I want. The decorator does not work for me because it is in an outer scope.</p>
<p>TO BE EVEN MORE CLEAR:
I need a decorator/function that wraps another function(i.e. a decorator), that can access and create a list of a child element.</p>
<pre><code>def module_decorator_func_thing():
     r = command_that_acts_like_locals()_but_for_child_scopes
     def user_var_list():
          font1 = 'green'
          font2 = 'pink'
     # back in "module_decorator_func_thing"'s scope
     print(r) # this variable should contain only a dict/list containing the
     # the following:
     # r = {'font1': 'green', 'font2': 'pink')
</code></pre>
<p>currently users need to do this:</p>
<pre><code>def vars_func_container():
     font1 = 'green'
     font2 = 'pink'
     return locals() #  &lt;---- I want the user to not have to type this and for 
    # a function decorator to take care of it instead possibly.
</code></pre>
<hr/>
<p>Info for @aguy and others wishing for  more info.
The dictionary/list that I am obtaining via your guys' tips will be sent to this function to do the real job of the program.
(If I were to start using lists, i'd need to convert to a dictionary but that's no problem for me to solve.)
The dict of variables is used with this function to "compile/compyle"(Pun on the word 'Python' + 'compile) and is insert in the "variables" parameter. e.g. you execute the function like this.</p>
<pre><code>compyle("My sample title", return_stylesheet_from_func(*insert .css filename), 
return_variables_from_function(*insert function containing variables*), "**True/False to turn on compilation**", 
"**True/False to turn on annotations/suggestions**")
</code></pre>
<hr/>
<pre><code>def compyle(title, style_sheet, variables, boolean=False, boolean2=True):
    """
    :param title: The name you wish your .css file to be named.
    :param style_sheet: The name of the multi-line string that will compose your .css file
    :param variables: The name of the dictionary containing your .pcss variables
    :param boolean: A.K.A the "Compiler Parameter" - Turns the compiler on or off
    :param boolean2: A.K.A the "Annotation Parameter" - Turns annotations on or off
    :return: returns compiled .pcss text as normal .css style text to be utilized with .html
    """
    # -----------------------------------
    file_name = title + ".css"
    replace_num = len(variables.keys())
    counter = replace_num
    content = style_sheet
    # -----------------------------------
    # add theme support with namedtuple's formatted to mimic structs in C/C++
    # this will be a major feature update as well as a nice way to allow the future prospect of integrating C/C++ into
    # the compiler. Info: https://stackoverflow.com/questions/35988/c-like-structures-in-python
    for k, v in variables.items():
        counter -= 1
        content = content.replace(k, v, replace_num)
        if counter == 0:
            break
        else:
            pass
    looped_content = str(content)
    id_content = looped_content.replace("hash_", "#")
    output = id_content.replace("dot_", ".")

    if boolean is True:
        if boolean2 is True:
            output = " /* --- Pyle Sheet --- */\n" + output
            with open(file_name, 'w') as writ:
                writ.write(output)
                writ.close()
                print('compiled successfully; The file was saved as ' + "\"" + file_name + "\".")
        elif boolean2 is False:
            pass
        else:
            logging.warning("An Error Occurred - see module, documentation, or online Q&amp;A for assistance.")
    elif boolean is False:
        if boolean2 is True:
            print('compiled successfully; The file ' + "\"" + file_name + "\"" + "was not saved/created.")
        elif boolean2 is False:
            pass
        else:
            logging.warning("An Error Occurred - see module, documentation, or online Q&amp;A for assistance.")
    else:
        logging.warning('An Error Occurred with the Compile Parameter (See: boolean in pyle_sheets source file) - \ '
                        'see module, documentation, or online Q&amp;A for assistance.')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I can't see any way to do this without getting pretty deep; what follows is the simplest solution I've come up with.</p>
<h2>how it works</h2>
<p>Using the <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer">ast</a> module, we go through the code of the given function and find all the assignments. These are evaluated in a given namespace and this namespace is returned.</p>
<h2>the code</h2>
<pre><code>import ast
import functools
import inspect

def returnAssignments(f):
    @functools.wraps(f)
    def returner():
        assignments = dict()
        for node in ast.walk(ast.parse(inspect.getsource(f))):
            if isinstance(node, ast.Assign):
                exec(compile(ast.Module([node]), '&lt;ast&gt;', 'exec'),
                     globals(),
                     assignments)
        return assignments
    return returner
</code></pre>
<h2>usage</h2>
<pre><code>from ra import returnAssignments

@returnAssignments
def foo():
    this = 'something'
    that = 37
    the_other = object()

print(foo())
</code></pre>
<h2>output</h2>
<pre class="lang-none prettyprint-override"><code>rat@pandion:~/tmp$ python test.py
{'this': 'something', 'that': 37, 'the_other': &lt;object object at 0x10205b130&gt;}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wonder if such a crude solution as I provide here might be useful to you. Note that I haven't tested it on all cases, so it might be a bit rough. Also, it returns everything as a string, a behavior which you might want to further change.</p>
<p>Define the function:</p>
<pre><code>def get_local_vars_from_function(f):
    import inspect
    s = inspect.getsourcelines(f)[0]
    d = {}
    for l in s:
        if '=' in l:
            var, val = l.split('=')
            var = var.strip()
            val = val.strip()
            d[var] = val
    return d
</code></pre>
<p>Then to use it:</p>
<pre><code>In[91]: get_local_vars_from_function(user_var_list)
Out[91]: {'font1': "'green'", 'font2': "'pink'"}
</code></pre>
</div>
<span class="comment-copy">Can you explain why you want to do this?  Knowing what you are trying to achieve by doing this might help us figure out a solution.</span>
<span class="comment-copy">check my update</span>
<span class="comment-copy">Functions are for executing a task or calculation and returning a result not as a way to declare variables.  In fact the variables in the function are supposed to be temporary and don't persist.  It sounds like you want a 'receptacle' to allow the user of this module to declare a set of variables that your module will then use.  I can think of two ways to do this.  A dictionary of values or variables or a class.  A class could just hold class variables if you do not want to have multiple instances.  Would any of these ideas work in your context?</span>
<span class="comment-copy">A dict of values was my old idea but, I was trying to improve it from that.. I guess I might just have to make the end user do more work but, nobody likes using a confusing module.</span>
<span class="comment-copy">check my third example and new update; I feel like we are not exactly on the same page but, then again we might. Essentially I want users to not need a bottom return statement saying 'return locals()'. I'd like them to just make a function containing all the variable initialization.</span>
<span class="comment-copy">This works great aswell! I don't know who has the better answer lol. I shall do a coin toss in the morning.</span>
<span class="comment-copy">I have to give you the award of best answer even though it was truly a draw. Your method results in all data types keeping their integrity and that is obviously something that could be a benefit even though I need to turn them all into strings anyways... In fact, this could help allow for pre-processor statements since the variable's rvalues could keep their data types until the moment I need to turn them into a string.</span>
<span class="comment-copy">I actually WANT everything to become a string so that helps... Let me integrate this into the project and i'll get back with you! thank you.  EDIT: Check out my last edit labeled for you.</span>
<span class="comment-copy">With no modification, your answer works. But to be fair, let me evaluate Nathan V's answer as well to be fair lol. In all honetsly, I went though these suggestions from bottom to top so I suppose that wasn't quite fair lol.</span>
