<div class="post-text" itemprop="text">
<p>I wanted to test <code>cython</code> performance comparing it to standard python. So here I have 3 examples of a function which will loop through 200 ints adding the same number to the result over and over again and then returning the result. In the <code>timeit</code> module I made it to be called <code>1.000.000</code> times. </p>
<p>So there's the first example:</p>
<pre><code>[frynio@manjaro ctest]$ cat nocdefexample.pyx 
def nocdef(int num):
    cdef int result = 0
    for i in range(num):
        result += num
    return result


def xd(int num):
    return nocdef(num)
</code></pre>
<p>Here's the second (look closely, the first function definition matters):</p>
<pre><code>[frynio@manjaro ctest]$ cat cdefexample.pyx 
cdef int cdefex(int num):
    cdef int result = 0
    for i in range(num):
        result += num
    return result


def xd1(int num):
    return cdefex(num)
</code></pre>
<p>And there's the third one, which is placed in the main file:</p>
<pre><code>[frynio@manjaro ctest]$ cat test.py
from nocdefexample import xd
from cdefexample import xd1
import timeit

def standardpython(num):
    result = 0
    for i in range(num):
        result += num
    return result

def xd2(num):
    return standardpython(num)

print(timeit.timeit('xd(200)', setup='from nocdefexample import xd', number=1000000))
print(timeit.timeit('xd1(200)', setup='from cdefexample import xd1', number=1000000))
print(timeit.timeit('xd2(200)', setup='from __main__ import xd2', number=1000000))
</code></pre>
<p>I compiled it with <code>cythonize -a -i nocdefexample.pyx cdefexample.pyx</code> and I got two <code>.so</code>s. Then when I run <code>python test.py</code> - this shows up:</p>
<pre><code>[frynio@manjaro ctest]$ python test.py
0.10323301900007209
0.06339033499989455
11.448068103000423
</code></pre>
<p>So the first one is only <code>def &lt;name&gt;(int num)</code>. The second one (seems to be <code>1.5x</code> faster than the first one) is <code>cdef int &lt;name&gt;(int num)</code>. And the last one is just <code>def &lt;name&gt;(num)</code>.</p>
<p>The last ones performance is terrible, but that's what I wanted to see. The interesting thing for me is why those first two examples differ (I checked it many times, second is always ~<code>1.5x</code> faster than the first one).</p>
<p>Is it only because I specified the return type? </p>
<p>And if so, does it mean that they're both <code>cython</code> functions or is the first some kind of, I dunno, a mixed-type kinda function?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you must be aware, that in the case of cython-functions you are measuring just the overhead of calling a <code>cdef</code>- vs. a <code>def</code>-function:</p>
<pre><code>&gt;&gt;&gt; %timeit nocdef(1000)
60.5 ns ± 0.73 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

&gt;&gt;&gt; %timeit nocdef(10000)
60.1 ns ± 1.2 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>
<p>The C-compiler recognizes, that the loop will result in <code>num*num</code> and evaluates this multiplication directly without running the loop - and multiplication is equally fast for <code>10**3</code> and <code>10**4</code>.</p>
<p>This might come as surprise for a python-programmer, because the python-interpreter doesn't optimize and thus this loop has an <code>O(n)</code>-running time:</p>
<pre><code>&gt;&gt;&gt; %timeit standardpython(1000)
43.7 µs ± 182 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

&gt;&gt;&gt; %timeit standardpython(10000)
479 µs ± 4.95 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p>Now, calling a <code>cdef</code> function is much faster! Just look at the generated C-code for calling the <code>cdef</code> version (actually the creation of python-integer is already incorporated):</p>
<pre><code>__pyx_t_1 = __Pyx_PyInt_From_int(__pyx_f_4test_cdefex(__pyx_v_num)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 19, __pyx_L1_error)
</code></pre>
<p><code>__pyx_f_4test_cdefex</code> - is just a call of a C-function. Compared to call of <code>def</code>-version which happens via the whole python-machinery (here kind of abbreviated):</p>
<pre><code>   ...
 __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_nocdef); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 9, __pyx_L1_error)
  ...
 __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_num); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 9, __pyx_L1_error)
  ...
 __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
  ...
 __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9, __pyx_L1_error)
</code></pre>
<p>The Cython has to:</p>
<ol>
<li>Create a python-integer from the C-int <code>num</code> to be able to call a Python-function (<code>__Pyx_PyInt_From_int</code>)</li>
<li>locate this method using its name (<code>__Pyx_GetModuleGlobalName</code> + <code>PyMethod_GET_SELF</code>)</li>
<li>and finally call the function.</li>
</ol>
<p>The first call is probably at least 100 times faster, but the overall speed-up is less than 2 only because calling the "inner"-function is not the only work that needs to be done: <code>def</code>-functions <code>xd</code> and <code>xd1</code> have to be called anyway + the resulting python-integer must be created. </p>
<p>Fun-fact:</p>
<pre><code> &gt;&gt;&gt; %timeit nocdef(16)
 44.1 ns ± 0.294 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

 &gt;&gt;&gt; %timeit nocdef(17)
 58.5 ns ± 0.638 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>
<p>The reason is the <a href="https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong" rel="nofollow noreferrer">integer pool</a> for values <code>-5</code>...<code>256</code>=<code>16^2</code> so the values from this range can be constructed faster.</p>
<hr/>
<p>Specifying the return type doesn't play that big role in your example: it only decides, where the conversion to python-integer happens - either in <code>nocdef</code> or <code>xd1</code> - but it happens eventually.</p>
</div>
<span class="comment-copy"><a href="https://notes-on-cython.readthedocs.io/en/latest/function_declarations.html" rel="nofollow noreferrer">notes-on-cython.readthedocs.io/en/latest/…</a> can you elaborate, what on this page is not clear to you?</span>
<span class="comment-copy">The difference with calling <code>def ...(num)</code> and <code>def ...(int num)</code>. Why the second one is faster. And why is it the slower than <code>cdef int ...(int num)</code></span>
<span class="comment-copy">the page i linked to explains exactly this. i'm not sure how one can explain it better if one doesn't know what about it you don't understand. the difference between the two you mentioned is obviously the type hint and that's obviously the reason for the performance difference. the difference between the other two is obviously the declaration of the functions themselves and /that/ behaviour is clearly explained (to me) on the page i linked.</span>
<span class="comment-copy">I think a more reasonable test would just be to call <code>nocdef</code> directly. As it is there's two layers of Python calling overhead (e.g. <code>xd</code> checks that the argument is an <code>int</code>, then passes it to <code>nocdef</code> which checks the argument is an <code>int</code>).</span>
<span class="comment-copy">a more reasonable test would be to use <code>num**2</code> ;)</span>
<span class="comment-copy">Exactly what I was looking for</span>
