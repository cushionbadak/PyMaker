<div class="post-text" itemprop="text">
<p>I have the following code in python. My question is how do you print each element in the linked queue? I know that I will have to make a <code>__repr__</code> or <code>__str__</code> function but I am unsure how to implement it. Thanks.</p>
<pre><code>class LinkedQueue :
    class _Node :
        def __init__(self, element, next):
            self._element = element
            self._next = next


        def get_elements():
            return self._element

        def set_elements(num):
            self._element = num    

    def __init__(self) :
        self._head = None
        self._tail = None
        self._size = 0

    def __len__(self) :
        return self._size

    def is_empty(self) :
        return self._size == 0

    def first(self) :
        if self.is_empty() :
            raise Empty('Queue is empty')
        return self._head._element

    def dequeue(self) :
        if self.is_empty():
            raise Empty('Queue is empty')
        answer = self._head._element
        self._head = self._head._next
        self._size -= 1
        if self.is_empty() :
            self._tail = None
        return answer

    def enqueue(self, e) :
        newest = self._Node(e,None)
        if self.is_empty() :
            self._head = newest
        else :
            self._tail._next = newest
        self._tail = newest
        self._size += 1

class Empty(Exception) :
    pass    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It depends on what you want the repr to look like, but here's one way. We give the <code>_Node</code> class a simple <code>__repr__</code> that just returns the repr of the element, and to build the repr for a <code>LinkedQueue</code> instance we walk the linked list, storing the repr of each <code>Node</code> into a list. We can then call <code>.join</code> on that list to make the repr for the <code>LinkedQueue</code>.</p>
<pre><code>class Empty(Exception): 
    pass

class LinkedQueue: 
    class _Node:
        def __init__(self, element, _next=None):
            self._element = element
            self._next = _next

        def __repr__(self):
            return repr(self._element)

    def __init__(self): 
        self._head = None
        self._tail = None
        self._size = 0

    def __len__(self): 
        return self._size

    def __repr__(self):
        lst = []
        head = self._head
        while head is not None:
            lst.append(repr(head))
            head = head._next
        return 'Queue({})'.format(", ".join(lst))

    def is_empty(self): 
        return self._size == 0

    def first(self): 
        if self.is_empty(): 
            raise Empty('Queue is empty')
        return self._head._element

    def dequeue(self): 
        if self.is_empty():
            raise Empty('Queue is empty')
        answer = self._head._element
        self._head = self._head._next
        self._size -= 1
        if self.is_empty(): 
            self._tail = None
        return answer

    def enqueue(self, e): 
        newest = self._Node(e)
        if self.is_empty(): 
            self._head = newest
        else: 
            self._tail._next = newest
        self._tail = newest
        self._size += 1

# test

q = LinkedQueue()
for u in 'abcd':
    q.enqueue(u)
    print(len(q))

print(q)

while not q.is_empty():
    print(q.first(), q.dequeue())
</code></pre>
<p><strong>output</strong></p>
<pre><code>1
2
3
4
Queue('a', 'b', 'c', 'd')
a a
b b
c c
d d
</code></pre>
<hr/>
<p>I got rid of the getter &amp; setter method in <code>Node</code>, since you don't use them, and we don't normally write getters &amp; setters like that in Python. See the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">Descriptor HowTo Guide</a> in the docs.</p>
<p>FWIW, I would make <code>Node</code> a separate class (or get rid of it entirely), rather than nesting it in <code>LinkedQueue</code>. I guess it doesn't hurt to nest it, but nested class definitions aren't often used in Python.</p>
<p>BTW, the <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a> is a very efficient double-ended queue. For simple queues and stacks, it's generally faster than <code>list</code>. But I guess this <code>LinkedQueue</code> class is for an exercise in implementing linked lists in Python, so <code>collections.deque</code> isn't currently relevant for you. ;)</p>
</div>
<span class="comment-copy">Have you  looked at just using a <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer">python list</a> and the <code>append()</code> and <code>pop()</code> methods?</span>
