<div class="post-text" itemprop="text">
<p>I have a list of of tuples that represent different times </p>
<pre><code>timeList = [('4', '12', 'PM'), ('8', '23', 'PM'), ('4', '03', 'AM'), ('1', '34', 'AM'), 
('12', '48', 'PM'), ('4', '13', 'AM'), ('11', '09', 'AM'), ('3', '12', 'PM'), 
('4', '10', 'PM')]
</code></pre>
<p>I want to return the max from the list, after some searching I realized I could use the key in max to search by the AM or PM first.<br/>
<code>print(max(timeList, key = operator.itemgetter(2)))
</code></p>
<p>When I run this however, I'm getting the wrong max <code>('4', '12', 'PM')
</code> 
I thought about it, and not only does it not make sense, given that 8:23 should be max, but I also realized that 12:48 would probably return max since it's a PM and also technically greater than 8 in my search.</p>
<p>That being said, how might I get this max to find the latest possible time, given formatting of the list can not be changed. </p>
</div>
<div class="post-text" itemprop="text">
<p>Just define an appropriate key-function. You want <code>int(hour)</code>, <code>int(minute)</code> and <code>'PM'</code> already sorts lexicographically higher than <code>"AM"</code>, but it should be considered <em>first</em>, so. Also, you need to take the hours modulus 12, so that <code>12</code> sorts less than other numbers, within a <code>pm</code>/<code>am</code>:</p>
<pre><code>In [39]: timeList = [('4', '12', 'PM'), ('8', '23', 'PM'), ('4', '03', 'AM'), ('1', '34', 'AM'),
    ...: ('12', '48', 'PM'), ('4', '13', 'AM'), ('11', '09', 'AM'), ('3', '12', 'PM'),
    ...: ('4', '10', 'PM')]

In [40]: def key(t):
...:     h, m, z = t
...:     return z, int(h)%12, int(m)
...:

In [41]: max(timeList,key=key)
Out[41]: ('8', '23', 'PM')
</code></pre>
<p>But what would make <em>the most sense</em> is to actually use <code>datetime.time</code> objects, instead of pretending a tuple of strings is a good way to store time.</p>
<p>So something like:</p>
<pre><code>In [49]: def to_time(t):
    ...:     h, m, z = t
    ...:     h, m = int(h)%12, int(m)
    ...:     if z  == "PM":
    ...:         h += 12
    ...:     return datetime.time(h, m)
    ...:

In [50]: real_time_list = list(map(to_time, timeList))

In [51]: real_time_list
Out[51]:
[datetime.time(16, 12),
 datetime.time(20, 23),
 datetime.time(4, 3),
 datetime.time(1, 34),
 datetime.time(12, 48),
 datetime.time(4, 13),
 datetime.time(11, 9),
 datetime.time(15, 12),
 datetime.time(16, 10)]

In [52]: list(map(str, real_time_list))
Out[52]:
['16:12:00',
 '20:23:00',
 '04:03:00',
 '01:34:00',
 '12:48:00',
 '04:13:00',
 '11:09:00',
 '15:12:00',
 '16:10:00']
</code></pre>
<p>Note, now <code>max</code> "just works":</p>
<pre><code>In [54]: t = max(real_time_list)

In [55]: print(t)
20:23:00
</code></pre>
<p>And if you need a pretty string to print, just do the formatting at that point:</p>
<pre><code>In [56]: print(t.strftime("%I:%M %p"))
08:23 PM
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not <em>add</em> structure to your data?</p>
<pre><code>from datetime import datetime

max(datetime.strptime(''.join(x), '%I%M%p') for x in timeList)

# datetime.datetime(1900, 1, 1, 20, 23)
# i.e. 8.23pm
</code></pre>
<p>While you say "formatting of list should not be changed", that's exactly what all solutions are implicitly doing in order to perform comparisons.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>key</code> param with the <code>max</code> function is used to notify <code>max</code> on which value you want to perform max operation. <code>itemgetter(2)</code> fetches the value at 2nd index, and lexicographically "PM" is the highest value in the list at index 2 (lexicographically 'PM' &gt; 'AM'). You may use a <em>lambda</em> function to calculate the maximum on tuple at index 0 and 1 as:</p>
<pre><code>&gt;&gt;&gt; timeList = [('4', '12', 'PM'), ('8', '23', 'PM'), ('4', '03', 'AM'), ('1', '34', 'AM'), ('12', '48', 'PM'), ('4', '13', 'AM'), ('11', '09', 'AM'), ('3', '12', 'PM'), ('4', '10', 'PM')]

# type-casting it to `int` to avoid incorrect result 
# due lexicographical comparision of `str`
&gt;&gt;&gt; max(timeList, key=lambda x: (x[2], int(x[0]), int(x[1])))
('12', '48', 'PM')            #   ^      ^         ^ Third priority to `int` value of minute
                              #   ^      ^ Second priority to int value of `hour`
                              #   ^ First priority to lexicographically sort on `AM`/`PM`
</code></pre>
<p>OR, you perform the comparison on <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime" rel="nofollow noreferrer"><code>datetime.datetime</code></a> object as:</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; max(timeList, key=lambda x: datetime.strptime('{}:{}{}'.format(*x), '%I:%M%p'))
('8', '23', 'PM')
</code></pre>
<p>I think you should have created the list of <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime" rel="nofollow noreferrer"><code>datetime.datetime</code></a> instead of time <code>tuples</code> initially.</p>
</div>
<div class="post-text" itemprop="text">
<p>Adding to the solutions you can also sort with datetime:</p>
<pre><code>from datetime import datetime

timeList = [('4', '12', 'PM'), ('8', '23', 'PM'), ('4', '03', 'AM'), ('1', '34', 'AM'), 
('12', '48', 'PM'), ('4', '13', 'AM'), ('11', '09', 'AM'), ('3', '12', 'PM'), 
('4', '10', 'PM')]

sorted(timeList, key=lambda x: datetime.strptime(''.join(x), '%I%M%p'))[-1]
</code></pre>
<p>Returns:</p>
<pre><code>('8', '23', 'PM')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is really elegantly implemented in pandas, which allows a MultiIndex, which we can then sort on and take the head:</p>
<pre><code>import numpy as np
import pandas as pd

timeList = [('4','12','PM'),  ('8','23','PM'),  ('4','03','AM'),
            ('1','34','AM'),  ('12','48','PM'), ('4','13','AM'),
            ('11','09','AM'), ('3','12','PM'),  ('4','10','PM')]

timeDf = pd.DataFrame(timeList, columns=['hr','min','meridiem'])
timeDf.set_index(['meridiem','hr','min'], inplace=True, drop=True)

#timeDf['value'] = np.random.randint(1,10, timeDf.shape[0]) # np.nan

timeDf.sort_index(level=0, ascending=False, inplace=True) # sort by meridiem, then the remaining cols (alphanumeric string comparison)
timeDf.index[0]
# ('PM', '8', '23')
</code></pre>
<p>Notes:</p>
<ul>
<li>If you want to keep <code>hr,min,meridiem</code> as columns in your df, then use <code>set_index(..., drop=False)</code></li>
<li>as AntonvBR points out, if the timestamp also included a timezone, then we could no longer use a simple sort on multiple distinct (string) fields; we'd want to compute the underlying datetime then use that as sort key.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>looks like you timeList are times.
maybe it makes sense parsing it as such?</p>
<pre><code> max([datetime.strptime("{}:{} {}".format(t[0],t[1],t[2]),'%I:%M %p') for t in timeList]).strftime("%H:%M")
</code></pre>
</div>
<span class="comment-copy">to run the code make sure you include <code>import operator</code></span>
<span class="comment-copy">.itemgetter(2) returns the third element, not the second (offset 0)</span>
<span class="comment-copy">The term you want to use is <i>"custom sort order, by meridiem (alphabetic descending), then by hour and min (alphanumeric descending)"</i></span>
<span class="comment-copy">FYI: <a href="https://stackoverflow.com/questions/1468857/what-is-am-pm-called">'AM/PM' can either be called 'period' (apparently its standard name) or 'meridiem' (way less ambiguous)</a></span>
<span class="comment-copy">I like this one best, as it solves the problem without using datetime (what i was trying to do for a challenge).</span>
<span class="comment-copy">I have seem many videos and answers in the same format as your juanpa, where you have <code>In [n]:</code> and I was wondering how you got those, what IDE you're using.</span>
<span class="comment-copy">@Podo it's not an IDE, it's an enhanced interpreter shell, <a href="https://ipython.org/install.html" rel="nofollow noreferrer"><code>ipython</code></a></span>
<span class="comment-copy">@Podo it's associated with Jupyter Notebooks, but the enhanced shell by itself is great. Here's some more info: <a href="http://ipython.readthedocs.io/en/stable/interactive/tutorial.html" rel="nofollow noreferrer">ipython.readthedocs.io/en/stable/interactive/tutorial.html</a></span>
<span class="comment-copy">Wonderful. So when I use a key function like you've shown as the key in my max, I'm getting an <code>unexpected EOF while parsing</code> at the line <code>max(timeList,key = key)   I tried passing it timeList as a parameter, like </code>key = key(timeList)` since I assume that's where function <code>key</code> is getting it's argument, but that gives an error as well.   Thoughts?</span>
<span class="comment-copy">yeap, looked for this before posting a similar solution.</span>
<span class="comment-copy">@AntonvBR, I upvoted your answer &amp; juanpa's for either implementing or mentioning conversion to dates. It's worrying how so many of us instinctively jump onto the string formatting bandwagon.</span>
<span class="comment-copy">yes I agree, but it is also very common to read the questions literally and forget the fact that the OPs aren't necessarily looking for what they are asking for.</span>
<span class="comment-copy">Hmmm, but to go back to old format you would have to do something like this: <code>tuple(max(datetime.strptime(''.join(x), '%I%M%p') for x in timeList).strftime('%#I %M %p').split(' '))</code>, right?</span>
<span class="comment-copy">Yup, sure. Or... just keep dates as dates...</span>
<span class="comment-copy">You need to inlcude 'PM'/'AM' in the sort key, or else this will fail: <code>timeList.append(('12','59','AM'))</code></span>
<span class="comment-copy">@juanpa.arrivillaga thanks! added it.</span>
<span class="comment-copy"><code>pandas</code> allows doing this automatically (with a MultiIndex), see my answer</span>
<span class="comment-copy">... what if there's an <code>('11','49','PM')</code>? Anyway, why not <code>timeDf.sort_values(by=['meridiem','hr','min'])</code>?</span>
<span class="comment-copy">Nice, but you are overcomplicating it (look at jp_data_analysis' answer)</span>
