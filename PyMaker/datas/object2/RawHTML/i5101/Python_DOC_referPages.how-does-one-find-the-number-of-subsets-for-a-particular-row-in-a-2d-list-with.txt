<div class="post-text" itemprop="text">
<p>Please excuse the title, it is hard to express the problem correctly without showing an example.  </p>
<p>I have a very large 2D array with rows of varying sizes, for example:</p>
<pre><code>big2DArray =
[["a","g","r"],
["a","r"],
["p","q"],
["a", "r"]]
</code></pre>
<p>I need to return a dictionary, it has to look something like this:</p>
<pre><code>{('a','g','r'): 1, ('a', 'r'): 3, ('p', 'q'):1}
</code></pre>
<p>The <code>('a', 'r')</code> tuple is found to have a value of 3, since it occurs twice as itself and once as a subset (less than or equal) to the tuple <code>('a', 'g', 'r')</code>.</p>
<p>Normally I would use something like this:</p>
<pre><code>dictCounts = Counter(map(tuple, big2DArray))
</code></pre>
<p>Which, for big2Darray, would give:</p>
<pre><code>{('a','g','r'): 1, ('a', 'r'): 2, ('p', 'q'):1}
</code></pre>
<p>My question is this, can Collections' Counter function be used so that it gives the counts for the subsets as well, like explained above?  If not, is there any <em>comparably efficient</em> method to return my desired dictionary output for subsets?  </p>
<p>Thanks so much!</p>
<p>Edit 1:  Just for further clarity! I do not want to return all subsets, such as {('a','g'): 1, ('a','r'):3}, and so on.  I only want to return the counts for the unique rows in the 2D array. So in this case the counts for: ('a','g','r'), ('a','r'), ('p','q'). </p>
<p>Edit 2: The row ["a","r"] should be treated as equivalent to ["r", "a"], and so should the tuples ('a','r') and ('r','a')</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://python-reference.readthedocs.io/en/latest/docs/sets/issubset.html" rel="nofollow noreferrer"><code>set.issubset</code></a> with <code>collections.Counter</code> here.</p>
<p><strong>Demo:</strong></p>
<pre><code>from collections import Counter

big2DArray = [["a","g","r"],
              ["a","r"],
              ["p","q"],
              ["a", "r"],
              ["r", "a"]]

counts = Counter(map(lambda x: tuple(sorted(x)), big2DArray))

count_lst = list(counts)
for i, k1 in enumerate(count_lst):
    rest = count_lst[:i] + count_lst[i+1:]
    for k2 in rest:
        if set(k1).issubset(k2):
            counts[k1] += 1

print(counts)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Counter({('a', 'r'): 4, ('a', 'g', 'r'): 1, ('p', 'q'): 1})
</code></pre>
<p>In the above code, in order to make sure <code>["r", "a"]</code> and <code>["a","r"]</code> are equivalent, you can sort them beforehand, and add them as tuples to <code>Counter()</code>. </p>
<p>The other more efficient way would be to use <code>frozenset</code>, as shown in the other answer. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is one solution. It uses <code>defaultdict</code> instead of <code>Counter</code>. The dictionary keys are <a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow noreferrer"><code>frozensets</code></a>. If you need ordered tuple dictionary keys, see <a href="https://stackoverflow.com/a/48721673/9209546">@RoadRunner's solution</a>.</p>
<pre><code>from itertools import combinations, chain
from collections import defaultdict

big2DArray = [["a","g","r"],
              ["a","r"],
              ["p","q"],
              ["a", "r"]]

arr_new = [[set(i) for k in range(2, len(j)+1) \
            for i in combinations(j, k)] for j in big2DArray]

full_list = set(map(frozenset, big2DArray))

counter = defaultdict(int)

for i in range(len(big2DArray)):
    for j in full_list:
        if j in arr_new[i]:
            counter[frozenset(j)] += 1

# defaultdict(int,
#             {frozenset({'a', 'r'}): 3,
#              frozenset({'a', 'g', 'r'}): 1,
#              frozenset({'p', 'q'}): 1})
</code></pre>
</div>
<span class="comment-copy">Are you sure you really want to get <b>all</b> subset? It's a exponentially huge number.</span>
<span class="comment-copy">Can you also clarify whether you need <code>('g', 'r')</code>. This is technically a subset but does not appear in your output.</span>
<span class="comment-copy">Edited the question, I hope that makes it more clear!</span>
<span class="comment-copy">Why is this question getting downvoted?</span>
<span class="comment-copy">Since <code>('a', 'r')</code> and <code>('r', 'a')</code> are considered equivalent for user's algorithm, is it a good idea to have <code>Counter</code> keys as tuples? More a question for OP. This is why I went down frozenset route.</span>
<span class="comment-copy">@jp_data_analysis Yeah I was unsure about that as well. This could be fixed with <code>tuple(sorted(x))</code> or <code>frozenset</code> as you've done. I'll update the answer.</span>
