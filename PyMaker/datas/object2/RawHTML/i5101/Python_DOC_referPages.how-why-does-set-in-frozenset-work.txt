<div class="post-text" itemprop="text">
<p>Even though sets are unhashable, membership check in other set works:</p>
<pre><code>&gt;&gt;&gt; set() in {frozenset()}
True
</code></pre>
<p>I expected <code>TypeError: unhashable type: 'set'</code>, consistent with other behaviours in Python:</p>
<pre><code>&gt;&gt;&gt; set() in {}  # doesn't work when checking in dict
TypeError: unhashable type: 'set'
&gt;&gt;&gt; {} in {frozenset()}  # looking up some other unhashable type doesn't work
TypeError: unhashable type: 'dict'
</code></pre>
<p>So, how is set membership in other set implemented?</p>
</div>
<div class="post-text" itemprop="text">
<p>The last line of <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.clear" rel="nofollow noreferrer">the documentation for <code>set</code>s</a> discusses this:</p>
<blockquote>
<p>Note, the <code>elem</code> argument to the <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer"><code>__contains__()</code></a>, <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.remove" rel="nofollow noreferrer"><code>remove()</code></a>, and <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.discard" rel="nofollow noreferrer"><code>discard()</code></a>
  methods may be a <code>set</code>. To support searching for an equivalent
  <code>frozenset</code>, a temporary one is created from <code>elem</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><code>set_contains</code> is <a href="https://github.com/python/cpython/blob/v3.6.0/Objects/setobject.c#L1874" rel="nofollow noreferrer">implemented like this</a>:</p>
<pre><code>static int
set_contains(PySetObject *so, PyObject *key)
{
    PyObject *tmpkey;
    int rv;

    rv = set_contains_key(so, key);
    if (rv &lt; 0) {
        if (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))
            return -1;
        PyErr_Clear();
        tmpkey = make_new_set(&amp;PyFrozenSet_Type, key);
        if (tmpkey == NULL)
            return -1;
        rv = set_contains_key(so, tmpkey);
        Py_DECREF(tmpkey);
    }
    return rv;
}
</code></pre>
<p>So this will delegate directly to <a href="https://github.com/python/cpython/blob/v3.6.0/Objects/setobject.c#L430" rel="nofollow noreferrer"><code>set_contains_key</code></a> which will essentially hash the object and then look up the element using its hash.</p>
<p>If the object is unhashable, <code>set_contains_key</code> returns <code>-1</code>, so we get inside that <code>if</code>. Here, we check <em>explicitly</em> whether the passed <code>key</code> object is a set (or an instance of a set subtype) <strong>and</strong> whether we previously got a type error. This would suggest that we tried a containment check with a <code>set</code> but that failed because it is unhashable.</p>
<p>In that exact situation, we now create a new <code>frozenset</code> from that <code>set</code> and attempt the containment check using <code>set_contains_key</code> again. And since frozensets are properly hashable, we are able to find our result that way.</p>
<p>This explains why the following examples will work properly even though the set itself is not hashable:</p>
<pre><code>&gt;&gt;&gt; set() in {frozenset()}
True
&gt;&gt;&gt; set(('a')) in { frozenset(('a')) }
True
</code></pre>
</div>
<span class="comment-copy">also another error <code>[] in {()}</code> <code>TypeError: unhashable type: 'list'</code></span>
<span class="comment-copy">There are two questions here basically: Why can you do <code>set() in thingThatRequiresHashableElements</code>, and why is the <code>set()</code> apparently compared to the existing <code>frozenset()</code> when the membership test is actually made.</span>
<span class="comment-copy">Well, it's documented: "Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')])." - the latter case is what's going on here - but the mechanism isn't discussed there. Might be a pointer to digging in further though. <a href="https://docs.python.org/2/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">docs.python.org/2/library/stdtypes.html#set-types-set-frozenset</a></span>
<span class="comment-copy"><a href="https://stackoverflow.com/q/32232182/2301450">Dupe?</a></span>
<span class="comment-copy">Seems people still able to submit answers somehow even though its a duplicate</span>
