<div class="post-text" itemprop="text">
<p>I just wrote a simple <a href="https://github.com/allrod5/injectable" rel="nofollow noreferrer"><code>@autowired</code> decorator</a> for Python that instantiate classes based on type annotations.</p>
<p>To enable lazy initialization of the class, the package provides a <code>lazy(type_annotation: (Type, str))</code> function so that the caller can use it like this:</p>
<pre><code>@autowired
def foo(bla, *, dep: lazy(MyClass)):
   ...
</code></pre>
<p>This works very well, under the hood this <code>lazy</code> function just returns a function that returns the actual type and that has a <em>lazy_init</em> property set to <code>True</code>. Also this does <strong>not</strong> break IDEs' (e.g., PyCharm) code completion feature.</p>
<h2><a href="https://github.com/allrod5/injectable/issues/3" rel="nofollow noreferrer">But I want to enable the use of a subscriptable <code>Lazy</code> type use instead of the <code>lazy</code> function.</a></h2>
<p>Like this:</p>
<pre><code>@autowired
def foo(bla, *, dep: Lazy[MyClass]):
   ...
</code></pre>
<p>This would behave very much like <a href="https://github.com/python/typing/blob/7d7ffcd51e1ed9bccfa0466b371e490b1555208b/python2/typing.py#L773" rel="nofollow noreferrer">typing.Union</a>. And <strong>while I'm able to implement the subscriptable type, IDEs' code completion feature will be rendered useless</strong> as it will present suggestions for attributes in the <code>Lazy</code> class, not <code>MyClass</code>.</p>
<p>I've been working with this code:</p>
<pre><code>class LazyMetaclass(type):
    def __getitem__(lazy_type, type_annotation):
        return lazy_type(type_annotation)

class Lazy(metaclass=LazyMetaclass):
    def __init__(self, type_annotation):
        self.type_annotation = type_annotation
</code></pre>
<p>I tried redefining <code>Lazy.__dict__</code> as a property to forward to the subscripted type's <code>__dict__</code> but this seems to have no effect on the code completion feature of PyCharm.</p>
<p>I strongly believe that what I'm trying to achieve is possible as <a href="https://github.com/python/typing/blob/7d7ffcd51e1ed9bccfa0466b371e490b1555208b/python2/typing.py#L773" rel="nofollow noreferrer">typing.Union</a> works well with IDEs' code completion. I've been trying to decipher what in the source code of <a href="https://github.com/python/typing/blob/7d7ffcd51e1ed9bccfa0466b371e490b1555208b/python2/typing.py#L773" rel="nofollow noreferrer">typing.Union</a> makes it to behave well with code completion features but with no success so far.</p>
</div>
<div class="post-text" itemprop="text">
<p>For the <code>Container[Type]</code> notation to work you would want to create a <a href="https://docs.python.org/3/library/typing.html#user-defined-generic-types" rel="nofollow noreferrer">user-defined generic type</a>:</p>
<pre><code>from typing import TypeVar, Generic

T = TypeVar('T')

class Lazy(Generic[T]):
    pass
</code></pre>
<p>You then use </p>
<pre><code>def foo(bla, *, dep: Lazy[MyClass]):
</code></pre>
<p>and <code>Lazy</code> is seen as a container that holds the class. </p>
<p><strong>Note</strong>: this <em>still means the IDE sees <code>dep</code> as an object of type <code>Lazy</code></em>. <code>Lazy</code> is a container type here, <em>holding</em> an object of type <code>MyClass</code>. Your IDE won't auto-complete for the <code>MyClass</code> type, you can't use it that way.</p>
<p>The notation also doesn't create an instance of the <code>Lazy</code> class; it creates a <em>subclass</em> instead, via the <code>GenericMeta</code> metaclass. The subclass has a special attribute <code>__args__</code> to let you introspect the subscription arguments:</p>
<pre><code>&gt;&gt;&gt; a = Lazy[str]
&gt;&gt;&gt; issubclass(a, Lazy)
True
&gt;&gt;&gt; a.__args__
(&lt;class 'str'&gt;,)
</code></pre>
<p>If all you wanted was to reach into the type annotations <em>at runtime</em> but resolve the name lazily, you could just support a string value:</p>
<pre><code>def foo(bla, *, dep: 'MyClass'):
</code></pre>
<p>This is valid type annotation, <em>and</em> your decorator could resolve the name at runtime by using the <a href="https://docs.python.org/3/library/typing.html#typing.get_type_hints" rel="nofollow noreferrer"><code>typing.get_type_hints()</code> function</a> (at a deferred time, not at decoration time), or by wrapping strings in your <code>lazy()</code> callable at decoration time.</p>
<p>If <code>lazy()</code> is meant to flag a type to be treated differently from other type hints, then you are trying to overload the type hint annotations with some other meaning, and type hinting <em>simply doesn't support such use cases</em>, and using a  <code>Lazy[...]</code> containing can't make it work.</p>
</div>
<span class="comment-copy">This is much better way of defining custom type annotations. Though it will break code completion features as well.</span>
<span class="comment-copy">@RodrigoMartins: yes, I was in the process of noting this. I don't think you really want to use the <code>Container[Contained]</code> notation here, it doesn't apply to your situation.</span>
<span class="comment-copy">First, to just get this out of the way: I don't intent to hack a way to fool the IDE into thinking that <code>Lazy[A]</code> is of type <code>A</code>. I the same that is observed when using <code>Union[A, B]</code>: IDE will code-complete attributes of <code>A</code> and <code>B</code> because <code>Union</code> behaves like a proxy.  The decorator supports string annotations and lazily resolving the name, but it is not intended that annotating your typing with a string will automatically force lazy initialization of the dependency. The lazy initialization feature is meant to be used only when explicitly requested by the caller.</span>
<span class="comment-copy">Second: As you noticed, my <code>lazy()</code> function is there only to flag a type to be lazy initialized. But this does not mean to be treated differently by the IDE.  I disagree with "<i>type hinting simply doesn't support such use cases</i>", once my decorator has access to the <code>Lazy[A]</code> annotation it can apply special behavior based on the existence of a class member, say <code>Lazy.__lazy_init__</code>.  I gave the context of lazy init to better justify why I need this. But in the end, regardless of whatever, I want to define a container type <code>Container[Type]</code> that will show code completions to <code>Type</code>.</span>
<span class="comment-copy">@RodrigoMartins: your <i>code</i> can treat <code>Lazy</code> differently, but type hinting consumers like your IDE won't. <code>Union</code> has specific meaning in the type hinting spec, so it is indeed treated as a proxy by the IDE. It does so because the spec tells it to. There is no provision in the specs to support user-defined proxies however.</span>
