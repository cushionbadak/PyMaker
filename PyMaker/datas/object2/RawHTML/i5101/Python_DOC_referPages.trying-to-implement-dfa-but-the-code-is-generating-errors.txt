<div class="post-text" itemprop="text">
<p><strong>Code:-</strong></p>
<pre><code>#Shortest DFA implementation in Python
S,D,F=input()
s=1
for c in S:s=D[s,c]
print(["Not a chance!","Accepted!"][F&amp;s&gt;0])
</code></pre>
<p><strong>Input:-</strong> 
Input is a triple of string S, a delta function D, and final state mask F. I number each state with a power of 2, so F is just the OR of each accepting state.  D is a map from (state,input char) -&gt; state.</p>
<p>Example input (accepts all strings ending in b):</p>
<pre><code>'abab',{(1,'a'):1,(1,'b'):2,(2,'a'):1,(2,'b'):2},2
</code></pre>
<p><strong>Output:-</strong></p>
<pre><code>---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-32-506f09a31940&gt; in &lt;module&gt;()
      1 #Shortest DFA implementation in Python
----&gt; 2 S,D,F=input()
      3 s=1
      4 for c in S:s=D[s,c]
      5 print(["Not a chance!","Accepted!"][F&amp;s&gt;0])

ValueError: too many values to unpack (expected 3)
</code></pre>
<p>Similarly, the following code is for implementing an NFA. But it is throwing a different kind of error, even after adding the eval(). The code is as follows:-</p>
<pre><code>#Shortest NFA implementation
S,D,F=eval(input())
s=1
for c in S:
 t,s=s,0
 for a,b in D[c]:s|=t/a%2*b
print(["Not a chance!","Accepted!"][F&amp;s&gt;0])
</code></pre>
<p><strong>Input:-</strong>
We number states as powers of 2 as before.  D is a map from input character to a list of transitions labelled by that character.</p>
<p>example input (accepts all strings ending in b):</p>
<pre><code>'abab',{'a':[(1,1)],'b':[(1,1),(1,2)]},2
</code></pre>
<p><strong>The output obtained is:-</strong></p>
<pre><code>'abab',{'a':[(1,1)],'b':[(1,1),(1,2)]},2
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-34-7e5418d2d6fc&gt; in &lt;module&gt;()
      4 for c in S:
      5  t,s=s,0
----&gt; 6  for a,b in D[c]:s|=t/a%2*b
      7 print(["Not a chance!","Accepted!"][F&amp;s&gt;0])

TypeError: unsupported operand type(s) for |=: 'int' and 'float'
</code></pre>
<p>Please tell me the necessary but minimal modifications required in the above codes for it to execute successfully and produce the desired output. </p>
</div>
<div class="post-text" itemprop="text">
<p>This code is valid in Python 2, not in Python 3.  I suspect the code is actually designed for Python 2 when you are using Python 3.  <a href="https://docs.python.org/2/library/functions.html#input" rel="nofollow noreferrer"><code>input</code></a> in Python 2 not only reads in a string from the input, but it also performs an <a href="https://docs.python.org/2/library/functions.html#eval" rel="nofollow noreferrer"><code>eval</code></a> statement which means that it will take the string and convert it into Python syntax.  <a href="https://docs.python.org/3/library/functions.html#input" rel="nofollow noreferrer"><code>input</code></a> in Python 3 returns a string of what you put in.  The <code>eval</code> is not performed anymore as you see in Python 2.  To mimic what you see in Python 2, you need to run <code>eval</code> on top of <code>input</code>:</p>
<pre><code>In [1]: S,D,F = eval(input())
'abab',{(1,'a'):1,(1,'b'):2,(2,'a'):1,(2,'b'):2},2

In [2]: S
Out[2]: 'abab'

In [3]: D
Out[3]: {(1, 'a'): 1, (1, 'b'): 2, (2, 'a'): 1, (2, 'b'): 2}

In [4]: F
Out[4]: 2
</code></pre>
<h1>Edit</h1>
<p>With your new code that you're running, the culprit is the division operation in the loop: <code>t/a</code>.  This returns a floating-point number by default whereas in Python 2, if <code>t</code> and <code>a</code> are both integers, it will return an integer.  You have to be careful running Python 2 code in a Python 3 environment.  Simply wrap <code>t/a</code> in an <code>int</code> call: <code>int(t/a)</code>.</p>
<pre><code>In [7]: S,D,F=eval(input())
   ...: s=1
   ...: for c in S:
   ...:  t,s=s,0
   ...:  for a,b in D[c]:s|=int(t/a)%2*b
   ...: print(["Not a chance!","Accepted!"][F&amp;s&gt;0])
   ...:
'abab',{'a':[(1,1)],'b':[(1,1),(1,2)]},2
Accepted!
</code></pre>
<p>My final note to you is to be exceptionally careful running Python 2 code in a Python 3 environment.  If possible, run the code in the environment it's designed for.  If not, this useful comparison guide of idioms from Python 2 to Python 3 should help: <a href="http://python-future.org/compatible_idioms.html" rel="nofollow noreferrer">http://python-future.org/compatible_idioms.html</a>.  In particular:</p>
<ul>
<li><code>input</code>: <a href="http://python-future.org/compatible_idioms.html#input" rel="nofollow noreferrer">http://python-future.org/compatible_idioms.html#input</a></li>
<li>... and finally the division operator: <a href="http://python-future.org/compatible_idioms.html#division" rel="nofollow noreferrer">http://python-future.org/compatible_idioms.html#division</a></li>
</ul>
</div>
<span class="comment-copy">#Shortest NFA implementation S,D,F=eval(input()) s=1 for c in S:  t,s=s,0  for a,b in D[c]:s|=t/a%2*b print(["Not a chance!","Accepted!"][F&amp;s&gt;0])</span>
<span class="comment-copy">@AkashDas I ran this code and I got <code>Accepted!</code> as the output.</span>
<span class="comment-copy">I made the eval() modification to the DFA program and it ran fine. The code I have commented is for implementing NFA. I have modified the question accordingly. I am using Python 3. I have mentioned the error obtained as well. Can you please take a look and tell me if you come up with something. Thanks!</span>
<span class="comment-copy"><code>t/a</code> returns a floating-point number by default whereas in Python 2, if <code>t</code> and <code>a</code> are both integers, it will return an integer.  You have to be careful running Python 2 code in a Python 3 environment.  Simply wrap <code>t/a</code> in an <code>int</code> call: <code>int(t/a)</code>.  I'll edit my post.</span>
<span class="comment-copy">Thanks a tonne for all your help.</span>
