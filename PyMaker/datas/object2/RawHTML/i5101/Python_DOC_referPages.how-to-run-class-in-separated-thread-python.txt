<div class="post-text" itemprop="text">
<p>I have two classes in Python script. One of is <code>Main()</code> and the second is <code>Loading()</code></p>
<pre><code>class Main:
   pass

class Loading:
   pass
</code></pre>
<p>At first, works <code>Main()</code> that return was filled dictionary</p>
<p>Then is created instance of <code>Loading()</code> that iterates all images and downloads them:</p>
<pre><code>## LOAD IMAGES ##
imageLoader = Loading()
imageLoader.save()
</code></pre>
<p>So, the problem is when I call this script it creates one major thread that is waiting for the end of <code>imageLoader = Loading()</code>.</p>
<p>As a result, a major thread works so long, it invokes 502 Server error.</p>
<p>How to run <code>imageLoader = Loading()</code> in a separate background thread that to release major thread?</p>
<p>What will be launched first in this code:</p>
<pre><code>LOADED_IMAGES = {}
IMAGES_ERRORS = []
IMAGES = {"A": "https://images.aif.ru/009/299/3378e1a1ab2d1c6e6be6d38253dd3632.jpg", "B": "http://static1.repo.aif.ru/1/77/623957/b99ee5f894f38261e4d3778350ffbaae.jpg"}

    excel = Excel()
    excel.readExcel(file_path, 'Main')

    imageLoader = ImageLoader()
    Thread(target=imageLoader.run().save()).start()

Does it work line by line or Thread will be created immediately?


**This is full code:**

    class ImageLoader:
        def run(self):
            for article, image in IMAGES.items():
                if image is None or image == '':
                    continue
                LOADED_IMAGES[article] = self.loadImage(self.replaceHttpsProtocol(image), '/home/o/oliwin4/jara/public_html/image/catalog/s/')

        def replaceHttpsProtocol(self, url):
            return url.replace("https:", "http:")

        def nameNameGenerate(self):
            return int(round(time.time() * 1000))

        def extention(self, path):
            ext = path.split(".")[-1]
            return '.' + ext if ext else "jpg"

        def save(self):
            for article, image in LOADED_IMAGES.items():
                self.add(article, image)

        def add(self, article, image):
            Products.update(image=image).where(Products.sku == article).execute()

        def loadImage(self, path, path_folder):
            try:

                filename = str(self.nameNameGenerate()) + str(self.extention(path))
                wget.download(url=path, out=path_folder + filename)
                return 'catalog/s/' + filename

            except BaseException as e:
                IMAGES_ERRORS.append(str(e))
</code></pre>
<p><strong>Using:</strong></p>
<pre><code>def runOnThread():
    imageLoader = ImageLoader()
    imageLoader.run()
    imageLoader.save()

if __name__ == "__main__":
     Thread(target=runOnThread, daemon=True).start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to look for which line is blocking your code to run it in a separated thread, usually the blocking line is some kind of I/O or expensive computation.</p>
<p>To do it you can use the threading module.</p>
<p>So, assuming that your blocking line is the</p>
<pre><code>imageLoader.save()
</code></pre>
<p>Try to run it in a separated thread with this code.</p>
<pre><code>from threading import Thread

Thread(target=imageLoader.save()).start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned, you can use Python's <code>threading</code> module for this. Though, a thread takes a reference to a function (passing <code>target</code> a function call is useless / wrong).</p>
<p>In your case, if you want to both instantiate then run a function on an object in a separate thread, you should put these two in a function:</p>
<pre><code>def runOnThread():
    imageLoader = Loading()
    imageLoader.save()
</code></pre>
<p>Then pass a reference of this function to a new thread, like so (notice no <code>()</code>):</p>
<pre><code>from threading import Thread
Thread(target=runOnThread).start()
</code></pre>
<p>If you don't want the main thread to wait for the new thread to finish, you could make it a <a href="https://docs.python.org/3/library/threading.html#thread-objects" rel="nofollow noreferrer">Daemon</a> thread, like so:</p>
<pre><code>Thread(target=runOnThread, daemon=True).start()
</code></pre>
<hr/>
<p>Shorter version of all the above:</p>
<pre><code>from threading import Thread
Thread(target=lambda: Loading().save(), daemon=True).start()
</code></pre>
</div>
<span class="comment-copy">After you used the threaded code, what is the error you getting?</span>
<span class="comment-copy">Also in your code you have this piece of code above your class definition, isn't that making the code run twice? "    imageLoader = ImageLoader()     Thread(target=imageLoader.run().save()).start()"</span>
<span class="comment-copy">How to put this to <code>Thread</code>? <code>imageLoader = Loading()</code> and then call <code>imageLoader.save()</code>?</span>
<span class="comment-copy">I don't know the insides of your Loading() class, does it get blocked only on the line imageLoader.save()? If so, you can use Thread(target=imageLoader.save()).start(). It will run this line in another thread.</span>
<span class="comment-copy">Be careful, because this will run separately, so if you wan't to do something after this thread finish its job, you need to wait for it to finish. To do that you use the method join(). (ex.: t1 = Thread(target=some_function()).start() and them t1.join() -&gt; this wait the thread to finish. So usually you start a bunch of threads and them wait them all to finish to do some work.</span>
<span class="comment-copy">I dont need that main thread wait ti finish child thread</span>
<span class="comment-copy">So just run the thread with start and you'll be fine :)</span>
<span class="comment-copy">Main thread is waiting  still finishing <code>Loading()</code></span>
<span class="comment-copy">@Amely check my update</span>
<span class="comment-copy">I get twice call of ` Loading()` I dont know why</span>
<span class="comment-copy">@Amely show the code you've just tested (on pastebin or something)</span>
<span class="comment-copy">Okay, it works unpredictably</span>
