<div class="post-text" itemprop="text">
<p>I am using Python 3.6 to process the data I receive in a text file containing a Dict having sorted keys. An example of such file can be:</p>
<blockquote>
<p>{"0.1":"A","0.2":"B","0.3":"C","0.4":"D","0.5":"E","0.6":"F","0.7":"G","0.8":"H","0.9":"I","1.0":"J"}</p>
</blockquote>
<p>My data load and transform is simple - I load the file, and then transform the dict into a list of tuples. Simplified it looks like this:</p>
<pre><code>import json
import decimal

with open('test.json') as fp:
    o = json.loads(fp.read())

l = [(decimal.Decimal(key), val) for key, val in o.items()]
is_sorted = all(l[i][0] &lt;= l[i+1][0] for i in range(len(l)-1))
print(l)
print('Sorted:', is_sorted)
</code></pre>
<p>The list is always sorted in Windows and never in Linux. I know that I can sort the list manually, but since the data file is always sorted already and rather big, I'm looking for a different approach. Is there a way to somehow force json package to load the data to my dict sorted in both Windows and Linux?</p>
<p>For the clarification: I have no control over the structure of data I receive. My goal is to find the most efficient method to load the data into the list of tuples for further processing from what I get.</p>
</div>
<div class="post-text" itemprop="text">
<p>A <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">dictionary</a> is just a mapping between its keys and corresponding values. It doesn't have any order. It doesn't make sense to say you always find them sorted. In addition, any dictionary member access is <code>O(1)</code> so it's probably fast enough for your need. In case you think you still need some order, <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">ordered dictionary</a> may be useful. </p>
</div>
<div class="post-text" itemprop="text">
<p>Dicts are unordered objects in Python, so the problem you're running into is actually by design.</p>
<p>If you want to get a sorted list of tuples, you can do something like:</p>
<p><code>sorted_tuples = sorted(my_dict.items(),key=lambda x:x[0])
</code></p>
<p>or</p>
<p><code>import operator
sorted_tuples = sorted(my_dict.items(),key=operator.itemgetter(0)</code></p>
<p>The dict method <code>.items()</code> converts the dict to a list of tuples and <code>sorted()</code> sorts that list. The <code>key</code> parameter to sorted explains how to sort the list. Both <code>lambda x: x[0]</code> and <code>operator.itemgetter(0)</code> select the first element of the tuple (the key from the original dict), and sort on that element.</p>
</div>
<span class="comment-copy">Dictionaries (and JSON maps/objects, for that matter) <i>aren't</i> ordered data structures. If order matters, use an ordered structure (e.g. JSON array, which converts to a Python list).</span>
<span class="comment-copy">I doubt you're really using Python 3.6 in Linux.</span>
<span class="comment-copy">I don't see the point of using that key. Can that ever make a difference?</span>
<span class="comment-copy">There are some issues with using anonymous/lambda functions in Python (e.g., they're not compatible with the standard pickle operation). I think <code>operator.itemgetter(n)</code> is slightly faster than <code>lambda x:x[n]</code>. Also: some organizations don't like the using of lambdas at all, while others prefer it. YMMV.</span>
<span class="comment-copy">No I mean why don't you just do <code>sorted(my_dict.items())</code> <i>without</i> a key?</span>
<span class="comment-copy">For this instance you wouldn't need to. The default key works just fine. That said, it's good to know about the <code>key=</code> parameter more generally.</span>
