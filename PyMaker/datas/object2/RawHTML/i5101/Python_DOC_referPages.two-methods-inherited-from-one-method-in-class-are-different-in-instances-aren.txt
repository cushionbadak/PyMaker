<div class="post-text" itemprop="text">
<p>Can someone please explain why it is so?</p>
<pre><code>class Foo:
    def bar(self):
        pass

a = Foo()
b = Foo()

a.bar == b.bar # False
a.bar is b.bar # False
</code></pre>
<p>I thought that they both inherit the class method and it's the one method.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you access a function through an instance that is defined on the class, a <em>bound-method</em> object is created each time. From the <a href="https://docs.python.org/3.6/tutorial/classes.html#method-objects" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>What exactly happens when a method is called? You may have noticed
  that <code>x.f()</code> was called without an argument above, even though the
  function definition for <code>f()</code> specified an argument. What happened to
  the argument? Surely Python raises an exception when a function that
  requires an argument is called without any — even if the argument
  isn’t actually used…</p>
<p>Actually, you may have guessed the answer: the special thing about
  methods is that the instance object is passed as the first argument of
  the function. In our example, the call <code>x.f()</code> is exactly equivalent to
  <code>MyClass.f(x)</code>. In general, calling a method with a list of n arguments
  is equivalent to calling the corresponding function with an argument
  list that is created by inserting the method’s instance object before
  the first argument.</p>
<p>If you still don’t understand how methods work, a look at the
  implementation can perhaps clarify matters. <strong>When an instance attribute
  is referenced that isn’t a data attribute, its class is searched. If
  the name denotes a valid class attribute that is a function object, a
  method object is created by packing (pointers to) the instance object
  and the function object just found together in an abstract object:
  this is the method object.</strong></p>
</blockquote>
<p>Note, this happens <em>every time you access a method</em>:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...    def bar(self): pass
...
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.bar is f.bar
False
</code></pre>
<p>How does this work? Well, actually, <a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="nofollow noreferrer">functions <em>are descriptor objects</em></a>, note the presence of a <code>__get__</code>:</p>
<pre><code>&gt;&gt;&gt; def func(): pass
...
&gt;&gt;&gt; func.__get__
&lt;method-wrapper '__get__' of function object at 0x101e38ae8&gt;
</code></pre>
<p>In other words, you can think of Python functions as being implemented thusly:</p>
<pre><code>class Function(object):
    . . .
    def __get__(self, obj, objtype=None):
        "Simulate func_descr_get() in Objects/funcobject.c"
        if obj is None:
            return self
        return types.MethodType(self, obj)
</code></pre>
<p>Of course, they aren't implemented in Python (in CPython at least!).</p>
<p>Also note, accessing the function directly on the class, of course, doesn't do this (at least on Python 3, which you've tagged on your question):</p>
<pre><code>&gt;&gt;&gt; Foo.bar is Foo.bar
True
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/1227121/compare-object-instances-for-equality-by-their-attributes-in-python">Compare object instances for equality by their attributes in Python</a></span>
