<div class="post-text" itemprop="text">
<p>My thought was to get rid of how users are constantly using <code>seek(0)</code> to reset the text file reading. </p>
<p>So instead I've tried to create a <code>MyReader</code> that's an <code>collections.Iterator</code> and then using <code>.reset()</code> to replace <code>seek(0)</code> and then it continues from where it last yielded by retaining a <code>self.iterable</code> object. </p>
<pre><code>class MyReader(collections.Iterator):
    def __init__(self, filename):
        self.filename = filename
        self.iterable = self.__iterate__()

    def __iterate__(self):
        with open(self.filename) as fin:
            for line in fin:
                yield line.strip()

    def __iter__(self):
        for line in self.iterable:
            yield line

    def __next__(self):
        return next(self.iterable)

    def reset(self): 
        self.iterable = self.__iterate__()
</code></pre>
<p>The usage would be something like:</p>
<pre><code>$ cat english.txt
abc
def
ghi
jkl

$ python

&gt;&gt;&gt; data = MyReader('english.txt')
&gt;&gt;&gt; print(next(data))
abc
&gt;&gt;&gt; print(next(data))
def
&gt;&gt;&gt; data.reset()
&gt;&gt;&gt; print(next(data))
abc
</code></pre>
<p>My question is <strong>does this already exist in Python-verse somewhere?</strong> Esp. if there's already a native object that does something like this, I would like to avoid reinventing the wheel =)</p>
<p>If it doesn't exist? <strong>Does the object look a little unpythonic?</strong> Since it says it's an iterator but the true Iterator is actually the <code>self.iterable</code> and the other functions are wrapping around it to do "resets". </p>
</div>
<div class="post-text" itemprop="text">
<p>I think it depends on what is your real situation. Let's say if you just want to get rid of <code>file.seek(0)</code>, it can be simple:</p>
<pre><code>class MyReader:
    def __init__(self, filename, mode="r"):
        self.file = open(filename, mode)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    def __iter__(self):
        self.file.seek(0)
        for line in self.file:
            yield line.strip()

    def close(self):
        self.file.close()
</code></pre>
<p>You can even use it like a normal context manager:</p>
<pre><code>with MyReader("a.txt") as a:
    for line in a:
        print(line)
    for line in a:
        print(line)
</code></pre>
<p>output:</p>
<pre><code>sdfas
asdf
asd
fas
df
asd
f
sdfas
asdf
asd
fas
df
asd
f
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have a couple of criticisms of your <code>MyReader</code> class. I <em>was</em> going to post an alternative that's a <a href="https://docs.python.org/3/reference/datamodel.html#context-managers" rel="nofollow noreferrer">context manager</a> but Sraw beat me to it. ;)</p>
<p>You shouldn't use names that start and end with double underscores like <code>__iterate__</code>. Such names are essentially reserved for the language implementors, and if an official <code>__iterate__</code> magic method is added to the language your code will break. If you want a private method, you could name it <code>_iterate</code>. </p>
<p>There is a little problem with that <code>__iterate__</code> method: its <code>with</code> block is only exited when the file has been completely read for the current <code>self.iterable</code>, so if the <code>MyReader</code> instance gets reset then you have an old open file sitting around, consuming a file descriptor. Sure, it'll get closed eventually, when the program exits (or you delete the <code>MyReader</code> instance), but it's messy IMHO.</p>
<p>Also, I'm not totally happy with the <code>yield line.strip()</code>. Sure, it's convenient most of the time when you're reading a text file, but in some cases the caller may want to look at any leading or trailing white space, and you've taken that option away from them.</p>
<p>BTW, that <code>__iter__</code> method is redundant: your class still does what its supposed to do if you eliminate that method.</p>
</div>
<span class="comment-copy">Did you even test your snippet? It is totally not executable. Missing <code>self</code> in <code>__init__</code>, <code>filename</code> in <code>__iterate__</code> is undefined.</span>
<span class="comment-copy">Sorry I was abstracting from a bigger class. Now it should work.</span>
<span class="comment-copy">File-like objects already do something like this --you get the same output if you do <code>data = open('english.txt')</code> and <code>data.seek(0)</code> instead of <code>data.reset()</code>. What does using <code>data.reset()</code> instead of <code>data.seek(0)</code> buys you?</span>
<span class="comment-copy">Ah so instead of <code>Iterator</code> I could have inherit from <code>File</code>? Hmmm, the object does many more things though =)</span>
<span class="comment-copy">Thank you! Your answer gave me many teachable moments.</span>
<span class="comment-copy">BTW, with <code>__next__</code>, Python automatically infers <code>__iter__</code> ?</span>
