<div class="post-text" itemprop="text">
<p>I'm trying to catch an exception inside of a function, and handle it outside of the function in the top level functionality. I found a lot of great resources for creating a user defined function, as well as how I can catch them using <code>raise</code>, however it's not working out how I would expect.</p>
<p>I have defined two functions, <code>DontThrow</code> and <code>MyException</code>. Nothing ever catches <code>DontThrow</code> so it should never be handled, but yet the second my code gets to the class delcaration, it does exactly why I titled it not to do! It's like python is reading from the top down doing everything regardless of if it's caught anything</p>
<p>How can I cause my exceptions to only handle if they are raised?</p>
<pre><code>import sys

class DontThrow(Exception):
    print("You shouldn't see this")
    sys.exit(1)

class MyException(Exception):
    print("Bad exception")
    sys.exit(1)

def main():
    x = 5
    try:
        if x &lt; 6:
          raise MyException
    finally:
        pass
</code></pre>
<p>Output:<br/>
<code>You shouldn't see this
</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Python exceptions are classes, and classes are executed at the time of definition.</p>
<p>For example consider this code:</p>
<pre><code>import sys
class test:
    print("hey")
    sys.exit()
</code></pre>
<p>In this <code>test</code> is never instantiated but the print statement will be called. I suspect this is a surprise for you, but it is the cause of the behavior you see.</p>
<p>If you want to have your exceptions quit the program have that behavior in the <code>except</code> block, not in the exception itself.</p>
<p>How this would work with your current exception hierarchy would be something like this:</p>
<pre><code>import sys

class DontThrow(Exception):
    pass

class MyException(Exception):
    pass

def main():
    x = 5
    try:
        if x &lt; 6:
            raise MyException
    except DontThrow:
        print("You shouldn't see this")
        sys.exit(1)
    except MyException:
        print("Bad exception")
        sys.exit(1)
    else:
        print("no exception was thrown")
    finally:
        print("This always gets called")

if __name__ == "__main__":
    main()
</code></pre>
<p>Note that an uncaught exception will exit the program anyway, so if something isn't caught there's no need to try to call <code>sys.exit()</code> directly</p>
</div>
<div class="post-text" itemprop="text">
<p>It is depend on the order of class definition.If you change the order like below than the output is like Bad exception</p>
<pre><code>import sys

class MyException(Exception):
    print("Bad exception")
    sys.exit(1)

class DontThrow(Exception):
    print("You shouldn't see this")
    sys.exit(1)

def main():
    x = 5
    try:
        if x &lt; 6:
          raise MyException
    finally:
        pass
</code></pre>
</div>
<span class="comment-copy">May be this will help you in some way <a href="https://stackoverflow.com/questions/1319615/proper-way-to-declare-custom-exceptions-in-modern-python" title="proper way to declare custom exceptions in modern python">stackoverflow.com/questions/1319615/â€¦</a></span>
<span class="comment-copy">@ArpitSolanki I actually say that, and have another example I tried using the same class definition. I didn't spend too much time on it given that it was 8 years old, and the differences between python 2 and 3 seem major from what I can tell. How do I know if an 8 year old post is still valid?</span>
<span class="comment-copy">I tried those and they are perfectly valid. At least the top ones and reliable ones</span>
<span class="comment-copy"><b>"It's like python is reading from the top down"</b> -- well that's exactly how Python interprets a program. You may also want to read: <a href="https://docs.python.org/3/reference/executionmodel.html" rel="nofollow noreferrer">docs.python.org/3/reference/executionmodel.html</a></span>
<span class="comment-copy">Thanks! I didn't even know it was called execution model, so that's a big help.</span>
<span class="comment-copy">yeah coming from c++, that's not at all how i'm used to things working.</span>
<span class="comment-copy">@Podo c++ is very different in this regard, run-time code in C++ is only ever executed after a class is instantiated. (sure the metaprogramming bit is a bit different but that is at compile time, perhaps the default behavior of python is a bit more like c++ metaprogramming in regards to <i>when</i> things happen although it's very different in the details of course.)</span>
<span class="comment-copy">So then is it not possible to catch an exception inside of a function and have it actually handle the exception outside of a function?</span>
<span class="comment-copy">@Podo, I'll make an edit and you can explain if this is what you mean</span>
<span class="comment-copy">@Podo <a href="https://ideone.com/g61tHf" rel="nofollow noreferrer">It's possible</a>, you just need to move the code in your classes to <code>__init__</code> method.  But raising another exception from an exception doesn't make much sense, the proper way, like shuttle87 mentioned is to handle it in an <code>except</code> block based on the exception raise.</span>
<span class="comment-copy">That fails to fix the problem, rather swapping the two to still have a bad result.</span>
