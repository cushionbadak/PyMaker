<div class="post-text" itemprop="text">
<p>What is the algorithmic difference between math.ceil() and round() when trailing decimal points are &gt;= 0.5 in Python 3?</p>
<p>For example,</p>
<pre><code>round(9.5) = 10
round(9.67) = 10
math.ceil(9.5) = 10
math.ceil(9.5) = 10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/functions.html#round" rel="noreferrer">docs</a>,</p>
<blockquote>
<p>[...] if two multiples are equally close, rounding is done toward the even
  choice (so, for example, both round(0.5) and round(-0.5) are 0, and
  round(1.5) is 2).</p>
</blockquote>
<p>However, <code>math.ceil</code> will always "round" up. I.e. the smallest integer greater than or equal to the input.</p>
<p>Moreover, <code>round</code> and <code>math.ceil</code> differ greatly when executing on negative numbers.</p>
<pre><code>&gt;&gt;&gt; math.ceil(-2.8)
-2
&gt;&gt;&gt; round(-2.8)
-3
</code></pre>
</div>
<span class="comment-copy">Try an input of <code>8.5</code>.</span>
<span class="comment-copy">@MarkDickinson why does that happen? floating point binary issue?</span>
<span class="comment-copy">@Skyler: No: it's an explicit choice in Python 3 to round halfway cases to the nearest <i>even</i> number. That's the default IEEE 754 rounding mode (roundTiesToEven), and Python isn't alone in using it by default for rounding.</span>
