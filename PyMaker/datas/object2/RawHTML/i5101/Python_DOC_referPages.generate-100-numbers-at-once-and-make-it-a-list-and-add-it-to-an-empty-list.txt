<div class="post-text" itemprop="text">
<p><strong>I need to generate 100 numbers from 1-500 and append it to an empty list</strong>, but I don't know how to fix my code. There is a &lt;'none'&gt; at the end when I print it. And when I used a len function to count a, it only says 1, so it didn't really added the 100 numbers. </p>
<pre><code>a = []
import random
print("original: \n")
for x in range(100):
    nums = random.randint(1,501)
    b = print(nums, end=" ")

a.append(b)
print(a)
print(len(a))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>On python-3.6, you can use <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices</code></a>, and extend <code>a</code> by this function's return value:</p>
<pre><code>a.extend(random.choices(range(1, 501), k=100))
</code></pre>
<p>Although, if you're starting off with an empty list and adding nothing before this step, it would make more sense to just initialise <code>a</code> as </p>
<pre><code>a = random.choices(range(1, 501), k=100)
</code></pre>
<p>Without doing any empty-list initialisation before.</p>
<p>If you're on older versions of python, use <a href="https://docs.python.org/3/library/random.html#random.randint" rel="nofollow noreferrer"><code>random.randint</code></a> in a loop.</p>
<pre><code>a.extend(random.randint(1, 500) for _ in range(100))  
</code></pre>
<p>Or, </p>
<pre><code>a = [random.randint(1, 500) for _ in range(100)]
</code></pre>
<p>Alternatively, </p>
<pre><code>a = []
for _ in range(100):
    a.append(random.randint(1, 500))
</code></pre>
<p>From the docs, I believe the upper bound is inclusive (hence, <code>500</code>). </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>nums = random.randint(1,501)
</code></pre>
<p>This returns <em>a single</em> random number, so the plural name “nums” is misleading here.</p>
<pre><code>b = print(nums, end=" ")
</code></pre>
<p>The <code>print</code> function prints something, in this case the generated number, but itself has no return value. So <code>b</code> will be <code>None</code>.</p>
<pre><code>a.append(b)
</code></pre>
<p>This could <em>theoretically</em> append the generated number to the list. However, as we established, <code>b</code> is <code>None</code>, so this will append <code>None</code> to the list. Furthermore, this line is <em>outside of the loop</em>, so this will only run once, and would only add a single of your 100 numbers.</p>
<p>You should do something like this instead:</p>
<pre><code>a = []
for x in range(100):
    num = random.randint(1,501)
    a.append(num)

print(a)
print(len(a))
</code></pre>
<p>You can also use a list comprehension here, to make it simpler:</p>
<pre><code>a = [random.randint(1, 501) for x in range(100)]
print(a)
print(len(a))
</code></pre>
<p>This will have the same result.</p>
<p>You could also use <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices</code></a> which on its own is already capable of generating a list of random numbers with a specified size. So this would work just as well:</p>
<pre><code>a = random.choices(range(1, 501), k=100)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe this is what you are looking for. <code>print</code> does not return anything, you cannot add <code>print</code> onto a list. In fact, it's not clear why you need 2 variables for this.</p>
<pre><code>import random

a = []

for x in range(100):
    a.append(random.randint(1,501))

print(' '.join(map(str, a)))

print(len(a))
</code></pre>
<p>An alternative solution which avoids loops uses the <code>numpy</code> library:</p>
<pre><code>import numpy as np

a = np.random.randint(1, 501, 100)
</code></pre>
<p><em>If</em> performance is an issue; e.g. for many, large random lists; here is benchmarking versus a valid list-based solution using <code>random</code>:</p>
<pre><code>import numpy as np
import random

%timeit np.random.randint(1, 501, 100)        # 5.97 µs
%timeit random.choices(range(1, 501), k=100)  # 66.3 µs
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>randint() function generate only one random number. You can generate the random in a for loop 100 times &amp; simulatenosuly append in the list so when outside the for loop ,the list 'a' have the 100 random numbers &amp; this can be verified through length len() function .</p>
<p>Also I am attach the screenshot of the output.</p>
<pre><code>a = []
import random
print("original: \n")
for x in range(100):
  nums = random.randint(1,501)
  a.append(nums)

print("Numbers : " , a)
print("Length : " , len(a))
</code></pre>
<p><a href="https://i.stack.imgur.com/VRLcz.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/VRLcz.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Your code was correct just a little mistake that is you don't have indented the <code>a.append(nums)</code>, So that become out side the scope of <code>for</code> loop. Try this code :) .</p>
<pre><code>import random

a = []
print("original: \n")

for x in range(100):
    nums = random.randint(1,501) 
    print(nums, end=" ") 
    a.append(nums) 

print(a) 
print(len(a))
</code></pre>
</div>
<span class="comment-copy"><code>print</code> function returns <code>None</code>. You should do <code>a.append(nums)</code> inside the for loop and you can get rid of <code>b =</code>, just do the <code>print(nums, end=" ")</code></span>
<span class="comment-copy">You could do it in one row like this: <code>a = [random.randint(1, 500) for _ in range(100)] </code>. This is referred to as a list-comprehension.</span>
<span class="comment-copy">@Laire, did one of the below solutions solve your problem? If so, feel free to accept (tick on left), so other users know.</span>
<span class="comment-copy">Yes, I think extend is the way to go. For readability we could do it in two rows with a generator in the first. But that's just cosmetics +1</span>
<span class="comment-copy">@AntonvBR I can only assume that part of the question is an XY problem. ;/</span>
<span class="comment-copy">numpy is a better option, here we don't have to maintain the list.</span>
<span class="comment-copy">@jiteshmohite Can you explain what you mean by "don't have to maintain the list"?</span>
<span class="comment-copy">Please don’t add benchmarks to answers when the question is not explicitly about performance. That gives just the false impression that this is actually relevant, when instead it’s much more likely that there are very different bottlenecks in an application that make these micro optimization very negligible. Especially considering that the difference here is in microseconds…</span>
<span class="comment-copy">@poke, Good point. I've handled many instances (e.g. MC simulations), where it can be an issue, so I have added a disclaimer about performance.</span>
