<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/16134281/python-mocking-a-function-from-an-imported-module">Python Mocking a function from an imported module</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I would like to test a email sending method I wrote. In file, format_email.py I import send_email.</p>
<pre><code> from cars.lib.email import send_email

 class CarEmails(object):

    def __init__(self, email_client, config):
        self.email_client = email_client
        self.config = config

    def send_cars_email(self, recipients, input_payload):
</code></pre>
<p>After formatting the email content in send_cars_email() I send the email using the method I imported earlier. </p>
<pre><code> response_code = send_email(data, self.email_client)
</code></pre>
<p>in my test file test_car_emails.py</p>
<pre><code>@pytest.mark.parametrize("test_input,expected_output", test_data)
def test_email_payload_formatting(test_input, expected_output):
    emails = CarsEmails(email_client=MagicMock(), config=config())
    emails.send_email = MagicMock()
    emails.send_cars_email(*test_input)
    emails.send_email.assert_called_with(*expected_output)
</code></pre>
<p>When I run the test it fails on assertion not called. I believe The issue is where I am mocking the send_email function. </p>
<p>Where should I be mocking this function?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you are mocking with the line <code>emails.send_email = MagicMock()</code> is the function</p>
<pre><code>class CarsEmails:

    def send_email(self):
        ...
</code></pre>
<p>that you don't have. This line will thus only <em>add</em> a new function to your <code>emails</code> object. However, this function is not called from your code and the assignment will have no effect at all. Instead, you should mock the function <code>send_email</code> from the <code>cars.lib.email</code> module.</p>
<h3>mocking the function where it is used</h3>
<p>Once you have imported the function <code>send_email</code> via <code>from cars.lib.email import send_email</code> in your module <code>format_email.py</code>, it becomes available under the name <code>format_email.send_email</code>. Since you know the function is called there, you can mock it under its new name:</p>
<pre><code>from unittest.mock import patch

from format_email import CarsEmails

@pytest.mark.parametrize("test_input,expected_output", test_data)
def test_email_payload_formatting(config, test_input, expected_output):
    emails = CarsEmails(email_client=MagicMock(), config=config)
    with patch('format_email.send_email') as mocked_send:
        emails.send_cars_email(*test_input)
        mocked_send.assert_called_with(*expected_output)
</code></pre>
<h3>mocking the function where it is defined</h3>
<p><strong>Update</strong>:</p>
<p>It really helps to read the section <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">Where to patch</a> in the <code>unittest</code> docs (also see the <a href="https://stackoverflow.com/questions/48812097/mocking-a-imported-function-with-pytest/48847105#comment84747994_48847105">comment</a> from <a href="https://stackoverflow.com/users/100297/martijn-pieters">Martijn Pieters</a> suggesting it):</p>
<blockquote>
<p>The basic principle is that you patch where an object is looked up, which is not necessarily the same place as where it is defined.</p>
</blockquote>
<p>So stick with the mocking of the function in usage places and don't start with refreshing the imports or aligning them in correct order. Even when there should be some obscure usecase when the source code of <code>format_email</code> would be inaccessible for some reason (like when it is a cythonized/compiled C/C++ extension module), you still have only two possible ways of doing the import, so just try out both mocking possibilities as described in <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">Where to patch</a> and use the one that succeeds.</p>
<p><strong>Original answer</strong>:</p>
<p>You can also mock <code>send_email</code> function in its original module:</p>
<pre><code>with patch('cars.lib.email.send_email') as mocked_send:
    ...
</code></pre>
<p>but be aware that if you have called the import of <code>send_email</code> in <code>format_email.py</code> before the patching, patching <code>cars.lib.email</code> won't have any effect on code in <code>format_email</code> since the function is already imported, so the <code>mocked_send</code> in the example below won't be called:</p>
<pre><code>from format_email import CarsEmails

...

emails = CarsEmails(email_client=MagicMock(), config=config)
with patch('cars.lib.email.send_email') as mocked_send:
    emails.send_cars_email(*test_input)
    mocked_send.assert_called_with(*expected_output)
</code></pre>
<p>To fix that, you should either import <code>format_email</code> for the first time after the patch of <code>cars.lib.email</code>:</p>
<pre><code>with patch('cars.lib.email.send_email') as mocked_send:
    from format_email import CarsEmails
    emails = CarsEmails(email_client=MagicMock(), config=config)
    emails.send_cars_email(*test_input)
    mocked_send.assert_called_with(*expected_output)
</code></pre>
<p>or reload the module e.g. with <code>importlib.reload()</code>:</p>
<pre><code>import importlib

import format_email

with patch('cars.lib.email.send_email') as mocked_send:
    importlib.reload(format_email)
    emails = format_email.CarsEmails(email_client=MagicMock(), config=config)
    emails.send_cars_email(*test_input)
    mocked_send.assert_called_with(*expected_output)
</code></pre>
<p>Not that pretty either way, if you ask me. I'd stick with mocking the function in the module where it is called.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you are using pytest, I would suggest using pytest's
built-in <a href="https://docs.pytest.org/en/latest/monkeypatch.html" rel="nofollow noreferrer">'monkeypatch'</a> fixture.</p>
<p>Consider this simple setup:</p>
<p>We define the function to be mocked.
</p>
<pre><code>"""`my_library.py` defining 'foo'."""


def foo(*args, **kwargs):
    """Some function that we're going to mock."""
    return args, kwargs
</code></pre>
<p>And in a separate file the class that calls the function.
</p>
<pre><code>"""`my_module` defining MyClass."""
from my_library import foo


class MyClass:
    """Some class used to demonstrate mocking imported functions."""
    def should_call_foo(self, *args, **kwargs):
        return foo(*args, **kwargs)
</code></pre>
<p>We mock the function <strong>where it is used</strong> using the 'monkeypatch' fixture
</p>
<pre><code>"""`test_my_module.py` testing MyClass from 'my_module.py'"""
from unittest.mock import Mock

import pytest

from my_module import MyClass


def test_mocking_foo(monkeypatch):
    """Mock 'my_module.foo' and test that it was called by the instance of
    MyClass.
    """
    my_mock = Mock()
    monkeypatch.setattr('my_module.foo', my_mock)

    MyClass().should_call_foo(1, 2, a=3, b=4)

    my_mock.assert_called_once_with(1, 2, a=3, b=4)
</code></pre>
<p>We could also factor out the mocking into its own fixture if you want to reuse it.
</p>
<pre><code>@pytest.fixture
def mocked_foo(monkeypatch):
    """Fixture that will mock 'my_module.foo' and return the mock."""
    my_mock = Mock()
    monkeypatch.setattr('my_module.foo', my_mock)
    return my_mock


def test_mocking_foo_in_fixture(mocked_foo):
    """Using the 'mocked_foo' fixture to test that 'my_module.foo' was called
    by the instance of MyClass."""
    MyClass().should_call_foo(1, 2, a=3, b=4)

    mocked_foo.assert_called_once_with(1, 2, a=3, b=4)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The simplest fix would be below</p>
<pre><code>@pytest.mark.parametrize("test_input,expected_output", test_data)
def test_email_payload_formatting(test_input, expected_output):
    emails = CarsEmails(email_client=MagicMock(), config=config())
    import format_email
    format_email.send_email = MagicMock()
    emails.send_cars_email(*test_input)
    format_email.send_email.assert_called_with(*expected_output)
</code></pre>
<p>Basically you have a module which has already imported <code>send_email</code> in the <code>format_email</code> and you have to update the loaded module now.</p>
<p>But it is not the most recommended way of doing it because you loose the original <code>send_email</code> function. So you should use patch with context. There are different ways of doing that </p>
<p><strong>Way 1</strong></p>
<pre><code>from format_email import CarsEmails

@pytest.mark.parametrize("test_input,expected_output", test_data)
def test_email_payload_formatting(test_input, expected_output):
    emails = CarsEmails(email_client=MagicMock(), config=config())
    with patch('cars.lib.email.send_email') as mocked_send:
        import format_email
        reload(format_email)
        emails.send_cars_email(*test_input)
        mocked_send.assert_called_with(*expected_output)
</code></pre>
<p>In this we mock the actual function which was imported</p>
<p><strong>Way 2</strong></p>
<pre><code>with patch('cars.lib.email.send_email') as mocked_send:
    from format_email import CarsEmails

    @pytest.mark.parametrize("test_input,expected_output", test_data)
    def test_email_payload_formatting(test_input, expected_output):
        emails = CarsEmails(email_client=MagicMock(), config=config())
        emails.send_cars_email(*test_input)
        mocked_send.assert_called_with(*expected_output)
</code></pre>
<p>This way any test within your file will used the patched function for other tests also</p>
<p><strong>Way 3</strong></p>
<pre><code>from format_email import CarsEmails

@pytest.mark.parametrize("test_input,expected_output", test_data)
def test_email_payload_formatting(test_input, expected_output):
    with patch('format_email.send_email') as mocked_send:
        emails = CarsEmails(email_client=MagicMock(), config=config())
        emails.send_cars_email(*test_input)
        mocked_send.assert_called_with(*expected_output)
</code></pre>
<p>In this method we patch the import itself and not the actual function which was called. In this case no reload needed as such</p>
<p>So you can see there are different ways of doing mocking, some approaches comes as good practices and some come as personal choice</p>
</div>
<span class="comment-copy">what is <code>emails.send_email</code>? Is it part of the <code>CarEmails</code> class or is it referring to <code>cars.lib.email.send_email</code>?</span>
<span class="comment-copy">It is referring to cars.lib.email.send_email</span>
<span class="comment-copy">I see, but then it won't be a part of the emails object, will it?</span>
<span class="comment-copy">No it won't. I tried importing <code>from cars.lib.email import send_email</code> and then <code>send_email = MagicMock()</code> in the test file but it also gets not called error.</span>
<span class="comment-copy">I know I have misunderstood how mocking works. I'm just not sure 'where' I should be mocking.</span>
<span class="comment-copy">You should never need <code>importlib.reload()</code>. Just patch the correct location. Also see the <code>unittest.mock</code> documentation: <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer"><i>Where to patch</i></a>.</span>
<span class="comment-copy">@MartijnPieters dang, it's time to read the <code>unittest</code> apidoc once again. Thank you for the link, let me update the answer mentioning it.</span>
<span class="comment-copy">Do <b>not</b> use direct assignment of <code>MagicMock()</code> instances to the objects you want to mock out, <i>always</i> use <a href="https://docs.python.org/3/library/unittest.mock.html#the-patchers" rel="nofollow noreferrer">a patcher</a>. Otherwise the mock will not be cleaned up and your test framework will bleed into other tests and cause issues.</span>
<span class="comment-copy">Your <i>way 2</i> is also incorrect. The patcher there exits after defining the test function, so the mock will not be applied when the actual test runs.</span>
<span class="comment-copy">Your <i>way 3</i> approach is the only correct one, but your explanation for what it does is not. And it is rather redundant given that hoefling already covered that option.</span>
<span class="comment-copy">@MartijnPieters, I hope the -1 was not from you, because I had mentioned that "But it is not the most recommended way" for MagicMock, I was just trying to show the poster why it didn't work in the way he way trying. And I have tested all 3 ways before posting here</span>
<span class="comment-copy">Don't ever use <i>way 1</i>, there should never be a need to reload a module when testing. Refactor your code if you have module globals that change as you run tests (or use test teardown hooks to reset the state).</span>
