<div class="post-text" itemprop="text">
<p>Is there a way in Python to define a method that is both a class method and an instance method, such that both <code>cls</code> and <code>self</code> are receivers. In particular, I am looking to make a method that (1) knows which class it was called on when called on the class (<code>Foo.method(value)</code>) and (2) knows which instance it was called on when called on an instance (<code>foo.method()</code>).</p>
<p>For example, I would envision something working like this:</p>
<pre><code>class Foo:
    def __str__(self): return 'Foo()'

    @classinstancemethod
    def method(cls, self):
        print(cls, self)

class Bar(Foo):
    def __str__(self): return 'Bar()'

Foo().method()     # &lt;class '__main__.Foo'&gt; Foo()
Bar().method()     # &lt;class '__main__.Bar'&gt; Bar()
Foo.method(Foo())  # &lt;class '__main__.Foo'&gt; Foo()
Foo.method(Bar())  # &lt;class '__main__.Foo'&gt; Bar()
Bar.method(Foo())  # &lt;class '__main__.Bar'&gt; Foo()
</code></pre>
<p>Note that I am aware that undecorated methods can be called like <code>Foo.foo(value)</code>, but this is not what I want because it doesn't get the <code>cls</code> variable. And without the <code>cls</code> variable, the method has no idea which class it was just called on. It may have been called as <code>Bar.method(value)</code>, and there would be now way to know that if <code>value</code> was an instance of <code>Foo</code>. An undecorated method is more like both a static method and an instance method, not both a class method and an instance method.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be solved by implementing <code>classinstancemethod</code> as a custom <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor</a>.</p>
<p>In a nutshell, the descriptor must define a <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer"><code>__get__</code></a> method that will be called when it's accessed as an attribute (like <code>Foo.method</code> or <code>Foo().method</code>). This method will be passed the instance and the class as arguments and returns a <em>bound</em> method (i.e. it returns a method with the <code>cls</code> and <code>self</code> arguments baked in). When this bound method is called, it forwards the baked-in <code>cls</code> and <code>self</code> parameters to the actual method.</p>
<pre><code>class classinstancemethod:
    def __init__(self, method, instance=None, owner=None):
        self.method = method
        self.instance = instance
        self.owner = owner

    def __get__(self, instance, owner=None):
        return type(self)(self.method, instance, owner)

    def __call__(self, *args, **kwargs):
        instance = self.instance
        if instance is None:
            if not args:
                raise TypeError('missing required parameter "self"')
            instance, args = args[0], args[1:]

        cls = self.owner
        return self.method(cls, instance, *args, **kwargs)
</code></pre>
<hr/>
<p>Results:</p>
<pre><code>class Foo:
    def __repr__(self): return 'Foo()'

    @classinstancemethod
    def method(cls, self):
        print((cls, self))


class Bar(Foo):
    def __repr__(self): return 'Bar()'


Foo().method()     # (&lt;class '__main__.Foo'&gt;, 'Foo()')
Bar().method()     # (&lt;class '__main__.Bar'&gt;, 'Bar()')
Foo.method(Foo())  # (&lt;class '__main__.Foo'&gt;, 'Foo()')
Foo.method(Bar())  # (&lt;class '__main__.Foo'&gt;, 'Bar()')
Bar.method(Foo())  # (&lt;class '__main__.Bar'&gt;, 'Foo()')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need a decorator for this. This is how methods already work; the instance is passed as first argument – implicitly when method is called from instance and explicitly from the class – with the instance available, you can retrieve the class by calling <code>type</code> on the instance:</p>
<pre><code>class Foo(object):
    def __repr__(self): return 'Foo()'

    def method(self):
        print((type(self), self)) 

class Bar(Foo):
    def __repr__(self): return 'Bar()'
</code></pre>
<p>On another note, in the <code>__str__</code> (or <code>__repr__</code>) special methods, you should return a string, not print.</p>
<p>I have used <code>__repr__</code> since <code>__str__</code> is not called for printing the instance when inside a container object (tuple here).</p>
<p><strong>Update</strong>:</p>
<p>Considering the issues with class/instance printing in the above approach, you can use a descriptor instead to properly manage correct class and instance selection within the method:</p>
<pre><code>class classinstancemethod():

  def __get__(self, obj, cls):
     def method(inst=None):
        print(cls, inst if inst else obj)
     return method

class Foo(object):
    method = classinstancemethod()

    def __str__(self): return 'Foo()'


class Bar(Foo):
    def __str__(self): return 'Bar()'
</code></pre>
</div>
<span class="comment-copy">Perfect. I suspected that <code>__get__</code> was somehow the solution.</span>
<span class="comment-copy">No, that's wrong. <code>Foo.method(Bar())</code> should output <code>(&lt;class '__main__.Foo'&gt;, 'Bar()')</code>, but yours outputs <code>(&lt;class '__main__.Bar'&gt;, 'Bar()')</code>.</span>
<span class="comment-copy">@Aran-Fey Thanks for noting. They can use the hidden <code>__class__</code> variable in Python3 instead of <code>type(self)</code>.</span>
<span class="comment-copy">That doesn't work as expected either. If you use <code>__class__</code> then it'll always return <code>Foo</code> as the class.</span>
<span class="comment-copy">I anticipated this solution in my final paragraph. It is not what I am looking for because when it is called like <code>Bar.method(Foo())</code>, then <code>method</code> has no idea that its receiver was the <code>Bar</code> class. That information is lost.</span>
<span class="comment-copy">@Aran-Fey Was already working on the descriptor answer, in trying to address you comment, thanks for the eye.</span>
