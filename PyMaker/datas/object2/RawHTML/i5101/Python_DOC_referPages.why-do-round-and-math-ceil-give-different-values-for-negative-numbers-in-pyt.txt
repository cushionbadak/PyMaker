<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/48722276/what-is-the-algorithmic-difference-between-math-ceil-and-round-when-trailing">What is the algorithmic difference between math.ceil() and round() when trailing decimal points are &gt;= 0.5 in Python 3?</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>Why do round() and math.ceil() give different values for negative numbers in Python 3?</p>
<p>For example,</p>
<pre><code>round(-5.5) = -6
round(-5.7) = -6
math.ceil(-5.5) = -5
math.ceil(-5.7) = -5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The functions execute different mathematical operations:</p>
<ul>
<li><p><code>round()</code> rounds a float value to the <em>nearest integer</em>. If either of the two integers on either side are equal distance apart, the <em>even number</em> is picked. </p>
<p>Here, the <em>nearest</em> integer is always <code>-6</code>; for <code>-5.5</code> the nearest even integer is <code>-6</code>, not <code>-5</code>.</p></li>
<li><p><code>math.ceil()</code> returns the smallest integer <em>greater than or equal</em> to the float value.</p>
<p>Here, the next integer <em>greater</em> than the inputs is always <code>-5</code> (remember that negative numbers <em>decrease</em> away from zero).</p></li>
</ul>
<p>I think the biggest confusion you have comes from the <em>even rounding rule</em>. Had you picked <code>-4.5</code>, you'd have seen <code>round()</code> return <code>-4</code>:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.ceil(-4.5)
-4
&gt;&gt;&gt; round(-4.5)
-4
</code></pre>
<p>From the <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer"><code>round()</code> function documentation</a>:</p>
<blockquote>
<p>if two multiples are equally close, rounding is done toward the even choice (so, for example, both <code>round(0.5)</code> and <code>round(-0.5)</code> are <code>0</code>, and <code>round(1.5)</code> is <code>2</code>).</p>
</blockquote>
<p>Rounding half to the nearest integers always has to break the tie <em>somehow</em>, and different programming languages don't always agree on how to do this, the <a href="https://en.wikipedia.org/wiki/IEEE_754#Rounding_rules" rel="nofollow noreferrer">IEEE 754 standard</a> defines 5 different methods. Python 3 uses the IEEE 754 default and rounds <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_to_even" rel="nofollow noreferrer">halves to even</a>, because this method has the advantage that it is free of sign bias and in reasonable distributions of numbers will result in the same average values. </p>
</div>
<div class="post-text" itemprop="text">
<p>Ceil(argument) will return closest biggest whole number if the argument is a float, -5 is BIGGER than -6. As for round() please view python's doc. I believe its pretty well explained.</p>
</div>
<span class="comment-copy">Because rounding and the math ceiling are <i>different operations</i>.</span>
<span class="comment-copy">I thought it rounded away from 0, so <code>round(-0.5)</code> is <code>-1</code> or is that Python 2 only?</span>
<span class="comment-copy">To be clear, three of the five IEEE 754 rounding modes are directed, so ties aren't a special case for those modes. IEEE 754 only defines two round-to-nearest rounding modes (and only one of those is <i>required</i> for binary floating-point types; the other is optional). Okay, I'll stop nitpicking now.</span>
<span class="comment-copy">@MarkDickinson: well, you make an explicit choice about the direction to round to in those cases; hardcoding a direction is also a solution to the tie. :-)</span>
<span class="comment-copy">I'm still horrified that JavaScript's round-to-nearest doesn't follow <i>either</i> of the IEEE 754 round-to-nearest modes, though. (It always rounds ties towards +infinity.)</span>
