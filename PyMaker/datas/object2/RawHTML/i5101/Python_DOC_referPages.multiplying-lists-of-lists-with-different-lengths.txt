<div class="post-text" itemprop="text">
<p>I have:</p>
<pre><code>a = [[1,2],[3,4],[7,10]]
b = [[8,6],[1,9],[2,1],[8,8]]
</code></pre>
<p>I want to multiply (pairwise) every element of a with b</p>
<pre><code>1*8+2*6+1*1+2*9+.....+1*8+2*8+3*8+4*6+......+7*8+10*8
</code></pre>
<p>Here's my code so far:</p>
<pre><code>def f(a, b):
    new = [x for x in a or x in b]
    newer = []
    for tuple1, tuple2 in new:
        newer.append(map(lambda s,t: s*t, new, new))
    return sum(newer)
</code></pre>
<p>so my plan of attack was to get all the lists in one list and then multiply everything together. I have seen that lambda work for multiplying lists pairwise but I can't get it to work for the one list. </p>
</div>
<div class="post-text" itemprop="text">
<p>That kind of combination is called the Cartesian product. I'd use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="noreferrer"><code>itertools.product</code></a> for this, which can easily cope with more than 2 lists, if you want.</p>
<p>Firstly, here's a short demo that shows how to get all of the pairs and how to use tuple assignment to grab the individual elements of the pairs of sublists.</p>
<pre><code>from itertools import product

a = [[1,2],[3,4],[7,10]]
b = [[8,6],[1,9],[2,1],[8,8]]

for (u0, u1), (v0, v1) in product(a, b):
    print(u0, u1, v0, v1)
</code></pre>
<p><strong>output</strong></p>
<pre><code>1 2 8 6
1 2 1 9
1 2 2 1
1 2 8 8
3 4 8 6
3 4 1 9
3 4 2 1
3 4 8 8
7 10 8 6
7 10 1 9
7 10 2 1
7 10 8 8
</code></pre>
<p>And here's how to find the <a href="https://docs.python.org/3.3/library/functions.html#sum" rel="noreferrer"><code>sum</code></a> of products that you want.</p>
<pre><code>total = sum(u0 * v0 + u1 * v1 for (u0, u1), (v0, v1) in product(a, b))
print(total)
</code></pre>
<p><strong>output</strong></p>
<pre><code>593
</code></pre>
<hr/>
<p>Here's an alternative approach, using the distributive property, as mentioned by Prune.</p>
<p>Firstly, here's an unreadable list comprehension version. ;) </p>
<pre><code>a = [[1,2],[3,4],[7,10]]
b = [[8,6],[1,9],[2,1],[8,8]]

print(sum([u*v for u,v in zip(*[[sum(t) for t in zip(*u)] for u in (a, b)])]))
</code></pre>
<p><strong>output</strong></p>
<pre><code>593
</code></pre>
<h3>How it works</h3>
<p>By the distributive law, the sum you want from the given input data can be written as</p>
<pre><code>(1 + 3 + 7) * (8 + 1 + 2 + 8) + (6 + 9 + 1 + 8) * (2 + 4 + 10)
</code></pre>
<p>We can re-arrange the data to produce that expression as follows.</p>
<pre><code># Use zip to transpose each of the a &amp; b lists.
for u in (a, b):
    for t in zip(*u):
        print(t)
</code></pre>
<p><strong>output</strong></p>
<pre><code>(1, 3, 7)
(2, 4, 10)
(8, 1, 2, 8)
(6, 9, 1, 8)
</code></pre>
<p>Now we modify that slightly to get the sums of those lists     </p>
<pre><code># Use zip to transpose each of the a &amp; b lists and compute the partial sums.
partial_sums = []
for u in (a, b):
    c = []
    for t in zip(*u):
        c.append(sum(t))
    partial_sums.append(c)
print(partial_sums)        
</code></pre>
<p><strong>output</strong></p>
<pre><code>[[11, 16], [19, 24]]
</code></pre>
<p>Now we just need to multiply the corresponding items of those lists, and add those products together to get the final sum. Once again, we use <code>zip</code> to perform the transposition.</p>
<pre><code>total = 0
for u, v in zip(*partial_sums):
    print(u, v)
    total += u * v
print(total)        
</code></pre>
<p><strong>output</strong></p>
<pre><code>11 19
16 24
593
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your only need is to return that conglomerate sum, I suggest that you quit doing all of that complex work: apply the distributive property.  From your example, I'm not sure how thoroughly you are making your cross-products, but this collapses the example to do all elements of each.</p>
<pre><code>sum1 = sum(sum(_) for _ in a)
sum2 = sum(sum(_) for _ in b)
return sum1 * sum2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suggest stepping back from the code and breaking this down into smaller parts. First, multiply each element from two lists, pairwise.</p>
<p>Second, given a list of lists <code>a</code> and a list of numbers <code>b</code>, multiply each list of <code>a</code> pairwise by <code>b</code>. This can reuse the solution to part 1.</p>
<p>Finally, solve your original problem with two lists of lists by reusing part 2.</p>
<p>Note how I am describing each of these pieces <strong>in words</strong> without worrying too much about Python syntax. Now that we have a description in words, it is easier to translate it into Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>numpy</code> will knock this out trivially:</p>
<pre><code>&gt;&gt;&gt; a = np.array(a)
&gt;&gt;&gt; b = np.array(b)
&gt;&gt;&gt; (a @ b.T).sum()
593
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.product</code> with <code>zip</code>:</p>
<pre><code>import itertools
a=[[1,2],[3,4],[7,10]]
b=[[8,6],[1,9],[2,1],[8,8]]
result = sum(sum(c*d for c, d in zip(h, k)) for h, k in itertools.product(a, b))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To make things easier, you can use <code>itertools.product</code> function. </p>
<p>What it does is that it returns Cartesian product of iterables passed to it like arguments. After you have Cartesian product, you can iterate through them and do sum of pairs of coordinates.</p>
<p>After explanation, this is something that you want:</p>
<pre><code>from itertools import product


a = [[1, 2], [3, 4], [7, 10]]
b = [[8, 6], [1, 9], [2, 1], [8, 8]]


def multiply(a, b):
    sum = 0
    for pair1, pair2 in product(a, b):
        sum += pair1[0]*pair2[0] + pair1[1]*pair2[1]
    return sum


print multiply(a, b) #  593
</code></pre>
</div>
<span class="comment-copy"><code>new=[x for x in a or x in b]</code> is not doing what you think it is doing.</span>
<span class="comment-copy">What juanpa.arrivillaga said. You should print <code>new</code>. The reason it gives that result is that your code is equivalent to <code>new=[x for x in (a or x in b)]</code>. And since <code>a</code> isn't empty, <code>(a or x in b)</code> evaluates to <code>a</code>.</span>
<span class="comment-copy">Very nice.  I like how unpacking the tuples gets rid of having to write in extra complexity like <code>sum(map(lambda x:x[0][0]*x[1][0]+x[0][1]*x[1][1], itertools.product(a, b)))</code> or <code>sum(sum(c*d for c, d in zip(h, k)) for h, k in itertools.product(a, b))</code>.</span>
<span class="comment-copy">Thanks @StevenRumbalski! And not only is it easier to read, using tuple unpacking is faster than using indexing.</span>
<span class="comment-copy">Another version of the distribuitive: <code>sum(sum(p[i] for p in a)*sum(p[i] for p in b) for i in range(2))</code>.</span>
<span class="comment-copy">@StevenRumbalski Well, that's a bit more compact than my version. :) OTOH, my version copes with more than 2 lists, but it does assume that the input sublists have two items each.</span>
<span class="comment-copy">I was about to comment <code>sum(x * y for x, y in zip(map(sum, zip(*a)), map(sum, zip(*b))))</code> but your edit does the same thing (sort of, I hardwire to two lists).</span>
<span class="comment-copy">That answer is too big! But using the distributive property is an excellent idea...</span>
<span class="comment-copy">So for the first it is: [x*y for x,y in zip(a,b)] but how do I do the next parts?</span>
<span class="comment-copy">@user342624 Make that a function and use it for part 2. If it helps, use different names for the input lists, say <code>x</code> is the list of lists and <code>y</code> is the single list of numbers. Can you write another list comprehension that uses your first one (as the return from a function)?</span>
<span class="comment-copy">What does the <code>@</code> operator do with numpy arrays? I've never seen this before.</span>
<span class="comment-copy">@Piinthesky  This is a matrix multiplication.  It multiplies rows by columns.</span>
<span class="comment-copy">Please explain how your solution works.</span>
<span class="comment-copy">Updated with explanation.</span>
