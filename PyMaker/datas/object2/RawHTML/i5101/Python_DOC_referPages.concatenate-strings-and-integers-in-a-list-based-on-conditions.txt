<div class="post-text" itemprop="text">
<p>I'm working with a list that contains both strings and integers, and I want to create a function that concatenates new elements to these strings and integers based on different conditions. For instance if the element in the list is an integer I want to add 100 to it; if the element is a string I want to add "is the name". I tried working with a list comprehension but couldn't figure out how to account for strings and integers both being present in the list (so not sure if this is possible here). Here's a basic example of what I'm working with:</p>
<pre><code>sample_list = ['buford', 1, 'henley', 2, 'emi', 3]
</code></pre>
<p>the output would look like this:</p>
<pre><code>sample_list = ['buford is the name', 101, 'henley is the name', 102, 'emi is the name', 103]
</code></pre>
<p>I tried using something like this:</p>
<pre><code>def concat_func():
    sample_list = ['buford', 1, 'henley', 2, 'emi', 3]
    [element + 100 for element in sample_list if type(element) == int]
</code></pre>
<p>I also tried using basic for loops and wasn't sure if this was the right way to go about it instead:</p>
<pre><code>def concat_func():
    sample_list = ['buford', 1, 'henley', 2, 'emi', 3]
    for element in sample_list:
        if type(element) == str:
            element + " is the name"
        elif type(element) == int:
            element + 100
    return sample_list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You were close. instead of checking for equality with type, use 'is'. You can also do isinstance() as pointed out in the comments to check for inheritance and subclasses of str/int.</p>
<pre><code>sample_list = ['buford', 1, 'henley', 2, 'emi', 3]
newlist = []

for s in sample_list:
    if type(s) is int:
        newlist.append(s + 100)
    elif type(s) is str:
        newlist.append(s + ' is the name')
    else:
        newlist.append(s)

newlist2 = []

for s in sample_list:
    if isinstance(s, int):
        newlist2.append(s + 100)
    elif isinstance(s, str):
        newlist2.append(s + ' is the name')
    else:
        newlist2.append(s)

print(newlist)
print(newlist2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Plain LC:</p>
<pre><code>&gt;&gt;&gt; ['{} is the name'.format(x) if isinstance(x,str) else x+100 for x in sample_list]
['buford is the name', 101, 'henley is the name', 102, 'emi is the name', 103]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a> is one way:</p>
<pre><code>sample_list = ['buford', 1, 'henley', 2, 'emi', 3]

result = [k+' is the name' if isinstance(k, str) \
          else k+100 if isinstance(k, int) \
          else k for k in sample_list]

# ['buford is the name', 101, 'henley is the name', 102, 'emi is the name', 103]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just change the position of the if condition and add an 'else' condition to it. Just as this:</p>
<pre><code>[element + (100 if type(element) == int else " is the name") for element in sample_list]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a mapping <code>dict</code> with key as mappings and value as the value that needs to be concatenated</p>
<pre><code>&gt;&gt;&gt; d = {'str':"is the name", "int": 100}
</code></pre>
<p>Next you can do simple list comprehension and use <code>+</code> operator on each list element and value from mapping dict. You would need to yield a two tuple of list element and its type. This can be achieved using <a href="https://docs.python.org/3.3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> and <a href="https://docs.python.org/3.3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a></p>
<pre><code>&gt;&gt;&gt; [k+d[t] for k,t in zip(l,map(lambda x: type(x).__name__,l))]
&gt;&gt;&gt; ['bufordis the name', 101, 'henleyis the name', 102, 'emiis the name', 103]
</code></pre>
</div>
<span class="comment-copy">It would be better to use <code>isinstance</code>.</span>
