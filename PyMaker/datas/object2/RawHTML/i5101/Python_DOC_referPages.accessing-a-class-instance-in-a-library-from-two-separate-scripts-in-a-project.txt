<div class="post-text" itemprop="text">
<p>I searched all over and could not come up with a reasonable search query to produce helpful results. I'll try to explain this with a simple example (that is tested).</p>
<p>Suppose I have some small custom Python library that contains just the following private class and public instance of it:</p>
<pre><code>#!/usr/bin/env python

class _MyClass(object):
    def __init__(self):
        self.val = "Default"

my_instance = _MyClass()
</code></pre>
<p>Now, I also have two other python files ('file_a' and 'file_b') that will end up importing this instance from my library as seen below.</p>
<p>The full code in 'file_a':</p>
<pre><code>#!/usr/bin/env python

from my_lib import my_instance

my_instance.val = "File A was here!"
import file_b
file_b.check_val()
</code></pre>
<p>The full code in 'file_b':</p>
<pre><code>#!/usr/bin/env python

from my_lib import my_instance

def check_val():
    print "From 'file_b', my_instance.val is: {}".format(my_instance.val)
</code></pre>
<p>The resulting output, if I only execute 'file_a' within a directory that also contains 'file_b' and 'my_lib', is this:</p>
<pre class="lang-none prettyprint-override"><code>From 'file_b', my_instance.val is: File A was here!
</code></pre>
<p>Can someone explain to me how 'file_b' is able to access the same exact instance as 'file_a' in my example? Does this have to do with how the value being set in 'file_a' is global?</p>
<p><em>By the way, I do know I can just make 'MyClass' public again and instantiate it whenever a unique instance is needed in either 'file_a' or 'file_b', but the main reason I am posting this question is to wrap my head around this specific concept.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>There are two things you need to understand here:</p>
<h2>1. Module caching</h2>
<p>Python caches module imports to improve performance, this happens even when you do <code>from foo import bar</code>. The module object gets stored in <code>sys.modules</code>.</p>
<p>Hence, in your case both <code>file_a</code> and <code>file_b</code> are accessing same module object <code>my_lib</code> and same instance <code>my_instance</code>.</p>
<h2>2. References</h2>
<p>In Python variable assignment is basically adding a new reference to the same object, this is true for imports as well. </p>
<pre><code>from my_lib import my_instance
</code></pre>
<p>is basically</p>
<pre><code>import my_lib
my_instance = my_lib.my_instance
del my_lib
</code></pre>
<p>Now as we modify this instance in <code>file_a</code>, we have basically modified the instance in <code>my_lib</code>, and <code>file_b</code> will also see this change.</p>
<hr/>
<p>You can modify <code>file_a</code> and <code>file_b</code> to verify this.</p>
<p><code>file_a</code>:</p>
<pre><code>#!/usr/bin/env python

from my_lib import my_instance

my_instance.val = "File A was here!"

print "Inside file_a"
import sys
print id(sys.modules['my_lib']), sys.modules['my_lib'].my_instance, my_instance

import file_b
file_b.check_val()
</code></pre>
<p><code>file_b</code>:</p>
<pre><code>#!/usr/bin/env python

from my_lib import my_instance

print "Inside file_b"
import sys
print id(sys.modules['my_lib']), sys.modules['my_lib'].my_instance, my_instance


def check_val():
    print "From 'file_b', my_instance.val is: {}".format(my_instance.val)
</code></pre>
<p><strong>Output(check the object IDs):</strong></p>
<pre><code>&gt;&gt;&gt; %run file_a.py

Inside file_a
4396461816 &lt;my_lib._MyClass object at 0x106158ad0&gt; &lt;my_lib._MyClass object at 0x106158ad0&gt;
Inside file_b
4396461816 &lt;my_lib._MyClass object at 0x106158ad0&gt; &lt;my_lib._MyClass object at 0x106158ad0&gt;
From 'file_b', my_instance.val is: File A was here!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you <code>import my_lib</code> in each file and then <code>print(id(my_lib))</code>, you'll see that the only a single module object is created. </p>
<p>Reading <a href="https://docs.python.org/3/reference/import.html" rel="nofollow noreferrer">The <code>import</code> system</a> from the python docs may help you understand what's going on here. Of particular relevance is the section on <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="nofollow noreferrer">The module cache</a>. In part:</p>
<blockquote>
<p>The first place checked during <code>import</code> search is <code>sys.modules</code>. This
  mapping serves as a cache of all modules that have been previously
  imported, including the intermediate paths. So if <code>foo.bar.baz</code> was
  previously imported, <code>sys.modules</code> will contain entries for <code>foo</code>,
  <code>foo.bar</code>, and <code>foo.bar.baz</code>. Each key will have as its value the
  corresponding module object.</p>
<p>During import, the module name is looked up in <code>sys.modules</code> and if
  present, the associated value is the module satisfying the import, and
  the process completes.</p>
</blockquote>
</div>
<span class="comment-copy">Ahh, that makes a lot more sense. I was not aware of how python caches modules per project. I'll definitely do some reading on the import system, then. Thanks!</span>
