<div class="post-text" itemprop="text">
<p>If I have a list <code>ts</code> of tuples in python:</p>
<pre><code>ts = [(702,703), (703,704), (803,805), (803,806), (901,903), (902,903)]
</code></pre>
<p>How do I obtain a list containing common elements between 2 or more such tuples?</p>
<p>Assume that both the tuples in <code>ts</code> and the the elements in tuples are already numerically sorted.</p>
<p>For this example, the intended output should be:</p>
<pre><code>ts_output = [703, 803, 903]
</code></pre>
<p>Below is my working so far:</p>
<pre><code>ts = [(702,703), (703,704), (803,805), (803,806), (901,903), (902,903)]
ts = set(ts)

t1 = set(w for w,x in ts for y,z in ts if w == y) # t1 should only contain 803
print("t1: ", t1)

t2 = set(y for w,x in ts for y,z in ts if x == y) # t2 should only contain 703
print("t2: ", t2)

t3 = set(x for w,x in ts for y,z in ts if x == z) # t3 should only contain 903
print("t3: ", t3)
</code></pre>
<p>And this is the corresponding output:</p>
<pre><code>t1: {803, 901, 902, 702, 703}
t2: {703}
t3: {704, 805, 806, 903, 703}
</code></pre>
<p>From above, only <code>t2</code> gave the intended output, but I'm not sure what happened to <code>t1</code> and <code>t3</code>.</p>
<p>You may use this alternative input to test your code, and it should give the exact same output:</p>
<pre><code> ts = [(701,703), (702,703), (703,704), (803,805), (803,806), (901,903), (902,903), (903,904)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import collections

ts = [(702,703), (703,704), (803,805), (803,806), (901,903), (902,903)]
flat_list = [item for sublist in ts for item in sublist]
duplicates = [item for item, count in collections.Counter(flat_list).items() if count &gt; 1]
print(duplicates)
</code></pre>
<h2>Explanation:</h2>
<p>Given your input, you first need to flat your list.</p>
<pre><code>#1 Simple and pythonic
flat_list = [item
                for sublist in ts
                    for item in sublist]

#2 More efficient.
import itertools
flat_list = itertools.chain.from_iterable(ts)
</code></pre>
<p>In case of method #1 your <code>flat_list</code> will be <code>list</code> object in in case of method #2 it will be <code>generator</code> object. Both will behave same for iteration.</p>
<p>Now you can count the elements in your flat_list. If they are greater than 1 they are duplicates.</p>
<pre><code>for item, count in collections.Counter(flat_list).items():
    if count &gt; 1:
        print(item)
</code></pre>
<p>or you can use more pythonic list comprehension.</p>
<pre><code>duplicates = [item
                 for item, count in collections.Counter(flat_list).items()
                     if count &gt; 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to flatten your list of tuples. You can do this using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a></p>
<pre><code>&gt;&gt;&gt; from itertools import chain

&gt;&gt;&gt; flat_list = list(chain(*ts))
&gt;&gt;&gt; flat_list
&gt;&gt;&gt; [702, 703, 703, 704, 803, 805, 803, 806, 901, 903, 902, 903]
</code></pre>
<p>Or you can also use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterables</code></a> to do the same like, However this doesn't require iterable unpacking</p>
<pre><code>&gt;&gt;&gt; flat_list = list(itertools.chain.from_iterable(ts))
&gt;&gt;&gt; flat_list
&gt;&gt;&gt; [702, 703, 703, 704, 803, 805, 803, 806, 901, 903, 902, 903]
</code></pre>
<p>After this step you can use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Collections.Counter</code></a> to count occurance of each element in flat list and filter once which occurs more than one.</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; c = Counter(flat_list)
&gt;&gt;&gt; c
&gt;&gt;&gt; Counter({803: 2, 903: 2, 703: 2, 704: 1, 805: 1, 806: 1, 901: 1, 902: 1, 702: 1}) 
</code></pre>
<p>Then finally filter <code>c</code></p>
<pre><code>&gt;&gt;&gt; [k for k,v in c.items() if v&gt;1]
&gt;&gt;&gt; [803, 903, 703]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; ts = [(702,703), (703,704), (803,805), (803,806), (901,903), (902,903)]
&gt;&gt;&gt; c = Counter(el for t in ts for el in t)
&gt;&gt;&gt; [k for k in c if c[k] &gt;= 2]
[703, 803, 903]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an answer that solves it by only passing through once instead of twice and builds result as it goes (not sure if its faster or slower in practice for super large <code>ts</code>)</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; ts = [(702,703), (703,704), (803,805), (803,806), (901,903), (902,903)]
&gt;&gt;&gt; def find_common(ts):
...   c = Counter()
...   for num in chain.from_iterable(ts):
...     c[num] += 1
...     if c[num] == 2:
...       yield num
... 
&gt;&gt;&gt; list(find_common(ts))
[703, 803, 903]
</code></pre>
<p>And without <code>Counter</code></p>
<pre><code>&gt;&gt;&gt; def find_common(ts):
...   seen, dupes = set(), set()
...   for num in chain.from_iterable(ts):
...     if num in seen and num not in dupes:
...       dupes.add(num)
...       yield num
...     seen.add(num)
&gt;&gt;&gt; list(find_common(ts))
[703, 803, 903]
</code></pre>
</div>
<span class="comment-copy">I think you are not making it very clear.</span>
<span class="comment-copy">What if <code>(703, 703)</code> is a tuple in the list as well? What should the output for <code>[(702, 701), (703, 703)]</code> be?</span>
<span class="comment-copy">That's exactly I was thinking @Elmex80s</span>
<span class="comment-copy">@Elmex80s We assume that that will not happen. The data has been filtered for repeated numbers like <code>(703, 703)</code>. Also, elements in tuples will be ordered from smallest to largest, so <code>(702, 701)</code> will be reordered to <code>(701, 702)</code>. Hope this clarifies!</span>
<span class="comment-copy">Any of the answers qualify to solve your problem?</span>
<span class="comment-copy">import itertools; itertools.chain.from_iterable(ts) is faster than the list comprehension when merging any list or tuple of the list into single list or tuple.</span>
<span class="comment-copy">agreed. But this is more pythonic. Edited.</span>
<span class="comment-copy"><code>chain.from_iterable(ts)</code> also works here .</span>
<span class="comment-copy">@RoadRunner updated!</span>
