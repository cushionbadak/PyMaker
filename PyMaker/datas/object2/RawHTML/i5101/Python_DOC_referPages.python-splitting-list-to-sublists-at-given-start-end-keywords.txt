<div class="post-text" itemprop="text">
<p>If I were to have a list, say </p>
<pre><code>lst = ['hello', 'foo', 'test', 'world', 'bar', 'idk']
</code></pre>
<p>I'd like to split it into a sublist with <code>'foo'</code> and <code>'bar'</code> as start and end keywords, so that I would get</p>
<pre><code>lst = ['hello', ['foo', 'test', 'world', 'bar'], 'idk']
</code></pre>
<p>The way I am currently doing this is as follows.</p>
<pre><code>def findLoop(t):   
    inds = [index for index, item in enumerate(t) if item in ["FOO", "BAR"]]
    centre = inds[(len(inds)/2)-1:(len(inds)/2)+1]
    newCentre = t[centre[0]:centre[1]+1]
    return t[:centre[0]] + [newCentre] + t[centre[1]+1:]

def getLoops(t):
    inds = len([index for index, item in enumerate(t) if item in ["FOO", "BAR"]])
    for i in range(inds):
        t = findLoop(t)
    return t
</code></pre>
<p>This looks a bit messy, but it works very well for nested start/end keywords, so sublists can be formed inside of sublists, but it does not work for multiple start/end keywords not being inside eachother. Being nested is not important yet, so any help would be appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>One creative way would be to dump your list to a <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">JSON</a> string, add <code>[</code> and <code>]</code> where needed, and parse your JSON string back to a Python nested list:</p>
<pre><code>import json
lst = ['hello', 'foo', 'test', 'world', 'bar', 'idk']
start_keywords = ['world', 'foo', 'test']
end_keywords = ['bar', 'idk', 'foo']
dump = json.dumps(lst)

for k in start_keywords:
    dump = dump.replace(f'"{k}"', f'["{k}"')

for k in end_keywords:
    dump = dump.replace(f'"{k}"', f'"{k}"]')

json.loads(dump)
# ['hello', ['foo'], ['test', ['world', 'bar'], 'idk']]
json.loads(dump)[2][1][0]
# 'world'
</code></pre>
<p>The advantage is that it's easy to follow, it works fine for arbitrary nested lists and it detects if the structure isn't correct. You need to make sure your words don't contain <code>"</code>, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way using slicing:</p>
<pre><code>&gt;&gt;&gt; lst = ['hello', 'foo', 'test', 'world', 'bar', 'idk']
&gt;&gt;&gt; a=lst.index('foo')
&gt;&gt;&gt; b=lst.index('bar')+1
&gt;&gt;&gt; lst[a:b] = [lst[a:b]]
&gt;&gt;&gt; lst
['hello', ['foo', 'test', 'world', 'bar'], 'idk']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>multiple start,ends (based on Mark Tolonen's answer)</p>
<pre><code>lst = ['hello', 'foo', 'test', 'world', 'bar', 'idk','am']
t = [('foo','test'),('world','idk')]

def sublists(lst, t):
    for start,end in t:
        a=lst.index(start)
        b=lst.index(end)+1
        lst[a:b] = [lst[a:b]]
    return lst

print(sublists(lst,t)) 
</code></pre>
<p>Returns:</p>
<pre><code> ['hello', ['foo', 'test'], ['world', 'bar', 'idk'], 'am']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using slicing, without support for nested lists:</p>
<pre><code>&gt;&gt;&gt; lst = ['hello', 'foo', 'test', 'world', 'bar', 'idk']
&gt;&gt;&gt; start_idx = lst.index('foo')
&gt;&gt;&gt; end_idx = lst.index('bar')
&gt;&gt;&gt; lst[:start_idx] + [lst[start_idx:end_idx+1]] + lst[end_idx+1:]
['hello', ['foo', 'test', 'world', 'bar'], 'idk']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To get your code to achieve the desired results, you need to make the following changes:</p>
<ol>
<li><p>Slice indices must be integers. Your findLoop function fails on the second line if your test list has an odd length. Coerce the type of the slice indices to int to round down (as is required here)</p>
<pre><code>centre = inds[int(len(inds)/2)-1:int(len(inds)/2)+1]
</code></pre></li>
<li><p><code>in</code> is case sensitive.</p>
<pre><code>&gt;&gt;&gt; 'foo' in ['FOO', 'BAR']
False
</code></pre></li>
<li><p>In getLoops, you only need to search for the first element in your pair, as findLoops sublists from a pair of words on each call.</p>
<pre><code>inds = len([index for index, item in enumerate(t) if item in ['foo']])
</code></pre></li>
</ol>
<p><a href="https://tio.run/##nVExbsMwDNz9Cm62kBSt201Apqz9gaDBranEqCMZFIO0r3dFuRacDh1qwCB14B11uumLz8G/zGNkOICpzziOod5D7UIujJGl3gKNvTRvHUkZ@o/azj06cIPvX0OYGlYaAKr0Q4KiyKWKn@ACQe72MDBeUg/orxekjjGxYHAFN@teWWNtFntHz4RJTlSTJDcj@kYO6vFZPbT6N7RrF6LH23HlsllkzJPVP11r10FCvpJPM7oMWdiBKQJyKgrC07aqxPwJWbxHMb91Ltf5r3trVZbKRIGp8ydc3C1L5JO4Nk9/52OeSN6kXC6Fq1TVxYjEcIfCYRu6@TN1W2L/Bg" rel="nofollow noreferrer">Try it online!</a></p>
<hr/>
<p>However, as you've noticed, your code is quite messy, and the other answers show how you can use <code>list().index()</code> to better effect.</p>
<p>If you'd like to further this to find nested sublists, that will require some more clarification on how you'd like this to behave. Consider the following problems:</p>
<ul>
<li><p>sublisting <code>['foo', 'bar']</code>, then <code>['test', 'world']</code></p>
<ul>
<li>Should sublisting occur only on the initial list, or inside sublists too?</li>
</ul></li>
<li><p>sublisting <code>['foo', 'world']</code>, then <code>['test', 'bar']</code></p>
<ul>
<li>How should matches on different levels of the list behave?</li>
</ul></li>
</ul>
</div>
<span class="comment-copy">wow, this works perfectly, even for the stuff I was planning on implementing later on. Thanks!</span>
<span class="comment-copy">Yes but OP is asking for multiple start,end too. I took the liberty to make a function out of it.</span>
<span class="comment-copy">@AntonvBR OP's example doesn't work and doesn't show what he means.  Add your own answer don't edit mine, please.</span>
<span class="comment-copy">I don't know whether this matters in the Op case, but this fails if they appear more than once: <code>['A', 'foo', 'test', 'bar', 'B', 'foo', 'test2', 'bar']</code> should become <code>['A', ['foo', 'test', 'bar'], 'B', ['foo', 'test2', 'bar']]</code> and not <code>['A', ['foo', 'test', 'bar'], 'B', 'foo', 'test2', 'bar']</code>.Also what about <code>['A', 'foo', 'bar', 'bar']</code>. Should it group as <code>['foo', 'bar']</code> (as your code) or <code>['foo', 'bar', 'bar']</code>?</span>
<span class="comment-copy">Relevant but unclear how OP intends to use it. You could also build in error exceptions of course. Good point anyhow!</span>
