<div class="post-text" itemprop="text">
<p>I want to know how to wrap a C++ object with <a href="https://docs.python.org/3/extending/extending.html" rel="nofollow noreferrer">Python Extension API</a> (and distutils) without external tools (like Cython, Boost, SWIG, ...). Just in pure Python way without creating a dll.</p>
<p>Note that my C++ object has memory allocations so destructor has to be called to avoid memory leaks.</p>
<pre><code>#include "Voice.h"

namespace transformation
{ 
  Voice::Voice(int fftSize) { mem=new double[fftSize]; } 

  Voice::~Voice() { delete [] mem; } 

  int Voice::method1() { /*do stuff*/ return (1); } 
}
</code></pre>
<p>I just want to do somethings like that in Python :</p>
<pre><code>import voice

v=voice.Voice(512)
result=v.method1()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Seems that the answer was in fact here : <a href="https://docs.python.org/3.6/extending/newtypes.html" rel="noreferrer">https://docs.python.org/3.6/extending/newtypes.html</a></p>
<p>With examples, but not really easy.</p>
<p>EDIT 1 :</p>
<p>In fact, it is not really for wrapping a C++ object in a Python object, but rather to create a Python object with C code. (edit2 : and so you can wrap C++ object!)</p>
<p>EDIT 2 :</p>
<p>Here is a solution using the <a href="https://docs.python.org/3.6/extending/newtypes.html" rel="noreferrer">Python newtypes</a></p>
<p>.</p>
<p>Original C++ file : <code>Voice.cpp</code></p>
<pre><code>#include &lt;cstdio&gt;

#include "Voice.h"

namespace transformation
{ 
    Voice::Voice(int fftSize) {
        printf("c++ constructor of voice\n");
        this-&gt;fftSize=fftSize;
        mem=new double[fftSize];
        } 

    Voice::~Voice() { delete [] mem; } 

    int Voice::filter(int freq) {
        printf("c++ voice filter method\n");
        return (doubleIt(3));
    }
    int Voice::doubleIt(int i) { return 2*i; }
}
</code></pre>
<p>.</p>
<p>Original h file : <code>Voice.h</code></p>
<pre><code>namespace transformation {

    class Voice {
    public:
        double *mem;
        int fftSize;

        Voice(int fftSize);
        ~Voice();

        int filter(int freq);
        int doubleIt(int i);
    };

}
</code></pre>
<p>.</p>
<p>C++ Python wrapper file : voiceWrapper.cpp</p>
<pre><code>#include &lt;Python.h&gt;

#include &lt;cstdio&gt;
//~ #include "structmember.h"

#include "Voice.h"

using transformation::Voice;

typedef struct {
    PyObject_HEAD
    Voice * ptrObj;
} PyVoice;




static PyModuleDef voicemodule = {
    PyModuleDef_HEAD_INIT,
    "voice",
    "Example module that wrapped a C++ object",
    -1,
    NULL, NULL, NULL, NULL, NULL
};

static int PyVoice_init(PyVoice *self, PyObject *args, PyObject *kwds)
// initialize PyVoice Object
{
    int fftSize;

    if (! PyArg_ParseTuple(args, "i", &amp;fftSize))
        return -1;

    self-&gt;ptrObj=new Voice(fftSize);

    return 0;
}

static void PyVoice_dealloc(PyVoice * self)
// destruct the object
{
    delete self-&gt;ptrObj;
    Py_TYPE(self)-&gt;tp_free(self);
}


static PyObject * PyVoice_filter(PyVoice* self, PyObject* args)
{
    int freq;
    int retval;

    if (! PyArg_ParseTuple(args, "i", &amp;freq))
        return Py_False;

    retval = (self-&gt;ptrObj)-&gt;filter(freq);

    return Py_BuildValue("i",retval);
}


static PyMethodDef PyVoice_methods[] = {
    { "filter", (PyCFunction)PyVoice_filter,    METH_VARARGS,       "filter the mem voice" },
    {NULL}  /* Sentinel */
};

static PyTypeObject PyVoiceType = { PyVarObject_HEAD_INIT(NULL, 0)
                                    "voice.Voice"   /* tp_name */
                                };


PyMODINIT_FUNC PyInit_voice(void)
// create the module
{
    PyObject* m;

    PyVoiceType.tp_new = PyType_GenericNew;
    PyVoiceType.tp_basicsize=sizeof(PyVoice);
    PyVoiceType.tp_dealloc=(destructor) PyVoice_dealloc;
    PyVoiceType.tp_flags=Py_TPFLAGS_DEFAULT;
    PyVoiceType.tp_doc="Voice objects";
    PyVoiceType.tp_methods=PyVoice_methods;
    //~ PyVoiceType.tp_members=Noddy_members;
    PyVoiceType.tp_init=(initproc)PyVoice_init;

    if (PyType_Ready(&amp;PyVoiceType) &lt; 0)
        return NULL;

    m = PyModule_Create(&amp;voicemodule);
    if (m == NULL)
        return NULL;

    Py_INCREF(&amp;PyVoiceType);
    PyModule_AddObject(m, "Voice", (PyObject *)&amp;PyVoiceType); // Add Voice object to the module
    return m;
}
</code></pre>
<p>.</p>
<p>distutils file : <code>setup.py</code></p>
<pre><code>from distutils.core import setup, Extension

setup(name='voicePkg', version='1.0',  \
      ext_modules=[Extension('voice', ['voiceWrapper.cpp','Voice.cpp'])])
</code></pre>
<p>.</p>
<p>python test file : <code>test.py</code></p>
<pre><code>import voice

v=voice.Voice(512)
result=v.filter(5)
print('result='+str(result))
</code></pre>
<p>.</p>
<p>and magic :</p>
<pre><code>sudo python3 setup.py install
python3 test.py
</code></pre>
<p>Output is :</p>
<pre><code>c++ constructor of voice
c++ voice filter method
result=6
</code></pre>
<p>Enjoy !</p>
<p>Doom</p>
</div>
<div class="post-text" itemprop="text">
<p>You may like to start with <a href="https://docs.python.org/3.6/extending/extending.html" rel="nofollow noreferrer">Extending Python with C or C++</a>.</p>
<p>You can use <a href="https://github.com/python/cpython/tree/master/Modules" rel="nofollow noreferrer">standard Python modules source code</a> as examples.</p>
<p>The value provided by Boost.Python, SWIG, etc, is that you do not have to know/understand all the low level details because they handle them for you. This is why people use them.</p>
</div>
<span class="comment-copy">You won't be able to do that well unless you read and understand <a href="https://docs.python.org/3.6/c-api/index.html" rel="nofollow noreferrer">docs.python.org/3.6/c-api/index.html</a></span>
<span class="comment-copy">OK. But maybe you have a link to an example. Examples are often more understandable than official docs (even if it is usefull when you want to go deep inside). I haven't found anything.</span>
<span class="comment-copy">Use python modules source code as examples: <a href="https://github.com/python/cpython/tree/master/Modules" rel="nofollow noreferrer">github.com/python/cpython/tree/master/Modules</a></span>
<span class="comment-copy">The value provided by Boost.Python, SWIG, etc, is that you do not have to know/understand all the low level details.</span>
<span class="comment-copy">I can't believe that Python designers have not provided a simple way to do that.</span>
