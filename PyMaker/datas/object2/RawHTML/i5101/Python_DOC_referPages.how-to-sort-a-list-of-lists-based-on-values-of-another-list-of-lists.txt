<div class="post-text" itemprop="text">
<p>My two list of lists are:</p>
<pre><code>lst_1 = [[1, 'John'], [2, 'Mcquin'], [4, 'Paul'], [7, 'Jimmy'], [9, 'Coco'], [11, 'Coco']]
lst_2 = [[3, 'Mcquin', 1], [6, 'Paul', 6], [5, 'John', 15], [12, 'Coco', 18], [8, 'Jimmy', 24], [10, 'Coco', 24]]
</code></pre>
<p>What is the most efficient way of sorting <code>lst_1</code> based on the second value in the sublist of <code>lst_2</code> (<code>lst_2[i][1]</code>)?
Preferred output:</p>
<pre><code>[[2, 'Mcquin'], [4, 'Paul'], [1, 'John'], [9, 'Coco'], [7, 'Jimmy'], [11, 'Coco']]
</code></pre>
<p>It doesn't matter if there are duplicates of the same name (Coco in this case). Also, the lists will always contain the same names like here.</p>
</div>
<div class="post-text" itemprop="text">
<p><em>Edit: I think I have an <strong><code>O(n)</code></strong> solution!</em></p>
<hr/>
<p>Originally, I thought we could create a <code>dictionary</code> of the names and the indexes they should appear in the final list based on <code>lst_2</code>. Then we could create the final list by sorting <code>lst_1</code> - giving an <code>O(n log(n))</code> solution.</p>
<p>However, the problem with that method is that there are duplicate names in <code>lst_2</code>! Also, this new method even has a better time complexity!</p>
<hr/>
<p>First we create a dictionary <em>based on <code>lst_1</code></em> where each <code>key</code> is a name and each value is a <strike><code>list</code></strike> <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a> (thanks RoadRunner) of the numbers which correspond to that name.</p>
<p>By using a <code>deque</code>, we maintain the ordering of those elements in <code>lst_1</code> with the same names. Also, we have the ability to call <code>.popleft</code> on a <code>deque</code> in <code>O(1)</code> time.</p>
<p>This then allows us to iterate over <code>lst_2</code> (removing the need for any sorting as it is already in order) and append to a new list the name followed by the first entry of values in the dictionary we created.</p>
<p>If we use <code>.popleft()</code> to get the first element, we also remove it meaning that when that name next comes up in <code>lst_2</code>, we get the next value in <code>lst_1</code>.</p>
<p>So, here's the code:</p>
<pre><code>import collections
vals = {}
for v, n in lst_1:
    vals.setdefault(n, collections.deque()).append(v)

#vals == {'Paul': [4], 'Coco': [9, 11], 'John': [1], 'Mcquin': [2], 'Jimmy': [7]}
#        (each key here ^^ is actually a deque but it's easier to see with lists)
r = []
for _,n,_ in lst_2:
    r.append([n, vals[n].popleft()])
</code></pre>
<p>giving <code>r</code> (for result) as:</p>
<pre><code>[['Mcquin', 2], ['Paul', 4], ['John', 1], ['Coco', 9], ['Jimmy', 7], ['Coco', 11]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If both your lists have the same amount of names, you could store the indices of each element in a <a href="https://docs.python.org/3.6/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>, then pop off each index and use it as the sort key when an item is found during sorting. </p>
<p><strong>Demo:</strong></p>
<pre><code>from collections import defaultdict, deque

lst_1 = [[1, 'John'], [2, 'Mcquin'], [4, 'Paul'], [7, 'Jimmy'], [9, 'Coco'], [11, 'Coco']]
lst_2 = [[3, 'Mcquin', 1], [6, 'Paul', 6], [5, 'John', 15], [12, 'Coco', 18], [8, 'Jimmy', 24], [10, 'Coco', 24]]

sort_map = defaultdict(deque)
for i, x in enumerate(lst_2):
    sort_map[x[1]].append(i)

result = sorted(lst_1, key=lambda x: sort_map[x[1]].popleft())

print(result)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>[[2, 'Mcquin'], [4, 'Paul'], [1, 'John'], [9, 'Coco'], [7, 'Jimmy'], [11, 'Coco']]. 
</code></pre>
<p><strong>Note:</strong> You can use <a href="https://docs.python.org/3.6/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a> to pop off elements from the beginning in constant time, as shown above. This minor improvement allows the above solution to remain at overall O(NlogN), which is the cost of sorting. </p>
</div>
<div class="post-text" itemprop="text">
<p>Very not pythonish but still easy to understand and working:</p>
<pre><code>lst_new = []
for item in lst_2:
    name = item[1]
    for item2 in lst_1:
        if name == item2[1]:
            lst_new.append(list.copy(item2))
            lst_1.remove(item2)
            #item2[1] = "" is also an option but it's worse for long inputs
            break
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; lst_new
[[2, 'Mcquin'], [4, 'Paul'], [1, 'John'], [9, 'Coco'], [7, 'Jimmy'], [11, 'Coco']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given two lists:</p>
<pre><code>xs = [[4, 'a'], [3, 'b'], [7, 'c'], [10, 'd']]
ys = [ 7, 3, 4, 10]
</code></pre>
<p>the following line sorts the list <code>xs</code> by the order of items in <code>ys</code>:</p>
<pre><code>[x for y in ys for x in xs if x[0] == y]
</code></pre>
<p>Result:</p>
<pre><code>&gt;&gt;&gt; [x for y in ys for x in xs if x[0] == y]
[[7, 'c'], [3, 'b'], [4, 'a'], [10, 'd']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>l = sorted(lst_1, key=lambda x: [i[2] for i in lst_2 if i[1] == x[1]][0])
</code></pre>
<p>Explanation: We're sorting with the key being the 3rd value (i[2]) from lst_2 only if the 2nd value matches the argument (i[1] == x[1]).</p>
<p>Note that if a value that exist in lst_1 is missing from lst_2 an error will result (perhaps justifiably, since a key is missing).</p>
</div>
<span class="comment-copy">How does an entry of <code>lst_1</code> map to <code>lst_2</code> And your preferred output is <b>not</b> based on <code>lst_2[i][1]</code>.</span>
<span class="comment-copy">but it is? it's ordered following the order of the first occurrence of every name in the second list</span>
<span class="comment-copy">by your logic: <code>[2, 'Mcquin']</code> is provided by <code>'Paul'</code> (<code>lst_2[1][1]</code>) - what kind of sorting did you imagine?</span>
<span class="comment-copy">@liliscent For example, if <code>lst_2[0][1] == 'Mcquin'</code> then the new sorted <code>lst_1[0]</code> should be the sublist that contains <code>'Mcquin'</code></span>
<span class="comment-copy">Please edit your question to make the sort order as specific as possible.</span>
<span class="comment-copy">the three last entries should be <code>[12, 'Coco', 18], [8, 'Jimmy', 24], [10, 'Coco', 24]</code></span>
<span class="comment-copy">@JohnSmith See the updated answer, it now works properly (sorry for the mistake before) and is even more efficient!</span>
<span class="comment-copy"><code>pop(0)</code> is O(N) I believe. If you use <code>popleft()</code> from <code>deque</code> this would be a O(N) solution, since it's O(1) instead when popping from the front. Nice job :-).</span>
<span class="comment-copy">@RoadRunner Very interesting, led me to reading up a lot about CPython's implementation of <code>lists</code>! I have updated the answer to use <code>deque</code> now.</span>
<span class="comment-copy">Explain the downvote because this works as OP intended</span>
<span class="comment-copy">The only reason I can see for the downvote is that this is <code>O(nm)</code>. Other than that, its a completely valid solution. I think its a pretty creative solution.</span>
<span class="comment-copy">ah I didn't think of <code>item[2] = ""</code>. Nice one!</span>
<span class="comment-copy">@RoadRunner yeah it's not so efficient but if the lists are going to be not very long I don't see a reason to write a more complicated algorithm</span>
<span class="comment-copy">@JohnSmith actually, you could simply do <code>lst_1.remove(item2)</code> and make the algorithm faster for longer lists</span>
