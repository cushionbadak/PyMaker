<div class="post-text" itemprop="text">
<p>I have two lists of equal length, one containing <code>labels</code> and the other <code>data</code>. For example:</p>
<pre><code>labels = ['cat', 'cat', 'dog', 'dog', 'dog', 'fish', 'fish', 'giraffe', ...]
data = [ 0.3, 0.1, 0.9, 0.5, 0.4, 0.3, 0.2, 0.8, ... ]
</code></pre>
<p>How can I extract sub-lists of both lists in parallel based on a particular label in the <code>labels</code> list? </p>
<p>For example, using <code>fish</code> as a selection criteria, I want to generate:</p>
<pre><code>selected_labels = [ 'fish', 'fish' ]
selected_data = [ 0.3, 0.2 ]
</code></pre>
<p>My best guess sounds cumbersome - make a list of element-wise tuples, extract a list of relevant tuples from that list, then de-tuple that list of tuples back into two lists of single elements. Even if that's the way to approach it, I'm too new to Python to stumble on the syntax for that. </p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> and a <a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow noreferrer">generator expression</a> this can be done like:</p>
<h3>Code:</h3>
<pre><code>tuples = (x for x in zip(labels, data) if x[0] == 'fish')
selected_labels, selected_data = map(list, zip(*tuples))
</code></pre>
<h3>How does this work?</h3>
<p>The <code>tuples</code> line builds a <a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow noreferrer">generator expression</a> which zips the two lists together and drops any thing that is uninteresting.  The second line uses zip again and then <code>map</code>s the resulting tuples into <code>list</code>s as desired.</p>
<p>This has the advantage of building no intermediate data structures so should be fairly fast and memory efficient.</p>
<h3>Test Code:</h3>
<pre><code>labels = ['cat', 'cat', 'dog', 'dog', 'dog', 'fish', 'fish', 'giraffe']
data = [0.3, 0.1, 0.9, 0.5, 0.4, 0.3, 0.2, 0.8]

tuples = (x for x in zip(labels, data) if x[0] == 'fish')
selected_labels, selected_data = map(list, zip(*tuples))

print(selected_labels)
print(selected_data)
</code></pre>
<h3>Results:</h3>
<pre><code>['fish', 'fish']
[0.3, 0.2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This might be a good place to apply <a href="https://docs.python.org/3/library/itertools.html#itertools.compress" rel="nofollow noreferrer"><code>itertools.compress</code></a>, which is slightly faster than <code>zip</code>, at least for the size of data structures you're working with.</p>
<pre><code>from itertools import compress

selected_data = list(compress(data, (i=='fish' for i in labels)))
selected_labels = ['fish'] * len(selected_data)
</code></pre>
<p>Usage:</p>
<pre><code>compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F
</code></pre>
<p>Timing:</p>
<pre><code>def with_compress():
    selected_data = list(compress(data, (i=='fish' for i in labels)))
    selected_labels = ['fish'] * len(selected_data)
    return selected_data, selected_labels

def with_zip():
    tuples = (x for x in zip(labels, data) if x[0] == 'fish')
    selected_labels, selected_data = map(list, zip(*tuples))
    return selected_data, selected_labels

%timeit -r 7 -n 100000 with_compress()
3.82 µs ± 96.8 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

%timeit -r 7 -n 100000 with_zip()
4.67 µs ± 348 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p><code>(i=='fish' for i in labels)</code> is a generator of <code>True</code> and <code>False</code>.  <code>compress</code> filters down <code>data</code> element-wise to cases where <code>True</code> occurs.</p>
<p>From the docstring:</p>
<blockquote>
<p>Roughly equivalent to:</p>
<pre><code>def compress(data, selectors):
    # compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F
    return (d for d, s in zip(data, selectors) if s)
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can <a href="https://docs.python.org/3.3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> the lists together, filter them based on the keyword you are looking for and then <a href="https://stackoverflow.com/a/19343/5741172"><code>unzip</code></a></p>
<pre><code>&gt;&gt;&gt; items = zip(*filter(lambda x: x[0] == "fish",zip(labels,data)))
&gt;&gt;&gt; list(items)
&gt;&gt;&gt; [('fish', 'fish'), (0.3, 0.2)]
</code></pre>
<p>Then your <code>selected_data</code> and <code>selected_labels</code> would be:</p>
<pre><code>&gt;&gt;&gt; selected_data = list(items[1])
&gt;&gt;&gt; selected_labels = list(items[0])
</code></pre>
<p>Another alternative is to use <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> function to get the desired format:</p>
<pre><code> &gt;&gt;&gt; items = map(list,zip(*filter(lambda x: x[0] == "fish",zip(labels,data))))
&gt;&gt;&gt; list(items) 
&gt;&gt;&gt; [['fish', 'fish'], [0.3, 0.2]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The simplest approach is totally fine here, and likely very performant:</p>
<pre><code>&gt;&gt;&gt; selected_labels, selected_data  = [], []
&gt;&gt;&gt; for l, d in zip(labels, data):
...     if l == 'fish':
...         selected_labels.append(l)
...         selected_data.append(d)
...
&gt;&gt;&gt; selected_labels
['fish', 'fish']
&gt;&gt;&gt; selected_data
[0.3, 0.2]
</code></pre>
<p>Some more timings, didn't have time to include every approach so far, but here's a few:</p>
<pre><code>&gt;&gt;&gt; labels*=5000
&gt;&gt;&gt; data *= 5000
&gt;&gt;&gt; def juan(data, labels, target):
...     selected_labels, selected_data  = [], []
...     for l, d in zip(labels, data):
...         if l == target:
...             selected_labels.append(l)
...             selected_data.append(d)
...     return selected_labels, selected_data
...
&gt;&gt;&gt; def stephen_rauch(data, labels, target):
...     tuples = (x for x in zip(labels, data) if x[0] == target)
...     selected_labels, selected_data = map(list, zip(*tuples))
...     return selected_labels, selected_data
...
&gt;&gt;&gt; from itertools import compress
&gt;&gt;&gt;
&gt;&gt;&gt; def brad_solomon(data, labels, target):
...     selected_data = list(compress(data, (i==target for i in labels)))
...     selected_labels = ['fish'] * len(selected_data)
...     return selected_data, selected_labels
...
&gt;&gt;&gt; import timeit
&gt;&gt;&gt; setup = "from __main__ import data, labels, juan, stephen_rauch, brad_solomon"
&gt;&gt;&gt; timeit.timeit("juan(data,labels,'fish')", setup, number=1000)
3.1627789690101054
&gt;&gt;&gt; timeit.timeit("stephen_rauch(data,labels,'fish')", setup, number=1000)
3.8860850729979575
&gt;&gt;&gt; timeit.timeit("brad_solomon(data,labels,'fish')", setup, number=1000)
2.7442518350144383
</code></pre>
<p>I would say, relying on <code>itertools.compress</code> is doing just fine. I was worried that having to do <code>selected_labels = ['fish'] * len(selected_data)</code> would slow it down, but it is an expression that could be highly optimized in Python (size of the list known ahead of time, and simply repeating the same pointer). Finally, note, the simple, naive approach I gave can be optimized by "caching" the <code>.append</code> method:</p>
<pre><code>&gt;&gt;&gt; def juan(data, labels, target):
...     selected_labels, selected_data  = [], []
...     append_label = selected_labels.append
...     append_data = selected_data.append
...     for l, d in zip(labels, data):
...         if l == target:
...             append_label(l)
...             append_data(d)
...     return selected_labels, selected_data
...
&gt;&gt;&gt; timeit.timeit("juan(data,labels,'fish')", setup, number=1000)
2.577823764993809
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As an alternative to the <code>zip</code> answer, you might consider using a different data structure.  I would put that in a <code>dict</code></p>
<pre><code>data = {'cat' : [0.3, 0.1],
        'dog' : [0.9, 0.5, 0.4],
        'fish' : [0.3, 0.2],
        'giraffe' : [0.8],
        # ...
        }
</code></pre>
<p>Then to access, just <code>data['fish']</code> will give <code>[0.3, 0.2]</code> </p>
<p>You can load the data you have into such a <code>dict</code>by doing this one time only</p>
<pre><code>data2 = {}
for label, datum in zip(labels,data):
    if label not in data2:
        data2[label] = []
    data2[label].append(datum)
</code></pre>
<p>Then just do this for each query</p>
<pre><code>select = 'fish'
selected_data = data2[select]
selected_labels = [select] * len(selected_data)
</code></pre>
</div>
<span class="comment-copy">Can I suggest something: instead of <code>tuples = ( ... )</code> which creates a mysterious object that is hard to inspect/print, that you change to <code>list_of_tuples = [ ... ]</code> which is easier to inspect/print, and ultimately easier to understand? If tuples are better in some way, perhaps explain why.</span>
<span class="comment-copy">@omatai It's a generator, so you don't evaluate all at once.</span>
<span class="comment-copy">OK - so you're saying that just because it is enclosed in <code>()</code> it doesn't generate tuples immediately, it creates a generator object that will generate tuples when required? I think I get that. Still having difficulty comprehending the list unpacking, but working on it...</span>
<span class="comment-copy">In this particular case, generator doesn't actually pay back much. It's fully evaluated at <code>*tuples</code>.</span>
<span class="comment-copy">Iterating on Numpy/pandas data is often different.  Numpy has very specialized (vectorized) ways to get performance.  Suggest you put together another specific question.  This question here was well received, I am sure you can construct another great question.</span>
<span class="comment-copy">I understand all of this apart from the <code>*</code> - can you provide a reference to this syntax to help newcomers? (<code>*</code> is hard to search for...)</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/3480184/unpack-a-list-in-python">* is list unpacking</a></span>
<span class="comment-copy">Stop putting unnecessary calls to <code>list</code> everywhere, it defeats the purpose of using these iterators</span>
<span class="comment-copy">@juanpa.arrivillaga I have updated my answer.</span>
<span class="comment-copy">Thanks for this - definitely the easiest answer to understand. That said, it is very useful to see a range of ways to solve the same problem, some of which introduce more powerful concepts.</span>
<span class="comment-copy">I don't have the luxury of supplying the data in a new data structure. If you want to avoid downvote, please specify the code to make the conversion. Also, weird as it seems, even if there are 10000 items of <code>fish</code> data, I still need a second list with 10000 identical labels of <code>fish</code>.</span>
