<div class="post-text" itemprop="text">
<p>Given a pattern and a string <code>str</code>, find if <code>str</code> follows the same pattern.</p>
<p>Here follows means a full match, such that there is a bijection between a letter in pattern and a non-empty word in <code>str</code>.</p>
<p>Examples:
<code>pattern = "abba"</code>, <code>str = "dog cat cat dog"</code> should return true; <code>dog</code> is <code>a</code>, <code>cat</code> is <code>b</code> and the words form the <code>abba</code> pattern.
<code>pattern = "abba"</code>, <code>str = "dog cat cat fish"</code> should return false; the string follows a <code>abbc</code> pattern instead.</p>
<p>My solution works in Python 2:</p>
<pre><code>def wordPattern(self, pattern, str):
    s = pattern
    t = str.split()
    return map(s.find, s) == map(t.index, t)
</code></pre>
<p>But I am just wondering why this solution  does not working in Python 3. There, the function will always return <code>False</code> when trying to test the above examples. Could anyone please give some advice?  </p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, <code>map()</code> returns an iterator object, not a list. Equality testing between these objects won't work (equality is testing for <em>identity</em>, the exact same object in memory, instead).</p>
<p>Convert to lists explicitly:</p>
<pre><code>def wordPattern(self, pattern, str):
    s = pattern
    t = str.split()
    return list(map(s.find, s)) == list(map(t.index, t))
</code></pre>
<p>or use list comprehensions:</p>
<pre><code>def wordPattern(self, pattern, str):
    s = pattern
    t = str.split()
    return [s.find(c) for c in  s] == [t.index(w) for w in t]
</code></pre>
<p>or avoid creating lists altogether by comparing the zipped results with the <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow noreferrer"><code>all()</code> function</a>:</p>
<pre><code>from operator import eq
from itertools import starmap, zip_longest

def wordPattern(self, pattern, str):
    s = pattern
    t = str.split()
    return all(starmap(eq, zip_longest(map(s.find, s), map(t.index, t))))
</code></pre>
<p>The latter short-circuits without having to make all comparisons if there is no match. In the spirit of keeping the functional style, I used <a href="https://docs.python.org/3/library/itertools.html#itertools.starmap" rel="nofollow noreferrer"><code>itertools.starmap()</code></a> to test for equality with the <a href="https://docs.python.org/3/library/operator.html#operator.eq" rel="nofollow noreferrer"><code>operator.eq()</code> function</a>. By using <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest()</code></a> we make sure that we can detect the case where the pattern length and word count don't match.</p>
</div>
<span class="comment-copy">map returns a generator in python 3</span>
<span class="comment-copy">Use list(map(...))</span>
<span class="comment-copy">thanks for the corrections :) yours already tells the story to tell so mine is superflous.</span>
<span class="comment-copy">I heard that <code>list1 == list2</code> comparisons short circuit too, is that right? see comment here <a href="https://stackoverflow.com/a/18410924/6260170">stackoverflow.com/a/18410924/6260170</a></span>
<span class="comment-copy">@Chris_Rands: it does, but you first have to do two full iterations to <i>create the lists</i>.</span>
<span class="comment-copy">@MartijnPieters of course, thanks!</span>
<span class="comment-copy">@MartijnPieters I think that the last solution only works if <code>s</code> and <code>t</code> have the same number of elements. Did I miss something?</span>
