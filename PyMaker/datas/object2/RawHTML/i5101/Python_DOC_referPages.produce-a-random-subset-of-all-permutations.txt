<div class="post-text" itemprop="text">
<p>I'm looking for a way to randomly sample a fixed length subset of all permutations. </p>
<pre><code>import itertools
from random import shuffle

mylist = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T']
</code></pre>
<h2>APPROACH A</h2>
<p>Approach A below suffers from the problem that the permutations are too similar.</p>
<pre><code>a_pre = itertools.permutations(mylist,20)
a = itertools.islice(a_pre,3)

list(a)
</code></pre>
<blockquote>
<p>['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T']</p>
<p>['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'T', 'S']</p>
<p>['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'S', 'R', 'T']</p>
</blockquote>
<h2>APPROACH B</h2>
<p>Approach B gets me closer to my desired outcome, but here there's always a risk of producing identical ordering between lists, so this approach is not feasible.</p>
<pre><code>#repeat n=3 times

shuffle(mylist)
print(mylist)
</code></pre>
<blockquote>
<p>['J', 'B', 'M', 'A', 'O', 'C', 'K', 'S', 'H', 'Q', 'N', 'T', 'R', 'D', 'G', 'P', 'I', 'E', 'F', 'L']</p>
<p>['R', 'O', 'C', 'I', 'G', 'E', 'Q', 'L', 'P', 'J', 'F', 'N', 'A', 'B', 'H', 'T', 'D', 'K', 'M', 'S']</p>
<p>['L', 'O', 'I', 'G', 'B', 'E', 'R', 'A', 'D', 'N', 'J', 'S', 'H', 'F', 'K', 'M', 'Q', 'T', 'C', 'P']</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>but here there's always a risk of producing identical ordering between lists, so this approach is not feasible.</p>
</blockquote>
<p>You can use tuples (since lists aren't hashable) and sets (so that there are no duplicates/identical lists) to get around this:</p>
<pre><code>from random import shuffle

mylist = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T']
myset = set()
while len(myset) &lt; 5: #change 5 to however many you want
     shuffle(mylist)
     myset.add(tuple(mylist))
print([list(x) for x in myset])
</code></pre>
<p>Edit: As <a href="https://stackoverflow.com/users/1639625/tobias-k">@tobias_k</a> points out:</p>
<blockquote>
<p>For the given list, there are 20! = 2432902008176640000 different permutations, so collisions are really very unlikely.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Consider the itertools <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>random_permutation</code> recipe</a>:</p>
<p>From the docs:</p>
<pre><code>def random_permutation(iterable, r=None):
    "Random selection from itertools.permutations(iterable, r)"
    pool = tuple(iterable)
    r = len(pool) if r is None else r
    return tuple(random.sample(pool, r))
</code></pre>
<p><strong>Code</strong></p>
<pre><code>import string

import more_itertools as mit


iterable = string.ascii_uppercase[:-6]
[random_permutation(iterable) for _ in range(3)]
</code></pre>
<p>Output</p>
<pre><code>[('M', 'K', 'Q', 'A', 'I', 'J', 'H', 'T', 'C', 'E', 'P', 'L', 'B', 'N', 'G', 'F', 'S', 'D', 'O', 'R'), 
 ('A', 'G', 'I', 'S', 'E', 'T', 'B', 'Q', 'D', 'M', 'C', 'O', 'J', 'H', 'N', 'F', 'K', 'P', 'R', 'L'), 
 ('C', 'S', 'O', 'H', 'I', 'K', 'A', 'G', 'D', 'B', 'R', 'E', 'L', 'T', 'M', 'N', 'F', 'P', 'Q', 'J')]
</code></pre>
<p><a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> is a third-party library that <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.random_permutation" rel="nofollow noreferrer">implements this recipe</a> for you.</p>
</div>
<div class="post-text" itemprop="text">
<p>you could use this to generate the <code>number</code>-th lexicographic perutation of <code>N</code> elements:</p>
<pre><code>def permutation_from_int(N, number):
    '''
    get the number-th lexicographic permutation of length N.

    N: the length of the permutation
    0 &lt;= number &lt;= factorial(N) -1: the number of the desired
    permutation
    '''

    # assert 0 &lt;= number &lt; factorial(N)

    ret = [None] * N
    select = list(range(N))

    for i in range(N - 1, -1, -1):
        index, number = divmod(number, factorial(i))
        element = select[index]
        ret[N - 1 - i] = element
        select.remove(element)
    return ret
</code></pre>
<p>then you just have to generate (and keep a <code>set</code> of - if you want to avoid duplicates) random integers that represent the permutations:</p>
<pre><code>N_TESTS = 17
strg = 'ABCD'
N = len(strg)
N_MAX = factorial(N)
seen = set()

for _ in range(N_TESTS):
    number = randrange(N_MAX)
    while number in seen:
        number = randrange(N_MAX)
    seen.add(number)
    perm = permutation_from_int(N, number)
    print(''.join(strg[i] for i in perm))
</code></pre>
<p>note that this may loop forever if the number of test is bigger that the space of all the permutations...</p>
<p>which prints (e.g.):</p>
<pre><code>DACB
DBCA
BADC
BDCA
DCAB
DABC
CADB
DBAC
DCBA
...
</code></pre>
<p>but as mentioned in the other answers: if you have a permutation of 20 elements the chance of hitting a repeated permutation is very small!</p>
</div>
<div class="post-text" itemprop="text">
<p>I think your question is a special case of <a href="https://stackoverflow.com/questions/48580361/python-given-a-set-of-n-elements-choose-k-at-random-m-times">one I had</a>, for k=N
Based on this, the two solutions stated there should apply. The first one is a tad slow :)</p>
<p>So the random sampling one (Which you also hint at your question, just discard duplicates...) seems to be the only answer for now.</p>
<p>It would be very interesting to see if there is a generative solution to either this question, or the more general one...
Here's the code based on that answer:</p>
<pre><code>import itertools
from random import shuffle

mylist = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T']
n=len(mylist)
k = n
m = 5
samples = set()
tries = 0
while len(samples) &lt; m:
    samples.add(tuple(random.sample(mylist,k)))
    print (len(samples))

print(samples)
print(tries)
</code></pre>
</div>
<span class="comment-copy">How many permutations do you want to generate?  You can store the ones you already had in a set (e.g. after concatenating the list to a string, or after turning it into a tuple) and avoid the ones you have already used.</span>
<span class="comment-copy">For the given list, there are 20! = 2432902008176640000 different permutations, so collisions are really very unlikely.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/12581437/python-random-sample-with-a-generator-iterable-iterator">Python random sample with a generator / iterable / iterator</a></span>
<span class="comment-copy">You might add a bit about the chance of encountering duplicates (very, very low for the given list).</span>
