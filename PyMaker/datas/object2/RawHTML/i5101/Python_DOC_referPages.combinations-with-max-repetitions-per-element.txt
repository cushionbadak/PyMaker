<div class="post-text" itemprop="text">
<p>I want to get a list of k-sized tuples with the combinations of a list of elements (let's call it <code>elements</code>) similar to what <code>itertools.combinations_with_replacement(elements, k)</code> would do. The difference is that I want to add a maximum to the number of replacements per element. </p>
<p>So for example if I run the following:</p>
<pre><code>elements = ['a', 'b']
print(list(itertools.combinations_with_replacement(elements, 3)))
</code></pre>
<p>I get:</p>
<pre><code>[('a', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'b'), ('b', 'b', 'b')]
</code></pre>
<p>I would like to have something like the following:</p>
<pre><code>elements = {'a': 2, 'b': 3}
print(list(combinations_with_max_replacement(elements, 3)))
</code></pre>
<p>Which would print</p>
<pre><code>[('a', 'a', 'b'), ('a', 'b', 'b'), ('b', 'b', 'b')]
</code></pre>
<p>Notice that the max number of <code>'a'</code> in each tuple is <code>2</code> so <code>('a', 'a', 'a')</code> is not part of the result. </p>
<p>I'd prefer to avoid looping through the results of <code>itertools.combinations_with_replacement(elements, k)</code> counting the elements in each tuple and filtering them out.</p>
<p>Let me know if I can give any further info.</p>
<p>Thanks for the help!</p>
<p><strong>UPDATE</strong></p>
<p>I tried:</p>
<pre><code>elements = ['a'] * 2 + ['b'] * 3
print(set(itertools.combinations(elements, 3)))
</code></pre>
<p>and get:</p>
<pre><code>{('a', 'b', 'b'), ('b', 'b', 'b'), ('a', 'a', 'b')}
</code></pre>
<p>I get the elements I need but I lose the order and seems kind of hacky</p>
</div>
<div class="post-text" itemprop="text">
<p>I know you don't want to loop through the results but maybe it's easier to filter the output in this way.</p>
<pre><code>def custom_combinations(elements, max_count):
    L = list(itertools.combinations_with_replacement(elements, max_count))
    for element in elements.keys():
        L = list(filter(lambda x: x.count(element) &lt;= elements[element], L))
    return L
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Pure Python Solution</strong> (i.e. without <code>itertools</code>)</p>
<p>You can use <em>recursion</em>:</p>
<pre><code>def combos(els, l):
    if l == 1:
        return [(k,) for k, v in els.items() if v]
    cs = []
    for e in els:
        nd = {k: v if k != e else v - 1 for k, v in els.items() if v}
        cs += [(e,)+c for c in combos(nd, l-1)]
    return cs
</code></pre>
<p>and a test shows it works:</p>
<pre><code>&gt;&gt;&gt; combos({'a': 2, 'b': 3}, 3)
[('b', 'b', 'b'), ('b', 'b', 'a'), ('b', 'a', 'b'), ('b', 'a', 'a'), ('a', 'b', 'b'), ('a', 'b', 'a'), ('a', 'a', 'b')]
</code></pre>
<p><em>note that we do loose the order but this is unavoidable if we are passing <code>els</code> as a <code>dictionary</code> as you requested.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>I believe this recursive solution has the time complexity you desire.</p>
<p>Rather than passing down a dict, we pass down a list of the item pairs. We also pass down <code>start_idx</code>, which tells the 'lower' recursive function calls to ignore earlier elements. This fixes the out-of-order problem of the other recursive answer.</p>
<pre><code>def _combos(elements, start_idx, length):
    # ignore elements before start_idx
    for i in range(start_idx, len(elements)):
        elem, count = elements[i]
        if count == 0:
            continue
        # base case: only one element needed
        if length == 1:
            yield (elem,)
        else:
            # need more than one elem: mutate the list and recurse
            elements[i] = (elem, count - 1)
            # when we recurse, we ignore elements before this one
            # this ensures we find combinations, not permutations
            for combo in _combos(elements, i, length - 1):
                yield (elem,) + combo
            # fix the list
            elements[i] = (elem, count)


def combos(elements, length):
    elements = list(elements.items())
    return _combos(elements, 0, length)

print(list(combos({'a': 2, 'b': 3}, 3)))
# [('a', 'a', 'b'), ('a', 'b', 'b'), ('b', 'b', 'b')]
</code></pre>
<p>As an bonus, profiling shows it's more performant than the set(itertools.combinations(_)) solution as the input size grows.</p>
<pre><code>print(timeit.Timer("list(combos({'a': 2, 'b': 2, 'c': 2}, 3))",
             setup="from __main__ import combos").timeit())
# 9.647649317979813
print(timeit.Timer("set(itertools.combinations(['a'] * 2 + ['b'] * 2 + ['c'] * 2, 3))").timeit())
# 1.7750148189952597

print(timeit.Timer("list(combos({'a': 4, 'b': 4, 'c': 4}, 4))",
             setup="from __main__ import combos").timeit())
# 20.669851204031147
print(timeit.Timer("set(itertools.combinations(['a'] * 4 + ['b'] * 4 + ['c'] * 4, 4))").timeit())
# 28.194088937016204

print(timeit.Timer("list(combos({'a': 5, 'b': 5, 'c': 5}, 5))",
             setup="from __main__ import combos").timeit())
# 36.4631432640017
print(timeit.Timer("set(itertools.combinations(['a'] * 5 + ['b'] * 5 + ['c'] * 5, 5))").timeit())
# 177.29063899395987
</code></pre>
</div>
<span class="comment-copy">Using <code>set</code> is essentially just removing duplicates by iterating over it...</span>
<span class="comment-copy">Yes, thatâ€™s correct, so no progress from my end</span>
<span class="comment-copy">I have just posted a solution which doesn't use any filtering</span>
<span class="comment-copy">Thanks for your answer. Your approach behaves as expected but I was expecting to avoid looping through the elements specifically because it adds an <code>O(n^2)</code> additional complexity with <code>n</code> being the number of combinations returned, which I am expecting to be a big number</span>
<span class="comment-copy">There is always an <a href="https://docs.python.org/3/library/collections.html?highlight=ordereddict#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a></span>
<span class="comment-copy">Thanks for the answer. Your approach returns undesired elements like <code>('b', 'a', 'b')</code> which by <code>itertools.combinations</code> is considered the same as <code>('a', 'b', 'b')</code>, and thus not returned. Also, timed it and it's way slower than an approach that filters out the elements by looping through them. The whole idea is not to increase time complexity. Also, I wouldn't mind using a list of tuples or OrderedDict if that helps preserve the order</span>
