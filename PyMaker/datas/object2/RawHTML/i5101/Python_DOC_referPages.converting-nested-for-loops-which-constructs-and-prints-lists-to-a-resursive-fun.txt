<div class="post-text" itemprop="text">
<p>I'm trying to convert the following nested for loops which constructs and prints a list into a recursive function as it would greatly improve the runtime of it.  However, I'm having difficulty with this.  How could I go about converting it with so many layers of nested loops?</p>
<pre><code>for v in range(-10, 11, 1):
     for w in range(-10, 11, 1):
            for x in range(-10, 11, 1):
                for y in range(-10, 11, 1):
                    for z in range(-10, 11, 1):
                        print([v, w, x, y, z])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/users/8347081/mypetlion">@mypetlion</a> mentioned above, recursion in Python might not give you the performance boost you are looking for.</p>
<p>What about using <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a>? I haven't benchmarked it compared to your original but it does seem to be <a href="https://github.com/python/cpython/blob/7745ec4e356ac1f4eaf43b155f4482c20a907d48/Modules/itertoolsmodule.c#L2031" rel="nofollow noreferrer">implemented in C</a>.</p>
<pre><code>from itertools import product

for p in product(range(-10, 11), repeat=5):
    print(p)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understood well, this could be a <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" rel="nofollow noreferrer">combination with replacement</a> function done with <code>itertools</code>:</p>
<pre><code>import itertools
import numpy as np

comb =  list(itertools.combinations_with_replacement(range(-10,11,1), 5))

for x in comb:
    print  np.asarray(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create default list in the function signature to store the elements you have currently accumulated, and once the length of the list equals the desired amount, yield the current list:</p>
<pre><code>def combinations(count, args, current = []): 
    if len(current) == count:
       yield current
    else:
       for i in range(*args):
         yield from combinations(count, args, current + [i])

print(list(combinations(5, [-10, 11])))
</code></pre>
</div>
<span class="comment-copy">Minor typo in the first line: <code>for (v in range(-10, 11, 1))</code> should be <code>for v in range(-10, 11, 1)</code> I presume. Your point is clear nevertheless.</span>
<span class="comment-copy">While recursion does have some advantages over iteration, performance is generally not one of them. Especially not in Python, which by default, doesn't optimize tail recursion. Is there any other reason you need this to be in the form of a recursive function?</span>
<span class="comment-copy">@mypetlion Honestly, I'm just trying to see if I'd get any performance advantages as well as it being a personal challenge.</span>
<span class="comment-copy">What would be an example output?</span>
<span class="comment-copy">@SebastienD <code>[-4, 0, 7, 1, 7]</code></span>
<span class="comment-copy">I was about to mention the same solution. According to the documentation "This function (...) does not build up intermediate results in memory", so it is a perf win. Moreover, if there was something else to optimize, I'm pretty sure they'd do that.</span>
<span class="comment-copy">Still doesn't match the output of the original. Your last two lines: <code>[ 9 10 10 10 10]; [10 10 10 10 10]</code> VS Original last two lines: <code>[10, 10, 10, 10, 9]; [10, 10, 10, 10, 10]</code>. If you just run the original code you will see that the pattern does not match the output of <code>combinations_with_replacement</code>.</span>
<span class="comment-copy">Alright I see, the output order matters this is it?</span>
<span class="comment-copy">This link shows the last few lines of your output VS the original codes output (the outputs are totally different): <a href="https://bpaste.net/show/bbb6497d707d" rel="nofollow noreferrer">bpaste.net/show/bbb6497d707d</a></span>
<span class="comment-copy">You're using both iteration and recursion here, which is not what the question asked for. Your <code>print</code> statement also doesn't produce the desired output.</span>
<span class="comment-copy">@mypetlion The OP does not specifically state that all loops were to be eliminated from the recursion. However, I did fix the <code>print</code> statement so that the generator expression will be forced to retrieve all combinations in memory.</span>
