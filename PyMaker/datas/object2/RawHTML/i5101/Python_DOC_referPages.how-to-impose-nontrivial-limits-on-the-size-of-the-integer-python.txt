<div class="post-text" itemprop="text">
<p>I'm implementing simple socket programming which compute <code>Post-Fix</code> operation. It's just computing a single operation such as "<code>1044 900 -</code> " "<code>30 6 /</code>" and so on. (It can compute more complicate post-fix so far) </p>
<p>There are four operators : <code>add</code>, <code>subtract</code>, <code>multiple</code>, <code>divide</code> </p>
<p>I'm programming server and client very defensively. And the question is... <strong>How do we impose (nontrivial) limits on the size of the integer?</strong> Anything we should know about the limitation of computing single operation in Python?</p>
<p><strong>My thought:</strong> 
I guess the python handle automatically unlike C because python is good. So we don't need to worry about it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since defensive programming is not about just limiting number sizes, I expanded my answer to reflect more aspects I find important.</p>
<p><strong>Secure your environment</strong>. Even before you start writing the server, decide who can use the application and how to get rid of malicious users. Authentication? (IP) Ban lists? (IP) White lists? Firewall rules? VPN?</p>
<p><strong>Control your buffers</strong> - have an explicit upper limit. Is the current transmission larger than N bytes? Discard it, then report an error to the client and probably drop the connection. This applies to both directions - an attacker might try to pass you a 10 Gb expression as well as pass you an expression that will weight 10 Gb when computed.</p>
<p>This also applies for input/output queue if you have these - stop accepting more expressions if you already have a lot of work to do.</p>
<p>If you go fully defensive - every piece of dynamically allocated memory must have a limit. Python integers too. Fun fact - according to NASA docs, Curiosity rover doesn't (or at least shouldn't) have any piece of dynamically allocated memory in its software.</p>
<p><strong>Employ simple application protocol</strong>. This means saying no to accepting anything <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer">pickled</a> or ready-for-<a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer"><code>eval</code></a>. Common formats have their vulnerabilities too - consult with OWASP before proceeding and use trusted libraries that have protection against known attacks (for example, see this <a href="https://en.wikipedia.org/wiki/Billion_laughs_attack" rel="nofollow noreferrer">wiki page</a> about billion laughs XML).</p>
<p>You can use a binary protocol in combination with <code>struct</code> module to naturally limit sizes of your numbers to 4 bytes, 8 bytes, or to another arbitrary limit.</p>
<p><strong>Control your call stack</strong>. Don't use recursion (for whatever reason you think you need it) so you naturally avoid dealing with call stack issues. Don't make depth of your stack a function of program input.</p>
<p><strong>Control your compute resources</strong>. Make sure you control the number of concurrent computations in flight. Make sure computations can time out. Make sure the program can't hang the machine. Make sure you're not dealing with huge numbers - your program should try discard an expression early if it is complex enough.</p>
<p>To illustrate. How would your server behave when given <code>2 65536 pow 65536 pow 65536 pow 65536</code> input? A sum of two N-bit integers occupies up to N+1 bits. A product of two N-bit integers occupies up to 2N bits of memory. You can use these rules to predict at what point the size of result becomes unacceptable.</p>
<p><strong>Have a recovery strategy</strong>. If, after all, your application or server fails - how and in what cases can you help to make the app running again without manual intervention? Can you be notified when manual intervention is needed?</p>
</div>
<span class="comment-copy">Please edit your question to include the code as a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>, not external links</span>
<span class="comment-copy">The number of bytes used to represent the integer grows at most linearly with the number of characters in your situation, so you should be fine with just a limit on the number of characters of input (assuming you wanted to have that limit anyway).</span>
<span class="comment-copy">Report an error if the inputs to add or multiply are too large. Or when reading a number it is too long. Or when the stack is too deep.</span>
<span class="comment-copy">@DanD. That's good point. Can we determine how exactly deep the stack can be? How large the inputs to add, multiply or divide can be?</span>
<span class="comment-copy">It is up to you, the implementer, to set a stack depth limit.  In most environments supporting python, hundreds of megabytes are available.  However, a stack depth of millions is far from necessary.  Note that RPN calculators can evaluate 99% of expressions with a maximum stack depth of 4.</span>
