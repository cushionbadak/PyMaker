<div class="post-text" itemprop="text">
<p>I have list of lists and would like to create data frame with count of all unique elements. Here is my test data:</p>
<pre><code>test = [["P1", "P1", "P1", "P2", "P2", "P1", "P1", "P3"],
        ["P1", "P1", "P1"],
        ["P1", "P1", "P1", "P2"],
        ["P4"],
        ["P1", "P4", "P2"],
        ["P1", "P1", "P1"]]
</code></pre>
<p>I can do something like this using <code>Counter</code> with <code>for</code> loop as:</p>
<pre><code>from collections import Counter
for item in test:
     print(Counter(item))
</code></pre>
<p>But how can I have result of this loop summed up into new data frame ?</p>
<p>Expected output as data frame:</p>
<pre><code>P1 P2 P3 P4
15 4  1  2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is one way.</p>
<pre><code>from collections import Counter
from itertools import chain

test = [["P1", "P1", "P1", "P2", "P2", "P1", "P1", "P3"],
        ["P1", "P1", "P1"],
        ["P1", "P1", "P1", "P2"],
        ["P4"],
        ["P1", "P4", "P2"],
        ["P1", "P1", "P1"]]

c = Counter(chain.from_iterable(test))

for k, v in c.items():
    print(k, v)

# P1 15
# P2 4
# P3 1
# P4 2    
</code></pre>
<p>For output as dataframe:</p>
<pre><code>df = pd.DataFrame.from_dict(c, orient='index').transpose()

#    P1 P2 P3 P4
# 0  15  4  1  2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In terms of better performance, you should be either using:</p>
<ul>
<li><p><a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a> as:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; from itertools import chain

&gt;&gt;&gt; Counter(chain.from_iterable(test))
Counter({'P1': 15, 'P2': 4, 'P4': 2, 'P3': 1})
</code></pre></li>
<li><p>OR, yo should be using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> with <em>list comprehension</em> <em>(requires one less import of <code>itertools</code> with same performance)</em> as:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter

&gt;&gt;&gt; Counter([x for a in test for x in a])
Counter({'P1': 15, 'P2': 4, 'P4': 2, 'P3': 1})
</code></pre></li>
</ul>
<p>Keep reading for more alternative solutions and the performance comparison. <em>(skip otherwise)</em></p>
<hr/>
<p><strong><em>Approach 1</em></strong>: <strong>Concatenate your sublists to create the single <code>list</code> and find the count using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a></strong>.</p>
<ul>
<li><p><strong>Solution 1</strong>: Concatenate list using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a> and find the count using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> as:</p>
<pre><code>test = [
    ["P1", "P1", "P1", "P2", "P2", "P1", "P1", "P3"],
    ["P1", "P1", "P1"],
    ["P1", "P1", "P1", "P2"],
    ["P4"],
    ["P1", "P4", "P2"],
    ["P1", "P1", "P1"]
]

from itertools import chain 
from collections import Counter

my_counter = Counter(chain.from_iterable(test)) 
</code></pre></li>
<li><p><strong>Solution 2</strong>: Combine list using <em>list comprehension</em> as:</p>
<pre><code>from collections import Counter

my_counter = Counter([x for a in my_list for x in a])
</code></pre></li>
<li><p><strong>Solution 3</strong>: Concatenate list using <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer"><code>sum</code></a></p>
<pre><code>from collections import Counter

my_counter = Counter(sum(test, []))
</code></pre></li>
</ul>
<hr/>
<p><strong><em>Approach 2:</em></strong> <strong>Calculate count of elements in each sublist using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> and then <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer"><code>sum</code></a> the <code>Counter</code> objects</strong> in the list.</p>
<ul>
<li><p><strong>Solution 4</strong>: Count objects of each sublist using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> and <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> as:</p>
<pre><code>from collections import Counter

my_counter = sum(map(Counter, test), Counter())
</code></pre></li>
<li><p><strong>Solution 5</strong>: Count objects of each sublist using <em>list comprehension</em> as:</p>
<pre><code>from collections import Counter

my_counter = sum([Counter(t) for t in test], Counter())
</code></pre></li>
</ul>
<p>In all the solutions above, <code>my_counter</code> will hold the value:</p>
<pre><code>&gt;&gt;&gt; my_counter
Counter({'P1': 15, 'P2': 4, 'P4': 2, 'P3': 1})
</code></pre>
<hr/>
<h1>Performance Comparison</h1>
<p>Below is the <code>timeit</code> comparison on Python 3 for the list of 1000 sublist and 100 elements in each sublist:</p>
<ol>
<li><p>Fastest using <code>chain.from_iterable</code> <em>(17.1 msec)</em></p>
<pre><code>mquadri$ python3 -m timeit "from collections import Counter; from itertools import chain; my_list = [list(range(100)) for i in range(1000)]" "Counter(chain.from_iterable(my_list))"
100 loops, best of 3: 17.1 msec per loop 
</code></pre></li>
<li><p>Second on the list is using <em>list comprehension</em> to combine the list and then do the <code>Count</code> (similar result as above but without the additional import of <code>itertools</code>) <em>(18.36 msec)</em></p>
<pre><code>mquadri$ python3 -m timeit "from collections import Counter; my_list = [list(range(100)) for i in range(1000)]" "Counter([x for a in my_list for x in a])"
100 loops, best of 3: 18.36 msec per loop
</code></pre></li>
<li><p>Third in terms of performance is using <code>Counter</code> on sublists within <em>list comprehension</em> : <em>(162 msec)</em></p>
<pre><code>mquadri$ python3 -m timeit "from collections import Counter; my_list = [list(range(100)) for i in range(1000)]" "sum([Counter(t) for t in my_list], Counter())"
10 loops, best of 3: 162 msec per loop
</code></pre></li>
<li><p>Fourth on the list is via using <code>Counter</code> with <code>map</code> (results are quite similar to the one using <em>list comprehension</em> above) <em>(176 msec)</em></p>
<pre><code>mquadri$ python3 -m timeit "from collections import Counter; my_list = [list(range(100)) for i in range(1000)]" "sum(map(Counter, my_list), Counter())"
10 loops, best of 3: 176 msec per loop
</code></pre></li>
<li><p>Solution using <code>sum</code> to concatenate the list is too slow <em>(526 msec)</em></p>
<pre><code>mquadri$ python3 -m timeit "from collections import Counter; my_list = [list(range(100)) for i in range(1000)]" "Counter(sum(my_list, []))"
10 loops, best of 3: 526 msec per loop
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Here is another way to do it, using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a></p>
<pre><code>&gt;&gt;&gt; from itertools import groupby, chain

&gt;&gt;&gt; out = [(k,len(list(g))) for k,g in groupby(sorted(chain(*test)))]
&gt;&gt;&gt; out
&gt;&gt;&gt; [('P1', 15), ('P2', 4), ('P3', 1), ('P4', 2)]
</code></pre>
<p>Convert it to dict like:</p>
<pre><code>&gt;&gt;&gt; dict(out)
&gt;&gt;&gt; {'P2': 4, 'P3': 1, 'P1': 15, 'P4': 2}
</code></pre>
<p>To convert it to dataframe use</p>
<pre><code>&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; pd.DataFrame(dict(out), index=[0])
   P1  P2  P3  P4
0  15   4   1   2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The function "set" keeps only the unique elements in a list. Thus, using "len(set(mylinst))", you get the number of unique elements in your list. Then, you only have to iterate over it. </p>
<pre><code>dict_nb_item = {}
i = 0
for test_item in test:
    dict_nb_item[i] = len(set(test_item))
    i += 1
print(dict_nb_item)
</code></pre>
</div>
<span class="comment-copy">There already is functionality to handle imports like you do. It is <code>from itertools import chain.from_iterable as concat</code></span>
<span class="comment-copy">@Ev.Kounis Actually not quite, <code>from itertools import chain as concat</code> would be possible though and I agree that the one liner they current have is nasty, but otherwise decent answer (I made an edit, hope it's ok)</span>
<span class="comment-copy">You don't need a loop, to transform it into a DataFrame: <code>pd.DataFrame.from_dict(c, orient='index').transpose()</code> or even shorter: <code>pd.DataFrame(c, index=[0])</code></span>
<span class="comment-copy">@StefanPochmann Well originally they were re-naming <code>itertools.chain.from_iterable </code> , which I've always thought is too long. Anyway I think they were referring to <a href="http://toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.concat" rel="nofollow noreferrer">toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.concat</a></span>
<span class="comment-copy">Yeah, but then it won't be summing up the <code>Counter</code> but running single Counter on the combined list. However I think I should mention this one too in the answer <i>(nice way to skip import of <code>itertools</code> with same performance)</i></span>
<span class="comment-copy">How does this produce the result the OP is after?</span>
<span class="comment-copy">This one is outputting <code>{0: 3, 1: 1, 2: 2, 3: 1, 4: 3, 5: 1}</code> (Python-3) which is hardy what the OP is looking for.</span>
