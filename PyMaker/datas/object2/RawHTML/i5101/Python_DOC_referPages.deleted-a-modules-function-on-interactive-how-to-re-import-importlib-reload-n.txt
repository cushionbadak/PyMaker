<div class="post-text" itemprop="text">
<p>I've deleted a (package builtin) function on ipython:</p>
<pre><code>Python 3.6.4 |Anaconda custom (64-bit)| (default, Jan 16 2018, 10:22:32) [MSC v.1900 64 bit (AMD64)]
Type 'copyright', 'credits' or 'license' for more information
IPython 6.2.1 -- An enhanced Interactive Python. Type '?' for help.

In [1]: import math

In [2]: math.cos(0)
Out[2]: 1.0

In [3]: del math.cos

In [4]: math.cos(0)
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-4-9cdcc157d079&gt; in &lt;module&gt;()
----&gt; 1 math.cos(0)

AttributeError: module 'math' has no attribute 'cos'
</code></pre>
<p>OK. But how do I reload the function? This didn't help:</p>
<pre><code>In [5]: import importlib

In [6]: importlib.reload(math)
Out[6]: &lt;module 'math' (built-in)&gt;

In [7]: math.cos(0)
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-7-9cdcc157d079&gt; in &lt;module&gt;()
----&gt; 1 math.cos(0)

AttributeError: module 'math' has no attribute 'cos'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The above code works for me in Python 3.4 on Windows but the <a href="https://docs.python.org/3/reference/import.html" rel="nofollow noreferrer">documentation</a> for 3.6 states:</p>
<blockquote>
<p>Beware though, as if you keep a reference to the module object, invalidate its cache entry in sys.modules, and then re-import the named module, the two module objects will not be the same. By contrast, importlib.reload() will reuse the same module object, and simply reinitialise the module contents by rerunning the module’s code.</p>
</blockquote>
<p>(so maybe I was only "lucky")</p>
<p>so what is pretty sure to work is:</p>
<pre><code>import math,sys
del math.cos
del math
sys.modules.pop("math")   # remove from loaded modules
import math
print(math.cos(0))
</code></pre>
<p>It still works, and you don't even need <code>reload</code>. Just remove from cache &amp; import again.</p>
<p>As noted in comments, using <code>reload</code> also works, but you need to update the module reference given by <code>reload</code>, not just reuse the same old one with the <code>cos</code> entry missing:</p>
<pre><code>import math,sys
del math.cos
import importlib
math = importlib.reload(math)
print(math.cos(0))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>OK people, I wrote a little module to solve this confusion.
I sincerely doubt that it is buggless. So improvements are welcome.</p>
<p>This module works nicely both on Py 2 and 3. Tried on Python 2.7 and Python 3.5.</p>
<pre><code>

# rld.py --&gt; the reloading module

import sys

__all__ = ["reload"]

try:
    # Python 2:
    _reload = reload
    from thread import get_ident
    def reload (module):
        if isinstance(module, basestring):
            module = sys.modules[module]
        if module.__name__==__name__:
            raise RuntimeError("Reloading the reloading module is not supported!")
        print ("Reloading: %s" % module.__name__)
        # Get locals() of a frame that called us:
        ls = sys._current_frames()[get_ident()].f_back.f_locals
        # Find variables holding the module:
        vars = [name for name, mod in ls.iteritems() if mod==module]
        if len(vars)==0:
            print ("Warning: Module '%s' has no references in this scope.\nReload will be attempted anyway." % module.__name__)
        else:
            print("Module is referenced as: %s" % repr(vars))
        # Reload:
        m = _reload(module)
        for x in vars:
            ls[x] = m
        print("Reloaded!")
except NameError:
    # Python 3:
    from _thread import get_ident
    def reload (module):
        if isinstance(module, str):
            module = sys.modules[module]
        if module.__name__==__name__:
            raise RuntimeError("Reloading the reloading module is not supported!")
        print ("Reloading: %s" % module.__name__)
        # Get locals() of a frame that called us:
        ls = sys._current_frames()[get_ident()].f_back.f_locals
        # Find variables holding the module:
        vars = [name for name, mod in ls.items() if mod==module]
        if len(vars)==0:
            print ("Warning: Module '%s' has no references in this scope.\nReload will be attempted anyway." % module.__name__)
        else:
            print("Module is referenced as: %s" % repr(vars))
        # Dereference all detected:
        for x in vars:
            del ls[x]
        del sys.modules[module.__name__]
        # Reimport:
        m = __import__(module.__name__)
        # Rebind to old variables:
        for x in vars:
            ls[x] = m
        # Remap references in the old module
        # to redirect all other modules that already imported that module:
        for vname in dir(m):
            setattr(module, vname, getattr(m, vname))
        print("Reloaded!")

&gt;&gt;&gt; # Usage:
&gt;&gt;&gt; from rld import * # Always import it first - just in case
&gt;&gt;&gt; import math
&gt;&gt;&gt; math.cos
&lt;built-in function cos&gt;
&gt;&gt;&gt; del math.cos
&gt;&gt;&gt; math.cos
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'module' object has no attribute 'cos'
&gt;&gt;&gt; reload(math)
Reloading: math
Module is referenced as: ['math']
Reloaded!
&gt;&gt;&gt; math.cos
&lt;built-in function cos&gt;
&gt;&gt;&gt; #-------------------------
&gt;&gt;&gt; # This also works:
&gt;&gt;&gt; import math as quiqui
&gt;&gt;&gt; alias = quiqui
&gt;&gt;&gt; del quiqui.cos
&gt;&gt;&gt; quiqui.cos
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'module' object has no attribute 'cos'
&gt;&gt;&gt; alias.cos
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'module' object has no attribute 'cos'
&gt;&gt;&gt; reload("math")
Reloading: math
Module is referenced as: ['alias', 'quiqui']
&gt;&gt;&gt; quiqui.cos
&lt;built-in function cos&gt;
&gt;&gt;&gt; alias.cos
&lt;built-in function cos&gt;

</code></pre>
</div>
<span class="comment-copy">I cannot reproduce your issue. Works here on python 3.4 windows. please include your exact python version &amp; OS</span>
<span class="comment-copy">have you tried in a non-interactive environment? maybe it's a IPython issue.</span>
<span class="comment-copy">@ Jean-François Fabre, added details on environment in question</span>
<span class="comment-copy">Ow, you can use reload() no problem. Just don't del math, but do: math = reload(math). Whether you do or don't need to remove it from sys.modules first I don't know for Py3. On Py2.7 it is not necessary for most modules. Your example with math works just fine without manually modifying the cache.</span>
<span class="comment-copy">that sounds cleaner, yes. Edited.</span>
<span class="comment-copy">BTW, although the module's address in cache (its reference) doesn't change after reload(), the module in the cache does appear to be reloaded. E.g. sys.modules["math"].cos, after del math.cos will raise AttributeError, but after math = reload(math), sys.modules["math"].cos will be back again. So cache is refreshed. At least in Py27 it is.</span>
<span class="comment-copy">this is tricky stuff! yes, the reload way is better.</span>
<span class="comment-copy">Oh, no, this is just nice and easy. Imagine reloading whole module that was imported using 'from' statement. That's a real mess. Oh, and, yes, using reload() will work, but it will reload only your module. Modules that your module is importing won't be reloaded as long as they are in cache. So don't be surprised if you reload your module after you changed something in its submodule and the change is not reflected.</span>
