<div class="post-text" itemprop="text">
<p>I have a dictionary which looks like:</p>
<pre><code>dict = {'A':[1,2], 'B':[0], 'c':[4]}
</code></pre>
<p>need it to look like:</p>
<pre><code>dict = {'A':[1,2], 'B':[0,0], 'c':[4,0]}
</code></pre>
<p>What I am doing right now:</p>
<pre><code>dict = {x: y+[0] for (x,y) in dict.items() if len(y) &lt; 2}
</code></pre>
<p>which generates:</p>
<pre><code>dict = {'B':[0,0], 'c':[4,0]}
</code></pre>
<p>any idea how I could avoid eliminating those who do not meet the condition?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're almost there. Try:</p>
<pre><code>my_dict = {x: y + [0] if len(y) &lt; 2 else y
           for (x,y) in dict.items()}
</code></pre>
<p>(as mentioned by jp_data_analysis, avoid naming variables after builtins like <code>dict</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>This is one way.</p>
<p><strong>Note</strong>: do not name variables after classes, e.g. use <code>d</code> instead of <code>dict</code>.</p>
<pre><code>d = {'A':[1,2], 'B':[0], 'c':[4]}

d = {k: v if len(v)==2 else v+[0] for k, v in d.items()}

# {'A': [1, 2], 'B': [0, 0], 'c': [4, 0]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use dictionary comprehension:</p>
<pre><code>d = {'A':[1,2], 'B':[0], 'c':[4]}
new_d = {a:b+[0] if len(b) == 1 else b for a, b in d.items()}
</code></pre>
<p>Also, it is best practice not to assign variables to names shadowing common builtins, such as <code>dict</code>, as you are then overriding the function in the current namespace.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>Your code is almost correct. Your problem is that you're filtering out any lists bigger than <code>2</code>. What you need to do instead is simply place them in the new dictionary unchanged. This can be done using the <a href="https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator">ternary operator</a>. It has the form <code>value1 if condition else value2</code>.</p></li>
<li><p>Also, if you want a more general way to pad every list in your dictionary to 
be of equal length, you can use <code>map</code> and <code>max</code>.</p></li>
</ol>
<p>Here is your code with the above modifications:</p>
<pre><code>&gt;&gt;&gt; d = {'A':[1, 2], 'B': [0], 'c': [4]}
&gt;&gt;&gt; 
&gt;&gt;&gt; max_len = max(map(len, d.values()))
&gt;&gt;&gt; {k: v + [0] * (max_len - len(v)) if len(v) &lt; max_len else v for k, v in d.items()}
{'A': [1, 2], 'B': [0, 0], 'c': [4, 0]}
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A generalized way:</p>
<pre><code>d = {'A':[1,2], 'B':[0], 'c':[4]}

m = max(len(v) for v in d.values())
for k, v in d.items():
    if len(v) &lt; m:
        d[k].extend([0 for i in range(m-len(v))])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You were very close, just use <a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow noreferrer"><code>update()</code></a>:</p>
<pre><code>d = {'A':[1,2], 'B':[0], 'c':[4]}

d.update({x: y+[0] for (x,y) in d.items() if len(y) &lt; 2})

d
# {'A': [1, 2], 'B': [0, 0], 'c': [4, 0]}
</code></pre>
<p>Like others have said, don't use reassign reserved names like <code>dict</code>, it's a one way street down to debugging hell.</p>
</div>
<span class="comment-copy">Worth pointing out that in 3.5+ you can also combine lists as follows: <code>{k: [*v, *[0 for i in range(max_len-len(v))]] if len(v) &lt; max_len else v for k, v in d.items()}</code></span>
<span class="comment-copy">@ZaxR Yep sure, but I'm pretty sure that'd be slower than just list multiplication and concatenation.</span>
<span class="comment-copy">Looking at <a href="https://stackoverflow.com/a/35631185/7619676">this analysis</a> of unpacking, it seems like it might actually be faster, but I haven't really dug very deep on it.</span>
<span class="comment-copy">To whomever downvoted this answer, can you please explain your rationale so I can improve it necessary? This code works and answers the question, so I'm not sure why it attracted the downvote.</span>
<span class="comment-copy">I actually like your answer too but would be interested to know the downvoters idea on this.</span>
