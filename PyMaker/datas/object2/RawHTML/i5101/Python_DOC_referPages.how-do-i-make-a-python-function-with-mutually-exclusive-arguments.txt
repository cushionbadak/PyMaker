<div class="post-text" itemprop="text">
<p>I have a Python class which needs to accept one of two mutually exclusive arguments. If the arguments are not exclusive, (ie: if both or neither are given), an error should be raised.</p>
<pre><code>class OrgLocation:
    __init__(self, location_num=None, location_path=None):
        """location_num &amp; location_path are mutually exclusive"""
</code></pre>
<p>In most scenarios, the best option would be to make two separate classes. However, I am working with <a href="https://stackoverflow.com/q/9812136/3357935">an external API</a> which <em>requires</em> these two attributes to be mutually exclusive.</p>
<p>Request:</p>
<pre><code>&lt;OrgLocation LocationPathName="ROOT/BU/DIV/SL/DEPT/JOB" LocationNum="1234"/&gt;
</code></pre>
<p>Response:</p>
<pre><code>&lt;Error Message="Use either LocationNum or LocationPathName but not both." ErrorCode="1186"&gt;
</code></pre>
<hr/>
<p>Similar questions seem to indicate that <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer"><code>argparse</code></a> can be used for mutually exclusive arguments in command-line interfaces, but I'm unsure how to apply this to a class constructor</p>
<p>How can I create a Python function with mutually exclusive arguments?</p>
</div>
<div class="post-text" itemprop="text">
<p>You might want to create a test in the <strong>init</strong> method but a better question might be... Why?</p>
<pre><code>if location_num is not None and location_path is not None:
    raise TheseParametersAreMutuallyExclusiveError()
</code></pre>
<p>Why would you make a class that has multiple purposes? Why not create separate classes?</p>
</div>
<div class="post-text" itemprop="text">
<p>Beyond <a href="https://stackoverflow.com/a/48794353/3357935">the answer by @Ivonet</a>, a common way in Python is to accept a single parameter, and duck it:</p>
<pre><code>class Location:
    __init__(self, location):
        """location_num &amp; location_path are mutually exclusive"""
        try:
            x = self.locationArray[location] #location is a num?
        except TypeError:
            x = self.locationDict[location] #location is a string?
</code></pre>
<p>possibly with another exception. If you want to use <code>argparse</code>, which may be overkill for only two parameters, but would scale nicely:</p>
<pre><code>import argparse

class Bla:
    parser = argparse.ArgumentParser(prog='Class Bla init')
    path_group = parser.add_mutually_exclusive_group(required=True)
    path_group.add_argument('--num',nargs=1,type=int)
    path_group.add_argument('--path',nargs=1,type=str)

    def __init__(self,**kwargs):
        args=self.parser.parse_args(sum(
            zip(map(
            lambda x: '--'+x,kwargs.keys()),
            map(str,kwargs.values())),()))

#Bla(x='abc')
#Bla(num='abc')
Bla(path='abc')
Bla(path='abc',num=3)
</code></pre>
<p>Results from top top bottom:</p>
<pre><code>usage: Class Bla init [-h] (--num NUM | --path PATH)
bla.py: error: one of the arguments --num --path is required

usage: Class Bla init [-h] (--num NUM | --path PATH)
bla.py: error: argument --num: invalid int value: 'abc'

&lt;__main__.Bla object at 0x7fd070652160&gt;

usage: Class Bla init [-h] (--num NUM | --path PATH)
bla.py: error: argument --num: not allowed with argument --path
</code></pre>
<p>This is also cool since <code>Bla(help='anything')</code> will actually print the usage (and exit). This is to answer the specific question regarding <code>argparse</code>, but to be clear, @Ivonet has the answer I would actually use for your exact example.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you want to do is easy:</p>
<pre><code>class Location:
    __init__(self, location_num=None, location_path=None):
    """location_num &amp; location_path are mutually exclusive"""

    if location_num is not None and location_path is not None:
        raise ValueError("should have location_num or location_path, but not both")
    elif location_num:
        #create location from int
    elif location_str:
        #create location from str
</code></pre>
<p>but it's not considered correct python. You should create alternate constructors as classmethods, instead:</p>
<pre><code>class Location:
    def __init__(self, parsed_location):
        #create location
    @classmethod
    def from_int(cls, location_int):
        return cls(parse_int(location_int))
    @classmethod
    def from_str(cls, location_str):
        return cls(parse_str(location_str))
</code></pre>
<p>See <a href="https://stackoverflow.com/questions/682504/what-is-a-clean-pythonic-way-to-have-multiple-constructors-in-python">What is a clean, pythonic way to have multiple constructors in Python?</a> for a more in-depth example.</p>
</div>
<span class="comment-copy">do you mean something like <code>if location_num is not None and location_path is not None: raise SomeError('error message')</code>?</span>
<span class="comment-copy">What behavior do you want to see? Do you want an error to be shown if both are given? Do you want to use one over the other?</span>
<span class="comment-copy">@Matt I would expect an error if they are not exclusive. Updated my question to clarify.</span>
<span class="comment-copy">@Steven Vascellaro be sure to add in logic that checks if they are both None to cover the "Neither are given" case from your question.</span>
<span class="comment-copy">this is not python... also, idiomatically, one would use <code>is</code> for <code>None</code> comparisons because <code>None</code> is guaranteed to be a singleton, but <code>==</code> <i>does</i> work.</span>
<span class="comment-copy">Just fixed it you are right... had just been answering Java stuff so my bad :-)</span>
<span class="comment-copy">I agree that separate classes would be ideal. Unfortunately, I'm working with an <a href="https://stackoverflow.com/q/9812136/3357935">external API</a> which has predefined class structures.</span>
<span class="comment-copy">I've edited my question to indicate why mutually exclusive arguments are required.</span>
