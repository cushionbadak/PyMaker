<div class="post-text" itemprop="text">
<p>I am running some shell scripts with the subprocess module in python. If the shell scripts is running to long, I like to kill the subprocess. I thought it will be enough if I am passing the <code>timeout=30</code> to my <code>run(..)</code> statement.</p>
<p>Here is the code:</p>
<pre><code>try:
    result=run(['utilities/shell_scripts/{0} {1} {2}'.format(
                        self.language_conf[key][1], self.proc_dir, config.main_file)],
                shell=True,
                check=True,
                stdout=PIPE,
                stderr=PIPE, 
                universal_newlines=True, 
                timeout=30,
                bufsize=100)
except TimeoutExpired as timeout:
</code></pre>
<p>I have tested this call with some shell scripts that runs 120s. I expected the subprocess to be killed after 30s, but in fact the process is finishing the 120s script and than raises the Timeout Exception. Now the Question how can I kill the subprocess by timeout?</p>
</div>
<div class="post-text" itemprop="text">
<p>The documentation explicitly states that the process should be killed:</p>
<p>from the <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer">docs for <code>subprocess.run</code></a>:</p>
<blockquote>
<p>"The timeout argument is passed to Popen.communicate(). If the timeout expires, the child process will be killed and waited for. The TimeoutExpired exception will be re-raised after the child process has terminated."</p>
</blockquote>
<p>But in your case you're using <code>shell=True</code>, and I've seen issues like that before, because the blocking process is a child of the shell process.</p>
<p>I don't think you need <code>shell=True</code> if you decompose your arguments properly and your scripts have the proper shebang. You could try this:</p>
<pre><code>result=run(
  [os.path.join('utilities/shell_scripts',self.language_conf[key][1]), self.proc_dir, config.main_file],  # don't compose argument line yourself
            shell=False,  # no shell wrapper
            check=True,
            stdout=PIPE,
            stderr=PIPE, 
            universal_newlines=True, 
            timeout=30,
            bufsize=100)
</code></pre>
<p>note that I can reproduce this issue very easily on Windows (using <code>Popen</code>, but it's the same thing):</p>
<pre><code>import subprocess,time

p=subprocess.Popen("notepad",shell=True)
time.sleep(1)
p.kill()
</code></pre>
<p>=&gt; notepad stays open, probably because it manages to detach from the parent shell process.</p>
<pre><code>import subprocess,time

p=subprocess.Popen("notepad",shell=False)
time.sleep(1)
p.kill()
</code></pre>
<p>=&gt; notepad closes after 1 second</p>
<p>Funnily enough, if you remove <code>time.sleep()</code>, <code>kill()</code> works even with <code>shell=True</code> probably because it successfully kills the shell which is launching <code>notepad</code>.</p>
<p>I'm not saying you have exactly the same issue, I'm just demonstrating that <code>shell=True</code> is evil for many reasons, and not being able to kill/timeout the process is one more reason.</p>
<p>However, <em>if</em> you need <code>shell=True</code> for a reason, you can use <code>psutil</code> to kill all the children in the end. In that case, it's better to use <code>Popen</code> so you get the process id directly:</p>
<pre><code>import subprocess,time,psutil

parent=subprocess.Popen("notepad",shell=True)
for _ in range(30): # 30 seconds
    if parent.poll() is not None:  # process just ended
      break
    time.sleep(1)
else:
   # the for loop ended without break: timeout
   parent = psutil.Process(parent.pid)
   for child in parent.children(recursive=True):  # or parent.children() for recursive=False
       child.kill()
   parent.kill()
</code></pre>
<p>(source: <a href="https://stackoverflow.com/questions/6549669/how-to-kill-process-and-child-processes-from-python">how to kill process and child processes from python?</a>)</p>
<p>that example kills the notepad instance as well.</p>
</div>
<span class="comment-copy">have you tried legacy methods with <code>Popen</code> ?</span>
<span class="comment-copy">What do you have in your <code>except</code> block?  From the doc:  "<i>The child process is not killed if the timeout expires, so in order to cleanup properly a well-behaved application should kill the child process and finish communication</i>"</span>
<span class="comment-copy">I have read the official document, it sends <code>SIGKILL</code> to kill the subprocess. Maybe your script cannot be killed by <code>SIGKILL</code>? Try it in raw terminal.</span>
<span class="comment-copy">@cdarke That is the behavior of <code>Popen</code> but not <code>run</code>. <code>run</code> will kill the child process.</span>
<span class="comment-copy">@Sraw:  sorry, you are right.  I would still like to know what is in the <code>except</code> block though.</span>
<span class="comment-copy">In <code>run</code>'s source code, it also use <code>kill()</code> to terminate child process. So in this case, I don't think this will work. But who knows...</span>
<span class="comment-copy">@Sraw: I think it's the bloody shell=True which causes the issue.</span>
<span class="comment-copy">I'm... still not sure about it as I have never seen this behavior. Since you said you have seen it, could you do us a favor by providing an example which will cause this situation?</span>
<span class="comment-copy">@Sraw actually I <i>can</i>. I'm using windows, but I'm sure it can be reproduced on Linux as well.</span>
<span class="comment-copy">Because of some reasons, I need to execute the commands in the shell, so <code>shell=true</code> is necessary.  When I am not using the statement I get an <code>FileNotFoundError</code>. Or is this error caused by an other false configuration?</span>
