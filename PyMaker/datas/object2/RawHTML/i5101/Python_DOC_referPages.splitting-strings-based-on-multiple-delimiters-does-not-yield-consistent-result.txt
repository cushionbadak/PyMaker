<div class="post-text" itemprop="text">
<p>I have a file type with many rows containing information as follows:</p>
<pre><code>  P087 = ( 4.000000000000000E+001,-6.250000000000000E-001 )
  P088 = ( 4.000000000000000E+001, 0.000000000000000E+000 )
</code></pre>
<p>I'm reading this file line by line using </p>
<pre><code>fo = open(FileName, 'r')
for line in fo:
    #do stuff to line
</code></pre>
<p>I'd like to see how to split each line to give lists as follows:</p>
<pre><code>[87, 40.0,-0.625]
[88, 40.0, 0.0]
</code></pre>
<p>I tried splitting using <code>python</code>'s regular <code>.split()</code> method but it doesn't split the lines consistently, yielding varying list lengths for each line. </p>
<p>I also investigated <code>re.split()</code> using stuff like <code>re.split([ = ( ]|,)</code> but that didn't work either. I'm also not a big regular expression user (though I know they are very powerful) which explains why I'm having a hard time finding the right one.</p>
<p>I guess I need to delimit the lines by  <code>' = ( '</code> and <code>','</code> though I'm really not sure how to do it such that the resulting lists are consistent. Any help would be much appreciated. </p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>This should do it:</p>
<pre><code>for line in fo:
    parts = re.match(r'\s*P(\d+)\s*=\s*[(]\s*([^ ,]*)[ ,]+([^ ,]*)[ )]*',line).groups()
    print([int(parts[0]), float(parts[1]), float(parts[2])])
</code></pre>
<p>The <code>re.match</code> is used to extract the important parts, then each is parsed to the appropriate type to be printed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval()</code></a> for parsing the tuple string:</p>
<pre><code>import ast
import re

with open(FileName, 'r') as f:
    out = [
        [int(re.findall('(?&lt;=P)\d+', k)[0]), *ast.literal_eval(v.strip())]
        for k, v in [line.split('=') for line in f]
    ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A solution without regex:</p>
<pre><code>def parse_line(line):
    first, second = line.split(',')
    ind = int(first.split()[0][2:])
    num1 = float(first.split()[-1])
    num2 = float(second.split()[0])
    return [ind, num1, num2]

line = 'P087 = ( 4.000000000000000E+001,-6.250000000000000E-001 )'
print(parse_line(line))

line = ' P088 = ( 4.000000000000000E+001, 0.000000000000000E+000 )'
print(parse_line(line))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following regular expression will extract all the lines from your file:</p>
<pre><code>c = re.compile(r'\s*P(\d+)\s*=\s*\(\s*([\d\.\+\-E]+)\s*,\s*([\d\.\+\-E]+)\s*\)')
lines = list(c.findall(x))
</code></pre>
<p>where <code>x</code> is the string that is your file content.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not always a good idea to use it, but <code>eval</code> can be ideal in these situations:</p>
<pre><code>from ast import literal_eval
result = []
for line in fo:
  item = []
  name, val = line.split('=')
  item.append(name.strip())
  item.extend(literal_eval(val.strip()))
  result.append(item)

print(result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Regex</strong>:  <a href="https://regex101.com/r/FTSU5b/1" rel="nofollow noreferrer"><code>[-0-9.]+[-E+0-9]*</code></a> or <code>[-\d.]+[-E+\d]*</code></p>
<p>Details:</p>
<ul>
<li><code>[]</code> Match a single character present in the list</li>
<li><code>+</code> Matches between <code>one</code> and <code>unlimited</code> times</li>
<li><code>*</code> Matches between <code>zero</code> and <code>unlimited</code> times</li>
</ul>
<p><strong>Python code</strong>:</p>
<pre><code>import re

def arr_num(text):
    array = []
    for n in re.finditer(r'[-0-9.]+[-E+0-9]*', text):
        array.append(n.group().isdigit() and int(n.group()) or float(n.group()))
    return array
</code></pre>
<p>Output:</p>
<pre><code>arr_num("SE104 = ( P1555, P1378, P1379, P1380, P1377, P1363, P1362, P1361, P1367, P1371, P1372, P1373, P1364, P1365, P1366 )")
&gt;&gt;&gt; [104, 1555, 1378, 1379, 1380, 1377, 1363, 1362, 1361, 1367, 1371, 1372, 1373, 1364, 1365, 1366]

arr_num("P087 = ( 4.000000000000000E+001,-6.250000000000000E-001 )")
&gt;&gt;&gt; [87, 40.0, -0.625]
</code></pre>
</div>
<span class="comment-copy">Hi, you mean that each line will be like the string : <code>'P087 = ( 4.000000000000000E+001,-6.250000000000000E-001 )'</code>?</span>
<span class="comment-copy">Yes, exactly what I mean</span>
<span class="comment-copy">Could you regex the whole string and use a few capture groups to get out the values you want? (see <a href="https://docs.python.org/2/howto/regex.html#grouping" rel="nofollow noreferrer">docs.python.org/2/howto/regex.html#grouping</a>)</span>
<span class="comment-copy">Try doing a findall using <code>[^ (),=P\r\n]+</code> on each line.</span>
<span class="comment-copy">works like a charm. Would you have another matching string for something like <code>SE104 = ( P1555, P1378, P1379, P1380, P1377, P1363, P1362, P1361, P1367, P1371, P1372, P1373, P1364, P1365, P1366 )</code> to convert to <code>[104, 1555, 1378, 1378 ....]</code> and so forth? all are integers in this case</span>
<span class="comment-copy">Also what does the <code>([^ ,]*)</code> part mean? Are you using the caret here as a negate symbol? i.e group anything that is not a comma?</span>
<span class="comment-copy"><code>([^ ,]*)</code> captures a sequence of characters that are not either a space or a comma.</span>
