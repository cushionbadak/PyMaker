<div class="post-text" itemprop="text">
<p>Given an arbitrary class <code>X</code> as input, is it possible to find out if instances of <code>X</code> will have a <code>__dict__</code>?</p>
<hr/>
<p>I tried <code>hasattr(X, '__dict__')</code>, but that doesn't work because it checks whether the class object has a <code>__dict__</code>:</p>
<pre><code>&gt;&gt;&gt; hasattr(int, '__dict__')
True
&gt;&gt;&gt; vars(5)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: vars() argument must have __dict__ attribute
</code></pre>
<p>The absence of <code>__slots__</code> also isn't a guarantee that there's a <code>__dict__</code>:</p>
<pre><code>&gt;&gt;&gt; hasattr(int, '__slots__')
False
&gt;&gt;&gt; vars(5)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: vars() argument must have __dict__ attribute
</code></pre>
<p>I also considered creating an instance of <code>X</code> with <code>object.__new__(X)</code> (to bypass <code>X.__new__</code> and <code>X.__init__</code>, which could potentially have undesired side effects), but this fails for built-in types:</p>
<pre><code>&gt;&gt;&gt; hasattr(object.__new__(int), '__dict__')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: object.__new__(int) is not safe, use int.__new__()
</code></pre>
<p>Is it possible to do this without calling any unknown/untrusted code (like the constructor of <code>X</code>)?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>dir()</code> will list <code>__dict__</code> in Python3, example:</p>
<pre><code>&gt;&gt;&gt; class MyInt(int):
...     pass
...
&gt;&gt;&gt; '__dict__' in dir(int)
False
&gt;&gt;&gt; '__dict__' in dir(MyInt)
True
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a> module to get all attributes of an instance which are not methods</p>
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; from operator import itemgetter

&gt;&gt;&gt; b = 5
&gt;&gt;&gt; inspect.getmembers(b, lambda a:not(inspect.isroutine(a)))
</code></pre>
<p>Will produce a long lists of all attributes of <code>b</code> and their small description.</p>
<p>I have performed some tests to see how it works, Here are my findings</p>
<pre><code>&gt;&gt;&gt; def get_attrs(x):
       return list(map(itemgetter(0), inspect.getmembers(x, lambda a:not(inspect.isroutine(a)))))

&gt;&gt;&gt; "__dict__" in get_attrs(type(b))
&gt;&gt;&gt; False

&gt;&gt;&gt; l = [1,2,3]
&gt;&gt;&gt; "__dict__" in get_attr(type(l))
&gt;&gt;&gt; False

&gt;&gt;&gt; class A:
       pass

&gt;&gt;&gt; a = A()
&gt;&gt;&gt; "__dict__" in get_attr(type(a))
&gt;&gt;&gt; True
</code></pre>
</div>
<span class="comment-copy">Just to be perfectly clear. You want to be able to predict if instance of some class <code>X</code> will contain <code>__dict__</code>?</span>
<span class="comment-copy">In theory, wouldn't it be possible to create a C-level extension type that does not have <code>__dict__</code> as a pre-named attribute, but which always mutates the instance inside of <code>__init__</code> to assign something to the attribute name <code>__dict__</code> during the execution of <code>__init__</code>? If so, this would imply it's not possible to know ahead of time without inspecting source code, because the instance strictly receives <code>__dict__</code> as a side-effect of <code>__init__</code>. It could even be conditional, e.g. if <code>datetime.datetime.now()</code> is greater than 3 pm, add <code>__dict__</code>.</span>
<span class="comment-copy">It would also be possible for the class's <code>__new__()</code> to choose between two subclasses based on the supplied parameters, one of which uses <code>__slots__</code> and the other one having a <code>__dict__</code>, thus making the answer indeterminate.</span>
<span class="comment-copy">@Laszlowaty That's correct, yes.</span>
<span class="comment-copy">@Aran-Fey Well then it could dynamically modify the class object to have <code>__dict__</code> during instance creation. I know these are corner cases, much like <a href="https://stackoverflow.com/questions/46575174/if-an-object-doesnt-have-dict-does-its-class-must-have-a-slots-att">here</a>. But the point is that they illustrate you cannot have a <i>general</i> way to determine the answer. Best you could do is make assumptions about certain built-in types vs. user-defined types.</span>
<span class="comment-copy">This is good enough for me, but I'm still going to be nitpicky (because I explicitly asked for a solution that doesn't execute unknown code): <code>dir(X)</code> will call <code>X</code>'s metaclass's <code>__dir__</code> method if it exists. That said, I don't mind executing a <code>__dir__</code> method - I wanted to avoid calling <code>X</code>'s constructor because constructors sometimes have side effects, but I don't think anyone would be crazy enough to have side effects in a <code>__dir__</code> method.</span>
<span class="comment-copy">Isn't it calling constructor of <code>X</code>? :)</span>
<span class="comment-copy">@Laszlowaty Yes, but only for demonstration purposes. Calling <code>'__dict__' in dir(X)</code> gives me my expected output, with no constructors being called. But it's true that this answer could be made a lot clearer without all the <code>dir</code> calls on instances - after all, I don't even have an <code>X</code> instance to call <code>dir</code> on, so what's the point of showing the output of <code>dir(instance)</code>? This answer would benefit a lot from a little bit of polishing.</span>
<span class="comment-copy">Well I'm preparing my answer to your question, but I need some more research to do. Short answer: it's not possible. The only reason you see <code>__dict__</code> here is because of the inheritance. If you define your class in python2 as <code>class A: ....</code> you will receive <code>['__doc__', '__init__', '__module__']</code> as output of the <code>dir(A)</code>. In python3, of course, you will receive <code>__dict__</code> in the output, but still you have no idea wheter it is the built-in <code>dict</code> method, or something else.</span>
<span class="comment-copy">Now that's better!</span>
<span class="comment-copy">This seems to work, but it's not nearly as elegant and fast and readable as the <code>dir</code> solution. Also, since the question states that you get a class as input, I don't see why you're calling <code>get_attrs</code> on <i>instances</i> like <code>5</code> or <code>[1,2,3]</code> or <code>a</code>. You should be calling it on <code>int</code> and <code>list</code> and <code>A</code> instead.</span>
<span class="comment-copy">@Aran-Fey yes I do agree with you. I was considering input will be an instance of class. In that case if a class overrides <code>__dir__</code> then you might not get all attributes of class, However <code>vars</code> will still work fine as far as <code>__dict__</code> is defined. But in case of input is class it doesn't matter.</span>
