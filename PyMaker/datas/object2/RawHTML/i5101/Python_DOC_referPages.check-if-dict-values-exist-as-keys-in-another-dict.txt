<div class="post-text" itemprop="text">
<p>I have two dictionaries:</p>
<pre><code>concave = {6: [2, 3, 4, 5], 2: [6], 3: [6], 4: [6], 5: [6]}
convex = {1: [2, 3, 4, 5], 2: [1, 3, 5], 3: [1, 2, 4], 4: [1, 3, 5], 5: [1, 2, 4], 6: [7, 8, 9, 10], 7: [6, 8, 10, 11], 8: [6, 7, 9, 11], 9: [6, 8, 10, 11], 10: [6, 7, 9, 11], 11: [7, 8, 9, 10]}
</code></pre>
<p>And I have returned the keys which have max length values in the convex dict:</p>
<pre><code>max_lens = [1, 6, 7, 8, 9, 10, 11]
</code></pre>
<p>For each number in <code>max_lens</code>, I want to check that it does not exist as a key in <code>concave</code> <strong>and</strong> its <em>values</em> in <code>convex</code> exist as keys in <code>concave</code>. </p>
<p>So in this example, '1' would satisfy this condition as it is not included in <code>concave</code> as a key, but its values in <code>convex</code> are (i.e. 2, 3 4 and 5).</p>
<p>I have tried to figure out how to go about this using for loops/if statements:</p>
<pre><code>for i in enumerate(max_lens):
    if i not in concave:
        for k,v in convex.items():
            for j in v:
</code></pre>
<p>That is about as far as I got before getting totally confused. There must be an easier way to do this other than using multiple for loops and if statements?</p>
<p>I'm a bit of a python noob so sorry if this comes across as confusing!</p>
</div>
<div class="post-text" itemprop="text">
<p>I <em>think</em> I understood (for the record I prefer the explicit <code>concave.keys()</code>)</p>
<pre><code>result_dict = {}
for convex_key in max_lens:
    result_dict[convex_key] = convex_key not in concave.keys() \
                              and all(convex_val in concave.keys() 
                                      for convex_val in convex[convex_key])
</code></pre>
<p>Edit (see comments)</p>
<pre><code>for convex_key in max_lens:
    if convex_key not in concave.keys() and \
           all(convex_val in concave.keys() for convex_val in convex[convex_key]):
        top_face = convex_key
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Spelling this problem out into steps always helps:</p>
<ul>
<li>Loop over each of the lengths <code>l</code> in <code>max_lens</code></li>
<li>Check if <code>l</code> doesn't exist in <code>concave</code> but exists in <code>convex</code>. A conjunction of these two conditions is needed here. If either fails, don't continue. </li>
<li>If the above two conditions are accepted, check if all the values from <code>convex[l]</code> exist in <code>concave</code>. </li>
<li>If the code reaches here with no issues, all the conditions are met. </li>
</ul>
<p><strong>Demo:</strong></p>
<pre><code>concave = {6: [2, 3, 4, 5], 2: [6], 3: [6], 4: [6], 5: [6]}
convex = {1: [2, 3, 4, 5], 2: [1, 3, 5], 3: [1, 2, 4], 4: [1, 3, 5], 5: [1, 2, 4], 6: [7, 8, 9, 10], 7: [6, 8, 10, 11], 8: [6, 7, 9, 11], 9: [6, 8, 10, 11], 10: [6, 7, 9, 11], 11: [7, 8, 9, 10]}

max_lens = [1, 6, 7, 8, 9, 10, 11]

for l in max_lens:
    if l not in concave and l in convex and all(v in concave for v in convex[l]):
        print(l)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it with comprehension:</p>
<pre><code>[i for i in max_lens if i not in concave and convex[i] in concave.values()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a simple forloop.</p>
<pre><code>concave = {6: [2, 3, 4, 5], 2: [6], 3: [6], 4: [6], 5: [6]}
convex = {1: [2, 3, 4, 5], 2: [1, 3, 5], 3: [1, 2, 4], 4: [1, 3, 5], 5: [1, 2, 4], 6: [7, 8, 9, 10], 7: [6, 8, 10, 11], 8: [6, 7, 9, 11], 9: [6, 8, 10, 11], 10: [6, 7, 9, 11], 11: [7, 8, 9, 10]}
max_lens = [1, 6, 7, 8, 9, 10, 11]

for i in max_lens:
    if (i not in concave):   #Check if not in key.
        if convex[i] in concave.values():   #Check Value.
                print i
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't understand a problem easily, it's often a good way, to divide it into several smaller problems:</p>
<ol>
<li>write a function that checks if a value is not key of a dict:</li>
</ol>
<p><code>def is_no_key_in(v, _dict):
    return key not in _dict
</code></p>
<ol start="2">
<li>Since that is too simple return a list of keys that are not in dict:</li>
</ol>
<p><code>def no_key_values(_list, _dict):
    return [ v for v in _list if is_no_key_in(v, _dict) ]
</code></p>
<ol start="3">
<li>Now that you only have values that fit your first condition, you can concentrate on your second condition. Since you want that every value of a list is in a list of keys, you can start making a union-like function:</li>
</ol>
<p><code>def union(a_lst, b_lst):
    return [ a for a in a_lst if a in b_lst]
</code></p>
<ol start="4">
<li>To make it more into something serving your needs, you could change it to a function that checks for any diffs:</li>
</ol>
<p><code>def is_subset(a_lst, b_lst):
    return len([a for a in a_lst if a not in b_lst]) == 0
</code></p>
<ol start="5">
<li>Now you piece the functions together:</li>
</ol>
<p><code>def satisfies_conditions(max_lens):
    for lens in no_key_values(max_lens, concave):
        if is_subset(convex[lens], concave.keys())
            yield lens
</code>
<code>result = [ lens for lens in satisfies_conditions(max_lens) ]
</code></p>
<p><code>result</code> now contains all lenses that satisfy your conditions and if you want to change your conditions, you can easily do so. If your code works, you can go on and refactor it. For example you might not need <code>is_no_key_in</code> as it is a very simple function. Then go on and inline it into <code>no_key_values</code>:</p>
<p><code>def no_key_values(_list, _dict):
    return [ v for v in _list if v not in _dict ]
</code>
If you write some tests before refactoring (or even writing the code) you can ensure, that your refactoring won't introduce bugs. Then simplify the code step by step. Maybe you will end up with a solution as simple as proposed in other answers here.</p>
<p>(I hope this will also help you with future problems like that :-))</p>
</div>
<span class="comment-copy">Your example is ambiguous. Should it return <code>1</code> also, when the convex values for <code>1</code> are <code>[2, 3, 4]</code> or <code>[2, 6]</code>? Reading your question, I assume yes, but some people interpret it differently.</span>
<span class="comment-copy">Yeah that is what I wanted it to do! Instead of returning a dict of booleans, how could I just store the true result '1' in a variable such as <code>top_face</code>?</span>
<span class="comment-copy">I'll edit my comment, but what if there are multiple <code>True</code> results?</span>
<span class="comment-copy">@RoadRunner Not in python 3 (which i think it's fair to assume as this is 2018). <code>keys</code> is a view onto the keys of the dictionary and is <code>O(1)</code>. <a href="https://docs.python.org/3/library/stdtypes.html#dict-views" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#dict-views</a></span>
<span class="comment-copy">That isn't what OP wants. They want to see if all the values of <code>i</code> are keys in <code>concave</code>.</span>
<span class="comment-copy">@FHTMitchell OP statement? "For each number in max_lens, I want to check that it does not exist as a key in concave "</span>
<span class="comment-copy">"<b>and</b> its values in convex exist as keys in concave". <code>convex[i] in convex.values()</code> doesn't do that.</span>
<span class="comment-copy">:( Very hard to understand....</span>
