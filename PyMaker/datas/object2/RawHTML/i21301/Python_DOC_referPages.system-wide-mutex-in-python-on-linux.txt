<div class="post-text" itemprop="text">
<p>Is there any easy way to have a system-wide mutex in Python on Linux? By "system-wide", I mean the mutex will be used by a group of Python <em>processes</em>; this is in contrast to a traditional mutex, which is used by a group of <em>threads</em> within the same process.</p>
<p>EDIT: I'm not sure Python's <a href="https://docs.python.org/2/library/multiprocessing.html" rel="noreferrer"><code>multiprocessing</code></a> package is what I need. For example, I can execute the following in two different interpreters:</p>
<pre><code>from multiprocessing import Lock
L = Lock()
L.acquire()
</code></pre>
<p>When I execute these commands simultaneously in two separate interpreters, I want one of them to hang. Instead, neither hangs; it appears they aren't acquiring the same mutex.</p>
</div>
<div class="post-text" itemprop="text">
<p>The "traditional" Unix answer is to use file locks. You can use <code>lockf(3)</code> to lock sections of a file so that other processes can't edit it; a very common abuse is to use this as a mutex between processes. The python equivalent is <a href="https://docs.python.org/3/library/fcntl.html#fcntl.lockf">fcntl.lockf</a>. </p>
<p>Traditionally you write the PID of the locking process into the lock file, so that deadlocks due to processes dying while holding the lock are identifiable and fixable.</p>
<p>This gets you what you want, since your lock is in a global namespace (the filesystem) and accessible to all processes. This approach also has the perk that non-Python programs can participate in your locking. The downside is that you need a place for this lock file to live; also, some filesystems don't actually lock correctly, so there's a risk that it will silently fail to achieve exclusion. You win some, you lose some.</p>
</div>
<div class="post-text" itemprop="text">
<p>The POSIX standard specifies inter-process semaphores which can be used for this purpose.  <a href="http://linux.die.net/man/7/sem_overview" rel="noreferrer">http://linux.die.net/man/7/sem_overview</a></p>
<p>The <code>multiprocessing</code> module in Python is built on this API and others.  In particular, <code>multiprocessing.Lock</code> provides a cross-process "mutex".  <a href="http://docs.python.org/library/multiprocessing.html#synchronization-between-processes" rel="noreferrer">http://docs.python.org/library/multiprocessing.html#synchronization-between-processes</a></p>
<p><strong>EDIT</strong> to respond to edited question:</p>
<p>In your proof of concept each process is constructing a <code>Lock()</code>.  So you have two separate locks.  That is why neither process waits.  You will need to share the same lock between processes.  The section I linked to in the <code>multiprocessing</code> documentation explains how to do that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try <a href="https://github.com/symonsoft/ilock" rel="noreferrer">ilock</a> library:</p>
<pre><code>from ilock import ILock

with ILock('Unique lock name'):
    # The code should be run as a system-wide single instance
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For a system-wide mutex that enables the synchronization of absolutely separate processes (i.e., to INCLUDE Linux processes that do NOT belong to the same processes tree), simply use <a href="https://docs.python.org/3/library/fcntl.html" rel="nofollow">fcntl.flock</a>. I suppose that using a memory file under Linux' /run/shm folder may make it perform faster.</p>
<p>See more <a href="https://mail.python.org/pipermail/python-list/2000-January/050947.html" rel="nofollow">here</a>.</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/5756813/simple-but-fast-ipc-method-for-a-python-and-c-application" title="simple but fast ipc method for a python and c application">stackoverflow.com/questions/5756813/â€¦</a></span>
<span class="comment-copy">Have you found a good solution?</span>
<span class="comment-copy">Logical place for the lock file is <code>/var/lock</code> - however if there are going to be a vast number of locking operations, I suggest <code>/tmp</code> as not all systems have <code>/var/lock</code> in <code>tmpfs</code> ramdisk.</span>
<span class="comment-copy">Not all systems have /tmp in tmpfs ramdisk either; my install of OS X does not seem to. Good points all the same, though.</span>
<span class="comment-copy">he was asking about <i>linux</i> and most (if not all) of the major modern linux distros have /tmp in /tmpfs - none have /var/lock by default IIRC.</span>
<span class="comment-copy">My Debian Squeeze install doesn't have a tmpfs /tmp either. It's actually got tmpfs on /dev/shm, which feature I've also seen on Fedora. It probably doesn't much matter in the end, as long as the location is documented.</span>
<span class="comment-copy"><a href="http://blog.vmfarms.com/2011/03/cross-process-locking-and.html" rel="nofollow noreferrer">blog.vmfarms.com/2011/03/cross-process-locking-and.html</a> has a sample implementation (using flock); works nicely on Solaris</span>
<span class="comment-copy">Thanks, but "multiprocessing" doesn't appear to be what I need; see the edited question.</span>
<span class="comment-copy">Editing my answer.</span>
<span class="comment-copy">The section you linked to appears to show how a master process can spawn 10 processes, passing a Lock object to each one it creates. My use case is different, as there is no master process spawning subprocesses. In my case, each process is invoked completely independently, but they must still coordinate.</span>
<span class="comment-copy">Shared memory with a configured numeric address may be the only option if there is no relationship between peers but they still need a shared mutex.  The mutex object can then live in the shared memory segment.  There may be no Python API for this; if not you may have to go native.  Also confirm that PThreads supports this use case fully; I worry it may not.  Also, to me this is a design smell; it seems like you should be either using threads and mutexes, or a separate process like redis or riak to arbitrate.</span>
<span class="comment-copy">... or directly via <code>portalocker</code>: <code>with portalocker.TemporaryFileLock('filename.lock'): ...</code></span>
<span class="comment-copy">@KT. TemporaryFileLock has race issues. Also, ILock support re-entrance.</span>
<span class="comment-copy">Are you sure about the race issues? It seems to me both <code>ILock</code> and <code>portalocker.Lock</code> use exactly the same strategy of first doing <code>open</code> and then simply calling <code>portalocker.lock</code> on the handle to gain exclusivity. Where would the latter implementation miss anything to cause a race issue?</span>
<span class="comment-copy">There can be an unexpected exception raised in case when file is deleted</span>
<span class="comment-copy">I see, you are referring to the "WindowsError" catching piece in your code. It would probably make sense to add this try-catch to portalocker as well then. If you then also add a TemporaryFileRLock (which is a matter of 10 lines), the need for maintaining a separate library would probably go away.</span>
