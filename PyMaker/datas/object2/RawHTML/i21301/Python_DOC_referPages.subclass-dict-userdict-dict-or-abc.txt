<div class="post-text" itemprop="text">
<p>What's the difference between <code>UserDict</code>, <code>dict</code> and <code>ABC</code> and which one is recommended? The docs seem to deprecate <code>UserDict</code>?</p>
<p>Also it seems UserDict's <code>update()</code> would use my <code>setitem</code> method whereas <code>dict</code> doesn't? Which methods are really essential to override given I want custom <code>setitem</code> and <code>getitem</code> function?</p>
<p>With <code>ABC</code>s I'd have to implement absolutely all methods since it provides no default implementation?</p>
<p>I want to make a <code>dict</code> that does two things:</p>
<ul>
<li><code>intern()</code> all keys and values</li>
<li>store some of the values in an SQLite database</li>
</ul>
<p>So which of <code>UserDict</code>, <code>dict</code> and <code>ABC</code> would best allow me to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want a custom collection that actually holds the data, subclass <em>dict</em>.  This is especially useful if you want to <em>extend</em> the interface (e.g., add methods).</p>
<p>None of the built-in methods will call your custom <code>__getitem__</code> / <code>__setitem__</code>, though.  If you need total control over these, create a custom class that implements the <code>collections.MutableMapping</code> abstract base class instead.</p>
<p>The ABC does not provide a means to store the actual data, only an interface with default implementations for some methods.  These default implementations will, however, call your custom <code>__getitem__</code> and <code>__setitem__</code>.  You will have to use an internal <code>dict</code> to hold the data, and implement all abstract methods: <code>__len__</code>, <code>__iter__</code>, <code>__getitem__</code>, <code>__setitem__</code>, and <code>__delitem__</code>.</p>
<p>The class <code>UserDict</code> from the <code>collections</code> module (in Python 2, the module is called <code>UserDict</code> as well) is a wrapper around an internal <code>dict</code>, implementing the <code>MutableMapping</code> ABC.  If you want to customize the behavior of a <code>dict</code>, this implementation could be a starting point.</p>
<p>In summary:</p>
<ul>
<li><strong>MutableMapping</strong> defines the interface.  Subclass this to create something that acts like a <code>dict</code>.  It's totally up to you if and how you store the data.</li>
<li><strong>UserDict</strong> is an implementation of <code>MutableMapping</code> using an internal "real" <code>dict</code> as storage.  If you want a dict-like storage collection but override some methods exposed by <code>dict</code>, this might be a good starting point for you.  But make sure to read the code to know how the basic methods are implemented, so that you are consistent when overriding a method.</li>
<li><strong>dict</strong> is "the real thing". Subclass this if you want to <em>extend</em> the interface.  Overriding methods to do custom things might be dangerous, as there are usually multiple ways of accessing the data, and you could end up with an inconsistent API.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Don't use the <code>UserDict</code> class -- you don't need it. As the docs say, you can just subclass <code>dict</code> directly.</p>
<p>However, you still want the <code>UserDict</code> module, for <a href="http://docs.python.org/library/userdict.html#UserDict.DictMixin" rel="nofollow"><code>DictMixin</code></a>:</p>
<p><strong>Note:</strong> <code>DictMixin</code>, while not officially deprecated, has been removed in Python 3, and it's recommended in the docs that you use <code>collections.MutableMapping</code>. This, however, has a drawback -- you need to implement more of the dictionary interface - <code>__delitem__</code>, <code>__getitem__</code>, <code>__iter__</code>, <code>__len__</code>, and <code>__setitem__</code>. With <code>DictMixin</code>, you can just implement the ones you want to change, and the rest use a default implementation.</p>
<pre><code>from UserDict import DictMixin

class MyDict(DictMixin, dict):
    def __setitem__(self, key, value):
        print key, value # just an example
        # use intern(key) or whatever here
        dict.__setitem__(self, key, value) # or
        # super(MyDict, self).__setitem__(key, value)

m = MyDict()

m['a'] = 'b'
# a b
m.update({'a': 'c'})
# a c
</code></pre>
<p>It will automatically make <code>update</code> use your <code>__setitem__</code> as you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on Secrets <a href="https://www.packtpub.com/application-development/secret-recipes-python-ninja" rel="nofollow noreferrer">Recipes of the Python Ninja</a> book</p>
<p>The only special thing the UserDict has beyond the normal dictionary operations is a single attribute:</p>
<blockquote>
<p>data: A real dictionary to hold the contents of the UserDict class</p>
</blockquote>
<p>To get to the items in the dictionary, you have to either iterate over them or call items(). While the UserDict instance supports the same methods, the view returned by items() is noticeably different:</p>
<pre><code>  &gt;&gt;&gt; from collections import UserDict
  &gt;&gt;&gt; a = UserDict(a=1)
  &gt;&gt;&gt; d = dict(d=3)  # regular dictionary for comparison

  &gt;&gt;&gt; for k in d:
  ...     print(k, d[k])
  ... 
  d 3
  &gt;&gt;&gt; d.items()
  dict_items([('d', 3)])
  &gt;&gt;&gt; for k in a:
  ...     print(k, a[k])
  ... 
  a 1
  &gt;&gt;&gt; a.items()
  ItemsView({'a': 1})
</code></pre>
<p>Notice that the dictionary object returns a tuple of key/values. The UserDict returns an actual dictionary object. Depending on what you are doing, this difference can be important, as is the ability to use the data attribute to access the dictionary.</p>
</div>
<span class="comment-copy">But at least some ABCs are also useful to simplify implementations that aren't based on built-in types, as this snippet from the same section shows: <code>Several of the ABCs are also useful as mixins that make it easier to develop classes supporting container APIs. For example, to write a class supporting the full Set API, it only necessary to supply the three underlying abstract methods: __contains__(), __iter__(), and __len__(). The ABC supplies the remaining methods such as __and__() and isdisjoint()</code></span>
<span class="comment-copy">If you want to test if something is a <code>dict</code>, use <code>isistance(x, dict)</code>.  If you want to test it it's some kind of mapping, use <code>isinstance(x, Mapping)</code>.  This is what the ABCs are there for.  They are only useful if every kind of mapping uses <code>Mapping.register()</code> or just subclasses it directly.  And yes, this <b>is</b> the primary purpose of an ABC.</span>
<span class="comment-copy">Thanks. From the previous post I learned about Mixins and now I realized that ABC provide default implementations. It's a minor issue to provide a data variable myself, so I suppose I will get used to ABC.</span>
<span class="comment-copy">@agf: Even <code>DictMixin</code> requires you to implement 5 base methods.</span>
<span class="comment-copy">@agf: The <code>userdict</code> module is gone in Python 3.0, this is why I said it's deprecated. See <a href="http://www.python.org/dev/peps/pep-3108/" rel="nofollow noreferrer">python.org/dev/peps/pep-3108</a> (Quote: "Not as useful since types can be a superclass. Useful bits moved to the 'collections' module.")</span>
<span class="comment-copy">Sorry if I missed something, but UserDict is still here in Python 3: <a href="https://docs.python.org/3/library/collections.html#collections.UserDict" rel="nofollow noreferrer">docs.python.org/3/library/collections.html#collections.UserDict</a> And it is useful if you need to have a working <code>update</code> method.</span>
<span class="comment-copy">@AdrienClerc The <code>UserDict</code> <i>module</i> is gone, the <i>class</i> was moved to <code>collections</code> and made implement the <code>MutableMapping</code> ABC.  Please note that the <code>update</code> method is provided by <code>MutableMapping</code>, not <code>UserDict</code>, so that alone is no reason to use <code>UserDict</code>.  You should use <code>UserDict</code> if you want a wrapper for an internal <code>dict</code>.  If you just want to simulate a <code>dict</code> and store your data elsewhere, use <code>MutableMapping</code>.</span>
<span class="comment-copy">&gt; Starting with Python version 2.6, it is recommended to use collections.MutableMapping instead of DictMixin.</span>
<span class="comment-copy">@agf: You are wrong.  The <code>UserDict</code> module is deprecated and shouldn't be used.  How is using <code>UserDict.DictMixin</code> as a mix-in easier than using <code>collections.MutableMapping</code> as a mix-in?  You will only need to overwrite <code>__setitem__()</code> in both cases.</span>
<span class="comment-copy">@agf: The whole module is gone in Python 3.x.</span>
<span class="comment-copy">I don't think so.  If you want all the functionality of a <code>MutableMapping</code>, you will have to implement all abstract methods.  But there are only 5 of those, so it's not that bad.  But again, since <code>DictMixin</code> is gone in Py3k, I would strongly advice against using it.  With Python 3.3 coming next year, the days of 2.x are numbered.</span>
<span class="comment-copy">I did. Try that with the example in my answer. <code>update</code> won't call <code>__setitem__</code>, so you won't see <code>a c</code> printed. In fact, adding <code>MutableMapping</code> after <code>dict</code> in the method resolution order has <i>no effect at all</i>, as <code>dict</code> implements all of the methods defined as abstract by <code>MutableMapping</code>. There is no way to get the desired behavior with <code>MutableMapping</code> without defining all of the core dictionary interface.</span>
