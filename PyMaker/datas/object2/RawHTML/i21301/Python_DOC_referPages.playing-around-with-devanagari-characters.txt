<div class="post-text" itemprop="text">
<p>I have something like  </p>
<pre><code>a = "बिक्रम मेरो नाम हो"
</code></pre>
<p>I want to achieve something like</p>
<pre><code>a[0] = बि a[1] = क्र a[3] = म
</code></pre>
<p>but as म takes 4 bytes while बि takes 8 bytes I am not able to get to that straight.
So what could be done to achieve that? In Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>The algorithm for splitting text into grapheme clusters is given in <a href="http://www.unicode.org/reports/tr29/tr29-17.html#Grapheme_Cluster_Boundaries">Unicode Annex 29</a>, section 3.1. I'm not going to implement the full algorithm for you here, but I'll show you roughly how to handle the case of Devanagari, and then you can read the Annex for yourself and see what else you need to implement.</p>
<p>The <a href="http://docs.python.org/3/library/unicodedata.html"><code>unicodedata</code> module</a> contains the information you need to detect the grapheme clusters.</p>
<pre><code>&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; a = "बिक्रम मेरो नाम हो"
&gt;&gt;&gt; [unicodedata.name(c) for c in a]
['DEVANAGARI LETTER BA', 'DEVANAGARI VOWEL SIGN I', 'DEVANAGARI LETTER KA', 
 'DEVANAGARI SIGN VIRAMA', 'DEVANAGARI LETTER RA', 'DEVANAGARI LETTER MA',
 'SPACE', 'DEVANAGARI LETTER MA', 'DEVANAGARI VOWEL SIGN E',
 'DEVANAGARI LETTER RA', 'DEVANAGARI VOWEL SIGN O', 'SPACE',
 'DEVANAGARI LETTER NA', 'DEVANAGARI VOWEL SIGN AA', 'DEVANAGARI LETTER MA',
 'SPACE', 'DEVANAGARI LETTER HA', 'DEVANAGARI VOWEL SIGN O']
</code></pre>
<p>In Devanagari, each grapheme cluster consists of an initial letter, optional pairs of virama (vowel killer) and letter, and an optional vowel sign. In regular expression notation that would be <code>LETTER (VIRAMA LETTER)* VOWEL?</code>. You can tell which is which by looking up the <a href="http://www.unicode.org/versions/Unicode6.0.0/ch04.pdf">Unicode category</a> for each code point:</p>
<pre><code>&gt;&gt;&gt; [unicodedata.category(c) for c in a]
['Lo', 'Mc', 'Lo', 'Mn', 'Lo', 'Lo', 'Zs', 'Lo', 'Mn', 'Lo', 'Mc', 'Zs',
 'Lo', 'Mc', 'Lo', 'Zs', 'Lo', 'Mc']
</code></pre>
<p>Letters are category <code>Lo</code> (Letter, Other), vowel signs are category <code>Mc</code> (Mark, Spacing Combining), virama is category <code>Mn</code> (Mark, Nonspacing) and spaces are category <code>Zs</code> (Separator, Space).</p>
<p>So here's a rough approach to split out the grapheme clusters:</p>
<pre><code>def splitclusters(s):
    """Generate the grapheme clusters for the string s. (Not the full
    Unicode text segmentation algorithm, but probably good enough for
    Devanagari.)

    """
    virama = u'\N{DEVANAGARI SIGN VIRAMA}'
    cluster = u''
    last = None
    for c in s:
        cat = unicodedata.category(c)[0]
        if cat == 'M' or cat == 'L' and last == virama:
            cluster += c
        else:
            if cluster:
                yield cluster
            cluster = c
        last = c
    if cluster:
        yield cluster

&gt;&gt;&gt; list(splitclusters(a))
['बि', 'क्र', 'म', ' ', 'मे', 'रो', ' ', 'ना', 'म', ' ', 'हो']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So, you want to achieve something like this</p>
<pre><code>a[0] = बि a[1] = क्र a[3] = म
</code></pre>
<p>My advice is to ditch the idea that string indexing corresponds to the characters you see on the screen.  Devanagari, as well as several other scripts, do not play well with programmers who grew up with Latin characters.  I suggest reading the Unicode standard chapter 9 (<a href="http://www.unicode.org/versions/Unicode6.0.0/">available here</a>).</p>
<p>It looks like what you are trying to do is break a string into grapheme clusters.  String indexing by itself will not let you do this.  Hangul is another script which plays poorly with string indexing, although with combining characters, even something as familiar as Spanish will cause problems.</p>
<p>You will need an external library such as ICU to achieve this (unless you have lots of free time).  ICU has Python bindings.</p>
<pre><code>&gt;&gt;&gt; a = u"बिक्रम मेरो नाम हो"
&gt;&gt;&gt; import icu
    # Note: This next line took a lot of guesswork.  The C, C++, and Java
    # interfaces have better documentation.
&gt;&gt;&gt; b = icu.BreakIterator.createCharacterInstance(icu.Locale())
&gt;&gt;&gt; b.setText(a)
&gt;&gt;&gt; i = 0
&gt;&gt;&gt; for j in b:
...     s = a[i:j]
...     print '|', s, len(s)
...     i = j
... 
| बि 2
| क् 2
| र 1
| म 1
|   1
| मे 2
| रो 2
|   1
| ना 2
| म 1
|   1
| हो 2
</code></pre>
<p>Note how some of these "characters" (grapheme clusters) have length 2, and some have length 1.  This is why string indexing is problematic: if I want to get grapheme cluster #69450 from a text file, then I have to linearly scan through the entire file and count.  So your options are:</p>
<ul>
<li>Build an index (kind of crazy...)</li>
<li>Just realize that you can't break on every character boundary.  The break iterator object is capable of going both forwards AND backwards, so if you need to extract the first 140 characters of a string, then you look at index 140 and iterate <em>backwards</em> to the previous grapheme cluster break, that way you don't end up with funny text.  (Better yet, you can use a <em>word break</em> iterator for the appropriate locale.)  The benefit of using this level of abstraction (character iterators and the like) is that it no longer matters which encoding you use: you can use UTF-8, UTF-16, UTF-32 and it all just works.  Well, mostly works.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve this with a <a href="http://www.regular-expressions.info/unicode.html" rel="nofollow">simple regex</a> for any engine that supports <code>\X</code></p>
<p><a href="https://regex101.com/r/eD0eZ9/1" rel="nofollow">Demo</a></p>
<p>Unfortunately, Python's re <a href="http://bugs.python.org/issue12733" rel="nofollow">does not support</a> the \X grapheme match.</p>
<p>Fortunately, the proposed replacement, <a href="https://pypi.python.org/pypi/regex" rel="nofollow">regex</a>, does support <code>\X</code>:</p>
<pre><code>&gt;&gt;&gt; a = "बिक्रम मेरो नाम हो"
&gt;&gt;&gt; regex.findall(r'\X', a)
['बि', 'क्', 'र', 'म', ' ', 'मे', 'रो', ' ', 'ना', 'म', ' ', 'हो']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Indic and non Latin scripts like Hangul do not generally follow the idea of matching string indices to code points. It's generally a pain working with Indic scripts. Most characters are two bytes with some rare ones extending into three. With Dravidian, it's no defined order. See the <a href="http://www.unicode.org/versions/Unicode6.0.0/ch09.pdf" rel="nofollow noreferrer">Unicode specification</a> for more details. </p>
<p>That said,check <a href="https://stackoverflow.com/questions/2287962/c-how-to-read-unicode-characters-hindi-script-for-e-g-using-c-or-is-the">here</a> for some ideas about unicode and python with C++. </p>
<p>Finally,as said by <a href="https://stackoverflow.com/questions/6805311/playing-aroud-with-devanagari-characters/6805416#6805416">Dietrich</a>, you might want to check out <a href="http://site.icu-project.org/" rel="nofollow noreferrer">ICU</a> too. It has bindings available for C/C++ and java via icu4c and icu4j respectively. There's some learning curve involved, so I suggest you set aside <strike>some</strike> loads of time for it. :)</p>
</div>
<div class="post-text" itemprop="text">
<p>There's a pure-Python library called <a href="https://pypi.python.org/pypi/uniseg" rel="nofollow"><code>uniseg</code></a> which provides a number of utilities including a grapheme cluster iterator which provides the behaviour you described:</p>
<pre><code>&gt;&gt;&gt; a = u"बिक्रम मेरो नाम हो"
&gt;&gt;&gt; from uniseg.graphemecluster import grapheme_clusters
&gt;&gt;&gt; for i in grapheme_clusters(a): print(i)
... 
बि
क्
र
म

मे
रो

ना
म

हो
</code></pre>
<p>It claims to implement the full Unicode text segmentation algorithm described in <a href="http://www.unicode.org/reports/tr29/tr29-21.html" rel="nofollow">http://www.unicode.org/reports/tr29/tr29-21.html</a>.</p>
</div>
<span class="comment-copy">I never really played with devnagri, which i am definitely going try now :P, but knowing devnagri script, I have a feeling that that the difference in 'ma' and 'be' as you mentioned might be because, in devnagri "ma" is one character , but "be" = "ba" + "e" (ba mai e ki maatra! :P  is what i mean). If the difference in representation is because of that,  then you should be able to separate the 'matras' or one and half letters like 'kra' by doing some simple bit operations to check and saperate, then out them in a List like data structure. Do post a solution if you find one. I am curious!</span>
<span class="comment-copy">#something like this may help # <a href="https://gist.github.com/950405" rel="nofollow noreferrer">gist.github.com/950405</a></span>
<span class="comment-copy">Is that right? You've output क् (ka + virama) and र (ra) as separate clusters, but according to the <a href="http://www.unicode.org/reports/tr29/tr29-17.html#Grapheme_Cluster_Boundaries" rel="nofollow noreferrer">Unicode Text Segmentation algorithm</a> these should form the single cluster क्र (kra).</span>
<span class="comment-copy">@Gareth: I suspect that is a "tailored grapheme cluster" -- which means that it will only be separated in that manner in certain locales.  Since I supply the default locale, no "tailoring" will be done.</span>
<span class="comment-copy">@Gareth: On further research, it appears that not only are such rules not implemented by ICU, but they do not appear in the Unicode locale database.  The tailored grapheme cluster examples in the Unicode text segmentation algorithm page appear to be non-normative, as I cannot find rules for the other two examples either.</span>
<span class="comment-copy">Output is not correct. 'क् र' should be 'क्र'. Looks like there is an issue with the library.</span>
<span class="comment-copy">@shantanoo That's certainly possible – I would report that to the author: <a href="https://bitbucket.org/emptypage/uniseg-python" rel="nofollow noreferrer">bitbucket.org/emptypage/uniseg-python</a></span>
