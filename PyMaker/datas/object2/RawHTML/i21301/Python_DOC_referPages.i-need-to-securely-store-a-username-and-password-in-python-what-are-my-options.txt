<div class="post-text" itemprop="text">
<p>I'm writing a small Python script which will periodically pull information from a 3rd party service using a username and password combo. I don't need to create something that is 100% bulletproof (does 100% even exist?), but I would like to involve a good measure of security so at the very least it would take a long time for someone to break it. </p>
<p>This script won't have a GUI and will be run periodically by <code>cron</code>, so entering a password each time it's run to decrypt things won't really work, and I'll have to store the username and password in either an encrypted file or encrypted in a SQLite database, which would be preferable as I'll be using SQLite anyway, and I <em>might</em> need to edit the password at some point. In addition, I'll probably be wrapping the whole program in an EXE, as it's exclusively for Windows at this point. </p>
<p>How can I securely store the username and password combo to be used periodically via a <code>cron</code> job?</p>
</div>
<div class="post-text" itemprop="text">
<p>I recommend a strategy similar to <a href="http://en.wikipedia.org/wiki/Ssh-agent">ssh-agent</a>.  If you can't use ssh-agent directly you could implement something like it, so that your password is only kept in RAM.  The cron job could have configured credentials to get the actual password from the agent each time it runs, use it once, and de-reference it immediately using the <code>del</code> statement.</p>
<p>The administrator still has to enter the password to start ssh-agent, at boot-time or whatever, but this is a reasonable compromise that avoids having a plain-text password stored anywhere on disk.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://pypi.python.org/pypi/keyring" rel="noreferrer" title="keyring">python keyring library</a> integrates with the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa380261(v=vs.85).aspx" rel="noreferrer"><code>CryptProtectData</code></a> API on Windows (along with relevant API's on Mac and Linux) which encrypts data with the user's logon credentials.</p>
<p>Simple usage:</p>
<pre><code>import keyring

# the service is just a namespace for your app
service_id = 'IM_YOUR_APP!'

keyring.set_password(service_id, 'dustin', 'my secret password')
password = keyring.get_password(service_id, 'dustin') # retrieve password
</code></pre>
<p>Usage if you want to store the username on the keyring:</p>
<pre><code>import keyring

MAGIC_USERNAME_KEY = 'im_the_magic_username_key'

# the service is just a namespace for your app
service_id = 'IM_YOUR_APP!'  

username = 'dustin'

# save password
keyring.set_password(service_id, username, "password")

# optionally, abuse `set_password` to save username onto keyring
# we're just using some known magic string in the username field
keyring.set_password(service_id, MAGIC_USERNAME_KEY, username)
</code></pre>
<p>Later to get your info from the keyring</p>
<pre><code># again, abusing `get_password` to get the username.
# after all, the keyring is just a key-value store
username = keyring.get_password(service_id, MAGIC_USERNAME_KEY)
password = keyring.get_password(service_id, username)  
</code></pre>
<p>Items are encrypted with the user's operating system credentials, thus other applications running in your user account would be able to access the password.  </p>
<p>To obscure that vulnerability a bit you could encrypt/obfuscate the password in some manner before storing it on the keyring.  Of course, anyone who was targeting your script would just be able to look at the source and figure out how to unencrypt/unobfuscate the password, but you'd at least prevent some application vacuuming up all passwords in the vault and getting yours as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>After looking though the answers to this and related questions, I've put together some code using a few of the suggested methods for encrypting and obscuring secret data. This code is specifically for when the script has to run without user intervention (if the user starts it manually, it's best to have them put in the password and only keep it in memory as the answer to this question suggests). This method isn't super-secure; fundamentally, the script can access the secret info so anyone who has full system access has the script and its associated files and can access them. What this does do id obscures the data from casual inspection and leaves the data files themselves secure if they are examined individually, or together without the script.</p>
<p>My motivation for this is a project that polls some of my bank accounts to monitor transactions - I need it to run in the background without me re-entering passwords every minute or two.</p>
<p>Just paste this code at the top of your script, change the saltSeed and then use store() retrieve() and require() in your code as needed:</p>
<pre><code>from getpass import getpass
from pbkdf2 import PBKDF2
from Crypto.Cipher import AES
import os
import base64
import pickle


### Settings ###

saltSeed = 'mkhgts465wef4fwtdd' # MAKE THIS YOUR OWN RANDOM STRING

PASSPHRASE_FILE = './secret.p'
SECRETSDB_FILE = './secrets'
PASSPHRASE_SIZE = 64 # 512-bit passphrase
KEY_SIZE = 32 # 256-bit key
BLOCK_SIZE = 16  # 16-bit blocks
IV_SIZE = 16 # 128-bits to initialise
SALT_SIZE = 8 # 64-bits of salt


### System Functions ###

def getSaltForKey(key):
    return PBKDF2(key, saltSeed).read(SALT_SIZE) # Salt is generated as the hash of the key with it's own salt acting like a seed value

def encrypt(plaintext, salt):
    ''' Pad plaintext, then encrypt it with a new, randomly initialised cipher. Will not preserve trailing whitespace in plaintext!'''

    # Initialise Cipher Randomly
    initVector = os.urandom(IV_SIZE)

    # Prepare cipher key:
    key = PBKDF2(passphrase, salt).read(KEY_SIZE)

    cipher = AES.new(key, AES.MODE_CBC, initVector) # Create cipher

    return initVector + cipher.encrypt(plaintext + ' '*(BLOCK_SIZE - (len(plaintext) % BLOCK_SIZE))) # Pad and encrypt

def decrypt(ciphertext, salt):
    ''' Reconstruct the cipher object and decrypt. Will not preserve trailing whitespace in the retrieved value!'''

    # Prepare cipher key:
    key = PBKDF2(passphrase, salt).read(KEY_SIZE)

    # Extract IV:
    initVector = ciphertext[:IV_SIZE]
    ciphertext = ciphertext[IV_SIZE:]

    cipher = AES.new(key, AES.MODE_CBC, initVector) # Reconstruct cipher (IV isn't needed for edecryption so is set to zeros)

    return cipher.decrypt(ciphertext).rstrip(' ') # Decrypt and depad


### User Functions ###

def store(key, value):
    ''' Sore key-value pair safely and save to disk.'''
    global db

    db[key] = encrypt(value, getSaltForKey(key))
    with open(SECRETSDB_FILE, 'w') as f:
        pickle.dump(db, f)

def retrieve(key):
    ''' Fetch key-value pair.'''
    return decrypt(db[key], getSaltForKey(key))

def require(key):
    ''' Test if key is stored, if not, prompt the user for it while hiding their input from shoulder-surfers.'''
    if not key in db: store(key, getpass('Please enter a value for "%s":' % key))


### Setup ###

# Aquire passphrase:
try:
    with open(PASSPHRASE_FILE) as f:
        passphrase = f.read()
    if len(passphrase) == 0: raise IOError
except IOError:
    with open(PASSPHRASE_FILE, 'w') as f:
        passphrase = os.urandom(PASSPHRASE_SIZE) # Random passphrase
        f.write(base64.b64encode(passphrase))

        try: os.remove(SECRETSDB_FILE) # If the passphrase has to be regenerated, then the old secrets file is irretrievable and should be removed
        except: pass
else:
    passphrase = base64.b64decode(passphrase) # Decode if loaded from already extant file

# Load or create secrets database:
try:
    with open(SECRETSDB_FILE) as f:
        db = pickle.load(f)
    if db == {}: raise IOError
except (IOError, EOFError):
    db = {}
    with open(SECRETSDB_FILE, 'w') as f:
        pickle.dump(db, f)

### Test (put your code here) ###
require('id')
require('password1')
require('password2')
print
print 'Stored Data:'
for key in db:
    print key, retrieve(key) # decode values on demand to avoid exposing the whole database in memory
    # DO STUFF
</code></pre>
<p>The security of this method would be significantly improved if os permissions were set on the secret files to only allow the script itself to read them, and if the script itself was compiled and marked as executable only (not readable). Some of that could be automated, but I haven't bothered. It would probably require setting up a user for the script and running the script as that user (and setting ownership of the script's files to that user).</p>
<p>I'd love any suggestions, criticisms or other points of vulnerability that anyone can think of. I'm pretty new to writing crypto code so what I've done could almost certainly be improved.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the best you can do is protect the script file and system it's running on.</p>
<p>Basically do the following:</p>
<ul>
<li>Use file system permissions (chmod 400)</li>
<li>Strong password for owner's account on the system</li>
<li>Reduce ability for system to be compromised (firewall, disable unneeded services, etc)</li>
<li>Remove administrative/root/sudo privileges for those that do not need it</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>There's not much point trying to encrypt the password: the person you're trying to hide it from has the Python script, which will have the code to decrypt it.  The fastest way to get the password will be to add a print statement to the Python script just before it uses the password with the third-party service.</p>
<p>So store the password as a string in the script, and base64 encode it so that just reading the file isn't enough, then call it a day.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few options for storing passwords and other secrets that a Python program needs to use, particularly a program that needs to run in the background where it can't just ask the user to type in the password.</p>
<p>Problems to avoid:</p>
<ol>
<li>Checking the password in to source control where other developers or even the public can see it.</li>
<li>Other users on the same server reading the password from a configuration file or source code.</li>
<li>Having the password in a source file where others can see it over your shoulder while you are editing it.</li>
</ol>
<h2>Option 1: SSH</h2>
<p>This isn't always an option, but it's probably the best. Your private key is never transmitted over the network, SSH just runs mathematical calculations to prove that you have the right key.</p>
<p>In order to make it work, you need the following:</p>
<ul>
<li>The database or whatever you are accessing needs to be accessible by SSH. Try searching for "SSH" plus whatever service you are accessing. For example, <a href="https://www.postgresql.org/docs/9.1/static/ssh-tunnels.html" rel="nofollow noreferrer">"ssh postgresql"</a>. If this isn't a feature on your database, move on to the next option.</li>
<li>Create an account to run the service that will make calls to the database, and <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2" rel="nofollow noreferrer">generate an SSH key</a>.</li>
<li>Either add the public key to the service you're going to call, or create a local account on that server, and install the public key there.</li>
</ul>
<h2>Option 2: Environment Variables</h2>
<p>This one is the simplest, so it might be a good place to start. It's described well in the <a href="https://12factor.net/config" rel="nofollow noreferrer">Twelve Factor App</a>. The basic idea is that your source code just pulls the password or other secrets from environment variables, and then you configure those environment variables on each system where you run the program. It might also be a nice touch if you use default values that will work for most developers. You have to balance that against making your software "secure by default".</p>
<p>Here's an example that pulls the server, user name, and password from environment variables.</p>
<pre><code>import os

server = os.getenv('MY_APP_DB_SERVER', 'localhost')
user = os.getenv('MY_APP_DB_USER', 'myapp')
password = os.getenv('MY_APP_DB_PASSWORD', '')

db_connect(server, user, password)
</code></pre>
<p>Look up how to set environment variables in your operating system, and consider running the service under its own account. That way you don't have sensitive data in environment variables when you run programs in your own account. When you do set up those environment variables, take extra care that other users can't read them. Check file permissions, for example. Of course any users with root permission will be able to read them, but that can't be helped.</p>
<h2>Option 3: Configuration Files</h2>
<p>This is very similar to the environment variables, but you read the secrets from a text file. I still find the environment variables more flexible for things like deployment tools and continuous integration servers. If you decide to use a configuration file, Python supports several formats in the standard library, like <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">JSON</a>, <a href="https://docs.python.org/3/library/configparser.html" rel="nofollow noreferrer">INI</a>, <a href="https://docs.python.org/3/library/netrc.html" rel="nofollow noreferrer">netrc</a>, and <a href="https://docs.python.org/3/library/xml.etree.elementtree.html" rel="nofollow noreferrer">XML</a>. You can also find external packages like <a href="https://pypi.org/project/PyYAML/" rel="nofollow noreferrer">PyYAML</a> and <a href="https://pypi.org/project/toml/" rel="nofollow noreferrer">TOML</a>. Personally, I find JSON and YAML the simplest to use, and YAML allows comments.</p>
<p>Three things to consider with configuration files:</p>
<ol>
<li>Where is the file? Maybe a default location like <code>~/.my_app</code>, and a command-line option to use a different location.</li>
<li>Make sure other users can't read the file.</li>
<li>Obviously, don't commit the configuration file to source code. You might want to commit a template that users can copy to their home directory.</li>
</ol>
<h2>Option 4: Python Module</h2>
<p>Some projects just put their secrets right into a Python module.</p>
<pre><code># settings.py
db_server = 'dbhost1'
db_user = 'my_app'
db_password = 'correcthorsebatterystaple'
</code></pre>
<p>Then import that module to get the values.</p>
<pre><code># my_app.py
from settings import db_server, db_user, db_password

db_connect(db_server, db_user, db_password)
</code></pre>
<p>One project that uses this technique is <a href="https://docs.djangoproject.com/en/2.1/topics/settings/" rel="nofollow noreferrer">Django</a>. Obviously, you shouldn't commit <code>settings.py</code> to source control, although you might want to commit a file called <code>settings_template.py</code> that users can copy and modify.</p>
<p>I see a few problems with this technique:</p>
<ol>
<li>Developers might accidentally commit the file to source control. Adding it to <code>.gitignore</code> reduces that risk.</li>
<li>Some of your code is not under source control. If you're disciplined and only put strings and numbers in here, that won't be a problem. If you start writing logging filter classes in here, stop!</li>
</ol>
<p>If your project already uses this technique, it's easy to transition to environment variables. Just move all the setting values to environment variables, and change the Python module to read from those environment variables.</p>
</div>
<div class="post-text" itemprop="text">
<p>operating systems often have support for securing data for the user.  in the case of windows it looks like it's <a href="http://msdn.microsoft.com/en-us/library/aa380261.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/aa380261.aspx</a></p>
<p>you can call win32 apis from python using <a href="http://vermeulen.ca/python-win32api.html" rel="nofollow">http://vermeulen.ca/python-win32api.html</a></p>
<p>as far as i understand, this will store the data so that it can be accessed only from the account used to store it.  if you want to edit the data you can do so by writing code to extract, change and save the value.</p>
</div>
<div class="post-text" itemprop="text">
<p>I used <a href="https://cryptography.io/en/latest/" rel="nofollow noreferrer" title="Cryptography">Cryptography</a> because I had troubles installing (compiling) other commonly mentioned libraries on my system. (Win7 x64, Python 3.5)</p>
<pre><code>from cryptography.fernet import Fernet
key = Fernet.generate_key()
cipher_suite = Fernet(key)
cipher_text = cipher_suite.encrypt(b"password = scarybunny")
plain_text = cipher_suite.decrypt(cipher_text)
</code></pre>
<p>My script is running in a physically secure system/room. I encrypt credentials with an "encrypter script" to a config file. And then decrypt when I need to use them.
"Encrypter script" is not on the real system, only encrypted config file is. Someone who analyses the code can easily break the encryption by analysing the code, but you can still compile it into an EXE if necessary.</p>
</div>
<span class="comment-copy"><b>See also</b>: <a href="http://stackoverflow.com/questions/157938">stackoverflow.com/questions/157938</a></span>
<span class="comment-copy">+1, that makes a lot of sense. I could always build a UI for it which essentially asks the user for his password on boot, that way it's <i>never</i> stored on disk and is safe from prying eyes.</span>
<span class="comment-copy">How should the username be stored? Does <code>keyring</code> support retrieving both the username and password?</span>
<span class="comment-copy">@StevenVascellaro see my edit to my answer.</span>
<span class="comment-copy">@DustinWyatt Clever use of <code>get_password</code> for the username. Although, I think you should begin the answer with the original simplified example of  <code>keyring.set_password()</code> and <code>keyring.get_password()</code></span>
<span class="comment-copy">Unfortunately, it's Windows, I'll be wrapping it in an EXE, and I'll need to change the password every so often, so hard-coding it won't be an option.</span>
<span class="comment-copy">Windows still has file system permissions. Store the password in an external file and remove everyone's access excluding your own. You probably also have to remove their administrative privileges.</span>
<span class="comment-copy">Yeah using permissions is the only reliable security option here. Obviously any administrator will still be able to access the data (at least on windows/usual linux distributions) but then that's a battle already lost.</span>
<span class="comment-copy">It's true. When password decryption is automated, then that's just as good as having a plain text password. The real security is in locking down the user account with access. The best that can be done is to give read-only permissions to only that user account. Possibly create a special user, specifically and only for that service.</span>
<span class="comment-copy">I'll need to edit the username and password periodically and I'll be wrapping the whole thing in an EXE for Windoze; I've edited the post to reflect this. Should I simply base64 it wherever I do end up storing it?</span>
<span class="comment-copy">I agree that "encrypting" the password does not help, since the plain-text password must anyway be obtained in an automated fashion, and therefore must be obtainable from whatever is stored.  But there are viable approaches.</span>
<span class="comment-copy">This looks like the best choice to me, but I feel this answer is way too incomplete to accept it, given it's lacking any actual examples.</span>
<span class="comment-copy">There are some examples for using these functions in Python over here: <a href="http://stackoverflow.com/questions/463832/using-dpapi-with-python" title="using dpapi with python">stackoverflow.com/questions/463832/using-dpapi-with-python</a></span>
