<div class="post-text" itemprop="text">
<p>I recently developed a class named <code>DocumentWrapper</code> around some ORM document object in Python to transparently add some features to it without changing its interface in any way.</p>
<p>I just have one issue with this. Let's say I have some <code>User</code> object wrapped in it. Calling <code>isinstance(some_var, User)</code> will return <code>False</code> because <code>some_var</code> indeed is an instance of <code>DocumentWrapper</code>.</p>
<p>Is there any way to fake the type of an object in Python to have the same call return <code>True</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Testing the <em>type</em> of an object is usually an antipattern in python.  In some cases it makes sense to test the <em>"duck type"</em> of the object, something like:</p>
<pre><code>hasattr(some_var, "username")
</code></pre>
<p>But even that's undesirable, for instance there are reasons why that expression might return false, even though a wrapper uses some magic with <code>__getattribute__</code> to correctly proxy the attribute.  </p>
<p>It's usually preferred to allow variables only take a single abstract type, and possibly <code>None</code>.  Different behaviours based on different inputs should be achieved by passing the optionally typed data in different variables.  You want to do something like this:</p>
<pre><code>def dosomething(some_user=None, some_otherthing=None):
    if some_user is not None:
        #do the "User" type action
    elif some_otherthing is not None:
        #etc...
    else:
         raise ValueError("not enough arguments")
</code></pre>
<p>Of course, this all assumes you have some level of control of the code that is doing the type checking.  Suppose it isn't.  for "isinstance()" to return true, the class must appear in the instance's bases, or the class must have an <code>__instancecheck__</code>.   Since you don't control either of those things for the class, you have to resort to some shenanigans on the instance.  Do something like this:</p>
<pre><code>def wrap_user(instance):
    class wrapped_user(type(instance)):
        __metaclass__ = type
        def __init__(self):
            pass
        def __getattribute__(self, attr):
            self_dict = object.__getattribute__(type(self), '__dict__')
            if attr in self_dict:
                return self_dict[attr]
            return getattr(instance, attr)
        def extra_feature(self, foo):
            return instance.username + foo # or whatever
    return wrapped_user()
</code></pre>
<p>What we're doing is creating a new class dynamically at the time we need to wrap the instance, and actually inherit from the wrapped object's <code>__class__</code>.  We also go to the extra trouble of overriding the <code>__metaclass__</code>, in case the original had some extra behaviors we don't actually want to encounter (like looking for a database table with a certain class name).  A nice convenience of this style is that we never have to create any instance attributes on the wrapper class, there is no <code>self.wrapped_object</code>, since that value is present at <em>class creation time</em>.  </p>
<p>Edit: As pointed out in comments, the above only works for some simple types, if you need to proxy more elaborate attributes on the target object, (say, methods), then see the following answer:  <a href="https://stackoverflow.com/a/31658279/65696">Python - Faking Type Continued</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>__instancecheck__</code> magic method to override the default <code>isinstance</code> behaviour:</p>
<pre><code>@classmethod
def __instancecheck__(cls, instance):
    return isinstance(instance, User)
</code></pre>
<p>This is only if you want your object to be a <em>transparent</em> wrapper; that is, if you want a <code>DocumentWrapper</code> to behave like a <code>User</code>. Otherwise, just expose the wrapped class as an attribute.</p>
<p><sub>This is a Python 3 addition; it came with abstract base classes. You can't do the same in Python 2.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>Override <code>__class__</code> in your wrapper class <code>DocumentWrapper</code>:</p>
<pre><code>class DocumentWrapper(object):

  @property
  def __class__(self):
    return User

&gt;&gt;&gt; isinstance(DocumentWrapper(), User)
True
</code></pre>
<p>This way no modifications to the wrapped class <code>User</code> are needed.</p>
<p>Python Mock does the same (see mock.py:612 in mock-2.0.0, couldn't find sources online to link to, sorry).</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution by using metaclass, but you need to modify the wrapped classes:</p>
<pre><code>&gt;&gt;&gt; class DocumentWrapper:
    def __init__(self, wrapped_obj):
        self.wrapped_obj = wrapped_obj

&gt;&gt;&gt; class MetaWrapper(abc.ABCMeta):
    def __instancecheck__(self, instance):
        try:
            return isinstance(instance.wrapped_obj, self)
        except:
            return isinstance(instance, self)

&gt;&gt;&gt; class User(metaclass=MetaWrapper):
    pass

&gt;&gt;&gt; user=DocumentWrapper(User())
&gt;&gt;&gt; isinstance(user,User)
True
&gt;&gt;&gt; class User2:
    pass

&gt;&gt;&gt; user2=DocumentWrapper(User2())
&gt;&gt;&gt; isinstance(user2,User2)
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you want to test the type of the object your <code>DocumentWrapper</code> wraps, not the type of the <code>DocumentWrapper</code> itself. If that's right, then the interface to <code>DocumentWrapper</code> needs to expose that type. You might add a method to your <code>DocumentWrapper</code> class that returns the type of the wrapped object, for instance. But I don't think that making the call to <code>isinstance</code> ambiguous, by making it return True when it's not, is the right way to solve this.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best way is to inherit DocumentWrapper from the User itself, or mix-in pattern and doing multiple inherintance from many classes </p>
<pre><code> class DocumentWrapper(User, object)
</code></pre>
<p>You can also fake isinstance() results by manipulating <code>obj.__class__</code> but this is deep level magic and should not be done.</p>
</div>
<span class="comment-copy">multiple inheritance?</span>
<span class="comment-copy"><code>isinstance(some_var.user, User)</code>? What are you actually trying to do?</span>
<span class="comment-copy">Just trying to have a transparent wrapper, which behaves <i>exactly</i> like the wrapped class. Including with isinstance. Multiple inheritance is not the solution, at least because User is just one of the many classes the DocumentWrapper wraps. (I don't have control over these classes, I'm not able to change their inheritance tree.)</span>
<span class="comment-copy">Thanks a lot for your valuable help =)</span>
<span class="comment-copy">And why is the (seemingly redundant) <code>__metaclass__ = type</code> necessary?</span>
<span class="comment-copy">You have effectively neutered the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a>, e.g. <code>wrap_user(obj).extra_feature()</code> returns an unbound method. You need to, at the very least, check for <code>__get__</code> methods on the objects you retrieve from <code>self_dict</code>. See <a href="https://stackoverflow.com/q/31658171">Python - Faking Type Continued</a> for a follow-up question someone asked.</span>
<span class="comment-copy">The call to <code>wrapped_user()</code>  appears to return <code>None</code>, is that intended?</span>
<span class="comment-copy">@oarfish: certainly not.  the empty <code>__new__</code> is erroneous, just deleting it improves things, but i'm not sure what i was trying to communicate with that example 7 years ago...</span>
<span class="comment-copy">I heard this, thanks... But I'm using Python 2.x +(</span>
<span class="comment-copy">this is in 2.6 <a href="https://docs.python.org/2/reference/datamodel.html#customizing-instance-and-subclass-checks" rel="nofollow noreferrer">docs.python.org/2/reference/â€¦</a></span>
<span class="comment-copy">Big caveat, this method goes in the <b>meta</b> class of the <b>wrapped</b> class.</span>
<span class="comment-copy">Big lightbulb, <b>you need to modify the wrapped classes</b>.  So you can only "fake" your own types, e.g. not strings or ints.</span>
<span class="comment-copy">Thanks. User is not the only document type wrapped, so this won't unfortunately work. But thanks, I didn't even know multiple inheritance was possible with Python =)</span>
