<div class="post-text" itemprop="text">
<p>With Python 3 I am requesting a json document from a URL.</p>
<pre><code>response = urllib.request.urlopen(request)
</code></pre>
<p>The <code>response</code> object is a file-like object with <code>read</code> and <code>readline</code> methods. Normally a JSON object can be created with a file opened in text mode.</p>
<pre><code>obj = json.load(fp)
</code></pre>
<p>What I would like to do is:</p>
<pre><code>obj = json.load(response)
</code></pre>
<p>This however does not work as urlopen returns a file object in binary mode.</p>
<p>A work around is of course:</p>
<pre><code>str_response = response.read().decode('utf-8')
obj = json.loads(str_response)
</code></pre>
<p>but this feels bad...</p>
<p>Is there a better way that I can transform a bytes file object to a string file object? Or am I missing any parameters for either <code>urlopen</code> or <code>json.load</code> to give an encoding?</p>
</div>
<div class="post-text" itemprop="text">
<p>HTTP sends bytes. If the resource in question is text, the character encoding is normally specified, either by the Content-Type HTTP header or by another mechanism (an RFC, HTML <code>meta http-equiv</code>,...).</p>
<p><code>urllib</code> <em>should</em> know how to encode the bytes to a string, but it's too naïve—it's a horribly underpowered and un-Pythonic library.</p>
<p><a href="http://www.diveintopython3.net/http-web-services.html#dont-try-this-at-home" rel="noreferrer">Dive Into Python 3</a> provides an overview about the situation.</p>
<p>Your "work-around" is fine—although it feels wrong, it's the correct way to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python’s wonderful standard library to the rescue…</p>
<pre><code>import codecs

reader = codecs.getreader("utf-8")
obj = json.load(reader(response))
</code></pre>
<p>Works with both py2 and py3.</p>
<p>Docs: <a href="https://docs.python.org/2/library/codecs.html#codecs.getreader" rel="noreferrer">Python 2</a>, <a href="https://docs.python.org/3/library/codecs.html#codecs.getreader" rel="noreferrer">Python3</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I have come to opinion that the question is the best answer :)</p>
<pre><code>import json
from urllib.request import urlopen

response = urlopen("site.com/api/foo/bar").read().decode('utf8')
obj = json.loads(response)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For anyone else trying to solve this using the <code>requests</code> library:</p>
<pre><code>import json
import requests

r = requests.get('http://localhost/index.json')
r.raise_for_status()
# works for Python2 and Python3
json.loads(r.content.decode('utf-8'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This one works for me, I used 'request' library with <code>json()</code> check out the doc in <a href="http://docs.python-requests.org/en/master/user/quickstart/#json-response-content" rel="noreferrer">requests for humans</a></p>
<pre><code>import requests

url = 'here goes your url'

obj = requests.get(url).json() 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I ran into similar problems using Python 3.4.3 &amp; 3.5.2 and Django 1.11.3. However, when I upgraded to Python 3.6.1 the problems went away.</p>
<p>You can read more about it here:
<a href="https://docs.python.org/3/whatsnew/3.6.html#json" rel="noreferrer">https://docs.python.org/3/whatsnew/3.6.html#json</a></p>
<p>If you're not tied to a specific version of Python, just consider upgrading to 3.6 or later.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're experiencing this issue whilst using the flask microframework, then you can just do:</p>
<p><code>data = json.loads(response.get_data(as_text=True))</code></p>
<p><a href="http://werkzeug.pocoo.org/docs/0.10/wrappers/#werkzeug.wrappers.BaseRequest.get_data" rel="nofollow noreferrer">From the docs</a>: "If as_text is set to True the return value will be a decoded unicode string"</p>
</div>
<div class="post-text" itemprop="text">
<p>Just found this simple method to make HttpResponse content as a json</p>
<pre><code>import json

request = RequestFactory() # ignore this, this just like your request object

response = MyView.as_view()(request) # got response as HttpResponse object

response.render() # call this so we could call response.content after

json_response = json.loads(response.content.decode('utf-8'))

print(json_response) # {"your_json_key": "your json value"}
</code></pre>
<p>Hope that helps you</p>
</div>
<div class="post-text" itemprop="text">
<p>Your workaround actually just saved me. I was having a lot of problems processing the request using the Falcon framework. This worked for me. req being the request form curl pr httpie</p>
<pre><code>json.loads(req.stream.read().decode('utf-8'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will stream the byte data into json.</p>
<pre><code>import io

obj = json.load(io.TextIOWrapper(response))
</code></pre>
<p>io.TextIOWrapper is preferred to the codec's module reader. <a href="https://www.python.org/dev/peps/pep-0400/" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-0400/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I used below program to use of <code>json.loads()</code></p>
<pre><code>import urllib.request
import json
endpoint = 'https://maps.googleapis.com/maps/api/directions/json?'
api_key = 'AIzaSyABbKiwfzv9vLBR_kCuhO7w13Kseu68lr0'
origin = input('where are you ?').replace(' ','+')
destination = input('where do u want to go').replace(' ','+')
nav_request = 'origin={}&amp;destination={}&amp;key={}'.format(origin,destination,api_key)
request = endpoint + nav_request
**response = urllib.request.urlopen(request).read().decode('utf-8')
directions = json.loads(response)**
print(directions)
</code></pre>
</div>
<span class="comment-copy">I think you have a typo there, "readall" should be "read" ?</span>
<span class="comment-copy">@BobYoplait I agree.</span>
<span class="comment-copy">This may be the "correct" way to do it but if there was one thing I could undo about Python 3 it would be this bytes/strings crap. You would think the built-in library functions would at least know how to deal with other built-in library functions. Part of the reason we use python is the simple intuitive syntax. This change breaks that all over the place.</span>
<span class="comment-copy">Check out <a href="http://docs.python-requests.org/" rel="nofollow noreferrer">the "requests" library</a> -- it handles this sort of thing for you automagically.</span>
<span class="comment-copy">This isn’t a case of the built-in library functions needing to “know how” to deal with other functions. JSON is defined as a UTF-8 representation of objects, so it can’t magically decode bytes that it doesn’t know the encoding of. I do agree that <code>urlopen</code> ought to be able to decode the bytes itself since it knows the encoding. Anyway, I’ve posted the Python standard library solution as an answer — you can do streaming decoding of bytes using the <code>codecs</code> module.</span>
<span class="comment-copy">@ThatAintWorking: I would disagree. While it is a pain in the neck to explicitly have to manage the difference between bytes and strings, it is a much greater pain to have the language make some implicit conversion for you. Implicit bytes &lt;-&gt; string conversions are a source of many bugs, and Python3 is very helpful in pointing out the pitfalls. But I agree the library has room for improvement in this area.</span>
<span class="comment-copy">@EvertW the failure, in my opinion, it forcing strings to be unicode in the first place.</span>
<span class="comment-copy">I got this error when trying this answer in <code>python 3.4.3</code> not sure why?  The error was <code>TypeError: the JSON object must be str, not 'StreamReader'</code></span>
<span class="comment-copy">@AronYsidoro Did you possibly use <code>json.loads()</code> instead of <code>json.load()</code>?</span>
<span class="comment-copy">For bonus points, use the encoding specified in the response, instead of assuming utf-8: <code>response.headers.get_content_charset()</code>. Returns <code>None</code> if there is no encoding, and doesn't exist on python2.</span>
<span class="comment-copy">@PhilFrost That’s slick. In practice it might pay to be careful with that; JSON is always UTF-8, UTF-16 or UTF-32 by definition (and is overwhelmingly likely to be UTF-8), so if another encoding is returned by the web server, it’s possibly a misconfiguration of the web server software rather than genuinely non-standard JSON.</span>
<span class="comment-copy">when I used in in python 3.5, the error was "AttributeError: 'bytes' object has no attribute 'read'"</span>
<span class="comment-copy">This functionality is built-in to <code>requests</code>: you can simply do <code>r.json()</code></span>
<span class="comment-copy">The clarify, if you use @jbg's method, you don't need to do <code>json.loads</code>. All you have to do is <code>r.json()</code> and you've got your JSON object loaded into a dict already.</span>
<span class="comment-copy"><code>*** UnicodeEncodeError: 'ascii' codec can't encode characters in position 264-265: ordinal not in range(128)</code></span>
<span class="comment-copy">I got to this page because I was having an issue with Flask unit tests - thanks for posting the single line call.</span>
<span class="comment-copy">`*** AttributeError: 'Response' object has no attribute 'readable'``</span>
<span class="comment-copy">*** AttributeError: 'bytes' object has no attribute 'readable'</span>
<span class="comment-copy">Are you using urllib or requests? This is for urllib. If you have a bytes object, just use <code>json.loads(bytes_obj.decode())</code>.</span>
