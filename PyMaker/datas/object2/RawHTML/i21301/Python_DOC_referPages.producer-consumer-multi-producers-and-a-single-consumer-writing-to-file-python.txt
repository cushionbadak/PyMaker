<div class="post-text" itemprop="text">
<p>My requirement is similar to <a href="https://stackoverflow.com/questions/5105382/multiple-producers-single-consumer">Multiple producers, single consumer</a>
except i need it in python </p>
<p>I have created an application that spawns 5 concurrent processes (I am using multiprocessing library).These 5 process are independently producing output in dict format.</p>
<p>Earlier I was printing the output to console, but now would like to output it to a file.</p>
<p>I am looking for a pattern where all my 5 producers write to a shared queue that supports concurrent writes.</p>
<p>And a single consumer process that too has access to this queue and consumes the data from it, with the ability to wait if there is no data to write and terminate when producers are done with their task.</p>
<p>Thanks Anuj</p>
</div>
<div class="post-text" itemprop="text">
<p>since you are already using multiprocess, all you need is the Queue class</p>
<p>and a sample (modified from the Queue docs)</p>
<pre><code>from multiprocessing import Process, Queue

def child(q, url):
    result = my_process(url)
    q.put(result)

if __name__ == '__main__':
    q = Queue()
    urls = [...]
    children = []
    for url in urls:
       p = Process(target=child, args=(q,url))
       p.start()
       children.append(p)
    for p in children:
       p.join()
       print q.get() #or write to file (might not be the answer from this child)
</code></pre>
<p><strong>Edit:</strong>
For multiple answers from each child replace the last for loop with:</p>
<pre><code>while 0 != multiprocessing.active_children():
    print q.get()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've implemented this pattern in Python where a supervisor process spawns a bunch of processes and then consumes log messages from all of them and writes those log messages into a single log file.</p>
<p>Basically, I used execve to spawan the processes an specified that stderr for each process was connected to a PTY. Then my supervisor opened all the master PTYs and used <code>select</code> to read from them in a loop. The PTY's are line-buffered by the tty line discipline and you can use readline on them for non=blocking reads. I believe that I also used fcntl on the PTYs to set os.O_NONBLOCK as well.</p>
<p>Works great. The only hitch is that you need to read more than one line per pty when you return from the select poll, otherwise you can lose output (assuming you have something reaping the child processes and restarting). By reading all lines available on each PTY you also avoid tracebacks getting interleaved with other messages.</p>
<p>If you really need to send objects rather than text lines, then you are better of using a real pub-sub messaging system like AMQP or ZeroMQ. AMQP is a much bigger hammer than you need so only check that out if you expect to be building lots of similar apps. Otherwise, try the simpler 0MQ <a href="http://www.zeromq.org/intro:read-the-manual" rel="nofollow">http://www.zeromq.org/intro:read-the-manual</a> which is just a messaging library that makes sockets much much easier to use.</p>
</div>
<span class="comment-copy">shouldn't this childs.append(child) be childs.append(p)</span>
<span class="comment-copy">Please also let me know the behavior when i will fetch objects from the queue    Let us consider the scenario when queue is quite large, I want to continuously poll the queue for results and wait on it when it is empty.</span>
<span class="comment-copy">@anuj singh - edited, thanks</span>
<span class="comment-copy">Accepting the answer as I am using multiprocessing queues in my code. But for child process management I have a separate monitoring thread in my parent process that continuously monitors a process status and the output returned to check for dead or blocked for long time child processes. Actually  I spwan firefox and XVFB instances in child process and Firefox being Firefox it tends to hang often and makes my child process un-responsive :)</span>
<span class="comment-copy">The p.join() will block waiting on child q.put eventually causing a deadlock, its explained under "Joining processes that use queues" at <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing-programming" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">You can also do some line buffering in your merger process, inserting banners as needed into the log output so you can keep the outputs straight.</span>
<span class="comment-copy">Thanks Micheal , In my case i do not have logs actually , Each of my process will be given a URL and using selenium webdriver api it will navigate the URL and once done I would be fetching certain data from the DOM in dict format. Each process will generate a dict from an input url and will be putting it in a queue , insertion order is not important. While at write time a single consumer will try fetching 5 objects from queue and block if not available and will write to a file. Your answer though helpful will be good if you could also include some code as well.</span>
