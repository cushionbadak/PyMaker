<div class="post-text" itemprop="text">
<p>I want to redirect the print to a .txt file using python. I have a 'for' loop, which will 'print' the output for each of my .bam file while I want to redirect ALL these output to one file. So I tried to put</p>
<pre><code> f = open('output.txt','w'); sys.stdout = f
</code></pre>
<p>at the beginning of my script. However I get nothing in the .txt file.
My script is:</p>
<pre><code>#!/usr/bin/python

import os,sys
import subprocess
import glob
from os import path

f = open('output.txt','w')
sys.stdout = f

path= '/home/xug/nearline/bamfiles'
bamfiles = glob.glob(path + '/*.bam')

for bamfile in bamfiles:
    filename = bamfile.split('/')[-1]
    print 'Filename:', filename
    samtoolsin = subprocess.Popen(["/share/bin/samtools/samtools","view",bamfile],
                                  stdout=subprocess.PIPE,bufsize=1)
    linelist= samtoolsin.stdout.readlines()
    print 'Readlines finished!'
    ........print....
    ........print....
</code></pre>
<p>So what's the problem? Any other way besides this sys.stdout?</p>
<p>I need my result look like:</p>
<pre><code>Filename: ERR001268.bam
Readlines finished!
Mean: 233
SD: 10
Interval is: (213, 252)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The most obvious way to do this would be to print to a file object:</p>
<pre><code>with open('out.txt', 'w') as f:
    print &gt;&gt; f, 'Filename:', filename     # Python 2.x
    print('Filename:', filename, file=f)  #Â Python 3.x
</code></pre>
<p>However, redirecting stdout also works for me.  It is probably fine for a one-off script such as this:</p>
<pre><code>import sys

orig_stdout = sys.stdout
f = open('out.txt', 'w')
sys.stdout = f

for i in range(2):
    print 'i = ', i

sys.stdout = orig_stdout
f.close()
</code></pre>
<p>Redirecting externally from the shell itself is another good option:</p>
<pre><code>./script.py &gt; out.txt
</code></pre>
<p>Other questions:</p>
<p>What is the first filename in your script?  I don't see it initialized.</p>
<p>My first guess is that glob doesn't find any bamfiles, and therefore the for loop doesn't run.  Check that the folder exists, and print out bamfiles in your script.</p>
<p>Also, use <a href="http://docs.python.org/library/os.path.html" rel="noreferrer">os.path.join and os.path.basename</a> to manipulate paths and filenames.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can redirect print with the <code>&gt;&gt;</code> operator.</p>
<pre><code>f = open(filename,'w')
print &gt;&gt;f, 'whatever'     # Python 2.x
print('whatever', file=f) # Python 3.x
</code></pre>
<p>In most cases, you're better off just writing to the file normally.</p>
<pre><code>f.write('whatever')
</code></pre>
<p>or, if you have several items you want to write with spaces between, like <code>print</code>:</p>
<pre><code>f.write(' '.join(('whatever', str(var2), 'etc')))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><a href="https://docs.python.org/2/library/functions.html#print">Python 2</a> or <a href="https://docs.python.org/3/library/functions.html#print">Python 3</a> API reference: </p>
<p><code>print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)</code></p>
<blockquote>
<p>The <em>file</em> argument must be an object with a <code>write(string)</code> method; if it is not present or <code>None</code>, <a href="https://docs.python.org/3/library/sys.html#sys.stdout"><code>sys.stdout</code></a> will be used. Since printed arguments are converted to text strings, <code>print()</code> cannot be used with binary mode file objects. For these, use <code>file.write(...)</code> instead.</p>
</blockquote>
</blockquote>
<p>Since <a href="https://docs.python.org/3/glossary.html#term-file-object">file object</a> normally contains <code>write()</code> method, all you need to do is to pass a <a href="https://docs.python.org/3/glossary.html#term-file-object">file object</a> into its argument.</p>
<h1>Write/Overwrite to File</h1>
<pre><code>with open('file.txt', 'w') as f:
    print('hello world', file=f)
</code></pre>
<h1>Write/Append to File</h1>
<pre><code>with open('file.txt', 'a') as f:
    print('hello world', file=f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This works perfectly:</p>
<pre><code>import sys
sys.stdout=open("test.txt","w")
print ("hello")
sys.stdout.close()
</code></pre>
<p>Now the hello will be written to the test.txt file. Make sure to close the <code>stdout</code> with a <code>close</code>, without it the content will not be save in the file</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest solution isn't through python; its through the shell.  From the first line of your file (<code>#!/usr/bin/python</code>) I'm guessing you're on a UNIX system.  Just use <code>print</code> statements like you normally would, and don't open the file at all in your script.  When you go to run the file, instead of</p>
<pre><code>./script.py
</code></pre>
<p>to run the file, use</p>
<pre><code>./script.py &gt; &lt;filename&gt;
</code></pre>
<p>where you replace <code>&lt;filename&gt;</code> with the name of the file you want the output to go in to.  The <code>&gt;</code> token tells (most) shells to set stdout to the file described by the following token.</p>
<p>One important thing that needs to be mentioned here is that "script.py" needs to be made executable for <code>./script.py</code> to run.</p>
<p>So before running <code>./script.py</code>,execute this command</p>
<p><code>chmod a+x script.py</code>
(make the script executable for all users)</p>
</div>
<div class="post-text" itemprop="text">
<h3>Don't use <code>print</code>, use <code>logging</code></h3>
<p>You can change <code>sys.stdout</code> to point to a file, but this is a pretty clunky and inflexible way to handle this problem.  Instead of using <code>print</code>, use the <a href="https://docs.python.org/3.5/library/logging.html" rel="noreferrer"><code>logging</code></a> module.</p>
<p>With <code>logging</code>, you can print just like you would to <code>stdout</code>, or you can also write the output to a file.  You can even use the different message levels (<code>critical</code>, <code>error</code>, <code>warning</code>, <code>info</code>, <code>debug</code>) to, for example, only print major issues to the console, but still log minor code actions to a file.</p>
<h3>A simple example</h3>
<p>Import <code>logging</code>, get the <code>logger</code>, and set the processing level:</p>
<pre><code>import logging
logger = logging.getLogger()
logger.setLevel(logging.DEBUG) # process everything, even if everything isn't printed
</code></pre>
<p>If you want to print to stdout:</p>
<pre><code>ch = logging.StreamHandler()
ch.setLevel(logging.INFO) # or any other level
logger.addHandler(ch)
</code></pre>
<p>If you want to also write to a file (if you only want to write to a file skip the last section):</p>
<pre><code>fh = logging.FileHandler('myLog.log')
fh.setLevel(logging.DEBUG) # or any level you want
logger.addHandler(fh)
</code></pre>
<p>Then, wherever you would use <code>print</code> use one of the <code>logger</code> methods:</p>
<pre><code># print(foo)
logger.debug(foo)

# print('finishing processing')
logger.info('finishing processing')

# print('Something may be wrong')
logger.warning('Something may be wrong')

# print('Something is going really bad')
logger.error('Something is going really bad')
</code></pre>
<p>To learn more about using more advanced <code>logging</code> features, read the excellent <a href="https://docs.python.org/3.5/howto/logging.html" rel="noreferrer"><code>logging</code> tutorial in the Python docs</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may not like this answer, but I think it's the RIGHT one. Don't change your stdout destination unless it's absolutely necessary (maybe you're using a library that only outputs to stdout??? clearly not the case here).</p>
<p>I think as a good habit you should prepare your data ahead of time as a string, then open your file and write the whole thing at once. This is because input/output operations are the longer you have a file handle open, the more likely an error is to occur with this file (file lock error, i/o error, etc). Just doing it all in one operation leaves no question for when it might have gone wrong.</p>
<p>Here's an example:</p>
<pre><code>out_lines = []
for bamfile in bamfiles:
    filename = bamfile.split('/')[-1]
    out_lines.append('Filename: %s' % filename)
    samtoolsin = subprocess.Popen(["/share/bin/samtools/samtools","view",bamfile],
                                  stdout=subprocess.PIPE,bufsize=1)
    linelist= samtoolsin.stdout.readlines()
    print 'Readlines finished!'
    out_lines.extend(linelist)
    out_lines.append('\n')
</code></pre>
<p>And then when you're all done collecting your "data lines" one line per list item, you can join them with some <code>'\n'</code> characters to make the whole thing outputtable; maybe even wrap your output statement in a <code>with</code> block, for additional safety (will automatically close your output handle even if something goes wrong):</p>
<pre><code>out_string = '\n'.join(out_lines)
out_filename = 'myfile.txt'
with open(out_filename, 'w') as outf:
    outf.write(out_string)
print "YAY MY STDOUT IS UNTAINTED!!!"
</code></pre>
<p>However if you have lots of data to write, you <strong>could</strong> write it one piece at a time. I don't think it's relevant to your application but here's the alternative:</p>
<pre><code>out_filename = 'myfile.txt'
outf = open(out_filename, 'w')
for bamfile in bamfiles:
    filename = bamfile.split('/')[-1]
    outf.write('Filename: %s' % filename)
    samtoolsin = subprocess.Popen(["/share/bin/samtools/samtools","view",bamfile],
                                  stdout=subprocess.PIPE,bufsize=1)
    mydata = samtoolsin.stdout.read()
    outf.write(mydata)
outf.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if ur using linux i suggest u to use <code>tee</code> command the implementation goes like this python <code>python_file.py |tee any_file_name.txt</code>
if u dont want to change anything in the code ,i think this might be the best possible solution ,u can also implement logger but u need do some changes in the code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Changing the value of sys.stdout does change the destination of all calls to print. If you use an alternative way to change the destination of print, you will get the same result.</p>
<p>Your bug is somewhere else:</p>
<ul>
<li>it could be in the code you removed for your question (where does filename come from for the call to open?)</li>
<li>it could also be that you are not waiting for data to be flushed: if you print on a terminal, data is flushed after every new line, but if you print to a file, it's only flushed when the stdout buffer is full (4096 bytes on most systems).</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>If redirecting <code>stdout</code> works for your problem, <a href="https://stackoverflow.com/a/7152903/8117067">Gringo Suave's answer</a> is a good demonstration for how to do it.</p>
<p>To make it <em>even easier</em>, I made a version utilizing <a href="https://docs.python.org/library/contextlib.html#contextlib.contextmanager" rel="nofollow noreferrer">contextmanagers</a> for a succinct generalized calling syntax using the <code>with</code> statement:</p>
<pre><code>from contextlib import contextmanager
import sys

@contextmanager
def redirected_stdout(outstream):
    orig_stdout = sys.stdout
    try:
        sys.stdout = outstream
        yield
    finally:
        sys.stdout = orig_stdout
</code></pre>
<p>To use it, you just do the following (derived from Suave's example):</p>
<pre><code>with open('out.txt', 'w') as outfile:
    with redirected_stdout(outfile):
        for i in range(2):
            print('i =', i)
</code></pre>
<p>It's useful for selectively redirecting <code>print</code> when a module uses it in a way you don't like. The only disadvantage (and this is the dealbreaker for many situations) is that it doesn't work if one wants multiple threads with different values of <code>stdout</code>, but that requires a better, more generalized method: indirect module access. You can see implementations of that in other answers to this question.</p>
</div>
<div class="post-text" itemprop="text">
<p>Something to extend print function for loops</p>
<pre><code>x = 0
while x &lt;=5:
    x = x + 1
    with open('outputEis.txt', 'a') as f:
        print(x, file=f)
    f.close()
</code></pre>
</div>
<span class="comment-copy">Don't use <code>print</code>.</span>
<span class="comment-copy">Why not use <code>f.write(data)</code>?</span>
<span class="comment-copy">yeah, but I have several data for each bam file (mean, SD,interval...), how can I put these data one by one?</span>
<span class="comment-copy"><code>f.write(line)</code> - it inserts a line break at the end.</span>
<span class="comment-copy">@Eran Zimmerman: <code>f.write(line)</code> does not add a line break to the data.</span>
<span class="comment-copy">thx....but how to initialize my first file?</span>
<span class="comment-copy">Line 8 of your code uses a variable named filename, but it hasn't been created yet.  Later in the loop you use it again, but not relevant.</span>
<span class="comment-copy">Bad practice to change sys.stdout if you don't need to.</span>
<span class="comment-copy">@my I'm not convinced it is bad for a simple script like this.</span>
<span class="comment-copy">+1 Haha well you can have my upvote because it's the right way to do it if you absolutely must do it the wrong way... But I still say you should do it with regular file output.</span>
<span class="comment-copy">thx, but here I have more than one 'print'....so plus '\n' ?</span>
<span class="comment-copy">If there are a lot of output statements these can get old fast.  The posters original idea is valid; there is something else wrong with the script.</span>
<span class="comment-copy">Poster's original idea is absolutely invalid. There's no reason to redirect stdout here, since he already gets the data into a variable.</span>
<span class="comment-copy">I think he meant "technically valid", in that you can, in fact, redirect <code>sys.stdout</code>, not that it was a good idea.</span>
<span class="comment-copy">I just confused why some of those earlier answers were to monkey patch the global <code>sys.stdout</code> :(</span>
<span class="comment-copy">but even if we perform <code>sys.stdout.close()</code> , if you type anything in python shell it will show error as <code>ValueError: I/O operation on closed file.</code> <a href="http://imgur.com/a/xby9P" rel="nofollow noreferrer">imgur.com/a/xby9P</a>. Best way to handle this is follow what @Gringo Suave posted</span>
<span class="comment-copy">i tried this, but doesn't work</span>
<span class="comment-copy">What system/terminal are you using, and what results are you getting? It works on Unix/Unix-like(Linux) systems which use the Bash interpreter. If I remember right, <a href="http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/redirection.mspx" rel="nofollow noreferrer">it works on Windows too</a>.</span>
<span class="comment-copy">Linux...........</span>
<span class="comment-copy">./script.py &gt; &lt;filename&gt; 2&gt;&amp;1  You need to capture stderr as well.  2&gt;&amp;1 will do that</span>
<span class="comment-copy">@rtaft Why?  The question specifically wants to pipe the output of <code>print</code> to a file.  It would be reasonable to expect stdout (stack traces and the like) to still print to the terminal.</span>
<span class="comment-copy">Hi, I want to use this logging for writing the console data to the log file with the time like at which time that data is taken. But i am not able to understand the logging function or library properly. Can you help me with this</span>
<span class="comment-copy">@haris Read through the <a href="https://docs.python.org/3.5/howto/logging.html" rel="nofollow noreferrer">Python docs' logging tutorial</a> and check out examples in other questions on Stack Overflow (there are a lot of them). If you are still unable to get it to work, ask a new question.</span>
<span class="comment-copy">With disk caching performance of the original should be acceptable.  This solution however has the drawback of ballooning the memory requirements if there were a lot of output.  Though probably nothing to worry about here, it is generally a good idea to avoid this if possible.  Same idea as using xrange (py3 range) instead of range, etc.</span>
<span class="comment-copy">@Gringo: He didn't specify this requirement. Rarely do I ever write enough data to a file that this would be relevant. This is not the same idea as xrange because xrange doesn't deal with file i/o. Disk caching might help but it's still a bad practice to keep a file handle open for a large body of code.</span>
<span class="comment-copy">Your comment contradicts itself.  To be honest the performance aspect of both approaches is irrelevant for non-huge amounts of data. xrange certainly is similar, it works on one piece at a time instead of all at once in memory.  Perhaps a generator vs list is a better example though.</span>
<span class="comment-copy">@Gringo: I fail to see how my comment contradicts itself. Maybe the performance aspect isn't relevant, keeping a file handle open for an extended period always increases the risk of error. In programming  file i/o is always inherently more risky than doing something within your own program, because it means you have to reach out through the OS and mess around with file locks. The shorter you have a file open for, the better, simply because you don't control the file system from your code. xrange is different because it has nothing to do with file i/o, and FYI I rarely use xrange either; cheers</span>
<span class="comment-copy">@Gringo: I appreciate your criticism and enjoyed the heated debate. Even though we disagreed on some points I still respect your views as it's clear you have a good reason for taking your stance. Thanks for ending it reasonably and have a very good night. :P</span>
<span class="comment-copy">great; was looking for it</span>
<span class="comment-copy">no need to use <code>while</code> and no need to close the file when using <code>with</code></span>
