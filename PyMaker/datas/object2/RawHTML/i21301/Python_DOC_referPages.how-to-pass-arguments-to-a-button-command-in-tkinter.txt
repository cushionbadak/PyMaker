<div class="post-text" itemprop="text">
<p>Suppose I have the following <code>Button</code> made with Tkinter in Python:</p>
<pre><code>import Tkinter as Tk
win = Tk.Toplevel()
frame = Tk.Frame(master=win).grid(row=1, column=1)
button = Tk.Button(master=frame, text='press', command=action)
</code></pre>
<p>The method <code>action</code> is called when I press the button, but what if I wanted to pass some arguments to the method <code>action</code>?</p>
<p>I have tried with the following code: </p>
<pre><code>button = Tk.Button(master=frame, text='press', command=action(someNumber))
</code></pre>
<p>This just invokes the method immediately, and pressing the button does nothing.</p>
</div>
<div class="post-text" itemprop="text">
<p>I personally prefer to use <code>lambdas</code> in such a scenario, because imo it's clearer and simpler and also doesn't force you to write lots of wrapper methods if you don't have control over the called method, but that's certainly a matter of taste.</p>
<p>That's how you'd do it with a lambda (note there's also some implementation of currying in the functional module, so you can use that too):</p>
<pre><code>button = Tk.Button(master=frame, text='press', command= lambda: action(someNumber))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can also be done by using <code>partial</code> from the standard library <a href="http://docs.python.org/2/library/functools.html">functools</a>, like this:</p>
<pre><code>from functools import partial
#(...)
action_with_arg = partial(action, arg)
button = Tk.Button(master=frame, text='press', command=action_with_arg)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's ability to provide default values for function arguments gives us a way out.</p>
<pre><code>def fce(x=myX, y=myY):
    myFunction(x,y)
button = Tk.Button(mainWin, text='press', command=fce)
</code></pre>
<p>See: <a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/extra-args.html" rel="noreferrer">http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/extra-args.html</a></p>
<p>For more buttons you can create a function which returns a function:</p>
<pre><code>def fce(myX, myY):
    def wrapper(x=myX, y=myY):
        pass
        pass
        pass
        return x+y
    return wrapper

button1 = Tk.Button(mainWin, text='press 1', command=fce(1,2))
button2 = Tk.Button(mainWin, text='press 2', command=fce(3,4))
button3 = Tk.Button(mainWin, text='press 3', command=fce(9,8))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Example GUI:</h1>
<p>Let's say I have the GUI:</p>
<pre><code>import tkinter as tk

root = tk.Tk()

btn = tk.Button(root, text="Press")
btn.pack()

root.mainloop()
</code></pre>
<h1>What Happens When a Button Is Pressed</h1>
<p>See that when <code>btn</code> is pressed it calls <em>its own</em> function which is very similar to <code>button_press_handle</code> in the following example:</p>
<pre><code>def button_press_handle(callback=None):
    if callback:
        callback() # Where exactly the method assigned to btn['command'] is being callled
</code></pre>
<p>with:</p>
<pre><code>button_press_handle(btn['command'])
</code></pre>
<p>You can simply think that <code>command</code> option should be set as, the reference to the method we want to be called, similar to <code>callback</code> in <code>button_press_handle</code>.</p>
<hr/>
<h1>Calling a Method(<a href="https://stackoverflow.com/questions/824234/what-is-a-callback-function">Callback</a>) When the Button is Pressed</h1>
<p><strong><em>Without</em> arguments</strong> </p>
<p>So if I wanted to <code>print</code> something when the button is pressed I would need to set:</p>
<pre><code>btn['command'] = print # default to print is new line
</code></pre>
<p>Pay close attention to the <em>lack</em> of <code>()</code> with the <code>print</code> method which is omitted in the meaning that: <em>"This is the method's name which I want you to call when pressed <strong>but</strong> don't call it just this very instant."</em> However, I didn't pass any arguments for the <code>print</code> so it printed whatever it prints when called without arguments.</p>
<p><strong><em>With</em> Argument(s)</strong></p>
<p>Now If I wanted to also pass arguments to <em>the method I want to be called</em> when the button is pressed I could make use of the anonymous functions, which can be created with <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="noreferrer">lambda</a> statement, in this case for <code>print</code> built-in method, like the following:</p>
<pre><code>btn['command'] = lambda arg1="Hello", arg2=" ", arg3="World!" : print(arg1 + arg2 + arg3)
</code></pre>
<hr/>
<h1>Calling <em>Multiple</em> Methods when the Button Is Pressed</h1>
<p><strong><em>Without</em> Arguments</strong></p>
<p>You can also achieve that using <code>lambda</code> statement but it is considered bad practice and thus I won't include it here. The good practice is to define a separate method, <code>multiple_methods</code>, that calls the methods wanted and then set it as the callback to the button press:</p>
<pre><code>def multiple_methods():
    print("Vicariously") # the first inner callback
    print("I") # another inner callback
</code></pre>
<p><strong><em>With</em> Argument(s)</strong></p>
<p>In order to pass argument(s) to method that calls other methods, again make use of <code>lambda</code> statement, but first:</p>
<pre><code>def multiple_methods(*args, **kwargs):
    print(args[0]) # the first inner callback
    print(kwargs['opt1']) # another inner callback
</code></pre>
<p>and then set:</p>
<pre><code>btn['command'] = lambda arg="live", kw="as the" : a_new_method(arg, opt1=kw)
</code></pre>
<hr/>
<h1>Returning Object(s) From the Callback</h1>
<p>Also further note that <code>callback</code> can't really <code>return</code> because it's only called inside <code>button_press_handle</code> with <code>callback()</code> as opposed to <code>return callback()</code>. It does <code>return</code> but <em>not</em> anywhere outside that function. Thus you should rather <em>modify</em> object(s) that are accessible in the current scope.</p>
<hr/>
<h1>Complete Example with <a href="https://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="noreferrer">global</a> Object Modification(s)</h1>
<p>Below example will call a method that changes <code>btn</code>'s text each time the button is pressed:</p>
<pre><code>import tkinter as tk

i = 0
def text_mod():
    global i, btn           # btn can be omitted but not sure if should be
    txt = ("Vicariously", "I", "live", "as", "the", "whole", "world", "dies")
    btn['text'] = txt[i]    # the global object that is modified
    i = (i + 1) % len(txt)  # another global object that gets modified

root = tk.Tk()

btn = tk.Button(root, text="My Button")
btn['command'] = text_mod

btn.pack(fill='both', expand=True)

root.mainloop()
</code></pre>
<hr/>
<p><a href="https://stackoverflow.com/a/47980499/7032856">Mirror</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The reason it invokes the method immediately and pressing the button does nothing is that <code>action(somenumber)</code> is evaluated and its return value is attributed as the command for the button. So if <code>action</code> prints something to tell you it has run and returns <code>None</code>, you just run <code>action</code> to evaluate its return value and given <code>None</code> as the command for the button.</p>
<p>To have buttons to call functions with different arguments you can use global variables, although I can't recommend it:</p>
<pre><code>import Tkinter as Tk

frame = Tk.Frame(width=5, height=2, bd=1, relief=Tk.SUNKEN)
frame.grid(row=2,column=2)
frame.pack(fill=Tk.X, padx=5, pady=5)
def action():
    global output
    global variable
    output.insert(Tk.END,variable.get())
button = Tk.Button(master=frame, text='press', command=action)
button.pack()
variable = Tk.Entry(master=frame)
variable.pack()
output = Tk.Text(master=frame)
output.pack()

if __name__ == '__main__':
    Tk.mainloop()
</code></pre>
<p>What I would do is make a <code>class</code> whose objects would contain every variable required and methods to change those as needed:</p>
<pre><code>import Tkinter as Tk
class Window:
    def __init__(self):
        self.frame = Tk.Frame(width=5, height=2, bd=1, relief=Tk.SUNKEN)
        self.frame.grid(row=2,column=2)
        self.frame.pack(fill=Tk.X, padx=5, pady=5)

        self.button = Tk.Button(master=self.frame, text='press', command=self.action)
        self.button.pack()

        self.variable = Tk.Entry(master=self.frame)
        self.variable.pack()

        self.output = Tk.Text(master=self.frame)
        self.output.pack()

    def action(self):
        self.output.insert(Tk.END,self.variable.get())

if __name__ == '__main__':
    window = Window()
    Tk.mainloop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One simple way would be to configure <code>button</code> with <code>lambda</code> like the following syntax:</p>
<pre><code>button['command'] = lambda arg1 = local_var1, arg2 = local_var2 : function(arg1, arg2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>button = Tk.Button(master=frame, text='press', command=lambda: action(someNumber))
</code></pre>
<p>I believe should fix this</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a lambda to pass the entry data to the command function if you have more actions to carry out, like this (I've tried to make it generic, so just adapt):</p>
<pre><code>event1 = Entry(master)
button1 = Button(master, text="OK", command=lambda: test_event(event1.get()))

def test_event(event_text):
    if not event_text:
        print("Nothing entered")
    else:
        print(str(event_text))
        #  do stuff
</code></pre>
<p>This will pass the information in the event to the button function. There may be more Pythonesque ways of writing this, but it works for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>JasonPy - a few things... </p>
<p>if you stick a button in a loop it will be created over and over and over again... which is probably not what you want. (maybe it is)...</p>
<p>The reason it always gets the last index is lambda events run when you click them - not when the program starts. I'm not sure 100% what you are doing but maybe try storing the value when it's made then call it later with the lambda button. </p>
<p>eg: (don't use this code, just an example)</p>
<pre><code>for entry in stuff_that_is_happening:
    value_store[entry] = stuff_that_is_happening
</code></pre>
<p>then you can say....</p>
<pre><code>button... command: lambda: value_store[1]
</code></pre>
<p>hope this helps!  </p>
</div>
<div class="post-text" itemprop="text">
<p>For posterity: you can also use classes to achieve something similar. For instance:</p>
<pre><code>class Function_Wrapper():
    def __init__(self, x, y, z):
        self.x, self.y, self.z = x, y, z
    def func(self):
        return self.x + self.y + self.z # execute function
</code></pre>
<p>Button can then be simply created by:</p>
<pre><code>instance1 = Function_Wrapper(x, y, z)
button1  = Button(master, text = "press", command = instance1.func)
</code></pre>
<p>This approach also allows you to change the function arguments by i.e. setting <code>instance1.x = 3</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Building on Matt Thompsons answer : a class can be made callable so it can be used instead of a function:</p>
<pre><code>import tkinter as tk

class Callback:
    def __init__(self, func, *args, **kwargs):
        self.func = func
        self.args = args
        self.kwargs = kwargs
    def __call__(self):
        self.func(*self.args, **self.kwargs)

def default_callback(t):
    print("Button '{}' pressed.".format(t))

root = tk.Tk()

buttons = ["A", "B", "C"]

for i, b in enumerate(buttons):
    tk.Button(root, text=b, command=Callback(default_callback, b)).grid(row=i, column=0)

tk.mainloop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best thing to do is use lambda as follows:</p>
<pre><code>button = Tk.Button(master=frame, text='press', command=lambda: action(someNumber))
</code></pre>
</div>
<span class="comment-copy">frame = Tk.Frame(master=win).grid(row=1, column=1) #  Q. what is the value of frame now ?</span>
<span class="comment-copy">You're still writing wrapper methods, you're just doing it inline.</span>
<span class="comment-copy">This doesn't work if <i>someNumber</i> is in fact a variable that changes values inside a loop that creates many buttons. Then each button will call action() with the last value that has been assigned to <i>someNumber</i> and not the value it had when the button was created. The solution using <code>partial</code> works in this case.</span>
<span class="comment-copy">This worked great for me. However, can you also explain why the OPs statement of <code>"This just invokes the method immediately, and pressing the button does nothing"</code> happens?</span>
<span class="comment-copy">@Scrontch I wonder how many novice Tkinter users never felt in the trap you mentioned! At any rate one can <i>capture</i> the current value using the idiom <code>callback=lambda x=x: f(x)</code> as in <code>fs = [lambda x=x: x*2 for x in range(5)] ; print [f() for f in fs]</code></span>
<span class="comment-copy">@Voo what do you mean above with "although old school python people will probably stick to the default parameter assignment for the lambda"? I did not get lambda to work and thus now use partial.</span>
<span class="comment-copy">Or even shorter: <code>button = Tk.Button(master=frame, text='press', command=partial(action, arg))</code></span>
<span class="comment-copy">This does not solve the problem. What if you are creating three buttons that all call the same function but need to pass different arguments?</span>
<span class="comment-copy">You can create a function Which returns a function.</span>
<span class="comment-copy">I know this isn't active any more but I linked to here from <a href="http://stackoverflow.com/questions/35616411/tkinter-going-back-and-forth-between-frames-using-buttons/35636241#35636241" title="tkinter going back and forth between frames using buttons">stackoverflow.com/questions/35616411/â€¦</a>, this works the exact same way as using lambda expressions, you can define a function for each button in the same way as making a lambda expression for each button.</span>
<span class="comment-copy">putting the first code example in a loop that keeps changing <code>myX</code> and <code>myY</code> works perfectly thank you very much.</span>
