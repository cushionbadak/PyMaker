<div class="post-text" itemprop="text">
<p>What is the standard way of making a class comparable in Python 3?  (For example, by id.)</p>
</div>
<div class="post-text" itemprop="text">
<p>For a full set of comparison functions I have used the following mixin, which you could put in say for example a mixin.py in your module.</p>
<pre><code>class ComparableMixin(object):
    def _compare(self, other, method):
        try:
            return method(self._cmpkey(), other._cmpkey())
        except (AttributeError, TypeError):
            # _cmpkey not implemented, or return different type,
            # so I can't compare with "other".
            return NotImplemented

    def __lt__(self, other):
        return self._compare(other, lambda s, o: s &lt; o)

    def __le__(self, other):
        return self._compare(other, lambda s, o: s &lt;= o)

    def __eq__(self, other):
        return self._compare(other, lambda s, o: s == o)

    def __ge__(self, other):
        return self._compare(other, lambda s, o: s &gt;= o)

    def __gt__(self, other):
        return self._compare(other, lambda s, o: s &gt; o)

    def __ne__(self, other):
        return self._compare(other, lambda s, o: s != o)
</code></pre>
<p>To use the mixin above you need to implement a _cmpkey() method that returns a key of objects that can be compared, similar to the key() function used when sorting. The implementation could look like this:</p>
<pre><code>&gt;&gt;&gt; from .mixin import ComparableMixin

&gt;&gt;&gt; class Orderable(ComparableMixin):
...
...     def __init__(self, firstname, lastname):
...         self.first = firstname
...         self.last = lastname
...
...     def _cmpkey(self):
...         return (self.last, self.first)
...
...     def __repr__(self):
...         return "%s %s" % (self.first, self.last)
...
&gt;&gt;&gt; sorted([Orderable('Donald', 'Duck'), 
...         Orderable('Paul', 'Anka')])
[Paul Anka, Donald Duck]
</code></pre>
<p>The reason I use this instead of the total_ordering recipe is <a href="http://bugs.python.org/issue10042" rel="nofollow">this bug</a>. It's fixed in Python 3.4, but often you need to support older Python versions as well.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>sort</code> needs only <code>__lt__</code>. </p>
<p><a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow noreferrer"><code>functools.total_ordering</code></a> (as of 2.7 / 3.2) is a decorator that provides all of the comparison operators so you don't have to write all of them yourself.</p>
<p>By default, classes are hashable, and this uses their <code>id()</code>; I'm not sure why you'd want to order classes by their <code>id()</code> unless you just wanted the order to be stable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if this is complete, but you'd want to define:</p>
<pre><code>__eq__, __gt__, __ge__, __lt__, __le__
</code></pre>
<p>As <a href="https://stackoverflow.com/users/500584/agf">agf</a> said, I'm missing:</p>
<pre><code>__ne__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You said you are trying to do this:</p>
<pre><code>max((f(obj), obj) for obj in obj_list)[1]
</code></pre>
<p>You should simply do this:</p>
<pre><code>max(f(obj) for obj in obj_list)
</code></pre>
<p>EDIT: Or as gnibbler said:  <code>max(obj_list, key=f)</code></p>
<p>But you told gnibbler you need an object reference to the max object.  I think this is simplest:</p>
<pre><code>def max_obj(obj_list, max_fn):
    if not obj_list:
        return None

    obj_max = obj_list[0]
    f_max = max_fn(obj)

    for obj in obj_list[1:]:
        if max_fn(obj) &gt; f_max:
            obj_max = obj
    return obj_max

obj = max_obj(obj_list)
</code></pre>
<p>Of course you might want to let it raise an exception rather than return none if you try to find the max_obj() of an empty list.</p>
</div>
<div class="post-text" itemprop="text">
<p>I just thought of a really hackish way to do it.  This is in the same spirit as what you were originally trying to do.  It does not require adding any functions to the class object; it works for any class.</p>
<pre><code>max(((f(obj), obj) for obj in obj_list), key=lambda x: x[0])[1]
</code></pre>
<p>I really don't like that, so here's something less terse that does the same thing:</p>
<pre><code>def make_pair(f, obj):
    return (f(obj), obj)

def gen_pairs(f, obj_list):
    return (make_pair(f, obj) for obj in obj_list)

def item0(tup):
    return tup[0]

def max_obj(f, obj_list):
    pair = max(gen_pairs(f, obj_list), key=item0)
    return pair[1]
</code></pre>
<p>Or, you could use this one-liner if <code>obj_list</code> is always an indexable object like a list:</p>
<pre><code>obj_list[max((f(obj), i) for i, obj in enumerate(obj_list))[1]]
</code></pre>
<p>This has the advantage that if there are multiple objects such that <code>f(obj)</code> returns an identical value, you know which one you will get: the one with the highest index, i.e. the latest one in the list.  If you wanted the earliest one in the list, you could do that with a key function.</p>
</div>
<span class="comment-copy">Uh, why would you want to sort by the arbitrarily assigned memory address of your class?</span>
<span class="comment-copy">sure you <b>could</b>, but would it make sense to order things by their memory locations?</span>
<span class="comment-copy">@Tim: Because I am doing: <code>max((f(obj), obj) for obj in obj_list)[1]</code> to get the obj with the highest value according to <code>f</code>.  Python 3 complains that obj is not comparable.  I don't really care how it's compared.</span>
<span class="comment-copy">Surely you mean to say <code>max(obj_list, key=f)</code> instead of that monstrosity</span>
<span class="comment-copy">@gnibbler: Thanks!!  But what if I want both the <code>obj</code> as well as <code>f(obj)</code>?</span>
<span class="comment-copy">It's worth pointing out to anyone finding this answer that the <code>mixin</code> module is a hypothetical module one could define â€” it's not in the Python standard library.</span>
<span class="comment-copy">Yeah, clarified this.</span>
<span class="comment-copy">The bug has now been fixed.   Would you mind updating your answer or adding a new one?</span>
<span class="comment-copy">Updated, thanks!</span>
<span class="comment-copy">Thank you!  So, in Python &gt;3.4, you would recommend applying the decorator <code>functools.total_ordering</code>?</span>
<span class="comment-copy">+1 Just want to mention for anyone else searching this decorator is available as <code>functools.total_ordering</code>.</span>
<span class="comment-copy">@Neil G : + everyone else: Also be aware that that decorator has bugs, and shouldn't be used if you ever expect anyone to compare your class with any other class <a href="http://bugs.python.org/issue10042" rel="nofollow noreferrer">bugs.python.org/issue10042</a> My preferred method is a mixin: <a href="http://python3porting.com/preparing.html#comparatively-tricky" rel="nofollow noreferrer">python3porting.com/preparing.html#comparatively-tricky</a></span>
<span class="comment-copy">@Lennart: Please add an answer.  I did notice that mixin.  Why wasn't it added to the Python standard library like the decorator?</span>
<span class="comment-copy">@Neil G: Well, it's not old and widely used enough.</span>
<span class="comment-copy">Besides, not everyone likes multiple inheritance...</span>
<span class="comment-copy">Isn't there a way to have most of these automatically defined with a mixin?</span>
<span class="comment-copy">@Neil: And how would the mixin define them?</span>
<span class="comment-copy">See the decorator recipe in my answer. Also, the other comparison is <code>__ne__</code>, not equal.</span>
<span class="comment-copy">@Ignacio: Perhaps if one is defined, it could use it to define the rest?</span>
<span class="comment-copy">never used mixins, sorry can't help there. I'm still a little unsure of myself with Python3 as well, mostly continuing using Python2.</span>
<span class="comment-copy">The first version breaks ties with the object itself.</span>
<span class="comment-copy">Yes, I didn't quite grok what you were doing when I wrote the first version.  I think I have it now.</span>
<span class="comment-copy">Did you really need to post two separate answers? They're both doing the same thing, and both are way less clear than the original <code>max((f(obj), obj) for obj in obj_list)</code></span>
<span class="comment-copy">Do you consider it some sort of breach of etiquette to post two completely different answers as two separate answers?  And do you really think they are doing the same thing?  One calls max() with a key, the other is a for loop; how are they doing the same thing?  And I am not sure I agree my solutions are less clear.  By the way, you left off the <code>[1]</code> from his answer, which was tricky enough it fooled me the first time I read it.</span>
