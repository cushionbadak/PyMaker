<div class="post-text" itemprop="text">
<p>I have a big script in Python. I inspired myself in other people's code so I ended up using the <code>numpy.random</code> module for some things (for example for creating an array of random numbers taken from a binomial distribution) and in other places I use the module <code>random.random</code>.</p>
<p>Can someone please tell me the major differences between the two?
Looking at the doc webpage for each of the two it seems to me that <code>numpy.random</code> just has more methods, but I am unclear about how the generation of the random numbers is different.</p>
<p>The reason why I am asking is because I need to seed my main program for debugging purposes. But it doesn't work unless I use the same random number generator in all the modules that I am importing, is this correct?</p>
<p>Also, I read here, in another post, a discussion about NOT using <code>numpy.random.seed()</code>, but I didn't really understand why this was such a bad idea. I would really appreciate if someone explain me why this is the case.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have made many correct observations already!</p>
<p>Unless you'd like to seed both of the random generators, it's probably simpler in the long run to choose one generator or the other. </p>
<p>For <code>numpy.random.seed()</code>, the main difficulty is that it is not thread-safe - that is, it's not safe to use if you have <a href="http://www.prasannatech.net/2008/08/introduction-to-thread-programming.html" rel="noreferrer">many different threads of execution</a>, because it's not guaranteed to work if two different threads are executing the function at the same time. If you're not using threads, and if you can reasonably expect that you won't need to rewrite your program this way in the future, <code>numpy.random.seed()</code> should be fine.  If there's any reason to suspect that you may need threads in the future, it's much safer in the long run to do as suggested, and to <a href="https://stackoverflow.com/questions/5836335/consistenly-create-same-random-numpy-array/5837352#5837352">make a local instance of the <code>numpy.random.Random</code> class</a>. As far as I can tell, <code>random.random.seed()</code> is thread-safe (or at least, I haven't found any evidence to the contrary).</p>
<p>The <code>numpy.random</code> library contains a few extra probability distributions commonly used in scientific research, as well as a couple of convenience functions for generating arrays of random data. The <code>random.random</code> library is a little more lightweight, and should be fine if you're not doing scientific research or other kinds of work in statistics.</p>
<p>Otherwise, they both use the <a href="http://en.wikipedia.org/wiki/Mersenne_twister" rel="noreferrer">Mersenne twister sequence</a> to generate their random numbers, and they're both completely deterministic - that is, if you know a few key bits of information, it's possible to predict with absolute certainty <a href="https://jazzy.id.au/2010/09/22/cracking_random_number_generators_part_3.html" rel="noreferrer">what number will come next</a>. For this reason, neither numpy.random nor random.random is suitable for any <a href="https://www.bishopfox.com/blog/2014/08/untwisting-mersenne-twister-killed-prng/" rel="noreferrer">serious cryptographic uses</a>. But because the sequence is so very very long, both are fine for generating random numbers in cases where you aren't worried about people trying to reverse-engineer your data. This is also the reason for the necessity to seed the random value - if you start in the same place each time, you'll always get the same sequence of random numbers!</p>
<p>As a side note, if you <em>do</em> need cryptographic level randomness, you should use the <a href="https://docs.python.org/3/library/secrets.html" rel="noreferrer">secrets</a> module, or something like <a href="https://www.dlitz.net/software/pycrypto/api/current/Crypto.Random.random-module.html" rel="noreferrer">Crypto.Random</a> if you're using a Python version earlier than Python 3.6.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="http://shop.oreilly.com/product/0636920023784.do" rel="noreferrer">Python for Data Analysis</a>, the module <code>numpy.random</code> supplements the Python <code>random</code> with functions for efficiently generating whole arrays of sample values from many kinds of probability distributions.</p>
<p>By contrast, Python's built-in <code>random</code> module only samples one value at a time, while <code>numpy.random</code> can generate very large sample faster. Using IPython magic function <code>%timeit</code> one can see which module performs faster:</p>
<pre><code>In [1]: from random import normalvariate
In [2]: N = 1000000

In [3]: %timeit samples = [normalvariate(0, 1) for _ in xrange(N)]
1 loop, best of 3: 963 ms per loop

In [4]: %timeit np.random.normal(size=N)
10 loops, best of 3: 38.5 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The source of the seed and the distribution profile used are going to affect the outputs - if you are looking for cryptgraphic randomness, seeding from os.urandom() will get nearly real random bytes from device chatter (ie ethernet or disk) (ie /dev/random on BSD)</p>
<p>this will avoid you giving a seed and so generating determinisitic random numbers.  However the random calls then allow you to fit the numbers to a distribution (what I call scientific random ness - eventually all you want is a bell curve distribution of random numbers, numpy is best at delviering this.</p>
<p>SO yes, stick with one generator, but decide what random you want - random, but defitniely from a distrubtuion curve, or as random as you can get without a quantum device.</p>
</div>
<span class="comment-copy">As a distantly related note, it's sometimes neccesary to use <i>neither</i>, since the Mersenne twister does not produce random sequences of entropy sufficient for cryptographic (and some unusual scientific) purposes.  In those rare cases, you often need <a href="https://www.dlitz.net/software/pycrypto/apidoc/Crypto.Random.random-module.html" rel="nofollow noreferrer">Crypto.Random</a>, which is able to use OS specific entropy sources to generate non-deterministic random sequences of much higher quality than is available from <code>random.random</code> alone.  You usually don't need this, though.</span>
<span class="comment-copy">Thank you Hannnele. Your insights were really very useful! It turns out that I cannot get away with using ONLY a single random number generator, (which needs to be numpy since random doesn't produce binomial distributions) because parts of my program call another program which uses random. I will have to seed the two generators.</span>
<span class="comment-copy">"if you know which number you have now, it's possible to predict with absolute certainty what number will come next." I think this statement might need some clarification. What is meant is that if you know the <i>internal state</i> of the generator you can reproduce the sequence - which is what you do when you seed the generator. Given a single number output from the generator you can not predict the next number. The period is so large you would probably need a long sequence of numbers before you could compute where you are on the pseudo-random sequence and thus predict the next one.</span>
<span class="comment-copy">@KaushikGhose Thanks, I have updated the answer.</span>
<span class="comment-copy">Thank you very much Paul, your answer was really useful! I am not looking for cryptographic randomness, I am doing mathematical modeling and pseudo-random numbers are enough for me. It turns out I cannot stick to one generator as I wanted since I need numpy for the binomial distribution and my program calls another program that uses random :(</span>
