<div class="post-text" itemprop="text">
<p>Say I have this list:</p>
<pre><code>li = ["a", "b", "a", "c", "x", "d", "a", "6"]
</code></pre>
<p>As far as help showed me, there is not a builtin function that returns the last occurrence of a string (like the reverse of <code>index</code>). So basically, how can I find the last occurrence of <code>"a"</code> in the given list?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are actually using just single letters like shown in your example, then <a href="https://docs.python.org/3/library/stdtypes.html#str.rindex" rel="nofollow noreferrer"><code>str.rindex</code></a> would work handily.  This raises a <code>ValueError</code> if there is no such item, the same error class as <code>list.index</code> would raise. Demo:</p>
<pre><code>&gt;&gt;&gt; li = ["a", "b", "a", "c", "x", "d", "a", "6"]
&gt;&gt;&gt; ''.join(li).rindex('a')
6
</code></pre>
<p>For the more general case you could use <code>list.index</code> on the reversed list: </p>
<pre><code>&gt;&gt;&gt; len(li) - 1 - li[::-1].index('a')
6
</code></pre>
<p>The slicing here creates a <em>copy</em> of the entire list. That's fine for short lists, but for the case where <code>li</code> is very large, efficiency can be better with a lazy approach:</p>
<pre><code>def list_rindex(li, x):
    for i in reversed(range(len(li))):
        if li[i] == x:
            return x
    raise ValueError("{} is not in list".format(x))
</code></pre>
<p>One-liner version:</p>
<pre><code>next(i for i in reversed(range(len(li))) if li[i] == 'a')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A one-liner that's like Ignacio's except a little simpler/clearer would be</p>
<pre><code>max(loc for loc, val in enumerate(li) if val == 'a')
</code></pre>
<p>It seems very clear and Pythonic to me: you're looking for the highest index that contains a matching value. No nexts, lambdas, reverseds or itertools required. </p>
</div>
<div class="post-text" itemprop="text">
<p>Many of the other solutions require iterating over the entire list.  This does not.</p>
<pre><code>def find_last(lst, elm):
  gen = (len(lst) - 1 - i for i, v in enumerate(reversed(lst)) if v == elm)
  return next(gen, None)
</code></pre>
<p>Edit: In hindsight this seems like unnecessary wizardry.  I'd do something like this instead:</p>
<pre><code>def find_last(lst, sought_elt):
    for r_idx, elt in enumerate(reversed(lst)):
        if elt == sought_elt:
            return len(lst) - 1 - r_idx
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I like both <a href="https://stackoverflow.com/questions/6890170/python-how-to-find-last-occurrence-in-a-list-in-python/6890255#6890255">wim's</a> and <a href="https://stackoverflow.com/questions/6890170/python-how-to-find-last-occurrence-in-a-list-in-python/6890187#6890187">Ignacio's</a> answers. However, I think <code>itertools</code> provides a slightly more readable alternative, lambda notwithstanding. (For Python 3; for Python 2, use <code>xrange</code> instead of <code>range</code>).</p>
<pre><code>&gt;&gt;&gt; from itertools import dropwhile
&gt;&gt;&gt; l = list('apples')
&gt;&gt;&gt; l.index('p')
1
&gt;&gt;&gt; next(dropwhile(lambda x: l[x] != 'p', reversed(range(len(l)))))
2
</code></pre>
<p>This will raise a <code>StopIteration</code> exception if the item isn't found; you could catch that and raise a <code>ValueError</code> instead, to make this behave <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer">just like <code>index</code></a>.</p>
<p>Defined as a function, avoiding the <code>lambda</code> shortcut:</p>
<pre><code>def rindex(lst, item):
    def index_ne(x):
        return lst[x] != item
    try:
        return next(dropwhile(index_ne, reversed(range(len(lst)))))
    except StopIteration:
        raise ValueError("rindex(lst, item): item not in list")
</code></pre>
<p>It works for non-chars too. Tested:</p>
<pre><code>&gt;&gt;&gt; rindex(['apples', 'oranges', 'bananas', 'apples'], 'apples')
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; (x for x in reversed([y for y in enumerate(li)]) if x[1] == 'a').next()[0]
6

&gt;&gt;&gt; len(li) - (x for x in (y for y in enumerate(li[::-1])) if x[1] == 'a').next()[0] - 1
6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the fact that dictionary keys are unique and when building one with tuples only the last assignment of a value for a particular key will be used.  As stated in other answers, this is fine for small lists but it creates a dictionary for all unique values and might not be efficient for large lists.</p>
<pre><code>dict(map(reversed, enumerate(li)))["a"]

6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I came here hoping to find someone had already done the work of writing the most efficient version of <code>list.rindex</code>, which provided the full interface of <code>list.index</code> (including optional <code>start</code> and <code>stop</code> parameters). I didn't find  that in the answers to this question, or <a href="https://stackoverflow.com/questions/522372">here</a>, or <a href="https://stackoverflow.com/questions/9836425">here</a>, or <a href="https://stackoverflow.com/questions/12985096">here</a>. So I put this together myself... making use of suggestions from other answers to this and the other questions.</p>
<pre><code>def rindex(seq, value, start=None, stop=None):
  """L.rindex(value, [start, [stop]]) -&gt; integer -- return last index of value.
  Raises ValueError if the value is not present."""
  start, stop, _ = slice(start, stop).indices(len(seq))
  if stop == 0:
    # start = 0
    raise ValueError('{!r} is not in list'.format(value))
  else:
    stop -= 1
    start = None if start == 0 else start - 1
  return stop - seq[stop:start:-1].index(value)
</code></pre>
<p>The technique using <code>len(seq) - 1 - next(i for i,v in enumerate(reversed(seq)) if v == value)</code>, suggested in several other answers, can be more space-efficient: it needn't create a reversed copy of the full list. But in my (offhand, casual) testing, it's about 50% slower.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a simple loop:</p>
<pre><code>def reversed_index(items, value):
    for pos, curr in enumerate(reversed(items)):
        if curr == value:
            return len(items) - pos - 1
    raise ValueError("{0!r} is not in list".format(value))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>last_occurence=len(yourlist)-yourlist[::-1].index(element)-1
</code></pre>
<p>just easy as that.no need to import or create a function.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def rindex(lst, val):
    try:
        return next(len(lst)-i for i, e in enumerate(reversed(lst), start=1) if e == val)
    except StopIteration:
        raise ValueError('{} is not in list'.format(val))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>val = [1,2,2,2,2,2,4,5].</p>
<p>If you need to find last occurence of 2</p>
<p><code>last_occurence = (len(val) -1) - list(reversed(val)).index(2)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a little one-liner for obtaining the last index, using <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> and a list comprehension:</p>
<pre><code>li = ["a", "b", "a", "c", "x", "d", "a", "6"]
[l[0] for l in enumerate(li) if l[1] == "a"][-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from array import array
fooa = array('i', [1,2,3])
fooa.reverse()  # [3,2,1]
fooa.index(1)
&gt;&gt;&gt; 2
</code></pre>
</div>
<span class="comment-copy">YMMV, but for this example, <code>len(li) - next(i for i, v in enumerate(reversed(li), 1) if v == 'a')</code> is a little faster for me</span>
<span class="comment-copy">Before other people also fall into into this trap: Use <code>range(len(li)-1, -1, -1)</code> instead of <code>range(len(li)-1, 0, -1)</code>, otherwise the first element will not be included.</span>
<span class="comment-copy">@Corrumpo  wow, that bug went unnoticed for more than 5 years.  Thanks for the comment, updated.</span>
<span class="comment-copy">there is <code>str.rindex()</code>, any reason there isn't <code>list.rindex()</code>?</span>
<span class="comment-copy">rather than <code>zip()</code> and <code>reversed()</code>: <code>next(i for i in range(len(li)-1, -1, -1) if li[i] == 'a')</code> ?</span>
<span class="comment-copy">As @Isaac points out this always iterates over all N elements of li.</span>
<span class="comment-copy">This is perfect. Maybe not ideal for a large data set but for small amount of data its great.</span>
<span class="comment-copy">a significant downside is the fact you will always iterate through the whole list. you should emphasis that in your answer.</span>
<span class="comment-copy">It would be very nice to make this small snippet python 3 compatible.</span>
<span class="comment-copy">@AskingQuestions: Thanks! done.</span>
<span class="comment-copy">Python 3 now permits a default arg to <code>next</code>, so you can eliminate the <code>try... except</code></span>
<span class="comment-copy">@PM2Ring, I don't know why you'd want to use a default arg here though. Then you'd need to have an <code>if</code> statement and raise a <code>ValueError</code> inside that. (Recall that we're trying to duplicate the <code>index</code> API exactly, which means raising a <code>ValueError</code> if the item can't be found.) Using <code>try</code> in this context is more idiomatic and, I would guess, more efficient.</span>
<span class="comment-copy">Fair call. Maybe raise <code>IndexError</code> rather than <code>ValueError</code>, to be consistent with <code>.index</code> ?</span>
<span class="comment-copy">Why not <code>reversed(enumerate(li))</code>?</span>
<span class="comment-copy">Because it didn't occur to me 3 years ago.</span>
<span class="comment-copy">Weirdly though, <code>reversed(enumerate(li))</code> results in an error that reads <code>argument to reversed() must be a sequence</code>! And it says that for <code>reversed((y for y in enumarete(li))</code> too!</span>
<span class="comment-copy">Makes sense that <code>reversed()</code> cannot operate on iterators in general, including generators. So, <code>enumerate(reversed(li))</code> and adjusting the index component of the enumerated tuples is a workaround that avoids creating a copy of the list.</span>
<span class="comment-copy">Welcome to Stack Overflow! Please don't answer just with source code. Try to provide a nice description about how your solution works. See: <a href="https://stackoverflow.com/help/how-to-answer">How do I write a good answer?</a>. Thanks</span>
