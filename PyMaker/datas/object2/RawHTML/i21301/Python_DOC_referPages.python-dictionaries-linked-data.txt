<div class="post-text" itemprop="text">
<pre><code>d1 = {"dog":"woof", "cat":"meow"}
d2 = d1
d2["dog"] = "bark"
for i in d1:
    print(i, d1[i])

dog bark
cat meow
</code></pre>
<p>What's the best way to do it so:</p>
<pre><code>dog woof
cat meow
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>d1 = {"dog":"woof", "cat":"meow"}
d2 = d1.copy() # make a copy, not a reference to the same dictionary
d2["dog"] = "bark"
for i in d1:
    print(i, d1[i])

# dog woof
# cat meow
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>d1</code> and <code>d2</code> point to the same object in the memory and therefore changing values in <code>d2</code> will affect <code>d1</code> as well.</p>
<pre><code>d1 = {}
d2 = d1
print id(d1) == id(d2)
# out: True
</code></pre>
<p>Use the copy-method of the dictionary-class or the copy-module.</p>
<pre><code>d2 = d1.copy()
</code></pre>
<p></p>
<pre><code>from copy import copy
d2 = copy(d1)
</code></pre>
<p>If you have mutable objects stored in the dictionary (i.e. lists) and want to copy theese as well, you should use the deepcopy-function.</p>
<pre><code>from copy import deepcopy
d2 = deepcopy(d1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/stdtypes.html#dict.copy" rel="nofollow">Copy</a> the dictionary:</p>
<pre><code>d2 = d1.copy() # instead of d2 = d1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In your case, both <code>d1</code> and <code>d2</code> refer to same object. You can create copy of the original dict by :</p>
<ol>
<li>using <code>d1.copy()</code></li>
<li>using <code>copy.copy(d1)</code></li>
<li>using <code>dict(d1)</code></li>
<li>using <code>copy.deepcopy(d1)</code></li>
</ol>
<p>1,2,3 will create shallow copies and 4 will create a deep copy</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd like to propose a better way to do this.</p>
<pre><code>from collections import ChainMap
d1 = {"dog":"woof", "cat":"meow"}
d2 = ChainMap({}, d1)
d2["dog"] = "bark"

for i in d1:
    print(i, d1[i])
# dog woof
# cat meow

for i in d2:
    print(i, d2[i])
# dog bark
# cat meow
</code></pre>
<p>Please read ChainMap's reference: <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer">https://docs.python.org/3/library/collections.html#collections.ChainMap</a></p>
<p>If you're using python2, to implement the ChainMap, use this minimal code recipe: <a href="https://code.activestate.com/recipes/305268/" rel="nofollow noreferrer">https://code.activestate.com/recipes/305268/</a></p>
</div>
<span class="comment-copy">You can also use slice notation. Have to double-check (on mobile), but something like [:] used after the item you want the copy of.</span>
<span class="comment-copy">Interesting, why do you think this way is better than dictionaries?</span>
<span class="comment-copy">Hi SCD. It is neither better nor worse than dictionaries because ChainMap is a dictionary. To be more precise, underneath the abstraction, it's a list of dictionaries.</span>
<span class="comment-copy">Most of the time it's a proper choice, because the original dictionary may be any size and it does not affect you. Especially if you're changing only few entries in the data.</span>
