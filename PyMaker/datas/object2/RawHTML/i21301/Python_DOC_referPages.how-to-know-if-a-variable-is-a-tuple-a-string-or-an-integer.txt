<div class="post-text" itemprop="text">
<p>I am trying to figure out a type mismatch while adding a string to another string in a concatenate operation.</p>
<p>Basically the error returned is a <a href="https://docs.python.org/3/library/exceptions.html#TypeError" rel="noreferrer"><code>TypeError</code></a> (cannot concatenate string and tuple); so I would like to figure out where I assigned a value as tuple instead of string.</p>
<p>All the values that I assign are strings, so I gotta figure out where the tuple is coming from, so I was hoping that there is a way in Python to find out what is contained inside a variable and what type is it.</p>
<p>So far using <a href="https://docs.python.org/3/library/pdb.html" rel="noreferrer">pdb</a> I was able to check the content of the variables, and I get correctly the values that I would expect; but I would like to know also the type of the variable (by logic, if the compiler is able to raise a type error, it means that it knows what is inside a variable and if it is compatible with the operation to perform; so there must be a way to get that value/flag out).</p>
<p>Is there any way to print out the type of a variable in python?</p>
<p>BTW, I tried to change all my variables to be explicitly strings, but is not feasible to force <code>str (myvar)</code>, so I cannot just cast as string type everywhere I use strings.</p>
</div>
<div class="post-text" itemprop="text">
<p>You just use:</p>
<pre><code>type(varname)
</code></pre>
<p>which will output int, str, float, etc...</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>isinstance(obj, tuple)
isinstance(obj, basestring)
isinstance(obj, int)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>make use of isinstance ?</p>
<pre><code>if isinstance(var, int):

if isinstance(var, str):

if isinstance(var, tuple):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You probably want to test (assuming Python 2.x) using <code>isinstance(obj, basestring)</code>. You have the options of using <code>isinstance</code>, <code>type</code>, and calling the attribute <code>__class__</code>, but <code>isinstance</code> is likely to be the one you want here. Take a look at <a href="http://www.siafoo.net/article/56" rel="noreferrer">this article</a> for a more thorough treatment of the differences between the three options.</p>
</div>
<div class="post-text" itemprop="text">
<p>Please note, should you wanted to check your var type in if statement, the construct
<code>if type(varname) == "tuple":</code> won't work. But these will:</p>
<pre><code>if type(varname) is tuple:
if type(varname) is list:
if type(varname) is dict:
if type(varname) is int:
if type(varname) is str:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>repr(object) will give a textual description of object, which should show type and value. Your can print or view this in the debugger.</p>
<p>For simple values repr usually returns the same string as you would write the value literally in code. For custom classes it gives the class name and object id, or something else if the class'es</p>
<pre><code>__repr__
</code></pre>
<p>is overridden.</p>
</div>
<span class="comment-copy">Not wanting to be picky, but variables never have a type in Python, only objects (referenced by variables) do. Because of this there are no real type casts, only object conversion functions.</span>
<span class="comment-copy">Indeed Jurgen; I am not fully aware of how python works under the hood, but i assume that is an object oriented language, so when i create a variable it will create an object of the right datatype and reference it with a pointer, so when i use the variable i am in fact using an instance of the object string (or whatever other datatype). The end point thou is to get the type of that object :)</span>
<span class="comment-copy">Using <code>__class__</code> is almost always better than using <code>type</code> because in most situations, they'll return the same thing, except that <code>type</code> will declare the type of all old-style classes to be 'instance'. refer to <a href="http://stackoverflow.com/questions/1060499/difference-between-typeobj-and-obj-class">this SO question</a></span>
<span class="comment-copy">thanks for the reply; this is great for a check while running the program, but I am trying to get the value while debugging with pdb. This is a great way to avoid the problem!</span>
<span class="comment-copy">Testing for <code>str</code> will fail on <code>unicode</code> strings. Also, <code>isinstance(var, tuple)</code> will miss any variables that happen to be <code>list</code>s, which will often arise in situations such as these. Of course, you might want to error out if the var is an instance of a <code>list</code>, but it's good to be sure that you know what's going to happen in different situations.</span>
<span class="comment-copy">In Python 3 you can use a sequence of types to test: <code>isinstance(var, (tuple, list))</code></span>
<span class="comment-copy">Thanks Darren; I will probably do the testing using your suggestion, but at the moment i am using pdb; so I can figure out which one is the  problematic var and avoid to do the same mistake (I like defensive coding but at the same time i prefer to avoid to make a mistake in first instance, instead than relying on a check to catch a possible mistake ).  Interesting that there is also the <b>class</b> attribute; never heard of it.</span>
<span class="comment-copy">You should really use isinstance instead. type() is dangerous when it comes to inheritance.</span>
<span class="comment-copy">@bugmenot123, I'm not covering all the possible outcomes, I'm making note about the mistake that people usually do when trying to check for type and then got surprised when it's not working. Otherwise, you're absolutely right.</span>
<span class="comment-copy">Thanks for the reply Jurgen. I tried repr but it returns me the value of the variable *in my case the string), so it does the same that p(varname) does...am I doing something wrong, since I should see as you mentioned, type, value and description of the object?</span>
<span class="comment-copy">No. It returns a string literal for a str or unicode, <i>including</i> the quotes, so you should recognize it as that type. It returns unquoted digits for integer types and similiar for other numeric types. For a custom class A, it returns something like &lt;mymodule.A instance at 0x123456&gt; by default, but some classes overwrite this description string.</span>
<span class="comment-copy">I see; indeed it is really useful, thanks a lot!!</span>
