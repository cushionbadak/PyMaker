<div class="post-text" itemprop="text">
<p>I need to pass  a file path name to a module which creates a report document as pdf,html etc.How do I build the file path name from a directory name,base file name and a fileformat string ?</p>
<p>The directory may or may not exist at the time of call</p>
<p>for example</p>
<pre><code>dir_name='/home/me/dev/my_reports'
base_filename='daily_report'
format = 'pdf'
</code></pre>
<p>I need to create a string <code>'/home/me/dev/my_reports/daily_report.pdf'</code> </p>
<p>concatenating the pieces manually didn't seem to be a good way.
I tried os.path.join</p>
<pre><code>join(dir_name,base_filename,format)
</code></pre>
<p>but it gives</p>
<pre><code>'/home/me/dev/my_reports/daily_report/pdf'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This works fine:</p>
<pre><code>os.path.join(dir_name, base_filename + "." + filename_suffix)
</code></pre>
<p>Keep in mind that <code>os.path.join()</code> exists only because different operating systems use different path separator characters. It smooths over that difference so cross-platform code doesn't have to be cluttered with special cases for each OS. There is no need to do this for file name "extensions" (see footnote) because they are always connected to the rest of the name with a dot character, on every OS.</p>
<p>If using a function anyway makes you feel better (and you like needlessly complicating your code), you can do this:</p>
<pre><code>os.path.join(dir_name, '.'.join((base_filename, filename_suffix)))
</code></pre>
<p>If you prefer to keep your code clean, simply include the dot in the suffix:</p>
<pre><code>suffix = '.pdf'
os.path.join(dir_name, base_filename + suffix)
</code></pre>
<hr/>
<p>Footnote: There is no such thing as a file name "extension" on non-Micorsoft operating systems. Its presence on Windows comes from MS-DOS and FAT, which borrowed it from CP/M, which has been dead for decades. That dot-plus-three-letters that many of us are accustomed to seeing is just part of the file name on every other modern OS, where it has no built-in meaning.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are fortunate enough to be running Python 3.4+, you can use <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a>:</p>
<pre><code>&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; dirname = '/home/reports'
&gt;&gt;&gt; filename = 'daily'
&gt;&gt;&gt; suffix = '.pdf'
&gt;&gt;&gt; Path(dirname, filename).with_suffix(suffix)
PosixPath('/home/reports/daily.pdf')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Um, why not just:</p>
<pre><code>&gt;&gt;&gt;&gt; import os
&gt;&gt;&gt;&gt; os.path.join(dir_name, base_filename + "." + format)
'/home/me/dev/my_reports/daily_report.pdf'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just use <a href="https://docs.python.org/3.4/library/os.path.html#os.path.join" rel="nofollow noreferrer"><code>os.path.join</code></a> to join your path with the filename and extension. Use <a href="https://docs.python.org/3.4/library/sys.html#sys.argv" rel="nofollow noreferrer"><code>sys.argv</code></a> to access arguments passed to the script when executing it:</p>
<pre><code>#!/usr/bin/env python3
# coding: utf-8

# import netCDF4 as nc
import numpy as np
import numpy.ma as ma
import csv as csv

import os.path
import sys

basedir = '/data/reu_data/soil_moisture/'
suffix = 'nc'


def read_fid(filename):
    fid = nc.MFDataset(filename,'r')
    fid.close()
    return fid

def read_var(file, varname):
    fid = nc.Dataset(file, 'r')
    out = fid.variables[varname][:]
    fid.close()
    return out


if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('Please specify a year')

    else:
        filename = os.path.join(basedir, '.'.join((sys.argv[1], suffix)))
        time = read_var(ncf, 'time')
        lat = read_var(ncf, 'lat')
        lon = read_var(ncf, 'lon')
        soil = read_var(ncf, 'soilw')
</code></pre>
<p>Simply run the script like:</p>
<pre><code>   # on windows-based systems
   python script.py year

   # on unix-based systems
   ./script.py year
</code></pre>
</div>
<span class="comment-copy">You mentioned that the OS separator may not be <code>.</code>. For this one can use <code>os.extsep</code>.</span>
<span class="comment-copy">I mentioned no such thing.</span>
<span class="comment-copy">You went to some lengths to explain that 'File name "extensions" only have significant meaning on one major operating system (they're simply part of the file name on non-Windows systems), and their separator character is always a dot'. The OP also expressed they saw /pdf at the end. So you could have done <code>os.path.join(dir_name, base_filename, os.extsep, extension)</code>. Your answer is perfectly correct.</span>
<span class="comment-copy">Yeah, you're right, it gives back just a string so os.path.join(dir_name, ''.join([base_filename, os.extsep, extension])) should do it. Again, it doesn't undermine the correctness of your answer.</span>
<span class="comment-copy">os.path.join is the best solution on python</span>
<span class="comment-copy">thanks,but I was hoping there was a cleaner way of appending that extension..python even has a splitext function to cut off the extension..so there has to be something to do the reverse</span>
<span class="comment-copy">The splitext function retains the '.' at the front of the extension.  This is likely the cleanest way to do it.  If you want it to "look" cleaner in your code, I'd suggest using a function or a lambda function.</span>
