<div class="post-text" itemprop="text">
<p>I want to override my Python class's <code>__getattribute__</code> and <code>__setattr__</code> methods. My use case is the usual one: I have a few special names that I want to handle, and I want the default behavior for anything else. For <code>__getattribute__</code>, it seems that I can request the default behavior simply by raising <code>AttributeError</code>. However, how can I achieve the same in <code>__setattr__</code>? Here is a trivial example, implementing a class with immutable fields "A", "B", and "C".</p>
<pre><code>class ABCImmutable(SomeSuperclass):
    def __getattribute__(self, name):
        if name in ("A", "B", "C"):
            return "Immutable value of %s" % name
        else:
            # This should trigger the default behavior for any other
            # attribute name.
            raise AttributeError()

    def __setattr__(self, name, value):
        if name in ("A", "B", "C"):
            raise AttributeError("%s is an immutable attribute.")
        else:
            # How do I request the default behavior?
            ???
</code></pre>
<p>What goes in place of the question marks? With old-style classes, the answer was apparently <code>self.__dict__[name] = value</code>, but documentation indicates that this is wrong for new-style classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's</p>
<pre><code>super(ABCImmutable, self).__setattr__(name, value)
</code></pre>
<p>in Python 2, or</p>
<pre><code>super().__setattr__(name, value)
</code></pre>
<p>in Python 3.</p>
<p>Also, raising <code>AttributeError</code> is <strong>not</strong> how you fall back to the default behavior for <code>__getattribute__</code>. You fall back to the default with</p>
<pre><code>return super(ABCImmutable, self).__getattribute__(name)
</code></pre>
<p>on Python 2 or</p>
<pre><code>return super().__getattribute__(name)
</code></pre>
<p>on Python 3.</p>
<p>Raising <code>AttributeError</code> skips the default handling and goes to <code>__getattr__</code>, or just produces an <code>AttributeError</code> in the calling code if there's no <code>__getattr__</code>.</p>
<p>See the documentation on <a href="https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access" rel="noreferrer">Customizing Attribute Access</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>SomeSuperclass.__setattr__(self, name, value)</code> ?</p>
</div>
<span class="comment-copy">"documentation indicates that this is wrong for new-style classes"...and didn't it indicate what was right for new-style classes?</span>
<span class="comment-copy">Why aren't you just implementing your named fields as set-only properties?</span>
<span class="comment-copy">The immutability was just a trivial example use case for <b>setattr</b>. My actual use is a bit more complicated. My class inherits from dict, but in addition, certain special keys (determined at runtime) are accessible <code>object.key</code> instead of <code>object['key']</code>. I could probably add them as properties using runtime reflection or something, but it's easier to use <code>__getattr__</code> and <code>__setattr__</code>, and performance isn't particularly critical.</span>
<span class="comment-copy">By the way the reason why self.__dict__[name] = value wouldn't work is because you need to get the attribute self.__dict__ to do this, and thus cause infinite recursions.</span>
<span class="comment-copy">Close, but you don't need the second "self".  You'd call it like this:      super(ABCImmutable, self).__setattr__(name, value)  Otherwise you'll get the "expected 2 arguments, but got three" exception.</span>
<span class="comment-copy">Don't I need a call to <code>super</code> somewhere? At least in the general case?</span>
<span class="comment-copy">@Ryan Thompson I'm pretty sure you can use <code>super()</code> in place of <code>SomeSuperclass</code> but I'm trying to track down whether that is specific to Python 3.</span>
<span class="comment-copy">@Ryan Thompson Looking at the <a href="http://code.activestate.com/recipes/577721-how-to-use-super-effectively-python-27-version/" rel="nofollow noreferrer">Python 2 examples for Raymond Hettinger's "Python's super() considered super!" post</a>, it looks like it would be <code>super(ABCImmutable, self).__setattr__(self, name, value)</code> in Python 2. I'll update my answer with what I think should be the correct invocation.</span>
<span class="comment-copy">you can also use super: <code>super(ABCImmutable, self).__setattr__(name, value)</code> in python 2.x or <code>super().__setattr__(name, value)</code> in 3.x. Maybe you want to have a look at this: <a href="http://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="nofollow noreferrer">rhettinger.wordpress.com/2011/05/26/super-considered-super</a></span>
<span class="comment-copy">This answer most closely follows the <a href="https://docs.python.org/3.7/reference/datamodel.html#customizing-attribute-access" rel="nofollow noreferrer">Python docs</a>. The techniques (<code>SomeSuperClass...</code> or <code>super...</code>) seem equivalent to me, but if you use <code>super</code> do take note of the args passed in as shown by @Jeannot and @Dave's <a href="https://stackoverflow.com/questions/7042152/how-do-i-properly-override-setattr-and-getattribute-on-new-style-classes#comment9675936_7042247">comment</a>.</span>
