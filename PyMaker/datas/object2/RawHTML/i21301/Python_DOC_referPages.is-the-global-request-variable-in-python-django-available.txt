<div class="post-text" itemprop="text">
<p>I have written a plugin that sends a signal to activate my code. However, it doesn't send the user-request object to my code. I am looking for a way to retrieve the current request without modifying the main application. I cannot find any documentation related to global request (like <code>$_SERVER['REMOTE_ADDR']</code> in PHP).</p>
<p>I would like to know if there are any variable to do like that in Python/Django.</p>
</div>
<div class="post-text" itemprop="text">
<p>As I know it, you define your Django view using a number of methods like:</p>
<pre><code>def detail(request, some_param):
  # [...]
</code></pre>
<p>The parameter <code>request</code> contains information about the HTTP request. <code>request.META['HTTP_X_FORWARDED_FOR']</code> for example, returns the client's IP address.</p>
<p>If your plugin has something to do with requests, its classes and function probably will be instantiated/called from your view. This means you need to pass it the current <code>request</code> object, as it makes no sense to have a <em>global</em> request object around. 
In PHP, this is possible, as every request causes the whole code to be executed from scratch, but in Django requests are dispatched by a server and passed around in the framework using <code>HttpRequest</code> objects. Also refer to <a href="https://docs.djangoproject.com/en/dev/ref/request-response/" rel="nofollow">this</a> part of the Django documentation for more information.</p>
</div>
<div class="post-text" itemprop="text">
<p>Django doesn't provide a global request object (it would actually be a thread local, not a global).  But there are a few techniques you can use to get the same effect yourself: <a href="http://nedbatchelder.com/blog/201008/global_django_requests.html">http://nedbatchelder.com/blog/201008/global_django_requests.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>AFAIK it is not available, except you make it available.</p>
<p>You can copy+paste the snippets provided in the other answers, or you can use this library: <a href="https://pypi.python.org/pypi/django-crequest" rel="nofollow">https://pypi.python.org/pypi/django-crequest</a></p>
<blockquote>
<p>Middleware to make current request always available.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>you can attach it to current request via middleware and retrieve it back
<a href="https://github.com/jedie/django-tools/blob/master/django_tools/middlewares/ThreadLocal.py" rel="nofollow">https://github.com/jedie/django-tools/blob/master/django_tools/middlewares/ThreadLocal.py</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Based on Ned Batchelder's reply I've compiled a solution. Although I wouldn't recommend it for anything but debugging/troubleshooting. There's a better solution on the linked page.</p>
<p>Put module <code>m1</code> at a project root:</p>
<pre><code>import inspect
def get_request():
    for f in inspect.stack():
        f_code = inspect.getmembers(f.frame, inspect.iscode)[0][1]
        f_locals = [v for (n, v) in inspect.getmembers(f.frame) if n == 'f_locals'][0]
        co_varnames = [v for (n, v) in inspect.getmembers(f_code) if n == 'co_varnames'][0]
        if 'request' in co_varnames:
            return f_locals['request']
</code></pre>
<p>Then in any other file:</p>
<pre><code>import m1
print(m1.get_response().path)
</code></pre>
<p>You might want to make sure you don't introduce <a href="https://docs.python.org/3/library/inspect.html#the-interpreter-stack" rel="nofollow noreferrer">reference cycles</a>. I haven't understood under which particular conditions I must do what exactly. Not that it matters in my case. But your mileage might vary.</p>
</div>
<span class="comment-copy">There are already exists views, and what I have to do is Plug-in which activate by that views, but that views haven't send the request object to my function. I also cannot alter  behavior of the code (views) of main application. So, I have to look for another solution.</span>
<span class="comment-copy">This is hardly possible, see my updated post. Django can handle multiple requests at once, so there cannot exist some global but request-specific state. Maybe we can figure out a solution if you provide more information on what your plugin does, how it is structured, or even post some code.</span>
<span class="comment-copy">This is actually the most precise answer. How to get to the request outside a view. The solution is a bit hackish (installing middleware catching the request object for every thread in a dictionary), and this all encourages to pass the request down instead of globally retrieving it. Looks like a lot of <code>ModelAdmin.save_model(...)</code> overrides ahead (and worse still <code>ModelAdmin.save_related(...)</code>.</span>
<span class="comment-copy">For django 2.0, <a href="https://github.com/appstore-zencore/django-middleware-global-request" rel="nofollow noreferrer">django-middleware-global-request</a> works</span>
