<div class="post-text" itemprop="text">
<p>I've problem to read from Standard input or pipe in python when the pipe is from a "open" (do not know right name)
file.</p>
<p>I have as example 
<strong>pipetest.py:</strong></p>
<pre><code>import sys
import time
k = 0
try:
   for line in sys.stdin:
      k = k + 1
      print line
except KeyboardInterrupt:
   sys.stdout.flush()
   pass
print k
</code></pre>
<p>I run a program that have continues output and Ctrl+c after a while</p>
<pre><code>$ ping 127.0.0.1 | python pipetest.py
^C0
</code></pre>
<p>I get no output.
But if I go via an ordinary file it works.</p>
<pre><code>$ ping 127.0.0.1 &gt; testfile.txt
</code></pre>
<p>this is ended by Ctrl+c after a short while</p>
<pre><code>$ cat testfile.txt |  python pipetest.py

PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.017 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.015 ms
64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.014 ms
64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.013 ms
64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.012 ms

--- 127.0.0.1 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 3998ms
rtt min/avg/max/mdev = 0.012/0.014/0.017/0.003 ms
10
</code></pre>
<p><strong>How do I do to get any output before the program ends, in this case ping has ended?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Try the next:</p>
<pre><code>import sys
import time
k = 0
try:
    buff = ''
    while True:
        buff += sys.stdin.read(1)
        if buff.endswith('\n'):
            print buff[:-1]
            buff = ''
            k = k + 1
except KeyboardInterrupt:
   sys.stdout.flush()
   pass
print k
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>k = 0
try:
    while True:
        print sys.stdin.readline()
        k += 1
except KeyboardInterrupt:
    sys.stdout.flush()
    pass
print k
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For this to work without waiting until the stdin stream ends, you can iter on the readline. I think this is the simplest solution.</p>
<pre><code>import sys
k = 0
try:
   for line in iter(sys.stdin.readline, b''):
      k = k + 1
      print line
except KeyboardInterrupt:
   sys.stdout.flush()
   pass
print k
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>while sys.stdin is a file-like object, meaning you can iterate over its lines, it will block until a EOF is inserted. </p>
<p>The behaviour can be described with the following pseudo-code:</p>
<pre><code>while True:
    input = ""
    c = stdin.read(1)
    while c is not EOF:
        input += c
        c = stdin.read(1)
    for line in input.split('\n'):
        yield line
</code></pre>
<p>this means that, while you can iterate over sys.stdin's lines, you cannot use this approach for the task at hand and you must explicitly call read() or readline()</p>
</div>
<div class="post-text" itemprop="text">
<p>This is how I ended up doing this. I didn't really like any of the other solutions, they didn't seem very pythonic. </p>
<p>This will make a container for any open file input to iterate over all the lines. This will also take care of closing the file at the end of the context manager. </p>
<p>I feel like this is probably how the <code>for line in sys.stdin:</code> block should operate by default.</p>
<pre><code>class FileInput(object):                                                        
    def __init__(self, file):                                                   
        self.file = file                                                       

    def __enter__(self):                                                        
        return self                                                             

    def __exit__(self, *args, **kwargs):                                        
        self.file.close()                                                       

    def __iter__(self):                                                         
        return self                                                             

    def next(self):                                                             
        line = self.file.readline()                                             

        if line == None or line == "":                                          
            raise StopIteration                                                 

        return line  

with FileInput(sys.stdin) as f:
    for line in f:
        print f

with FileInput(open('tmpfile') as f:
    for line in f:
        print f
</code></pre>
<p>From the command line both of the following should work: </p>
<pre><code>tail -f /var/log/debug.log | python fileinput.py
cat /var/log/debug.log | python fileinput.py
</code></pre>
</div>
<span class="comment-copy">I'm glad it worked, but you can certainly use <code>for line in stdin</code>, so long as you know it will block until it finds a line ending (which is why your version works, <code>read</code> doesn't block like that).</span>
<span class="comment-copy">I'm not suggesting you delete your answer, just that the very last line was wrong. I deleted the "totally wrong" comment since it was wrong -- your program was right, just your closing statement was wrong. I'm not the downvoter (I wouldn't be, since I didn't know whether or not your answer would work).</span>
<span class="comment-copy">Doesn't this have the same problem as the version in the question? I think readline blocks until it finds a <code>\n</code>, too?</span>
<span class="comment-copy">I don't believe so, it works as expected.</span>
<span class="comment-copy">usering <code>iter</code> that way is clever</span>
<span class="comment-copy"><i>import time</i> is useless. Probably this is the best solution.</span>
<span class="comment-copy">@MastroGeppetto Yeah, that was an artifact from the original question that never got removed. :-)  Thanks</span>
<span class="comment-copy">You want to completely close stdin?</span>
<span class="comment-copy">You are not permanently closing stdin in a system wide manner. You are closing the connection between your program and the file.</span>
<span class="comment-copy">@Kellen Fox -- you may have gotten your wish!  <a href="http://stackoverflow.com/a/1454400/188963">stackoverflow.com/a/1454400/188963</a> <a href="https://docs.python.org/3/library/fileinput.html" rel="nofollow noreferrer">docs.python.org/3/library/fileinput.html</a></span>
