<div class="post-text" itemprop="text">
<p>I am new in programming...My code is very simple. Let's say my number is '123' then i want to get 'abc' .please check where i am wrong</p>
<pre><code>def number2char(number):
    search_array = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]
    replace_array = ["a", "b", "c", "d", "d", "e", "f", "g", "h", "i"]
    num_2_char = number.replace(search_array, replace_array);
    return num_2_char;  
</code></pre>
<p>I am getting an error here like this </p>
<blockquote>
<p>num_2_char = number.replace(search_array, replace_array);
  TypeError: expected a character buffer object</p>
</blockquote>
<p>Please help me...</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <a href="https://docs.python.org/3/library/stdtypes.html#str.replace" rel="nofollow noreferrer"><code>str.replace</code></a> replaces one substring with a replacement substring. That's what the error means: it wants a substring, and you gave it a list of separate characters.</p>
<hr/>
<p>You could loop over the replacement pairs, calling <code>replace</code> for each one:</p>
<pre><code>&gt;&gt;&gt; s = '123'
&gt;&gt;&gt; for search, replace in zip(search_array, replace_array):
...     s = s.replace(search, replace)
&gt;&gt;&gt; s
'abc'
</code></pre>
<hr/>
<p>Or you could just use <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer"><code>str.translate</code></a>, which actually <em>does</em> do what you want, although it requires a bit of setup:</p>
<pre><code>&gt;&gt;&gt; search_array = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]
&gt;&gt;&gt; replace_array = ["a", "b", "c", "d", "d", "e", "f", "g", "h", "i"]
&gt;&gt;&gt; trans = str.maketrans(dict(zip(search_array, replace_array)))
&gt;&gt;&gt; '123'.translate(trans)
'abc'
</code></pre>
<p>Or, alternatively, and probably more readable:</p>
<pre><code>&gt;&gt;&gt; search = "1234567890"
&gt;&gt;&gt; replace = "abcddefghi"
&gt;&gt;&gt; trans = str.maketrans(search, replace)
&gt;&gt;&gt; '123'.translate(trans)
'abc'
</code></pre>
<hr/>
<p>By the way, if it isn't intentional that you specified <code>d</code> twice in a row, it might be clearer (and harder to make that typo!) to specify the letters like this:</p>
<pre><code>&gt;&gt;&gt; replace = string.ascii_lowercase[:10]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a dictionary instead. There's a few steps here:</p>
<ol>
<li>We want to map every number to a character, so we can create a dictionary with the input characters as keys and the output characters as values.</li>
<li>You can't iterate a numerical input, so we have to convert it to a string to access each character in turn. In your example the value is already a string (<code>'123'</code>) but there's no reason you can't make the function accept both numerical and string inputs.</li>
<li>The replacement is done in a list comprehension, which naturally returns a list. So you need to call <code>join()</code> to join all of the characters back together into a single string.</li>
</ol>
<p>One approach is as follows:</p>
<pre><code>def number2char(number):
    search_array = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]
    replace_array = ["a", "b", "c", "d", "d", "e", "f", "g", "h", "i"]
    replace_dict = dict(zip(search_array, replace_array))
    num_2_char = ''.join([replace_dict.get(char, '_') 
                          for char in str(number)])
    return num_2_char

a = number2char(123)
</code></pre>
<p>In this case I've used <code>replace_dict.get(str(item), '_')</code> so that the code doesn't crash if someone gives an input that isn't in the <code>replace_dict</code>; instead they just get back underscores. There's probably better ways to handle that, but it's safer than just trying to access the dictionary as <code>replace_dict[item]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def number2char(number):
    search_array = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]
    replace_array = ["a", "b", "c", "d", "d", "e", "f", "g", "h", "i"]
    num_2_char=''
    for i in number:
        num_2_char +=  replace_array[search_array.index(i)]
    return num_2_char;
</code></pre>
</div>
<span class="comment-copy">You can't just guess at what you want a method to do. It does what it was documented to do. For <a href="https://docs.python.org/3/library/stdtypes.html#str.replace" rel="nofollow noreferrer"><code>str.replace</code></a>, what it does is replace one substring with another substring.</span>
<span class="comment-copy">Thanks for editing...please anyone help me!</span>
<span class="comment-copy">Is it intentional that you have <code>"d"</code> twice in a row?</span>
<span class="comment-copy">Great explanation and very helpful . Thank you very much @roganjosh</span>
<span class="comment-copy">What is point 2 about? The OP says the input is <code>123'</code>, which is a string. Plus, if it <i>weren't</i> a string, he wouldn't get the <code>TypeError</code>  he got, he'd get an <code>AttributeError</code>.</span>
<span class="comment-copy">@abarnert ah, that's a fair enough observation. You're right, I missed that the input was already a string, but I was already working on an explanation for <code>dict.get()</code>. I guess that point is a bit redundant but I'm not sure it affects the flow of the explanation to be removed?</span>
<span class="comment-copy">I think it confuses things, especially for a novice who's going to start trying to figure out why <code>'123'</code> isn't a string.</span>
<span class="comment-copy">Also, I think <code>dict.get(item, item)</code> might be more useful than <code>dict.get(item, '_')</code>… but that's really up to what the OP wants to happen in that case. (He might actually want an error, because that's a "this should never happen" case, for all I know.)</span>
<span class="comment-copy">This really isn't a good solution. Almost any time you find yourself calling <code>index</code> on a list, it's a sign that you're using either the wrong data structure or the wrong algorithm. Here, you could just use a dict, instead of linearly searching through every character every time—it would be simpler, and clearer in meaning, and even more efficient (not that it's going to matter here). But at that point, you've just got roganjosh's answer.</span>
