<div class="post-text" itemprop="text">
<p>I have the following code:</p>
<pre><code>def test_transformation_last_price(self):
    data_set = etl.fromdicts([{'MTDReturn': 4, 'EffectiveDate': '1992-06-30'},
                              {'MTDReturn': 3.2, 'EffectiveDate': '1992-07-31'}])
    last_price_dataset = self.parser.last_price_dataset(data_set)
    first_row = list(etl.dicts(last_price_dataset))[0]
    expected_row = {'TimeSeriesValue': 121.20923188958272,
                    'EffectiveDate': datetime.date(1992, 6, 30),
                    'FundID': self.parser.FUND_ID,
                    'TimeSeriesTypeID': self.parser.LAST_PRICE_ID}
    self.assertEqual(first_row, expected_row)
</code></pre>
<p>My method: <code>last_price_dataset</code> runs a few other methods that essentially grab a value from a database and produces some calculations based on it. At the moment this passes, and it's correct. However, that value might change by a few decimal points here and there. </p>
<p>Is there a unittest I can use that checks if the <code>TimeSeriesValue</code> is close that number in the dict?</p>
<p><code>AssertAlmostEqual</code> doesn't work with dicts like that. Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>TestCase.assertAmostEqual</code>(please read more here - <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual</a>):</p>
<pre><code>assertAlmostEqual(first, second, places=7, msg=None, delta=None)
</code></pre>
<p>For instance, if the precision is 0 decimal places then the following test passes:</p>
<pre><code>from unittest import TestCase
from unittest import main

class Test(TestCase):
    def test_1(self):
        dict1 = {'TimeSeriesValue': 121.20923188958272}
        dict2 = {'TimeSeriesValue': 121.3}
        self.assertAlmostEqual(dict1['TimeSeriesValue'], dict2['TimeSeriesValue'], 1)

if __name__ == '__main__':
    main()
</code></pre>
<blockquote>
<p>OK</p>
</blockquote>
<p>For your test it could be like:</p>
<pre><code># number of decimal places is 0
self.assertAlmostEqual(expected_row['TimeSeriesValue'], first_row[&lt;your key here&gt;], 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had the same problem today. So I simply build my own method <code>assertDictAlmostEqual</code>.</p>
<pre><code>def assertDictAlmostEqual(self, d1, d2, msg=None, places=7):

    # check if both inputs are dicts
    self.assertIsInstance(d1, dict, 'First argument is not a dictionary')
    self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')

    # check if both inputs have the same keys
    self.assertEqual(d1.keys(), d2.keys())

    # check each key
    for key, value in d1.items():
        if isinstance(value, dict):
            self.assertDictAlmostEqual(d1[key], d2[key], msg=msg)
        else:
            self.assertAlmostEqual(d1[key], d2[key], places=places, msg=msg)
</code></pre>
</div>
<span class="comment-copy">Why can't TestCase.assertAmostEqual be used?</span>
<span class="comment-copy">I believe it <code>assertAlmostEqual</code> rounds a value down with <code>round(abs(second-first)</code> and when attempting it, I get a Typeerror: <code>unsopported operand type(s) for -: 'dict' and 'dict'</code></span>
<span class="comment-copy">Thank you, although that works for a single value I still need to verify the rest of the data is equal. I guess I could add additional asserts for the other keys.</span>
<span class="comment-copy">@user7496931 A pleasure! Yep, that would be the easiest way.</span>
