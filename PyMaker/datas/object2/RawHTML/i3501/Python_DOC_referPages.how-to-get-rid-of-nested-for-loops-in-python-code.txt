<div class="post-text" itemprop="text">
<p>I have 1 year of satellite measurements of the electrons (the instrument was measuring every 4 seconds). This array is called 'electrons'. I also have the corresponding times in format datetime.datetime (called 'time'). I want to average electrons array to get a mean value for every minute instead of every 4 seconds. I wanna put them in a new array 'g'. However, when I write the loops, it becomes extremely slow. Is there any way to make it faster? Here is what I do:</p>
<pre><code>import numpy as np
import spacepy.time as spt
import datetime as dt

year=2001
for month in range (1,13):
        dmax=np.array([[31,28,31,30,31,30,31,31,30,31,30,31]]).T #number of days in a month
        for day in range(1,dmax[month-1]+1):
            for hour in range(24):
                for minute in range(60):

                D1=spt.Ticktock(dt.datetime(year, month, day, hour, minute, 0,0),'UTC').RDT #lower boundary of a minute

#here, spt is a spacepy.time, and '.RDT' returns GREGORIAN ORDINAL TIME.

                D2=spt.Ticktock(dt.datetime(year, month, day, hour, minute, 59,999999),'UTC').RDT #upper boundary of a minute

                mask=((time&gt;D1)&amp;(time&lt;D2))

                electrons_logic=electrons[mask]
                k=(month-1)*dmax[month-1]*24*60+(day-1)*24*60+hour*60+(minute+1) #number of the minute in a year
                g[k,0]=np.nanmean(electrons_logic)
</code></pre>
<p>Is there a way to avoid the nested loops and make it faster?</p>
<p>Maybe there is a way to make it faster using multiprocessing/parallel computing?</p>
</div>
<div class="post-text" itemprop="text">
<p>Whenever you have a problem regarding iteration, think of <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a>.</p>
<pre><code>from itertools import product

dmax=np.array([[31,28,31,30,31,30,31,31,30,31,30,31]]).T
for month in range (1,13):
    for day, hour, minute in product(range(1,dmax[month-1]+1), range(24), range(60)):
        ...
</code></pre>
<p>I also advise to define <code>dmax</code> outside the loop as it would otherwise be instantiated on each <code>month</code> iteration.</p>
</div>
<div class="post-text" itemprop="text">
<p>The alternative (at least for the 3 inner loops) is to loop on the number of minutes, 
then use division+remainder to compute hour and day:</p>
<pre><code>dmax=np.array([[31,28,31,30,31,30,31,31,30,31,30,31]]).T #number of days in a month
for month in range (1,13):
    nb_days = dmax[month-1]
    for m in range(60*24*nb_days):
        hour,minute = divmod(m,60)
        day,hour = divmod(hour,nb_days)
        day += 1
</code></pre>
<p>this is a tradeoff between using 2 divisions/modulos (using the <code>divmod</code> function allows to do it in one go) at each iteration vs 2 loops. As python loops are expensive, it's worth trying.</p>
</div>
<div class="post-text" itemprop="text">
<p>If there is any static initialization (for your code)</p>
<pre><code>dmax=np.array([[31,28,31,30,31,30,31,31,30,31,30,31]]).T #number of days in a month
</code></pre>
<p>It should be outside the for-loop. Because, everytime that loop runs, that array will be initialized for that many computations.</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like you're not using month, day and minute for anything else than calculating seconds.</p>
<p>you can make it in just 1 loop with something like this without even having to hard code the days in a month array:</p>
<pre><code>year=2001
DT1=dt.datetime(year, 1, 1, 0, 0, 0, 0),'UTC')
DT2=dt.datetime(year, 1, 1, 0, 0, 59, 999999),'UTC')
DToneSec=datetime.timedelta(seconds=1)
DTy=dt.datetime(year+1, 1, 1, 0, 0, 0, 0),'UTC')-DT1

for k in range (1,DTy.total_seconds()+1):
    D1=spt.Ticktock(DT1).RDT
    DT1+=DToneSec
    D2=spt.Ticktock(DT2).RDT
    DT2+=DToneSec

    g[k,0]=np.nanmean(electrons[(time&gt;D1)&amp;(time&lt;D2)])
</code></pre>
</div>
<span class="comment-copy">you could loop on the minutes (1 loop) and use divmod to work out the other values. division/modulus vs loops tradeoff. worth being timed.</span>
<span class="comment-copy">It could have been nice! However, the problem is that months have different number of days, so at some point the dived would be difficult...</span>
<span class="comment-copy">you can still do it for the 3 inner loops. and define <code>dmax</code> at the start (not that it takes too much time, but still...)</span>
<span class="comment-copy">pandas.resample maybe?</span>
<span class="comment-copy">itertools, always itertools</span>
<span class="comment-copy">The problem is that itertools actually takes more time than simple loops. I timed it, and simple loops are faster by 13%...</span>
<span class="comment-copy">@TomSmith If performance is really that much of an issue then, you should kepp your nested loops as they will be faster for sure. The solution using divmod by <a href="https://stackoverflow.com/a/50955940/5079316">Jean-Fran√ßois</a> might be faster than mine (I assume it is but did not test), but it will not be as quick as the loops.</span>
<span class="comment-copy">Actually, the solution with divmod makes it 30% slower! I thought there would be some magical way to improve it, but it seems to me that I just have to wait until it runs to the end...</span>
<span class="comment-copy">When performance is needed, going the raw ugly way is often the solution as their is a significant overhead to invoking and calling functions. But do remove the dmax from the outer loop, you will gain significant performance doing so</span>
