<div class="post-text" itemprop="text">
<p>Two newly installed from the same scratch VMs with the same python36 versions have different values for sys.path:</p>
<p>1st VM</p>
<pre><code>[root@vm1 ~]# python36 -m site
sys.path = [
    '/root',
    '/usr/lib64/python36.zip',
    '/usr/lib64/python3.6',
    '/usr/lib64/python3.6/lib-dynload',
    '/usr/lib64/python3.6/site-packages',
    '/usr/lib/python3.6/site-packages',
]
USER_BASE: '/root/.local' (doesn't exist)
USER_SITE: '/root/.local/lib/python3.6/site-packages' (doesn't exist)
ENABLE_USER_SITE: True
</code></pre>
<p>2nd VM</p>
<pre><code>[root@vm2 ~]# python36 -m site
sys.path = [
    '/root',
    '/usr/lib64/python36.zip',
    '/usr/lib64/python3.6',
    '/usr/lib64/python3.6/lib-dynload',
    '/usr/local/lib64/python3.6/site-packages',
    '/usr/local/lib/python3.6/site-packages',
    '/usr/lib64/python3.6/site-packages',
    '/usr/lib/python3.6/site-packages',
]
USER_BASE: '/root/.local' (doesn't exist)
USER_SITE: '/root/.local/lib/python3.6/site-packages' (doesn't exist)
ENABLE_USER_SITE: True
</code></pre>
<p>2nd VM has /usr/local/lib* paths for some reasons. </p>
<p>os.environ on both machines shows the same values for variables:</p>
<ul>
<li>no custom path values for PYTHONPATH</li>
<li><p>original PATH variables(dunno if they are connected to PYTHONPATH)
are also the same</p>
<p>[root@vm1 ~] env | grep -E "^PATH="
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/java/latest/bin:/opt/java/latest/jre/bin:/root/bin</p></li>
</ul>
<p>How python36 initialise PYTHONPATH(sys.path) during initial installation, when no custom values at OS side for PYTHONPATH are configured?</p>
</div>
<div class="post-text" itemprop="text">
<p>A normal installation is expected to be able to run without any <code>PYTHONPATH</code> environment variable at all. As explained in the docs, <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" rel="nofollow noreferrer"><code>PYTHONPATH</code></a> is there for the user, to…</p>
<blockquote>
<p>Augment the default search path for module files. The format is the same as the shell’s PATH: one or more directory pathnames separated by os.pathsep (e.g. colons on Unix or semicolons on Windows). Non-existent directories are silently ignored.</p>
</blockquote>
<p>So, none of the standard Python installers (that includes building locally and running <code>make install</code>, and the Windows and macOS binary installers available under Downloads at python.org) do anything at all to create a <code>PYTHONPATH</code> value or get it set up in your environment. And most semi-official and third-party packages (like the Pythons includes or packaged by Linux distros and by Apple, the less-common-platforms installers under Downloads/Other, "batteries plus" Python distributions like Anaconda, etc.) will work the same way.</p>
<hr/>
<p>Notice that the <code>PYTHONPATH</code> directories are added to the default search path. As noted in the same docs:</p>
<blockquote>
<p>The default search path is installation dependent, but generally begins with prefix/lib/pythonversion (see PYTHONHOME above). It is always appended to PYTHONPATH.</p>
<p>An additional directory will be inserted in the search path in front of PYTHONPATH as described above under Interface options. The search path can be manipulated from within a Python program as the variable sys.path.</p>
</blockquote>
<p>This is also explained in <a href="https://docs.python.org/3/library/sys.html#sys.path" rel="nofollow noreferrer"><code>sys.path</code></a>:</p>
<blockquote>
<p>A list of strings that specifies the search path for modules. Initialized from the environment variable PYTHONPATH, plus an installation-dependent default.</p>
<p>As initialized upon program startup, the first item of this list, path[0], is the directory containing the script that was used to invoke the Python interpreter. If the script directory is not available (e.g. if the interpreter is invoked interactively or if the script is read from standard input), path[0] is the empty string, which directs Python to search modules in the current directory first. Notice that the script directory is inserted before the entries inserted as a result of PYTHONPATH.</p>
<p>…</p>
<p>See also Module <a href="https://docs.python.org/3/library/site.html#module-site" rel="nofollow noreferrer"><code>site</code></a> This describes how to use .pth files to extend sys.path.</p>
</blockquote>
<p>Unlike <code>PYTHONPATH</code>, this <code>site</code> mechanism <em>is</em> sometimes used by third-party and semi-official installs. For example, Apple uses it to add its <code>Extras</code> library of pre-installed packages like <code>pyobjc</code> to the builtin Python 2.7 on macOS.</p>
<hr/>
<p>If you're wondering how that "installation-dependent default" is loaded by the <code>sys</code> module in CPython, it ultimately comes down to a public C API function, <a href="https://docs.python.org/3/c-api/init.html#c.Py_GetPath" rel="nofollow noreferrer"><code>Py_GetPath</code></a>:</p>
<blockquote>
<p>Return the default module search path; this is computed from the program name (set by Py_SetProgramName() above) and some environment variables. The returned string consists of a series of directory names separated by a platform dependent delimiter character. The delimiter character is ':' on Unix and Mac OS X, ';' on Windows. The returned string points into static storage; the caller should not modify its value. The list <code>sys.path</code> is initialized with this value on interpreter startup; it can be (and usually is) modified later to change the search path for loading modules.</p>
</blockquote>
<p>If you want to see how the C code works, you probably want to start at <a href="https://github.com/python/cpython/blob/master/Python/pathconfig.c#L47" rel="nofollow noreferrer"><code>_PyPathConfig_Init</code></a>, because the actual <a href="https://github.com/python/cpython/blob/master/Python/pathconfig.c#L208" rel="nofollow noreferrer"><code>Py_GetPath</code></a> just calls a function that makes sure this has been called and then pulls the value out of the struct that it sets.</p>
</div>
<span class="comment-copy">Are you asking how the installer (meaning <code>make install</code>, or the macOS or WIndows binary python.org installers, or third-party things like the Anaconda installers or distro packages?) picks a <code>PYTHONPATH</code> and sets it set in your environment? If so, the answer is simple: it doesn't. There is no <code>PYTHONPATH</code> set by any normal installation.</span>
<span class="comment-copy">Or are you asking how the values in <code>sys.path</code>, without any <code>PYTHONPATH</code>, are baked into a CPython install? Or how <code>sys.path</code> is built out of <code>PYTHONPATH</code>, the baked-in values, and <code>site</code>? Or something different?</span>
<span class="comment-copy">@abarnert in both cases python36 was installed from the same repo (centos7 epel repo). Literally, both VMs were deployed with python36 completely the same way. However, they have different values in sys.path. I wonder if anybody could help me with understanding on how sys.path values are generated during initial installation.</span>
<span class="comment-copy">That doesn't answer my question. They don't have different <code>PYTHONPATH</code> environment variables. So what are you actually asking? I tried to guess what you mean and provide an answer, but I may well have guessed wrong, because you haven't been at all clear about what you want.</span>
