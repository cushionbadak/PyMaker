<div class="post-text" itemprop="text">
<p>I have four C++ files: A.h, A.cpp, B.h, B.cpp, and A.h is included in B.cpp</p>
<p>A.h:</p>
<pre><code>#pragma once 
void A();
</code></pre>
<p>A.cpp:</p>
<pre><code>#include &lt;iostream&gt;
void A() {
    std::cout &lt;&lt; "A" &lt;&lt; std::endl;
}
</code></pre>
<p>B.h:</p>
<pre><code>#pragma once
void B();
</code></pre>
<p>B.cpp:</p>
<pre><code>#include "A.h"
#include &lt;iostream&gt;
void B() {
    A();
    std::cout &lt;&lt; "B" &lt;&lt; std::endl;
}
</code></pre>
<p>Now I wrote two SWIG inerface files A.i and B.i</p>
<p>A.i:</p>
<pre><code>%module A
%{
#include "A.h"
%}
%include "A.h"
</code></pre>
<p>B.i:</p>
<pre><code>%module B
%{
#include "B.h"
%}
%include "B.h"
</code></pre>
<p>The setup.py file is:</p>
<pre><code>from distutils.core import setup, Extension
A_ext = Extension( "_A", [ "A.i", "A.cpp", ], swig_opts = ['-c++'], extra_compile_args = ['-g'])
B_ext = Extension( "_B", [ "B.i", "B.cpp", ], swig_opts = ['-c++'], extra_compile_args = ['-g'])
setup(
    name = "test",
    version = "1.0",
    ext_modules = [ A_ext, B_ext ],
    py_modules = [ "A", "B" ]
)
</code></pre>
<p>If I type the command below, it will show 'A'.</p>
<pre><code>python -c 'import A; A.A()' 
</code></pre>
<p>If I type the command below, the segmentation fault appears:</p>
<pre><code>python -c 'import B; B.B()'
</code></pre>
<p>How could I do to get this command run correctly? Since I don't want to compile B.cpp many times, is there any way except the one below?</p>
<pre><code>B_ext = Extension( "_B", [ "B.i", "A.cpp", "B.cpp", ], swig_opts = ['-c++'], extra_compile_args = ['-g'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I changed your files a bit, for clarity.</p>
<p><em>a.h</em>:</p>
<pre class="lang-cpp prettyprint-override"><code>#pragma once 


void funcA();
</code></pre>
<p><em>a.cpp</em>:</p>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;iostream&gt;


void funcA() {
    std::cout &lt;&lt; __FILE__ &lt;&lt; " " &lt;&lt; __LINE__ &lt;&lt;  " " &lt;&lt; __FUNCTION__ &lt;&lt;  std::endl;
}
</code></pre>
<p><em>a.i</em>:</p>
<pre class="lang-cpp prettyprint-override"><code>%module a
%{
    #include "a.h"
%}
%include "a.h"
</code></pre>
<p><em>b.h</em>:</p>
<pre class="lang-cpp prettyprint-override"><code>#pragma once


void funcB();
</code></pre>
<p><em>b.cpp</em>:</p>
<pre class="lang-cpp prettyprint-override"><code>#include "a.h"
#include &lt;iostream&gt;


void funcB() {
    std::cout &lt;&lt; __FILE__ &lt;&lt; " " &lt;&lt; __LINE__ &lt;&lt;  " " &lt;&lt; __FUNCTION__ &lt;&lt;  std::endl;
    funcA();
}
</code></pre>
<p><em>b.i</em>:</p>
<pre class="lang-cpp prettyprint-override"><code>%module b
%{
    #include "b.h"
%}
%include "b.h"
</code></pre>
<p><em>setup.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>from distutils.core import setup
from distutils.extension import Extension


a = "a"
b = "b"

ext_a = Extension("_" + a, [a + ".i", a + ".cpp"], swig_opts=("-c++",), extra_compile_args=["-g"])
ext_b = Extension("_" + b, [b + ".i", b + ".cpp"], swig_opts=("-c++",), extra_compile_args=["-g"])

setup(
    name="test",
    version="1.0",
    ext_modules=[ext_a, ext_b],
    py_modules=[a, b]
)
</code></pre>
<p>What happens (simplified) when calling <code>b.funcB()</code> (only the <em>stacktrace</em>, imports left aside). Each step invokes the next:</p>
<ol>
<li><em>funcB</em> from module <em>b</em> (<em>b.py</em>)</li>
<li><em>funcB</em> from module <em>_b</em> (<em>_b.so</em>, or <em>_b.cpython-35m-x86_64-linux-gnu.so</em>)

<ul>
<li>Everything from here happens in <em>C</em> (or <em>C++</em>)</li>
<li>Current <em>funcB</em> is <strong>different</strong> than the one from <em>b.cpp</em>: it's generated by <em>swig</em> and its name is <em>_wrap_funcB</em></li>
<li>Previous bullet also applies to <em>funcA</em> and <em>a.cpp</em></li>
</ul></li>
<li><em>funcB</em> from <em>b.cpp</em></li>
<li><em>funcA</em> from <em>a.cpp</em></li>
</ol>
<p>The problem is that the code from step <strong><em>#4.</em></strong> is not in the module <em>_b</em>, and it will fail at runtime. But things are a little bit stranger: the failure (core dump) doesn't appear when <em>funcB</em> is called but at module (<em>b</em> -&gt; <em>_b</em>) <strong>import</strong> time (I think this happens because of <em>swig</em>'s behind the scene magic), as seen below.</p>
<p><strong>Output</strong>:</p>
<blockquote>
<pre class="lang-py prettyprint-override"><code>[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050938128]&gt; ls
a.cpp  a.h  a.i  b.cpp  b.h  b.i  setup.py
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050938128]&gt; python3 setup.py build &gt; /dev/null 2&gt;&amp;1
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050938128]&gt; echo $?
0
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050938128]&gt; ls
a.cpp  a.h  a.i  a.py  a_wrap.cpp  b.cpp  b.h  b.i  b.py  build  b_wrap.cpp  setup.py
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050938128]&gt; ls ./build/lib.linux-x86_64-3.5
_a.cpython-35m-x86_64-linux-gnu.so  _b.cpython-35m-x86_64-linux-gnu.so
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050938128]&gt; PYTHONPATH=${PYTHONPATH}:./build/lib.linux-x86_64-3.5 python3 -c "import _a;_a.funcA()"
a.cpp 6 funcA
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050938128]&gt; PYTHONPATH=${PYTHONPATH}:./build/lib.linux-x86_64-3.5 python3 -c "import _b"
Segmentation fault (core dumped)
</code></pre>
</blockquote>
<p>In order to solve it, either:</p>
<ol>
<li>As you pointed out include <em>funcA</em> in module <em>_b</em> (by adding <em>a.cpp</em> in <em>ext_b</em>'s source files list). This way, both modules will be self contained (from <em>funcA</em>'s <em>PoV</em>), each will work independently,  but also <em>funcA</em> will be duplicated in both of them</li>
<li>Make <em>_b</em> depend on <em>_a</em> (after all, they're <em>shared objects</em>). But that's not how <em>Python</em> extension modules are to be used, and it won't work on <em>Win</em> (and also on some <em>Ux</em> flavors). So, this is more like a (lame) workaround (<em>gainarie</em>)</li>
<li>Build <em>a.cpp</em> into a different shared library (an <em>.so</em>, but <strong>not</strong> a <em>Python</em> extension module) to be used by both modules. Needless to say that at runtime each of them will require the <em>.so</em> to be present</li>
</ol>
<p>Obviously, to option <strong><em>#3.</em></strong> is the perfect candidate. But <em>distutils</em> (<a href="https://docs.python.org/3/distutils/apiref.html#api-reference" rel="nofollow noreferrer">[Python 3]: API Reference</a>) doesn't provide the needed functionality <em>OOTB</em> (apparently building an extension module and an external shared library that it depends on, is not a scenario that <em>distutils</em> aims for), or at least, I couldn't find any. <br/>There is a <em>build_clib</em> module, which offers the functionality of building a <strong>static</strong> lib (to be used by the extension modules), but that would be same as option <strong><em>#1.</em></strong>.</p>
<p><em>setup.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>import sys
import os
from distutils.core import setup
from distutils.extension import Extension
from distutils.command.build_clib import build_clib
from distutils.command.build_ext import build_ext
from distutils.ccompiler import CCompiler


__win = sys.platform[:3].lower() == "win"
export_symbols_option = "export_symbols"


class build_clib_dyn(build_clib):
    def finalize_options(self):
        self.set_undefined_options('build',
                                   ('build_lib', 'build_clib'),
                                   ('build_temp', 'build_temp'),
                                   ('compiler', 'compiler'),
                                   ('debug', 'debug'),
                                   ('force', 'force'))
        self.libraries = self.distribution.libraries
        if self.libraries:
            self.check_library_list(self.libraries)
        if self.include_dirs is None:
            self.include_dirs = self.distribution.include_dirs or []
        if isinstance(self.include_dirs, str):
            self.include_dirs = self.include_dirs.split(os.pathsep)

    def build_libraries(self, libraries):
        for (lib_name, build_info) in libraries:
            sources = build_info.get('sources')
            if sources is None or not isinstance(sources, (list, tuple)):
                raise DistutilsSetupError(
                       "in 'libraries' option (library '%s'), "
                       "'sources' must be present and must be "
                       "a list of source filenames" % lib_name)
            sources = list(sources)
            macros = build_info.get('macros')
            include_dirs = build_info.get('include_dirs')
            objects = self.compiler.compile(sources,
                                            output_dir=self.build_temp,
                                            macros=macros,
                                            include_dirs=include_dirs,
                                            debug=self.debug)
            self.compiler.link(CCompiler.SHARED_OBJECT, objects, self.compiler.library_filename(lib_name, lib_type="shared"),
                               output_dir=self.build_clib,
                               export_symbols=build_info.get(export_symbols_option),
                               debug=self.debug)


if __win:
    class build_ext_w_dyn_dep(build_ext):
        def finalize_options(self):
            super(build_ext_w_dyn_dep, self).finalize_options()
            self.library_dirs.append(os.path.dirname(self.build_temp))

else:
    class build_ext_w_dyn_dep(build_ext):
        pass


a_name = "a"
b_name = "b"
common_name = a_name + b_name + "common"
swig_opts = ["-c++"]
libraries = [common_name]
lib_common_build_info = {"sources": [a_name + ".cpp"]}
if __win:
    extra_compile_args = None
    extra_link_args = None
    lib_common_build_info[export_symbols_option] = ["funcA"]
else:
    extra_compile_args = ["-g"]
    extra_link_args = ["-Wl,-rpath,${ORIGIN}"]

lib_common_info = (common_name, lib_common_build_info)
ext_a = Extension("_" + a_name, [a_name + ".i"], libraries=libraries, extra_compile_args=extra_compile_args, extra_link_args=extra_link_args, swig_opts=swig_opts)
ext_b = Extension("_" + b_name, [b_name + ".i", b_name + ".cpp"], libraries=libraries, extra_compile_args=extra_compile_args, extra_link_args=extra_link_args, swig_opts=swig_opts)

setup(
    name="test",
    version="1.0",
    libraries=[lib_common_info],
    cmdclass={"build_clib": build_clib_dyn, "build_ext": build_ext_w_dyn_dep},
    ext_modules=[ext_a, ext_b],
    py_modules=[a_name, b_name]
)
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li><em>build_clib_dyn</em> extends <em>build_clib</em> as its functionality had to be modified. 2 methods overridden but only small parts of them actually changed (comments were not copied from the base class methods (<em>Python<strong>3.5.4</strong></em></li></ul></div>
<span class="comment-copy">Did this answer your question?</span>
