<div class="post-text" itemprop="text">
<pre><code>class A():
    def tmp(self):
        print("hi")

def b(a):
    a.tmp()
</code></pre>
<p>To check if tmp method is called in b, the recommended way is</p>
<pre><code>a = A()
a.tmp = MagicMock()
b(a)
a.tmp.assert_called()
</code></pre>
<p>But tmp here is being mocked away and is not resulting in a <code>"hi"</code> getting printed.</p>
<p>I would want my unit test to check if method tmp is called without mocking it away.</p>
<p>Is this possible?</p>
<p>I know this is not a standard thing to expect when writing unitests. But my use case (which is bit tricky) requires this.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can set the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow noreferrer"><code>Mock.side_effect</code></a> to be the original method.  </p>
<pre><code>from unittest.mock import MagicMock

class A():
    def tmp(self):
        print("hi")

def b(a):
    a.tmp()

a = A()
a.tmp = MagicMock(side_effect=a.tmp)
b(a)
a.tmp.assert_called()
</code></pre>
<p>When <code>side_effect</code> is a function (or a bound method in this case, which is a kind of function), calling the <code>Mock</code> will also call the <code>side_effect</code> with the same arguments.</p>
<p>The <code>Mock()</code> call will return whatever the <code>side_effect</code> returns, unless it returns the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.DEFAULT" rel="nofollow noreferrer"><code>unnittest.mock.DEFAULT</code></a> singleton. Then it will return <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value" rel="nofollow noreferrer"><code>Mock.return_value</code></a> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>Or you can decorate the method to test:</p>
<pre><code>def check_called(fun):
    def wrapper(self, *args, **kw):
        attrname = "_{}_called".format(fun.__name__)
        setattr(self, attrname, True)
        return fun(self, *args, **kw)
    return wrapper


a = A()
a.tmp = check_called(a.tmp)
b(a)
assert(getattr(a, "_tmp_called", False))
</code></pre>
<p>but MagicMock's <code>side_effect</code> is definitly a better solution if you're already using Mock ;)</p>
</div>
<span class="comment-copy">def tmp(self):         return "hi"</span>
<span class="comment-copy">what if I care about return value as well?</span>
<span class="comment-copy">@claudius Did you try it?  Calling the <code>Mock</code> object should return whatever <code>side_effect</code> returns with those arguments.</span>
