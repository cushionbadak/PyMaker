<div class="post-text" itemprop="text">
<p>I am trying to understand decorators and currently reading <a href="http://www.itmaybeahack.com/book/python-2.6/html/p03/p03c06_decorators.html" rel="nofollow noreferrer">the documentation</a></p>
<pre><code>import types

class SelfDocumenting( object ):
    @classmethod
    def getMethods( aClass ):
        return [ (n,v.__doc__) for n,v in aClass.__dict__.items()
                 if type(v) == types.FunctionType ]
    def help( self ):
        """Part of the self-documenting framework"""
        print self.getMethods()

class SomeClass( SelfDocumenting ):
    attr= "Some class Value"
    def __init__( self ):
        """Create a new Instance"""
        self.instVar= "some instance value"
    def __str__( self ):
        """Display an instance"""
        return "%s %s" % ( self.attr, self.instVar )
</code></pre>
<p>I do not understand why getMethods gets an argument called aClass but when SomeClass is defined and it is called later (see below) it can figure out what to replace with aClass in getMethods method:</p>
<pre><code>&gt;&gt;&gt; ac= SomeClass()
&gt;&gt;&gt; ac.help()
[('__str__', 'Display an instance'), ('__init__', 'Create a new Instance')]
</code></pre>
<p><strong>UPDATE</strong>:
Thanks to the answer but for future reference my confusion originated from the fact that self is a reserved word and aClass is not. So I wasn't sure how that is being handled. @abarnert's comment I think clarifies that the code in documentation is not really representative. </p>
</div>
<div class="post-text" itemprop="text">
<p>This isn't really related to the fact that it is a <code>classmethod</code>.</p>
<p>For the same reason we don't need to pass the instance when calling a "normal" instance method, the instance (and in this case, the class) is passed implicitly.</p>
<pre><code>class Foo:
    def instance_method(self):
        print('No need to pass {} explictly'.format(self))

    @classmethod
    def class_method(cls):
        print('No need to pass {} explictly'.format(cls))

obj = Foo()

obj.instance_method()
# No need to pass &lt;__main__.Foo object at 0x0000000002A38DD8&gt; explictly

obj.class_method()
# No need to pass &lt;class '__main__.Foo'&gt; explictly
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer">Straight from the <code>classmethod</code> documentation</a>:</p>
<blockquote>
<p>A class method receives the class as implicit first argument, just like an instance method receives the instance</p>
</blockquote>
<p>This is the same for derived classes:</p>
<blockquote>
<p>If a class method is called for a derived class, the derived class object is passed as the implied first argument.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>According to the description, as in the below mentioned link 
 <a href="https://docs.python.org/2/library/functions.html#classmethod" rel="nofollow noreferrer">https://docs.python.org/2/library/functions.html#classmethod</a></p>
<p>A class method is a method that is bound to a class rather than its object. It doesn't require creation of a class instance, much like staticmethod.</p>
<p>The difference between a static method and a class method is:</p>
<ul>
<li>Static method knows nothing about the class and just deals with the
parameters Class method works with the class since its parameter is
always the class itself.</li>
</ul>
<p>The class method can be called both by the class and its object.
<strong>source:</strong>
<a href="https://www.programiz.com/python-programming/methods/built-in/classmethod" rel="nofollow noreferrer">https://www.programiz.com/python-programming/methods/built-in/classmethod</a></p>
<p>You can see the description of the @ClassMethod here in the <code>__ builtin __.py</code></p>
<pre><code>class classmethod(object):
    """
    classmethod(function) -&gt; method

    Convert a function to be a class method.

    A class method receives the class as implicit first argument,
    just like an instance method receives the instance.
    To declare a class method, use this idiom:

      class C:
          @classmethod
          def f(cls, arg1, arg2, ...):
              ...

    It can be called either on the class (e.g. C.f()) or on an instance
    (e.g. C().f()).  The instance is ignored except for its class.
    If a class method is called for a derived class, the derived class
    object is passed as the implied first argument.

    Class methods are different than C++ or Java static methods.
    If you want those, see the staticmethod builtin.
    """
    def __getattribute__(self, name): # real signature unknown; restored from __doc__
        """ x.__getattribute__('name') &lt;==&gt; x.name """
        pass

    def __get__(self, obj, type=None): # real signature unknown; restored from __doc__
        """ descr.__get__(obj[, type]) -&gt; value """
        pass

    def __init__(self, function): # real signature unknown; restored from __doc__
        pass

    @staticmethod # known case of __new__
    def __new__(S, *more): # real signature unknown; restored from __doc__
        """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
        pass

    __func__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
</code></pre>
</div>
<span class="comment-copy">Can an answer presume knowledge of <a href="https://docs.python.org/2/tutorial/classes.html#inheritance" rel="nofollow noreferrer">inheritance</a>?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>classmethod</code></a> has it's own documentation, which should help clear things up.</span>
<span class="comment-copy">As a side note, this may not be the best code to be learning from. Something that's this far from PEP 8 formatting, and that uses idiosyncratic names like <code>aClass</code> instead of <code>cls</code>, may be written by someone who's either not that experienced with Python, or hates it and wishes they were coding Java instead or something.</span>
<span class="comment-copy">Well an extra confusion is that aClass name is not really a reserved name whereas self is. So I wasn't sure what that aClass means. I think @abarnert's comment is very relevant here.</span>
<span class="comment-copy">@Cupitor <code>self</code> is <b>not</b> a reserved keyword</span>
<span class="comment-copy">Well, I am shocked... my editors always changed the color of it, so I assumed it is. didn't know I can fill in the blank with whatever (which is confusing actually).</span>
<span class="comment-copy">@Cupitor Then let me shock you even more. Since this whole mechanism is only a syntactic sugar, every instance method can be called through the class while providing an instance. In the example in my answer the line <code>Foo.instance_method(obj)</code> will work just fine.</span>
<span class="comment-copy">@Cupitor Indeed I forgot to init <code>obj</code>, I edited the code. And yes, calling <code>Foo.class_method(obj)</code> will result with an error since then 2 arguments will be passed in (<code>cls</code>, which is the class <code>Foo</code>, and <code>obj</code>): <code>class_method takes 1 positional argument but 2 were given</code></span>
