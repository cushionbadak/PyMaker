<div class="post-text" itemprop="text">
<p>I'm working on the following problem, I have a class, an asynchronous  method of which I want to mock patch:</p>
<pre><code>class ExampleClass:
    async def asy_method(self, param):
        return await some_coroutine(self, param)

example_instance = ExampleClass()
</code></pre>
<p>I want to patch specifically only calls like</p>
<pre><code>await example_instance.asy_method('test_param')
</code></pre>
<p>Normally I'd use </p>
<pre><code>mocker.patch('ExampleClass.asy_method', new_callable=AsyncMock)
</code></pre>
<p>where mocker is the pytest-mock plugin fixture and AsyncMock has the form</p>
<pre><code>class AsyncMock(mock.MagicMock):
    async def __call__(self, *args, **kwargs):
         return super(AsyncMock, self).__call__(*args, **kwargs)
</code></pre>
<p>which would give me a Mock object that behaves like a coroutine on call. 
The problem is, that I want to have access to the <code>self</code> attribute that is passed to the method. <code>self</code> is only passed to the mock object if you set 
<code>autospec=True</code> though (see also <a href="https://docs.python.org/3/library/unittest.mock-examples.html#mocking-unbound-methods" rel="nofollow noreferrer">Python Doc on patching unbound methods</a>), which you can't use together with <code>new_callable</code>.</p>
<p>Does anyone have an idea how to resolve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Indeed, you can't mix autospeccing and a new callable. Instead, autospec the method, but then replace the <code>side_effect</code> attribute, giving it an <code>AsyncMock()</code> instance:</p>
<pre><code>from unittest import mock


def configure_coroutine_mock(mock_function, klass=AsyncMock):
    """Make an autospecced async function return a coroutine mock"""
    mock_function.side_effect = AsyncMock()
    # mark the side effect as a child of the original mock object
    # so transitive access is recorded on the parent mock too. This is 
    # what .return_value does normally
    mock._check_and_set_parent(
        mock_function.mock, mock_function.side_effect,
        None, '()')
    return mock_asy_method.side_effect


with mocker.patch('ExampleClass.asy_method', autospec=True) as mock_asy_method:
    configure_coroutine_mock(mock_asy_method)
</code></pre>
<p>Because the <code>AsyncMock()</code> is a callable object, it'll be called <em>every time <code>mock_asy_method</code> is called</em>, and the arguments are passed on to the object. The result of that call is then used to return from <code>mock_asy_method()</code>:</p>
<pre><code>&gt;&gt;&gt; from unittest import mock
&gt;&gt;&gt; class ExampleClass:
...     async def asy_method(self, param):
...         return await some_coroutine(self, param)
...
&gt;&gt;&gt; example_instance = ExampleClass()
&gt;&gt;&gt; with mock.patch('__main__.ExampleClass.asy_method', autospec=True) as mock_asy_method:
...     configure_coroutine_mock(mock_asy_method)
...     print(example_instance.asy_method('foo'))  # call to patched class coroutine
...     print(mock_asy_method.mock_calls)          # calls are recorded
...
&lt;AsyncMock name='asy_method()' id='4563887496'&gt;
&lt;coroutine object AsyncMock.__call__ at 0x1100780f8&gt;
[call(&lt;__main__.ExampleClass object at 0x10ffac1d0&gt;, 'foo')]
</code></pre>
<p>As you can see, the <code>self</code> argument and the parameter are recorded in the call, because <code>mock_asy_method</code> is a properly specced function.</p>
<p>Of course, only if the returned <code>AsyncMock()</code> call result is actually awaited will we see that call recorded too:</p>
<pre><code>&gt;&gt;&gt; with mock.patch('__main__.ExampleClass.asy_method', autospec=True) as mock_asy_method:
...     configure_coroutine_mock(mock_asy_method)
...     loop = asyncio.get_event_loop()
...     coro = example_instance.asy_method('foo')
...     loop.run_until_complete(coro)
...     print(mock_asy_method.mock_calls)
...     
&lt;AsyncMock name='asy_method()' id='4564408920'&gt;
&lt;AsyncMock name='asy_method()()' id='4564999360'&gt;    
[call(&lt;__main__.ExampleClass object at 0x10ffac1d0&gt;, 'foo'),
 call()(&lt;__main__.ExampleClass object at 0x10ffac1d0&gt;, 'foo')]
</code></pre>
</div>
