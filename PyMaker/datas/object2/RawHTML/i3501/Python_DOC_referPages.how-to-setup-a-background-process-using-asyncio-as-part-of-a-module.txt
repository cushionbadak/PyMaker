<div class="post-text" itemprop="text">
<p>I'm writing a python module (experimental use case) which gives users the ability to send messages to another computer. The computer we want to send the message to has an unknown address which changes at arbitrary times. There is another computer (intermediary) which provides the address and time until the address expires. </p>
<p>For simplicity sake, let's call the one sending the message <em>computer-A</em>, the one receiving <em>computer-B</em> and <em>computer-C</em> is the intermediary we need to contact for computer-B's address. </p>
<p><strong>What I'm trying to accomplish:</strong></p>
<p>I want to be able to defer the process of waiting for the expiration time to be over to asyncio.sleep(). When the time expires, I would expect the process to get back control of the event loop and run a function to update the address.</p>
<p>The problem i'm struggling with is how do i implement this within a class where I cannot invoke run_until_complete/run_forever (or am i blatantly incorrect). How do you implement such a thing using the asyncio framework?</p>
<p><strong>Example hypothetical code?:</strong></p>
<pre><code>from some_random_messaging_service import deliver_msg

INTERMEDIARY_COMPUTER_C_ADDRESS = "some.random.address"

class CustomMessagingSystem:

    def __init__(self, computer=None):
        """Constructor

        :param computer: computer name

        """
        self.addresses = {}
        if computer:
            self.get_address(computer)

    def get_address(self, computer):
        """Gets address from computer-C (intermediary)

        :param computer: computer name

        """
        self.addresses[computer] = self.find_address(INTERMEDIARY_COMPUTER_C_ADDRESS, computer)
        await self.update_address(computer, self.expiration_time(computer))

    def expiration_time(self, computer):
        """
        :param computer: computer name
        :return: address expiration time in seconds
        """
        return self.addresses[computer][1]

    def address(self, computer):
        """

        :param computer: computer name
        :return: computer address

        """
        return self.addresses[computer][0]

    async def update_address(self, computer, expiration_time):
        """updates address of computer after given expiration_time

        :param computer: computer name
        :expiration_time: expiration time in seconds

        """
        asyncio.sleep(expiration_time)
        self.get_address(computer)

    def send_message(self, computer, message):
        """Sends message to target computer

        :param computer: computer name
        :param message: UTF-8 message

        """
        deliver_msg(self.address(computer), message)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A way to accomplish this is to have your class schedule a task on the event loop using <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_task" rel="nofollow noreferrer"><code>create_task</code></a>.
This can be done before or after the event loop has been started.</p>
<p>As you want to have a separate timer for each address, it would be simplest to have 1 task per address;
we can keep these in a dictionary alongside the addresses:</p>
<pre><code>class CustomMessagingSystem:

    def __init__(self, computer=None, ioloop=asyncio.get_event_loop()):
        self.addresses = {}
        self.updaters = {}
        self.ioloop = ioloop
        if computer:
            self._add_address(computer)

    def get_address(self, computer):
        try:
            return self.addresses[computer]
        except KeyError:
            self._add_address(computer)
            return self.addresses[computer]

    def _add_address(self, computer):
            address = self.find_address(INTERMEDIARY_COMPUTER_C_ADDRESS, computer)
            task = self.ioloop.create_task(self._update_address, computer)
            self.updaters[computer] = task
            self.addresses[computer] = address

    async def _update_address(self, computer):
        while True:
            addr, expiration_time = self.find_address(INTERMEDIARY_COMPUTER_C_ADDRESS, computer)
            self.addresses[addr] = addr
            await asyncio.sleep(expiration_time)

    def send_message(self, computer, message):
        deliver_msg(self.get_address(computer), message)
</code></pre>
<p>Naturally, if the event loop is never started, then the updating will never happen.</p>
<p>Finally, something that you'll want to do is to control the lifetime of these updater tasks.
I didn't implement this in the above example to keep it short.
The standard approach is to make your class into a context manager, and get <code>__exit__</code>
to cancel all the updaters.</p>
</div>
<div class="post-text" itemprop="text">
<p>The general flow of an asyncio program is something like this.</p>
<pre><code>async def long_io_bound_operation():
    await &lt;call some async function that does your work&gt;
    ...

def main():
    asyncio.get_event_loop().run_until_complete(long_io_bound_operation())
</code></pre>
<p>There are other ways to actually wait on the coroutine returned by the function call <code>long_io_bound_operation()</code> depending on what you want, but this is the main form of it.  Read up on the asyncio module for the gritty details, but the gist of it is that every time you use the <code>await</code> keyword, the python runtime can elect to do a non-blocking wait for the result rather than blocking and spinning waiting on some work to be done.</p>
<p>It's a little unclear to me from your code exactly what protocol you plan to invoke for this communication, but it's a really good bet that there is already an asyncio-compliant wrapper around that protocol written for you to leverage.  <code>aiohttp</code> is an async wrapper for http request, for example.</p>
<p>If you give more details about the protocol you're using, then you'll probably get more specific advice for your problem.  Hope this general summary is useful, though.</p>
</div>
<span class="comment-copy">This comes close to what I was describing - to your point Joe, I suppose it's up to the user of this code to start the event loop?  I should look into several asyncio support modules to see how they implemented it</span>
<span class="comment-copy">Yes, if you want to use asyncio then the client program will always need to "cooperate" with you by using asyncio itself. If you don't want this restriction then another option would be to use threads, but then you enter into a whole other world of pain.</span>
