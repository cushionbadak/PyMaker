<div class="post-text" itemprop="text">
<p>I am having this error:</p>
<pre><code>  File "/boo/foot/routing/models.py", line 133, in indexing
  contact = self.contact.get_full_name() if self.contact else '',
AttributeError: 'NoneType' object has no attribute 'get_full_name'
</code></pre>
<p>my code is:</p>
<pre><code>class Visit(models.Model):
    contact = models.ForeignKey(Contact, on_delete=models.SET_NULL, null=True, blank=True )


    def indexing(self):
        obj = VisitIndex(
            meta = { 'id' : self.id },
            contact = self.contact.get_full_name() if self.contact  else '',
        )
        print(obj)
        obj.save()
</code></pre>
<p>and the indexing method is attached to the <code>post_save</code> signal:</p>
<pre><code>@receiver(post_save, sender = Visit)
def index_post(sender, instance, **kwargs):
    instance.indexing()
</code></pre>
<p>I am testing if <code>self.contact</code> is not falsy in order to get <code>get_full_name()</code>... yet, it seems even with NoneType it gets to that part. Where could the problem be?</p>
</div>
<div class="post-text" itemprop="text">
<p>You already know this, but with your code, that error can only occur if <code>self.contact</code> is <code>None</code>. But the truthiness test will fail if <code>self.contact</code> is <code>None</code>, so that section of code canâ€™t be reached. You are right about both of these things. The conclusion must be that something is not as it appears with your code. If you try to put together a minimum, verifiable example (a short section of code that others can run to reproduce the problem), then you will probably find the error. That is similar to a structured debugging process (keep narrowing the problem until you find the source), and I often find I discover my errors as I try to write a good question about them. </p>
<p>Alternatively, as a first debugging step, it would be helpful to take a closer look at <code>self.contact</code> Is it <code>None</code> or not? You can also make your test a little more precise (although it shouldn't be necessary):</p>
<pre><code>def indexing(self):
    print(self.contact) # is it really None?
    if hasattr(self.contact, 'get_full_name'):
        contact = self.contact.get_full_name()
    else:
        contact = ''
    obj = VisitIndex(
        meta={ 'id' : self.id },
        contact=contact,
    )
    print(obj)
    obj.save()
</code></pre>
<p>This is arguably more 'pythonic' and slightly faster, but I like it less:</p>
<pre><code>try:
    get_full_name = self.contact.get_full_name
except AttributeError:
    contact = ''
else:
    contact = get_full_name()
</code></pre>
</div>
<span class="comment-copy">Anything <b>OTHER THAN</b> <code>None</code>; <code>False</code>; empty containers (strings, dicts, lists); numeric zeros; and user defined False is True in Python. <code>type(None)</code> is not empty and not any of the define False things -- therefore <code>True</code>.  See <a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="nofollow noreferrer">Boolean Operations in Python</a></span>
<span class="comment-copy">How about just outputting <code>self.contact</code>? The first time you access the object, it's an <code>ForeignKey</code> representation - and the result might be different. @dawg - If it were a type object, the error message would be ".. type object 'NoneType' ...".</span>
<span class="comment-copy">@MatsLindh I will try to get he output of self.contact</span>
