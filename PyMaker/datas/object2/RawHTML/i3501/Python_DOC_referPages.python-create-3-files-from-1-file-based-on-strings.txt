<div class="post-text" itemprop="text">
<p>I have a large dataset that is stored in a file on Linux.  I would like to write a python script that will take this file and write it to 3 files based on the first occurrence of 3 specific strings.</p>
<p>My dataset looks like this:</p>
<pre><code>Handle: A1
OrgID: AA
Name: Name1

Handle: A2
OrgID: BB 
Name: Name2

OrgID: 1111
OrgName: Name1
Street: 1111 Street

OrgID: 2222
OrgName: Name2
Street: 2222 Street

NetHandle: Net1
OrgID: AA
Parent: Net1

NetHandle: Net2
OrgID: BB
Parent: Net2
</code></pre>
<p>I want the first file to have all of the entries that start with "Handle" and stop before the entries that start with OrgID".  The second file with entries that start with "OrgID" and the third file that starts with "NetHandle".  The tricky part is that OrigID is in all three.  I have tried a few ways from examples on stack and other sites but I have not been able to accomplish this yet.  Any help would be greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming what you've posted is the literal file format, the simplest thing to do is read chunks of 4 lines at a time and switch on the first line.<sup>1</sup></p>
<hr/>
<p>We can use the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>grouper</code> recipe from the <code>itertools</code> docs</a>, which can chunk anything into groups of any fixed size. But I'll show you how to do it without the recipe, because it's worth understanding how it works:</p>
<pre><code>with open('dataset.txt', 'r') as f:
    # Create a list with 4 references to the same iterator.
    iters = [iter(f)] * 4
    # Zip into an iterator that grabs one value from each reference.
    chunks = zip(*iters)
    # Now each chunk is a tuple of four successive values.
    for chunk in chunks:
</code></pre>
<hr/>
<p>Now, how do we switch on the groups? The simplest thing to do here is make a dictionary mapping labels to output files:</p>
<pre><code>outfiles = {'Handle': handles, 'OrgID': orgs, 'NetHandle': nets}
</code></pre>
<p>… then just extract the label from each chunk and look up the output file:</p>
<pre><code>firstline = chunk[0]
label = firstline.split(':')[0]
outfile = outfiles[label]
</code></pre>
<p>You might want some error handling here. But if you're pretty sure the file doesn't have any chunks that don't match exactly one of these three formats, this is probably good enough.<sup>2</sup></p>
<hr/>
<p>Putting it together:</p>
<pre><code>with open('dataset.txt', 'r') as f, open('handles.txt', 'w') as handles, \
      open('orgs.txt', 'w') as orgs, open('nets.txt', 'w') as nets:
    outfiles = {'Handle': handles, 'OrgID': orgs, 'NetHandle': nets}
    for chunk in zip(*([iter(f)]*4)):
        label = chunk[0].split(':')[0]
        outfiles[label].writelines(chunk)
</code></pre>
<p>Or, if you use the <code>grouper</code> recipe (which you should):</p>
<pre><code>with open('dataset.txt', 'r') as f, open('handles.txt', 'w') as handles, \
      open('orgs.txt', 'w') as orgs, open('nets.txt', 'w') as nets:
    outfiles = {'Handle': handles, 'OrgID': orgs, 'NetHandle': nets}
    for chunk in grouper(f, 4):
        label = chunk[0].split(':')[0]
        outfiles[label].writelines(chunk)
</code></pre>
<hr/>
<p>If the file doesn't actually end in a newline, the last chunk is going to fail. But you can fix that easily by specifying <code>''</code> as a <code>fillvalue</code>:</p>
<pre><code>    for chunk in grouper(f, 4, ''):
</code></pre>
<hr/>
<p><sub>1. You could make things a tiny bit more efficient—although not quite as simple—if you can assume that all the Handle chunks come first, then all the OrgID chunks, then all the NetHandle chunks. But when I asked whether that was true, you just answered "They are all in chunks", which does nothing to resolve the ambiguity. So, I'll write it to handle the possibility that they're intermixed.</sub></p>
<p><sub>2. If you're wrong, and one of the chunks starts with <code>'Spam:'</code>, you'll get a <code>KeyError: 'Spam'</code>. Or, if one of the chunks isn't 4 lines long, so you end up getting out of sync and reading the <code>Street:</code> as the first line, you'll get <code>KeyError: 'Street'</code>. So, any unexpected input should be pretty easy to debug.</sub></p>
</div>
<span class="comment-copy">are all entries 3 lines from beginning to end?</span>
<span class="comment-copy">Are there entries that start with "Handle" that occur after the first occurrence of "OrgID"? Think about using <code>enumerate</code> and checking that the previous line is blank.</span>
<span class="comment-copy">Are those single and pentuple dots literally in the input file like that? If so, you don't even really need to switch on the groups; every group is a <code>Handle</code> until you hit the <code>.</code>, then skip over the <code>.....</code> and every group is a <code>OrgID</code> until you hit the <code>.</code>, etc.</span>
<span class="comment-copy">Yes, all entries have 3 lines from the beginning to the end @ ak_slick</span>
<span class="comment-copy">Please avoid <i>"Give me the codez"</i> questions. Also see <a href="https://meta.stackoverflow.com/q/261592/608639">How much research effort is expected of Stack Overflow users?</a></span>
<span class="comment-copy">This doesn't seem to work... everything outputs in handles.txt</span>
<span class="comment-copy">@ak_slick You didn't answer whether the <code>.</code> and <code>.....</code> lines were in the actual input file. Obviously if they aren't there, splitting on them won't work.</span>
<span class="comment-copy">@ak_slick Try the new version. It works with your updated question example.</span>
