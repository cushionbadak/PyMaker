<div class="post-text" itemprop="text">
<p>I have a list of dictionaries which have a date string within them. I would like to remove a single entry of two if there is a matching hour and minute for that record. </p>
<p>Here is some sample data, as you can see the first two dictionaries have 14:21 in them, I would only like one of those dictionaries and the other to be removed.</p>
<p>I'm not sure how to even start with this one, is it possible?</p>
<pre><code>[{'x': '2018-06-19 14:21:22', 'y': 80},
{'x': '2018-06-19 14:21:26', 'y': 86},
{'x': '2018-06-19 14:24:02', 'y': 89},
{'x': '2018-06-19 14:24:07', 'y': 95},
{'x': '2018-06-19 14:25:10', 'y': 127}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is one approach using a simple iteration and a check list.</p>
<p><strong>Demo:</strong></p>
<pre><code>checkVal = set()
data = [{'x': '2018-06-19 14:21:22', 'y': 80}, {'x': '2018-06-19 14:21:26', 'y': 86}, {'x': '2018-06-19 14:24:02', 'y': 89}, {'x': '2018-06-19 14:24:07', 'y': 95}, {'x': '2018-06-19 14:25:10', 'y': 127}, {'x': '2018-06-19 14:25:14', 'y': 138}, {'x': '2018-06-19 14:28:04', 'y': 91}, {'x': '2018-06-19 14:28:08', 'y': 83}, {'x': '2018-06-19 14:30:11', 'y': 92}, {'x': '2018-06-19 14:30:16', 'y': 99}, {'x': '2018-06-19 14:31:21', 'y': 80}, {'x': '2018-06-19 14:31:26', 'y': 90}, {'x': '2018-06-19 14:34:03', 'y': 131}, {'x': '2018-06-19 14:34:07', 'y': 137}, {'x': '2018-06-19 14:35:28', 'y': 98}, {'x': '2018-06-19 14:35:32', 'y': 91}, {'x': '2018-06-19 14:37:11', 'y': 86}, {'x': '2018-06-19 14:37:16', 'y': 92}, {'x': '2018-06-19 14:39:02', 'y': 111}, {'x': '2018-06-19 14:39:06', 'y': 118}, {'x': '2018-06-19 14:42:03', 'y': 95}, {'x': '2018-06-19 14:42:08', 'y': 104}, {'x': '2018-06-19 14:43:04', 'y': 165}, {'x': '2018-06-19 14:43:09', 'y': 168}, {'x': '2018-06-19 14:45:11', 'y': 89}, {'x': '2018-06-19 14:45:15', 'y': 94}, {'x': '2018-06-19 14:47:11', 'y': 133}, {'x': '2018-06-19 14:47:16', 'y': 146}, {'x': '2018-06-19 14:49:16', 'y': 134}, {'x': '2018-06-19 14:49:21', 'y': 146}, {'x': '2018-06-19 14:52:05', 'y': 157}, {'x': '2018-06-19 14:52:09', 'y': 169}, {'x': '2018-06-19 14:54:13', 'y': 66}, {'x': '2018-06-19 14:54:17', 'y': 63}, {'x': '2018-06-19 14:55:09', 'y': 95}, {'x': '2018-06-19 14:55:14', 'y': 90}, {'x': '2018-06-19 14:58:02', 'y': 112}, {'x': '2018-06-19 14:58:07', 'y': 119}, {'x': '2018-06-19 14:59:09', 'y': 98}, {'x': '2018-06-19 14:59:13', 'y': 91}]

res = []
for i in data:
    if i["x"][:-3] not in checkVal:
        res.append(i)
        checkVal.add(i["x"][:-3])
print(res)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>[{'y': 80, 'x': '2018-06-19 14:21:22'}, {'y': 89, 'x': '2018-06-19 14:24:02'}, {'y': 127, 'x': '2018-06-19 14:25:10'}, {'y': 91, 'x': '2018-06-19 14:28:04'}, {'y': 92, 'x': '2018-06-19 14:30:11'}, {'y': 80, 'x': '2018-06-19 14:31:21'}, {'y': 131, 'x': '2018-06-19 14:34:03'}, {'y': 98, 'x': '2018-06-19 14:35:28'}, {'y': 86, 'x': '2018-06-19 14:37:11'}, {'y': 111, 'x': '2018-06-19 14:39:02'}, {'y': 95, 'x': '2018-06-19 14:42:03'}, {'y': 165, 'x': '2018-06-19 14:43:04'}, {'y': 89, 'x': '2018-06-19 14:45:11'}, {'y': 133, 'x': '2018-06-19 14:47:11'}, {'y': 134, 'x': '2018-06-19 14:49:16'}, {'y': 157, 'x': '2018-06-19 14:52:05'}, {'y': 66, 'x': '2018-06-19 14:54:13'}, {'y': 95, 'x': '2018-06-19 14:55:09'}, {'y': 112, 'x': '2018-06-19 14:58:02'}, {'y': 98, 'x': '2018-06-19 14:59:09'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You already have an answer, but for a very efficient solution use the itertools <code>unique_everseen</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipe</a>. It's also safer since it will throw a useful error if the input date isn't valid.</p>
<pre><code>from datetime import datetime
from itertools import filterfalse

input_ = [{'x': '2018-06-19 14:21:22', 'y': 80},
          {'x': '2018-06-19 14:21:26', 'y': 86},
          {'x': '2018-06-19 14:24:02', 'y': 89},
          {'x': '2018-06-19 14:24:07', 'y': 95},
          {'x': '2018-06-19 14:25:10', 'y': 127}]

def unique_everseen(iterable, key=None):
    """List unique elements, preserving order. Remember all elements ever seen.
    # unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D
    # unique_everseen('ABBCcAD', str.lower) --&gt; A B C D
    """
    seen = set()
    seen_add = seen.add
    if key is None:
        for element in filterfalse(seen.__contains__, iterable):
            seen_add(element)
            yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen_add(k)
                yield element

def hour_and_min(dct):
    fmt = '%Y-%m-%d %H:%M:%S'
    d = datetime.strptime(dct['x'], fmt)
    return d.hour, d.minute  # add `, d.year, d.month, d.day` if you care about these

output = list(unique_everseen(input_, key=hour_and_min))
</code></pre>
<hr/>
<p>And output is:</p>
<pre><code>[{'x': '2018-06-19 14:21:22', 'y': 80},
 {'x': '2018-06-19 14:24:02', 'y': 89},
 {'x': '2018-06-19 14:25:10', 'y': 127}]
</code></pre>
</div>
<span class="comment-copy">Yes, it is possible. You could, for example, parse the strings to datetimes, compare the hour and minute parts, and implement some logic to decide which one (first?) should end up in the output.</span>
<span class="comment-copy">so simple! i like it! In my head it was way more complicated!</span>
<span class="comment-copy">Should be <code>check_val</code> but +1 anyway ;)</span>
