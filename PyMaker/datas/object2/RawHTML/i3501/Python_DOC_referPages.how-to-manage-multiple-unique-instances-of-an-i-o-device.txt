<div class="post-text" itemprop="text">
<p>I have a I/O serial device (a class, calling it here <code>SerialPort</code>) that other parts of my program will read/write to. <code>SerialPort</code> handles the connection to the port (pyserial), threading of the I/O, and is implemented as a pub/sub design, other classes in my program get called back if there is a new message, or can write new messages. The device has &gt;100 supported messages and responses, hence the pub/sub design (not the center of this question but just wanted to clarify choice). </p>
<p>Now I need to add 2 (or more) of the same device. What I would like to do is have any observer call something like:</p>
<pre><code># The name of the devices and corresponding serial ports are known at run time. So in the program there will be N known devices.

# Where SerialPort("UniqueName1") is connected to port /dev/ttyUSB0
some_observer = Observer(SerialPort("UniqueName1"))
# Where SerialPort("UniqueName2") is connected to port /dev/ttyUSB2
other_observer = Observer(SerialPort("UniqueName2"))
# Here some_observer and random_observer both get the same instance of SerialPort("UniqueName1")
random_observer = Observer(SerialPort("UniqueName1"))
</code></pre>
<p>Where in Observer() an instance (or an interface) of SerialPort is kept, so Observer can write, and register callbacks to SerialPort. The part I am stuck on is how to handle that every call to SerialPort("UniqueName1") should just return the already connected SerialPort object (assuming its been connected/initialized earlier). Observer should just be able to say "I want to talk to a device with UniqueName1 (or 2)"  </p>
<p>In this fashion I could then have an observer of both SerialPort objects by keeping two (or more) SerialPort references in Observer. I dont need to do this, but this design does not restrict me if I need to in the future.</p>
<p>Any advice on how to do this in python (2.7)? I am new to python, googling as I go. I just need help on where I should put the python/pseudo code below. I tried to put this in the class Serialport but the <code>SerialPort.__init__(name)</code> did not let me return an already created SerialPort device</p>
<pre><code># Somewhere in the code
sp = SerialPort(name="UniqueName1")
# Now in SerialPort, where all_serial_ports = list of available SerialPorts
for serial_ports in all_serial_ports:
    if serial_ports.name == name:
        return serial_port
# Did not find serial port (need to do something)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While it <em>is</em> possible to intercept the <code>SerialPort</code> constructor so that <code>SerialPort("UniqueName1")</code> returns the existing value (if any) instead of creating a new one,<sup>1</sup> that's usually not what you want to do.</p>
<p>The simplest solution is to just store a dict of serial ports, but this requires manually looking things up each time:</p>
<pre><code>if "UniqueName1" not in ports:
    ports["UniqueName1"] = SerialPort("UniqueName1")
some_observer = Observer(ports["UniqueName1"])
</code></pre>
<p>So, you might want to make the dict private and wrap up the access in a function:</p>
<pre><code>def getport(name):
    if port not in _ports:
        ports[name] = SerialPort(name)
    return ports[name]
</code></pre>
<p>And now you just call that function:</p>
<pre><code>some_observer = Observer(getport("UniqueName1"))
</code></pre>
<p>You can just put this function in the same module as your <code>SerialPort</code> or <code>Observer</code> class.</p>
<p>If you might have multiple different name-to-ports mappings, you'd probably want to instead wrap this in a <code>SerialPortManager</code> class whose instances have a <code>self._ports</code> and a <code>getport</code> method, but otherwise you don't need that.</p>
<hr/>
<p><sub> 1. If you really do want to intercept the constructor, the way to do that is with a <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a> method. The default implementation just returns a new empty object of your type, and if you return that, your <code>__init__</code> method gets called. But you can return anything else you want instead. Which includes not calling the <code>super()</code> version and instead looking up a value in some private dict.</sub></p>
</div>
<span class="comment-copy">Do you really want this to be handled by the constructor of the <code>SerialPort</code> class, instead of a call to some instance of a <code>SerialPorts</code> or <code>SerialPortManager</code> classâ€”or just a lookup in a public dict?</span>
<span class="comment-copy">@abarnert Im not sure, not sure what makes the most sense. If it was handled by a SerialPortManager, would it be something like SerialPortManager.get_serial_port("UniqueName1")?</span>
<span class="comment-copy">Your right, I probably should keep it simple and not make it over complicated. I will however check out the <code>__new__</code> for my own learning.</span>
<span class="comment-copy">@user2840470 The one tricky thing to watch out for with <code>__new__</code> is that whether it calls <code>__init__</code> depends entirely on whether what you return passes <code>isinstance(obj, cls)</code>, not on whether you retrieved it through <code>super().__new__</code> or not. The simplest solution is usually to make <code>__init__</code> idempotent (or even a no-op) and do the initialization inside <code>__new__</code> instead. If you search for singleton libraries, you should find some examples of that.</span>
