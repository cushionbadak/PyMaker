<div class="post-text" itemprop="text">
<p>I have been given code to control a vacuum pump and take measurements in my lab that runs correctly on version 2.7 of python, however the computer that is linked to the vacuum system in the lab only has version 3.0 so the code does not run correctly. </p>
<p>If anyone could update the code I would be very grateful. </p>
<p>Code: </p>
<pre><code># -*- coding: utf-8 -*-
"""
Created on Fri Jul 14 10:25:56 2017

@author: jav2g09

This module contains drivers for the following equipment from Pfeiffer
Vacuum:

* TPG 262 and TPG 261 Dual Gauge. Dual-Channel Measurement and Control
    Unit for Compact Gauges
"""
print ("start")
import time
import serial
import numpy as np

# Code translations constants
MEASUREMENT_STATUS = {
    0: 'Measurement data okay',
    1: 'Underrange',
    2: 'Overrange',
    3: 'Sensor error',
    4: 'Sensor off (IKR, PKR, IMR, PBR)',
    5: 'No sensor (output: 5,2.0000E-2 [mbar])',
    6: 'Identification error'
}
GAUGE_IDS = {
    'TPR': 'Pirani Gauge or Pirani Capacitive gauge',
    'IKR9': 'Cold Cathode Gauge 10E-9 ',
    'IKR11': 'Cold Cathode Gauge 10E-11 ',
    'PKR': 'FullRange CC Gauge',
    'PBR': 'FullRange BA Gauge',
    'IMR': 'Pirani / High Pressure Gauge',
    'CMR': 'Linear gauge',
    'noSEn': 'no SEnsor',
    'noid': 'no identifier'
}
PRESSURE_UNITS = {0: 'mbar/bar', 1: 'Torr', 2: 'Pascal'}


class TPG26x(object):
    r"""Abstract class that implements the common driver for the TPG 261 and
    TPG 262 dual channel measurement and control unit. The driver implements
    the following 6 commands out the 39 in the specification:

    * PNR: Program number (firmware version)
    * PR[1,2]: Pressure measurement (measurement data) gauge [1, 2]
    * PRX: Pressure measurement (measurement data) gauge 1 and 2
    * TID: Transmitter identification (gauge identification)
    * UNI: Pressure unit
    * RST: RS232 test

    This class also contains the following class variables, for the specific
    characters that are used in the communication:

    :var ETX: End text (Ctrl-c), chr(3), \\x15
    :var CR: Carriage return, chr(13), \\r
    :var LF: Line feed, chr(10), \\n
    :var ENQ: Enquiry, chr(5), \\x05
    :var ACK: Acknowledge, chr(6), \\x06
    :var NAK: Negative acknowledge, chr(21), \\x15
    """

    ETX = chr(3)  # \x03
    CR = chr(13)
    LF = chr(10)
    ENQ = chr(5)  # \x05
    ACK = chr(6)  # \x06
    NAK = chr(21)  # \x15

    def __init__(self, port='067B:2303', baudrate=9600): #/dev/ttyUSB0
        """Initialize internal variables and serial connection

        :param port: The COM port to open. See the documentation for
            `pyserial &lt;http://pyserial.sourceforge.net/&gt;`_ for an explanation
            of the possible value. The default value is '/dev/ttyUSB0'.
        :type port: str or int
        :param baudrate: 9600, 19200, 38400 where 9600 is the default
        :type baudrate: int
        """
        # The serial connection should be setup with the following parameters:
        # 1 start bit, 8 data bits, No parity bit, 1 stop bit, no hardware
        # handshake. These are all default for Serial and therefore not input
        # below
        self.serial = serial.Serial(port=port, baudrate=baudrate, timeout=1)

    def _cr_lf(self, string):
        """Pad carriage return and line feed to a string

        :param string: String to pad
        :type string: str
        :returns: the padded string
        :rtype: str
        """
        return string + self.CR + self.LF

    def _send_command(self, command):
        """Send a command and check if it is positively acknowledged

        :param command: The command to send
        :type command: str
        :raises IOError: if the negative acknowledged or a unknown response
            is returned
        """
        self.serial.write((self._cr_lf(command)).encode()) #  
        response = self.serial.readline()
        if response == self._cr_lf(self.NAK):
            message = 'Serial communication returned negative acknowledge'
            raise IOError(message)
        elif response != self._cr_lf(self.ACK):
            message = 'Serial communication returned unknown response:\n{}'\
                ''.format(repr(response))
            raise IOError(message)

    def _get_data(self):
        """Get the data that is ready on the device

        :returns: the raw data
        :rtype:str
        """
        self.serial.write(self.ENQ)
        data = self.serial.readline()
        return data.rstrip(self.LF).rstrip(self.CR)

    def _clear_output_buffer(self):
        """Clear the output buffer"""
        time.sleep(0.1)
        just_read = 'start value'
        out = ''
        while just_read != '':
            just_read = self.serial.read()
            out += just_read
        return out

    def program_number(self):
        """Return the firmware version

        :returns: the firmware version
        :rtype: str
        """
        self._send_command('PNR')
        return self._get_data()

    def pressure_gauge(self, gauge=1):
        """Return the pressure measured by gauge X

        :param gauge: The gauge number, 1 or 2
        :type gauge: int
        :raises ValueError: if gauge is not 1 or 2
        :return: (value, (status_code, status_message))
        :rtype: tuple
        """
        if gauge not in [1, 2]:
            message = 'The input gauge number can only be 1 or 2'
            raise ValueError(message)
        self._send_command('PR' + str(gauge))
        reply = self._get_data()
        status_code = int(reply.split(',')[0])
        value = float(reply.split(',')[1])
        return value, (status_code, MEASUREMENT_STATUS[status_code])

    def pressure_gauges(self):
        """Return the pressures measured by the gauges

        :return: (value1, (status_code1, status_message1), value2,
            (status_code2, status_message2))
        :rtype: tuple
        """
        self._send_command('PRX')
        reply = self._get_data()
        # The reply is on the form: x,sx.xxxxEsxx,y,sy.yyyyEsyy
        status_code1 = int(reply.split(',')[0])
        value1 = float(reply.split(',')[1])
        status_code2 = int(reply.split(',')[2])
        value2 = float(reply.split(',')[3])
        return (value1, (status_code1, MEASUREMENT_STATUS[status_code1]),
                value2, (status_code2, MEASUREMENT_STATUS[status_code2]))

    def pressure_value(self):
        """Return the pressures measured by the gauges
        :return: [Tiem Value]
        """
        self._send_command('PRX')
        reply = self._get_data()
        # The reply is on the form: x,sx.xxxxEsxx,y,sy.yyyyEsyy
        status_code1 = int(reply.split(',')[0])
        value1 = float(reply.split(',')[1])
        status_code2 = int(reply.split(',')[2])
        value2 = float(reply.split(',')[3])
        return value1

    def gauge_identification(self):
        """Return the gauge identication

        :return: (id_code_1, id_1, id_code_2, id_2)
        :rtype: tuple
        """
        self._send_command('TID')
        reply = self._get_data()
        id1, id2 = reply.split(',')
        return id1, GAUGE_IDS[id1], id2, GAUGE_IDS[id2]

    def pressure_unit(self):
        """Return the pressure unit

        :return: the pressure unit
        :rtype: str
        """
        self._send_command('UNI')
        unit_code = int(self._get_data())
        return PRESSURE_UNITS[unit_code]

    def rs232_communication_test(self):
        """RS232 communication test

        :return: the status of the communication test
        :rtype: bool
        """
        self._send_command('RST')
        self.serial.write(self.ENQ)
        self._clear_output_buffer()
        test_string_out = ''
        for char in 'a1':
            self.serial.write(char)
            test_string_out += self._get_data().rstrip(self.ENQ)
        self._send_command(self.ETX)
        return test_string_out == 'a1'


class TPG262(TPG26x):
    """Driver for the TPG 262 dual channel measurement and control unit"""

    def __init__(self, port='/dev/ttyUSB0', baudrate=9600):
        """Initialize internal variables and serial connection

        :param port: The COM port to open. See the documentation for
            `pyserial &lt;http://pyserial.sourceforge.net/&gt;`_ for an explanation
            of the possible value. The default value is '/dev/ttyUSB0'.
        :type port: str or int
        :param baudrate: 9600, 19200, 38400 where 9600 is the default
        :type baudrate: int        
        """
        super(TPG262, self).__init__(port=port, baudrate=baudrate)


class TPG261(TPG26x):
    """Driver for the TPG 261 dual channel measurement and control unit"""

    def __init__(self, port='/dev/ttyUSB0', baudrate=9600):
        """Initialize internal variables and serial connection

        :param port: The COM port to open. See the documentation for
            `pyserial &lt;http://pyserial.sourceforge.net/&gt;`_ for an explanation
            of the possible value. The default value is '/dev/ttyUSB0'.
        :type port: str or int
        :param baudrate: 9600, 19200, 38400 where 9600 is the default
        :type baudrate: int
        """
        super(TPG261, self).__init__(port=port, baudrate=baudrate)




gauge = TPG262(port='COM4')#


P=[]
T=[]

import time

start_time = time.time()
interval = 1

for i in range(85999):
    time.sleep(start_time + i*interval - time.time())
    print (gauge.pressure_value())
    P.append(int(gauge.pressure_value()))
    end = time.time()
    T.append(end - start_time)
    print(end - start_time)
    np.savetxt('BakeOutEmptySystem.txt', np.c_[T,P])
    print ("Saved!")



print ("done")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The program <code>2to3</code> could update (at least to some extent) the code for you. It can be used like this:</p>
<pre><code>2to3 -n -W --add-suffix=.out.py script.py
</code></pre>
<p>The output file here will be <code>script.py.out.py</code> in the same directory.</p>
<p>Details: <a href="https://docs.python.org/3/library/2to3.html" rel="nofollow noreferrer">https://docs.python.org/3/library/2to3.html</a>.</p>
</div>
<span class="comment-copy">the print statements have brackets. this is python3.x, also we will not just update the code for you that's not what we do.</span>
<span class="comment-copy">Stack Overflow is not a free coding service. If you need someone to do work for you, hire a developer.</span>
<span class="comment-copy">Also, someone in your lab needs to learn how python modules work and <code>import</code> the driver, rather than throwing their code at the bottom of it, ruining it for anyone who tries to import it.</span>
<span class="comment-copy">Please post less code, your code is way to much</span>
<span class="comment-copy">@Hester I'm sorry your supervisor is so lazy and disrespectful to the Stack Overflow community.</span>
<span class="comment-copy">how do you use that?</span>
<span class="comment-copy">Why don't you do some research on how to use <code>2to3</code>?</span>
<span class="comment-copy">@Hester I've updated the answer. (ResetACK: Did you ask me or Hester?)</span>
<span class="comment-copy">@KirillBulygin thank you so much!</span>
<span class="comment-copy">@ResetACK I did some but didn't understand it, I'm not very good at python and yet here I am</span>
