<div class="post-text" itemprop="text">
<p>So I currently have a nested list. </p>
<pre><code>org_network=[[1, 2, 3], [1, 4, 5], [1, 3, 6], [7, 9, 10]]
</code></pre>
<p>I need to figure out how to manipulate it to create lists of possible combinations of the nested lists. These combinations cannot have lists that share numbers. Here is an example of what the result should be:</p>
<pre><code>network_1=[[1,2,3],[7,9,10]]
network_2=[[1,4,5],[7,9,10]]
network_3=[[1,3,6],[7,9,10]]
</code></pre>
<p>Note: 
1. This code is going to be linked to a constantly updated csv file, so the org_network list will have varying amounts of elements within it (which also means that there will be numerous resulting networks.</p>
<p>I have been working on this for about four hours and have yet to figure it out. Any help would be very appreciated. I have primarily been trying to use for loops and any() functions to no avail. Thanks for any help.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations()</code></a> with set intersection:</p>
<pre><code>&gt;&gt;&gt; from itertools import combinations
&gt;&gt;&gt; org_network=[[1, 2, 3], [1, 4, 5], [1, 3, 6], [7, 9, 10]]
&gt;&gt;&gt; [[x, y] for x, y in combinations(org_network, r=2) if not set(x).intersection(y)]
[[[1, 2, 3], [7, 9, 10]], [[1, 4, 5], [7, 9, 10]], [[1, 3, 6], [7, 9, 10]]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is an approach that will be efficient if the number of unique elements is small relative to the number of sets.</p>
<p>Steps:</p>
<ol>
<li>For each unique element, store indices of all sets in which the element <em>does not</em> occur.</li>
<li>For each set <code>s</code> in the network, find all other sets that contain every element of <code>s</code> using data from the first step.</li>
<li>Iterate over pairs, discarding duplicates based on ID order.</li>
</ol>
<hr/>
<pre><code>from functools import reduce

org_network = [[1, 2, 3], [1, 4, 5], [1, 3, 6], [7, 9, 10]]

# convert to sets
sets = [set(lst) for lst in org_network]

# all unique numbers
uniqs = set().union(*sets)

# map each unique number to sets that do not contain it:
other = {x: {i for i, s in enumerate(sets) if x not in s} for x in uniqs}

# iterate over sets:
for i, s in enumerate(sets):
    # find all sets not overlapping with i
    no_overlap = reduce(lambda l, r: l.intersection(r), (other[x] for x in s))

    # iterate over non-overlapping sets
    for j in no_overlap:
        # discard duplicates
        if j &lt;= i:
            continue

        print([org_network[i], org_network[j]])


# result
# [[1, 2, 3], [7, 9, 10]]
# [[1, 4, 5], [7, 9, 10]]
# [[1, 3, 6], [7, 9, 10]]
</code></pre>
<p>Edit: If combinations of size greater than two are required, it is possible to modify the above approach. Here is an extension that uses depth-first search to traverse all pairwise disjoint combinations.</p>
<pre><code>def not_overlapping(set_ids):
    candidates = reduce(
        lambda l, r: l.intersection(r), (other[x] for sid in set_ids for x in sets[sid])
    )
    mid = max(set_ids)
    return {c for c in candidates if c &gt; mid}


# this will produce "combinations" consisting of a single element
def iter_combinations():
    combs = [[i] for i in range(len(sets))]
    while combs:
        comb = combs.pop()
        extension = not_overlapping(comb)
        combs.extend(comb + [e] for e in extension)
        yield [org_network[i] for i in comb]


def iter_combinations_long():
    for comb in iter_combinations():
        if len(comb) &gt; 1:
            yield comb


all_combs = list(iter_combinations_long())
</code></pre>
</div>
<span class="comment-copy">I think I see what you are doing but I am curious, if there were more elements in org_network, and there where larger resulting combinations, would this work? That is really my goal</span>
<span class="comment-copy">Are you looking for all combinations or just those of size 2? In the latter case, this should work as is. Otherwise, the approach can be modified.</span>
<span class="comment-copy">No the combinations I will be looking for will larger than 2, I just  used 2 in the example for simplicity. Would I be able to modify this method for an unknown amount?</span>
<span class="comment-copy">I added a modification that should extend the above approach to arbitrary combination sizes.</span>
