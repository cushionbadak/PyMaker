<div class="post-text" itemprop="text">
<p>I am using Python 2.7.10 with the <code>enum34</code> library. I am trying to do the following:</p>
<pre class="lang-python prettyprint-override"><code>from enum import Enum


class Foo(Enum):
    def __init__(self):
        pass


class Bar(Foo):
    VALUE = 1

    def __init__(self, value):
        super(Bar, self).__init__()
</code></pre>
<p>When this code is run, I receive the error <code>NameError: global name 'Bar' is not defined</code>. Could someone help explain why I receive this error and if it's possible to call the parent constructor of an enum subclass? Thank you in advance!</p>
<p>Edit: Traceback (with path names redacted) for Olivier Melançon:</p>
<pre><code>Traceback (most recent call last):
  File "/.../test.py", line 9, in &lt;module&gt;
    class Bar(Foo):
  File "/.../lib/python2.7/site-packages/enum/__init__.py", line 236, in __new__
    enum_member.__init__(*args)
  File "/.../test.py", line 13, in __init__
    super(Bar, self).__init__()
NameError: global name 'Bar' is not defined

Process finished with exit code 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <code>Bar.VALUE.__init__</code> is being called before <code>Bar</code> exists.</p>
<p>You can see where this happens in <a href="https://bitbucket.org/stoneleaf/enum34/src/f24487b45cd041fc9406d67441d2186ac70772b7/enum/__init__.py?at=default&amp;fileviewer=file-view-default#__init__.py-235" rel="nofollow noreferrer"><code>EnumMeta.__new__</code></a>, but even without looking at the code, it pretty much <em>has</em> to work this way: the whole point of an <code>Enum</code> class is that its enumeration members are constant values that act as attributes of the class while also being instances of it.</p>
<p>In that, this code will produce the exact same error in 3.4+ with the stdlib <code>enum</code> module, and similar errors with multiple third-party <code>enum</code> replacements.</p>
<p>In general, if you have Enum hierarchies at all, you're expected to put values only in the "leaf" classes and behavior only in the non-leaf classes. However, the only restriction that's actually explicitly documented in <a href="https://docs.python.org/3/library/enum.html#restricted-subclassing-of-enumerations" rel="nofollow noreferrer">Restricted subclassing of enumerations</a> is no values in non-leaf classes, so technically what you're trying to do should be legal, even if it's unusual and was never explicitly intended to work.</p>
<hr/>
<p>If you were using Python 3, there's a pretty easy workaround: just using <code>super()</code> instead of <code>super(Bar, self)</code>, and it doesn't matter than <code>Bar</code> doesn't exist yet.</p>
<p>In Python 2, since that isn't doable, you need to manually simulate <code>super</code>. For full generality, that means writing the code to walk the <code>mro</code> and so on, but since multiple inheritance including two or more <code>Enum</code> classes isn't going to work anyway, you'll be fine just hardcoding it statically:</p>
<pre><code>def __init__(self, value):
    Foo.__init__(self)
</code></pre>
<hr/>
<p>Alternatively, if you change your design to put all the behavior in non-leaf classes, that will also work:</p>
<pre><code>class Foo(Enum):
    def __init__(self):
        pass

class Bar(Foo):
    def __init__(self, value):
        super(Bar, self).__init__()

class Baz(Bar):
    VALUE = 1
</code></pre>
<hr/>
<p>Most likely, whatever you're actually trying to accomplish could be done in a better way without requiring either of these changes. But since your toy example doesn't accomplishes anything, there's nothing more to show.</p>
</div>
<span class="comment-copy">I don't think this works even in Python 3.4+. IIRC, subclassing enum classes only works when only the base class has behavior and only the subclasses have enumeration members.</span>
<span class="comment-copy">I want to add that I get the same error in Python3 if I provide the class and object to super, but not if I just call super()</span>
<span class="comment-copy">What is the intention of this code? Why do you want to override the initializer of <code>Enum</code> in <code>Foo</code> to do nothing, and why do you want to override it in <code>Bar</code> to take a value and ignore it?</span>
<span class="comment-copy">Traceback posted for @OlivierMelançon.</span>
<span class="comment-copy">@user9027325 If you're trying to do something that isn't documented to work, and in fact doesn't work, and I can't assume anything other than that there was "some behavior" you wanted, I can't tell you how to achieve that. I could at best explain why your code doesn't work (and I think it's exactly what I said in my last comment) and then leave you to come up with a different design. Is that what you're after?</span>
<span class="comment-copy">Yes, <code>__new__</code> and <code>__init__</code> are both called when the members are created, which is before the class officially exists.</span>
<span class="comment-copy">@EthanFurman It seems like anyone who might wonder about <code>__new__</code> would know that it must be getting called before <code>__init__</code> even without scanning the code, right? But maybe what's going on is complicated enough that it's worth mentioning? I honestly don't have an intuition on that; if you think I should mention <code>__new__</code>, I'll edit the question (or you can edit it, of course).</span>
<span class="comment-copy">@EthanFurman Also, your "the class officially exists" seems like slightly clumsy terminology, but the way I phrased it in the answer (just end-running around the problem by referring to the name <code>Bar</code> instead of the class…) seems even worse. Any suggestions for a better way to put it?</span>
<span class="comment-copy">It's actually very clumsy terminology.  A better explanation is that the name <code>Bar</code> is not bound to the class until after the metaclass finishes processing the class, but unlike normal Python classes where instances are created and initialized /after/ class processing and creation, <code>Enum</code> members are created and initialized /before/ the class has been fully processed.  The magic <code>super()</code> in Python 3 may not have this problem, I haven't tested that.</span>
<span class="comment-copy">@EthanFurman Yeah, I was looking for a way to say that in one short sentence that's better than what I have in the answer, but maybe there is no way to do that. Meanwhile, the magic <code>super</code> doesn't have this problem, because <code>__class__</code> is a closure cell that gets created as part of executing the class definition. See <a href="https://docs.python.org/3/reference/datamodel.html#creating-the-class-object" rel="nofollow noreferrer">creating the class object</a> or <a href="https://www.python.org/dev/peps/pep-3135/" rel="nofollow noreferrer">PEP 3135</a> for details. But I can see why you wouldn't have tested that, because this is an odd use case.</span>
