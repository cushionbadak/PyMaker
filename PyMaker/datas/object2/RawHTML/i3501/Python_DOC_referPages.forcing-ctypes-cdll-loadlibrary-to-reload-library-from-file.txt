<div class="post-text" itemprop="text">
<p>I have the following code</p>
<pre><code>import ctypes
lib1 = ctypes.cdll.LoadLibrary("./mylib.so")
# modify mylib.so (code generation and compilation) or even delete it
lib2 = ctypes.cdll.LoadLibrary("./mylib.so")
</code></pre>
<p>The problem is that <code>lib2</code> refers to the original shared library, not the new one. If I delete mylib.so between the calls I get no error.</p>
<p>Using <code>ctypes._reset_cache()</code> does not help.</p>
<p>How can I tell <code>ctypes</code> to actually reload the library from the hard disk?</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know how to instruct <em>ctypes</em> how to unload a library (didn't find a way on <a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer">[Python 3]: ctypes - A foreign function library for Python</a>, but that doesn't mean that there isn't one).</p>
<p>It can be done manually, by forcing the loader to (decrement the library's reference count and) unload it via <a href="http://man7.org/linux/man-pages/man3/dlclose.3p.html" rel="nofollow noreferrer">[man7]: DLCLOSE(3P)</a> (also read <a href="http://man7.org/linux/man-pages/man3/dlopen.3.html" rel="nofollow noreferrer">[man7]: DLOPEN(3)</a> for additional info on loading / unloading libraries).</p>
<p><em>dll.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include &lt;stdio.h&gt;

int func0(int arg0) {
    int alter_factor = 2;
    printf("From C - arg0: %d, alter_factor: %d\n", arg0, alter_factor);
    return arg0 * alter_factor;
}
</code></pre>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import ctypes


DLL_NAME = "./dll.so"


def handle_dll(dll_name=DLL_NAME):
    dll_dll = ctypes.CDLL(dll_name)
    func0_func = dll_dll.func0
    func0_func.argtypes = [ctypes.c_int]
    func0_func.restype = ctypes.c_int
    return dll_dll, func0_func


def main():
    dlclose_func = ctypes.CDLL(None).dlclose
    dlclose_func.argtypes = [ctypes.c_void_p]
    dlclose_func.restype = ctypes.c_int

    dll, func0 = handle_dll()
    res = func0(42)
    print(res)
    dlclose_func(dll._handle)
    input("In another terminal, modify the C code (e.g. change `alter_factor`), recompile (gcc -fPIC -shared -o dll.so dll.c), and when done press ENTER here...")
    dll, func0 = handle_dll()
    res = func0(42)
    print(res)


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050964033]&gt; python3 code.py
Python 3.5.2 (default, Nov 23 2017, 16:37:01)
[GCC 5.4.0 20160609] on linux

From C - arg0: 42, alter_factor: 2
84
In another terminal, modify the C code (e.g. change `alter_factor`), recompile (gcc -fPIC -shared -o dll.so dll.c), and when done press ENTER here...
From C - arg0: 42, alter_factor: 3
126
</code></pre>
</blockquote>
</div>
<span class="comment-copy">That worked. Thanks. However, this method might provoke segmentation faults (which seems to be a matter of fact). Also, it should be noted, that one has to call dlclose_func multiple times if the lib was loaded multiple times.</span>
<span class="comment-copy">Yes, trying to access a symbol from an unloaded library is <i>Undefined Behavior</i> (and expected to segfault sometimes). And also each <code>dlopen</code> call must have its <code>dlaclose</code> counterpart. But that's all knowledge related to loading/unloading libs.</span>
