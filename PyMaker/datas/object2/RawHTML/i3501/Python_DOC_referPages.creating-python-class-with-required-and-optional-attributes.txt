<div class="post-text" itemprop="text">
<p>I want to create multiple python classes which has alot of required and optional fields. During initialization I want to check whether all required attributes are passed and do validation of all attributes.</p>
<p>This is solution i came up with. But problem with this, IDEs no more auto suggests the class attributes.</p>
<p>Is there any better solution to handle my problem ?</p>
<pre>
<code>
class Field(object):
    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]


class IntField(Field):

    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise ValueError(f'expecting integer in {self.name} got {value}')
        instance.__dict__[self.name] = value

class StrField(Field):
    def __set__(self, instance, value):
        if not isinstance(value, six.string_types):
            raise ValueError(f'expecting string in {self.name} got {value}')
        instance.__dict__[self.name] = value

class PropertiesCreator(type):

    def __new__(mcs, classname, baseclasses, props):
        c_props = props.get('_required_properties', ())
        for name, cname in c_props:
            props[name] = cname()

        c_props = props.get('_optional_properties', ())
        for name, cname in c_props:
            props[name] = cname()

        return super(PropertiesCreator, mcs).__new__(mcs, classname, baseclasses, props)


class Schema(object):

    _required_properties = ()
    _optional_properties = ()

    def __init__(self, **kwargs):
        for name, _ in self._required_properties:
            try:
                value = kwargs.pop(name)
            except KeyError:
                raise RequiredAttributeError("Required %s is missing" % name)
            else:
                setattr(self, name, value)

        for name, _ in self._optional_properties:
            try:
                value = kwargs.pop(name)
            except KeyError:
                pass
            else:
                setattr(self, name, value)

        if kwargs:
            raise InvalidAttributeError("Invalid items ")

    def required_attributes(self):
        return self._required_properties

    def optional_attributes(self):
        return self._optional_properties


@six.add_metaclass(PropertiesCreator)
class CheckpointSchema(Schema):
    _required_properties = (
        ("name",    StrField),
        ("is_enabled", BoolField)
    )

    def __init__(self, **kwargs):
        super(CheckpointSchema, self).__init__(**kwargs)
</code>
</pre>
</div>
<div class="post-text" itemprop="text">
<p>The ways you  can use a metaclass to check for properties are open ended, and just code running at run time can actually define whether an argument will be required or valid. That means, there is <em>no</em> way for an IDE to possibly guess your desired verification schema and work along with it - you could only ensure it by writing an extension to your IDE that would go along with your code.</p>
<p>HOWEVER, there is a good chance that if an IDE imports a module containing your class using Python itself (and  not by trying to statically check the actual typed-in code), if your object-classes have a well formed <code>__init__</code> method with all required parameters as mandatory, and all optional parameters with a default sentinel value, it would work.</p>
<p>Therefore, you have to write your metaclass in a way it actually generates an <code>__init__</code> function with the proper signature. Although there are ways to programmaticaly  set a function signature with things from the <code>inspect</code> module, or create a function using <code>types.CodeType</code> + <code>types.FunctionType</code>, this would take  a long time to get working, and become less readable than simply composing a string with the desired method signature and use <code>exec</code> to get it rolling. Moreover, this could make use of annotations, so you can get even extra help from the IDE.</p>
<p>So, your code could become something like (sorry - Python 3.6 - to make this compatible with Python 2.7 as well you will need a lot more typing):</p>
<pre><code>from textwrap import dedent as D

...
class IntField(Field):
    type_ = int

class StrField(Field):
    type = str
...


_SENTINEL = object()


def _check_attrs(**kwargs):
    self = kwargs.pop("self")
    for name, _ in self._required_properties:
        try:
            value = kwargs.pop(name)
        except KeyError:
            raise RequiredAttributeError("Required %s is missing" % name)
        else:
            setattr(self, name, value)

    for name, _ in self._optional_properties:
        value = kwargs.pop(name)
        if value is not _SENTINEL:
            setattr(self, name, value)

    if kwargs:
        raise InvalidAttributeError("Invalid items ")



class PropertiesCreator(type):

    def __new__(mcs, classname, baseclasses, props):
        c_props = props.get('_required_properties', ())
        for name, cname in c_props:
            props[name] = cname()
        required = ", ".join(f"{name}:{cname.type_}" for name, cname in c_props)

        optional = []
        c_props = props.get('_optional_properties', ())
        for name, cname in c_props:
            props[name] = cname()
            optional.append((
        optional = ", ".join(f"{name}:{cname.type_}={_SENTINEL}" for name, cname in c_props)

        namespace = {"_check_attrs": _check_attrs}

        exec(D(f"""\
            def __init__(self, *, {required}, {optional}):
                _check_attrs(locals())
        """))
        props["__init__"] = namespace["__init__"]

        return super(PropertiesCreator, mcs).__new__(mcs, classname, baseclasses, props)





class CheckpointSchema(Schema, metaclass=PropertiesCreator):  
    # Sorry - we are 18 months away from python 2 EOL . 
    # Do you really need Python 2 compatibility in a new project thic complex?
    _required_properties = (
        ("name",    StrField),
        ("is_enabled", BoolField)
    )

    # Leave __init__ undefined.  
    # if you need more code to run on `__init__`, the metaclass will
    # get a lot more complicated - maybe change th emetaclass to 
    # make use of `__new__` to init the properties, instead
    # and leave `__init__` alone. 
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">Abstract Base Classes</a></span>
<span class="comment-copy">Unfortunately, using a metaclass very often confuses you IDE, use an ABC instead. It should accomplish what you want without the confusion.</span>
<span class="comment-copy">I didn't get it. Should i make PropertiesCreator class Abstract class ? Can you please give a example how it will solve my problem.</span>
