<div class="post-text" itemprop="text">
<p>I have simplified the problem like this.</p>
<p>program.py</p>
<pre><code>from classB import B
myClass = B(7)
myClass.print__()
myClass.bbb = 8
print(myClass.bbb)
myClass.print__()
</code></pre>
<p>classA.py</p>
<pre><code>class A:
    def __init__(self, a):
        self.aaa = a

    def print_(self):
        print(self.aaa)
</code></pre>
<p>classB.py</p>
<pre><code>from classA import A
class B:
    def __init__(self, bb):
        self.bbb = bb
        self.Aclass = A(self.bbb)

    def print__(self):
        self.Aclass.print_()
</code></pre>
<p>In program.py, I created a classB instance myClass, and initialized with 7. If then, from classB.py, a classA instance Aclass will be created, and also be initialized with 7, so when I call print__(), it shows that Aclass is also initialized with 7.</p>
<p>The problem here is when I updated myClass.bbb to 8, I also expected Aclass.aaa to be 8, but it didn't.</p>
<p>I might solve this by making another function like update_varA(), but could you please explain why this happens, and a better solution to this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are right about the update function. In your case it would be (in classB.py)</p>
<pre><code>class B:
    def update_value(self, new_value):
        self.bbb = new_value
        self.AClass.aaa = new_value

    [... all the other functions]
</code></pre>
<p>Another way would be to set the value directly in your main routine (program.py)</p>
<pre><code>myClass.AClass.aaa = 8
</code></pre>
<p>would to the trick.</p>
<p>If you want to dive in a little deeper, you could also override the <code>__setattr__()</code> function. Basically, when you do something like</p>
<pre><code>myClass.bbb = 8  
</code></pre>
<p>python does this under the hood:</p>
<pre><code>myClass.__setattr__('bbb', 8)
</code></pre>
<p>myClass is acutually an instance of the class here btw, so the name is a little misleading. Nevertheless, you can override the <strong>setattr</strong>():</p>
<pre><code>class B:
    def __setattr__(self, name, value):
        if name=='bbb':
            self.bbb = new_value
            self.AClass.aaa = new_value
        else:
            super().__setattr__(name, value)

    [... all the other functions]
</code></pre>
<p>but this is quite advanced. You can read about it <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer">here</a></p>
</div>
<span class="comment-copy">You should understand two things: first, integers are immutable; second, <code>a = 7</code>does not modify the object which was previously in <code>a</code> - it just puts a different object (7) into <code>a</code>.</span>
<span class="comment-copy">Thanks for the answer!!! Iâ€™ll look up more about the last one!</span>
<span class="comment-copy">If bbb was not a number, and was mutable like list, then would my code work?</span>
<span class="comment-copy">I don't think so... but you could just try it yourself :) Experimenting with a language is one of the quickest ways to learn it!</span>
