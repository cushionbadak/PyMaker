<div class="post-text" itemprop="text">
<p>I'm trying to automatically group conditions together in python. The difficulty lies in that if there are several conditions, like 100 conditions, it would be tedious to "AND" all of these by hand. How can I use a loop to achieve this? </p>
<pre><code>import pandas as pd
s1 = pd.Series([1,2,3,4,5,6])
s2 = pd.Series([5,6,7,8,9,10])
s3 = pd.Series([11,12,5,7,8,2])
df = pd.DataFrame({'A': s1,'B': s2,'C': s3})

condition1 = df['A'] &gt; 3
condition2 = df['B'] &gt; 6
condition3 = df['C'] &gt; 5
# AND Operation -&gt;&gt;&gt; Can be achieved with a loop?
select = condition1 &amp; condition2 &amp; condition3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A couple of points  to note:</p>
<ul>
<li>You can use a list or dictionary to store a variable number of variables.</li>
<li>Your Boolean series function as NumPy arrays; you can therefore combine a collection of series and use <a href="https://docs.scipy.org/doc/numpy-1.10.4/reference/generated/numpy.ndarray.all.html" rel="nofollow noreferrer"><code>np.ndarray.all</code></a> (or <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.all.html" rel="nofollow noreferrer"><code>pd.DataFrame.all</code></a>) to calculate their intersection.</li>
</ul>
<p>You can use a list of Boolean series with NumPy or Pandas:</p>
<pre><code>conditions = [df['A'] &gt; 3,
              df['B'] &gt; 6,
              df['C'] &gt; 5]

# all equivalent
select = pd.concat(conditions, axis=1).all(axis=1)
select = np.logical_and.reduce(conditions)
select = np.array(conditions).all(axis=0)

print(select)

array([False, False, False,  True,  True, False], dtype=bool)
</code></pre>
<p>Equivalently, if you wish to name your Boolean filters, you can use a dictionary:</p>
<pre><code>conditions = {1: df['A'] &gt; 3,
              2: df['B'] &gt; 6,
              3: df['C'] &gt; 5}

select = np.array(list(conditions.values())).all(axis=0)
</code></pre>
<p><strong>Performance benchmarking</strong></p>
<p>Performance will be very data-dependent, you should also try <code>reduce</code> as per <a href="https://stackoverflow.com/a/50930428/9209546">@Kopytok's solution</a> and check performance with your data.</p>
<pre><code>df = pd.concat([df]*1000)

conditions = [df['A'] &gt; 3,
              df['B'] &gt; 6,
              df['C'] &gt; 5]

conditions = conditions*100

%timeit reduce(lambda x, y: x &amp; y, conditions)     # 104 ms per loop
%timeit np.logical_and.reduce(conditions)          # 104 ms per loop
%timeit np.array(conditions).all(axis=0)           # 99.4 ms per loop
%timeit pd.concat(conditions, axis=1).all(axis=1)  # 34.6 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can achive it by creating a list of conditions and using <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>reduce</code></a>:</p>
<pre><code>from functools import reduce

conditions = [
    df['A'] &gt; 3,
    df['B'] &gt; 6,
    df['C'] &gt; 5,
]

total_condition = reduce(lambda x, y: x &amp; y, conditions)
</code></pre>
<hr/>
<p>Test case:</p>
<pre><code>d = pd.DataFrame(np.random.randint(1, 5, (700000, 3)), columns=["a", "b", "c"])

conditions = [
    d["a"] &gt; 2,
    d["c"] &gt; 1,
    d["b"] &gt; 2,
]*100
</code></pre>
<p>Using <code>reduce</code>:</p>
<pre><code>from functools import reduce

%timeit reduce(lambda x, y: x &amp; y, conditions)
&gt; 547 ms ± 14.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<p>Using <code>np.concat</code> + <code>df.all()</code>:</p>
<pre><code>%timeit pd.concat(conditions, axis=1).all(1)
&gt; 4.19 s ± 367 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
</div>
<span class="comment-copy">Why don't you simply store conditions in a list instead of dictionary?</span>
<span class="comment-copy">In the second case couldn't you use <code>np.logical_and.reduce(conditions)</code>? I think it would be faster than the concat?</span>
<span class="comment-copy">@ALollz, for a large number of arrays I see <code>np.array(conditions).all(0)</code> faster. But I'm not sure the minor differences are important.</span>
<span class="comment-copy">OK, look like this is <i>very</i> data-dependent. I match yours and you probably will match mine. Guess OP should try both.</span>
<span class="comment-copy">Yes, I have the same results as yours</span>
