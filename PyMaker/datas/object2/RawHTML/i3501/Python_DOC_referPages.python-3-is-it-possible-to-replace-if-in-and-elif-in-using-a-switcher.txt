<div class="post-text" itemprop="text">
<p>I know how to use a dictionary as a switcher in Python. I'm not sure how to use one for my specific case. I think I will just need to use if, elif, and else but hopefully I am proved wrong by the community :)</p>
<p>I want to make a find/replace function for certain characters in strings. The string is at least one sentence but usually more and comprised of many words.</p>
<p>Basically what I am doing is the following:</p>
<pre><code>if non-breaking hyphen in string:  # string is a sentence with many words
  replace non-breaking hyphen with dash

elif en dash in string:
  replace en dash with dash

elif em dash in string:
  replace em dash with dash

elif non-breaking space in string:
  replace non-breaking space with space
</code></pre>
<p>.... and so forth</p>
<p>The only thing I can think of is splitting the string apart into separate sub-strings and then looping through them then the dictionary switcher would work. But this would obviously add a lot of extra processing time and the purpose of using a dictionary switcher is to save time.</p>
<p>I could not find anything on this specific topic searching everywhere.</p>
<p>Is there a way to use a switcher in Python using if in and elif in?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's the <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer"><code>str.translate</code></a> solution</p>
<pre><code>replacements = {
    '\u2011': '-',  # non breaking hyphen
    '\u2013': '-',  # en dash
    '\u2014': '-',  # em dash
    '\u00A0': ' ',  # nbsp
}

trans = str.maketrans(replacements)
new_string = your_string.translate(trans)
</code></pre>
<p>Note that this only works if you want to replace single characters from the input.  <code>{'a': 'bb'}</code> is a valid <code>replacements</code>, but <code>{'bb': 'a'}</code> is not.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just to show that regex is a valid solution, and some timings:</p>
<pre><code>replacements = {
    '\u2011': '-',
    '\u2013': '-',
    '\u2014': '-',
    '\u00A0': ' ', 
}

import re
s = "1‑‑‑‑2–––––––3————————"

re.sub(
    '|'.join(re.escape(x) for x in replacements),
    lambda x: replacements[x.group()], s
)
# Result
1----2-------3--------
</code></pre>
<p><strong><em>Timings</em></strong> (<strong><code>str.trans</code></strong> wins and is also cleaner)</p>
<pre><code>s = "1‑‑‑‑2–––––––3————————"
s *= 10000

%timeit re.sub('|'.join(re.escape(x) for x in replacements), lambda x: replacements[x.group()], s)
90.7 ms ± 182 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [733]: %timeit s.translate(trans)
15.8 ms ± 59.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although Benjamin's answer might be right, it is case-specific, while your question has a rather general-purpose tone to it. There is a universal functional approach (I've added Python 3.5 type annotations to make this code self-explanatory):</p>
<pre><code>from typing import TypeVar, Callable, Iterable

A = TypeVar('A')
B = TypeVar('B')
Predicate = Callable[[A], bool]
Action = Callable[[A], B]
Switch = Tuple[Predicate, Action]

def switch(switches: Iterable[Switch], default: B, x: A) -&gt; B:
    return next(
        (act(x) for pred, act in switches if pred(x)), default
    )

switches = [
    (lambda x: '\u2011' in x, lambda x: x.replace('\u2011', '-')),
    (lambda x: '\u2013' in x, lambda x: x.replace('\u2013', '-'))
]
a = "I'm–a–string–with–en–dashes"

switch(switches, a, a) # if no switches are matched, return the input
</code></pre>
<p>This is quite superfluous in your case, because your example boils down to a regex operation. Take note, while <code>switches</code> can be any iterable, you might want to use something with predictable iteration order, i.e. any <code>Sequence</code> type (e.g. <code>list</code> or <code>tuple</code>), because the first action with a matched predicate will be used.</p>
</div>
<span class="comment-copy">Looks like a good fit for regular expressions to me.  One regex for each <code>if</code> clause, and you won't need any conditional logic.</span>
<span class="comment-copy">@cxw If you need one regex per <code>if</code> clause, what's the point of using regex instead of string operations?</span>
<span class="comment-copy">You want just <code>if</code> statements not <code>elif</code>.  If there's a <code>en dash</code> in <code>string</code>, that doesn't mean you want to ignore the <code>em dash</code> in string too, does it?  If each thing you want to replace is a single character, you should use <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer"><code>str.translate</code></a></span>
<span class="comment-copy">But is it truly necessary to have <code>if</code>s here in the first place? Why not just perform the replacements without checking whether the character is present first? <code>if "." in s: s = s.replace(".", "-")</code> has the same behavior as <code>s = s.replace(".", "-")</code> by itself.</span>
<span class="comment-copy">@Kevin  thanks, I will change that since what I'm doing is redundant. For the sake of this question lets assume I am not replacing text and doing some other operation based on if something is in a string, is it possible to create a dictionary switcher?</span>
<span class="comment-copy">The issue I see here is that you will replace all at once, contrary to pseudo code implementation of OP</span>
<span class="comment-copy">@BenjaminToueg I'm operating under the impression that this is what they actually wanted, even if it wasn't what they wrote.</span>
<span class="comment-copy">@Patrick Haugh  sorry I wasn't as clear as you would have liked. It is difficult to explain in text. This is what I was after, thanks.</span>
<span class="comment-copy">The main advantage to this approach is that it works with multiple character substrings that you may want to replace. I'd suggest using <code>'|'.join(re.escape(x) for x in replacements)</code> to avoid any issues if there are regex-relevant characters to be replaced (and there's no need to call <code>keys()</code>). I'm not sure the <code>'({})'.format(...)</code> part is necessary, you can just use <code>x|y</code> from the <code>join</code> call as the pattern directly, as the replacement works with no capturing group at all.</span>
<span class="comment-copy">Yea, was working on cleaning the regex up, thanks for the suggestions, I'll update</span>
<span class="comment-copy">Good solution, but unreadable. It would help a lot if you added a usage example so people can figure out how to use it.</span>
<span class="comment-copy">@Aran-Fey I've hesitated to add an example, because the solution is quite superfluous in the context of OP's example. Nevertheless, here you are.</span>
<span class="comment-copy">Yeah, it's pretty annoying to have to write a bunch of lambdas. It's probably more useful as recipe than a function. It'd look much cleaner with a loop with the lambdas inlined.</span>
<span class="comment-copy">@Aran-Fey in general, the point of using a function is the ability to apply it partially to a list of switches (e.g. <code>replace_dashes = partial(switch, switches)</code> or even <code>partial(switch, switches, default)</code>, if the default is fixed, too) and reuse the switcher multiple times in various places/expressions allowing for expressive (in the functional programming sense) code.</span>
