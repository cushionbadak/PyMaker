<div class="post-text" itemprop="text">
<p>Given a dictionary with tuples as keys (and numbers/scalars as values), what is a Pythonic way to convert to a nested dictionary?  The hitch is that from input-to-input, the tuples are of arbitrary length.</p>
<p>Below, <code>d1</code>, <code>d2</code>, and <code>d3</code> demonstrate increasing nestedness:</p>
<pre><code>from itertools import product

d1 = dict(zip(product('AB', [0, 1]), range(2*2)))
d2 = dict(zip(product('AB', [0, 1], [True, False]), range(2*2*2)))
d3 = dict(zip(product('CD', [0, 1], [True, False], 'AB'), range(2*2*2*2)))
</code></pre>
<p>And their resulting nested versions would be:</p>
<pre><code># For d1
{'A': {0: 0, 1: 1}, 'B': {0: 2, 1: 3}}

# For d2
{'A': {0: {True: 0, False: 1}, 1: {True: 2, False: 3}},
 'B': {0: {True: 4, False: 5}, 1: {True: 6, False: 7}}}

# Beginning of result for d3
{
'C': {
    0: {
        True: {
            'A': 0
            'B': 1
        },
        False: {
            'A': 2,
            'B': 3
        },
    1: # ...
</code></pre>
<hr/>
<p>My attempts: I like the this trick for initializing an empty data structure, which is given in a number of other SO answers:</p>
<pre><code>from collections import defaultdict

def nested_dict():
    return defaultdict(nested_dict)
</code></pre>
<p>But am having trouble implementing this because the number of levels is uncertain.  I could use something like:</p>
<pre><code>def nest(d: dict) -&gt; dict:
    res = nested_dict()
    for (i, j, k), v in d.items():
        res[i][j][k] = v
    return res
</code></pre>
<p>But this would <em>only</em> work for <code>d2</code> because its keys have 3 levels (i, j, k) above.  </p>
<p>Here's my attempt at a solution to generalizing this, but I'm guessing there is a simpler route.</p>
<pre><code>def set_arbitrary_nest(keys, value):
    """
    &gt;&gt;&gt; keys = 1, 2, 3
    &gt;&gt;&gt; value = 5
    result --&gt; {1: {2: {3: 5}}}
    """

    it = iter(keys)
    last = next(it)
    res = {last: {}}
    lvl = res
    while True:
        try:
            k = next(it)
            lvl = lvl[last]
            lvl[k] = {}
            last = k
        except StopIteration:
            lvl[k] = value
            return res

&gt;&gt;&gt; set_arbitrary_nest([1, 2, 3], 5)
{1: {2: {3: 5}}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just loop over each key, and use all but the last element of the key to add dictionaries. Keep a reference to the last dictionary so set, then use the last element in the key tuple to actually set a key-value pair in the output dictionary:</p>
<pre><code>def nest(d: dict) -&gt; dict:
    result = {}
    for key, value in d.items():
        target = result
        for k in key[:-1]:  # traverse all keys but the last
            target = target.setdefault(k, {})
        target[key[-1]] = value
    return result
</code></pre>
<p>You could use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce()</code></a> to handle the traversing-down-the-dictionaries work:</p>
<pre><code>from functools import reduce

def nest(d: dict) -&gt; dict:
    result = {}
    traverse = lambda r, k: r.setdefault(k, {})
    for key, value in d.items():
        reduce(traverse, key[:-1], result)[key[-1]] = value
    return result
</code></pre>
<p>I used <code>dict.setdefault()</code> rather than the auto-vivication <code>defaultdict(nested_dict)</code> option, as this produces a regular dictionary that won't further implicitly add keys when they don't yet exist.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(nest(d1))
{'A': {0: 0, 1: 1}, 'B': {0: 2, 1: 3}}
&gt;&gt;&gt; pprint(nest(d2))
{'A': {0: {False: 1, True: 0}, 1: {False: 3, True: 2}},
 'B': {0: {False: 5, True: 4}, 1: {False: 7, True: 6}}}
&gt;&gt;&gt; pprint(nest(d3))
{'C': {0: {False: {'A': 2, 'B': 3}, True: {'A': 0, 'B': 1}},
       1: {False: {'A': 6, 'B': 7}, True: {'A': 4, 'B': 5}}},
 'D': {0: {False: {'A': 10, 'B': 11}, True: {'A': 8, 'B': 9}},
       1: {False: {'A': 14, 'B': 15}, True: {'A': 12, 'B': 13}}}}
</code></pre>
<p>Note that the above solution is a clean O(N) loop (N being the length of the input dictionary), whereas a groupby solution as proposed by Ajax1234 has to <em>sort</em> the input to work, making that a O(NlogN) solution. That means that for a dictionary with 1000 elements, a <code>groupby()</code> would need 10.000 steps to produce the output, whereas an O(N) linear loop only takes 1000 steps. For a million keys, this increases to 20 million steps, etc.</p>
<p>Moreover, recursion in Python is.. slow, as Python can't optimise such solutions to an iterative approach. Function calls are relatively expensive, so using recursion can carry significant performance costs as you greatly increase the number of function calls and by extension frame stack operations.</p>
<p>A time trial shows by how much this matters; using your sample <code>d3</code> and 100k runs, we easily see a 5x speed difference:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; timeit('n(d)', 'from __main__ import create_nested_dict as n, d3; d=d3.items()', number=100_000)
8.210276518017054
&gt;&gt;&gt; timeit('n(d)', 'from __main__ import nest as n, d3 as d', number=100_000)
1.6089267160277814
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby</code> with recursion:</p>
<pre><code>from itertools import groupby
def create_nested_dict(d):
  _c = [[a, [(c, d) for (_, *c), d in b]] for a, b in groupby(sorted(d, key=lambda x:x[0][0]), key=lambda x:x[0][0])]
  return {a:b[0][-1] if not any([c for c, _ in b]) else create_nested_dict(b) for a, b in _c}
</code></pre>
<hr/>
<pre><code>from itertools import product

d1 = dict(zip(product('AB', [0, 1]), range(2*2)))
d2 = dict(zip(product('AB', [0, 1], [True, False]), range(2*2*2)))
d3 = dict(zip(product('CD', [0, 1], [True, False], 'AB'), range(2*2*2*2)))
print(create_nested_dict(d1.items()))
print(create_nested_dict(d2.items()))
print(create_nested_dict(d3.items())) 
</code></pre>
<p>Output:</p>
<pre><code>{'A': {0: 0, 1: 1}, 'B': {0: 2, 1: 3}}
{'A': {0: {False: 1, True: 0}, 1: {False: 3, True: 2}}, 'B': {0: {False: 5, True: 4}, 1: {False: 7, True: 6}}}
{'C': {0: {False: {'A': 2, 'B': 3}, True: {'A': 0, 'B': 1}}, 1: {False: {'A': 6, 'B': 7}, True: {'A': 4, 'B': 5}}}, 'D': {0: {False: {'A': 10, 'B': 11}, True: {'A': 8, 'B': 9}}, 1: {False: {'A': 14, 'B': 15}, True: {'A': 12, 'B': 13}}}}
</code></pre>
</div>
<span class="comment-copy">Using <code>groupby()</code> here is <i>expensive</i>, as the input is guaranteed to require sorting! Sorting adds a O(NlogN) cost, overkill when a simple O(N) loop would do! Moreover, putting that all on one line is very expensive indeed.</span>
<span class="comment-copy">@MartijnPieters True, however, sorted input is necessary for <code>itertools.groupby</code>. However, I think <code>itertools.groupby</code> makes the recursive logic a bit easier, and perhaps cleaner.</span>
<span class="comment-copy">I strongly disagree about making the logic cleaner or easier. That code is highly unreadable.</span>
