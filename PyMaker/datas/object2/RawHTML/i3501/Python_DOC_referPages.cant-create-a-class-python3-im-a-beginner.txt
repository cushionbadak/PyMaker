<div class="post-text" itemprop="text">
<p>I want some help for the following question.</p>
<p>I created this class.</p>
<pre><code>&gt;&gt;&gt;class CountFromBy:
       pass
</code></pre>
<p>But I can't create objects  from it.</p>
<p>I want to make an increment counter. 
So input these codes, but they doesn't work in the way I assume. Like this:</p>
<pre><code>&gt;&gt;&gt;c = CountFromBy()
&gt;&gt;&gt;c
0
&gt;&gt;&gt;c.increase()
&gt;&gt;&gt;c.increase()
&gt;&gt;&gt;c.increase()
&gt;&gt;&gt;c
3
</code></pre>
<p>But, actually the result is:</p>
<pre><code>&gt;&gt;&gt;c = CountFromBy()
&gt;&gt;&gt;c
&lt;__main__.CountFromBy object at 0x042647F0&gt;
</code></pre>
<p>How can I get the expected result?</p>
</div>
<div class="post-text" itemprop="text">
<p>You might be looking to make a subclass of <code>int</code>—something that acts just like an <code>int</code>, but has some extra behavior.</p>
<p>To do this, you use inheritance:</p>
<pre><code>&gt;&gt;&gt; class CountFromBy(int):
...     pass
</code></pre>
<p>Now, when you write <code>c = CountFromBy()</code>, it's a <code>CountFromBy</code> instance, which is also an <code>int</code> instance, so:</p>
<pre><code>&gt;&gt;&gt; c = CountFromBy()
&gt;&gt;&gt; c
0
</code></pre>
<p>So far, you haven't added any new behavior, but if you want to do that, you just add methods:</p>
<pre><code>&gt;&gt;&gt; class CountFromBy(int):
...     def squared(self):
...         return CountFromBy(self * self)
&gt;&gt;&gt; c = CountFromBy(3)
&gt;&gt;&gt; c
3
&gt;&gt;&gt; c.squared()
9
</code></pre>
<p>But if you want to add an <code>increase()</code> method, there's a big problem: <code>int</code> values are immutable. Since <code>CountFromBy</code> values are <code>int</code> values, they're also immutable. There's no way to write the class this way.</p>
<hr/>
<p>You might be looking for a class that <em>uses</em> an <code>int</code>, instead of <em>being</em> one. For that, you don't use inheritance, you just create a member:</p>
<pre><code>&gt;&gt;&gt; class CountFromBy:
...     def __init__(self):
...         self.number = 0
</code></pre>
<p>If you want it to print out its <code>number</code> value, you can give it a <code>str</code> method:</p>
<pre><code>&gt;&gt;&gt; class CountFromBy:
...     def __init__(self):
...         self.number = 0
...     def __repr__(self):
...         return f'CountFromBy({self.number})'
...     def __str__(self):
...         return str(self.number)
&gt;&gt;&gt; c = CountFromBy()
&gt;&gt;&gt; c
CountFromBy(0)
&gt;&gt;&gt; print(c)
0
</code></pre>
<p>And now, you can add that <code>increase</code> method—it just replaces <code>self.number</code> with a new value:</p>
<pre><code>&gt;&gt;&gt; class CountFromBy:
...     def __init__(self):
...         self.number = 0
...     def __repr__(self):
...         return f'CountFromBy({self.number})'
...     def __str__(self):
...         return str(self.number)
...     def increase(self):
...         self.number = self.number + 1
&gt;&gt;&gt; c = CountFromBy()
&gt;&gt;&gt; c.increase()
&gt;&gt;&gt; c.increase()
&gt;&gt;&gt; c.increase()
&gt;&gt;&gt; print(c)
3
</code></pre>
<hr/>
<p>Finally, you might be looking for the best of both worlds—something that acts as much as possible like an <code>int</code> without actually being one, using an <code>int</code> for storage. This is just like <a href="https://docs.python.org/3/library/collections.html#userdict-objects" rel="nofollow noreferrer"><code>UserDict</code></a> and friends from the standard library, so you can look at <a href="https://github.com/python/cpython/blob/3.6/Lib/collections/__init__.py#L957" rel="nofollow noreferrer">the source for those classes</a>. As you can see, it's a bit more involved, so you probably don't want to try that yet. Plus, you'd have to decide what it means to act "as much as possible like an <code>int</code>", while at the same time being mutable.</p>
</div>
<div class="post-text" itemprop="text">
<p>There you go.</p>
<pre><code>class CountFromBy:
    def __init__(self, count=0):
        self.count = count
    def __repr__(self):
        return str(self.count)
    def increase(self):
        self.count += 1
</code></pre>
<p>e.g.</p>
<pre><code>&gt;&gt;&gt; c = CountFromBy() 
&gt;&gt;&gt; c 
0        
&gt;&gt;&gt; c.increase()
&gt;&gt;&gt; c.increase() 
&gt;&gt;&gt; c.increase()  
&gt;&gt;&gt; c 
3
</code></pre>
<p>You can also initialze count by passing the initial value to the constructor.</p>
<pre><code>&gt;&gt;&gt; c = CountFromBy(5) 
&gt;&gt;&gt; c 
5
&gt;&gt;&gt; c.increase()
&gt;&gt;&gt; c
6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this is a simple class you can use </p>
<pre><code>class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

p1 = Person("morty", 32)

print(p1.name)
print(p1.age)
</code></pre>
</div>
<span class="comment-copy">Why do you expect evaluating <code>c</code> to show you <code>0</code>, instead of showing you a <code>CountFromBy</code> object? (And also, why do you expect to be able to call an <code>increase()</code> method on it when you haven't defined such a method anywhere?)</span>
<span class="comment-copy">Please start by reading some basic tutorials, which SO is not.</span>
