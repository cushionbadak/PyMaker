<div class="post-text" itemprop="text">
<p>I have a list of lists:</p>
<pre><code>       Y= [[192, 193, 194, 195, 196, 197, 198, 199, 200],
         [507, 508, 509],
         [526, 527, 528, 529],
         [560, 561],
         [635, 636, 637]]
</code></pre>
<p>and I want the last and first elements of each list into a separate list. 
I used the zip command:</p>
<pre><code>list(zip(*Y))[0]
</code></pre>
<p>for all first elements and gave me:</p>
<pre><code>[192,507,526,560,635]
</code></pre>
<p>but when I use <code>list(zip(*Y))[-1]</code></p>
<p>I got <code>[193, 508, 527, 561, 636]</code></p>
<p>instead of <code>[200,509,529,561,637]</code></p>
<p>what am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You were close - just use the reversed list iterators:</p>
<pre><code>&gt;&gt;&gt; list(zip(*[reversed(y) for y in Y]))[0]
(200, 509, 529, 561, 637)
</code></pre>
<p>Or, more directly, a list comprehension:</p>
<pre><code>[y[-1] for y in Y]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> zips up iterables of the same length. If you give it iterables of <em>different</em> lengths, it stops at the end of the first one.</p>
<p>So, since your shortest list is length 2, you get the first elements, then the second elements… and that's it, so <code>[-1]</code> returns the second elements.</p>
<p>You could use <code>itertools.zip_longest</code>, but that won't really help, because it handles iterables of different lengths by filling in extra <code>None</code> values at the end, not by… inserting extra values in the middle or something that would stretch them all out to the same length.</p>
<hr/>
<p>The easiest thing to do is to take the first and last of each <em>first</em>, before zipping:</p>
<pre><code>Y= [[192, 193, 194, 195, 196, 197, 198, 199, 200],
    [507, 508, 509],
    [526, 527, 528, 529],
    [560, 561],
    [635, 636, 637]]

FL = [(sublist[0], sublist[-1]) for sublist in Y]
</code></pre>
<p>Then you can transpose that with <code>zip</code>:</p>
<pre><code>F, L = zip(*FL)
</code></pre>
<hr/>
<p>Or just not <code>zip</code> anything, since you're not getting any real benefit out of transposing things anyway, just making things more complicated:</p>
<pre><code>F = [sublist[0] for sublist in Y]
L = [sublist[-1] for sublist in Y]
</code></pre>
<hr/>
<p>Alternatively, you could zip the forward and backward lists:</p>
<pre><code>F = zip(*Y)
L = zip(*map(reversed, Y))
</code></pre>
<p>And then get the first elements out of each of those:</p>
<pre><code>f, l = next(F), next(L) # or list(F)[0] if you insist
</code></pre>
<p>I think this is the closest to what you were trying to do, but it seems like the most complicated way to do it.</p>
</div>
<span class="comment-copy">zip is a zip-to-smallest-list function, what's wrong with <code>[x[-1] for x in Y]</code>?</span>
