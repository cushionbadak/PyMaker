<div class="post-text" itemprop="text">
<p>I'm currently writing a program where Python-Files are copied into a docker-container with a main module and should then be executed in Threads.</p>
<p>Suppose I have the following structure:</p>
<pre><code>.
├── app.py
├── rule1
|   └── foo.py
├── rule2
|   └── bar.py
:
:   ...
: 
└── ruleX
    └── foobar.py
</code></pre>
<p>The idea is, that each <code>.py</code> in a subdirectory implements an interface and is then called in it's own Thread by the <code>main.py</code>. The <code>main.py</code> on the other hand then communicates with the program running on the host.
The only thing the Thread would have to to, would be to create an instance of the loaded class and call the <code>.analyze()</code>-function.</p>
<p>As far I found the following code:</p>
<pre class="lang-py prettyprint-override"><code>import importlib.util
spec = importlib.util.spec_from_file_location("module.name", "/path/to/file.py")
foo = importlib.util.module_from_spec(spec)
spec.loader.exec_module(foo)
foo.MyClass()
</code></pre>
<p>But in my case I am not sure what to enter for <code>module.name</code>. And how can the function be called?</p>
</div>
<div class="post-text" itemprop="text">
<p>The place to look for this information is <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer">the documentation</a>. The code that you apparently found somewhere is basically just <a href="https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly" rel="nofollow noreferrer">one of the examples in the docs</a> with all the explanation and context stripped out.</p>
<p>You do also need to understand a little bit about how Python modules and packages work, but otherwise, anything you don't understand here should be findable within the same doc chapter.</p>
<hr/>
<blockquote>
<p>But in my case I am not sure what to enter for <code>module.name</code>.</p>
</blockquote>
<p><code>module.name</code> is just the name of the module. It's the name that will show up in tracebacks, and it may affect other debugging, and reflective code (e.g., if you're using <code>inspect</code> anywhere), and possibly relative imports from within the module. (I'm guessing that, other that debugging output, none of this is going to affect you, in which case it doesn't even matter that much if you get it wrong.)</p>
<p>Anyway, if you're not sure, and want to see some examples rather than dig through dry and confusing documentation, open the interactive interpreter and try this:</p>
<pre><code>import &lt;whatever&gt;
print(&lt;whatever&gt;.__name__, &lt;whatever&gt;.__file__)
</code></pre>
<p>… for different values of <code>&lt;whatever&gt;</code> (from the stdlib, and from packages you've installed off PyPI, and from your own project) to get an idea. The <code>__name__</code> you see there is the name that got passed to <code>spec_from_file_location</code> by the machinery under the covers.</p>
<p>But the short version is:</p>
<ul>
<li>If you want <code>rule1</code> to act like a "namespace package", use <code>rule1.foo</code>.</li>
<li>If you want <code>rule1</code> to act like just another path on sys.path, use <code>foo</code>. </li>
</ul>
<hr/>
<blockquote>
<p>And how can the function be called?</p>
</blockquote>
<p>The exact same way you were calling a class:</p>
<pre><code>foo.analyze()
</code></pre>
<hr/>
<p>One last thing: what you're building is a pretty standard plugin system, with the simplest possible plugin API ("must expose a function <code>analyze</code> that takes no parameters"). You might want to look around for other applications with plugin systems to read their code for ideas. (But be aware that many of them are made to be backward compatible with Python 2.7 or 3.3, which means that the actual steps for importing will be very different, and you don't want to use the old-style code they use.)</p>
</div>
