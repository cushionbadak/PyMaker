<div class="post-text" itemprop="text">
<pre><code>In [1]: class Foo():
   ...:     pass
   ...: 

In [2]: class Qux():
   ...:     def __init__(self):
   ...:         item = Foo()
   ...:         

In [3]: a = Foo()

In [4]: setattr(a, 'superpower', 'strength')

In [5]: a.superpower
Out[5]: 'strength'

In [6]: b = Qux()

In [7]: b.item = a

In [8]: b.superpower
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-8-cf0e287006f1&gt; in &lt;module&gt;()
----&gt; 1 b.superpower

AttributeError: Qux instance has no attribute 'superpower'
</code></pre>
<p>What I would like is to define some way of calling any attribute on Qux and have it return <code>getattr(Qux.item, &lt;attributename&gt;)</code>. In other words, to have <code>b.superpower</code> work <strong>without</strong> explicitly defining:</p>
<pre><code>@property
def superpower(self):
    return getattr(self.item, 'superpower')
</code></pre>
<p>I don't want to lose access to any properties defined on <code>Qux</code> itself as well, but rather to expose properties defined on <code>Foo</code> if they are not also on <code>Qux</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Define a <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a>:</p>
<pre><code>class Qux(Foo):
    def __init__(self):
        self.item = Foo()
    def __getattr__(self, attr):
        return getattr(self.item, attr)
</code></pre>
<p><code>__getattr__</code> gets called whenever someone tries to look up an attribute of the object, but fails through normal means.</p>
<p>It has an evil twin called <code>__getattribute__</code>, which <em>always</em> gets called and must be used with extreme caution.</p>
</div>
<div class="post-text" itemprop="text">
<p>You do that by defining <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a>, not with a property. For any attribute that <em>cannot be found</em> with the standard protocol, Python will call the <code>__getattr__</code> method of a class.</p>
<p>Moreover, to store the <code>item</code>, you have to assign it to <code>self.item</code>, otherwise it is thrown at the end of <code>Qux.__init__</code>.</p>
<p>Finally, inheriting from <code>Foo</code> seems unecessary in that case.</p>
<pre><code>class Foo:
    def __init__(self, superpower):
        self.superpower = superpower

class Qux:
    def __init__(self, foo_item):
        self.item = foo_item

    def __getattr__(self, name):
        return getattr(self.item, name)
</code></pre>
<h2>Example</h2>
<pre><code>f = Foo('strenght')
q = Qux(f)
print(q.superpower) # 'strenght'
</code></pre>
<h1>Inheritance</h1>
<p>Although, it seems you half-tried to implement this with inheritance. If your intent was to extend <code>Qux</code> behaviour with <code>Foo</code>, then inheritance would be the way to go.</p>
<pre><code>class Foo:
    def __init__(self, superpower):
        self.superpower = superpower

class Qux(Foo):
    def __getattr__(self, name):
        return getattr(self.item, name)
</code></pre>
<h2>Example</h2>
<pre><code>q = Qux('strenght')
print(q.superpower)  # 'strenght'
</code></pre>
</div>
<span class="comment-copy">@Vishal Using <code>__getattr__</code> already does exactly that, see the doc linked in both our answers</span>
<span class="comment-copy">Can I use <code>__setattr__</code> similarly to set an attribute only if it is already defined (<code>__dict__</code>?) and set it on <code>self.item</code> if not?</span>
<span class="comment-copy">Yes. When you know it is defined already, make sure not to <code>setattr()</code> directly, because that will trigger your <code>__setattr__</code> method again. Instead, call <code>super().__setattr__(self, attr, val)</code>.</span>
<span class="comment-copy">I picked the other one only because it was answered first. Both answers work for me. Thank you.</span>
<span class="comment-copy">@Vishal Sure thing. Glad we could help!</span>
