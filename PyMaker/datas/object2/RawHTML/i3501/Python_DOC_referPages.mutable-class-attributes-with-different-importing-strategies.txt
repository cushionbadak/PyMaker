<div class="post-text" itemprop="text">
<p>I've recently stumbled upon a weird behavior of the mutable class attributes.<br/>
Theoretically (and practically), a mutable argument defined on a class level will be shared within all instances until any instance will overwrite the reference.  </p>
<p>In our project, we have directory structure similar to below:  </p>
<pre><code>├─── main.py
└─── src
    ├─── __init__.py
    ├─── cache_user.py
    └─── common_cache.py
</code></pre>
<h3>common_cache.py:</h3>
<pre><code>class CommonCache:
    cache = {}
</code></pre>
<h3>cache_user.py:</h3>
<pre><code>from .common_cache import CommonCache


class CacheUser(CommonCache):
    pass
</code></pre>
<h3>main.py:</h3>
<pre><code>from src.cache_user import CacheUser
from src.common_cache import CommonCache

common_cache = CommonCache()
cache_user = CacheUser()
print(id(common_cache.cache))
print(id(CommonCache.cache))
print(id(cache_user.cache))
print(id(CacheUser.cache))
</code></pre>
<h3>Result of running main.py:</h3>
<pre><code>2163305605304
2163305605304
2163305605304
2163305605304
</code></pre>
<p>All ID's are the same as expected which proves, that all instances and classes are sharing common reference to the same dictionary. However, when we add <code>src</code> directory into <code>PYTHONPATH</code> and slightly change imports, something weird will happen.  </p>
<h3>cache_user.py:</h3>
<pre><code>from src.common_cache import CommonCache


class CacheUser(CommonCache):
    pass
</code></pre>
<h3>main.py</h3>
<pre><code>from cache_user import CacheUser
from common_cache import CommonCache

common_cache = CommonCache()
cache_user = CacheUser()
print(id(common_cache.cache))
print(id(CommonCache.cache))
print(id(cache_user.cache))
print(id(CacheUser.cache))
</code></pre>
<h3>Result of running main.py:</h3>
<pre><code>2067930459016
2067930459016
2067930458440
2067930458440
</code></pre>
<p>Now, <code>CommonCache</code> (and instances) have their own <code>cache</code> dictionary, different from <code>CacheUser</code> (and instances). What happened? The only thing that changes is the method how we do imports. If we will put breakpoint in <code>CommonCache</code> class we can clearly see, that <code>cache = {}</code> is executed twice - once per import. If we would have more than one class that does import of <code>CommonCache</code>, only the distinct import methods will trigger <code>cache = {}</code>.  </p>
<p>Solving this issue in our project wasn't just unifying import method since the project is too big to do that. Our solution is to create <code>CacheStorage</code> class that is imported only by <code>CommonCache</code>, and the real <code>cache</code> dict is stored within <code>CacheStorage</code>.  </p>
<p>So, why is it happening? I can't find any explanation for this situation.<br/>
Also, how to deal with that? Is there any better solution than creating a <code>CacheStorage</code> object?</p>
<p>This was tested in Python3.6 on CentOS and Windows.</p>
</div>
<div class="post-text" itemprop="text">
<p>This suggests that modules are identified by their "import" name rather than the absolute file of the module file. In your case, a module <code>src.common_cache</code> is found in <code>.</code> while another module <code>common_cache</code> in <code>./src</code>.</p>
<p><a href="https://docs.python.org/3/tutorial/modules.html" rel="nofollow noreferrer">When a new module is imported, each statement get executed</a>. Therefore, there are two distinct modules imported (what the Python interpreter think):</p>
<ul>
<li>one <code>CommonCache</code> defined in the module <code>src.common_cache</code></li>
<li>one <code>CommonCache</code> defined in the module <code>common_cache</code>.</li>
</ul>
<p>This assertion also show both <code>CommonCache</code> are not refered to the same class.</p>
<pre><code>assert src.common_cache.CommonCache is not common_cache.CommonCache
</code></pre>
</div>
<span class="comment-copy">I think <code>src.common_cache</code> and <code>common_cache</code> are recognized as different modules though they point to the same file. To archive the singleton pattern of class variable / module variable, the name how a module get imported should be standardized among the related files.</span>
<span class="comment-copy">Yes, it is quite clear from the example. But the main question is why does it happen?</span>
<span class="comment-copy">That's clear. But can you tell why it does work this way if the file path is the same in both cases? Is it a bug or a feature? If feature, what are the use cases?</span>
<span class="comment-copy">This is not a bug nor feature. This is how the import system work. Python first search the required in the memory to see if it is loaded. If not, Python search it in <code>sys.path</code> (related to <code>PYTHONPATH</code>)  one by one or raise <code>ImportError</code>.</span>
<span class="comment-copy">Ok, but why <code>src.common_cache</code> and <code>common_cache</code> are treated as a different modules if their target is the same file? You can see that in <code>sys.modules</code>. That seems like a bug. Note that in first example the import statement is executed only once. The <code>ImportError</code> is never raised, it just imports the same file twice if it is within <code>PYTHONPATH</code>. If the key in <code>sys.modules</code> would be full file path instead of relative path, both modules will be treated as one.</span>
