<div class="post-text" itemprop="text">
<p>I'm trying to find the first repeated character in my string and output that character using python. When checking my code, I can see I'm not index the last character of my code.</p>
<p>What am I doing wrong? </p>
<pre><code>letters = 'acbdc'
for a in range (0,len(letters)-1):
#print(letters[a])
    for b in range(0, len(letters)-1):
        #print(letters[b])
        if (letters[a]==letters[b]) and (a!=b):
            print(b)
            b=b+1
a=a+1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this in an easier way:</p>
<pre><code>letters = 'acbdc'
found_dict = {}
for i in letters:
    if i in found_dict:
        print(i)
        break
    else:
        found_dict[i]= 1
</code></pre>
<p>Output:
<code>c</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution with sets, it should be slightly faster than using dicts.</p>
<pre><code>letters = 'acbdc'
seen = set()

for letter in letters:
    if letter in seen:
        print(letter)
        break
    else:
        seen.add(letter)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution that would stop iteration as soon as it finds a dup</p>
<pre><code>&gt;&gt;&gt; from itertools import dropwhile
&gt;&gt;&gt; s=set(); next(dropwhile(lambda c: not (c in s or s.add(c)), letters))
'c'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should use <code>range(0, len(letters))</code> instead of <code>range(0, len(letters) - 1)</code> because <code>range</code> already stops counting at one less than the designated stop value. Subtracting 1 from the stop value simply makes you skip the last character of <code>letters</code> in this case.</p>
<p>Please read the documentation of range:
<a href="https://docs.python.org/3/library/stdtypes.html#range" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#range</a></p>
</div>
<div class="post-text" itemprop="text">
<p>There were a few issues with your code...</p>
<p>1.Remove <code>-1</code> from <code>len(letters)</code></p>
<p>2.Move back one indent and do <code>b = b + 1</code> even if you don't go into the if statement</p>
<p>3.Indent and do <code>a = a + 1</code> in the first for loop.</p>
<p>See below of how to fix your code...</p>
<pre><code>    letters = 'acbdc'
    for a in range(0, len(letters)):
        # print(letters[a])
        for b in range(0, len(letters)):
            # print(letters[b])
            if (letters[a] == letters[b]) and (a != b):
                print(b)
            b = b + 1
        a = a + 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Nice one-liner generator:</p>
<pre><code>l = 'acbdc'
next(e for e in l if l.count(e)&gt;1)
</code></pre>
<p>Or following the rules in the comments to fit the "abba" case:</p>
<pre><code>l = 'acbdc'
next(e for c,e in enumerate(l) if l[:c+1].count(e)&gt;1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The below code prints the first repeated character in a string. I used the functionality of the list to solve this problem.</p>
<pre><code>      def findChar(inputString): 
          list = []
          for c in inputString:
              if c in list:
                  return c
              else:
                  list.append(c) 
      return 'None'    

      print (findChar('gotgogle'))
</code></pre>
<p>Working fine as well. It gives the result as 'g'.</p>
</div>
<div class="post-text" itemprop="text">
<p>If complexity is not an issue then this will work fine.</p>
<pre><code>letters = 'acbdc'
found = False
for i in range(0, len(letters)-1):
    for j in range(i+1, len(letters)):
        if (letters[i] == letters[j]):
            print (letters[j])
            found = True
            break
    if (found):
        break
</code></pre>
</div>
<span class="comment-copy">remove the <code>-1</code> from <code>len(letters)-1</code> - <code>range</code> has an exclusive upper bound</span>
<span class="comment-copy">Half of the solutions are doing this wrong, and half are doing it right.  Can you clarify what the proper output should be for the string <code>abba</code>?</span>
<span class="comment-copy">You would want a break or return after Print, because they want only the FIRST occurance. Therefore you need to exit your loop.</span>
<span class="comment-copy">Thank you. I have written the code for all repeated letters. I am updating it soon.</span>
<span class="comment-copy">FWIW, you don't need the call <code>.keys()</code>. <code>x in dict</code> already checks if the key is in the dict. Plus, it is slow in Python 2 :)</span>
<span class="comment-copy">You've noticed a very good point. I have updated my answer. thanks.</span>
<span class="comment-copy">This doesn't work for a string like <code>abba</code>.  It will return <code>a</code>.  To generalize, you are assuming that the first repeated character also appears in order previously in the string</span>
<span class="comment-copy">Isn't <code>a</code> the first character that was repeated?</span>
<span class="comment-copy">No, <code>b</code> is the first character to be repeated.  <code>a</code> is repeated <i>after</i> <code>b</code></span>
<span class="comment-copy">Well then I misinterpretted the question. BigBadBison also does this.</span>
<span class="comment-copy">@ᴡʜᴀᴄᴋᴀᴍᴀᴅᴏᴏᴅʟᴇ3000 The second solution does fix it but it isn't as efficient as Sunitha's answer, which solves it in O(n). Still a good alternative though.</span>
