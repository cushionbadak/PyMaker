<div class="post-text" itemprop="text">
<p>I am reading the docs on python <code>threading</code> and the <code>timer</code> subclass and I do not quite understand how it would work if I want to run two (or more) timed class methods at different rates on the same thread. </p>
<p>For example, I have an I/O serial device that I want to periodically read (if any data), write any input messages from outside modules, and periodically write a predefined device specific heartbeat message. This is all wrapped in a custom class. I/O messages are stored in two separate class queue objects.</p>
<p>Do I need to create three <code>threading.Timer</code> objects for each function, or can I somehow use one thread that switches?</p>
<pre><code>import serial, threading, Queue
# the exact syntax below may be incorrect

class MySerialDevice:

    def __init__():
         # Some other modules will be appending to this (through a class method) 
         self.write_queue = Queue()
         self.read_queue = Queue()
         self.port = serial.Serial()
         # check for incoming data every 20ms
         self.thread1 = threading.Timer(0.02, self.read)
         # check for outgoing data every 20ms
         self.thread2 = threading.Timer(0.02, self.write)
         # Send the heaertbeat every 1 second
         self.thread3 = threading.Timer(1, self.heartbeat)

         # what do I do here???
         # can I make all three tasks on a single thread, that just continuously loops 
         # and "if incoming data, read, if outgoing data, write, heartbeat???

    def read(self):
        # checks for actual data, appending to queue are ommited
        self.port.read()
    def write(self):
        # checks for data in queue ommitted
        self.port.write(self.write_queue[0])
    def heartbeat(self):
        self.port.write("Device Heartbeat message)"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/threading.html#timer-objects" rel="nofollow noreferrer"><code>Timer</code></a> is dead-simple; there's nothing more to it than you see. It runs a single timer, one time, taking up a whole thread to do it.</p>
<p>In fact, it's really there more as sample code than anything else. The second sentence in its documentation is "<code>Timer</code> is a subclass of <code>Thread</code> and as such also functions as an example of creating custom threads." And the <code>threading</code> docs link to <a href="https://github.com/python/cpython/blob/3.7/Lib/threading.py#L1132" rel="nofollow noreferrer">the source</a>, and you can see how simple it is.</p>
<hr/>
<p>It's not that hard to build something more complicated out of that sample code. </p>
<p>There used to be some good examples in the ActiveState recipe collection. I don't know how to search their new repo, but you can start off with <a href="https://code.activestate.com/recipes/langs/python/tags/timer/" rel="nofollow noreferrer">a tag lookup</a>.</p>
<p>Alternatively, there are a bunch of more powerful schedulers ready to use on PyPI.</p>
<hr/>
<p>Or you can rewrite your code around a <code>tick</code> method. If you tick every 20ms, <code>read</code> and <code>write</code> run on every tick, and <code>heartbeat</code> runs every 50 ticks, right?</p>
<pre><code>def __init__(self):
    self.tickcount = 0
    self.timer = threading.Timer(0.02, self.tick)

def tick(self):
    self.read()
    self.write()
    self.tickcount += 20
    if not self.tickcount % 1000:
        self.heartbeat()
    self.timer = threading.Timer(0.02, self.tick)
</code></pre>
<hr/>
<p>However, at this point, it's almost as simple to just write a function that loops every 20ms instead of using a timer. And that's much easier to extend if, e.g., you need to worry about not accumulating lag. For example:</p>
<pre><code>def ticker(self):
    last = datetime.datetime.now()
    while True:
        wake = last + datetime.timedelta(milliseconds=20)
        now = datetime.datetime.now()
        while wake &gt; now:
            time.sleep((wake - now).total_seconds())
        self.tick()
        last = wake
</code></pre>
<p>Now you can just run <code>self.ticker</code> in a thread.</p>
<hr/>
<p>Or you can just use multiple <code>Timer</code> objects. You're talking about a handful of objects and three timers per object, right? It may not seem the most elegant solution, but it's not like it's going to overburden the scheduler.</p>
</div>
<span class="comment-copy">You should just use a single thread ... in the above each <code>Timer</code> is a separate thread, and will only run its target <i>once</i></span>
