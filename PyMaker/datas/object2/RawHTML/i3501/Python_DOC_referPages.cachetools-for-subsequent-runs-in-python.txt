<div class="post-text" itemprop="text">
<p>Am a beginner.Sorry if my question is childish . Do cachetools in python work for susbsequent runs? </p>
<pre><code>import cachetools
import time


@cachetools.cached({})
def find_sum(n):
    time.sleep(5)
    return n+2


print find_sum(2)
print find_sum(3)
print find_sum(2)
</code></pre>
<p>So during the first run the third call is faster but the next time i run the file i want the first call to be faster and take result from the cache. Can cachetools do this?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://cachetools.readthedocs.io/" rel="nofollow noreferrer"><code>cachetools</code></a> cannot do this out of the box. But it's very easy to add.</p>
<p>You can pass any mutable mapping you want to the <a href="http://cachetools.readthedocs.io/en/latest/#memoizing-decorators" rel="nofollow noreferrer">memoizing decorators</a>. You're using a plain old dict, and dicts are trivial to pickle. And even if you use one of the fancy <a href="http://cachetools.readthedocs.io/en/latest/#cache-implementations" rel="nofollow noreferrer">cache implementations</a> provided by the library, they're all easy to pickle as well.<sup>1</sup></p>
<p>So:</p>
<pre><code>import cachetools
import pickle
import time

try:
    with open('mycache.pickle', 'rb') as f:
        cache = pickle.load(f)
except FileNotFoundError:
    cache = {} # or cachetools.LRUCache(maxsize=5) or whatever you want

@cachetools.cached(cache)
def find_sum(n):
    time.sleep(5)
    return n+2

print(find_sum(2))
print(find_sum(3))
print(find_sum(2))

with open('mycache.pickle', 'wb') as f:
    pickle.dump(cache, f)
</code></pre>
<hr/>
<p>Of course you can add:</p>
<ul>
<li>A <code>finally</code> or context manager or <code>atexit</code> to make sure you save your files at shutdown even if you hit an exception or ^C.</li>
<li>A timer that saves them every so often.</li>
<li>A hook on the cache object to save on every update, or every Nth update. (Just override the <code>__setitem__</code> methodâ€”or see <a href="http://cachetools.readthedocs.io/en/latest/#extending-cache-classes" rel="nofollow noreferrer">Extending cache classes</a> for other things you can do, if you use one of the fancier classes instead of a dict.)</li>
</ul>
<hr/>
<p>Or you can even use an on-disk key-value database as a cache.</p>
<p>The simplest such database is <a href="https://docs.python.org/3/library/dbm.html" rel="nofollow noreferrer"><code>dbm</code></a>. It's limited to <code>str</code>/<code>bytes</code> for both keys and values. (You can use <a href="https://docs.python.org/3/library/shelve.html" rel="nofollow noreferrer"><code>shelve</code></a> if you want non-string values; if you want non-string keys, you probably want a different solution.) So, that doesn't quite work for our example. But for a similar example, it's almost magic:</p>
<pre><code>import dbm
import time
import cachetools

cache = dbm.open('mycache.dbm', 'c')
@cachetools.cached(cache, key=lambda s:s)
def find_string_sum(s):
    time.sleep(5)
    return s + '!'

print(find_string_sum('a'))
print(find_string_sum('b'))
print(find_string_sum('a'))
</code></pre>
<p>The only tricky bit was that I had to override the <code>key</code> function. (The default key function handles <code>*args, **kw</code>, so for argument <code>'a'</code> you end up with something like <code>(('a',), ())</code>, which is obviously not a string.)</p>
<hr/>
<p><sub>1. As you can see from <a href="https://github.com/tkem/cachetools/blob/master/cachetools/rr.py#L8" rel="nofollow noreferrer">the source</a>, there are bug fixes to make sure all of the classes are picklable in all supported Python versions, so this is clearly intentional.</sub></p>
</div>
