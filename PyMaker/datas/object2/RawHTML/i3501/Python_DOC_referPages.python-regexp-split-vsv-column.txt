<div class="post-text" itemprop="text">
<p>With data like</p>
<pre><code>230030215840▒Cumul Arte▒pl▒PROGRAMME_WEB▒SCI_nauka▒075631-005-A▒TV▒1
230030215840▒Cumul Arte▒pl▒PROGRAMME_WEB▒SCI_nauka▒075631-006-A▒TV▒1
</code></pre>
<p>I would like to split 075631-006-A into</p>
<pre><code>...▒075631-006-A▒075631-006▒A▒...
</code></pre>
<p>That means adding two columns.
My idea was first to check if such a string is present</p>
<pre><code>searchObj=re.search("(\d{6}-\d{3})-([A-Z])",data,flags=0)
    if searchObj&gt;0: #On trouve un EM
</code></pre>
<p>And then to do a sub using searchObj.groups but I can't make it</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is one way:</p>
<pre><code>&gt;&gt;&gt; data='230030215840▒Cumul Arte▒pl▒PROGRAMME_WEB▒SCI_nauka▒075631-005-A▒TV▒1'
&gt;&gt;&gt; import re
&gt;&gt;&gt; searchObj = re.search("(\d{6}-\d{3})-([A-Z])",data,flags=0)
&gt;&gt;&gt; data.replace(searchObj.expand('\\1-\\2'), searchObj.expand('\\1▒\\2'))
'230030215840▒Cumul Arte▒pl▒PROGRAMME_WEB▒SCI_nauka▒075631-005▒A▒TV▒1'
</code></pre>
<p>The <a href="https://docs.python.org/3/library/re.html#re.match.expand" rel="nofollow noreferrer">expand documentation</a> explains how it can be used to exploit the matched groups.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use nested groups: wrap your whole substring with another paren group, treating it more like "atomic" thing, and keep paren groups you started with for matching the parts:</p>
<pre><code>&gt;&gt;&gt; s = '230030215840▒Cumul Arte▒pl▒PROGRAMME_WEB▒SCI_nauka▒075631-006-A▒TV▒1'
&gt;&gt;&gt; re.search(r'((\d{6}-\d{3})-([A-Z]))', s).groups()
('075631-006-A', '075631-006', 'A')
&gt;&gt;&gt; re.search(r'((\d{6}-\d{3})-([A-Z]))', s).groups()[1:]
('075631-006', 'A')
</code></pre>
<p>This way, if the whole <code>075631-006-A</code>-like substring was not present, the MatchObject would be None, raising an error:</p>
<pre><code>&gt;&gt;&gt; re.search(r'((\d{6}-\d{3})-([A-Z]))', '075631-006-__BAD__').groups()[1:]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'groups'
</code></pre>
<p>Then, more complete solution would look like:</p>
<pre><code>rx = re.compile(r'((\d{6}-\d{3})-([A-Z]))')
match = rx.search(input)
if match:
   # all 3 groups are present here
   part1, part2 = match.groups()[1:]
</code></pre>
<p>Hope this helps.</p>
<p><em>EDIT</em> <br/>
Another variant is to use non-capturing paren group. Depending on your taste it adds or removes clarity - slicing <code>[1:]</code> is not needed, but at the same time you use this funky  <code>(?:....)</code> <a href="https://docs.python.org/2/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">regexp syntax</a>:</p>
<pre><code>rx = re.compile(r'(?:(\d{6}-\d{3})-([A-Z]))')
match = rx.search(input)
if match:
   part1, part2 = match.groups()
</code></pre>
</div>
<span class="comment-copy">what does the first v stand for?</span>
<span class="comment-copy">Since it is a delimited string, it is probably safer to first split, then modify the required field and the assemble the string back, see <a href="https://ideone.com/bAStzh" rel="nofollow noreferrer">this Python demo</a>.</span>
<span class="comment-copy">This approach behaves erroneously for invalid input if only one of paren groups is present - it should rather error (searchObj == None) than do invalid <code>data.replace()</code>.</span>
<span class="comment-copy">That's not surprising, is it?</span>
<span class="comment-copy">That is surprising for a user if he has invalid data and he doesn't know about that- very real world situation. Imagine one of OP's input lines has this format broken.. It's better to provide code which fails for invalid input than the one which gives false positive, isn't it? Robustness is a good thing</span>
