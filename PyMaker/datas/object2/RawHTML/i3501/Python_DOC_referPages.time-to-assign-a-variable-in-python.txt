<div class="post-text" itemprop="text">
<p>Suppose I have the following in a really tight loop:</p>
<pre><code>a = func(x)
b = func2(a)
</code></pre>
<p>The variable <code>a</code> is not used anywhere else.</p>
<p>Does Python automatically compile away the assignment to <code>a</code>, or does it take the time to do the variable assignment every time? In other words, is this code identical, or is it marginally faster due to the lack of assigning to <code>a</code>?</p>
<pre><code>b = func2(func(x))
</code></pre>
<p>Is the behavior the same for Python2.7 vs Python3?</p>
</div>
<div class="post-text" itemprop="text">
<p>So using the very fun <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> module we can look into the actual bytecode that is generated from the python code you provided. To keep things simple I have replaced <code>func</code> and <code>func2</code> with builtin functions (<code>int</code> and <code>float</code>).</p>
<p>So our source looks like this:</p>
<pre><code>def assign():
    a = int()
    b = float(a)
</code></pre>
<p>Versus a simplified version:</p>
<pre><code>def simple():
    b = float(int())
</code></pre>
<p>And then starting with the cpython 2.7 interpretter, we can see the bytecodes generated from the <code>assign</code> function:</p>
<pre><code>dis.dis(assign)
  2           0 LOAD_GLOBAL              0 (int)
              3 CALL_FUNCTION            0
              6 STORE_FAST               0 (a)

  3           9 LOAD_GLOBAL              1 (float)
             12 LOAD_FAST                0 (a)
             15 CALL_FUNCTION            1
             18 STORE_FAST               1 (b)
             21 LOAD_CONST               0 (None)
             24 RETURN_VALUE
</code></pre>
<p>As you can see there is no peephole optimization to remove the unnecessary intermediate variable, which results in an additional 2 instructions (<code>STORE_FAST a</code>, <code>LOAD_FAST a</code>) when compared against the bytecodes for the simplified `simple method: </p>
<pre><code>dis.dis(simple)
  2           0 LOAD_GLOBAL              0 (float)
              3 LOAD_GLOBAL              1 (int)
              6 CALL_FUNCTION            0
              9 CALL_FUNCTION            1
             12 STORE_FAST               0 (b)
             15 LOAD_CONST               0 (None)
             18 RETURN_VALUE
</code></pre>
<p>This is the same for the CPython interpreter for Python 3.5, and for the pypy interpreter for Python 2.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the dis module to compare the bytecode: looks like the second method produces fewer <em>operations</em></p>
<pre><code>import dis

print(dis.dis('a=f(2);b=g(a)'))
print(dis.dis('b=g(f(2))'))


&gt;&gt;&gt;   
  1           0 LOAD_NAME                0 (f)
              2 LOAD_CONST               0 (2)
              4 CALL_FUNCTION            1
              6 STORE_NAME               1 (a)
              8 LOAD_NAME                2 (g)
             10 LOAD_NAME                1 (a)
             12 CALL_FUNCTION            1
             14 STORE_NAME               3 (b)
             16 LOAD_CONST               1 (None)
             18 RETURN_VALUE
None
  1           0 LOAD_NAME                0 (g)
              2 LOAD_NAME                1 (f)
              4 LOAD_CONST               0 (2)
              6 CALL_FUNCTION            1
              8 CALL_FUNCTION            1
             10 STORE_NAME               2 (b)
             12 LOAD_CONST               1 (None)
             14 RETURN_VALUE
None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Such type of queries could be easily checked with <code>timeit</code>. Here are the results with <code>Python2.7</code>.</p>
<pre><code>root:/var# python -m timeit "f1 = lambda x:x; f2 = lambda x: x*2; a=f1(2); b=f2(a)"
1000000 loops, best of 3: 0.29 usec per loop
root:/var# python -m timeit "f1 = lambda x:x; f2 = lambda x: x*2; b=f2(f1(2))"
1000000 loops, best of 3: 0.284 usec per loop
root:/var# python -m timeit "f1 = lambda x:x; f2 = lambda x: x*2; a=f1(2); b=f2(a)"
1000000 loops, best of 3: 0.285 usec per loop
root:/var# python -m timeit "f1 = lambda x:x; f2 = lambda x: x*2; b=f2(f1(2))"
1000000 loops, best of 3: 0.283 usec per loop
root:/var# python -m timeit "f1 = lambda x:x; f2 = lambda x: x*2; a=f1(2); b=f2(a)"
1000000 loops, best of 3: 0.294 usec per loop
root:/var# python -m timeit "f1 = lambda x:x; f2 = lambda x: x*2; b=f2(f1(2))"
1000000 loops, best of 3: 0.286 usec per loop
</code></pre>
<p>And this shows consistent results with other answers that describe the use the the awesome <code>dis</code> module.</p>
</div>
<div class="post-text" itemprop="text">
<p>The actual time will depend on the functions <code>func()</code> and <code>func2()</code> do. Not the best example, but a quick (and dirty) test code is given below:</p>
<pre><code>import time

def func(x):
    return 5

def func2(a):
    return 10

t0 = time.time()
x = 10
for i in range(1,10000):
    a = func(x)
    b = func2(a)
t1 = time.time()

print("Time 1: ", t1-t0)

t2 = time.time()
x = 10
for i in range(1,10000):
    b = func2(func(x))
t3 = time.time()

print("Time 2: ", t3-t2)
</code></pre>
<p>The output of the above code is:</p>
<pre><code>Time 1:  0.0029211044311523438
Time 2:  0.002785921096801758
</code></pre>
<p>So yes, the implementation where we avoid the assignment of <code>a</code> is marginally faster in Pyhton 3.</p>
</div>
<span class="comment-copy">not sure about it, but without the assignment could be a bit faster</span>
<span class="comment-copy">This seems like a question you could answer by just trying it yourself (e.g. using the <a href="https://docs.python.org/2/library/timeit.html" rel="nofollow noreferrer">timeit</a> module).</span>
<span class="comment-copy">@larsks I've read that <code>timeit</code> is somewhat unreliable for such small timing differences. All answers below that use it show differences on the order of nanoseconds, which isn't convincing and might just be noise.  The bytecode answers are the answer I was looking for (and I did not know about <code>dis</code> previously)</span>
<span class="comment-copy">Basically the same as the answer by @MatthewStory but shows a different way to use <code>dis.dis</code> - I'll leave it up unless I get some negative responses.</span>
<span class="comment-copy">It would probably make more sense to put the creation of <code>f1</code> and <code>f2</code> in the setup block instead of inside the timing loop.</span>
<span class="comment-copy">Agreed. No need to initialize for each iteration.</span>
<span class="comment-copy">Why would it depend on the specific functions?</span>
<span class="comment-copy">Sorry, I meant, the actual timing will depend on the content of the functions. Edited the response.</span>
