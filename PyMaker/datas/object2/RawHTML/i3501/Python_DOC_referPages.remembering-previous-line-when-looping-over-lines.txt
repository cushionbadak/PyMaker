<div class="post-text" itemprop="text">
<p>Suppose I have a large CSV file with data on whether it rained at a given day and time. A toy example is as follows.</p>
<pre><code>Day, Time, Rain
1, 0800, 1
1, 0818, 0
1, 0842, 1
1, 0900, 0
2, 0800, 0
2, 0822, 1
2, 0845, 1
2, 0900, 1
</code></pre>
<p>I wish to write code that can calculates the proportion of time that it rained in a day. My calculation method is as follows (from the second observation of the day onwards):</p>
<ol>
<li>If it didn't rain between that observation and the previous observation, then the entire period is <em>not</em> counted as raining. </li>
<li>If it rained between that observation and the previous observation, then the entire period is counted as raining </li>
<li>If exactly one of that observation and previous observations is raining, half of the period is counted as raining.</li>
</ol>
<p>So for example, on Day 1 it was raining for 30 minutes (half of 0800 to 0818, half of 0818 to 0842, and half of 0842 and 0900). On Day 2 it was raining for 49 minutes (half of the period from 0800 and 0822, and raining from 0822 to 0900).</p>
<p>How can I do this quickly in Python? I know that <code>for line in file:</code> iterates through each line, but doesn't store a memory of the previous line.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd maintain a variable holding the last line seen and update it each iteration:</p>
<pre><code>last_line = None
for line in lines:

    # You need to change this to explicitly check against None if line can be empty
    if not last_line:
        # Handle no last line on the first iteration

    # Use line and last_line

    # Update the last line seen
    last_line = line
</code></pre>
<p>You could also default <code>last_line</code> to a valid value at the start which would do away with the need to check for it in the loop. That's not always feasible though. </p>
<p>There is conceivably more complicated methods like zipping <code>lines</code> with a version of itself where each element is offset by one, but this is likely much simpler. </p>
</div>
<div class="post-text" itemprop="text">
<p><em>[Note: if this is a one-off, then I suggest using Carcigenicate's answer]</em></p>
<p>This is a great use for generators and the <code>yield</code> statement.  The following function will accept your iterator, and yield pairs as a 2-tuple which can be used however you need.</p>
<p><strong>Generator Function:</strong></p>
<pre><code>def lineandlast(listish, first=True, last=True):
    iterator = iter(listish)
    lastline = next(iterator)

    if first:
      yield lastline, None

    for line in iterator:
        yield line, lastline
        lastline = line

    if last:
        yield None, lastline
</code></pre>
<p><strong>Example:</strong></p>
<pre><code>for line, last in lineandlast([1,2,3,4,5]):
    print(line, last)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>1 None
2 1
3 2
4 3
5 4
None 5
</code></pre>
<p><strong>Notes:</strong><br/>
There are two keyword arguments, <code>first</code> and <code>last</code>, which can be used to control the output of the first and last items on the output example above.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could just <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> your lines, where you know the previous line and current line.</p>
<p><strong>Demo:</strong></p>
<pre><code>with open('data.csv') as in_file:
    # skip headers
    next(in_file)

    # convert _io_TextIOWrapper object to list
    in_file = list(in_file)

    # print out current and previous lines
    for curr, prev in zip(in_file[1:], in_file):
        print("CURRENT: %s, PREVIOUS: %s" % (curr.strip(), prev.strip()))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>CURRENT: 1, 0818, 0, PREVIOUS: 1, 0800, 1
CURRENT: 1, 0842, 1, PREVIOUS: 1, 0818, 0
CURRENT: 1, 0900, 0, PREVIOUS: 1, 0842, 1
CURRENT: 2, 0800, 0, PREVIOUS: 1, 0900, 0
CURRENT: 2, 0822, 1, PREVIOUS: 2, 0800, 0
CURRENT: 2, 0845, 1, PREVIOUS: 2, 0822, 1
CURRENT: 2, 0900, 1, PREVIOUS: 2, 0845, 1
</code></pre>
<p>You could also use the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code></a> library for csv file processing. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby</code>:</p>
<pre><code>import itertools, csv, typing
from functools import reduce
def calculate_minutes(stats:typing.List[list]) -&gt; int:
  new_row = [(int(a), list(b)) for a, b in itertools.groupby(stats, key=lambda x:x[-1])]
  result = 0
  for i in range(len(new_row)-1):
    [m, _start], [m1, _end] = new_row[i], new_row[i+1]
    if any([m, m1]):
      a, b = int(_start[-1][0]), int(_end[0][0])
      result += abs((((int(str(a)[0])-int(str(b)[0]))*60)+int(str(a)[1:])-int(str(b)[1:]))//2)
      if m and len(_start) &gt; 1:
        a, b = int(_start[-1][0]), int(_start[0][0])
        result += abs(((int(str(a)[0])-int(str(b)[0]))*60)+int(str(a)[1:])-int(str(b)[1:]))
      if m1 and len(_end) &gt; 1:
        a, b = int(_end[-1][0]), int(_end[0][0])
        result += abs(((int(str(a)[0])-int(str(b)[0]))*60)+int(str(a)[1:])-int(str(b)[1:]))
  return result

with open('filename.csv') as f:
  data = list(csv.reader(f))
  new_results = {a:[c for _, *c in b] for a, b in itertools.groupby(data[1:], key=lambda x:x[0])}
  final_results = {a:calculate_minutes(b) for a, b in new_results.items()}
  print(final_results)
</code></pre>
<p>Output:</p>
<pre><code>{'1': 30, '2': 49}
</code></pre>
</div>
<span class="comment-copy">That makes sense. I'll try it.</span>
<span class="comment-copy">Firstly, I would suggest <a href="https://pandas.pydata.org/" rel="nofollow noreferrer">pandas</a> for fast .csv file processing.  That depends on how large the problem is.  Secondly, here are some <a href="https://stackoverflow.com/help/mcve">tips</a> for writing good SO questions; we prefer if people give us more code to work with.  If someone is very patient, they may solve your problem for you, but most people passing by will not have time for that.  Welcome to SO!</span>
