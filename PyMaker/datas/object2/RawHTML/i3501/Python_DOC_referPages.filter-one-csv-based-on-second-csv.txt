<div class="post-text" itemprop="text">
<p>After reading in two CSV files A and B, I would like to remove all rows in B
whose first two columns  do not match the first two columns of any row in A.
Then save B to disk.</p>
<p>Here is what I have so far:</p>
<pre><code> A =  pd.read_csv('A.csv', header=None)
 B = pd.read_csv('B.csv', header = None)
 for row_A in A.iterrows():
     foundMatch = False
     for row_B in B.iterrows():
         if (row_A[0] == row_B[0] and row_A[1] == row_B[1]) :
             foundMatch = True
             break
     if (!foundMatch)
         # delete row from B
  B.to_csv('B_filtered.csv', index=False, header=None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>IIUC, given two data frames:</p>
<pre><code>dfa = pd.DataFrame({"col1": ["str{}".format(i) for i in range(10)], 
                   "col2": ["str{}".format(chr(i)) for i in range(97,107)]})

    col1    col2
0   str0    stra
1   str1    strb
2   str2    strc
3   str3    strd
4   str4    stre
5   str5    strf
6   str6    strg
7   str7    strh
8   str8    stri
9   str9    strj

dfb = pd.DataFrame({"col1": ["str0", "str1", "str1000"],
                    "col2": ["stra", "strb", "strc"]})

    col1    col2
0   str0    stra
1   str1    strb
2   str1000 strc
</code></pre>
<p>You can first <code>transform</code> the first two columns to become <code>tuples</code> (and consequently hashable objects), and then use <code>isin</code> to check whether there is such a pair in <code>df</code> A, i.e.</p>
<pre><code>&gt;&gt;&gt; dfa.transform(tuple, 1)
0    (str0, stra)
1    (str1, strb)
2    (str2, strc)
3    (str3, strd)
4    (str4, stre)
5    (str5, strf)
6    (str6, strg)
7    (str7, strh)
8    (str8, stri)
9    (str9, strj)
</code></pre>
<p>So</p>
<pre><code>df_final = dfb.loc[dfb.transform(tuple, 1).isin(dfa.transform(tuple, 1))]
</code></pre>
<p>which gives</p>
<pre><code>    col1    col2
0   str0    stra
1   str1    strb
</code></pre>
<p>Then just save it <code>to_csv</code></p>
<pre><code>df_final.to_csv("result.csv")
</code></pre>
<hr/>
<p><em>(Side note: whenever possible, try not to use iteration in pandas data frames. Performance will suck and you'll lose the real power of this library )</em></p>
</div>
<div class="post-text" itemprop="text">
<p>You could also try this pure python solution which uses the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code></a> library:</p>
<pre><code>from csv import reader
from csv import writer

with open('A.csv') as fileA, \
     open('B.csv') as fileB, \
     open('B_filtered.csv', 'w') as outB:

    csv_writer = writer(outB)

    readerA = reader(fileA)
    readerB = reader(fileB)

    # store first two columns of every row in file A
    A_map = {(col1, col2) for col1, col2, *_ in readerA}

    for col1, col2, *rest in readerB:

        # only write to csv if columns exist in map
        if (col1, col2) in A_map:
            csv_writer.writerow([col1, col2, *rest])
</code></pre>
</div>
<span class="comment-copy">Please post a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a></span>
<span class="comment-copy">Fantastic! One more question - what if I want to match the first two colums of A to the second and third columns of B ?</span>
<span class="comment-copy">@Jacko then you'd explicitly select the columns, e.g. <code>dfb[["col2", "col3"]].transform(tuple,1)</code> and so forth: <code>dfb.loc[dfb[["col2", "col3"]].transform(tuple, 1).isin(dfa[["col1", "col2"]].transform(tuple, 1))]</code></span>
<span class="comment-copy">Super awesome! Thank you!</span>
