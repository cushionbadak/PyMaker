<div class="post-text" itemprop="text">
<p>Here is my dataframe:</p>
<pre><code>data1 = [['2017-02-10','orange','jon','small','1','1.1'], ['2017-02-10','orange','jon','medium','1','2.1'], ['2017-02-10','orange','jon','large','1','3.1'], ['2017-02-11','orange','mary','small','2','1.2'], ['2017-02-10','orange','jon','medium','2','2.2'], ['2017-02-10','orange','jon','large','2','3.2'], ['2017-02-10','orange','jon','small','1','7.1'], ['2017-02-11','orange','mary','medium','1','8.1'], ['2017-02-11','orange','mary','large','1','9.1'], ['2017-02-11','orange','mary','small','2','10.1'], ['2017-02-11','orange','mary','medium','2','11.1'], ['2017-02-11','orange','mary','large','2','12.1']]

df = pd.DataFrame(data1,columns=['date', 'fruit', 'name', 'size', 'replicate', 'weight'])
print df
          date   fruit  name    size replicate weight
0   2017-02-10  orange   jon   small         1    1.1
1   2017-02-10  orange   jon  medium         1    2.1
2   2017-02-10  orange   jon   large         1    3.1
3   2017-02-11  orange   mary   small         2    1.2
4   2017-02-10  orange   jon  medium         2    2.2
5   2017-02-10  orange   jon   large         2    3.2
6   2017-02-10  orange  jon   small         1    7.1
7   2017-02-11  orange  mary  medium         1    8.1
8   2017-02-11  orange  mary   large         1    9.1
9   2017-02-11  orange  mary   small         2   10.1
10  2017-02-11  orange  mary  medium         2   11.1
11  2017-02-11  orange  mary   large         2   12.1
</code></pre>
<p>I need to group this dataframe so that the output has a small, medium, and large values separated by replicate, like so:</p>
<pre><code>val1 = ['2017-02-10', 'orange', 'jon', 'small', '1', '1.1'],
['2017-02-10', 'orange', 'jon', 'medium', '1', '2.1'],
['2017-02-10', 'orange', 'jon', 'large', '1', '3.1'],

val2 = ['2017-02-10', 'orange', 'jon', 'small', '2', '7.1'],
['2017-02-10', 'orange', 'jon', 'medium', '2', '2.2'],
['2017-02-10', 'orange', 'jon', 'large', '2', '3.2'],

val3 = ['2017-02-11', 'orange', 'mary', 'small', '1', '1.2'],
['2017-02-11', 'orange', 'mary', 'medium', '1', '8.1'],
['2017-02-11', 'orange', 'mary', 'large', '1', '9.1'],

val4....
</code></pre>
<p>The format of the output doesn't matter, its more how to group the data appropriately. Using a non-pandas/numpy approach, I can create a unique identifier from values taken from multiple columns so that if a 'jon' instance is out of place', it will still be grouped correctly in the output. More specifically, each output group could have a unique identifier for 'date', 'fruit', 'name', BUT must have all corresponding instances of 'small', 'medium', and 'large', along with the weight of the item.</p>
</div>
<div class="post-text" itemprop="text">
<h3>Ordered data</h3>
<p>You can use a dictionary for a variable number of variables. Here's one way using <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iloc.html" rel="nofollow noreferrer"><code>pd.DataFrame.iloc</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a>:</p>
<pre><code>from itertools import zip_longest

# calculate when replicate changes
s = df['replicate'] != df['replicate'].shift()

# extract index of True values
idx = s[s].index

# enumerate and slice using integer location
vals = {num: df.iloc[i:j] for num, (i, j) in enumerate(zip_longest(idx, idx[1:]), 1)}

print(vals)

{1:          date   fruit name    size replicate weight
 0  2017-02-10  orange  jon   small         1    1.1
 1  2017-02-10  orange  jon  medium         1    2.1
 2  2017-02-10  orange  jon   large         1    3.1,
 2:          date   fruit name    size replicate weight
 3  2017-02-10  orange  jon   small         2    1.2
 4  2017-02-10  orange  jon  medium         2    2.2
 5  2017-02-10  orange  jon   large         2    3.2,
 3:          date   fruit  name    size replicate weight
 6  2017-02-11  orange  mary   small         1    7.1
 7  2017-02-11  orange  mary  medium         1    8.1
 8  2017-02-11  orange  mary   large         1    9.1,
 4:           date   fruit  name    size replicate weight
 9   2017-02-11  orange  mary   small         2   10.1
 10  2017-02-11  orange  mary  medium         2   11.1
 11  2017-02-11  orange  mary   large         2   12.1}
</code></pre>
<hr/>
<h3>Unordered data</h3>
<p>You can still use a dictionary, this time <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html" rel="nofollow noreferrer"><code>pd.DataFrame.groupby</code></a> is convenient:</p>
<pre><code>groups = df.groupby(['date', 'fruit', 'name', 'replicate'])

vals = {i: v for i, (_, v) in enumerate(groups, 1)}

print(vals)

{1:          date   fruit name    size replicate weight
0  2017-02-10  orange  jon   small         1    1.1
1  2017-02-10  orange  jon  medium         1    2.1
2  2017-02-10  orange  jon   large         1    3.1,
 2:          date   fruit name    size replicate weight
3  2017-02-10  orange  jon   small         2    1.2
4  2017-02-10  orange  jon  medium         2    2.2
5  2017-02-10  orange  jon   large         2    3.2,
 3:          date   fruit  name    size replicate weight
6  2017-02-11  orange  mary   small         1    7.1
7  2017-02-11  orange  mary  medium         1    8.1
8  2017-02-11  orange  mary   large         1    9.1,
 4:           date   fruit  name    size replicate weight
9   2017-02-11  orange  mary   small         2   10.1
10  2017-02-11  orange  mary  medium         2   11.1
11  2017-02-11  orange  mary   large         2   12.1}
</code></pre>
</div>
<span class="comment-copy">Are you just looking to extract 3 rows at a time? Also, shouldn't there be a <code>val4</code> in line with your input?</span>
<span class="comment-copy">No I would not like to just extract 3 rows at a time. This example might be organized like that but not all are. Yes val4 should also be in output</span>
<span class="comment-copy">While this technically works, it is strictly based upon the order of the rows in this example and not upon the structure of the dataframe. For example, if I take one row and move it elsewhere, this code no longer works. I will change the example to reflect this....sorry, and thanks for the help!</span>
<span class="comment-copy">Can you specify the <i>specific criteria</i> you use for grouping (e.g. which fields)? It might be helpful if your example was less trivial, at least to help future visitors.</span>
<span class="comment-copy">@Rob, Also, have updated for unordered case under certain assumptions.</span>
<span class="comment-copy">Thanks so much for your effort and patience jpp</span>
