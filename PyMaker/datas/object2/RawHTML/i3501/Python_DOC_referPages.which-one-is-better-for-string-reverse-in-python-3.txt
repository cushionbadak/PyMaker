<div class="post-text" itemprop="text">
<pre><code>s="google"
print("".join(reversed(s)))  //elgoog
print(s[::-1])  //elgoog
</code></pre>
<p>In above the string is reverse using python 3 reversed method and slicing method both display the same output, but from this which one is most efficient in python programming language, why??</p>
</div>
<div class="post-text" itemprop="text">
<p>When you talk about efficiency you should specify from which perspective? Memory, Runtime, Implementation, etc.</p>
<p>Regard the runtime the reverse indexing is definitely faster because when you use <code>join</code> plus <code>reversed</code> you're calling two functions which both has their own deficiencies (suspending and resuming a function's frame, etc.) compare to a simple indexing. But if you want to loop over the character one by one, for any purpose, and the memory is an issue (mostly when the string is large) you can use <code>reversed</code> because it returns an iterator object.</p>
<pre><code>In [2]: s = "example"

In [4]: r = reversed(s)

In [5]: next(r)  # e.g. You can access to the characters using `next()`
Out[5]: 'e'
</code></pre>
<p>So the conclusion is that you should choose the method based on your need and actually this is why there are multiple ways for one particular task in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no significant difference in memory efficiency. Since strings are immutable, both approaches must copy the entire data. </p>
<p>To check performance, you can use the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a> module in standard libraries. Slicing is significantly faster, due to avoiding iteration within Python code:</p>
<pre><code>&gt;&gt;&gt; s = "google"
&gt;&gt;&gt; %timeit "".join(reversed(s))
612 ns ± 20.8 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
&gt;&gt;&gt; %timeit s[::-1]
157 ns ± 3.96 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>
<p>And the runtime improvement is increasing for larger strings:</p>
<pre><code>&gt;&gt;&gt; s = s*1000
&gt;&gt;&gt; %timeit "".join(reversed(s))
119 µs ± 2.37 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
&gt;&gt;&gt; %timeit s[::-1]
10.8 µs ± 123 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p>CPython 3.7.0b4 on macOS.</p>
</div>
<span class="comment-copy"><a href="https://dbader.org/blog/python-reverse-string#info" rel="nofollow noreferrer">Here's</a> a comparison</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/931092/reverse-a-string-in-python">Reverse a string in Python</a></span>
<span class="comment-copy">The suggested dupe target includes the relevant benchmarks in this answer <a href="https://stackoverflow.com/a/27843760/6260170">stackoverflow.com/a/27843760/6260170</a></span>
<span class="comment-copy">"most efficient" - concerning what? Speed? Readability? Space? What's your use case? Is reversal efficiency even relevant there?</span>
<span class="comment-copy">@jpp I believe wim's comment applies <i>after</i> the <code>str.join</code> call</span>
<span class="comment-copy">@jpp <code>reversed</code> does <i>not</i> copy the string, it <i>iterates</i> in reverse. There is never a copy made. In contrast, <code>s[::1]</code> does create a copy. That's why the use case is critical to decide what is most efficient.</span>
<span class="comment-copy">@Chris_Rands, Thank you, this makes more sense. <code>reversed</code>, as an iterator, doesn't copy the entire string. Thanks!</span>
<span class="comment-copy"><code>''.join(...)</code> is not slower because of "calling two functions".  It's slower because of iteration within Python runtime.</span>
<span class="comment-copy">@wim Yes, that too. But using those two functions has its own noticeable overhead as well. Also, note that iterations at either C or Python level both make the program slow (increase the complexity) but what's important is the amount of codes/interpretations that's happening at Python level which in this case creating/interpreting/etc. a function twice has enough overhead to make your code slower.</span>
<span class="comment-copy">Thanks for your advance..</span>
