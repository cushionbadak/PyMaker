<div class="post-text" itemprop="text">
<hr/>
<p><strong>The main process is the following:</strong></p>
<p>One main folder A with B,C,D... subfolders. This main folder has <strong>new</strong> under consideration files.<strong>Most</strong> of the subfolders have shps.</p>
<p>There is one other main folder though. Let's call it K with L,M,N.. subfolders.These subfolders are the corresponding from the other subfolders of the other folder with the <strong>new</strong> files.</p>
<p>The subfolders from <strong>A</strong> have the same names with the ones from <strong>K</strong> although <strong>K</strong> may have more that we don't need.</p>
<p>I want the user to insert the directory of the main <code>A</code> folder and read the first shp from the first subfolder (if it exists an shp there) then go to the other <code>old</code> main folder and check the corresponding subfolder, get the <code>shp</code> from there <em>and do some comparisons between them and print the results</em>(the italics parts i have already solved them)and then continue with the rest of the <code>new</code> folder's subfolders accordingly.If in one subfolder there is not an shp it should print:'folder name' has no shp. and continue with the rest.</p>
<p>How should i do it?</p>
<p>I have tried this code where does some part of it: It stores to a list each shp in every subfolder but from the first main folder. It needs from the two main folders for the comparison to be successful.</p>
<pre><code>import fiona
from pprint import pprint
import os

rootdir = r'C:\Users\user\Desktop\a' # path to the root directory you walk
    sfiles = [] # a list with all the .shp files
    for entry in os.listdir(rootdir):
        dirpath = os.path.join(rootdir, entry)
        if os.path.isdir(dirpath): 
            for file in os.listdir(dirpath): # Get all files in the subdirectories
                if file.endswith('.shp'): # If it's an .shp.
                    filepath = os.path.join(dirpath, file)
                    sfiles.append(fiona.open(filepath))
</code></pre>
<hr/>
<p>When should i add this combination between each shapefiles.schema piece?
if the shapefiles were inserted manually i would do it like this:</p>
<pre><code>pst_n=fiona.open(r'C:\Users\user\Desktop\new\PST')#new pst
pst_o=fiona.open(r'C:\Users\user\Desktop\old\PST')#old_pst
pst_n.schema
d1 = pst_n.schema['properties']
d2 = pst_o.schema['properties']

d1_items = set(d1.items())
d2_items = set(d2.items())
result = sorted([(k, 'd1', v) for k, v in d1_items if (k, v) not in d2_items] +
                [(k, 'd2', v) for k, v in d2_items if (k, v) not in d1_items])

result = [(k, v, d) for k, d, v in result]


pprint(result)
</code></pre>
<p>And shows the differences like that:</p>
<pre><code>[('ADDRESS', 'int:4', 'd1'),
 ('ADDRESS', 'str:254', 'd2'),
 ('AREA', 'float:19.11', 'd2'),
 ('DEC_ID', 'int:4', 'd1'),
 ('DEC_ID', 'str:254', 'd2'),
 ('DESC_', 'str:254', 'd1'),
 ('FID_PERIVL', 'int:9', 'd1'),
 ('KAEK', 'str:50', 'd1'),
 ('KAEK', 'str:12', 'd2'),
 ('LEN', 'float:19.11', 'd2'),
</code></pre>
<p>Now how should i show each combination's differences as it loops?</p>
<p>The files so you can test if it works is here:
<a href="http://www.mediafire.com/file/644y8e12pj9jrei/main_folders.zip" rel="nofollow noreferrer">http://www.mediafire.com/file/644y8e12pj9jrei/main_folders.zip</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can drastically simplify your file collection code by using <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow noreferrer"><code>os.walk()</code></a> to do the collecting; you could use <a href="https://docs.python.org/3/library/fnmatch.html" rel="nofollow noreferrer"><code>fnmatch.filter()</code></a> to filter down the filenames to only <code>*.shp</code> files:</p>
<pre><code>import os
import fnmatch

def new_file_paths(rootdir):
    for dirpath, dirnames, filenames in os.walk(rootdir):
        if dirpath == rootdir: continue. # ignore files in the root
        yield dirpath, [os.path.join(dirpath, fname) for fname in fnmatch.filter(filenames, '*.shp')]
</code></pre>
<p>This is a generator function that yields a list of files <em>per directory</em>, so you can print information per directory to give to your users. â€˜os.walk()` will traverse all subdirectories, at any depth, starting at the root. </p>
<p>If this is an issue, and further nested directories are to be ignored, then using <a href="https://docs.python.org/3/library/glob.html#glob.iglob" rel="nofollow noreferrer"><code>glob.iglob()</code></a> with grouping on the directory name would be simpler:</p>
<pre><code>from glob import iglob
from itertools import groupby

def new_file_paths(rootdir):
    # only .shp files in direct subfolders 
    results = igblob(os.path.join(rootdir, '*', '*.shp'))
    return ((d, list(p)) for d, p in groupby(results, key=os.path.dirname))
</code></pre>
<p>When you loop over the generator object, you can take the <em>relative</em> path name of each file in a directory, and check if there is a corresponding file in the other location:</p>
<pre><code>rootdir_new = r'C:\Users\user\Desktop\a'
rootdir_old = r'C:\Users\user\Desktop\k'

for directory, paths in new_file_paths(rootdir_new)):
    if not paths:
        print('{} is empty, no new files found'.format(directory))
        continue

    for path in paths:
        relative_path = os.path.relpath(path, rootdir_new)
        old_path = os.path.join(rootdir_old, relative_path)
        if not os.path.exists(old_path):
            # no corresponding old file
            print('No matching previous version of {}' 
                  'found, skipping'.format(relative_path))
            continue

        # compare `path` with `old_path`
</code></pre>
<p>As for your comparison code, you can make use of the fact that the <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer"><code>dict.items()</code> <em>dictionary view object</em></a> is a set, so you can use set operations on those directly without having to call <code>set()</code> on them, and sets natively support producing differences. And <code>sorted()</code> can take a <em>key</em> function, so you can sort your results without having to re-arrange your output list:</p>
<pre><code>from operator import itemgetter

d1 = pst_n.schema['properties']
d2 = pst_o.schema['properties']

changed = {'d1': d1.items() - d2.items(), 'd2': d2.items() - d1.items()}
results = sorted(
    ((k, v, d) for d in changed for k, v in changed[d]),
    key=itemgetter(0, 2)) # sort by key, then source. Values will *always* differ.
</code></pre>
</div>
<span class="comment-copy">Ok,that's just an alternative way of doing the already existing first part .Can you answer the actual problem?It looks like you are gonna devise an amazing solution.</span>
<span class="comment-copy">@whwhhw: It's all there now.</span>
<span class="comment-copy">Can you run it?It shows errors to me. first you are closing two parenthesis in the 4th line and if i remove the one it says ths:<code>File "&lt;ipython-input-21-dad72e1da7e6&gt;", line 6     print(f'{directory'}) is empty, no new files found')                        ^ SyntaxError: invalid syntax</code> in the location of <code>}</code> .</span>
<span class="comment-copy">@whwhhw: right, you are using a Python version older than 3.6. I've removed the <code>f'...'</code> string syntax in that case.</span>
<span class="comment-copy">Have you tested it with the files and its ok?What parts should i add if any to work completely?</span>
