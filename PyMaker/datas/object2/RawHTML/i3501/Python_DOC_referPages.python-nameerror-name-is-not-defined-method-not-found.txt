<div class="post-text" itemprop="text">
<p>I'm working from a book, very much newbie stuff, and the code below is from the book, and defines a simple class. But for <em>some reason</em>, the author has decided to put a "helper method" called <code>check_index</code> outside the class. I cannot for the life of me figure out why he would do this, as the method seems integral to teh operation of the class. He writes:</p>
<blockquote>
<p>The index checking is taken care of by a utility function Iâ€™ve written
  for the purpose, check_index.</p>
</blockquote>
<p>I have tried putting it inside the class (the code below is as it is in the book), but the runtime refuses to find the method - it falls over with</p>
<pre><code>NameError: name 'check_index' is not defined
</code></pre>
<p>My questions are, why did the author put this "helper method" outside the class, and why does the code not work when I move the method inside the class:</p>
<pre><code>class ArithmeticSequence:
    def __init__(self, start=0, step=1):
        self.start = start # Store the start value
        self.step = step # Store the step value
        self.changed = {} # No items have been modified      
    def __getitem__(self, key):
        check_index(key)
        try: return self.changed[key] # Modified?
        except KeyError: # otherwise ...
            return self.start + key * self.step # ... calculate the value
    def __setitem__(self, key, value):
        check_index(key)
        self.changed[key] = value # Store the changed value


def check_index(key):
    if not isinstance(key, int): raise TypeError
    if key &lt; 0: raise IndexError
</code></pre>
<p>When I move the method inside the class, I just slot it in with the other methods. But it is not found by the runtime. Why?</p>
<pre><code>class ArithmeticSequence:
    def __init__(self, start=0, step=1):
        self.start = start # Store the start value
        self.step = step # Store the step value
        self.changed = {} # No items have been modified
    def check_index(key):
        if not isinstance(key, int): raise TypeError
        if key &lt; 0: raise IndexError        
    def __getitem__(self, key):
        check_index(key)
        try: return self.changed[key] # Modified?
        except KeyError: # otherwise ...
            return self.start + key * self.step # ... calculate the value
    def __setitem__(self, key, value):
        check_index(key)
        self.changed[key] = value # Store the changed value
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to use <code>self</code></p>
<p><strong>Ex:</strong></p>
<pre><code>class ArithmeticSequence:
    def __init__(self, start=0, step=1):
        self.start = start # Store the start value
        self.step = step # Store the step value
        self.changed = {} # No items have been modified
    def check_index(self, key):
        if not isinstance(key, int): raise TypeError
        if key &lt; 0: raise IndexError        
    def __getitem__(self, key):
        self.check_index(key)
        try: return self.changed[key] # Modified?
        except KeyError: # otherwise ...
            return self.start + key * self.step # ... calculate the value
    def __setitem__(self, key, value):
        self.check_index(key)
        self.changed[key] = value # Store the changed value
</code></pre>
<ul>
<li>And call the function with self Ex: <code>self.check_index</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>def check_index(key)</code> still defines a method of <code>ArithmeticSequence</code>, regardless of what you call the first argument, which means you have to call it like a regular instance method (<code>self.check_index()</code>), and if you want to pass it an argument you have to add it after <code>self</code>. If you want to define a method on the class itself, you can use <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow noreferrer"><code>@staticmethod</code></a> or <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>@classmethod</code></a>:</p>
<pre><code>class Foo:
    @staticmethod
    def bar(key):
        return key

    @classmethod
    def baz(cls, key):
        return key

    def quux(self):
        print(Foo.bar("abcd"), Foo.baz("abcd"))

Foo().quux()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><code>ArithmeticSequence</code> is not a new-style class. Check <a href="https://www.python.org/doc/newstyle/" rel="nofollow noreferrer">this</a></li>
<li>You have 2 options:

<ol>
<li>Add <code>self</code> to <code>check_index</code>. In the class, you will use it as <code>self.check_index(key)</code>. You will need to instantiate an <code>ArithmeticSequence</code> class object.</li>
<li>Add <code>@staticmethod</code> before <code>check_index</code>. You will use it as <code>ArithmeticSequence.check_index(key)</code></li>
</ol></li>
</ol>
</div>
<span class="comment-copy">In your class implementation, each method is <code>instance</code> method. Why there is no <code>self</code> parameter in your `check_index(self, key).</span>
<span class="comment-copy">I tried it with check_error(self,key) - that didn't work either.</span>
<span class="comment-copy">You need to call with <code>self.check_index...</code></span>
<span class="comment-copy">Ah I see, now it works - I hadn't been calling it with self.  Thank you.  As to the other question: why would the author define the method outside the class?  To me it's bordering on ridiculous - the class needs the method; without the method the class doesn't work.</span>
<span class="comment-copy">Would it become a new-style class if it were defined like this:  <code>class ArithmeticSequence(object)</code>?:</span>
<span class="comment-copy">Yes. New-style class is more pythonic, and it enables to use decorator like <code>@staticmethod</code>. @JL_SO</span>
