<div class="post-text" itemprop="text">
<p>I have the following example:</p>
<pre><code>class A:
    value = None
    @property
    def value(self):
        if not value:
            result = &lt;do some external call&gt;
            self.value = result
        return self.value
</code></pre>
<p>However, this is not working since I'm getting the exception:</p>
<pre><code>AttributeError: can't set attribute
</code></pre>
<p>And that makes sense, but what would be the idiomatic way of doing something like this? I don't just want to use different names. </p>
</div>
<div class="post-text" itemprop="text">
<p>You're trying to use <code>self.value</code> as both the name of the property, and the name of the attribute used under the covers to store that property. That doesn't make sense; you need to give it a different name. Since that attribute is meant to be "private", and accessed only through the property, you normally want to use an underscore prefix.</p>
<p>In other words, do exactly the same thing done in the example in <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">the docs for <code>property</code></a>.</p>
<p>And of course that <code>if not value:</code> has to be changed to access the same attribute via <code>self</code>, not some local variable with the same name.</p>
<pre><code>class A:
    _value = None
    @property
    def value(self):
        if not self._value:
            result = &lt;do some external call&gt;
            self._value = result
        return self._value
</code></pre>
<hr/>
<p>Another option is to use a library that does this for you. As pointed out by Martijn Pieters in the comments, <a href="https://pypi.org/project/cached-property/" rel="nofollow noreferrer"><code>cached-property</code></a> gives you exactly what you want. And it's tested and robust in all kinds of edge cases you likely never thought about, like threads and asyncio. And it's also got great documentation, and readable source code, that explains how it works.</p>
<hr/>
<p>Anyway, it may not be immediately obvious why that <code>_value = None</code> is correct.</p>
<p><code>_value = None</code> in the class definition creates a <em>class attribute</em> named <code>_value</code>, shared by all instances of the class.</p>
<p><code>self._value = result</code> in a method body doesn't change that class attribute, it creates an <em>instance attribute</em> with the same name.</p>
<p>Instance attributes <em>shadow</em> class attributes. That is, when you try to access <code>self._value</code> in the <code>if</code> and <code>return</code> statements, that looks for an instance attribute, then falls back to a class attribute if one doesn't exist. So, the class attribute's <code>None</code> value works as a default value for the instance attribute.</p>
<p>For providing default attribute values, this is a pretty common idiom—but it can be confusing in some cases (e.g., with mutable values).</p>
<p>Another way to do the same thing is to just force the instance to always have a <code>_value</code> attribute, by setting it in your <code>__new__</code> or <code>__init__</code> method:</p>
<pre><code>class A:
    def __init__(self):
        self._value = None
    @property
    def value(self):
        if not self._value:
            result = &lt;do some external call&gt;
            self._value = result
        return self._value
</code></pre>
<p>While this is a bit more verbose and complex at first glance (and requires knowing about <code>__init__</code>), it does avoid the potential for confusion about class vs. instance attributes, so if you're sharing your code with novices, it's more likely they'll be able to follow it.</p>
<p>Alternatively, you can use <code>getattr</code> to see whether the attribute exists, so you don't need either a fallback class attribute or an <code>__init__</code>, but this is usually not what you want to do. </p>
<hr/>
<p>Taking a step back, you can even replace <code>property</code> with a descriptor that replaces itself on first lookup—but if you don't know what that means (even after reading the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">HowTo</a>), you probably don't want to do that either.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/4037481/caching-attributes-of-classes-in-python" title="caching attributes of classes in python">stackoverflow.com/questions/4037481/…</a></span>
<span class="comment-copy">This code makes zero sense. Why do you place a <code>value=None</code> as a class variable, only to immediately replace it with a <code>property</code>? You can't set the attribute because you haven't defined a setter. Also, <code>if not value:</code> would throw a <code>NameError</code> since <code>value</code> is not defined, so this code wouldn't reach teh <code>AttributeError</code>.</span>
<span class="comment-copy">@juanpa.arrivillaga I've added some explanation.</span>
<span class="comment-copy">Another option would be to use a descriptor without <code>__set__</code> or <code>__delete__</code> methods, so you can simply set <code>self.__dict__['name'] = value</code> and never invoke the descriptor again on subsequent accesses.</span>
<span class="comment-copy">@MartijnPieters Yeah, but I don't know if I want to try to explain that to someone who's having trouble with the fundamentals, and I don't like giving people magic invocations that they can copy and paste without any hope of understanding and never be able to debug or modify. If you think you can explain it, write a separate answer.</span>
<span class="comment-copy">@abarnert: fair enough; just wanting to put that out there too. Do write for a future audience too, not just the current OP, and then consider if you can make the non-data descriptor option clear enough. Or just point to <a href="https://pypi.org/project/cached-property/" rel="nofollow noreferrer">PyDanny's <code>cached_property</code> project</a> with a short intro.</span>
<span class="comment-copy">@MartijnPieters I didn't know about <code>cached_property</code>; that does seem worth including. But as for writing for a future audience—honestly, I don't think anyone who understands descriptors is going to be looking for anything in this question, and I don't think trying to teach descriptors is doable in the middle of an already-long answer about the basics of using <code>@property</code>, <code>_private</code> attributes, etc. (I think even explaining class vs. instance attributes it pushing it…)</span>
