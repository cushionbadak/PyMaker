<div class="post-text" itemprop="text">
<p>I don't understand what happens when a class is called without parenthesis. My question stems from reading from this <a href="https://docs.python.org/3/howto/logging-cookbook.html" rel="nofollow noreferrer" title="python HOWTO: Logging Cookbook">Python HOWTO: Logging Cookbook</a>. Specifically I'm trying to understand a recipe that I've placed at the end of this question. The purpose of the recipe is to instruct a <code>logging</code> formatter to use UTC time from within a logging configuration dictionary.</p>
<p>A class is defined,</p>
<pre><code>class UTCFormatter(logging.Formatter):
    converter = time.gmtime
</code></pre>
<p>and then later used by name only; without parenthesis.</p>
<pre><code>'formatters': {
            'utc': {
                '()': UTCFormatter,   # &lt;-------------------Class used here
                'format': '%(asctime)s %(message)s',
            },
</code></pre>
<p><strong>What happens here and why is calling the class in this way a benefit over creating an instance of the class? What is this way of doing things called?</strong> That is, what keywords (other than 'class') could I search for that would help me find more information about this in the python documentation?</p>
<p>Full Recipe:</p>
<pre><code>import logging
import logging.config
import time

class UTCFormatter(logging.Formatter):
    converter = time.gmtime

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'utc': {
            '()': UTCFormatter,
            'format': '%(asctime)s %(message)s',
        },
        'local': {
            'format': '%(asctime)s %(message)s',
        }
    },
    'handlers': {
        'console1': {
            'class': 'logging.StreamHandler',
            'formatter': 'utc',
        },
        'console2': {
            'class': 'logging.StreamHandler',
            'formatter': 'local',
        },
    },
    'root': {
        'handlers': ['console1', 'console2'],
   }
}

if __name__ == '__main__':
    logging.config.dictConfig(LOGGING)
    logging.warning('The local time is %s', time.asctime())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using just the name of a class (<code>UTCFormatter</code> in your case) does <em>not</em> instantiate the class. Instead, <code>UTCFormatter</code> is a variable that points to a value of type <code>type</code>:</p>
<pre><code>In [1]: class Foo:
   ...:     pass
   ...: 

In [2]: type(Foo)
Out[2]: type
</code></pre>
<p>That variable can be used to create new instances via <code>UTCFormatter()</code>, but it can also be used like any other variable. In particular, it can be passed to functions and bound to other names. For example, you can do the following:</p>
<pre><code>In [3]: def my_function(some_class):
   ...:     print('Creating an instance of {}'.format(some_class.__name__))
   ...:     return some_class()
   ...: 

In [4]: foo = my_function(Foo)
Creating an instance of Foo

In [5]: foo
Out[5]: &lt;__main__.Foo at 0x7f017451e438&gt;
</code></pre>
<p>This is useful in many situations. In your recipe, you define a formatter once by specifying a class (<code>UTCFormatter</code>) and a name (<code>'utc'</code>). That definition is then re-used when you configure different handlers to use that formatter, e.g.</p>
<pre><code>'console1': {
    'class': 'logging.StreamHandler',
    'formatter': 'utc',
},
</code></pre>
<p>To construct the actual logger hierarchy from your configuration, <code>logging.config.dictConfig</code> doesn't need one instance of <code>UTCFormatter</code> (which it would get if you had passed <code>UTCFormatter()</code> instead) but one for each handler that you configure to use that formatter (two in your case). Passing the class itself instead of an instance allows <code>dictConfig</code> to create new instances as required.</p>
</div>
<span class="comment-copy">So if I'm understanding you correctly, I'm giving logger information about the type of class that I want it to use, and then later it uses that type definition to create instances of that class when it needs to. So this is just helping the logger to do other things under the hood. Is that right?</span>
<span class="comment-copy">Exactly! The class is a recipe, and passing it to a function allows the function to "cook" new instances without hard-coding details about the class in the function itself -- that means the recipe can be changed without changing the function.</span>
