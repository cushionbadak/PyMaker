<div class="post-text" itemprop="text">
<p>I have a comma separated series of integer values that I'd like to resample so that I have twice as many, where a new value is added half way between each of the existing values. For example, if this is my source:</p>
<pre><code>1,5,11,9,13,21
</code></pre>
<p>the result would be:</p>
<pre><code>1,3,5,8,11,10,9,11,13,17,21
</code></pre>
<p>In case that's not clear, I'm trying to add a number between each of the values in my source series, like this:</p>
<pre><code>1   5   11    9    13    21
1 3 5 8 11 10 9 11 13 17 21
</code></pre>
<p>I've searched quite a bit and it seems that something like scipy.signal.resample or panda should work, but I'm completely new at this and I haven't been able to get it working. For example, here's one of my attempts with scipy:</p>
<pre><code>import numpy as np
from scipy import signal
InputFileName = "sample.raw"
DATA250  = np.loadtxt(InputFileName, delimiter=',', dtype=int);
print(DATA250)
DATA500 = signal.resample(DATA250, 11)
print(DATA500)
</code></pre>
<p>Which outputs:</p>
<pre><code>[ 1  5 11  9 13 21]
[ 1.         -0.28829461  6.12324489 10.43251996 10.9108191   9.84503237
  8.40293529 10.7641676  18.44182898 21.68506897 12.68267746]
</code></pre>
<p>Obviously I'm using signal.resample incorrectly. Is there a way I can do this with signal.resample or panda? Should I be using some other method? </p>
<p>Also, in my example all of source numbers have an integer half way in between. In my actual data, that won't be the case. So if two of the number are 10,15, the new number would be 12.5. However I'd like to have all of the resulting numbers be integers. So the new number that gets inserted would need to either be 12 or 13 (it doesn't matter to me which it is).</p>
<p>Note that once I get this working, the source file will actually be a comma separated list of 2,000 numbers and the output should be 4,000 numbers (or technically 3,999 since there won't be one added to the end). Also, this is going to be used to process something similar to an ECG recording- currently the ECG is sampled at 250 Hz for 8 seconds, which is then passed to a separate process to analyze the recording. However that separate process needs the recording to be sampled at 500 Hz. So the workflow will be that I'll take a 250 Hz recording every 8 seconds and upsample it to 500 Hz, then pass the resulting output to the analysis process.</p>
<p>Thanks for any guidance you can provide.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since the interpolation is simple, you can do it by hand:</p>
<pre class="lang-python prettyprint-override"><code>import numpy as np
a = np.array([1,5,11,9,13,21])
b = np.zeros(2*len(a)-1, dtype=np.uint32)
b[0::2] = a
b[1::2] = (a[:-1] + a[1:]) // 2
</code></pre>
<p>You can also use <code>scipy.signal.resample</code> this way:</p>
<pre class="lang-python prettyprint-override"><code>import numpy as np
from scipy import signal
a = np.array([1,5,11,9,13,21])
b = signal.resample(a, len(a) * 2)
b_int = b.astype(int)
</code></pre>
<p>The trick is to have exactly twice the number of elements, so that odd points match your initial points. Also I think that the Fourier interpolation done by <code>scipy.signal.resample</code> is better for your ECG signal than the linear interpolation you're asking for.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you suggested a pandas solution, here is one possibility:</p>
<pre><code>import pandas as pd
import numpy as np

l = [1,4,11,9,14,21]
n = len(l)

df = pd.DataFrame(l, columns = ["l"]).reindex(np.linspace(0, n-1, 2*n-1)).interpolate().astype(int)

print(df)
</code></pre>
<p>It feels unnecessary complicated, though. I tag in pandas, so people more familiar with pandas functionality see it. </p>
</div>
<div class="post-text" itemprop="text">
<p>Although I probably would just use NumPy here, pretty similar to <a href="https://stackoverflow.com/a/50938352/908494">J. Martinot-Lagarde's answer</a>, you don't actually have to.</p>
<hr/>
<p>First, you can read a single row of comma-separated numbers with just the <code>csv</code> module:</p>
<pre><code>with open(path) as f:
    numbers = map(int, next(csv.reader(f))
</code></pre>
<p>… or just string operations:</p>
<pre><code>with open(path) as f:
    numbers = map(int, next(f).split(','))
</code></pre>
<hr/>
<p>And then you can interpolate that easily:</p>
<pre><code>def interpolate(numbers):
    last = None
    for number in numbers:
        if last is not None:
            yield (last+number)//2
        yield number
        last=number
</code></pre>
<p>If you want it to be fully general and reusable, just take a <code>function</code> argument and <code>yield function(last, number)</code>, and replace <code>None</code> with <code>sentinel = object()</code>.</p>
<hr/>
<p>And now, all you need to do is <code>join</code> the results and <code>write</code> them:</p>
<pre><code>with open(outpath, 'w') as f:
    f.write(','.join(map(str, interpolate(numbers))))
</code></pre>
<hr/>
<p>Are there any advantages to this solution? Well, other than the read/split and join/write, it's purely lazy. And we can write lazy split and join functions pretty easily (or just do it manually). So if you ever had to deal with a billion comma-separated numbers instead of a thousand, that's all you'd have to change.</p>
<p>Here's a lazy <code>split</code>:</p>
<pre><code>def isplit(s, sep):
    start = 0
    while True:
        nextpos = s.find(sep, start)
        if nextpos == -1:
            yield s[start:]
            return
        yield s[start:nextpos]
        start=nextpos+1
</code></pre>
<p>And you can use an <a href="https://docs.python.org/3/library/mmap.html" rel="nofollow noreferrer"><code>mmap</code></a> as a lazily-read string (well, <code>bytes</code>, but our data are pure ASCII, so that's fine):</p>
<pre><code>with open(path, 'rb') as f:
    with mmap.mmap(inf.fileno(), 0, access=mmap.ACCESS_READ) as mm:
        numbers = map(int, isplit(mm, b','))
</code></pre>
<p>And let's use a different solution for lazy writing, just for variety:</p>
<pre><code>def icsvwrite(f, seq, sep=','):
    first = next(seq, None)
    if not first: return
    f.write(first)
    for value in seq:
        f.write(sep)
        f.write(value)
</code></pre>
<p>So, putting it all together:</p>
<pre><code>with open(inpath, 'rb') as inf, open(outpath, 'w') as outf:
    with mmap.mmap(inf.fileno(), 0, access=mmap.ACCESS_READ) as mm:
        numbers = map(int, isplit(mm, b','))
        icsvwrite(outf, map(str, interpolate(numbers)))
</code></pre>
<hr/>
<p>But, even though I was able to slap this together pretty quickly, and all of the pieces are nicely reusable, I'd <em>still</em> probably use NumPy for your specific problem. You're not going to read a row of a billion numbers. You already have NumPy installed on the only machine that's ever going to run this script. The cost of importing it every 8 seconds (which you can solve by just having the script sleep between runs). So, it's hard to beat an elegant 3-line solution.</p>
</div>
<span class="comment-copy">Are you just reading these in and then writing them out without any processing besides the interpolation? If so, it might be simpler to not use <code>numpy</code> in the first place. Just do a loop over the values, remembering the last value. Then, each time, <code>if last is not None:</code> write <code>(last + value) // 2</code>, then write <code>value</code> and set <code>last = value</code>. If that's easier for you to understand and to code up, who cares if it's a bit less theoretically elegant?</span>
<span class="comment-copy">Thanks, I updated the description to indicate that all I'm doing is reading in the string in and then taking the output and passing it to a different process for further analysis.</span>
<span class="comment-copy">Thanks, this is great. I think I'm going to use the scipy.signal.resample - you're right it does seem to produce a smoother curve, although there is some fluctuation at the beginning and end of each graph. Regardless, this will work great.</span>
<span class="comment-copy"><code>scipy.signal.resample</code> supposes that the signal is periodic, so it tries to "match" the beginning and the end of the data. Look at the example in the documentation, it's pretty clear: <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.resample.html" rel="nofollow noreferrer">docs.scipy.org/doc/scipy/reference/generated/…</a></span>
<span class="comment-copy">Thanks for the pandas example. I agree with your comment- this is probably more complicated than just crunching the math, which is what I ended up going with.</span>
<span class="comment-copy">Wow, thanks for the detailed information! I ended up going with a different solution, but this is something I can play around with to learn more about python.</span>
