<div class="post-text" itemprop="text">
<p>I have a Dataframe, df, with the following column:</p>
<pre><code>df['ArrivalDate'] =
...
936   2012-12-31
938   2012-12-29
965   2012-12-31
966   2012-12-31
967   2012-12-31
968   2012-12-31
969   2012-12-31
970   2012-12-29
971   2012-12-31
972   2012-12-29
973   2012-12-29
...
</code></pre>
<p>The elements of the column are pandas.tslib.Timestamp.</p>
<p>I want to just include the year and month.  I thought there would be simple way to do it, but I can't figure it out.</p>
<p>Here's what I've tried:</p>
<pre><code>df['ArrivalDate'].resample('M', how = 'mean')
</code></pre>
<p>I got the following error:</p>
<pre><code>Only valid with DatetimeIndex or PeriodIndex 
</code></pre>
<p>Then I tried:</p>
<pre><code>df['ArrivalDate'].apply(lambda(x):x[:-2])
</code></pre>
<p>I got the following error:</p>
<pre><code>'Timestamp' object has no attribute '__getitem__' 
</code></pre>
<p>Any suggestions?</p>
<p>Edit: I sort of figured it out.  </p>
<pre><code>df.index = df['ArrivalDate']
</code></pre>
<p>Then, I can resample another column using the index.</p>
<p>But I'd still like a method for reconfiguring the entire column.  Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can directly access the <code>year</code> and <code>month</code> attributes, or request a <code>datetime.datetime</code>:</p>
<pre><code>In [15]: t = pandas.tslib.Timestamp.now()

In [16]: t
Out[16]: Timestamp('2014-08-05 14:49:39.643701', tz=None)

In [17]: t.to_pydatetime() #datetime method is deprecated
Out[17]: datetime.datetime(2014, 8, 5, 14, 49, 39, 643701)

In [18]: t.day
Out[18]: 5

In [19]: t.month
Out[19]: 8

In [20]: t.year
Out[20]: 2014
</code></pre>
<p>One way to combine year and month is to make an integer encoding them, such as: <code>201408</code> for August, 2014. Along a whole column, you could do this as:</p>
<pre><code>df['YearMonth'] = df['ArrivalDate'].map(lambda x: 100*x.year + x.month)
</code></pre>
<p>or many variants thereof.</p>
<p>I'm not a big fan of doing this, though, since it makes date alignment and arithmetic painful later and especially painful for others who come upon your code or data without this same convention. A better way is to choose a day-of-month convention, such as final non-US-holiday weekday, or first day, etc., and leave the data in a date/time format with the chosen date convention.</p>
<p>The <code>calendar</code> module is useful for obtaining the number value of certain days such as the final weekday. Then you could do something like:</p>
<pre><code>import calendar
import datetime
df['AdjustedDateToEndOfMonth'] = df['ArrivalDate'].map(
    lambda x: datetime.datetime(
        x.year,
        x.month,
        max(calendar.monthcalendar(x.year, x.month)[-1][:5])
    )
)
</code></pre>
<p>If you happen to be looking for a way to solve the simpler problem of just formatting the datetime column into some stringified representation, for that you can just make use of the <a href="http://strftime.org/" rel="noreferrer"><code>strftime</code></a> function from the <code>datetime.datetime</code> class, like this:</p>
<pre><code>In [5]: df
Out[5]: 
            date_time
0 2014-10-17 22:00:03

In [6]: df.date_time
Out[6]: 
0   2014-10-17 22:00:03
Name: date_time, dtype: datetime64[ns]

In [7]: df.date_time.map(lambda x: x.strftime('%Y-%m-%d'))
Out[7]: 
0    2014-10-17
Name: date_time, dtype: object
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want new columns showing year and month separately you can do this:</p>
<pre><code>df['year'] = pd.DatetimeIndex(df['ArrivalDate']).year
df['month'] = pd.DatetimeIndex(df['ArrivalDate']).month
</code></pre>
<p>or...</p>
<pre><code>df['year'] = df['ArrivalDate'].dt.year
df['month'] = df['ArrivalDate'].dt.month
</code></pre>
<p>Then you can combine them or work with them just as they are.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Best way found</strong>!!</p>
<p>the <code>date_column</code> has to be in date time format.</p>
<pre><code>df['month_year'] = df.date_column.dt.to_period('M')
</code></pre>
<p>You could also use <code>D</code> for Day, <code>2M</code> for 2 Months etc. for different sampling intervals, and in case one has time series data with time stamp, we can go for granular sampling intervals such as <code>45Min</code> for 45 min, <code>15Min</code> for 15 min sampling etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want the month year unique pair, using apply is pretty sleek.</p>
<pre><code>    df['mnth_yr'] = df['date_column'].apply(lambda x: x.strftime('%B-%Y'))     
</code></pre>
<p>outputs month-year in one column.</p>
<p>don't forget to first change the format to date-time before, I generally forget :|</p>
<pre><code>    df['date_column'] = pd.to_datetime(df['date_column'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Extracting the Year say from ['2018-03-04']  </p>
<pre><code>df['Year'] = pd.DatetimeIndex(df['date']).year  
</code></pre>
<p>The df['Year'] creates a new column. While if you want to extract the month just use .month  </p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to <a href="https://stackoverflow.com/a/39206377/1982951">jaknap32</a>, I wanted to aggregate the results according to Year and Month, so this worked:</p>
<pre><code>df_join['YearMonth'] = df_join['timestamp'].apply(lambda x:x.strftime('%Y%m'))
</code></pre>
<p>Output was neat:</p>
<pre><code>0    201108
1    201108
2    201108
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/25149272/9209546">@KieranPC's solution</a> is the correct approach for Pandas, but is not easily extendible for arbitrary attributes. For this, you can use <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr</code></a> within a generator comprehension and combine using <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.concat.html" rel="nofollow noreferrer"><code>pd.concat</code></a>:</p>
<pre><code>list_of_dates = ['2012-12-31', '2012-12-29', '2012-12-30']
df = pd.DataFrame({'ArrivalDate': pd.to_datetime(list_of_dates)})

L = ['year', 'month', 'day', 'dayofweek', 'dayofyear', 'weekofyear', 'quarter']
df = df.join(pd.concat((getattr(df['ArrivalDate'].dt, i).rename(i) for i in L), axis=1))

print(df)

  ArrivalDate  year  month  day  dayofweek  dayofyear  weekofyear  quarter
0  2012-12-31  2012     12   31          0        366           1        4
1  2012-12-29  2012     12   29          5        364          52        4
2  2012-12-30  2012     12   30          6        365          52        4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can first convert your date strings with <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.to_datetime.html" rel="nofollow noreferrer">pandas.to_datetime</a>, which gives you access to all of the <a href="https://docs.scipy.org/doc/numpy-dev/reference/arrays.datetime.html" rel="nofollow noreferrer">numpy datetime and timedelta</a> facilities. For example:</p>
<pre><code>df['ArrivalDate'] = pandas.to_datetime(df['ArrivalDate'])
df['Month'] = df['ArrivalDate'].values.astype('datetime64[M]')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>df['year_month']=df.datetime_column.apply(lambda x: str(x)[:7])
</code></pre>
<p>This worked fine for me, didn't think pandas would interpret the resultant string date as date, but when i did the plot, it knew very well my agenda and the string year_month where ordered properly... gotta love pandas!</p>
</div>
<span class="comment-copy">the best answer is clearly.. df['mnth_yr'] = df.date_column.dt.to_period('M') as below from @jaknap32</span>
<span class="comment-copy">You don't even have to do <code>to_period</code>: <code>df.date_column.dt.month</code> (or <code>.year</code>, or <code>.day</code>) works</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/30405413/python-pandas-extract-year-from-datetime-dfyear-dfdate-year-is-not">python pandas extract year from datetime --- df['year'] = df['date'].year is not working</a></span>
<span class="comment-copy">@elphz: <code>.dt.month</code> loses the year though. And <code>.dt.to_period('M')</code> changes the data type to something which is not a datetime64 anymore. I ended up using <a href="https://stackoverflow.com/a/43561379/1026">Juan's answer</a> suggesting <code>.astype('datetime64[M]')</code> to truncate the values.</span>
<span class="comment-copy">Performance can be bad, so it's always good to make the best possible use of helper functions, vectorized operations, and <code>pandas</code> split-apply-combine techniques. My suggestions above aren't meant to be taken as an endorsement that they are the most performant approaches for your case -- just that they are stylistically valid Pythonic choices for a range of cases.</span>
<span class="comment-copy">the best answer is clearly.. df['mnth_yr'] = df.date_column.dt.to_period('M') as below from @jaknap32</span>
<span class="comment-copy">You're supposed to multiply by 100 in <code>df['YearMonth'] = df['ArrivalDate'].map(lambda x: 1000*x.year + x.month)</code>.</span>
<span class="comment-copy">@GitGud Thanks for catching that typo. I updated it with the fix.</span>
<span class="comment-copy">@zthomas.nc I think they function better as two separate answers, since they offer two very different ways to solve it.</span>
<span class="comment-copy">Is there a way to do this in a single line ? I want to avoid traversing the same column multiple times.</span>
<span class="comment-copy">Some quick benchmarking with <code>timeit</code> suggests that the <code>DatetimeIndex</code> approach is significantly faster than either <code>.map/.apply</code> or <code>.dt</code>.</span>
<span class="comment-copy">the best answer is clearly.. df['mnth_yr'] = df.date_column.dt.to_period('M') as below from @jaknap32</span>
<span class="comment-copy">what actually does pd.Datetimeindex do?</span>
<span class="comment-copy">I sometimes do this:  <code>df['date_column_trunc'] = df[date_column'].apply(lambda s: datetime.date(s.year, s.month, 1)</code></span>
<span class="comment-copy">Certainly the best answer ..</span>
<span class="comment-copy">Best answer. OP can you consider marking this one as the accepted answer?</span>
<span class="comment-copy">Note that the resulting column is not of the <code>datetime64</code> dtype anymore. Using <code>df.my_date_column.astype('datetime64[M]')</code>, as in <a href="https://stackoverflow.com/a/43561379/1026">@Juan's answer</a> converts to dates representing the first day of each month.</span>
<span class="comment-copy">Thanks, It has been really helpful  date_1 = pd.DatetimeIndex(df['date'])  --year = date_1.year # For years-- --month =  date_1.month # For months-- --dy =  date_1.day # For days--</span>
