<div class="post-text" itemprop="text">
<p>If I import an external module twice in different pybind11::scoped_interpreter sessions, the application crashes in eval.h in function eval at following line:</p>
<pre><code>PyObject *result = PyRun_String(buffer.c_str(), start, global.ptr(), local.ptr());
</code></pre>
<p>with</p>
<pre><code>Exception thrown at 0x00007FFD710C4E0C (multiarray.cp36-win_amd64.pyd) in pybind-test.exe: 0xC0000005: Access violation writing location 0x000000000000000A.
</code></pre>
<h2>Reproducible example code</h2>
<pre><code>namespace py = pybind11;
void test() {
    try {
        py::scoped_interpreter guard{};
        py::object mainScope = py::module::import("__main__").attr("__dict__");
        py::exec(
            "import numpy\n",
            mainScope);
    }
    catch (py::error_already_set const &amp;pythonErr) {  std::cout &lt;&lt; pythonErr.what(); }
}
int main() {
    test();   // Runs fine
    test();   // Crashes at py::exec
}
</code></pre>
<p>I feel like this has to do with the comment in pybind11's embed.h:</p>
<blockquote>
<p>The interpreter can be restarted by calling <code>initialize_interpreter</code> again. Modules created using pybind11 can be safely re-initialized. However, Python itself cannot completely unload binary extension modules and there are several caveats with regard to interpreter restarting. All the details can be found in the CPython documentation. In short, not all interpreter memory may be freed, either due to reference cycles or user-created global data.</p>
</blockquote>
<p>So there is no way to call the Python interpreter twice? I have a python file containing helper numpy functions that I need to call at different points of algorithm execution from C++. Does this mean I can't do that? </p>
</div>
<div class="post-text" itemprop="text">
<p>Paraphrasing from the discussion at <a href="https://github.com/pybind/pybind11/issues/1439" rel="nofollow noreferrer">pybind11 github repo.</a></p>
<p>Instead of using <code>py::scoped_interpreter</code> use <code>py::initialize_interpreter</code> and <code>py::finalize_interpreter</code>. Call the interpreter in between as many times as you like.</p>
<p>Caveat:, “the Python interpreter is not fully thread-safe In order to support multi-threaded Python programs, there’s a global lock, called the global interpreter lock or <a href="https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock" rel="nofollow noreferrer">GIL</a>“.</p>
<p>Example usage:</p>
<pre><code>namespace py = pybind11;
void test() {
    try {
        py::object mainScope = py::module::import("__main__").attr("__dict__");
        py::exec(
            "import numpy\n",
            mainScope);
    }
    catch (py::error_already_set const &amp;pythonErr) {  std::cout &lt;&lt; pythonErr.what(); }
}
int main() {
   py::initialize_interpreter();
    test();  
    test();   
    py::finalize_interpreter();
}
</code></pre>
</div>
