<div class="post-text" itemprop="text">
<p>I'm automating some repository operations and I'm using <a href="https://gitpython.readthedocs.io/en/stable/index.html" rel="nofollow noreferrer">GitPython</a> for this job. Let's simplify things and assume I'd like to assert whether my function called <code>pull</code> method on the repository. Code below:</p>
<pre><code>from pytest_mock import MockFixture
from git import Git, Repo

repo = Repo('/Users/Jatimir/path/to/repo')

def pull() -&gt; None:
    repo.git.pull()
</code></pre>
<p>However, I noticed that <code>Git</code> class is somewhat special and doesn't implement <code>pull</code>. Instead, it "delegates" all the traffic to <code>__getattr__</code> which uses another method that does the job.</p>
<pre><code>def __getattr__(self, name):
    ...
    return lambda *args, **kwargs: self._call_process(name, *args, **kwargs)
</code></pre>
<p>My question is how to approach testing this? I'm using <a href="https://docs.pytest.org/en/latest/" rel="nofollow noreferrer">pytest</a> with <a href="https://github.com/pytest-dev/pytest-mock" rel="nofollow noreferrer">pytest-mock</a> that provides a <code>mocker</code> fixture and here are my attempts:</p>
<pre><code>def test_pull1(mocker: MockFixture) -&gt; None:
    pull_mock = mocker.MagicMock(name='pull')
    getattr_mock = mocker.MagicMock(name='__getattr__', return_value=pull_mock)

    mocker.patch.object(Git, '__getattr__', getattr_mock)
    pull()
    pull_mock.assert_called_once_with()


def test_pull2(mocker: MockFixture) -&gt; None:
    pull_mock = mocker.Mock(name='pull')

    def __getattr__(self, name):
        if name == 'pull':
            return pull_mock

    mocker.patch.object(Git, '__getattr__', __getattr__)
    pull()
    pull_mock.assert_called_once_with()
</code></pre>
<p>They both work, but I feel like there is a better way and maybe my approach to testing this is wrong.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to <a href="https://stackoverflow.com/users/3001761/jonrsharpe">jonrsharpe</a> who instructed me to use <code>create</code> argument I managed to achieve what I wanted with the following code:</p>
<pre><code>def test_pull(mocker: MockFixture) -&gt; None:
    m = mocker.patch.object(Git, 'pull', create=True)
    pull()
    m.assert_called_once_with()
</code></pre>
<p>Excerpt from the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer">documentation</a> explaining what <code>create=True</code> does:</p>
<blockquote>
<p>By default patch() will fail to replace attributes that don’t exist. If you pass in create=True, and the attribute doesn’t exist, patch will create the attribute for you when the patched function is called, and delete it again afterwards.</p>
</blockquote>
</div>
<span class="comment-copy">The fact that <code>Git</code> uses <code>__getattr__</code> is an <i>implementation detail</i>; just mock the <code>pull</code> method as if they implemented it the normal way.</span>
<span class="comment-copy">@jonrsharpe That's the first thing I tried and I was getting <code>AttributeError: &lt;class 'git.cmd.Git'&gt; does not have the attribute 'pull'</code> :/ with <code>patch.object</code>, but thanks to your comment I tried to manually assign a Mock to Git.pull and it worked. Thanks.</span>
<span class="comment-copy">You have to pass <code>create=True</code> to get the patch methods to replace attributes that don't exist.</span>
<span class="comment-copy">@jonrsharpe Wow :D that's such a simple solution, it works perfectly. It's great that I can use <code>patch.object</code> instead of my dirty solutions. You can add it as an answer, so I can accept it (:</span>
