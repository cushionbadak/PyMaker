<div class="post-text" itemprop="text">
<p>I trying to creat a list <code>new_list</code> from other lists <code>a,b,c,d</code> and been searching for a while now and this is what i have come up with</p>
<pre><code>a = [1] 
b = ['b1','b2','b3',...] 
c = ['c1','c2','c3',...] 
d = ['d1','d2','d3',...] 
count = 0 
output =[] 
for item in [b,c,d]:     
     output.append(item[0])
     count += 1
new_list = list(a + output) 
print (a1)'

output : [1, 'b1', 'c1', 'd1']
</code></pre>
<p>It prints what i want it to, but my problem is that i can´t get to continue...
I need to keep it printing the next and next <code>new_list</code> untill list <code>b,c,d</code> runs out of elements. </p>
<pre><code>wanted output:
[1, 'b1', 'c1', 'd1']
[1, 'b2', 'c2', 'd2']
[1, 'b3', 'c3', 'd3']
[..... and so on....]
</code></pre>
<p>i have tried nested loop, <code>count</code> in <code>item[0]</code> and extracting every element but this is the closest i have come and could really use some help or directions. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import copy

a = [1] 
b = ['b1','b2','b3'] 
c = ['c1','c2','c3'] 
d = ['d1','d2','d3']

lists = [b,c,d]

for x in range(len(lists[0])):
    temp_list = copy.deepcopy(a)
    print(temp_list + [this_list[x] for this_list in lists])

&gt;&gt;[1, 'b1', 'c1', 'd1']
  [1, 'b2', 'c2', 'd2']
  [1, 'b3', 'c3', 'd3']
</code></pre>
<p>Here you go my friend!</p>
<p>We assume that the length of every list is equal to the total number of the lists (without a)</p>
<blockquote>
<p>This will work for any number of lists with any length</p>
</blockquote>
<pre><code>import copy

a = [1] 
b = ['b1','b2','b3'] 
c = ['c1','c2','c3'] 
d = ['d1','d2','d3']
e = ['e1', 'e2', 'e3', 'e4', 'e5', 'e6']
f = ['f1', 'f2', 'f3', 'f4']

lists = [b,c,d,e,f]
lengths = [len(x) for x in lists]
max_len = max(lengths)

rotated_array = []
for x in range(max_len):
    temp_list = copy.deepcopy(a)
    for l in lists:
        try:
            temp_list.append(l[x])
        except IndexError:
            pass
    rotated_array.append(temp_list)

for row in rotated_array:
    print(row)


&gt;&gt;[1, 'b1', 'c1', 'd1', 'e1', 'f1']
  [1, 'b2', 'c2', 'd2', 'e2', 'f2']
  [1, 'b3', 'c3', 'd3', 'e3', 'f3']
  [1, 'e4', 'f4']
  [1, 'e5']
  [1, 'e6']
</code></pre>
<blockquote>
<p>Same code with explanations</p>
</blockquote>
<pre><code># copy module import to use deepcopy. (explanation on usage bellow)
import copy

# initialize lists to work with
a = [1] 
b = ['b1','b2','b3'] 
c = ['c1','c2','c3'] 
d = ['d1','d2','d3']
e = ['e1', 'e2', 'e3', 'e4', 'e5', 'e6']
f = ['f1', 'f2', 'f3', 'f4']

# a list of all lists. It is easier to work with - and iterate.
lists = [b,c,d,e,f]

# a list with the lengths of the other lists. should be: [3, 3, 3, 6, 4]
lengths = [len(x) for x in lists]

# max number of the list above - this is the max length of all lists
max_len = max(lengths)

# now we are going to loop all lists for the length of the longest one.
# looping through a smaller list will cause an IndexError because it will run out of items.
# ex. looping 6 times to list b. First 3 items are ok. There is no fourth. - so b[3] (which is fourth item) will cause IndexError

# initialize an empty list - a list of lists will be an array
rotated_array = []

# iterate for max loops
for x in range(max_len):

    # use deepcopy instead of : temp_list = a , it is a matter of memory and pointers. Deepcopy allocates new space in memory and the temp_list will have its own.
    temp_list = copy.deepcopy(a)

    # now for every list a,b,c,d... we will take the (x)th item and append it in the temp list
    for l in lists:
        try:

            #  temp list is simply [1] at the beginning (deepcopy). Next loop :[1, 'b1'], Next : [1, 'b1', 'c1']
            temp_list.append(l[x])

        # more simple: if the list that we try to take its item does not have this item (when trying to take by number -index)
        except IndexError:

            # pass will just not do anything and continue to the next loop
            pass

    # append temp_list in rotated list. first its empty :[], Next loop a single row is appended: [[1, 'b1', 'c1', 'd1', 'e1', 'f1']], Next: [[1, 'b1', 'c1', 'd1', 'e1', 'f1'], [1, 'b2', 'c2', 'd2', 'e2', 'f2']]
    rotated_array.append(temp_list)

# print the array - printing row after row will cause the effect af an array looking like the ones we are used to
for row in rotated_array:
    print(row)



&gt;&gt;[1, 'b1', 'c1', 'd1', 'e1', 'f1']
  [1, 'b2', 'c2', 'd2', 'e2', 'f2']
  [1, 'b3', 'c3', 'd3', 'e3', 'f3']
  [1, 'e4', 'f4']
  [1, 'e5']
  [1, 'e6']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>itertools.repeat()</code> for the first list (actually, iteratble), and then <code>zip()</code> all your iterables.</p>
<pre><code>&gt;&gt;&gt; zip(itertools.repeat(1), b, c, d)
[(1, 'b1', 'c1', 'd1'), (1, 'b2', 'c2', 'd2'), (1, 'b3', 'c3', 'd3')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming <code>b,c,d</code> are of the same length, you can zip the elements (extending <code>a</code> to the required length first):</p>
<pre><code>a = [1] 
b = ['b1','b2','b3'] 
c = ['c1','c2','c3']
d = ['d1','d2','d3'] 

a2 = a*len(b)

result = [list(x) for x in zip(a2,b,c,d)]

print(result)
&gt;&gt;&gt;[[1, 'b1', 'c1', 'd1'], [1, 'b2', 'c2', 'd2'], [1, 'b3', 'c3', 'd3']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>zip_longest</code></a> with <code>fillvalue</code> handling empty values in one list:</p>
<pre><code>from itertools import zip_longest

a = [1] 
b = ['b1','b2','b3'] 
c = ['c1','c2','c3'] 
d = ['d1','d2','d3']

print(list(zip_longest(a, b, c, d, fillvalue=a[0])))

# [(1, 'b1', 'c1', 'd1'), (1, 'b2', 'c2', 'd2'), (1, 'b3', 'c3', 'd3')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The other answers result in lists of tuples. If you want a list of lists, I would suggest doing a list comprehension:</p>
<pre><code>result = [ [a[0], b_i, c_i, d_i] for b_i, c_i, d_i in zip(b, c, d) ]
</code></pre>
</div>
<span class="comment-copy"><code>list(zip(a*len(b),b,c,d))</code></span>
<span class="comment-copy">Thanks!!! For now all my lenghts are the same, but what if there not in the future? I´m just woundering because you write "assume that the length of every list is equal" as if it´s posible to match upp the lists content even tough there not the same lenght, is that possbile or do i always need the same lenght on the lists?</span>
<span class="comment-copy">whenever you do a list comp without changing anything just use <code>list()</code></span>
<span class="comment-copy">Thank you, put it in a for loop and now works! Need to learn itertools! :)</span>
