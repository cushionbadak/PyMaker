<div class="post-text" itemprop="text">
<p>I have just started learning Python and one thing is bugging me is the exact type of <code>"__main__"</code>. So far, I have seen that <code>"__main__"</code> is mostly used as string literal like <code>__name__ == "__main__"</code>.<br/>
I mean, it is not a function, it is not a variable. With all the other built-in variables and functions starting with __ it is just confusing. Any special reason it has to start with __? I know it has special meaning in the context of modules and namespaces, but I am talking purely in the terms of basic/primitive data types.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, <code>"__main__"</code> is a string literal, since module names are strings. The module is called <code>__main__</code> to distinguish it from modules named <code>main</code>, and since it is a system-assigned name.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it's just a string. The fact that it has two underscores is because it's a "special name". Special names in Python have these two leading and trailing underscores.</p>
<p>What it actually represents is also explained in the <a href="https://docs.python.org/3/library/__main__.html" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<h2>29.4. <code>__main__</code> — Top-level script environment</h2>
<p><code>'__main__'</code> is the name of the scope in which top-level code executes. A module’s <code>__name__</code> is set equal to <code>'__main__'</code> when read from standard input, a script, or from an interactive prompt.</p>
<p>A module can discover whether or not it is running in the main scope by checking its own <code>__name__</code>, which allows a common idiom for conditionally executing code in a module when it is run as a script or with <code>python -m</code> but not when it is imported:</p>
<pre><code>if __name__ == "__main__":
     # execute only if run as a script
     main()
</code></pre>
<p>For a package, the same effect can be achieved by including a <code>__main__.py</code> module, the contents of which will be executed when the module is run with <code>-m</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it is a string literal. Like magic methods like <code>__init__</code> start and end with 2 underscores in order not to be mixed with other methods,  <code>__main__</code> has such naming not to be mixed with names of existing files.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it's just a string literal that by design looks a bit like the names of some special methods in Python.</p>
<p>There is a bit more information in the docs: <a href="https://docs.python.org/3/library/__main__.html" rel="nofollow noreferrer">https://docs.python.org/3/library/<strong>main</strong>.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You are right <code>__main__</code> is a string literal.  <code>__name__</code> is just a variable (commonally called a dunder alias).</p>
<p>Here are two easy ways to prove this:</p>
<p><strong>Using <code>type()</code>:</strong></p>
<pre><code>&gt;&gt;&gt; type(__name__)
&lt;class 'str'&gt;
&gt;&gt;&gt;
</code></pre>
<p>This should be enough but you can also overwrite the value of <code>__name__</code> for example (you shouldn't however):</p>
<pre><code>&gt;&gt;&gt; __name__ = 'hello'
&gt;&gt;&gt; __name__
'hello'
&gt;&gt;&gt;
</code></pre>
<p>My answer <a href="https://stackoverflow.com/questions/419163/what-does-if-name-main-do/49637838#49637838">here expains what it is</a>.</p>
<blockquote>
<p><code>__name__</code> is a DunderAlias - can be thought of as a global variable (accessible from modules) and works in a similar way to global.
  It is a string (global as mentioned above) as indicated by <code>type(__name__)</code> (<code>yielding &lt;class 'str'&gt;</code>), and is an inbuilt standard for both Python 3 and Python 2 versions.</p>
</blockquote>
</div>
<span class="comment-copy">Just to answer the question in the title: Yes, it's just a string literal.</span>
<span class="comment-copy">That may be nitpicking but <code>__main__</code> is in fact an existing module, just try <code>import __main__</code> :)</span>
<span class="comment-copy">@MSeifert You are right, thanks :) Removed "modules" from my answer.</span>
<span class="comment-copy">Thanks for that tip, after importing <code>__main__</code> I can access existing variables using dot notation like <code>__main__.varname</code>. That clears a ton of confusion.</span>
<span class="comment-copy">BTW, here is some discussion on <code>import __main__</code>: <a href="https://stackoverflow.com/questions/24023601/is-it-good-practice-to-use-import-main" title="is it good practice to use import main">stackoverflow.com/questions/24023601/…</a>. There are several points on why such imports can be bad.</span>
