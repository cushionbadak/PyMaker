<div class="post-text" itemprop="text">
<p>In the msvcrt.getch() method, when I enter any value that isn't in the ascii table, I get '\xe0' all the time. I don't know what this means</p>
<pre><code>&gt;&gt;&gt;import msvcrt
&gt;&gt;&gt;up_arrow = msvcrt.getch()
&gt;&gt;&gt; # this is where I have inputed the up arrow
&gt;&gt;&gt;print up_arrow
'\xe0'
&gt;&gt;&gt;down_arrow = msvcrt.getch()
&gt;&gt;&gt;
&gt;&gt;&gt;print down_arrow
'\xe0'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is explained in <a href="https://docs.python.org/3/library/msvcrt.html#msvcrt.getch" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>If the pressed key was a special function key, this will return '\000' or '\xe0'; the next call will return the keycode.</p>
</blockquote>
<p>Under the covers, as you can see from <a href="https://github.com/python/cpython/blob/master/PC/msvcrtmodule.c#L227" rel="nofollow noreferrer">the source</a>, Python is just calling the MSVCRT function <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/getch-getwch" rel="nofollow noreferrer"><code>_getch</code></a>, which is sort of like the POSIX function <a href="http://pubs.opengroup.org/onlinepubs/7908799/xcurses/getch.html" rel="nofollow noreferrer"><code>getch</code></a>, but different in one key way:</p>
<blockquote>
<p>When reading a function key or an arrow key, each function must be called twice; the first call returns 0 or 0xE0, and the second call returns the actual key code.</p>
</blockquote>
<p>The historical reason for this goes back to DOS compatibility in Windows NT 3.x (or, rather, Turbo C for DOS compatibility in Microsoft C++ for Windows NT). </p>
<p>IIRC (and I've probably got a few of the details wrongâ€¦), the basic idea was this: You'd make a BIOS call to get hi and lo values for the keyboard, meaning every key had a 16-bit value. Turbo C, to make things easier, provided a nice call that would map keys to their character in the current (8-bit) codepage, so <code>a</code> would give you back a single byte, <code>0x61</code>. But there wasn't enough room to map everything, so special keys like <code>VK_UP</code> would be returned unmapped, across two separate calls, first the hi byte <code>0xE0</code> and then the lo byte <code>0x50</code>. Microsoft copied that from Borland to make it easier to port code to their compiler, and then to port code from DOS/Win3.1 to NT, and so that's what MSVCRT still does today, and Python is just wrapping the function that does that.</p>
<p><a href="https://stackoverflow.com/a/2877857/908494">This answer</a> gives some more details.</p>
<p>Of course on most Unix terminals, the up arrow also send a sequence of characters, usually the same as the cursor-up display control sequence for that character, typically <code>ESC</code>, then <code>[</code>, then <code>A</code>. But people don't expect a single-character <code>getch</code>-like function to return a single value for every key on Unix, so nobody gets confused.</p>
</div>
