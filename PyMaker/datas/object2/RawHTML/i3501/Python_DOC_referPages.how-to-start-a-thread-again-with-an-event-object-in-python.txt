<div class="post-text" itemprop="text">
<p>I want to make a thread and control it with an event object. Detailedly speaking, I want the thread to be executed whenever the event object is set and to wait itselt, repeatedly.</p>
<p>The below shows a sketchy logic I thought of.</p>
<pre><code>import threading
import time

e = threading.Event()

def start_operation():
    e.wait()

    while e.is_set():
        print('STARTING TASK')

        e.clear()



t1 = threading.Thread(target=start_operation)
t1.start()

e.set()    # first set
e.set()    # second set
</code></pre>
<p>I expected <code>t1</code> to run once <code>the first set</code> has been commanded and to stop itself(due to <code>e.clear</code> inside it), and then to run again after <code>the second set</code> has been commanded. So, accordign to what I expected, it should print out 'STARTING TASK' two times. But it shows it only once, which I don't understand why. How am I supposed to change the code to make it run the <code>while loop</code> again, whenever the event object is set?</p>
</div>
<div class="post-text" itemprop="text">
<p>The first problem is that once you exit a <code>while</code> loop, you've exited it. Changing the predicate back won't change anything. Forget about events for a second and just look at this code:</p>
<pre><code>i = 0
while i == 0:
    i = 1
</code></pre>
<p>It obviously doesn't matter if you set <code>i = 0</code> again later, right? You've already left the while loop, and the whole function. And your code is doing exactly the same thing.</p>
<p>You can fix problem that by just adding another <code>while</code> loop around the whole thing:</p>
<pre><code>def start_operation():
    while True:
        e.wait()

        while e.is_set():
            print('STARTING TASK')

            e.clear()
</code></pre>
<p>However, that still isn't going to work—except maybe occasionally, by accident.</p>
<p><code>Event.set</code> doesn't block; it just sets the event immediately, even if it's already set. So, the most likely flow of control here is:</p>
<ul>
<li>background thread hits <code>e.wait()</code> and blocks.</li>
<li>main thread hits <code>e.set()</code> and sets event.</li>
<li>main thread hits <code>e.set()</code> and sets event again, with no effect.</li>
<li>background thread wakes up, does the loop once, calls <code>e.clear()</code> at the end.</li>
<li>background thread waits forever on <code>e.wait()</code>.</li>
</ul>
<p>(The fact that there's no way to avoid missed signals with events is effectively the reason conditions were invented, and that anything newer than Win32 and Python doesn't bother with events… But a condition isn't sufficient here either.)</p>
<hr/>
<p>If you want the main thread to block until the event is clear, and only then set it again, you can't do that. You need something extra, like a second event, which the main thread can wait on and the background thread can set.</p>
<hr/>
<p>But if you want to keep track of multiple <code>set</code> calls, without missing any, you need to use a different sync mechanism. A <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer"><code>queue.Queue</code></a> may be overkill here, but it's dead simple to do in Python, so let's just use that. Of course you don't actually have any values to put on the queue, but that's OK; you can just stick a dummy value there:</p>
<pre><code>import queue
import threading

q = queue.Queue()

def start_operation():
    while True:
        _ = q.get()
        print('STARTING TASK')

t1 = threading.Thread(target=start_operation)
t1.start()

q.put(None)
q.put(None)
</code></pre>
<p>And if you later want to add a way to shut down the background thread, just change it to stick values on:</p>
<pre><code>import queue
import threading

q = queue.Queue()

def start_operation():
    while True:
        if q.get():
            return
        print('STARTING TASK')    

t1 = threading.Thread(target=start_operation)
t1.start()

q.put(False)
q.put(False)
q.put(True)
</code></pre>
</div>
<span class="comment-copy">Once you exit a <code>while</code> loop, you've exited it; changing the predicate back won't change anything. To make that work, you'd need another <code>while</code> loop, maybe a <code>while True:</code>, around the whole thing (including the <code>e.wait()</code>).</span>
<span class="comment-copy">Thank you for your detailed answer! I have learened a lot from you and I appreciate it!</span>
