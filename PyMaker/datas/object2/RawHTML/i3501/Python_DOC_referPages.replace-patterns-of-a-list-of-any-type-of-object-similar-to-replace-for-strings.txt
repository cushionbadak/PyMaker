<div class="post-text" itemprop="text">
<p>With a string you can replace substrings of length greater than 1. For example, <code>'abcabc'.replace('abca','*')</code> yields <code>'*bc'</code>. </p>
<p>I would like to do this with a list. For example, something like this:</p>
<pre class="lang-python prettyprint-override"><code>[1, [0], 'a', 1, [0], 'a'].replace([1, [0], 'a', 1], [5])
</code></pre>
<p>should yield</p>
<pre class="lang-python prettyprint-override"><code>[5, [0], 'a']
</code></pre>
<p>Note that <a href="https://stackoverflow.com/questions/2582138/finding-and-replacing-elements-in-a-list-python">this question</a> is not a duplicate because they do not need to match patterns but only specific items of the list.</p>
</div>
<div class="post-text" itemprop="text">
<p>a solution that works, replaces the sub-list in-place by using slice assignment:</p>
<pre><code>def replace_list(lst,sublst,replacement):
    lensub = len(sublst)
    i = 0
    while i &lt;= len(lst)-lensub:
        if lst[i:i+lensub] == sublst:
            lst[i:i+lensub] = replacement
            i += len(replacement)
        else:
            i += 1

lst = [1, [0], 'a', 1, [0], 'a']
replace_list(lst,[1, [0], 'a', 1], [5])
</code></pre>
<p>now <code>lst</code> is:</p>
<pre><code>[5, [0], 'a']
</code></pre>
<p>more complex input (to test end condition &amp; multiple replacements)</p>
<pre><code>lst = [1, [0], 'a', 1, 1, [0], 'a', 1, [0], 'a',1, [0], 'a', 1]
</code></pre>
<p>yields once replaced:</p>
<pre><code>[5, 5, [0], 'a', 5]
</code></pre>
<p>how it works:</p>
<ul>
<li>loop to slice the list to replace into to the exact size of the sub-list (use while because list changes if replaced into</li>
<li>if there's a match, use slice assignment to replace the slice by the replacement &amp; increase counter to avoid overlapping replacements</li>
</ul>
<p>I'm not too happy about the constant list slicing, but it's needed here to perform equality with the other list, and creating an inner loop would be more cumbersome and not necessarily faster.</p>
<p>If you don't want to work in-place, you could create a copy at start,work on the copy and return it:</p>
<pre><code>def replace_list(lst_,sublst,replacement):
   lst = lst_.copy()
   ...
   return lst
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">ast.literal_eval</a> then you can use the same string <code>.replace</code>:</p>
<pre><code>&gt;&gt;&gt; from ast import literal_eval
&gt;&gt;&gt; li=[1, [0], 'a', 1, [0], 'a']
&gt;&gt;&gt; literal_eval(repr(li).replace("1, [0], 'a', 1", '5'))
[5, [0], 'a']
</code></pre>
<p>As pointed out in comments, you can also use <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">json</a> to do a similar thing:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; json.loads(json.dumps(li).replace('1, [0], "a", 1','5'))
[5, [0], 'a']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>with recursion, maybe it is not a good solution but it works</p>
<pre><code>lst = [1, [0], 'a', 1, 1, [0], 'a', 1, [0], 'a',1, [0], 'a', 1]
rep = [1, [0], 'a', 1]

numb = 5

def rep_lst(lst, sub, repl):
    for i, x in enumerate(lst):
        if x == repl[0] and lst[i:i+len(repl)] == repl:
            lst = rep_lst(lst[:i] + [sub] +  lst[i+len(repl):], sub, repl)

    return lst

print(rep_lst(lst, numb, rep))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[5, 5, [0], 'a', 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following solution is a bit far-fetched, but it goes from the following assumption:</p>
<blockquote>
<p>The method <code>str.replace</code> is fast, very fast. Why not convert the list to something that can use it.</p>
</blockquote>
<p>First we need to write a helper that will allow to get a hash for mutable elements in the list.</p>
<pre><code>def make_hashable(item):
    """Convert an item to its hashable counterpart"""
    try:
        hash(item)
        return item
    except TypeError:
        if isinstance(item, (list, tuple)):
            return tuple(make_hashable(x) for x in item)
        elif isinstance(item, set):
            return frozenset(make_hashable(x) for x in item)
        elif isinstance(item, dict):
            return frozenset((k, make_hashable(v)) for k, v in item.items())
        raise
</code></pre>
<p>We can now write translation dictionaries for conversion to a string representation in O(n) and use <code>str.replace</code>. </p>
<pre><code>from itertools import count, chain

def list_replace(lst, sublst, repl):
    counter = count(1)
    item_to_char, char_to_item = {}, {chr(0): repl}
    lst_chars, sublst_chars = [], []

    # Create the str representation for lst
    for item in lst:
        item = make_hashable(item)
        if item in item_to_char:
            c = item_to_char[item]
        else:
            c = chr(next(counter))
            item_to_char[item] = c
            char_to_item[c] = [item]
        lst_chars.append(c)

    # Create the str representation for sublst
    for item in sublst:
        item = make_hashable(item)
        if item in item_to_char:
            c = item_to_char[item]
        else:
            return lst
        sublst_chars.append(c)

    lst_string = ''.join(lst_chars)
    sublst_string = ''.join(sublst_chars)

    # use str.replace
    lst_string = lst_string.replace(sublst_string, chr(0))

    # Convert back to a list
    return list(chain(*map(char_to_item.get, lst_string)))
</code></pre>
<h3>Example</h3>
<pre><code>print(list_replace([1, [2], 3], [1, [2]], [6]))  # [6, 3]
</code></pre>
</div>
<span class="comment-copy">what approach did you take and where is your problem?</span>
<span class="comment-copy"><code>[5, [0], 'a']</code> or <code>[[5], [0], 'a']</code></span>
<span class="comment-copy">@scharette <code>[5, [0], 'a']</code>. I put <code>[5]</code> in the <code>replace</code> because I would want <code>[5, 5]</code> as the second argument to return <code>[5, 5, [0], 'a']</code>.</span>
<span class="comment-copy">I think JSON is a better way to do this hack than repr/eval. Sure, this way handles a few more types, but it's less predictable and reliable. For example, after <code>li.append(li)</code>, do you want a nice exception about circular references, or do you want the last element silently converted to a list containing the Ellipsis object?</span>
<span class="comment-copy">@abarnert: Great observation. Edit made.</span>
<span class="comment-copy">@abarnert Are you sure, there is a case when Ellipsis is accepted in <code>ast.literal_eval</code>? From the <a href="https://docs.python.org/3.6/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">documentation</a>: "The string or node provided may only consist of the following Python literal structures: strings, numbers, tuples, lists, dicts, booleans, and None." I'm getting <code>ValueError: malformed node or string: &lt;_ast.Ellipsis object at 0x7f81e9c75cc0&gt;</code> when trying to do what described in your comment.</span>
<span class="comment-copy">@Jatimir I just picked that example off the top of my head without checking it. If it doesn't demonstrate the problem, make the list 2000 deep instead of infinitely deep. <code>json.loads(json.dumps(lst))</code> will work, while <code>ast.literal_eval(repr(lst))</code> will segfault with a stack overflow or, if you're lucky, raise a <code>MemoryError</code>. Or just throw in, say, a <code>datetime</code> object, and JSON will raise at <code>dumps</code> time, while <code>repr</code> will only raise at <code>literal_eval</code> time, which is harder to debug, The point is, <code>repr</code> isn't meant to be a persistence format; JSON is.</span>
<span class="comment-copy">@abarnert that explains much more, thank you.</span>
