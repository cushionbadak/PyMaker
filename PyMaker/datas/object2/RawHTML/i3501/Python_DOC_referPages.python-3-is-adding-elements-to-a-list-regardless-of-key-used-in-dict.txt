<div class="post-text" itemprop="text">
<p>I have a dict that I defined with:</p>
<pre><code>keys = ['Valid', 'Reverse']
NOC = dict.fromkeys(keys, [])
</code></pre>
<p>I then iterate through a file and based on elements in the rows I add them to different lists in that dict based on a value in the row</p>
<p>This is code inside the list comprehension looping through the reader content:</p>
<pre><code>if item[0] == '4':
    if float(item[10]) &lt; 0:
        state = 'Reverse'
        print(state)
        NOC[state].append(item[6]+"FOOOO")
    if float(item[10]) &gt;= 0:
        state = 'Valid'
        print(state)
        NOC[state].append(item[6])

    print (NOC['Reverse'])
</code></pre>
<p>As you can see, I am adding the string "FOOOO" in the case of 'Reverse". I did this to see what was happening inside of the lists in the dict.</p>
<p>I have validated that the if-then statements are all working correctly.</p>
<p>However, the appends seem to be writing to the same place in memory. It's strange. Here is some output of the list comprehension looping through the file content:</p>
<pre><code>Valid
['68382011714']
Valid
['68382011714', '69315013701']
Valid
['68382011714', '69315013701', '16729018201']
Valid
['68382011714', '69315013701', '16729018201', '54458098010']
Valid
['68382011714', '69315013701', '16729018201', '54458098010', '61570007301']
Valid
['68382011714', '69315013701', '16729018201', '54458098010', '61570007301', '61570007301']
Reverse
['68382011714', '69315013701', '16729018201', '54458098010', '61570007301', '61570007301', '61570007301FOOOO']
</code></pre>
<p>It makes no sense to me that print(NOC['Reverse']) is showing values that have anything other than those with the appended "FOOOO". Why is this happening?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're creating only a single list with:</p>
<pre><code>NOC = dict.fromkeys(keys, [])
</code></pre>
<p>which gets assigned to every key of <code>NOC</code>. Since the keys point to the same list, whatever key you use you'll get the same list back, hence you'll be modifying the same list. You can easily test that with:</p>
<pre><code>assert NOC["Valid"] is not NOC["Reverse"], "It's the same list!"
</code></pre>
<p>Instead of doing that, make sure each key gets its own list as:</p>
<pre><code>NOC = {k: [] for k in keys}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is because the value for both the keys has same reference, when you create a dictionary from keys using <code>NOC = dict.fromkeys(keys, [])</code></p>
<pre><code>&gt;&gt;&gt; keys = ['Valid', 'Reverse']
&gt;&gt;&gt; NOC = dict.fromkeys(keys, [])
&gt;&gt;&gt; NOC
{'Valid': [], 'Reverse': []}
&gt;&gt;&gt; id(NOC['Valid'])
50173312
&gt;&gt;&gt; id(NOC['Reverse'])
50173312
</code></pre>
<p>If you can see here both keys has reference to the same list. So when you are appending it is getting appended to the same list. So, I would prefer you to do something like this to create dictionary in order to avoid the above problem.</p>
<pre><code>&gt;&gt;&gt; keys = ['Valid', 'Reverse']
&gt;&gt;&gt; NOC = dict.fromkeys(keys, [])
&gt;&gt;&gt; for key in NOC.keys():
...     NOC[key] = []
...
&gt;&gt;&gt; NOC
{'Valid': [], 'Reverse': []}
&gt;&gt;&gt; id(NOC['Valid'])
50173312
&gt;&gt;&gt; id(NOC['Reverse'])
11515384
</code></pre>
<p>Now the append works perfect.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the provided value is a mutable object (whose value can be modified) like list, dictionary, etc., when the mutable object is modified, each element of the sequence also gets updated.</p>
<p>This is because, each element is assigned a reference to the same object (points to the same object in the memory). you must be use dictionary comprehension <code>
keys = ['Valid', 'Reverse']
NOC = { key: [] for key in keys }</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here the problem is that all values point to the same list. An efficient and Pythonic solution would be to use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>.</p>
<pre><code>from collections import defaultdict
NOC = defaultdict(list)
</code></pre>
<p>Hope it satisfies your requirements.</p>
</div>
<span class="comment-copy">I love Python because the answers are often so easy. Thank you for helping. I spent two hours on this and never once considered that I was creating a single list because of how I was creating the variables. Thank you, thank you, thank you.</span>
<span class="comment-copy">I wish I could mark all answers correct - but thank you so much Krushi</span>
<span class="comment-copy">I wish I could mark all answers correct - but thank you so much Iro</span>
