<div class="post-text" itemprop="text">
<p>I've created the following little HTTP server for learning purposes:</p>
<pre><code>import SimpleHTTPServer
import SocketServer

class ServerHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):

    def do_GET(self):
        print(self.headers)
        SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self)

    def do_POST(self):
        print(self.headers)
        form = cgi.FieldStorage(
            fp=self.rfile,
            headers=self.headers,
            environ={'REQUEST_METHOD':'POST',
                 'CONTENT_TYPE':self.headers['Content-Type'],

def main():
    port = 50738
    Handler = ServerHandler(1000)
    httpd = SocketServer.TCPServer(("192.168.X.Y", port), Handler)

    print "serving at port", port
    httpd.serve_forever()


if __name__ == "__main__":
    main()
</code></pre>
<p>My assumptions are as follows:</p>
<ul>
<li>My class 'ServerHandler' extends the SimpleHTTPServer.SimpleHTTPRequestHandler class by two functions namely go_GET and do_POST</li>
<li>The main() function creates a server handler object and server socket bound to my I.P. address and port of choice, and invokes a function to serve/listen indefinitely. </li>
</ul>
<p><strong>Aside</strong>: I know by looking at the Python DOCs <a href="https://docs.python.org/2/library/simplehttpserver.html" rel="nofollow noreferrer">https://docs.python.org/2/library/simplehttpserver.html</a> that SimpleHTTPServer.SimpleHTTPRequestHandler has a method  called do_GET, which I assume gets overridden by the do_GET in my ServerHandler class?</p>
<p><strong>Question</strong>:
What is going on under the hood relating to do_GET and do_POST? Is it the case that once we have this server listening for HTTP "activity" directed towards a specific IP:PORT that it automatically know if an incoming signal is a GET or POST and as soon as one is encountered the server calls my do_GET or do_POST functions?    </p>
</div>
<div class="post-text" itemprop="text">
<p>When you call <code>SocketServer.TCPServer</code>, you assign your <code>Handler</code> class as the class to receive incoming requests.</p>
<p>All that the <code>SimpleHTTPServer</code> module has helped you with is providing the basic HTTP functionality, but you could write all of that yourself.</p>
<p>So, as you say, when you define <code>Handler</code>, you are inheriting all the methods from the <code>SimpleHTTPRequestHandler</code> class, but then overriding two of the pre-defined methods: <code>do_GET</code> and <code>do_POST</code>. You could also override any other methods in the class.</p>
<p>However, these <code>do_*</code> methods would <em>never</em> be called if it wasn't for the <code>handle</code> method defined in the <code>SimpleHTTPRequestHandler</code> as it is this function which <em>is</em> called by the <code>socketserver</code> module.</p>
<p>So if you were to just inherit the <code>socketserver.BaseRequestHandler</code>, you would loose all functionality as this class' <code>handle()</code> method does nothing:</p>
<blockquote>
<p><strong><code>class socketserver.BaseRequestHandler</code></strong></p>
<p>...</p>
<p><code>handle()</code></p>
<blockquote>
<p>This function must do all the work required to service a
    request. The default implementation does nothing. Several instance
    attributes are available to it; the request is available as
    self.request; the client address as self.client_address; and the
    server instance as self.server, in case it needs access to per-server
    information.</p>
</blockquote>
<p>...</p>
</blockquote>
<p>So, by importing the <code>SimpleHTTPRequestHandler</code> from the <code>SimpleHTTPServer</code> module, you immediately get the basic functionality for a HTTP server.</p>
<p>All this functionality is documented <a href="https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler" rel="nofollow noreferrer">here</a>, with an important bit on its <code>handle</code> method:</p>
<blockquote>
<p><strong><code>class http.server.BaseHTTPRequestHandler(request, client_address, server)</code></strong></p>
<p>...</p>
<p><code>handle()</code></p>
<blockquote>
<p>Calls handle_one_request() once (or, if persistent
    connections are enabled, multiple times) to handle incoming HTTP
    requests. You should never need to override it; instead, implement
    appropriate do_*() methods.</p>
</blockquote>
<p><code>handle_one_request()</code> </p>
<blockquote>
<p><strong>This method will parse and dispatch the request
    to the appropriate do_*() method.</strong> You should never need to override
    it.</p>
</blockquote>
<p>...</p>
</blockquote>
<p>So finally, after breaking down how the <code>socketserver.TCPServer</code> will call the <code>handle()</code> method for <em>whatever</em> class you pass it, we see how the <code>SimpleHTTPRequestHandler</code> implements this as passing the request onto the appropriate <code>do_GET</code>, <code>do_POST</code> or whatever method depending on the headers of the request.</p>
<hr/>
<p>If you want to see how you could implement this yourself, take a look at the source code, either in <code>/usr/lib/pythonX.Y/http/server.py</code> or on <a href="https://github.com/python/cpython/blob/master/Lib/http/server.py" rel="nofollow noreferrer">GitHub</a>.</p>
<p>We can see there what their that <code>SimpleHTTPServer</code> inherits <code>BaseHTTPServer</code> which is where the <code>handle()</code> and <code>handle_one_request()</code> methods are defined:</p>
<p>So, as the docs describe, <code>handle</code> just passes requests to <code>handle_one_request</code> until the connection closes:</p>
<pre><code>def handle(self):
    """Handle multiple requests if necessary."""
    self.close_connection = True

    self.handle_one_request()
    while not self.close_connection:
        self.handle_one_request()
</code></pre>
<p>and the <code>handle_one_request</code> is where the <code>do_*</code> methods get called:</p>
<pre><code>def handle_one_request(self):
    """Handle a single HTTP request.
    You normally don't need to override this method; see the class
    __doc__ string for information on how to handle specific HTTP
    commands such as GET and POST.
    """
    try:
        self.raw_requestline = self.rfile.readline(65537)
        if len(self.raw_requestline) &gt; 65536:
            self.requestline = ''
            self.request_version = ''
            self.command = ''
            self.send_error(HTTPStatus.REQUEST_URI_TOO_LONG)
            return
        if not self.raw_requestline:
            self.close_connection = True
            return
        if not self.parse_request():
            # An error code has been sent, just exit
            return
        mname = 'do_' + self.command   ## the name of the method is created
        if not hasattr(self, mname):   ## checking that we have that method defined
            self.send_error(
                HTTPStatus.NOT_IMPLEMENTED,
                "Unsupported method (%r)" % self.command)
            return
        method = getattr(self, mname)  ## getting that method
        method()                       ## finally calling it
        self.wfile.flush() #actually send the response if not already done.
    except socket.timeout as e:
        #a read or a write timed out.  Discard this connection
        self.log_error("Request timed out: %r", e)
        self.close_connection = True
        return
</code></pre>
<p><em>(note, I double-hashed (<code>##</code>) my comments to seperate them from the original author's)</em></p>
</div>
<span class="comment-copy">@ Joe lddon - Thank you, that is a fantastic answer. I understand now. Unfortunately my user rating is not enough to up-vote this answer. Thanks again</span>
