<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/17576009/python-class-property-use-setter-but-evade-getter">Python class @property: use setter but evade getter?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<pre><code>class My_Class:
    def __init__(self):
        self._x = 0

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, x):
        self._x = x
</code></pre>
<p>If I delete the following getter from the code above:</p>
<pre><code>@property
def x(self):
    return self._x
</code></pre>
<p>The code stops working. How can I create a setter without a getter?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>property</code> function does not have to be used as a decorator:decorator can be used as a function:</p>
<pre><code>class My_Class:
    def _set_x(self, value):
        self._x = value

    x = property(fset=_set_x)  # now value has only a setter

    del _set_x  # optional: delete the unneeded setter function

instance = My_Class()
instance.x= 8  # the setter works

print(instance._x) # the "private" value

print(instance.x) # raises: AttributeError: unreadable attribute
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class My_Class:
    def __init__(self):
        self._x = 0

    @property
    def x(self):
        raise RuntimeError('This property has no getter!')

    @x.setter
    def x(self, x):
        self._x = x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an alternative answer to what I already offered: make your own write-only <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor</a>.</p>
<pre><code>class WriteOnly:
    def __init__(self, private_name):
        self.private_name = private_name

    def __set__(self, obj, value):
        obj.__dict__[self.private_name] = value

    def __get__(self, obj, type=None):
        raise AttributeError('unreadable attribute')


class My_Class:
    x = WriteOnly('_x')

instance = My_Class()
instance.x = 8  # the setter works

print(instance._x) # the "private" value

print(instance.x) # raises: AttributeError: unreadable attribute
</code></pre>
</div>
<span class="comment-copy">Can you explain the usage? Perhaps there's an alternative approach</span>
<span class="comment-copy">why <code>del _set_value</code>??</span>
<span class="comment-copy">@juanpa.arrivillaga That is the standard cookbook how <code>property</code> was used before <code>@decorator</code> syntax was introduced. It deletes the method before it even becomes a method. It is optional, as the comment says, if you want not to have <code>X._set_value</code> (or <code>X._set_x</code> after I modified the variable names in the answer to fit the question).</span>
