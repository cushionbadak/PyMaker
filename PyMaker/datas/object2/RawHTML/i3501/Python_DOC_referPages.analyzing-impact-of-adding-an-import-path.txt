<div class="post-text" itemprop="text">
<p>I have the following directory structure:</p>
<pre><code>TestFolder:
    test.py
CommonFolder:
    common.py
</code></pre>
<p>And in <code>test.py</code>, I need to import <code>common.py</code>.</p>
<p>In order to do that, in <code>test.py</code> I add the path of <code>CommonFolder</code> to the system paths.</p>
<p>Here is what I started off with:</p>
<pre><code>sys.path.append(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'CommonFolder'))
</code></pre>
<p>Then I figured that <code>/</code> is a valid separator in pretty much every OS, so I changed it to:</p>
<pre><code>sys.path.append(os.path.dirname(os.path.dirname(__file__)) + '/CommonFolder')
</code></pre>
<p>Then I figured that <code>..</code> is also a valid syntax in pretty much every OS, so I changed it to:</p>
<pre><code>sys.path.append(os.path.dirname(__file__) + '/../CommonFolder')
</code></pre>
<p>My questions:</p>
<ol>
<li>Are my assumptions above correct, and will the code run correctly on every OS?</li>
<li>In my last change, I essentially add a slightly longer path to the system paths. More precisely - <code>FullPath/TestFolder/../CommonFolder</code> instead of <code>FullPath/CommonFolder</code>. Is the any runtime impact to this? I suppose that every <code>import</code> statement might be executed slightly slower, but even if so, that would be minor. Is there any good reason not to do it this way?</li>
</ol>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're writing code to span multiple Operating Systems it's best not to try to construct the paths yourself.  Between Linux and Windows you immediately run into the forward vs backwards slash issue, just as an example.</p>
<p>I'd recommend looking into the Python <code>pathlib</code> library.  It handles generating paths for different operating systems.</p>
<p><a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer">https://docs.python.org/3/library/pathlib.html</a></p>
<p>This is a great blog about this subject and how to use the library:
<a href="https://medium.com/@ageitgey/python-3-quick-tip-the-easy-way-to-deal-with-file-paths-on-windows-mac-and-linux-11a072b58d5f" rel="nofollow noreferrer">https://medium.com/@ageitgey/python-3-quick-tip-the-easy-way-to-deal-with-file-paths-on-windows-mac-and-linux-11a072b58d5f</a></p>
<p><strong>UPDATE:</strong></p>
<p>Updating this with a more specific answer.</p>
<p>Regarding the directory paths, as long as you're not building the paths yourself (using a utility such as pathlib) the paths you've created should be fine.  Linux, Mac, and <a href="https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths" rel="nofollow noreferrer">Windows</a> all support relative paths (both mac and linux are <a href="https://unix.stackexchange.com/a/4097">Unix ~based</a> of course).</p>
<p>As for whether it's efficient, unless you're frequently dynamically loading or reloading your source files (which is not common) most files are <a href="https://docs.python.org/3/reference/import.html#regular-packages" rel="nofollow noreferrer">loaded into memory</a> before the code is run, so there would be no performance impact on setting up the file paths in this way.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>os.path.join()</code> for OS independent path separator instead of <code>/</code> </p>
<p>Example: <code>os.path.join(os.path.dirname(__file__),"..","CommonFolder")</code></p>
<p>Or instead you can make CommonFolder as python package by just placing a empty file by name <code>__init__.py</code> inside CommonFolder. After that you can simply <code>import common</code> in <code>test.py</code> as:-</p>
<pre><code>from CommonFolder import common
</code></pre>
</div>
<span class="comment-copy">Thanks, but you didn't quite refer specifically to any of my questions. Also, forward slash works on both Windows and Linux, so I don't think there's any problem with that (at least not with regards to these specific operating systems).</span>
<span class="comment-copy">Hm, I think I see what you mean.  So, really your question is "are relative paths safe and efficient on all Operating Systems?"  Is that right?</span>
<span class="comment-copy">You kinda combined the two questions into one, but yes, thank you.</span>
<span class="comment-copy">Yeah, as far as I know performance isn't an issue because the files are loaded into memory before they're run, and as long as you're not building the paths yourself then they are safe.</span>
<span class="comment-copy">Ok, expanded the answer to include a bit more info about this in order to try to answer your questions more directly.</span>
<span class="comment-copy">I used it, didn't you read the question?</span>
<span class="comment-copy">And it doesn't help to make <code>CommonFolder</code> a package, because it doesn't reside alongside the test file, but in an "uncle" folder.</span>
<span class="comment-copy">@goodvibration, in your question, you started with correct code using <code>os.path.join()</code>, but you ended up using <code>/</code> instead of os.path.join(), which is os dependent.</span>
<span class="comment-copy">Yes, so why do provide an example which I have already stated explicitly? Also, I asked if there could be any cross-platform problems with it, and you gave an answer which AFAIK is wrong, since forward slash works fine on Windows.</span>
