<div class="post-text" itemprop="text">
<p>I'm trying to experiment a bit with python asyncio to improve in that area, for self teaching purposes I'm trying to connect to redis, send some commands and read the response, this can fall under generic "read a stream of data from some source". The problem I cannot solve is how to read data in chunks, since the connection is not being closed between server and client and the termination sequence <code>\r\n</code> could be met more than once. If I await when there is no more data of course the call will block until something else will be received.</p>
<pre><code>class Client:
    def __init__(self, loop, host='127.0.0.1', port=6379):
        self.host = host
        self.port = port
        self.reader = None
        self.writer = None
        self.loop = loop

    @asyncio.coroutine
    def _connect(self):
        self.reader, self.writer = yield from asyncio.open_connection(
            self.host, self.port, loop=self.loop)

    async def read(self, b=4096):
        resp = b''
        while True:
            chunk = await self.reader.read(b)
            if chunk:
                resp += chunk
            else:
                break
        return resp
</code></pre>
<p>Let's pretend I want to read the response in chunks of 2 bytes (yes is stupid but it's just for this learning purpose) so:</p>
<pre><code>loop = asyncio.get_event_loop()
client = Client(loop)
..... sends some commands here ....
resp = await client.read(2)
</code></pre>
<p>I cannot figure out how while not knowing the length of the server response the code can still be safe when the response is longer than the bytes read from the socket.</p>
</div>
<div class="post-text" itemprop="text">
<p>I encountered a similar problem recently. My solution was to continue reading until a given character (or set of characters) is read. This is the same philosophy behind people saying "over" on walkie talkies when they are done talking. It is easier to just wait for the response to say that it is done talking. </p>
<p>While I haven't worked with the asyncio module before, I believe that the following code should solve your problem, assuming that the source of the input ends the response with whatever character (or string of characters) is indicated in the variable <code>end_signal</code>.</p>
<pre><code>class Client:
    def __init__(self, loop, host='127.0.0.1', port=6379):
        self.host = host
        self.port = port
        self.reader = None
        self.writer = None
        self.loop = loop

    @asyncio.coroutine
    def _connect(self):
        self.reader, self.writer = yield from asyncio.open_connection(
            self.host, self.port, loop=self.loop)

    async def read(self, b=4096, end_signal = "10101101110111110"):
        resp = b''
        while True:
            chunk = await self.reader.read(b)
            resp += chunk
            if resp[-1*len(end_signal):] == end_signal:
                break
        return resp
</code></pre>
</div>
<span class="comment-copy">Related: <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader.readuntil" rel="nofollow noreferrer">reader.readuntil</a></span>
<span class="comment-copy">readuntil seems to do the job but still does not fit the case where one wants complete control over the size of the chunks</span>
<span class="comment-copy">Change the termination sequence to something you'll only use when you terminate.</span>
<span class="comment-copy">I cannot change the way a server responds to me</span>
<span class="comment-copy">How can the termination sequence be present more than once within the response? Isn't the definition of a <i>termination sequence</i> something that terminates the response? Can you show how you would implement what you need with ordinary, blocking sockets?</span>
<span class="comment-copy">Code? This isn't really an answer yet, although it has the potential to possibly be one.</span>
<span class="comment-copy">The problem and hence my question is how to avoid blocking if the termination sequence is not known or like in redis it can be present multiple time within the response</span>
<span class="comment-copy">Isn't this code a reimplementation of <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader.readuntil" rel="nofollow noreferrer"><code>StreamReader.readuntil</code></a>?</span>
<span class="comment-copy">No, that's the right way of doing it. readuntil will read until sequence is found, that means if the response is <code>$6\r\nabcdef\r\n</code> it will truncate the response while checking if the chunk ends with what you expect will give the desired result</span>
