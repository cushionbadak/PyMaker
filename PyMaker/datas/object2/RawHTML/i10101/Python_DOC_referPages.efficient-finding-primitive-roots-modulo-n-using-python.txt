<div class="post-text" itemprop="text">
<p>I'm using the following code for finding <a href="https://en.wikipedia.org/wiki/Primitive_root_modulo_n" rel="nofollow">primitive roots</a> modulo <code>n</code> in <strong>Python</strong>:</p>
<p><strong>Code:</strong></p>
<pre><code>def gcd(a,b):
    while b != 0:
        a, b = b, a % b
    return a

def primRoots(modulo):
    roots = []
    required_set = set(num for num in range (1, modulo) if gcd(num, modulo) == 1)

    for g in range(1, modulo):
        actual_set = set(pow(g, powers) % modulo for powers in range (1, modulo))
        if required_set == actual_set:
            roots.append(g)           
    return roots

if __name__ == "__main__":
    p = 17
    primitive_roots = primRoots(p)
    print(primitive_roots)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>[3, 5, 6, 7, 10, 11, 12, 14]   
</code></pre>
<p><em>Code fragment extracted from:</em> <a href="https://github.com/masterrr/cryptography/blob/master/Diffie-Hellman/main.py" rel="nofollow"><em>Diffie-Hellman (Github)</em></a></p>
<hr/>
<p>Can the <code>primRoots</code> method be simplified or optimized in terms of <strong>memory usage</strong> and <strong>performance</strong>/efficiency? </p>
</div>
<div class="post-text" itemprop="text">
<p>One quick change that you can make here (<strong>not efficiently optimum yet</strong>) is using list and set comprehensions:</p>
<pre><code>def primRoots(modulo):
    coprime_set = {num for num in range(1, modulo) if gcd(num, modulo) == 1}
    return [g for g in range(1, modulo) if coprime_set == {pow(g, powers, modulo)
            for powers in range(1, modulo)}]
</code></pre>
<p>Now, one powerful and interesting algorithmic change that you can make here is to optimize your <a href="https://docs.python.org/3/library/math.html#math.gcd" rel="nofollow noreferrer"><code>gcd</code> function</a> using <a href="https://en.wikipedia.org/wiki/Memoization" rel="nofollow noreferrer">memoization</a>. Or even better you can simply use built-in <code>gcd</code> function form <code>math</code> module in Python-3.5+ or <code>fractions</code> module in former versions:</p>
<pre><code>from functools import wraps
def cache_gcd(f):
    cache = {}

    @wraps(f)
    def wrapped(a, b):
        key = (a, b)
        try:
            result = cache[key]
        except KeyError:
            result = cache[key] = f(a, b)
        return result
    return wrapped

@cache_gcd
def gcd(a,b):
    while b != 0:
        a, b = b, a % b
    return a
# or just do the following (recommended)
# from math import gcd
</code></pre>
<p>Then:</p>
<pre><code>def primRoots(modulo):
    coprime_set = {num for num in range(1, modulo) if gcd(num, modulo) == 1}
    return [g for g in range(1, modulo) if coprime_set == {pow(g, powers, modulo)
            for powers in range(1, modulo)}]
</code></pre>
<p>As mentioned in comments, as a more pythoinc optimizer way you can use <code>fractions.gcd</code> (or for Python-3.5+ <a href="https://docs.python.org/3/library/math.html#math.gcd" rel="nofollow noreferrer"><code>math.gcd</code></a>).</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on the comment of <strong>Pete</strong> and answer of <strong>Kasramvd</strong>, I can suggest this:</p>
<pre><code>from math import gcd as bltin_gcd

def primRoots(modulo):
    required_set = {num for num in range(1, modulo) if bltin_gcd(num, modulo) }
    return [g for g in range(1, modulo) if required_set == {pow(g, powers, modulo)
            for powers in range(1, modulo)}]

print(primRoots(17))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>[3, 5, 6, 7, 10, 11, 12, 14]
</code></pre>
<hr/>
<p><strong>Changes:</strong></p>
<ul>
<li>It now uses <a href="https://docs.python.org/2/library/functions.html#pow" rel="nofollow noreferrer">pow</a> method's 3-rd argument for the modulo.</li>
<li>Switched to <a href="https://docs.python.org/3/library/math.html#math.gcd" rel="nofollow noreferrer">gcd</a> built-in function that's defined in <code>math</code> (for Python <code>3.5</code>) for a speed boost.</li>
</ul>
<hr/>
<p><em>Additional info about built-in <strong>gcd</strong> is here:</em> <a href="https://stackoverflow.com/questions/39678984/efficient-check-if-two-numbers-are-co-primes-relatively-primes"><em>Co-primes checking</em></a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can greatly improve your isNotPrime function by using a more efficient algorithm.  You could double the speed by doing a special test for even numbers and then only testing odd numbers up to the square root, but this is still very inefficient compared to an algorithm such as the Miller Rabin test.  This version in the <a href="https://rosettacode.org/wiki/Miller%E2%80%93Rabin_primality_test#Python:_Proved_correct_up_to_large_N" rel="nofollow noreferrer">Rosetta Code</a> site will always give the correct answer for any number with fewer than 25 digits or so.  For large primes, this will run in a tiny fraction of the time it takes to use trial division.  </p>
<p>Also, you should avoid using the floating point exponentiation operator ** when you are dealing with integers as in this case (even though the Rosetta code that I just linked to does the same thing!).  Things might work fine in a particular case, but it can be a subtle source of error when Python has to convert from floating point to integers, or when an integer is too large to represent exactly in floating point.  There are efficient integer square root algorithms that you can use instead.  Here's a simple one:</p>
<pre><code>def int_sqrt(n):
   if n == 0:
      return 0
   x = n
   y = (x + n//x)//2

   while (y&lt;x):
      x=y
      y = (x + n//x)//2

   return x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the special case that p is prime, the following is a good bit faster:</p>
<pre><code>import sys

# translated to Python from http://www.bluetulip.org/2014/programs/primitive.js
# (some rights may remain with the author of the above javascript code)

def isNotPrime(possible):
    # We only test this here to protect people who copy and paste
    # the code without reading the first sentence of the answer.
    # In an application where you know the numbers are prime you
    # will remove this function (and the call). If you need to
    # test for primality, look for a more efficient algorithm, see
    # for example Joseph F's answer on this page.
    i = 2
    while i*i &lt;= possible:
        if (possible % i) == 0:
            return True
        i = i + 1
    return False

def primRoots(theNum):
    if isNotPrime(theNum):
        raise ValueError("Sorry, the number must be prime.")
    o = 1
    roots = []
    r = 2
    while r &lt; theNum:
        k = pow(r, o, theNum)
        while (k &gt; 1):
            o = o + 1
            k = (k * r) % theNum
        if o == (theNum - 1):
            roots.append(r)
        o = 1
        r = r + 1
    return roots

print(primRoots(int(sys.argv[1])))
</code></pre>
</div>
<span class="comment-copy">Note that <code>pow</code> allows a third argument, the modulo, which is much, much faster than manually applying the modulus.</span>
<span class="comment-copy">You should use <code>pow(g, powers, modulo)</code> instead of <code>pow(g, powers) % modulo</code>...</span>
<span class="comment-copy">@Bakuriu Indeed, what an obvious miss. Thanks for note!</span>
<span class="comment-copy">gcd() from the fractions module seems to be just as fast (tested with p = 4099)</span>
<span class="comment-copy">@JoachimWagner Definitely! thanks for the comment.</span>
<span class="comment-copy">That <code>if gcd(num, modulo)</code> is always true, perhaps you forgot a conditional?</span>
<span class="comment-copy">Note that <code>gcd</code> is available in the <code>fractions</code> module since at least python2.7, probably well before.</span>
<span class="comment-copy">This is not an answer to the question but a comment / improvement to my partial answer.</span>
