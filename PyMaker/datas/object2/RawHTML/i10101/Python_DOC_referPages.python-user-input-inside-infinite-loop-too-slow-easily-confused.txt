<div class="post-text" itemprop="text">
<p>I have a Python script running on a Raspberry Pi that sits waiting for user input and records the input in a SQLite database:</p>
<pre><code>#!/usr/bin/env python

import logging
import db

while True:
    barcode = raw_input("Scan ISBN: ")
    if ( len(barcode) &gt; 1 ):
        logging.info("Recording scanned ISBN: " + barcode)
        print "Recording scanned ISBN: " + barcode
        db.recordScan(barcode, 1)
</code></pre>
<p>That <code>db.recordScan()</code> method looks like this:</p>
<pre><code># Adds an item to queue
def recordScan(isbn, shop_id):
    insert = "INSERT INTO scans ( isbn, shop_id ) VALUES ( ?, ? )"
    conn = connect()
    conn.cursor().execute(insert, [isbn, shop_id])
    conn.commit()
    conn.close()
</code></pre>
<p><em>(Note: The whole code repo is available at <a href="https://github.com/martinjoiner/bookfetch-scanner-python/" rel="nofollow">https://github.com/martinjoiner/bookfetch-scanner-python/</a> if you wanna see how I'm connecting to the db and such)</em> </p>
<p>My problem is that using a USB barcode scanner (which is effectively just a keyboard input that sends a series of keystrokes followed by the <code>Enter</code> key) it is really easy to input at such a fast rate that the command line seems to get <em>"confused"</em>. </p>
<p><strong>For example compare the following results...</strong> </p>
<p>When you go slow the script works well and the command looks neat like this:</p>
<pre><code>Scan ISBN: 9780465031467
Recording scanned ISBN: 9780465031467
Scan ISBN: 9780141014593
Recording scanned ISBN: 9780141014593
Scan ISBN: 
</code></pre>
<p>But when you hammer it hard and go really fast the input prompt kind of gets ahead of itself and the messages printed by the script get written on top of the input prompt:</p>
<pre><code>Recording scanned ISBN: 9780141014593
9780141014593
9780141014593
9780465031467
Recording scanned ISBN: 9780141014593
Scan ISBN: Recording scanned ISBN: 9780141014593
Scan ISBN: Recording scanned ISBN: 9780141014593
Scan ISBN: Recording scanned ISBN: 9780465031467
Scan ISBN: 9780571273188
9780141014593
</code></pre>
<p>It sometimes hangs in that position indefinitely, I don't know what it's doing but you can wake it back up again with another input and it carries on as normal although the input before the one it hung on doesn't get recorded which is bad because it makes the whole system unreliable. </p>
<p>My question is: Is this an inevitability that I just have to live with? Will I always be able to out-pace the low-powered Raspberry Pi by hitting it with too many inputs in close succession or is there some faster way of doing this? Can I push the database write operation to another thread or something along those lines? Forgive my ignorance, I am learning. </p>
</div>
<div class="post-text" itemprop="text">
<p>Don't build SQL strings from user input. Ever. </p>
<p><em>Always</em> use parameterized queries.</p>
<pre><code># Adds an item to queue
def recordScan(isbn, shop_id):
    insert = "INSERT INTO scans ( isbn, shop_id ) VALUES ( ?, ? )"
    conn = connect()
    conn.cursor().execute(insert, [isbn, shop_id])
    conn.commit()
    conn.close()
</code></pre>
<p>Please read <a href="https://docs.python.org/2/library/sqlite3.html" rel="nofollow">https://docs.python.org/2/library/sqlite3.html</a>, at the very least the upper part of the page, where they explain this approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>You appear to be opening and closing the database each and every time. That will clearly add a huge overhead, especially as you are "hammering" away at it.<br/>
Connect to the database once at the beginning and close it upon exit.<br/>
In between, simply perform your <code>insert</code>, <code>update</code> and <code>delete</code> statements. </p>
<p>Edit:<br/>
For the purposes of this I renamed <code>db.py</code> to be called <code>barcode1.py</code> so edit appropriately.
Alter <code>listen.py</code> to be as follows:    </p>
<pre><code>#!/usr/bin/env python

import logging
import barcode1
DB_FILE_NAME = "scan-queue.db"
my_db = barcode1.sqlite3.connect(DB_FILE_NAME)
my_cursor = my_db.cursor()

def InsertScan(isbn, shop_id):
    insert = "INSERT INTO scans ( isbn, shop_id ) VALUES ( ?, ? )"
    my_cursor.execute(insert, [isbn, shop_id])
    my_db.commit()

while True:
    barcode = raw_input("Scan ISBN: ")
    if ( len(barcode) &gt; 1 ):
        logging.info("Recording scanned ISBN: " + barcode)
        print "Recording scanned ISBN: " + barcode
        InsertScan(barcode, 1)
my_db.close()
</code></pre>
<p>For your purposes replace references to "barcode1" with "db"<br/>
As you can see all that happens here is that a separate function has been added to do the writing and only the writing.<br/>
Clearly this is a quick mock up and could be improved immeasurably, in fact I'd rewrite it as a single script. This is one of those classic examples where in an attempt to write object oriented code, you end up shooting yourself in the foot.<br/>
In fact you could do without the function and just include the <code>insert</code> code within the <code>while</code> statement.</p>
<p>Locking:
from the sqlite3 documents:</p>
<pre><code> sqlite3.connect(database[, timeout, detect_types, isolation_level, check_same_thread, factory, cached_statements, uri])
</code></pre>
<p>Opens a connection to the SQLite database file database. You can use ":memory:" to open a database connection to a database that resides in RAM instead of on disk.</p>
<p>When a database is accessed by multiple connections, and one of the processes modifies the database, the SQLite database is locked until that transaction is committed. The timeout parameter specifies how long the connection should wait for the lock to go away until raising an exception. The default for the timeout parameter is 5.0 (five seconds).</p>
</div>
<div class="post-text" itemprop="text">
<p>After much experimenting based on helpful advice from users @tomalak, @rolf-of-saxony and @hevlastka my conclusion is that <strong>yes, this <em>is</em> an inevitability that I just have to live with.</strong> </p>
<p>Even if you strip the example down to the basics by removing the database write process and making it a simple <em>parrot</em> script that just repeats back inputs (See <a href="https://stackoverflow.com/questions/40156905/python-on-raspberry-pi-user-input-inside-infinite-loop-misses-inputs-when-hit-wi">Python on Raspberry Pi user input inside infinite loop misses inputs when hit with many</a>), it is still possible to scan items so fast that inputs get missed/skipped/ignored. The Raspberry Pi simply cannot keep up. </p>
<p>So my approach will now be to add an audio feedback feature such as a beep sound to indicate to the user when the device is ready to receive the next input. A route I didn't want to go down but it seems my code is the most efficient it can be and we're still able to hit the limits. Responsibility is with the user to not go at breakneck speed and the best we can do a responsible product builders is give them good feedback. </p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the issues I brought up in my first answer, there is another problem which effects the speed of the updates, namely the <code>commits</code>.<br/>
You will find that if you <code>commit</code> in batches, the speed goes up exponentially. Adjust the journaling and up it goes again.<br/>
Working on a PI 3, I mocked up 5000 updates in 10 seconds with the journal on and in 0.43 seconds with the journal off.<br/>
If you change your code to store the barcodes in a list and then fire off the database updates in batches, you code will work on a Raspberry Pi.</p>
<p>See below for my test code:</p>
<pre><code>#!/usr/bin/env python
import sqlite3
import time
DB_FILE_NAME = "scan-queue.db"
my_db = sqlite3.connect(DB_FILE_NAME)
my_cursor = my_db.cursor()
my_cursor.execute('CREATE TABLE if not exists scans(id INTEGER PRIMARY KEY AUTOINCREMENT,isbn TEXT NOT NULL,shop_id INT NOT NULL)')   
my_db.commit()
#This line turns off journaling, passing off the writes to the OS
# No rollbacks are available and corruption can occur if the machine has an issue
# but you're not NASA
my_cursor.execute("PRAGMA synchronous = OFF") #Can increase speed 20 fold
def InsertScan(isbn, shop_id):
    insert = "INSERT INTO scans ( isbn, shop_id ) VALUES ( ?, ? )"
    my_cursor.execute(insert, [isbn, shop_id])

tot_t = time.time() #Time entire run
shop_id = 1
barcode = 11111111111111
batch=[]
while shop_id &lt; 5000:
    #barcode = raw_input("Scan ISBN: ")
    batch_cnt = 0
    while batch_cnt &lt; 100:
        shop_id +=1
        barcode +=1
        batch_cnt +=1
        print "Recording scanned ISBN: ", barcode, shop_id
        batch.append((barcode,shop_id))
    print "Saving", str(len(batch)), "scanned ISBN's"
    t = time.time() #Time batch update
    for i in batch:
        InsertScan(i[0],i[1])
    batch=[]
    my_db.commit()
    t2 = time.time() - t
    print "Secs =", t2 #Print update time in seconds
print "Saving", str(len(batch)), "scanned ISBN's"
for i in batch: #Final update (just in case) or when program is quit
    InsertScan(i[0],i[1])
my_db.commit()
x = my_cursor.execute("select count(*) from scans")
tot_t2 = time.time() - tot_t
print "5000 Updates in ", tot_t2 #Print update time in seconds
for i in x:
    print i,"Total rows in scans table" #Print total of records in table
my_db.close() 
</code></pre>
</div>
<span class="comment-copy">Not sure which raspberry pi you're using (and I've only worked with generation 1) but these gizmos usually have a single core CPU. If you're running a MySQL instance on the same rasp pi then you might want to look into moving that over to another machine, perhaps something with a bit more power.</span>
<span class="comment-copy">Same goes for SQLite (since I'm bad at reading and just realised that it says SQLite not MySQL!)</span>
<span class="comment-copy">I agree with your suggestion, but does it address the OP's issue of multiple <code>raw_input</code> calls getting jumbled up by super-fast user input? I expect them to get the same mangled data regardless of whether they parameterize or not.</span>
<span class="comment-copy">It is not a public system and I am the only person using it so for now, SQL injection attacks are not a concern. You may notice that the method is called with the shop_id hard-coded to <code>1</code>; this is still just a proof of concept in early development. But as this SQL issue is distracting from the question I will edit the code to best practice. Thank you for your input.</span>
<span class="comment-copy">That's not the point. "I don't need to use SQL parameters in this case" is not a valid position to hold. One never uses unparameterized SQL unless there is absolutely no way to avoid it. Then again, you are right, the whole SQL part of your question is a red herring. It's not the SQL part that causes the trouble here, you should edit that out of your question completely. Reduce it to the part of the code that deals with the barcode scanner.</span>
<span class="comment-copy">@Tomalak that's a good point. I've just tried commenting out the call to <code>db.recordScan()</code> and I can still scan fast enough to make it miss inputs, although I cannot recreate the hanging behavior which leads me to believe that's caused by 2 scripts reading/writing from the same database (a subject for a separate question).</span>
<span class="comment-copy">I don't think it could be a locking issue, since this is single-threaded code and no other process is accessing the database. Try to do <code>print("Recording scanned ISBN: " + len(barcode))</code>, i.e. don't print the scanned data itself. Maybe there's odd characters in there, not printing it might staighten out the output. Just tossing ideas around.</span>
<span class="comment-copy">Ah yes, I connect and disconnect each time because there is another script in a separate shell reading/writing to the same database. Is there a middle ground? I am actually writing a separate question to cover the "2 scripts 1 database" issue.</span>
<span class="comment-copy">I have created a second question to deal with the concurrent access issue <a href="http://stackoverflow.com/questions/40134943/2-shells-1-cup-sharing-a-queue-between-2-python-scripts-on-raspberry-pi" title="2 shells 1 cup sharing a queue between 2 python scripts on raspberry pi">stackoverflow.com/questions/40134943/…</a></span>
<span class="comment-copy">I have covered it above. See <a href="https://docs.python.org/3/library/sqlite3.html" rel="nofollow noreferrer">docs.python.org/3/library/sqlite3.html</a></span>
<span class="comment-copy">Ooo yes good effort on the re-edits. I will play with an in-memory database now. I will want the queue to persist in memory if the device is powered off though. Am I correct in thinking the best way to do that would be to add some code that occasionally backs up the queue to a file, the in-memory queue is then populated from that file on future loads.</span>
<span class="comment-copy">If you are attempting to <code>share</code> an in memory database between 2 or more processes, I think you will struggle. However see <a href="http://stackoverflow.com/questions/3315046/sharing-a-memory-database-between-different-threads-in-python-using-sqlite3-pa" title="sharing a memory database between different threads in python using sqlite3 pa">stackoverflow.com/questions/3315046/…</a> I really don't see why you can't simply use a bog standard sqlite3 db.</span>
<span class="comment-copy">This is a good separate question by the way. Post your parrot script and everything else that someone in possession of the necessary hardware needs to reproduce, maybe someone comes up with an idea. Somehow I have a hard time imagining that GHz hardware is too slow for a few rapid keystrokes. Maybe it's something else.</span>
<span class="comment-copy">Maybe something in here helps as well? <a href="https://www.raspberrypi.org/forums/viewtopic.php?f=45&amp;t=55100" rel="nofollow noreferrer">raspberrypi.org/forums/viewtopic.php?f=45&amp;t=55100</a> - as in, you might be able to use a different way of reading out data from the scanner.</span>
<span class="comment-copy">That being said, here is a question with more info on making SQLite play nice with multiple write processes. <a href="http://stackoverflow.com/questions/1063438/sqlite3-and-multiple-processes" title="sqlite3 and multiple processes">stackoverflow.com/questions/1063438/…</a></span>
<span class="comment-copy">@Tomalak I've made a separate question as suggested <a href="http://stackoverflow.com/questions/40156905/python-on-raspberry-pi-user-input-inside-infinite-loop-misses-inputs-when-hit-wi" title="python on raspberry pi user input inside infinite loop misses inputs when hit wi">stackoverflow.com/questions/40156905/…</a></span>
<span class="comment-copy">In parallel also try the alternative to <code>raw_input()</code> as suggested by the forum post.</span>
