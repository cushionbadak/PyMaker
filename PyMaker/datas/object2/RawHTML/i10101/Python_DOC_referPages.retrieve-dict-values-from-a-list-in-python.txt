<div class="post-text" itemprop="text">
<p>I have a dictionary where the values are lists of different lengths like so:</p>
<pre><code>{"a":[1,2,3], "b":[4,3,5,6,7], "c":[1], "d":[2,5]}
</code></pre>
<p>I would like to convert it to a list of tuples for upload to a database:</p>
<pre><code>[("a",1), ("a",2), ("a",3), ("b",4), ("b",3) ... ]
</code></pre>
<p>The most recent thing I have tried is:</p>
<pre><code>lst = []
mydict = {"a":[1,2,3], "b":[4,3,5,6,7], "c":[1], "d":[2,5]}
for k in mydict.keys():
    for i in range(len(mydict[k])):
        count = 0
        while count &lt; i:
            lst.append((k, mydict[k]))
            count += 1
</code></pre>
<p>This does not work, but I can't tell why. Thanks for any help!</p>
</div>
<div class="post-text" itemprop="text">
<p>It feels like you're over-complicating it a bit...</p>
<p>It should only require 2 loops:</p>
<pre><code>lst = []
for k, vals in mydict.items():
    for value in vals:
        lst.append((k, value))
</code></pre>
<p>The first loop is over the dictionary items, the inner loop is over the values list.  For each value in the values list, just append a tuple that holds the key and the value to your resultant list.</p>
<p>And, FWIW, there are lots of other spellings here:</p>
<pre><code>lst = []
for k, vals in mydict.items():
    lst.extend((k, value) for value in vals)
</code></pre>
<p>Or even a <a href="https://stackoverflow.com/a/40179474/748858">1-liner</a>:</p>
<pre><code>lst = [(k, value) for k, vals in mydict.items() for value in vals]
</code></pre>
<p>though I'm not a huge fan of the 1-line version...</p>
<hr/>
<p>As for why your version <em>doesn't</em> work, let's take a look and find out:</p>
<pre><code>lst = []
mydict = {"a":[1,2,3], "b":[4,3,5,6,7], "c":[1], "d":[2,5]}
for k in mydict.keys():
    for i in range(len(mydict[k])):
        count = 0
        while count &lt; i:
            lst.append((k, mydict[k]))
            count += 1
</code></pre>
<p>The first thing that we see is you have an extra loop.  For each key, you'll be hitting some of the values twice when you only want to hit them once.  You <em>could</em> fix it by removing the loop over <code>range(len(...))</code>:</p>
<pre><code>lst = []
mydict = {"a":[1,2,3], "b":[4,3,5,6,7], "c":[1], "d":[2,5]}
for k in mydict.keys():
    count = 0
    while count &lt; len(mydict[k]):
        lst.append((k, mydict[k]))
        count += 1
</code></pre>
<p>But, this is already a more verbose (and, IMHO, confusing) way to write it out than the options I've provided above.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should avoid for loops in python where possible, its very inefficient. Use list comprehension as the most pythonic way to do this. stack is the name of the dict:</p>
<pre><code>[(i,x) for x in stack[i] for i in stack.keys()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>new_list = []
for key, values in mydict.items():
    for val in values:
        new_list.append((key, val))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow">itertools</a> and zip:</p>
<pre><code>import itertools
d = {"a":[1,2,3], "b":[4,3,5,6,7], "c":[1], "d":[2,5]}
result = []
for k, v in d.items():
    result.extend(zip(itertools.cycle(k), v))
</code></pre>
<p>or:</p>
<pre><code>for k, v in d.items():
    result.extend(itertools.izip(itertools.cycle(k), v))
</code></pre>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow">itertools.repeat</a> could also be used in place of itertools.cycle.</p>
</div>
<span class="comment-copy">Where is pmid coming from?</span>
<span class="comment-copy">You don't need to call .keys</span>
<span class="comment-copy">Yes you are correct. Just helps to see whats going on. Especially when I use random names like 'stack' for my dictionary.</span>
<span class="comment-copy">I disagree with the assertion that "you should avoid for loops ..." because they're inefficient.  At worst, they're only marginally slower than an equivalent list comprehension.  The primary concern is typically how easy the expression is to <i>read</i> until your profiling can tell you otherwise.  List-comps frequently shine here because they can be digested as a single atomic unit for those who are familiar with them.</span>
<span class="comment-copy">How does this solution differ from the solution posted a few minutes ago?</span>
<span class="comment-copy">Woops, I guess I was beat to the punch.</span>
<span class="comment-copy">While this code snippet may solve the problem, it doesn't explain why or how it answers the question. Please <a href="//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers">include an explanation for your code</a>, as that really helps to improve the quality of your post. Remember that you are answering the question for readers in the future, and those people might not know the reasons for your code suggestion. <b>Flaggers / reviewers:</b> <a href="//meta.stackoverflow.com/a/260413/2747593">For code-only answers such as this one, downvote, don't delete!</a></span>
