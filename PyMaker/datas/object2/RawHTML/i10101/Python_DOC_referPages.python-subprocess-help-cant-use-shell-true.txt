<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/26643719/python-exporting-environment-variables-in-subprocess-popen">Python: Exporting environment variables in subprocess.Popen(..)</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/1253122/why-does-subprocess-popen-with-shell-true-work-differently-on-linux-vs-windows">Why does subprocess.Popen() with shell=True work differently on Linux vs Windows?</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>I am wracking my brain over here trying to do a simple function with python without using shell=true and am not getting the results I need. I am using python 2.7 on Linux. </p>
<p>I have tried multiple methods of doing this. It works fine if I use shell=true like so:</p>
<pre><code>import subprocess as s

var1 = s.call("echo $HOME", shell=True)
</code></pre>
<p>and </p>
<pre><code>import subprocess as s

var1 = s.check_output("echo $HOME", shell=True)
</code></pre>
<p>both return </p>
<p><code>/home/myhost</code> </p>
<p>... like it should but everything else I tried fails. In most cases it seems that it is passing my variable as a string instead of a command. </p>
<p>These are the results I have received with the various methods:</p>
<pre><code>import subprocess as s

print var1
</code></pre>
<p>returns</p>
<pre><code>myhost@me:~/Desktop$ python home_test.py 
  File "home_test.py", line 42, in &lt;module&gt;
    main()
  File "home_test.py", line 11, in main
    my_test()
  File "home_test.py", line 16, in check_auth
    var1 = s.check_output("echo $HOME")
  File "/usr/lib/python2.7/subprocess.py", line 567, in check_output
    process = Popen(stdout=PIPE, *popenargs, **kwargs)
  File "/usr/lib/python2.7/subprocess.py", line 711, in __init__
    errread, errwrite)
  File "/usr/lib/python2.7/subprocess.py", line 1343, in _execute_child
    raise child_exception
OSError: [Errno 2] No such file or directory
</code></pre>
<p>Then I tried this:</p>
<pre><code>import subprocess as s

var1 = s.Popen(['echo', '$HOME'], stdout=s.PIPE) 

print var1
</code></pre>
<p>returns</p>
<pre><code>myhost@me:~/Desktop$ python home_test.py 
&lt;subprocess.Popen object at 0x7f297ebcbf90&gt;
myhost@me:~/Desktop$echo: write error: Broken pipe
</code></pre>
<p>Then this:</p>
<pre><code>import subprocess as s

cmd1 = '$HOME'
var1 = s.Popen(['/bin/echo', cmd1], stdout=s.PIPE)

print var1
</code></pre>
<p>returns</p>
<pre><code>('$Home\n', None)
</code></pre>
<p>and this</p>
<pre><code>import subprocess as s

cmd1 = 'HOME'
var1 = s.Popen(['/bin/echo', cmd1], stdout=s.PIPE)
print var1
</code></pre>
<p>returns</p>
<pre><code>myhost@me:~/Desktop$ python home_test.py 
('Home\n', None)
</code></pre>
<p>found some doc that said to use os... which also failed, which isn't surprising after finding out this had been deprecated in 2.6.</p>
<pre><code>import os

var1 = os.popen('echo $HOME')
print var1
</code></pre>
<p>returns</p>
<pre><code>&lt;open file 'echo $HOME', mode 'r' at 0x7f1c6b26f6f0&gt;
sh: echo: I/O error
</code></pre>
<p>Then my final attempt (actually there were more... but we will just leave it at this)</p>
<pre><code>import subprocess as s

var1= s.Popen(["echo", "$HOME"], stdout=s.PIPE).communicate()[0] 

print var1
</code></pre>
<p>returns:</p>
<pre><code>myhost@me:~/Desktop$ python home_test.py 
$HOME
</code></pre>
<p>Can someone please point me in the right direction? I have spent an entire day fiddling with this and I need help please. Thank you in advance for any help given. </p>
</div>
<div class="post-text" itemprop="text">
<p>Lets start with the answer</p>
<pre>
import os
home = os.environ['HOME']
print(home)
</pre>
<p>Now onto your attempts and results. Your main problem (besides a few random bugs) is that <code>$HOME</code> is replaced with the value of the environment variable by the shell. Without the shell argument expansion <code>$HOME</code> is just a string and that is what you get.</p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you really just want to get the value of an environment variable. <code>os.getenv('HOME')</code> should do that for you.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer mentioning <code>os.environ['HOME']</code> is correct, but it's probably not what you want for portability. There is no guarantee that <code>HOME</code> is set (it's by convention, not required; users could delete it, shells could choose not to set it, etc.). And if you eventually want portability to Windows, that's not its name. If you want the user's home directory, don't check the environment directly, instead, use <a href="https://docs.python.org/3/library/os.path.html#os.path.expanduser" rel="nofollow"><code>os.path.expanduser</code></a> to use smarter home directory lookup logic:</p>
<pre><code>import os.path

home = os.path.expanduser('~')
</code></pre>
<p>This will work even if <code>HOME</code> is not defined, and generalizes to looking up other user's home directories (<code>os.path.expanduser('~someotheruser')</code>).</p>
<p>In Python 3.5+, you could also <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.home" rel="nofollow">use <code>pathlib.Path.home()</code> to get a <code>Path</code> object representing the home directory</a>.</p>
<p>Also, tangentially, if you need to expand a string with a bunch of environment variable replacements in general, you might want to look at <a href="https://docs.python.org/3/library/os.path.html#os.path.expandvars" rel="nofollow"><code>os.path.expandvars</code></a>, which does the environment lookup and string formatting as a single operation.</p>
</div>
<span class="comment-copy">In <code>var1 = s.Popen(['echo', '$HOME'], stdout=s.PIPE)</code>, only the first array element is treated as a script. Subsequent array elements are arguments to that script.</span>
<span class="comment-copy">...btw, what's your real use case? In general, using <code>shell=True</code> is the Wrong Thing; it introduces security bugs if not used with sufficient (substantial!) caution, and does nothing you can't do by making your Python more verbose.</span>
<span class="comment-copy">Thank you this worked. I don't know why I didn't think of this. Probably because I was beating my head on the wall trying to use subprocess.</span>
<span class="comment-copy">Your main problem was that you were trying to do shell variable expansion without using the shell :)</span>
<span class="comment-copy">@shellsbelles: As a rule, the vast majority of the simple shell utilities have better (or at least lower overhead) equivalents in Python. Even in the cases where <code>subprocess</code>ing the shell utility appears faster (e.g. reading compressed data from a <code>.gz</code> file is superficially faster), it's usually only because <code>subprocess</code> does the parallelism "for free" (and in the <code>gzip</code> module's case, on some versions, it's because they didn't buffer by default, <code>io.BufferedReader</code> wrapping would fix it); if you threaded or parallel processed the Python equivalent code, it wouldn't lose out much.</span>
<span class="comment-copy">A handful of examples: Reading the environment is best done with <code>os.environ</code>, moving and copying files with <code>shutil</code>, dealing with compressed data with the <code>gzip</code>/<code>bzip2</code>/<code>lzma</code> modules, <code>ls</code> without globbing becomes <code>os.listdir</code> (<code>os.scandir</code> on modern Python for better perf) or the <code>glob</code> module for globbing behavior, <code>find</code> becomes <code>os.walk</code>, etc.</span>
<span class="comment-copy">Thanks, however this did not work, I put the results in the comments</span>
<span class="comment-copy">Nevermind, I had a typo. This also worked. Thanks to the both of you.</span>
<span class="comment-copy">Tangential warning: As a rule, it's better to use <code>os.environ</code> exclusively and ban the <code>getenv</code>/<code>putenv</code> for consistency. Specifically, it's a problem if you mutate the environment; calling <code>putenv</code> doesn't change <code>os.environ</code>, but mutating <code>os.environ</code> will also do <code>putenv</code> (if supported). Additionally, <code>getenv</code> and <code>putenv</code> aren't available on all OSes (though admittedly, it's only rare UNIX-like flavors that don't support it AFAICT), while <code>os.environ</code> is always supported.</span>
