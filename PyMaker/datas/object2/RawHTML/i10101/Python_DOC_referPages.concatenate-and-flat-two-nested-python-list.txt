<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/18713321/element-wise-addition-of-2-lists">Element-wise addition of 2 lists?</a>
<span class="question-originals-answer-count">
                    13 answers
                </span>
</li>
</ul>
</div>
<p>I have two vectors in the form </p>
<pre><code>a = [[1,2,3],[1,2,3],[1,2,3]]

b = [[5,6,7],[5,6,7],[5,6,7]]
</code></pre>
<p>I want the output to be </p>
<pre><code>c = [[1,2,3,5,6,7],[1,2,3,5,6,7],[1,2,3,5,6,7]]
</code></pre>
<p>I got this line </p>
<pre><code>c = [[a[i],b[i]] for i in range(len(a))]
</code></pre>
<p>but my output is </p>
<pre><code>[[[1, 2, 3], [5, 6, 7]], [[1, 2, 3], [5, 6, 7]], [[1, 2, 3], [5, 6, 7]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><em>zip</em></a> and <em>concatenate</em> each pairing:</p>
<pre><code>a = [[1,2,3],[1,2,3],[1,2,3]]

b = [[5,6,7],[5,6,7],[5,6,7]]

print([i + j for i,j in zip(a, b)])
</code></pre>
<p>Which would give you:</p>
<pre><code>[[1, 2, 3, 5, 6, 7], [1, 2, 3, 5, 6, 7], [1, 2, 3, 5, 6, 7]]
</code></pre>
<p>Or using your own logic:</p>
<pre><code>[a[i] + b[i] for i in range(len(a))]
</code></pre>
<p><em>concatenating</em>  with + is the key. If you were going to index I would use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><em>enumerate</em></a>:</p>
<pre><code>[ele + b[i] for i, ele in enumerate(a)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just another way:</p>
<pre><code>&gt;&gt;&gt; map(list.__add__, a, b)
[[1, 2, 3, 5, 6, 7], [1, 2, 3, 5, 6, 7], [1, 2, 3, 5, 6, 7]]
</code></pre>
<p>Or using the <code>operator</code> module:</p>
<pre><code>&gt;&gt;&gt; map(operator.add, a, b)
[[1, 2, 3, 5, 6, 7], [1, 2, 3, 5, 6, 7], [1, 2, 3, 5, 6, 7]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution using the itertools module:</p>
<pre><code>from itertools import chain, starmap
c = map(list, list(starmap(chain, zip(a, b))))
</code></pre>
<p>Edited thanks to Padraic's comment. It's too nested at this point for me to recommend using this.</p>
</div>
<span class="comment-copy">Better use six <i>different</i> sublists to make it more obvious where the parts in the output come from.</span>
<span class="comment-copy">that's a nice way, I have several features vectors, and I need it to create an array as input for a scikit learn classifier</span>
<span class="comment-copy">I'm going with padraic's solution since It could be extended to more lists in the form    [ele + b[i] + c[i] for i, ele in enumerate(a)]</span>
<span class="comment-copy">This would give you a list of chain objects. It would be <code>list(starmap(operator.add, zip(a, b)))</code> if anything or <code>list(starmap(list.__add__, zip(a, b)))</code>.</span>
<span class="comment-copy">My bad, edited.</span>
<span class="comment-copy">I think the operator approach is nicer as you would also need an additional list call on map so it would actually become <code>list(map(list, list(starmap(chain, zip(a, b)))))</code></span>
<span class="comment-copy">Map can operate on generators so you don't need the list call around starmap.</span>
<span class="comment-copy">Try it with Python 3</span>
