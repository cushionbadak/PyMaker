<div class="post-text" itemprop="text">
<p>I can't use Numpy or any other library function as this is a question I have to do, I have to define my own way.</p>
<p>I am writing a function that takes two lists (2 dimensional) as arguments. The function should calculate the element-wise product of both lists and store them in a third list and return this resultant list from the function.
An example of the input lists are:</p>
<h3>list1:</h3>
<pre><code>[[2,3,5,6,7],[5,2,9,3,7]]  
</code></pre>
<h3>list2:</h3>
<pre><code>[[5,2,9,3,7],[1,3,5,2,2]]
</code></pre>
<p>The function prints the following list: </p>
<pre><code>[[10, 6, 45, 18, 49], [5, 6, 45, 6, 14]] 
</code></pre>
<p>That is <code>2*5=10</code>, <code>3*2=6</code>, <code>5*9=45</code> ... and so on.</p>
<p>This is my code below, but it is only for a list with 2 lists (elements) inside in it like the example above and works perfectly fine for that, but what I want is to edit my code so that no matter how many number of lists (elements) are there in the 2-D list, it should print out its element-wise product in a new 2-D list e.g. it should also work for </p>
<pre><code>[[5,2,9,3,7],[1,3,5,2,2],[1,3,5,2,2]]
</code></pre>
<p>or </p>
<pre><code>[[5,2,9,3,7],[1,3,5,2,2],[1,3,5,2,2],[5,2,9,3,7]]
</code></pre>
<p>or any number of lists there are within the whole list.</p>
<pre><code>def ElementwiseProduct(l,l2):
    i=0
    newlist=[] #create empty list to put prouct of elements in later
    newlist2=[]
    newlist3=[] #empty list to put both new lists which will have proudcts in them
    while i==0:
        a=0
        while a&lt;len(l[i]):
            prod=l[i][a]*l2[i][a] #corresponding product of lists elements
            newlist.append(prod) #adding the products to new list
            a+=1
        i+=1
    while i==1:
        a=0
        while a&lt;len(l[i]):
            prod=l[i][a]*l2[i][a] #corresponding product of lists elements
            newlist2.append(prod) #adding the products to new list
            a+=1
        i+=1
    newlist3.append(newlist)
    newlist3.append(newlist2)
    print newlist3

#2 dimensional list example
list1=[[2,3,5,6,7],[5,2,9,3,7]] 
list2=[[5,2,9,3,7],[1,3,5,2,2]]  
ElementwiseProduct(list1,list2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow"><code>zip</code></a> the two lists in a <em>list comprehension</em>, then further <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow"><code>zip</code></a> the resulting <em>sublists</em> and then finally multiply the items:</p>
<pre><code>list2 = [[5,2,9,3,7],[1,3,5,2,2]]
list1 = [[2,3,5,6,7],[5,2,9,3,7]]

result = [[a*b for a, b in zip(i, j)] for i, j in zip(list1, list2)]
print(result)
# [[10, 6, 45, 18, 49], [5, 6, 45, 6, 14]]
</code></pre>
<p>Should in case the <em>lists</em>/<em>sublists</em> do not have the same number of elements, <a href="https://docs.python.org/2/library/itertools.html#itertools.izip_longest" rel="nofollow"><code>itertools.izip_longest</code></a> can be used to generate fill values such as an empty sublist for the smaller list, or 0 for the shorter sublist:</p>
<pre><code>from itertools import izip_longest

list1 = [[2,3,5,6]]
list2 = [[5,2,9,3,7],[1,3,5,2,2]]
result = [[a*b for a, b in izip_longest(i, j, fillvalue=0)] 
               for i, j in izip_longest(list1, list2, fillvalue=[])]
print(result)
# [[10, 6, 45, 18, 0], [0, 0, 0, 0, 0]]
</code></pre>
<p>You may change the inner <code>fillvalue</code> from 0 to 1 to return the elements in the longer sublists as is, instead of a homogeneous 0.</p>
<hr/>
<p><em>Reference</em>:</p>
<p><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">List comprehensions</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a function that can handle any type of iterable, nested to any level (any number of dimensions, not just 2):</p>
<pre><code>def elementwiseProd(iterA, iterB):
    def multiply(a, b):
        try:
            iter(a)
        except TypeError:
            # You have a number
            return a * b
        return elementwiseProd(a, b)
    return [multiply(*pair) for pair in zip(iterA, iterB)]
</code></pre>
<p>This function works recursively. For each element in a list, it checks if the element is iterable. If it is, the output element is a list containing the elementwise multiplication of the iterables. If not, the product of the numbers is returned.</p>
<p>This solution will work on mixed nested types. A couple of assumptions that are made here are that all the levels of nesting are the same size, and that an element that is a number in one iterable (vs a nested iterable), is always a number in the other.</p>
<p>In fact, this snippet can be extended to apply any n-ary function to any n iterables:</p>
<pre><code>def elementwiseApply(op, *iters):
    def apply(op, *items):
        try:
            iter(items[0])
        except TypeError:
            return op(*items)
        return elementwiseApply(op, *items)
    return [apply(op, *items) for items in zip(*iters)]
</code></pre>
<p>To do multiplication, you would use <code>operator.mul</code>:</p>
<pre><code>from operator import mul
list1=[[2,3,5,6,7], [5,2,9,3,7]] 
list2=[[5,2,9,3,7], [1,3,5,2,2]]
elementwiseApply(mul, list1, list2)
</code></pre>
<p>produces</p>
<pre><code>[[10, 6, 45, 18, 49], [5, 6, 45, 6, 14]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python, it's generally better to loop directly over the items in a list, rather than looping indirectly using indices. It makes the code easier to read as well as more efficient since it avoids the tedious index arithmetic.</p>
<p>Here's how to solve your problem using traditional <code>for</code> loops. We use the built-in <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> function to iterate over two (or more) lists simultaneously.</p>
<pre><code>def elementwise_product(list1,list2):
    result = []
    for seq1, seq2 in zip(list1,list2):
        prods = []
        for u, v in zip(seq1, seq2):
            prods.append(u * v)
        result.append(prods)
    return result

list1=[[2,3,5,6,7], [5,2,9,3,7]] 
list2=[[5,2,9,3,7], [1,3,5,2,2]]

print(elementwise_product(list1,list2))
</code></pre>
<p><strong>output</strong></p>
<pre><code>[[10, 6, 45, 18, 49], [5, 6, 45, 6, 14]]
</code></pre>
<p>We can use <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehensions</a> to make that code a lot more compact. It may seem harder to read at first, but you'll get used to list comprehensions with practice.</p>
<pre><code>def elementwise_product(list1,list2):
    return [[u*v for u, v in zip(seq1, seq2)] 
        for seq1, seq2 in zip(list1,list2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use numpy arrays. They are your best option as they run on a C background and hence are much faster computationally</p>
<p>First, install numpy. Shoot up your terminal (CMD if you're in windows), type</p>
<pre><code>pip install numpy
</code></pre>
<p>or, if in Linux, <code>sudo pip install numpy</code></p>
<p>Then, go on to write your code</p>
<pre><code>import numpy as np

list1=np.array([[2,3,5,6,7],[5,2,9,3,7]]) #2 dimensional list example
list2=np.array([[5,2,9,3,7],[1,3,5,2,2]])

prod = np.multiply(list1,list2)
# or simply, as suggested by Mad Physicist,
prod = list1*list2
</code></pre>
</div>
<span class="comment-copy">You should use zip in a list comp</span>
<span class="comment-copy">Moses Koledoye's answer should do the trick without Numpy</span>
<span class="comment-copy">If one of the answers below fixes your issue, you should accept it (click the check mark next to the appropriate answer). That does two things. It lets everyone know your issue has been resolved to your satisfaction, and it gives the person that helps you credit for the assist. See <a href="http://meta.stackexchange.com/a/5235">here</a> for a full explanation.</span>
<span class="comment-copy">You could also introduce parameter expansion with <code>result = [[a*b for a, b in zip(*e)] for e in zip(list1, list2)]</code></span>
<span class="comment-copy">@MadPhysicist That looks neater, but would require some explanation about how unpacking works :)</span>
<span class="comment-copy">Add in the use of <code>reduce</code> and <code>operator.mul</code> and this answer is golden</span>
<span class="comment-copy">Cute, but I suspect that it may be a bit too advanced for the OP. OTOH, it may be of interest to other readers.</span>
<span class="comment-copy">@PM2Ring. I wrote this back when I thought it looked like the requirement was to handle any-dimensional arrays. Kept it for the exact reason that you state. Don't expect it to be the accepted answer, but it is a useful example.</span>
<span class="comment-copy">I like this answer because it addresses the most basic issues with OPs code. It is probably the most helpful for someone just jumping into Python.</span>
<span class="comment-copy">Hope you don't mind the import edit. OP seems very new to Python so it's probably best to be explicit.</span>
<span class="comment-copy">Also, you could just do <code>list1 * list2</code>.</span>
<span class="comment-copy">You would also have to install numpy.  The OP is also tasked with writing their own function so numpy is not an option as per the first line of their question. I cannot use numpy ....</span>
<span class="comment-copy">Thanks for pointing it out @PadraicCunningham. Added installation guide. Numpy is an essential library, so I think he should try it out.</span>
<span class="comment-copy">And @MadPhysicist Thanks for the heads up :-)</span>
