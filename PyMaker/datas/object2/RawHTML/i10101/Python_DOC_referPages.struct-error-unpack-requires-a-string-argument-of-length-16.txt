<div class="post-text" itemprop="text">
<p>While processing a PDF <a href="https://yadi.sk/i/2vABlTaexZerg" rel="nofollow noreferrer">file (2.pdf)</a> with pdfminer (pdf2txt.py) I received the following error:</p>
<pre><code>pdf2txt.py 2.pdf 

Traceback (most recent call last):
  File "/usr/local/bin/pdf2txt.py", line 115, in &lt;module&gt;
    if __name__ == '__main__': sys.exit(main(sys.argv))
  File "/usr/local/bin/pdf2txt.py", line 109, in main
    interpreter.process_page(page)
  File "/usr/local/lib/python2.7/dist-packages/pdfminer/pdfinterp.py", line 832, in process_page
    self.render_contents(page.resources, page.contents, ctm=ctm)
  File "/usr/local/lib/python2.7/dist-packages/pdfminer/pdfinterp.py", line 843, in render_contents
    self.init_resources(resources)
  File "/usr/local/lib/python2.7/dist-packages/pdfminer/pdfinterp.py", line 347, in init_resources
    self.fontmap[fontid] = self.rsrcmgr.get_font(objid, spec)
  File "/usr/local/lib/python2.7/dist-packages/pdfminer/pdfinterp.py", line 195, in get_font
    font = self.get_font(None, subspec)
  File "/usr/local/lib/python2.7/dist-packages/pdfminer/pdfinterp.py", line 186, in get_font
    font = PDFCIDFont(self, spec)
  File "/usr/local/lib/python2.7/dist-packages/pdfminer/pdffont.py", line 654, in __init__
    StringIO(self.fontfile.get_data()))
  File "/usr/local/lib/python2.7/dist-packages/pdfminer/pdffont.py", line 375, in __init__
    (name, tsum, offset, length) = struct.unpack('&gt;4sLLL', fp.read(16))
struct.error: unpack requires a string argument of length 16
</code></pre>
<p>While the similar <a href="https://yadi.sk/i/Z37JK5S9xZeoX" rel="nofollow noreferrer">file (1.pdf)</a> doesn't cause a problem.</p>
<p>I can't find any information about the error. I added an <a href="https://github.com/euske/pdfminer/issues/144" rel="nofollow noreferrer">issue</a> on the pdfminer GitHub repository, but it remained unanswered. Can someone explain to me why this is happening? What can I do to parse <a href="https://yadi.sk/i/2vABlTaexZerg" rel="nofollow noreferrer">2.pdf</a>?</p>
<hr/>
<p><strong>Update</strong>: I get a similar error with <code>BytesIO</code> instead of <code>StringIO</code> after <a href="https://github.com/euske/pdfminer#how-to-install" rel="nofollow noreferrer">installing pdfminer</a> directly from the GitHub repository.</p>
<pre><code>    $ pdf2txt.py 2.pdf 
Traceback (most recent call last):
  File "/home/danil/projects/python/pdfminer-source/env/bin/pdf2txt.py", line 116, in &lt;module&gt;
    if __name__ == '__main__': sys.exit(main(sys.argv))
  File "/home/danil/projects/python/pdfminer-source/env/bin/pdf2txt.py", line 110, in main
    interpreter.process_page(page)
  File "/home/danil/projects/python/pdfminer-source/env/local/lib/python2.7/site-packages/pdfminer/pdfinterp.py", line 839, in process_page
    self.render_contents(page.resources, page.contents, ctm=ctm)
  File "/home/danil/projects/python/pdfminer-source/env/local/lib/python2.7/site-packages/pdfminer/pdfinterp.py", line 850, in render_contents
    self.init_resources(resources)
  File "/home/danil/projects/python/pdfminer-source/env/local/lib/python2.7/site-packages/pdfminer/pdfinterp.py", line 356, in init_resources
    self.fontmap[fontid] = self.rsrcmgr.get_font(objid, spec)
  File "/home/danil/projects/python/pdfminer-source/env/local/lib/python2.7/site-packages/pdfminer/pdfinterp.py", line 204, in get_font
    font = self.get_font(None, subspec)
  File "/home/danil/projects/python/pdfminer-source/env/local/lib/python2.7/site-packages/pdfminer/pdfinterp.py", line 195, in get_font
    font = PDFCIDFont(self, spec)
  File "/home/danil/projects/python/pdfminer-source/env/local/lib/python2.7/site-packages/pdfminer/pdffont.py", line 665, in __init__
    BytesIO(self.fontfile.get_data()))
  File "/home/danil/projects/python/pdfminer-source/env/local/lib/python2.7/site-packages/pdfminer/pdffont.py", line 386, in __init__
    (name, tsum, offset, length) = struct.unpack('&gt;4sLLL', fp.read(16))
struct.error: unpack requires a string argument of length 16
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>TL; DR</strong></p>
<p>Thanks to @mkl and @hynecker for the extra info...  With that I can confirm this is a bug in pdfminer and your PDF.  Whenever pdfminer tries to get embedded file streams (e.g. font definitions), it is picking up the last one in the file before an <code>endobj</code>.  Sadly, not all PDFs rigorously add the end tag and so pdfminer should be resilient to this.</p>
<p><strong>Quick fix for this issue</strong></p>
<p>I've created a patch - which has been submitted as a pull request on github.  See <a href="https://github.com/euske/pdfminer/pull/159" rel="nofollow">https://github.com/euske/pdfminer/pull/159</a>.</p>
<p><strong>Detailed diagnosis</strong></p>
<p>As mentioned in the other answers, the reason you're seeing this is that you're not getting the expected number of bytes from the stream as pdfminer is unpacking the data.  But why?</p>
<p>As you can see in your stack trace, pdfminer (rightly) spots that it has a CID font to process.  It then goes on to process the embedded font file as a TrueType font (in <code>pdffont.py</code>).  It tries to parse the associated stream (stream ID 18) by reading out a set of binary tables.</p>
<p>This doesn't work for <code>2.pdf</code> because it has a text stream.  You can see this by running <code>dumppdf -b -i 18 2.pdf</code>.  I've put the start here:</p>
<pre><code>/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo &lt;&lt; /Registry (Adobe) /Ordering (UCS) /Supplement 0
&gt;&gt; def /CMapName /Adobe-Identity-UCS def
...
</code></pre>
<p>So, garbage in, garbage out...  Is this a bug in your file or pdfminer?  Well, the fact that other readers can handle it made me suspicious.</p>
<p>Digging around a little more, I see that this stream is <strong>identical</strong> to stream ID 17, which is the cmap for the <code>ToUnicode</code> field.  A quick look at the <a href="http://www.adobe.com/devnet/pdf/pdf_reference.html" rel="nofollow">PDF spec</a> shows that these cannot be the same.</p>
<p>Digging in to the code further, I see that all streams are getting the same data.  Oops!  This is the bug.  The cause appears to be related to the fact that this PDF is missing some end tags - as noted by @hynecker.</p>
<p>The fix is to return the right data for each stream.  Any other fix to just swallow the error will result in bad data being used for all streams and so, for example, incorrect font definitions.</p>
<p>I believe the attached patch will fix your problem and should be safe to use in general.</p>
</div>
<div class="post-text" itemprop="text">
<p>I fixed your problem in the source code, and I try on your file <code>2.pdf</code> to make sure it worked.</p>
<p>In the file <a href="https://github.com/euske/pdfminer/blob/master/pdfminer/pdffont.py" rel="nofollow">pdffont.py</a> I replaced:</p>
<pre><code>class TrueTypeFont(object):

    class CMapNotFound(Exception):
        pass

    def __init__(self, name, fp):
        self.name = name
        self.fp = fp
        self.tables = {}
        self.fonttype = fp.read(4)
        (ntables, _1, _2, _3) = struct.unpack('&gt;HHHH', fp.read(8))
        for _ in xrange(ntables):
            (name, tsum, offset, length) = struct.unpack('&gt;4sLLL', fp.read(16))
            self.tables[name] = (offset, length)
        return
</code></pre>
<p>by this:</p>
<pre><code>class TrueTypeFont(object):

    class CMapNotFound(Exception):
        pass

    def __init__(self, name, fp):
        self.name = name
        self.fp = fp
        self.tables = {}
        self.fonttype = fp.read(4)
        (ntables, _1, _2, _3) = struct.unpack('&gt;HHHH', fp.read(8))
        for _ in xrange(ntables):
            fp_bytes = fp.read(16)
            if len(fp_bytes) &lt; 16:
                break
            (name, tsum, offset, length) = struct.unpack('&gt;4sLLL', fp_bytes)
            self.tables[name] = (offset, length)
        return
</code></pre>
<p><strong>Explanations</strong></p>
<p>@Nabeel Ahmed was right</p>
<blockquote>
<p>The foramt string &gt;4sLLL requires 16 bytes size of buffer, which is specified correctly to fp.read to read 16 bytes at a time.</p>
<p>So, the problem can only be with the buffer stream it's reading i.e. the content of your specific PDF file.</p>
</blockquote>
<p>In the code we see that <code>fp.read(16)</code> are made in a loop without any check.Thus, we don't know for sure if it successfully read it all. It could for instance reached an <code>EOF</code>.</p>
<p>To avoid this problem, I just <code>break</code> out of the for loop when this kind of problem appears. </p>
<pre><code>    for _ in xrange(ntables):
        fp_bytes = fp.read(16)
        if len(fp_bytes) &lt; 16:
            break
</code></pre>
<p>In any <em>regular</em> cases, it shouldn't change anything anyway.</p>
<p>I will try to do a pull request on github, but I'm not even sure it will be accepted so I suggest you do a monkey patch for now and modify your <code>/home/danil/projects/python/pdfminer-source/env/local/lib/python2.7/site-packages/pdfminer/pdffont.py</code> file right now.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is really an invalid PDF because there are some missing keywords <strong>endobj</strong> after three <em>indirect objects</em>. (object 5, 18 and 22)</p>
<blockquote>
<p>The definition of an <strong>indirect object</strong> in a PDF file shall consist of its object number and generation number (separated by white space), followed by the value of the object bracketed between the keywords <strong>obj</strong> and <strong>endobj</strong>. 
  (chapter 7.3.10 in <a href="http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/pdf/pdfs/PDF32000_2008.pdf" rel="nofollow">PDF reference</a>)</p>
</blockquote>
<p>The example 2.pdf is a simple PDF 1.3 version that uses a simple uncompressed cross reference and uncompressed object separators.  The failure can be easily found by grep command and by a general file viewer that the PDF has 22 indirect objects. The pattern " obj" is found correctly exactly 22 times (never accidentally in a string object or in a stream, fortunately for simplicity), but the keyword <em>endobj</em> is three times missing.</p>
<pre><code>$ grep --binary-files=text -B1 -A2 -E " obj|endobj" 2.pdf
...
18 0 obj
&lt;&lt; /Length 451967/Length1 451967/Filter [/FlateDecode] &gt;&gt; 
stream
...
endstream                 % # see the missing "endobj" here
17 0 obj
&lt;&lt; /Length 12743 /Filter [/FlateDecode] &gt;&gt; 
stream
...
endstream
endobj
...
</code></pre>
<p>Similarly the object 5 has no <em>endobj</em> before object 1 and the object 22 has no <em>endobj</em> before object 21.</p>
<p>It is known that broken cross references in PDF can be and should be usually reconstructed by obj/endobj keywords (see the PDF reference, chapter C.2) Some applications do probably vice-versa fix missing endobj if cross references are correct, but it is no written advice.</p>
</div>
<div class="post-text" itemprop="text">
<p>The last error message tells you a lot:</p>
<blockquote>
<p>File "/usr/local/lib/python2.7/dist-packages/pdfminer/pdffont.py", line 375, in </p>
<p><strong>init</strong>
      (name, tsum, offset, length) = struct.unpack('&gt;4sLLL', fp.read(16))
  struct.error: unpack requires a string argument of length 16</p>
</blockquote>
<p>You can easily debug what is going on, for example, by putting necessary debug statements exactly in <a href="https://github.com/euske/pdfminer/blob/master/pdfminer/pdffont.py" rel="nofollow">pdffont.py</a> file. My guess is that there is something special about your pdf contents. Judging by the method name - <code>TrueTypeFont</code> - which throws the error message, there is some incompatibility with the font type.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let start with explaining the statement where you're getting exception:</p>
<pre><code>struct.unpack('&gt;4sLLL', fp.read(16))
</code></pre>
<p>where the synopsis is:</p>
<p><code>struct.unpack(fmt, buffer)</code> </p>
<blockquote>
<p>The method <a href="https://docs.python.org/3/library/struct.html#struct.unpack" rel="nofollow noreferrer"><code>unpack</code></a>, unpacks from the buffer <code>buffer</code> (which
  presumably earlier  packed by <code>pack(fmt, ...)</code>) according to the
  <a href="https://docs.python.org/3/library/struct.html#struct-format-strings" rel="nofollow noreferrer"><strong>format string</strong></a> <code>fmt</code>. The result is a tuple even if it
  contains exactly one item. The buffer’s size in bytes must match the
  size required by the format, as reflected by calcsize().</p>
</blockquote>
<p>The most common case is, wrong number of bytes (<code>16</code>) for the format used (<code>&gt;4sLLL</code>) - for example, for a format expecting 4 bytes, you have specified 3 bytes:</p>
<pre><code>(name, tsum, offset, length) = struct.unpack('BH', fp.read(3))
</code></pre>
<p>for this you'll get</p>
<pre><code>struct.error: unpack requires a string argument of length 4
</code></pre>
<p>The reason - the format struct ('BH') expects 4 bytes i.e. when we pack something using 'BH' format it'll occupy 4 bytes of memory.
A good explanation <a href="https://stackoverflow.com/questions/2611858/struct-error-unpack-requires-a-string-argument-of-length-4/2612851#2612851">here</a>.</p>
<hr/>
<p>To clarify it further - let's look into the <code>&gt;4sLLL</code> format string. To verify the size <code>unpack</code> 'd be expecting for the buffer (the bytes you're reading from the PDF file). Quoting from docs:</p>
<blockquote>
<p>The buffer’s size in bytes must match the size required by the format,
  as reflected by calcsize().</p>
</blockquote>
<pre><code>&gt;&gt;&gt; import struct 
&gt;&gt;&gt; struct.calcsize('&gt;4sLLL')
16
&gt;&gt;&gt; 
</code></pre>
<p>To this point we can say there's nothing wrong with the statement:</p>
<pre><code>(name, tsum, offset, length) = struct.unpack('&gt;4sLLL', fp.read(16))
</code></pre>
<p>The foramt string <code>&gt;4sLLL</code> requires 16 bytes size of buffer, which is specified correctly to fp.read to read 16 bytes at a time.</p>
<p>So, the problem can only be with the buffer stream it's reading i.e. the content of your specific PDF file.</p>
<hr/>
<p>Can be a bug - as per this <a href="https://github.com/nexB/scancode-toolkit/issues/289#issuecomment-238850139" rel="nofollow noreferrer">comment</a>:</p>
<blockquote>
<p>This is a bug in the upstream PDFminer by @euske There seems to be
  patches for this so it should be an easy fix. Beyond this I also need
  to strengthen the pdf parsing such that we never error out from a
  failed parse</p>
</blockquote>
<p>I'll edit the question it I find something helpful to add here - a solution, or a patch.</p>
</div>
<div class="post-text" itemprop="text">
<p>In case you still get some struct errors after applying Peter's patch, especially when parsing many files in one script's run (using os.listdir), try changing resource manager caching to false.</p>
<pre><code>rsrcmgr = PDFResourceManager(caching=False)
</code></pre>
<p>It helped me to get rid of the rest of errors after applying above solutions.</p>
</div>
<span class="comment-copy">I suspect you've hit the end of the file before the parser expected it due to a bug.  Try running <a href="https://euske.github.io/pdfminer/#dumppdf" rel="nofollow noreferrer">dumppdf.py</a> instead and see if there is obviously bad data just before this error.</span>
<span class="comment-copy">this is what I get <a href="https://gist.github.com/danmash/a8b42f72787ca0c329a0b2c2ae6aeea3" rel="nofollow noreferrer">gist.github.com/danmash/a8b42f72787ca0c329a0b2c2ae6aeea3</a></span>
<span class="comment-copy">I think you also want to use the <code>-a</code> option too...</span>
<span class="comment-copy">so.. can you explain what can I do with this <a href="https://gist.github.com/danmash/d1f4e41385e71c49382e0cfb171ee857" rel="nofollow noreferrer">dump</a> ?</span>
<span class="comment-copy">Looking at the stack trace, you can see that it died processing a font.  There are only 2 of that type in the dump and both the streams used by these fonts are present, so it's not obvious what's wrong.</span>
<span class="comment-copy">Are you sure about your analysis of the PDF? I inspected 2.pdf using Adobe Acrobat Preflight, in particular the object 18, and it looks like <a href="https://i.stack.imgur.com/rvaLQ.png" rel="nofollow noreferrer">this</a>, i.e. in particular the contents clearly look like a font file. Using Preflight to check for PDF syntax errors, it merely warns about missing <b>FontName</b> entries...</span>
<span class="comment-copy">Interesting...  I used dumppdf.  Maybe there's a bug in its stream handling, which is also affecting pdfminer?</span>
<span class="comment-copy">@mkl OK - so digging in to the stream parsing, I see that it always returns the last stream, no matter what ID was requested.  This is a bug.  I'll dig a little more and update my answer...</span>
<span class="comment-copy">Ah, the joy of bug hunting... ;)</span>
<span class="comment-copy">Yes it is simple enough and correct if a new indirect  object immediately follows after the the missing endobj. It could be a little problematic to be accepted as a patch for pdfminer, if a more general solution will be necessary later, but for a current status of pdfminer it seems good enough. I  added a word "broken" to the patch, for the case it must be refactored later.</span>
<span class="comment-copy">Good catch. So there are issues both in pdfminer and the pdf... ;)</span>
<span class="comment-copy">@mkl Do you think that a rule can be quoted from the documentation to explain that pdfminer is not a "conforming reader" according to the PDF reference? I would like to write a patch, but I know that some strange implementations are correct and should not be fixed. I see a <a href="https://feliam.wordpress.com/2010/08/14/pdf-a-broken-spec/#div-comment-122" rel="nofollow noreferrer">discussion</a> with Leonard Rosenthol - PDF Standards Architect in Adobe - "... as long as the object that it points to is valid then it can be anywhere – even in the middle of an uncompressed stream"</span>
<span class="comment-copy">@hynekcer I don't think we need to fall back on xrefs.  pdfminer is actually parsing at the (indirect) object level and so only needs to know when one ends. Since (I believe) indirect objects cannot be nested, you can detect and use the next obj tag to be an implicit endobj.  Coding that up has worked on these 2 files for me.</span>
<span class="comment-copy">Can you send a link to a working branch to check it? I can find some counterexamples for tests until it is ok. I think to create some conditional breaks to terminate the main loop <code>while not self.results:</code> in psparser.PSStackParser.nextobject(). Indirect object can contain indirect objects and it is not a problem because the referencing is postponed until  you call the <code>resolve()</code> method of the indirect object. The possibilities are <code>any_object [ comment | whitespace ]* [ stream .. endstream ] [ comment | whitespace ]* { endobj | other_token }</code>. Other token denotes a lost endobj.</span>
<span class="comment-copy">... the world is not perfect.)</span>
