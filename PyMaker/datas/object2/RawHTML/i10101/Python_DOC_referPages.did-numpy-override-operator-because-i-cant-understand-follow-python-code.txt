<div class="post-text" itemprop="text">
<pre><code>image_size = 28
num_labels = 10

def reformat(dataset, labels):
  dataset = dataset.reshape((-1, image_size * image_size)).astype(np.float32)
  # Map 0 to [1.0, 0.0, 0.0 ...], 1 to [0.0, 1.0, 0.0 ...]
  labels = (np.arange(num_labels) == labels[:,None]).astype(np.float32)
  return dataset, labels
train_dataset, train_labels = reformat(train_dataset, train_labels)
valid_dataset, valid_labels = reformat(valid_dataset, valid_labels)
test_dataset, test_labels = reformat(test_dataset, test_labels)
print('Training set', train_dataset.shape, train_labels.shape)
print('Validation set', valid_dataset.shape, valid_labels.shape)
print('Test set', test_dataset.shape, test_labels.shape)
</code></pre>
<p>What does this line mean?</p>
<pre><code>labels = (np.arange(num_labels) == labels[:,None]).astype(np.float32)
</code></pre>
<p>code is from <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/udacity/2_fullyconnected.ipynb" rel="nofollow">https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/udacity/2_fullyconnected.ipynb</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In numpy, the <code>==</code> operator means something different when comparing two numpy arrays (as is being done in that line of note), so yes, it is overloaded in that sense. It compares the two numpy arrays elementwise and returns a boolean numpy array of the same size as the two inputs. The same is true for other comparisons like <code>&gt;=</code>, <code>&lt;</code>, etc.</p>
<p>E.g. 
</p>
<pre><code>import numpy as np
print(np.array([5,8,2]) == np.array([5,3,2]))
# [True False True]
print((np.array([5,8,2]) == np.array([5,3,2])).astype(np.float32))
# [1. 0. 1.]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For Numpy arrays the <code>==</code> operator is a element-wise operation which returns a boolean array. The <code>astype</code> function transforms the boolean values <code>True</code> to <code>1.0</code> and <code>False</code> to <code>0.0</code> as stated in the comment.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/expressions.html#value-comparisons" rel="nofollow">https://docs.python.org/3/reference/expressions.html#value-comparisons</a> describes value comparisons like <code>==</code>.  While the default comparison is an <code>identity</code> <code>x is y</code>, it first checks if either argument implements an <code>__eq__</code> method.  Numbers, lists, and dictionaries implement their own version.  And so does <code>numpy</code>.</p>
<p>What's unique about the <code>numpy</code> <code>__eq__</code> is that it does, if possible an element by element comparison, and returns a boolean array of the same size.</p>
<pre><code>In [426]: [1,2,3]==[1,2,3]
Out[426]: True
In [427]: z1=np.array([1,2,3]); z2=np.array([1,2,3])
In [428]: z1==z2
Out[428]: array([ True,  True,  True], dtype=bool)
In [432]: z1=np.array([1,2,3]); z2=np.array([1,2,4])
In [433]: z1==z2
Out[433]: array([ True,  True, False], dtype=bool)
In [434]: (z1==z2).astype(float)     # change bool to float
Out[434]: array([ 1.,  1.,  0.])
</code></pre>
<p>A common SO question is 'why do I get this ValueError?'</p>
<pre><code>In [435]: if z1==z2: print('yes')
...
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</code></pre>
<p>That's because the comparison produces this array which has more than one True/False value.</p>
<p>Comparison of floats is also a common problem. Check out <code>isclose</code> and <code>allclose</code> it that issue comes up.</p>
</div>
