<div class="post-text" itemprop="text">
<p>I am writing an embedded application that reads data from a set of sensors and uploads to a central server. This application is written in Python and runs on a Rasberry Pi unit. </p>
<p>The data needs to be collected every 1 minute, however, the Internet connection is unstable and I need to buffer the data to a non volatile storage (SD-card) etc. whenever there is no connection. The buffered data should be uploaded as and when the connection comes back.</p>
<p>Presently, I'm thinking about storing the buffered data in a SQLite database and writing a cron job that can read the data from this database continuously and upload.</p>
<p>Is there a python module that can be used for such feature? </p>
</div>
<div class="post-text" itemprop="text">
<p>If you mean a module to work with SQLite database, check out <a href="http://www.sqlalchemy.org/" rel="nofollow">SQLAlchemy</a>.</p>
<p>If you mean a module which can do what cron does, check out <a href="https://docs.python.org/3/library/sched.html" rel="nofollow">sched</a>, a python event scheduler.</p>
<p>However, this looks like a perfect place to implemet a task queue --using a dedicated task broker (rabbitmq, redis, zeromq,..), or python's <a href="https://docs.python.org/3/library/threading.html" rel="nofollow">threads</a> and <a href="https://docs.python.org/2/library/queue.html" rel="nofollow">queues</a>. In general, you want to submit an upload task, and worker thread will pick it up and execute, while the task broker handles retries and failures. All this happens asynchronously, without blocking your main app.</p>
<p>UPD: Just to clarify, you don't need the database if you use a task broker, because a task broker stores the tasks for you. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a python module that can be used for such feature? </p>
</blockquote>
<p>I'm not aware of any readily available module, however it should be quite straight forward to build one. Given your requirement:</p>
<blockquote>
<p>the Internet connection is unstable and I need to buffer the data to a non volatile storage (SD-card) etc. whenever there is no connection. The buffered data should be uploaded as and when the connection comes back.</p>
</blockquote>
<p>The algorithm looks something like this (pseudo code):</p>
<pre><code># buffering module
data = read(sensors)
db.insert(data)

# upload module
# e.g. scheduled every 5 minutes via cron
data = db.read(created &gt; last_successful_upload)
success = upload(data)
if success:
    last_successful_upload = max(data.created)
</code></pre>
<p>The key is to seperate the buffering and uploading concerns. I.e. when reading data from the sensor don't attempt to immediately upload, always upload from the scheduled module. This keeps the two modules simple and stable.</p>
<p>There are a few edge cases however that you need to concern yourself with to make this work reliably:</p>
<ol>
<li>insert data while uploading is in progress</li>
<li>SQLlite doesn't support being accessed from multiple processes well</li>
</ol>
<p>To solve this, you might want to consider another database, or create multiple SQLite databases or even flat files for each batch of uploads. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is only database work. You can create a master and slave databases in different locations and if one is not on the network, will run with the last synched info.</p>
<p>And when the connection came back hr merge all the data.</p>
<p>Take a look in this <a href="https://stackoverflow.com/questions/2366018/how-to-re-sync-the-mysql-db-if-master-and-slave-have-different-database-incase-o">answer</a> and search for master and slave database</p>
</div>
<span class="comment-copy">a task queue based on zeromq can be a solution.</span>
<span class="comment-copy">after googling a bit, I can see that ZeroMQ seems to be a good somution for a raspbery pi. An example of how to set it up: <a href="http://www.pihomeserver.fr/en/2014/01/15/raspberry-pi-home-server-le-message-broker-zeromq-pour-lier-vos-machines/" rel="nofollow noreferrer">pihomeserver.fr/en/2014/01/15/â€¦</a></span>
<span class="comment-copy">Thanks @miraculixx, that's a good advise. I will probably go with separate files.</span>
<span class="comment-copy">it is on an embedded system, with possible tens or hundred of  master/slaves to configure. It is overkill</span>
