<div class="post-text" itemprop="text">
<p>I am trying to get a running median for a number of integers. For example: 6 elements will come one by one, let say 12,4,5,3,8,7  for which running median at each input is 12,8,5,4.5,6,5 respectively. I wrote a python code but it seems to give incorrect answer. Help is appreciated .</p>
<pre><code>n = int(raw_input().strip())
s=[]
for i in xrange(n):
    a=int(raw_input())
    if len(s)==0: 
        s.append(a)
        print "%.1f" % a
    else:
        for j in xrange(len(s)):
            if a&lt;s[j]:
                s.insert(j,a)
        if a&gt;=s[-1]:
            s.append(a)
        if len(s)%2==0:
            print "%.1f" % float((s[len(s)/2] + s[len(s)/2 -1])/2.0)
        else:
            print  "%.1f" % s[len(s)/2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Read the comments embedded in the code below - </p>
<pre><code>n = int(raw_input().strip())
s=[]
for i in xrange(n):
    a=int(raw_input())
    if len(s)==0:
        s.append(a)
        print "%.1f" % a
    else:
        for j in xrange(len(s)):
            if a&lt;s[j]:
                s.insert(j,a)
                break  # break after insertion to avoid multiple insertions
        else:  # Read https://docs.python.org/3/reference/compound_stmts.html#for
            s.append(a)

        if len(s)%2==0:
            print "%.1f" % float((s[len(s)/2] + s[len(s)/2 -1])/2.0)
        else:
            print  "%.1f" % s[len(s)/2]
</code></pre>
<hr/>
<p>A more <em>Pythonic</em> (sic) way of doing the same - </p>
<pre><code>import bisect

n = int(raw_input().strip())
s=[]
for i in xrange(n):
    a=int(raw_input())

    bisect.insort_left(s, a)

    quotient, remainder = divmod(len(s), 2)
    if remainder:
        print  "%.1f" % s[quotient]
    else:
        print "%.1f" % ((s[quotient - 1] + s[quotient])/2.0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>n = int(raw_input().strip())
s=[]
for i in xrange(n):
    a=int(raw_input())
    if len(s)==0: 
        s.append(a)
        print "%.1f" % a
    else:
        for j in xrange(len(s)):
            if a&lt;s[j]:
                s.insert(j,a)
                break # inserted this break
        if a&gt;=s[-1]:
            s.append(a)
        if len(s)%2==0:
            print "%.1f" % float((s[len(s)/2] + s[len(s)/2 -1])/2.0)
        else:
            print  "%.1f" % s[len(s)/2]
</code></pre>
<p>This was the output and input:</p>
<pre><code> 6
 12
12.0
 4
8.0
 5
5.0
 3
4.5
 8
5.0
 7
6.0
</code></pre>
<p>The issue was in your <code>for j in xrange(len(s))</code> you were inserting as long as a was less then the next value. You didn't just insert once, that added more values than you wanted into the list. Adding a <code>break</code> will only insert once, at the time it finds the first spot it belongs too. </p>
</div>
<span class="comment-copy">That's 6 outputs in the question. You misread 4.5 as two outputs.</span>
<span class="comment-copy">@user2357112 you are correct, I need to sleep more, will edit.</span>
