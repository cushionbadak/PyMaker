<div class="post-text" itemprop="text">
<p>Look at following code and please explain why the <code>str.count('')</code> method and <code>len(str)</code> function is giving two different outputs.</p>
<pre><code>a=''
print(len(a))
print(a.count(''))
</code></pre>
<p>Output:</p>
<pre><code>0
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>str.count()</code> counts non-overlapping occurrences of the substring:</p>
<blockquote>
<p>Return the number of non-overlapping occurrences of substring <em>sub</em>.</p>
</blockquote>
<p>There is exactly one such place where the substring <code>''</code> occurs in the string <code>''</code>: right at the start. So the count <em>should</em> return <code>1</code>.</p>
<p>Generally speaking, the empty string will match at <em>all positions</em> in a given string, including right at the start and end, so the count should <em>always</em> be the length plus 1:</p>
<pre><code>&gt;&gt;&gt; (' ' * 100).count('')
101
</code></pre>
<p>That's because empty strings are considered to exist between all the characters of a string; for a string length 2, there are 3 empty strings; one at the start, one between the two characters, and one at the end.</p>
<p>So yes, the results are different and they are entirely correct.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>.count('')</code> counts the number of locations of zero-length strings. You could also think of this as the number of possible cursor positions.</p>
<pre><code>"test".count('')

 t e s t
^ ^ ^ ^ ^
</code></pre>
<p>Instead of counting the number of characters (like <code>len(str)</code>), you're counting the number of anti-characters.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html?highlight=count#bytes.count" rel="nofollow noreferrer">Documentation</a>:</p>
<blockquote>
<p>Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.</p>
</blockquote>
<p>If we have a look at the <a href="https://github.com/python/cpython/blob/bea57060c863d0c3474c79350bd9c557f2ff0e7c/Objects/bytes_methods.c#L670" rel="nofollow noreferrer">implementation</a>, we find that it call the function <code>stringlib_count</code> (<a href="https://github.com/python/cpython/blob/master/Objects/stringlib/count.h" rel="nofollow noreferrer">source</a>) which just goes on and return the length of the string plus one, when the length of the sub is zero:</p>
<pre><code>if (sub_len == 0)
    return (str_len &lt; maxcount) ? str_len + 1 : maxcount;
</code></pre>
<p>(<a href="https://github.com/python/cpython/blob/master/Objects/stringlib/count.h#L16" rel="nofollow noreferrer">source</a>)</p>
<p><em>Note</em>: <code>maxcount</code> is set to largest positive value of <a href="https://stackoverflow.com/questions/2550774/what-is-size-t-in-c#2550799">size_t</a>.</p>
<hr/>
<p>Of course, that is just a short cirtcuit. If we skip that check, the code goes on to call <a href="https://github.com/python/cpython/blob/master/Objects/stringlib/count.h#L19" rel="nofollow noreferrer">FASTSEARCH</a>.</p>
<p>How is <a href="https://github.com/python/cpython/blob/master/Objects/stringlib/fastsearch.h#L164" rel="nofollow noreferrer">FASTSHEARCH implemented</a>? It goes on a <a href="https://github.com/python/cpython/blob/master/Objects/stringlib/fastsearch.h#L217" rel="nofollow noreferrer">loop</a>, checking for every position if the string matches the sub at that position.</p>
<p>Since it is looking for an empty string, it will say that it matches in every position (at every position, it finds no characters that differ, up to the length of the sub).</p>
<p>Remember that it is looking in the <em>inclusive</em> range from start to end. Meaning that it will look in every position in the string, that is:</p>
<ul>
<li>The start (before the first character)</li>
<li>Between each character pair (after each character, before the next one)</li>
<li>The end (after the last character)</li>
</ul>
<p>That is one position per character (before each character) plus one (the end). Or if you prefer, it is one position per character (after each character) plus one (the start). In either case, it will return the length of the string plus one. The developers short circuited it to avoid doing the loop.</p>
</div>
<span class="comment-copy">Why <i>should</i> they give the same output? There is one empty string in your empty string. An empty string has length 0.</span>
<span class="comment-copy">So, why a='  ' &lt;---(Here i gave two spaces)is giving 3 empty string which length is 2? Thanks for your reply @MartijnPieters</span>
<span class="comment-copy">Because there is an empty string 'between' the start and the first space, another one between the first and the second space, and one last one between the last space and the end.</span>
<span class="comment-copy">Thanks A lot @Martijn Pieters .... Now I got the clear difference between count() and len() in python .... Thanks a lot again</span>
<span class="comment-copy">I'm not sure if "There is exactly one such place where the substring '' occurs in the string '': right at the start." is the right way to put it. CPython just seems to special case the <code>len(substr) == 0</code> and <a href="https://github.com/python/cpython/blob/master/Objects/stringlib/count.h#L16" rel="nofollow noreferrer">return <code>len(str)+1</code></a></span>
<span class="comment-copy">@JimFasarakis-Hilliard: I'm not sure if you have fully read my answer, but I'm saying exactly what the code there does.</span>
<span class="comment-copy">It's rather unclear to me what <code>count()</code> should return when passed the empty string.  It's a matter of convention how to count the occurrences, and I think it would be reasonable to just throw a <code>ValueError</code> for this case.  "Non-overlapping" means that the intersection of two occurrences is the empty string, so if you have two occurrences of the empty string at index 0, they are actually non-overlapping.</span>
<span class="comment-copy">Yes yes I see that you did point out the <code>len + 1</code> part; I'm just wandering if there's merit for pointing out that no counting <i>actually</i> takes place when <code>substr</code> is empty (but, it's an implementation detail, so, maybe not).</span>
<span class="comment-copy">@MartijnPieters Actually, I think there is more to it.  I don't think it's possible to implement this without making the empty string a special case one way or the other.  You'd usually find the first place where a string matches, increase your counter, and then continue searching where the match ends.  For the empty string, this would give an infinite loop, consistent with my argument above.</span>
