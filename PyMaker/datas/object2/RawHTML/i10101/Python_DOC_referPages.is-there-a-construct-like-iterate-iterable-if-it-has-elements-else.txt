<div class="post-text" itemprop="text">
<p>Is there a more compact way to iterate an iterable if it has elements, or do something else if it hasn't?</p>
<p>My "problem" is in Python but I'd be interested in other languages as well.</p>
<p>Currently I test the number of elements first:</p>
<pre><code>In [1]: l=[]

In [2]: if l:
   ...:     for e in l:
   ...:         print(e)
   ...: else:
   ...:     print("else")
   ...:
else
</code></pre>
<p>The <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow"><code>for</code> statement has an <code>else</code></a>:</p>
<pre><code>In [2]: for e in []:
   ...:     print(e)
   ...: else:
   ...:     print("else")
   ...:
else
</code></pre>
<p>but its "suite" (block) is also executed when the iteration is completed:</p>
<pre><code>In [1]: for e in [1,2,3]:
   ...:     print(e)
   ...: else:
   ...:     print("else")
   ...:
1
2
3
else
</code></pre>
<p>I realize there is not much to gain here (one line and indent level) but I am curious if something like this exists.</p>
</div>
<div class="post-text" itemprop="text">
<p>Most of the time you just test for length and exit early:</p>
<pre><code>if not l:
    # empty case
    return  # or raise exception
</code></pre>
<p>At any rate, because iteration <em>will not take place</em> on an empty list, the following is also sufficient, no <code>else</code> required:</p>
<pre><code>if not l:
    # empty case
for i in l:
    # only ever executed if there are any elements
</code></pre>
<p>The <code>for ... else</code> suite is only useful for loops that <em>exit early</em>; the <code>else</code> suite is executed for all loops that <em>completed</em>. If a <code>break</code> was used the <code>else</code> is skipped. This makes it unsuitable for detecting empty sequences, as iteration on those completes successfully regardless of the number of elements in the absence of a <code>break</code> statement.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you ask for other languages, here is Squeak/Pharo Smalltalk, since the paradigms are sufficiently close to Python:</p>
<p>you would write something like:</p>
<pre><code>aCollection
    ifEmpty: [Transcript cr; show: 'else']
    ifNotEmpty: [aCollection do: [:each | Transcript cr; show: each printString]].
</code></pre>
<p>You could as well create a new method in Collection:</p>
<pre><code>ifNotEmptyDo: aBlock elseDo: elseBlock
    self isEmpty ifTrue: [^elseBlock value].
    ^self do: aBlock
</code></pre>
<p>Then use it like this:</p>
<pre><code>aCollection
    ifNotEmptyDo: [:each | Transcript cr; show: each printString]
    elseDo: [Transcript cr; show: 'else'].
</code></pre>
<p>Note that isEmpty is defined as <code>^self size = 0</code> by default, which is an heresy for possibly lazy or infinite collections... So I propose this new definition:</p>
<pre><code>isEmpty
    self do: [:each |^false].
    ^true
</code></pre>
<p>Just to see that testing emptyness or performing a loop is more or less the same task ;)</p>
<p><strong>Conclusion</strong>, in Smalltalk there is a very low level of syntactic sugar.<br/>
The block closures enable differed, conditional, or repeated evaluation.<br/>
Thus all the constructs like branches and loops and combinations of these are just ordinary messages taking block closures as parameters and you can add your own construct at will.<br/>
This facility is often abused with overkill selectors for a very small added value, so the need for new constructs should allways be put in balance with the maintenance cost (more methods to implement, test, and learn for a newcomer, etc...). Let's remember: "<em>Small is beautiful</em>".</p>
</div>
<span class="comment-copy">Most of the time you just test for length and exit early: <code>if not l: # empty case, return</code>.</span>
<span class="comment-copy">I've included test output with the first example to double-check the issue you pointed out before your edit...</span>
<span class="comment-copy"><i>"I'd be interested in other languages as well"</i> â€“ there will be widely differing approaches to this in various languages, it's a bit out of scope to talk about all of them here.</span>
<span class="comment-copy">You are probably right about the scope, it may be limited to constructs that exists for the exact purpose (e.g. an <code>else</code> that would behave differently).</span>
<span class="comment-copy">Too obvious :-)</span>
