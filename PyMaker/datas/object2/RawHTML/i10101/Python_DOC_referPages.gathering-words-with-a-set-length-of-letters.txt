<div class="post-text" itemprop="text">
<p>Is there a way to group words with a given length of letters in Python?</p>
<p>I started working on this function:</p>
<pre><code>lenght_words(a,b,text):
returnlist = []
</code></pre>
<p>in the return list I want the words which have length:</p>
<p>a &lt;= lenght &lt;= b</p>
<p>so I was thinking:</p>
<ol>
<li>split the lines of the text in order to have the function operating on differents lines of the text</li>
<li>remove the punctuation from the lines</li>
<li>if in a line there are words which have the right lenght, the function must put them in the returnlist with a space between each word (e.g. 'cat dog'), otherwise the function put ''</li>
</ol>
<p>I know there is the <code>splitlines()</code> method, but I don't know how to use it (even after reading about it).</p>
<p>I want to give an example of how the function has to work:</p>
<pre><code>function(6,7,'All in the golden afternoon\nFull leisurely we glide;\nFor  both our oars, with little skill,\nBy little arms are plied.')
</code></pre>
<p>This function should separate the lines:</p>
<blockquote>
<p>All in the golden afternoon</p>
<p>Full leisurely we glide;</p>
<p>For  both our oars,</p>
<p>with little skill,</p>
<p>By little arms are plied.</p>
</blockquote>
<p>--&gt; delete the punctuation and return:</p>
<pre><code>['golden','','little','little']
</code></pre>
<p>I know I have to append the words to the return list, but I don't know how to proceed.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could write a list comprehension like this:</p>
<pre><code>[token for token in s.split(" ") if a &lt;= len(token) &lt;= b]
</code></pre>
<p>It would return all words in variable s (str) with character lengths between a (int) and b (int). An example on how to use it is</p>
<pre><code>s = 'All in the golden afternoon\nFull leisurely we glide;'
s += '\nFor  both our oars, with little skill,\nBy little arms are plied.'
a = 6
b = 7
result = [token for token in s.split(" ") if a &lt;= len(token) &lt;= b]
</code></pre>
<p>where result would be:</p>
<p>['golden', 'little', 'little', 'plied.']</p>
<p>To get rid of the punctuation, just add</p>
<pre><code>import string
s = "".join([char for char in s if char not in string.punctuation])
</code></pre>
<p>above the last line. The results are then:</p>
<p>['golden', 'little', 'little']</p>
<p>Hope this works for you!</p>
<p><strong>EDIT:</strong></p>
<p>If you want to search the different lines separately, I would suggest a solution like this:</p>
<pre><code>import string


def split_by_line_and_find_words_with_length(min, max, s):
    #store result
    result = []

    # separate string lines
    lines = s.splitlines()

    for line in lines:
        # remove punctuation
        l = "".join([char for char in line if char not in string.punctuation])

        # find words with length between a and b
        find = [token for token in l.split(" ") if a &lt;= len(token) &lt;= b]

        # add empty string to result if no match
        if find == []: find.append("")

        # add any findings to result
        result += find

    return result
</code></pre>
<p>With your example string and preferred word lengths this would return ['golden', '', 'little', 'little'].</p>
</div>
<div class="post-text" itemprop="text">
<p>Your were on the right track when you where thinking about ranges. Here is how I would write your function.</p>
<ul>
<li>Create a function with three parameters: <code>start</code> and <code>stop</code> for the range, and <code>sentence</code> for the target sentence.</li>
<li>Inside the function, create a list called <code>word_list</code>.</li>
<li>Iterate over each line in the sentence by splitting the sentence via <code>.splitlines()</code>.</li>
<li>Filter out all punctuation characters from each line you iterate over.</li>
<li>You then iterate over each word in the current line via list comprehension, and test if each word you iterate over is in a given range: <code>tmp = [word for word in line.split() if start &lt;= len(word) &lt;= stop]</code>. Assign the result of the list comprehnsion to a list called <code>tmp</code>.</li>
<li>If the length of <code>tmp</code> is greater than one

<ul>
<li>join each word in <code>tmp</code> by a space and add the joined string to the <code>word_list</code>.</li>
</ul></li>
<li>otherwise, if the <code>tmp</code> list is only one element long

<ul>
<li>Simply add it to the <code>word_list</code></li>
</ul></li>
<li>Otherwise if it is empty

<ul>
<li>Add an empty string to <code>word_list</code></li>
</ul></li>
<li>return <code>word_list</code></li>
</ul>
<p>Using the steps above, here i how I would write your function:</p>
<pre><code># create a function with the parameters `start`, `stop` and `sentence`
# `start` and `stop` are for the range, and `sentence` is the
# target sentence to iterate over.
def group_words_by_length(start: int, stop: int, sentence: str) -&gt; list:
    # import the string module so we can use its punctuation attribute.
    import string

    # create a list to hold words that
    # are in the given `start`-`stop` range
    word_list = []

    # iterate over each line in the sentence
    # using the string attribute `.splitlines()`
    # which splits the string at every new line
    for line in sentence.splitlines():

        # filter out punctuation from
        # every line.
        line = ''.join([char for char in line if char not in string.punctuation])

        # iterate over every word in each line
        # via list comprehension. Inside the list comprehension
        # we only add a word if is is in the given range.
        tmp = [word for word in line.split() if start &lt;= len(word) &lt;= stop]

        # if we found more than one valid word
        # in the current line...
        if len(tmp) &gt; 1:

            # join each word in the
            # list by a space, and add
            # the joined string to the `word_list`.
            tmp = ' '.join(tmp)
            word_list.append(tmp)

        # if we found only
        # one valid word...
        elif len(tmp) == 1:

            # simply add the word
            # to the `word_list`.
            word_list.extend(tmp)

        # otherwise...
        else:
            # add an empty string to the
            # `word_list`.
            word_list.append("")

    # return the `word_list`
    return word_list

# testing of the function with
# your test string.
print(group_words_by_length(6, 7, 'All in the golden afternoon\nFull leisurely we glide;\nFor  both our oars, with little skill,\nBy little arms are plied.'))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>['golden', '', 'little', 'little']
</code></pre>
</div>
<span class="comment-copy">It looks like you want us to write some code for you. While many users are willing to produce code for a coder in distress, they usually only help when the poster has already tried to solve the problem on their own. A good way to demonstrate this effort is to include the code you've written so far, example input (if there is any), the expected output, and the output you actually get (output, tracebacks, etc.). The more detail you provide, the more answers you are likely to receive. Check the <a href="http://stackoverflow.com/tour">FAQ</a> and <a href="http://stackoverflow.com/questions/how-to-ask">How to Ask</a>.</span>
<span class="comment-copy">Very good start. At this point, you should probably use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a> to count the words. Words as keys, count as values. The point of using a defaultdict is you can set a default value (0 here) for words you did not see yet.</span>
<span class="comment-copy">thank you for the help you provided me, the output should be   ['golden','','little','little']                                                                               the function doesn't put '' if no words with the given lenght are found in the line;  so i guess i  have to put a if condition to make it happen, right?</span>
<span class="comment-copy">@erupti0n I'm sorry. What are you asking?</span>
<span class="comment-copy">the output should be ['golden','','little','little'] but the function returns ['golden,'little','little']</span>
<span class="comment-copy">@erupti0n Alright let me know if the function I gave works.</span>
<span class="comment-copy">it works as it should :)</span>
