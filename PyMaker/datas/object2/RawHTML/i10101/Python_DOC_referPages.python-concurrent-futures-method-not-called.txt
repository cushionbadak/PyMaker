<div class="post-text" itemprop="text">
<p>I am running a local django server with the following code: </p>
<pre><code>import concurrent.futures

media_download_manager = concurrent.futures.ProcessPoolExecutor(max_workers=2)

def hello():
    print "hello"


for i in range(1, 1000):
    print "submitting task "
    media_download_manager.map(hello)
</code></pre>
<p>I am initializing a process pool executor to accept tasks with 2 worker threads. The tasks are being submitter but the worker threads handling the submitted tasks do not seem to have triggered. </p>
<p>Following it the console output: </p>
<pre><code>submitting task 1
submitting task 2
submitting task 3
submitting task 4
submitting task 5
submitting task 6
submitting task 7
submitting task 8
submitting task 9
Performing system checks...

System check identified no issues (0 silenced).
October 15, 2016 - 06:09:31
Django version 1.8.4, using settings 'Learn.settings'
Starting development server at http://192.168.1.3:8000/
Quit the server with CONTROL-C.
</code></pre>
<p>What am I missing here ?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you are using <code>map</code> instead of <code>submit</code>. The former is a way similar to the built-in <code>map</code> function to map arguments to a function that you want to run asynchronically on all of them. You used <code>map</code> with <code>i+1</code> instead of an iterable 
(e.g. <code>[i+1]</code>), but don't do that in your case. You are passing only one value to the map.</p>
<p><code>submit</code> however, fires up only one function asynchorincally in your pool. That's exactly what you want to do!</p>
<p>I've modified your example a bit, following is the code. Also consider about
reading if <code>ThreadPoolManager</code>might be favorable in your case instead of
<code>ProcessPoolManager</code> as it seems to be I/O bound (network stuff). But don't catch
me on that.</p>
<pre><code>import concurrent.futures
from time import sleep
from random import random

media_download_manager = concurrent.futures.ProcessPoolExecutor(max_workers=4)

def hello(i):
    be_sleepy = random() * 2
    sleep(be_sleepy)
    print("hello", i)


if __name__ == '__main__':  # protecting funny multiprocessing error on Windows
    for i in range(10):
        print("submitting task", i)
        media_download_manager.submit(hello, i+1)
        # media_download_manager.map(hello, [i+1])  # &lt;--awkward ;), notice additional []
</code></pre>
<p>Example output:</p>
<pre><code>submitting task 0
submitting task 1
submitting task 2
submitting task 3
submitting task 4
submitting task 5
submitting task 6
submitting task 7
submitting task 8
submitting task 9
hello 1
hello 3
hello 6
hello 2
hello 7
hello 9
hello 5
hello 4
hello 8
hello 10
</code></pre>
<p>Also note @ShadowRanger's answer which has a way to determine when all your tasks finished.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map" rel="nofollow">The <code>Executor.map</code> function</a> is intended to pass arguments from an iterable(s) to a mapping function. You didn't provide any iterables so it doesn't run (and your function takes no arguments, so if you had provided iterables, it would have failed when it passed too many arguments).</p>
<p>If you just want to run that function without arguments some number of times, call <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.submit" rel="nofollow"><code>submit</code></a>; <code>map</code> is intended to pass arguments and accumulate results from what it returns, not just run something for side-effects (it's a functional programming tool, and functional code is side-effect free in general).</p>
<p>Fixed code would be:</p>
<pre><code>futures = []
for i in range(1, 1000):
    print "submitting task "
    futures.append(media_download_manager.submit(hello))
concurrent.futures.wait(futures)  # Wait for all tasks to finish
</code></pre>
</div>
