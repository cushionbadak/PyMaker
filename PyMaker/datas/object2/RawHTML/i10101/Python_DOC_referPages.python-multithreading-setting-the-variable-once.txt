<div class="post-text" itemprop="text">
<p>Does the following code thread-safe?<br/>
Will only one/first thread set the variable, set_this_var_only_once?  </p>
<pre><code>set_this_var_only_once = None

def worker():
    global set_this_var_only_once
    if set_this_var_only_once is None:
        set_this_var_only_once = "not None"

for i in range(10):
    t = threading.Thread( target=worker )
    t.daemon=True
    t.start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Absolutely not.</p>
<p>It is quite possible that two threads execute this line before executing the next one:</p>
<pre><code>    if set_this_var_only_once is None:
</code></pre>
<p>After that, both threads will execute the next line:</p>
<pre><code>        set_this_var_only_once = "not None"
</code></pre>
<p>You can use <a href="https://docs.python.org/3/library/threading.html#threading.Lock" rel="nofollow noreferrer">locks</a> to prevent that:</p>
<pre><code>lock = threading.Lock()

def worker():
    lock.acquire()
    if set_this_var_only_once is None:
        set_this_var_only_once = "not None"
    lock.release()
</code></pre>
<p>Only one thread will be able to <em>acquire</em> the lock. If another thread tries to acquire it while it is locked, the call to <code>lock.acquire()</code> will block and wait until the lock is <em>released</em> by the first thread. Then the lock will be acquired by the other thread.</p>
<p>That way it is ensured that the code between <code>lock.acquire()</code> and <code>lock.release()</code> is executed in one thread at a time.</p>
<p><strong>EDIT</strong></p>
<p>As Gerhard pointed in <a href="https://stackoverflow.com/a/40100334/389289">the other answer</a>, you can use the <a href="https://docs.python.org/3/library/threading.html#with-locks" rel="nofollow noreferrer">context management protocol</a> with locks:</p>
<pre><code>with lock:
    if set_this_var_only_once is None:
        set_this_var_only_once = "not None"
</code></pre>
<p>That will also make sure the lock is correctly released in case of an exception within the locked block.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to lock the variable like this:</p>
<pre><code>from threading import Lock

lock = Lock()
set_this_var_only_once = None

def worker():
    with lock:
        if set_this_var_only_once is None:
            set_this_var_only_once = "not None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No it's not. </p>
<blockquote>
<p>If another thread gets control after the current thread has fetched
  the variable, it may fetch the variable, increment it, and write it
  back, before the current thread does the same thing. And since theyâ€™re
  both seeing the same original value, only one item will be accounted
  for.</p>
</blockquote>
<p><a href="http://effbot.org/zone/thread-synchronization.htm" rel="nofollow">Here's</a> this good article about it. </p>
<p>P.S. Also the following line is needed in the worker(): </p>
<pre><code>global set_this_var_only_once 
</code></pre>
</div>
<span class="comment-copy">What if two or more workers check the condition before either of them sets the variable?</span>
<span class="comment-copy">@machineyearning that is my worry</span>
<span class="comment-copy">Using <code>with</code> is a nice touch ;)</span>
<span class="comment-copy">Makes the code more clear and it's practically identical with Java's synchronized blocks, i.e. synchronized(lock) { /*code*/ }.</span>
