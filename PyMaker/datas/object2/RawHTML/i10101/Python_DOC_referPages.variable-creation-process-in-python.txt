<div class="post-text" itemprop="text">
<p>Doing everything in Microsoft shell and using 2.7.12</p>
<h1>Prelude</h1>
<pre><code>a = [1,2,3,4,5]
b = [1,2,3,4,5]
c = a
</code></pre>
<h1>Actions</h1>
<pre><code>a[0] is b[0] is c[0]
True
</code></pre>
<p>Are not the three lists pointing to the same elements in the memory location? and are therefore liable to change if one is changed?</p>
<p>Part I understand:</p>
<pre><code>c[0] = 8888888
a[0]
8888888
</code></pre>
<p>Part I don't understand:</p>
<pre><code>b[0] = 9999999
a[0]
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python can decide to share immutable objects storage (strings, integers, ...)</p>
<p>Since they are immutable, it is transparent to the user. It just saves memory.</p>
<pre><code>a[0] is b[0]
</code></pre>
<p>could be True or False. On the other hand</p>
<pre><code>a[0] is c[0]
</code></pre>
<p>is always True because <code>a is c</code>. (and modifying <code>a</code> changes <code>c</code>)</p>
<p>But since <code>list</code> type is mutable, <code>a</code> cannot be <code>b</code> (Python doesn't allow itself to optimize storage in that case). Those are independent objects. Modifying <code>a</code> cannot change <code>b</code>.</p>
<p>note about my "can be true or false" remark. Consider this in python 3.4</p>
<pre><code>&gt;&gt;&gt; b=1234567890
&gt;&gt;&gt; a=[1234567890]
&gt;&gt;&gt; b is a[0]
False
</code></pre>
<p>Python did not bother to make the link between <code>b</code> and <code>a[0]</code>. Also happens with long strings (I assume that would be a performance issue vs low probability to find an exact big number 2 times in a row? whereas <code>1</code> has better chance to be repeated throughout the program)</p>
<p>However if you do this you get a different result:</p>
<pre><code>&gt;&gt;&gt; b=1234567890
&gt;&gt;&gt; a=[b,1,2]
&gt;&gt;&gt; b is a[0]
True
</code></pre>
<p>(I wouldn't say for sure why as it can vary depending whether it is stored as a long int or mere int, value or address, etc... , but Python has definitely more information about the value being duplicated here!)</p>
<p>Conclusion is: don't rely on that for immutable objects. Use <code>==</code> at all times.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>int</code>s are <em>immutable</em>. This means that when you reassign <code>a[0]</code>, you're not changing whatever <code>1</code> is. Rather, you're changing whatever <code>a[0]</code> holds. You don't change what it means to be <code>1</code> - you change what it means to be <code>a[0]</code>.</p>
<p>If on the other hand you did this:</p>
<pre><code>L = [1,2,3]
a = [L]
b = [L]
a.[0].append(4)
</code></pre>
<p>you'd see the change reflected in <code>b</code> as well</p>
</div>
<div class="post-text" itemprop="text">
<p>Assignment in Python is by reference - it creates a new reference, or alias for an object, not copies the object - and since event <em>int</em> is an object in Python - at least (in my version - up to 256), this rule mostly works works.</p>
<p>The following example wit function <em>id</em> - which shows object reference - illustrates the point</p>
<pre><code>In [37]: a = range(1, 6)

In [38]: b = range(1, 6)

In [39]: id(1)
Out[39]: 4298160472

In [40]: id(a[0])
Out[40]: 4298160472

In [41]: id(a)
Out[41]: 4376534696

In [42]: id(b)
Out[42]: 4378531744

In [44]: c = a

In [45]: id(c)
Out[45]: 4376534696
</code></pre>
<p>However, this will not work on floats - which is logical, since quantity of floats, and integers is infinite</p>
<pre><code>In [49]: a = .1

In [50]: b = .1

In [51]: id(a)
Out[51]: 4298708040

In [52]: id(b)
Out[52]: 4303248152
</code></pre>
<p>As you may see, new object is created for each new float, though value is the same</p>
</div>
<span class="comment-copy">Why should <code>a</code> and <code>b</code> point to the same location? just because they happen to have lists with identical values?</span>
<span class="comment-copy">Thats how it happens in python. So you create a= 5 and itll search if 5 already exists and if does it will point a to that. funny exercise for you: a = [1,2,3,4,5]; g = 4; g is a[3]; True. funny, right??!! can someone confirm if what i just said is right?  PS - New to community</span>
<span class="comment-copy">integers are immutable, list are mutable. The provided answers explain that very much in detail. "Thats how it happens in python" is also obviously wrong, else you wouldn't be seeing the result you are seeing.</span>
<span class="comment-copy">And the <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="nofollow noreferrer">official documentation</a> even says: <i>after <code>a = 1; b = 1</code>, <code>a</code> and <code>b</code> may or may not refer to the same object with the value one, depending on the implementation, but after <code>c = []; d = []</code>, <code>c</code> and <code>d</code> are guaranteed to refer to two different, unique, newly created empty lists.</i></span>
<span class="comment-copy">Okay. I think i am getting a hang of what you are trying to convey. Maybe my very basics require checking. I am a newbie to OOP. you helped. thank you</span>
<span class="comment-copy">Are you saying:-a = [1,2,3,4]</span>
<span class="comment-copy">are you saying  a = [1,2,3,4] b = 1 a[0] is b can be false</span>
<span class="comment-copy">definitely, maybe not for the value <code>1</code> but still: see my edit.</span>
<span class="comment-copy">Just to confirm if what i have understood about objects is right. are the following things exactly the same things: a) list1 = [1,2]; list2 = copy.copy(a) b) list1 = [1,2]; list2 = [1,2]</span>
<span class="comment-copy">@NitinSiwach: you got it right :)</span>
