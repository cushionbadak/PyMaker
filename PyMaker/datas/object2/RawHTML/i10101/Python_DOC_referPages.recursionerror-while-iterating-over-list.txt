<div class="post-text" itemprop="text">
<p>I have a list of geodesic points by the format: <code>[lat, long, elevation, index, land/sea binary classifier]</code> in a grid formation with regular spacing throughout the dataset.  I'm trying to find all neighbouring points that are land (elv &gt; 0) to the current point in the list.</p>
<p>I keep getting this error:  <code>RecursionError: maximum recursion depth exceeded while getting the repr of a list</code> and although I understand the sort of thing that could be causing this, I have no idea how this applies to this situation as I'm not explicitly using recursion.  How am I able to remedy this error?  How can I understand the problem better as well?</p>
<p>(topLat, bottomLat, westLong, eastLong are the lats and longs for the first and last point in the grid/map to identify points at the edge of the map)</p>
<pre><code>def buildNeighbours(point, dataset):
    neighbours = []
    ix = int(point[3])

    if point[0] != topLat and point[0] != bottomLat and point[1] != westLong and point[1] != eastLong:
        nw = dataset[ix - (rowLength + 1)]
        n = dataset[ix - rowLength]
        ne = dataset[ix - (rowLength - 1)]
        e = dataset[ix + 1]
        se = dataset[ix + (rowLength + 1)]
        s = dataset[ix + rowLength]
        sw = dataset[ix + (rowLength - 1)]
        w = dataset[ix - 1]
        neighbours = [nw, n, ne, e, se, s, sw, w]
        point.append(neighbours)

    else:
        point = []

    return point


for point in dataList:
    point = buildNeighbours(point, dataList)

print(dataList[2000])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To stringify a point (really a <code>list</code>), <code>print</code> must first get the string representation of every element.  The last element of each point is a <code>list</code> of neighboring points, each of which is a <code>list</code> that contains yet another <code>list</code> of neighboring points... one of which is the original point.  And so it continues...</p>
<p><code>list</code>'s <code>__repr__</code> attempts to limit recursive cases, eventually giving up and returning <code>'...'</code>.  Assuming it uses the same defaults as <a href="https://docs.python.org/3/library/reprlib.html#repr-objects" rel="nofollow"><code>reprlib.Repr</code> objects</a>, the <code>maxlevel</code> (max recursion depth) is 6.  With 8 neighbors each, that could mean thousands of visits to a relatively small number of unique points.</p>
<p>I was able to print a 3×3 grid, where the fan-out is limited because most of the points only have 3 or 5 neighbors (corners and sides).  My simplified <code>point</code> lists, which didn't contain altitude or land/sea elements, required about 700kiB to represent the whole grid... about 40KiB for the upper-left corner alone.  On a 4×4 grid, a single point ballooned up to about 16MiB.</p>
<p>That said, I'm guessing what your inputs look like, and I probably haven't reproduced what you're really doing.  More importantly, I did <em>not</em> get a <code>RecursionError</code> like you did, perhaps because I gave up waiting for it.</p>
<p>With those caveats in mind, I suggest:</p>
<ul>
<li><p>In each point's <code>neighbors</code> list, store the <em>indices</em> of the neighbors.  Look them up later whenever you need them.  (This is the simplest solution I could come up with.)  Write a couple helper functions that calculate the northwest or south or whatever neighbor of a given index, since you'll be doing that a lot.</p></li>
<li><p>Alternatively, consider creating a <code>neighbors</code> dictionary, mapping each point's index to a list of indices.  You'd have to keep that dictionary alongside <code>dataList</code> at all times, but it would let you remove the list of neighbors from all of your points.</p></li>
<li><p>If you really have to store the neighbors themselves, create a <code>Point</code> class with custom <code>__str__</code> and <code>__repr__</code> methods that don't try to print the neighbors.  As a bonus, a class would let you refer to fields with names like <code>lat</code>, <code>lng</code>, and <code>index</code> instead of mysterious subscripts like <code>[1]</code> and <code>[3]</code>.</p></li>
</ul>
</div>
<span class="comment-copy">You could get this if a list item is in fact a reference to the original list. <code>repr</code> would keep circling back to the top of the nested lists.  Your code is really long so I haven't tried to figure out where the problem is. Do you have a shorter version that demonstrates the problem.</span>
<span class="comment-copy">Whenever it has to excute the if statement, the error occurs</span>
<span class="comment-copy">The error is very much self-explanatory - you've managed to implement infinite loop somehow. Short sample (3-7 entries) of your data list plus the way you run this script may help the community to assist you. None seems to be possible to evaluate from your current code though</span>
<span class="comment-copy">I think that you get an error in one of the <code>if</code> calculations, python tries to raise an error, but hits a recursion error when generating the error message. Put a <code>print(repr(point))</code> at the top of the function and it will likely hit. Then you can deal with that.</span>
<span class="comment-copy">What is <code>point</code>? It seems like a list of ints or floats but then you append a list to it. Is that intentional?</span>
