<div class="post-text" itemprop="text">
<p>How do I find the location of my site-packages directory?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two types of site-packages directories, <em>global</em> and <em>per user</em>.</p>
<ol>
<li><p><strong>Global</strong> site-packages ("<a href="https://stackoverflow.com/questions/9387928/whats-the-difference-between-dist-packages-and-site-packages">dist-packages</a>") directories are listed in <code>sys.path</code> when you run:</p>
<pre><code>python -m site
</code></pre>
<p>For a more concise list run <code>getsitepackages</code> from the <a href="https://docs.python.org/3.5/library/site.html#site.getsitepackages" rel="noreferrer">site module</a> in Python code:</p>
<pre><code>python -c "import site; print(site.getsitepackages())"
</code></pre>
<p><em>Note:</em> With virtualenvs <a href="https://github.com/pypa/virtualenv/issues/228" rel="noreferrer">getsitepackages is not available</a>, <code>sys.path</code> from above will list the virtualenv's site-packages directory correctly, though.</p></li>
<li><p>The <strong>per user</strong> site-packages directory (<a href="https://www.python.org/dev/peps/pep-0370/" rel="noreferrer">PEP 370</a>) is where Python installs your local packages:</p>
<pre><code>python -m site --user-site
</code></pre>
<p>If this points to a non-existing directory check the exit status of Python and see <code>python -m site --help</code> for explanations.</p>
<p><em>Hint:</em> Running <code>pip list --user</code> or <code>pip freeze --user</code> gives you a list of all installed <em>per user</em> site-packages.</p></li>
</ol>
<hr/>
<h2>Practical Tips</h2>
<ul>
<li><p><code>&lt;package&gt;.__path__</code> lets you identify the location(s) of a specific package: (<a href="https://stackoverflow.com/questions/2699287/what-is-path-useful-for">details</a>)</p>
<pre><code>$ python -c "import setuptools as _; print(_.__path__)"
['/usr/lib/python2.7/dist-packages/setuptools']
</code></pre></li>
<li><p><code>&lt;module&gt;.__file__</code> lets you identify the location of a specific module: (<a href="https://softwareengineering.stackexchange.com/questions/111871/module-vs-package">difference</a>)</p>
<pre><code>$ python3 -c "import os as _; print(_.__file__)"
/usr/lib/python3.6/os.py
</code></pre></li>
<li><p>Run <code>pip show &lt;package&gt;</code> to show Debian-style package information:</p>
<pre><code>$ pip show pytest
Name: pytest
Version: 3.8.2
Summary: pytest: simple powerful testing with Python
Home-page: https://docs.pytest.org/en/latest/
Author: Holger Krekel, Bruno Oliveira, Ronny Pfannschmidt, Floris Bruynooghe, Brianna Laugher, Florian Bruhin and others
Author-email: None
License: MIT license
Location: /home/peter/.local/lib/python3.4/site-packages
Requires: more-itertools, atomicwrites, setuptools, attrs, pathlib2, six, py, pluggy
</code></pre></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import site; site.getsitepackages()
['/usr/local/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages']
</code></pre>
<p>(or just first item with <code>site.getsitepackages()[0]</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="http://docs.djangoproject.com/en/dev/topics/install/#remove-any-old-versions-of-django" rel="noreferrer">"How to Install Django" documentation</a> (though this is useful to more than just Django installation) - execute the following from the shell:</p>
<pre><code>python -c "from distutils.sysconfig import get_python_lib; print(get_python_lib())"
</code></pre>
<p>Formatted for readability (rather than use as a one-liner), that looks like the following:</p>
<pre><code>from distutils.sysconfig import get_python_lib
print(get_python_lib())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>For Ubuntu</em>,</p>
<pre><code>python -c "from distutils.sysconfig import get_python_lib; print get_python_lib()"
</code></pre>
<p>...is not correct.</p>
<p>It will point you to <code>/usr/lib/pythonX.X/dist-packages</code></p>
<p>This folder only contains packages your operating system has automatically installed for programs to run.</p>
<p><em>On ubuntu</em>, the site-packages folder that contains packages installed via setup_tools\easy_install\pip will be in <code>/usr/local/lib/pythonX.X/dist-packages</code></p>
<p>The second folder is probably the more useful one if the use case is related to installation or reading source code.</p>
<p>If you do not use Ubuntu, you are probably safe copy-pasting the first code box into the terminal.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what worked for me:</p>
<pre><code>python -m site --user-site
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's say you have installed the package 'django'. import it and type in dir(django). It will show you, all the functions and attributes with that module. Type in the python interpreter - </p>
<pre><code>&gt;&gt;&gt; import django
&gt;&gt;&gt; dir(django)
['VERSION', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', 'get_version']
&gt;&gt;&gt; print django.__path__
['/Library/Python/2.6/site-packages/django']
</code></pre>
<p>You can do the same thing if you have installed mercurial.</p>
<p>This is for Snow Leopard. But I think it should work in general as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>As others have noted, <code>distutils.sysconfig</code> has the relevant settings:</p>
<pre><code>import distutils.sysconfig
print distutils.sysconfig.get_python_lib()
</code></pre>
<p>...though the default <code>site.py</code> does something a bit more crude, paraphrased below:</p>
<pre><code>import sys, os
print os.sep.join([sys.prefix, 'lib', 'python' + sys.version[:3], 'site-packages'])
</code></pre>
<p>(it also adds <code>${sys.prefix}/lib/site-python</code> and adds both paths for <code>sys.exec_prefix</code> as well, should that constant be different).</p>
<p>That said, what's the context? You shouldn't be messing with your <code>site-packages</code> directly; setuptools/distutils will work for installation, and your program may be running in a virtualenv where your pythonpath is completely user-local, so it shouldn't assume use of the system site-packages directly either.</p>
</div>
<div class="post-text" itemprop="text">
<p>The native system packages installed with python installation in Debian based systems can be found at :</p>
<blockquote>
<p>/usr/lib/python2.7/dist-packages/</p>
</blockquote>
<p>In OSX - <code>/Library/Python/2.7/site-packages</code></p>
<p>by using this small code :</p>
<pre><code>from distutils.sysconfig import get_python_lib
print get_python_lib()
</code></pre>
<p>However, the list of packages installed via <code>pip</code> can be found at :</p>
<blockquote>
<p>/usr/local/bin/</p>
</blockquote>
<p>Or one can simply write the following command to list all paths where python packages are.</p>
<pre><code>&gt;&gt;&gt; import site; site.getsitepackages()
['/usr/local/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages']
</code></pre>
<p><em>Note: the location might vary based on your OS, like in OSX</em></p>
<pre><code>&gt;&gt;&gt; import site; site.getsitepackages()
['/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages', '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/site-python', '/Library/Python/2.7/site-packages']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All the answers (or: the same answer repeated over and over) are inadequate. What you want to do is this:</p>
<pre><code>from setuptools.command.easy_install import easy_install
class easy_install_default(easy_install):
  """ class easy_install had problems with the fist parameter not being
      an instance of Distribution, even though it was. This is due to
      some import-related mess.
      """

  def __init__(self):
    from distutils.dist import Distribution
    dist = Distribution()
    self.distribution = dist
    self.initialize_options()
    self._dry_run = None
    self.verbose = dist.verbose
    self.force = None
    self.help = 0
    self.finalized = 0

e = easy_install_default()
import distutils.errors
try:
  e.finalize_options()
except distutils.errors.DistutilsError:
  pass

print e.install_dir
</code></pre>
<p>The final line shows you the installation dir. Works on Ubuntu, whereas the above ones don't. Don't ask me about windows or other dists, but since it's the exact same dir that easy_install uses by default, it's probably correct everywhere where easy_install works (so, everywhere, even macs). Have fun. Note: original code has many swearwords in it.</p>
</div>
<div class="post-text" itemprop="text">
<p>A side-note: The proposed solution (<code>distutils.sysconfig.get_python_lib()</code>) does not work when there is more than one site-packages directory (as <a href="http://pythonsimple.noucleus.net/python-install/python-site-packages-what-they-are-and-where-to-put-them" rel="nofollow noreferrer">recommended by this article</a>). It will only return the main site-packages directory.</p>
<p>Alas, I have no better solution either. Python doesn't seem to keep track of site-packages directories, just the packages within them.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works for me.
It will get you both dist-packages and site-packages folders.
If the folder is not on Python's path, it won't be
doing you much good anyway.</p>
<pre><code>import sys; 
print [f for f in sys.path if f.endswith('packages')]
</code></pre>
<p>Output (Ubuntu installation):</p>
<pre><code>['/home/username/.local/lib/python2.7/site-packages',
 '/usr/local/lib/python2.7/dist-packages',
 '/usr/lib/python2.7/dist-packages']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An additional note to the <code>get_python_lib</code> function mentioned already: on some platforms different directories are used for platform specific modules (eg: modules that require compilation).  If you pass <code>plat_specific=True</code> to the function you get the site packages for platform specific packages.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should work on all distributions in and out of virtual environment due to it's "low-tech" nature. The os module always resides in the parent directory of 'site-packages'</p>
<pre><code>import os; print(os.path.dirname(os.__file__) + '/site-packages')
</code></pre>
<p>To change dir to the site-packages dir I use the following alias (on *nix systems):</p>
<pre><code>alias cdsp='cd $(python -c "import os; print(os.path.dirname(os.__file__))"); cd site-packages'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from distutils.sysconfig import get_python_lib
print get_python_lib()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>pip show will give all the details about a package:
<a href="https://pip.pypa.io/en/stable/reference/pip_show/" rel="noreferrer">https://pip.pypa.io/en/stable/reference/pip_show/</a>  [pip show][1]</p>
<p>To get the location:</p>
<pre><code>pip show &lt;package_name&gt;| grep Location
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A modern stdlib way is using <a href="https://docs.python.org/3/library/sysconfig.html" rel="nofollow noreferrer"><code>sysconfig</code></a> module, available in version 2.7 and 3.2+. Python currently uses <em>eight</em> paths (<a href="https://docs.python.org/3/library/sysconfig.html#installation-paths" rel="nofollow noreferrer">docs</a>):</p>
<blockquote>
<ul>
<li><em>stdlib</em>: directory containing the standard Python library files that are not platform-specific.</li>
<li><em>platstdlib</em>: directory containing the standard Python library files that are platform-specific.</li>
<li><em>platlib</em>: directory for site-specific, platform-specific files.</li>
<li><em>purelib</em>: directory for site-specific, non-platform-specific files.</li>
<li><em>include</em>: directory for non-platform-specific header files.</li>
<li><em>platinclude</em>: directory for platform-specific header files.</li>
<li><em>scripts</em>: directory for script files.</li>
<li><em>data</em>: directory for data files.</li>
</ul>
</blockquote>
<p>In most cases, users finding this question would be interested in the 'purelib' path (in <a href="https://stackoverflow.com/a/122387/674039">some  cases</a>, you might be interested in 'platlib' too).  Unlike the currently accepted answer, this method should not misbehave depending on whether or not you have a virtualenv activated.</p>
<p>At system level (this is Python 3.7.0 on mac OS):</p>
<pre><code>&gt;&gt;&gt; import sysconfig
&gt;&gt;&gt; sysconfig.get_paths()['purelib']
'/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages'
</code></pre>
<p>With a venv, you'll get something like this </p>
<pre><code>&gt;&gt;&gt; import sysconfig                                                                                                                                                
&gt;&gt;&gt; sysconfig.get_paths()['purelib']                                                                                                                                
'/private/tmp/.venv/lib/python3.7/site-packages'
</code></pre>
<p>A shell script is also available to display these details, which you can invoke by executing <code>sysconfig</code> as a module:</p>
<pre><code>python -m sysconfig
</code></pre>
<p><strong><em>Note:</em></strong> <code>sysconfig</code> (<a href="https://github.com/python/cpython/blob/master/Lib/sysconfig.py" rel="nofollow noreferrer">source</a>) is not to be confused with the <code>distutils.sysconfig</code> submodule (<a href="https://github.com/python/cpython/blob/master/Lib/distutils/sysconfig.py" rel="nofollow noreferrer">source</a>) mentioned in several other answers here. That is an entirely different module and it's lacking the <code>get_paths</code> function discussed above.</p>
</div>
<div class="post-text" itemprop="text">
<p>Answer to old question. But use ipython for this. </p>
<pre><code>pip install ipython
ipython 
import imaplib
imaplib?
</code></pre>
<p>This will give the following output about imaplib package -</p>
<pre><code>Type:        module
String form: &lt;module 'imaplib' from '/usr/lib/python2.7/imaplib.py'&gt;
File:        /usr/lib/python2.7/imaplib.py
Docstring:  
IMAP4 client.

Based on RFC 2060.

Public class:           IMAP4
Public variable:        Debug
Public functions:       Internaldate2tuple
                        Int2AP
                        ParseFlags
                        Time2Internaldate
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had to do something slightly different for a project I was working on: find the <em>relative</em> site-packages directory relative to the base install prefix.  If the site-packages folder was in <code>/usr/lib/python2.7/site-packages</code>, I wanted the <code>/lib/python2.7/site-packages</code> part.  I have, in fact, encountered systems where <code>site-packages</code> was in <code>/usr/lib64</code>, and the accepted answer did NOT work on those systems. </p>
<p>Similar to cheater's answer, my solution peeks deep into the guts of Distutils, to find the path that actually gets passed around inside <code>setup.py</code>.  It was such a pain to figure out that I don't want anyone to ever have to figure this out again.</p>
<pre><code>import sys
import os
from distutils.command.install import INSTALL_SCHEMES

if os.name == 'nt':
    scheme_key = 'nt'
else:
    scheme_key = 'unix_prefix'

print(INSTALL_SCHEMES[scheme_key]['purelib'].replace('$py_version_short', (str.split(sys.version))[0][0:3]).replace('$base', ''))
</code></pre>
<p>That should print something like <code>/Lib/site-packages</code> or <code>/lib/python3.6/site-packages</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If it is already added to the <code>PYTHONPATH</code> you can also do something like</p>
<pre><code>import sys
print('\n'.join(sys.path))
</code></pre>
</div>
<span class="comment-copy">If you just want the exact location of one package then you can use <code>pip show &lt;package name&gt;</code></span>
<span class="comment-copy">there is a site package directory in a virtualenv. You can get  the   directory for site-specific modules inside/outside virtualenv using <a href="https://stackoverflow.com/a/122340/4279"><code>python -c "from distutils.sysconfig import get_python_lib; print(get_python_lib())"</code></a> (it works on both Python 2 and 3 too).</span>
<span class="comment-copy">Nice. And to get the first one: <code>python -c "import site; print(site.getsitepackages()[0])"</code></span>
<span class="comment-copy">This is good but, unfortunately, this function is available only from python2.7.  So, nice solution if you are using python2.7 or above, but not working for python 2.6 and below</span>
<span class="comment-copy">python -c "import site; print(site.getsitepackages())"</span>
<span class="comment-copy">I get AttributeError: 'module' object has no attribute 'getsitepackages' when using with virtualenv (python 2.7.8), the distutils solution below works though.</span>
<span class="comment-copy">@radtek: for venv's, I detect venv via <code>hasattr(sys,'real_prefix')</code> and then determine site packages heuristically from <code>[p for p in sys.path if p.endswith('site-packages')][-1]</code> (plus check if there is one found before doing the <code>[-1]</code>.</span>
<span class="comment-copy">@radtek It is a known bug that the site module does not work for virtualenv <a href="https://github.com/pypa/virtualenv/issues/355" rel="nofollow noreferrer">github.com/pypa/virtualenv/issues/355</a></span>
<span class="comment-copy">Does virtualenv provide a way to find its site-packages?</span>
<span class="comment-copy">You can use virtualenvwrapper, which has the command <code>cdsitepackages</code>, to directly change into the environment's site-packages directory.</span>
<span class="comment-copy">@PiotrDobrogost: works for me on Python 2.7 in a virtualenv on Linux</span>
<span class="comment-copy">First comment does not apply anymore: this showed the correct location both outside and inside a virtualenv.</span>
<span class="comment-copy">Did not work for me on Windows 10 using Linux bash, it returns <code>/usr/lib/python3/dist-packages</code> instead of <code>/usr/lib/python3.5/dist-packages</code>.</span>
<span class="comment-copy">If the asker is after a particular package's location, <code>module.__file__</code> is the better way. If they're trying to install things… just use the tools.</span>
<span class="comment-copy"><code>'/usr/lib/pythonX.X/dist-packages' in site.getsitepackages()</code> on Ubuntu (though it goes <i>after</i> <code>/usr/local/...</code> in the list). You only get something into <code>/usr/local</code> via <code>sudo pip</code> and you shouldn't use <code>sudo pip</code> on Ubuntu unless you decided to make your own distribution: if you use <code>sudo pip</code>, it is your responsibility to make sure that all dependencies of the current and <i>future</i> python modules installed via <code>sudo apt</code> or <code>sudo pip</code> are compatible. Consider <a href="https://virtualenv.pypa.io/en/stable/#introduction" rel="nofollow noreferrer">what problem <code>virtualenv</code> was created to solve</a></span>
<span class="comment-copy">Clear explanation to understand the differences of the 2 <code>dist-packages</code> in (L)Ubuntu.</span>
<span class="comment-copy">For me this points to a folder that doesn't even exist (<code>~/.local/lib/python2.7/site-packages</code>).</span>
<span class="comment-copy">same, in OS X Mavericks , my home .local isn't what I wanted it to find plus yeah its not really there anyways.</span>
<span class="comment-copy">Its in my main /Library folder I had to manually navigate to it, for some reason the direct full path wasn't working</span>
<span class="comment-copy">how do i use the packages installed here? if i do <code>virtualenv</code> it complains that the package does not exist. how do i invoke the packages installed at a custom location?</span>
<span class="comment-copy">This tells you where Python will look for user specific packages. Comments like "doesn't even exist" and "isn't what I wanted it to find" don't make sense in this context.</span>
<span class="comment-copy">&gt;&gt;&gt; import pg &gt;&gt;&gt; print pg.__path__ Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: 'module' object has no attribute '<b>path</b>'</span>
<span class="comment-copy">it works, i need to find the sklearn package to add to the PYDEV path, thanks.</span>
<span class="comment-copy">use <code>django.__file__</code> for this rather than <code>__path__</code>.  and, no, it's not a guarantee that this has anything to do with site-packages, but with things like django, that you've most likely <i>pip installed</i>, it will do when you're in a hurry and it can be used for other purposes as well (reading a default config file from the file system for example).</span>
<span class="comment-copy">works  reliable with <code>python2</code> on osx and ubuntu with and without virtualenv but not with <code>python3</code> at all.</span>
<span class="comment-copy">2008 was a while back -- this answer was three months before Python 3.0's release.</span>
<span class="comment-copy">sure, but today my comment might help. correct me if am wrong. furthermore, i did not downvote this answer or any other in regards to <code>python3</code>.</span>
<span class="comment-copy">If I remember correctly, dist-packages is specific to Debian and derivates.</span>
<span class="comment-copy">@SamuelSantana you are correct. dist-packages are specific to debian based systems. In this case I invoked <code>site.getsitepackages()</code> from the system installation hence the dist-packages, other installations will show site-packages.</span>
<span class="comment-copy">Thanks, this is pretty useful, on py3 with brackets for print it gets me    /usr/local/lib/python3.4/dist-packages  I'm trying to work out how to get    /usr/lib/python3.4/dist-packages so will have to play further.</span>
<span class="comment-copy">requires external library <code>easy_install</code> and does not fail gracefully if unavailable which is inadequate :)</span>
<span class="comment-copy">indeed, this is not perfect, but it worked for me and took a lot of time to figure out, so I put it here in hopes someone else can build upon the time I've spent on it already.</span>
<span class="comment-copy">I guess that's the reason why <code>get_python_lib()</code> when being run from within virtualenv shows <i>site-packages</i> of Python used to create virtualenv and not the virtualenv's <i>site-packages</i>.</span>
<span class="comment-copy">@Piotr That was probably a bug in distutils.sysconfig. I've just tested it an I get the inner site-packages, as expected.</span>
<span class="comment-copy">Also tested with Python 2.7 installed in a virtualenv on Linux, and the distutils.sysconfig method works fine to get the inner Python's site-packages.</span>
<span class="comment-copy">accepted answer is the recommended way, so you should tell why yours is better, since it's a bit of a hack</span>
<span class="comment-copy">What's wrong with a hack? ;)  It's simpler and easy to understand and remember if you're working interactively.</span>
<span class="comment-copy">for <code>python2</code> this is a working answer.</span>
<span class="comment-copy">Best answer so far</span>
<span class="comment-copy">This isn't the site-packages directory, but the directory that the package is installed into. This is also only helpful if you're using iPython and not for being able to programmatically get an install directory.</span>
