<div class="post-text" itemprop="text">
<p>I have a Jupyter notebook that I plan to run repeatedly. It has functions in it, the structure of the code is this:</p>
<pre><code>def construct_url(data):
    ...
    return url

def scrape_url(url):
    ... # fetch url, extract data
    return parsed_data

for i in mylist: 
    url = construct_url(i)
    data = scrape_url(url)
    ... #Â use the data to do analysis
</code></pre>
<p>I'd like to write tests for <code>construct_url</code> and <code>scrape_url</code>. What's the most sensible way to do this?</p>
<p>Some approaches I've considered:</p>
<ul>
<li>Move the functions out into a utility file, and write tests for that utility file in some standard Python testing library. Possibly the best option, though it means that not all of the code is visible in the notebook.</li>
<li>Write asserts within the notebook itself, using test data (adds noise to the notebook).</li>
<li>Use specialised Jupyter testing to test the content of the cells (don't think this works, because the content of the cells is going to change). </li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to use Python standard testing tools, such as <a href="https://docs.python.org/3.6/library/doctest.html" rel="noreferrer">doctest</a> or <a href="https://docs.python.org/3.6/library/unittest.html" rel="noreferrer">unittest</a>, directly in the notebook.</p>
<h2>Doctest</h2>
<p>A notebook cell with a function and a test case in a docstring:</p>
<pre class="lang-py prettyprint-override"><code>def add(a, b):
    '''
    This is a test:
    &gt;&gt;&gt; add(2, 2)
    5
    '''
    return a + b
</code></pre>
<p>A notebook cell (the last one in the notebook) that runs all test cases in the docstrings:</p>
<pre><code>import doctest
doctest.testmod(verbose=True)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Trying:
    add(2, 2)
Expecting:
    5
**********************************************************************
File "__main__", line 4, in __main__.add
Failed example:
    add(2, 2)
Expected:
    5
Got:
    4
1 items had no tests:
    __main__
**********************************************************************
1 items had failures:
   1 of   1 in __main__.add
1 tests in 2 items.
0 passed and 1 failed.
***Test Failed*** 1 failures.
</code></pre>
<h2>Unittest</h2>
<p>A notebook cell with a function:</p>
<pre class="lang-py prettyprint-override"><code>def add(a, b):
    return a + b
</code></pre>
<p>A notebook cell (the last one in the notebook) that contains a test case. The last line in the cell runs the test case when the cell is executed:</p>
<pre class="lang-py prettyprint-override"><code>import unittest

class TestNotebook(unittest.TestCase):

    def test_add(self):
        self.assertEqual(add(2, 2), 5)


unittest.main(argv=[''], verbosity=2, exit=False)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>test_add (__main__.TestNotebook) ... FAIL

======================================================================
FAIL: test_add (__main__.TestNotebook)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "&lt;ipython-input-15-4409ad9ffaea&gt;", line 6, in test_add
    self.assertEqual(add(2, 2), 5)
AssertionError: 4 != 5

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
</code></pre>
<h2>Debugging a Failed Test</h2>
<p>While debugging a failed test, it is often useful to halt the test case execution at some point and run a debugger. For this, insert the following code just before the line at which you want the execution to halt:</p>
<pre class="lang-py prettyprint-override"><code>import pdb; pdb.set_trace()
</code></pre>
<p>For example:</p>
<pre class="lang-py prettyprint-override"><code>def add(a, b):
    '''
    This is the test:
    &gt;&gt;&gt; add(2, 2)
    5
    '''
    import pdb; pdb.set_trace()
    return a + b
</code></pre>
<p>For this example, the next time you run the doctest, the execution will halt just before  the return statement and the <a href="https://docs.python.org/3/library/pdb.html" rel="noreferrer">Python debugger</a> (pdb) will start. You will get a pdb prompt directly in the notebook, which will allow you to inspect the values of <code>a</code> and <code>b</code>, step over lines, etc.</p>
<p>I created a <a href="https://gist.github.com/SergiyKolesnikov/f94d91b947051ab5d2ba1aa30e25f050#file-test_and_debug-ipynb" rel="noreferrer">Jupyter notebook for experimenting</a> with the techniques I have just described.</p>
</div>
<div class="post-text" itemprop="text">
<p>In my opinion the best way to have a Unit tests in Jupyter notebook is the following package:
<a href="https://github.com/JoaoFelipe/ipython-unittest" rel="nofollow noreferrer">https://github.com/JoaoFelipe/ipython-unittest</a></p>
<p>example from the package docs:</p>
<pre><code>%%unittest_testcase
def test_1_plus_1_equals_2(self):
    sum = 1 + 1
    self.assertEqual(sum, 2)

def test_2_plus_2_equals_4(self):
    self.assertEqual(2 + 2, 4)

Success
..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After researching a bit, I reached my own solution where I have my own testing code looks like this</p>
<pre><code>def red(text):
    print('\x1b[31m{}\x1b[0m'.format(text))

def assertEquals(a, b):
    res = a == b
    if type(res) is bool:
        if not res:
            red('"{}" is not "{}"'.format(a, b))
            return
    else:
        if not res.all():
            red('"{}" is not "{}"'.format(a, b))
            return

    print('Assert okay.')
</code></pre>
<p>What it does is</p>
<ul>
<li>Check if <code>a</code> equals <code>b</code>.</li>
<li>If they are different it shows the arguments in red.</li>
<li>If they are the same it says 'okay'.</li>
<li>If the result of the comparison is an array it checks if <code>all()</code> is true.</li>
</ul>
<p>I put the function on top of my notebook and I test something like this</p>
<pre><code>def add(a, b):
    return a + b

assertEquals(add(1, 2), 3)
assertEquals(add(1, 2), 2)
assertEquals([add(1, 2), add(2, 2)], [3, 4])

---

Assert okay.
"3" is not "2"  # This is shown in red.
Assert okay.
</code></pre>
<p>Pros of this approach are</p>
<ul>
<li>I can test cell by cell and see the result as soon as I change something of a function.</li>
<li>I don't need to add extra code something like <code>doctest.testmod(verbose=True)</code> that I have to add if I use doctest.</li>
<li>Error messages are simple.</li>
<li>I can customize my testing (assert) code.</li>
</ul>
</div>
<span class="comment-copy">Care to report back? I'm currently refactoring some old notebooks and using both your first and second strategies for different purposes. The notebooks share certain utility functions, which I've moved out to <code>utils.py</code>. This script also contains the unit tests for the functions, as you suggest. The notebooks tackle a series of rather unpleasant data wrangling and cleaning tasks. Where I originally used debugging messages to observe the result of a specific transformation of the data, I now have assertions that verify that the data set meets certain expectations at various stages.</span>
<span class="comment-copy">Very interested in this as well...</span>
<span class="comment-copy">This might be very useful for testing notebooks in general: <a href="https://github.com/opengeophysics/testipynb" rel="nofollow noreferrer">github.com/opengeophysics/testipynb</a></span>
