<div class="post-text" itemprop="text">
<p>I frequently see code like this at work:</p>
<pre><code>overlap &amp;= group['ADMSN_DT'].loc[i] &lt;= group['epi_end'].loc[j]
</code></pre>
<p>My question is what do operators such as <code>&amp;=</code>, <code>|=</code>, and <code>~</code> do in pandas?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#boolean-indexing" rel="nofollow">documentation</a></p>
<blockquote>
<p>The operators are: | for or, &amp; for and, and ~ for not. These must be
  grouped by using parentheses.</p>
</blockquote>
<p><a href="https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements" rel="nofollow">Augmented assignment statements</a></p>
<blockquote>
<p>An augmented assignment evaluates the target (which, unlike normal
  assignment statements, cannot be an unpacking) and the expression
  list, performs the binary operation specific to the type of assignment
  on the two operands, and assigns the result to the original target.
  The target is only evaluated once.</p>
</blockquote>
<p>just like <code>a += 1</code> increments <code>a</code>, <code>a &amp;= b</code> compares <code>a</code> and <code>b</code> and assigns the result to <code>a</code>.</p>
<pre><code>a = 1
b = 0
print(a &amp; b)
&gt;&gt;&gt; 0
a &amp;= b
print(a)
&gt;&gt;&gt; 0
</code></pre>
<p>And a <code>pandas</code> example</p>
<p>Let's generate a dataframe of zeros and ones.</p>
<pre><code>import numpy as np
import pandas as pd
a = pd.DataFrame(np.random.randint(0, 2, size=(6,4)), columns=list('ABCD'))
b = pd.DataFrame(np.random.randint(0, 2, size=(6,4)), columns=list('ABCD'))
</code></pre>
<p>Our initial dataframe</p>
<pre><code>print(a)
</code></pre>
<blockquote>
<pre><code>   A  B  C  D
0  0  1  1  0
1  0  0  1  0
2  1  0  0  1
3  1  1  0  0
4  0  0  0  1
5  0  0  0  0
</code></pre>
</blockquote>
<pre><code>print(b)
</code></pre>
<blockquote>
<pre><code>   A  B  C  D
0  0  0  0  0
1  1  1  1  0
2  0  1  1  1
3  0  1  1  1
4  1  1  1  0
5  1  1  1  1
</code></pre>
</blockquote>
<p>The 4th row of <code>a</code> and <code>b</code></p>
<pre><code>print(a.loc[3])
</code></pre>
<blockquote>
<pre><code>A    1
B    1
C    0
D    0
Name: 1, dtype: int32
</code></pre>
</blockquote>
<pre><code>print(b.loc[3])
</code></pre>
<blockquote>
<pre><code>A    0
B    1
C    1
D    1
Name: 1, dtype: int32
</code></pre>
</blockquote>
<p>Now evaluate and assign row 4</p>
<pre><code>a.loc[3] &amp;= b.loc[3]
</code></pre>
<p>Row 4 of <code>a</code> has changed. Only where both rows have 1 at the same position a 1 is written back to <code>a</code>.</p>
<pre><code>print(a.loc[3])
</code></pre>
<blockquote>
<pre><code>A    0
B    1
C    0
D    0
Name: 3, dtype: int32
</code></pre>
</blockquote>
</div>
<span class="comment-copy">in most c-ish based languages, they're short cuts. <code>foo X= ...</code> is simply <code>foo = foo X...</code></span>
<span class="comment-copy">Since "<a href="http://pandas.pydata.org/pandas-docs/stable/dsintro.html#series-is-ndarray-like" rel="nofollow noreferrer">Series are ndarray-like</a>", you should probably wonder <a href="/questions/16034672/how-do-numpys-in-place-operations-e-g-work">what in-place operators do in numpy</a>.</span>
<span class="comment-copy">Those are element-wise logical operators that work on Series/DataFrames. With assignment (<code>ser1 &amp;= ser2</code>) they work as usual, as Marc B said: <code>ser1 = ser1 &amp; ser2</code>.</span>
<span class="comment-copy">so |= is for intersection and &amp;= is for a union?</span>
<span class="comment-copy">They have nothing to do with unions or intersections. <code>pd.Series([True, False, True]) &amp; pd.Series([False, True, True])</code> returns <code>pd.Series([False, False, True])</code> so the operator is applied element-wise.</span>
<span class="comment-copy">for &amp; and | what does it mean if there is an = sign following it as shown in the example?</span>
<span class="comment-copy">@bigdata It does the operation and then assigns the result to the name on the left</span>
<span class="comment-copy">@bigdata: see updated answer</span>
<span class="comment-copy">So for the following code import numpy as np a = pd.DataFrame(np.random.randn(6,4),columns=list('ABCD')) b = pd.DataFrame(np.random.randn(6,4),columns=list('ABCD')) a &amp;= b</span>
<span class="comment-copy">so for the following code import numpy as np a = pd.DataFrame(np.random.randn(6,4),columns=list('ABCD')) b = pd.DataFrame(np.random.randn(6,4),columns=list('ABCD')) a &amp;= b  returns an error of  TypeError: ufunc 'bitwise_and' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''</span>
