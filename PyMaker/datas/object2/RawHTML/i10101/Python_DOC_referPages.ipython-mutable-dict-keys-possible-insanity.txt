<div class="post-text" itemprop="text">
<p>Dict-keys should probably be immutable, but that's not <em>actually</em> a requirement. All that's required is that the key can be hashed. What happens if I change the object in such a way that its hash changes after inserting it into my dict? Besides just generally "bad things", I'm getting some extra-unexpected behavior.</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
        def __init__(self, n):
            self.n = n
        def __hash__(self):
            return self.n

&gt;&gt;&gt; foo = Foo(1)
&gt;&gt;&gt; d = {foo : foo.n}
&gt;&gt;&gt; print(d)
{&lt;__main__.Foo at 0xdeadbeef: 1}
&gt;&gt;&gt; d
{&lt;__main__.Foo at 0xdeadbeef: 1}
</code></pre>
<p>so far, so good. The time for following rules is over. Let's do something dumb:</p>
<pre><code>&gt;&gt;&gt; foo.n += 1
</code></pre>
<p>Now, I'm running <code>IPython 5.1.0</code> (installed via <code>anaconda</code>), which is running <code>Python 3.5.2</code> (on a Mac? not sure yet which system details are interesting - ask for more info and I'll be happy to add it).</p>
<pre><code>&gt;&gt;&gt; print(d)
{&lt;__main__.Foo at 0xdeadbeef: 1}
&gt;&gt;&gt; d
KeyError ...
IPython/core/formatters.py
    print.pretty(obj)
IPython/lib/pretty.py
    return self.type_pprinters[cls](obj, self, cycle)
IPython/lib/pretty.py
    p.pretty(obj[key])
KeyError: &lt;__main__.Foo at 0xdeadbeef&gt;
</code></pre>
<p>This is surprising/confusing to me - if we can correctly <code>print</code> the object, why can't <code>IPython</code> figure out how to <code>print</code> it? It seems like it's trying to look up the key, which of course it can't find because the hash changed, but - why then does <code>print(d)</code> work just fine?</p>
<p>Ok, not done being dumb:</p>
<pre><code>&gt;&gt;&gt; d[foo] = foo.n
</code></pre>
<p>Logically thinking - the hash of <code>foo</code> changed so it'll not recognize that it "already has this key" - it <em>doesn't</em> already have this key. And:</p>
<pre><code>&gt;&gt;&gt; print(d)
{__main__.Foo at 0xdeadbeef: 1, __main__.Foo at 0xdeadbeef: 2}
</code></pre>
<p>but then, asking <code>IPython</code> to show:</p>
<pre><code>&gt;&gt;&gt; d
{__main__.Foo at 0xdeadbeef: 2, __main__.Foo at 0xdeadbeef: 2}
</code></pre>
<p>Might be a little hard to see amidst the pointers and dunderscores, but it thinks <em>BOTH</em> values in our dictionary are <code>2</code>. Based on the stacktrace above, I'm guessing this is because it tries to use the <code>foo</code> it has a reference to, and instead of actually looking <em>at</em> our dictionary keys, it ...thinks it knows...? And just uses the reference (for our current <code>foo</code>, with <code>foo.n=2</code>, and it "knows" the values are <code>foo.n</code> not "regular integers")? This is probably the most baffling part, and where I would appreciate some understanding.</p>
<p>Final question: is this a bug in IPython (in which case I'll try to file a bug-report) or is the process of using hashable-but-mutable dict keys and changing them and re-adding them to dictionaries "undefined behavior" in Python? It seems pretty well-defined in terms of output from <code>print(d)</code>, but maybe I'm missing something.</p>
</div>
<div class="post-text" itemprop="text">
<p>For the sake of completeness, I'll put an answer here so we can close this loop:</p>
<p>The beginning of my question said </p>
<blockquote>
<p>"Dict-keys should probably be immutable, but that's not actually a
  requirement. All that's required is that the key can be hashed."</p>
</blockquote>
<p>But, as pointed out by @Stefan Pochmann, that's not precise enough to be accurate. The dict-key must be hashable <strong>and the hash should never change over the object's lifetime</strong>.</p>
<p>That doesn't mean the <em>object</em> must be immutable, but it does mean the parts of the object that feed into the hash shouldn't change in such a way that they'd change the output of the <code>__hash__()</code> call.</p>
<p>So, when I altered my instance in such a way as to change the hash, I violated the requirement and all bets are off - I can no longer make expectations about how this object will act. The "issue" with IPython then is just a matter of it making valid assumptions about objects that I've violated (the assumptions, not the objects), so it's perfectly understandable for it to error out on me.</p>
</div>
<span class="comment-copy">The requirement is "hashable", which is <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow noreferrer">defined</a> as <i>"An object is hashable if it has a hash value which never changes during its lifetime [...]"</i>. Thus you're violating the requirement. Your <i>"hashable-but-mutable"</i> is an oxymoron.</span>
<span class="comment-copy">We generally try to make IPython work with broken user code, so feel free to file an issue. We may quietly roll our eyes about it, though ;-)</span>
<span class="comment-copy">@StefanPochmann - that might've been what I was looking for - if I'm violating a requirement, then it's fine to get undefined behavior. I didn't realize that was the precise definition of hashable. Thanks!</span>
<span class="comment-copy">@ThomasK - eye-rolling encouraged - this was a particularly nitpicky thing that <i>should</i> never happen in practice, so I wouldn't worry about it. I was just trying to understand what was the cause of the error/discrepancy to pinpoint what "expected behavior" might be. But as Stefan mentions, once I start messing with object hash values, I lose the ability to have precise expectations about the code.</span>
