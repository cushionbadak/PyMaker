<div class="post-text" itemprop="text">
<p>I started with programming in python just a few months ago and I really love it.
It's so intuitive and fun to start with.</p>
<p>Data for starting point:
I have a linux mashine on which runs python 3.2.3 I have three buttons on GUI to start a function with and one to stop that proccess or the proccesses (Idea).</p>
<p>The source is as follows:</p>
<pre><code>def printName1(event):
    while button5 != True
    print('Button 1 is pressed')
    time.sleep(3) # just for simulation purposes to get reaction time for stopping

    return
print('STOP button is pressed')

def StopButton():
    button5 = True
</code></pre>
<p>I have tried while, and try with except, but the main problem is that the GUI (thinter) is not responding at that time during the process is running. It stores the input and runs it after the first function (printName1) is finished.
I also looked here at stackoverflow, but the solutions didn't worked properly for me and they had the same issues with interrupting.
I apologize for that (maybe) basic question, but I am very new in python and spend a few day of searching an trying. </p>
<p>Is there a way to do that? The solution can maybe made with threading? But how?
Any advise/help is really appreciated.</p>
<p>Thanks a lot!</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>threading.Event</code></p>
<pre><code>import threading
class ButtonHandler(threading.Thread):
    def __init__(self, event):
        threading.Thread.__init__(self)
        self.event = event
    def run (self):
        while not self.event.is_set():
            print("Button 1 is pressed!")
            time.sleep(3)
        print("Button stop")

myEvent = threading.Event()

#The start button
Button(root,text="start",command=lambda: ButtonHandler(myEvent).start()).pack()



#Say this is the exit button
Button(root, text="stop",command=lambda: myEvent.set()).pack()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Also, you might want to look at using Tk.after. I found it much easier and more intuitive than threads. The after command takes the time in milliseconds to wait and then the command to run after the time.</p>
<pre><code>def printName1():
    if button5 != True:
        print('Button 1 is pressed')
    else:
        print('STOP button is pressed')
    root.after(1000,printName1)

def stopButton():
    button5 = True

root = Tk()
app = Frame(root)
app.pack()

stopbtn = Button(app, text='STOP', command=stopButton)
stopbtn.pack()

root.after(1000,printName1)
root.mainloop()
</code></pre>
<p>maybe this answer will help too: <a href="https://stackoverflow.com/questions/27050492/how-do-you-create-a-tkinter-gui-stop-button-to-break-an-infinite-loop">How do you create a Tkinter GUI stop button to break an infinite loop?</a></p>
</div>
<span class="comment-copy">Yes, you will need to put that function into a different thread. Everything running on the same thread as the GUI will block it and prevent any inputs. (In certain cases you might also be able to do this using generator functions, but in general threads are the "way to go")</span>
<span class="comment-copy">Okay thanks a lot Bryan. So how do I start with that function or more specific how do I have to use that threading killing function. I have no idea or understanding how this will work or look like. I can just imagine in very simple syntax, but this seem to be wired or not obviesly right away?</span>
<span class="comment-copy">You have a few different options. The simplest one for this case could be to just move the entire functionality of <code>printName1</code> into a thread. That solution may not be ideal for every problem, but it would work for this one. Python itself provides a few different libraries for dealing with parallelism including <a href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" rel="nofollow noreferrer">concurrent.future</a>, <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">threading</a> and <a href="https://docs.python.org/3.5/library/_thread.html?highlight=thread#module-_thread" rel="nofollow noreferrer">_thread</a>.</span>
<span class="comment-copy">Thanks to Dashadower for your reply and code. I found out that this had '_initilizing' error. I could fix it by adding the following line threading.Thread.__init__(self), but it is not stopping the proccess, and after it is stoped, I need to run the programm from beginning. I can not run the programm again. The idea was to press button1 many time as I wish, but be able to stop the thread at any time and than let it run from beginning without restarting the whole programm.</span>
<span class="comment-copy">@skyflyofsw Thanks for fixing that, I edited my answer. Also, do you mean that if you press the stop button, the thread wouldn't stop?</span>
