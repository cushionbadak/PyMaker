<div class="post-text" itemprop="text">
<p>I have a script in python which works as shown below. Each function performs a completely different task and not related to each other. My problem is if <strong>function2()</strong> is having an issue during the execution process then <strong>function3()</strong>, <strong>function4()</strong>, <strong>function5()</strong> will not execute. I know you will say to handle this by catching the exception (try..except) but then i have to catch every exception which is not i am looking for. In a nutshell how do i code where my other functions are not impacted if any of the function is having issue. Ideally it should exclude that problematic function and let the other function to execute.</p>
<pre><code>def function1():
    some code

def function2():
    some code

def function3():
    some code

def function4():
    some code

def function5():
    some code

if __name__ == '__main__':
    function1()
    function2()
    function3()
    function4()
    function5()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No need to write multiple <code>try/except</code>. Create a list of your function and execute them. For example, you code should be like:</p>
<pre><code>if __name__ == '__main__':
    func_list = [function1, function2, function3, function4, function5]

    for my_func in func_list:
        try:
            my_func()
        except:
            pass
</code></pre>
<hr/>
<p>OR, create a <em>decorator</em> and add that decorator to each of your function. Check <a href="http://thecodeship.com/patterns/guide-to-python-function-decorators/" rel="nofollow">A guide to Python's function decorators</a>. For example, your decorator should be like:</p>
<pre><code>def wrap_error(func):
    def func_wrapper(*args, **kwargs):
        try:
           return func(*args, **kwargs)
        except:
           pass
    return func_wrapper
</code></pre>
<p>Now add this decorator with your function definition as:</p>
<pre><code>@wrap_error
def function1():
    some code
</code></pre>
<p>Functions having this decorator added to them won't raise any <code>Exception</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use exception and catch all sort of exceptions like this</p>
<pre><code>if __name__ == '__main__':
    try:
        function1()
    except:
        pass
    try:
        function2()
    except:
        pass    
    try:
        function3()
    except:
        pass    
    try:
        function4()
    except:
        pass
</code></pre>
<p>for large number of functions you can use</p>
<pre><code>func_dict = {
 func1 : {
     param1 : val
     param2 : val
   },
 func1 : {
     param1 : val
     param2 : val
   }
}
</code></pre>
<p>thus you can iterate over the keys of the dictionary for the function and iterate on the parameters </p>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.4, a new context manager as <a href="https://docs.python.org/3/library/contextlib.html#contextlib.suppress" rel="nofollow noreferrer"><code>contextlib.suppress</code></a> is added which as per the doc:</p>
<blockquote>
<p>Return a context manager that suppresses any of the specified exceptions if they occur in the body of a <code>with</code> statement and then resumes execution with the first statement following the end of the with statement.</p>
</blockquote>
<p>In order to suppress all the exceptions, you may use it as:</p>
<pre><code>from contextlib import suppress

if __name__ == '__main__':
    with suppress(Exception):  # `Exception` to suppress all the exceptions
        function1()
        function2()
        # Anything else you want to suppress
</code></pre>
</div>
<span class="comment-copy">Two thoughts: You don`t have to catch every single exception by just not naming the concrete exception, right? I guess this should work... Or you just execute function2() at the end of function1(), so if there is an error before, it will not go as far and break earlier.</span>
<span class="comment-copy">if exception handling is an issue due to code lenght, you could write a function that "wraps" all your functions in a <code>try - except</code> block like <code>def wrap_em(func_list): for func in func_list: try: func except: continue</code></span>
<span class="comment-copy">@nostradamus - The thing is I tried what you just mentioned. Basically my function contains several web crawlers. So i am not sure when my function can break. So piling them up according to which function will have an issue will not work in this case.</span>
<span class="comment-copy">@Ev.Kounis - This can be a solution but lets see what other have to say.</span>
<span class="comment-copy">the only problem i see with that are arguments. you cannot pass arguments to the functions you are running like that.</span>
<span class="comment-copy">@Ev.Kounis You can. In that case you need to make it as <code>dict</code> instead of list.  <code>Key</code> will be function and <code>value</code> will be arguments. Data structure depends on the requirement :)</span>
<span class="comment-copy">as far as i understood it, this is what OP explicitly said he does not want to have.</span>
<span class="comment-copy">what I understood that , he was planning to write down every exception that might come up explicitly. But rather he can catch all the exception</span>
<span class="comment-copy">This way is out of the picture because my functions contains around 15 web crawlers and coding in this way is not pythonic.</span>
<span class="comment-copy">then dictionary seems to be the right way</span>
