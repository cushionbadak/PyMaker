<div class="post-text" itemprop="text">
<p>I want to recursively parse all values in a dict that are strings with <code>ast.literal_eval(value)</code> but not do that eval if the string doesn't contain a dict. I want this, because I have a string in a dict that is a dict in itself and I would like the value to be a dict. Best to give an example</p>
<pre><code>my_dict = {'a': 42, 'b': "my_string", 'c': "{'d': 33, 'e': 'another string'}"}
</code></pre>
<p>Now I don't want a do to <code>ast.literal_eval(my_dict['c'])</code> I want a generic solution where I can do <code>convert_to_dict(my_dict)</code></p>
<p>I wanted to write my own method, but I don't know how to check if a string contains a dict, and then ast.literal_eval will fail, hence the question.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a proposition that handles recursion. As it was suggested in the comments, it tries to eval everything then check if the result is a dict, if it is we recurse, else we skip the value . I sligthly altered the initial dict to show that it hanldes recusion fine :</p>
<pre><code>import ast
my_dict = {'a': 42, 'b': "my_string", 'c': "{'d': 33, 'e': \"{'f' : 64}\"}"}

def recursive_dict_eval(old_dict):
    new_dict = old_dict.copy()
    for key,value in old_dict.items():
        try:
            evaled_value=ast.literal_eval(value)
            assert isinstance(evaled_value,dict)
            new_dict[key]=recursive_dict_eval(evaled_value)

        except (SyntaxError, ValueError, AssertionError):
            #SyntaxError, ValueError are for the literal_eval exceptions
            pass
    return new_dict

print(my_dict)
print(recursive_dict_eval(my_dict))
</code></pre>
<p>Output:</p>
<pre><code>{'a': 42, 'b': 'my_string', 'c': '{\'d\': 33, \'e\': "{\'f\' : 64}"}'}
{'a': 42, 'b': 'my_string', 'c': {'e': {'f': 64}, 'd': 33}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can check if you have a dict after using <em>literal_eval</em> and reassign:</p>
<pre><code>from ast import literal_eval

def reassign(d):
    for k, v in d.items():
        try:
            evald = literal_eval(v)
            if isinstance(evald, dict):
                d[k] = evald
        except ValueError:
            pass
</code></pre>
<p>Just pass in the dict:</p>
<pre><code>In [2]: my_dict = {'a': 42, 'b': "my_string", 'c': "{'d': 33, 'e': 'another stri
   ...: ng'}"}

In [3]: reassign(my_dict)

In [4]: my_dict
Out[4]: {'a': 42, 'b': 'my_string', 'c': {'d': 33, 'e': 'another string'}}

In [5]: my_dict = {'a': '42', 'b': "my_string", '5': "{'d': 33, 'e': 'another st
...: ring', 'other_dict':{'foo':'bar'}}"}
In [6]: reassign(my_dict)  
In [7]: my_dict
Out[7]: 
{'5': {'d': 33, 'e': 'another string', 'other_dict': {'foo': 'bar'}},
 'a': '42',
 'b': 'my_string'}
</code></pre>
<p>You should also be aware that if you had certain other objects in the dict like <em>datetime</em> objects etc.. then literal_eval would fail so it really depends on what your dict can contain as to whether it will work or not.</p>
<p>If you need a recursive approach, all you need is to call reassign on the new dict.</p>
<pre><code>def reassign(d):
    for k, v in d.items():
        try:
            evald = literal_eval(v)
            if isinstance(evald, dict):
                d[k] = evald
                reassign(evald)
        except ValueError:
            pass
</code></pre>
<p>And again just pass the dict:</p>
<pre><code>In [10]: my_dict = {'a': 42, 'b': "my_string", 'c': "{'d': 33, 'e': \"{'f' : 64}
    ...: \"}"}

In [11]: reassign(my_dict)

In [12]: my_dict
Out[12]: {'a': 42, 'b': 'my_string', 'c': {'d': 33, 'e': {'f': 64}}}
</code></pre>
<p>And if you want a new dict:</p>
<pre><code>from ast import literal_eval
from copy import deepcopy

def reassign(d):
    for k, v in d.items():
        try:
            evald = literal_eval(v)
            if isinstance(evald, dict):
                yield k, dict(reassign(evald))
        except ValueError:
            yield k, deepcopy(v)
</code></pre>
<p>Which will give you a new dict:</p>
<pre><code>In [17]: my_dict = {'a': [1, 2, [3]], 'b': "my_string", 'c': "{'d': 33, 'e': \"{
    ...: 'f' : 64}\"}"}

In [18]: new =  dict(reassign(my_dict))

In [19]: my_dict["a"][-1].append(4)

In [20]: new
Out[20]: {'a': [1, 2, [3]], 'b': 'my_string', 'c': {'d': 33, 'e': {'f': 64}}}

In [21]: my_dict
Out[21]: 
{'a': [1, 2, [3, 4]],
 'b': 'my_string',
 'c': '{\'d\': 33, \'e\': "{\'f\' : 64}"}'}
</code></pre>
<p>You need to make sure to <em>deepcopy</em> objects or you won't get a true independent copy of the dict when you have nested object like  the list of lists above.</p>
</div>
<div class="post-text" itemprop="text">
<p>The general idea referenced in my above comment is to run thru the dictionary and try and evaluate. Store that in a local variable, and then check if that evaluated expression is a dictionary. If so, then reassign it to the passed input. If not, leave it alone. </p>
<pre><code>my_dict = {'a': 42, 'b': "my_string", 'c': "{'d': 33, 'e': 'another string'}"}

def convert_to_dict(d):
    for key, val in d.items():
        try:
            check = ast.literal_eval(val)
        except:
            continue 
        if isinstance(check, dict):
            d[key] = check 
    return d

convert_to_dict(my_dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you need to handle nested <code>str</code> defining <code>dict</code>, <a href="https://docs.python.org/3/library/json.html#json.loads" rel="nofollow"><code>json.loads</code> with an <code>object_hook</code></a> might work for you:</p>
<pre><code>import json

def convert_subdicts(d):
    for k, v in d.items():
        try:
            # Try to decode a dict
            newv = json.loads(v, object_hook=convert_subdicts)
        except Exception:
            continue
        else:
            if isinstance(newv, dict):
                d[k] = newv  # Replace with decoded dict
    return d

origdict = {'a': 42, 'b': "my_string", 'c': "{'d': 33, 'e': 'another string'}"}
newdict = convert_subdicts(origdict.copy())  # Omit .copy() if mutating origdict okay
</code></pre>
<p>That should recursively handle the case where the contained <code>dict</code>s might contain <code>str</code>s values that define subdicts. If you don't need to handle that case, you can omit the use of the <code>object_hook</code>, or replace <code>json.loads</code> entirely with <code>ast.literal_eval</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The other answers were really good and lead me to the right solution, but the previous accepted answer had a bug. Here is my working solution:</p>
<pre><code>def recursive_dict_eval(myDict):
    for key,value in myDict.items():
        try:
            if(isinstance(value, dict)):
                recursive_dict_eval(value)
            evaled_value=ast.literal_eval(value)
            assert isinstance(evaled_value,dict)
            myDict[key]=recursive_dict_eval(evaled_value)

        except (SyntaxError, ValueError, AssertionError):
            #SyntaxError, ValueError are for the literal_eval exceptions
            pass
    return myDict
</code></pre>
</div>
<span class="comment-copy">I think the strategy would be to eval and then run <code>isinstance</code> or something similar to check if it is a dict</span>
<span class="comment-copy">Can you make an example? Because if I recursively eval the values in the dict I will get an error.</span>
<span class="comment-copy">Use literal_eval in a try/except, check if it is a dict in the try and reassign the key to the new value</span>
<span class="comment-copy">@PadraicCunningham, why not make that an answer?</span>
<span class="comment-copy">You could <code>continue</code> in the <code>except</code> block and/or use an <code>else:</code> following the <code>except</code> block to only execute the <code>isinstance</code> and assignment if no exception is thrown. Nicer than needing to set <code>check = False</code> and test it later when you know it's invalid anyway.</span>
