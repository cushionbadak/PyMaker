<div class="post-text" itemprop="text">
<p>I found I often use same pattern in tests again and again:</p>
<pre><code>mock_get_data = mock.MagicMock()
mock_get_data.get_data.return_value = "mocked DB data"
mock_db = mock.Mock(spec=DBClass, return_value=mock_get_data)
</code></pre>
<p>It would be used for testing (with patching) that type of code:</p>
<pre><code>db_connector = DBClass(settings)
print db_connector.get_data()
</code></pre>
<p>Is any way to make that 'double mock' thing shorter?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do like this:</p>
<pre><code>mock_db = mock.Mock(spec=DBClass, return_value=mock.Mock(get_data=lambda:"mocked DB data"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should be able to do this by passing in a dictionary to the constructor, as described in the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.configure_mock" rel="nofollow">configure mock</a> section of the docs, instead of configuring it after the MagicMock is created.</p>
<p>I believe the following would achieve the desired result:</p>
<pre><code>mock_db = mock.Mock(spec=DBClass, return_value=mock.MagicMock(**{"get_data.return_value": "mocked DB data"})
</code></pre>
</div>
<span class="comment-copy">Is any way to do it without double mock.Mock creation?</span>
<span class="comment-copy">You can pass any other object, For example configure class it in the fixtures and pass it like a return_value, but i think that Mock is the more proper way</span>
