<div class="post-text" itemprop="text">
<p>I saw <a href="https://stackoverflow.com/questions/13635032/what-is-the-inverse-function-of-zip-in-python">this</a>, and <a href="https://stackoverflow.com/questions/19339/a-transpose-unzip-function-in-python-inverse-of-zip">this</a> questions and I'd like to have the same effect, only efficiently done with <a href="https://docs.python.org/2/library/itertools.html#itertools.izip" rel="nofollow noreferrer"><code>itertool.izip</code></a>.</p>
<p>From <code>itertool.izip</code>'s documentation:</p>
<blockquote>
<p>Like zip() except that it returns an iterator instead of a list</p>
</blockquote>
<p>I need an iterator because I can't fit all values to memory so instead I'm using a generator and iterating over the values.</p>
<p>More specifically, I have a generator that generates a three values tuple, and instead of iterating it I'd like to feed three lists of values to three functions, each list represents a single position in the tuple.</p>
<p>Out of those three-tuple-values, only one is has big items (memory consumption wise) in it (lets call it <code>data</code>) while the other two contain only values that require only little amount of memory to hold, so iterating over the <code>data</code> value's "list of values" first should work for me by consuming the <code>data</code> values one by one, and caching the small ones.</p>
<p>I can't think of a smart way to generate one "list of values" at a time, because I might decide to remove instances of a three-value-tuple occasionally, depending on the big value of the tuple.  </p>
<p>Using the widely suggested <code>zip</code> solution, similar to:</p>
<pre><code>&gt;&gt;&gt; zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
[('a', 'b', 'c', 'd'), (1, 2, 3, 4)]
</code></pre>
<p>Results in the "unpacking argument list" part (*[...]) of this to trigger a full iteration over the entire iterator and (I assume) cache all results in memory, which is as I said, an issue for me.</p>
<p>I can build a mask list (True/False for small values to keep), but I'm looking for a cleaner more pythonic way. If all else fails, I'll do that.</p>
</div>
<div class="post-text" itemprop="text">
<p>What's wrong with a traditional loop?</p>
<pre><code>&gt;&gt;&gt; def gen():
...     yield 'first', 0, 1
...     yield 'second', 2, 3
...     yield 'third', 4, 5
...
&gt;&gt;&gt; numbers = []
&gt;&gt;&gt; for data, num1, num2 in gen():
...     print data
...     numbers.append((num1, num2))
...
first
second
third
&gt;&gt;&gt; numbers
[(0, 1), (2, 3), (4, 5)]
</code></pre>
</div>
<span class="comment-copy">So the 'data' values might go into the third entry in the 3-tuple, and the shorter lists into the first and second, yes? Can you describe what is supposed to happen when those shorter lists are exhausted? Preferably give an explicit example using two very short lists and a slightly longer one.</span>
<span class="comment-copy">@barny The lists themselves all have the same length, I was talking about the size (i.e memory requirements) of individual values in the lists. Data values are too big to hold in memory together.</span>
<span class="comment-copy">Phrasing was indeed unclear, edited.</span>
<span class="comment-copy">so you want to <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer">filter</a> your data?</span>
<span class="comment-copy">No, I cannot use a filter because I also need to actually process <code>data</code> (which must be an iterator). I can obviously iterate twice but one iteration takes about an hour now and I'll soon double the number of items.</span>
<span class="comment-copy">Thanks, this could work but I'm passing the data generator to a library function without control of how it iterates over the values, so I can't have it append the other values to other lists.</span>
<span class="comment-copy">@NirIzr - Make a wrapper, then?</span>
<span class="comment-copy">Yes, Thanks! Have no idea how I overlooked that.</span>
