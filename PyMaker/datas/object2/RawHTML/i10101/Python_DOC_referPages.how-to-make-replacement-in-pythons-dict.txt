<div class="post-text" itemprop="text">
<p>The goal I want to achieve is to exchange all items whose form is <code>#item_name#</code> to the from <code>(item_value)</code> in the dict. I use two <code>dict</code> named <code>test1</code> and <code>test2</code> to test my function. Here is the code:</p>
<pre><code>test1={'integer_set': '{#integer_list#?}', 'integer_list': '#integer_range#(?,#integer_range#)*', 'integer_range': '#integer#(..#integer#)?', 'integer': '[+-]?\\d+'}
test2={'b': '#a#', 'f': '#e#', 'c': '#b#', 'e': '#d#', 'd': '#c#', 'g': '#f#', 'a': 'correct'}
def change(pat_dict:{str:str}):
    print('Expanding: ',pat_dict)
    num=0
    while num&lt;len(pat_dict):
        inv_pat_dict = {v: k for k, v in pat_dict.items()}
        for value in pat_dict.values():
            for key in pat_dict.keys():
                if key in value:
                    repl='#'+key+'#'
                    repl2='('+pat_dict[key]+')'
                    value0=value.replace(repl,repl2)
                    pat_dict[inv_pat_dict[value]]=value0 
        num+=1
    print('Result: ',pat_dict)    

change(test1)
change(test2)
</code></pre>
<p>sometimes I can get correct result like:</p>
<pre><code>Expanding:  {'integer': '[+-]?\\d+', 'integer_list': '#integer_range#(?,#integer_range#)*', 'integer_set': '{#integer_list#?}', 'integer_range': '#integer#(..#integer#)?'}
Result:  {'integer': '[+-]?\\d+', 'integer_list': '(([+-]?\\d+)(..([+-]?\\d+))?)(?,(([+-]?\\d+)(..([+-]?\\d+))?))*', 'integer_set': '{((([+-]?\\d+)(..([+-]?\\d+))?)(?,(([+-]?\\d+)(..([+-]?\\d+))?))*)?}', 'integer_range': '([+-]?\\d+)(..([+-]?\\d+))?'}
Expanding:  {'c': '#b#', 'f': '#e#', 'e': '#d#', 'b': '#a#', 'g': '#f#', 'd': '#c#', 'a': 'correct'}
Result:  {'c': '((correct))', 'f': '(((((correct)))))', 'e': '((((correct))))', 'b': '(correct)', 'g': '((((((correct))))))', 'd': '(((correct)))', 'a': 'correct'}
</code></pre>
<p>But most of time I get wrong results like that:</p>
<pre><code>Expanding:  {'integer_range': '#integer#(..#integer#)?', 'integer': '[+-]?\\d+', 'integer_set': '{#integer_list#?}', 'integer_list': '#integer_range#(?,#integer_range#)*'}
Result:  {'integer_range': '([+-]?\\d+)(..([+-]?\\d+))?', 'integer': '[+-]?\\d+', 'integer_set': '{(#integer_range#(?,#integer_range#)*)?}', 'integer_list': '#integer_range#(?,#integer_range#)*'}
Expanding:  {'f': '#e#', 'a': 'correct', 'd': '#c#', 'g': '#f#', 'b': '#a#', 'c': '#b#', 'e': '#d#'}
Result:  {'f': '(((((correct)))))', 'a': 'correct', 'd': '(((correct)))', 'g': '((((((correct))))))', 'b': '(correct)', 'c': '((correct))', 'e': '((((correct))))'}
</code></pre>
<p>How could I update my code to achieve my goal?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is caused by the fact that python dictionaries are unordered. Try using a <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow">OrderedDict</a> instead of <code>dict</code> and you should be fine. The OrderedDict works just like a normal <code>dict</code> but with ordering retained, at a small performance cost.</p>
<p>Note that while you could create an OrderedDict from a dict literal (like I did here at first), that dict would be unordered, so the ordering might not be guaranteed. Using a list of <code>(key, value)</code> pairs preserves the ordering in all cases.</p>
<pre><code>from collections import OrderedDict

test1=OrderedDict([('integer_set', '{#integer_list#?}'), ('integer_list', '#integer_range#(?,#integer_range#)*'), ('integer_range', '#integer#(..#integer#)?'), ('integer', '[+-]?\\d+')])
test2=OrderedDict([('b', '#a#'), ('f', '#e#'), ('c', '#b#'), ('e', '#d#'), ('d', '#c#'), ('g', '#f#'), ('a', 'correct')])
def change(pat_dict:{str:str}):
    print('Expanding: ',pat_dict)
    num=0
    while num&lt;len(pat_dict):
        inv_pat_dict = {v: k for k, v in pat_dict.items()}
        for value in pat_dict.values():
            for key in pat_dict.keys():
                if key in value:
                    repl='#'+key+'#'
                    repl2='('+pat_dict[key]+')'
                    value0=value.replace(repl,repl2)
                    pat_dict[inv_pat_dict[value]]=value0
        num+=1
    print('Result: ',pat_dict)

change(test1)
change(test2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this one. Your problem is due to mutating starting dict. You need to change its copy.</p>
<pre><code>test1={'integer_set': '{#integer_list#?}', 'integer_list': '#integer_range#(?,#integer_range#)*', 'integer_range': '#integer#(..#integer#)?', 'integer': '[+-]?\\d+'}
test2={'b': '#a#', 'f': '#e#', 'c': '#b#', 'e': '#d#', 'd': '#c#', 'g': '#f#', 'a': 'correct'}
def change(d):
    new_d = d.copy()
    for k in d.keys():
        for nk, v in new_d.items():
            if k in v:
                new_d[nk] = v.replace('#{}#'.format(k), '({})'.format(new_d[k]))
    return new_d

test1 = change(test1)
test2 = change(test2)
</code></pre>
</div>
<span class="comment-copy">The randomization is <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">to prevent web services from being DoS-ed</a> when the user can create arbitrary keys in a <code>dict</code> and might craft said keys to cause hash collisions, reducing most <code>dict</code> operations from <code>O(1)</code> to <code>O(n)</code>. The fact that it affects iteration order is not actually a design <i>goal</i> (and in fact, in CPython 3.6, <code>dict</code>s are likely to iterate in insertion order by default due to an implementation change that happens to achieve that as a free side-effect of a change to less memory hungry <code>dict</code> design).</span>
<span class="comment-copy">I stand corrected. The same behaviour is present in Go, where it is to avoid developers trusting the ordering of <code>map</code> output. Edited. What I don't get is why iteration order would change on each read without intermittent writes; how would this avoid a hash collision? @ShadowRanger</span>
