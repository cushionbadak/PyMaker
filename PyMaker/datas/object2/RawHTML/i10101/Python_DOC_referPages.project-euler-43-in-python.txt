<div class="post-text" itemprop="text">
<p>I came across another difficult Project Euler problem 
<a href="https://projecteuler.net/problem=43" rel="nofollow">Link to the problem</a></p>
<p>My first instinct was to try a simple brute force solution, which took too much time to run.</p>
<p>So I thought of a nicer solution, but I have no idea, how to code it.</p>
<p>I want to:</p>
<ol>
<li>Generate all the necessary triplets.</li>
<li>Put together all the combinations.</li>
<li>Calculate the sum.</li>
</ol>
<p>I did the step 1, my result looks something like this:</p>
<pre><code>Multiples of 17: [[0, 1, 7], [0, 3, 4], [0, 5, 1], [0, 6, 8], [0, 8, 5], [1,   0, 2], [1, 3, 6], [1, 5, 3], [1, 7, 0], [1, 8, 7], [2, 0, 4], [2, 3, 8], [2, 8, 9], [3, 0, 6], [3, 4, 0], [3, 5, 7], [3, 7, 4], [3, 9, 1], [4, 0, 8], [4, 2, 5], [4, 5, 9], [4, 7, 6], [4, 9, 3], [5, 1, 0], [5, 2, 7], [5, 6, 1], [5, 7, 8], [6, 1, 2], [6, 2, 9], [6, 8, 0], [6, 9, 7], [7, 1, 4], [7, 3, 1], [7, 4, 8], [7, 6, 5], [7, 8, 2], [8, 1, 6], [8, 5, 0], [8, 6, 7], [9, 0, 1], [9, 1, 8], [9, 3, 5], [9, 5, 2], [9, 8, 6]] etc...
</code></pre>
<p>Now here comes the tricky part for me. I tried putting them together with nested loops, but that was really messy. If you have any advice please tell me :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, the brute force solution hardly takes any time to run.</p>
<p>As @MooingRawr suggests, if you use <code>itertools.permutations</code> there are only <em>~ 0.9 x 9!</em> permutations of <em>0123456789</em> that don't start with a zero.</p>
<pre><code>from itertools import permutations

primes = [17, 13, 11, 7, 5, 3, 2]

total = 0

# Generate permutations of 10 distict digits -- 10 factorial
for i in permutations('0123456789'):

  # Discard those that begin with zero -- one-tenth of 10!
  if i[0] == '0':
    continue 

  # Convert into a string and assume that it is valid
  n = ''.join(list(i))
  valid = True

  # Check if the last three digits are divisible by 17, ...
  #    ... then shift left and check if those digits are divisible by 13, etc.
  for j in xrange(0, len(primes)):
    x = n[len(primes) - j:len(primes) - j + 3]
    if int(x) % primes[j]:
      valid = False
      break

  # Print and add
  if valid:
    print 'Valid number: %s' % n
    total += int(n)

print 'Total: %d' % total
</code></pre>
<p>If you run this solution <a href="https://repl.it/JEuR/1" rel="nofollow noreferrer">here</a>, it runs within a few seconds, which should be fine for PE.</p>
<p>However, the approach you suggest is indeed more efficient. Note, you had hardcoded seven loops, I simply used <code>factors</code> to generate them, where <code>factor[i]</code> is a factor of <em>d_i d_i+1 d_i+2</em>.</p>
<p>You worried about generating all the combinations, but this is trivial using recursion, where each iteration checks the last two digits and finds a valid next digit.</p>
<pre><code>factors = [1, 2, 3, 5, 7, 11, 13, 17]
valid_len = len(factors)
valid_sequences  = []
total = 0

# Checks for a 3-digit number with 3 unique digits
def not_unique(digits):
  return (digits[0] == digits[1]) or (digits[1] == digits[2]) or (digits[0] == digits[2])


# For each of the prime numbers, generate all valid triples that have unique digits
for i in xrange(0 ,len(factors)):
  current_map = {}
  for j in xrange(factors[i], 1000, factors[i]):
    digits = str(j).zfill(3)

    # Prune those numbers that have non-unique digits
    if not_unique(digits):
      continue

    # current_map is of the form {'d1d2':[list of all possible valid d3s], ...}
    if digits[:2] not in current_map:
      current_map[digits[:2]] = [digits[2]]
    else:
      current_map[digits[:2]].append(digits[2])

  valid_sequences.append(current_map)


# Checks each triple starting with the 3 most significant digits
# Get the last two digits, and find all the valid values for the next one digit
# Perform recursively
def get_matches_starting_with(sequence, index):
  global total
  if index == valid_len:
    print 'Valid number: %s' % sequence
    total += int(sequence)
  else:
    pair = sequence[-2:]
    if pair in valid_sequences[index]:
      for digit in valid_sequences[index][pair]:
        if not digit in sequence:
          get_matches_starting_with(sequence + digit, index + 1)

all_matches = []
for pair in valid_sequences[0]:
  if pair[0] == '0':
      continue
  for digit in valid_sequences[0][pair]:
    triple = pair + digit
    all_matches.append(get_matches_starting_with(triple, 1))

print 'Total: %d' % total
</code></pre>
<p>You may want to run the solution <a href="https://repl.it/JEze" rel="nofollow noreferrer">here</a> and perhaps print the values at intermediate steps to see what is going on.</p>
<p>There is still a lot of opportunities for pruning the number of explored states. Your approach brought it down from 3265920 to about 3000. </p>
</div>
<span class="comment-copy">itertools permutations found here. <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.permutations</a></span>
<span class="comment-copy">Could we see the mess before advising? :)</span>
<span class="comment-copy">Here it is [Pastebin link] (<a href="http://pastebin.com/E4xdcFwJ" rel="nofollow noreferrer">pastebin.com/E4xdcFwJ</a>). Note, that the code isn't working at all. I'm looking for more like a general advice on how to structure the solution.</span>
