<div class="post-text" itemprop="text">
<p>I am using pythons mock.patch and would like to change the return value for each call.
Here is the caveat:
the function being patched has no inputs, so I can not change the return value based on the input.</p>
<p>Here is my code for reference.</p>
<pre><code>def get_boolean_response():
    response = io.prompt('y/n').lower()
    while response not in ('y', 'n', 'yes', 'no'):
        io.echo('Not a valid input. Try again'])
        response = io.prompt('y/n').lower()

    return response in ('y', 'yes')
</code></pre>
<p>My Test code:</p>
<pre><code>@mock.patch('io')
def test_get_boolean_response(self, mock_io):
    #setup
    mock_io.prompt.return_value = ['x','y']
    result = operations.get_boolean_response()

    #test
    self.assertTrue(result)
    self.assertEqual(mock_io.prompt.call_count, 2)
</code></pre>
<p><code>io.prompt</code> is just a platform independent (python 2 and 3) version of "input". So ultimately I am trying to mock out the users input. I have tried using a list for the return value, but that doesn't seam to work.</p>
<p>You can see that if the return value is something invalid, I will just get an infinite loop here. So I need a way to eventually change the return value, so that my test actually finishes.</p>
<p>(another possible way to answer this question could be to explain how I could mimic user input in a unit-test)</p>
<hr/>
<p>Not a dup of <a href="https://stackoverflow.com/questions/7665682/python-mock-object-with-method-called-multiple-times">this question</a> mainly because I do not have the ability to vary the inputs.</p>
<p>One of the comments of the Answer on <a href="https://stackoverflow.com/questions/21927057/mock-patch-os-path-exists-with-multiple-return-values">this question</a> is along the same lines, but no answer/comment has been provided.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can assign an <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="noreferrer"><em>iterable</em></a> to <code>side_effect</code>, and the mock will return the next value in the sequence each time it is called:</p>
<pre><code>&gt;&gt;&gt; from unittest.mock import Mock
&gt;&gt;&gt; m = Mock()
&gt;&gt;&gt; m.side_effect = ['foo', 'bar', 'baz']
&gt;&gt;&gt; m()
'foo'
&gt;&gt;&gt; m()
'bar'
&gt;&gt;&gt; m()
'baz'
</code></pre>
<p>Quoting the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock" rel="noreferrer"><code>Mock()</code> documentation</a>:</p>
<blockquote>
<p>If <em>side_effect</em> is an iterable then each call to the mock will return the next value from the iterable.</p>
</blockquote>
<p>As an aside, the test <code>response is not 'y' or 'n' or 'yes' or 'no'</code> will <strong>not</strong> work; you are asking if the expression <code>(response is not 'y')</code> is true, or <code>'y'</code> is true (always the case, a non-empty string is always true), etc. The various expressions on either side of <code>or</code> operators are <em>independent</em>. See <a href="https://stackoverflow.com/q/15112125">How do I test one variable against multiple values?</a></p>
<p>You should <em>also</em> not use <code>is</code> to test against a string. The CPython interpreter <em>may</em> reuse string objects <a href="https://stackoverflow.com/a/24245514">under certain circumstances</a>, but this is not behaviour you should count on.</p>
<p>As such, use:</p>
<pre><code>response not in ('y', 'n', 'yes', 'no')
</code></pre>
<p>instead; this will use <em>equality</em> tests (<code>==</code>) to determine if <code>response</code> references a string with the same contents (value).</p>
<p>The same applies to <code>response == 'y' or 'yes'</code>; use <code>response in ('y', 'yes')</code> instead.</p>
</div>
<span class="comment-copy"><code>response is not 'y' or 'n' or 'yes' or 'no'</code> in <b>not</b> doing what you think it does. See <a href="http://stackoverflow.com/q/15112125">How do I test one variable against multiple values?</a> and you should <i>not</i> use <code>is</code> to compare string values, use <code>==</code> to compare <i>values</i>, not object identities.</span>
<span class="comment-copy">Also be careful here.  It seems that you're trying to use <code>is</code> to compare string literals.  Don't do that.  The fact that it works (sometimes) is only an implementation detail in CPython.  Also, <code>response is not 'y' or 'n' or 'yes' or 'no'</code> probably isn't doing what you think it is...</span>
<span class="comment-copy">Is there a way to do this with the standard <code>mock</code>? Is there a way to use patch with MagicMock like i am doing with standard mock?</span>
<span class="comment-copy">@Humdinger: This is a feature of the stardard <code>Mock</code> class.</span>
<span class="comment-copy">Assigning a list appears to work with python 3 only. Testing with python 2.7 I need to use an iterator instead (<code>m.side_effect = iter(['foo', 'bar', 'baz'])</code>).</span>
<span class="comment-copy">@user686249: I can indeed reproduce this, because speccing from a method produces a <code>lambda</code> (a function), not a <code>MagicMock</code>. A function object cannot <i>have</i> properties, so the <code>side_effect</code> attribute <i>has</i> to be an iterable. You should not be speccing the method like that though. Better use <a href="https://docs.python.org/3/library/unittest.mock.html#patch-object" rel="nofollow noreferrer"><code>mock.patch.object(requests.Session, 'post')</code></a>; that results in a patcher object that properly auto-specs on the method, <b>and</b> supports <code>side_effect</code> properly.</span>
<span class="comment-copy">@JoeMjr2: When the iterator is exhausted, <code>StopIteration</code> is raised.  You can use any iterator, so you could use <code>itertools.chain(['Foo'], itertools.repeat('Bar'))</code> to produce <code>Foo</code> once, then forever produce <code>Bar</code>.</span>
