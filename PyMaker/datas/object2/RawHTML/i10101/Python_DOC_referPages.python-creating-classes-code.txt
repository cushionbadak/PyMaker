<div class="post-text" itemprop="text">
<p>Sorry for the poor title, didnt know what to put.</p>
<p>When creating a class in python i use this,</p>
<pre><code>class NewClass(object):
    def __init__(self,name):
        self.name = name
</code></pre>
<p>but why is it different to this?</p>
<pre><code>class NewClass(object):
    def __init__(self,name):
        name = self.name
</code></pre>
<p>Surely the equals sign means it is the same process? Why is different?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>=</code> is an <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements">assignment statement</a>, you appear to be confusing this with a <code>==</code>, the <a href="https://docs.python.org/3/reference/expressions.html#comparisons">equality comparison operator</a>.</p>
<p>The statements are entirely different:</p>
<pre><code>self.name = name
</code></pre>
<p>assigns the value referenced by the local variable <code>name</code> to the attribute <code>name</code> on the object referenced by <code>self</code>. It sets an attribute on the newly created instance, from the value passed into the initialiser method.</p>
<p>The alternative statement</p>
<pre><code>name = self.name
</code></pre>
<p>assigns the value of the attribute <code>name</code> found on self, to the local variable <code>name</code>. It rebinds the local name (replaces the old value with a new). Once the method ends, the effects are gone. You are likely to get an <code>AttributeError</code> as the attribute <code>name</code> doesn't exist on <code>self</code> at that point in time.</p>
<p>If <code>==</code> had been used, then <em>usually</em> yes, <code>name == self.name</code> is the equivalent of <code>self.name == name</code>. However, objects can override how equality is tested by defining a new implementation for the <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__"><code>__eq__</code> method</a> so the two expressions <em>could</em> theoretically produce different results.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class NewClass(object):
    def __init__(self,name):
        self.name = name
</code></pre>
<p>This assigns the instance variable <code>self.name</code> to the value of the argument which was provided to <code>__init__()</code> (in this case <code>name</code>)</p>
<pre><code>class NewClass(object):
    def __init__(self,name):
        name = self.name
</code></pre>
<p>This assigns the instance variable <code>self.name</code> to the value of the argument <code>name</code>. This would throw an error if <code>self.name</code> was not assigned to something else earlier in the <code>__init__()</code> function.</p>
</div>
<span class="comment-copy"><code>=</code> is <b>assignment</b>, not an equality test. <code>self.name = name</code> sets the attribute <code>name</code> on the object referenced by <code>self</code>. <code>name = self.name</code> sets a local variable <code>name</code>.</span>
<span class="comment-copy">Assigning <code>name</code> to <code>self.name</code> and assigning <code>self.name</code> to <code>name</code> surely is differentâ€¦!?</span>
<span class="comment-copy"><code>a = b</code> means <code>change a to be equal to b</code>. That is different from <code>change b to be equal to a</code>.</span>
<span class="comment-copy">We expect a certain minimum familiarity with programming. Any basic programming course/tutorial/book would explain the difference between <code>=</code> and <code>==</code>.</span>
<span class="comment-copy">Which should be obvious if you understand what <code>=</code> does, no?</span>
<span class="comment-copy">I find the terms used very sloppy/incorrect. The first sentence is somewhere between vague and backwards.</span>
<span class="comment-copy">@MartijnPieters My mistake - it is an instance variable, isn't it?</span>
<span class="comment-copy"><i>Class variables</i> would more readily be interpreted as <i>class attributes</i>, attributes that are defined on the class itself rather than on the instance.</span>
