<div class="post-text" itemprop="text">
<pre><code>from checker.checker import check_board_state, check_row, check_winner,\
    check_column, check_diagonal

import sys
import unittest


class TestChecker(unittest.TestCase):

    def test_winner_row(self):
        check_board_state([['o', 'x', '.'],
                          ['o', 'o', 'o'],
                          ['.', 'x', 'o']])

        output = sys.stdout.getvalue().strip()
        assert output == 'o'

    def test_draw(self):
        check_board_state([['.', 'x', '.', 'o', 'o'],
                          ['o', 'o', 'x', '.', '.'],
                          ['.', 'o', 'x', '.', '.'],
                          ['.', 'o', 'x', '.', '.'],
                          ['.', 'o', 'x', '.', '.']])

        output = sys.stdout.getvalue().strip()
        assert output == '.'


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>I want to test printed value in check_board_state function but I have problem with these tests. When I try to run them  using     </p>
<blockquote>
<p>python -m unittest tests.py </p>
</blockquote>
<p>i've got error:</p>
<blockquote>
<p>AttributeError: '_io.TextIOWrapper' object has no attribute 'getvalue'</p>
</blockquote>
<p>Tests works fine in PyDev in Eclipse when I use Python unittest instead of Python run. How Can I resolve this problem?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from checker import checker
from io import StringIO
import sys
import unittest


class TestChecker(unittest.TestCase):
    def setUp(self):
        # every test instance the class(setUp)
        self.cls = checker()
        old_stdout = sys.stdout
        sys.stdout = mystdout = StringIO()
        super(TestChecker, self).setUp()

    def test_winner_row(self):
        # the modules should give a return
        self.cls.check_board_state([['o', 'x', '.'],
                                   ['o', 'o', 'o'],
                                   ['.', 'x', 'o']])

        result = sys.stdout.getvalue().strip()
        excepted = "o"
        # use unittests assertion methods
        self.assertEqual(excepted, result)

    def test_draw(self):
        self.cls.check_board_state([['.', 'x', '.', 'o', 'o'],
                                   ['o', 'o', 'x', '.', '.'],
                                   ['.', 'o', 'x', '.', '.'],
                                   ['.', 'o', 'x', '.', '.'],
                                   ['.', 'o', 'x', '.', '.']])
        result = sys.stdout.getvalue().strip()
        excepted = "."
        self.assertEqual(excepted, result)

    def tearDown(self):
        sys.stdout = old_stdout
        super(TestChecker, self).tearDown()
if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<span class="comment-copy">You could change check_board_state so it returns the result instead of printing it to stdout, or add a parameter that defaults to sys.stdout that you could pass from your tests, kind of like the <a href="https://docs.python.org/3/library/functions.html?highlight=print#print" rel="nofollow noreferrer">print</a> function in python3</span>
<span class="comment-copy">You need to redirect <code>stdout</code> to a buffer that you can test. <a href="http://stackoverflow.com/questions/1218933/can-i-redirect-the-stdout-in-python-into-some-sort-of-string-buffer">See this</a>. Also use the <code>assert</code> methods that come with <code>unittest.TestCase</code>, they are much richer and more readable.</span>
<span class="comment-copy">Explain your answer.</span>
<span class="comment-copy">Nice clean execution but you make assumptions about the return value of the function under test. If you correct this I will vote up.</span>
<span class="comment-copy">@Dan true. thanks for the feedback, i change that</span>
