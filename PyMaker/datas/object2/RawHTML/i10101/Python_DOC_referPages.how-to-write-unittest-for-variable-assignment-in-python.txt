<div class="post-text" itemprop="text">
<p>This is in <code>Python 2.7</code>.  I have a class called <code>class A</code>, and there are some attributes that I want to throw an exception when being set by the user:</p>
<pre><code>myA = A()
myA.myattribute = 9   # this should throw an error
</code></pre>
<p>I want to write a <code>unittest</code> that ensures that this throws an error.  </p>
<p>After creating a test class and inheriting <code>unittest.TestCase</code>, I tried to write a test like this:</p>
<pre><code>myA = A()
self.assertRaises(AttributeError, eval('myA.myattribute = 9'))
</code></pre>
<p>But, this throws a <code>syntax error</code>.  However, if I try <code>eval('myA.myattribute = 9')</code>, it throws the attribute error, as it should.</p>
<p>How do I write a unittest to test this correctly?  </p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <code>assertRaises</code> as a context manager:</p>
<pre><code>with self.assertRaises(AttributeError):
    myA.myattribute = 9
</code></pre>
<p>The <a href="https://docs.python.org/3/library/unittest.html#basic-example" rel="nofollow">documentation shows more examples for this if you are interested</a>. The documentation for <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaises" rel="nofollow">assertRaises</a> has a lot more detail on this subject as well.</p>
<p>From that documentation:</p>
<blockquote>
<p>If only the exception and possibly the msg arguments are given, return a context manager so that the code under test can be written
  inline rather than as a function:</p>
<pre><code>with self.assertRaises(SomeException):
     do_something()
</code></pre>
</blockquote>
<p>which is exactly what you are trying to do.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>self.assertRaises</code> takes a callable (and optionally one or more arguments for that callable) as its argument; you are providing the value that results from calling the callable with its arguments. The correct test would be <strike><code>self.assertRaises(AttributeError, eval, 'myA.myattribute = 9')</code></strike></p>
<pre><code># Thanks to @mgilson for something that actually works while
# resembling the original attempt.
self.assertRaises(AttributeError, eval, 'myA.myattribute = 9', locals())
</code></pre>
<p>However, you should use <code>assertRaises</code> as a context manager, which allows you to write the much more natural</p>
<pre><code>with self.assertRaises(AttributeError):
    myA.myattribute = 9
</code></pre>
</div>
<span class="comment-copy">Would that first form work?  <code>eval</code> will evaluate the expression in the current namespace -- which is the namespace in which <code>eval</code> is getting called which would <i>not</i> have <code>myA</code> defined.  If you're going to use the functional form (which isn't advised), you probably should go with <code>self.assertRaises(AttributeError, setattr, myA, 'myattribute', 9)</code>, <i>or</i> you'll have to pass the current function's locals through:  <code>self.assertRaises(AttributeError, eval, 'myA.myattribute = 9', locals())</code></span>
<span class="comment-copy">The second one works, but the first one doesn't</span>
<span class="comment-copy">Yeah, I didn't really give any thought to how you would correctly use <code>eval</code>. I should have just explained that <code>assertRaises</code> takes something that <i>it</i> can call, rather than the result of a expression, and left it at that.</span>
