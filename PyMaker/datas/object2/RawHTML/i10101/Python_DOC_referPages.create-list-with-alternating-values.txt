<div class="post-text" itemprop="text">
<p>I'm looking to create a list whose values alternate based on a set of known patterns. Note that there may not be an equal number of items with each prefix. (2 foos, 3 bars, 3 spams). My current solution is nasty gaggle that .pop()'s from lists built from common prefixes and appends to a new list.</p>
<pre><code>prefix_patterns = ['foo','bar','spam']

inlist = ['fooABC','fooXYZ','barABC','barXYZ','spamABC','bar123','spamXYZ','spam123']
</code></pre>
<p>Desired output:</p>
<pre><code>outlist = ['fooABC','barABC','spamABC','fooXYZ','barXYZ','spamXYZ','bar123','spam123']
</code></pre>
<p>Current solution (doesn't handle lists of differing lengths):</p>
<pre><code>foos = [value for value in inlist if 'foo' in value]
bars = [value for value in inlist if 'bar' in value]
spams = [value for value in inlist if 'spam' in value]

while foos:
    outlist.append(foos.pop())
    outlist.append(bars.pop())
    outlist.append(spams.pop())
</code></pre>
<p>For context: Looking to use this as a sort of throttling mechanism when making requests to 4 different servers.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you're using <strong>Python 2.x</strong> this would work:</p>
<pre><code># group by prefix first -&gt; [['fooXX']['barXX']['spamXX']]
prefix_match = [[x for x in inlist if x.startswith(pre)] for pre in prefix_patterns]
outlist = [x for i in map(None,*prefix_match) for x in i if x]
</code></pre>
<p>The <code>map</code> built-in function will zip <code>prefix_match</code> together and pad with <code>None</code> if one of the lists is too short. Then you can simply flatten this list and exclude any <code>None</code> objects. </p>
<p>For <strong>Python 3.x</strong> you could replace the map function with <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow">itertools.zip_longest</a>:</p>
<pre><code>from itertools import zip_longest
prefix_match = [[x for x in inlist if x.startswith(pre)] for pre in prefix_patterns]
outlist = [x for i in zip_longest(*prefix_match) for x in i if x]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>inlist =['fooABC','fooXYZ','barABC','barXYZ','spamABC','bar123','spamXYZ','spam123']

new_inlist = []

separator = '-'

# Adding separator, I believe it won't require in real scenario as there must be separator between host and user.
for prefix in ['foo', 'bar', 'spam']:
    for item in inlist:
        if item.startswith(prefix):
           new_inlist.append(item.replace(prefix, prefix + separator))

# Ultimately new_inlist -&gt;
#['foo-ABC','foo-XYZ','bar-ABC','bar-XYZ','spam-ABC','bar-123','spam-XYZ','spam-123']

# Now Just do sorting
new_inlist.sort(key=lambda x: x.split(separator)[1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd play with sorting:</p>
<pre><code>def prefix_sort(string):
    for prefix in ('foo','bar','spam'):
       if prefix == string[:len(prefix)]: break
    return (string[len(prefix):],prefix)

sorted(inlist,key=prefix_sort)
</code></pre>
<p>This would return the list lexicographical error in the words, and within word with the prefix.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're looking for the <a href="https://docs.python.org/3.4/library/itertools.html" rel="nofollow">itertools</a> recipe roundrobin.</p>
<pre><code>from itertools import cycle, islice

prefix_patterns = ['foo','bar','spam']
inlist = ['fooABC','fooXYZ','barABC','barXYZ','spamABC','bar123','spamXYZ','spam123']
outlist = ['fooABC','barABC','spamABC','fooXYZ','barXYZ','spamXYZ','bar123','spam123']

def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).__next__ for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))

def check_prefix(item):
    for prefix in prefix_patterns:
        if item.startswith(prefix):
            return prefix

group = {}
for item in inlist:
    key = check_prefix(item)
    group.setdefault(key, []).append(item)
print([x for x in roundrobin(*list(group.values()))])

&gt;&gt; ['barABC', 'spamABC', 'fooABC', 'barXYZ', 'spamXYZ', 'fooXYZ', 'bar123', 'spam123']
</code></pre>
</div>
<span class="comment-copy">generators are always a fun way to do things like this.. they save on memory too</span>
<span class="comment-copy">Could you show your current solution.</span>
<span class="comment-copy">Are the words sharing a prefix always sorted in inlist? foo&lt;str&gt; always befotre bar&lt;str&gt; before spam&lt;str&gt;</span>
<span class="comment-copy">@kabanus No, they are in random order</span>
<span class="comment-copy">@leaf done.....</span>
<span class="comment-copy">That doesn't answer the question: Sorting isn't mentioned or asked for. Why is it being provided?</span>
<span class="comment-copy">I think in question James didn't mention that he is not looking for sort solution that is why I added sort solution.</span>
