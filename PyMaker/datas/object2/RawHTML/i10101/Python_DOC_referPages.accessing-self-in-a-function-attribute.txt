<div class="post-text" itemprop="text">
<p>I'm trying to add a decorator that adds callable attributes to functions that return slightly different objects than the return value of the function, but will execute the function at some point.</p>
<p>The problem I'm running into is that when the function object is passed into the decorator, it is unbound and doesn't contain the implicit <code>self</code> argument.  When I call the created attribute function (ie. <code>string()</code>), I don't have access to <code>self</code> and can't pass it into the original function.</p>
<pre><code>def deco(func):
    """
    Add an attribute to the function takes the same arguments as the
    function but modifies the output.
    """
    def string(*args, **kwargs):
        return str(func(*args, **kwargs))
    func.string = string
    return func


class Test(object):

    def __init__(self, value):
        self._value = 1

    @deco
    def plus(self, n):
        return self._value + n
</code></pre>
<p>When I go to execute the attribute created by the decorator, this is the error I get, because <code>args</code> doesn't contain the <code>self</code> reference.</p>
<pre><code>&gt;&gt;&gt; t = Test(100)
&gt;&gt;&gt; t.plus(1)         # Gets passed self implicitly
101
&gt;&gt;&gt; t.plus.string(1)  # Does not get passed self implicitly
...
TypeError: plus() takes exactly 2 arguments (1 given)
</code></pre>
<p>Is there a way to create a decorator like this that can get a reference to <code>self</code>?  Or is there a way to <em>bind</em> the added attribute function (<code>string()</code>) so that it <em>also</em> gets called with the implicit <code>self</code> argument?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/howto/descriptor.html">descriptors</a> here:</p>
<pre><code>class deco(object):

    def __init__(self, func):
        self.func = func
        self.parent_obj = None

    def __get__(self, obj, type=None):
        self.parent_obj = obj
        return self

    def __call__(self, *args, **kwargs):
        return self.func(self.parent_obj, *args, **kwargs)

    def string(self, *args, **kwargs):
        return str(self(*args, **kwargs))


class Test(object):

    def __init__(self, value):
        self._value = value

    @deco
    def plus(self, n):
        return self._value + n
</code></pre>
<p>so that:</p>
<pre><code>&gt;&gt;&gt; test = Test(3)
&gt;&gt;&gt; test.plus(1)
4
&gt;&gt;&gt; test.plus.string(1)
'4'
</code></pre>
<p>This warrants an explanation. <code>deco</code> is a decorator, but it is also a <a href="https://docs.python.org/3/howto/descriptor.html">descriptor</a>. A descriptor is an object that defines alternative behavior that is to be invoked when the object is looked up as an attribute of its parent. Interestingly, bounds methods are themselves implemented using the descriptor protocol</p>
<p>That's a mouthful. Let's look at what happens when we run the example code. First, when we define the <code>plus</code> method, we apply the <code>deco</code> decorator. Now normally we see functions as decorators, and the return value of the function is the decorated result. Here we are using a class as a decorator. As a result, <code>Test.plus</code> isn't a function, but rather an <em>instance</em> of the <code>deco</code> type. This instance contains a reference to the <code>plus</code> function that we wish to wrap. </p>
<p>The <code>deco</code> class has a <code>__call__</code> method that allows instances of it to act like functions. This implementation simply passes the arguments given to the <code>plus</code> function it has a reference to. Note that the first argument will be the reference to the <code>Test</code> instance.</p>
<p>The tricky part comes in implementing <code>test.plus.string(1)</code>. To do this, we need a reference to the <code>test</code> instance of which the <code>plus</code> instance is an attribute. To accomplish this, we use the descriptor protocol. That is, we define a <code>__get__</code> method which will be invoked whenever the <code>deco</code> instance is accessed as an attribute of some parent class instance. When this happens, it stores the parent object inside itself. Then we can simply implement <code>plus.string</code> as a method on the <code>deco</code> class, and use the reference to the parent object stored within the <code>deco</code> instance to get at the <code>test</code> instance to which <code>plus</code> belongs.</p>
<p>This is a lot of magic, so here's a disclaimer: Though this looks cool, it's probably not a great idea to implement something like this.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to decorate your function at instantiation time (before creating the instance method). You can do this by overriding the <code>__new__</code> method:</p>
<pre><code>class Test(object):

    def __new__(cls, *args_, **kwargs_):
        def deco(func):
            def string(*args, **kwargs):
                return "my_str is :" + str(func(*args, **kwargs))
            # *1
            func.__func__.string = string
            return func

        obj = object.__new__(cls, *args_, **kwargs_)
        setattr(obj, 'plus', deco(getattr(obj, 'plus')))
        return obj

    def __init__(self, value):
        self._value = 1

    def plus(self, n):
        return self._value + n
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; t = Test(100)
&gt;&gt;&gt; t.plus(1)
&gt;&gt;&gt; t.plus.string(5)
&gt;&gt;&gt; 'my_str is :6'
</code></pre>
<hr/>
<p><sub>
1. Since python doesn't let you access the real instance attribute at setting time you can use <code>__func__</code> method in order to access the real function object of the instance method.
</sub></p>
</div>
<span class="comment-copy">You need to pass the <code>value</code> to calss at instantiation time! otherwise it will raise <code>TypeError: __init__() takes exactly 2 arguments (1 given)</code>.</span>
<span class="comment-copy">Interesting concept.. As for me, I have some doubt it's 100% possible, but will watch for answers for sure</span>
<span class="comment-copy">@Kasramvd Yeah, that was a typo in the question, it's fixed now.</span>
<span class="comment-copy">Another problem is that the decorator returns None, so you cant call the <code>plus</code> function.</span>
<span class="comment-copy">walking up call stack is only way comes to my mind so far, but it's definitely poor approach</span>
<span class="comment-copy">Thanks for the idea!  I really dislike that it breaks the decorator paradigm though.  So that you could look at the function definitions (see that they're decorated by the <code>@</code> syntax) and quickly know they have theses attributes.</span>
