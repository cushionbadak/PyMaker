<div class="post-text" itemprop="text">
<p>Here is the scenario:</p>
<p>I have two classes:</p>
<pre><code>class A:
  pass:

class B:
  pass
</code></pre>
<p>Now I want to create a client, in that I need to have a small utility method, which should return my class template/object e.g: class A, class B, as I pass on the class name to that utility e.g <code>get_obj(classA)</code>.</p>
<p>Now, is this possible? If then please suggest an approach, as I don't get any correct answer as of now in web.</p>
<p>Hope I am making sense.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a possible implementation. All the code is contained in a single '.py' file</p>
<pre><code>class A:                                                                                            
   pass                                                                                             


class B:                                                                                            
   pass                                                                                             

# map class name to class                                                                                                    
_classes = {                                                                                        
         A.__name__: A,                                                                             
         B.__name__: B,                                                                             
}                                                                                                   

def get_obj(cname):                                                                                       
    return _classes[cname]()                                                                            

# test the function                                                                                                    
if __name__ == '__main__':                                                                          
   print get_obj('A')   
</code></pre>
<p>It will produce the following output</p>
<pre><code>&lt;__main__.A instance at 0x1026ea950&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Standard library function <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow"><code>namedtuple</code></a> creates and returns a class. Internally it uses <code>exec</code>. It may be an inspiration for what you need.</p>
<p>Source code: <a href="https://github.com/python/cpython/blob/master/Lib/collections/__init__.py#L356" rel="nofollow">https://github.com/python/cpython/blob/master/Lib/collections/<strong>init</strong>.py#L356</a></p>
</div>
<div class="post-text" itemprop="text">
<p><code>globals()</code> returns a dictionary containing all symbols defined in the global scope of the module (including classes <code>A</code> and <code>B</code>):</p>
<p><em>a_and_b_module.py</em></p>
<pre class="lang-py prettyprint-override"><code>class A: pass
class B: pass

def get_cls(cls_name):
    return globals()[cls_name]
</code></pre>
<p><strong>If you are looking for simplicity</strong></p>
<p>If the code that will call this function is inside the module, then you can eliminate the function altogether and use <code>globals()[cls_name]</code> directly.</p>
<p>If the code that will call this function is outside the module, then you could use <code>getattr</code> function:</p>
<p><em>a_and_b_module.py</em></p>
<pre class="lang-py prettyprint-override"><code>class A: pass
class B: pass
</code></pre>
<p><em>another_file.py</em></p>
<pre class="lang-py prettyprint-override"><code>import a_and_b_module

cls_name = 'A'
chosen_cls = getattr(a_and_b_module, cls_name)
</code></pre>
<p><strong>If you are looking for complete control</strong></p>
<p>The problem with the approach above is that it could return anything defined in <em>a_and_b_module.py</em>, not restricting itself to <code>A</code> and <code>B</code>. If you want to make sure only A and B can be returned:</p>
<pre class="lang-py prettyprint-override"><code>class A: pass
class B: pass

allowed_classes = ('A', 'B')

def get_cls(cls_name):
    assert cls_name in allowed_classes
    return globals()[cls_name]
</code></pre>
<p>Note: you might also be interested in the concept of <a href="https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)" rel="nofollow">factory</a>.</p>
</div>
<span class="comment-copy">make the classes an <a href="https://jeffknupp.com/blog/2014/06/18/improve-your-python-python-classes-and-object-oriented-programming/" rel="nofollow noreferrer">object</a></span>
<span class="comment-copy">Yes, you can just have a <code>dict</code> like <code>cls = {'classA': A, 'classB': B}</code>, and then you can call <code>cls.get('classA')</code> for your <code>get_obj</code> implementation. This is a start though, but without much more details on what you are <i>actually</i> wanting to do the actual answer can be quite different.</span>
<span class="comment-copy">Why do you need it? What is an empty class, that this method would return, good for?</span>
<span class="comment-copy">It's funny that people are downvoting this answer considering that the designers of the language themselves seemingly have no problem using <code>exec</code> for this kind of thing.</span>
<span class="comment-copy">@RickTeachey I've downvoted it, because question is not about <b>defining</b> class. Is about defining <i>small utility method, which should return my class template/object e.g: class A, class B, as I pass on the class name to that utility</i>.</span>
<span class="comment-copy">I think we need more clarification from the original asker what should it really do. Whether he wants just a dict lookup like in @AnthonyKong's answer or something more dynamic.</span>
