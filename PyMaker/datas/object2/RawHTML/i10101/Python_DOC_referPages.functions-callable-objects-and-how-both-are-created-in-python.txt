<div class="post-text" itemprop="text">
<p>I'm wondering about the more intricate differences between functions and callable objects. For example, if you do:</p>
<pre><code>def foo1():
   return 2 + 4

class foo2:
   def __call__():
      return 2 + 4

import sys 
sys.getsizeof(foo1)  # returns 136
sys.getsizeof(foo2)  # returns 1016
</code></pre>
<p>There's clearly a big difference between functions and callable objects. However, I can't find a lot of documentation on what is going on behind the scenes. I know functions are first-class objects, but I also know that classes have a lot more going on than your regular functions. class foo2 is created with a metaclass, <code>type()</code>.  </p>
<p>My questions then, are these: </p>
<ol>
<li>When you create a function <code>def foo1():</code>, how does this differ from
the process of defining a class with a metaclass? Is there a version of <code>type()</code> but for functions, a metafunction?</li>
<li>Say someone wanted to write their own metafunction (the real reason behind this), would it be better to just use decorators, or maybe a metaclass that makes callable classes? What advantages would either offer (a metaclass that makes callable classes seems clunky)?</li>
<li>Is the only purpose behind having a callable object to have a function that can store info in it as well?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Functions are also callable objects:</p>
<pre><code>&gt;&gt;&gt; foo1.__call__
&lt;method-wrapper '__call__' of function object at 0x105bafd90&gt;
&gt;&gt;&gt; callable(foo1)
True
</code></pre>
<p>But a class needs to keep track of <em>more information</em>; it doesn't matter here that you gave it a <code>__call__</code> method. <em>Any</em> class is bigger than a function:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; def foo1():
...    return 2 + 4
...
&gt;&gt;&gt; class foo3:
...    pass
...
&gt;&gt;&gt; sys.getsizeof(foo1)
136
&gt;&gt;&gt; sys.getsizeof(foo3)
1056
</code></pre>
<p>A function object is a distinct object type:</p>
<pre><code>&gt;&gt;&gt; type(foo1)
&lt;class 'function'&gt;
</code></pre>
<p>and is reasonably compact because the meat is not actually in the function object but in other objects <em>referenced by</em> the function object:</p>
<pre><code>&gt;&gt;&gt; sys.getsizeof(foo1.__code__)
144
&gt;&gt;&gt; sys.getsizeof(foo1.__dict__)
240
</code></pre>
<p>And that's it really; different types of objects have different sizes because they track different things or use composition to store stuff in other objects.</p>
<p>You can use the <code>type(foo1)</code> return value (or <a href="https://docs.python.org/3/library/types.html#types.FunctionType"><code>types.FunctionType</code></a>, which is the same object) to produce new function objects if you so desire:</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; types.FunctionType(foo1.__code__, globals(), 'somename')
&lt;function foo1 at 0x105fbc510&gt;
</code></pre>
<p>which is basically what the interpreter does whenever a <code>def function(..): ...</code> statement is being executed.</p>
<p>Use <code>__call__</code> to make custom classes callable when that makes sense to your API. The <a href="https://docs.python.org/3/library/enum.html#functional-api"><code>enum.Enum()</code> class is callable</a>, for example, specifically because using the call syntax gives you a syntax distinct from subscription, which was used for other purposes. And a <a href="https://docs.python.org/3/library/xmlrpc.client.html#serverproxy-objects"><code>xmlrpc.client.ServerProxy()</code> object</a> produces method objects that are instances of <code>_Method</code>, because they proxy a remote call, not a local function.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a version of type() but for functions, a metafunction?</p>
</blockquote>
<p>Sort of. Functions have a type, and that type can be used to construct new functions from, at minimum, a code object and a globals dictionary. (The code object can be constructed using <code>compile()</code> or grabbed from an existing function, or, if you're a masochist, built from a bytecode string and other information using the code type's constructor.) The function type is not a meta-anything because functions are instances, not classes. You can get this type using <code>type(lambda:0)</code> (putting any function in the parentheses), and do <code>help(type(lambda:0))</code> to see its arguments. The function type is an instance of <code>type</code>.</p>
<blockquote>
<p>Say someone wanted to write their own metafunction</p>
</blockquote>
<p>You can't subclass the function type, sorry.</p>
<pre><code>class FunkyFunc(type(lambda: 0)): pass

TypeError: Error when calling the metaclass bases
    type 'function' is not an acceptable base type
</code></pre>
<blockquote>
<p>Is the only purpose behind having a callable object to have a function that can store info in it as well?</p>
</blockquote>
<p>There are many uses for it. Your example is one (although function instances can have attributes, a class provides better documentation of the attributes); the flip side, making a plain old data object callable, is another (I gave a kind of funky example of that <a href="https://stackoverflow.com/questions/38935313/how-to-chain-multiple-arguments-in-python-add123-6/38935526#38935526">in this answer</a>). You can use classes to write decorators if the instances are callable. You can use <code>__call__</code> on a metaclass to customize instance construction. And you can use it to write functions with different behavior, sort of as if you could in fact subclass the function type. (If you want C-style "static" variables in a function, you might write it as a class with a <code>__call__</code> method and use attributes to store the static data.)</p>
<p>A fun thing about function objects is that, because they're callable, they themselves have a <code>__call__</code> method. But a method is callable, and so that <code>__call__</code> method also has a <code>__call__</code> method, and that <code>__call__</code> method (being callable) also has a <code>__call__</code> method, and so on <em>ad infinitum.</em> :-)</p>
</div>
<span class="comment-copy">So when you define foo1, what exactly happens - is that function defined by a specialized function-creating metaclass? Or is it handled by type()?</span>
<span class="comment-copy">@santasmic: it is handled by the interpreter internally, but you can do the same with the return value of <code>type(foo1)</code>.</span>
<span class="comment-copy">@peter Interesting. I am just attempting to understand as in-depth as possible - so, if I wanted to create a function-generating function/class, would it be best to use a decorator, to maintain the referencing of dict and code and avoid storing them inside the function?</span>
<span class="comment-copy">Thank you! FunctionType is what I was looking for. I appreciate your answer!</span>
<span class="comment-copy">"You can't subclass the function type, sorry."</span>
<span class="comment-copy">Oops I didn't realize hitting enter would submit the comment. Anyway, that makes me sad but thank you for your response!</span>
