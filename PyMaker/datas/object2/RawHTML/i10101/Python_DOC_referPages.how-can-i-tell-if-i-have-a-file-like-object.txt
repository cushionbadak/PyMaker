<div class="post-text" itemprop="text">
<p>I want to have a function that writes data to a file:</p>
<pre><code>def data_writer(data, file_name):
    spiffy_data = data # ...
    with open(file_name, 'w') as out:
        out.write(spiffy_data)
</code></pre>
<p>But sometimes, I have a file object instead of a file name. In this case, I sometimes have a <code>tempfile.TemporaryFile</code> (which creates a file-like object that's writable).</p>
<p>I'd like to be able to write something like:</p>
<pre><code>def data_writer(data, file_thing):
    spiffy_data = data # ...
    if type(file_thing) is file_like:
        file_thing.write(spiffy_data)
    else:
        with open(file_name, 'w') as out:
            out.write(spiffy_data)
</code></pre>
<p>What's a good way to do this?</p>
<p>Also, does makes sense to do in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>While your approach is <a href="https://docs.python.org/3/glossary.html#term-lbyl" rel="nofollow noreferrer"><code>LBYL</code></a>, it's pythonic to assume it's <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer"><code>EAFP</code></a>. So you could just <code>try</code> to </p>
<ul>
<li><code>write()</code> to the <code>file_thing</code> you received or</li>
<li><code>open()</code> it</li>
</ul>
<p>and <code>except</code> a potential exception, depending on which you feel better represents the default case.</p>
<p><strong>Edit:</strong> Cf <a href="https://stackoverflow.com/questions/40110731/how-can-i-tell-if-i-have-a-file-like-object/40110875#comment67493524_40110875">ShadowRanger's comment</a> for why mixing the exception handling with a context manager is rather unelegant here.</p>
</div>
<div class="post-text" itemprop="text">
<p>A function should do one thing, and do that one thing well. In the case of <code>data_writer</code>, its one thing is to write data to a file-like object. Let the caller worry about providing such an object. That said, you can also provide that caller in the form of a wrapper that takes a file name and opens it for <code>data_writer</code>.</p>
<pre><code>def data_writer(data, file_obj):
    spiffy_data = data # ...
    file_obj.write(spiffy_data)

def write_data_to_file(data, file_name):
    with open(file_name, "w") as f:
        data_writer(f, file_name)
</code></pre>
</div>
<span class="comment-copy">I'd just check whether you got a string with <code>isinstance(file_thing, str)</code>.  If so, treat it as a filename, otherwise treat it as a file-like object.</span>
<span class="comment-copy">Why not always take a file-like and let the caller handle it?</span>
<span class="comment-copy">Alternatively, some APIs (<a href="https://docs.python.org/3/library/tarfile.html#tarfile.open" rel="nofollow noreferrer">e.g. <code>tarfile.open</code></a>) take a file name by default, but allow you to pass a <code>fileobj</code> instead by keyword so it uses that instead of opening a file. Up to you if this makes sense.</span>
<span class="comment-copy">One possibility instead of checking the <code>type</code>, would be to check the attributes of <code>file_thing</code> for e.g., <code>write()</code>:  <code>if hasattr(file_thing, 'write'):...</code></span>
<span class="comment-copy">EAFP doesn't work so well here; by the time you try to <code>write</code>, you're already in the writing logic, and it's awkward to retroactively open the file. Particularly if you're being good and using <code>with</code> statements to manage the lifetime of a file object you open.</span>
<span class="comment-copy">Yeah, good point. Handling the exception doesn't mix great with the context manager :/</span>
<span class="comment-copy">I think if the writing logic is factored out (or is actually a one-liner) then it's OK. You do have to copy/paste the call to write data, which is ugly, but I'm not seeing a solution there...</span>
