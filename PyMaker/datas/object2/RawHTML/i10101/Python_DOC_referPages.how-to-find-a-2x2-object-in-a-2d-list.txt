<div class="post-text" itemprop="text">
<p>I have an exercise that I have to complete for school and I'm kinda stuck. 
I have to program a function that tells you if there's a face on the photo, by photo we can imagine a 2D list, so a list that consists of more lists to create a 2 dimensional object. The face is represented by 2x2 square with the word face in it these letters can be in a random order.  As shown below in picture I. and II.:</p>
<p><img alt="Face diagrams" src="https://i.stack.imgur.com/8qF2J.jpg" title="Face diagrams"/></p>
<p>Also there can be more faces, as long as the word face is shown at least once in the whole 2Dlist it should return True.</p>
<p>The problem is that the letters can't be in a row or in a column as shown in picture III.. I really can't figure out how to make a condition that would eliminate this. So far I know how to find out out if all of the letters are in that 2Dlist and I eliminated the possibility of having just a single row or a single column as shown in the picture IV. and V..</p>
<p>Here's what I have so far:</p>
<pre><code>def is_face_on_photo(photo):
    list2D = photo
    faces = ['f','a','c','e']
    newlist = []
    for list in list2D:
        for letter in list:
            newlist.append(letter)
    if 'f' in newlist and 'a' in newlist and 'c' in newlist and 'e' in newlist and (faces not in list2D) and (len(list2D) &gt;= 2) and (len(list2D[0]) &gt;= 2):
        print True
    else:
        print False
 pass
</code></pre>
<p>I'm new to python so I would appreciate any help I can get :) thanks a lot</p>
</div>
<div class="post-text" itemprop="text">
<p>Search element by element through each row, then the next row, and so on, left to right, and down, until you find an F, A, C, or E.</p>
<p>When you do, since you're checking left to right and top to bottom, you can assume you've found the top left corner of a potential "FACE". So check if the letter to the right, the one below, and the one to the lower right satisfy the rest of the FACE.</p>
<p>If so, you're done. If not, keep going.</p>
<p><strong>Edit:</strong> Here's a somewhat wordy version. I haven't tested it, but it's the idea.</p>
<pre><code>def is_face_on_photo(photo):
    found = False

    for row,photo_row in enumerate(photo):
        for col,letter in enumerate(photo_row):

            if (letter in "face") and col + 1 &lt; len(photo_row) and row + 1 &lt; len(photo):
                found = True  # Until proven otherwise

                num_found = {"f":0, "a":0, "c":0, "e":0}

                right_letter = photo_row[col + 1]
                below_letter = photo[row + 1][col]
                below_right_letter = photo[row + 1][col + 1]

                letters = [letter, right_letter, below_letter, below_right_letter]

                # Could replace with something like defaultdict
                for let in letters:
                    if let in num_found:
                        num_found[let] += 1

                # Would need to change this slightly if the letters of "face" had 
                # any repetitions, like two "a"s or something
                for let in "face":
                    if num_found[let] == 0:
                        found = False
                        break

            if found:
                break

        if found:
            break

    return found
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a method somewhat similar to that described in the other answer, here is an implementation that should work. It will go through each cell and, if that cell includes a letter in 'face', it will proceed to check the three cells to the right, the three below, and the square of which it is the top-right member.</p>
<p>Note that this <strong>is not</strong> the most efficient way of doing this: information from previous tries (which could prevent most of these attempts) is not preserved. </p>
<pre><code>def is_face_on_photo(arr):
    word = set('face')
    num_rows = len(arr)
    num_cols = len(arr[0])
    for y, row in enumerate(arr):
        for x, cell in enumerate(row):
            if cell in word:
                # horizontal?
                if x + 3 &lt; num_cols and set(row[x:x+4]) == word:
                    return True
                # vertical
                if y + 3 &lt; num_rows and set(arr[i][x] for i in range(y, y + 4)) == word:
                    return True
                # square
                if x + 1 &lt; num_cols and y + 1 &lt; num_cols and set(arr[y][x:x+2] + arr[y+1][x:x+2]) == word:
                    return True
    return False

    arr = [
        ['x', 'x', 'x', 'x'],
        ['x', 'f', 'c', 'x'],
        ['x', 'a', 'e', 'x'],
        ['x', 'x', 'x', 'x']
    ]

    print (is_face_on_photo(arr)) # True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way to scan your 2D lists. </p>
<p>We use the built-in <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> function to get pairs of adjacent rows from the photo, and use <code>zip</code> again to get pairs of adjacent cells from the current pair of rows. This gives us the 4 cells in a 2x2 square. We also use the built-in <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a> function to give us the x,y indices of the top-left corner of the current 2x2 square. </p>
<p>We put the letters from the square into a set so we can quickly test if it is equal to the set containing the letters of 'face'. But we also need to make sure that any face we find doesn't overlap a face we've already found. To do that, we maintain a set <code>found</code> that keeps track of the x,y indices of each face we find. </p>
<h3>Update</h3>
<p>Here's a better version of this code; the previous version didn't handle photos that contain both overlapping faces and non-overlapping faces. This version maintains another set <code>bad</code> that keeps track of faces that overlap other faces.</p>
<pre><code>all_data = [
    [
        ['x', 'x', 'x', 'x'],
        ['x', 'f', 'a', 'x'],
        ['x', 'c', 'e', 'x'],
        ['x', 'x', 'x', 'x'],
    ],
    [
        ['c', 'a', 'x', 'x'],
        ['f', 'e', 'x', 'x'],
        ['x', 'x', 'x', 'x'],
        ['x', 'x', 'x', 'x'],
    ],
    [
        ['c', 'a', 'f', 'x'],
        ['f', 'e', 'c', 'x'],
        ['x', 'x', 'x', 'x'],
        ['x', 'x', 'x', 'x'],
    ],
    [
        ['c', 'a', 'f', 'x'],
        ['f', 'e', 'c', 'x'],
        ['x', 'c', 'e', 'x'],
        ['x', 'f', 'a', 'x'],
    ],
    [
        ['x', 'a', 'x', 'x'],
        ['f', 'e', 'x', 'x'],
        ['x', 'x', 'x', 'x'],
        ['x', 'x', 'x', 'x'],
    ],
    [
        ['c', 'a', 'x', 'x', 'x', 'x'],
        ['f', 'e', 'c', 'a', 'f', 'e'],
        ['f', 'e', 'e', 'f', 'a', 'c'],
        ['a', 'c', 'x', 'x', 'x', 'x'],
    ],
]

def show(a):
    print('\n'.join(''.join(row) for row in a))

face = set('face')

def is_face_on_photo(photo):
    ''' Return the number of valid faces found in photo '''
    found = set()
    bad = set()
    # Get pairs of adjacent rows
    for y, (row0, row1) in enumerate(zip(photo, photo[1:])):
        # Get pairs of adjacent cells from the pair of rows
        for x, t in enumerate(zip(row0, row0[1:], row1, row1[1:])):
            if set(t) == face:
                found.add((x, y))
                # See if it overlaps any existing faces
                newbad = found.intersection({(x-1, y), (x, y-1), (x-1, y-1)})
                if newbad:
                    bad.update(newbad)
                    bad.add((x, y))
    return len(found) - len(bad)

for photo in all_data:
    show(photo)
    print(is_face_on_photo(photo), '\n')
</code></pre>
<p><strong>output</strong></p>
<pre><code>xxxx
xfax
xcex
xxxx
1 

caxx
fexx
xxxx
xxxx
1 

cafx
fecx
xxxx
xxxx
0 

cafx
fecx
xcex
xfax
1 

xaxx
fexx
xxxx
xxxx
0 

caxxxx
fecafe
feefac
acxxxx
4 
</code></pre>
</div>
<span class="comment-copy">I think that picture III is invalid because the two "face" squares that it contains overlap each other.</span>
<span class="comment-copy">By "he problem is that the letters can't be in a row or in a column as shown in picture III.." do you mean picture IV?</span>
<span class="comment-copy">Which are valid and invalid from your images?</span>
<span class="comment-copy">the I. II. and III. are valid</span>
<span class="comment-copy">Thank you so much ! This totally fixes my problem, I didn't know that you can work with rows and columns like this.</span>
