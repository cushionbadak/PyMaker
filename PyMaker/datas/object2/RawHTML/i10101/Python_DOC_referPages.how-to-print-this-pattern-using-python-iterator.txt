<div class="post-text" itemprop="text">
<pre><code>L = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
head = 'head'
tail = 'tail'
</code></pre>
<p>suppose we can and can only get the iterator of some iterable(L).
and we can not know the length of L.
Is that possible to print the iterable as:</p>
<pre><code>'head123tail'
'head456tail' 
'head789tail' 
'head10tail'
</code></pre>
<p>My try at it is as follows.</p>
<pre><code>L = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
head = 'head'
tail = 'tail'
slice_size = 3

i = iter(L)
try:
    while True:
        counter = 0
        while counter &lt; slice_size:
            e = next(i)
            if counter == 0:
                print(head, end='')
            print(e, end='')
            counter += 1
        else:
            print(tail)
except StopIteration:
    if counter &gt; 0:
        print(tail)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way to do it with <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow"><code>itertools.count</code></a>. </p>
<p><code>groupby</code> on the key function <code>lambda _: next(c)//3</code> groups the items in the iterables in <em>threes</em>  in successions. The logic uses the integer division of the next object in the count item on 3:</p>
<pre><code>from itertools import groupby, count

L = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
head = 'head'
tail = 'tail'

c = count()    
for _, g in groupby(L, lambda _: next(c)//3):
    item = head + ''.join(map(str, g)) + tail
    print(item)
</code></pre>
<p><em>Output</em>:</p>
<pre><code>head123tail
head456tail
head789tail
head10tail
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can <a href="https://stackoverflow.com/a/24527424/1639625">split the iterator into chunks</a> of three, using <code>chain</code> and <code>slice</code> from <code>itertools</code> and a <code>for</code> loop, and then join them. The <code>for</code> loop will do most of what your <code>try/while True/except</code> construct is doing.</p>
<pre><code>L = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
head = 'head'
tail = 'tail'
slice_size = 3
iterator = iter(L)

from itertools import chain, islice
for first in iterator:
    chunk = chain([first], islice(iterator, slice_size - 1))
    print(head, ''.join(str(x) for x in chunk), tail)
</code></pre>
<p>However, if your iterator is just a <code>list</code>, you can just use <code>range</code> with a <code>step</code> parameter:</p>
<pre><code>for start in range(0, len(L), slice_size):
    chunk = L[start : start + slice_size]
    print(head, ''.join(str(x) for x in chunk), tail)
</code></pre>
</div>
<span class="comment-copy">You'll have to buffer your 'head', and print it only after next has succeeded, since you can't predict what's next in an iterator without consuming it.</span>
<span class="comment-copy">@ Jacques, thanks for your suggestion. I modify my preliminary question.</span>
<span class="comment-copy">That's a very interesting application of <code>groupby</code> and <code>count</code>. You might also post this as an answer to <a href="http://stackoverflow.com/questions/24527006/split-a-generator-into-chunks-without-pre-walking-it">this</a> more general question.</span>
<span class="comment-copy">I don't know how to choose between the current two answers. So I <code>timeit</code>. I ran them on my slow computer for 1000 times. Koledoye's answer got 2.9803745844324028 seconds; tobias_k's got 8.567057737782685 seconds.</span>
<span class="comment-copy">@tobias_k Thanks for the pointer. Added an answer: <a href="http://stackoverflow.com/a/40063403/3125566">stackoverflow.com/a/40063403/3125566</a></span>
<span class="comment-copy">@minion You could at least upvote the answers if you're still not sure of which to accept</span>
<span class="comment-copy">@MosesKoledoye, would you slightly change your answer, since my question is 'we can only get the iterator of some iterable(L).'</span>
