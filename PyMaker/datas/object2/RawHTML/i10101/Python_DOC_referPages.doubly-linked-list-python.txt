<div class="post-text" itemprop="text">
<p>I am using <code>Python 3.0</code>, and I have to create the following:</p>
<p>1) Implement an ADT called Setplus as an ordered doubly-linked list, where the items are ordered from smallest item to the largest item in the list</p>
<p>So First I created a module called <code>Double_Node</code></p>
<pre><code>class Double_Node:
    """
    Fields: value stores any value
            next points to the next node in the list
            prev points to the previous node in the list
    """

    ## Double_Node() produces a newly constructed empty node.
    ## __init__: Any -&gt; Node
    def __init__(self, value, prev = None, next = None):
        self.value = value 
        self.prev_node = prev
        self.next_node = next

    def get_next (self):
        return self.next_node
    def set_next (self, n):
        self.next_node = n
    def get_prev (self):
        return self.prev_node
    def set_prev (self, p):
        self.next_prev_node = p
    def get_value (self):
        return self.value
    def set_value (self, d):
        self.value = d


    ## print(self) prints the value stored in self.
    ## Effect: Prints value.
    ## __str__: Node -&gt; Str
    def __str__(self):
        return str(self.value)
</code></pre>
<p>Then I create a class called Setplus:</p>
<pre><code>class Setplus:
    """
    Field: _head points to the first node in the linked list
           _tail points to the last node in a linked list
    """


    ## Setplus() produces a newly constructed empty setplus.
    ## __init__: -&gt; Setplus
    def __init__(self):
        self._head = None
        self._tail = None

    ## self.empty() produces True if self is empty.
    ## empty: Setplus -&gt; Bool
    def empty(self):
        return self._head == None

    ## value in self produces True if value is an item in self.
    ## __contains__: Setplus Any -&gt; Bool
    def __contains__(self, value):
        current = self._head
        while current:
            if current.get_value == value:
                return True
            else:
                current = current.get_next
        return False

    ## self.distinct() produces True if all items are distinct.
    ## distinct: Setplus -&gt; Bool
    #def distinct(self):

    ## count(value) produces the number of occurrences of value.
    ## count: Setplus Any -&gt; Int
        def count(self, value):
            counter = 0
            current = self._head
            while current != None:
                if current.value == value:
                    counter += 1
                    print (counter)
                else:
                    current = current.next
            return counter

    ## self.add(value) adds value as an item in order.
    ## Effects: Mutates self.
    ## add: Setplus Any -&gt; None 
    def add(self, value):
        new_node = Double_Node(value)
        if self.head == None:
            self.head = new_node
        if self.tail != None:
            slef.tail.next = new_node

        self.tail = new_node
</code></pre>
<p>I am having trouble creating creating a contains method, count, which counts the number of values and add, which adds the node in the correct nondecreasing order. </p>
<p>Thanks in Advance</p>
</div>
<div class="post-text" itemprop="text">
<p>The first major issue in your code is typos and incorrect names.</p>
<p>There's one clear typo, <code>slef</code> instead of <code>self</code> in one of your functions.</p>
<p>There are also a bunch of places where you're using two different names for what is supposed to be the same attribute (<code>_head</code> and <code>head</code> or <code>next</code> and <code>next_node</code>, for instance).</p>
<p>You also have defined getter and setter functions in your <code>Double_Node</code> class, but the only time you try to use them in <code>Setplus</code> you only reference the method without calling it. The line <code>current = current.get_next</code> should almost certainly be <code>current = current.get_next()</code>.</p>
<p>A brief diversion on getter and setter functions: They're usually not needed in Python classes. Just use attributes directly. If you later find you need more fancy behavior (e.g. validation of newly set values or generation of requested values on the fly), you can change the class use a <code>property</code> to turn attribute access syntax into method calls. In other programming languages you usually can't change away from attribute access that way, so getter and setter methods are encouraged in order to have an extensible API from the start.</p>
<p>(Note that if you're a student, your instructors may be less familiar with Python than other languages, so they may want you to write getters and setters even though they're generally bad style in Python code. Consider learning how to use a <code>property</code> instead and you might blow their mind later on!)</p>
<p>I'd get rid of the getter and setter functions in <code>Double_Node</code>, simply as a matter of style. <em>But</em>, if you are going to keep them (perhaps because they're required for your assignment), you should then actually <em>use</em> them in your code!</p>
<p>And finally, to get to the actual question you wanted help with, inserting into the linked list in sorted order, you probably want to do something like this:</p>
<pre><code>def add(self, value):
    new_node = Double_Node(value)
    if self._head == None: # inserting into empty list
        self._head = self._tail = new_node

    else: # inserting into a list that contains at least one node already
        current = self._head
        while current and current.value &lt; value: # find a node to insert before
            current = current.get_next()

        if current: # not inserting at end of list
            prev = current.get_prev()
            if prev: # not inserting at start
                new_node.set_prev(prev)
                prev.set_next(new_node)

            else: # inserting at start
                self._head = new_node

            new_node.set_next(current)
            current.set_prev(new_node)

        else: # inserting at end
            new_node.set_prev(self._tail)
            self._tail.set_next(new_node)
            self._tail = new_node
</code></pre>
<p>After you've made <code>add</code> insert in sorted order, your other methods can take advantage of that fact. For instance, <code>__contains__</code> can stop searching if it sees a value that's greater than the one it's looking for, and <code>count</code> will find all the matching values in one contiguous group.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you'd like to use existing Python classes for this, you may find these useful.</p>
<h3>Doubly-linked list:</h3>
<p><code>deque</code>, from the <code>collections</code> module:</p>
<p><a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow">https://docs.python.org/3/library/collections.html#collections.deque</a></p>
<h3>Ordered data structure from smallest to largest:</h3>
<p>The <code>heapq</code> module, which implements a min heap.</p>
<p><a href="https://docs.python.org/3/library/heapq.html" rel="nofollow">https://docs.python.org/3/library/heapq.html</a></p>
</div>
<span class="comment-copy">What does "having trouble" mean? I see you've implemented a <code>__contains__</code>, <code>count</code> and <code>add</code> method already. What's wrong with them? Other than messed up indentation on <code>count</code> (which might be an artifact of copying your code to Stack Overflow rather than something in the original version), I don't see anything obviously wrong. It would improve your question a lot if you actually described what happens when you use your classes (and what you expected to happen instead).</span>
<span class="comment-copy">My error is in add, as it has to be an orderable linked list at its current form it appends at the end, I am not able to compare the two elements, and include the element in there. For example: If I have a list 1 2 3 6 7 and I want to insert "5" at the current form it adds to the end making it 1 2 3 4 6 7 5, while I am trying to make it 1 2 3 4 5 6 7. Thanks</span>
<span class="comment-copy">Can you please explain to me what you meant by this line "A brief diversion on getter and setter functions: They're usually not needed in Python classes. Just use attributes directly."</span>
<span class="comment-copy">Can you please explain to me what you meant by this line  "A brief diversion on getter and setter functions: They're usually not needed in Python classes. Just use attributes directly." So how would I call it.</span>
<span class="comment-copy">Usually you'd not bother writing <code>get_whatever</code> and <code>set_whatever</code> functions in the <code>Double_Node</code> class, and in <code>Setplus</code> you'd just access the attributes <code>next_node</code> and <code>prev_node</code> directly (e.g. <code>current.prev_node</code> instead of <code>current.get_prev()</code>).</span>
<span class="comment-copy">The function has trouble inserting into the middle of the linked list, when something is inserted into the middle it adds that element and deletes everything in front of it, so I think there is a problem when we assign 'prev = current.get_prev()' . For example, if we are to add 5 to the following list 1 2 3 4 6 7 8, what it will do is create a list 5 6 7 8.</span>
<span class="comment-copy">Ah, you're right. The issue was that I moved the <code>prev = current.get_prev()</code> line below the <code>current.set_prev(new_node)</code> line after it had originally been above. That breaks things. I've edited my answer to put the linking of <code>current</code> and <code>new_node</code> after the <code>prev</code> linking code, so it will work. Note that there is also an issue in the <code>Double_Node</code> class that I didn't fix here (it sets <code>self.next_prev_node</code> insetead of <code>self.prev_node</code> in <code>set_prev</code>).</span>
<span class="comment-copy">This doesn't really answer the question. While library data structures like the ones you refer to are useful (and probably better than hand-written ones in most real world code), this is pretty clearly a homework assignment by a student learning about linked lists. Neither <code>collections.deque</code> objects or the heaps build with <code>heapq</code> are linked lists, so they're not relevant at all.</span>
