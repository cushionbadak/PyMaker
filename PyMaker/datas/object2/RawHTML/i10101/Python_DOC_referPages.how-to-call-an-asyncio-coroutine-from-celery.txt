<div class="post-text" itemprop="text">
<p>I am using <em>asyncio</em> for a network framework.</p>
<p>In below code(<code>low_level</code> is our low level function, <code>main</code> block is our program entry, <code>user_func</code> is user-defined function):</p>
<pre><code>import asyncio

loop = asyncio.get_event_loop()
""":type :asyncio.AbstractEventLoop"""


def low_level():
    yield from asyncio.sleep(2)


def user_func():
    yield from low_level()


if __name__ == '__main__':
    co = user_func()
    loop.run_until_complete(co)
</code></pre>
<p>I want wrap the <code>low_level</code> as normal function rather than <code>coroutine</code>(for <code>compatibility</code> etc.), but <code>low_level</code> is in event loop. How can wrap it as a normal function?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>low_level</code> is a coroutine, it can <em>only</em> be used by running an <code>asyncio</code> event loop. If you want to be able to call it from synchronous code that <em>isn't</em> running an event loop, you have to provide a wrapper that actually launches an event loop and runs the coroutine until completion:</p>
<pre><code>def sync_low_level():
    loop = asyncio.get_event_loop()
    loop.run_until_complete(low_level())
</code></pre>
<p>If you want to be able to call <code>low_level()</code> from a function that <em>is</em> part of the running event loop, have it block for two seconds, but not have to use <code>yield from</code>, the answer is that you can't. The event loop is single-threaded; whenever execution is inside one of your functions, the event loop is blocked. No other events or callbacks can be processed. The only ways for a function running in the event loop to give control back to the event loop are to 1) <code>return</code> 2) use <code>yield from</code>. The <code>asyncio.sleep</code> call in <code>low_level</code> will never be able to complete unless you do one those two things.</p>
<p>Now, I suppose you could create an <em>entirely new event loop</em>, and use that to run the sleep synchronously from a coroutine running as part of the default event loop:</p>
<pre><code>import asyncio

loop = asyncio.get_event_loop()

@asyncio.coroutine
def low_level(loop=None):
    yield from asyncio.sleep(2, loop=loop)


def sync_low_level():
    new_loop = asyncio.new_event_loop()
    new_loop.run_until_complete(low_level(loop=new_loop))

@asyncio.coroutine
def user_func():
    sync_low_level()

if __name__ == "__main__":
    loop.run_until_complete(user_func())
</code></pre>
<p>But I'm really not sure why you'd want to do that.</p>
<p>If you just want to be able to make <code>low_level</code> act like a method returning a <code>Future</code>, so you can attach callbacks, etc. to it, just wrap it in <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.async"><code>asyncio.async()</code></a>:</p>
<pre><code>loop = asyncio.get_event_loop()

def sleep_done(fut):
    print("Done sleeping")
    loop.stop()

@asyncio.coroutine
def low_level(loop=None):
    yield from asyncio.sleep(2, loop=loop)

def user_func():
    fut = asyncio.async(low_level())
    fut.add_done_callback(sleep_done)

if __name__ == "__main__":
    loop.call_soon(user_func)
    loop.run_forever()
</code></pre>
<p>Output:</p>
<pre><code>&lt;2 second delay&gt;
"Done sleeping"
</code></pre>
<p>Also, in your example code, you should use the <code>@asyncio.coroutine</code> decorator for both <code>low_level</code> and <code>user_func</code>,  as stated in the <a href="https://docs.python.org/3/library/asyncio-task.html#coroutines"><code>asyncio</code> docs</a>:</p>
<blockquote>
<p>A coroutine is a generator that follows certain conventions. For
  documentation purposes, all coroutines should be decorated with
  @asyncio.coroutine, but this cannot be strictly enforced.</p>
</blockquote>
<p><strong>Edit:</strong></p>
<p>Here's how a user from a synchronous web framework could call into your application without blocking other requests:</p>
<pre><code>@asyncio.coroutine
def low_level(loop=None):
    yield from asyncio.sleep(2, loop=loop)

def thr_low_level():
   loop = asyncio.new_event_loop()
   t = threading.Thread(target=loop.run_until_complete, args(low_level(loop=loop),))
   t.start()
   t.join()
</code></pre>
<p>If a request being handled by Flask calls <code>thr_low_level</code>, it will block until the request is done, but the GIL should be released for all of the asynchronous I/O going on in <code>low_level</code>, allowing other requests to be handled in separate threads.</p>
</div>
<span class="comment-copy">What do you mean by running it as a normal function? Do you want to be able to call it from code that <i>isn't</i> running as part of the event loop?</span>
<span class="comment-copy">@dano As I comment "I write web framework, the framework run a event loop, and user function call low level function provide by the web framework. Consider compatibility with other framework, user function may call low level function as normal function rather than a coroutine. Is it impossible to keep compatibility with other framework?"</span>
<span class="comment-copy">See also <a href="https://stackoverflow.com/q/30155138/320911">stackoverflow.com/q/30155138/320911</a></span>
<span class="comment-copy">More general, if I write web framework, the framework run a event loop, and user function call low level function provide by the web framework. Consider compatibility with other framework, user function may call low level function as normal function rather than a coroutine. Is it impossible to keep compatibility with other framework?</span>
<span class="comment-copy">@RobertLu So you're wondering how you can call an asyncio coroutine from some web framework that has its own event loop (like <a href="http://www.tornadoweb.org/en/stable/" rel="nofollow noreferrer">Tornado</a>, for example)? Is there a particular framework you're interested in?</span>
<span class="comment-copy">yes, I hope it's not complicated.</span>
<span class="comment-copy">@RobertLu Can you share which web framework? Unfortunately I don't think there's a one-size-fits-all(-web-frameworks) answer to this.</span>
<span class="comment-copy">Let's talk about flask. In flask user call <code>connect</code> function, but I want use a coroutine to replace it(when this request wait query result, other request can get CPU though asyncio's event loop), and I hope user's legacy code can work normally above asyncio.</span>
