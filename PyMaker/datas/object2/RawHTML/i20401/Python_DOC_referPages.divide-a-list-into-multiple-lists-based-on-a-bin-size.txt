<div class="post-text" itemprop="text">
<p>I have a list containing more than 100,000 values in it. </p>
<p>I need to divide the list into multiple smaller lists based on a specific bin width say 0.1. Can anyone help me how to write a python program to do this?</p>
<p>my list looks like this</p>
<pre><code>-0.234
-0.04325
-0.43134
-0.315
-0.6322
-0.245
-0.5325
-0.6341
-0.5214
-0.531
-0.124
-0.0252
</code></pre>
<p>I would like to have an output like this</p>
<pre><code>list1 = [-0.04325, -0.0252] 
list2 = [-0.124] 
list3 = [-0.234, -0.245 ] 
list4 = [-0.315] 
list5 = [-0.43134] 
list6 = [-0.5325, -0.5214, -0.531] 
list7 = [-0.6322, -0.6341]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a simple and nice way using <a href="http://scipy.org/Numpy_Example_List_With_Doc#head-e68744814a0dcbf3acbcf1aee5db412198cf312c" rel="noreferrer">numpys digitize</a>:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; mylist = np.array([-0.234, -0.04325, -0.43134, -0.315, -0.6322, -0.245,
                       -0.5325, -0.6341, -0.5214, -0.531, -0.124, -0.0252])
&gt;&gt;&gt; bins = np.arange(0,-1,-0.1)
&gt;&gt;&gt; for i in xrange(1,10):
...     mylist[np.digitize(mylist,bins)==i]
... 
array([-0.04325, -0.0252 ])
array([-0.124])
array([-0.234, -0.245])
array([-0.315])
array([-0.43134])
array([-0.5325, -0.5214, -0.531 ])
array([-0.6322, -0.6341])
array([], dtype=float64)
array([], dtype=float64)
</code></pre>
<p>digitize, returns an array with the index value for the bin that each element falls into.</p>
</div>
<div class="post-text" itemprop="text">
<p>This will create a dict where each value is a list of elements that fit in a bin.</p>
<pre><code>import collections
bins = collections.defaultdict(list)
binId = lambda x: int(x*10)
for val in vals:
    bins[binId(val)].append(val)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is this what you want? (Sample output would have been helpful :)</p>
<pre><code>f = [-0.234, -0.04325, -0.43134, -0.315, -0.6322, -0.245, 
     -0.5325, -0.6341, -0.5214, -0.531, -0.124, -0.0252]

import numpy as np
data = np.array(f)
hist, edges = np.histogram(data, bins=10)
print hist
</code></pre>
<p>yields:</p>
<pre><code> [2 3 0 1 0 1 2 0 1 2]
</code></pre>
<p>This SO question <a href="https://stackoverflow.com/questions/2144443/assigning-points-to-bins">assigning points to bins</a> might be helpful.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works:</p>
<pre><code>l=[-0.234, -0.04325, -0.43134, -0.315, -0.6322, -0.245,
-0.5325, -0.6341, -0.5214, -0.531, -0.124, -0.0252]

d={}
for k,v in zip([int(i*10) for i in l],l):
   d.setdefault(k,[]).append(v)

LoL=[d[e] for e in sorted(d.keys(), reverse=True)]

for i,l in enumerate(LoL,1):
    print('list',i,l)    
</code></pre>
<p>Prints:</p>
<pre><code>list 1 [-0.04325, -0.0252]
list 2 [-0.124]
list 3 [-0.234, -0.245]
list 4 [-0.315]
list 5 [-0.43134]
list 6 [-0.5325, -0.5214, -0.531]
list 7 [-0.6322, -0.6341]
</code></pre>
<p>How it works:</p>
<pre><code>1: The list
&gt;&gt;&gt; l=[-0.234, -0.04325, -0.43134, -0.315, -0.6322, -0.245,
... -0.5325, -0.6341, -0.5214, -0.531, -0.124, -0.0252]

2: Produce the keys:
&gt;&gt;&gt; [int(i*10) for i in l]
[-2, 0, -4, -3, -6, -2, -5, -6, -5, -5, -1, 0]

3: Produce tuples to put in the dict:
&gt;&gt;&gt; zip([int(i*10) for i in l],l)
[(-2, -0.234), (0, -0.04325), (-4, -0.43134), (-3, -0.315), (-6, -0.6322), 
 (-2, -0.245), (-5, -0.5325), (-6, -0.6341), (-5, -0.5214), (-5, -0.531), 
 (-1, -0.124), (0, -0.0252)]

4: unpack the tuples into k,v and loop over the list
&gt;&gt;&gt;for k,v in zip([int(i*10) for i in l],l):

5: add k key to a dict (if not there) and append the float value to a list associated 
   with that key:
    d.setdefault(k,[]).append(v)
</code></pre>
<p>I suggest a Python tutorial on these statements. </p>
</div>
<div class="post-text" itemprop="text">
<p>Binning can be done with <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>import itertools as it


iterable = ['-0.234', '-0.04325', '-0.43134', '-0.315', '-0.6322', '-0.245',
            '-0.5325', '-0.6341', '-0.5214', '-0.531', '-0.124', '-0.0252']

a,b,c,d,e,f,g = [list(g) for k, g in it.groupby(sorted(iterable), key=lambda x: x[:4])]
c
# ['-0.234', '-0.245']
</code></pre>
<p>Note: this simple key function assumes the values in the iterable are between -0.0 and -10.0. Consider <code>lambda x: "{:.1f}".format(float(x))</code> for general cases.</p>
<p>See also this <a href="https://stackoverflow.com/a/45873519/4531270">post</a> for details on how <code>groupby</code> works.</p>
</div>
<div class="post-text" itemprop="text">
<p>We can make bins with <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a>, a third-party library.</p>
<p><strong>Given</strong></p>
<pre><code>iterable = (
    "-0.234 -0.04325 -0.43134 -0.315 -0.6322 -0.245 "
    "-0.5325 -0.6341 -0.5214 -0.531 -0.124 -0.0252"
).split()

iterable
# ['-0.234', '-0.04325', '-0.43134', '-0.315', '-0.6322', '-0.245', '-0.5325', '-0.6341', '-0.5214', '-0.531', '-0.124', '-0.0252']
</code></pre>
<p><strong>Code</strong></p>
<pre><code>import more_itertools as mit


keyfunc = lambda x: float("{:.1f}".format(float(x)))
bins = mit.bucket(iterable, key=keyfunc)

keys = [-0.0,-0.1,-0.2, -0.3,-0.4,-0.5,-0.6]
a,b,c,d,e,f,g = [list(bins[k]) for k in keys]
c
# ['-0.234', '-0.245']
</code></pre>
<hr/>
<p><strong>Details</strong></p>
<p>We can bin by the key function, which we define to format numbers to a single precision, i.e. <code>-0.213</code> to <code>-0.2</code>.</p>
<pre><code>keyfunc = lambda x: float("{:.1f}".format(float(x)))
bins = mit.bucket(iterable, key=keyfunc)
</code></pre>
<p>These bins are accessed by the keys defined by the key function:</p>
<pre><code>c = list(bins[-0.2])
c
# ['-0.234', '-0.245']
</code></pre>
<p>Access all bins by iterating keys:</p>
<pre><code>f = lambda x: float("{:.1f}".format(float(x)))
bins = mit.bucket(iterable, key=keyfunc)

keys = [-0.0,-0.1,-0.2, -0.3,-0.4,-0.5,-0.6]
for k in keys:
    print("{} --&gt; {}".format(k, list(bins[k])))
</code></pre>
<p>Output</p>
<pre><code>-0.0 --&gt; ['-0.04325', '-0.0252']
-0.1 --&gt; ['-0.124']
-0.2 --&gt; ['-0.234', '-0.245']
-0.3 --&gt; ['-0.315']
-0.4 --&gt; ['-0.43134']
-0.5 --&gt; ['-0.5325', '-0.5214', '-0.531']
-0.6 --&gt; ['-0.6322', '-0.6341']
</code></pre>
<p>List comprehension and unpacking is another option (see Code example).</p>
<p>See also <a href="https://more-itertools.readthedocs.io/en/latest/api.html" rel="nofollow noreferrer"><code>more_itertools</code> docs</a> for more details.</p>
</div>
<span class="comment-copy">You provided example input; please also provided expected output.</span>
<span class="comment-copy">can you tell me what is happening in line 3.</span>
<span class="comment-copy">@user it is creating a lambda. This is a temporary function to map values to bin ids. I'd suggest searching for 'python lambda' if you want more in depth information.</span>
<span class="comment-copy">the histograms give the number of elements in a bin but not the elements itself. I have tried with it. I have included a sample output in my original question.</span>
<span class="comment-copy">@user1492449 Thanks for the feedback, I'll mull this over and maybe post another answer. In the meantime edited your post to make the output more readable.</span>
<span class="comment-copy">thanks for the reply and it works. Can you please explain me this?</span>
