<div class="post-text" itemprop="text">
<p>I'm aware that I can use: <code>isinstance(x, str)</code> in python-3.x but I need to check if something is a string in python-2.x as well. Will <code>isinstance(x, str)</code> work as expected in python-2.x? Or will I need to check the version and use <code>isinstance(x, basestr)</code>?</p>
<p>Specifically, in python-2.x:</p>
<pre><code>&gt;&gt;&gt;isinstance(u"test", str)
False
</code></pre>
<p>and python-3.x does not have <code>u"foo"</code></p>
</div>
<div class="post-text" itemprop="text">
<p>If you're writing 2.x-and-3.x-compatible code, you'll probably want to use <a href="http://packages.python.org/six/#six.string_types" rel="noreferrer">six</a>:</p>
<pre><code>from six import string_types
isinstance(s, string_types)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The most terse approach I've found without relying on packages like six, is:</p>
<pre><code>try:
  basestring
except NameError:
  basestring = str
</code></pre>
<p>then, assuming you've been checking for strings in Python 2 in the most generic manner,</p>
<pre><code>isinstance(s, basestring)
</code></pre>
<p>will now also work for Python 3+.</p>
</div>
<div class="post-text" itemprop="text">
<p>What about this, works in all cases?</p>
<pre><code>isinstance(x, ("".__class__, u"".__class__))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is @Lev Levitsky's answer, re-written a bit.</p>
<pre><code>try:
    isinstance("", basestring)
    def isstr(s):
        return isinstance(s, basestring)
except NameError:
    def isstr(s):
        return isinstance(s, str)
</code></pre>
<p>The <code>try</code>/<code>except</code> test is done once, and then defines a function that always works and is as fast as possible.</p>
<p>EDIT: Actually, we don't even need to call <code>isinstance()</code>; we just need to evaluate <code>basestring</code> and see if we get a <code>NameError</code>:</p>
<pre><code>try:
    basestring  # attempt to evaluate basestring
    def isstr(s):
        return isinstance(s, basestring)
except NameError:
    def isstr(s):
        return isinstance(s, str)
</code></pre>
<p>I think it is easier to follow with the call to <code>isinstance()</code>, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://python-future.org/compatible_idioms.html#unicode" rel="noreferrer"><code>future</code> library</a> adds (to Python 2) <strong>compatible names</strong>, so you can <strong>continue writing Python 3</strong>. You can simple do the following:</p>
<pre><code>from builtins import str
isinstance(x, str) 
</code></pre>
<hr/>
<p><strong>To install it</strong>, just execute <code>pip install future</code>.</p>
<p>As a <em>caveat</em>, it only support <code>python&gt;=2.6</code>,<code>&gt;=3.3</code>, but it is more modern than <code>six</code>, which is only <a href="https://docs.python.org/3/howto/pyporting.html#drop-support-for-python-2-6-and-older" rel="noreferrer">recommended if using <code>python 2.5</code></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe use a workaround like</p>
<pre><code>def isstr(s):
    try:
        return isinstance(s, basestring)
    except NameError:
        return isinstance(s, str)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can get the class of an object by calling <code>object.__class__</code>, so in order to check if object is the default string type:</p>
<pre><code>    isinstance(object,"".__class__)
</code></pre>
<p>And You can place the following in the top of Your code so that strings enclosed by quotes are in unicode in python 2:</p>
<pre><code>    from __future__ import unicode_literals
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this at the beginning of your code:</p>
<pre><code>from __future__ import print_function
import sys
if sys.version[0] == "2":
    py3 = False
else:
    py3 = True
if py3: 
    basstring = str
else:
    basstring = basestring
</code></pre>
<p>and later in the code:</p>
<pre><code>anystring = "test"
# anystring = 1
if isinstance(anystring, basstring):
    print("This is a string")
else:
    print("No string")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>type(string) == str</p>
<p>returns true if its a string, and false if not</p>
</div>
<span class="comment-copy">u"" syntax for Unicode literals is reintroduced in Python 3.3</span>
<span class="comment-copy">Exactly, this is an awkward problem to solve... thanks.</span>
<span class="comment-copy">Sorry I am a bit confuse about the following result.   <code>&gt;&gt;&gt; isinstance(u"foo", string_types)</code> <code>True</code> <code>&gt;&gt;&gt; isinstance(u"foo".encode("utf-8"), string_types)</code> <code>True</code>  I was expecting isinstance(u"foo", string_types) return false.</span>
<span class="comment-copy">@Chandler.Huang this question is about identifying <code>str</code> and <code>unicode</code> on Python 2, or <code>str</code> on Python 3. If you don't want <code>unicode</code> to count on Python 2, just use <code>str</code>.</span>
<span class="comment-copy">@ecatmur woops, thanks! deleted it, so noone gets confused</span>
<span class="comment-copy">you can also use it from <code>future</code> package instead of <code>six</code>: <code>from future.utils import string_types</code></span>
<span class="comment-copy">I really like this approach.</span>
<span class="comment-copy">me too... simple, elegant, effective! Thanks ;)</span>
<span class="comment-copy">For py3, <code>basestring = (str, bytes)</code> from <code>requests/compat.py</code></span>
<span class="comment-copy">Nice, but why? It would be nice if Python3 would be backward-compatible here. Above solutions works. Would be even better, if there would be no need for it.</span>
<span class="comment-copy">I'm apparently alone with the author, but I think this is rather elegant.</span>
<span class="comment-copy">@holdenweb: No and yes - a nifty "only impacts where needed" hack I think.</span>
<span class="comment-copy">The reason why I like this answer is that it is friendly with migrating from python2 to 3.</span>
<span class="comment-copy">I also went with this option, wrapping it in a helper function, so it only appears once, and there's a place in the docstring to credit Fil.</span>
<span class="comment-copy">Neat, and I was using it myself, until I realized that I also have <code>from __future__ import unicode_literals</code> active.  Now I'm going with: <code>isinstance(val, (str, u"".__class__))</code></span>
<span class="comment-copy"><code>isinstance("", basestring)</code> is what I meant by "calling". Anyway, +1.</span>
<span class="comment-copy">Python is a very dynamic language, and I don't think it looks bad at all to have a test like that.  This is a useful technique for figuring something out one time, and based on that, setting up a function that will always be correct.  Thanks for the +1.</span>
<span class="comment-copy">I'd write it as: <code>try: string_types = basestring except NameError: string_types = str</code></span>
<span class="comment-copy">I guess it should be <code>from</code> instead of <code>for</code>?</span>
<span class="comment-copy">Sorry to bug you but <code>isinstance(u'hello', basestr)</code> yields <code>SyntaxError: invalid syntax</code> for me with Python 3.2.3 under Window 7 .. any idea why this would be? It doesn't seem to like the <code>u</code> - I get this error with <code>str</code> and <code>basestr</code></span>
<span class="comment-copy">@Levon No problem :) That's because <a href="http://docs.python.org/release/3.0.1/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit" rel="nofollow noreferrer">Python3 doesn't have that syntax</a>, as <code>str</code> in Python3 is by definition Unicode. Accordingly, there's no <code>basestring</code> type, hence the <code>NameError</code> that is caught in my snippet.</span>
<span class="comment-copy">It does have that syntax as a noop now. in 3.3</span>
<span class="comment-copy">Thanks LevLevitsky and @Ranman .. need to read up on this.</span>
<span class="comment-copy">I would suggest doing the <code>try</code>/<code>except</code> test a single time, and based on the results of that single test, you define <code>isstr()</code> correctly.  There is no need to incur the overhead of an exception for every call to <code>isstr()</code>.</span>
<span class="comment-copy">I this solution quite a bit.  I found it can be useful to define str = "".__class__, which now allows isinstance(object, str) to be written normally, and also ensures that str(object) will return a unicode string in both Python 2 and Python 3.</span>
<span class="comment-copy">This doesn't work when parsing XML: <code>some_element.text</code> is a 'str' but the compare with 'unicode' would fail</span>
<span class="comment-copy">Does't work with unicode string on python 2: isinstance(u'XXX', ''.__class__) == False</span>
<span class="comment-copy">Not true for Python 2, where <code>string</code> is a unicode string</span>
