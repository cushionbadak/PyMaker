<div class="post-text" itemprop="text">
<p>I have a Python codebase, built for Python 3, which uses Python 3 style open() with encoding parameter:</p>
<p><a href="https://github.com/miohtama/vvv/blob/master/vvv/textlineplugin.py#L47" rel="noreferrer">https://github.com/miohtama/vvv/blob/master/vvv/textlineplugin.py#L47</a></p>
<pre><code>    with open(fname, "rt", encoding="utf-8") as f:
</code></pre>
<p>Now I'd like to backport this code to Python 2.x, so that I would have a codebase which works with Python 2 and Python 3.</p>
<p>What's the recommended strategy to work around <code>open()</code> differences and lack of encoding parameter?</p>
<p>Could I have a Python 3 <code>open()</code> style file handler which streams bytestrings, so it would act like Python 2 <code>open()</code>?</p>
</div>
<div class="post-text" itemprop="text">
<h3>1. To get an encoding parameter in Python 2:</h3>
<p>If you only need to support Python 2.6 and 2.7 you can use <a href="https://docs.python.org/2/library/io.html#io.open" rel="noreferrer"><code>io.open</code></a> instead of <code>open</code>. <code>io</code> is the new io subsystem for Python 3, and it exists in Python 2,6 ans 2.7 as well. Please be aware that in Python 2.6 (as well as 3.0) it's implemented purely in python and very slow, so if you need speed in reading files, it's not a good option.</p>
<p>If you need speed, or you need to support Python 2.5 or earlier, you can use <a href="https://docs.python.org/2/library/codecs.html#codecs.open" rel="noreferrer"><code>codecs.open</code></a> instead. It also has an encoding parameter, and is quite similar to <code>io.open</code> except it handles line-endings differently.</p>
<h3>2. To get a Python 3 <code>open()</code> style file handler which streams bytestrings:</h3>
<pre><code>open(filename, 'rb')
</code></pre>
<p>Note the 'b', meaning 'binary'.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think </p>
<pre><code>from io import open
</code></pre>
<p>should do.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way:</p>
<pre><code>with open("filename.txt", "rb") as f:
    contents = f.read().decode("UTF-8")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This may do the trick:</p>
<pre><code>import sys
if sys.version_info[0] &gt; 2:
    # py3k
    pass
else:
    # py2
    import codecs
    import warnings
    def open(file, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None, closefd=True, opener=None):
        if newline is not None:
            warnings.warn('newline is not supported in py2')
        if not closefd:
            warnings.warn('closefd is not supported in py2')
        if opener is not None:
            warnings.warn('opener is not supported in py2')
        return codecs.open(filename=file, mode=mode, encoding=encoding,
                    errors=errors, buffering=buffering)
</code></pre>
<p>Then you can keep you code in the python3 way.</p>
<p>Note that some APIs like <code>newline</code>, <code>closefd</code>, <code>opener</code> do not work</p>
</div>
<span class="comment-copy">The 'b' actually means binary mode, not bytes. See <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#open</a>.</span>
<span class="comment-copy">@pmdarrow Same thing in this case, but strictly speaking, yes.</span>
<span class="comment-copy">I ran into the problem that you cannot run regex over a byte stream for option 2 ;)</span>
<span class="comment-copy">@macmadness86 You need to use a byte regexp expression.</span>
<span class="comment-copy">A note from the porting howto: "Do not bother with the outdated practice of using codecs.open() as thatâ€™s only necessary for keeping compatibility with Python 2.5." <a href="https://docs.python.org/3/howto/pyporting.html" rel="nofollow noreferrer">docs.python.org/3/howto/pyporting.html</a></span>
<span class="comment-copy">I think Lennart's response below is much better as it provides more explanation and the caveat about the io module being slow in 2.x along with the suggestion to use codecs.open.</span>
<span class="comment-copy">What happens if I use <code>from io import open</code> in Python 3? I do not care for performance currently.</span>
<span class="comment-copy">@matth In python3 open from io is an alias for the built-in open. See <a href="https://docs.python.org/3/library/io.html?highlight=io#io.open" rel="nofollow noreferrer">docs.python.org/3/library/io.html?highlight=io#io.open</a></span>
<span class="comment-copy">this obviously does not work if you had different plans for <code>f</code></span>
<span class="comment-copy">you can reverse the condition to avoid that <code>pass</code>.</span>
