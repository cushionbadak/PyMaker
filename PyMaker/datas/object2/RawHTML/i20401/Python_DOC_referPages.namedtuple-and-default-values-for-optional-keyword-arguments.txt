<div class="post-text" itemprop="text">
<p>I'm trying to convert a longish hollow "data" class into a named tuple. My class currently looks like this:</p>
<pre><code>class Node(object):
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
</code></pre>
<p>After conversion to <code>namedtuple</code> it looks like:</p>
<pre><code>from collections import namedtuple
Node = namedtuple('Node', 'val left right')
</code></pre>
<p>But there is a problem here. My original class allowed me to pass in just a value and took care of the default by using default values for the named/keyword arguments. Something like:</p>
<pre><code>class BinaryTree(object):
    def __init__(self, val):
        self.root = Node(val)
</code></pre>
<p>But this doesn't work in the case of my refactored named tuple since it expects me to pass all the fields. I can of course replace the occurrences of <code>Node(val)</code> to <code>Node(val, None, None)</code> but it isn't to my liking.</p>
<p>So does there exist a good trick which can make my re-write successful without adding a lot of code complexity (metaprogramming) or should I just swallow the pill and go ahead with the "search and replace"? :)</p>
</div>
<div class="post-text" itemprop="text">
<h2>Python 3.7</h2>
<p>Use the <em>defaults</em> parameter.</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; fields = ('val', 'left', 'right')
&gt;&gt;&gt; Node = namedtuple('Node', fields, defaults=(None,) * len(fields))
&gt;&gt;&gt; Node()
Node(val=None, left=None, right=None)
</code></pre>
<h2>Before Python 3.7</h2>
<p>Set <code>Node.__new__.__defaults__</code> to the default values.</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Node = namedtuple('Node', 'val left right')
&gt;&gt;&gt; Node.__new__.__defaults__ = (None,) * len(Node._fields)
&gt;&gt;&gt; Node()
Node(val=None, left=None, right=None)
</code></pre>
<h2>Before Python 2.6</h2>
<p>Set <code>Node.__new__.func_defaults</code> to the default values.</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Node = namedtuple('Node', 'val left right')
&gt;&gt;&gt; Node.__new__.func_defaults = (None,) * len(Node._fields)
&gt;&gt;&gt; Node()
Node(val=None, left=None, right=None)
</code></pre>
<h2>Order</h2>
<p>In all versions of Python, if you set fewer default values than exist in the namedtuple, the defaults are applied to the rightmost parameters. This allows you to keep some arguments as required arguments.</p>
<pre><code>&gt;&gt;&gt; Node.__new__.__defaults__ = (1,2)
&gt;&gt;&gt; Node()
Traceback (most recent call last):
  ...
TypeError: __new__() missing 1 required positional argument: 'val'
&gt;&gt;&gt; Node(3)
Node(val=3, left=1, right=2)
</code></pre>
<h2>Wrapper for Python 2.6 to 3.6</h2>
<p>Here's a wrapper for you, which even lets you (optionally) set the default values to something other than <code>None</code>. This does not support required arguments.</p>
<pre><code>import collections
def namedtuple_with_defaults(typename, field_names, default_values=()):
    T = collections.namedtuple(typename, field_names)
    T.__new__.__defaults__ = (None,) * len(T._fields)
    if isinstance(default_values, collections.Mapping):
        prototype = T(**default_values)
    else:
        prototype = T(*default_values)
    T.__new__.__defaults__ = tuple(prototype)
    return T
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; Node = namedtuple_with_defaults('Node', 'val left right')
&gt;&gt;&gt; Node()
Node(val=None, left=None, right=None)
&gt;&gt;&gt; Node = namedtuple_with_defaults('Node', 'val left right', [1, 2, 3])
&gt;&gt;&gt; Node()
Node(val=1, left=2, right=3)
&gt;&gt;&gt; Node = namedtuple_with_defaults('Node', 'val left right', {'right':7})
&gt;&gt;&gt; Node()
Node(val=None, left=None, right=7)
&gt;&gt;&gt; Node(4)
Node(val=4, left=None, right=7)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I subclassed namedtuple and overrode the <code>__new__</code> method:</p>
<pre><code>from collections import namedtuple

class Node(namedtuple('Node', ['value', 'left', 'right'])):
    __slots__ = ()
    def __new__(cls, value, left=None, right=None):
        return super(Node, cls).__new__(cls, value, left, right)
</code></pre>
<p>This preserves an intuitive type hierarchy, which the creation of a factory function disguised as a class does not.</p>
</div>
<div class="post-text" itemprop="text">
<p>Wrap it in a function.</p>
<pre><code>NodeT = namedtuple('Node', 'val left right')

def Node(val, left=None, right=None):
  return NodeT(val, left, right)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With <a href="https://docs.python.org/3.6/library/typing.html#typing.NamedTuple" rel="noreferrer"><code>typing.NamedTuple</code></a> in Python 3.6.1+ you can provide both a default value and a type annotation to a NamedTuple field. Use <code>typing.Any</code> if you only need the former:</p>
<pre><code>from typing import Any, NamedTuple


class Node(NamedTuple):
    val: Any
    left: 'Node' = None
    right: 'Node' = None
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; Node(1)
Node(val=1, left=None, right=None)
&gt;&gt;&gt; n = Node(1)
&gt;&gt;&gt; Node(2, left=n)
Node(val=2, left=Node(val=1, left=None, right=None), right=None)
</code></pre>
<p>Also, in case you need both default values and optional mutability, Python 3.7 is going to have <a href="https://www.python.org/dev/peps/pep-0557/" rel="noreferrer">data classes (PEP 557)</a> that can in some (many?) cases replace namedtuples.
<hr/>
Sidenote: one quirk of the current specification of <a href="https://www.python.org/dev/peps/pep-3107/" rel="noreferrer">annotations</a> (expressions after <code>:</code> for parameters and variables and after <code>-&gt;</code> for functions) in Python is that they are evaluated at definition time<sup>*</sup>. So, since "class names become defined once the entire body of the class has been executed", the annotations for <code>'Node'</code> in the class fields above must be strings to avoid NameError.</p>
<p>This kind of type hints is called "forward reference" (<a href="https://www.python.org/dev/peps/pep-0484/#forward-references" rel="noreferrer">[1]</a>, <a href="https://www.python.org/dev/peps/pep-0484/#the-problem-of-forward-declarations" rel="noreferrer">[2]</a>), and with <a href="https://www.python.org/dev/peps/pep-0563/" rel="noreferrer">PEP 563</a> Python 3.7+ is going to have a <code>__future__</code> import (to be enabled by default in 4.0) that will allow to use forward references without quotes, postponing their evaluation.</p>
<p><sup><sup>*</sup> AFAICT only local variable annotations are not evaluated at runtime. (source: <a href="https://www.python.org/dev/peps/pep-0526/#runtime-effects-of-type-annotations" rel="noreferrer">PEP 526</a>)</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure if there's an easy way with just the built-in namedtuple. There's a nice module called <a href="http://pypi.python.org/pypi/recordtype/">recordtype</a> that has this functionality:</p>
<pre><code>&gt;&gt;&gt; from recordtype import recordtype
&gt;&gt;&gt; Node = recordtype('Node', [('val', None), ('left', None), ('right', None)])
&gt;&gt;&gt; Node(3)
Node(val=3, left=None, right=None)
&gt;&gt;&gt; Node(3, 'L')
Node(val=3, left=L, right=None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple">an example straight from the docs</a>:</p>
<blockquote>
<p>Default values can be implemented by using _replace() to customize a
  prototype instance:</p>
<pre><code>&gt;&gt;&gt; Account = namedtuple('Account', 'owner balance transaction_count')
&gt;&gt;&gt; default_account = Account('&lt;owner name&gt;', 0.0, 0)
&gt;&gt;&gt; johns_account = default_account._replace(owner='John')
&gt;&gt;&gt; janes_account = default_account._replace(owner='Jane')
</code></pre>
</blockquote>
<p>So, the OP's example would be:</p>
<pre><code>from collections import namedtuple
Node = namedtuple('Node', 'val left right')
default_node = Node(None, None, None)
example = default_node._replace(val="whut")
</code></pre>
<p>However, I like some of the other answers given here better.  I just wanted to add this for completeness. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a more compact version inspired by justinfay's answer:</p>
<pre><code>from collections import namedtuple
from functools import partial

Node = namedtuple('Node', ('val left right'))
Node.__new__ = partial(Node.__new__, left=None, right=None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In python3.7+ there's a brand new <a href="https://docs.python.org/3.7/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">defaults=</a> keyword argument.</p>
<blockquote>
<p><em>defaults</em> can be <code>None</code> or an iterable of default values. Since fields with a default value must come after any fields without a default, the <em>defaults</em> are applied to the rightmost parameters. For example, if the fieldnames are <code>['x', 'y', 'z']</code> and the defaults are <code>(1, 2)</code>, then <code>x</code> will be a required argument, <code>y</code> will default to <code>1</code>, and <code>z</code> will default to <code>2</code>.</p>
</blockquote>
<p>Example usage:</p>
<pre><code>$ ./python
Python 3.7.0b1+ (heads/3.7:4d65430, Feb  1 2018, 09:28:35) 
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; nt = namedtuple('nt', ('a', 'b', 'c'), defaults=(1, 2))
&gt;&gt;&gt; nt(0)
nt(a=0, b=1, c=2)
&gt;&gt;&gt; nt(0, 3)  
nt(a=0, b=3, c=2)
&gt;&gt;&gt; nt(0, c=3)
nt(a=0, b=1, c=3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Short, simple, and doesn't lead people to use <code>isinstance</code> improperly:</p>
<pre><code>class Node(namedtuple('Node', ('val', 'left', 'right'))):
    @classmethod
    def make(cls, val, left=None, right=None):
        return cls(val, left, right)

# Example
x = Node.make(3)
x._replace(right=Node.make(4))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A slightly extended example to initialize <em>all</em> missing arguments with <code>None</code>:</p>
<pre><code>from collections import namedtuple

class Node(namedtuple('Node', ['value', 'left', 'right'])):
    __slots__ = ()
    def __new__(cls, *args, **kwargs):
        # initialize missing kwargs with None
        all_kwargs = {key: kwargs.get(key) for key in cls._fields}
        return super(Node, cls).__new__(cls, *args, **all_kwargs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use this:</p>
<pre><code>import inspect

def namedtuple_with_defaults(type, default_value=None, **kwargs):
    args_list = inspect.getargspec(type.__new__).args[1:]
    params = dict([(x, default_value) for x in args_list])
    params.update(kwargs)

    return type(**params)
</code></pre>
<p>This basically gives you the possibility to construct any named tuple with a default value and override just the parameters you need, for example:</p>
<pre><code>import collections

Point = collections.namedtuple("Point", ["x", "y"])
namedtuple_with_defaults(Point)
&gt;&gt;&gt; Point(x=None, y=None)

namedtuple_with_defaults(Point, x=1)
&gt;&gt;&gt; Point(x=1, y=None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Combining approaches of @Denis and @Mark:</p>
<pre><code>from collections import namedtuple
import inspect

class Node(namedtuple('Node', 'left right val')):
    __slots__ = ()
    def __new__(cls, *args, **kwargs):
        args_list = inspect.getargspec(super(Node, cls).__new__).args[len(args)+1:]
        params = {key: kwargs.get(key) for key in args_list + kwargs.keys()}
        return super(Node, cls).__new__(cls, *args, **params) 
</code></pre>
<p>That should support creating the tuple with positional arguments and also with mixed cases.
Test cases:</p>
<pre><code>&gt;&gt;&gt; print Node()
Node(left=None, right=None, val=None)

&gt;&gt;&gt; print Node(1,2,3)
Node(left=1, right=2, val=3)

&gt;&gt;&gt; print Node(1, right=2)
Node(left=1, right=2, val=None)

&gt;&gt;&gt; print Node(1, right=2, val=100)
Node(left=1, right=2, val=100)

&gt;&gt;&gt; print Node(left=1, right=2, val=100)
Node(left=1, right=2, val=100)

&gt;&gt;&gt; print Node(left=1, right=2)
Node(left=1, right=2, val=None)
</code></pre>
<p>but also support TypeError:</p>
<pre><code>&gt;&gt;&gt; Node(1, left=2)
TypeError: __new__() got multiple values for keyword argument 'left'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.7: introduction of <code>defaults</code> param in namedtuple definition.</p>
<p>Example as shown in the documentation:</p>
<pre><code>&gt;&gt;&gt; Account = namedtuple('Account', ['type', 'balance'], defaults=[0])
&gt;&gt;&gt; Account._fields_defaults
{'balance': 0}
&gt;&gt;&gt; Account('premium')
Account(type='premium', balance=0)
</code></pre>
<p>Read more <a href="https://docs.python.org/3.7/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I find this version easier to read:</p>
<pre><code>from collections import namedtuple

def my_tuple(**kwargs):
    defaults = {
        'a': 2.0,
        'b': True,
        'c': "hello",
    }
    default_tuple = namedtuple('MY_TUPLE', ' '.join(defaults.keys()))(*defaults.values())
    return default_tuple._replace(**kwargs)
</code></pre>
<p>This is not as efficient as it requires creation of the object twice but you could change that by defining the default duple inside the module and just having the function do the replace line. </p>
</div>
<div class="post-text" itemprop="text">
<p>Since you are using <code>namedtuple</code> as a data class, you should be aware that python 3.7 will introduce a <code>@dataclass</code> decorator for this very purpose -- and of course it has default values. </p>
<p><a href="https://docs.python.org/3.7/library/dataclasses.html#dataclasses.dataclass" rel="nofollow noreferrer">An example from the docs</a>:</p>
<pre><code>@dataclass
class C:
    a: int       # 'a' has no default value
    b: int = 0   # assign a default value for 'b'
</code></pre>
<p>Much cleaner, readable and usable than hacking <code>namedtuple</code>. It is not hard to predict that usage of <code>namedtuple</code>s will drop with the adoption of 3.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>Inspired by <a href="https://stackoverflow.com/a/48953578">this answer</a> to a different question, here is my proposed solution based on a <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__metaclass__#metaclasses" rel="nofollow noreferrer">metaclass</a> and using <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super</code></a> (to handle future subcalssing correctly).  It is quite similar to <a href="https://stackoverflow.com/a/16721002">justinfay's answer</a>.</p>
<pre><code>from collections import namedtuple

NodeTuple = namedtuple("NodeTuple", ("val", "left", "right"))

class NodeMeta(type):
    def __call__(cls, val, left=None, right=None):
        return super(NodeMeta, cls).__call__(val, left, right)

class Node(NodeTuple, metaclass=NodeMeta):
    __slots__ = ()
</code></pre>
<p>Then:</p>
<pre><code>&gt;&gt;&gt; Node(1, Node(2, Node(4)),(Node(3, None, Node(5))))
Node(val=1, left=Node(val=2, left=Node(val=4, left=None, right=None), right=None), right=Node(val=3, left=None, right=Node(val=5, left=None, right=None)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the <code>NamedTuple</code> class from my <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer"><code>Advanced Enum (aenum)</code></a> library, and using the <code>class</code> syntax, this is quite simple:</p>
<pre><code>from aenum import NamedTuple

class Node(NamedTuple):
    val = 0
    left = 1, 'previous Node', None
    right = 2, 'next Node', None
</code></pre>
<p>The one potential drawback is the requirement for a <code>__doc__</code> string for any attribute with a default value (it's optional for simple attributes).  In use it looks like:</p>
<pre><code>&gt;&gt;&gt; Node()
Traceback (most recent call last):
  ...
TypeError: values not provided for field(s): val

&gt;&gt;&gt; Node(3)
Node(val=3, left=None, right=None)
</code></pre>
<p>The advantages this has over <a href="https://stackoverflow.com/a/16721002/208880"><code>justinfay's answer</code></a>:</p>
<pre><code>from collections import namedtuple

class Node(namedtuple('Node', ['value', 'left', 'right'])):
    __slots__ = ()
    def __new__(cls, value, left=None, right=None):
        return super(Node, cls).__new__(cls, value, left, right)
</code></pre>
<p>is simplicity, as well as  being <code>metaclass</code> based instead of <code>exec</code> based.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another solution:</p>
<pre><code>import collections


def defaultargs(func, defaults):
    def wrapper(*args, **kwargs):
        for key, value in (x for x in defaults[len(args):] if len(x) == 2):
            kwargs.setdefault(key, value)
        return func(*args, **kwargs)
    return wrapper


def namedtuple(name, fields):
    NamedTuple = collections.namedtuple(name, [x[0] for x in fields])
    NamedTuple.__new__ = defaultargs(NamedTuple.__new__, [(NamedTuple,)] + fields)
    return NamedTuple
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; Node = namedtuple('Node', [
...     ('val',),
...     ('left', None),
...     ('right', None),
... ])
__main__.Node

&gt;&gt;&gt; Node(1)
Node(val=1, left=None, right=None)

&gt;&gt;&gt; Node(1, 2, right=3)
Node(val=1, left=2, right=3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a short, simple generic answer with a nice syntax for a named tuple with default arguments:</p>
<pre><code>import collections

def dnamedtuple(typename, field_names, **defaults):
    fields = sorted(field_names.split(), key=lambda x: x in defaults)
    T = collections.namedtuple(typename, ' '.join(fields))
    T.__new__.__defaults__ = tuple(defaults[field] for field in fields[-len(defaults):])
    return T
</code></pre>
<p>Usage:</p>
<pre><code>Test = dnamedtuple('Test', 'one two three', two=2)
Test(1, 3)  # Test(one=1, three=3, two=2)
</code></pre>
<p>Minified:</p>
<pre><code>def dnamedtuple(tp, fs, **df):
    fs = sorted(fs.split(), key=df.__contains__)
    T = collections.namedtuple(tp, ' '.join(fs))
    T.__new__.__defaults__ = tuple(df[i] for i in fs[-len(df):])
    return T
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answer by jterrace to use recordtype is great, but the author of the library recommends to use his <a href="https://pypi.org/project/namedlist/" rel="nofollow noreferrer">namedlist</a> project, which provides both mutable (<code>namedlist</code>) and immutable (<code>namedtuple</code>) implementations.</p>
<pre><code>from namedlist import namedtuple
&gt;&gt;&gt; Node = namedtuple('Node', ['val', ('left', None), ('right', None)])
&gt;&gt;&gt; Node(3)
Node(val=3, left=None, right=None)
&gt;&gt;&gt; Node(3, 'L')
Node(val=3, left=L, right=None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a less flexible, but more concise version of Mark Lodato's wrapper: It takes the fields and defaults as a dictionary.</p>
<pre><code>import collections
def namedtuple_with_defaults(typename, fields_dict):
    T = collections.namedtuple(typename, ' '.join(fields_dict.keys()))
    T.__new__.__defaults__ = tuple(fields_dict.values())
    return T
</code></pre>
<p>Example:</p>
<pre><code>In[1]: fields = {'val': 1, 'left': 2, 'right':3}

In[2]: Node = namedtuple_with_defaults('Node', fields)

In[3]: Node()
Out[3]: Node(val=1, left=2, right=3)

In[4]: Node(4,5,6)
Out[4]: Node(val=4, left=5, right=6)

In[5]: Node(val=10)
Out[5]: Node(val=10, left=2, right=3)
</code></pre>
</div>
<span class="comment-copy">Why do you want to make this conversion?  I like your original <code>Node</code> class just the way it is.  Why convert to named tuple?</span>
<span class="comment-copy">I wanted to make this conversion because the current <code>Node</code> and other classes are simple data-holder value objects with a bunch of different fields (<code>Node</code> is just one of them). These class declarations are nothing much more than line noise IMHO hence wanted to trim them out. Why maintain something which isn't required? :)</span>
<span class="comment-copy">You don't have any method functions on your classes at all?  You don't, for example, have a <code>.debug_print()</code> method that walks the tree and prints it?</span>
<span class="comment-copy">Sure I do, but that's for the <code>BinaryTree</code> class. <code>Node</code> and other data holders don't require such special methods esp given that named tuples have a decent <code>__str__</code> and <code>__repr__</code> representation. :)</span>
<span class="comment-copy">Okay, seems reasonable.  And I think Ignacio Vazquez-Abrams has given you the answer: use a function that does the default values for your node.</span>
<span class="comment-copy">Let's see...your one-liner: a) is the shortest/simplest answer, b) preserves space efficiency, c) doesn't break <code>isinstance</code> ...all pros, no cons...too bad you were a little late to the party.  This is the best answer.</span>
<span class="comment-copy">One problem with the wrapper version: unlike the builtin collections.namedtuple, this version is not pickleable/multiprocess serializable if the def() is included in a different module.</span>
<span class="comment-copy">I have given this answer an upvote as it is preferable to my own. Its a pity however that my own answer keeps getting upvoted :|</span>
<span class="comment-copy">@ishaaq, the problem is that <code>(None)</code> is not a tuple, it's <code>None</code>.  If you use <code>(None,)</code> instead, it should work fine.</span>
<span class="comment-copy">Excellent! You can generalize the setting-of-defaults  with: <code>Node.__new__.__defaults__= (None,) * len(Node._fields)</code></span>
<span class="comment-copy">This might need slots and fields properties in order to maintain the space efficiency of a named tuple.</span>
<span class="comment-copy">For some reason, <code>__new__</code> is not being called when <code>_replace</code> is used.</span>
<span class="comment-copy">Please take a look at @marc-lodato answer below which IMHO is a better solution than this.</span>
<span class="comment-copy">but @marc-lodato's answer doesn't provide the ability for a subclass to have different defaults</span>
<span class="comment-copy">@JasonS, i suspect that for a subclass to have different defaults could violate the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow noreferrer">LSP</a>. However, a subclass may very well want to have <i>more</i> defaults.  In any case, it would be for the <i>subclass</i> to use justinfay's <a href="https://stackoverflow.com/a/16721002">method</a>, and the base class would be fine with Marc's <a href="https://stackoverflow.com/a/18348004">method</a>.</span>
<span class="comment-copy">This is clever, and can be a good option, but can also cause problems by breaking <code>isinstance(Node('val'), Node)</code>: it will now raise an exception, rather than returning True. While a bit more verbose, <a href="http://stackoverflow.com/a/16721002/260491">@justinfay's answer (below)</a> preserves type hierarchy information properly, so is probably a better approach if others are going to interact with Node instances.</span>
<span class="comment-copy">I like the brevity of this answer. Perhaps the concern in the comment above can be addressed by naming the function <code>def make_node(...):</code> rather than pretending it is a class definition. In that way users are not tempted to check for type polymorphism on the function but use the tuple definition itself.</span>
<span class="comment-copy">See my answer for a variation of this that doesn't suffer from misleading people to use <code>isinstance</code> incorrectly.</span>
<span class="comment-copy">This seems like the cleanest solution for 3.6.1+ users. Note that this example is (slightly) confusing as the type hint for the fields <code>left</code> and <code>right</code> (i.e. <code>Node</code>) is the same type as the class being defined and therefore must be written as strings.</span>
<span class="comment-copy">@101, thank you, I've added a note about this to the answer.</span>
<span class="comment-copy">What's the analog for the idiom <code>my_list: List[T] = None</code> <code>self.my_list = my_list if my_list is not None else []</code>? Can we not use default parameters like this?</span>
<span class="comment-copy">@weberc2 Great question! I'm not sure if this workaround for mutable def. values is possible with <code>typing.NamedTuple</code>. But with data classes <a href="https://www.python.org/dev/peps/pep-0557/#mutable-default-values" rel="nofollow noreferrer">you can use</a> <code>Field</code> objects with a <code>default_factory</code> attr. for this, replacing your idiom with <code>my_list: List[T] = field(default_factory=list)</code>.</span>
<span class="comment-copy">Ah, not possible to use a third party package though <code>recordtype</code> certainly looks interesting for future work. +1</span>
<span class="comment-copy">The module is quite small and only a <a href="https://bitbucket.org/ericvsmith/recordtype/src/c970cb94dc82/recordtype.py" rel="nofollow noreferrer">single file</a> so you could always just add it to your project.</span>
<span class="comment-copy">Fair enough, though I'll wait for some more time for a pure named tuple solution is there is one out there before marking this accepted! :)</span>
<span class="comment-copy">Agreed pure python would be nice, but I don't think there is one :(</span>
<span class="comment-copy">Just to note that <code>recordtype</code> is mutable whereas <code>namedtuple</code> is not. This might matter if you want the object to be hashable (which I guess you don't, since it started out as a class).</span>
<span class="comment-copy">+1. It's very strange that they decided to go with an <code>_</code> method (which basically means a private one) for something like <code>replace</code> which seems pretty useful..</span>
<span class="comment-copy">@sasuke - I was wondering that too.  It's already a little odd that you define the elements with a space separated string instead of <code>*args</code>.  It may just be that it was added to the language before a lot of those things were standardized.</span>
<span class="comment-copy">The  <code>_</code> prefix is to avoid colliding with the names of the user defined tuple fields (relevant doc quote: "Any valid Python identifier may be used for a fieldname except for names starting with an underscore."). As for the space separated string, I think that's just to save a few keystrokes (and you can pass a sequence of strings if you prefer).</span>
<span class="comment-copy">Ah, yeah, I forgot you access the elements of the named tuple as attributes, so the <code>_</code> makes a lot of sense then.</span>
<span class="comment-copy">Your solution is simple and the best. The rest is IMHO rather ugly. I would do only one small change. Instead of default_node I would prefer node_default because it makes better experience with IntelliSense. In case you start typing node you received everything you need :)</span>
<span class="comment-copy">Beware that <code>Node(1, 2)</code> doesn't work with this recipe, but works in @justinfay's answer. Otherwise, it's quite nifty (+1).</span>
<span class="comment-copy">@jorgeca You're right, that is a problem.</span>
<span class="comment-copy"><code>dict</code> has no guarantee of ordering.</span>
