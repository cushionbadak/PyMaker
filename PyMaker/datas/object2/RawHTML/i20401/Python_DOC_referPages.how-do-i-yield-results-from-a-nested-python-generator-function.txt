<div class="post-text" itemprop="text">
<p>I have a function which yields results as it downloads them. For the purposes of this question, lets say I yield a sting once every second but I want a convenience function to wrap my generator:</p>
<pre><code>import time

def GeneratorFunction(max_val):
    for i in range(0,5):
        time.sleep(1)
        yield "String %d"%i

def SmallGenerator():
    yield GeneratorFunction(3)

for s in SmallGenerator():
    print s
</code></pre>
<p>...why doesn't that just print the 5 strings I'm expecting? Instead it appears to return the generator functio:</p>
<pre><code>&lt;generator object GeneratorFunction at 0x020649B8&gt;
</code></pre>
<p>How can I get this to yield the strings as a normal generator function would?</p>
</div>
<div class="post-text" itemprop="text">
<p>Can't believe I missed this; The answer is to simply return the generator function with suitable arguments applied:</p>
<pre><code>import time

def GeneratorFunction(max_val):
    for i in range(0,max_val):
        time.sleep(1)
        yield "String %d"%i

def SmallGenerator():
    return GeneratorFunction(3) # &lt;-- note the use of return instead of yield

for s in SmallGenerator():
    print s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may have to use the <a href="https://docs.python.org/3/whatsnew/3.3.html" rel="noreferrer">new <code>yield from</code></a>, available since Python 3.3, known as “<a href="https://docs.python.org/3/reference/expressions.html#yieldexpr" rel="noreferrer">delegated generator</a>”.</p>
<p>If I understood the question correctly, I came to the same issue, and found an answer elsewhere.</p>
<p>I wanted to do something like this:</p>
<pre><code>def f():

    def g():

        do_something()
        yield x
        …
        yield y

    do_some_other_thing()
    yield a
    …
    g()  # Was not working.
    yield g()  # Was not what was expected neither; yielded None.
    …
    yield b
</code></pre>
<p>I now use this instead:</p>
<pre><code>yield from g()  # Now it works, it yields x and Y.
</code></pre>
<p>I got the answer from this page: <a href="http://simeonvisser.com/posts/python-3-using-yield-from-in-generators-part-1.html" rel="noreferrer">Python 3: Using "yield from" in Generators - Part 1 (simeonvisser.com)</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Came here looking for a different form of "nested yield" and finally found the hidden answer. Might not be the best but it works. </p>
<p>I was wanting to yield through a registry tree and here is the solution.</p>
<pre><code>        def genKeys(key):
            for value in key.values():
                yield value
            for subkey in key.subkeys():
                print(subkey)
                for x in genKeys(subkey): #this is the trick
                    continue
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another small example for generating the multiplication table from 1 to 10:</p>
<pre><code>class Gen1:

    def __init__(self, gen2):
        self.gen2 = gen2

    def __iter__(self):    
        for a in range(1, 11):    
            for b in self.gen2:
                yield a * b


class Gen2:    

    def __iter__(self):
        for a in range(1, 11):
            yield a


def main():

    gen2 = Gen2()
    gen1 = Gen1(gen2)

    for v in gen1:
        print(v)

if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I came looking for another use of nested yields..</p>
<pre><code>list_of_lists = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
]

def iter_all(foo):
    yield foo

    if isinstance(foo, list):
        for i in foo:
            for x in iter_all(i):
                yield x


print([i for i in iter_all(list_of_lists)])
</code></pre>
<p>output:</p>
<pre><code>[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1, 2, 3], 1, 2, 3, [4, 5, 6], 4, 5, 6, [7, 8, 9], 7, 8, 9]
</code></pre>
</div>
<span class="comment-copy">FYI, in Python 3.3, <code>yield from GeneratorFunction(3)</code> will work..</span>
<span class="comment-copy">@DSM: Thanks. Still not quite made the transition to 3+ yet...</span>
