<div class="post-text" itemprop="text">
<p>I'm using eSpeak on Ubuntu and have a Python 2.7 script that prints and speaks a message:</p>
<pre><code>import subprocess
text = 'Hello World.'
print text
subprocess.call(['espeak', text])
</code></pre>
<p>eSpeak produces the desired sounds, but clutters the shell with some errors (ALSA lib..., no socket connect) so i cannot easily read what was printed earlier. Exit code is 0. </p>
<p>Unfortunately there is no documented option to turn off its verbosity, so I'm looking for a way to only visually silence it and keep the open shell clean for further interaction.</p>
<p>How can I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Redirect the output to DEVNULL:</p>
<pre><code>import os
import subprocess

FNULL = open(os.devnull, 'w')
retcode = subprocess.call(['echo', 'foo'], stdout=FNULL, stderr=subprocess.STDOUT)
</code></pre>
<p>It is effectively the same as running this shell command:</p>
<pre><code>retcode = os.system("echo 'foo' &amp;&gt; /dev/null")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a more portable version (just for fun, it is not necessary in your case):</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-
from subprocess import Popen, PIPE, STDOUT

try:
    from subprocess import DEVNULL # py3k
except ImportError:
    import os
    DEVNULL = open(os.devnull, 'wb')

text = u"René Descartes"
p = Popen(['espeak', '-b', '1'], stdin=PIPE, stdout=DEVNULL, stderr=STDOUT)
p.communicate(text.encode('utf-8'))
assert p.returncode == 0 # use appropriate for your program error handling here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/2/library/subprocess.html#subprocess.check_output" rel="noreferrer"><code>subprocess.check_output</code></a> (new in python 2.7).  It will suppress stdout and raise an exception if the command fails.  (It actually returns the contents of stdout, so you can use that later in your program if you want.)  Example:</p>
<pre><code>import subprocess
try:
    subprocess.check_output(['espeak', text])
except subprocess.CalledProcessError:
    # Do something
</code></pre>
<p>You can also suppress stderr with:</p>
<pre><code>    subprocess.check_output(["espeak", text], stderr=subprocess.STDOUT)
</code></pre>
<p>For earlier than 2.7, use</p>
<pre><code>import os
import subprocess
with open(os.devnull, 'w')  as FNULL:
    try:
        subprocess._check_call(['espeak', text], stdout=FNULL)
    except subprocess.CalledProcessError:
        # Do something
</code></pre>
<p>Here, you can suppress stderr with </p>
<pre><code>        subprocess._check_call(['espeak', text], stdout=FNULL, stderr=FNULL)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of Python3 you no longer need to open devnull and can call <a href="https://docs.python.org/3/library/subprocess.html#subprocess.DEVNULL" rel="nofollow noreferrer">subprocess.DEVNULL</a>.</p>
<p>Your code would be updated as such:</p>
<pre><code>import subprocess
text = 'Hello World.'
print(text)
subprocess.call(['espeak', text], stderr=subprocess.DEVNULL)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if you happen to be using the subprocess module in windows (not specific to this question but matches title) with python 2.7x and it is ONLY the errors you want to suppress (specific to this question), you can do something like this:</p>
<p><code>output = subprocess.check_output(["arp", "-a", "-N", "127.0.0.2"], stderr=subprocess.STDOUT)</code></p>
<p>you should be able to test using the code above on your system but if 127.0.0.2 happens to exist in your arp table you can just pick an ip that does not have a nic associated with it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not use commands.getoutput() instead?</p>
<pre><code>import commands

text = "Mario Balotelli" 
output = 'espeak "%s"' % text
print text
a = commands.getoutput(output)
</code></pre>
</div>
<span class="comment-copy">could you not just call with os.system then? not ideal but shouldnt print i dont think</span>
<span class="comment-copy">@JoranBeasley: os.system() will print to the console unless you redirect the shell command</span>
<span class="comment-copy">no, os.system('espeak '+ text) reproduces this behavior.</span>
<span class="comment-copy">@ferkulat: I updated my answer to also show the <code>os.system</code> syntax. Though it is just for illustration. Stick with subprocess</span>
<span class="comment-copy">Non 2.7 specific version: <a href="http://stackoverflow.com/questions/5495078/how-do-you-discard-subprocess-output-in-python" title="how do you discard subprocess output in python">stackoverflow.com/questions/5495078/…</a> which allows for the perfect <code>subprocess.DEVNUL</code> solution.</span>
<span class="comment-copy">micro neat picks: you could use <code>os.devnull</code> if <code>subprocess.DEVNULL</code> is not available (&lt;3.3), use <code>check_call()</code> instead of <code>call()</code> if you don't check its returned code, open files in binary mode for <code>stdin/stdout/stderr</code>, usage of <code>os.system()</code> should be discouraged, <code>&amp;&gt;</code> doesn't work for <code>sh</code> on Ubuntu an explicit <code>&gt;/dev/null 2&gt;&amp;1</code> could be used.</span>
<span class="comment-copy">@J.F.Sebastian: Thanks for the suggestions. I actually meant to use <code>os.devnull</code> but accidentally typed it out. Also, I am sticking with the OPs use of <code>call</code> since they are not catching the possible exception <code>check_call</code> would raise. And for the <code>os.system</code> redirect, it was more just an illustration of what the effective use of the subprocess approach is doing. Not really as a second suggestion.</span>
<span class="comment-copy">Don't you need to close the FNULL that you have opened?</span>
<span class="comment-copy">Just a note, you can use <code>close_fds=True</code> in <code>subprocess.call</code> to close the <code>FNULL</code> descriptor after the subprocess exists</span>
<span class="comment-copy">@ewino: On <code>close_fds=True</code>,  file descriptors are closed <i>after</i> <code>fork()</code> but <i>before</i> <code>execvp()</code> i.e., they are closed in the <i>child</i> process just <i>before</i> the executable is run. <a href="https://www.python.org/dev/peps/pep-0446/#inheritance-of-file-descriptors-on-windows" rel="nofollow noreferrer"><code>close_fds=True</code> won't work on Windows if any of the streams are redirected</a>. <code>close_fds</code> does not close files in the <i>parent</i> process.</span>
<span class="comment-copy">Note that this produces a <code>DEVNULL</code> which isn't fully general, like the one provided by <code>subprocess</code>; since it's opened <code>wb</code> it can't be used for <code>stdin</code>.</span>
<span class="comment-copy">@Reid: you could use <code>'r+b'</code> mode if you need it instead.</span>
<span class="comment-copy">More precisely, it returns the stdout. Which is great as might want to use it as well besides being able to ignore it.</span>
<span class="comment-copy">However, it doesn't mask out standard errors.</span>
<span class="comment-copy">I think this is more straightforward. @StudentT I think you should handle errors with CalledProcessError. <code>except subprocess.CalledProcessError as e</code> and then use <code>e.code</code> or <code>e.output</code></span>
<span class="comment-copy">That doesn't suppress the errors. It redirects stderr to stdout, so <code>output</code> has mushed output and errors, which is probably not what is desired.</span>
<span class="comment-copy">a) it doesn't discard input, it accumulates it in memory unnecessarily b) it breaks if <code>text</code> has quotes in it, or uses a different character encoding, or too large for a command line c) it is Unix only (on Python 2)</span>
