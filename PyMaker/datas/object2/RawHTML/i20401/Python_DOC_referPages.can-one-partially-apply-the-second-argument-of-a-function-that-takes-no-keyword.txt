<div class="post-text" itemprop="text">
<p>Take for example the python built in <code>pow()</code> function.</p>
<pre><code>xs = [1,2,3,4,5,6,7,8]

from functools import partial

list(map(partial(pow,2),xs))

&gt;&gt;&gt; [2, 4, 8, 16, 32, 128, 256]
</code></pre>
<p>but how would I raise the xs to the power of 2?</p>
<p>to get <code>[1, 4, 9, 16, 25, 49, 64]</code></p>
<pre><code>list(map(partial(pow,y=2),xs))

TypeError: pow() takes no keyword arguments
</code></pre>
<p>I know list comprehensions would be easier.</p>
</div>
<div class="post-text" itemprop="text">
<h1>No</h1>
<p>According to <a href="http://docs.python.org/library/functools.html#functools.partial.args">the documentation</a>, <a href="http://docs.python.org/library/functools.html#functools.partial"><code>partial</code></a> <em>cannot</em> do this (emphasis my own):</p>
<blockquote>
<p><strong>partial.args</strong></p>
<blockquote>
<p>The <em>leftmost</em> positional arguments that will be prepended to the positional arguments</p>
</blockquote>
</blockquote>
<hr/>
<p>You could always just "fix" <code>pow</code> to have keyword args:</p>
<pre><code>_pow = pow
pow = lambda x, y: _pow(x, y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think I'd just use this simple one-liner:</p>
<pre><code>import itertools
print list(itertools.imap(pow, [1, 2, 3], itertools.repeat(2)))
</code></pre>
<p><strong>Update:</strong></p>
<p>I also came up with a funnier than useful solution. It's a beautiful syntactic sugar, profiting from the fact that the <code>...</code> literal means <code>Ellipsis</code> in Python3. It's a modified version of <code>partial</code>, allowing to omit some positional arguments between the leftmost and rightmost ones. The only drawback is that you can't pass anymore Ellipsis as argument.</p>
<pre><code>import itertools
def partial(func, *args, **keywords):
    def newfunc(*fargs, **fkeywords):
        newkeywords = keywords.copy()
        newkeywords.update(fkeywords)
        return func(*(newfunc.leftmost_args + fargs + newfunc.rightmost_args), **newkeywords)
    newfunc.func = func
    args = iter(args)
    newfunc.leftmost_args = tuple(itertools.takewhile(lambda v: v != Ellipsis, args))
    newfunc.rightmost_args = tuple(args)
    newfunc.keywords = keywords
    return newfunc

&gt;&gt;&gt; print partial(pow, ..., 2, 3)(5) # (5^2)%3
1
&gt;&gt;&gt; print partial(pow, 2, ..., 3)(5) # (2^5)%3
2
&gt;&gt;&gt; print partial(pow, 2, 3, ...)(5) # (2^3)%5
3
&gt;&gt;&gt; print partial(pow, 2, 3)(5) # (2^3)%5
3
</code></pre>
<p>So the the solution for the original question would be with this version of partial <code>list(map(partial(pow, ..., 2),xs))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Why not just create a quick lambda function which reorders the args and partial that</p>
<pre><code>partial(lambda p, x: pow(x, p), 2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could create a helper function for this:</p>
<pre><code>from functools import wraps
def foo(a, b, c, d, e):
    print('foo(a={}, b={}, c={}, d={}, e={})'.format(a, b, c, d, e))

def partial_at(func, index, value):
    @wraps(func)
    def result(*rest, **kwargs):
        args = []
        args.extend(rest[:index])
        args.append(value)
        args.extend(rest[index:])
        return func(*args, **kwargs)
    return result

if __name__ == '__main__':
    bar = partial_at(foo, 2, 'C')
    bar('A', 'B', 'D', 'E') 
    # Prints: foo(a=A, b=B, c=C, d=D, e=E)
</code></pre>
<p>Disclaimer: I haven't tested this with keyword arguments so it might blow up because of them somehow. Also I'm not sure if this is what <code>@wraps</code> should be used for but it seemed right -ish.</p>
</div>
<div class="post-text" itemprop="text">
<p>you could use a closure</p>
<pre><code>xs = [1,2,3,4,5,6,7,8]

def closure(method, param):
  def t(x):
    return method(x, param)
  return t

f = closure(pow, 2)
f(10)
f = closure(pow, 3)
f(10)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way of doing it would be:</p>
<pre><code>def testfunc1(xs):
    from functools import partial
    def mypow(x,y): return x ** y
    return list(map(partial(mypow,y=2),xs))
</code></pre>
<p>but this involves re-defining the pow function.</p>
<p>if the use of partial was not 'needed' then a simple lambda would do the trick</p>
<pre><code>def testfunc2(xs):
    return list(map(lambda x: pow(x,2), xs))
</code></pre>
<p>And a specific way to map the pow of 2 would be</p>
<pre><code>def testfunc5(xs):
    from operator import mul
    return list(map(mul,xs,xs))
</code></pre>
<p>but none of these fully address the problem directly of partial applicaton in relation to keyword arguments</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with <code>lambda</code>, which is more flexible than <code>functools.partial()</code>:</p>
<pre><code>pow_two = lambda base: pow(base, 2)
print(pow_two(3))  # 9
</code></pre>
<p>More generally:</p>
<pre><code>def bind_skip_first(func, *args, **kwargs):
  return lambda first: func(first, *args, **kwargs)

pow_two = bind_skip_first(pow, 2)
print(pow_two(3))  # 9
</code></pre>
<p>One down-side of lambda is that some libraries are not able to serialize it.</p>
</div>
<div class="post-text" itemprop="text">
<p>The very versatile <a href="http://funcy.readthedocs.io/en/stable/index.html" rel="nofollow noreferrer">funcy</a> includes an <code>rpartial</code> function that exactly addresses this problem.</p>
<pre><code>xs = [1,2,3,4,5,6,7,8]
from funcy import rpartial
list(map(rpartial(pow, 2), xs))
# [1, 4, 9, 16, 25, 36, 49, 64]
</code></pre>
<p>It's just a lambda under the hood:</p>
<pre><code>def rpartial(func, *args):
    """Partially applies last arguments."""
    return lambda *a: func(*(a + args))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As already said that's a limitation of <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a> if the function you want to <code>partial</code> doesn't accept keyword arguments.</p>
<p>If you don't mind using an external library <sup>1</sup> you could use <a href="https://iteration-utilities.readthedocs.io/en/latest/generated/partial.html" rel="nofollow noreferrer"><code>iteration_utilities.partial</code></a> which has a partial that supports placeholders:</p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import partial
&gt;&gt;&gt; square = partial(pow, partial._, 2)  # the partial._ attribute represents a placeholder
&gt;&gt;&gt; list(map(square, xs))
[1, 4, 9, 16, 25, 36, 49, 64]
</code></pre>
<hr/>
<p><sup>1</sup> Disclaimer: I'm the author of the <a href="https://github.com/MSeifert04/iteration_utilities" rel="nofollow noreferrer"><code>iteration_utilities</code></a> library (installation instructions can be found <a href="http://iteration-utilities.readthedocs.io/en/latest/installation.html" rel="nofollow noreferrer">in the documentation</a> in case you're interested).</p>
</div>
<div class="post-text" itemprop="text">
<p>If you can't use lambda functions, you can also write a simple wrapper function that reorders the arguments. </p>
<pre><code>def _pow(y, x):
    return pow(x, y)
</code></pre>
<p>and then call</p>
<pre><code>list(map(partial(_pow,2),xs))

&gt;&gt;&gt; [1, 4, 9, 16, 25, 36, 49, 64]
</code></pre>
</div>
<span class="comment-copy">another usage of partial starting from 2-nd argument is partial for method(s) omitting self argument</span>
<span class="comment-copy">now why didn't I read the documentation. P.S beautiful formatting of this answer. +1</span>
<span class="comment-copy">if in python 4.X pow() is "fixed", we will all know where they got their idea from :)</span>
<span class="comment-copy">@beoliver: Actually, as of <a href="https://www.python.org/dev/peps/pep-0457/" rel="nofollow noreferrer">PEP-457</a>, positional-only arguments are formalized into what seems to be a feature, so I would never expect a fix to <code>pow</code></span>
<span class="comment-copy">When using lambda here, you don't need the <code>functools.partial()</code> anymore.</span>
<span class="comment-copy">@Eric clever solution!</span>
<span class="comment-copy">nice, for some reason I never use repeat.  and as I'm on 3.X, it's just <code>list(map(pow, [1, 2, 3], itertools.repeat(2)))</code></span>
<span class="comment-copy">nice, I didn't know they changed <code>map</code> in Python3</span>
<span class="comment-copy">izip is also now zip EDIT... I only just saw your update!!! ;)</span>
<span class="comment-copy">The funny one is pretty clever in a somewhat horrifying way :P (Also, you're not really supposed to pass Ellipsis around to begin with, so that's not much of a disadvantage. Unless you count "using Ellipsis for something it's not meant to be used" a disadvantage.)</span>
<span class="comment-copy">after learning some functional programming, for me it looks like a bizarre way of function currying in python</span>
<span class="comment-copy">The most readable solution!</span>
<span class="comment-copy">Major +1. I was tempted to select this answer, but I suppose I was thinking more about the inbuilt <code>functools.partial</code>. But this is definitely being saved. I like :)</span>
<span class="comment-copy">+1 nice and simple, I suppose I could build up a little library of various closures. :) ... now which one was I looking for again.</span>
<span class="comment-copy">This should be added to the question, not posted as an answer.</span>
<span class="comment-copy">yesterday I was advised to add my attempts as an answer as opposed to the question. It's a no win situation!</span>
<span class="comment-copy">I think here it's OK. You should phrase it more as "Here's one way to do it" rather than as an addition to the question. To a certain extent, pretend you're someone else answering.</span>
<span class="comment-copy">Maybe take a look at <a href="http://meta.stackexchange.com/questions/17845/etiquette-for-answering-your-own-question" title="etiquette for answering your own question">meta.stackexchange.com/questions/17845/â€¦</a></span>
<span class="comment-copy">@Eric, just gave it a read. I think this answer is in keeping. I'll tweak it a bit</span>
<span class="comment-copy">What do you mean with some libraries? I think no library is able to serialize them.</span>
<span class="comment-copy">I'm often using ruamel.yaml and it serializes lambdas fine.</span>
<span class="comment-copy">Okay, I was thinking about the built-in modules. Thanks for the clarification :)</span>
<span class="comment-copy">Not "exactly". The second argument need not necessarily be the last one.</span>
