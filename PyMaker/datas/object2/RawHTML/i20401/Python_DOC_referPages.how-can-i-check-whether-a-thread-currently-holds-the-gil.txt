<div class="post-text" itemprop="text">
<p>I tried to find a function that tells me whether the current thread has the global interpreter lock or not.</p>
<p>The Python/C-API documentation does not seem to contain such a function.</p>
<p>My current solution is to just acquire the lock using <code>PyGILState_Ensure()</code> before releasing it using <code>PyEval_SaveThread</code> to not try releasing a lock that wasn't acquired by the current thread.</p>
<p>(btw. what does "issues a fatal error" mean?)</p>
<p>Background of this question: I have a multithreaded application which embeds Python. If a thread is closed without releasing the lock (which might occur due to crashes), other threads are not able to run any more. Thus, when cleaning up/closing the thread, I would like to check whether the lock is held by this thread and release it in this case.</p>
<p>Thanks in advance for answers!</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using (or can use) Python 3.4, there's a new function for the exact same purpose:</p>
<pre><code>if (PyGILState_Check()) {
    /* I have the GIL */
}
</code></pre>
<p><a href="https://docs.python.org/3/c-api/init.html?highlight=pygilstate_check#c.PyGILState_Check" rel="noreferrer">https://docs.python.org/3/c-api/init.html?highlight=pygilstate_check#c.PyGILState_Check</a></p>
<blockquote>
<p>Return 1 if the current thread is holding the GIL and 0 otherwise. This function can be called from any thread at any time. Only if it has had its Python thread state initialized and currently is holding the GIL will it return 1. This is mainly a helper/diagnostic function. It can be useful for example in callback contexts or memory allocation functions when knowing that the GIL is locked can allow the caller to perform sensitive actions or otherwise behave differently.</p>
</blockquote>
<p>In python 2, you can try something like the following:</p>
<pre><code>int PyGILState_Check2(void) {
    PyThreadState * tstate = _PyThreadState_Current;
    return tstate &amp;&amp; (tstate == PyGILState_GetThisThreadState());
}
</code></pre>
<p>It seems to work well in the cases i have tried.
<a href="https://github.com/pankajp/pygilstate_check/blob/master/_pygilstate_check.c#L9" rel="noreferrer">https://github.com/pankajp/pygilstate_check/blob/master/_pygilstate_check.c#L9</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I dont know what you are looking for ... but just you should consider the use of the both macros <code>Py_BEGIN_ALLOW_THREADS</code> and <code>Py_END_ALLOW_THREADS</code>, with this macros you can make sure that the code between them doesn't have the GIL locked and random crashes inside them will be sure.</p>
</div>
<span class="comment-copy">If a thread crashes while holding the GIL, I cannot imagine that it would be safe to run another Python thread.</span>
<span class="comment-copy">Why don't you just fix your thread code so it wont crash?</span>
<span class="comment-copy">@dietrich-epp: the code that causes the crash is normally not python, in fact it might not even be necessarily python code where the crash happens. Most data is thread local (only exception are parts in the python interpreter) so a crash in one thread will not have (too much) side effects in other threads.</span>
<span class="comment-copy">@jochen-ritzel: the code base is quite huge, and even if most python API-parts were coded defensively, scripting using python might disclose further deficiencies.</span>
<span class="comment-copy">You might able to use the <code>faulthandler</code> module in Python 3.3.</span>
<span class="comment-copy">I am already using the functions PyGILState_Ensure()/PyGILState_Release() for acquiring/releasing the GIL. Additionally, SWIG acquires/releases the lock whenever calling into/leaving the C library code. So Py_BEGIN_ALLOW_THREADS and Py_END_ALLOW_THREADS are not needed in my case. But I think you are right when saying that random crashes can only occur in an unlocked state.</span>
