<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/377017/test-if-executable-exists-in-python">Test if executable exists in Python?</a>
<span class="question-originals-answer-count">
                    21 answers
                </span>
</li>
</ul>
</div>
<p>How do I check if a program exists from a python script?</p>
<p>Let's say you want to check if <code>wget</code> or <code>curl</code> are available. We'll assume that they should be in path.</p>
<p>It would be the best to see a multiplatform solution but for the moment, Linux is enough.</p>
<p>Hints: </p>
<ul>
<li>running the command and checking for return code is not always enough as some tools do return non 0 result even when you try <code>--version</code>. </li>
<li>nothing should be visible on screen when checking for the command</li>
</ul>
<p>Also, I would appreciate a solution that that is more general, like <code>is_tool(name)</code></p>
</div>
<div class="post-text" itemprop="text">
<h1>shutil.which</h1>
<p>Let me recommend an option that has not been discussed yet: a Python implementation of <code>which</code>, specifically <code>shutil.which</code>. It was introduced in Python 3.3 and is cross-platform, supporting Linux, Mac, and Windows. It is also available in Python 2.x via <a href="https://pypi.python.org/pypi/whichcraft" rel="noreferrer">whichcraft</a>. You can also just rip the code for <code>which</code> right out of whichcraft <a href="https://github.com/pydanny/whichcraft/blob/master/whichcraft.py#L20" rel="noreferrer">here</a> and insert it into your program.</p>
<pre><code>def is_tool(name):
    """Check whether `name` is on PATH and marked as executable."""

    # from whichcraft import which
    from shutil import which

    return which(name) is not None
</code></pre>
<hr/>
<h1>distutils.spawn.find_executable</h1>
<p>Another option that has already been mentioned is <code>distutils.spawn.find_executable</code>.</p>
<p><code>find_executable</code>'s docstring is as follows:</p>
<blockquote>
<p>Tries to find 'executable' in the directories listed in 'path'</p>
</blockquote>
<p>So if you pay attention, you'll note that the name of the function is somewhat misleading. Unlike <code>which</code>, <code>find_executable</code> does not actually verify that <code>executable</code> is marked as executable, only that it is on the PATH. So it's entirely possible (however unlikely) that <code>find_executable</code> indicates a program is available when it is not.</p>
<p>For example, suppose you have a file <code>/usr/bin/wget</code> that is not marked executable. Running <code>wget</code> from the shell will result in the following error: <em>bash: /usr/bin/wget: Permission denied</em>. <code>which('wget') is not None</code> will return False, yet <code>find_executable('wget') is not None</code> will return True. You can probably get away with using either function, but this is just something to be aware of with <code>find_executable</code>.</p>
<pre><code>def is_tool(name):
    """Check whether `name` is on PATH."""

    from distutils.spawn import find_executable

    return find_executable(name) is not None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way is to try to run the program with the desired parameters, and handle the exception if it doesn't exist:</p>
<pre><code>try:
    subprocess.call(["wget", "your", "parameters", "here"])
except OSError as e:
    if e.errno == os.errno.ENOENT:
        # handle file not found error.
    else:
        # Something else went wrong while trying to run `wget`
        raise
</code></pre>
<p>This is a common pattern in Python: <a href="http://docs.python.org//glossary.html#term-eafp" rel="noreferrer">EAFP</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a subprocess call to the binary needed with :</p>
<ul>
<li>"which" : *nix</li>
<li>"where" : Win 2003 and later (Xp has an addon)</li>
</ul>
<p>to get the executable path (supposing it is in the environment path).</p>
<pre><code>import os 
import platform
import subprocess

cmd = "where" if platform.system() == "Windows" else "which"
try: 
    subprocess.call([cmd, your_executable_to_check_here])
except: 
    print "No executable"
</code></pre>
<p>or just use Ned Batchelder's wh.py script, that is a "which" cross platform implementation:</p>
<p><a href="http://nedbatchelder.com/code/utilities/wh_py.html">http://nedbatchelder.com/code/utilities/wh_py.html</a> </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import subprocess
import os

def is_tool(name):
    try:
        devnull = open(os.devnull)
        subprocess.Popen([name], stdout=devnull, stderr=devnull).communicate()
    except OSError as e:
        if e.errno == os.errno.ENOENT:
            return False
    return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd go for:</p>
<pre><code>import distutils.spawn

def is_tool(name):
  return distutils.spawn.find_executable(name) is not None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would probably shell out to <code>which wget</code> or <code>which curl</code> and check that the result ends in the name of the program you are using. The magic of unix :)</p>
<p>Actually, all you need to do is check the return code of <code>which</code>. So... using our trusty <code>subprocess</code> module:</p>
<pre><code>import subprocess

rc = subprocess.call(['which', 'wget'])
if rc == 0:
    print 'wget installed!'
else:
    print 'wget missing in path!'
</code></pre>
<p>Note that I tested this on windows with cygwin... If you want to figure out how to implement <code>which</code> in pure python, i suggest you check here: <a href="http://pypi.python.org/pypi/pycoreutils" rel="nofollow noreferrer">http://pypi.python.org/pypi/pycoreutils</a> (oh dear - it seems they don't supply <code>which</code>. Time for a friendly nudge?)</p>
<p><strong>UPDATE</strong>: On Windows, you can use <code>where</code> instead of <code>which</code> for a similar effect.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd change @sorin's answer as follows, the reason is it would check the name of the program without passing the absolute path of the program</p>
<pre><code>from subprocess import Popen, PIPE

def check_program_exists(name):
    p = Popen(['/usr/bin/which', name], stdout=PIPE, stderr=PIPE)
    p.communicate()
    return p.returncode == 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
import subprocess


def is_tool(prog):
    for dir in os.environ['PATH'].split(os.pathsep):
        if os.path.exists(os.path.join(dir, prog)):
            try:
                subprocess.call([os.path.join(dir, prog)],
                                stdout=subprocess.PIPE,
                                stderr=subprocess.STDOUT)
            except OSError, e:
                return False
            return True
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A slight modification to @SvenMarnach's code that addresses the issue of printing to the standard output stream.  If you use the <code>subprocess.check_output()</code> function rather than <code>subprocess.call()</code> then you can handle the string that is normally printed to standard out in your code and still catch exceptions and the exit status code.</p>
<p>If you want to suppress the standard output stream in the terminal, donâ€™t print the std out string that is returned from <code>check_output</code>:</p>
<pre><code>import subprocess
import os
try:
    stdout_string = subprocess.check_output(["wget", "--help"], stderr=subprocess.STDOUT)
    # print(stdout_string)
except subprocess.CalledProcessError as cpe:
    print(cpe.returncode)
    print(cpe.output)
except OSError as e:
    if e.errno == os.errno.ENOENT:
        print(e)
    else:
        # Something else went wrong while trying to run `wget`
        print(e)
</code></pre>
<p>The non-zero exit status code and output string are raised in the <code>CalledProcessError</code> as  <code>subprocess.CalledProcessError.returncode</code> and <code>subprocess.CalledProcessError.output</code> so you can do whatever you'd like with them. </p>
<p>If you want to print the executable's standard output to the terminal, print the string that is returned:</p>
<pre><code>import subprocess
import os
try:
    stdout_string = subprocess.check_output(["wget", "--help"], stderr=subprocess.STDOUT)
    print(stdout_string)
except subprocess.CalledProcessError as cpe:
    print(cpe.returncode)
    print(cpe.output)
except OSError as e:
    if e.errno == os.errno.ENOENT:
        print(e)
    else:
        # Something else went wrong while trying to run `wget`
        print(e)
</code></pre>
<p><code>print()</code> adds an extra newline to the string.  If you want to eliminate that (and write std error to the std err stream instead of the std out stream as shown with the print() statements above), use <code>sys.stdout.write(string)</code> and <code>sys.stderr.write(string)</code> instead of print():</p>
<pre><code>import subprocess
import os
import sys
try:
    stdout_string = subprocess.check_output(["bogus"], stderr=subprocess.STDOUT)
    sys.stdout.write(stdout_string)
except subprocess.CalledProcessError as cpe:
    sys.stderr.write(cpe.returncode)
    sys.stderr.write(cpe.output)
except OSError as e:
    if e.errno == os.errno.ENOENT:
        sys.stderr.write(e.strerror)
    else:
        # Something else went wrong while trying to run `wget`
        sys.stderr.write(e.strerror)
</code></pre>
</div>
<span class="comment-copy">Link to docs for <code>shutil.which()</code>: <a href="https://docs.python.org/3/library/shutil.html#shutil.which" rel="nofollow noreferrer">docs.python.org/3/library/shutil.html#shutil.which</a></span>
<span class="comment-copy">up vote for distutils.spawn.find_executable! Thanks man!</span>
<span class="comment-copy">right. for programs you know how to use, this is probably the best way to go about it. After all: expecting success often leads to cleaner code...</span>
<span class="comment-copy">@DarenThomas: For programs you don't know how to use, the information whether they exist or not doesn't seem to be too useful. :)</span>
<span class="comment-copy">I like your approach, but it does pollute the stdout and stderr. Also, it is not a function ;)</span>
<span class="comment-copy">Your solution will display output of the executed command, look at my solution, based on yours, which is totally quiet. <a href="http://stackoverflow.com/a/11210902/99834">stackoverflow.com/a/11210902/99834</a></span>
<span class="comment-copy">@SorinSbarnea: My approach is a completely different one.  The only reason you might be testing if a command exists is that you are planning to run it.  My recommendation is:  Don't test in advance, just run it, and catch the exception if things fail.  This does not pollute stdout or stderr in any way, and it will lead to cleaner code and less overhead.</span>
<span class="comment-copy">call doesn't throw an exception when the program doesn't exist, instead the call returns non-zero</span>
<span class="comment-copy">This would leave the subprocess running indefinitely if it fills the pipe buffers of either stdout or stderr.  If you want to run the process <i>at all</i> just to check if it exists, you should use open <code>os.devnull</code> and use it as stdout and stderr.</span>
<span class="comment-copy">not likely to happen but you are right, thanks.</span>
<span class="comment-copy">Many tools output usage information when called without parameters, which could easily fill the pipe buffers.  I was wrong with my initial comment anyway â€“ I missed the call to <code>comunnicate()</code>, which was beyond the right margin of the code box, and I did not scroll far enough to the right.  The method <code>Popen.communicate()</code> takes care of avoiding any deadlocks.</span>
<span class="comment-copy">Make sure to open /dev/null for <i>writing</i> ie: <code>open(os.devnull, "w")</code></span>
<span class="comment-copy">Also just a FYI for people using Python 3.3 and later, you can use <code>subprocess.DEVNULL</code> rather than <code>open(os.devnull)</code>.</span>
<span class="comment-copy"><code>distutils.spawn</code> works well in Linux and Mac OS X. But in the latter one, if you make a <code>app</code>, and you double click to execute,  <code>distutils.spawn</code> always returns <code>None</code>.</span>
<span class="comment-copy">Wouldn't this try to run a program named <code>"which wget"</code>, i.e. with a space in the filename?</span>
<span class="comment-copy">@SvenMarnach, right! I got the syntax all wrong :( oh dear.</span>
<span class="comment-copy">This should be: <code>subprocess.call(['which', 'wget'])</code></span>
<span class="comment-copy">@nbubis, thank you! i updated my answer to reflect this.</span>
<span class="comment-copy">Sadly, this solution does not work for Windows platform</span>
<span class="comment-copy">Sadly, this solution does not work for Windows platform</span>
<span class="comment-copy">@GuillaumeJacquenot Thanks for telling me that, I don't have Windows platform to test.</span>
<span class="comment-copy">This is not platform-independent:  If you really want to replicate OS functionality, you should at least use <code>os.path.join()</code> and <code>os.pathsep</code>.</span>
<span class="comment-copy">(I also edited in <code>os.pathsep</code> â€“ on Windows, <code>PATH</code> is semicolon-delimited.)</span>
<span class="comment-copy">good catch, did my edit overwrite your pathsep?</span>
<span class="comment-copy">I like your function, but for programs that runs in interactive mode it does not work very well. Try for instance <code>nslookup</code>.</span>
