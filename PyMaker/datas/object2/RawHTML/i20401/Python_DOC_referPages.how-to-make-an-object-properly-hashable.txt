<div class="post-text" itemprop="text">
<p>Here is my code:</p>
<pre><code>class Hero:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return self.name + str(self.age)

    def __hash__(self):
        print(hash(str(self)))
        return hash(str(self))

heroes = set()

heroes.add(Hero('Zina Portnova', 16)) # gets hash -8926039986155829407
print(len(heroes)) # gets 1

heroes.add(Hero('Lara Miheenko', 17)) # gets hash -2822451113328084695
print(len(heroes)) # gets 2

heroes.add(Hero('Zina Portnova', 16)) # gets hash -8926039986155829407
print(len(heroes)) # gets 3! WHY?
</code></pre>
<p>Why is this happening?<br/>
The 1st and the 3rd object have same content and same hash but <code>len()</code> tells about 3 unique objects?</p>
</div>
<div class="post-text" itemprop="text">
<p>You also need to define <code>__eq__()</code> in a compatible way with <a href="http://docs.python.org/reference/datamodel.html#object.__hash__" rel="noreferrer"><code>__hash__()</code></a> – otherwise, equality will be based on object identity.</p>
<p>On Python 2, it is recommended you also define <code>__ne__</code> to make <code>!=</code> consistent with <code>==</code>. On Python 3, the default <code>__ne__</code> implementation will delegate to <code>__eq__</code> for you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here  is the the entire code :</p>
<pre><code>class Hero:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return self.name + str(self.age)

    def __hash__(self):
        print(hash(str(self)))
        return hash(str(self))

    def __eq__(self,other):
        return self.name == other.name and self.age== other.age



heroes = set()
heroes.add(Hero('Zina Portnova', 16)) # gets hash -8926039986155829407
print(len(heroes)) # gets 1

heroes.add(Hero('Lara Miheenko', 17)) # gets hash -2822451113328084695
print(len(heroes)) # gets 2

heroes.add(Hero('Zina Portnova', 16)) # gets hash -8926039986155829407
print(len(heroes)) # gets 2 
</code></pre>
<p>The function recognises the <code>__eq__</code> and as such the len is 2.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="noreferrer">The Python documentation</a> might be helpful:</p>
<blockquote>
<p>If a class does not define a <code>__cmp__()</code> or <code>__eq__()</code> method it should not define a <code>__hash__()</code> operation either;</p>
</blockquote>
</div>
<span class="comment-copy">Not sure, but your probably need <code>__eq__</code> or <code>__cmp__</code>: <a href="http://docs.python.org/glossary.html#term-hashable" rel="nofollow noreferrer">docs.python.org/glossary.html#term-hashable</a></span>
<span class="comment-copy">That aside, this isn’t the best hash function (because you’re not hashing a general string, one of the string components has much lower entropy because it’s known to consist of digits). For a trivial but pretty effective fix, take the hash values of the objects separately and xor them. For more magic, add them scaled by a prime number constant.</span>
<span class="comment-copy">@KonradRudolph: There's an implied assumption in your comment – specifically that a "good" hash is needed for the set to perform well.  This is not the case with Python's <code>set</code> implementation; see <a href="http://hg.python.org/cpython/file/26e2ee402a0b/Objects/dictobject.c#l113" rel="nofollow noreferrer">this comment from the Python sources</a> for further explanations.</span>
<span class="comment-copy">@Sven I somewhat disagree. First, this is a CPython implementation detail, not guaranteed by Python. Second, this still assumes high entropy in the lower bits (<i>and</i> to some extent later in the higher bits, for collision). You still need good randomness, only not over the whole number range. Third, the comment, while detailed, is somewhat murky on the theory side. I’m not very confident in this far-from-rigorous analysis. I want a rigorous, peer-reviewed study on that, not some hand-waving.</span>
<span class="comment-copy">@KonradRudolph: The hash function should actually be implemented as <code>hash((self.name, self.age))</code>, deferring the details to the tuple hash algorithm of the Python implementation, which is hopefully optimised to work well with the <code>set</code> and <code>dict</code> implementations.  And I agree that the linked comment is not a rigorous analysis. I find it interesting anyway; extensive and thorough benchmarking, as has been <a href="http://hg.python.org/cpython/file/26e2ee402a0b/Objects/dictnotes.txt" rel="nofollow noreferrer">performed for the CPython <code>dict</code> implementation</a>, might lead to better performance in practice than a rigorous analysis.</span>
<span class="comment-copy">Indeed, after checking if the hashes are equal, the <code>dict</code>/<code>set</code> must also check for actual equality in case of hash collision.</span>
<span class="comment-copy">@user2357112 Definig <code>__ne__</code> not required to make a type hashable, right?  It may be good idea to define it, since otherwise <code>!=</code> will have rather weird semantics, but if all you want to do is using the type in a set or dictionary, you don't really need it.</span>
<span class="comment-copy">@SvenMarnach: Technically, sets and dicts don't use <code>!=</code> anywhere, but actually relying on that is a recipe for nasty bugs. Even if sets don't use <code>!=</code>, someone's probably gonna. You can reword it if you want, but I think the answer should definitely mention <code>__ne__</code>; the spirit of the question definitely seems more "how do I do things <i>right</i>" than "what is the bare minimum needed to get this code snippet to produce the expected output".</span>
<span class="comment-copy">@user2357112 I'm not sure I fully agree; it really depends on the scope of what you are working on.  And the fact that set and dict don't use <code>!=</code> isn't an accident, but documented and guaranteed behaviour.  The Python 2 glossary also defines hashable as basically "having <code>__hash__ and (__eq__ or __cmp__)</code>" without any mention of <code>__ne__</code>.  Anyway, I agree that it never hurts to define it, and slightly modified the wording.</span>
<span class="comment-copy">In order for a <code>set.add(x)</code> to include <code>x</code> into the set, where <code>x</code> is a user-defined type, both <code>hash(x)</code> must return a unique integer (i.e., one that is not already seen when hash() is called on each of the objects already in  a set) AND <code>__eq__(self,x)</code> must be false. In other words, if two instances hash to the same value OR is equal by <code>__eq__</code> definition, then it is not included from the set when you call <code>set.add(x)</code>. Is this correct?</span>
