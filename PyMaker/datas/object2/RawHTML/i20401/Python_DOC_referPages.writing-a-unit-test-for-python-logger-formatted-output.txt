<div class="post-text" itemprop="text">
<p>How could you write a unittest in Python that would test that the output from a logger is indeed in the format you expect (i.e. set through a call to logging.basicConfig())? I'm thinking along the lines of a custom StreamHandler and use of the 're' library but it doesn't look like LogRecord passed to StreamHandler.emit() can give me the string that will be output.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the documentation (<a href="http://packages.python.org/testfixtures/logging.html" rel="nofollow">http://packages.python.org/testfixtures/logging.html</a>):</p>
<blockquote>
<p>To help with this, TestFixtures allows you to easily capture the output of calls to Pythonâ€™s logging framework and make sure they were as expected. There are three different techniques, depending on the type of test you are writing.</p>
<ol>
<li><a href="http://packages.python.org/testfixtures/logging.html#the-context-manager" rel="nofollow">The context manager</a></li>
<li><a href="http://packages.python.org/testfixtures/logging.html#the-decorator" rel="nofollow">The decorator</a></li>
<li><a href="http://packages.python.org/testfixtures/logging.html#manual-usage" rel="nofollow">The manual usage</a></li>
</ol>
</blockquote>
<p>The examples are included in the documentation. The shortened version is below.</p>
<h2>The context manager</h2>
<pre><code>&gt;&gt;&gt; import logging
&gt;&gt;&gt; from testfixtures import LogCapture
&gt;&gt;&gt; with LogCapture() as l:
...     logger = logging.getLogger()
...     logger.info('a message')
...     logger.error('an error')
</code></pre>
<p>And after that you can check the logs for equality:</p>
<pre><code>&gt;&gt;&gt; l.check(
...     ('root', 'INFO', 'a message'),
...     ('root', 'ERROR', 'another error'),
...     )
Traceback (most recent call last):
 ...
AssertionError: Sequence not as expected:

same:
(('root', 'INFO', 'a message'),)

first:
(('root', 'ERROR', 'another error'),)

second:
(('root', 'ERROR', 'an error'),)
</code></pre>
<h2>The decorator</h2>
<p>Similar to the previous, but applied to specific function:</p>
<pre><code>from testfixtures import log_capture

@log_capture()
def test_function(l):
    logger = logging.getLogger()
    logger.info('a message')
    logger.error('an error')

    l.check(
        ('root', 'INFO', 'a message'),
        ('root', 'ERROR', 'an error'),
        )
</code></pre>
<h2>Manual usage</h2>
<pre><code>&gt;&gt;&gt; from testfixtures import LogCapture
&gt;&gt;&gt; l = LogCapture()
</code></pre>
<p>After which you can also "check" the logs:</p>
<pre><code>&gt;&gt;&gt; l.check(('root', 'INFO', 'a message'))
&lt;...&gt;
</code></pre>
<p><strong>EDIT</strong>: To access specific logs and analyze them in a custom way, you can just iterate through <code>l.records</code> (where <code>l</code> is just <code>LogCapture</code>'s instance) and access some properties of each of them (eg. <code>msg</code> contains message sent to logger, <code>levelname</code> contains codename of the level, and there are plenty other properties).</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use only standard libraries, this solution could help. It is based on <code>unittest</code> and <code>mock</code> libraries.</p>
<p>For example if you have <code>script.py</code> with following content.</p>
<pre><code>logger = logging.getLogger(__name__)

def log_something():
    logger.debug("something")
</code></pre>
<p>You could write a test for it that will look like this.</p>
<pre><code>import unittest

import mock

from script import log_something

@mock.patch("script.logger")
def test_function(mock_log):
    log_something()

    assertTrue(
        "something" in mock_log.debug.call_args_list[0][0][0]
    )
</code></pre>
<p>This is using the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.call_args_list" rel="nofollow noreferrer">call_args_list</a> from the <code>mock</code> library.</p>
<p><strong>To explain <code>[0][0][0]</code> at the end</strong>:</p>
<ol>
<li><p>The <code>call_args_list</code> is a list of <code>call</code> objects, which looks like this <code>[call("something")]</code>. So the first <code>[0]</code> is returning the first <code>call</code> object.</p></li>
<li><p>The second <code>[0]</code> returns the tuple of arguments for the <code>call</code> object. It will look like this <code>("something",)</code>.</p></li>
<li><p>Third <code>[0]</code> returns the first argument that was given to <code>logger</code> in our case. So the final string will be only <code>"something"</code>.</p></li>
</ol>
</div>
