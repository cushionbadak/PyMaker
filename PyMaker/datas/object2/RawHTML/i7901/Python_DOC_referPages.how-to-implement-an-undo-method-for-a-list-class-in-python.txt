<div class="post-text" itemprop="text">
<p>Im kinda new with python and I got a task to create a class "UndoList" (type list) with an undo()-method. This method should undo typical list-operations like, append, insert, remove...</p>
<pre><code>&gt;&gt;&gt; ul = UndoList([1,2,3])
&gt;&gt;&gt; ul.append(4), print(ul), undo(ul), print(ul)
[1,2,3,4]
[1,2,3]
&gt;&gt;&gt; ul.remove(3), print(ul), undo(ul), print(ul)
[1,2]
[1,2,3]
...
</code></pre>
<p>This undo()-method should only undo one operation (as u can see in the example). My teacher gave me the hint, to save the value of the list in the instance before every operation.</p>
<p>This is my class:</p>
<pre><code>class UndoList(list):

   def __init__(self, lis):
       list.__init__(self, lis)
       self.lis = []

   def __append__(self, lis):
       list.__add__(self, lis)
       return lis

   def undo(self):
       return self

a1 = UndoList([1,2,3])
print(a1), a1.append(4), print(a1)   #[1,2,3] [1,2,3,4]
a1.undo(), print(a1)                 #[1,2,3,4]
</code></pre>
<p>So now my question: how can i create an instance in my class to save my actual list before I do any operation? And is it possible to just retrun this instance in my undo-method?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's some code that will get you started. Really though, it's best to avoid sub-classing Python's standard types because to do it properly you generally need to override <em>every</em> method, which can be rather tedious and error-prone.</p>
<p>Note that the <code>append</code> method is called <code>append</code>, not<code>__append__</code>. :) And that the methods which mutate a list in-place return <code>None</code>, not the list.</p>
<pre><code>from copy import deepcopy

class UndoList(list):
    def __init__(self, *args):
        super().__init__(*args)
        self.old = []

    def append(self, item):
        self.old = deepcopy(self[:])
        super().append(item)

    def extend(self, items):
        self.old = deepcopy(self[:])
        super().extend(items)

    def undo(self):
        temp = deepcopy(self[:])
        self[:] = self.old
        self.old = temp


a = UndoList([1, 2, 3])
print(a)

a.append(4)
print(a)
a.undo()
print(a)
a.undo()
print(a)

a.extend([5, 6])
print(a)
a.undo()
print(a)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[1, 2, 3]
[1, 2, 3, 4]
[1, 2, 3]
[1, 2, 3, 4]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4]
</code></pre>
<p>We use <code>def __init__(self, *args)</code> so that we can call <code>UndoList()</code> with no args to get an empty UndoList.</p>
<p>As 9000 mentions in the comments, you probably don't need <code>deepcopy</code> here. It consumes extra RAM by recursively copying every list item (except for immutable items), and it's slow. Using <code>deepcopy</code> does make <code>UndoList</code> robust. OTOH, it also means that items restored from <code>.old</code> are copies of the original items, and in some cases that is undesirable - if other objects refer to those items then the back-up process breaks that connection. </p>
<p>If you want to experiment with this, simply change the code that backs up the list to</p>
<pre><code>self.old = self[:]
</code></pre>
<p>and the <code>undo</code> method becomes</p>
<pre><code>def undo(self):
    self[:], self.old = self.old, self[:]
</code></pre>
<hr/>
<p>The sane way to do this is to build a new class using <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">Abstract Base Classes</a> rather than sub-classing <code>list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's simple. but tedious: you add a <code>history</code> attribute to the list object.  This is a stack of previous variable states.  Every change operation needs to push its current state onto the object's <code>history</code> before the change.  The <code>undo</code> operation simply pops the most recent one.</p>
<p>You've already noted that you'll have to redefine all of the change operations (such as the <code>__append__</code> in your class).</p>
</div>
<span class="comment-copy">So, do you want us to solve your class excercise for you???</span>
<span class="comment-copy">you should implement some kind of <code>history</code> attribute.</span>
<span class="comment-copy">Do you mean that you only need to support a single level of undo?</span>
<span class="comment-copy">@PM2Ring thats right. I just need to undo a single operation</span>
<span class="comment-copy">This is doubtlessly a working solution, but a <i>very</i> memory-intensive one. Chances are the OP did not ask to shield mutable data in the list from changes.</span>
<span class="comment-copy">This works great! Thanks a lot, buddy. I will now try to build this using the abstract base classes. Thanks a lot!</span>
<span class="comment-copy">@9000 Perhaps <code>deepcopy</code> is overkill, and I agree that it's not <i>really</i> necessary for <code>append</code> or <code>extend</code>, but it is necessary for <code>remove</code>, since the removed items could be mutated by other code before an <code>undo</code> call, and then the <code>undo</code> wouldn't restore the list to its previous state. OTOH, having list items mutated by other code is always a possibility when working with lists...</span>
<span class="comment-copy">@9000 I've updated my answer in response to your comment.</span>
