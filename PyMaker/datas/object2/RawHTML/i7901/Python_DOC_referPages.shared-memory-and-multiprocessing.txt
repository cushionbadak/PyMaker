<div class="post-text" itemprop="text">
<p>From <a href="https://stackoverflow.com/q/10721915">this question</a> and its answers, I <em>think</em> I understand why this python code:</p>
<pre><code>big_list = [
    {j: 0 for j in range(200000)}
    for i in range(60)
]

def worker():
    for dic in big_list:
        for key in dic:
            pass
        print "."
        time.sleep(0.2)

w = multiprocessing.Process(target=worker)
w.start()

time.sleep(3600)
</code></pre>
<p>keeps using more and more memory during its execution: it's because the child process updates reference count to a shared-memory object in the loop, triggering the "copy-on-write" mecanism (I can watch the free memory diminushing via <code>cat /proc/meminfo | grep MemFree</code>).</p>
<p>What I don't understand, however, is why the same thing happens if the iteration takes place in the parent rather than in the child:</p>
<pre><code>def worker():
    time.sleep(3600)

w = multiprocessing.Process(target=worker)
w.start()

for dic in big_list:
    for key in dic:
        pass
    print "."
    time.sleep(0.2)
</code></pre>
<p>The child don't even needs to know the <em>existence</em> of <code>big_list</code>.</p>
<p>In this small example I can solve the problem by putting <code>del big_list</code> in the child function, but sometimes variables references are not accessible like this one, so things get complicated.</p>
<p>Why is this mecanism happening and how can I avoid it properly?</p>
</div>
<div class="post-text" itemprop="text">
<p>After a <code>fork()</code>, both parent and child "see" the same address space.  The first time <em>either</em> changes the memory at a common address, the copy-on-write (COW) mechanism has to clone the page containing that address.  So, for purposes of creating COW pages, it doesn't matter whether the mutations occur in the child or in the parent.</p>
<p>In your second code snippet, you left out the most important part:  exactly where <code>big_list</code> was created.  Since you said you can get away with <code>del big_list</code> in the child, <code>big_list</code> probably existed before you forked the worker process.  If so, then - as above - it doesn't really matter to your symptom whether <code>big_list</code> is modified in the parent or the child.</p>
<p>To avoid this, create <code>big_list</code> <em>after</em> creating your child process.  Then the address space it lives in won't be shared.  Or, in Python 3.4 or later, use <code>multiprocessing.set_start_method('spawn')</code>.  Then <code>fork()</code> won't be used to create child processes, and no address space is shared at all (which is always the case on Windows, which doesn't have <code>fork()</code>).</p>
</div>
<span class="comment-copy">Your results and question may be OS (Unix/Linux/OSX) dependent. They certainly aren't coded properly for Windows (no <code>if __name__ == '__main__':</code>, see <a href="https://docs.python.org/3/library/multiprocessing.html#the-spawn-and-forkserver-start-methods" rel="nofollow noreferrer"><b>Safe importing of main module</b></a> in the docs).</span>
<span class="comment-copy">Thank you for the explanation ! I tried to use <a href="https://github.com/celery/billiard/" rel="nofollow noreferrer">billiard</a> to use <code>set_start_method('spawn')</code> in python2 but using billiard.Queue made the communication between processes extremely slow, thus useless for my use case. I ended up doing what you suggested : fork earlier (even if in my case it may be something like one hour before the real usage).</span>
