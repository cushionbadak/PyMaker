<div class="post-text" itemprop="text">
<p>I'm new to writing unit tests, this question might be silly but I'm posting this after a lot of research.</p>
<p>I'm trying to write a unit test for a function in the centralized/views.py which is being used in a lot of other views.</p>
<p>The function looks like this</p>
<pre><code>def make_job(self, request, *args, **kwargs):
   .....
   .....
   return Response(data, status=status.HTTP_200_OK)
</code></pre>
<p>I need help in mocking the request in the unit test, since this function is called by other views I'm not sure how to test this function independently without relying on the url path.</p>
<p>What is the approach to mock this request?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use mock.patch as a function decorator, or even better as a contextmanager:</p>
<pre><code>with mock.patch('path.to.your.app.Class.method', new=new_function_with_return):
    # do something here
    pass
</code></pre>
<p><a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#patch</a></p>
<p>[edit] sorry, I was reading a little too fast. You can create fake request objects via Django's RequestFactory:</p>
<p><a href="https://docs.djangoproject.com/en/1.11/topics/testing/advanced/#the-request-factory" rel="nofollow noreferrer">https://docs.djangoproject.com/en/1.11/topics/testing/advanced/#the-request-factory</a></p>
</div>
<span class="comment-copy">Hi @odi - Thanks for your reply, I have tried request factory but that requires the path of the url and since multiple views uses this function I'm not sure which request url should be used. So I was wondering if there is a way to test independently</span>
<span class="comment-copy">well, in testing theorie, you should test all url path's to reach 100% coverage and branch converage ;) Having only integration tests for some functions is not ideal, but sometimes the only economic way to get a decent coverage. Speaking from experience: having some integregration tests in a large legacy code basis is an couple order of magnitude higher on the crazy-to-sane scale.</span>
