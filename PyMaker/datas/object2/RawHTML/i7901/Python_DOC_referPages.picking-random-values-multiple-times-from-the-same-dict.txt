<div class="post-text" itemprop="text">
<p>I'm trying to pick a random value from a dict. and then pick a second value from the same dict. guaranteeing that it is different. </p>
<pre><code>def pick_value():
    value, attribute = random.choice(list(my_dict.items()))
    return(value, attribute)
</code></pre>
<p>If I call the function it works, however there is no guarantee that the second time I call it the value will be different than the first so I tried the following.</p>
<pre><code>my_value_list = []

val1, attr1 = pick_value()
my_value_list.append(val1)

val2, attr2 = pick_value()
if val2 in my_value_list:
    val2, attr2 = pick_value()
</code></pre>
<p>I still get matching values occasionally. I tried replacing the <code>if val2 in</code> statement with <code>while val2 in</code> and still no luck. Am I misunderstanding something simple?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need exactly two values (or any fixed number you know in advance), use <a href="https://docs.python.org/3/library/random.html#random.sample" rel="nofollow noreferrer"><code>random.sample()</code></a>. That's what it's for: Sampling "without replacement", i.e. once you've picked an element from the list, it is no longer available to be picked again.</p>
<pre><code>samples = random.sample(list(mydict.items()), 2)
attr1, val1 = samples[0]
attr2, val2 = samples[1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As <code>alexis</code> has suggested, <code>random.sample()</code> is the right tool for this job, but for the sake of completeness, if you need to pick up random fields in a iterative/lazy fashion, you can do it yourself by:</p>
<pre><code>def pick_random_destructive(data):
    key = random.choice(data.keys()) if data else None
    return key, data.pop(key, None)
</code></pre>
<p>However, that WILL modify the <code>dict</code> you pass to it. If you want a non-modifying iterative method you can create a generator like:</p>
<pre><code>def pick_random_nondestructive(data):
    keys = random.shuffle(data.keys())
    while keys:
        key = keys.pop()
        yield key, data[key]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>random.choice</code> can achieve this but you'll be needing to retain state information after each call to the function as such when <code>random.choice</code> returns the previous random value, you ignore the value and call it again. Popping the value out of the sequence is another alternative:</p>
<pre><code>def pick_value():
    L = list(my_dict.items())

    if hasattr(pick_value, 'prev'):
        for _ in range(100):
            res = random.choice(L)
            if res != pick_value.prev: 
                pick_value.prev = res
                return res
    else:
        res = random.choice(L)
        pick_value.prev = res
        return res
</code></pre>
<p>The first time you call <code>pick_value</code> there's no previous value, this is what the outer <code>if</code> statement is for, it checks if the there's a previous value and compare it against the newly chosen random value. This function  returns <code>None</code> when <code>random.choice</code> fails to return a random value that's not equal to the previous one after 100 calls to <code>random.choice</code>. </p>
<p>*Of course, this is just a variation on a theme, other users provided simpler alternatives, so you don't necessarily need to wrap <code>random.choice</code> with the above logic.  </p>
</div>
<div class="post-text" itemprop="text">
<p>This option is useful if you are already using numpy library:</p>
<p>Consider using random.choice from numpy:</p>
<pre><code>import numpy as np

my_dict = {"a" : 1, "b": 2, "c": 3, "d" : 4}

#first, take two random key index from 0 to length
twoRandom = np.random.choice(list(my_dict.keys()),2,replace=False)

#then take the value of the key at index in the list
key1 = twoRandom[0]
key2 = twoRandom[1]

#finally, get the value
value1 = my_dict.get(key1)
value2 = my_dict.get(key2)
</code></pre>
</div>
<span class="comment-copy">Do you need that dict for anything else after this operation?</span>
<span class="comment-copy">Any reason you're not using <code>random.sample()</code>?</span>
<span class="comment-copy">No, after I get my random values out it doesn't matter to me anymore.</span>
<span class="comment-copy">he's probably going to suggest popping the value you grabbed to ensure uniqueness</span>
<span class="comment-copy">That should do the work jsut perfect :D, thanks for sharing, great answer, short and sweet</span>
<span class="comment-copy">Your code samples with replacement, which is exactly what the OP wants to avoid. (And why are you sampling the indexes, and not the keys directly?)</span>
<span class="comment-copy">Using a behemoth like NumPy to do simple sampling sounds awfully wasteful.</span>
<span class="comment-copy">@alexis what is exactly the OP wants to avoid that I'm doing? I don't get you... my bad sorry, could you explain? And I'm sampling the index because I didn't know how to sample the values directly</span>
<span class="comment-copy">@zwer using something like that solves your problem isn't bad, why reinvent the wheel? And how much is the cost to do an import?</span>
<span class="comment-copy">The OP does not want repetitions in the results. To sample the values... just sample them :-) But actually the <code>len</code> you stuck in there will break your code, have you actually tried it?</span>
