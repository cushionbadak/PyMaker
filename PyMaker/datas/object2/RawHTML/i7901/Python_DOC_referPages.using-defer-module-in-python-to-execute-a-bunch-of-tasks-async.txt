<div class="post-text" itemprop="text">
<p>I saw this <a href="https://stackoverflow.com/questions/19302530/python-generator-send-function-purpose">page</a> suggesting the usage of defer module to execute a series of tasks asynchronously.</p>
<p>I want to use it for my Project:</p>
<ol>
<li>Calculate the median of each list of numbers I have (Got a list, containing lists of numbers)</li>
<li>Get the minimum and maximum medians, of all medians.</li>
</ol>
<p>But for the matter of fact, I did not quite understand how to use it.</p>
<p>I would love some explanation about defer in python, and whether you think it is the appropriate way achieving my goal (considering the Global Interpreter Lock).</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>No, using asynchronous programming (<em>cooperative routines</em>, aka coroutines), will not help your use case. Async is great for <em>I/O intensive workloads</em>, or anything else that has to wait for slower, external events to fire.</p>
<p>Coroutines work because they give up control (<em>yield</em>) to other coroutines whenever they have to wait for something (usually for some I/O to take place). If they do this frequently, the event loop can alternate between <em>loads</em> of coroutines, often far more than what threading could achieve, with a simpler programming model (no need to lock data structures all the time).</p>
<p>Your use-case is not waiting for I/O however; you have a <em>computationally heavy workload</em>. Such workloads do not have obvious places to yield, and because they don't need wait for external events, there is no reason to do so anyway. For such a workload, use a <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">multiprocessing model</a> to do work in parallel on different CPU cores.</p>
<p>Asynchronous programming does not defeat the GIL either, but does give the event loop the opportunity to move the <em>waiting for I/O</em> parts to C code that can unlock the GIL and handle all that I/O processing in parallel while other Python code (in a different coroutine) can execute.</p>
<p>See <a href="https://www.youtube.com/watch?v=l4Nn-y9ktd4" rel="nofollow noreferrer">this talk by my colleague Łukasz Langa at PyCON 2016</a> for a good introduction to async programming.</p>
</div>
<span class="comment-copy">The answer talks about Twisted there; you want to watch  my colleague <a href="https://www.youtube.com/watch?v=l4Nn-y9ktd4" rel="nofollow noreferrer">Łukasz Langa explain asynchronous programming at Pycon 2016</a> and use Python 3.5 or newer to get the benefit of using the more readable <code>async</code>/<code>await</code> syntax to achieve the same.</span>
<span class="comment-copy">That said, using coroutines gives you better latency control in I/O heavy applications. CPU-heavy applications (like calculating stats on numbers), will <b>not</b> benefit. Use multiprocessing instead.</span>
<span class="comment-copy">Thank you for your comment</span>
<span class="comment-copy">Thank you for your comment</span>
