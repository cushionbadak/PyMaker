<div class="post-text" itemprop="text">
<p>I want to use the event loop to monitor any inserting data into my asyncio.Queue(you can find its source code here <a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/queues.py" rel="nofollow noreferrer">https://github.com/python/cpython/blob/3.6/Lib/asyncio/queues.py</a>), but I run into some problems. Here is the following code:</p>
<pre><code>import asyncio
import threading

async def recv(q):
    while True:
        msg = await q.get()
        print(msg)

async def checking_task():
    while True:
        await asyncio.sleep(0.1)

def loop_in_thread(loop,q):
    asyncio.set_event_loop(loop)
    asyncio.ensure_future(recv(q))
    asyncio.ensure_future(insert(q))
    # asyncio.ensure_future(checking_task()) comment this out, and it will work as intended
    loop.run_forever()

async def insert(q):
    print('invoked')
    await q.put('hello')

q = asyncio.Queue() 
loop = asyncio.get_event_loop()
t = threading.Thread(target=loop_in_thread, args=(loop, q,))
t.start()
</code></pre>
<p>The program has started and we can see the following result</p>
<pre><code>invoked
hello
-&gt; print(asyncio.Task.all_tasks())
{&lt;Task pending coro=&lt;recv() running at C:/Users/costa/untitled3.py:39&gt;
wait_for=&lt;Future pending cb=[&lt;TaskWakeupMethWrapper object at 0x000001E215DCFAC8&gt;()]&gt;&gt;}
</code></pre>
<p>But now if we manually add data into <code>q</code> by using <code>q.put_nowait('test')</code>, we would get the following result:</p>
<pre><code>q.put_nowait('test') # a non-async way to add data into queue
-&gt; print(asyncio.Task.all_tasks())
{&lt;Task pending coro=&lt;recv() running at C:/Users/costa/untitled3.py:39&gt;
 wait_for=&lt;Future finished result=None&gt;&gt;}
</code></pre>
<p>As you can see, the future is already finished, yet we still haven't print out the newly added string <code>'test'</code>. In other words, <code>msg = await q.get()</code> is still waiting even though the Future related to q.get() is done and there are no other tasks running. This confuses me because in the official documentation(<a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio-task.html</a>), it says</p>
<blockquote>
<p>result = await future or result = yield from future – suspends the coroutine until the future is done, then returns the future’s result</p>
</blockquote>
<p>It seemed that even though the Future is done, we still need some sort of <code>await</code> in other async function to make the event loop keep processing tasks.</p>
<p>I found a workaround to this problem, which is adding a <code>checking_task()</code>, and also add that coroutine into the event loop; then it will work as intended.</p>
<p>But adding a checking_task() coroutine is very costly for CPU since it just runs a while loop. I am wondering if there is some manual way for us to trigger that <code>await</code> event without using a async function. For example, something magical like</p>
<pre><code>q.put_nowait('test')
loop.ok_you_can_start_running_other_pending_tasks()
</code></pre>
<p>Helps will be greatly appreciated! Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>So I ended up with using</p>
<pre><code>loop.call_soon_threadsafe(q.put_nowait, 'test')
</code></pre>
<p>and it will work as intended. After figure this out, I searched some information about . It turned out this post (<a href="https://stackoverflow.com/questions/37841222/scheduling-an-asyncio-coroutine-from-another-thread/37842263#comment63144818_37841222">Scheduling an asyncio coroutine from another thread</a>) has the same problem. And @kfx's answer would also work, which is</p>
<pre><code>loop.call_soon_threadsafe(loop.create_task, q.put('test'))
</code></pre>
<p>Notice asyncio.Queue.put() is a coroutine but asyncio.Queue.put_nowait() is a normal function. </p>
</div>
