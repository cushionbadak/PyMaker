<div class="post-text" itemprop="text">
<p>My code:</p>
<pre><code> class World:
    def __init__(self, _map, pos):
        self.orig_map = _map
        self.map = self.orig_map[:]
        self.orig_pos = pos
        self.pos = list(self.orig_pos)
    def reset(self):
        self.map = self.orig_map[:]
        self.pos = list(self.orig_pos)
    def left(self):
        if self.pos[1]&gt;0:
            self.pos[1]-=1
    def right(self):
        if not self.pos[1]+1&gt;=len(self.map[0]):
            self.pos[1]+=1
    def up(self):
        if self.pos[0]&gt;0:
            self.pos[0]-=1
    def down(self):
        if not self.pos[0]+1&gt;=len(self.map):
            self.pos[0]+=1
    def eat(self):
        if self.map[self.pos[0]][self.pos[1]]==1:
            self.map[self.pos[0]][self.pos[1]]=0
            return True
</code></pre>
<p>What is supposed to happen:</p>
<pre><code>&gt;&gt;&gt; w=World([[0,0,0],[0,1,0],[0,0,0]],(0,0))
&gt;&gt;&gt; w.right()
&gt;&gt;&gt; w.down()
&gt;&gt;&gt; w.eat()
True
&gt;&gt;&gt; w.reset()
&gt;&gt;&gt; w.map
&gt;&gt;&gt; [[0, 0, 0], [0, 1, 0], [0, 0, 0]]
</code></pre>
<p>What happens:</p>
<pre><code>&gt;&gt;&gt; w=World([[0,0,0],[0,1,0],[0,0,0]],(0,0))
&gt;&gt;&gt; w.right()
&gt;&gt;&gt; w.down()
&gt;&gt;&gt; w.eat()
True
&gt;&gt;&gt; w.reset()
&gt;&gt;&gt; w.map
&gt;&gt;&gt; [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
</code></pre>
<p>Where it probably goes wrong: <code>self.map = self.orig_map[:]</code></p>
<p>The above would have worked (tried and tested) for a single list, however, it doesn't seem to work for nested lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>By saying <code>self.map = self.orig_map[:]</code> you are indeed making a copy of <code>self.orig_map</code>. However, this is a <em>shallow</em> copy, and the elements within <code>self.map</code> will still be the same objects as the elements within <code>self.orig_map</code>.</p>
<p>What you need to do instead is make <code>self.map</code> a <em>deep</em> copy of <code>self.orig_map</code> in your <code>__init__</code>. E.g.</p>
<pre><code>import copy
...
    self.map = copy.deepcopy(self.orig_map)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should use <code>deepcopy</code></p>
<pre><code>import copy

cop2 = copy.deepcopy(origin) 
</code></pre>
<p>It will recursively copy your object.</p>
</div>
<span class="comment-copy"><code>deep_copy</code> it. <a href="http://www.python-course.eu/deep_copy.php" rel="nofollow noreferrer">See this</a></span>
<span class="comment-copy">Did you mean <code>w.orig_map</code> in the last step? You could in this case use the <code>copy</code> module's <a href="https://docs.python.org/3/library/copy.html#copy.deepcopy" rel="nofollow noreferrer"><code>deepcopy</code></a> function.</span>
<span class="comment-copy">@IljaEverilä No, I meant <code>w.map</code>. However, at that step, they should be equal (value wise) but be different objects.</span>
<span class="comment-copy">Right, missed the <code>reset()</code> call.</span>
<span class="comment-copy">Depending on exactly what <code>self.orig_map</code> contains, <code>deepcopy</code> may not work <a href="https://stackoverflow.com/questions/1601269/how-to-make-a-completely-unshared-copy-of-a-complicated-list-deep-copy-is-not" title="how to make a completely unshared copy of a complicated list deep copy is not">stackoverflow.com/questions/1601269/…</a></span>
