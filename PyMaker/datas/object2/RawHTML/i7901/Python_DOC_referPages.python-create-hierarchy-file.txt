<div class="post-text" itemprop="text">
<p>Given the following unordered tab delimited file:</p>
<pre><code>Asia    Srilanka
Srilanka    Colombo
Continents  Europe
India   Mumbai
India   Pune
Continents  Asia
Earth   Continents
Asia    India
</code></pre>
<p>The goal is to generate the following output (tab delimited):</p>
<pre><code>Earth   Continents  Asia    India   Mumbai
Earth   Continents  Asia    India   Pune
Earth   Continents  Asia    Srilanka    Colombo
Earth   Continents  Europe
</code></pre>
<p>I have created the following script to achieve the goal:</p>
<pre><code>root={} # this hash will finally contain the ROOT member from which all the nodes emanate
link={} # this is to hold the grouping of immediate children 
for line in f:
    line=line.rstrip('\r\n')
    line=line.strip()
    cols=list(line.split('\t'))
    parent=cols[0]
    child=cols[1]
    if not parent in link:
        root[parent]=1
    if child in root:
        del root[child]
    if not child in link:
        link[child]={}
    if not parent in link:
        link[parent]={}
    link[parent][child]=1
</code></pre>
<p>Now I intend to print the desired output using two dict created earlier (root and link). I am not sure how to go about doing this in python. But I know that we could write following in perl to achieve the result:</p>
<pre><code>print_links($_) for sort keys %root;

sub print_links
{
  my @path = @_;

  my %children = %{$link{$path[-1]}};
  if (%children)
  {
    print_links(@path, $_) for sort keys %children;
  } 
  else 
  {
    say join "\t", @path;
  }
}
</code></pre>
<p>Could you please help me achieve the desired output in python 3.x?</p>
</div>
<div class="post-text" itemprop="text">
<p>I see here next problems:</p>
<ul>
<li>reading relations from file;</li>
<li>building hierarchy from relations.</li>
<li>writing hierarchy to file.</li>
</ul>
<p>Assuming that height of hierarchy tree is less than default <a href="https://docs.python.org/3/library/sys.html#sys.getrecursionlimit" rel="nofollow noreferrer">recursion limit</a> (equals to <code>1000</code> in most cases), let's define utility functions for this separate tasks.</p>
<h2>Utilities</h2>
<ol>
<li><p>Parsing of relations can be done with</p>
<pre><code>def parse_relations(lines):
    relations = {}
    splitted_lines = (line.split() for line in lines)
    for parent, child in splitted_lines:
        relations.setdefault(parent, []).append(child)
    return relations
</code></pre></li>
<li><p>Building hierarchy can be done with</p>
<ul>
<li><p><strong>Python &gt;=3.5</strong></p>
<pre><code>def flatten_hierarchy(relations, parent='Earth'):
    try:
        children = relations[parent]
        for child in children:
            sub_hierarchy = flatten_hierarchy(relations, child)
            for element in sub_hierarchy:
                try:
                    yield (parent, *element)
                except TypeError:
                    # we've tried to unpack `None` value,
                    # it means that no successors left
                    yield (parent, child)
    except KeyError:
        # we've reached end of hierarchy
        yield None
</code></pre></li>
<li><p><strong>Python &lt;3.5</strong>: extended iterable unpacking <a href="https://docs.python.org/3/whatsnew/3.5.html?highlight=unpack#whatsnew-pep-448" rel="nofollow noreferrer">was added with PEP-448</a>, but it can be replaced with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> like</p>
<pre><code>import itertools


def flatten_hierarchy(relations, parent='Earth'):
    try:
        children = relations[parent]
        for child in children:
            sub_hierarchy = flatten_hierarchy(relations, child)
            for element in sub_hierarchy:
                try:
                    yield tuple(itertools.chain([parent], element))
                except TypeError:
                    # we've tried to unpack `None` value,
                    # it means that no successors left
                    yield (parent, child)
    except KeyError:
        # we've reached end of hierarchy
        yield None
</code></pre></li>
</ul></li>
<li><p>Hierarchy export to file can be done with</p>
<pre><code>def write_hierarchy(hierarchy, path, delimiter='\t'):
    with open(path, mode='w') as file:
        for row in hierarchy:
            file.write(delimiter.join(row) + '\n')
</code></pre></li>
</ol>
<h2>Usage</h2>
<p>Assuming that file path is <code>'relations.txt'</code>:</p>
<pre><code>with open('relations.txt') as file:
    relations = parse_relations(file)
</code></pre>
<p>gives us </p>
<pre><code>&gt;&gt;&gt; relations
{'Asia': ['Srilanka', 'India'],
 'Srilanka': ['Colombo'],
 'Continents': ['Europe', 'Asia'],
 'India': ['Mumbai', 'Pune'],
 'Earth': ['Continents']}
</code></pre>
<p>and our hierarchy is</p>
<pre><code>&gt;&gt;&gt; list(flatten_hierarchy(relations))
[('Earth', 'Continents', 'Europe'),
 ('Earth', 'Continents', 'Asia', 'Srilanka', 'Colombo'),
 ('Earth', 'Continents', 'Asia', 'India', 'Mumbai'),
 ('Earth', 'Continents', 'Asia', 'India', 'Pune')]
</code></pre>
<p>finally export it to file called <code>'hierarchy.txt'</code>:</p>
<pre><code>&gt;&gt;&gt; write_hierarchy(sorted(hierarchy), 'hierarchy.txt')
</code></pre>
<p>(we use <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer"><code>sorted</code></a> to get hierarchy like in your desired output file)</p>
<h2>P. S.</h2>
<p>If you are not familiar with <code>Python</code> <a href="https://docs.python.org/3/glossary.html#term-generator" rel="nofollow noreferrer">generators</a> we can define <code>flatten_hierarchy</code> function like</p>
<ul>
<li><p><strong>Python &gt;= 3.5</strong></p>
<pre><code>def flatten_hierarchy(relations, parent='Earth'):
    try:
        children = relations[parent]
    except KeyError:
        # we've reached end of hierarchy
        return None
    result = []
    for child in children:
        sub_hierarchy = flatten_hierarchy(relations, child)
        try:
            for element in sub_hierarchy:
                result.append((parent, *element))
        except TypeError:
            # we've tried to iterate through `None` value,
            # it means that no successors left
            result.append((parent, child))
    return result
</code></pre></li>
<li><p><strong>Python &lt; 3.5</strong></p>
<pre><code>import itertools


def flatten_hierarchy(relations, parent='Earth'):
    try:
        children = relations[parent]
    except KeyError:
        # we've reached end of hierarchy
        return None
    result = []
    for child in children:
        sub_hierarchy = flatten_hierarchy(relations, child)
        try:
            for element in sub_hierarchy:
                result.append(tuple(itertools.chain([parent], element)))
        except TypeError:
            # we've tried to iterate through `None` value,
            # it means that no successors left
            result.append((parent, child))
    return result
</code></pre></li>
</ul>
</div>
<span class="comment-copy">Thanks. I found that this line is giving error: result.append((parent, *element))   SyntaxError: can use starred expression only as assignment target</span>
<span class="comment-copy">Excellent solution. For a python newbie like me, there are lot of things I could pick up and focus from your solution.</span>
