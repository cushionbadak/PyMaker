<div class="post-text" itemprop="text">
<p>Take this code:</p>
<pre><code>import itertools as it
import numpy as np
data = ['a','b','c','d']
dw = np.array([1, 3], dtype=np.int64)
print(list(it.islice(data,dw[0],dw[1],1)))
</code></pre>
<p>On Python 2.7 it prints <code>['b', 'c',]</code> as expected.</p>
<p>On Python 3.6 it throws an exception:</p>
<pre><code>ValueError: Stop argument for islice() must be None or an integer: 0 &lt;= x &lt;= sys.maxsize.
</code></pre>
<p>The same goes for <code>np.int32</code>, and other methods of the <code>itertools</code> package throw similar errors, e.g. when you use <code>permutations</code> you get <code>TypeError: Expected int as r</code>.</p>
<p>I couldn't find much on this apart from  <a href="https://github.com/numpy/numpy/issues/2951" rel="noreferrer">this numpy issue</a> and related ones, but that one was closed 3 years ago implying it was solved.</p>
<p>And basic things like indexing with numpy ints <code>data[dw[0]]</code> or boolean comparisons like <code>dw[0] == 1</code> work just fine.</p>
<p>Am I missing something? Could this be a Python 3 bug?</p>
</div>
<div class="post-text" itemprop="text">
<p>a <code>numpy.int64</code> is apparently not a subclass of <code>int</code></p>
<pre><code>a, b = dw[0], dw[1]
</code></pre>
<blockquote>
<p><code>type(a)</code></p>
</blockquote>
<pre><code>numpy.int64
</code></pre>
<blockquote>
<p><code>isinstance(a, int)</code></p>
</blockquote>
<pre><code>False
</code></pre>
<h1>Numpy documentation</h1>
<p>The <a href="https://docs.scipy.org/doc/numpy/reference/arrays.scalars.html" rel="noreferrer">documentation</a> mentions this explicitly</p>
<blockquote>
<p>Warning</p>
<p>The int_ type does not inherit from the int built-in under Python 3,
  because type int is no longer a fixed-width integer type.</p>
</blockquote>
<h1>Solution</h1>
<pre><code>print(list(it.islice(data, int(dw[0]) , int(dw[1]), 1)))
</code></pre>
<p>or numpy slicing</p>
<pre><code>data[dw[0]:dw[1]:1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure if it's a bug in Python 3 or not, but it looks like the behaviour has changed since 2.7.  As the <a href="https://github.com/numpy/numpy/issues/2951" rel="nofollow noreferrer">numpy issue you linked</a> described, under py27, either <code>numpy.int32</code> or <code>numpy.int64</code> would appear to be a subclass of <code>int</code> (depending on whether you use a 32- or 64-bit build of Python); under py3, the types are no longer related (numpy has fixed-width numeric types, python's <code>int</code> is variable-width).</p>
<p>The <a href="https://github.com/python/cpython/blob/3.6/Modules/itertoolsmodule.c#L1403" rel="nofollow noreferrer">implementation of <code>itertools.islice</code></a> requires its arguments to be objects of type PyLong (<a href="https://docs.python.org/3/c-api/long.html" rel="nofollow noreferrer">which is the Python API name for the Python <code>int</code> type</a>).  Specifically, it calls <a href="https://github.com/python/cpython/blob/3.6/Objects/longobject.c#L605" rel="nofollow noreferrer"><code>PyLong_AsSize_t</code></a>, which converts a Python object into a C <code>size_t</code> value.  This method seems to require that its argument is actually a Python <code>int</code> object, since it calls <a href="https://github.com/python/cpython/blob/3.6/Include/longobject.h#L14" rel="nofollow noreferrer"><code>PyLong_Check</code></a>.  I think this method is broadly equivalent to Python's <code>isinstance(obj, int)</code>, which explains the difference in behaviour between py2 and py3 here.</p>
<p><a href="https://github.com/python/cpython/blob/3.6/Objects/listobject.c#L2410" rel="nofollow noreferrer">Normal list indexing</a> uses another more tolerant method to coerce arguments into positive integer values, called <a href="https://github.com/python/cpython/blob/3.6/Objects/abstract.c#L1255" rel="nofollow noreferrer"><code>PyNumber_AsSsize_t</code></a>. 
 This checks if its argument is an <code>int</code>, and, if not, falls back to trying to call its argument's <a href="https://docs.python.org/3/reference/datamodel.html#object.__index__" rel="nofollow noreferrer"><code>__index__</code></a> method; as @MarkDickinson points out, numpy's numeric types implement this method, so everything works fine.  Perhaps this would be a more intuitive thing for <code>itertools.islice</code> to do.</p>
</div>
<div class="post-text" itemprop="text">
<p>This looks like a case for the <code>__index__</code> magic method (which numpy's integers already implement). I suggest raising an issue on the tracker, requesting this as an enhancement - that islice accept any object that implements <code>__index__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to keep a <code>islice</code>/<code>slice</code>-like object, use <code>np.s_</code>:</p>
<pre><code>slice = np.s_[dw[0]: dw[1]: 1]
data[slice]

['b', 'c']
</code></pre>
<p>since <code>np.s_</code> is a <code>numpy</code> object, it doesn't mind the <code>numpy</code> integers.</p>
</div>
<span class="comment-copy">the simplest fix would be to use type casting: <code>int(dw[0]), int(dw[1])</code></span>
<span class="comment-copy">Even where it works, py2.7, the use an array instead of a list will slower.</span>
<span class="comment-copy">Exactly the sort of thing that makes me hate Python.</span>
<span class="comment-copy">So why does <code>itertools.islice</code> require <code>int</code>s while regular list slicing is fine without them (e.g. <code>data[dw[0]]</code>)?</span>
<span class="comment-copy">@Chris_Rands: Regular list slicing and indexing supports anything that implements the <code>__index__</code> method. NumPy integer types implement that method.</span>
<span class="comment-copy">@MarkDickinson Thank you; is there a reason for that design? Why not let <code>islice</code> support anything with the <code>__index__</code>  method too? Although perhaps there is no real need for this given how easy it is to cast to <code>int</code>...</span>
<span class="comment-copy">@Chris_Rands: I think that's a question for bugs.python.org.</span>
<span class="comment-copy">@MarkDickinson Ok, a bug issue has been raised (not by me) <a href="http://bugs.python.org/issue30537" rel="nofollow noreferrer">bugs.python.org/issue30537</a></span>
<span class="comment-copy">Given that things like indexing or boolean comparisons work just fine shouldn't this considered to be a bug? Apparently many more basic functionalities are implemented in a way that works.</span>
<span class="comment-copy">@Khris I'm personally inclined to view this as a shortcoming of <code>islice</code>, yes.  It would seem more sensible to have <code>islice</code> consume any argument which is in some way "numeric" (including, for example, the base type <code>np.integer</code>).</span>
<span class="comment-copy">Regular slicing was never an issue; <code>list(it.islice(data,np.s_[dw[0]]))</code> still fails</span>
<span class="comment-copy">The point is to skip creating an <code>iterable</code> object altogether and use a <code>numpy</code> object with equivalent function.  The reason why <code>itertools</code> fails is covered in other answers.</span>
<span class="comment-copy">But simply <code>data[dw[0]:dw[1]]</code> works</span>
<span class="comment-copy">Thus the introductory phrase "If you want to keep a slice-like object".  i.e. if you're going to be using that slice on a bunch of different <code>list</code>s</span>
<span class="comment-copy">But then why not just use <code>slice()</code> like <code>a = slice(dw[0],dw[1]); data[a]</code>?</span>
