<div class="post-text" itemprop="text">
<p>I need to group sublists with the same elements together
For example:</p>
<pre><code>list1 =[[1, 0], [2, 1], [30, 32]]
</code></pre>
<p>would link <code>[1, 0]</code> and <code>[2, 1]</code> together since they both contain <code>1</code> and those two would combine into <code>[0, 1, 2]</code> </p>
<p>So after linking, the new list should be like:</p>
<pre><code>new_list1 = [[1, 0, 2], [30, 32]]
</code></pre>
<p>IE: there shouldn't be same number inside a sub-list and order is not important.</p>
<p>A longer example:</p>
<pre><code>list2 = [[2, 3], [4, 3], [6, 5], [7, 6], [7, 8], [13, 14], [30, 32]]
</code></pre>
<p>after linking, it would be </p>
<pre><code>new_list2 = [[2, 3, 4], [6, 5, 7, 8], [13, 14], [30, 32]]
</code></pre>
<p>So how can this be done in a general way?</p>
</div>
<div class="post-text" itemprop="text">
<p>To group the sublists in a general way you can:</p>
<h3>Code:</h3>
<pre><code>def linking_sublists(lists):
    index = {}
    sets = []
    for l in lists:
        found = None
        for i in l:
            if i in index:
                # this list has an element we have already seen
                if found:
                    # combine two sets
                    to_remove = index[i]
                    if found != to_remove:
                        for j in index[i]:
                            found.add(j)
                            index[j] = found
                        to_remove.clear()
                else:
                    found = index[i]

        if found is not None:
            s = found
            for i in l:
                s.add(i)
        else:
            s = set(l)
            sets.append(s)
        for i in l:
            index[i] = s

    return [list(sorted(s)) for s in sets if s]
</code></pre>
<h3>How:</h3>
<p>This function uses sets and an index <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer"><code>dict</code></a> to group any list with matching elements into sets and track which elements are already in a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer"><code>set</code></a>.</p>
<h3>Test Code:</h3>
<pre><code>list_2 = [[2, 3], [4, 3], [6, 5], [7, 6], [7, 8], [13, 14], [30, 32]]
print(linking_sublists(list_2))

list_3 = [[2, 3], [4, 3], [6, 5], [7, 6], [7, 8], [30, 32], [4, 5], [3, 4]]
print(linking_sublists(list_3))
</code></pre>
<h3>Results:</h3>
<pre><code>[[2, 3, 4], [5, 6, 7, 8], [13, 14], [30, 32]]
[[2, 3, 4, 5, 6, 7, 8], [30, 32]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way of seeing this problem is to think of each sublist as a node in a graph. Two nodes share an edge if they have common items.</p>
<p>The islands (<a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)" rel="nofollow noreferrer">"connected components" or just "components"</a>) of the graph can then be used to construct the new lists. The graph for <code>list2</code> would look like this:</p>
<pre><code>[2,3]&lt;---&gt;[4,3]

[6,5]&lt;---&gt;[7,6]&lt;---&gt;[7,8]

[13,14]   [30,32]
</code></pre>
<p>Code sketch (untested):</p>
<pre><code>list2=[[2,3],[4,3],[6,5],[7,6],[7,8],[13,14],[30,32]]

# Convert to tuples for easier handling
l2 = [tuple(item) for item in list2]

# Build a graph
graph = {item: set() for item in l2}
for sublist in l2:
    for sublist2 in l2:
        if sublist == sublist2:
            continue
        for item in sublist:
            if item in sublist2:
                graph[sublist].add(sublist2)

# Find all nodes that start_node is connected to
def island(graph, start_node):
    visited = set()
    visited.add(start_node)
    frontier = set(graph[start_node])
    while frontier:
        node = frontier.pop()
        visited.add(node)
        frontier.update(n for n in graph[node] if n not in visited)
    return visited

# Find all islands
islands = []
for sublist in l2:
    i = island(graph, sublist)
    if i not in islands:
        islands.append(i)

# Build the new lists by getting all unique numbers from each island
[list(set(item for sublist in island for item in sublist)) for island in islands]

# Output:
# [[2, 3, 4], [8, 5, 6, 7], [13, 14], [32, 30]]
</code></pre>
<p>The above can be improved, both the way the graph is built and the way components are found can be made more efficient.</p>
<p>This kind of thinking can be used to solve many different problems. That said, I like Stephen Rauch's solution more because of its simplicity. </p>
</div>
<span class="comment-copy">Can you make this code runs faster, sir?</span>
<span class="comment-copy">Not much faster, without quite a bit more work.  This code is already using sets and dicts to do the lookups.  These are the most efficient Python native structures for efficient lookups.  If this is not fast enough you might want  explore @Andr√©Laszlo <a href="https://stackoverflow.com/a/44222761/7311767">answer</a>.</span>
