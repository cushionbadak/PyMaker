<div class="post-text" itemprop="text">
<p>I tried using <code>pyparsing</code> to parse a CSV with:</p>
<ul>
<li><strong>Commas between parenthesis (or brackets, etc):</strong> "a(1,2),b" should return the list ["a(1,2)","b"]</li>
<li><strong>Missing values:</strong> "a,b,,c," should return the list ['a','b','','c','']</li>
</ul>
<p>I worked a solution but it seems "dirty". Mainly, the <code>Optional</code> inside only one of the possible atomics. I think the optional should be independent of the atomics. That is, I feel it should be put somewhere else, for example in the <code>delimitedList</code> optional arguments, but in my trial and error that was the only place that worked and made sense. It could be in any of the possible atomics so I chose the first. </p>
<p>Also, I don't fully understand what <code>originalTextFor</code> is doing but if I remove it it stops working.</p>
<p>Working example:</p>
<pre><code>import pyparsing as pp

# Function that parses a line of columns separated by commas and returns a list of the columns
def fromLineToRow(line):
    sqbrackets_col = pp.Word(pp.printables, excludeChars="[],") | pp.nestedExpr(opener="[",closer="]")  # matches "a[1,2]"
    parens_col = pp.Word(pp.printables, excludeChars="(),") | pp.nestedExpr(opener="(",closer=")")      # matches "a(1,2)"
    # In the following line:
    # * The "^" means "choose the longest option"
    # * The "pp.Optional" can be in any of the expressions separated by "^". I put it only on the first. It's used for when there are missing values
    atomic = pp.originalTextFor(pp.Optional(pp.OneOrMore(parens_col))) ^ pp.originalTextFor(pp.OneOrMore(sqbrackets_col))

    grammar = pp.delimitedList(atomic)

    row = grammar.parseString(line).asList()
    return row

file_str = \
"""YEAR,a(2,3),b[3,4]
1960,2.8,3
1961,4,
1962,,1
1963,1.27,3"""

for line in file_str.splitlines():
    row = fromLineToRow(line)
    print(row)
</code></pre>
<p>Prints:</p>
<pre><code>['YEAR', 'a(2,3)', 'b[3,4]']
['1960', '2.8', '3']
['1961', '4', '']
['1962', '', '1']
['1963', '1.27', '3']
</code></pre>
<p>Is this the right way to do this? Is there a "cleaner" way to use the <code>Optional</code> inside the first atomic?</p>
</div>
<div class="post-text" itemprop="text">
<p>Working inside-out, I get this:</p>
<pre><code># chars not in ()'s or []'s - also disallow ','
non_grouped = pp.Word(pp.printables, excludeChars="[](),")

# grouped expressions in ()'s or []'s
grouped = pp.nestedExpr(opener="[",closer="]") | pp.nestedExpr(opener="(",closer=")")

# use OneOrMore to allow non_grouped and grouped together
atomic = pp.originalTextFor(pp.OneOrMore(non_grouped | grouped))
# or based on your examples, you *could* tighten this up to:
# atomic = pp.originalTextFor(non_grouped + pp.Optional(grouped))
</code></pre>
<p><code>originalTextFor</code> recombines the original input text within the leading and trailing boundaries of the matched expressions, and returns a single string. If you leave this out, then you will get all the sub-expressions in a nested list of strings, like <code>['a',['2,3']]</code>. You <em>could</em> rejoin them with repeated calls to <code>''.join</code>, but that would collapse out whitespace (or use <code>' '.join</code>, but that has the opposite problem of potentially introducing whitespace).</p>
<p>To optionalize the elements of the list, just say so in the definition of the delimited list:</p>
<pre><code>grammar = pp.delimitedList(pp.Optional(atomic, default=''))
</code></pre>
<p>Be sure to add the default value, else the empty slots will just get dropped.</p>
<p>With these changes I get:</p>
<pre><code>['YEAR', 'a(2,3)', 'b[3,4]']
['1960', '2.8', '3']
['1961', '4', '']
['1962', '', '1']
['1963', '1.27', '3']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you can do is using regex <code>re</code>, for instance:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.split(r',\s*(?![^()]*\))', line1)
['a(1,2)', 'b']
&gt;&gt;&gt; re.split(r',\s*(?![^()]*\))', line2)
['a', 'b', '', 'c', '']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re

with open('44289614.csv') as f:
    for line in map(str.strip, f):
        l = re.split(',\s*(?![^()[]]*[\)\]])', line)
        print(len(l), l)
</code></pre>
<p>Output:</p>
<pre><code>3 ['YEAR', 'a(2,3)', 'b[3,4]']
3 ['1960', '2.8', '3']
3 ['1961', '4', '']
3 ['1962', '', '1']
3 ['1963', '1.27', '3']
</code></pre>
<p>Modified from <a href="https://stackoverflow.com/a/26809170/778533">this answer</a>.</p>
<p>I also like <a href="https://stackoverflow.com/a/1648570/778533">this answer</a>, which suggests modifying the input slightly and using <a href="https://docs.python.org/3/library/csv.html#csv.Dialect.quotechar" rel="nofollow noreferrer">quotechar</a> of the <code>csv</code> module.</p>
</div>
<span class="comment-copy">For parse-time conversion of numeric values, change <code>atomic</code> to: <code>atomic = pp.pyparsing_common.number | pp.originalTextFor(... etc.</code>.</span>
<span class="comment-copy">line1 parsing should be ["a(1,2)","b"] instead of ['a(1', '2)', 'b'] (the comma inside the parenthesis shouldn't be a delimiter)</span>
<span class="comment-copy">@Alechan see my update please</span>
<span class="comment-copy">Yes, that was my first approach before trying pyparsing but when I start to add square brackets or any other type of nested expressions then the regex gets more and more illegible</span>
