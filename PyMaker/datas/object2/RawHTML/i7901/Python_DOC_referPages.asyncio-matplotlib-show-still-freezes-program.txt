<div class="post-text" itemprop="text">
<p>I wish to <strong>run a simulation</strong> while at the <strong>same time output its progress in a plot</strong>. I've been looking through a lot of examples of threading and multiprocessing, but they are all pretty complex. So I thought with Python's new <code>asyncio</code> library this should be easier.</p>
<p>I found an example (<a href="https://stackoverflow.com/questions/37549846/how-to-use-yield-inside-async-function">How to use 'yield' inside async function?</a>) and modified it for my cause:</p>
<pre><code>import matplotlib.pyplot as plt
import asyncio
import numpy as np


class DataAnalysis():
    def __init__(self):
        # asyncio so we can plot data and run simulation in parallel
        loop = asyncio.get_event_loop()
        try:
            loop.run_until_complete(self.plot_reward())
        finally:
            loop.run_until_complete(
                loop.shutdown_asyncgens())  # see: https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.shutdown_asyncgens
            loop.close()

    async def async_generator(self):
        for i in range(3):
            await asyncio.sleep(.4)
            yield i * i

    async def plot_reward(self):
        # Prepare the data
        x = np.linspace(0, 10, 100)

        # Plot the data
        plt.plot(x, x, label='linear')

        #plt.show()

        # add lines to plot
        async for i in self.async_generator():
            print(i)
            # Show the plot
            plt.show()


if __name__ == '__main__':
    DataAnalysis()
</code></pre>
<h2>Question</h2>
<p>I added a simple <code>plt.show()</code> and the program still freezes. I thought with <code>asyncio</code> I could run it in parallel? Obviously my knowledge is still lacking.
An example that does the following would be really helpful:</p>
<ul>
<li>Add a line to a plot (of <code>matplotlib</code>) everytime <code>async_generator</code> returns a value.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>First of all, I misunderstood asyncio, it doesn't make run things in parallel (<a href="https://stackoverflow.com/questions/40558484/use-asyncio-for-parallel-tasks">use asyncio for parallel tasks</a>).</p>
<p>It seems the only thing that worked for me was <code>plt.pause(0.001)</code> (<a href="https://stackoverflow.com/questions/28269157/plotting-in-a-non-blocking-way-with-matplotlib">Plotting in a non-blocking way with Matplotlib</a>). <code>plt.draw()</code> opened a window, but it didn't show anything and <code>plt.show</code> freezes the program. It seems that <code>plt.show(block=False)</code> is deprecated and using <code>plt.ion</code> gives the problem that the final result closes when the program is finished. Also <code>await asyncio.sleep(0.1)</code> didn't make the plot draw a line.</p>
<h2>Working code</h2>
<pre><code>import matplotlib.pyplot as plt
import asyncio
import matplotlib.cbook
import warnings
warnings.filterwarnings("ignore",category=matplotlib.cbook.mplDeprecation)


class DataAnalysis():
    def __init__(self):
        # asyncio so we can plot data and run simulation in parallel
        loop = asyncio.get_event_loop()
        try:
            loop.run_until_complete(self.plot_reward())
        finally:
            loop.run_until_complete(
                loop.shutdown_asyncgens())  # see: https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.shutdown_asyncgens
            loop.close()
            # keep plot window open
            plt.show()

    async def async_generator(self):
        for i in range(3):
            await asyncio.sleep(.4)
            yield i * i

    async def plot_reward(self):
        #plt.ion()  # enable interactive mode

        # receive dicts with training results
        async for i in self.async_generator():
            print(i)
            # update plot
            if i == 0:
                plt.plot([2, 3, 4])
            elif i == 1:
                plt.plot([3, 4, 5])

            #plt.draw()
            plt.pause(0.1)
            #await asyncio.sleep(0.4)


if __name__ == '__main__':
    da = DataAnalysis()
</code></pre>
<h2>Notes</h2>
<ul>
<li><p>You get however a deprecated message: <code>python3.6/site-packages/matplotlib/backend_bases.py:2445: MatplotlibDeprecationWarning: Using default event loop until function specific to this GUI is implemented
warnings.warn(str, mplDeprecation)</code>, which you can suppress with: <code>warnings.filterwarnings()</code>.</p></li>
<li><p>I'm not sure if <code>asyncio</code> was actually necessary for my use case...</p></li>
<li><p>Difference between <code>threading</code> and <code>multiprocessing</code> for who's interested: <a href="https://stackoverflow.com/questions/3044580/multiprocessing-vs-threading-python">Multiprocessing vs Threading Python</a></p></li>
</ul>
</div>
