<div class="post-text" itemprop="text">
<p>I have the following code written in python 2.7 to find n time Cartesian product of a set (AxAxA...xA)-</p>
<pre><code>prod=[]
def cartesian_product(set1,set2,n):
    if n&gt;=1:
        for x in set1:
            for y in set2:
                prod.append('%s,%s'%(x,y))
        #prod='[%s]' % ', '.join(map(str, prod)) 
        #print prod
        cartesian_product(set1,prod,n-1)
    else:
        print prod


n=raw_input("Number of times to roll: ")
events=["1","2","3","4","5","6"]
cartesian_product(events,events,1)
</code></pre>
<p>This works properly when n=1. But changing the parameter value from <strong><em>cartesian_product(events,events,1)</em></strong> to <strong><em>cartesian_product(events,events,2)</em></strong> doesn't work. Seems there's an infinite loop is running. I can't figure where exactly I'm making a mistake.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def cartesian_product(*X):
    if len(X) == 1: #special case, only X1
        return [ (x0, ) for x0 in X[0] ]
    else:
        return [ (x0,)+t1 for x0 in X[0] for t1 in cartesian_product(*X[1:]) ]

n=int(raw_input("Number of times to roll: "))
events=[1,2,3,4,5,6]
prod=[]
for arg in range(n+1):
    prod.append(events)
print cartesian_product(*prod)
</code></pre>
<p>Output:</p>
<pre><code>Number of times to roll:  1

[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
</code></pre>
<p>you can also pass string in your events list but it'll print string in tuple also.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you pass the reference to the global variable <code>prod</code> to the recursive call, you are modifying the list that <code>set2</code> also references. This means that <code>set2</code> is growing as you iterate over it, meaning the iterator never reaches the end.</p>
<p>You don't need a global variable here. <em>Return</em> the computed product instead.</p>
<pre><code>def cartesian_product(set1, n):
    # Return a set of n-tuples
    rv = set()
    if n == 0:
        # Degenerate case: A^0 == the set containing the empty tuple
        rv.add(())
    else:
        rv = set()
        for x in set1: 
            for y in cartesian_product(set1, n-1):
                rv.add((x,) + y)
    return rv
</code></pre>
<p>If you want to perserve the order of the original argument, use <code>rv = []</code> and <code>rv.append</code> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>inside the recursive call <code>cartesian_product(set1,prod,n-1)</code> you are passing the list prod, and you are again appending values to it, so it just grows over time and the inner loop never terminates. Perhaps you might need to change your implementation.</p>
</div>
<span class="comment-copy">when it runs the second time, you are passing <code>prod</code> as <code>set2</code>. Since <code>prod</code> is defined outside the function, set2 and prod are now the same thing. so when you do <code>for y in set2</code> and <code>prod.append</code>, you are appending to <code>set2</code>, which is causing the infinite iteration.</span>
<span class="comment-copy">Hint: <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> does the job (unless this is homework of some sort)</span>
<span class="comment-copy">But the loop should stop when n&lt;1. This means it should exactly run 2 times when n=2 @algrebe</span>
<span class="comment-copy">@AbdullahShahriar it is still stuck in the endless <code>for y in set2</code> stage. only after it comes out of that can it call <code>cartesian_product</code> again which will print prod.</span>
<span class="comment-copy">your code will always give [] value as it checks for cartesian_product(set1, n-1) and in recursion, it comes to n=0 and function will return [] always.</span>
<span class="comment-copy">Always return []</span>
<span class="comment-copy">OK, I was confused both about what A^0 should be and how to create a set containing just an empty tuple. Should be fixed now.</span>
