<div class="post-text" itemprop="text">
<p>I am drawing dozens of functions as subplots, by storing pure functions as list. I find many different functions are considered the same. Here is a simplified example, where two cosine functions are drawn.</p>
<pre><code>#!/usr/bin/env python3
import math # cos
from matplotlib import pyplot as plt # Plotting.

scale =[0.01*x for x in list(range(200))]
list_fun =[lambda t: math.cos(2*math.pi*i*t) for i in [1,2]]

data_1 =list(map(list_fun[0], scale))
data_2 =list(map(list_fun[1], scale))

fig =plt.figure( figsize=(11,5) )

ax =fig.add_subplot(1, 2, 1) # left
ax.plot( scale, data_1, label="cos 2$\pi$t" )
ax.legend()

ax =fig.add_subplot(1, 2, 2) # right
ax.plot( scale, data_2, label="cos 4$\pi$t" )
ax.legend()

plt.show()
</code></pre>
<p>The plot shows both <code>$\cos (4\pi t)$</code> functions, but one should be <code>$\cos (2\pi t)$</code>. I guess the list formed by several pure functions are invalid in python, is it so? If so, is there an alternative syntax? I am new to Python so there may have been some glaring errors.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>list_fun</code> list contains two identical functions because of how you defined it. Both functions return <code>math.cos(2*math.pi*i*t)</code>, where <code>i</code> has its final value, 2. </p>
<p>You could copy <code>i</code> to another variable to get this to work:</p>
<pre><code>[lambda t, m=i: math.cos(2*math.pi*m*t) for i in [1,2]]
</code></pre>
</div>
<span class="comment-copy">Your <code>list_fun</code> lists contains two identical functions because of how you defined it. Both functions return <code>math.cos(2*math.pi*i*t)</code>, where <code>i</code> has its final value, 2</span>
<span class="comment-copy">Use <code>lambda t, i=i: ... for i in [1,2]</code> to create a closure over the current value of <code>i</code>. Otherwise, <code>i</code> is simply a global (or nonlocal) variable in the body of the resulting function object, whose value is found when the function is called.</span>
<span class="comment-copy">The old <a href="http://python-guide-pt-br.readthedocs.io/en/latest/writing/gotchas/#id1" rel="nofollow noreferrer">late binding</a> problem!</span>
<span class="comment-copy">See <a href="https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" rel="nofollow noreferrer">Why do lambdas defined in a loop with different values all return the same result?</a> and <a href="https://sopython.com/canon/30/why-do-my-lambda-functions-or-nested-functions-created-in-a-loop-all-use-the-las/" rel="nofollow noreferrer">sopython.com/canon/30/…</a></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/12423614/local-variables-in-python-nested-functions" title="local variables in python nested functions">stackoverflow.com/questions/12423614/…</a> The code in that question uses a different technique to define the functions, but it's essentially the same problem. OTOH, at first glance, it's not clear that this question is a dupe of that one, so I'm not comfortable using it as a dupe target.</span>
<span class="comment-copy">This is correct! But I am still struggling to understand the evaluation order....</span>
<span class="comment-copy">@Aminopterin In khelwood's code the assignment of the default value <code>m=i</code> happens when the function is created, so <code>m</code> gets the desired value of <code>i</code> as its default value. In your code, the name <code>i</code> is looked up each time the function is called, and in this case <code>i</code> is found in the scope of the list comp where the function was created, where <code>i</code> has the value it was set to at the end of the <code>for</code> loop.</span>
