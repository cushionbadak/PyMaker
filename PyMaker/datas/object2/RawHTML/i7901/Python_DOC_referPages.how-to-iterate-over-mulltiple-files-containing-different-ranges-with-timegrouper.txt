<div class="post-text" itemprop="text">
<p>I have a collection of files. Each file has 1 second data. Furthermore, the files are not periodic, i.e. they are not daily files. For example, one file may contain a day and a half of data, whereas the next may contain 3 days and 2 hours; gaps may exist between files and within them. Another issue is that it is not practical to load all the files in memory at the same time.</p>
<p>Here is a concrete example that shows the problem. The following dataframe has a day and half of 1 second data:</p>
<pre><code>index = pd.date_range('now', periods=60*60*24*1.5, freq='1S')
data_a = pd.DataFrame(np.random.rand(len(index)), index=index, columns=['data'])
</code></pre>
<p>The next dataframe starts where the previous one left off and it has two days of data:</p>
<pre><code>index = pd.date_range(data_a.index[-1] + pd.Timedelta('1S'), periods=60*60*24*2, freq='1S')
data_b = pd.DataFrame(np.random.rand(len(index)), index=index, columns=['data'])
</code></pre>
<p>Lets create 10 minute iterators on each dataframe and <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer">chain</a> them:</p>
<pre><code>ia = iter(data_a.groupby(TimeGrouper('10Min')))
ib = iter(data_b.groupby(TimeGrouper('10Min')))
iaib = chain(ia, ib)
</code></pre>
<p>The desired behaviour if we iterate over <code>iaib</code> is to see each group key (and its data) only once, but this is not the case.</p>
<pre><code>seen = {}
for name, group in iaib:
    count = seen.get(name, 0)
    seen[name] = count + 1

seen_twice = {key: value for key, value in seen.items() if value &gt; 1}
</code></pre>
<p>The contents of <code>seen_twice</code> are:</p>
<pre><code>{Timestamp('2017-06-02 08:50:00', freq='10T'): 2}
</code></pre>
<p>In this example, <code>2017-06-02 08:50:00</code> is the key of the last group of <code>data_a</code> and the first group of <code>data_b</code>.</p>
<p>How do I iterate by 10 minute groups over all the files without repeating groups at the edges of the files?</p>
</div>
<div class="post-text" itemprop="text">
<p>The solution has two parts: one is to handle all the files as a single dataset; the other is to account for the fact that a 10 minute group can be split between the end of one file and the start of the next.</p>
<p>These are the required imports:</p>
<pre><code>from itertools import chain

import pandas as pd
from pandas.tseries.resample import TimeGrouper
</code></pre>
<h3>Handle all the files as a single dataset</h3>
<p>This function returns an iterator over the 10 minute groups of the given file:</p>
<pre><code>def make_iterator(file):
    df = pd.read_csv(file, index_col='timestamp', parse_dates=['timestamp'])
    return iter(df.groupby(TimeGrouper('10Min')))
</code></pre>
<p>The above function is used to create an iterator of iterators with <a href="https://docs.python.org/3.6/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain</code></a>. Given a list of files a single iterator over all the 10 min groups of the collection of files can be created like so:</p>
<pre><code>files = ... # list obtained by os.listdir() or glob.glob()    
iterator_of_single_file_group_iterators = map(make_iterator, files)
chained_file_group_iterator = chain.from_iterable(iterator_of_single_file_group_iterators)
</code></pre>
<h3>Account for the fact that a group can be split between the end of one file and the start of the next</h3>
<p>However, the above iterator is not aware of 10 minute groups that span two files. The following class addresses that problem:</p>
<pre><code>class TimeGrouperChainDecorator(object):

    def __init__(self, iterator):
        self.iterator = iterator
        self._has_more = True
        self._last_item = next(self.iterator)

    def __iter__(self):
        return self

    def __next__(self):
        if not self._has_more:
            raise StopIteration
        try:
            return self._next()
        except StopIteration:
            self._has_more = False
            if self._last_item is not None:
                return self._last_item
            raise StopIteration

    def _next(self):
        new_key, new_data = next(self.iterator)

        last_key, last_data = self._last_item
        if new_key == last_key:
            data = pd.concat([last_data, new_data])
            try:
                self._last_item = next(self.iterator)
            except StopIteration:
                self._has_more = False
            return new_key, data
        else:
            self._last_item = new_key, new_data
            return last_key, last_data
</code></pre>
<p>Note that the implementation is entirely dependent on the pandas <code>groupby</code> API. To use it, create an instance of the class with the above chained iterators:</p>
<pre><code>iterator = TimeGrouperChainDecorator(chained_file_group_iterator)

for name, group in iterator:
    # do something with each 10 minute group
</code></pre>
<p>My implementation may not be perfect so any feedback is welcome. I've published a <a href="https://bitbucket.org/snippets/pablo_esteban/8nzRK" rel="nofollow noreferrer">snippet with 3 tests</a>.</p>
</div>
<span class="comment-copy">Thanks for the feedback, hopefully I've improved the question.</span>
