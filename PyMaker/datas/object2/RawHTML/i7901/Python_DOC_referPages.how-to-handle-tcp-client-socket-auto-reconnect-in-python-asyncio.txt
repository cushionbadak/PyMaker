<div class="post-text" itemprop="text">
<p>I am using python asyncio streams to connect to several socket servers, but when the server is down, my code can't auto reconnect. </p>
<p>What I need is that, when the server is down, my script will try to reconnect every 5 seconds, until connected and start to parse the data again.</p>
<pre><code>import asyncio

server1 = {'host': '192.168.1.51', 'port': 11110}
server2 = {'host': '192.168.1.52', 'port': 11110}


async def tcp_client(host, port, loop):
    print('connect to server {} {}'.format(host, str(port)))
    reader, writer = await asyncio.open_connection(host, port, loop=loop)

    while True:
        data = await reader.read(100)
        print('raw data received: {}'.format(data))

        await asyncio.sleep(0.1)


loop = asyncio.get_event_loop()
try:
    for server in [server1, server2]:
        loop.run_until_complete(tcp_client(server['host'], server['port'], loop))
        print('task added: connect to server {} {}'.format(server['host'], server['port']))
finally:
    loop.close()
    print('loop closed')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can handle reconnection by simply looping over a <code>try/except</code> statement.</p>
<p>Additionally, <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for" rel="nofollow noreferrer">asyncio.wait_for</a> can be used to set a timeout on the read operation.</p>
<p>Consider this working example:</p>
<pre><code>import asyncio

async def tcp_client(host, port):
    reader, writer = await asyncio.open_connection(host, port)
    try:
        while not reader.at_eof():
            data = await asyncio.wait_for(reader.read(100), 3.0)
            print('raw data received: {}'.format(data))
    finally:
        writer.close()

async def tcp_reconnect(host, port):
    server = '{} {}'.format(host, port)
    while True:
        print('Connecting to server {} ...'.format(server))
        try:
            await tcp_client(host, port)
        except ConnectionRefusedError:
            print('Connection to server {} failed!'.format(server))
        except asyncio.TimeoutError:
            print('Connection to server {} timed out!'.format(server))
        else:
            print('Connection to server {} is closed.'.format(server))
        await asyncio.sleep(2.0)

async def main():
    servers = [('localhost', 8888), ('localhost', 9999)]
    coros = [tcp_reconnect(host, port) for host, port in servers]
    await asyncio.gather(*coros)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    loop.close()
</code></pre>
</div>
<span class="comment-copy">First of all your code will not run: you can't access items in a dictionary using dot notation - use <code>server['host']</code> or <code>server.get('host')</code>.</span>
<span class="comment-copy">Another problem is that <code>loop.run_until_complete()</code> runs until it, well, completes, i.e. it blocks. Thus only one server will be connected at a time.</span>
<span class="comment-copy">And another problem is that <code>tcp_client()</code> needs to check if the connection is closed. You can tell that when <code>data</code> is the empty string - then return from the function.</span>
<span class="comment-copy">1. I have corrected the codes. 2. So I need to use loop.call_soon() instead of loop.run_until_complete() to run the task? 3. I can use len(data) == 0 to check if the connection is closed?</span>
<span class="comment-copy">2. Consider using <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="nofollow noreferrer">asyncio.gather</a> or <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait" rel="nofollow noreferrer">asyncio.wait</a> 3. See <a href="https://docs.python.org/3/library/asyncio-stream.html?highlight=stream%20api#asyncio.StreamReader.at_eof" rel="nofollow noreferrer">StreamReader.at_eof</a></span>
<span class="comment-copy">I used your code but failed. When I unplug my servers and plugin them again, connection didn't restarted again. below is the log: 2017-05-26 21:39:54,239 - Connecting to server 10.0.1.68 1100 ... 2017-05-26 21:39:54,240 - Connecting to server 10.0.1.69 1100 ... 2017-05-26 21:39:54,977 - raw data received: b'030 1495834968 00.000 00.004 00.010 00.007 00.004 00.000 00.000 00.000\n'</span>
<span class="comment-copy">@DesmondChen Maybe another exception is raised when you unplug your servers, you can try to replace <code>ConnectionRefusedError</code> with <code>Exception</code>. Also, using <code>await asyncio.gather(*coros)</code> will cause your program to stop at the first unexpected exception.</span>
<span class="comment-copy">I changed "ConnectionRefusedError to Exception" and "await asyncio.wait(coros)" to "await asyncio.gather(*coros)". But it still doesn't work. I think that it is stuck at  async def tcp_client(host, port) and no exception raised.</span>
<span class="comment-copy">@DesmondChen You might want to run your tests with netcat servers (e.g. run <code>nc -l 8888</code>, write a message to stdin, press enter and interrupt with CTRL+C) to see if the problem comes from your servers.</span>
<span class="comment-copy">It seems that when the buffer is empty, read.at_eof() is still False.</span>
