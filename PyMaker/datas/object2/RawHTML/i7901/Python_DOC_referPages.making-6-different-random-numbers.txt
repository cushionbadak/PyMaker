<div class="post-text" itemprop="text">
<p>I'm not that good at coding right now, i am trying to improve and learn. ATM i was trying to write a code that randomly picks 6 non-repeating numbers, but i fail at it. what should i do?</p>
<pre><code>import random

a = random.randint(1, 100)
b = random.randint(1, 100)
c = random.randint(1, 100)
x = random.randint(1, 100)
y = random.randint(1, 100)
z = random.randint(1, 100)

outa = b, c, x, y, z
outb = a, c, x, y, z
outc = a, b, x, y, z
outx = a, b, c, y, z
outy = a, b, c, x, z
outz = a, b, c, x, y

all = a, b, c, x, y, z

while a in outa or b in outb or c in outc or x in outx or y in outy or z in outz:
    if a in outa:
        a = random.randint(1,100)
    elif b in outb:
        b = random.randint(1,100)
    elif c in outc:
        c = random.randint(1,100)
    elif x in outx:
        x = random.randint(1,100)
    elif y in outy:
        y = random.randint(1,100)
    elif z in outz:
        z = random.randint(1,100)

print(all)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>all = a, b, c, x, y, z
</code></pre>
<p>Things like that creates a tuple of <em>values</em>. So at the time the line executes, that tuple has fixed values inside and cannot be changed. It especially does not change when you update one of the variables you originally used to construct it. So you cannot use <code>all</code> for the final result, or the <code>outX</code> tuples to check for any duplicates because they are fixed and will not update.</p>
<p>In order for your code to work, you would have to recreate all those tuples in every iteration of your while loop. But in general, you will quickly notice that having those explicit variables is not a good idea.</p>
<p>If you want to keep using <code>randint</code>, then you could just generate one number at a time, and “reroll” whenever you encounter a number you already have:</p>
<pre><code>numbers = []
while len(numbers) &lt; 6:
    num = random.randint(1, 100)
    if num not in numbers:
        numbers.append(num)
</code></pre>
<p>I’m using a list here, which is a mutable data structure to collect multiple values (compared to the tuple, which is immutable).</p>
<p>You can also use <a href="https://docs.python.org/3/library/random.html#random.sample" rel="nofollow noreferrer"><code>random.sample</code></a> here which offers an even easier way to get any number of unique values from a range of numbers:</p>
<pre><code>numbers = random.sample(range(1, 100), 6)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is a function in <code>random</code> that does just that:</p>
<pre><code>all = random.sample(range(1,101), 6)
</code></pre>
<p>If the list of possible values is too large to build, then your algorithm is fine, but better with a list:</p>
<pre><code>all = []
while len(all) &lt; 6:
    x = random.randint(1, 10000000)
    if not x in all:
        all.append(x)
</code></pre>
<p>If your list is much bigger than <code>6</code> you can consider using a <code>set</code> instead of a <code>list</code>.</p>
<p><strong>UPDATE:</strong> Actually, <code>random.sample()</code> is pretty smart, and with python3 this code:</p>
<pre><code>all = random.sample(range(1,10000000001), 6)
</code></pre>
<p>works just fine, while this one:</p>
<pre><code>all = random.sample(list(range(1,10000000001)), 6)
</code></pre>
<p>eats all my memory.</p>
<p>If you are with python2 you can use <code>xrange</code> instead of <code>range</code> to get the same effect.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of creating 6 different variables, you could create a list that generates 6 unique numbers using <code>random.sample</code>:</p>
<pre><code>import random

nums = random.sample(range(1,100), 6)
print (nums)

Output:
[2,34,5,61,99,3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Like this:</p>
<pre><code>random.sample(range(1,100), 6)
</code></pre>
</div>
<span class="comment-copy">Do you know anything about lists?</span>
<span class="comment-copy"><i>"randomly picks 6 non-repeating numbers"</i>: <code>random.sample(range(1, 100), 6)</code></span>
<span class="comment-copy">All the suggestions in this question that use <code>sample</code> (except mine) are missing the 100 in the range. <code>range</code> does not include the ending value but <code>randint</code> does.</span>
<span class="comment-copy">Any reason to turn the <code>range()</code> into <code>set</code> before sampling, seems to make things significantly slower for the same result.</span>
<span class="comment-copy">I think you're right, no need for the set. I'll edit.</span>
