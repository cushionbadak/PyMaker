<div class="post-text" itemprop="text">
<p>After some research about recursive functions i am facing contradiction: On one side solving problems in recursive way is elegant while on the other side in practice performance seems to be horrible and number of recursive calls is limited.</p>
<p>I understand by default Pythons recursive depth is limited to 1000, however even in a simple application i get very bad performmance as early as 40 - 50 calls.</p>
<p>Let me give an example:</p>
<pre><code>def fibonacci(n):
    if n == 1 or n == 0:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
</code></pre>
<p>This simple recursive function on my PC takes huge amount of time to solve even for low n. For testing i also wrote another function:</p>
<pre><code>def fib_nonrecursive(n):
    fib_seq = [1, 1]
    for i in range(2, n+1):
        value = fib_seq[i-1] + fib_seq[i-2]
        fib_seq.append(value)        
    return fib_seq[i]
</code></pre>
<p>Non recursive way is very fast even on big numbers, so definitivly problem cannot be operations involved or size of numbers. So my question is why the recursive way is so slow and is there any way to make it faster? Is there any way to expand resursive depth?</p>
<p><strong>EDIT</strong> 
Since answers suggested using memoization i looked into it and implemented it on my example:</p>
<pre><code>def mem(f):
    memory = {}
    def inner_function(x):
        if x not in memory:            
            memory[x] = f(x)
            return memory[x]
        else:
            return memory[x]
    return inner_function

@mem
def fibonacci(n):
    if n == 1 or n == 0:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
</code></pre>
<p>Same <code>mem(f)</code> can be used with other recursive functions <code>f</code>. The <code>@mem</code> part must be included for <code>f</code> to be passed as argument to <code>mem()</code> (see "decorators")
It is slightly advanced way to code but i didnt find an easier was to implement memoization for given example. If there is simpler way of implementation pls correct me.</p>
</div>
<div class="post-text" itemprop="text">
<p>Ignoring the fact that <code>fibonacci()</code> is a textbook case for memoization (which would make it much faster), "deep and cheap" recursion simply is not a thing in plain Python.</p>
<p>In many languages there is tail-call elimination.  Python doesn't have this.  In many languages, pushing an additional stack frame is very cheap.  Not so in Python.</p>
<p>It's not so easy to find real-world code where this is a problem, which may go some way toward explaining why the Python folks have kept it  simple and always create bona fide stack frames with full debugging ability.  There's just not a lot of demand for cheap and deep recursion in most Python applications.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with recursive functions is that you call the same method with the same parameter a certain number of times. For example, in <code>fibrecursive(7)</code>, <code>fibrecursive(2)</code> is called 4 times. Each time you redo the same thing.</p>
<p>You can improve performance using <a href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="nofollow noreferrer">dynamic programming</a>. In short, you store your result in an array and when you call <code>fibrecursive(2)</code> you check in your array if it already exists.</p>
<p>Here is the pseudo code from the article:</p>
<pre><code>function fib(n)
    if key n is not in map m 
        m[n] := fib(n − 1) + fib(n − 2)
    return m[n]
</code></pre>
</div>
<span class="comment-copy">The recursive fib function is likely noticeably worse since each "iteration" spawns 2 more calls to itself. That would make it O(n*2) vs O(n) if I'm not mistaken. Have you found other recursive functions to be slower than their iterative version?</span>
<span class="comment-copy">Read about memoization.</span>
<span class="comment-copy">Recursie fibonacci calculation is a perfect fit for memoization. <a href="https://stackoverflow.com/questions/1988804/what-is-memoization-and-how-can-i-use-it-in-python" title="what is memoization and how can i use it in python">stackoverflow.com/questions/1988804/…</a></span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer">docs.python.org/3/library/functools.html#functools.lru_cache</a> might help for meomization. and: is your question about general recursion or just fibonacci?</span>
<span class="comment-copy">If was thinking about that option but both calls shoud be stored in the stack anyway and O(n) = O(n*2) from what i remember since both are petty much linear. I ofetn noticed slowness using recursion but didnt do side by side compparison since i usualy write either one or the other version of code.</span>
<span class="comment-copy">Could memoization alse be called hashing? it seems to me very similart concept. So basically if recursion is only way i found to solve a problem i should use memoization if possible or write in some oother language?</span>
<span class="comment-copy">Memoization is just associating the arguments of a function with the result of evaluating the function on the arguments. Hashing is one way to implement it.</span>
