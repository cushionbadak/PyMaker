<div class="post-text" itemprop="text">
<p>I want to group similar strings, however, I would prefer to be smart to catch whether conventions like '/' or '-' are diverged instead of letter differences.</p>
<p>Given following input:</p>
<pre><code>moose
mouse
mo/os/e
m.ouse

alpha = ['/','.']
</code></pre>
<p>I want to group strings with respect to restricted set of letters, where output should be:</p>
<pre><code>moose
mo/os/e

mouse
m.ouse
</code></pre>
<p>I'm aware I can get similar strings using <a href="https://docs.python.org/3/library/difflib.html" rel="nofollow noreferrer">difflib</a> but it doesn't provide option for limiting the alphabet. Is there another way of doing this? Thank you.</p>
<p><strong>Update:</strong></p>
<p>Instead of restricted letters, alphas are simpler to implement by just checking for occurrences. Therefore, I've changed the title.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe something like:</p>
<pre><code>from collections import defaultdict

container = defaultdict(list)
for word in words:
    container[''.join(item for item in word if item not in alpha)].append(word)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is an idea that takes a few (easy) steps:</p>
<pre><code>import re
example_strings = ['m/oose', 'moose', 'mouse', 'm.ouse', 'ca...t', 'ca..//t', 'cat']
</code></pre>
<h1>1. Index all of your strings so you can refer back to them by index later:</h1>
<pre><code>indexed_strings = list(enumerate(example_strings))
</code></pre>
<h1>2. Store all strings with restricted characters in a dictionary using index as the key, string as the value. Then remove the restricted chars temporarily for sorting:</h1>
<pre><code># regex to match restricted alphabet
restricted = re.compile('[/\.]')
# dictionary to store strings with restricted char
restricted_dict = {}
for (idx, string) in indexed_strings:
    if restricted.search(string):
        # storing the string with a restricted char by its index
        restricted_dict[idx] = string
        # stripping the restricted char temporarily and returning to the list
        indexed_strings[idx] = (idx, restricted.sub('', string))
</code></pre>
<h1>3. Sort the cleaned list of strings by string values, then iterate over the strings once more and replace the stripped strings with their original values:</h1>
<pre><code>indexed_strings.sort(key=lambda x: x[1])
# make a new list for the final set of strings
final_strings = []
for (idx, string) in indexed_strings:
    if idx in restricted_dict:
        final_strings.append(restricted_dict[idx])
    else:
        final_strings.append(string)
</code></pre>
<p>Result: <code>['ca...t', 'ca..//t', 'cat', 'm/oose', 'moose', 'mouse', 'm.ouse']</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Since you want to group words, you should probably use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a>.</p>
<p>You just need to define a function which deletes <code>alpha</code> chars (e.g. with <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer"><code>str.translate</code></a>), and you can apply <a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer"><code>sort</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> to your data:</p>
<pre><code>from itertools import groupby

words = ['moose', 'mouse', 'mo/os/e', 'm.ouse']
alpha = ['/','.']

alpha_table = str.maketrans('', '', ''.join(alpha))

def remove_alphas(word):
    return word.lower().translate(alpha_table)

words.sort(key=remove_alphas)
print(words)
# ['moose', 'mo/os/e', 'mouse', 'm.ouse'] # &lt;- Words are sorted correctly.

for common_word, same_words in groupby(words, remove_alphas):
    print(common_word)
    print(list(same_words))
# moose
# ['moose', 'mo/os/e']
# mouse
# ['mouse', 'm.ouse']
</code></pre>
</div>
<span class="comment-copy">Have you considered casefolding and stripping away anything that's not within <code>a-z</code>?</span>
<span class="comment-copy">Can you add some other examples? Can <code>/</code> appear anywhere in the word, e.g., <code>/moose</code> or <code>moose/</code>? Can the restricted symbols appear more than once? Can they co-occur?</span>
<span class="comment-copy">Yes, anywhere and they can occur more than once. I will improve the example shortly. @inspectorG4dget stripping away special chars, grouping them with exact match (maybe allowing space) may help. Thinking about it.</span>
<span class="comment-copy">How about making a defaultdict(list) where keys are filtered words and values are lists of words?</span>
<span class="comment-copy">@inspectorG4dget I think your solution is simple and makes sense with exact matching. Levenshtein may not be needed at all in that case. @.hello_world, you are thinking about a similar solution as I understand.</span>
<span class="comment-copy">Nice one, it works! I will wait a bit to see a if more of a non-exact solution comes along. Thank you.</span>
<span class="comment-copy">Looks like there is no other way around as example I provided even ignores  a single letter difference, so this should be the accepted answer.</span>
<span class="comment-copy">It's interesting, but the complexity with an extra dict is totally unneeded. You use <code>sort</code> with a <code>key</code>. Why not use it with <code>lambda string: restricted.sub('', string)</code> directly?</span>
<span class="comment-copy">@EricDuminil I agree and more generally I concede that the accepted answer is much more elegant and accomplishes everything the OP wants in a single pass :-)</span>
<span class="comment-copy">I'm not sure the accepted answer is a single pass : it needs to iterate over every <code>alpha</code> char for every <code>item</code> in <code>words</code>. For your solution, I was just saying that <code>1</code> and <code>2</code> are unneeded.</span>
