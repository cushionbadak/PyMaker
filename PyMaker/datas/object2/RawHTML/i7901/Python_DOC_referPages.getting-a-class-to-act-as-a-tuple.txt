<div class="post-text" itemprop="text">
<p>I'm trying to have a class act in every way like a tuple that's an attribute of the class, so len(instance) would be the same as len(instance.tup), instance[3] would return instance.tup[3], etc. Here's the class:</p>
<pre><code>class mytup(object):
     def __init__(self, a):
         self.tup = tuple(a)
     def __getattr__(self, nm):
         f = types.MethodType(lambda self:getattr(self.tup, nm)(), self, type(self))
         f.__func__.func_name = nm
         setattr(self, nm, f)
         return f
</code></pre>
<p>I can</p>
<pre><code>mt = mytup(range(10))
</code></pre>
<p>But if I try to:</p>
<pre><code>In [253]: len(mt)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-253-67688b907b8a&gt; in &lt;module&gt;()
----&gt; 1 len(mt)

TypeError: object of type 'mytup' has no len()
</code></pre>
<p>mt does in fact have a __len__ that I can call:</p>
<pre><code>In [254]: mt.__len__
Out[254]: &lt;bound method mytup.__len__ of &lt;__main__.mytup object at 0x2e85150&gt;&gt;
In [255]: mt.__len__()
Out[255]: 10
</code></pre>
<p>(I even renamed it __len__). As near as I can tell, this should look just as if I did:</p>
<pre><code>def __len__(self, *a):
    return self.tup.__len__(*a)
</code></pre>
<p>But python won't let me len(mt) (or mt[2] or mt [1:5] for that matter).</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason this isn't working as you have hoped is because doing:</p>
<pre><code>setattr(self, nm, f)
</code></pre>
<p>Is <em>not equivalent</em> to </p>
<pre><code>def __len__(self, *a):
    return self.tup.__len__(*a)
</code></pre>
<p>In the latter case, your method is a property of <em>the class</em> because it is defined in <em>class scope</em>. It would be the equivlanet of <code>setattr(cls, nm, f)</code>. If you check <code>MyTup.__dict__</code> you will see it there. However, in the former case, <code>__len__</code> is a property of the <em>instance</em>. So it will be in <code>my_instance.__dict__</code>. <code>len</code> checks the class for a <code>__len__</code> method, and doesn't find one. Hence the error. Your <code>__getattr__</code> is never actually called, and even if it were, it wouldn't allow you to use <code>len</code>. You <em>can</em> use <code>an_instanec.__len__</code> diretly, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>New-style classes look-up "special methods"—those that start and end with two underscore characters—on an instance's <strong>class</strong> not the instance involved, so when <code>len()</code> is called it tries to call <code>typeof(mt).__len__()</code>. So the proper way to do what you want would be to use one of the <a href="https://docs.python.org/3/library/collections.abc.html#module-collections.abc" rel="nofollow noreferrer">Abstract Base Classes for Containers</a> in the <code>collections</code> module (since Python 3.3)</p>
<pre><code>import collections

class MyTuple(collections.Sequence):
    def __init__(self, a):
        self.tup = tuple(a)

    def __len__(self):
        return len(self.tup)

    def __getitem__(self, index):
        return self.tup[index]

    def __getattr__(self, nm):
        f = types.MethodType(lambda self: getattr(self.tup, nm)(), self, type(self))
        f.__func__.func_name = nm
        setattr(self, nm, f)
        return f

mt = MyTuple(range(10))
print(len(mt))  # -&gt; 10
print(mt[4])  # -&gt; 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>len</code> does not use <code>__getattr__</code> to get the <code>__len__</code> function - it calls <code>__len__</code> directly.</p>
<p>Calling <strong><code>x.__len__</code></strong> is like calling <code>getattr(x, '__len__')</code> - which will return the <code>x.__len__</code> method object.</p>
<p><strong><code>len</code></strong> works behind the scene, so it can access this method directly, without invoking the <code>__getattr__</code> helper.</p>
<ul>
<li>Try to add a print statement in your <code>__getattr__</code> to see what is printed when calling <code>len</code> (hint: nothing). </li>
</ul>
</div>
<span class="comment-copy">Just a question, why do you need this?</span>
<span class="comment-copy">why don't you inherit everything from the <code>tuple</code> class then?</span>
<span class="comment-copy">Can you just use a <code>namedtuple</code> from the collections module?</span>
<span class="comment-copy">Here is a link to the documentation: <a href="https://docs.python.org/3.5/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">docs.python.org/3.5/library/…</a></span>
<span class="comment-copy">Heck, why aren't you just using a tuple? The best way to get something that behaves in every way like a tuple is to use a tuple.</span>
<span class="comment-copy">Thanks. That explains why it's failing. Can you suggest a solution?</span>
<span class="comment-copy">@mlv don't try to reinvent inheritance? Use a <code>nametuple</code>? I don't know. What exactly are you trying to accomplish? I assumed you were trying to figure out more about Python internals. Why not inherit from <code>tuple</code>?</span>
<span class="comment-copy">Yes, I do want to learn more about python internals. That's the main thing that drove this Quixotic quest. That and not wanting to define wrapper methods for every tuple method.</span>
<span class="comment-copy">I ended up just defining 6 methods, <code>__hash__</code>, <code>__repr__</code>, <code>__cmp__</code>, <code>__iter__</code>, <code>__len__</code>, and <code>__getitem__</code> (probably didn't need <code>__iter__</code>, but it made things faster).</span>
