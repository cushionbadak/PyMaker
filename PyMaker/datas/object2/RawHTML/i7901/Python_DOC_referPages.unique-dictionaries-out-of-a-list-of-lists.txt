<div class="post-text" itemprop="text">
<p>I have a list called <code>matrix</code> which contains some rows. Each <code>row</code> contains some dictionaries, and each dictionary could be contained in more than one row.</p>
<p>I want to generate a list called <code>dictionaries</code> which contains all the dictionaries in the matrix, but <strong>without duplicates</strong>. I already have a solution, but I would like to use comprehension.</p>
<pre><code>row1 = [{'NODE':1}, {'NODE':2}, {'NODE':3}]
row2 = [{'NODE':3}, {'NODE':4}, {'NODE':5}]
row3 = [{'NODE':4}, {'NODE':6}, {'NODE':7}]
matrix = [row1, row2, row3]

dictionaries = []
for row in matrix:
    for dictionary in row:
        items.append(dictionary) if dictionary not in dictionaries else None

print dictionaries
[{'NODE':1}, {'NODE':2}, {'NODE':3}, {'NODE':4}, {'NODE':5}, {'NODE':6}, {'NODE':7}]
</code></pre>
<p>I would like something like the following but it doesn't work since I cannot ask to check a list while I'm creating it:</p>
<pre><code>dictionaries = [dictionary for row in matrix for dictionary in row if dictionary not in dictionaries]
</code></pre>
<p>The dictionary keys and values are primitive immutable objects like strings and integers. </p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a list comprehension, but depending on your Python version, using an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code> object</a> with a generator expression to flatten the matrix would actually be more efficient.</p>
<p>When your values are <em>not hashable</em> and thus can't be stored in a set or dictionary, you'll have to use first create an immutable representation, so we can store that representation in a set or dictionary to efficiently track uniqueness.</p>
<p>For dictionaries that are flat structures with all keys and values immutable, just use <code>tuple(sorted(d.items()))</code>. This produces a tuple of all <code>(key, value)</code> pairs (also tuples), in sorted order to avoid dictionary order issues.</p>
<p>On Python 3.5 and up, use an <code>OrderedDict()</code> that maps the immutable keys to original dictionaries:</p>
<pre><code>from collections import OrderedDict

key = lambda d: tuple(sorted(d.items()))

dictionaries = list(OrderedDict((key(v), v) for row in matrix for v in row).values())
</code></pre>
<p>On Python 3.4 and earlier, <code>OrderedDict</code> is slow and you'd be beter of using a separate set approach for Python 3.4 and below:</p>
<pre><code>key = lambda d: tuple(sorted(d.items()))
seen = set()
seen_add = seen.add
dictionaries = [
    v for row in matrix
    for k, v in ((key(v), v) for v in row)
    if not (k in seen or seen_add(k))]
</code></pre>
<p>Quick demo using your input data and an <code>OrderedDict</code>:</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; row1 = [{'NODE':1}, {'NODE':2}, {'NODE':3}]
&gt;&gt;&gt; row2 = [{'NODE':3}, {'NODE':4}, {'NODE':5}]
&gt;&gt;&gt; row3 = [{'NODE':4}, {'NODE':6}, {'NODE':7}]
&gt;&gt;&gt; matrix = [row1, row2, row3]
&gt;&gt;&gt; key = lambda d: tuple(sorted(d.items()))
&gt;&gt;&gt; list(OrderedDict((key(v), v) for row in matrix for v in row).values())
[{'NODE': 1}, {'NODE': 2}, {'NODE': 3}, {'NODE': 4}, {'NODE': 5}, {'NODE': 6}, {'NODE': 7}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have NumPy:</p>
<pre><code>np.unique(matrix).tolist()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Flatten the list, then use a set to eliminate dupes.</p>
<pre><code>print set(item for sublist in matrix for item in sublist)
</code></pre>
</div>
<span class="comment-copy">Does order matter?</span>
<span class="comment-copy">no it doesn't matter</span>
<span class="comment-copy">So your items are <i>mutable</i> and so can't be hashed. Does the mutability <i>extend to nested values</i>? E.g. <code>{'NODE': {'set', 'with', 'elements'}}</code>? Or are all keys and values immutable?</span>
<span class="comment-copy">no, it is not extended to nested values</span>
<span class="comment-copy">thanks, actually my problem was a bit more complicated, so I updated my question since it still doesn't work</span>
<span class="comment-copy">@piezzoritro: right, so your items are <i>mutable</i>. That's still something we can fix.</span>
<span class="comment-copy">Thanks! you solved it.</span>
<span class="comment-copy">The goal posts have moved: the matrix rows contain <i>dictionaries</i>. Will numpy still handle that case efficiently?</span>
<span class="comment-copy">Just tested this and no, <code>np.unique()</code> wants to <i>order</i> the elements and that results in a <code>TypeError: '&gt;' not supported between instances of 'dict' and 'dict'</code> exception.</span>
<span class="comment-copy">Good point, thanks. I've removed the <code>[..]</code>. Is that what the downvote was for?</span>
<span class="comment-copy">It was; thanks for updating! Any reason you are not using a <code>{...}</code> set comprehension here?</span>
<span class="comment-copy">Since the rows contain dictionaries, I get an error TypeError: unhashable type: 'dict'</span>
<span class="comment-copy">Note that the goalposts have moved; the OP updated the problem, they have <i>unhashable dictionaries</i> in their matrix.</span>
