<div class="post-text" itemprop="text">
<p>While reading <em>Python 101</em> by <em>Michael Driscoll</em> I got to his explanation on checking if a key exists in a dictionary. I checked it on my machine with a dictionary containing keys <code>'a'</code> to <code>'z'</code> where the value is their order, and a function that measures time on retrieving the key <code>'t'</code> (picked it at random)</p>
<p>Here's my function:</p>
<pre><code>def f(d, flag):
start_time = time.time()
if flag:
    print("t" in d)
else:
    print("t" in d.keys())
print("--- %s seconds ---" % (time.time() - start_time))
</code></pre>
<p>And here are the results:</p>
<pre><code>&gt;&gt;&gt; f(dict,True)
True
--- 0.03937530517578125 seconds ---

&gt;&gt;&gt; f(dict,False)
True
--- 0.05114388465881348 seconds ---
</code></pre>
<p>BUT, I still don't get it. I thought that <code>key in dict.keys()</code> would result in iteration on much smaller collection, which will be faster. Is there something special in the implementation of <code>in</code> or <code>keys()</code> that causes this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>dictionary.keys()</code> is slower because it does <em>more work</em>:</p>
<ul>
<li>It adds an attribute lookup; <code>dictionary.keys</code></li>
<li>It adds a method call (<code>keys()</code>), requiring the current call frame to be pushed onto the stack, and popped afterwards.</li>
<li>Another object has to be created for the return value (a dictionary view). It's a light-weight object, but you still need to allocate memory for it on the heap.</li>
</ul>
<p>None of this is needed, because a containment test against the dictionary and the dictionary view on the keys test <em>the exact same thing</em>. Containment testing directly on a dictionary does not include the values, you are testing for keys <em>only</em>, in both cases.</p>
<p>From the <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="nofollow noreferrer"><code>dict()</code> object documentation</a>:</p>
<blockquote>
<p><code>key in d</code><br/>
  Return <code>True</code> if <em>d</em> has a key <em>key</em>, else <code>False</code>.</p>
</blockquote>
<p>Note that using walk-clock time is not a great way of testing for performance differences. Use the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code> module</a> instead, which picks the best performing timer, disables the GC to eliminate a source of skew, and repeats the test many times to minimise system skew.</p>
<p>You can reproduce the time difference by testing for the additional steps above separately (combining the call and object creation into one). By default <code>timeit.timet()</code> repeats the test 1 million times and returns the total time taken:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; from string import ascii_lowercase
&gt;&gt;&gt; d = {l: i for i, l in enumerate(ascii_lowercase)}
&gt;&gt;&gt; 't' in d
True
&gt;&gt;&gt; timeit.timeit('d.keys', globals={'d': d})
0.0439452639548108
&gt;&gt;&gt; timeit.timeit('keys()', globals={'keys': d.keys})
0.06267352704890072
</code></pre>
<p>So merely looking up the <code>.keys</code> attribute 1 million times already takes 44 milliseconds, while calling the method (without attribute lookup) adds another 63ms. Both methods have some overhead for looking up the global name however:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('d', globals={'d': d})
0.027833244064822793
</code></pre>
<p>So one would expect there to be a 107 - 28 == 79ms (roughly) difference between the two methods.</p>
<p>And indeed, the time difference between using <code>'t' in d</code> and <code>'t' in d.keys()</code> is about that much:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('"t" in d.keys()', globals={'d': d})
0.11647015693597496
&gt;&gt;&gt; timeit.timeit('"t" in d', globals={'d': d})
0.0370339349610731
</code></pre>
<p>116 - 37 is 79 milliseconds, as predicted.</p>
</div>
<span class="comment-copy">Because you need to create an additional object first.</span>
<span class="comment-copy">But why downvoted?</span>
<span class="comment-copy">Why did you think that <code>dict.keys()</code> would test against a smaller collection? What would that collection not include that <code>key in dict</code> would?</span>
<span class="comment-copy">I thought that dict is a collection of pairs and I will search each pair instead of searching a list of one-item-object, and that accessing the pair would also cost CPU time. Moreover I thought that returning keys would be a small and fast operation</span>
<span class="comment-copy">Note that if you were using Python 2, the timings would be much more different <a href="https://stackoverflow.com/questions/24540975/why-does-key-in-d-keys-finish-in-on-time-while-key-in-d-finishes-in-o1" title="why does key in d keys finish in on time while key in d finishes in o1">stackoverflow.com/questions/24540975/…</a> and could be a dupe of this (see the Python 3 relevant part: <a href="https://stackoverflow.com/questions/17539367/python-dictionary-keys-in-complexity" title="python dictionary keys in complexity">stackoverflow.com/questions/17539367/…</a>)</span>
