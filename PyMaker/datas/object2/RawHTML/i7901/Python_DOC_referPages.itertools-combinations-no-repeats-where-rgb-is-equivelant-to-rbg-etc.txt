<div class="post-text" itemprop="text">
<p>I'm trying to use <code>itertools.combinations</code> to return unique combinations. I've searched through several similar questions but have not been able to find an answer.</p>
<p>An example:
</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; e = ['r','g','b','g']
&gt;&gt;&gt; list(itertools.combinations(e,3))
[('r', 'g', 'b'), ('r', 'g', 'g'), ('r', 'b', 'g'), ('g', 'b', 'g')]
</code></pre>
<p>For my purposes, (r,g,b) is identical to (r,b,g) and so I would want to return only (rgb),(rgg) and (gbg).</p>
<p>This is just an illustrative example and I would want to ignore all such 'duplicates'. The list e could contain up to 5 elements. Each individual element would be either r, g or b. Always looking for combinations of 3 elements from <code>e</code>.</p>
<p>To be concrete, the following are the only combinations I wish to call 'valid': (rrr), (ggg), (bbb), (rgb).</p>
<p>So perhaps the question boils down to how to treat any variation of (rgb) as equal to (rgb) and therefore ignore it.</p>
<p>Can I use <code>itertools</code> to achieve this or do I need to write my own code to drop the 'dupliates' here? If no itertools solution then I can just easily check if each is a variation of (rgb), but this feels a bit 'un-pythonic'.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to your definition of "valid outputs", you can directly build them like this:</p>
<pre><code>from collections import Counter

# Your distinct values
values = ['r', 'g', 'b']

e = ['r','g','b','g', 'g']

count = Counter(e)
# Counter({'g': 3, 'r': 1, 'b': 1})

# If x appears at least 3 times, 'xxx' is a valid combination  
combinations = [x*3 for x in values if count[x] &gt;=3]

# If all values appear at least once, 'rgb' is a valid combination
if all([count[x]&gt;=1 for x in values]):
    combinations.append('rgb')

print(combinations)
#['ggg', 'rgb']
</code></pre>
<p>This will be more efficient than creating all possible combinations and filtering the valid ones afterwards.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <code>set</code> to discard duplicates. </p>
<p>In your case the number of characters is the way you identify duplicates so you could use <code>collections.Counter</code>. In order to save them in a <code>set</code> you need to convert them to <code>frozenset</code>s though (because <code>Counter</code> isn't hashable):</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; e = ['r','g','b','g']
&gt;&gt;&gt; result = []
&gt;&gt;&gt; seen = set()
&gt;&gt;&gt; for comb in itertools.combinations(e,3):
...     cnts = frozenset(Counter(comb).items())
...     if cnts in seen:
...         pass
...     else:
...         seen.add(cnts)
...         result.append(comb)
&gt;&gt;&gt; result
[('r', 'g', 'b'), ('r', 'g', 'g'), ('g', 'b', 'g')]
</code></pre>
<p>If you want to convert them to strings use:</p>
<pre><code>result.append(''.join(comb))  # instead of result.append(comb)
</code></pre>
<p>and it will give:</p>
<pre><code>['rgb', 'rgg', 'gbg']
</code></pre>
<p>The approach is a variation of the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>unique_everseen</code> recipe (itertools module documentation)</a> - so it's probably "quite pythonic".</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not completely clear what you want to return. It depends on what comes first when iterating. For example if <code>gbr</code> is found first, then <code>rgb</code> will be discarded as a duplicate:</p>
<pre><code>import itertools

e = ['r','g','b','g']       
s = set(e)
v = [s] * len(s)

solns = []

for c in itertools.product(*v):
    in_order = sorted(c)
    if in_order not in solns:
        solns.append(in_order)

print solns  
</code></pre>
<p>This would give you:</p>
<pre><code>[['r', 'r', 'r'], ['b', 'r', 'r'], ['g', 'r', 'r'], ['b', 'b', 'r'], ['b', 'g', 'r'], ['g', 'g', 'r'], ['b', 'b', 'b'], ['b', 'b', 'g'], ['b', 'g', 'g'], ['g', 'g', 'g']]
</code></pre>
</div>
<span class="comment-copy">So, why don't you simply choose one among your four valid outputs?</span>
<span class="comment-copy">Sorry if not clear but I want to return all valid combinations subject to what I consider 'valid' as noted in the question.</span>
<span class="comment-copy">And what about <code>rrb</code> <code>rrg</code> etc..? Also if you're sure that your only valid outputs are <code>rrr</code>, <code>ggg</code>, <code>bbb</code> and <code>rgb</code> well then just output them, there's nothing to calculate?</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/36254303/how-many-different-ways-to-fill-n-number-bins-with-b-number-of-balls">See this question.</a> Consider <code>r</code>, <code>g</code>, and <code>b</code> to be the bins with a capacity equal to their counts. Then, apply the algorithm in the accepted answer.</span>
<span class="comment-copy">Thank you for this. Whilst it didn't produce what I was looking for, the technique was new to me and your link was insightful so +1.</span>
