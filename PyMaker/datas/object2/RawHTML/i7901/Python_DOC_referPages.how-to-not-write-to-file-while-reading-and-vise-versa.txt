<div class="post-text" itemprop="text">
<p>I have a <code>python</code> program (say <code>reader.py</code>) which uses file <code>setting.py</code> to read from:</p>
<pre><code>while( True ):
  ...
  execfile( settings.py )
  ...
</code></pre>
<p>But there is other <code>python</code> program (say <code>writer.py</code>) that uses this file to write to:</p>
<pre><code>...
try:
  settings = open('settings.py', 'w')
  settings.truncate()
  settings.write( 'some text')
except IOError:
  print('Cannot write to file')
finally:
  settings.close()
...
</code></pre>
<p><strong>Note1:</strong> <code>reader.py</code> and <code>writer.py</code> do not ''know'' about each other.</p>
<p><strong>Note2:</strong> <code>reader.py</code> reads <code>settings.py</code> cyclically, though <code>writer.py</code> writes to file when user wants to (not necessarily right after he/she clicked ''write'', it just means that there is no any rule when to write).</p>
<p><strong>Question:</strong> What is <em>the best</em> way to cooperate two programs in order to avoid any contradiction? I know this might depend on platform. I am using Linux. Distributions are: Ubuntu, Scientific Linux.</p>
<p><strong>EDIT1</strong>: If I choose to use <code>FiFo</code> I encounter the following problem: <em>Once writer has write to <code>settings</code> file it will probably never write again but reader should have access to <code>settings</code> anyway in this case. In other words, reader should have an ability to read from file and not to wait for writer in this case. Otherwise reader has to wait for writer.</em>
Ordinary using of <code>FiFo</code> does not allow reader to read from file if writer does not write (until it has written). How to deal with this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p><br/>
    You may be interested in using a named pipe for your interprocess communications. Available in Linux, it is a special type of file designed for client (writer.py), server (reader.py), tasks. After writing to the pipe, the client will wait until the server has received the data. This allows you to sync the two processes somewhat.</p>
<p><a href="https://linux.die.net/man/4/fifo" rel="nofollow noreferrer">Linux Manual for FiFo</a><br/>
<a href="https://docs.python.org/2/library/os.html" rel="nofollow noreferrer">Python doc: os.mkfifo(path[, mode])</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I found the following solution which seems to be working. I use <code>flock</code> to create locks.</p>
<p><code>Reader</code>:</p>
<pre><code>import errno                                                                                    
import fcntl
from time import *

path = "testLock.py"

f = open(path, "r")

while True: 
  try:
    fcntl.flock(f, fcntl.LOCK_EX | fcntl.LOCK_NB)
    break   
  except IOError as e:
    if e.errno != errno.EAGAIN:
    raise 
  else:   
    sleep(1)
    print 'Waiting...'

#reader's action      
execfile(path)  
#drop lock          
fcntl.flock(f, fcntl.LOCK_UN)
</code></pre>
<p><code>Writer</code>:</p>
<pre><code>import errno                                                                                    
import fcntl
from time import *

path = "testLock.py"

f = open(path, "w")

while True: 
  try:
    fcntl.flock(f, fcntl.LOCK_SH | fcntl.LOCK_NB)
    break   
  except IOError as e:
    if e.errno != errno.EAGAIN:
    raise 
  else:   
    sleep(1)
    print 'Waiting...'

#writer's action      
for i in (1,10,2):
  f.write('print "%d" % i')
  sleep(1)  
#drop lock          
fcntl.flock(f, fcntl.LOCK_UN)
</code></pre>
<p>I have some question here:</p>
<p><strong>Qusetion 1</strong>: Is it correct usage of <code>LOCK_EX</code> and <code>LOCK_SH</code> I mean are they in the right place?</p>
<p><strong>Question 2</strong>: Is the reader's action i.e <code>execfile</code> correct here? If the file is already opened is <code>execfile</code> try to open it anyway?</p>
</div>
<span class="comment-copy">If you need to run the two scripts in parallel while ensuring that the reading / writing doesn't happen simultaneously, you can try using <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">multiprocessing</a>, create separated threads and join them.</span>
<span class="comment-copy">You might want to write to <code>settings_new.py</code>, then once your write is complete, move <code>settings_new.py</code> to <code>settings.py</code> (overwriting it). I think this should create an atomic 'update' to the file - many applications such as text editors take this approach.</span>
<span class="comment-copy">Your suggestion was helpful but I do not know how to do this: when <i>reader</i> open FIFO I want <i>writer</i> to wait. And vise-versa. But If <i>writer</i> is not writing at current moment to FIFO <i>reader</i> <b>should not</b> wait until <i>writer</i> is ready.</span>
