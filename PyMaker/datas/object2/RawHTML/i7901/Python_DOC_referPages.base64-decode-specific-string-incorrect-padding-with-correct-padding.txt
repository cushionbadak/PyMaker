<div class="post-text" itemprop="text">
<p>I am trying to Base64 decode a string (into bytes) using Python's base64.b64decode(str) method:</p>
<blockquote>
<p>46oWrWpy2gTEGwNnN6Ayy</p>
</blockquote>
<p>and I am ensuring it has a multiple of 4 ='s for padding or out of frustration any of these:</p>
<blockquote>
<p>46oWrWpy2gTEGwNnN6Ayy=</p>
<p>46oWrWpy2gTEGwNnN6Ayy==</p>
<p>46oWrWpy2gTEGwNnN6Ayy===</p>
<p>46oWrWpy2gTEGwNnN6Ayy==================================================</p>
</blockquote>
<p>and yet I still get "Incorrect Padding" on Python v3.6.1. Other strings are fine.</p>
<p>I show a colleague, he tries on Python 2 and observes the same response.</p>
<p>I note removing the first "4" is enough to ensure the Base64 decode works.</p>
<p>I have skim read <a href="https://docs.python.org/3/library/base64.html" rel="nofollow noreferrer">Python's docs</a> (noting casefold doesn't apply for Base64) and haven't yet ventured further into <a href="https://tools.ietf.org/html/rfc3548.html" rel="nofollow noreferrer">RFC3548</a> but wondered if someone else had encountered something similar before. Anyone have any clues :)? Surely this can't be a bug in Python's Base64 decoder?</p>
</div>
<div class="post-text" itemprop="text">
<p>Worked it out.</p>
<p>Each character of Base64 text is 6 bits of the raw's 8 bits. If a character is mid-way through the raw's bytes then you are missing some remaining bits. The Wikipedia article (and many online answers) seems to use padding as interchangeable for a '0' byte which is not the case (in the Base64 dictionary it should be encoded as an A).</p>
<p>Padding is not interchangeable for missing data.</p>
<pre><code>#!/usr/bin/env python3

# We use hexlify for debugging.
import binascii

# We use the Base64 library.
import base64

# Base64 works on multiples of 4 characters..
# ..Sometimes we get 3/2/1 characters and it might be midway through another.
def relaxed_decode_base64(data):

 # If there is already padding we strim it as we calculate padding ourselves.
 if '=' in data:
  data = data[:data.index('=')]

 # We need to add padding, how many bytes are missing.
 missing_padding = len(data) % 4

 # We would be mid-way through a byte.
 if missing_padding == 1:
  data += 'A=='
 # Jut add on the correct length of padding.
 elif missing_padding == 2:
  data += '=='
 elif missing_padding == 3:
  data += '='

 # Actually perform the Base64 decode.
 return base64.b64decode(data)

# Debugging
print(str(relaxed_decode_base64('46oWrWpy2gTEGwNnN6Ayy')) + '\n')

testString = ''

for count in range(0, 1024):
 testString += '/'
 print(str(len(testString)) + ' - ' + testString)
 print(binascii.hexlify(relaxed_decode_base64(testString)))
 input()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Seems to be a problem in your data, not related to Python:</p>
<pre><code>$ echo 46oWrWpy2gTEGwNnN6Ayy | base64 -d
ãª­jrÚÄg7 2base64: invalid input
$ echo 46oWrWpy2gTEGwNnN6Ayy= | base64 -d
ãª­jrÚÄg7 2base64: invalid input
$ echo 46oWrWpy2gTEGwNnN6Ayy== | base64 -d
ãª­jrÚÄg7 2base64: invalid input
$ echo 46oWrWpy2gTEGwNnN6Ayy=== | base64 -d
ãª­jrÚÄg7 2base64: invalid input
$ echo 46oWrWpy2gTEGwNnN6Ayy==== | base64 -d
ãª­jrÚÄg7 2base64: invalid input
</code></pre>
<p>I managed to decode it this way (removed the last 'y'):</p>
<pre><code>$ echo 46oWrWpy2gTEGwNnN6Ay | base64 -d
ãª­jrÚÄg7 2
</code></pre>
</div>
