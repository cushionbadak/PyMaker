<div class="post-text" itemprop="text">
<p>Python's namedtuple can be really useful as a lightweight, immutable data class. I like using them for bookkeeping parameters rather than dictionaries. When some more functionality is desired, such as a simple docstring or default values, you can easily refactor the namedtuple to a class. However, I've seen classes that inherit from namedtuple. What functionality are they gaining, and what performance are they losing? For example, I would implement this as</p>
<pre><code>from collections import namedtuple

class Pokemon(namedtuple('Pokemon', 'name type level')):
    """
    Attributes
    ----------
    name : str
        What do you call your Pokemon?
    type : str
        grass, rock, electric, etc.
    level : int
        Experience level [0, 100]
    """
     __slots__ = ()
</code></pre>
<p>For the sole purpose of being able to document the attrs cleanly, and <code>__slots__</code> is used to prevent the creation of a <code>__dict__</code> (keeping the lightweight nature of namedtuples).</p>
<p>Is there a better recommendation of a lightweight data class for documenting parameters? Note I'm using Python 2.7.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>NEW UPDATE:</strong></p>
<p>In python 3.6+, you can use the new typed syntax and create a <code>typing.NamedTuple</code>. The new syntax supports all the usual python class creation features (docstrings, multiple inheritance, default arguments, methods, etc etc are available as of 3.6.1):</p>
<pre><code>import typing

class Pokemon(MyMixin, typing.NamedTuple):
    """
    Attributes
    ----------
    name : str
        What do you call your Pokemon?
    type : str
        grass, rock, electric, etc.
    level : int
        Experience level [0, 100]
    """
    name: str
    type: str
    level: int = 0 # 3.6.1 required for default args

    def method(self):
        # method work
</code></pre>
<p>The class objects created by this version are mostly equivalent to the original <code>collections.namedtuple</code>, <a href="https://docs.python.org/3/library/typing.html" rel="noreferrer">except for a few details</a>.</p>
<p>You can also use the same syntax as the old named tuple:</p>
<pre><code>Pokemon = typing.NamedTuple('Pokemon', [('name', str), ('type', str), ('level', int)])
</code></pre>
<p><strong>Original Answer</strong></p>
<hr/>
<p>Short answer: <a href="https://stackoverflow.com/questions/1606436/adding-docstrings-to-namedtuples">no, unless you are using Python &lt; 3.5</a></p>
<p>The <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="noreferrer">P3 docs</a> seem to imply pretty clearly that unless you need to add calculated fields (i.e., descriptors), subclassing <code>namedtuple</code> is not considered the canonical approach. This is because you can update the docstrings directly (they are now writable as of 3.5!). </p>
<blockquote>
<p>Subclassing is not useful for adding new, stored fields. Instead, simply create a new named tuple type from the <code>_fields</code> attribute...</p>
<p>Docstrings can be customized by making direct assignments to the <code>__doc__</code> fields...</p>
</blockquote>
<p>UPDATE:</p>
<p>There are now a couple other compelling possibilities for lightweight data classes in the latest versions of Python.</p>
<p>One is <a href="https://docs.python.org/3/library/types.html#additional-utility-classes-and-functions" rel="noreferrer"><code>types.SimpleNamespace</code> (Python 3.3 and later)</a>. It is not structured like <code>namedtuple</code>, but structure isn't always necessary.</p>
<p>One thing to note about <code>SimpleNamespace</code>: by default it is required to explicitly designate the field names when instantiating the class. This can be got around fairly easily, though, with a call to <code>super().__init__</code>:</p>
<pre><code>from types import SimpleNamespace

class Pokemon(SimpleNamespace):
    """
    Attributes
    ----------
    name : str
        What do you call your Pokemon?
    type : str
        grass, rock, electric, etc.
    level : int
        Experience level [0, 100]
    """
    __slots__ = ("name", "type", "level")
    # note that use of __init__ is optional
    def __init__(self, name, type, level):
        super().__init__(name=name, type=type, level=level)
</code></pre>
<p>Another intriguing option- <a href="https://www.python.org/downloads/release/python-370a4/" rel="noreferrer">which will be available as of Python 3.7</a> (not yet released)- <a href="https://www.python.org/dev/peps/pep-0557/" rel="noreferrer">is <code>dataclasses.dataclass</code> (see PEP 557)</a>:</p>
<pre><code>from dataclasses import dataclass

@dataclass
class Pokemon:
    __slots__ = ("name", "type", "level")
    name: str  # What do you call your Pokemon?
    type: str  # grass, rock, electric, etc.
    level: int = 0  # Experience level [0, 100]
</code></pre>
<p>Note that both of these suggestions are mutable by default, and that <code>__slots__</code> is not required for either one.</p>
</div>
<span class="comment-copy">See also this post on alternative data containers <a href="https://stackoverflow.com/a/47784683/4531270">stackoverflow.com/a/47784683/4531270</a>, i.e. <code>NamedTuple</code> and dataclasses.</span>
