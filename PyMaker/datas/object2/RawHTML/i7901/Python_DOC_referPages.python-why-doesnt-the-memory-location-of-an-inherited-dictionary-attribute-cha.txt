<div class="post-text" itemprop="text">
<p>So I have a parent class called User_1, and User_1's init method looks like this:</p>
<pre><code>class User_1(object):
    def __init__(self, user_id, bio="", likes=0, uploads={}, follows=0, dateJoined=None, accountType=""):
        self.user_id = user_id
        self.bio = bio
        self.likes = likes
        self.uploads = uploads
        self.follows = follows
        self.dateJoined = dateJoined
        self.accountType = accountType
        self.comments = []
        self.responseCommentsCount = 0
</code></pre>
<p>I then have a class that inherits from the User_1 class called TrendingUsers, and it's init method looks like this:</p>
<pre><code>class TrendingUser(User_1):
    def __init__(self, user_id):
        User_1.__init__(self, user_id)

        self.averageTSWords = 0.0
        self.averageSSWords = 0.0
        self.percOfClipTitlesUntitled = 0.0
        self.percOfClipsWithCaptions = 0.0
        self.percOfClipsWithTags = 0.0
        self.percOfClipsWithComments = 0.0
        self.percOfPurgatoryClips = 0.0
        self.averageTimeDifferenceBetweenUploaded = 0.0
</code></pre>
<p>I create several instances of the TrendingUser class and store them in a dictionary like so:</p>
<pre><code>for user_id in user_ids:
    dic[user_id] = TrendingUser(user_id)
</code></pre>
<p>Now when I check the memory address of the various instances of TrendingUser using the id() function, I get different values. However, when I check the memory address of the all inherited attributes of each TrendingUser instance, I get the same value across the instances, except for the comments attribute (the list). </p>
<p>A side question: Why is this the case?</p>
<p>The real question is that when I edit one of the inherited attributes of a TrendingUser instance, for example updating the bio, the memory address changes, and only that instance's bio has been updated. This is not the case with the uploads attribute, which is a dictionary. When I insert a key-value pair into what I believe is the uploads attribute of a single TrendingUser instance, it adds the key-value pair to all TrendingUser instances' uploads attribute. When I check if the memory address of the uploads attribute changed after inserting the key-value pair, I realize that it hasn't, which explains the behavior. </p>
<p>I was wondering why is this the case with dictionaries, but not other variable types (I have tried similar exercises with the various inherited attributes), and how to get around this problem when inheriting from a Parent class that has a dictionary attribute you would like to use? I.e. I only want to update one instance's inherited uploads attribute at a time, not all of them at once.</p>
<p>Any help on this matter would be greatly appreciated. Thank you. </p>
<p>EDIT:</p>
<p>This might help:</p>
<p>Before doing anything:</p>
<pre><code>('user_id', 'memory_address_uploads_attribute', 'memory_address_comments_attribute', 'memory_address_bio_attribute', 'memory_address_follows_attribute')
(66809143, 4446746056, 4458480848, 4441785608, 140675510194976)
(60284557, 4446746056, 4458480560, 4441785608, 140675510194976)
(11299389, 4446746056, 4458667400, 4441785608, 140675510194976)
</code></pre>
<p>After changing the bio of TrendingUser with user_id = 11299389</p>
<pre><code>(66809143, 4446746056, 4458480848, 4441785608, 140675510194976)
(60284557, 4446746056, 4458480560, 4441785608, 140675510194976)
(11299389, 4446746056, 4458667400, 4458804640*, 140675510194976)
</code></pre>
<ul>
<li>the memory address changed</li>
</ul>
<p>After adding a key-value to the uploads attribute of TrendingUser with user_id = 11299389</p>
<pre><code>(66809143, 4446746056*, 4458480848, 4441785608, 140675510194976)
(60284557, 4446746056*, 4458480560, 4441785608, 140675510194976)
(11299389, 4446746056*, 4458667400, 4458804640, 140675510194976)
</code></pre>
<ul>
<li>no change, and now all uploads attributes of the thee TrendingUser instances have the inserted key-value pair</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In Python, the rule is "once created, an object never moves".</p>
<p>That rule refers to the head of the object (the part whose address you see in CPython when calling <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer"><em>id()</em></a>).  Internally, mutable container points to the variable length port of the data.  As you suspected, the location of that data can move around as more data gets added.</p>
<p>For an overview of how Python dicts work, see my recent <a href="https://www.youtube.com/watch?v=npw4s1QTmPg" rel="nofollow noreferrer">PyCon talk</a> and the related <a href="https://dl.dropboxusercontent.com/u/3967849/compdict/_build/html/index.html" rel="nofollow noreferrer">slides</a>.  To better understand the object model, see <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Ned Batchelder's blog post</a>.</p>
<p>A key point is that "python containers don't contain anything", they just have references to existing objects.  In the case of <em>TrendingUser</em> the underlying instance dictionaries point to the same attribute values (constants created when the method definition was built).</p>
<p>As you update the values, for instances of TrendingUsers, the memory location will point to the new values you've inserted and they will not be that same addresses as the default values (remember, that once created, those objects will never move).</p>
<p>Hope that adds a little clarity :-)</p>
<p>See this <a href="http://pythontutor.com/visualize.html#code=class%20TrendingUser%28object%29%3A%0A%20%20%20%20def%20__init__%28self,%20user_id%29%3A%0A%20%20%20%20%20%20%20%20self.user_id%20%3D%20user_id%0A%20%20%20%20%20%20%20%20self.averageTSWords%20%3D%200.0%0A%20%20%20%20%20%20%20%20self.averageSSWords%20%3D%200.0%0A%20%20%20%20%20%20%20%20self.percOfClipTitlesUntitled%20%3D%200.0%0A%20%20%20%20%20%20%20%20self.percOfClipsWithCaptions%20%3D%200.0%0A%20%20%20%20%20%20%20%20self.percOfClipsWithTags%20%3D%200.0%0A%20%20%20%20%20%20%20%20self.percOfClipsWithComments%20%3D%200.0%0A%20%20%20%20%20%20%20%20self.percOfPurgatoryClips%20%3D%200.0%0A%20%20%20%20%20%20%20%20self.averageTimeDifferenceBetweenUploaded%20%3D%200.0%0A%0Au1%20%3D%20TrendingUser%281234%29%0Au2%20%3D%20TrendingUser%285678%29&amp;cumulative=false&amp;curInstr=25&amp;heapPrimitives=true&amp;mode=display&amp;origin=opt-frontend.js&amp;py=2&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" rel="nofollow noreferrer">Pytutor visualization</a> of what is happening with your code. Note that both instances refer to the <em>same</em> underlying data.</p>
</div>
<div class="post-text" itemprop="text">
<p>The default argument <code>uploads={}</code> is the problem.  It actually creates the dict at class definition time and sets that dict as the default, instead of what you want (create a new empty dict if none is specified).  For that, the usual pattern is</p>
<pre><code>def __init__(self, par=None):
  if par is None:
    par = {}
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument">"Least Astonishment" and the Mutable Default Argument</a></span>
<span class="comment-copy">But why do all instances of the TrendingUser objects' uploads attribute point to the same dictionary, and how can I get around this issue?</span>
<span class="comment-copy">Thanks for the explanation, your solution worked :) ... just wanted to understand why a bit more</span>
