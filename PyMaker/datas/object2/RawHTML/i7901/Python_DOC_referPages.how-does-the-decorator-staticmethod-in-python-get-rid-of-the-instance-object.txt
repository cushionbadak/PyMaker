<div class="post-text" itemprop="text">
<p>As far as I have understood, a decorator is a function that takes another function as a parameter, performs some operation on it and then returns it.</p>
<p>Talking about the decorator @staticmethod, what exactly does that decorator do to eliminate the instance object that is being passed by default ?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>staticmethod</code> decorator returns a <code>staticmethod</code> <em>object</em>. This object implements the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a>, same as functions do.</p>
<p>What this does is not that it gets rid of the instance, instead the <code>staticmethod.__get__</code> <em>ignores</em> binding altogether and just returns the unaltered function object. For regular functions, <code>function.__get__</code> would instead bind by returning a method object (which then tracks the instance and the function to combine them when called).</p>
<p>You can reproduce this by manually invoking the descriptor protocol:</p>
<pre><code>&gt;&gt;&gt; class Demo:
...     def regular(self):
...         pass
...     @staticmethod
...     def static():
...         pass
...
&gt;&gt;&gt; Demo.__dict__['regular']  # bypass __getattribute__
&lt;function Demo.regular at 0x108515268&gt;
&gt;&gt;&gt; Demo.__dict__['static']   # bypass __getattribute__
&lt;staticmethod object at 0x1084d4f60&gt;
&gt;&gt;&gt; Demo.__dict__['regular'].__get__(Demo())  # descriptor protocol, pass in an instance
&lt;bound method Demo.regular of &lt;__main__.Demo object at 0x1084e2668&gt;&gt;
&gt;&gt;&gt; Demo.__dict__['static'].__get__(Demo())  # descriptor protocol, pass in an instance
&lt;function Demo.static at 0x1085152f0&gt;
</code></pre>
<p>By accessing the attributes of the <code>Demo</code> class through <code>Demo.__dict__</code>, we bypass the descriptor protocol normally enforced by the <code>__getattribute__</code> method. As you can see, for a regular method a <em>function</em> object is returned, but for <code>static</code> a <code>staticmethod</code> object is found instead.</p>
<p>Calling <code>.__get__(Demo())</code> on either to invoke the descriptor protocol then produces a method object, and the un-altered function object, respectively. This is exactly what direct access to the same names on an instance produces:</p>
<pre><code>&gt;&gt;&gt; Demo().regular
&lt;bound method Demo.regular of &lt;__main__.Demo object at 0x1084dde10&gt;&gt;
&gt;&gt;&gt; Demo().static
&lt;function Demo.static at 0x1085152f0&gt;
</code></pre>
<p>Note that the same protocol is also the reason that <code>classmethod</code> objects are passed <code>type(instance)</code> instead of the instance as a first argument, and also why <code>property</code> objects call the underlying function on access.</p>
</div>
<span class="comment-copy">See the Python implementation somewhere at the bottom: <a href="https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods" rel="nofollow noreferrer">docs.python.org/3/howto/â€¦</a></span>
