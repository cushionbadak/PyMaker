<div class="post-text" itemprop="text">
<p>Consider following code:</p>
<pre><code>async with app:
    ...
    async with app.resource as rsrc:
        ...
        async with rsrc.foo as bar:
            ...
</code></pre>
<p>Having lots of nested <code>with</code> or <code>async with</code> statements has negative effect on readability of code, especially in tests, where the same clause might be reused lots of times.</p>
<p>In languages like D, there is <code>scope(exit) ...</code> construct, which allows you to append code to the list of scope finalizers â€” this code would be executed once the scope is left, allowing you to effectively do what <code>__exit__</code> does, but without adding an indent.</p>
<p>Is there a way to flatten <code>with</code> in Python and do something like this?</p>
<pre><code>await async_with(app)
scope_exit(app.quit)

...

rsrc = await async_with(app.resource)
scope_exit(rsrc.release)

...

bar = await async_with(rsrc.foo)
scope_exit(lambda: bar.unfrob())

...
</code></pre>
<p>Or, alternatively, is there a way to reliably execute arbitrary code on exiting the scope?</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I know, you can't achieve what you want. Especially because there's no possibility to define such "scope".</p>
<p>Even in your pseudo-code:</p>
<pre><code>await async_with(app)
scope_exit(app.quit)

...

rsrc = await async_with(app.resource)
scope_exit(rsrc.release)

...

bar = await async_with(rsrc.foo)
scope_exit(lambda: bar.unfrob())

raise ExceptionHere()
</code></pre>
<p>What context should [not] catch it?</p>
<p>I may be wrong, but the the only way to set the "guard" for catching exceptions is <code>try/except</code> clause. <code>with</code> is roughly a wrapper around it.</p>
<p>Speaking about motivation, if you have problems with nested context managers so hard, you should probably refactor your core to extract inner context as functions. You may take a look at <a href="https://docs.python.org/3/library/contextlib.html" rel="nofollow noreferrer">contextlib</a> for helpers</p>
</div>
<div class="post-text" itemprop="text">
<p>I can't stand the extra indentations from the <code>with</code> statement... This is what I do to flatten them:</p>
<p>Nested:</p>
<pre><code>def stuff_with_files(path_a, path_b):
    # ... do stuff
    with open(path_a) as fileA:
        # ... do stuff with fileA
        with open(path_b) as fileB:
            # ... do stuff with fileA and fileB

def main():
    stuff_with_files('fileA.txt', 'fileB.txt')
</code></pre>
<p>Flattened:</p>
<pre><code># Extract the 'with' statement.
def with_file(path, func, *args, **kwargs):
    with open(path) as file:
        func(file, *args, **kwargs)


def process_a_b(fileB, results_of_a):
    # ... do stuff with fileB and results_of_a.


def process_a(fileA):
    # ... do stuff with fileA
    results = # ...
    with_file('fileB.txt', process_a_b, results)


def main():
    with_file('fileA.txt', process_a)
</code></pre>
</div>
<span class="comment-copy">The <a href="https://docs.python.org/3/reference/compound_stmts.html#with" rel="nofollow noreferrer"><code>with</code> statement</a> can have many members. I'm unsure if you can use any of the resulting variables in the statement.</span>
<span class="comment-copy">@Kendas, while it's possible to include multiple clauses in single <code>with</code> statement, it's impossible to execute any code in between without resorting to <code>with</code> (or non-existent <code>scope_exit</code>)</span>
<span class="comment-copy">If you raise an exception at the very end, it should follow the same unwinding flow like it would with nested <code>with</code> - e.g. <code>bar.unfrob()</code> should be called, then <code>rsrc.release()</code>, then <code>app.quit()</code>. If exception was raised before <code>scope_exit(lambda: bar.unfrob())</code>, then there would be no such scope finalizer, so only <code>rsrc.release()</code> and <code>app.quit()</code> should be called.</span>
<span class="comment-copy">maybe I should even make this into a PEP to define the concept of "scope finalizer", to enable explicit RAII in Python.</span>
<span class="comment-copy">Tbh, i really doubt the possibility of flattening such thing, but you can always try :)  I recommend following readings: <a href="https://www.python.org/dev/peps/pep-0310/" rel="nofollow noreferrer">python.org/dev/peps/pep-0310</a> (actually, father of <code>with</code>, afaik) <a href="https://www.python.org/dev/peps/pep-0343/" rel="nofollow noreferrer">python.org/dev/peps/pep-0343</a> (intuition for <code>with</code>) <a href="https://stackoverflow.com/a/5071376/2161778">stackoverflow.com/a/5071376/2161778</a> (RAII in python and thoughts)</span>
