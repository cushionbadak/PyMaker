<div class="post-text" itemprop="text">
<p>I'm debugging some Python that takes, as input, a list of objects, each with some attributes.</p>
<p>I'd like to hard-code some test values -- let's say, a list of four objects whose "foo" attribute is set to some number.</p>
<p>Is there a more concise way than this?</p>
<pre><code>x1.foo = 1
x2.foo = 2
x3.foo = 3
x4.foo = 4
myfunc([x1, x2, x3, x4])
</code></pre>
<p>Ideally, I'd just like to be able to say something like:</p>
<pre><code>myfunc([&lt;foo=1&gt;, &lt;foo=2&gt;, &lt;foo=3&gt;, &lt;foo=4&gt;])
</code></pre>
<p>(Obviously, that is made-up syntax. But is there something similar that really works?)</p>
<p>Note: This will never be checked in. It's just some throwaway debug code. So don't worry about readability or maintainability.</p>
</div>
<div class="post-text" itemprop="text">
<p>I like Tetha's solution, but it's unnecessarily complex.</p>
<p>Here's something simpler:</p>
<pre><code>&gt;&gt;&gt; class MicroMock(object):
...     def __init__(self, **kwargs):
...         self.__dict__.update(kwargs)
...
&gt;&gt;&gt; def print_foo(x):
...     print x.foo
...
&gt;&gt;&gt; print_foo(MicroMock(foo=3))
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found this: <a href="http://www.hydrogen18.com/blog/python-anonymous-objects.html" rel="noreferrer">http://www.hydrogen18.com/blog/python-anonymous-objects.html</a>, and in my limited testing it seems like it works:</p>
<pre><code>&gt;&gt;&gt; obj = type('',(object,),{"foo": 1})()
&gt;&gt;&gt; obj.foo
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have a look at this:</p>
<pre><code>
class MiniMock(object):
    def __new__(cls, **attrs):
        result = object.__new__(cls)
        result.__dict__ = attrs
        return result

def print_foo(x):
    print x.foo

print_foo(MiniMock(foo=3))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Non classy:</p>
<pre><code>def mock(**attrs):
    r = lambda:0
    r.__dict__ = attrs
    return r 

def test(a, b, c, d):
    print a.foo, b.foo, c.foo, d.foo

test(*[mock(foo=i) for i in xrange(1,5)])
# or
test(mock(foo=1), mock(foo=2), mock(foo=3), mock(foo=4))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another obvious hack:</p>
<pre><code>class foo1: x=3; y='y'
class foo2: y=5; x=6

print(foo1.x, foo2.y)
</code></pre>
<p>But for your exact usecase, calling a function with anonymous objects directly, I don't know any one-liner less verbose than</p>
<pre><code>myfunc(type('', (object,), {'foo': 3},), type('', (object,), {'foo': 4}))
</code></pre>
<p>Ugly, does the job, but not really.</p>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.3, there's <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer">types.SimpleNamespace</a> that does exactly what you want:</p>
<pre><code>myfunc([types.SimpleNamespace(foo=1), types.SimpleNamespace(foo=2), types.SimpleNamespace(foo=3), types.SimpleNamespace(foo=4)])
</code></pre>
<p>That's a tad wordy, but you can clean it up with an alias:</p>
<pre><code>_ = types.SimpleNamespace
myfunc([_(foo=1), _(foo=2), _(foo=3), _(foo=4)])
</code></pre>
<p>And now that's actually pretty close to the fictional syntax in your question.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you can use <a href="https://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuple</a> to solve this as following:</p>
<pre><code>from collections import namedtuple
Mock = namedtuple('Mock', ['foo'])

mock = Mock(foo=1)
mock.foo  // 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So brief, such Python! O.o</p>
<pre><code>&gt;&gt;&gt; Object = lambda **kwargs: type("Object", (), kwargs)
</code></pre>
<p>Then you can use <code>Object</code> as a generic object constructor:</p>
<pre><code>&gt;&gt;&gt; person = Object(name = "Bernhard", gender = "male", age = 42)
&gt;&gt;&gt; person.name
'Bernhard'
&gt;&gt;&gt;
</code></pre>
<p>EDIT: Well okay, technically this creates a class object, not an object object. But you can treat it like an anonymous object or you modify the first line by appending a pair of parenthesis to create an instance immediately:</p>
<pre><code>&gt;&gt;&gt; Object = lambda **kwargs: type("Object", (), kwargs)()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>anonymous_object = type('',(),{'name':'woody', 'age':'25'})()
anonymous_object.name
&gt; 'woody'
</code></pre>
<p>There is a cool way but hard to understand. 
It use type() create a no-named class with default init params,
then init it without any param and get the anonymous object.</p>
</div>
<span class="comment-copy">However, if you're creating a whole bunch of these, you might save some time/memory by using the given dictionary instead of creating a new one and copying all the entries. Doesn't <i>really</i> matter, though.</span>
<span class="comment-copy">well, I might be subjective, but I see no substantial simplification. Yes, you use <b>init</b> and update, but youre still fiddling around with <b>dict</b>.</span>
<span class="comment-copy">You're right, there's no significant simplification. It's just shorter and doesn't use <b>new</b>, that's all.</span>
<span class="comment-copy">If you want convenient syntax, <code>_</code> is a valid class name in python, and isn't really any more indecipherable than the version posited in the question.</span>
<span class="comment-copy">With recent Python feature, you can use "def mock(**kwargs): return type('',(),kwargs)()", and do "a = mock(foo=1)"</span>
<span class="comment-copy">Brilliant! And is true one-liner!</span>
<span class="comment-copy">Credit to @RoadieRich for suggesting <code>_</code> as the class name in an earlier comment.</span>
<span class="comment-copy">If using _ bothers you (it feels a bit icky and unpythonic to me), and you really don't want to type so much, you can also just <code>from types import SimpleNamespace as Nsp</code> and use Nsp like _ in your answer.</span>
<span class="comment-copy">@JJC of course! The coding standards I currently work under don't allow renaming on import like that, so I tend to forget that's even an option.</span>
