<div class="post-text" itemprop="text">
<p>I have the following dictionary:</p>
<pre><code>dict = {'Sex':['Male','Male','Female','Female','Male'],
        'Height': [100,200,150,80,90],
        'Weight': [20,60,40,30,30]}
</code></pre>
<p>I'd like to be able to filter that dictionary using a condition on one key. For example, if I want to keep Male only:</p>
<pre><code>new_dict = {'Sex':['Male','Male','Male'],
            'Height': [100,200,90],
            'Weight': [20,60,30]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <em>dict comprehension</em> and check for the items at the corresponding index at key <code>'Sex'</code> while building the value lists:  </p>
<pre><code>d = {k: [x for i, x in enumerate(v) if dct['Sex'][i]=='Male'] 
                                      for k, v in dct.items()}
print(d)
# {'Sex': ['Male', 'Male', 'Male'], 
#  'Weight': [20, 60, 30], 
#  'Height': [100, 200, 90]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of trying to keep track of indexes, "transpose" the data structure to be a list of dictionaries:</p>
<pre><code>data = [{'Sex': 'Male', 'Height': 100, 'Weight': 20},
        {'Sex': 'Male', 'Height': 200, 'Weight': 60},
        {'Sex': 'Female', 'Height': 150, 'Weight': 40},
        {'Sex': 'Female', 'Height': 80, 'Weight': 30},
        {'Sex': 'Male', 'Height': 90, 'Weight': 30}]

only_males = [person for person in data if person['Sex'] == 'Male']
only_males
# [{'Sex': 'Male', 'Height': 100, 'Weight': 20},
#  {'Sex': 'Male', 'Height': 200, 'Weight': 60},
#  {'Sex': 'Male', 'Height': 90, 'Weight': 30}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The solution using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">collections.defaultdict</a> and <code>zip()</code> function:</p>
<pre><code>d = {
    'Sex':['Male','Male','Female','Female','Male'],
    'Height': [100,200,150,80,90],
    'Weight': [20,60,40,30,30]
}

result = collections.defaultdict(list)
for s,h,w in zip(d['Sex'], d['Height'], d['Weight']):
    if s == 'Male':
        result['Sex'].append(s)
        result['Height'].append(h)
        result['Weight'].append(w)

print(dict(result))
</code></pre>
<p>The output:</p>
<pre><code>{'Sex': ['Male', 'Male', 'Male'], 'Weight': [20, 60, 30], 'Height': [100, 200, 90]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/library/itertools.html#itertools.compress" rel="nofollow noreferrer"><code>itertools.compress</code></a> and a dictionary comprehension:</p>
<pre><code>&gt;&gt;&gt; import itertools

&gt;&gt;&gt; dct = {'Sex':    ['Male', 'Male', 'Female', 'Female', 'Male'],
...        'Height': [100, 200, 150, 80, 90],
...        'Weight': [20, 60, 40, 30, 30]}

&gt;&gt;&gt; mask = [item == 'Male' for item in dct['Sex']]

&gt;&gt;&gt; new_dict = {key: list(itertools.compress(dct[key], mask)) for key in dct}
&gt;&gt;&gt; new_dict
{'Height': [100, 200, 90],
 'Sex': ['Male', 'Male', 'Male'],
 'Weight': [20, 60, 30]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a pandas DataFrame (<a href="https://pypi.python.org/pypi/pandas/0.18.1/" rel="nofollow noreferrer">install</a> the package first)</p>
<pre><code>&gt;&gt;&gt; data = pandas.DataFrame(
   {'Sex':['Male','Male','Female','Female','Male'],
    'Height': [100,200,150,80,90],
    'Weight': [20,60,40,30,30]}
)

&gt;&gt;&gt; data[data['Sex'] == 'Male']
   Height   Sex  Weight
0     100  Male      20
1     200  Male      60
4      90  Male      30
</code></pre>
<p>This will work more like a database and you can filter a lot more things effortlessly. </p>
</div>
<div class="post-text" itemprop="text">
<p>Personally, I would use a list of objects instead, to have related attributes in the same object, this way:</p>
<pre><code>people = [{"Sex": "Male", "Height": 100, "Weight": 20}, {...}, ...]
</code></pre>
<p>I'd convert to a list this way (assuming the list in your dictionary all have the same size):</p>
<pre><code>list = []
for i in range(len(dict["Sex"])):
    list.append({k: v[i] for k, v in dict.iteritems()})
</code></pre>
<p>Or use <code>d.items()</code>if you are in python 3.x.</p>
<p>Then you can easily filter the list by key value, more details <a href="https://stackoverflow.com/questions/29051573/python-filter-list-of-dictionaries-based-on-key-value">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I will just put this here since I wrote it anyway. It creates a database in memory based on your dictionary which you can then query (flexibly as you might notice) to get the results you want.</p>
<pre><code>dict_ = {'Sex': ['Male', 'Male', 'Female', 'Female', 'Male'],
        'Height': [100, 200, 150, 80, 90],
        'Weight': [20, 60, 40, 30, 30]}

import sqlite3

conn = sqlite3.connect(':memory:')
curs = conn.cursor()
column_headers = [x for x in dict_]  # the keys are the headers
column_types = ('' for x in dict_)
header_creation = ', '.join([' '.join(x) for x in zip(column_headers, column_types)])
curs.execute("CREATE TABLE temp ({})".format(header_creation))
bindings = ','.join('?' * (header_creation.count(',') + 1))
result_insertion = "INSERT INTO temp ({}) VALUES ({})".format(', '.join(column_headers), bindings)
for i, item in enumerate(dict_[column_headers[0]]):
    values = [item]
    for j in column_headers[1:]:
        values.append(dict_[j][i])
    curs.execute(result_insertion, values)
conn.commit()

condition = 'weight &gt;= 40'

out = curs.execute('SELECT * FROM temp{}'.format(' WHERE {}'.format(condition) if condition else ';')).fetchall()
dict_out = {}
for i, k in enumerate(column_headers):
    dict_out[k] = [x[i] for x in out]
print(dict_out)  # {'Sex': ['Male', 'Female'], 'Weight': [60, 40], 'Height': [200, 150]}
</code></pre>
</div>
<span class="comment-copy">convert it into a database.</span>
<span class="comment-copy">Thanks but not ideal within my configuration.</span>
<span class="comment-copy">how flexible do you want to be? can another example be <code>height &gt; 100</code> for instance?</span>
<span class="comment-copy">Yes for instance. Any easy way to do it with code ?</span>
<span class="comment-copy">So you should show how OP would transpose the data assuming it might be big. Yours is the best option IMO using only dictionaries</span>
<span class="comment-copy">My guess is that data came in the format suggested by DeepSpace and the OP applied some effort to them to have the format he showed us...</span>
