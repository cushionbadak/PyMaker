<div class="post-text" itemprop="text">
<p><strong>TL;DR</strong></p>
<p>What is the most efficient way to implement a filter function for a dictionary with keys of variable dimensions? The filter should take a tuple of the same dimensions as the dictionary's keys and output all keys in the dictionary which match the filter such that <code>filter[i] is None or filter[i] == key[i]</code> for all dimensions <code>i</code>.</p>
<hr/>
<p>In my current project, I need to handle dictionaries with a lot of data. The general structure of the dictionary is such that it contains tuples with 2 to 4 integers as keys and integers as values. All keys in a dictionary have the same dimensions. To illustrate, the following are examples of dictionaries I need to handle:</p>
<pre><code>{(1, 2): 1, (1, 5): 2}
{(1, 5, 3): 2}
{(5, 2, 5, 2): 8}
</code></pre>
<p>These dictionaries contain a lot of entries, with the largest ones at about 20 000 entries. I frequently need to filter these entries, but often only looking at certain indices of the key tuples. Ideally, I want to have a function to which I can supply a filter tuple. The function should then return all keys which match the filter tuple. If the filter tuple contains a <code>None</code> entry, then this will match any value in the dictionary's key tuple at this index.</p>
<p>Example of what the function should do for a dictionary with 2-dimensional keys:</p>
<pre><code>&gt;&gt;&gt; dict = {(1, 2): 1, (1, 5): 2, (2, 5): 1, (3, 9): 5}
&gt;&gt;&gt; my_filter_fn((1, None))
{(1, 2), (1, 5)}
&gt;&gt;&gt; my_filter_fn((None, 5))
{(1, 5), (2, 5)}
&gt;&gt;&gt; my_filter_fn((2, 4))
set()
&gt;&gt;&gt; my_filter_fn((None, None))
{(1, 2), (1, 5), (2, 5), (3, 9)}
</code></pre>
<p>As my dictionaries have different dimensions of their tuples, I have tried solving this problem by writing a generator expression which takes the dimensions of the tuple into account:</p>
<pre><code>def my_filter_fn(entries: dict, match: tuple):
    return (x for x in entries.keys() if all(match[i] is None or match[i] == x[i]
                                             for i in range(len(key))))
</code></pre>
<p>Unfortunately, this is quite slow compared to writing out condition completely by hand (<code>(match[0] is None or match[0] === x[0]) and (match[1] is None or match[1] == x[1]</code>); for 4 dimensions this is about 10 times slower. This is a problem for me as I need to do this filtering quite often.</p>
<p>Following code demonstrates the performance issue. Code is just supplied to illustrate the problem and enable reproduction of the tests. You can skip the code part, results are below.</p>
<pre><code>import random
import timeit


def access_variable_length():
    for key in entry_keys:
        for k in (x for x in all_entries.keys() if all(key[i] is None or key[i] == x[i]
                                                       for i in range(len(key)))):
            pass


def access_static_length():
    for key in entry_keys:
        for k in (x for x in all_entries.keys() if
                  (key[0] is None or x[0] == key[0])
                  and (key[1] is None or x[1] == key[1])
                  and (key[2] is None or x[2] == key[2])
                  and (key[3] is None or x[3] == key[3])):
            pass


def get_rand_or_none(start, stop):
    number = random.randint(start-1, stop)
    if number == start-1:
        number = None
    return number


entry_keys = set()
for h in range(100):
    entry_keys.add((get_rand_or_none(1, 200), get_rand_or_none(1, 10), get_rand_or_none(1, 4), get_rand_or_none(1, 7)))
all_entries = dict()
for l in range(13000):
    all_entries[(random.randint(1, 200), random.randint(1, 10), random.randint(1, 4), random.randint(1, 7))] = 1

variable_time = timeit.timeit("access_variable_length()", "from __main__ import access_variable_length", number=10)
static_time = timeit.timeit("access_static_length()", "from __main__ import access_static_length", number=10)

print("variable length time: {}".format(variable_time))
print("static length time: {}".format(static_time))
</code></pre>
<p>Results:</p>
<pre>variable length time: 9.625867042849316
static length time: 1.043319165662158</pre>
<p>I would like to avoid having to create three different functions <code>my_filter_fn2</code>, <code>my_filter_fn3</code>, and <code>my_filter_fn4</code> to cover all possible dimensions of my dictionaries and then use static dimensions filtering. I am aware that filtering for variable dimensions will always be slower than filtering for fixed dimensions, but was hoping that it would not be almost 10 times slower. As I am not a Python expert, I was hoping that there is a clever way in which my variable dimensions generator expression could be reformulated to give me better performance.</p>
<p>What is the most efficient way to filter a huge dictionary in the way I described?</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for the opportunity to think about tuples in sets and dictionaries. It's a very useful and powerful corner of Python.</p>
<p>Python is interpreted, so if you've come from a compiled language, one good rule of thumb is to avoid complex nested iterations where you can. If you're writing complicated for loops or comprehensions it's always worth wondering if there's a better way to do it.</p>
<p>List subscripts (<code>stuff[i]</code>) and <code>range (len(stuff))</code> are inefficient and long-winded in Python, and rarely necessary. It's more efficient (and more natural) to iterate:</p>
<pre><code>for item in stuff:
    do_something(item)
</code></pre>
<p>The following code is fast because it uses some of the strengths of Python: comprehensions, dictionaries, sets and tuple unpacking.</p>
<p>There are iterations, but they're simple and shallow.
 There's only one if statement in the whole of the code, and that's executed only 4 times per filter operation. That also helps performance-- and makes code easier to read.</p>
<p>An explanation of the method...</p>
<p>Each key from the original data:</p>
<pre><code>{(1, 4, 5): 1}
</code></pre>
<p>is indexed by position and value:</p>
<pre><code>{
    (0, 1): (1, 4, 5),
    (1, 4): (1, 4, 5),
    (2, 5): (1, 4, 5)
}
</code></pre>
<p>(Python numbers elements from zero.)</p>
<p>Indexes are collated into one big lookup dictionary composed of sets of tuples:</p>
<pre><code>{
    (0, 1): {(1, 4, 5), (1, 6, 7), (1, 2), (1, 8), (1, 4, 2, 8), ...}
    (0, 2): {(2, 1), (2, 2), (2, 4, 1, 8), ...}
    (1, 4): {(1, 4, 5), (1, 4, 2, 8), (2, 4, 1, 8), ...}
    ...
}
</code></pre>
<p>Once this lookup is built (and it is built very efficiently) filtering is just set intersection and dictionary lookup, both of which are lightning-fast. Filtering takes microseconds on even a large dictionary.</p>
<p>The method handles data with tuples of arity 2, 3 or 4 (or any other) but <code>arity_filtered()</code> returns only keys with the same number of members as the filter tuple. So this class gives you the option of filtering all data together, or handling the different sizes of tuple separately, with little to choose between them as regards performance.</p>
<p>Timing results for the large random dataset (11,500 tuples) were 0.30s to build the lookup, 0.007 seconds for 100 lookups.</p>
<pre><code>from collections import defaultdict
import random
import timeit


class TupleFilter:
    def __init__(self, data):
        self.data = data
        self.lookup = self.build_lookup()

    def build_lookup(self):
        lookup = defaultdict(set)
        for data_item in self.data:
            for member_ref, data_key in tuple_index(data_item).items():
                lookup[member_ref].add(data_key)
        return lookup

    def filtered(self, tuple_filter):
        # initially unfiltered
        results = self.all_keys()
        # reduce filtered set
        for position, value in enumerate(tuple_filter):
            if value is not None:
                match_or_empty_set = self.lookup.get((position, value), set())
                results = results.intersection(match_or_empty_set)
        return results

    def arity_filtered(self, tuple_filter):
        tf_length = len(tuple_filter)
        return {match for match in self.filtered(tuple_filter) if tf_length == len(match)}

    def all_keys(self):
        return set(self.data.keys())


def tuple_index(item_key):
    member_refs = enumerate(item_key)
    return {(pos, val): item_key for pos, val in member_refs}


data = {
    (1, 2): 1,
    (1, 5): 2,
    (1, 5, 3): 2,
    (5, 2, 5, 2): 8
}

tests = {
     (1, 5): 2,
     (1, None, 3): 1,
     (1, None): 3,
     (None, 5): 2,
}

tf = TupleFilter(data)
for filter_tuple, expected_length in tests.items():
    result = tf.filtered(filter_tuple)
    print("Filter {0} =&gt; {1}".format(filter_tuple, result))
    assert len(result) == expected_length
# same arity filtering
filter_tuple = (1, None)
print('Not arity matched: {0} =&gt; {1}'
      .format(filter_tuple, tf.filtered(filter_tuple)))
print('Arity matched: {0} =&gt; {1}'
      .format(filter_tuple, tf.arity_filtered(filter_tuple)))
# check unfiltered results return original data set
assert tf.filtered((None, None)) == tf.all_keys()


&gt;&gt;&gt; python filter.py
Filter (1, 5) finds {(1, 5), (1, 5, 3)}
Filter (1, None, 3) finds {(1, 5, 3)}
Filter (1, None) finds {(1, 2), (1, 5), (1, 5, 3)}
Filter (None, 5) finds {(1, 5), (1, 5, 3)}
Arity filtering: note two search results only: (1, None) =&gt; {(1, 2), (1, 5)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've made some modifications:</p>
<ul>
<li><p>you don't need to use <a href="https://docs.python.org/3/library/stdtypes.html#dict.keys" rel="nofollow noreferrer"><code>dict.keys</code></a> method to iterate through keys, iterating through <code>dict</code> object itself will give us its keys,</p></li>
<li><p>created separate modules, it helps to read and modify:</p>
<ul>
<li><p><code>preparations.py</code> with helpers for generating test data:</p>
<pre><code>import random

left_ends = [200, 10, 4, 7]


def generate_all_entries(count):
    return {tuple(random.randint(1, num)
                  for num in left_ends): 1
            for _ in range(count)}


def generate_entry_keys(count):
    return [tuple(get_rand_or_none(1, num)
                  for num in left_ends)
            for _ in range(count)]


def get_rand_or_none(start, stop):
    number = random.randint(start - 1, stop)
    if number == start - 1:
        number = None
    return number
</code></pre></li>
<li><code>functions.py</code> for tested functions,</li>
<li><code>main.py</code> for benchmarks.</li>
</ul></li>
<li><p>passing arguments to function instead of getting them from global scope, so given static &amp; variable length versions become</p>
<pre><code>def access_static_length(all_entries, entry_keys):
    for key in entry_keys:
        for k in (x
                  for x in all_entries
                  if (key[0] is None or x[0] == key[0])
                  and (key[1] is None or x[1] == key[1])
                  and (key[2] is None or x[2] == key[2])
                  and (key[3] is None or x[3] == key[3])):
            pass


def access_variable_length(all_entries, entry_keys):
    for key in entry_keys:
        for k in (x
                  for x in all_entries
                  if all(key[i] is None or key[i] == x[i]
                         for i in range(len(key)))):
            pass
</code></pre></li>
<li><p>using <code>min</code> on results of <a href="https://docs.python.org/2/library/timeit.html#timeit.repeat" rel="nofollow noreferrer"><code>timeit.repeat</code></a> instead of <a href="https://docs.python.org/2/library/timeit.html#timeit.timeit" rel="nofollow noreferrer"><code>timeit.timeit</code></a> to get most representable results (more in <a href="https://stackoverflow.com/a/8220943/5997596">this answer</a>),</p></li>
<li><p>changing <code>entries_keys</code> elements count from <code>10</code> to <code>100</code> (including ends) with step <code>10</code>,</p></li>
<li><p>changing <code>all_entries</code> elements count from <code>10000</code> to <code>15000</code> (including ends) with step <code>500</code>.</p></li>
</ul>
<hr/>
<p>But getting back to the point.</p>
<h1>Improvements</h1>
<ol>
<li><p>We can improve filtration by skipping checks for indexes with <code>None</code> values in keys</p>
<pre><code>def access_variable_length_with_skipping_none(all_entries, entry_keys):
    for key in entry_keys:
        non_none_indexes = {i
                            for i, value in enumerate(key)
                            if value is not None}
        for k in (x
                  for x in all_entries.keys()
                  if all(key[i] == x[i]
                         for i in non_none_indexes)):
            pass
</code></pre></li>
<li><p>Next suggestion is to use <code>numpy</code>:</p>
<pre><code>import numpy as np


def access_variable_length_numpy(all_entries, entry_keys):
    keys_array = np.array(list(all_entries))
    for entry_key in entry_keys:
        non_none_indexes = [i
                            for i, value in enumerate(entry_key)
                            if value is not None]
        non_none_values = [value
                           for i, value in enumerate(entry_key)
                           if value is not None]
        mask = keys_array[:, non_none_indexes] == non_none_values
        indexes, _ = np.where(mask)
        for k in map(tuple, keys_array[indexes]):
            pass
</code></pre></li>
</ol>
<h1>Benchmarks</h1>
<p>Contents of <code>main.py</code>:</p>
<pre><code>import timeit
from itertools import product

number = 5
repeat = 10
for all_entries_count, entry_keys_count in product(range(10000, 15001, 500),
                                                   range(10, 101, 10)):
    print('all entries count: {}'.format(all_entries_count))
    print('entry keys count: {}'.format(entry_keys_count))
    preparation_part = ("from preparation import (generate_all_entries,\n"
                        "                         generate_entry_keys)\n"
                        "all_entries = generate_all_entries({all_entries_count})\n"
                        "entry_keys = generate_entry_keys({entry_keys_count})\n"
                        .format(all_entries_count=all_entries_count,
                                entry_keys_count=entry_keys_count))
    static_time = min(timeit.repeat(
        "access_static_length(all_entries, entry_keys)",
        preparation_part + "from functions import access_static_length",
        repeat=repeat,
        number=number))
    variable_time = min(timeit.repeat(
        "access_variable_length(all_entries, entry_keys)",
        preparation_part + "from functions import access_variable_length",
        repeat=repeat,
        number=number))
    variable_time_with_skipping_none = min(timeit.repeat(
        "access_variable_length_with_skipping_none(all_entries, entry_keys)",
        preparation_part +
        "from functions import access_variable_length_with_skipping_none",
        repeat=repeat,
        number=number))
    variable_time_numpy = min(timeit.repeat(
        "access_variable_length_numpy(all_entries, entry_keys)",
        preparation_part +
        "from functions import access_variable_length_numpy",
        repeat=repeat,
        number=number))

    print("static length time: {}".format(static_time))
    print("variable length time: {}".format(variable_time))
    print("variable length time with skipping `None` keys: {}"
          .format(variable_time_with_skipping_none))
    print("variable length time with numpy: {}"
          .format(variable_time_numpy))
</code></pre>
<p>which on my machine with <strong>Python 3.6.1</strong> gives:</p>
<pre><code>all entries count: 10000
entry keys count: 10
static length time: 0.06314293399918824
variable length time: 0.5234129569980723
variable length time with skipping `None` keys: 0.2890012050011137
variable length time with numpy: 0.22945181500108447
all entries count: 10000
entry keys count: 20
static length time: 0.12795891799760284
variable length time: 1.0610534609986644
variable length time with skipping `None` keys: 0.5744297259989253
variable length time with numpy: 0.5105678180007089
all entries count: 10000
entry keys count: 30
static length time: 0.19210158399801003
variable length time: 1.6491422000035527
variable length time with skipping `None` keys: 0.8566724129996146
variable length time with numpy: 0.7363859869983571
all entries count: 10000
entry keys count: 40
static length time: 0.2561357790000329
variable length time: 2.08878050599742
variable length time with skipping `None` keys: 1.1256247100027394
variable length time with numpy: 1.0066140279996034
all entries count: 10000
entry keys count: 50
static length time: 0.32130833200062625
variable length time: 2.6166040710013476
variable length time with skipping `None` keys: 1.4147321179989376
variable length time with numpy: 1.1700750320014777
all entries count: 10000
entry keys count: 60
static length time: 0.38276188999952865
variable length time: 3.153736616997776
variable length time with skipping `None` keys: 1.7147898039984284
variable length time with numpy: 1.4533947029995034
all entries count: 10000
entry keys count: 70
...
all entries count: 15000
entry keys count: 80
static length time: 0.7141444490007416
variable length time: 6.186657476999244
variable length time with skipping `None` keys: 3.376506028998847
variable length time with numpy: 3.1577993860009883
all entries count: 15000
entry keys count: 90
static length time: 0.8115685330012639
variable length time: 7.14327938399947
variable length time with skipping `None` keys: 3.7462387939995097
variable length time with numpy: 3.6140603050007485
all entries count: 15000
entry keys count: 100
static length time: 0.8950150890013902
variable length time: 7.829741768000531
variable length time with skipping `None` keys: 4.1662235900003
variable length time with numpy: 3.914334102999419
</code></pre>
<h1>Resume</h1>
<p>As we can see <code>numpy</code> version isn't so good as expected and it seems to be not <code>numpy</code>'s fault.</p>
<p>If we remove converting filtered array records to <code>tuple</code>s with <code>map</code> and just leave</p>
<pre><code>for k in keys_array[indexes]:
    ...
</code></pre>
<p>then it will be extremely fast (faster than <em>static length</em> version), so the problem is in conversion from <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html" rel="nofollow noreferrer"><code>numpy.ndarray</code></a> objects to <code>tuple</code>.</p>
<p>Filtering out <code>None</code> entry keys gives us about 50% speed gain, so feel free to add it.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't have a beautiful answer, but this sort of optimisation often makes code harder to read.  But if you just need more speed here are two things you can do.</p>
<p>Firstly we can straightforwardly eliminate a repeated computation from inside the loop.  You say that all the entries in each dictionary have the same length so you can compute that once, rather than repeatedly in the loop.  This shaves off about 20% for me:</p>
<pre><code>def access_variable_length():
    try:
        length = len(iter(entry_keys).next())
    except KeyError:
        return
    r = list(range(length))
    for key in entry_keys:
        for k in (x for x in all_entries.keys() if all(key[i] is None or key[i] == x[i]
                                                       for i in r)):
            pass
</code></pre>
<p>Not pretty, I agree.  But we can make it much faster (and even uglier!) by building the fixed length function using <code>eval</code>.  Like this:</p>
<pre><code>def access_variable_length_new():
    try:
        length = len(iter(entry_keys).next())
    except KeyError:
        return
    func_l = ["(key[{0}] is None or x[{0}] == key[{0}])".format(i) for i in range(length)]
    func_s = "lambda x,key: " + " and ".join(func_l)
    func = eval(func_s)
    for key in entry_keys:
        for k in (x for x in all_entries.keys() if func(x,key)):
            pass
</code></pre>
<p>For me, this is nearly as fast as the static version.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's say you have a dictionary - <code>d</code></p>
<pre><code>d = {(1,2):3,(1,4):5,(2,4):2,(1,3):4,(2,3):6,(5,1):5,(3,8):5,(3,6):9}
</code></pre>
<p>First you can get dictionary keys-</p>
<pre><code>keys = d.keys()
=&gt;
dict_keys([(1, 2), (3, 8), (1, 3), (2, 3), (3, 6), (5, 1), (2, 4), (1, 4)])
</code></pre>
<p>Now let's define a function <code>is_match</code> which can decide for given two tuples, if they are equal or not based on your conditions-<br/>
<code>is_match((1,7),(1,None))</code>, <code>is_match((1,5),(None,5))</code> and <code>is_match((1,4),(1,4))</code> will return <code>True</code> while <code>is_match((1,7),(1,8))</code>, <code>is_match((4,7),(6,12))</code> will return <code>False</code>.</p>
<pre><code>def if_equal(a, b):
    if a is None or b is None:
        return True
    else:
        if a==b:
            return True
        else:
            return False

is_match = lambda a,b: False not in list(map(if_equal, a, b))

tup = (1, None)
matched_keys = [key for key in keys if is_match(key, tup)]
=&gt;
[(1, 2), (1, 3), (1, 4)]
</code></pre>
</div>
<span class="comment-copy">it is not good to use built-ins names for your objects, so <code>filter</code> should be renamed (to <code>filter_entries</code> for example)</span>
<span class="comment-copy">@AzatIbrakov Thanks, I changed it.</span>
<span class="comment-copy">Thanks, very nice idea. Unfortunately, in practice my dictionaries change from time to time. I will need to check whether the cost of rebuilding the lookup table is offset by the speedup for lookups.</span>
<span class="comment-copy">Firstly, building the lookup dictionary is faster than serial searching, so why not just rebuild it? Secondly, there is nothing stopping you adding new data items to the lookup dictionary. If there are deletions they can easily be handled by checking filter results against the data. Udates are more tricky, and are most straightforwardly handled by a lookup rebuild</span>
<span class="comment-copy">Hey good luck. Feel free to mark a chosen answer if inclined</span>
<span class="comment-copy">Would you mind me including this in an MIT-licensed software package?</span>
<span class="comment-copy">Sure no problem</span>
<span class="comment-copy">Let us <a href="http://chat.stackoverflow.com/rooms/145973/discussion-between-chris-and-strubbly">continue this discussion in chat</a>.</span>
<span class="comment-copy">Thanks, but the performance of this solution is even worse than the one I already proposed (see in the question under "variable length").</span>
