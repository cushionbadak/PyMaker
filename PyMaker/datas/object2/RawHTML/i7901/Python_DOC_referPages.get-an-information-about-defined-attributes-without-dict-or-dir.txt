<div class="post-text" itemprop="text">
<p>So, let's say I want to write my own class, rewriting <code>__getattribute__</code> function. Every time, when someone calls attribute, which was not defined, I want it to generate a random int.</p>
<pre><code>X = GetAttribute()
print(X.predefined_attribute) # "First attribute"
X.attr2 = "Hi"
print(X.attr2) # "Hi"
print(X.attr3) # random int
</code></pre>
<p>Obviously, I can't write something like this, as it would cause a recursion.    </p>
<pre><code>class GetAttribute(object):
    def __init__(self):
        self.predefined_attribute = "First attribute"

    def __getattribute__(self, attr): 
        if attr not in self.__dict__: # the bad line
            return randint(0, 9999)
        else:
            return object.__getattribute__(self, attr)
</code></pre>
<p>How, without using <code>__dict__</code>, can I get an information about defined attributes?</p>
</div>
<div class="post-text" itemprop="text">
<p>I strongly urge you to reconsider overriding <code>__getattribute__</code> and use the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>object.__getattr__()</code> hook</a> instead. That method is called automatically for any <em>missing attribute</em>, and won't interfere with <code>dir()</code> or <code>__dict__</code> introspection:</p>
<pre><code>class GetAttribute(object):
    def __init__(self):
        self.predefined_attribute = "First attribute"

    def __getattr__(self, attr):
        # self.__dict__ can be used here but is not needed for your
        # sample usecase.
        return randint(0, 9999)
</code></pre>
<p>Your own implementation is flawed because you failed to check the <em>class</em> for your attribute. <code>__dict__</code> is a descriptor on the class, and trying to access <code>self.__dict__</code> is handled by <code>object.__getattribute__</code> too, triggering your infinite recursion. You can avoid the issue entirely by using  <code>object.__getattribute__</code> <strong>first</strong>. You could just catch the <code>AttributeError</code> exception this could throw:</p>
<pre><code>def __getattribute__(self, attr): 
    try:
        return object.__getattribute__(self, attr)
    except AttributeError:
        return randint(0, 9999)
</code></pre>
<p>The more painful path would be to re-implement the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a> to retrieve your <code>__dict__</code> attribute before testing:</p>
<pre><code>def __getattribute__(self, attr): 
    cls = type(self)
    # retrieve the __dict__ descriptor, and bind it to the instance
    __dict__ = cls.__dict__['__dict__'].__get__(self)
    # test against the instance dictionary and all classes in the MRO
    if attr not in __dict__ and not any(attr in c.__dict__ for c in cls.__mro__):
        return randint(0, 9999)
    return object.__getattribute__(self, attr)
</code></pre>
<p>or you could access <code>self.__dict__</code> via <code>object.__getattribute__(self, '__dict__')</code>. You do have to test the class MRO too, because those provide attributes for your instances too; you wouldn't want <code>X.__class__</code> to return a random integer rather than <code>GetAttribute</code> itself.</p>
<p>However, this use-case is already covered by implementing <code>__getattr__</code> instead, a much cleaner and simpler option.</p>
<p>Last but not least, instead of using <code>object.__getattribute__(self, ...)</code>, you should use <code>super().__getattribute__(...)</code> to ensure you are not skipping any other <code>__getattribute__</code> hooks in your class hierarchy.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need to bypass your own <code>__getattribute__</code>, for example to get at the "real" <code>self.__dict__</code>, you can explicitly call the superclass <code>__getattribute__</code>:</p>
<pre><code>if attr not in super().__getattribute__('__dict__'):
</code></pre>
<p>However, for your case, it'd probably be easier to just implement <code>__getattr__</code> instead of <code>__getattribute__</code>. <code>__getattr__</code> is only called for attribute lookups that <code>__getattribute__</code> raises an <code>AttributeError</code> on:</p>
<pre><code>def __getattr__(self, name):
    return randint(0, 9999)
</code></pre>
</div>
<span class="comment-copy">Your recursion is caused by an assumption that all attributes must live in <code>__dict__</code>. You should check the <i>class</i> first however.</span>
<span class="comment-copy">@MartijnPieters: Whoops. Fixed.</span>
<span class="comment-copy">And testing for <code>attr in instance.__dict__</code>, however way is used to retrieve that object, is not enough; there are other attributes available on the instance that <code>__getattribute__</code> would find but are missed this way. Like <code>instance.__class__</code>.</span>
