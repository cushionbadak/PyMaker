<div class="post-text" itemprop="text">
<p>Does Python have a random number generator that returns only one random integer number each time when <code>next()</code> function is called? Numbers <strong>should not repeat</strong> and the generator should return random integers in the interval <code>[1, 1 000 000]</code> that are unique.</p>
<p>I need to generate more than million different numbers and that sounds as if it is very memory consuming in case all the number are generated at same time and stored in a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are looking for a <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator" rel="noreferrer">linear congruential generator</a> with a full period. This will allow you to get a pseudo-random sequence of non-repeating numbers in your target number range.</p>
<p>Implementing a LCG is actually very simple, and looks like this:</p>
<pre><code>def lcg(a, c, m, seed = None):
    num = seed or 0
    while True:
        num = (a * num + c) % m
        yield num
</code></pre>
<p>Then, it just comes down to choosing the correct values for <code>a</code>, <code>c</code>, and <code>m</code> to guarantee that the LCG will generate a full period (which is the only guarantee that you get non-repeating numbers). As the Wikipedia article explains, the following three conditions need to be true:</p>
<ol>
<li><code>m</code> and <code>c</code> need to be relatively prime.</li>
<li><code>a - 1</code> is divisible by all prime factors of <code>m</code></li>
<li><code>a - 1</code> is divisible by 4, if <code>m</code> is also divisible by 4.</li>
</ol>
<p>The first one is very easily guaranteed by simply choosing a prime for <code>c</code>. Also, this is the value that can be chosen last, and this will ultimately allow us to mix up the sequence a bit.</p>
<p>The relationship between <code>a - 1</code> and <code>m</code> is more complicated though. In a full period LCG, <code>m</code> is the length of the period. Or in other words, it is the number range your numbers come from. So this is what you are usually choosing first. In your case, you want <code>m</code> to be around <code>1000000</code>. Choosing exactly your maximum number might be difficult since that restricts you a lot (in both your choice of <code>a</code> and also <code>c</code>), so you can also choose numbers larger than that and simply skip all numbers outside of your range later.</p>
<p>Let’s choose <code>m = 1000000</code> now though. The prime factors of <code>m</code> are <code>2</code> and <code>5</code>. And it’s also obviously divisible by <code>4</code>. So for <code>a - 1</code>, we need a number that is a multiple of <code>2 * 2 * 5</code> to satisfy the conditions 2 and 3. Let’s choose <code>a - 1 = 160</code>, so <code>a = 161</code>.</p>
<p>For <code>c</code>, we are using a random prime that’s somewhere in between of our range: <code>c = 506903</code></p>
<p>Putting that into our LCG gives us our desired sequence. We can choose any seed value from the range (<code>0 &lt;= seed &lt;= m</code>) as the starting point of our sequence.</p>
<p>So let’s try it out and verify that what we thought of actually works. For this purpose, we are just collecting all numbers from the generator in a set until we hit a duplicate. At that point, we should have <code>m = 1000000</code> numbers in the set:</p>
<pre><code>&gt;&gt;&gt; g = lcg(161, 506903, 1000000)
&gt;&gt;&gt; numbers = set()
&gt;&gt;&gt; for n in g:
        if n in numbers:
            raise Exception('Number {} already encountered before!'.format(n))
        numbers.add(n)

Traceback (most recent call last):
  File "&lt;pyshell#5&gt;", line 3, in &lt;module&gt;
    raise Exception('Number {} already encountered before!'.format(n))
Exception: Number 506903 already encountered before!
&gt;&gt;&gt; len(numbers)
1000000
</code></pre>
<p>And it’s correct! So we did create a pseudo-random sequence of numbers that allowed us to get non-repeating numbers from our range <code>m</code>. Of course, by design, this sequence will be always the same, so it is only random once when you choose those numbers. You can switch up the values for <code>a</code> and <code>c</code> to get different sequences though, as long as you maintain the properties mentioned above.</p>
<hr/>
<p>The big benefit of this approach is of course that you do not need to store all the previously generated numbers. It is a constant space algorithm as it only needs to remember the initial configuration and the previously generated value.</p>
<p>It will also not deteriorate as you get further into the sequence. This is a general problem with solutions that just keep generating a random number until a new one is found that hasn’t been encountered before. This is because the longer the list of generated numbers gets, the less likely you are going to hit a numbers that’s not in that list with an evenly distributed random algorithm. So getting the 1000000th number will likely take you a long time to generate with memory based random generators.</p>
<p>But of course, having this simply algorithm which just performs some multiplication and some addition does not appear very random. But you have to keep in mind that this is actually the basis for most pseudo-random number generators out there. So <code>random.random()</code> uses something like this internally. It’s just that the <code>m</code> is <em>a lot larger</em>, so you don’t notice it there.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really care about the memory you could use a <code>NumPy</code> array (or a Python <a href="https://docs.python.org/3/library/array.html" rel="nofollow noreferrer"><code>array</code></a>). </p>
<p>A one million NumPy array of <code>int32</code> (more than enough to contain integers between 0 and 1 000 000) will only consume ~4MB, Python itself would require ~36MB (roughly 28byte per integer and 8 byte for each list element + overallocation) for an identical list:</p>
<pre><code>&gt;&gt;&gt; # NumPy array
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.arange(1000000, dtype=np.int32).nbytes
4 000 000

&gt;&gt;&gt; # Python list
&gt;&gt;&gt; import sys
&gt;&gt;&gt; import random
&gt;&gt;&gt; l = list(range(1000000))
&gt;&gt;&gt; random.shuffle(l)
&gt;&gt;&gt; size = sys.getsizeof(l)                         # size of the list
&gt;&gt;&gt; size += sum(sys.getsizeof(item) for item in l)  # size of the list elements
&gt;&gt;&gt; size
37 000 108
</code></pre>
<p>You only want unique values and you have a consecutive range (1 million requested items and 1 million different numbers), so you could simply shuffle the range and then yield items from your shuffled array:</p>
<pre><code>def generate_random_integer():
    arr = np.arange(1000000, dtype=np.int32)
    np.random.shuffle(arr)
    yield from arr 
    # yield from is equivalent to:
    # for item in arr:     
    #     yield item
</code></pre>
<p>And it can be called using <code>next</code>:</p>
<pre><code>&gt;&gt;&gt; gen = generate_random_integer()
&gt;&gt;&gt; next(gen)
443727
</code></pre>
<p>However that will throw away the performance benefit of using NumPy, so in case you want to use NumPy don't bother with the generator and just perform the operations (vectorized - if possible) on the array. It consumes much less memory than Python and it could be orders of magnitude faster (factors of 10-100 faster are not uncommon!).</p>
</div>
<div class="post-text" itemprop="text">
<p>For a large number of non-repeating random numbers use an encryption.  With a given key, encrypt the numbers: 0, 1, 2, 3, ...  Since encryption is uniquely reversible then each encrypted number is guaranteed to be unique, provided you use the same key.  For 64 bit numbers use DES.  For 128 bit numbers use AES.  For other size numbers use some Format Preserving Encryption.  For pure numbers you might find Hasty Pudding cipher useful as that allows a large range of different bit sizes and non-bit sizes as well, like [0..5999999].</p>
<p>Keep track of the key and the last number you encrypted.  When you need a new unique random number just encrypt the next number you haven't used so far.</p>
</div>
<div class="post-text" itemprop="text">
<p>Considering your numbers should fit in a 64bit integer, one million of them stored in a list would be up to 64 mega bytes plus the list object overhead, if your processing computer can afford that the easyest way is to use shuffle:</p>
<pre><code>import random
randInts = list(range(1000000))
random.shuffle(randInts)
print(randInts)
</code></pre>
<p>Note that the other method is to keep track of the previously generated numbers, which will get you to the point of having all of them stored too.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import random 

# number of random entries 
x = 1000

# The set of all values 
y = {}
while (x &gt; 0) :
    a = random.randint(0 , 10**10)
    if a not in y :  
        a -= 1
</code></pre>
<p>This way you are sure you have perfectly random unique values
<code>x</code> represents the number of values you want</p>
</div>
<div class="post-text" itemprop="text">
<p>You can easily make one yourself:</p>
<pre><code>from random import random

def randgen():
    while True:
        yield random()


ran = randgen()
next(ran)  
next(ran)
...
</code></pre>
</div>
<span class="comment-copy">Maybe use <a href="https://docs.python.org/3/library/uuid.html" rel="nofollow noreferrer">docs.python.org/3/library/uuid.html</a>? <code>uuid.uuid4()</code></span>
<span class="comment-copy">how about extracting the distinct number from the time function? <code>print "%.20f" % time.time()</code></span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/random.html" rel="nofollow noreferrer">docs.python.org/3/library/random.html</a></span>
<span class="comment-copy">I think it's important to know what kind of random numbers you want. If you simply use <code>random.random()</code> to get a floating point value in the range between 0 and 1 you probably don't need to care about uniques (it's <i>really unlikely</i> that you get the same number twice) but if you want to get integers (say from 0-10 000 000) it's not that uncommon to get at least a few duplicates even if the range is ten times bigger. Without these details any answer will be speculative. You can increase your chances to get a really helpful answer by providing more of your <i>actual</i> requirements.</span>
<span class="comment-copy">@MSeifert thank you allready edited questions. I need integers that are not repeated.</span>
<span class="comment-copy">good answer, but I wonder, why the generator function?, also notice the python3 tag, you can simply do <code>yield from arr</code></span>
<span class="comment-copy">@DanielSanchez You're right. I haven't looked at the tags. The generator is included because he specifically asked for one: " that returns only one random integer number each time when next() function is called".</span>
<span class="comment-copy">Yeah, i did not saw that, you got my points, very interesting aproach with numpy :)</span>
<span class="comment-copy">Good ieda but I used LCG in the end because it was simpler.</span>
<span class="comment-copy">Python integers aren't 64bit, on my computer they are 28 <b>bytes</b>.</span>
<span class="comment-copy">@MSeifert, actually yes, i wasnt pretty sure so i was researching it,  thanks for confirming that, ill update the answer :)</span>
<span class="comment-copy">If I understand your solution right I have to store all numbers that I allready generated in dictionary <code>y</code>? That is something I do not want to do since I want to have nice solution that does not spend too much memory.</span>
<span class="comment-copy"><code>random.random</code> does not return an int, and is also not guaranteed to produce unique numbers (otherwise it wouldn’t be random).</span>
