<div class="post-text" itemprop="text">
<p>I found this task for implement a class named AccessList(type list) in python:</p>
<ul>
<li>Create a class AccessList(list) which behaves like a "normal" list with this feature:</li>
<li>there is managed a second intern list which bookmarks the last asked element (in-test). The access to this list is only readable with the property "access"</li>
<li>if there is an in-test, then the asked element should be added to the 2nd list</li>
<li>if you iterate over an instance of AccessList the access property should not change itself</li>
</ul>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt;a = AccessList()
&gt;&gt;&gt;a.extend([1,2,3])
&gt;&gt;&gt;a
[1,2,3]
&gt;&gt;&gt;a.access
[]
&gt;&gt;&gt;5 in a, 1 in a
False, True
&gt;&gt;&gt;a.access
[1]
&gt;&gt;&gt;1 in a, 3, in a
True, True
&gt;&gt;&gt;a.access
[3,1,1]
&gt;&gt;&gt;a.access.insert(0,17)
&gt;&gt;&gt;a.access
[3,1,1]
</code></pre>
<p>So this is my try:</p>
<pre><code>class AccessList(list):

    def __init__(self, lis=()):
        list.__init__(self, lis)
        self._access = []

    def _get_access(self):
        return self._access[:]

    access = property(_get_access, None, None, None)
</code></pre>
<p>But now I got no idea how to implement the in-test?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer"><code>__contains__</code></a> method is responsible for managing the <code>in</code> checks:</p>
<pre><code>class AccessList(list):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._access = []

    @property
    def access(self):
        return self._access[::-1]  # return a reversed copy

    def __contains__(self, item):
        res = super().__contains__(item)  # check if it contains the item
        if res:
            self._access.append(item)     # if it's contained append it to access
        return res
</code></pre>
<p>I made some changes here that don't really change the functionality but are considered good style:</p>
<ul>
<li>Using <code>super</code> instead of hardcoding the superclass explicitly.</li>
<li>Using <code>@property</code> to create the property.</li>
<li>Accepting <code>*args, **kwargs</code> in <code>__init__</code> and passing them to the superclass <code>__init__</code>. You don't care what is passed to the <code>__init__</code> so you can accept anything and let the superclass figure out what should be done.</li>
<li>You could use <code>self._access.copy()</code> instead of <code>self._access[:]</code>. I feel it's a bit clearer what happens. However if your list <strong>may</strong> contain mutable objects you need to use <code>copy.deepcopy(self._access)</code>, otherwise you could alter the instances inside the <code>_access</code> list!</li>
</ul>
<p>And it passes your tests:</p>
<pre><code>&gt;&gt;&gt; a = AccessList()
&gt;&gt;&gt; a.extend([1,2,3])
&gt;&gt;&gt; print(a)
[1, 2, 3]
&gt;&gt;&gt; print(a.access)
[]
&gt;&gt;&gt; print(5 in a, 1 in a)
False True
&gt;&gt;&gt; print(a.access)
[1]
&gt;&gt;&gt; print(1 in a, 3 in a)
True True
&gt;&gt;&gt; print(a.access)
[3, 1, 1]
&gt;&gt;&gt; a.access.insert(0,17)
&gt;&gt;&gt; print(a.access)
[3, 1, 1]
</code></pre>
</div>
<span class="comment-copy">Should it be a property (using it with <code>a.access</code>) or a method (<code>a.access()</code>). Also what exactly should <code>a</code> look like after the <code>a.access.insert(0, 17)</code>?</span>
<span class="comment-copy">@MSeifert sorry, i edited it in the example. It should be a property. After the <code>access.insert(0,17)</code>, the access-list should not be updated.. Only when i do the in-test</span>
<span class="comment-copy">As I mentioned in my answer to  <a href="https://stackoverflow.com/q/44291944/4014959">your previous question</a> it's rather unusual to sub-class the built-in types (in fact, in ancient Python it wasn't possible). There are generally better solution, involving Abstract Base classes. But I guess it makes for an interesting learning exercise.</span>
<span class="comment-copy">You can also subclass <a href="https://docs.python.org/3/library/collections.html#collections.UserList" rel="nofollow noreferrer"><code>collections.UserList</code></a> (or in Python 2: <a href="https://docs.python.org/2/library/userdict.html#UserList.UserList" rel="nofollow noreferrer"><code>UserList.UserList</code></a>).</span>
<span class="comment-copy">Ah! The <code>contains</code>-method! I got one more question: whats the difference in this example using <code>super()</code> or <code>list</code>? Normally it should use the superclass (which is list). But why i got a 'TypeError' when I us your <code>countains</code>-method with <code>list</code> instead of <code>super</code></span>
<span class="comment-copy"><code>list.__contains__</code> returns the unbound method, so you need to pass in <code>self</code>: <code>res = list.__contains__(self, item)</code>.</span>
<span class="comment-copy">More generally: <code>super()</code> determines the correct bound method depending on your inheritance. You can avoid hard-coding the superclass and passing in <code>self</code> as argument. It's just easier to use and prevents some bugs, and eases maintenance (for example if you change the inheritance).</span>
<span class="comment-copy">Ninja'd. My code's almost identical to yours, except I used <code>result</code> instead of <code>res</code>. :) And my <code>access</code> getter just returns <code>self._access</code> rather than making a copy via slicing; I don't think that's necessary here.</span>
<span class="comment-copy">BTW, your code (and mine) appends to the access list, but from the demo it lookslike the OP wants to insert the new items at the front of the list. Of course, that's inefficient and should be avoided unless its totally necessary, and if you do want to copy the access list in your getter you can just do the reversing thereL <code>return self._access[::-1]</code>.</span>
