<div class="post-text" itemprop="text">
<p>I imported readline to add customized tab completion to my program. Now i need to save the output of the program, but any attempt of redirecting stdout breaks the tab completion functionality.</p>
<p>I tried <code>python3 script.py | tee txt.txt</code> witch seemed to come closest to printing to both stdout and a text file, but it doesnt work.</p>
<p>here is the custom tab completion class with function call from main (just in case):</p>
<pre><code>import readline

class MyCompleter(object):

    def __init__(self, options):
        self.options = sorted(options)

    def complete(self, text, state):
        if state == 0:  
            if text: 
                self.matches = [s for s in self.options if s and s.startswith(text)]
            else:  
                self.matches = self.options[:]
        try: 
            return self.matches[state]
        except IndexError:
            return None

def readlineset(a): # function called from main to turn on tab completion
                    # a is list of strings
    readline.set_completer(MyCompleter(a).complete)
    readline.parse_and_bind('tab: complete')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a possible solution: "monkey-patch" the <code>sys.stdout.write</code> method so that anything written to <code>stdout</code> also gets sent to a file. I admit that this isn't exactly elegant, but it works. ;)</p>
<p>I've made the <code>Logger</code> class a <a href="https://docs.python.org/3/library/stdtypes.html#typecontextmanager" rel="nofollow noreferrer">Context Manager</a> so that it can be used in a <code>with</code> statement.</p>
<pre><code>import readline
import sys

class MyCompleter(object):
    def __init__(self, options):
        self.options = sorted(options)

    def complete(self, text, state):
        if state == 0:
            if text: 
                self.matches = [s for s in self.options if s and s.startswith(text)]
            else:
                self.matches = self.options[:]
        try:
            return self.matches[state]
        except IndexError:
            return None

class Logger(object):
    ''' Monkey-patch sys.stdout
        to copy output to a file
    '''
    def __init__(self, fname):
        self.fh = open(fname, 'w')
        self.oldwrite = sys.stdout.write
        sys.stdout.write = self.write

    def write(self, s):
        self.oldwrite(s)
        self.fh.write(s)

    def close(self):
        self.fh.close()
        sys.stdout.write = self.oldwrite

    # Define Context Manager methods so Logger 
    # can be used in a `with` statement
    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()
        return False

def readlineset(a):
    ''' Turn on tab completion. 
        `a` is list of strings that will be completed
    '''
    readline.set_completer(MyCompleter(a).complete)
    readline.parse_and_bind('tab: complete')

def main():
    readlineset(['python', 'stack', 'overflow', 'exchange'])
    with Logger('mylog.txt'):
        while True:
            s = input('&gt; ')
            if s == 'quit':
                break
            print(repr(s), len(s))

    print('bye')

if __name__ == '__main__':
    main()
</code></pre>
<p><strong>demo</strong></p>
<pre><code>&gt; This is a test
'This is a test' 14
&gt; python on stack overflow
'python on stack overflow' 24
&gt; quit
bye
</code></pre>
<p><strong>mylog.txt</strong></p>
<pre><code>'This is a test' 14
'python on stack overflow' 24
</code></pre>
<p>If you don't want to use <code>with</code>, you can use <code>Logger</code> like this:</p>
<pre><code>def main():
    readlineset(['python', 'stack', 'overflow', 'exchange'])
    logger = Logger('mylog.txt')
    while True:
        s = input('&gt; ')
        if s == 'quit':
            break
        print(repr(s), len(s))

    logger.close()
    print('bye')
</code></pre>
</div>
<span class="comment-copy"><a href="https://bugs.python.org/issue24829" rel="nofollow noreferrer">Possibly related Python Issue</a>. Background: readline is designed to work on interactive terminals, but redirecting the output to somewhere else (even if it echoes it back to you, like <code>tee</code>), makes the terminal appear non-interactive to readline.</span>
<span class="comment-copy">Perhaps you would prefer using <code>typescript</code> if you want to record the output of your interactive session (instead of <code>tee</code>)?</span>
