<div class="post-text" itemprop="text">
<p>I've been gong through the tutorials about multithreading and queue in python3. As the <a href="https://docs.python.org/3.6/library/queue.html" rel="nofollow noreferrer">official tutorial</a> goes, "The Queue class in this module implements all the required locking semantics". But in <a href="https://www.tutorialspoint.com/python3/python_multithreading.htm" rel="nofollow noreferrer">another tutorial</a>, I've seen an example as following:</p>
<pre><code>import queue
import threading
import time

exitFlag = 0

class myThread (threading.Thread):
   def __init__(self, threadID, name, q):
      threading.Thread.__init__(self)
      self.threadID = threadID
      self.name = name
      self.q = q
   def run(self):
      print ("Starting " + self.name)
      process_data(self.name, self.q)
      print ("Exiting " + self.name)

def process_data(threadName, q):
   while not exitFlag:
      queueLock.acquire()
      if not workQueue.empty():
         data = q.get()
         queueLock.release()
         print ("%s processing %s" % (threadName, data))
      else:
         queueLock.release()
         time.sleep(1)

threadList = ["Thread-1", "Thread-2", "Thread-3"]
nameList = ["One", "Two", "Three", "Four", "Five"]
queueLock = threading.Lock()
workQueue = queue.Queue(10)
threads = []
threadID = 1

# Create new threads
for tName in threadList:
   thread = myThread(threadID, tName, workQueue)
   thread.start()
   threads.append(thread)
   threadID += 1

# Fill the queue
queueLock.acquire()
for word in nameList:
   workQueue.put(word)
queueLock.release()

# Wait for queue to empty
while not workQueue.empty():
   pass

# Notify threads it's time to exit
exitFlag = 1

# Wait for all threads to complete
for t in threads:
   t.join()
print ("Exiting Main Thread")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe the tutorial you're following is a bad example of how to use Python's threadsafe queue. In particular, the tutorial is using the threadsafe queue in a way that unfortunately requires an extra lock. Indeed, this extra lock means that the threadsafe queue in the tutorial could be replaced with an old-fashioned non-threadsafe queue based on a simple list.</p>
<p>The reason that locking is needed is hinted at by the documentation for <a href="https://docs.python.org/3/library/queue.html#queue.Queue.empty" rel="noreferrer"><code>Queue.empty()</code></a>:</p>
<blockquote>
<p>If empty() returns <code>False</code> it doesn't guarantee that a subsequent call to get() will not block.</p>
</blockquote>
<p>The issue is that another thread could run in-between the call to empty() and the call to get(), stealing the item that empty() otherwise reported to exist. The tutorial probably uses the lock to ensure that the thread has exclusive access to the queue from the call to empty() until the call to get(). Without this lock, two threads could enter into the if-statement and both issue a call to get(), meaning that one of them could block, waiting for an item that will never be pushed.</p>
<hr/>
<p>Let me show you how to use the threadsafe queue properly. Instead of checking empty() first, just rely directly on the blocking behavior of get():</p>
<pre><code>def process_data(threadName, q):
    while True:
        data = q.get()
        if exitFlag:
            break
        print("%s processing %s" % (threadName, data))
</code></pre>
<p>The queue's internal locking will ensure that two threads do not interfere for the duration of the call to get(), and no queueLock is needed. Note that the tutorial's original code would check exitFlag periodically every 1 second, whereas this modified queue requires you to push a dummy object into the queue after setting exitFlag to <code>True</code> -- otherwise, the flag will never be checked.</p>
<p>The last part of the controller code would need to be modified as follows:</p>
<pre><code># Notify threads it's time to exit
exitFlag = 1
for _ in range(len(threadList)):
    # Push a dummy element causing a single thread to wake-up and stop.
    workQueue.put(None)
# Wait for all threads to exit
for t in threads:
    t.join()
</code></pre>
<hr/>
<p>There is another issue with the tutorial's use of the threadsafe queue, namely that a busy-loop is used in the main thread when waiting for the queue to empty:</p>
<pre><code># Wait for queue to empty
while not workQueue.empty():
    pass
</code></pre>
<p>To wait for the queue to empty it would be better to use <a href="https://docs.python.org/3/library/queue.html#queue.Queue.task_done" rel="noreferrer">Queue.task_done()</a> in the threads and then call <a href="https://docs.python.org/3/library/queue.html#queue.Queue.join" rel="noreferrer">Queue.join()</a> in the main thread. At the end of the loop body in process_data(), call <code>q.task_done()</code>. In the main controller code, instead of the while-loop above, call <code>q.join()</code>.</p>
<p>See also the <a href="https://docs.python.org/3/library/queue.html#queue.Queue.join" rel="noreferrer">example</a> in the bottom of Python's documentation page on the queue module.</p>
<hr/>
<p>Alternatively, you can keep the queueLock and replace the threadsafe queue with a plain old list as follows:</p>
<ul>
<li>Replace <code>workQueue = queue.Queue(10)</code> with <code>workQueue = []</code></li>
<li>Replace <code>if not workQueue.empty()</code> with <code>if len(workQueue) &gt; 0</code></li>
<li>Replace <code>workQueue.get()</code> with <code>workQueue.pop(0)</code></li>
<li>Replace <code>workQueue.put(word)</code> with <code>workQueue.append(word)</code></li>
</ul>
<p>Note that this doesn't preserve the blocking behavior of put() present in the original version.</p>
</div>
<span class="comment-copy">The trivial answer is official docs &gt; tutorialspoint.</span>
<span class="comment-copy">Thanks a lot. Another question, such that when a thread gets the exitFlag as 1 it will definitely terminate, I suppose that when the code runs to the last part to call join() on those thread, they should all have terminated, so what's the point of calling the join() on them?</span>
