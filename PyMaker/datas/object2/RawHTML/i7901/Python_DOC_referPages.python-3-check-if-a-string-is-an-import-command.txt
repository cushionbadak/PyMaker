<div class="post-text" itemprop="text">
<p>I want to check a string - is it an import command? I have tried</p>
<pre><code># Helper - analyses a string - is it an import string?
"""
fromlike   - from foo import bar
classic    - import foo
classic_as - import foo as baz
"""
def check_is_import(string):
    importname = ''
    fromlike   = False
    classic    = False
    classic_as = False
    if string[0:4] is 'from':
        fromlike = True
        importname = ''
    if not fromlike and (string[0:6] is 'import'):
        classic = True
        importname = string.split(' ')[1]
    if classic:
        commandlist = string.split(' ')
        if commandlist[2] is 'as':
            classic_as = True
            importname = commandlist[3]
            del commandlist
    if fromlike:
        return ('fromlike', importname)
    elif classic and (not classic_as):
        return ('classic', importname)
    elif classic_as:
        return ('classic_as', importname)
    else:
        return ('no_import', importname)
</code></pre>
<p>but it worked for "fromlike" imports. (Note: I'm not asking "why does this code don't work?", I'm just searching a solution) What code will sure detect all imports? Basically my code takes a slice of the string. If the <code>[0:4]</code> slice equals <code>'from'</code>, the string is a "fromlike import". Else: if the <code>[0:6]</code> slice equals <code>'import'</code>, the string is a "classic import". If it detects <code>'as'</code>, it will find the pseudo-name. This function must return a tuple which contains the import type under index 0 and imported module-name under index 1.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to be sure to handle all Python import forms, have <em>Python do the parsing</em>. Use the <a href="https://docs.python.org/3/library/ast.html#ast.parse" rel="nofollow noreferrer"><code>ast.parse()</code> function</a> and use the resulting parse tree; you'll either get <code>Import</code> or <code>ImportFrom</code> objects:</p>
<pre><code>  | Import(alias* names)
  | ImportFrom(identifier? module, alias* names, int? level)
</code></pre>
<p>Each <code>alias</code> consists of a name and optional identifier used to import the name <em>as</em>:</p>
<pre><code>-- import name with optional 'as' alias.
alias = (identifier name, identifier? asname)
</code></pre>
<p>Note that there can be <em>multiple imports</em>! You either have <code>classic</code> or <code>fromlike</code> imports, and both can import multiple names. Your function needs to return a <strong>list</strong> of <code>(type, name)</code> tuples. For invalid inputs, raise an exception (<code>ValueError</code> is a good fit here):</p>
<pre><code>import ast

def check_is_import(string):
    try:
        body = ast.parse(string).body
    except SyntaxError:
        # not valid Python
        raise ValueError('No import found')
    if len(body) &gt; 1:
        # not a single statement
        raise ValueError('Multiple statements found')
    if not isinstance(body[0], (ast.Import, ast.ImportFrom)):
        raise ValueError('No import found')
    type_ = 'classic' if isinstance(body[0], ast.Import) else 'fromlike'
    results = []
    for alias in body[0].names:
        alias_type = type_
        if alias.asname:
            alias_type += '_as'
        results.append((alias_type, alias.asname or alias.name))
    return results
</code></pre>
<p>The method should probably be renamed to <code>extract_import_names()</code>, as that reflects what it does much better.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; check_is_import('from foo import bar')
[('fromlike', 'bar')]
&gt;&gt;&gt; check_is_import('import foo')
[('classic', 'foo')]
&gt;&gt;&gt; check_is_import('import foo as baz')
[('classic_as', 'baz')]
&gt;&gt;&gt; check_is_import('from foo import bar, baz as spam, monty as python')
[('fromlike', 'bar'), ('fromlike_as', 'spam'), ('fromlike_as', 'python')]
&gt;&gt;&gt; check_is_import('import foo as baz, baz, spam as ham')
[('classic_as', 'baz'), ('classic', 'baz'), ('classic_as', 'ham')]
&gt;&gt;&gt; check_is_import('invalid python')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 3, in check_is_import
  File "/Users/mjpieters/Development/Library/buildout.python/parts/opt/lib/python3.6/ast.py", line 35, in parse
    return compile(source, filename, mode, PyCF_ONLY_AST)
  File "&lt;unknown&gt;", line 1
    invalid python
                 ^
SyntaxError: invalid syntax

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 6, in check_is_import
ValueError: No import found
&gt;&gt;&gt; check_is_import('import foo; import bar')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 9, in check_is_import
ValueError: Multiple statements found
&gt;&gt;&gt; check_is_import('1 + 1 == 2')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 11, in check_is_import
ValueError: No import found
</code></pre>
</div>
<span class="comment-copy">Why have a dog and bark yourself? Use <a href="https://docs.python.org/3/library/ast.html#ast.parse" rel="nofollow noreferrer"><code>ast.parse()</code></a> and look at the resulting AST tree.</span>
<span class="comment-copy">@MartijinPieters Please give me an example.</span>
<span class="comment-copy">In the process of writing an answer. :-)</span>
<span class="comment-copy">What should happen for multiple names? <code>import foo, bar, baz as spam</code>?</span>
<span class="comment-copy">Same as importing them as separate <code>import</code> commands, but returns <code>('classic_multi_as', 'spam')</code></span>
<span class="comment-copy">Error! Explained in the question.</span>
<span class="comment-copy">@VladislavToncharov: long ago already rectified.</span>
