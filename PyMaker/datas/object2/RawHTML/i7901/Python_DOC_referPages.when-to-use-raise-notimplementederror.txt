<div class="post-text" itemprop="text">
<p>Is it to for remembering yourself and your team to implement the class correctly?
I don't fully get the use of an abstract class like this:</p>
<pre><code>class RectangularRoom(object):
    def __init__(self, width, height):
        raise NotImplementedError

    def cleanTileAtPosition(self, pos):
        raise NotImplementedError

    def isTileCleaned(self, m, n):
        raise NotImplementedError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As the documentation states <a href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" rel="noreferrer"><sup>[docs]</sup></a>, </p>
<blockquote>
<p>In user defined base classes, abstract methods should raise this exception when they require derived classes to override the method, or while the class is being developed to indicate that the real implementation still needs to be added.</p>
</blockquote>
<p>Note that although the main stated use case this error is the indication of abstract methods that should be implemented on inherited classes, you can use it anyhow you'd like, like for indication of a <code>TODO</code> marker.</p>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/a/44316063/4653485">Uriel says</a>, it is meant for a method in an abstract class that should be implemented in child class, but can be used to indicate a TODO as well.</p>
<p>There is an alternative for the first use case: <a href="https://docs.python.org/3.4/library/abc.html" rel="noreferrer">Abstract Base Classes</a>. Those help creating abstract classes.</p>
<p>Here's a Python 3 example:</p>
<pre><code>class C(abc.ABC):
    @abstractmethod
    def my_abstract_method(self, ...):
    ...
</code></pre>
<p>When instantiating <code>C</code>, you'll get an error because <code>my_abstract_method</code> is abstract. You need to implement it in a child class.</p>
<pre><code>TypeError: Can't instantiate abstract class C with abstract methods my_abstract_method
</code></pre>
<p>Subclass <code>C</code> and implement <code>my_abstract_method</code>.</p>
<pre><code>class D(C):
    def my_abstract_method(self, ...):
    ...
</code></pre>
<p>Now you can instantiate <code>D</code>.</p>
<p><code>C.my_abstract_method</code> does not have to be empty. It can be called from <code>D</code> using <code>super()</code>.</p>
<p>An advantage of this over <code>NotImplementedError</code> is that you get an explicit <code>Exception</code> at instantiation time, not at method call time.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider if instead it was:</p>
<pre><code>class RectangularRoom(object):
    def __init__(self, width, height):
        pass

    def cleanTileAtPosition(self, pos):
        pass

    def isTileCleaned(self, m, n):
        pass
</code></pre>
<p>and you subclass and forget to tell it how to <code>isTileCleaned()</code> or, perhaps more likely, typo it as <code>isTileCLeaned()</code>. Then in your code, you'll get a <code>None</code> when you call it. </p>
<ul>
<li>Will you get the overridden function you wanted? Definitely not.</li>
<li>Is <code>None</code> valid output? Who knows.  </li>
<li>Is that intended behavior? Almost certainly not. </li>
<li>Will you get an error? It depends.</li>
</ul>
<p><code>raise NotImplmentedError</code> <em>forces</em> you to implement it, as it <strong>will</strong> throw an exception when you try to run it until you do so. This removes a lot of silent errors. It's similar to why a <a href="https://docs.python.org/2/howto/doanddont.html#except" rel="noreferrer">bare except is almost never a good idea</a>: because people make mistakes and this makes sure they aren't swept under the rug.</p>
<p>Note: Using an abstract base class, as other answers have mentioned, is better still, as then the errors are frontloaded and the program won't run until you implement them (with NotImplementedError, it will only throw an exception if actually called).</p>
</div>
<div class="post-text" itemprop="text">
<p>You might want to you use the <code>@property</code> decorator,</p>
<pre><code>&gt;&gt;&gt; class Foo():
...     @property
...     def todo(self):
...             raise NotImplementedError("To be implemented")
... 
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.todo
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 4, in todo
NotImplementedError: To be implemented
</code></pre>
</div>
<span class="comment-copy">Cross-site dupe: <a href="https://softwareengineering.stackexchange.com/q/231397/110531">softwareengineering.stackexchange.com/q/231397/110531</a></span>
<span class="comment-copy">I would say: When it satisfies the <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment" rel="nofollow noreferrer">"Principle of least astonishment"</a>.</span>
<span class="comment-copy">This is a useful question, as evidenced by the clear answer by Uriel as per the docs, and the value-add answer regarding abstract base classes by Jérôme .</span>
<span class="comment-copy">For abstract methods, I prefer to use <code>abc</code> (see <a href="https://stackoverflow.com/a/44316506/4653485">my answer</a>).</span>
<span class="comment-copy">Available in Python 2.6+ as well. Just <code>from abc import ABCMeta, abstractmethod</code> and define your ABC with <code>__metaclass__ = ABCMeta</code>. Docs: <a href="https://docs.python.org/2/library/abc.html" rel="nofollow noreferrer">docs.python.org/2/library/abc.html</a></span>
<span class="comment-copy">I don't see how this addresses the question, which is <i>when to use it</i>.</span>
