<div class="post-text" itemprop="text">
<p>I have a class called <code>A</code>:</p>
<pre><code>&gt;&gt;&gt; class A:
    def __init__(self):
        self.register = {}


&gt;&gt;&gt; 
</code></pre>
<p>class <code>A</code> will be sub-classed by class <code>B</code>. class <code>B</code> however, contains methods that need to be registered as a <code>name: function</code> pair in instances of class <code>A</code>'s dictionary. This is so class <code>A</code> can do work using the methods.</p>
<p>Here is an example of what I mean:</p>
<pre><code>&gt;&gt;&gt; class B(A):
    def foo(self):
        pass
    def bar(self):
        pass


&gt;&gt;&gt; b = B()
&gt;&gt;&gt; b.register # foo and bar were registered
{'key': &lt;foo function&gt;, 'key2': &lt;bar function&gt;}
&gt;&gt;&gt; 
</code></pre>
<p>Is there an idiomatic way to solve this? Or is something like this not possible, and it would be better to change my codes structure.</p>
<hr/>
<p>Note this is not a duplicate of <a href="https://stackoverflow.com/questions/44220434/is-it-possible-to-share-a-method-reference-defined-in-subclass-insatnces-with-in?noredirect=1#44220623">Auto-register class methods using decorator</a> because my register is not global, it is an instance variable of a class. This means using a meta-class like shown in the selected answer would not work.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you will declare all classes you need, and after that worry about <em>instance</em> registers have references to all declared methods in all subclasses, you just need to performa a "register" information when declaring the subclasses themselves. That is easy to do in Python 3.6 (but not 3.5) with the new <a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__" rel="nofollow noreferrer"><code>__init_subclass__</code> mechanism</a>. In Python 3.5 and before that, it is easier performed using a metaclass. </p>
<pre><code>class FallbackDict(dict):
    def __init__(self, fallback):
         self.fallback = fallback
    def __missing__(self, key):
          value = self.fallback[key]
          self[key] = value
          return value

class A:
    register = {}
    def __init__(self):
          # instance register shadows global register
          # for access via "self."
          self.register = FallbackDict(__class__.register)

    def __init_subclass__(cls):
          for attrname, value in cls.__dict__.items():
               if callable(value):
                    __class__.register[attrname] = value
</code></pre>
<p>The code here is meant to be simple - the custom dict class will "copy on read" values of the A.regiser dictionary into the instance dictionary. If you need a more consistent dictionary that include this behavior (for example, one that will iterate correctly the keys, values and items of both itself and the fallback dictionary) you'd better implement the "FallbackDict" class as an instance of collections.abc.MutableMapping instead (and just use an aggregate dictionary to actually keep the data)</p>
<p>You don't need the custom dict at all if you plan to create all your classes that register new methods before creating any instance of "A" - or if newly created classes don't have to update the existing instances - but in that case, you should copy A.register to the instance's "self.register" inside <code>__init__</code>.</p>
<p>If you can't change to Python 3.6 you will also need a custom metaclass to trigger the <code>__init_subclass__</code> method above. Just keep it as is, so that your code is ready to move to Python 3.6 and eliminate the metaclass, and add a metaclass something like:</p>
<pre><code>class MetaA(type):
    def __init__(cls, name, bases, namespace):
         super().__init__(name, bases, namespace)
         cls.__init_subclass__()

class A:
    ...
    @clasmethod
    def __init_subclass__(cls):
        # as above
        ...   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the link to <a href="https://stackoverflow.com/questions/3054372/auto-register-class-methods-using-decorator">this question</a> you mentioned in your post really can be used to solve your problem, if I understand it correctly.</p>
<p>The information you're trying to register <em>is</em> global information. While you want each instance to have a register containing this global information, all you really need to do is have <code>__init__</code> copy the global register into the instance register.</p>
</div>
<span class="comment-copy">can you add a TL;DR to the bottom?</span>
<span class="comment-copy">What is this for; what kind of behaviour do you want to implement with it? You can't access an instance attribute at class definition time; there <i>is</i> no instance yet.</span>
<span class="comment-copy">@jonrsharpe I guess your right. I was trying to implement a regex based lexer. I was trying to allow a user to map a certain regex pattern to a function using decorators. That way, whenever that specific regex was matched, the function would be called. I thought using decorators would be a concise way to do this.</span>
<span class="comment-copy">Your TL;DR is just the title again, and <i>still</i> doesn't actually mention <i>what you're trying to do</i>... This is currently an XY problem.</span>
<span class="comment-copy">@jonrsharpe I apologize, but I'm not exactly sure how to describe my problem that concisely. However, your right. After looking back over my code, I see this is somewhat of an XY question. I'll edit my question to clarify.</span>
