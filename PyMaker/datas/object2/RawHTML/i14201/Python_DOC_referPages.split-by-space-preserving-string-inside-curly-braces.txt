<div class="post-text" itemprop="text">
<pre><code>str = "cmd -opt1 { a b c  d e f g h } -opt2" 
</code></pre>
<p>I want output like this:  </p>
<pre><code>[ 'cmd', '-opt1', '{ a b c  d e f g h }', '-opt2' ]  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this situation, don't try to split, use <code>re.findall</code>:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall(r'{[^}]*}|\S+', 'cmd -opt1 { a b c  d e f g h } -opt2')
['cmd', '-opt1', '{ a b c  d e f g h }', '-opt2']
</code></pre>
<p>if you have to deal with nested curly brackets, the re module doesn't suffice, you need to use the <a href="https://pypi.python.org/pypi/regex" rel="nofollow">"new" regex module</a> that has the recursion feature.</p>
<pre><code>&gt;&gt;&gt; import regex
&gt;&gt;&gt; regex.findall(r'[^{}\s]+|{(?:[^{}]+|(?R))*+}', 'cmd -opt1 { a b {c d} e f} -opt2')
['cmd', '-opt1', '{ a b {c d} e f}', '-opt2']
</code></pre>
<p>Where <code>(?R)</code> refers to the whole pattern itself.</p>
<p>or this one (that is better):</p>
<pre><code>regex.findall(r'[^{}\s]+|{[^{}]*+(?:(?R)[^{}]*)*+}', 'cmd -opt1 { a b {c d} e f} -opt2')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>\s+(?![^{]*})
</code></pre>
<p>You can split by this.See demo.</p>
<p><a href="https://regex101.com/r/jV9oV2/6" rel="nofollow">https://regex101.com/r/jV9oV2/6</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Do take a look at <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow">the <code>argparse</code> module</a>, since I assume you are writing code to parse the arguments of your program.  Normally these arguments are stored in <code>sys.argv</code>, so you don't even need to care about splitting the command line string.  If you insist on using the command line, you may convert your argument string to an argument list with the <code>str.split</code> method.</p>
<pre><code>import argparse

parser = argparse.ArgumentParser(description='whatever cmd does.')
parser.add_argument('--opt1', metavar='N', type=int, nargs='+',
                   help='integers')

options = parser.parse_args()

for n in options.opt1:
   # do something with n
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just split on the <code>{</code> and <code>}</code> then split the separate parts by a regular space:</p>
<pre><code>str = "cmd -opt1 { a b c d e f g h } -opt2"
&gt;&gt;&gt; a, b = str.split("{")
&gt;&gt;&gt; c, d = b.split("}")
&gt;&gt;&gt; a.split() + ["{{{0}}}".format(c)] + d.split()
['cmd', '-opt1', '{ a b c d e f g h }', '-opt2']
</code></pre>
</div>
<span class="comment-copy">So where is your code, and what exactly is the problem with it? That appears to be command line input, why are you parsing it manually rather than getting it via <code>sys.argv</code>?</span>
<span class="comment-copy">This string is not from command line input.</span>
<span class="comment-copy">So where <i>is</i> it from? This is likely an <a href="http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a> that can be solved <i>before</i> you reach this step.</span>
<span class="comment-copy">I am parsing a file that contains these command. These command are given on tcl prompt. Tcl treats everything inside {} as a string.  I also want to parse command  with recursive curly "cmd -opt1 { a b {c d} e f} -opt2"</span>
<span class="comment-copy">There are quite a few SO questions on parsing TCL format in Python already (e.g. <a href="http://stackoverflow.com/q/5558276/3001761">stackoverflow.com/q/5558276/3001761</a>, <a href="http://stackoverflow.com/q/26288633/3001761">stackoverflow.com/q/26288633/3001761</a>); have you looked at any of them? That kind of background information really helps people point you to the best information.</span>
<span class="comment-copy">I also want to parse command with curly inside curly braces e.g. "cmd -opt1 { a b {c d} e f} -opt2". So output like : ['cmd', '-opt1', '{ a b {c  d} e f}', '-opt2']. Is this also possible somehow ?</span>
<span class="comment-copy">@DeepakY: Yes it is possible, but not with the re module, you need to use the "new" regex module: <a href="https://pypi.python.org/pypi/regex" rel="nofollow noreferrer">pypi.python.org/pypi/regex</a> that allows recursive patterns: <code>regex.findall(r'[^{}\s]+|{(?&gt;[^{}]+|(?R))*}', 'cmd...</code></span>
<span class="comment-copy">I believe the <code>parse_args</code> method expects a list, like it would get from <code>sys.argv</code>; will it work correctly on a string?</span>
<span class="comment-copy">It uses <code>sys.argv</code> by default.  It will not work on a string (will treat it as a list of characters)</span>
<span class="comment-copy">So if the OP has a <i>string</i>, how does this help them? You should at least include that caveat clearly in the answer.</span>
<span class="comment-copy"><i>"you may convert your argument string to an argument list with the <code>str.split</code> method"</i> - that is <b>exactly what they're having trouble with</b>, as their string contains some spaces they want to split on and some they don't...</span>
<span class="comment-copy">Thanks @jonrsharpe.  I have a knack for pointing towards solutions that are not directly related to the question.    Don't you think this is a design issue: parsing a string that's going to be used by another program?  Not using standard available components, like here, leads to tons of code that aren't really needed.  That's why I posted this answer.</span>
