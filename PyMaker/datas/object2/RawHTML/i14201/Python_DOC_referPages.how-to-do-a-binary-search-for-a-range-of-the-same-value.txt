<div class="post-text" itemprop="text">
<p>I have a sorted list of numbers and I need to get it return the range of index that the number appears. My list is:</p>
<pre><code>daysSick = [0, 0, 0, 0, 1, 2, 3, 3, 3, 4, 5, 5, 5, 6, 6, 11, 15, 24]
</code></pre>
<p>If I searched 0, I need to return (0, 3). Right now I can only get it to find the spot of one number! I know how to do the binary search, but I am stuck how to make it move up and down from the position to find the other same values! </p>
<pre><code>low = 0
high = len(daysSick) - 1
while low &lt;= high :
    mid = (low + high) // 2
    if value &lt; daysSick[mid]:
        high = mid - 1
    elif value &gt; list[mid]:
        low = mid + 1
    else:
        return mid
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I present a solution faster than the <a href="https://hg.python.org/cpython/file/2.7/Lib/bisect.py" rel="nofollow">raw functions taken</a> from the <code>bisect</code> library</p>
<h3>Solution</h3>
<p>With <em>Optimised</em> Binary Search</p>
<pre><code>def search(a, x):
    right = 0
    h = len(a)
    while right &lt; h:
        m = (right+h)//2
        if x &lt; a[m]: h = m
        else: 
            right = m+1
    # start binary search for left element only 
    # including elements from 0 to right-1 - much faster!
    left = 0
    h = right - 1
    while left &lt; h:
        m = (left+h)//2
        if x &gt; a[m]: left = m+1
        else: 
            h = m
    return left, right-1

search(daysSick, 5)
(10, 12)

search(daysSick, 2)
(5, 5)
</code></pre>
<h3>Comparision vs. <code>Bisect</code></h3>
<ul>
<li><p>Using customised binary search...</p>
<pre><code>%timeit search(daysSick, 3)
1000000 loops, best of 3: 1.23 µs per loop
</code></pre></li>
<li><p>Copying the raw code from the source from <code>bisect</code> into python...</p>
<pre><code>%timeit bisect_left(daysSick, 1), bisect_right(daysSick, 1)
1000000 loops, best of 3: 1.77 µs per loop
</code></pre></li>
<li><p>Using default import is by far the fastest as I think it might be optimised behind the scenes ...</p>
<pre><code>from bisect import bisect_left, bisect_right
%timeit bisect_left(daysSick, 1), bisect_right(daysSick, 1)
1000000 loops, best of 3: 504 ns per loop
</code></pre></li>
</ul>
<h3>Extra</h3>
<p>Without ext. libraries but not binary search</p>
<pre><code>daysSick = [0, 0, 0, 0, 1, 2, 3, 3, 3, 4, 5, 5, 5, 6, 6, 11, 15, 24]

# using a function
idxL = lambda val, lst:  [i for i,d in enumerate(lst) if d==val]

allVals = idxL(0,daysSick)
(0, 3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you use <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer">python's bisection routines</a>:</p>
<pre><code>&gt;&gt;&gt; daysSick = [0, 0, 0, 0, 1, 2, 3, 3, 3, 4, 5, 5, 5, 6, 6, 11, 15, 24]
&gt;&gt;&gt; from bisect import bisect_left, bisect_right
&gt;&gt;&gt; bisect_left(daysSick, 3)
6
&gt;&gt;&gt; bisect_right(daysSick, 3)
9
&gt;&gt;&gt; daysSick[6:9]
[3, 3, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ok, here's another way that works by attempting to reduce the range first before doing <code>bisect_left</code> and <code>bisect_right</code> on half of the already-reduced range. I wrote this code because I think it is <em>slightly</em> more efficient than just calling <code>bisect_left</code> and <code>bisect_right</code> even though it has the same time complexity.</p>
<pre><code>def binary_range_search(s, x):
    # First we will reduce the low..high range if possible
    # by using symmetric binary search to find an index pointing to x
    low, high = 0, len(s)
    while True:
        if low &gt;= high:
            return None
        mid = (low + high) // 2
        mid_element = s[mid]
        if x == mid_element:
            break
        elif x &lt; mid_element:
            high = mid
        else:
            low = mid + 1
    xindex = mid

    # Now we have found an index pointing to x called xindex
    # and potentially reduced the low..high range
    # now we can run bisect_left on low..xindex + 1

    lo, hi = low, xindex + 1
    while lo &lt; hi:
        mid = (lo+hi)//2
        if x &gt; s[mid]: lo = mid+1
        else: hi = mid
    first = lo

    # and also bisect_right on xindex..high

    lo, hi = xindex, high
    while lo &lt; hi:
        mid = (lo+hi)//2
        if x &lt; s[mid]: hi = mid
        else: lo = mid+1
    last = lo - 1

    return first, last
</code></pre>
<p>I think the time complexity is O(log n) just like the trivial solution, but I believe this is a bit more efficient regardless. I think it's worth noting that the second part where you do <code>bisect_left</code> and <code>bisect_right</code> can be parallelized for large data sets since they are independent operations that do not interact.</p>
</div>
<span class="comment-copy">is there any reason you are not using any python functions?</span>
<span class="comment-copy">@TerranceSeo, <a href="https://hg.python.org/cpython/file/2.7/Lib/bisect.py" rel="nofollow noreferrer">hg.python.org/cpython/file/2.7/Lib/bisect.py</a>, the bisect module source contains the methods which are simple  python bisection functions</span>
<span class="comment-copy">Well, then OP's binary search is not needed at all since you scan entire list here.</span>
<span class="comment-copy">@Alik I posted before he stated that the answer had to include a binary search in part of it. My solution was just to answer the Q without importing libraries</span>
<span class="comment-copy">@Terrance Seo - I edited to include an optimised binary search for your problem</span>
<span class="comment-copy">It looks like the bisect module is more than twice as fast.  Am I reading your results wrong?!</span>
<span class="comment-copy">@wim it's because the built in module is raw C code. That's why I copied the bisect python source code to made it a fair comparison. If you took my optimised code and translated it into C / Fortran it would beat the built in module as shown in the python vs. python comparison.</span>
<span class="comment-copy">@TerranceSeo, see the link in the comments, there is nothing special about the bisect methods, they are implemented in pure python.</span>
<span class="comment-copy">@wim OP wants the actual indices, i.e. <code>6, 8</code> - you would need to subtract <code>1</code> from <code>bisect_right()</code></span>
<span class="comment-copy">@PadraicCunningham that's not correct, they are implemented in C.  there is a reference python implementation for fallback, but it is not used normally.</span>
<span class="comment-copy">The c implementation if used if available.  The op is looking for the algorithms which are in the link i posted.</span>
