<div class="post-text" itemprop="text">
<p>Why is it regarded as bad practice to create your own user class in django as opposed to using the django built in user functions?</p>
<p>P.S The user class I want to create contains fields for their email, passwords(hashed integers), names and user type. The passwords were hashed using pythons hash() method.</p>
<pre><code>hash(password_string);
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using your own <code>User</code> class is <a href="https://docs.djangoproject.com/en/1.8/topics/auth/customizing/#substituting-a-custom-user-model">fully supported</a> and even encouraged by some, including me. It allows all kinds of customizations, such as using email as a username, providing a user type, or pretty much anything you can think of. </p>
<p>Providing your own authentication mechanism, whilst supported, is strongly discouraged if you don't have experience with security. You should build on the years and years of experience that have been put into Django's authentication mechanisms and the hashing functions used by Django, and rely on the constant watchful eye of the community looking out for security vulnerabilities.</p>
<p>As for storing the password using the built-in <code>hash(password_string)</code>? You're almost better of storing your passwords in plain-text. The built-in <code>hash()</code> function is designed for speed. It is not cryptographically secure, and it is incredibly quick. What does that mean? The first means that collisions are not evenly distributed. Some hashed values occur more than others, meaning that some passwords are inherently weaker and will compare equal to other passwords. The second means that an attacker who gets a hold of the passwords in your database can simply brute-force the values. You're using a single iteration, which means that the attacker can literally try billions of passwords each second. You're not using a salt, which makes the list of passwords suspect to parallelism and rainbow tables. Not to mention that, in Python 3, the <code>hash()</code> function is seeded with a random value, and each new Python process will produce a different hash for the same password, i.e. the passwords will only be valid for that particular Python process, until it is restarted. </p>
<p>That's just the tip of the iceberg. </p>
<p>So feel free to roll your own <code>User</code> class, use whatever you like as the username, provide whatever additional attributes you'd like, but please, please, please use Django's default authentication mechanisms for everyone's sake. </p>
</div>
<span class="comment-copy">As a side note: using Python's <code>hash</code> function for passwords is a very bad idea. You want a <a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function" rel="nofollow noreferrer">cryptographically-secure hash function</a>; Python's <code>hash</code> is designed to be as fast and simple as possible, not as hard to collide as possible. See <a href="https://docs.python.org/3/library/hashlib.html" rel="nofollow noreferrer">hashlib</a> for better alternatives (and follow the relevant links).</span>
<span class="comment-copy">Thank you very much. Your feedback is very much appreciated. I was really struggling to figure out why my lecturer gave me low marks for implementing my own user class but unfortunately she disappeared away on holidays.</span>
