<div class="post-text" itemprop="text">
<p><strong>I've achived these two things.</strong></p>
<ol>
<li><p>Find all possible sublists of a list in given range <code>(i ,j)</code>. <br/> </p>
<pre><code>A = [ 44, 55, 66, 77, 88, 99, 11, 22, 33 ] 
Let, i = 2 and j = 4
</code></pre>
<p>Then, Possible sublists of the list <code>"A"</code> in the given range <code>(2,4)</code> is : <br/></p>
<pre><code>[66], [66,77], [66,77,88], [77], [77,88], [88]
</code></pre></li>
<li><p>And, minimum of the resultant product after multipying all the elements of the sublists: <br/>
<br/>So, the resultant list after multiplying all the elements in the above sublists will become</p>
<pre><code>X = [66, 5082, 447216, 77, 6776, 88]`    
</code></pre>
<p>Now, the minimum of the above list, which is <code>min(X)</code> i.e <code>66</code></p></li>
</ol>
<p><strong>My Code</strong>: <br/></p>
<pre><code>i, j = 2, 4
A = [ 44, 55, 66, 77, 88, 99, 11, 22, 33 ] 
O, P = i, i
mini = A[O]
while O &lt;= j and P &lt;= j:
    if O == P:
        mini = min(mini, reduce(lambda x, y: x * y, [A[O]]))
    else:
        mini = min(mini, reduce(lambda x, y: x * y, A[O:P + 1]))
    P += 1
    if P &gt; j:
        O += 1
        P = O
print(mini)
</code></pre>
<p><strong>My Question:</strong></p>
<p>This code is taking more time to get executed for the Larger Lists and Larger Ranges ! <br/> Is there any possible "Pythonic" way of reducing the time complexity of the above code ? <br/><br/> Thanks in advance !</p>
<p><strong>EDIT :</strong> <br/></p>
<p>Got it. But, If there is more than one such possible sublist with the same minimum product, </p>
<ol>
<li>I need the longest sub list range <code>(i,j)</code> <br/></li>
<li>If there are still more than one sublists with the same "longest sub range", I need to print the sub-interval which has the lowest start index.</li>
</ol>
<p><br/>
Consider this list <code>A = [2, 22, 10, 12, 2]</code> if <code>(i,j) = (0,4)</code>. <br/>
There is a tie. <code>Min product = 2</code> with two possibilities <code>'(0,0)' and '(4,4)'</code> . <br/> Both sub list range = 0 <code>[ (0-0) and (4-4) ]</code> <br/>
In this case i need to <code>print (minproduct, [sublist-range])</code> =  <code>2, [0,0]</code> </p>
<p>Tried using dictionaries, It works for some inputs but not for all ! How to do this 'efficiently' ? <br/>
Thank you !</p>
</div>
<div class="post-text" itemprop="text">
<p>First, given the list and the index range, we can get the sublist <code>A[i : j + 1]</code></p>
<pre><code>[66, 77, 88]
</code></pre>
<p>For positive integers <code>a</code> and <code>b</code>, <code>a * b</code> is no less than <code>a</code> or <code>b</code>. So you don't need to do multiplying, it's not possible that multiplying of two or more elements has a smaller result. The minimum of this list <em>is</em> the minimum of all the  multiplying results.</p>
<p>So the result is:</p>
<pre><code>min(A[i : j + 1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For generating the sublists, it is as simple as two nested <code>for</code> loops in a list comprehension:</p>
<pre><code>def sublists(l,i,j):
    return [l[m:n+1] for m in range(i,j+1) for n in range(m,j+1)]
</code></pre>
<p>example:</p>
<pre><code>&gt;&gt;&gt; sublists(A,2,4)
[[66], [66, 77], [66, 77, 88], [77], [77, 88], [88]]
</code></pre>
<p>For finding the minimum product:</p>
<pre><code>&gt;&gt;&gt; min(map(prod, sublists(A,2,4)))
66
</code></pre>
<p>(you import <code>prod</code> from <code>numpy</code>, or define it as <code>def prod(x): return reduce(lambda i,j:i*j,x)</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>The accepted answer is correct for all positive ints as you cannot multiply the smallest element by any number and get a smaller result. It might make more sense if you were getting  all the slices greater than length 1.</p>
<p>If you were going to calculate it then you could use <code>itertools.islice</code> to get each slice and get the min using a generator expression:</p>
<pre><code>from itertools import islice
from operator import mul

print(min(reduce(mul, islice(A, n, k + 1), 1)
          for n in range(i, j + 1) for k in range(n, j + 1)))

66
</code></pre>
<p>If for i = 0 and j = 4 you considered <code>(44, 55, 66, 88)</code> a legitimate slice then you would need to use itertools.combinations.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>#EDIT: Quick Solution:</strong></p>
<pre><code>min(A[i:j+1])
</code></pre>
<p>Since all the numbers are positive integers, and you want to find the minimum product of all possible sublists of <code>A[i:j+1]</code> list<br/>
slice, it will also contain sublists of length 1. <strong>The minimum products of all such sublists will be lowest number among the <code>A[i:j+1]</code> slice.</strong></p>
<p><strong>Another Solution:</strong></p>
<p>The below method will be useful when you need <strong>to find the maximum product of sublists or you need all the possible combinations of <code>A[i:j+1]</code> list slice.</strong></p>
<p>We'll use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow"><strong>itertools.combinations</strong></a> to solve this. We can do this in 3 steps.</p>
<p><strong>Step1: Get the slice of the list</strong> </p>
<pre><code>my_list = A[i:j+1]
</code></pre>
<p>This will give us the slice to work on.</p>
<pre><code>my_list = A[2:5]
my_list
[66, 77, 88]
</code></pre>
<p><strong>Step-2 Generate all possible combinations:</strong> </p>
<pre><code>import itertools

my_combinations = []

for x in range(1, len(my_list)+1):
    my_combinations.extend(list(itertools.combinations(my_list,x)))

my_combinations
[(66,), (77,), (88,), (66, 77), (66, 88), (77, 88), (66, 77, 88)]
</code></pre>
<blockquote>
<p>iterools.combinations returns r length subsequences of elements from
  the input iterable</p>
</blockquote>
<p>So, we will use this to generate subsequences of length 1 to length equal to length of <code>my_list</code>. We will get a list of tuples with each element being a subsequence.    </p>
<p><strong>Step-3 : Find min product of all possible combinations</strong></p>
<pre><code>products_list = [reduce(lambda i,j:i*j, x) for x in my_combinations]
[66, 77, 88, 5082, 5808, 6776, 447216]

min(products_list)
66
</code></pre>
<p>After getting the subsequences, we apply list comprehension along with <code>reduce()</code> to get the list of products for all the subsequences in <code>my_combinations</code> list. Then we apply <code>min()</code> function to get the minimum product out of the <code>products_list</code> which will give us our answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Take a look a <code>itertools.combinations()</code></p>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow">https://docs.python.org/3/library/itertools.html#itertools.combinations</a></p>
<p>Call it passing the sublist, in a loop, with the other parameter varying from 1 to the length of the sublist.</p>
<p>It will definitely take "more time to get executed for the Larger Lists and Larger Ranges", i think that's inevitable. But might be much faster than your approach. Measure and see.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def solution(a_list):

    sub = [[]]

    for i in range(len(a_list)):
        for j in range(len(a_list)):
            if(i == j):
                sub.append([a_list[i]])
            elif(i &gt; j):
                sub.append([a_list[j],a_list[i]])
    sub.append(a_list)
    return sub


solution([10, 20, 30])
</code></pre>
<hr/>
<pre><code>[[], [10], [10, 20], [20], [10, 30], [20, 30], [30], [10, 20, 30]]
</code></pre>
</div>
<span class="comment-copy">What's the possible range of the elements in the list? Like are they positive? Are they integers?</span>
<span class="comment-copy">@YuHao, Yes.. positive Integers !</span>
<span class="comment-copy">Thank you sir, If there is more than one such possible sublist with the same minimum product, How to get the longest sublist (long sub range) ?</span>
<span class="comment-copy">@Srikanth Assuming <code>a</code> and <code>b</code> are positive integers, <code>a * b</code> equals to <code>a</code> only if <code>b</code> is <code>1</code>. So to get the longest such sublists, find <code>1</code>s.</span>
<span class="comment-copy">I don't know why this was downvoted, this is correct</span>
<span class="comment-copy">To make your answer more clear, could you please add what the <code>i</code> and <code>j</code> arguments in <code>sublists</code> do?</span>
