<div class="post-text" itemprop="text">
<p>How to get one element from the pair (list of 2 elements) in Python 3, if I know another element? For example, in the turn-based strategy game, I want to swap players:</p>
<pre><code>players = [playerA, playerB]
active_player = playerA

players_tmp = list(players) 
players_tmp.remove(active_player)
active_player = players_tmp[0]
</code></pre>
<p>This code works perfectly, but it's ugly.</p>
<p>Of course, in this particular case, I can always store an index (0 or 1) of the active player, and then do:</p>
<pre><code>self._active_player = 1 - self._active_player
</code></pre>
<p>And then write the @property method. But it's not that interesting.</p>
<p>Is there any beautiful way to do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use set;  </p>
<pre><code>players = {playerA, playerB}
active_player = {playerA}

active_player = players - active_player  
</code></pre>
<p>or;  </p>
<pre><code>players = {playerA, playerB}
active_player = playerA

active_player = (players - {active_player}).pop()  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the task of finding the other element in a pair, I’d just write a nice and clear function:</p>
<pre><code>def other_of(pair, item):
    a, b = pair
    return a if item == b else b
…
active_player = other_of(players, active_player)
</code></pre>
<p>If it works for your case, though, <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow"><code>itertools.cycle</code></a> might be a better way to cycle through options:</p>
<pre><code>import itertools

player_rotation = itertools.cycle(players)
…
active_player = next(player_rotation)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can utilize the fact that <code>True</code> can be used as index 1</p>
<pre><code>&gt;&gt;&gt; l = ['a','b']
&gt;&gt;&gt; l['a' is l[0]]
'b'
&gt;&gt;&gt; l['b' is l[0]]
'a'
</code></pre>
<p>So you can define your function as</p>
<pre><code>def find(l,i):
    return l[i is l[0]]
</code></pre>
<p>Demo</p>
<pre><code>&gt;&gt;&gt; find(["Player1","Player2"],"Player1")
'Player2'
&gt;&gt;&gt; find(["Player1","Player2"],"Player2")
'Player1'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just swap when you want to change the player and take the first element then you don't have to care who is active as you will get a different player each time:</p>
<pre><code>players = ["playerA", "playerB"]

players[0],players[1] = players[1],players[0]

active = players[0]
</code></pre>
<p>Or better again as minitech commented just call <code>list.reverse</code></p>
<pre><code>  players = ["playerA", "playerB"]
  players.reverse()
  active = players[0]
  print(active)
  playerB
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a common way to toggle a flag:</p>
<pre><code>if active_player == playerA:
    active_player = playerB
else:
    active_player = playerA
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>a better solution for this would be to have a generator.</p>
<pre><code>players = ['sdf','asdf','sasd']
active = 'sdf'
temp_players = (player for player in players if player != active)
active = temp_players.next()
</code></pre>
<p>this way you can have list of all your players and get one player everytime to replace with. 
it will also be better a easier if you are gonna have multiple players in a team playing at a time.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest:</p>
<pre><code>players = ['playerA', 'playerB']
def active_player(): return players[0]
print(active_player()) 
players.reverse()
print(active_player()) 
</code></pre>
<p>that gives :</p>
<pre><code>playerA
playerB
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code># conditional expressions
active_player = players[0] if players[1] == active_player else players[1]

# negative index
active_player = players[players.index(active_player) - 1]
</code></pre>
</div>
<span class="comment-copy">Your solution looks nice. Since active_player is a set of one object, the only problem I see is to retrieve the active_player from the set (without destroying it).</span>
<span class="comment-copy">@splattru <code>tuple(active_player)[0]</code></span>
<span class="comment-copy">@splattru or <code>next(iter(active_player))</code></span>
<span class="comment-copy"><code>players.reverse()</code>?</span>
<span class="comment-copy"><code>list.reverse</code> is in-place.</span>
<span class="comment-copy">@minitech, yep,  indeed, I was reading reversed</span>
<span class="comment-copy">Why the downvote? The question just wants to reassign the <code>active_player</code>.</span>
