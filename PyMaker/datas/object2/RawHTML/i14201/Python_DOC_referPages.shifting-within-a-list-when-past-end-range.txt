<div class="post-text" itemprop="text">
<p>I created a simple program for performing a Caeser cipher on a user inputted string.</p>
<p>In order to allow the shift to go past the end of the list and back to the beginning, I simply duplicated all the list values for that list.</p>
<p>Is there a more pythonic way of achieving this result so that it will shift back to the beginning and continue to shift if the shift goes past the end of the list range?</p>
<pre><code>while True:
    x = input("Enter the message you would like to encrypt via a Caeser shift; or type 'exit': ")
    if x == 'exit': break
    y = int(input("Enter the number by which you would like to have the message Caeser shifted: "))
    alphabet = list('abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz')
    encoded = ''
    for c in x:
        if c.lower() in alphabet:
            encoded += alphabet[alphabet.index(c)+y] if c.islower() else alphabet[alphabet.index(c.lower())+y].upper()
        else:
            encoded += c
    print(encoded)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you do want to do it this way, then you're best bet is to use modular arithmetic to calculate the index in <code>alphabet</code>:</p>
<pre><code>while True:
    x = input("Enter the message you would like to encrypt via a Caeser shift; or type 'exit': ")
    if x == 'exit': break
    y = int(input("Enter the number by which you would like to have the message Caeser shifted: "))
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    encoded = ''
    for c in x:
        if c.lower() in alphabet:
            i = (alphabet.index(c.lower()) + y) % 26
            encoded += alphabet[i] if c.islower() else alphabet[i].upper()
        else:
            encoded += c
    print(encoded)
</code></pre>
<p>Some notes: you don't need to convert your alphabet to a list: strings are iterable too; a <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow">dictionary</a> might be a better alternative data structure.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's the best pythonic way I could write. You don't even need a list because each character has an ASCII value which has a predefined range. Just play around with it.</p>
<pre><code>def encrypt(text,key):
    return "".join( [  chr((ord(i) - 97 + key) % 26 + 97)  if (ord(i) &lt;= 123 and ord(i) &gt;= 97) else i for i in text] )
</code></pre>
<p><code>ord(i)</code> gives you the ascii value. 97 is value of 'a'. So <code>ord(i) - 97</code> is same as searching for index of i in your list. Add the key to it to shift. <code>chr</code> is opposite of <code>ord</code> and it converts ascii value back to the character. </p>
<p>So just one line of code within the method.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>x = "message"
y = 10 # Caeser shift key
alphabet = list('abcdefghijklmnopqrstuvwxyz')
encoder = dict(zip(alphabet, alphabet[y:]+alphabet[:y])) 
encoded = "".join(encoder[c] for c in x)
</code></pre>
</div>
<span class="comment-copy">This is exactly what I was looking for. I haven't gotten familiar with modular arithmetic yet but it looks like a great trick to have in my arsenal. Good point on the list as well.</span>
<span class="comment-copy">"Pythonic": You keep using that word. I do not think it means what you think it means.</span>
<span class="comment-copy">Haha yup not very sure. But what I'm sure of is my code is rarely unpythonic! But do you stalk my activities bro?</span>
<span class="comment-copy">@xnx thanks for the comment anyways. I think I don't really need to brag about such one-liner solutions.</span>
<span class="comment-copy">Nice solution Josh, I like using the ASCII route and the list comprehension certainly does trim the code down.</span>
<span class="comment-copy">I like this a lot. Using the dictionary is a great way to go about this problem that would eliminate the need for modular arithmetic (as xnx pointed out). Thanks Mehdi.</span>
