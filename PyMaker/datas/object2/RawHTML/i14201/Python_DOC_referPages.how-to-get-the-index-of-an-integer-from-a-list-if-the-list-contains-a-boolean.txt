<div class="post-text" itemprop="text">
<p>I am just starting with Python.</p>
<p>How to get index of integer <code>1</code> from a list if the list contains a boolean <code>True</code> object before the <code>1</code>?</p>
<pre><code>&gt;&gt;&gt; lst = [True, False, 1, 3]
&gt;&gt;&gt; lst.index(1)
0
&gt;&gt;&gt; lst.index(True)
0
&gt;&gt;&gt; lst.index(0)
1
</code></pre>
<p>I think Python considers <code>0</code> as <code>False</code> and <code>1</code> as <code>True</code> in the argument of the <code>index</code> method. How can I get the index of integer <code>1</code> (i.e. <code>2</code>)?</p>
<p>Also what is the reasoning or logic behind treating boolean object this way in list?
As from the solutions, I can see it is not so straightforward.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#lists" rel="nofollow">documentation</a> says that </p>
<blockquote>
<p>Lists are mutable sequences, typically used to store collections of
  homogeneous items (where the precise degree of similarity will vary by
  application).</p>
</blockquote>
<p>You shouldn't store heterogeneous data in lists.
The implementation of <code>list.index</code> only performs the comparison using <code>Py_EQ</code> (<code>==</code> operator). In your case that comparison returns truthy value because <code>True</code> and <code>False</code> have values of the integers 1 and 0, respectively (<a href="https://docs.python.org/3/library/functions.html#bool" rel="nofollow">the bool class is a subclass of int</a> after all).</p>
<p>However, you could use generator expression and the <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow">built-in <code>next</code> function</a> (to get the first value from the generator) like this:</p>
<pre><code>In [4]: next(i for i, x in enumerate(lst) if not isinstance(x, bool) and x == 1)
Out[4]: 2
</code></pre>
<p>Here we check if <code>x</code> is an instance of <code>bool</code> <em>before</em> comparing <code>x</code> to 1. </p>
<p>Keep in mind that <code>next</code> can raise <code>StopIteration</code>, in that case it may be desired to (re-)raise <code>ValueError</code> (to mimic the behavior of <code>list.index</code>).</p>
<p>Wrapping this all in a function:</p>
<pre><code>def index_same_type(it, val):
    gen = (i for i, x in enumerate(it) if type(x) is type(val) and x == val)
    try:
        return next(gen)
    except StopIteration:
        raise ValueError('{!r} is not in iterable'.format(val)) from None
</code></pre>
<p>Some examples:</p>
<pre><code>In [34]: index_same_type(lst, 1)
Out[34]: 2

In [35]: index_same_type(lst, True)
Out[35]: 0

In [37]: index_same_type(lst, 42)
ValueError: 42 is not in iterable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Booleans <strong>are</strong> integers in Python, and this is why you can use them just like any integer:</p>
<pre><code>&gt;&gt;&gt; 1 + True
2
&gt;&gt;&gt; [1][False]
1
</code></pre>
<p>[this doesn't mean you should :)]</p>
<p>This is due to the fact that <code>bool</code> is a subclass of <code>int</code>, and almost always a boolean will behave just like 0 or 1 (except when it is cast to string - you will get <code>"False"</code> and <code>"True"</code> instead).</p>
<p>Here is one more idea how you can achieve what you want (however, try to rethink you logic taking into account information above):</p>
<pre><code>&gt;&gt;&gt; class force_int(int):
...     def __eq__(self, other):
...         return int(self) == other and not isinstance(other, bool)
... 
&gt;&gt;&gt; force_int(1) == True
False
&gt;&gt;&gt; lst.index(force_int(1))
2
</code></pre>
<p>This code redefines <code>int</code>'s method, which is used to compare elements in the <code>index</code> method, to ignore booleans.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a very simple naive one-liner solution using <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow"><code>map</code></a> and <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow"><code>zip</code></a>:</p>
<pre><code>&gt;&gt;&gt; zip(map(type, lst), lst).index((int, 1))
2
</code></pre>
<p>Here we map the type of each element and create a new list by zipping the types with the elements and ask for the index of <code>(type, value)</code>.</p>
<p>And here is a generic iterative solution using the same technique:</p>
<pre><code>&gt;&gt;&gt; from itertools import imap, izip
&gt;&gt;&gt; def index(xs, x):
...     it = (i for i, (t, e) in enumerate(izip(imap(type, xs), xs)) if (t, e) == x)
...     try:
...             return next(it)
...     except StopIteration:
...             raise ValueError(x)
... 
&gt;&gt;&gt; index(lst, (int, 1))
2
</code></pre>
<p>Here we basically do the <em>same thing</em> but iteratively so as to not cost us much in terms of memory/space efficiency. We an iterator of the same expression from above but using <a href="https://docs.python.org/2/library/itertools.html#itertools.imap" rel="nofollow"><code>imap</code></a> and <a href="https://docs.python.org/2/library/itertools.html#itertools.izip" rel="nofollow"><code>izip</code></a> instead and build a custom index function that returns the next value from the iterator or a raise a <code>ValueError</code> if there is no match.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try to this.</p>
<pre><code>for i, j in enumerate([True, False, 1, 3]):
    if not isinstance(j, bool) and j == 1:
        print i
</code></pre>
<p>Output:</p>
<pre><code>2
</code></pre>
</div>
<span class="comment-copy">It would be better to approach this problem from "Here's what I want to do..." than "Here's what I don't want to do...". e.g. what <i>specifically</i> are you trying to do that you want to search a list for a thing, but want to skip over things that compare equal to the thing you're searching for? The most likely realities of the situation are either that you really do want <code>list.index(1)</code> to return <code>0</code> despite your surprise or that you really shouldn't be putting yourself in a situation where you need to do this search.</span>
<span class="comment-copy">I'm no python developer but isn't that a bit odd to store integers together with booleans in the same list ? I see it as listing cars and fruits together...</span>
