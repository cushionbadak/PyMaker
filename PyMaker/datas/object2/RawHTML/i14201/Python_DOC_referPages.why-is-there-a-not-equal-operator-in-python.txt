<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/9452536/why-does-python-have-an-ne-operator-method-instead-of-just-eq">Why does Python have an __ne__ operator method instead of just __eq__?</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>I was wondering about the reason of having a not equal operator in <code>python</code>.</p>
<p>The following snipped:</p>
<pre><code>class Foo:
    def __eq__(self, other):
        print('Equal called')
        return True

    def __ne__(self, other):
        print('Not equal called')
        return True

if __name__ == '__main__':
    a = Foo()

    print(a == 1)
    print(a != 1)
    print(not a == 1)
</code></pre>
<p>outputs:</p>
<pre><code>Equal called
True
Not equal called
True
Equal called
False
</code></pre>
<p>Doesn't this actually invite a lot of trouble by potentially saying:</p>
<pre><code>A == B and A != B
</code></pre>
<p>can be correct at the same time. Furthermore this introduces a potential pitfall when forgetting to implement <code>__ne__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Depending on one's needs there are cases where equal and not equal are not opposite; however, the vast majority of cases they are opposite, so in Python 3 if you do not specify a <code>__ne__</code> method Python will invert the <code>__eq__</code> method for you.</p>
<p>If you are writing code to run on both Python 2 and Python 3, then you should define both.</p>
</div>
<div class="post-text" itemprop="text">
<p>Per the <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow">data model documentation</a>, which covers the <em>"magic methods"</em> you can implement on classes (emphasis mine):</p>
<blockquote>
<p>There are no implied relationships among the comparison operators. <strong>The
  truth of <code>x==y</code> does not imply that <code>x!=y</code> is false.</strong> Accordingly, when
  defining <code>__eq__()</code>, one should also define <code>__ne__()</code> so that the
  operators will behave as expected.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Seems you are returning <code>True</code> instead of doing the comparison.</p>
</div>
<span class="comment-copy">Optimization? And this is against contracts.</span>
<span class="comment-copy"><i>"There are no implied relationships among the comparison operators. The truth of <code>x==y</code> does not imply that <code>x!=y</code> is false. Accordingly, when defining  <code>__eq__()</code>, one should also define <code>__ne__()</code> so that the operators will behave as expected."</i></span>
<span class="comment-copy">@CoryKramer Where is it from?</span>
<span class="comment-copy">This seems in line with Python's informal "we're all adults here" policy. If you want to shoot yourself in the foot by having inconsistent behavior for the two operators, then Python isn't going to stop you. (I know this doesn't really answer the question of "why have two different dunder methods in the first place?", but it's worth pointing out)</span>
<span class="comment-copy">@magu_ I could see a strong argument either way, but I assume what they decided on was that Python should allow <a href="https://stackoverflow.com/questions/9452536/why-does-python-have-an-ne-operator-method-instead-of-just-eq">many-valued logic</a> so the requirement of just returning <code>True</code> or <code>False</code> isn't imposed</span>
<span class="comment-copy">NaN was my first thought too, but I just tested it and I can't come up with a circumstance where the two comparisons don't return opposite results.</span>
<span class="comment-copy">Hm, I disagree. It should be defined by the library if NaN are equal to any number of not. I agree with the second point though, except when subclassing it is still a potential pitfall.</span>
<span class="comment-copy">@MarkRansom: Ah, right, thanks.  Fixed that point.</span>
<span class="comment-copy">@magu_: I removed the point about <code>NaN</code> as I was wrong, but in Python <code>NaN</code> is unequal to everything, including itself.  For a library to do something else it would have to create it's own <code>NaN</code>-like object and use that.</span>
<span class="comment-copy">"Explicit is better than implicit."</span>
<span class="comment-copy">I'd love to see a practical example where it's useful to have <code>__eq__</code> and <code>__ne__</code> behave inconsistently.</span>
<span class="comment-copy">@MarkRansom how about <code>numpy</code>, where <code>==</code> and <code>!=</code> on arrays create arrays of boolean element-wise comparison? <code>x != y</code> gives an array, <code>not x == y</code> gives a <code>ValueError</code>!</span>
<span class="comment-copy">He's not actually having a problem with his code snippet. He's asking why the language is designed the way it is.</span>
<span class="comment-copy">They did that deliberately to prove a point. Python allows you to commit logical contradictions</span>
<span class="comment-copy">I think that's deliberate.</span>
<span class="comment-copy">I'm not asking why the code behaves, how it does, but why this is even possible.</span>
