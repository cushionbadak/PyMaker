<div class="post-text" itemprop="text">
<p>Error is:  </p>
<pre><code>Equilateral object has no attribute angle1.
</code></pre>
<p>please suggest how to fix this error and also please explain how self works. I am confused where to use self and where to not</p>
<pre><code> class Triangle(object):
     number_of_sides=3
     def __init__(self,angle1,angle2,angle3):
        self.angle1=angle1
        self.angle2=angle2
        self.angle3=angle3
     def check_angles(self):
        if self.angle1+self.angle2+self.angle3==180:
            return True
        else:
            return False         
class Equilateral(Triangle):   //inheritance
    angle=60
    def __init__(self):
        self.angle=self.angle1
        self.angle=self.angle2
        self.angle=self.angle3

man=Equilateral()
man.check_angles()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have it the wrong way around</p>
<pre><code>self.angle1= self.angle
etc
</code></pre>
<p>Self refers to the instantiated object, much like 'this' in java.  You attach attributes to the object using this keyword. </p>
<p>When defining variables on an object, attributes at the beginning of your class definition do not need self- they are class attributes which all instances of the object will create on instantiation, whereas variables you change or set using self are instance variables and not found on all instances of the object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Different from other languages, Python does not call <code>__init__()</code> of the super class. You have to call it yourself:</p>
<pre><code>class Equilateral(Triangle):
    angle=60
    def __init__(self, ...):
        super().__init__(...)
        self.angle=self.angle1
</code></pre>
<p>More <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow">details</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You have to call <code>__init__</code> from the super class:</p>
<pre><code>class Triangle(object):
     number_of_sides=3

     def __init__(self,angle1,angle2,angle3):
        self.angle1=angle1
        self.angle2=angle2
        self.angle3=angle3

     def check_angles(self):
        return self.angle1+self.angle2+self.angle3==180:

class Equilateral(Triangle):
    angle=60
    def __init__(self):
        Triangle.__init__(self, self.angle, self.angle, self.angle)

man=Equilateral()
man.check_angles()
</code></pre>
</div>
<span class="comment-copy">Helpful hint: Python comments use <code>#</code>, not <code>//</code>.</span>
<span class="comment-copy">yeah it worked,Thanks</span>
<span class="comment-copy">The other answers given about initialization are also correct (and are a better practice to stick by)</span>
<span class="comment-copy">yeah,it also worked,thanks</span>
<span class="comment-copy">uhm.. what about calling it using <code>super(Equilateral, self).__init__(...)</code></span>
<span class="comment-copy">If angle (or angle1,... whatever) is an attribute of the superclass, he should just assign it there and there would be no need to call anything. It would be reached through self.</span>
<span class="comment-copy">@Pynchia: What about other fields defined by the superclass? Or if something changes there?  That is the reason why Python does not call it automatically, it leaves freedom to the developer.</span>
<span class="comment-copy">I am not sure I get your point. Of course there are multiple ways to solve/design. I have the impression the approach hinted in the question may not be appropriate for the goal. If we get to know what the goal is.</span>
<span class="comment-copy">calling by above method python throws an error-unbound method __init__() must be called with Triangle instance as first argument (got int instance instead)</span>
