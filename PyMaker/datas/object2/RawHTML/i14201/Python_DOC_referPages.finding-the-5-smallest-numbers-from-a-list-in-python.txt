<div class="post-text" itemprop="text">
<p>I have a list of names,x, and a list of scores,y, that correspond to the names. </p>
<pre><code>x = {a,b,c,d,e,f,g,h,i,j,k} 
y= {8,8,15,13,12,17,18,12,14,14} 
</code></pre>
<p>So, a has score 8, b has scores 8, c has score 15, ..., k has score 14</p>
<p>I want to find the 5 smallest scores from the list,y, and get their name and have a print out similar to the following:</p>
<p>top5 lowest scores:</p>
<pre><code>a : 8
b : 8 
e : 12
h : 12 
d : 13
</code></pre>
<p>Currently, I am creating a copy of the list and then using pop to keep reducing the list, but it is giving me incorrect names for the scores. However, when I create my list for the max5 values, everything comes out fine using the same method. I am unsure of a function that lets me do this in python. This is just a sample of my problem, my real problem involves store locations along with scores for those stores that I computed from a function, but I want to get the top 5 highest and 5 lowest scores. Does anyone have an efficient solution to this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has a data structure called <code>Dictionary</code> that you can use to store key/value pairs . In Python , dictionary is defined as -</p>
<pre><code>dict = {'a':8 , 'b':8, 'c':15, 'd':13 ...}
</code></pre>
<p>Then you can iterate over the key value pairs in this dictionary to find the 5 smallest numbers.</p>
<p>You can convert the dict to a tuple and then sort the tuple based on the second item-</p>
<pre><code>import operator
dict = {'a':8 , 'b':8, 'c':15, 'd':13 ...}
sorted_dict = sorted(dict.items(), key=operator.itemgetter(1))
</code></pre>
<p>Instead of using a dict, you can also use a <code>list of tuples</code>, and use the last line in above code to sort it based on the second element of each tuple.</p>
<p>The list of tuples would look like -</p>
<pre><code>scores = [('a',8),('b',8),('c',15),('d',13)..]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>First of all, organize your input collection</strong></p>
<p>Suppose you have input <code>x</code> and <code>y</code> where each of them is the collection of labels and score, respectively:</p>
<pre><code>x = ['a','b','c','d','e','f','g'] 
y = [5,3,10,2,2,1,0]
</code></pre>
<p>To sort <code>x</code> by the corresponding score <code>y</code>, zip them together and sort by the score, take the first 5 and thats' it:</p>
<pre><code>min_list = sorted(zip(x,y), key=lambda t: t[1])[5:]
</code></pre>
<blockquote>
<p><strong><em>Quick explanation</em></strong></p>
<p>It zips x and y together so you have a list of 
       <strong>zip(x,y)</strong> = ('a',5), ('b',3), ...</p>
<p>Then you sort that list by the second element of each tuple
       <strong>sorted( zip(x,y ))</strong>
<em>where the key for sorting is the second element of tuple (t[1])</em></p>
<p>Lastly, take the first 5 elements of the sorted list
       <strong>[5:]</strong></p>
</blockquote>
<p>Your resultant collection looks like this:</p>
<pre><code>[('g', 0), ('f', 1), ('d', 2), ('e', 2), ('b', 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all, <code>{8,8,15...}</code> would create a <code>set</code>, not a <code>list</code>; as sets are not ordered, you cannot pair 2 sets together like this.</p>
<p>Thus you'd have</p>
<pre><code>x = ['a','b','c','d','e','f','g','h','i','j','k'] 
y = [8, 8, 15, 13, 12, 17, 18, 12, 14, 14]
</code></pre>
<p>Now, to make these into <code>letter, score</code> pairs, use the <code>zip</code> function.</p>
<pre><code>pairs = zip(x, y)
</code></pre>
<p>And then you can find <em>n</em> smallest items with aptly named <a href="https://docs.python.org/3/library/heapq.html#heapq.nsmallest" rel="nofollow"><code>nsmallest</code></a> function from the <code>heapq</code> module; you need to provide a custom <code>key</code> function that would provide the score for each item; we will use <code>operator.itemgetter(1)</code> for it (it would return the element <code>1</code> or the <code>score</code> for each <code>letter, score</code> pair:</p>
<pre><code>from operator import itemgetter
from heapq import nsmallest

result = nsmallest(5, pairs, key=itemgetter(1))
print(result)
</code></pre>
<p>prints out </p>
<pre><code>[('a', 8), ('b', 8), ('e', 12), ('h', 12), ('d', 13)]
</code></pre>
<p>To get the letters only, just add:</p>
<pre><code>letters = [ i[0] for i in result ]
</code></pre>
</div>
<span class="comment-copy">Your data structure is wrong. Use a dictionary.</span>
<span class="comment-copy"><code>x = {1, 3, 4, 5}</code> is a set and its elements have random order, unlike a list.</span>
<span class="comment-copy">Awesome thanks, then if say I wanted to print:  'f': 1 how would I call the dictionary? print min_list[1][0], ':', 'min_list[1][1]?</span>
<span class="comment-copy">and if I wanted to do the max I would just do min_list = sorted(zip(x,y), key=lambda t: t[1])[:5] instead of min_list = sorted(zip(x,y), key=lambda t: t[1])[5:]</span>
<span class="comment-copy">Actually there are lots of built-in functions in Python which does your job. To find max in the list, you can do: <code>max(zip(x,y), key:lambda t: t[1])</code></span>
