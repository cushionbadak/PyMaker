<div class="post-text" itemprop="text">
<p>I am curious how Files work in python. How is file implemented so that it is able to be looped through like this: </p>
<pre><code>csv_file = open("filename.csv", "r")
for line in csv_file:
    # do something with line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python 2, the details are a little murky; <a href="https://stackoverflow.com/a/30792730/908494">alexmcf's answer</a> covers the basics, and you can look up further details from there.</p>
<p>If you're using Python 3, everything is documented in great detail in the <a href="https://docs.python.org/3/library/io.html" rel="nofollow noreferrer"><code>io</code></a> module, and comes with a reasonably readable <a href="https://hg.python.org/cpython/file/defauly/Lib/_pyio.py" rel="nofollow noreferrer">pure Python implementation</a> in the stdlib, all built on top of nothing more than a very simple "raw file" interface (which <code>FileIO</code> implements on top of POSIX native file descriptors on Unix).</p>
<p>The <a href="https://docs.python.org/3/library/io.html#i-o-base-classes" rel="nofollow noreferrer"><code>IOBase</code></a> ABC/mixin provides an <code>__iter__</code> method based on the <code>readline</code> method:</p>
<blockquote>
<p><code>IOBase</code> (and its subclasses) supports the iterator protocol, meaning that an <code>IOBase</code> object can be iterated over yielding the lines in a stream. Lines are defined slightly differently depending on whether the stream is a binary stream (yielding bytes), or a text stream (yielding character strings). See <code>readline()</code> below.</p>
</blockquote>
<p>And if you look <a href="https://hg.python.org/cpython/file/3.5/Lib/_pyio.py#l516" rel="nofollow noreferrer">inside the 3.5 source</a>, it's as simple as you'd expect it to be:</p>
<pre><code>def __iter__(self):
    self._checkClosed()
    return self

def __next__(self):
    line = self.readline()
    if not line:
        raise StopIteration
    return line
</code></pre>
<p>Of course in CPython 3.1+, there's a C accelerator that's used in place of that Python code if possible, but <a href="https://hg.python.org/cpython/file/3.5/Modules/_io/iobase.c#l609" rel="nofollow noreferrer">it looks pretty similar</a>:</p>
<pre><code>static PyObject *
iobase_iter(PyObject *self)
{
    if (_PyIOBase_check_closed(self, Py_True) == NULL)
        return NULL;

    Py_INCREF(self);
    return self;
}

static PyObject *
iobase_iternext(PyObject *self)
{
    PyObject *line = PyObject_CallMethodObjArgs(self, _PyIO_str_readline, NULL);

    if (line == NULL)
        return NULL;

    if (PyObject_Size(line) == 0) {
        Py_DECREF(line);
        return NULL;
    }

    return line;
}
</code></pre>
<p>The file objects returned by <code>open</code>, and automatically created for things like <code>sys.stdout</code>, and most or all file objects created anywhere else in the stdlib (<code>GzipFile</code>, etc.), are instances of <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow noreferrer"><code>TextIOWrapper</code></a> (for text files), or <a href="https://docs.python.org/3/library/io.html#io.BufferedRandom" rel="nofollow noreferrer"><code>BufferedRandom</code></a>, <code>BufferedReader</code>, or <code>BufferedWriter</code> (for binary files), which all inherit this behavior from <code>IOBase</code>. There's nothing stopping a different file class from overriding <code>__iter__</code> (or registering with <code>IOBase</code> as an ABC instead of inheriting it), but I don't know of any that do.</p>
</div>
<div class="post-text" itemprop="text">
<p>For Python 2 ...</p>
<ul>
<li><p><strong>How are files opened</strong> From the <a href="https://docs.python.org/2/library/stdtypes.html#file.readlines" rel="nofollow">docs</a>...</p>
<blockquote>
<p>File objects are implemented using Câ€™s stdio package and can be
  created with the built-in <code>open()</code> function.</p>
</blockquote></li>
<li><p><strong>A File Object is it's own iterator</strong> from <a href="https://docs.python.org/2/library/stdtypes.html#file.next" rel="nofollow">docs</a>:</p>
<blockquote>
<p>A file object is its own iterator, for example iter(f) returns f
  (unless f is closed). When a file is used as an iterator, typically in
  a for loop (for example, for line in f: print line.strip()), the
  next() method is called repeatedly.</p>
</blockquote></li>
<li><p><strong>How is the iterable in a file object generated</strong> The iterator is generated by the newline character that is specified by the function <code>open()</code>. Python will by default recognise <a href="https://docs.python.org/2/glossary.html#term-universal-newlines" rel="nofollow">a number</a> of newline formats.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>It implements <a href="https://docs.python.org/2/glossary.html#term-iterable" rel="nofollow"><strong><code>iterable</code></strong></a> interface, and calls <a href="https://docs.python.org/2/tutorial/inputoutput.html#methods-of-file-objects" rel="nofollow"><strong><code>file.readline()</code></strong></a> method on each iteration/call of <a href="https://docs.python.org/2/library/stdtypes.html#iterator.next" rel="nofollow"><strong><code>next()</code></strong></a> method.</p>
</div>
<span class="comment-copy">It's not clear which parts you don't understand. Are you confused about how customizing the behavior of <code>for</code> loops works? Or are you wondering about how it finds line endings? Or something else? If you want to know how the implementation works, the most reliable way to do that is to <a href="https://hg.python.org/cpython/file/d77db57982a1/Objects/fileobject.c" rel="nofollow noreferrer">read the implementation</a>; that might be beyond your level of background knowledge, but you might be able to figure some things out.</span>
<span class="comment-copy">@user2357112 I believe he is asking how it is possible to iterate through a file object.</span>
<span class="comment-copy">@Scott Yes, that is what I'm asking.</span>
<span class="comment-copy">Are you asking about Python 2 or Python 3? After the changes to Unicode strings, the new file implementation is probably the biggest and most important change in Python 3.</span>
<span class="comment-copy">@alexmcf: It's not exactly the same as in Python 2, because in Python 3, binary files ignore the EOL characters and always use <code>\n</code>, while text files decode the text to Unicode before searching for the EOL characters. Also, in Python 3, the same code is shared by all file-like types, while in Python 2, they all effectively have to implement it separately, so they're more likely to vary.</span>
