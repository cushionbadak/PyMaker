<div class="post-text" itemprop="text">
<p>I'm using <code>assertRaises</code> in a loop like this:</p>
<pre><code>for i in ['a', 'b', 'c']: 
    self.assertRaises(ValidationError, my_method, i)
</code></pre>
<p>And the problem is that whenever test fails, the output looks like this:</p>
<pre><code>  File "/bla/test.py", line 4, in test_assertion
      my_method(i)
AssertionError: ValidationError not raised
</code></pre>
<p>How to make it print out the value of <code>i</code> when test fails? Like this:</p>
<pre><code>  File "/bla/test.py", line 4, in test_assertion
      my_method('b')
AssertionError: ValidationError not raised
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the ideal situation for the <a href="https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests" rel="nofollow"><code>subTests</code></a> context manager. However, this is only available in python 3. I think the best solution would be to create your own version of <code>subTests</code>. The benefits being it's easy to setup a basic mimicry of <code>subTests</code>, and if <code>subTests</code> is ever back ported to python 2 then it will be easy to switch.</p>
<pre><code>import unittest
import sys
from contextlib import contextmanager

class TestCaseWithSubTests(unittest.TestCase):

    @contextmanager
    def subTest(self, **kwargs):
        try:
            yield None
        except:
            exc_class, exc, tb = sys.exc_info()
            kwargs_desc = ", ".join("{}={!r}".format(k, v) for k, v in kwargs.items())
            new_exc = exc_class("with {}: {}".format(kwargs_desc, exc))
            raise exc_class, new_exc, tb.tb_next

class MyTest(TestCaseWithSubTests):

    def test_with_assertion_error(self):
        for i in [0, 1]:
            with self.subTest(i=i), self.assertRaises(ZeroDivisionError):
                1 / i

    def test_with_value_error(self):
        def f(i):
            raise ValueError

        for i in [0, 1]:
            with self.subTest(i=i), self.assertRaises(ZeroDivisionError):
                f(i)


if __name__ == "__main__":
    unittest.main()
</code></pre>
<p>Which produces the following output:</p>
<pre><code>FE
======================================================================
ERROR: test_with_value_error (__main__.MyTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Users\dunes\py2sub_tests.py", line 30, in test_with_value_error
    f(i)
  File "C:\Python27\lib\contextlib.py", line 35, in __exit__
    self.gen.throw(type, value, traceback)
  File "C:\Users\dunes\py2sub_tests.py", line 30, in test_with_value_error
    f(i)
  File "C:\Users\dunes\py2sub_tests.py", line 26, in f
    raise ValueError
ValueError: with i=0: 

======================================================================
FAIL: test_with_assertion_error (__main__.MyTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Users\dunes\py2sub_tests.py", line 22, in test_with_assertion_error
    1 / i
  File "C:\Python27\lib\contextlib.py", line 35, in __exit__
    self.gen.throw(type, value, traceback)
  File "C:\Users\dunes\py2sub_tests.py", line 22, in test_with_assertion_error
    1 / i
AssertionError: with i=1: ZeroDivisionError not raised

----------------------------------------------------------------------
Ran 2 tests in 0.006s

FAILED (failures=1, errors=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One solution is to use <code>assertRaises()</code> as a context manager.</p>
<pre><code>with self.assertRaises(ValidationError):
    my_method(i)
    print("Failed when i was",i)
</code></pre>
<p>The print statement will only execute when the <code>my_method()</code> line passes successfully, so it will appear as the output when your test fails. Bit of a hack, but it works (unless <code>my_method()</code> throws some error that is not a <code>ValidationError</code>).</p>
</div>
<span class="comment-copy">Thanks, both your and @Sam solutions work for me, but this one looks clearer to me with one pep8 correction: in subTest method <code>raise exc_class(new_exc)</code></span>
<span class="comment-copy">@3Gee I used the old style of raising an exception so as to preserve the traceback of the original exception. I'm work primarily with python 3, and this was the only way I could remember how to preserve a traceback in python 2. In python 3 I would have just written <code>raise new_exc from old_exc</code>.</span>
<span class="comment-copy">actually (at least in my test cases) the traceback is preserved even without explicitly passing it like you did.</span>
