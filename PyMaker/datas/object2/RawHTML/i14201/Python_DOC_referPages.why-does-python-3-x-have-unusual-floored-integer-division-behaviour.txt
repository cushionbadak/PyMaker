<div class="post-text" itemprop="text">
<p>Since the Python integer division operator (<code>a // b</code>) always returns a value which can be safely stored in an <code>int</code> without losing precision (no matter of values for a and b), why is the following true?</p>
<p>If one or both operands are of type <code>float</code>, this operator returns a <code>float</code>.</p>
<p>Only if both operands are of type <code>int</code> will this operator return an <code>int</code>.</p>
<p>Wouldn't it be more consistent if every implementation of <code>__floordiv__</code> returned an <code>int</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python states that both arguments are coerced to a common type. From the <a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex" rel="nofollow"><em>Numeric types</em> documentation</a>:</p>
<blockquote>
<p>Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. </p>
</blockquote>
<p>And from the <a href="https://docs.python.org/3/reference/expressions.html#arithmetic-conversions" rel="nofollow"><em>Arithmetic conversions</em> section</a> of the <em>Expressions</em> documentation:</p>
<blockquote>
<p>When a description of an arithmetic operator below uses the phrase “the numeric arguments are converted to a common type,” this means that the operator implementation for built-in types works as follows:</p>
<ul>
<li>If either argument is a complex number, the other is converted to complex;</li>
<li>otherwise, if either argument is a floating point number, the other is converted to floating point;</li>
<li>otherwise, both must be integers and no conversion is necessary.</li>
</ul>
</blockquote>
<p>and the <a href="https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations" rel="nofollow"><em>Binary arithmetic operations</em> section</a> (which includes floor division) then uses that phrasing:</p>
<blockquote>
<p>The <code>/</code> (division) and <code>//</code> (floor division) operators yield the quotient of their arguments. The numeric arguments are first converted to a common type.</p>
</blockquote>
<p>The floor division operator is no exception; the behaviour is exactly the same across all arithmetic operators.</p>
<p>If floor division were to behave differently, it would be the exception to this rule, creating <em>inconsistent behaviour</em>, rather than being more consistent.</p>
</div>
<span class="comment-copy">Thanks for such an integral answer, describing the underlying mechanics behind converting to a <i>common type</i> and relevant references to Python's documentation sections. Many Python programmers will likely benefit from this knowledge of 'narrow' and 'wide' types, which is heavily abstracted in Python.</span>
