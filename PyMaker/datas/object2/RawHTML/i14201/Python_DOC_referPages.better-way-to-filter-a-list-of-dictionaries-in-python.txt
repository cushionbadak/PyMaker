<div class="post-text" itemprop="text">
<p>I have a list of dictionaries that has the structure similar to this one:</p>
<pre><code>log = [{'user_id': 'id1', 'action': 'action1', 'timestamp': 'time1'},  
       {'user_id': 'id2', 'action': 'action2', 'timestamp': 'time2'},
       ...]
</code></pre>
<p>and is sorted by timestamp value. </p>
<p>I would like to delete sequential identical actions done by the same user leaving just the first one, e.g. if I have the following list:</p>
<pre><code>log = [{'user_id': 'id1', 'action': 'action1', 'timestamp': 'time1'},
       {'user_id': 'id1', 'action': 'action1', 'timestamp': 'time2'},
       {'user_id': 'id1', 'action': 'action1', 'timestamp': 'time3'},
       {'user_id': 'id2', 'action': 'action2', 'timestamp': 'time4'},
       {'user_id': 'id3', 'action': 'action2', 'timestamp': 'time5'},
       {'user_id': 'id3', 'action': 'action2', 'timestamp': 'time6'},
       {'user_id': 'id1', 'action': 'action1', 'timestamp': 'time7'},
       {'user_id': 'id1', 'action': 'action1', 'timestamp': 'time8'}]
</code></pre>
<p>I would like to obtain this list as a result:</p>
<pre><code>log = [{'user_id': 'id1', 'action': 'action1', 'timestamp': 'time1'},
       {'user_id': 'id2', 'action': 'action2', 'timestamp': 'time4'},
       {'user_id': 'id3', 'action': 'action2', 'timestamp': 'time5'},
       {'user_id': 'id1', 'action': 'action1', 'timestamp': 'time7'}]
</code></pre>
<p>Currently I am doing it like this:</p>
<pre><code>def merge_actions(log):
    merged_log = []
    merged_log.append(log[0])
    for i in range(1, len(log)):
        if log[i]['user_id'] == log[i-1]['user_id']:
            if log[i]['action'] == log[i-1]['action']:
                continue
        merged_log.append(log[i])
    return merged_log
</code></pre>
<p>Is there a better way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer"><code>itertools.groupby</code></a> and group by the <code>'user_id'</code> and <code>'action'</code>, you can grab the first element out of each of the groups.</p>
<pre><code>&gt;&gt;&gt; [next(group) for key, group in itertools.groupby(log, key = lambda i: (i['user_id'], i['action']))]
[{'timestamp': 'time1', 'action': 'action1', 'user_id': 'id1'},
 {'timestamp': 'time4', 'action': 'action2', 'user_id': 'id2'},
 {'timestamp': 'time5', 'action': 'action2', 'user_id': 'id3'},
 {'timestamp': 'time7', 'action': 'action1', 'user_id': 'id1'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/2.7/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a> to group sequential actions by the same user and then take the first element of each group:</p>
<pre><code>def merge_actions(log):
    return [next(group) for key, group in itertools.groupby(log, lambda l: (l['user_id'], l['action']))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you were to use a loop you just need to simply keep track of the last key you saw:</p>
<pre><code>it = iter(log)
start = next(it)
od,prev = [start], start["user_id"]
for d in it:
    k = d["user_id"]
    if prev != k:
        od.append(d)
    prev = k

print(od)

[{'action': 'action1', 'timestamp': 'time1', 'user_id': 'id1'}, 
 {'action': 'action2', 'timestamp': 'time4', 'user_id': 'id2'}, 
{'action': 'action2', 'timestamp': 'time5', 'user_id': 'id3'}, 
{'action': 'action1', 'timestamp': 'time7', 'user_id': 'id1'}]
</code></pre>
<p>If the actions are not always grouped check both keys:</p>
<pre><code>it = iter(log)
start = next(it)
od, prev,act = [start], start["user_id"],start["action"]
for d in it:
    k1, k2 = d["user_id"], d["action"]
    if prev != k1 or k2 != act:
        od.append(d)
    prev, act = k1, k2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a verbose attempt at using <code>groupby</code>:</p>
<pre><code>from itertools import groupby
a = [{'user_id': 'id1', 'action': 'action1', 'timestamp': 'time1'},
       {'user_id': 'id1', 'action': 'action1', 'timestamp': 'time2'},
       {'user_id': 'id1', 'action': 'action1', 'timestamp': 'time3'},
       {'user_id': 'id2', 'action': 'action2', 'timestamp': 'time4'},
       {'user_id': 'id3', 'action': 'action2', 'timestamp': 'time5'},
       {'user_id': 'id3', 'action': 'action2', 'timestamp': 'time6'},
       {'user_id': 'id1', 'action': 'action1', 'timestamp': 'time7'},
       {'user_id': 'id1', 'action': 'action1', 'timestamp': 'time8'}]
for u, grps in groupby(a, lambda d: d['user_id']):
    d_with_first_ts = sorted(grps, key = lambda user_dict: user_dict['timestamp'])[0]
    print('User: {}; Dict with first timestamp = {}'.format(u, d_with_first_ts))
</code></pre>
<p>You will get the following results:</p>
<pre><code>User: id1; Dict with first timestamp = {'timestamp': 'time1', 'action': 'action1', 'user_id': 'id1'}
User: id2; Dict with first timestamp = {'timestamp': 'time4', 'action': 'action2', 'user_id': 'id2'}
User: id3; Dict with first timestamp = {'timestamp': 'time5', 'action': 'action2', 'user_id': 'id3'}
User: id1; Dict with first timestamp = {'timestamp': 'time7', 'action': 'action1', 'user_id': 'id1'}
</code></pre>
</div>
<span class="comment-copy"><code>key=itemgetter('user_id','action')</code> will do the same job without the need for a lambda</span>
<span class="comment-copy">your example groups <i>all</i> actions by user, while I would like to merge only sequential ones, i.e. the result should also contain      {'user_id': 'id1', 'action': 'action1', 'timestamp': 'time7'}</span>
<span class="comment-copy">In that case, you can ignore <code>sorted_users</code> line. I will update the code</span>
