<div class="post-text" itemprop="text">
<pre><code>[[1, '34', '44'], [1, '40', '30', '41'], [1, '41', '40', '42'], [1, '42', '41', '43'], [1, '43', '42', '44'], [1, '44', '34', '43']]
</code></pre>
<p>I have a list of lists. My aim is to check whether any one sublist has anything in common with other sublists(excluding the first index object to compare). If it has anything in common then unify those sublists. </p>
<p>For example, for this example my final answer should be something like:</p>
<pre><code>[[1, '34, '44', '40' '30', '41', '42', '43']]
</code></pre>
<p>I can understand that I should convert the sublists to sets and then use union() and intersection() operation. But what I am stuck with is to how to compare each set/sublist. I can't run a loop over the list and compare each sublist one by one as the contents of the list would be modified and this would lead to error.</p>
<p>What I want to know is there any efficient method to compare all the sublists(converted to sets) and get union of them?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/itertools.html#module-itertools" rel="noreferrer"><em>itertools</em></a> module makes short work of this problem:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; list(set(chain.from_iterable(d)))
[1, '41', '42', '43', '40', '34', '30', '44']
</code></pre>
<p>Another way to do it is to unpack the list into separate arguments for <em>union()</em>:</p>
<pre><code>&gt;&gt;&gt; list(set().union(*d))
[1, '41', '42', '43', '40', '34', '30', '44']
</code></pre>
<p>The latter way eliminates all duplicates and doesn't require that the inputs first be converted to sets.  Also, it doesn't require an import.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using the <a href="https://docs.python.org/2/tutorial/controlflow.html#unpacking-argument-lists" rel="noreferrer">unpacking operator <code>*</code></a>:</p>
<pre><code>&gt;&gt; list(set.union(*map(set, a)))
[1, '44', '30', '42', '43', '40', '41', '34']
</code></pre>
<p>(Thanks Raymond Hettinger for the comment!)</p>
<p>(Note that </p>
<pre><code>set.union(*tup)
</code></pre>
<p>will unpack to </p>
<pre><code>set.union(tup[0], tup[1], ... tup[n - 1])
</code></pre>
<p>)</p>
</div>
<div class="post-text" itemprop="text">
<p>I personally like the readability of <code>reduce</code>, paired with a simple conditional function, something like</p>
<pre><code>somelists = [[1, '41', '40', '42'], [1, '42', '41', '43'], [1, '43', '42', '44'], [1, '44', '34', '43']] # your original lists
somesets = map(set,somelists) #your lists as sets

def condition(s1,s2): # condition to apply recursively to the sets
    if s1.intersection(s2):
        return s1.union(s2)
reduce( condition,somesets)
#{1, '30', '34', '40', '41', '42', '43', '44'}
</code></pre>
<p>Of course you can cast this result to a 2d list if you desire <code>list([reduce(...</code> </p>
<p>I will note that this is something like 3x slower than the <code>chain.fromiterable</code> answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use itertools to perform this action. Let us assume that your list has a variable name A</p>
<pre><code>import itertools

single_list_with_all_values = list(itertools.chain(*A))
single_list_with_all_values.sort()

print set(single_list_with_all_values)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [20]: s
Out[20]: 
[[1, '34', '44'],
 [1, '40', '30', '41'],
 [1, '41', '40', '42'],
 [1, '42', '41', '43'],
 [1, '43', '42', '44'],
 [1, '44', '34', '43']]
In [31]: list({x for _list in s for x in _list})
Out[31]: [1, '44', '30', '42', '43', '40', '41', '34']
</code></pre>
<p>Update:</p>
<p>Thanks for the comments</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; big = [[1, '34', '44'], [1, '40', '30', '41'], [1, '41', '40', '42'], [1, '42', '41', '43'], [1, '43', '42', '44'], [1, '44', '34', '43']]
&gt;&gt;&gt; set(reduce ( lambda l,a : l + a, big))
set([1, '44', '30', '42', '43', '40', '41', '34'])
</code></pre>
<p>And if you really want a list of a list as a final result </p>
<pre><code>&gt;&gt;&gt;&gt;[list(set(reduce ( lambda l,a : l + a, big)))]
[[1, '44', '30', '42', '43', '40', '41', '34']]
</code></pre>
<p>And if you don't like recoding a lambda function for the list addition :</p>
<pre><code>&gt;&gt;&gt;&gt;[list(set(reduce ( list.__add__, big)))]
[[1, '44', '30', '42', '43', '40', '41', '34']]
</code></pre>
<p><strong>EDIT</strong> : after your recommendation about using itertools.chain instead of list.__add__ I ran a timeit for both with the original variable used by the original poster.</p>
<p>It seems that timeit times list.__add__ around 2.8s and itertools.chain around 3.5 seconds.</p>
<p>I checked on this page and yes, you were right with the itertools.chain contains a from_iterable method that grants a huge performance boost. see below with list.__add__, itertools.chain and itertools.chain.from_iterable.</p>
<pre><code>&gt;&gt;&gt; timeit.timeit("[list(set(reduce ( list.__add__, big)))]", setup="big = [ [10,20,30,40] for ele in range(10000)]", number=30)
16.051744650801993
&gt;&gt;&gt; timeit.timeit("[list(set(reduce ( itertools.chain, big)))]", setup="big = [ [10,20,30,40] for ele in range(10000)]", number=30)
54.721315866467194
&gt;&gt;&gt; timeit.timeit("list(set(itertools.chain.from_iterable(big)))", setup="big = [ [10,20,30,40] for ele in range(10000)]", number=30)
0.040056066849501804
</code></pre>
<p>Thank you very much for your advises :)</p>
</div>
<span class="comment-copy">do you need the same order?</span>
<span class="comment-copy">No, there is no need to preserve order.</span>
<span class="comment-copy">Can there be other lists starting with e.g. <code>2</code>, which shouldn't be combined?</span>
<span class="comment-copy">Do you want this?<a href="http://stackoverflow.com/a/27803361/2867928">stackoverflow.com/a/27803361/2867928</a></span>
<span class="comment-copy">Actually, I forgot to stress on one important condition. Sorry, for my mistake. I have also mentioned that the sublists should be unified if and only if they have something in common otherwise they should remain as it is. So, first there is a need to check for intersection() which if isn't empty then only union should be done.  @Peter Wood  No, there will not be any sublist with separate starting index element like '2' or '3'. I mean in the list of lists all the sublist will  have same first index element.</span>
<span class="comment-copy">How does itertools generally scale? In your experience, can this kind of an operation handle tens or hundreds of millions item long lists ('items' being strings here)? Or even larger?</span>
<span class="comment-copy">The <code>chain.from_iterable()</code> step is scale invariant.  At any given time, its whole state is stored in just two pointers to iterators.  The <code>set()</code> and <code>list()</code> parts  eat memory in proportion to the total number of unique inputs.  On my 64-bit machine, one hundred million unique inputs takes 4.3 GB of RAM for the set object and 0.9 GB for the list object.</span>
<span class="comment-copy">This method works fine. Thanks. Could you explain what is the use of '*' in the code? Or maybe provide a link where I could study related to this to understand more.</span>
<span class="comment-copy">FWIW, the <i>tuple</i> step has no effect because star-unpacking works on any iterable.   You could also replace the list comprehension with <code>map(set, a)</code>.  The result boils down to <code>list(set.union(*map(set, a)))</code>.</span>
<span class="comment-copy">OMG, @Raymond Hettinger, am honored to have a comment by you. Will check what you say.</span>
<span class="comment-copy">@TapojyotiMandal See explanation in answer.</span>
<span class="comment-copy">This is pretty good.  A few improvements though.  1) A <code>chain(*it)</code> should always be changed to <code>chain.from_iterable(it)</code>.  2) There is no need to <code>sort()</code> because the ordering is lost in making the <i>set</i>.  3) Without the sort, there is no need to convert to a <i>list</i> before making the <i>set</i>.   With those changes, it boils down to <code>set(chain.from_iterable(d))</code>.</span>
<span class="comment-copy">thanks for the insight</span>
<span class="comment-copy">You don't need the list comprehension as the set constructor can take a generator.</span>
<span class="comment-copy">@PeterWood OP has asked for a list to be his final answer</span>
<span class="comment-copy">No, the comprehension is being passed to the <code>set</code>. You don't need it.</span>
<span class="comment-copy">Replacing the list comprehension with a set comprehension boils this one down to a nice, clean answer:  <code>list({x for _list in s for x in _list})</code>.</span>
<span class="comment-copy">Adding lists together like this is an inefficient O(n**2) operation and is almost always a bad idea.  Please use <code>itertools.chain</code> instead.</span>
