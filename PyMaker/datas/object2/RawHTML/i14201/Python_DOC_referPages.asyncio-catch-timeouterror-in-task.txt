<div class="post-text" itemprop="text">
<p>I have an <code>asyncio.Task</code> that I need to cancel after some amount of time. Before cancelling, the task needs to do some cleanup. According to the docs, I should just be able to call task.cancel or <code>asyncio.wait_for(coroutine, delay)</code> and intercept an <code>asyncio.TimeoutError</code> in the coroutine, but the following example is not working. I've tried intercepting other errors, and calling <code>task.cancel</code> instead, but neither have worked. Am I misunderstanding how cancelling a task works?</p>
<pre><code>@asyncio.coroutine
def toTimeout():
  try:
    i = 0
    while True:
      print("iteration ", i, "......"); i += 1
      yield from asyncio.sleep(1)
  except asyncio.TimeoutError:
    print("timed out")

def main():
  #... do some stuff
  yield from asyncio.wait_for(toTimeout(), 10)
  #... do some more stuff

asyncio.get_event_loop().run_until_complete(main())
asyncio.get_event_loop().run_forever()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for" rel="nofollow">documentation for <code>asyncio.wait_for</code></a> specifies that it will cancel the underlying task, and then raise <code>TimeoutError</code> from the <code>wait_for</code> call itself:</p>
<blockquote>
<p>Returns result of the Future or coroutine. When a timeout occurs, it
  cancels the task and raises <code>asyncio.TimeoutError</code>.</p>
</blockquote>
<p>And you are correct that task cancellation <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel" rel="nofollow">can indeed be intercepted</a>:</p>
<blockquote>
<p>[<code>Task.cancel</code>] arranges for a <code>CancelledError</code> to be thrown into the wrapped
  coroutine on the next cycle through the event loop. The coroutine then
  has a chance to clean up or even deny the request using
  <code>try</code>/<code>except</code>/<code>finally</code>. </p>
</blockquote>
<p>Note that the docs specify that <code>CancelledError</code> is thrown into the coroutine, not <code>TimeoutError</code>.</p>
<p>If you make that adjustment, things work the way you expect:</p>
<pre><code>import asyncio

@asyncio.coroutine
def toTimeout():
  try:
    i = 0
    while True:
      print("iteration ", i, "......"); i += 1
      yield from asyncio.sleep(1)
  except asyncio.CancelledError:
    print("timed out")

def main():
  #... do some stuff
  yield from asyncio.wait_for(toTimeout(), 3)
  #... do some more stuff

asyncio.get_event_loop().run_until_complete(main())
</code></pre>
<p>Output:</p>
<pre><code>iteration  0 ......
iteration  1 ......
iteration  2 ......
timed out
Traceback (most recent call last):
  File "aio.py", line 18, in &lt;module&gt;
    asyncio.get_event_loop().run_until_complete(main())
  File "/usr/lib/python3.4/asyncio/base_events.py", line 316, in run_until_complete
    return future.result()
  File "/usr/lib/python3.4/asyncio/futures.py", line 275, in result
    raise self._exception
  File "/usr/lib/python3.4/asyncio/tasks.py", line 238, in _step
    result = next(coro)
  File "aio.py", line 15, in main
    yield from asyncio.wait_for(toTimeout(), 3)
  File "/usr/lib/python3.4/asyncio/tasks.py", line 381, in wait_for
    raise futures.TimeoutError()
concurrent.futures._base.TimeoutError
</code></pre>
<p>As you can see, now <code>'timed out'</code> gets printed before the <code>TimeoutError</code> is raised by <code>wait_for</code>.</p>
</div>
