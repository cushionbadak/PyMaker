<div class="post-text" itemprop="text">
<pre><code>class Interval(object):
    def __sub__(self, other: Interval):
        pass
</code></pre>
<p>The way it is I get a 'NameError: name 'Interval' is not defined'. Can someone tell me which type would be correct here?</p>
</div>
<div class="post-text" itemprop="text">
<p>The class doesn't exist until after Python finishes executing all the code inside the class block, including your method definitions.</p>
<p>Just use a string literal instead, as suggested in <a href="https://www.python.org/dev/peps/pep-0484/#forward-references" rel="nofollow noreferrer">PEP 484</a>:</p>
<pre><code>class Interval(object):
    def __sub__(self, other: 'Interval'):
        pass
</code></pre>
<p>Note that it's perfectly fine to refer to the class <em>inside</em> a method:</p>
<pre><code>class Interval(object):
    def __sub__(self, other: 'Interval'):
        Interval.do_something()
</code></pre>
<p>This is only a problem if you need to use it in a method signature or directly inside the class block.</p>
<hr/>
<p><strong>As of Python 3.7, the above workaround is <a href="https://docs.python.org/3/whatsnew/3.7.html#pep-563-postponed-evaluation-of-annotations" rel="nofollow noreferrer">no longer necessary</a></strong> (but still perfectly valid, so you can and should continue using it if you need to support older versions of Python).  Instead, put the following at the top of each module to enable forward references within that module:</p>
<pre><code>from __future__ import annotations
</code></pre>
<p>This will cause all annotations to be lazily evaluated on lookup, so that you can refer to classes within their definitions, or even before their definitions.  In short, it makes every "reasonable" annotation mean what you (probably) wanted it to mean.</p>
<p>Finally, if you need to inspect type annotations, be sure you are using <a href="https://docs.python.org/3/library/typing.html#typing.get_type_hints" rel="nofollow noreferrer"><code>typing.get_type_hints()</code></a> instead of the <code>.__annotations__</code> special attribute.  This function correctly handles both the old and the new way of doing things, as well as a few other nuances of the type hinting rules such as automatic <code>Optional[T]</code> when the default value is <code>None</code>.  It is the comfortable and future-proof way to examine the type hints attached to an arbitrary Python object.</p>
</div>
