<div class="post-text" itemprop="text">
<p>I want to know how can I remove consecutive value in list or string.</p>
<p>If my list is:</p>
<pre><code>mylist = ["N","N","J","N","J","S","S","K","K","K","A","K"]
</code></pre>
<p>I should get:</p>
<pre><code>["N","J","N","J","S","K","A","K"]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use list comprehensions</p>
<pre><code>&gt;&gt;&gt; mylist = ["N","N","J","N","J","S","S","K","K","K","A","K"]
&gt;&gt;&gt; [j for i, j in enumerate(mylist) if j != mylist[i-1] or i == 0]
['N', 'J', 'N', 'J', 'S', 'K', 'A', 'K']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow">groupby</a> from itertools</p>
<pre><code>In [28]: from itertools import groupby

In [30]: lst
Out[30]: ['N', 'N', 'J', 'N', 'J', 'S', 'S', 'K', 'K', 'K', 'A', 'K']

In [31]: [elem[0] for elem in groupby(lst)]
Out[31]: ['N', 'J', 'N', 'J', 'S', 'K', 'A', 'K']
</code></pre>
<p>Performance</p>
<pre><code>In [33]: %timeit [j for i, j in enumerate(lst) if j != lst[i-1]]
100000 loops, best of 3: 2.8 µs per loop

In [34]: %timeit [elem[0] for elem in groupby(lst)]
100000 loops, best of 3: 2.55 µs per loop

In [36]: %timeit list(map(lambda x: x[0], filter(lambda x: x[0] != x[1], zip(lst,lst[1:]+['']))))
100000 loops, best of 3: 9.35 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>map</code>, <code>filter</code> and <code>zip</code> is very instructive:</p>
<pre><code>&gt;&gt;&gt; list(map(lambda x: x[0], filter(lambda x: x[0] != x[1], zip(mylist,mylist[1:]+['']))))
['N', 'J', 'N', 'J', 'S', 'K', 'A', 'K']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're looking for the <code>unique_justseen</code> recipe from the <code>itertools</code> docs:</p>
<pre><code>def unique_justseen(iterable, key=None):
    "List unique elements, preserving order. Remember only the element just seen."
    # unique_justseen('AAAABBBCCDAABBB') --&gt; A B C D A B
    # unique_justseen('ABBCcAD', str.lower) --&gt; A B C A D
    return map(next, map(itemgetter(1), groupby(iterable, key)))
</code></pre>
<p>Source: <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">https://docs.python.org/3/library/itertools.html#itertools-recipes</a></p>
</div>
<div class="post-text" itemprop="text">
<p><strong>1. The List Problem</strong></p>
<p>You can do that using Python's built-in <a href="https://docs.python.org/2/library/functions.html#reduce" rel="nofollow"><strong><code>reduce</code></strong></a> function, with assumption that you have at least one element in your list:</p>
<pre><code>reduce(lambda lst, el: lst if lst[-1] == el else lst + [el], mylist[1:], [mylist[0]])
</code></pre>
<p>So what you basically do here is initialise a new list containing the first element of your original list. Then using <code>reduce</code> you iterate over the rest of the elements one-by-one and apply the function supplied to <code>reduce</code>. Wht that function does, is simply check, whether the current element is equal to the last element of the aggregated one. If it is equal, it ignores the current element, by returning just the aggregated list, otherwise, it appends it to the aggregated list and returns.</p>
<p><strong>2. The Brackets Problem</strong></p>
<p>As for your brackets problem, you can use the <code>filter</code> built-in function, with a help of custom stack handling in a classic way:</p>
<pre><code>print(filter(escaped, mystr))
</code></pre>
<p>where <code>escaped</code> is defined in the following way:</p>
<pre><code>bracket_stack = []
def escaped(c):
    ignore = False
    if c in ['(', '[', '&lt;']:
        bracket_stack.append(c)
        ignore = True
    elif bracket_stack and c in [')', ']', '&gt;']:
        ignore = True
        if c == ')' and bracket_stack[-1] == '(':
            bracket_stack.pop()
        if c == ']' and bracket_stack[-1] == '[':
            bracket_stack.pop()
        if c == '&gt;' and bracket_stack[-1] == '&lt;':
            bracket_stack.pop()

    in_brackets = len(bracket_stack)
    return not (ignore or in_brackets)
</code></pre>
</div>
<span class="comment-copy">I don't understand, how the list is related here?</span>
<span class="comment-copy">Sorry i misuploaded the question</span>
<span class="comment-copy">Can you fix it please?</span>
<span class="comment-copy">sorry. fixed.. I made a mistake for uploading my question cause I'm newbie for this site : (</span>
<span class="comment-copy">So there are two unrelated questions? If yes, please separate them into two threads :)</span>
<span class="comment-copy">very concise and it uses only vanilla stuff</span>
<span class="comment-copy">That's the answer I just wanted to give so it must be the best one. :-)</span>
<span class="comment-copy">thank you so much. I'll try it. :)</span>
<span class="comment-copy">thank you so much. I'll try it</span>
<span class="comment-copy">thank you so much !</span>
<span class="comment-copy">perhaps you could mark this answer as accepted, @Arcanes?</span>
<span class="comment-copy">I doubt that performance is an issue here. This answer is not only correct, it also works on any iterable, not just lists, including infinite generators. It is also more flexible since it can use a custom <code>key</code> function.</span>
<span class="comment-copy">This will construct a lot of intermediary lists, which isn't nice for memory and performance. Furthermore, imho this is overcomplicating the problem, which can be solved using much more straight-forward iteration patterns, which is arguably more "pythonic".</span>
<span class="comment-copy">thanks! : )        I'll try this too!</span>
