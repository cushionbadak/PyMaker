<div class="post-text" itemprop="text">
<p>I'm using SWIG to generate Python Bindings for my qt app. I have several places where I use <a href="http://doc.qt.io/qt-5/qlist.html" rel="nofollow">QList</a>s and I would like to integrate those QLists like std::vector from the SWIG Library (see <a href="http://www.swig.org/Doc1.3/Library.html#Library_nn15" rel="nofollow">http://www.swig.org/Doc1.3/Library.html#Library_nn15</a>).<br/>
This means:  </p>
<ul>
<li>The QList objects should be iterable from python (= they must be an iterable python object)</li>
<li>It should be possible to pass a python list to a function which takes a qlist</li>
<li>... and all the other features listed in the SWIG Library for std::vector</li>
</ul>
<p>To achieve that I use the following Code:
<a href="https://github.com/osmandapp/OsmAnd-core/blob/master/swig/java/QList.i" rel="nofollow">https://github.com/osmandapp/OsmAnd-core/blob/master/swig/java/QList.i</a><br/>
Later in my classes using QLists, I add code like:</p>
<pre><code>%import "qlist.i"
%template(listfilter) QList&lt;Interface_Filter*&gt;;

class A {
    public:
    //.....
    QList&lt;Interface_Filter*&gt; get_filters();
};
</code></pre>
<p>This works so far, but it doesn't give me the kind of integration I get with std::vector.
I'm having trouble finding out which parts of std_vector.i, std_container.i,... make an object iterable.<br/>
<strong>How do I need to extend the QList interface file to make my QList's iterable?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>What you are asking for -- a qlist.i swig file that achieves the same level of integration for <code>QList</code> in python as std_vector.i does for <code>std::vector</code> -- is a non-trivial task.</p>
<p>I provide a very basic extended qlist.i file (and qlisttest.i to show you how to use it) and will try to explain what steps are required.</p>
<p><code>qlist.i</code>:</p>
<pre><code>%{
#include &lt;QList&gt;
%}

%pythoncode %{
class QListIterator:
    def __init__(self, qlist):
        self.index = 0
        self.qlist = qlist
    def __iter__(self):
        return self
    def next(self):
        if self.index &gt;= self.qlist.size():
            raise StopIteration;
        ret = self.qlist.get(self.index)
        self.index += 1
        return ret
    __next__ = next
%}

template&lt;class T&gt; class QList {
public:
class iterator;
typedef size_t size_type;
typedef T value_type;
typedef const value_type&amp; const_reference;
QList();
size_type size() const;
void reserve(size_type n);
%rename(isEmpty) empty;
bool empty() const;
void clear();
%rename(add) push_back;
void push_back(const value_type&amp; x);
%extend {
    const_reference get(int i) throw (std::out_of_range) {
    int size = int(self-&gt;size());
    if (i&gt;=0 &amp;&amp; i&lt;size)
        return (*self)[i];
    else
        throw std::out_of_range("QList index out of range");
    }
    void set(int i, const value_type&amp; val) throw (std::out_of_range) {
    int size = int(self-&gt;size());
    if (i&gt;=0 &amp;&amp; i&lt;size)
        (*self)[i] = val;
    else
        throw std::out_of_range("QList index out of range");
    }
    int __len__() {
    return self-&gt;size();
    }
    const_reference __getitem__(int i) throw (std::out_of_range) {
    int size = int(self-&gt;size());
    if (i&gt;=0 &amp;&amp; i&lt;size)
        return (*self)[i];
    else
        throw std::out_of_range("QList index out of range");
    }
    %pythoncode %{
    def __iter__(self):
        return QListIterator(self)
    %}
}
};

%define %qlist_conversions(Type...)
%typemap(in) const QList&lt; Type &gt; &amp; (bool free_qlist)
{
free_qlist = false;
if ((SWIG_ConvertPtr($input, (void **) &amp;$1, $1_descriptor, 0)) == -1) {
    if (!PyList_Check($input)) {
    PyErr_Format(PyExc_TypeError, "QList or python list required.");
    SWIG_fail;
    }
    Py_ssize_t len = PyList_Size($input);
    QList&lt; Type &gt; * qlist = new QList&lt; Type &gt;();
    free_qlist = true;
    qlist-&gt;reserve(len);
    for (Py_ssize_t index = 0; index &lt; len; ++index) {
    PyObject *item = PyList_GetItem($input,index);
    Type* c_item;
    if ((SWIG_ConvertPtr(item, (void **) &amp;c_item, $descriptor(Type *),0)) == -1) {
        delete qlist;
        free_qlist = false;
        PyErr_Format(PyExc_TypeError, "List element of wrong type encountered.");
        SWIG_fail;
    }
    qlist-&gt;append(*c_item);
    }
    $1 = qlist;
}
}
%typemap(freearg) const QList&lt; Type &gt; &amp;
{ if (free_qlist$argnum and $1) delete $1; }    
%enddef
</code></pre>
<p><code>qlisttest.i</code>:</p>
<pre><code>%module qlist;
%include "qlist.i"

%inline %{
class Foo {
public:
    int foo;
};
%}

%template(QList_Foo) QList&lt;Foo&gt;;
%qlist_conversions(Foo);

%inline %{  
int sumList(const QList&lt;Foo&gt; &amp; list) {
    int sum = 0;
    for (int i = 0; i &lt; list.size(); ++i) {
        sum += list[i].foo;
    }
    return sum;
}
%}
</code></pre>
<ol>
<li><p>Wrapping of <code>QList</code> to make it and its methods accessible from python<br/>
This is achieved by making the (partial) class definition available to swig. That is what your current <code>qlist.i</code> does.<br/>
<strong>Note:</strong> You might need to add a "template specialization" for the case <code>QList&lt;T*&gt;</code> that typedefs <code>const_reference</code> as <code>const T*</code> since you are using a <code>QList</code> of pointers. Otherwise, <code>QList&lt;T*&gt;::const_reference</code> will be <code>const T*&amp;</code>, which apparently might confuse swig. (see <a href="https://github.com/swig/swig/blob/master/Lib/std/std_vector.i#L97-100" rel="nofollow">swig/Lib/std/std_vector.i</a>)</p></li>
<li><p>Automatic conversion between python list and <code>QList</code><br/>
This is generally achieved by using swig <a href="http://www.swig.org/Doc3.0/SWIGDocumentation.html#Typemaps" rel="nofollow">typemaps</a>. For instance, if you want a function <code>f(const QList&lt;int&gt;&amp; list)</code> to be able to accept a python list, you need to specify an input typemap that performs the conversion from a python list to a <code>QList&lt;int&gt;</code>:</p>
<pre><code>%typemap(in) const QList&lt;int&gt; &amp;
{
    PyObject * py_list = $input;
    [check if py_list is really a python list of integers]
    QList&lt;int&gt;* qlist = new QList&lt;int&gt;();
    [copy the data from the py_list to the qlist]
    $1 = qlist;
}
%typemap(freearg) const QList&lt;int&gt; &amp;
{ if ($1) delete $1; }
</code></pre>
<p>Here, the situation is more difficult in several ways:</p>
<ul>
<li>You want to be able to pass a python lists <em>or</em> a wrapped <code>QList</code>: For this to work, you need to handle both cases in the typemap.</li>
<li>You want to convert a python list of wrapped type <code>T</code> to a <code>QList&lt;T&gt;</code>:<br/>
This also involves a conversion for every element of the list from the wrapped type <code>T</code> to the plain <code>T</code>. This is achieved by the swig function <code>SWIG_ConvertPtr</code>.</li>
<li>I am not sure if you can specify typemaps with template arguments. Therefore, I wrote a swig macro <code>%qlist_conversions(Type)</code> that you can use to attach the typemap to the <code>QList&lt;Type&gt;</code> for a specific <code>Type</code>.</li>
</ul>
<p>For the other conversion direction (<code>QList</code> -&gt; python list) you should first consider what you want. Consider a C++ function that returns a <code>QList&lt;int&gt;</code>. Calling this from python, should this return a wrapped <code>QList</code> object, or should it automatically convert the <code>QList</code> to a python list?</p></li>
<li><p>Accessing the wrapped <code>QList</code> as a python sequence, i.e., make <code>len</code> and <code>[]</code> work from python<br/>
For this, you need to extend the <code>QList</code> class in the qlist.i file using <code>%extend { ... }</code> and implement <code>__len__</code> and <code>__getitem__</code> methods.</p>
<p>If slicing should also work, you need to provide a <code>__getitem__(PySliceObject *slice)__</code> member method and input and "typecheck" typemaps for <code>PySliceObject</code>s.</p>
<p>If you want to be able to modify values in the wrapped <code>QList</code> using <code>[]</code> from python, you need to implement <code>__setitem__</code>.</p>
<p>For a list of all the useful methods you can implement to achieve better integration, see the python documentation on "builtin types" and "abstract base classes for containers".</p>
<p><strong>Note:</strong> If you use the swig <code>-builtin</code> feature, then you need to additionally register the above functions to the appropriate "slots" using e.g.</p>
<pre><code>%feature("python:slot", "sq_length", functype="lenfunc") __len__;
</code></pre></li>
<li><p>Making the wrapped <code>QList</code> iterable from python<br/>
For this you need to extend the <code>QList</code> class and implement an <code>__iter__()</code> method that returns a python iterator object.</p>
<p>A python iterator object is an object that provides the methods <code>__iter__()</code> and <code>__next__()</code> (<code>next()</code> for older python), where <code>__next__()</code> returns the next value and raises the python exception <code>StopIteration</code> to signal the end.</p>
<p>As mentioned before, you can implement the iterator object in python or C++. I show an example of doing this in python.</p></li>
</ol>
<p>I hope this helps as a basis for you to tweak the functionality that you require.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>You provided an answer to the question "How to make a python Object iterable", but I asked for "How do I need to extend the QList interface file to make my QList's iterable?" which is more a SWIG, than a python related question.</p>
</blockquote>
<p>I tested the example from <a href="http://www.swig.org/Doc1.3/Library.html#Library_nn15" rel="nofollow">http://www.swig.org/Doc1.3/Library.html#Library_nn15</a> with Java, C# and Python. Only Python and C# provide iterators. The generated interface of Java doesn't implement <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html" rel="nofollow">Iterable</a> or something like that. As far as I can see your question is related to the target language.</p>
<p>Maybe extending <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence" rel="nofollow">MutableSequence</a> is an option for you. The only methods you have to implement are <code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__len__</code> and <code>insert</code> by delegating them to the corresponding methods of QList. Afterwards your generated class is iterable.</p>
</div>
<div class="post-text" itemprop="text">
<p>As described in the <a href="https://docs.python.org/2/library/stdtypes.html#typeiter" rel="nofollow noreferrer">docs</a>, you need the following:</p>
<ul>
<li>QList should have a method in python <code>__iter__()</code> that returns an iterator object (<code>tp_iter</code> if you implement it in C).</li>
<li>The iterator object should implement <code>__iter__()</code> and return itself</li>
<li>The iterator object should implement <code>next()</code> that returns the next item or raises <code>StopIteration</code> when it's done. </li>
</ul>
<p>It's probably easiest to do in python, but you can implement it in C as well.</p>
<p>Another option is to use python generators to avoid implementing an iterator type. To do this you QList needs to implement <code>__iter__()</code> but instead of returning an iterator you simply <code>yield</code> the values.</p>
<p>The methods mentioned only need to be visible to python. You don't have to make them available in C/Java.</p>
<p>See also <a href="https://stackoverflow.com/questions/8776328/swig-interfacing-c-library-to-python-creating-iterable-python-data-type-from">SWIG interfacing C library to Python (Creating 'iterable' Python data type from C 'sequence' struct)</a></p>
</div>
<span class="comment-copy">Thank you sir, for providing (almost completely) what I asked for. I'll try out the code tomorrow, and come back with questions/comments. I was not aware that this would be that complicated. What puzzles me most, is that std_vector.i can be used with one simple line: <code>%template(vectori) vector&lt;int&gt;;</code>. How do they do that?!  Are we missing something here?</span>
<span class="comment-copy">SWIG contains a library of functions that do what I did above in a generic and much more sophisticated way. See e.g. <a href="https://github.com/swig/swig/tree/master/Lib/typemaps" rel="nofollow noreferrer">typemaps</a> and <a href="https://github.com/swig/swig/tree/master/Lib/std" rel="nofollow noreferrer">std</a> for the language independent code, and <a href="https://github.com/swig/swig/blob/master/Lib/python/pycontainer.swg" rel="nofollow noreferrer">pycontainer.swg</a> and <a href="https://github.com/swig/swig/blob/master/Lib/python/pyiterators.swg" rel="nofollow noreferrer">pyiterators.swg</a> for the relevant python code.</span>
<span class="comment-copy">However, that is difficult to use. First of all, they recommend for the implementation files: "don't look at them unless you are really drunk", which really says it all... Secondly, they are STL specific, and QList is not fully STL compatible (e.g., lacking <code>reverse_iterator</code>)</span>
<span class="comment-copy">Ah, I was only looking in the language independent code and never came across <code>pycontainer.swg</code> and <code>pyiterators.swg</code> files. I can still combine your 2 lines from <code>qlisttest.i</code> in a define, and then I have also a "<i>one single line, which does it all</i>"-kind of integration.</span>
<span class="comment-copy">As I stated in the Question, I was unable to find the parts which make a std_vector iterable in python, inside the std_vector.i file from the Swig Library. Your's and also Sorin's answer are both very generic and are not really SWIG related. As stated in the Bounty Text, <b>I would like to see a complete interface file for qlist.i</b>, which behaves like std_vector.i but operates on <a href="http://doc.qt.io/qt-5/qlist.html" rel="nofollow noreferrer">QList</a>s.</span>
<span class="comment-copy">You provided an answer to the question "How to make a python Object iterable", but I asked for  "<b>How do I need to extend the QList interface file to make my QList's iterable?</b>" which is more a SWIG, than a python related question.</span>
<span class="comment-copy">@Dreamcooled I thought you knew that. See docs: <a href="http://www.swig.org/Doc1.3/Python.html#Python_nn43" rel="nofollow noreferrer">swig.org/Doc1.3/Python.html#Python_nn43</a> -  31.6.3 Class extension with %extend .</span>
<span class="comment-copy">I did know about <code>%extend</code>, but it's not done with that. As stated in the Bounty Text, <b>I would like to see a complete interface file for qlist.i</b>, which behaves like std_vector.i but operates on QLists.</span>
