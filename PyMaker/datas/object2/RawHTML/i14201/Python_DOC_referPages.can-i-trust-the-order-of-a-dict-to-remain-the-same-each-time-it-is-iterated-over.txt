<div class="post-text" itemprop="text">
<p>I have the following three strings (they exist independently but are displayed here together for convenience):</p>
<pre><code>from mx2.x.org (mx2.x.org. [198.186.238.144])
            by mx.google.com with ESMTPS id g34si6312040qgg.122.2015.04.22.14.49.15
            (version=TLSv1 cipher=ECDHE-RSA-RC4-SHA bits=128/128);
            Wed, 22 Apr 2015 14:49:16 -0700 (PDT)

from HQPAMAIL08.x.org (10.64.17.33) by HQPAMAIL13.x.x.org
 (10.34.25.11) with Microsoft SMTP Server (TLS) id 14.2.347.0; Wed, 22 Apr
 2015 17:49:13 -0400

from HQPAMAIL13.x.org ([fe80::7844:1f34:e8b2:e526]) by
 HQPAMAIL08.iadb.org ([fe80::20b5:b1cb:9c01:aa86%18]) with mapi id
 14.02.0387.000; Wed, 22 Apr 2015 17:49:12 -0400
</code></pre>
<p>I'm looking to populate a dict with some values based on the reversed (bottom to top) order of the strings. Specifically, for each string, I'm extracting the IP address as an index of sorts, and then the full string as the value. </p>
<p>Given that order is important, I decided to go with lists, and initially did something like this (pseudocode, with the above bunch of text):</p>
<pre><code>IPs =[]
fullStrings =[]
for string in strings:
    IPs.append[$theIpAddressFoundInTheString]
    fullstrings.append[$theWholeString]
</code></pre>
<p>resulting in the following two lists (again, just an illustration):</p>
<pre><code>IPs ['198.186.238.144', '10.64.17.33', 'fe80::7844:1f34:e8b2:e526']

fullstrings ['from mx2.x.org (mx2.x.org. [198.186.238.144])
                by mx.google.com with ESMTPS id g34si6312040qgg.122.2015.04.22.14.49.15
                (version=TLSv1 cipher=ECDHE-RSA-RC4-SHA bits=128/128);
                Wed, 22 Apr 2015 14:49:16 -0700 (PDT)', 'from HQPAMAIL08.x.org (10.64.17.33) by HQPAMAIL13.x.x.org
     (10.34.25.11) with Microsoft SMTP Server (TLS) id 14.2.347.0; Wed, 22 Apr
     2015 17:49:13 -0400', 'from HQPAMAIL13.x.org ([fe80::7844:1f34:e8b2:e526]) by
     HQPAMAIL08.x.org ([fe80::20b5:b1cb:9c01:aa86%18]) with mapi id
     14.02.0387.000; Wed, 22 Apr 2015 17:49:12 -0400']
</code></pre>
<p>This has worked fine up until a point, but now as I begin populating a <strong>dict</strong>  with values in these lists (at hardcoded indices), comparing against values in other lists (again at hardcoded indices) etc., not only does debugging become a pain, the code becomes unsustainable.</p>
<p>I'm beginning to rewrite using a dict (returning a dict where the IP addresses are the keys and the full strings are the values). Then I will perform operations like:</p>
<pre><code>for k,v in myDictOfIpsAndStrings:
    anotherDict[$someHardcodedText] = k
    anotherDict[$otherHardcodedText] = v        
</code></pre>
<p>Here's my concern: <strong>can I be sure that the dict, any time it is iterated over, will always be done in the order in which the dict was created?</strong> If not, is my only option to revert back to lists (and the tedious and <strong>brittle</strong> length comparisons, assignments inherent in doing so) etc.?</p>
<p>I know that a dict is, by its very nature, unsorted. And I know of the <code>sorted</code> function, but I'm not looking to sort they keys by any descending/ascending order etc. rather it's about maintaining (somehow) the order in which the dict was created.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>can I be sure that the dict, any time it is iterated over, will always be done in the order in which the dict was created?</p>
</blockquote>
<p>No, a <code>dict</code> is unordered, and will lay out its ordering however the particular implementation decides to.</p>
<pre><code>&gt;&gt;&gt; d = {3: 'c', 2: 'b', 1: 'a'}
&gt;&gt;&gt; d
{1: 'a', 2: 'b', 3: 'c'}
</code></pre>
<p>See, immediately after I created the <code>dict</code> the order changed.</p>
<p>If you want to ensure you have a deterministic, controllable order, you can use a <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>collections.OrderedDict</code></a></p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; d = OrderedDict([(3, 'c'), (2, 'b'), (1, 'a')])
&gt;&gt;&gt; d
OrderedDict([(3, 'c'), (2, 'b'), (1, 'a')])
</code></pre>
<p>You can still access the <code>OrderedDict</code> in the conventions you are used to</p>
<pre><code>&gt;&gt;&gt; d[3]
'c'
&gt;&gt;&gt; d.get(3)
'c'
</code></pre>
<p>Note that you do not have to insert all of the elements upon creation. You can insert them one at a time if you want.</p>
<pre><code>&gt;&gt;&gt; d = OrderedDict()
&gt;&gt;&gt; d[3] = 'c'
&gt;&gt;&gt; d[2] = 'b'
&gt;&gt;&gt; d[1] = 'a'
&gt;&gt;&gt; d[4] = 'd'
&gt;&gt;&gt; d
OrderedDict([(3, 'c'), (2, 'b'), (1, 'a'), (4, 'd')])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should not rely on the iteration order of a dict. The <b>only</b> way you can get any stable and repeatable ordering is by doing something like:</p>
<pre><code>for key in sorted(yourdict):
   more code here
</code></pre>
<p>That will give you a stable ordering, but probably not the one you want. </p>
<p>You probbaly want to use an <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow">OrderedDict</a></p>
</div>
<span class="comment-copy">Use a <code>collections.OrderedDict</code>!</span>
<span class="comment-copy">Your question is unclear. What order do you expect to preserve? The order in which you inserted elements? Or the order in which you iterate to not change when you iterate more than once? There is no preservation of insert order, but once you have a dictionary, the order does remain stable until you insert more keys (or delete keys).</span>
<span class="comment-copy">@minitech Thanks. The documentation <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">docs.python.org/2/library/â€¦</a> contains the line "New in version 2.7", but it's buried in the middle of the desctiption. Should I read this as OrderedDict is new in 2.7, or only the popitem() method is new?</span>
<span class="comment-copy">@Pyderman: OrderedDict is new in 2.7.</span>
<span class="comment-copy">@Pyderman: see <a href="https://stackoverflow.com/q/15479928">Why is the order in Python dictionaries and sets arbitrary?</a>; dictionaries do not preserve the order in which you created it or added keys to it. So entering <code>{'foo': 1, 'bar': 2, 'baz': 3}</code> into Python gives you <code>{'baz': 3, 'bar': 2, 'foo': 1}</code>, and iteration over that dictionary will always give you <code>'baz'</code> first, <code>'bar'</code> second and <code>'foo'</code> third. Until you insert more keys or delete keys from it. The order in the sample is specific to 2.7 without hash seed randomisation.</span>
<span class="comment-copy">You may want to mention <code>OrderedDict</code>, which if your interpretation is correct, would fit the use-case perfectly.</span>
<span class="comment-copy">You <b>can</b> rely on the iteration order of a dict, provided you don't insert or delete anything. What you cannot rely on is the insertion order being preserved.</span>
<span class="comment-copy">@MartijnPieters Ok. See my question above. I guess I will need to populate the dict in one go if I want to to take advantage of this aspect.</span>
<span class="comment-copy">@MartijnPieters Thanks - this is an important point.  Until now, I thought it was the iteration of dicts that caused the change in order.</span>
