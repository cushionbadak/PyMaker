<div class="post-text" itemprop="text">
<p>Let's say I do this class:</p>
<pre><code>class Person:
   __slots__ = ["j"]

   def __init__(self):
       self.j = 1

   def hello(self):
       print("Hello")
</code></pre>
<p>Is the method <em>hello</em> in the slots?</p>
</div>
<div class="post-text" itemprop="text">
<p>Whether or not you're using <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow"><code>__slots__</code></a> to control instance attributes, methods are stored on the <em>class</em>, not the <em>instance</em>:</p>
<pre><code>&gt;&gt;&gt; class Slots:

    __slots__ = ['attr']

    def __init__(self):
        self.attr = None

    def method(self):
        pass


&gt;&gt;&gt; class NoSlots:

    def __init__(self):
        self.attr = None

    def method(self):
        pass


&gt;&gt;&gt; 'method' in Slots.__dict__
True
&gt;&gt;&gt; 'method' in NoSlots.__dict__
True
&gt;&gt;&gt; 'method' in NoSlots().__dict__
False
</code></pre>
<p>Using <code>__slots__</code> actually makes all defined attributes <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow"><em>descriptors</em></a> (see also <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow">the how-to</a>), which are also stored on the class:</p>
<pre><code>&gt;&gt;&gt; 'attr' in Slots.__dict__
True
&gt;&gt;&gt; type(Slots.attr)
&lt;class 'member_descriptor'&gt;
</code></pre>
</div>
<span class="comment-copy">Why not try it and see?</span>
<span class="comment-copy">I tried it and it seems to work but maybe functions are stored another way. It is strange that you don't have to implicitly put em in the slots list.</span>
<span class="comment-copy">Yes, they're stored on the <i>class</i> not the <i>instance</i> - they appear in neither <code>__slots__</code> nor <code>__dict__</code> on an instance.</span>
