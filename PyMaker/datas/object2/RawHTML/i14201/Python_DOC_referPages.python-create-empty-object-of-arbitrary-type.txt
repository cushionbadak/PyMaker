<div class="post-text" itemprop="text">
<p>for types such as list I can readily create an empty list to make this construct work:</p>
<pre><code> s = []
 s+= [1,2,3]  # result s assigned [1,2,3]
</code></pre>
<p>obviously useful in constructs like this:</p>
<pre><code> s=[]
 for v in (list1,list2,list3..):
   if condition : s+=v
</code></pre>
<p>Now I'm working with a user defined type, defined in a module that <em>I cannot read or change</em>.. I have to do this:</p>
<pre><code> s=0
 for v in (typefoo1,typefoo2,..):
   if condition :
    if s==0 :
     s=v
    else:
     s+=v
</code></pre>
<p>This works, but is ugly and occurs so often it is pretty annoying.
so.. is there a way to create an empty object such that the <code>+=</code> operator would behave simply like a regular assignment<code>=</code> regardless of the type on the r.h.s?</p>
<p>Edit:
I tried to keep the question generic deliberately, but for completeness the type in question is an Abaqus geometry sequence.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>is there a way to create an empty object such that the <code>+=</code> operator would behave simply like a regular assignment <code>=</code> regardless of the type on the r.h.s?</p>
</blockquote>
<p>Sure. Just write a class and define your <code>__add__</code> method to return the RHS unmodified.</p>
<pre><code>class DummyItem:
    def __add__(self, other):
        return other

s = DummyItem()
s += 23
print s
</code></pre>
<p>Result:</p>
<pre><code>23
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that your list has at least one element, you could just create an iterator and use <code>next</code> to get the first element and them sum the rest:</p>
<pre><code>i = iter(lst)
s = next(i)
for x in i:
    s += x
</code></pre>
<p>You could also do this using the <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer"><code>sum</code></a> function, with a second paramter specifying the initial value: <code>s = sum(i, next(i))</code>. This explicitly <em>does not work for strings</em>, but you could also use <code>reduce</code> in a similar way, which <em>will</em> work with strings: <code>s = reduce(operator.add, i, next(i))</code>. Or, you could even combine this with the <code>DummyItem</code> from <a href="https://stackoverflow.com/a/30783541/1639625">@Kevin's answer</a>, as <code>s = sum(lst, DummyItem())</code>. This way it also works with strings, and you can use the list directly and do not need to create an iterator.</p>
</div>
<span class="comment-copy">Is <code>iter</code> the user defined type, or is <code>v</code>?</span>
<span class="comment-copy">sorry a little terse, see edits.  Initializing <code>s</code> to <code>0</code> or <code>None</code> , etc produces a 'unsupported operand type error on += ' error.</span>
<span class="comment-copy">So, just to make this clear: <code>iter</code> is an iterable of objects <i>other than the usual numbers</i> that support addition among themselves?</span>
<span class="comment-copy">Exactly, <code>sum</code> does not work on this type, although one workaround is to write my own <code>sum</code> function specific to this type (Which is somewhat more elegant than the above )</span>
<span class="comment-copy">That works! sweet..</span>
<span class="comment-copy">the explicit loop works.. unfortunately <code>sum</code> throws an "illegal argument type" error..</span>
<span class="comment-copy">@agentp Seems like <code>sum</code> explicitly does not work with strings. Could this have been the problem?</span>
<span class="comment-copy">not a string either, but its the same issue - I added specifics of the type to the question.</span>
