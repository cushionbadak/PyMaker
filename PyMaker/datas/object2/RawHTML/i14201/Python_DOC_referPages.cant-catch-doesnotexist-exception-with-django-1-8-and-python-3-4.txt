<div class="post-text" itemprop="text">
<p>I have the following view in a Django app:</p>
<pre><code>class VideoCreateView(View):
    """
    Handle creating a video
    """
    template_name = 'albums/video_create.html'
    success_template_name = 'albums/video_created.html'

    def get(self, request, *args, **kwargs):
        """
        Display the confirmation dialogue
        """
        # First, get the album
        pk = kwargs['pk']
        try:
            album = Album.objects.get(id=pk)
        except Album.DoesNotExist:
            raise Http404

        # Render the template
        return render(request, self.template_name)

    def post(self, request, *args, **kwargs):
        """
        Generate the video
        """
        # First, get the album
        pk = kwargs['pk']
        try:
            album = Album.objects.get(id=pk)
        except Album.DoesNotExist:
            raise Http404

        # Trigger build
        if len(album.photo_set.all()) &gt; 0:
            celery_generate_video.delay(album)

            # Send response
            return render(request, self.success_template_name)
        else:
            raise HttpResponseBadRequest
</code></pre>
<p>This requires an ID for a photo album in the URL, and if the album does not exist, it should raise a 404 error. I've written the following test to check this behaviour:</p>
<pre><code>@mock.patch('storages.backends.s3boto.S3BotoStorage', FileSystemStorage)
def test_get_does_not_exist(self):
    """
    Test GET requests
    """
    pk = uuid.uuid4()
    url = reverse('video_create', kwargs={
        'pk': pk.urn[9:]
    })
    request = self.factory.get(url)
    request.user = self.user
    response = VideoCreateView.as_view()(request, pk=pk)
    self.assertEqual(response.status_code, 404)
</code></pre>
<p>Unfortunately, it's raising the following error:</p>
<pre><code>======================================================================
ERROR: test_get_does_not_exist (albums.tests.VideoCreateViewTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/matthew/Projects/digitallife/albums/views.py", line 200, in get
    album = Album.objects.get(id=pk)
  File "/home/matthew/Projects/digitallife/venv/lib/python3.4/site-packages/django/db/models/manager.py", line 127, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/home/matthew/Projects/digitallife/venv/lib/python3.4/site-packages/django/db/models/query.py", line 334, in get
    self.model._meta.object_name
albums.models.DoesNotExist: Album matching query does not exist.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/lib/python3.4/unittest/mock.py", line 1125, in patched
    return func(*args, **keywargs)
  File "/home/matthew/Projects/digitallife/albums/tests.py", line 573, in test_get_does_not_exist
    response = VideoCreateView.as_view()(request, pk=pk)
  File "/home/matthew/Projects/digitallife/venv/lib/python3.4/site-packages/django/views/generic/base.py", line 71, in view
    return self.dispatch(request, *args, **kwargs)
  File "/home/matthew/Projects/digitallife/venv/lib/python3.4/site-packages/django/views/generic/base.py", line 89, in dispatch
    return handler(request, *args, **kwargs)
  File "/home/matthew/Projects/digitallife/albums/views.py", line 202, in get
    raise Http404
django.http.response.Http404
</code></pre>
<p>It looks to me like the exception isn't being caught. I have used this method for catching invalid objects in Django before, but that was in Python 2.7, so I wondered if it was something in Python 3 (this is my first Python 3 Django project). What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're not doing anything wrong in the view. The test result shows it is doing exactly what you want: catching a DoesNotExist, and raising Http404 in response.</p>
<p>The issue is in your test. You're calling the view directly, which means you skip all the middleware that usually does things like handle exceptions and translate them into 404/500 responses. Instead of creating a request via the factory, you should use the built-in test client to call the view:</p>
<pre><code>url = ...
response = self.client.get(url)
</code></pre>
</div>
<span class="comment-copy">Should be <a href="https://docs.djangoproject.com/en/1.8/topics/http/shortcuts/#id5" rel="nofollow noreferrer"><code>raise Http404()</code></a> ? And  raise HttpResponseBadRequest()?</span>
<span class="comment-copy">@danihp Yes, it should. My bad - I think I need some more caffeine this morning!</span>
<span class="comment-copy">That's nailed it. Thank you very much!</span>
<span class="comment-copy">Its wrong to <code>raise Http404</code> with out instantiate a new object. Right way is <code>raise Http404()</code> also <code>raise HttpResponseBadRequest()</code>.</span>
<span class="comment-copy">@danihp that simply isn't true. It's perfectly valid to raise a class. See (Python core developer) Raymond Hettinger's answer <a href="http://stackoverflow.com/a/16709222/104349">here</a>, which links to the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement" rel="nofollow noreferrer">reference docs</a> which state the same thing.</span>
<span class="comment-copy">Nice, learning each day with @DanielRoseman. Thanks.</span>
