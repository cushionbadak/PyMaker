<div class="post-text" itemprop="text">
<p>I was trying to solve an old question:</p>
<blockquote>
<p>Write a function that add two [integer] numbers A and B. You should not use + or any arithmetic operators.</p>
</blockquote>
<p>The best solution is like this, quoted from "<a href="http://www.cnblogs.com/lishiblog/p/4194937.html" rel="nofollow">LintCode-A+B Problem</a>":</p>
<blockquote>
<p>For a + b in any base, we can treat the plus as two part: 1. a + b without carry; 2. the carry generated by a +b. The a+b then equals to part 1 plus part 2. If part1+part2 generates more carry, we can then repeat this procedure, until there is no carry.</p>
</blockquote>
<p>I can understand this algorithm and everything seems good, so I tested it on <a href="http://www.lintcode.com/en/problem/a-b-problem/" rel="nofollow">lintcode</a> with code pasted below.</p>
<pre><code>class Solution:
    """
    @param a: The first integer
    @param b: The second integer
    @return:  The sum of a and b
    """
    def aplusb(self, a, b):

        while b != 0:
            carry = a &amp; b
            a = a ^ b
            b = carry &lt;&lt; 1

        return a
</code></pre>
<p>But surprisingly, it gave me <code>Time Limit Exceeded</code> error in test case <code>[100, -100]</code>. So I ran it locally and print a, b for every loop:</p>
<pre><code>(-8, 8)
(-16, 16)
(-32, 32)
(-64, 64)
(-128, 128)
(-256, 256)
(-512, 512)
(-1024, 1024)
(-2048, 2048)
(-4096, 4096)
(-8192, 8192)
(-16384, 16384)
(-32768, 32768)
(-65536, 65536)
(-131072, 131072)
...
</code></pre>
<p>The calculation is correct, so I think this algorithm does not work for such input but when I wrote the same algorithm in C++, it just works:</p>
<pre><code>class Solution {
public:
    int aplusb(int a, int b) {
        while (b!=0){
            int carry = a &amp; b;
            a = a^b; 
            b = carry &lt;&lt; 1;
        }
        return a;
    }
};
</code></pre>
<p>I don't know what should be asked exactly, basically the questions are:</p>
<ol>
<li>Why does C++ give the correct output <code>0</code> while Python doesn't?</li>
<li>If I use Python, how do I modify this algorithm to make it work?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The binary, 2's complement representation of <code>-4</code> is</p>
<pre><code>...11100
</code></pre>
<p>Yes, I really do mean infinitely many <code>1</code>'s to the left; this is a binary repeating numeral. Technically, <code>4</code> is a repeating numeral too:</p>
<pre><code>...00100
</code></pre>
<p>it's just repeating <code>0</code>'s to the left.</p>
<p>Your addition problem is</p>
<pre><code>   ...11100
+  ...00100
--------------------
   ...00000
</code></pre>
<p>The operators <code>^</code>, <code>&lt;&lt;</code>, and <code>&amp;</code> have no trouble computing with infinitely many binary digits, but the problem is that there are infinitely many carries, and you are computing them <em>one digit at a time</em>. This will never finish.</p>
<p>Thus, you have to recognize when this algorithm will get stuck in this situation and do something else to account for it.</p>
<hr/>
<p>You don't run into this problem in C/C++, because, for example, if <code>int</code> is 32-bits, then all of the digits except for the rightmost 31 digits get collapsed into a single bit, so it does the remaining carries all at once.</p>
<p>However, technically speaking, the meaning of left shifting an <code>int</code> is in terms of the value as an integer, rather than as a bit pattern, so you are invoking <em>undefined behavior</em> if the two most significant bits <code>carry</code> are ever different, because then <code>carry &lt;&lt; 1</code> would produce an overflow).</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem are negative numbers, or, how they are represented. In Python integer numbers have arbitrary accuracy, while C++ ints are 32bit or 64bit. So in Python, you have to handle negative numbers, e.g. subtraction, separately, or limit the number of bits by hand.</p>
</div>
<div class="post-text" itemprop="text">
<p>Following the great explanation by @Hurkyl , I stepped through the algorithm for <code>a=4</code> and <code>b=-4</code> using the fact that python implements an infinite two's compliment representation:</p>
<pre><code>Step 0:

a = ...(0)...000100
b = ...(1)...111100

carry = a &amp; b = ...(0)...000100
a = a ^ b = ...(1)...111000
b = carry &lt;&lt; 1 = ...(0)...001000

Step 1:

a = ...(1)...111000
b = ...(0)...001000

carry = a &amp; b = ...(0)...001000
a = a ^ b = ...(1)...110000
b = carry &lt;&lt; 1 = ...(0)...010000

Step 2:

a = ...(1)...110000
b = ...(0)...010000

carry = a &amp; b = ...(0)...010000
a = a ^ b = ...(1)...100000
b = carry &lt;&lt; 1 = ...(0)...100000
</code></pre>
<p>It is clear that there needs to be an effective cutoff to emulate something like a 32-bit signed two's compliment integer. Once the carry bit bubbles up beyond highest bit the algorithm needs to be halted. The following appears to work:</p>
<pre><code>MAX_BIT = 2**32
MAX_BIT_COMPLIMENT = -2**32

def aplusb(a, b):

    while b != 0:
        if b == MAX_BIT:
            return a ^ MAX_BIT_COMPLIMENT
        carry = a &amp; b
        a = a ^ b
        b = carry &lt;&lt; 1

    return a
</code></pre>
<p>Results:</p>
<pre><code>&gt;&gt;&gt; aplusb(100,-100)
0
&gt;&gt;&gt; aplusb(100,-99)
1
&gt;&gt;&gt; aplusb(97,-99)
-2
&gt;&gt;&gt; aplusb(1000,-500)
500
&gt;&gt;&gt; aplusb(-1000,8000)
7000
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If 1-bit binary math operations (^) are forbidden, go for unary!</p>
<pre><code>from itertools import chain

def unary(x):
    "Unary representation of x"
    return ''.join(['x' for _ in range(0,x)])

def uplus(x, y):
    "Unary sum of x and y"
    return [c for c in chain(x,y)]

def plus(i, j):
    "Return sum calculated using unary math"
    return len(uplus(unary(i), unary(j)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That is because python is not normally using 32 bit signed int.</p>
<p>See:<a href="https://docs.python.org/2/library/ctypes.html#ctypes.c_int32" rel="nofollow">ctypes.c_int32</a></p>
<p>Accepted solution:</p>
<pre><code>class Solution:
"""
@param a: The first integer
@param b: The second integer
@return:  The sum of a and b
"""
def aplusb(self, a, b):
    import ctypes
    a = ctypes.c_int32(a).value
    a = ctypes.c_int32(a).value
    while b != 0:
        carry = ctypes.c_int32(a &amp; b).value
        a = ctypes.c_int32(a ^ b).value
        b = ctypes.c_int32(carry &lt;&lt; 1).value

    return a
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My solution:</p>
<pre><code>def foo(a, b):
"""iterate through a and b, count iteration via a list, check len"""
    x = []
    for i in range(a):
            x.append(a)
    for i in range(b):
            x.append(b)
    print len(x)
</code></pre>
<p>As already stated, bitwise is better.</p>
</div>
<span class="comment-copy">Signed integer overflow is undefined behavior.  OP is lucky the C version works at all.</span>
<span class="comment-copy">Could you explain "then all of the digits except for the rightmost 31 digits get collapsed into a single bit, so it does the remaining carries all at once." in more detail? thank you!</span>
<span class="comment-copy">@laike9m: It might be easier to think about it in the opposite direction: when you convert from <code>int</code> to a (2's complement) binary numeral, you have to sign extend: the most significant digit expands to an infinitely repeated digit.</span>
<span class="comment-copy">In order to get similar behaviour as the C++ version, you could supply numpy integers, which have a finite binary representation: aplusb(numpy.int32(100), numpy.int32(-100)) gives 0 as expected.</span>
<span class="comment-copy">Can C++ have 8-bit, or 16-bit integers?  Last time I recall, there were more than two sizes for integers <a href="http://en.cppreference.com/w/cpp/language/types" rel="nofollow noreferrer">in C++ numeric types</a>.</span>
<span class="comment-copy">I wonder if <code>-x</code> counts as one of the banned arithmetic operators here; just flipping the sign like that to change it into a subtraction problem is probably cheating.</span>
<span class="comment-copy">@ThomasMatthews see this <a href="http://www.cplusplus.com/reference/cstdint/" rel="nofollow noreferrer">cplusplus.com/reference/cstdint</a></span>
<span class="comment-copy">@Smac89 As you can see from both links, there are more sizes for integers than 32 or 64 bit.  For example, the C++ language defines the minimum ranges that unsigned char, unsigned short int, unsigned int and unsigned long must support.  There is no maximum size specified.  A platform can use 128-bits to represent all those types.</span>
<span class="comment-copy">If you take this approach, then rather than hardcoding an upper bound, you might consider determining the cutoff dynamically; e.g. so that your program would be able to give the correct results when adding two 87-bit numbers, or so that it could stop early if adding two 4-bit numbers. e.g. see <a href="https://docs.python.org/3/library/stdtypes.html#int.bit_length" rel="nofollow noreferrer">bit_length</a>. I think, as you've currently written it, your implementation would get stuck in a loop again if the numbers are bigger than 32 bits.</span>
<span class="comment-copy">Or we can import c_int32 only like this: <code>from ctypes import c_int32</code> and use like this: <code>a = c_int32(a).value</code></span>
<span class="comment-copy">Your code doesn't consider negative number cases</span>
