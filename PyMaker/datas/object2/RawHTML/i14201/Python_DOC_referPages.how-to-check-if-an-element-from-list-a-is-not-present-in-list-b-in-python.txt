<div class="post-text" itemprop="text">
<p>If I have one element alone this is easy:</p>
<pre>
&gt;&gt;&gt; 3 not in [2, 3, 4]
False
&gt;&gt;&gt; 3 not in [4, 5, 6]
True
</pre>
<p>But what if I have two lists and have to check if the elements in list <code>A</code> occur in list <code>B</code>?</p>
<pre><code>A=[1,2,3,4]
B=[4,5,6,7]
</code></pre>
<p>How do I get a results showing me that <code>1</code>,<code>2</code>,<code>3</code> are not in list <code>B</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using list comprehension:</p>
<p>truthy answer</p>
<pre><code>any([True for x in [1, 2, 3, 4] if x in [4, 5, 6, 7]])
</code></pre>
<p>list of elements not present in the second list</p>
<pre><code>[x for x in [1, 2, 3, 4] if x not in [4, 5, 6, 7]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if the items in the list are <em>hashable</em>:</p>
<pre><code>&gt;&gt;&gt; set(A) - set(B)
{1, 2, 3}
</code></pre>
<p>otherwise, you may use <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow"><code>filter</code></a> function:</p>
<pre><code>&gt;&gt;&gt; list(filter(lambda a: a not in B, A))
[1, 2, 3]
</code></pre>
<p>in that case, if <code>B</code> is <em>sorted</em>, you may get a better performance by using <a href="https://docs.python.org/3.5/library/bisect.html#bisect.bisect_left" rel="nofollow"><code>bisect.bisect_left</code></a> to search logarithmically:</p>
<pre><code>&gt;&gt;&gt; def pred(a):  # if B is already *sorted*
...     from bisect import bisect_left
...     i = bisect_left(B, a)
...     return i == len(B) or B[i] != a
... 
&gt;&gt;&gt; list(filter(pred, A))
[1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use list comprehension:</p>
<pre><code>C=[i for i in A if i not in B]
</code></pre>
<p>Output:</p>
<pre><code>[1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That's a typical case for boolean operations on sets:</p>
<pre><code>zerotonine = set(range(10))
fourtoten = set(range(4,11))
print "exclusively in one:", zerotonine ^ fourtoten
exclusively in one: set([0, 1, 2, 3, 10])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>set(A).difference(B) # set operation for difference between two collections A and B
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>set</code>.</p>
<p>e.g.</p>
<pre><code>&gt;&gt;&gt; a=[1,2,3,4]
&gt;&gt;&gt; b=[4,5,6,7]
&gt;&gt;&gt; list(set(a)-set(b))
[1, 2, 3]
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">This question has been asked a million times.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/2104305/finding-elements-not-in-a-list">Finding elements not in a list</a></span>
<span class="comment-copy">Please explain your answer, so that the asker can understand how it works.</span>
<span class="comment-copy">Just to point out: This is the same as using <code>set(A).symmetric_difference(B)</code> which has the same result as <code>set(B).symmetric_difference(A)</code>. Be aware that <code>set(A).difference(B)</code> could return a different result than <code>set(B).difference(A)</code> ("In A but not in B" vs "In B but not in A"), in case you're after such a property (as the question's title might suggest)</span>
<span class="comment-copy">Just to point out that this is not the symmetric difference. <code>set(A).difference(B)</code> will yield a different result than <code>set(B).difference(A)</code> when the lists are not exactly equal. If B contains a subset of A, then the latter will result an empty set. <code>set(A).symmetric_difference(B)</code> yields the same as <code>set(B).symmetric_difference(A)</code>. Here is a good link: <a href="https://www.programiz.com/python-programming/methods/set/difference" rel="nofollow noreferrer">programiz.com/python-programming/methods/set/difference</a></span>
