<div class="post-text" itemprop="text">
<p>I am studying <code>sklearn</code> and I write a class <code>Classifier</code> to do common classification. It need a <code>method</code> to determine using which Estimator:</p>
<pre><code># Classifier
from sklearn.svm import SVC
from sklearn.svm import LinearSVC
from sklearn.linear_model import SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier

class Classifier(object):
    def __init__(self, method='LinearSVC', *args, **kwargs):
        Estimator = getattr(**xxx**, method, None)
        self.Estimator = Estimator
        self._model = Estimator(*args, **kwargs)

    def fit(self, data, target):
        return self._model.fit(data, target)

    def predict(self, data):
        return self._model.predict(data)

    def score(self, X, y, sample_weight=None):
        return self._model.score(X, y, sample_weight=None)

    def persist_model(self):
        pass

    def get_model(self):
        return self._model

    def classification_report(self, expected, predicted):
        return metrics.classification_report(expected, predicted)

    def confusion_matrix(self, expected, predicted):
        return metrics.confusion_matrix(expected, predicted)
</code></pre>
<p>I want to get Estimator by name, but what <strong>xxx</strong> should be?
Or is there a better way to do this?<br/>
Build a dict to store the imported module?  but this way seems not so good..</p>
</div>
<div class="post-text" itemprop="text">
<p>In this case it is advised to simply use the class directly as an argument.</p>
<p>You will never have to worry about it as a string: you can compare <code>LinearSVC is LinearSVC</code>, and compare it to something else.</p>
<p>Think of it like accepting an integer as argument, then converting it to a string to use it: does that make sense? You can just simply require a string.</p>
<p>Proposed code:</p>
<pre><code>class Classifier(object):
    def __init__(self, model = LinearSVC, *args, **kwargs):
        self._model = model(*args, **kwargs)
</code></pre>
<p>You can then do:</p>
<pre><code>myclf = Classifier(..., estimator = LinearSVC, ...)
isinstance(myclf._model, LinearSVC)
</code></pre>
<h3>As per the comment:</h3>
<p>You can then also initialise a dict at start like:</p>
<pre><code>from sklearn.svm import LinearSVC

str_to_model = {'LinearSVC' : LinearSVC}

class Classifier(object):
    def __init__(self, model = "LinearSVC", *args, **kwargs):
        self._model = str_to_model[model](*args, **kwargs)
</code></pre>
<p>It's cleaner to work with a <code>KeyError</code> (the string/model does not exist, and you're aware since you did not define them), than to check <code>globals</code>, sounds pretty nasty!</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two build-in functions may help you: <code>globals</code> and <code>locals</code>, both of the two return a dict of the current symbol table.</p>
<p>you code could be <code>Estimator = globals()[method]</code> or mv the estimator keys to <code>__init__</code> and use <code>Estimator = locals()[method]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Built in function <a href="https://docs.python.org/3/library/functions.html#globals" rel="nofollow">globals()</a> does the trick: you can check that <code>globals()['LogisticRegression'] is LogisticRegression</code> returns <code>True</code>.</p>
<p>ADDENDUM</p>
<ul>
<li>Safe: nothing 'nasty' can happen by evaluating <code>globals()[method]</code></li>
<li>Efficient: overhead is negligible with respect to <code>some_method_dict[method]</code></li>
<li>Simple: <code>globals()[method]</code> is just the shortest answer to the question.</li>
</ul>
<p>If this is pythonic or not, I don't know, but the <code>globals()</code> builtin is there to be used, so why chose more complicated solutions?</p>
<p>To be explicit, </p>
<pre><code>Estimator = getattr(..., method, None)
</code></pre>
<p>can be implemented as</p>
<pre><code>Estimator = globals().get(method)
</code></pre>
<p>if the <code>None</code> return is preferred to a <code>KeyError</code> exception if <code>method</code> was not imported.</p>
</div>
<span class="comment-copy">I don't get it. Where is your import? Can you pass the <b>xxx</b> as a parameter?</span>
<span class="comment-copy">@sobolevn  import at the top, <code>from sklearn.linear_model import LogisticRegression</code> and so on</span>
<span class="comment-copy">Do you want to support dynamic module imports?</span>
<span class="comment-copy">@sobolevn  As you see, the <code>Classifier Estimator</code> from different module of sklearn, program don't know which from <code>linear_model </code> or <code>svm </code>. Using <code>dynamic import</code> mean I need a dict to record which <code>class</code> from which <code>module</code></span>
<span class="comment-copy">For many reasons it is better to give the actual class <code>LogisticRegression</code> as parameter, rather than the string version.</span>
<span class="comment-copy">Because I need to build a <code>Classifier</code>  by a html form. A user can choose the method,  that's why I use string.</span>
<span class="comment-copy">You can use <code>model.__name__</code> to get <code>LinearSVC</code>.</span>
<span class="comment-copy">It just like magic....I just wonder is this way safe and efficient? I need to instantiate this <code>Classifier</code> in many different module.</span>
