<div class="post-text" itemprop="text">
<p>This works and happily prints 81:</p>
<pre><code>class X:
    mypow = pow

print(X().mypow(3, 4))
</code></pre>
<p>But why? Isn't the method given the extra "self" argument and should be utterly confused?</p>
<p>For comparison, I also tried it with my own <code>Pow</code> function:</p>
<pre><code>def Pow(x, y, z=None):
    return x ** y

class Y:
    myPow = Pow

print(Pow(3, 4))
print(Y().myPow(3, 4))
</code></pre>
<p>The direct function call prints 81 and the method call crashes as expected, as it does get that extra instance argument:</p>
<pre><code>Python 3:  TypeError: unsupported operand type(s) for ** or pow(): 'Y' and 'int'
Python 2:  TypeError: unsupported operand type(s) for ** or pow(): 'instance' and 'int'
</code></pre>
<p>Why/how does Pythons own <code>pow</code> work here? <a href="https://docs.python.org/3/library/functions.html#pow">The documentation</a> didn't help and I couldn't find the source.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is because python functions defined in C (builtins) have auto handled self argument. Here is pow function header : </p>
<p><code>static PyObject *
math_pow(PyObject *self, PyObject *args)</code>
Here you can see that self is always passed by interpreter.</p>
</div>
<div class="post-text" itemprop="text">
<p>This behavior is connected to <a href="https://docs.python.org/2/howto/descriptor.html#functions-and-methods" rel="nofollow">method binding</a>. Have a look at what Python tells you about these functions/methods:</p>
<pre><code>&gt;&gt; pow
&lt;built-in function pow&gt;
&gt;&gt;&gt; X.mypow
&lt;built-in function pow&gt;
&gt;&gt;&gt; X().mypow
&lt;built-in function pow&gt;
</code></pre>
<p>and</p>
<pre><code>&gt;&gt;&gt; Pow
&lt;function Pow at 0x7f88f5715f50&gt;
&gt;&gt;&gt; Y.myPow
&lt;unbound method Y.Pow&gt;
&gt;&gt;&gt; Y().myPow
&lt;bound method Y.Pow of &lt;__main__.Y instance at 0x7f88f57117e8&gt;&gt;
</code></pre>
<p>Further the documentation states:</p>
<blockquote>
<p>Class dictionaries store methods as functions. In a class definition, methods are written using <a href="https://docs.python.org/2/reference/compound_stmts.html#def" rel="nofollow"><code>def</code></a> and <a href="https://docs.python.org/2/reference/expressions.html#lambda" rel="nofollow"><code>lambda</code></a>, the usual tools for creating functions. [...]</p>
<p>To support method calls, functions include the <a href="https://docs.python.org/2/reference/datamodel.html#object.__get__" rel="nofollow"><code>__get__()</code></a> method for binding methods during attribute access. This means that all functions are non-data descriptors which return bound or unbound methods depending whether they are invoked from an object or a class. [...]</p>
</blockquote>
<p>But built-in functions don't have a <code>__get__()</code> method. That's why <code>pow</code> wasn't bound and could be used the way you observed, while <code>Pow</code> couldn't.</p>
</div>
<span class="comment-copy">Same way it gets passed to my <code>Pow</code>? @PadraicCunningham</span>
<span class="comment-copy">That's because the <code>__self__</code> attribute of builtin functions is not writeable, hence it is always <code>None</code> for <code>pow</code>.</span>
<span class="comment-copy">@vaultah Try in Python 2.</span>
<span class="comment-copy">@AshwiniChaudhary Thanks, I'm looking into <code>__self__</code> now, didn't know that yet.</span>
<span class="comment-copy"><a href="https://bugs.python.org/issue14003" rel="nofollow noreferrer"><code>__self__</code> on built-in functions is not as documented</a></span>
<span class="comment-copy">Isn't that <code>math.pow</code>, not <code>pow</code>?</span>
<span class="comment-copy">It's math.pow, but behavior is same.</span>
<span class="comment-copy">Hmm, I checked and confirm it does behave the same in that regard (i.e., happily returns 81.0). I found <a href="https://github.com/python-git/python/blob/master/Modules/mathmodule.c#L927" rel="nofollow noreferrer">the source of that</a> and it just ignores the <code>self</code> argument. I guess I'd need to know how user-defined methods <i>don't</i> ignore it to really understand it. AshwiniChaudhary also commented something about builtin's <code>__self__</code> not writable, which I confirmed, but I guess that shouldn't matter if it's not used anyway. I'll look a bit into both issues.</span>
<span class="comment-copy">The problem is user defined methods behave different way when compared to C methods. Each python C method must have defined self, and it's filled always with something (current object, global etc.). User methods don't have that option, so that means when used way you have shown, first argument will be filled with self, but when used as usual, it will not.</span>
