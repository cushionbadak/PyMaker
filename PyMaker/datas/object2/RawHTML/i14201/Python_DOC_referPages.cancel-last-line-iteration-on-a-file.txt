<div class="post-text" itemprop="text">
<p>I need to iterate on a file, stop iteration on a condition and then continue parse the file at the same line with another function (That may change so I can't just add content in the previous function).</p>
<p>An example file (file.txt) :</p>
<pre><code>1
2
3
4
5
6
7
8
9
</code></pre>
<p>Function I try to do : </p>
<pre><code>def parse1(file, stop):
# 1st parsing function (Main function I am doing)
    for line in file:
            if line.strip() == stop:
            # Stop parsing on condition
                break
            else:
            # Parse the line (just print for example)
                print(line)

def parse2(file):
# 2nd parsing function (Will be my own functions or external functions)
    for line in file:
        # Parse the line (just print for example)
        print(line)
</code></pre>
<p>Result in terminal:</p>
<pre><code>&gt;&gt;&gt; file = open("file.txt")

&gt;&gt;&gt; parse1(file, "4")
1
2
3

&gt;&gt;&gt; parse2(file)
5
6
7
8
9
</code></pre>
<p>My problem with this is the "4" line is skipped by the 1st function when I look for condition. </p>
<p>How can I avoid this : I found any solution for cancel the last iteration or go back a line.</p>
<p>The <code>file.tell()</code> function don't work with <code>for</code> on file.</p>
<p>I tried to do this with <code>while</code> + <code>file.readline()</code> but it is very very slower than the <code>for</code> loop on file (And I want to parse files with millions of lines).</p>
<p>Is there an elegant solution for keeping the use of the <code>for</code> loop ?</p>
</div>
<div class="post-text" itemprop="text">
<p>In python3, the 'for line in file' construct is represented by an iterator internally. By definition, a value that was produced from an iterator cannot be 'put back' for later use (<a href="http://www.diveintopython3.net/iterators.html" rel="nofollow">http://www.diveintopython3.net/iterators.html</a>).</p>
<p>To get the desired behaviour, you need a function that <em>chains</em> together two iterators, such as the <a href="https://docs.python.org/3/library/itertools.html?itertools.chain#itertools.chain" rel="nofollow"><code>chain</code></a> function provided by the <code>itertools</code> module. In the stop condition of <code>parse1</code>, you return the last line together with the file iterator:</p>
<pre><code>import itertools

def parse1(file,stop):
# 1st parsing function
    for line in file:
       # Stop parsing on condition
        if line.strip() == stop:
            return itertools.chain([line],file) # important line
        else:
        # Parse the line (just print for example)
            print('parse1: '+line)
</code></pre>
<p>The chain statement connects two iterators. The first iterator contains just one element: the line you want to process again. The second iterator is the remaining part of the file. As soon as the first iterator runs out of values, the second iterator is accessed.</p>
<p>You don't need to change <code>parse2</code>. For clarity, I modified the print statement:</p>
<pre><code>def parse2(file):
# 2nd parsing function
for line in file:
    # Parse the line (just print for example)
    print('parse2: '+line)
</code></pre>
<p>Then, you can call parse1 and parse2 in a most functional manner:</p>
<pre><code>with open('testfile','r') as infile:
   parse2(parse1(infile,'4'))
</code></pre>
<p>The output of the above line is:</p>
<pre><code>parse1: 1
parse1: 2
parse1: 3
parse2: 4
parse2: 5
parse2: 6
parse2: 7
parse2: 8
parse2: 9
</code></pre>
<p>Note, how the value '4' was produced by the <code>parse2</code> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest to make a copy<sup>1</sup> of your file object and just iterate over the copy in <code>else</code> block and call the second function within first function , also as a more pythonic way you can use <code>with</code> statement for opening the file that will close the file at end of the statement and put the second function within first function :</p>
<pre><code>#ex.txt

1
2
3
4
5
6
7
8
9
10
</code></pre>
<p>you can use <a href="https://docs.python.org/2/library/itertools.html#itertools.tee" rel="nofollow"><code>itertools.tee</code></a> for create copy<sup>1</sup> of your file object :</p>
<pre><code>from itertools import tee

def parse1(file_name, stop):

  def parse2(file_obj):
    print '**********'
    for line in file_obj:
        print(line)

  with open(file_name) as file_obj:
    temp,file_obj=tee(file_obj)
    for line in temp:
            if line.strip() == stop:
                break
            else:
                next(file_obj)
                print(line)
    parse2(file_obj)

parse1("ex.txt",'4')
</code></pre>
<p>result :</p>
<pre><code>1

2

3

**********
4

5

6

7

8

9

10
</code></pre>
<hr/>
<p><sub>
1) actually <code>itertools.tee</code> doesn't create a copy but you can use it for this aim based on DOC it <em>Return n independent iterators from a single iterable.</em>
and you can assign one of this independent iterators to the object itself that has been iterated and create one another as temp.
</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>IMHO, the simplest solution is to have first parser return the line where it found the stop condition, and pass it to second one. The second should have an explicit function to parse one line to avoid code duplication :</p>
<pre><code>def parse1(file, stop):
# 1st parsing function (Main function I am doing)
    for line in file:
            if line.strip() == stop:
            # Stop parsing on condition
                return line
            else:
            # Parse the line (just print for example)
                print(line)
    return None

def parse2(file, line = None):
# 2nd parsing function (Will be my own functions or external functions)
    def doParse(line):
    # do actual parsing (just print for example)
        print(line)
    if line is None:
        doParse(line)
    for line in file:
        doParse(line)

# main
...
stop = parse1(file)
if stop:
    parse2(stop, file)
</code></pre>
</div>
<span class="comment-copy">could you not keep the line variable from parse1 and pass it to parse2</span>
<span class="comment-copy">The idea is good for my own functions, but l may use some external functions in place of <code>parse2</code> that don't have parameters like this.</span>
<span class="comment-copy">Thanks, this is exactly what I need !</span>
<span class="comment-copy">This answer work very good also. Thanks !</span>
<span class="comment-copy">@Anc Welcome, i think its more efficient and safe to put your functions within one!</span>
<span class="comment-copy">I agree that it's more efficient to make only one function, but for my case I need flexibility (The kind of file I want parse may vary).</span>
<span class="comment-copy">This idea work for my own functions, but don't work if I want use some external functions in place of parse2 that don't have parameters like this.</span>
