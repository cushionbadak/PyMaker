<div class="post-text" itemprop="text">
<p>I have a dictionary of dictionaries as follows:</p>
<pre><code>dictofdict = {'001': {'date': 201504, 'status':'New'}, '002': {'date':201504, 'status':'Constant', 'rate':'-10'}, '003':{'date': 201504, 'status':'In Review'}}
</code></pre>
<p>The <strong>inner</strong> dictionaries may or may not have all the following keys: date, status and rate. For example: 001 and 003 do not have the key rate in their dictionary of values.</p>
<p>How do I read this dictionary of dictionaries such that I have an output as follows. I am interested in only the date and status keys from the inner dictionaries.</p>
<pre><code>201504    001    New
201504    002    Constant
201504    003    In Review
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use an <code>if</code> clause to check if they exist in the inner dictionary</p>
<pre><code>&gt;&gt;&gt; for k,v in dictofdict.items():
...      if 'date' in v and 'status' in v:
...           print("{}\t{}\t{}".format(v['date'],k,v['status']))
... 
201504  003 In Review
201504  002 Constant
201504  001 New
</code></pre>
<p>If you are particular about the order then you will have to use <code>sorted</code> as a dictionary otherwise is un-ordered</p>
<pre><code>&gt;&gt;&gt; for k,v in sorted(dictofdict.items()):
...      if 'date' in v and 'status' in v:
...           print("{}\t{}\t{}".format(v['date'],k,v['status']))
... 
201504  001 New
201504  002 Constant
201504  003 In Review
</code></pre>
<p>As Padraic <a href="https://stackoverflow.com/questions/30739405/reading-specific-key-values-from-a-dictionary-of-dictionary/30739451?noredirect=1#comment49535047_30739451">mentions</a> you can use a list comprehension to store these values. </p>
<pre><code>[(k, d["date"], d["status"]) for k, d in sorted(dictofdict.items()) if "date" in d and "status" in d]
</code></pre>
<p>This can be used as </p>
<pre><code>&gt;&gt;&gt; l = [(k, d["date"], d["status"]) for k, d in sorted(dictofdict.items()) if "date" in d and "status" in d]
&gt;&gt;&gt; for i,j,k in l:
...     print("{}\t{}\t{}".format(i,j,k))
... 
201504  001 New
201504  002 Constant
201504  003 In Review
</code></pre>
<p>As JonCle <a href="https://stackoverflow.com/questions/30739405/reading-specific-key-values-from-a-dictionary-of-dictionary/30739451?noredirect=1#comment49535145_30739451">mentions</a> below</p>
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html?highlight=issubset#set.issubset" rel="nofollow noreferrer"><code>set.issubset</code></a> in your clause too.</p>
<p>This can be used as </p>
<pre><code>&gt;&gt;&gt; for k,v in sorted(dictofdict.items()):
...       if {'date', 'status'}.issubset(v):
...            print("{}\t{}\t{}".format(v['date'],k,v['status']))
... 
201504  001 New
201504  002 Constant
201504  003 In Review
</code></pre>
<p>One final approach is the <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a>. Called as <em>Easier to ask for forgiveness than permission</em>, you can avoid the <code>if</code> clause completely here!</p>
<pre><code>&gt;&gt;&gt; for k, v in sorted(dictofdict.items()):
...     try:
...         print '{date}\t{}\t{status}'.format(k, **v)
...     except KeyError:
...         pass
... 
201504  001 New
201504  002 Constant
201504  003 In Review
</code></pre>
<p>The working of this is that we assume that the key is present in the dict. If it is not there, an exception would be raised. Here we choose to ignore that as it is not required for us. </p>
<p>Note:</p>
<p>As you have a dictionary here, you can take advantage of the <code>format</code> method here to print the keys of the dictionary (You can see a few examples <a href="https://docs.python.org/2/library/string.html#format-examples" rel="nofollow noreferrer">here</a>) and supply the keys of the dictionary as fields in <code>format</code></p>
<p>This can be done as</p>
<pre><code>print('{date}\t{}\t{status}'.format(k, **v))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To do this, you need to check if inner dicts contain the key <code>status</code> and <code>date</code>. Also, to print in order, you can use the <code>sorted()</code> function.</p>
<pre><code>&gt;&gt;&gt; dictofdict = {'001': {'date': 201504, 'status':'New'}, '002': {'date':201504, 'status':'Constant', 'rate':-10}, '003':{'date': 201504, 'status':'In Review'}}

&gt;&gt;&gt; for number in  sorted(dictofdict):
    # Only print if date and status key are present in the inner dict
    if 'date' in dictofdict[number] and 'status' in  dictofdict[number]:
        print '{}\t{}\t{}'.format(dictofdict[number]['date'], number, dictofdict[number]['status'])


201504  001 New
201504  002 Constant
201504  003 In Review
</code></pre>
</div>
<span class="comment-copy">are date and status always there?</span>
<span class="comment-copy">since <code>dict.items()</code> returns a sequence of <code>(key, value)</code> pairs, the usual convention is to name them <code>k</code> and <code>v</code> (unless you have a more meaningfull naming of course) - <code>i</code> and <code>j</code> are the convention for index variables in nested C-like <code>for</code> loops.</span>
<span class="comment-copy">You would need two separate checks if the OP was either key in the case where only one exists</span>
<span class="comment-copy">You could also use a list comp if the op wants to store and keep <code>[(k, d["date"], d["status"]) for k, d in dictofdict.items() if "date" in d and "status" in d]</code></span>
<span class="comment-copy">In terms of scaling - <code>if {'date', 'status'}.issubset(d)</code> would also work nicely - that way you can use a variable for items instead of amending code logic</span>
<span class="comment-copy">I'd also contemplate changing your formatting from <code>print("{}\t{}\t{}".format(v['date'],k,v['status']))</code> to <code>'{date}\t{}\t{status}'.format(k, **v)</code></span>
<span class="comment-copy">No need for <code>sorted(dictofdict.keys())</code> just use <code>sorted(dictofdict)</code></span>
<span class="comment-copy">Yaa no need for it..thanks..edited!</span>
<span class="comment-copy">It's also worth noting that <code>has_key</code> was removed in Python 3.x (and has been deprecated for quite a while even in the 2.x series)... the correct approach is to use <code>if 'date' in dictofdict[number]</code>...</span>
<span class="comment-copy">Updated the ans!</span>
