<div class="post-text" itemprop="text">
<p>I have a 21 GB dataset df_ns:</p>
<pre><code>domain|ns
123.com|ns1.domanihost.com
hymi.net|ns2.hostinger.com
</code></pre>
<p>and another 12 GB dataset df_ip:</p>
<pre><code>ip|domain
28.76.2.2|myname.com
86.90.234.5| 123.com
</code></pre>
<p>and I would like to join them on domain name and for the domains that are in both files extract ip and ns.</p>
<p>The way I thought of using it is loading the df_ip data into a dictionary and going through df_ns data line by line and check if the domain is there, then extract the ns. But it is still very resource consuming .</p>
<p>Does anybody have any other, more efficient idea how to do it?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>sort -o df_ns.csv df_ns.csv &amp;&amp; \
sort -o df_ip.csv df_ip.csv &amp;&amp; \
join -t'|' df_ns.csv df_ip.csv &gt; df_combined.csv
</code></pre>
<p>Reference: <a href="http://linux.die.net/man/1/join" rel="nofollow">http://linux.die.net/man/1/join</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Sort your data by first column, e.g., with gnu sort.
After that, you will not need to store your data in memory, just use two iterators like this:</p>
<pre><code>import csv, sys
it1 = (csv.reader(open("df_ns", "r")))
it2 = (csv.reader(open("df_ip", "r")))
# skip the headers
it1.next()
it2.next()
try:
    dm1, ns = it1.next() # first row
except StopIteration:
    sys.exit(0)
try:
    dm2, ip = it2.next()
except StopIteration:
    sys.exit(0)
while True:
    if dm1 == dm2:
        print dm1, ns, ip
    if dm1 &lt; dm2:
        try:
            dm1, ns = it1.next()
        except StopIteration:
            break
        continue
    try: 
        dm2, ip = it2.next()
    except StopIteration:
        break
</code></pre>
</div>
<span class="comment-copy">How about using <a href="https://docs.python.org/3/library/io.html#io.StringIO" rel="nofollow noreferrer">StringIO</a>?</span>
<span class="comment-copy">Are you open to non-Python solutions? Here's an efficient solution: <code>sort -o df_ns.csv df_ns.csv &amp;&amp; sort -o df_ip.csv df_ip.csv &amp;&amp; join -t'|' df_ns.csv df_ip.csv &gt; df_combined.csv</code></span>
<span class="comment-copy">@Robáµ© Can you post it as an answer?</span>
<span class="comment-copy">Thanks for your help.Since it1 and 2 are lists, they cannot be assigned to two values like dm1,ns. Do you have any other idea how to do it?</span>
<span class="comment-copy">You're welcome. It1 and 2 are not actually lists, they must be iterators that yield tuples. Why do you want them to be <i>assigned</i> to two values?</span>
<span class="comment-copy">I do not want it. But currently I receive an error of too much value to unpack on the first "try-catch" of your answer.</span>
<span class="comment-copy">Oh, sorry, I didn't test the code -- I gave it just to illustrate the idea. But if there are too many values to unpack, then it means that your csv-files are probably not two-column comma-separated values... Would you please add smth like "row = it1.next(); print row;  dm1, ns = it1.next()" so that we can see what happens?</span>
