<div class="post-text" itemprop="text">
<p>I try to parse a html file with a Python script using the <code>xml.etree.ElementTree</code> module. The charset should be UTF-8 according to the header. But there is a strange character in the file. Therefore, the parser can't parse it. I opened the file in Notepad++ to see the character <img alt="FS" src="https://i.stack.imgur.com/vFwKv.png"/>. I tried to open it with several encodings but I don't find the correct one.</p>
<p>As I have many files to parse, I would like to know how to remove all bytes which can't be decode. Is there a solution?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I would like to know how to remove all bytes which can't be decode. Is there a solution?</p>
</blockquote>
<p>This is simple:</p>
<pre><code>with open('filename', 'r', encoding='utf8', errors='ignore') as f:
    ...
</code></pre>
<p>The <code>errors='ignore'</code> tells Python to drop unrecognized characters.  It can also be passed to <code>bytes.decode()</code> and most other places which take an <code>encoding</code> argument.</p>
<p>Since this decodes the bytes into unicode, it may not be suitable for an XML parser that wants to consume bytes.  In that case, you should write the data back to disk (e.g. using <a href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobj" rel="noreferrer"><code>shutil.copyfileobj()</code></a>) and then re-open in <code>'rb'</code> mode.</p>
<p>In Python 2, these arguments to the built-in <code>open()</code> don't exist, but you can use <code>io.open()</code> instead.  Alternatively, you can decode your 8-bit strings into unicode strings after reading them, but this is more error-prone in my opinion.</p>
<hr/>
<p><strong>But it turns out OP doesn't have invalid UTF-8.</strong>  OP has valid UTF-8 which happens to include control characters.  Control characters are mildly annoying to filter out since you have to run them through a function like this, meaning you can't just use <code>copyfileobj()</code>:</p>
<pre><code>import unicodedata

def strip_control_chars(data: str) -&gt; str:
    return ''.join(c for c in data if unicodedata.category(c) != 'Cc')
</code></pre>
<p>Cc is the Unicode category for "Other, control character, as described <a href="http://www.unicode.org/reports/tr44/#General_Category_Values" rel="noreferrer">on the Unicode website</a>.  To include a slightly broader array of "bad characters," we could strip the entire "other" category (which mostly contains useless stuff anyway):</p>
<pre><code>def strip_control_chars(data: str) -&gt; str:
    return ''.join(c for c in data if not unicodedata.category(c).startswith('C'))
</code></pre>
<p>This will filter out line breaks, so it's probably a good idea to process the file a line at a time and add the line breaks back in at the end.</p>
<p>In principle, we could create a <a href="https://docs.python.org/3/library/codecs.html" rel="noreferrer">codec</a> for doing this incrementally, and then we <em>could</em> use <code>copyfileobj()</code>, but that's like using a sledgehammer to swat a fly.</p>
</div>
<span class="comment-copy">does this help? <a href="http://stackoverflow.com/questions/21698024/how-to-correctly-parse-utf-8-xml-with-elementtree" title="how to correctly parse utf 8 xml with elementtree">stackoverflow.com/questions/21698024/â€¦</a></span>
<span class="comment-copy">Do you need a solution for both Python 2 <b>and</b> Python 3 ? It is often much easy to answer in only one version is of concern. I was thinking of a way to note the lines containing offending characters for further analysis, but it might be easier for one single version</span>
<span class="comment-copy">@hgwells Unfortunately it does not help as the solution is "Leave decoding the bytes to the parser" which is what I am doing...</span>
<span class="comment-copy">@SergeBallesta I need a solution in Python 3 for now, but I am sure that a Python 2 version would be interesting too.</span>
<span class="comment-copy">From your comment on Kevin's answer, I think that simply removing offending characters could not be enough as is exactly what his answer does. Could you show some part of the file (ideally around the line causing the error) ?</span>
<span class="comment-copy">@clemtoy: If you want to be able to see where the offending characters were, you could try <code>errors='replace'</code> instead of <code>errors='ignore'</code></span>
<span class="comment-copy">I am not sure to understand how to remove the characters from the file, is the solution something like <code>with open(filename, 'r', errors='ignore') as i, open('out.html', 'w') as o: shutil.copyfileobj(i, o)</code> ? (@SergeBallesta)</span>
<span class="comment-copy">@clemtoy: That looks like it ought to work, but you should probably specify the encoding explicitly in both open calls.  Also, make sure you don't accidentally overwrite the input file (e.g. if <code>filename == 'out.html'</code>).</span>
<span class="comment-copy">@Kevin Well, I just noticed I can open the file like this <code>open(filename, 'r', encoding='utf8')</code> and read it without any errors (the encoding is necessary, but I don't need to write <code>errors='ignore'</code>) So when I copy the file with <code>shutil.copyfileobj()</code> the character is copied. Anyway, the <code>xml.etree.ElementTree</code> parser does not accept the character... Sorry guys, I don't want to waste your time...</span>
<span class="comment-copy">@clemtoy: OK, you have valid UTF-8 which contains control characters.  We can filter those out too.</span>
