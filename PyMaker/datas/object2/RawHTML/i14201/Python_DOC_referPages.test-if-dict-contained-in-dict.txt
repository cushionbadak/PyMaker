<div class="post-text" itemprop="text">
<p>Testing for equality works fine like this for python dicts:</p>
<pre><code>first  = {"one":"un", "two":"deux", "three":"trois"}
second = {"one":"un", "two":"deux", "three":"trois"}

print(first == second) # Result: True
</code></pre>
<p>But now my second dict contains some additional keys I want to ignore:</p>
<pre><code>first  = {"one":"un", "two":"deux", "three":"trois"}
second = {"one":"un", "two":"deux", "three":"trois", "foo":"bar"}
</code></pre>
<p><strong>Is there a simple way to test if the first dict is part of the second dict, with all its keys and values?</strong></p>
<p><strong>EDIT 1:</strong></p>
<p>This question is suspected to be a duplicate of <a href="https://stackoverflow.com/questions/3415347/how-to-test-if-a-dictionary-contains-certain-keys">How to test if a dictionary contains certain <em>keys</em></a>, but I'm interested in testing keys <em>and their values</em>. Just containing the same keys does not make two dicts equal.</p>
<p><strong>EDIT 2:</strong></p>
<p>OK, I got some answers now using four different methods, and proved all of them working. As I need a fast process, I tested each for execution time. I created three identical dicts with 1000 items, keys and values were random strings of length 10. The <code>second</code> and <code>third</code> got some extra key-value pairs, and the last non-extra key of the <code>third</code> got a new value. So, <code>first</code> is a subset of <code>second</code>, but not of <code>third</code>. Using module <code>timeit</code> with 10000 repetitions, I got:</p>
<pre><code>Method                                                      Time [s]   
first.viewitems() &lt;=second.viewitems()                           0.9 
set(first.items()).issubset(second.items())                      7.3
len(set(first.items()) &amp; set(second.items())) == len(first)      8.5
all(first[key] == second.get(key, sentinel) for key in first)    6.0
</code></pre>
<p>I guessed the last method is the slowest, but it's on place 2. 
But method 1 beats them all.</p>
<p>Thanks for your answers!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects">dictionary view</a>:</p>
<pre><code># Python 2
if first.viewitems() &lt;= second.viewitems():
    # true only if `first` is a subset of `second`

# Python 3
if first.items() &lt;= second.items():
    # true only if `first` is a subset of `second`
</code></pre>
<p>Dictionary views are the <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects">standard in Python 3</a>, in Python 2 you need to prefix the standard methods with <code>view</code>. They act like sets, and <code>&lt;=</code> tests if one of those is a subset of (or is equal to) another.</p>
<p>Demo in Python 3:</p>
<pre><code>&gt;&gt;&gt; first  = {"one":"un", "two":"deux", "three":"trois"}
&gt;&gt;&gt; second = {"one":"un", "two":"deux", "three":"trois", "foo":"bar"}
&gt;&gt;&gt; first.items() &lt;= second.items()
True
&gt;&gt;&gt; first['four'] =  'quatre'
&gt;&gt;&gt; first.items() &lt;= second.items()
False
</code></pre>
<p>This works for <em>non-hashable values too</em>, as the keys make the key-value pairs unique already. The documentation is a little confusing on this point, but even with mutable values (say, lists) this works:</p>
<pre><code>&gt;&gt;&gt; first_mutable = {'one': ['un', 'een', 'einz'], 'two': ['deux', 'twee', 'zwei']}
&gt;&gt;&gt; second_mutable = {'one': ['un', 'een', 'einz'], 'two': ['deux', 'twee', 'zwei'], 'three': ['trois', 'drie', 'drei']}
&gt;&gt;&gt; first_mutable.items() &lt;= second_mutable.items()
True
&gt;&gt;&gt; first_mutable['one'].append('ichi')
&gt;&gt;&gt; first_mutable.items() &lt;= second_mutable.items()
False
</code></pre>
<p>You could also use the <a href="https://docs.python.org/2/library/functions.html#all"><code>all()</code> function</a> with a generator expression; use <code>object()</code> as a sentinel to detect missing values concisely:</p>
<pre><code>sentinel = object()
if all(first[key] == second.get(key, sentinel) for key in first):
    # true only if `first` is a subset of `second`
</code></pre>
<p>but this isn't as readable and expressive as using dictionary views.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>all(k in second and second[k] == v for k, v in first.items())
</code></pre>
<p>if you know that none of the values can be <code>None</code>, it will simplify to:</p>
<pre><code>all(second.get(k, None) == v for k, v in first.items())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So, you basically want to check if one dictionary is a subset of another.</p>
<pre><code>first  = {"one":"un", "two":"deux", "three":"trois"}
second = {"one":"un", "two":"deux", "three":"trois", "foo":"bar"}

def subset_dic(subset, superset):
    return len(set(subset.items()) &amp; set(superset.items())) == len(subset)


print(subset_dic(first, second))
</code></pre>
<p>Prints: </p>
<pre><code>True
</code></pre>
<p>In case you want to abstract out the subset/superset part:</p>
<pre><code>def subset_dic(dict1, dict2):
    return len(set(dict1.items()) &amp; set(dict2.items())) == len(min((dict1, dict2), key=len))
</code></pre>
<p><strong>Note</strong>: this will fail to work, if any value is a mutable object. Hence you can add an additional step (convert mutable object to immutable analog) in the function to overcome this limitation.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong># Updated Ans:</strong></p>
<p><strong>METHOD-1: Using Dictionary Views:</strong></p>
<p>As <a href="https://stackoverflow.com/users/100297/martijn-pieters">Martijn</a> suggested, We can use dictionary views to check this. <code>dict.viewitems()</code> acts as a set. We can perform various set operations on this like intersection, union etc. (Check this <a href="https://docs.python.org/2.7/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">link</a>.)</p>
<pre><code>first.viewitems() &lt;= second.viewitems()
True
</code></pre>
<p>We check if <code>first</code> is less than equal to <code>second</code>. This evaluating to True means <code>first</code> is a subset of <code>second.</code></p>
<p><strong>METHOD-2 Using issubset() operation of sets:</strong></p>
<p><strong>(DISCLAIMER: This method has some redundancy and requires all values to be hashable. Method-1 is suggested to be followed to handle all cases. Thanks <a href="https://stackoverflow.com/users/100297/martijn-pieters">Martijn</a> for the suggestions.)</strong></p>
<p>Use <code>.items()</code> attribute of a dictionary to get a list of (key,value) tuples and then use <strong>issubset()</strong> operation of sets. </p>
<p><strong>This will check for both the keys and the equality.</strong>.</p>
<pre><code>&gt;&gt;&gt; first  = {"one":"un", "two":"deux", "three":"trois"}
&gt;&gt;&gt; second = {"one":"un", "two":"deux", "three":"trois", "foo":"bar"}

&gt;&gt;&gt; set(first.items()).issubset(second.items())
True
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/3415347/how-to-test-if-a-dictionary-contains-certain-keys">How to test if a dictionary contains certain keys</a></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/9323749/python-check-if-one-dictionary-is-a-subset-of-another-larger-dictionary">Python: Check if one dictionary is a subset of another larger dictionary</a></span>
<span class="comment-copy">Why did you remove the alternative version you posted earlier? <code>not (set(first.items()) - set(second.items()))</code></span>
<span class="comment-copy">@Iskren because it will not work if values are not hashable, for example if  <code>'foo':[1, 2, 3]</code> was one of the items.</span>
<span class="comment-copy">Your second solution is very elegant, though it might get slow if values are deeply nested. Nevertheless it's highly polymorphic and concise. +1</span>
<span class="comment-copy">Creating a set of both full dictionaries seems a bit expensive.</span>
<span class="comment-copy">Comparing two sets of tuples without hashing is even more expensive in terms of sheer complexity.</span>
<span class="comment-copy">Yes, but no need to compare tuples; dictionaries already have O(1) item access, so you can just iterate through one dictionary and do member checks on the other one.</span>
<span class="comment-copy">There already is an answer that does that and SO rules recommend to post original answers only :)</span>
<span class="comment-copy">Sure, my comment wasn’t meant to be a “this is bad, you should do X instead”, just a general note on the performance of this solution :)</span>
<span class="comment-copy">Why use <code>list()</code> first and not use <code>set(first.items()).issubset(second.items())</code> directly? And in Python 3, <code>dict.items()</code> <i>supports the usecase directly</i>; <code>l1.items() &lt; l2.items()</code> works just fine. Note that this requires all values to be hashable (using <code>set()</code> objects or dictionary views).</span>
<span class="comment-copy">Thanks Martijn. That step was unnecessary. Updated the ans!</span>
<span class="comment-copy">You still have redundancy here; in Python 3 <code>dict.items()</code> <i>already acts as a set</i>. In Python 2 you can get the same behaviour by using <code>dict.viewitems()</code>. And your approach still requires that the values are hashable, while dictionary views do not.</span>
<span class="comment-copy">Yeaa updated! thanks for the suggestions Martijn..:)</span>
