<div class="post-text" itemprop="text">
<p>I am implementing a monthly calendar in django and used some code I found online. Within the code there is a lambda function that I need to tune for my specific use. </p>
<pre><code>def group_by_day(self, event):
        field = lambda event: event.start.day
        return dict(
            [(day, list(items)) for day , items in groupby(event, field)]
        )
</code></pre>
<p>From what I read online:</p>
<blockquote>
<p>group_by_day() builds a dictionary with the day of the month as key
  and any workouts for that day as its value (<a href="http://uggedal.com/journal/creating-a-flexible-monthly-calendar-in-django/" rel="nofollow">http://uggedal.com/journal/creating-a-flexible-monthly-calendar-in-django/</a>)</p>
</blockquote>
<p>Im quite new to python and having problem figuring out how its actually doing its magic. I do understand that it uses the <code>event.start.day</code> to assign it to a day and month. Is it doing this with recursion?</p>
<p>I'm trying to tune the function so it would support recurring/multi-day events.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>All the lambda does is return the day portion of the event start date; <code>lambda</code> objects are just functions. The real <em>magic</em> is in the <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby()</code> function</a>, which produces groups based on that return value. Each time the value changes from one event to the next, you get a new group.</p>
<p>Depending on how your multiday / recurrence is implemented, it probably is not going to be easy to adapt this directly to your case. You'd have to switch to a loop with a dictionary instead.</p>
<p>Here is an equivalent function using just a loop, which will be easier to adapt:</p>
<pre><code>def group_by_day(self, event):
    result = {}
    for e in event:
        day = event.start.day
        result.setdefault(day, []).append(event)
    return result
</code></pre>
<p>This is not dependent on the order of the events as it'll just group every date by the day regardless of where it appears in the sequence. This should let you add an event to <em>more than one day</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Lambda functions are like regular functions. For example:</p>
<pre><code>f = lambda x:x**2
</code></pre>
<p>Is equivelent to:</p>
<pre><code>def f(x):
    return x**2
</code></pre>
<p>So, in your case, for field(event), return event.start.day</p>
</div>
<div class="post-text" itemprop="text">
<p>There are three separate bits of magic: the lambda, the list comprehension, and the <code>groupby</code> function. </p>
<p>The statement <code>lambda event: event.start.day</code> is equivalent to:</p>
<pre><code>def f(event):
  return event.start.day
</code></pre>
<p>The <code>groupby</code> function presumably takes an <code>event</code> and a <code>field</code> and returns some sort of list of two-element lists (or tuples). </p>
<p>The list comprehension <code>[(day, list(items)) for day , items in groupby(event, field)]</code> is equivalent to:</p>
<pre><code>result = []
for day, items in groupby(event, field):
    result.append( (day, list(items)) )
</code></pre>
<p>And then the <code>dict</code> call takes that list of tuples and turns it into a dict of <code>day:list(items)</code> pairs. </p>
</div>
<span class="comment-copy">All the lambda does is return the day portion of the event start date. The <i>magic</i> is in the <code>groupby()</code> function, which produces groups based on that return value. Each time the value changes from one event to the next, you get a new group.</span>
<span class="comment-copy">Ya I realised that the lambda wasnt that <i>magic</i> after the prev answer. Thanks alot, this is exactly what i needed.</span>
