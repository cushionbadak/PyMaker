<div class="post-text" itemprop="text">
<p>I have two lists, one contains employee salaries and one contains queries. For each query I want to print how many employee salaries are less than that. </p>
<p>Below you can find code I currently use, which exceeds my time limit for large inputs. Therefore, I'm looking for more efficient solutions.</p>
<pre><code>sal = [int(raw_input()) for x in range(num_employees)]
q = [int(raw_input()) for x in range(num_queries)]
for i in q:
    count = 0
    for ep in sal:
        if ep &lt; i:
            count +=1
    print count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't know whether this will be any faster (or slower) than your solution. You can use the <a href="https://docs.python.org/2.7/library/timeit.html#module-timeit" rel="nofollow"><code>timeit</code></a> module to determine with your large inputs.</p>
<pre><code>sal = [int(raw_input()) for x in range(num_employees)]
q = [int(raw_input()) for x in range(num_queries)]
for i in q:
   print sum(1 for s in sal if s &lt; i)
</code></pre>
<p>Depending on data sizes, you could sort the salaries and queries beforehand and then you only need make one pass over the lists:</p>
<pre><code>idx = 0
sal = sorted(sal)
count = 0
for q in sorted(queries):
    while sal[idx] &lt; q:
        count += 1
        idx += 1
    print count
</code></pre>
<p>This second method will be faster for long inputs, but perhaps slower for shorter inputs - you'd have to profile with representative data. If your data is already sorted this method will be very fast.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>sal = [int(raw_input()) for x in range(num_employees)]
q = [int(raw_input()) for x in range(num_queries)]
for i in q:
    count = sum([1 for for ep in sal if ep &lt; i])
    print count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>bisect</code> on a sorted <code>sal</code> list:</p>
<pre><code>import bisect

sal = [int(raw_input()) for x in range(num_employees)]
q = [int(raw_input()) for x in range(num_queries)]
sal.sort()
for i in q:
    print bisect.bisect_left(sal, i)
</code></pre>
<p><code>bisect</code> does a logarithmic search, where the largest element of <code>sal &lt; i</code> is. For large lists, the complexity is <code>O(N * log(N))</code> instead of <code>O(N ** 2)</code> for the other solution with two for-loops. This is considerably faster for large numbers <code>N</code>.</p>
</div>
<span class="comment-copy">Try using numpy.</span>
<span class="comment-copy">You could take a look at SQL-Databases, like <a href="https://docs.python.org/3/library/sqlite3.html" rel="nofollow noreferrer">sqlite</a>.</span>
<span class="comment-copy">If you are using <code>raw_input()</code> to obtain your data in the first place, I would think that takes much longer than the actual double loop. How do you enter the data into your program?</span>
<span class="comment-copy">I get input as integers. First the number of employees then there values.</span>
<span class="comment-copy">How many items and what time limit are we talking about? For questions regarding performance optimization it is generally advisable to use a profiler to identify the actual slow part of the application. Try cProfile and gprof2dot.</span>
