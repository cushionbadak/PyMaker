<div class="post-text" itemprop="text">
<p>Its my understanding that when you implement a global lock in Python, this should reserve stdout for the thread that activates the lock, and therefore prevent other threads from utilizing stdout until the thread releases the lock.</p>
<p>Doesn't this means that in the following code, the loop in thread "a" should complete before the function in thread "b" outputs anything? When I run it, the "7" that thread "c" prints is sometimes interleaved in the output of "a".</p>
<p>I'd expect the output to always be the following:</p>
<pre><code> 5
 5
 5
 5
 5
 6
 7
</code></pre>
<p>But I am getting:</p>
<pre><code> 5
 7
 5
 5
 5
 6
</code></pre>
<p>The code:</p>
<pre><code>import threading, time

thelock = threading.Lock()

def afunc(var):
    with thelock:
        for i in range(5):
            time.sleep(.0002)
            print(var)

def bfunc(var):
    print(var)

a=threading.Thread(target=afunc, args=(5,))
b=threading.Thread(target=bfunc, args=(6,))
c=threading.Thread(target=bfunc, args=(7,))
a.start()
b.start()
c.start()
</code></pre>
<p>This is with Python 3.4.3 in OS X 10.10.3. The same behavior occurs when running the file directly in the OS X Terminal, or within PyCharm 4.5.1.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are not implementing the global lock because there is no such thing. I mean, there is but that is Global Interpreter Lock which is language feature and you are not implementing that.</p>
<p>GIL:
<a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" rel="nofollow">http://en.wikipedia.org/wiki/Global_Interpreter_Lock</a></p>
<p>Now, about the lock which you are implementing:</p>
<p>threading.Lock() -
A factory function that returns a new <strong>primitive</strong> lock object. Once a thread has <strong>acquired</strong> it, subsequent <strong>attempts to acquire</strong> <strong>it block</strong>, until it is released; any thread may release it.</p>
<p>See official docs for threading: <a href="https://docs.python.org/2/library/threading.html" rel="nofollow">https://docs.python.org/2/library/threading.html</a></p>
<p>Generally speaking, when you lock some resource into critical section, this resource will be locked only for threads which must also acquire lock to access the shared resource. In your example, function b does not attempt to acquire lock before writing to stdout. </p>
<p>Besides, i am fairly certain that this won't work as you expect and output will be mixed up anyway, as the stdout doesn't get locked. To get clean output, you could have threads passing messages to some thread-safe shared queue, and then have only one thread write to stdout from that queue.</p>
</div>
<div class="post-text" itemprop="text">
<p>threading.Lock does not influence the use of standard output at all. It only serves to create what called critical sections where only one thread at a time may execute code in all critical sections protected by the same lock instance.</p>
<p>If you need to serialize output you have to implement that yourself, maybe based on locks or some other mechanism.</p>
<p>For example you could have a logging class that buffers the logging of other threads while some locks are held, but that is not trivial because the logging class can't just "check" if a certain lock is in use because the would lead to race conditions. Generally blocking logging isn't such a great idea. But maybe you're thinking about some other use of stdout. Usually if you are trying to generate a specific stdout in a multithreaded program it is likely that you should explicitly use a lock for all output or restrict usage of output to just one thread. For restricting output to one thread maybe <a href="https://docs.python.org/3/library/queue.html" rel="nofollow">queue.Queue</a> can help so multiple threads can produce complete parts that are then printed by one thread a part at a time.</p>
</div>
<span class="comment-copy">Ah thanks! Yes I was not seeing the entire scope of how locks are used. I thought that being declared outside of the function meant it in a way provided some generic lock to global resources. It appears instead that a single lock object provides a baton-passing of sorts across functions or threads.</span>
<span class="comment-copy">Thanks! Yes I'm learning about queues now, but had just whipped this scenario up to test my understanding of locks. I had the idea a bit backwards. It seems proper to see locks as a virtual baton of sorts, where for the same baton, a thread or function will only run if it is holding the baton. Before being handed the baton, it will be blocked while another thread holds the baton and does its stuff. In my code above, bfunc did not have a baton, and would only be blocked if I used "with: thelock" before the print statement, so when afunc was done printing, bfunc could start printing.</span>
<span class="comment-copy">Yes, that's a way to see it. The program can only pass the <code>with thelock:</code> or <code>thelock.acquire()</code> line if it can obtain the one baton that is from <code>thelock</code>. At the end of the with block or with an explicit <code>thelock.release()</code> the baton is returned so this or another thread can use it again later to enter another protected block. For each lock there is only one baton. And if you already carry the baton you still can't pass because you need to <i>obtain</i> it when entering the protected code. You need to use an RLock if you need the thread to be able to "reuse" the baton.</span>
