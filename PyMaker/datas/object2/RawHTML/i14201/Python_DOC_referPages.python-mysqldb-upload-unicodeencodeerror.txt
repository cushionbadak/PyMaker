<div class="post-text" itemprop="text">
<p>I have a problem where I can upload CSV files to MySQL, but then something happens and I get an encoding error. Can some one please review my code and tell what is wrong? I'm new to enconding.</p>
<p>The following snippet is how I write the CSV files that will be uploaded, the data is extracted from an MDB file using the MDN tools (mdb-export):</p>
<pre><code>    tableIndex  = 1
    for tName in tableNames:
        fileName = os.path.join(csvPath, os.path.basename(mdb).split('.')[0] + '_' + tName + '.csv')

        try:
            p = subprocess.Popen(["mdb-export", "-H", mdb, tName], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            tableContent, error = p.communicate()

            if(p.returncode != 0):
                _logger.error('[%3d] Export Subprocess %d %s' % (tID, p.returncode, tableContent))
                SendMdbError(tID, mdb, _logger, 'ALERT: Export Subprocess')
                return(['', False])
            if(error):
                _logger.error('[%3d] Export Communicate %d %s' % (tID, p.returncode, error.strip()))
                SendMdbError(tID, mdb, _logger, 'ALERT: Export Communicate')
                return(['', False])

        except Exception as ex:
            _logger.exception('[%3d] Export Error' % tID)
            SendMdbError(tID, mdb, _logger, 'ALERT: Export Exception')
            return(['', False])
        except:
            _logger.exception('[%3d] Export Unexpected' % tID)
            SendMdbError(tID, mdb, _logger, 'ALERT: Export Unexpected')
            return(['', False])

        # If no data, no need for corresponding SQL
        if(len(tableContent) == 0):
            emptyTables.append(tName)

        # If data exists, dump data
        else:
            # Add the 'DriveTest' to the data to upload
            tableContent = tableContent.split('\n')

            tableContent = [dt + ',' + line for line in tableContent if(line)]
            tableContent = '\n'.join(tableContent)

            try:
                with open(fileName, 'wb') as f:
                    f.write(tableContent)

                    if(_VERBOSITY):
                        _logger.debug('[%3d] %3d - Write CSV SIZE[%8d] FILE: %s' %(tID, tableIndex, len(tableContent.split('\n')), fileName))
                        tableIndex += 1

            except IOError as err:
                _logger.exception('[%3d] Write IOError: %s' % (tID, str(err)))
                SendMdbError(tID, mdb, _logger, 'ALERT: Write IOError')
                return(['', False])
            except Exception as ex:
                _logger.exception('[%3d] Write Exception' % tID)
                SendMdbError(tID, mdb, _logger, 'ALERT: Write Exception')
                return(['', False])
            except:
                _logger.exception('[%3d] Write Unexpected: %s' % tID)
                SendMdbError(tID, mdb, _logger, 'ALERT: Write Unexpected')
                return(['', False])
</code></pre>
<p>The following is where I upload the CSV file, and here is where I get the error:</p>
<pre><code>    # Upload the data
    tableIndex = 0
    for table in tableDDL:
        try:

            with warnings.catch_warnings(record=True) as war:

                _logger.info('[%3d] %3d Going up... %s' %(tID, tableIndex+1, os.path.basename(mdb).split('.')[0] + '_' + table))

                _sqlLock[tableIndex].acquire()
                #self.cursor.execute(tableDDL[table])
                self.cursor.execute(tableULD[table])
                self.conn.commit()
                _sqlLock[tableIndex].release()

                if(war):
                    #if(_VERBOSITY): print('[%3d] %3d WARNINGS[%3d] %s' % (tID, tableIndex+1, len(war), os.path.basename(mdb).split('.')[0] + '_' + table))
                    _logger.warning('[%3d] %3d WARNINGS[%3d] %s' % (tID, tableIndex+1, len(war), os.path.basename(mdb).split('.')[0] + '_' + table))
                    for w in war:
                        _logger.warning('[%3d] %s' % (tID, w.message))

                #if(_VERBOSITY): print('[%3d] %3d Uploaded %s' % (tID, tableIndex+1, os.path.basename(mdb).split('.')[0] + '_' + table))
                _logger.info('[%3d] %3d Uploaded %s' % (tID, tableIndex+1, os.path.basename(mdb).split('.')[0] + '_' + table))
                tableIndex += 1

                # Remove the uploaded CSV file
                try:
                    os.remove(csvFiles[table]+'.csv')
                    _logger.info('[%3d] Removed CVS file: %s' % (tID, csvFiles[table]+'.csv'))
                except OSError:
                    pass

        except (MySQLdb.InternalError, MySQLdb.NotSupportedError) as err:
            _logger.error('[%3d] %3d Internal: %s %s' % (tID, tableIndex+1, err, sys.exc_info()[0]))
            self.conn.rollback()
            self.Disconnect(tID, _logger, _VERBOSITY, _DEBUG)
            return(False)
        except MySQLdb.OperationalError as err:
            _logger.error('[%3d] %3d OperationalError: %s' % (tID, tableIndex+1, sys.exc_info()[0]))
            _logger.error(err)
            self.conn.rollback()
            self.Disconnect(tID, _logger, _VERBOSITY, _DEBUG)
            return(False)
        except MySQLdb.ProgrammingError as err:
            _logger.error('[%3d] %3d ProgrammingError: %s' % (tID, tableIndex+1, sys.exc_info()[0]))
            _logger.error(err)
            self.conn.rollback()
            self.Disconnect(tID, _logger, _VERBOSITY, _DEBUG)
            return(False)
        except MySQLdb.Error as err:
            _logger.error('[%3d] %3d QUERY: %s %s' % (tID, tableIndex+1, err, sys.exc_info()[0]))
            self.conn.rollback()
            self.Disconnect(tID, _logger, _VERBOSITY, _DEBUG)
            return(False)
        except Exception as err:
            _logger.error('[%3d] %3d Exception: %s %s' % (tID, tableIndex+1, err, sys.exc_info()[0]))
            #self.conn.rollback()
            #self.Disconnect(tID, _logger, _VERBOSITY, _DEBUG)
            #return(False)
            pass
        except:
            _logger.error('[%3d] %3d Other: %s' % (tID, tableIndex+1, sys.exc_info()[0]))
            self.conn.rollback()
            self.Disconnect(tID, _logger, _VERBOSITY, _DEBUG)
            return(False)
</code></pre>
<p>The error I get is the following:</p>
<pre><code>2015-06-13 19:42:21,743 __main__ -    ERROR - [  1]   1 Exception: 'ascii' codec can't encode character u'\xb4' in position 40: ordinal not in range(128) &lt;type 'exceptions.UnicodeEncodeError'&gt;
2015-06-13 19:42:30,962 __main__ -    ERROR - [  1]   1 Exception: 'ascii' codec can't encode character u'\xb4' in position 27: ordinal not in range(128) &lt;type 'exceptions.UnicodeEncodeError'&gt;
</code></pre>
<p>I noticed that the given data gets uploaded, but not sure if all rows are uploaded.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Try before putting csv into DB <code>s.decode('UTF-8')</code> and after getting it out of the DB <code>s.encode('UTF-8')</code></p>
<p>I did it for SQLite and it worked OK.</p>
</div>
<div class="post-text" itemprop="text">
<p>Getting this to work should not be too difficult, but you have to understand what you're doing. Don't just try all possible combinations of <code>s.encode("UTF-8").decode("UTF-8")</code> and stuff like that.</p>
<p>First, understand the difference between a <code>string</code> and <code>bytes</code>. See <a href="https://docs.python.org/3/howto/unicode.html" rel="nofollow">https://docs.python.org/3/howto/unicode.html</a>. You can encode a string to bytes: <code>bytes = text.encode("UTF-8")</code>, and you can decode bytes to a string: <code>text = bytes.decode("UTF-8")</code></p>
<p>Second since a CSV file is a text file, you should open the CSV file in text mode. <code>open(fileName, 'w', encoding="utf-8")</code>. There's no need to encode or decode text in your code when writing the file.</p>
<p>Third, it is perfectly OK to write Unicode text to a TEXT field. No need for BINARYs or BLOBs. But make sure your database has a collation setting that can deal with it, usually that would be one of the utf-8 collations. Then to put Unicode in your database, use python strings and don't decode them to bytes.</p>
</div>
<div class="post-text" itemprop="text">
<p>The error message implies that the column definition in MySQL is <code>CHARACTER SET ascii</code>; is that correct?</p>
<p><code>B4</code> sounds like the latin1 (not utf8) encoding for <code>´</code>, which could be coming from a Microsoft Word document in a context such as <code>it´s</code>.</p>
<p>So, even changing the column to be <code>CHARACTER SET utf8</code> won't fix the problem.</p>
<p><code>BINARY</code> and <code>BLOB</code> are essentially the same type of field -- any byte is allowed.  <code>VARCHAR</code> and <code>TEXT</code> validate the bytes during <code>INSERT</code> to make sure they match the <code>CHARACTER SET</code>.</p>
</div>
<span class="comment-copy">A couple of questions: (1) What's in the <code>tableULD</code> variable, where is it coming from? (2) Can you get the stack trace from that exception?</span>
<span class="comment-copy">That being said, since you <i>appear</i> to be using python 3, try opening the file with <code>open(fileName, 'w', encoding="utf-8")</code> rather than <code>open(fileName, 'wb')</code>. You're after all writing text, not binary data.</span>
<span class="comment-copy">Ivan: Did as you recommended: I encoded after getting it from MDB ´tableContent = tableContent.encode('UTF-8').split('\n')´. Then decoded before uploading ´f.write(tableContent.decode('UTF-8'))´ Got error: ´tableContent = tableContent.encode('UTF-8').split('\n') UnicodeDecodeError: 'ascii' codec can't decode byte 0xaf in position 237: ordinal not in range(128)´</span>
<span class="comment-copy">OK. I did decoding  of HTML forms text input  before putting into the DB. But if you have just a file try s.encode("UTF-8") before. If that doesn't work try s.encode("UTF-8").decode.("UTF-8"). And s.encode('UTF-8') after.</span>
<span class="comment-copy">I added code to pin point where the data is causing the problem. It turns out that, non-ascii data is being uploaded to a BLOB field in MySQL, this is raising the exception. What is the best practice for dealing with non-ascii data that needs to be stored? Should BLOB be changed yo BINARY?</span>
<span class="comment-copy">Well, it's not the data's fault but rather how Python understands it. As you see MySQL accepts it no matter in what  encoding/decoding it is but Python is not capable to digest it later on. I recall now that I haven't tried  encoding right after decoding. Decoded data is not very convenient to operate with.</span>
<span class="comment-copy">These are a couple of examples of the offending non-ascii data: "^@^@^@^[ªmK&lt;96&gt;»""&lt;8a&gt;±^C^P^@ÿ®&lt;80&gt;^F&lt;9e&gt;§^^ÊÃ¬^R^A^P" and "^@^@T¯Qé{Ö"</span>
