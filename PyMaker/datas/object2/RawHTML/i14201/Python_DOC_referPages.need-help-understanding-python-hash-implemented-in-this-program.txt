<div class="post-text" itemprop="text">
<pre><code>t1 = 'This is an example data for testing minhashing'
t2 = 'This is an example test data for minhashing'
t3 = 'This is not related at all'
t4 = t1 
t5 = t3

# texts = [t1,t2,t3,t4,t5]

texts = [t1,t2,t3,t4,t5]

# Define Shingling function
def shingle(s, l):
    #Generate k-tuple shingles of a string
    l = min(len(s), l)
    return([s[i:i+l] for i in range(len(s) - l + 1)])

# Declare punctuation
exclude = set(string.punctuation)


# Generate hash functions
def hash_functions():
    def hash_factory(ni):
        return(lambda x: hash("salt" + str(ni) + str(x) + "salt"))
    return [hash_factory(i) for i in range(2)]

# Create list of shingle lists and Normalize text
shingle_list = [shingle(''.join(ch for ch in d.lower().replace(' ','') if ch not in exclude),4) for d in texts]

for x in shingle_list:
    print x

# Generate LSH matrix
LIST = [[min(fn(t) for t in tuples) for i, fn in enumerate(hash_functions())] for tuples in shingle_list]

for x in LIST:
    print x
</code></pre>
<p>Can anyone explain me what the hash function mentioned in the above snippet, it works fine but i donot understand ("salt" + str(ni) + str(x) + "salt). </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>it works fine but i donot understand ("salt" + str(ni) + str(x) + "salt).</p>
</blockquote>
<p>This part is trivial.</p>
<p>First, the <a href="https://docs.python.org/3/library/functions.html#func-str" rel="nofollow"><code>str</code></a> functions takes any object and converts it to its string representation. For example, <code>ni</code> is going to be a number <code>0</code> or <code>1</code>, which <code>str</code> will convert to the string <code>"0"</code> or <code>"1"</code>.</p>
<p>Next, we're just concatenating four strings together: <code>"a" + "bc" + "d" + "ef"</code> gives you <code>"abcdef"</code>.</p>
<hr/>
<p>I'm guessing that you're <em>really</em> asking is <em>why</em> you would do this.</p>
<p>When you're writing a hash function for some combination of values in terms of a simpler hash function, you want to be careful to make sure you include some kind of "salting", so your special combination of values doesn't accidentally hash to the same thing as a simple combination of the same values.</p>
<p>For an even simpler example, consider this class:</p>
<pre><code>class Point(object):
    def __init__(self, x, y):
        self.x, self.y = x, y
    def __hash__(self):
        return hash((self.x, self.y))
</code></pre>
<p>But this means that <code>hash((1.0, 2.0)) == hash(Point(1.0, 2.0))</code>. Usually, you don't want that; a Point isn't the same thing as a tuple, it's a type with its own (very thin, but not nonexistent) semantics. So, you stick some extra value, called a "salt", into the hash. For example:</p>
<pre><code>class Point(object):
    def __init__(self, x, y):
        self.x, self.y = x, y
    def __hash__(self):
        return hash((type(self), self.x, self.y))
</code></pre>
<p>And now, <code>hash((1.0, 2.0)) != hash(Point(1.0, 2.0))</code>.</p>
<p>Notice that this is distinct from, but not unrelated to, other important reasons for salting hashes (e.g., in cryptographic hashes, you can negotiate some shared random nonce to use as a salt, to make sure that nobody can reproduce the same hash results unless they have the negotiated salt, and you can use key exchange protocols to make sure they don't have it).</p>
<hr/>
<p>However, it's worth mentioning that this is a very silly hash function.</p>
<p>First, it's simpler, more robust, and more efficient to hash a tuple of values than to has a concatenated string. Most likely this code was written for some other language that didn't have a generic <code>hash</code> function, only a <code>hash_string</code> function.</p>
<p>Second, the only reason you'd want to both prepend and append a salt, instead of just one or the other, is if you didn't trust the <code>hash</code> function you're relying on to treat the parts of its values uniformly. And really, if you can't trust that, putting the salt on both ends doesn't help that much—and may actually hurt. (For example, if your <code>hash_string</code> undervalues everything after the first few characters, then prepending the salt does nicely avoid collision with unsalted values while appending it wouldn't—but it also means you're pushing 4 more actual characters out of the over-valued parts of the input, so your salted hashes are going to be even more badly distributed than normal hashes. If you really can't trust a hash function, you can't build a more complex hash function on top of it; you have to build your own.</p>
</div>
<div class="post-text" itemprop="text">
<p>The part you highlight</p>
<pre><code>def hash_functions():
    def hash_factory(ni):
        return(lambda x: hash("salt" + str(ni) + str(x) + "salt"))
    return [hash_factory(i) for i in range(2)]
</code></pre>
<p>Is a function factory. Instead of <code>hash_factory</code> returning a value, it returns a function whose, erm, <em>function</em> depends on the value you pass it. Imagine something like:</p>
<pre><code>def greeting_factory(greeting):
    return lambda name: greeting + name
</code></pre>
<p>You could use this greeting to create other functions, for example:</p>
<pre><code>say_hola = greeting_factory("Hola, ")
say_bonjour = greeting_factory("Bonjour, ")
say_hello = greeting_factory("Hello, ")
say_howdy = greeting_factory("Howdy, ")
</code></pre>
<p>Then use each of THOSE functions, which all expect one argument (the name of the person to say hello to)</p>
<pre><code>&gt;&gt;&gt; say_hola("Juan")
Hola, Juan
&gt;&gt;&gt; say_bonjour("Jacques")
Bonjour, Jacques
&gt;&gt;&gt; say_hello("James")
Hello, James
&gt;&gt;&gt; say_howdy("pardner")
Howdy, pardner
</code></pre>
<p>In this case, it's using a function factory to build a couple different hashing functions, then returning the list. This is identical to:</p>
<pre><code>def ways_to_say_hello():
    def greeting_factory(greeting):
        return lambda name: greeting + name
    return [greeting_factory(greet) for greet in ['Hola, ', 'Bonjour, ',
                                                  'Hello, ', 'Howdy, ']]

&gt;&gt;&gt; for hello_func in ways_to_say_hello():
...     hello_func("Adam Smith")
Hola, Adam Smith
Bonjour, Adam Smith
Hello, Adam Smith
Howdy, Adam Smith
</code></pre>
</div>
<span class="comment-copy">Is it really the string concatenation (or <code>str</code> calls) that you don't understand? Or do you not understand <i>why</i> they're doing that, or how the <code>lambda</code> is used to wrap it up as a function, or something else other than what you asked?</span>
<span class="comment-copy">I do not understand why the author is concatenating "salt".</span>
<span class="comment-copy">Thank you for taking time to explain in detail.</span>
<span class="comment-copy">Thank you for taking the time to explain. I am not much familiar with hash, I dont understand why the author is concatenating "salt". I understand str(ni) would change the hash value, but why is "salt" needed?</span>
<span class="comment-copy">@Siddarth it's not. This is a terrible example of a hashing function. It also does silly things like <code>for i, fn in enumerate(hash_functions())</code> when <code>i</code> is never used. For reasons why salting a hash is VITALLY important for more critical hashing functions (bcrypt, SHA-512, etc), you should review <a href="http://security.stackexchange.com/questions/51959/why-are-salted-hashes-more-secure" title="why are salted hashes more secure">security.stackexchange.com/questions/51959/…</a> which would be off-topic for stack exchange.</span>
<span class="comment-copy">@Siddarth Nota Bene: if you're hashing something important, <i>DON'T ROLL YOUR OWN HASH FUNCTION</i>. If you're not hashing anything important, use python's built-in <code>hash</code> function (i.e. <code>hash(t1)</code>). There's never an actual reason to write your own hashing function unless you're not happy with the industry standards and have the experience, education, and have done the necessary research to improve on it.</span>
<span class="comment-copy">Thank you, i will look into it. I now have a basic understanding of why he appending "salt"</span>
