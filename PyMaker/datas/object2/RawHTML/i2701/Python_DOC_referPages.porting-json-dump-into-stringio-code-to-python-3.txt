<div class="post-text" itemprop="text">
<p>I'm porting a Python 2 application to Python 3.  Currently running Python2.7 but, updating code to pass <code>pylint --py3k</code> tests, I have run into a problem with this:</p>
<pre><code>def json_resource_file(baseurl, jsondata, resource_info):
    """
    Return a file object that reads out a JSON version of the supplied entity values data. 
    """
    response_file = StringIO()
    json.dump(jsondata, response_file, indent=2, separators=(',', ': '), sort_keys=True)
    response_file.seek(0)
    return response_file
</code></pre>
<p>It works fine with:</p>
<pre><code>from StringIO import StringIO
</code></pre>
<p>but <code>StringIO.StringIO</code> doesn't exist in Python3 (according to pylint), so using:</p>
<pre><code>from io import StringIO
</code></pre>
<p>I get an error:  "TypeError: unicode argument expected, got 'str'" (This is running under Python 2 - I'm still preparing the ground, so to speak, and am not planning to use Python 3 until I have done as much preparation and testing as I can under Python 2.)</p>
<p>By way of some experimentation, I tried using <code>BytesIO</code> from <code>io</code>, but that gives a different error "TypeError: 'unicode' does not have the buffer interface".</p>
<p>Clearly, the Python2 version of json.dump is writing <code>str</code> values to the supplied file object.  I <em>think</em> the Python3 version of json.dump also writes <code>str</code> (i.e. Unicode) values.</p>
<p>So my question is:  is there an easy way to dump JSON to a StringIO memory buffer that works with Python 2 and 3?</p>
<h2>Notes</h2>
<ol>
<li><p>I realize I could use <code>json.dumps</code> and coerce the result to whatever type <code>StringIO</code> expects, but that all seems rather heavy-handed.</p></li>
<li><p>I'm also using the following future imports as part of my porting process:</p>
<pre><code>from __future__ import (unicode_literals, absolute_import, division, print_function)
</code></pre></li>
<li><p>Currently, a solution I'm thinking of is to test the python version and import a different version of <code>StringIO</code> accordingly, but that would violate the <a href="https://docs.python.org/3/howto/pyporting.html#use-feature-detection-instead-of-version-detection" rel="nofollow noreferrer">"Use feature detection instead of version detection"</a> principle.</p></li>
<li><p>In most of my code, using <code>from io import StringIO</code> appears to work fine for situations that I use <code>StringIO</code>.  It's the specific case of using a <code>StringIO</code> with <code>json.dump</code> that has caused me a few problems. </p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If your problem is the import statement, just wrap it in a try statement:</p>
<pre><code>try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO
</code></pre>
<p>The rest of your code should work as is, at least the code provided in your question works just fine for me.</p>
</div>
<span class="comment-copy">The errors occurr on python2 or python3 or on both? If the issue is with python2 then the fix is simply <code>try: from StringIO import StringIO except ImportError: from io import StringIO</code> or use <code>six.StringIO</code></span>
<span class="comment-copy"><code>"TypeError: unicode argument expected, got 'str'"</code> was raised by Python 2, not Python 3.</span>
<span class="comment-copy">Sorry, I was't clear - the errors are all under Python 2.  I haven't started actually using Python 3 yet.</span>
<span class="comment-copy">@Giacomo Alzetta - Thanks!  I wondered about the import/exception approach, and maybe I'll end up doing that.  But I have a gripe that it treats the (eventually) normal case of using Python3 as an exception, which feels not-so-future-proof to me.  (E.g. suppose a new module "StringIO" comes available in the future?).  And I can't construct it the other way round because Python2 has io.StringIO.  I think using <code>six.StringIO</code> is a better option, but so far I've been able to avoid this kind of external library dependency.</span>
<span class="comment-copy">Python2 will be dead soon. Port it over and fuggedaboutit.</span>
