<div class="post-text" itemprop="text">
<pre><code>lst = iter([1, 2, 3])
print([*lst])  # &gt;&gt;&gt; [1, 2, 3]
print([*lst])  # &gt;&gt;&gt; []
</code></pre>
<p>Is this expected behaviour for unpacking? I would've assumed the original data wouldn't be modified on unpacking and a copy is simply made?</p>
<p>EDIT:</p>
<p>If so, what is the reasoning behind it?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">glossary entry for iterators</a> (my emphasis):</p>
<blockquote>
<p>A container object (such as a list) produces a fresh new iterator each time you pass it to the iter() function or use it in a for loop. <em>Attempting this with an iterator will just return the same exhausted iterator object used in the previous iteration pass, <strong>making it appear like an empty container.</strong></em></p></blockquote></div>
<div class="post-text" itemprop="text">
<p>Yes, this is expected behavior for unpacking an <em>iterator</em>:</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3]
&gt;&gt;&gt; iter(lst)
&lt;list_iterator at 0x7fffe8b84ef0&gt;
</code></pre>
<p>The iterator can only be iterated once and then it is exhausted.</p>
<pre><code>&gt;&gt;&gt; i = iter(lst)
&gt;&gt;&gt; next(i)
1
&gt;&gt;&gt; next(i)
2
&gt;&gt;&gt; next(i)
3
&gt;&gt;&gt; next(i)
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
&lt;ipython-input-11-a883b34d6d8a&gt; in &lt;module&gt;()
----&gt; 1 next(i)

StopIteration: 
</code></pre>
<p>The iterator protocol specifies that an exhausted iterator must continue raising <code>StopIteration</code> exceptions on subsequent calls of its <code>__next__</code> method.  Therefore, iterating it once again is valid (not an error), but the iterator should yield no new items:</p>
<pre><code>&gt;&gt;&gt; list(i)
[]
</code></pre>
<p>Nothing prevents you to define an iterator which disobeys this rule, but <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">such iterators are deemed "broken"</a>.</p>
<p>The list <em>iterable</em> could be unpacked multiple times, however.</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3]
&gt;&gt;&gt; print(*lst)
1 2 3
&gt;&gt;&gt; print(*lst)
1 2 3
</code></pre>
<p>And you could create as many independent iterators, from the same source list, as you want:</p>
<pre><code>&gt;&gt;&gt; i1 = iter(lst)
&gt;&gt;&gt; i2 = iter(lst)
&gt;&gt;&gt; next(i2)
1
&gt;&gt;&gt; next(i2)
2
&gt;&gt;&gt; next(i1)  # note: it's another 1
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are confusing the terminology of "iterator" and "iterable".</p>
<p>An iterator (typically) can't be iterated over again. An <em>iterable</em> on the other hand (like a list) can:</p>
<pre><code>lst = [1, 2, 3]
print([*lst])  # &gt;&gt;&gt; [1, 2, 3]
print([*lst])  # &gt;&gt;&gt; [1, 2, 3]
</code></pre>
</div>
<span class="comment-copy">Why would you assume a copy is made? Would that be desirable behavior?</span>
<span class="comment-copy">Here is an answer explaing it: <a href="https://stackoverflow.com/a/25336738/8472976">stackoverflow.com/a/25336738/8472976</a> It is not a duplicate, because the question are quite different.</span>
