<div class="post-text" itemprop="text">
<p>I have a long-running Python server and would like to be able to upgrade a service without restarting the server. What's the best way do do this?</p>
<pre><code>if foo.py has changed:
    unimport foo  &lt;-- How do I do this?
    import foo
    myfoo = foo.Foo()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can reload a module when it has already been imported by using the <a href="https://docs.python.org/2.7/library/functions.html#reload" rel="noreferrer"><code>reload</code></a> builtin function:</p>
<pre><code>from importlib import reload  # Python 3.4+ only.
import foo

while True:
    # Do some things.
    if is_changed(foo):
        foo = reload(foo)
</code></pre>
<p>In Python 3, <code>reload</code> was moved to the <a href="https://docs.python.org/3.2/library/imp.html" rel="noreferrer"><code>imp</code></a> module. In 3.4, <code>imp</code> was deprecated in favor of <a href="https://docs.python.org/3.4/library/importlib.html" rel="noreferrer"><code>importlib</code></a>, and <a href="https://docs.python.org/3.4/library/importlib.html#importlib.reload" rel="noreferrer"><code>reload</code></a> was added to the latter. When targeting 3 or later, either reference the appropriate module when calling <code>reload</code> or import it.</p>
<p>I think that this is what you want. Web servers like Django's development server use this so that you can see the effects of your code changes without restarting the server process itself.</p>
<p>To quote from the docs:</p>
<blockquote>
<p>Python modules’ code is recompiled and
  the module-level code reexecuted,
  defining a new set of objects which
  are bound to names in the module’s
  dictionary. The init function of
  extension modules is not called a
  second time. As with all other objects
  in Python the old objects are only
  reclaimed after their reference counts
  drop to zero. The names in the module
  namespace are updated to point to any
  new or changed objects. Other
  references to the old objects (such as
  names external to the module) are not
  rebound to refer to the new objects
  and must be updated in each namespace
  where they occur if that is desired.</p>
</blockquote>
<p>As you noted in your question, you'll have to reconstruct <code>Foo</code> objects if the <code>Foo</code> class resides in the <code>foo</code> module.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.0–3.3 you would use: <a href="http://docs.python.org/3.3/library/imp.html?highlight=imp#imp.reload" rel="noreferrer"><code>imp.reload(module)</code></a></p>
<p>The <a href="http://docs.python.org/3.3/glossary.html#term-bdfl" rel="noreferrer">BDFL</a> has <a href="http://mail.python.org/pipermail/edu-sig/2008-February/008421.html" rel="noreferrer">answered</a> this question.</p>
<p>However, <a href="https://docs.python.org/dev/library/imp.html" rel="noreferrer"><code>imp</code> was deprecated in 3.4, in favour of <code>importlib</code></a> (thanks <a href="https://stackoverflow.com/users/2068635/stefan">@Stefan!</a>).</p>
<p>I <em>think</em>, therefore, you’d now use <a href="https://docs.python.org/dev/library/importlib.html#importlib.reload" rel="noreferrer"><code>importlib.reload(module)</code></a>, although I’m not sure.</p>
</div>
<div class="post-text" itemprop="text">
<p>It can be especially difficult to delete a module if it is not pure Python.</p>
<p>Here is some information from: <a href="http://web.archive.org/web/20080926094551/http://mail.python.org/pipermail/python-list/2003-December/241654.html" rel="noreferrer">How do I really delete an imported module?</a></p>
<blockquote>
<p>You can use sys.getrefcount() to find out the actual number of
  references.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; import sys, empty, os
&gt;&gt;&gt; sys.getrefcount(sys)
9
&gt;&gt;&gt; sys.getrefcount(os)
6
&gt;&gt;&gt; sys.getrefcount(empty)
3
</code></pre>
<blockquote>
<p>Numbers greater than 3 indicate that
  it will be hard to get rid of the
  module. The homegrown "empty"
  (containing nothing) module should be
  garbage collected after</p>
</blockquote>
<pre><code>&gt;&gt;&gt; del sys.modules["empty"]
&gt;&gt;&gt; del empty
</code></pre>
<blockquote>
<p>as the third reference is an artifact
  of the getrefcount() function.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><code>reload(module)</code>, but only if it's completely stand-alone. If anything else has a reference to the module (or any object belonging to the module), then you'll get subtle and curious errors caused by the old code hanging around longer than you expected, and things like <code>isinstance</code> not working across different versions of the same code.</p>
<p>If you have one-way dependencies, you must also reload all modules that depend on the the reloaded module to get rid of all the references to the old code. And then reload modules that depend on the reloaded modules, recursively.</p>
<p>If you have circular dependencies, which is very common for example when you are dealing with reloading a package, you must unload all the modules in the group in one go. You can't do this with <code>reload()</code> because it will re-import each module before its dependencies have been refreshed, allowing old references to creep into new modules.</p>
<p>The only way to do it in this case is to hack <code>sys.modules</code>, which is kind of unsupported. You'd have to go through and delete each <code>sys.modules</code> entry you wanted to be reloaded on next import, and also delete entries whose values are <code>None</code> to deal with an implementation issue to do with caching failed relative imports. It's not terribly nice but as long as you have a fully self-contained set of dependencies that doesn't leave references outside its codebase, it's workable.</p>
<p>It's probably best to restart the server. :-)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>if 'myModule' in sys.modules:  
    del sys.modules["myModule"]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For Python 2 use built-in function <a href="https://docs.python.org/2/library/functions.html#reload" rel="noreferrer">reload()</a>:</p>
<pre><code>reload(module)
</code></pre>
<p>For Python 2 and 3.2–3.3 use <a href="https://docs.python.org/3/library/imp.html#imp.reload" rel="noreferrer">reload from module imp</a>:</p>
<pre><code>import imp
imp.reload(module)
</code></pre>
<p>But <code>imp</code> <a href="https://docs.python.org/3/library/imp.html" rel="noreferrer">is  deprecated</a> since version 3.4 <a href="https://docs.python.org/3/library/importlib.html#importlib.reload" rel="noreferrer">in favor of importlib</a>, so use:</p>
<pre><code>import importlib
importlib.reload(module)
</code></pre>
<p>or</p>
<pre><code>from importlib import reload
reload(module)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following code allows you Python 2/3 compatibility:</p>
<pre><code>try:
    reload
except NameError:
    # Python 3
    from imp import reload
</code></pre>
<p>The you can use it as <code>reload()</code> in both versions which makes things simpler.</p>
</div>
<div class="post-text" itemprop="text">
<p>The accepted answer doesn't handle the from X import Y case. This code handles it and the standard import case as well:</p>
<pre><code>def importOrReload(module_name, *names):
    import sys

    if module_name in sys.modules:
        reload(sys.modules[module_name])
    else:
        __import__(module_name, fromlist=names)

    for name in names:
        globals()[name] = getattr(sys.modules[module_name], name)

# use instead of: from dfly_parser import parseMessages
importOrReload("dfly_parser", "parseMessages")
</code></pre>
<p>In the reloading case, we reassign the top level names to the values stored in the newly reloaded module, which updates them.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is the modern way of reloading a module:</p>
<pre><code>from importlib import reload
</code></pre>
<p>Just type <code>reload(MODULE_NAME)</code>, replacing <code>MODULE_NAME</code> with the name of the module you want to reload.</p>
<p>For example, <code>reload(math)</code> will reload the math function.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are <em>not</em> in a server, but <em>developing</em> and need to frequently reload a module, here's a nice tip.</p>
<p>First, make sure you are using the excellent <a href="https://ipython.org/" rel="noreferrer">IPython shell</a>, from the Jupyter Notebook project. After installing Jupyter, you can start it with <code>ipython</code>, or <code>jupyter console</code>, or even better, <code>jupyter qtconsole</code>, which will give you a nice colorized console with code completion in any OS.</p>
<p>Now in your shell, type:</p>
<pre><code>%load_ext autoreload
%autoreload 2
</code></pre>
<p>Now, <strong>every time</strong> you run your script, your modules will be reloaded. </p>
<p>Beyond the <code>2</code>, there are other <a href="https://ipython.org/ipython-doc/3/config/extensions/autoreload.html" rel="noreferrer">options of the autoreload magic</a>:</p>
<pre><code>%autoreload
Reload all modules (except those excluded by %aimport) automatically now.

%autoreload 0
Disable automatic reloading.

%autoreload 1
Reload all modules imported with %aimport every time before executing the Python code typed.

%autoreload 2
Reload all modules (except those excluded by %aimport) every time before
executing the Python code typed.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For those like me who want to unload all modules (when running in the Python interpreter under <a href="http://en.wikipedia.org/wiki/Emacs" rel="noreferrer">Emacs</a>):</p>
<pre><code>   for mod in sys.modules.values():
      reload(mod)
</code></pre>
<p>More information is in <em><a href="http://pyunit.sourceforge.net/notes/reloading.html" rel="noreferrer">Reloading Python modules</a></em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Enthought Traits has a module that works fairly well for this. <a href="https://traits.readthedocs.org/en/4.3.0/_modules/traits/util/refresh.html" rel="noreferrer">https://traits.readthedocs.org/en/4.3.0/_modules/traits/util/refresh.html</a></p>
<p>It will reload any module that has been changed, and update other modules and instanced objects that are using it. It does not work most of the time with <code>__very_private__</code> methods, and can choke on class inheritance, but it saves me crazy amounts of time from having to restart the host application when writing PyQt guis, or stuff that runs inside programs such as Maya or Nuke. It doesn't work maybe 20-30 % of the time, but it's still incredibly helpful.</p>
<p>Enthought's package doesn't reload files the moment they change - you have to call it explicitely - but that shouldn't be all that hard to implement if you really need it</p>
</div>
<div class="post-text" itemprop="text">
<p>Those who are using python 3 and reload from importlib.</p>
<p>If you have problems like it seems that module doesn't reload... That is because it needs some time to recompile pyc (up to 60 sec).I writing this hint just that you know if you have experienced this kind of problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>2018-02-01</p>
<ol>
<li>module <code>foo</code> must be imported successfully in advance.  </li>
<li><code>from importlib import reload</code>, <code>reload(foo)</code> </li>
</ol>
<p><a href="https://docs.python.org/3/library/importlib.html#importlib.reload" rel="nofollow noreferrer">31.5. importlib — The implementation of import — Python 3.6.4 documentation</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Other option. See that Python default <code>importlib.reload</code> will just reimport the library passed as an argument. It <strong>won't</strong> reload the libraries that your lib import. If you changed a lot of files and have a somewhat complex package to import, you must do a <strong>deep reload</strong>. </p>
<p>If you have <a href="https://ipython.org/" rel="nofollow noreferrer">IPython</a> or <a href="https://jupyter.org/" rel="nofollow noreferrer">Jupyter</a> installed, you can use a function to deep reload all libs:</p>
<pre><code>from IPython.lib.deepreload import reload as dreload
dreload(foo)
</code></pre>
<p>If you don't have Jupyter, install it with this command in your shell:</p>
<pre><code>pip3 install jupyter
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>for me for case of Abaqus it is the way it works.
Imagine your file is Class_VerticesEdges.py</p>
<pre><code>sys.path.append('D:\...\My Pythons')
if 'Class_VerticesEdges' in sys.modules:  
    del sys.modules['Class_VerticesEdges']
    print 'old module Class_VerticesEdges deleted'
from Class_VerticesEdges import *
reload(sys.modules['Class_VerticesEdges'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way could be to import the module in a function. This way when the function completes the module gets garbage collected. </p>
</div>
<div class="post-text" itemprop="text">
<p>I got a lot of trouble trying to reload something inside Sublime Text, but finally I could wrote this utility to reload modules on Sublime Text based on the code <code>sublime_plugin.py</code> uses to reload modules.</p>
<p>This below accepts you to reload modules from paths with spaces on their names, then later after reloading you can just import as you usually do.</p>
<pre><code>def reload_module(full_module_name):
    """
        Assuming the folder `full_module_name` is a folder inside some
        folder on the python sys.path, for example, sys.path as `C:/`, and
        you are inside the folder `C:/Path With Spaces` on the file 
        `C:/Path With Spaces/main.py` and want to re-import some files on
        the folder `C:/Path With Spaces/tests`

        @param full_module_name   the relative full path to the module file
                                  you want to reload from a folder on the
                                  python `sys.path`
    """
    import imp
    import sys
    import importlib

    if full_module_name in sys.modules:
        module_object = sys.modules[full_module_name]
        module_object = imp.reload( module_object )

    else:
        importlib.import_module( full_module_name )

def run_tests():
    print( "\n\n" )
    reload_module( "Path With Spaces.tests.semantic_linefeed_unit_tests" )
    reload_module( "Path With Spaces.tests.semantic_linefeed_manual_tests" )

    from .tests import semantic_linefeed_unit_tests
    from .tests import semantic_linefeed_manual_tests

    semantic_linefeed_unit_tests.run_unit_tests()
    semantic_linefeed_manual_tests.run_manual_tests()

if __name__ == "__main__":
    run_tests()
</code></pre>
<p>If you run for the first time, this should load the module, but if later you can again the method/function <code>run_tests()</code> it will reload the tests files. With Sublime Text (<code>Python 3.3.6</code>) this happens a lot because its interpreter never closes (unless you restart Sublime Text, i.e., the <code>Python3.3</code> interpreter).</p>
</div>
<span class="comment-copy">Memo tip: "import" doesn't mean "load", it means "load if not loaded yet and then import into namespace".</span>
<span class="comment-copy">the question should not include 'unload' as that is not possible in python yet - reload is however a known paradigm as answered below</span>
<span class="comment-copy">I had the same problem when using a dynamic module in py2exe app. As py2exe always keep bytecode in zip directory reload was not working. But I found a working solution using import_file module. Now my application is working fine.</span>
<span class="comment-copy">What if you want to "unload" because trying to delete a .pyc file is being used by the code?</span>
<span class="comment-copy">actually, the django dev server restarts itself when you change a file .. (it restarts the server, not just reloads the module)</span>
<span class="comment-copy">where is this "is_changed" function coming from? i see no documentation on it and it doesn't run in my Python 3.1.3 environment, nor does it run in 2.6.4.</span>
<span class="comment-copy">no cdleary, Django can't just use reload: <a href="http://pyunit.sourceforge.net/notes/reloading.html" rel="nofollow noreferrer">pyunit.sourceforge.net/notes/reloading.html</a></span>
<span class="comment-copy">Won't work for the <code>from m import X</code> case.</span>
<span class="comment-copy">@BartoszKP if <code>X</code> is not  a module, you can <code>import sys; reload(sys.modules[X.__module__])</code></span>
<span class="comment-copy">The earnest newbie is grateful to learn about critical nuances between Python 2 and 3.</span>
<span class="comment-copy">is imp.reload(imp) valid?</span>
<span class="comment-copy">@LoïcFaure-Lacroix the same way <code>reload(__builtins__)</code> is valid in 2.x</span>
<span class="comment-copy">What is <code>foo</code> here?</span>
<span class="comment-copy">@LoïcFaure-Lacroix yes, imp can reload itself.</span>
<span class="comment-copy">I just discovered that if the module is a part of a package, you have to delete it there as well: <code>setattr(package, "empty", None)</code></span>
<span class="comment-copy">This is the correct solution, especially if you have a package with nested modules. <code>reload()</code> only reloads the top-most module, and anything inside it will not be reloaded unless you first delete it from sys.modules.</span>
<span class="comment-copy">Isn't dreload specifically for that scenario?</span>
<span class="comment-copy">@Josh: nope, it's for reloading a package tree, and even then it only works as long as the package doesn't have outside/circular dependencies.</span>
<span class="comment-copy">Can you elaborate the part with <code>None</code> values because I'm running exactly into this issue: I'm deleting items from <code>sys.modules</code> and after re-import some imported dependencies are <code>None</code>.</span>
<span class="comment-copy">@shclamar: See <a href="http://stackoverflow.com/questions/1958417/why-are-there-dummy-modules-in-sys-modules" title="why are there dummy modules in sys modules">stackoverflow.com/questions/1958417/…</a> (and the links from there) for background. It's unclear to me (even looking at the import.c code) how the <code>None</code> entries managed to make their way back through the import mechanism when the 'real' entries were deleted, and I can't seem to make it happen on 2.7; in future certainly it's no longer a problem as implicit relative imports have gone away. In the meantime, deleting all entries with <code>None</code> value does seem to fix it.</span>
<span class="comment-copy">@Eliethesaiyan: do you mean the <code>reload</code> function? It is built-in, you don't have to import any library.</span>
<span class="comment-copy">+1. My goal was to run nose tests within python. After I had loaded a module and renamed some functions, the old names remained when calling <code>nose.run()</code>, even after <code>reload(my_module)</code> <code>%run my_module</code></span>
<span class="comment-copy">If your module imports it's own submodules, you may need to delete those too. Something like <code>[del(sys.modules[mod] for mod in sys.modules.keys() if mod.startswith('myModule.')]</code>.</span>
<span class="comment-copy">to handle any of these cases: <code>from six import reload_module</code> (need to <code>pip install six</code> first of course)</span>
<span class="comment-copy">@Anentropic: It is good advice to recommend using six package, but the syntax is <code>from six.moves import reload_module</code> (<a href="https://pythonhosted.org/six/#module-six.moves" rel="nofollow noreferrer">doc</a>)</span>
<span class="comment-copy">Noticed an issue, globals() refers to the module you define this function in, so if you define it in a module different than the one you call it in this doesn't work.</span>
<span class="comment-copy">For interactive, after <code>&gt;&gt;&gt; from X import Y</code> to reload do <code>&gt;&gt;&gt; __import__('X', fromlist='Y')</code></span>
<span class="comment-copy">@BobStein-VisiBone, is there a way to make that work when <code>fromlist='*'</code>?</span>
<span class="comment-copy">Good question, don't know @MikeC.  By the way I'm trending to cease almost all use of <code>from</code> in import statements.  Just stark <code>import &lt;package&gt;</code> and explicit package.symbol in the code.  Realize this may not always be possible or desirable.  (Here's one exception: from future import print_function.)</span>
<span class="comment-copy">Mike C: what works for me is <code>foo = reload(foo); from foo import *</code></span>
<span class="comment-copy">Or just do <code>from importlib import reload</code>. Then you can do <code>reload(MODULE_NAME)</code>. There is no need for this function.</span>
<span class="comment-copy">I believe <code>modulereload(MODULE_NAME)</code> is more self-explanatory than just <code>reload(MODULE_NAME)</code> and has a lower chance to conflict with other functions.</span>
<span class="comment-copy">@RichieBendall Sorry, but this answer is completely wrong. The reload() function takes module object, not module name... Read the docs: <a href="https://docs.python.org/3/library/importlib.html#importlib.reload" rel="nofollow noreferrer">docs.python.org/3/library/importlib.html#importlib.reload</a> And I agree with @ pault - this "as modulereload" is superflous.</span>
<span class="comment-copy">I've changed my answer to reflect your opinion.</span>
<span class="comment-copy">Actually that doesn't seem to work reliably (in 2.6) because not everything in <code>sys.modules.values()</code> is a module. For example:      &gt;&gt;&gt; type(sys.modules.values()[1])     &lt;class 'email.LazyImporter'&gt;  So if I try to run that code it falls over (I Know its not meant as a practical solution, just pointing that out).</span>
<span class="comment-copy">It doesn't even work in earlier pythons - as written.  I had to exclude some names. I'll update the post when I move that code to my new computer.</span>
<span class="comment-copy">Works fine in Python 2.7 after some modifications: <code>if mod and mod.__name__ != "__main__": imp.reload(mod)</code></span>
<span class="comment-copy">This works well for me: import imp [reload(m) for m in sys.modules.values() if m and not "<b>" in m.__name</b> and not imp.is_builtin(m.__name__)]</span>
<span class="comment-copy">@Patrick - please edit the answer as you see fit...</span>
<span class="comment-copy">Both this Ipython dreload and reload() from importlib does complain with <code>reload() argument must be module</code>. I'm using a custom function import and doesn't seem to work. Using built-in modules does work. :-( it's a waste of time being reloading iPython for every little change i made to my code ...</span>
<span class="comment-copy">This answer is a direct copy from here: <a href="http://ebanshi.cc/questions/1942/how-do-i-unload-reload-a-python-module" rel="nofollow noreferrer" title="how do i unload reload a python module">ebanshi.cc/questions/1942/…</a></span>
<span class="comment-copy">The module will never get garbage collected because a global reference is held at least in <code>sys.modules</code>.</span>
