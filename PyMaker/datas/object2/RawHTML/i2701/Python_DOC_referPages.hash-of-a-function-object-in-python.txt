<div class="post-text" itemprop="text">
<p>Let me explain why I need to do this:</p>
<p>I'm developing a library, and have the need to serialize python functions.</p>
<p>Here are the 2 utility functions I use:</p>
<pre><code>def serialize_func(fn: function) -&gt; Tuple[bytes, str]:
    return marshal.dumps(fn.__code__), fn.__name__


def deserialize_func(serialized_fn: Tuple[bytes, str]) -&gt; function:
    return types.FunctionType(
        marshal.loads(serialized_fn[0]), globals(), serialized_fn[1]
    )
</code></pre>
<p>Now, If somehow I could cache the serialized functions, and store them in a <code>dict</code> like this:</p>
<pre><code>Dict[function_hash, function]

{
     &lt;function hash&gt;: &lt;function&gt;,
     &lt;function hash&gt;: &lt;function&gt;,
     ...
}
</code></pre>
<p>It would result in quite a performance improvement since I don't need to serialize (and transport) them repeatedly.</p>
<p>Is there a reliable way to achieve this?</p>
<p>EDIT: If I tried hashing a function, It's not exactly what I have in mind.</p>
<pre><code>In [1]: def x():
   ...:     pass

In [2]: hash(x)
Out[2]: 8745212393041

In [3]: def x():
   ...:     pass

In [4]: hash(x)
Out[4]: -9223363291642382793
</code></pre>
<p>I need 2 functions with the same body, signature, global scope (and something else, which I'm probably missing) to return the same hash.</p>
<p><a href="https://github.com/pycampers/zproc" rel="nofollow noreferrer">Here</a> is the library in question.</p>
<hr/>
<p>EDIT: Here is some in-depth explanation of why I want to do this.</p>
<p>I am sending the function from a process ("Client") to another one ("Server"), and executing it on "Server".</p>
<p>Sounds weird and complicated, but I have a good reason for it.</p>
<p>This whole process makes the function strictly atomic across all "Client"s</p>
<p>The "Server" is the "Actor". So one, and only one function can run at a time, making it easier for the programmer to avoid race conditions.</p>
<p>Now, I if the "Client" has already sent the function to the "Server" once, then for the subsequent interactions, It sends only the hash of that function, and the "Server" can just look up that function in its table.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I need 2 functions with the same body, signature, global scope (and something else, which I'm probably missing) to return the same hash.</p>
</blockquote>
<p>Then you will have to construct the hash yourself, based on those criteria.</p>
<p>For example:</p>
<pre><code>def foo(x):
    return "It is " + str(x + 1)

def bar(x):
    return "The answer is " + str(x + 2)

def quux(x):
    return "The answer is " + str(x - 2)


def fnhash(f):
    c = f.__code__
    return hash((c.co_argcount, c.co_code))

fnhash(foo)
# =&gt; -640999299468968616
fnhash(bar)
# =&gt; -640999299468968616
fnhash(quux)
# =&gt; -1235803056671018747
</code></pre>
<p>Note that the first ones are the same, because the code and the number of positional parameters are the same - we didn't include <code>co_consts</code>, so the different string and changing <code>1</code> to <code>2</code> is not taken into account. Note that the last one is different, because we changed the operation (which influenced <code>co_code</code>, which in turn influenced <code>fnhash</code>).</p>
<p>It will be up to you to select exactly which attributes of the code object you will choose to be meaningful (e.g. I doubt you'll want to include <code>co_filename</code> and <code>co_firstline</code>). See the meanings of various <code>co_*</code> fields <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">in the <code>inspect</code> docs</a>.</p>
</div>
<span class="comment-copy">Strings are hashable (including byte arrays, which is what <code>marshal.dumps</code> returns), so they work without any change as dictionary keys. While it is not too common to see a collision on a hash value, it is quite possible, so a dictionary where the key is the hash value is not really recommended.</span>
<span class="comment-copy">I want to hash "function" objects, not their serialized version.  The serialization takes some finite time, and that finite time results in a perf issue, when done repeatedly.  Right now, I have to make the user serialize it once, and use the serialized counterpart themselves. SO was looking to automate that part.</span>
<span class="comment-copy">If it helps at all, here is the API in question - <a href="https://zproc.readthedocs.io/en/latest/_modules/zproc/zproc.html#atomic" rel="nofollow noreferrer">zproc.readthedocs.io/en/latest/_modules/zproc/zproc.html#atomic</a></span>
<span class="comment-copy">Well, functions are hashable too. <code>hash(enumerate)</code> (though you get different value in different instances of Python)</span>
<span class="comment-copy">[Updated answer for better formatting]</span>
<span class="comment-copy">Thanks, this is quite useful.  Is there a way I can see if the global scope is the same?  For example  - <a href="https://gist.github.com/devxpy/da53556d1b5bc97a745c41bff5ff50d2" rel="nofollow noreferrer">gist.github.com/devxpy/da53556d1b5bc97a745c41bff5ff50d2</a></span>
<span class="comment-copy">Actually, I don't need to do that since I'm not transporting the global scope, and it does not matter. This Much should suffice. Thanks.</span>
<span class="comment-copy">These two functions are identical, except that the first one will have <code>inspect.CO_NESTED</code> in its <code>co_flags</code> - because you never use <code>somevar</code>, it is not closed over. If you did use <code>somevar</code>, it would appear in <code>co_freevars</code> in the closure one, but not the other one where it is undefined. Of course, the <i>value</i> of the closed variable is not there, as it is not property of the function itself - it just knows it must remember it - and you should get it yourself (probably from <code>locals()</code>)</span>
<span class="comment-copy">Wow, that might just enable me to use global variables!</span>
<span class="comment-copy">I never knew python kept such extensive track of it's variables and functions. Really cool.</span>
