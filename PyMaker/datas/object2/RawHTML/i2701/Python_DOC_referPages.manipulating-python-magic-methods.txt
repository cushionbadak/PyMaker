<div class="post-text" itemprop="text">
<p>I have more of a background with data science libraries or calling methods and attributes from classes. I am experimenting with manipulating magic methods. I am having a difficult time getting <code>bool</code> types and returning their opposites. </p>
<p>I did something with <code>str</code> and <code>datetime</code> objects that worked but can't seem to to the same with <code>__cmp__</code>, <code>__lt__</code>, <code>__eq__</code> or `<strong>gt</strong>'. Here is my code:</p>
<pre><code>class Opposite:

    def __cmp__(self, other):

        if other.__class__.__name__ == 'bool':
            return other

    def __lt__(self, other):
        if other.__class__.__name__ == 'bool':
            return other

    def __eq__(self, other):
        if other.__class__.__name__ == 'bool':
            return other

    def __gt__(self, other):
        if other.__class__.__name__ == 'bool':
            return other


if __name__=="__main__":

    """ test class Compare """

    a = 1
    b = 1
    c = a &lt; b
    d = a &gt; b
    e = a == b

print("Results:\na\t{}\nb\t{}\nc\t{}\nd\t{}\ne\t{}\n".format(a,b,c,d,e))
print("\nType:\na-type\t{}\nb-type\t{}\nc-type\t{}\nd-type\t{}\ne-type\t{}\n"
      .format(type(a),type(b),type(c),type(d),type(e)))
</code></pre>
<p>This prints the following:</p>
<pre><code>Results:
a   1
b   1
c   False
d   False
e   True

Type:
a-type  &lt;class 'int'&gt;
b-type  &lt;class 'int'&gt;
c-type  &lt;class 'bool'&gt;
d-type  &lt;class 'bool'&gt;
e-type  &lt;class 'bool'&gt;
</code></pre>
<p>As you can see, the results are the same as not using the class at all. I added an <code>__init__</code> method to print <code>using Opposite</code> and it only prints that if I instantiate the object with something like <code>a = Opposite()</code>.</p>
<p>I would like to enter something like <code>a &gt; b</code>, <code>a &lt; b</code>, or <code>a == b</code>, and return the opposite boolean value, <code>True</code>, or <code>False</code>, as an exercise. </p>
<p>I tried several things such as placing the methods under the <code>__init__</code> method I created, which didn't work either. I read on this and still don't quite understand how to do this with booleans, integers and floats for that matter. The way the methods are above is how I was able to turn datetime objects into strings with <code>__add__</code>, <code>__radd__</code> and <code>__rsub__</code> methods.</p>
<p>Thank you for your help. </p>
<p><strong>EDIT</strong></p>
<p>Thanks to your help, I have a better understanding and have completed my small experiment with this code:</p>
<pre><code>class Opposite:

    def __init__(self, x):
        self._x = x

    def __lt__(self, other):
        return not self._x &lt; other._x

    def __eq__(self, other):
        return not self._x == other._x

    def __gt__(self, other):
        return not self._x &gt; other._x

    def __le__(self, other):
        return not self._x &lt;= other._x

    def __ge__(self, other):
        return not self._x &gt;= other._x

def tester(w, x, y, z):
    try:
        # Original values
        a = w &lt; x
        b = w &gt; x
        c = w == x
        d = w &lt;= x
        e = w &gt;= x

        # Opposite values
        f = y &lt; z
        g = y &gt; z
        h = y == z
        i = y &lt;= z
        j = y &gt;= z

        # Results
        k = 'Fail' if a == f else 'Success'
        l = 'Fail' if b == g else 'Success'
        m = 'Fail' if c == h else 'Success'
        n = 'Fail' if d == i else 'Success'
        o = 'Fail' if e == j else 'Success'

        print('\nComparing {} and {}:\t&lt;\t&gt;\t==\t&lt;=\t&gt;='.format(w, x))
        print('Original Values:', end='\t')
        print('{0}\t{1}\t{2}\t{3}\t{4}'.format(a, b, c, d, e))
        print('Opposite Values:', end='\t')
        print('{0}\t{1}\t{2}\t{3}\t{4}'.format(f, g, h, i, j))
        print('Comparisons:', end='\t')
        print('\t{0}\t{1}\t{2}\t{3}\t{4}'.format(k, l, m, n, o))

    except(Exception) as err:
        print(err)

if __name__=="__main__":

    """ test class Compare """

    a = 1
    b = 2
    c = Opposite(a)
    d = Opposite(b)
    tester(a, b, c, d)
</code></pre>
<p>This prints the following:</p>
<pre><code>Comparing 1 and 2:  &lt;   &gt;   ==  &lt;=  &gt;=
Original Values:    True    False   False   True    False
Opposite Values:    False   True    True    False   True
Comparisons:        Success Success Success Success Success
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you mean that you want to return the negation of the boolean resulting from the comparison you could do something like</p>
<pre><code>class T:
    def __init__(self, x):
        self._x = x

    def __lt__(self, other):
        return not self._x &lt; other._x

t1 = T(1)
t2 = T(2)

print(t1 &lt; t2) #False
</code></pre>
<p>Note that in the comparison <code>self._x &lt; other._x</code> you are using the <code>__lt__</code> method of the int class.</p>
</div>
<span class="comment-copy">You didn't make any instances of your class at all. Why do you expect your comparison code to execute? You'd need to make instances of <code>Opposite</code> for your code to be used (and to be clear, as written it's not the opposite of anything). Also, if this is Python 3, <code>__cmp__</code> isn't magic anymore, only the individual rich comparison methods are used.</span>
<span class="comment-copy">For your class methods to be used the left operand has to be an instance of that class. Yours is an <code>int</code>.</span>
<span class="comment-copy">@KlausD.: Technically, it can work if the right operand is an instance of the class, and the left operand has a correctly implemented comparator (one that returns <code>NotImplemented</code> when it doesn't know how to compare itself to the right operand); in that case, the left operand is tried, and when it returns <code>NotImplemented</code>, <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow noreferrer">the reflected operand is tried for the right hand side</a> (see final paragraph of linked section). Of course, in the OP's case, nothing is an instance of the class at all.</span>
<span class="comment-copy">That is correct, but does not apply to his class and an int.</span>
<span class="comment-copy">Originally, I was hoping to manipulate say <code>__lt__</code> so I can simply perform <code>2 &lt; 1</code> and get <code>True</code> without instantiating the class, but that isn't how it works. I would have to break python to do that lol</span>
