<div class="post-text" itemprop="text">
<p>I'm new to python and don't know why this code wont run. I'm trying to make an employee class and access it and initialise an object from a different class here's the class code:</p>
<pre><code>class employee:

    def __init__(self):
        self.__name
        self.__num


    def employee(self):
        self.__name = "Brian"
        self.__num = 40000

    def employee(self, n ,x):
        self.__name = n
        self.__num = x

    def setName(self, n):
        self.__name = n

    def getName(self):
        return self.__name

    def setNum(self, x):
        self.__num = x

    def getNum(self):
        return self.__num

    def toString(self):
        res = "Name: " + self.__name
        res += "\nNum: " + self.__num
</code></pre>
<p>and here's the test code:</p>
<pre><code>import Employee
def main():

    jane = Employee.employee("Jane", 40000)
    brian = Employee.employee()

    print(brian.toString())
    print(jane.toString())

main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First read this : <a href="https://dirtsimple.org/2004/12/python-is-not-java.html" rel="nofollow noreferrer">https://dirtsimple.org/2004/12/python-is-not-java.html</a></p>
<p>and then this: <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/classes.html</a></p>
<p>Then rewrite your code the Python way:</p>
<pre><code># employee.py (module names should be all lower)    
class Employee(object):
    # inheriting from `object` is only useful in python2
    # but doesn't break anything in python3

    def __init__(self, name="Brian", num=4000):
        self.name = name
        self.num = num

    def __str__(self):
        # this will be automagically called when trying
        # to make a string out of an Employee
        return "Name: {self.name}\nNum: {self.num}".format(self=self)

    # and that's all. You don't need private attributes nor
    # accessors, Python has a strong support for computed 
    # attributes so you can turn plain attributes into
    # computed ones later if needed (without breaking
    # the client code of course).
</code></pre>
<p>and the test code</p>
<pre><code># test.py
from employee import Employee

def main():
    # instanciating a class is done by calling it
    jane = Employee("Jane", 40000)
    brian = Employee()

    print(jane)
    print(brian)

if __name__ == "__main__":
    main()
</code></pre>
<p>I strongly suggest you at least follow the full Python tutorial before trying to write PHP or Java code in Python, it'll save everyone's time.</p>
</div>
<div class="post-text" itemprop="text">
<p>you are writing python in java style. See <a href="https://docs.python.org/3/tutorial/classes.html#class-objects" rel="nofollow noreferrer">classes documentation</a></p>
<pre><code>class Employee:

    # initialize constructor with default arguments
    def __init__(self, name="Brian", num=40000):
        self.name = name
        self.num = num

    # you don't need this. this is the work of "__init__" function above
    def employee(self, n ,x):
        self.__name = n
        self.__num = x

    def set_name(self, n):
        self.name = n

    def get_name(self):
        return self.name

    def set_num(self, num):
        self.num = num

    def get_num(self):
        return self.num

    # tostring equivalent
    def __str__(self):
        # string format
        return "Name: {0}\nNum: {1}".format(self.name, self.num)
</code></pre>
<p>Testing the code</p>
<pre><code>def main():
    # you don't need to import employee class if in the same file
    import Employee

    # creating instances
    jane = Employee("Jane", 40000)
    brian = Employee()

    print(brian)
    print(jane)


if __name__=="__main__":
    main()
</code></pre>
<p>will print out</p>
<pre><code>&gt;&gt;&gt; Name: Brian
&gt;&gt;&gt; Num: 40000
&gt;&gt;&gt; Name: Jane
&gt;&gt;&gt; Num: 40000
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You class definition does not look good to me.</p>
<p>In the <strong>init</strong> method you don't assign anything to the attributes. It should be like:</p>
<pre><code>class employee:

    def __init__(self, name, num):
        self.name = name
        self.num = num
</code></pre>
<p>Furthermore your second instantiation is missing the attributes. Should be like:</p>
<pre><code>brian = Employee.employee("Brian", 30.000)
</code></pre>
<p>Your ToString method is also incorrect, you cannot concatenate strings like that. Try something like:</p>
<pre><code>def toString(self):
    res = "Name: {}, Num: {}".format(self.name, self.num)
    return res
</code></pre>
</div>
<span class="comment-copy">You're calling object methods as if they were class methods. Move all the initialising logic into the constructor.</span>
<span class="comment-copy">1. Fix the indentation. 2. What do you expect <code>self.__name</code> in <code>__init__</code> to do? 3. The usage of Getters and Setters (as you implemented it) is quite uncommon in Python. 4. The second definition of the <code>employee</code> method overwrites the first. 5. The whole code looks like you're trying to write Java in Python.</span>
<span class="comment-copy">this is not the way to go in Python. Have a look at the <a href="https://docs.python.org/3/tutorial/classes.html#class-objects" rel="nofollow noreferrer">classes documentation</a></span>
