<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/12739911/how-to-split-a-string-within-a-list-to-create-key-value-pairs-in-python">How to split a string within a list to create key-value pairs in Python</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>Given the following sample data:</p>
<pre><code>values=['A 1','B 2','C 3']
</code></pre>
<p>I want to create a dictionary where A maps to 1, B to 2, and C to 3. The following works, but there is repetition:</p>
<pre><code>my_dict={value.split()[0]:value.split()[1] for value in values}
</code></pre>
<p>The repetition of <code>value.split()</code> looks ugly. Is there a way to more elegantly create the dictionary without repeating <code>value.split()</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Two ways I can think of:</p>
<pre><code>&gt;&gt;&gt; {k:v for k,v in (s.split() for s in values)}
{'A': '1', 'B': '2', 'C': '3'}
&gt;&gt;&gt; dict(s.split() for s in values)
{'A': '1', 'B': '2', 'C': '3'}
</code></pre>
<hr/>
<p>I suggesting reading about the <code>dict</code> type: <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#mapping-types-dict</a>; in particular:</p>
<blockquote>
<p>Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value.</p>
</blockquote>
<p>as well as the introduction of dict-comprehensions in <a href="https://www.python.org/dev/peps/pep-0274/" rel="nofollow noreferrer">PEP 274</a>:</p>
<blockquote>
<p>The semantics of dict comprehensions can actually be demonstrated in stock Python 2.2, by passing a list comprehension to the built-in dictionary constructor:</p>
<pre><code>&gt;&gt;&gt; dict([(i, chr(65+i)) for i in range(4)])
</code></pre>
<p>is semantically equivalent to:</p>
<pre><code>&gt;&gt;&gt; {i : chr(65+i) for i in range(4)}
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>For a <a href="https://stackoverflow.com/questions/24279/functional-programming-and-non-functional-programming">functional</a> solution, you can use <code>dict</code> with <code>map</code> and <code>str.split</code>:</p>
<pre><code>values = ['A 1', 'B 2', 'C 3']

res = dict(map(str.split, values))

{'A': '1', 'B': '2', 'C': '3'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can do this way pythonic:</p>
<pre><code>&gt;&gt;&gt; values =['A 1','B 2','C 3']
&gt;&gt;&gt; dict(map(str.split, values))
{'A': '1', 'C': '3', 'B': '2'}
</code></pre>
<h1>str.split([sep[, maxsplit]])</h1>
<blockquote>
<p>Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made).
  If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns [''].</p>
</blockquote>
<h1>map(function, iterable, ...)</h1>
<blockquote>
<p>Apply function to every item of iterable and return a list of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. If one iterable is shorter than another it is assumed to be extended with None items. If function is None, the identity function is assumed; if there are multiple arguments, map() returns a list consisting of tuples containing the corresponding items from all iterables (a kind of transpose operation). The iterable arguments may be a sequence or any iterable object; the result is always a list.</p>
</blockquote>
<p>you can see that dictionary is not in ordered as your list. Using <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">collections.orderedDict</a> we can retain the order of the input given.</p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; values =['A 1','B 2','C 3']
&gt;&gt;&gt; my_ordered_dict = collections.OrderedDict(map(str.split, values))
&gt;&gt;&gt; my_ordered_dict
OrderedDict([('A', '1'), ('B', '2'), ('C', '3')])
</code></pre>
</div>
<span class="comment-copy"><code>dict(v.split() for v in values)</code></span>
<span class="comment-copy">As @Aran-Fey says, the <code>dict()</code> constructor can take in a list of pairs like <code>[('A', '1'), ('B', '2')]</code></span>
<span class="comment-copy">Not having the parens around <code>s.split() for s in values</code> is what got me, thanks!</span>
<span class="comment-copy">I prefer option 2. <code>k:v for k,v</code> looks like an anti-pattern to me, similar to <code>[x for x in iterable]</code>.</span>
<span class="comment-copy">@timgeb me too but it is a different method which allows for more flexibility/adaptation in different scenarios.</span>
<span class="comment-copy">Nice short way to do it!</span>
