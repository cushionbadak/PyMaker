<div class="post-text" itemprop="text">
<p>How can I change the serialization method used by the Python <code>multiprocessing</code> library? In particular, the default serialization method uses the <code>pickle</code> library with the default pickle protocol version for that version of Python. The default pickle protocol is version 2 in Python 2.7 and version 3 in Python 3.6. How can I set the protocol version to 2 in Python 3.6, so I can use some of the classes (like <code>Client</code> and <code>Listener</code>) in the <code>multiprocessing</code> library to communicate between a server processing run by Python 2.7 and a client process run by Python 3.6?</p>
<p>(Side note: as a test, I modified <a href="https://github.com/python/cpython/blob/5458647bb867770fc3d830a618cef6994fdfac4b/Lib/multiprocessing/connection.py#L206" rel="nofollow noreferrer">line 206 of <code>multiprocessing/connection.py</code></a> by adding <code>protocol=2</code> to the <code>dump()</code> call to force the protocol version to 2 and my client/server processes worked in my limited testing with the server run by 2.7 and the client by 3.6).</p>
<p>In Python 3.6, a <a href="http://bugs.python.org/issue28053" rel="nofollow noreferrer">patch</a> was merged to let the serializer be set, but the patch was undocumented, and I haven't figured out how to use it. Here is how I tried to use it (I posted this also to the Python ticket that I linked to):</p>
<p>pickle2reducer.py:</p>
<pre><code>from multiprocessing.reduction import ForkingPickler, AbstractReducer

class ForkingPickler2(ForkingPickler):
    def __init__(self, *args):
        if len(args) &gt; 1:
            args[1] = 2
        else:
            args.append(2)
        super().__init__(*args)

    @classmethod
    def dumps(cls, obj, protocol=2):
        return ForkingPickler.dumps(obj, protocol)


def dump(obj, file, protocol=2):
    ForkingPickler2(file, protocol).dump(obj)


class Pickle2Reducer(AbstractReducer):
    ForkingPickler = ForkingPickler2
    register = ForkingPickler2.register
    dump = dump
</code></pre>
<p>and in my client:</p>
<pre><code>import pickle2reducer
multiprocessing.reducer = pickle2reducer.Pickle2Reducer()
</code></pre>
<p>at the top before doing anything else with <code>multiprocessing</code>. I still see <code>ValueError: unsupported pickle protocol: 3</code> on the server run by Python 2.7 when I do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe the patch you're referring to works if you're using a multiprocessing <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer">"context" object</a>.</p>
<p>Using your pickle2reducer.py, your client should start with:</p>
<pre><code>import pickle2reducer
import multiprocessing as mp

ctx = mp.get_context()
ctx.reducer = pickle2reducer.Pickle2Reducer()
</code></pre>
<p>And <code>ctx</code> has the same API as  <code>multiprocessing</code>.</p>
<p>Hope that helps!</p>
</div>
<span class="comment-copy">That seems like the right way to make use of the patch. I don't see how to use a context in my specific situation. I use <code>from multiprocessing.connection import Client, Listener</code> and <code>from multiprocessing.managers import BaseManager, NameSpaceProxy</code> and none of those four classes are accessible from the context object. I was able to do this instead: <code>multiprocessing.context._default_context.reducer = Pickle2Reducer()</code>.</span>
