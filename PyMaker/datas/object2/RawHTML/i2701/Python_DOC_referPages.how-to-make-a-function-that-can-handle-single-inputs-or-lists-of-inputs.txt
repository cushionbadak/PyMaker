<div class="post-text" itemprop="text">
<p>I'll illustrate my question with a couple of overly simple functions that just square numbers. But it is the general best practice for writing functions that I want to know about.</p>
<p>Suppose I have a number that I want to square, I could write the following function.</p>
<pre><code>def square (x):
    y = x**2
    return y
</code></pre>
<p>If I had a list of numbers and wanted to get the list in which each element is squared, I could use</p>
<pre><code>def square (x_list):
    y_list = []
    for x in x_list:
        y_list.append( x**2 )
    return y_list
</code></pre>
<p>But I want to write just one function that will handle both of these cases. It will see whether the input is a number or a list, and act accordingly. I could do this using <code>type</code> to detect type, but I'd like to know what the most pythonic way to do it is.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's very simple if you use numpy. For multiple elements make it as an array. For single element ,the function is applied as it.</p>
<pre><code>import numpy as np

def square(a):
    return a**2

a = np.array([2,3,4,5])
print(square(a)) # array([ 4,  9, 16, 25])

b = 9
print(square(b)) # 81
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would agree with @Bryan Oakley's answer, that it's best to write the code to only accept a single argument type. With that being said, I figured I would present an example of a function that handles a variable number of input arguments:</p>
<pre><code>def square(*args):

    return [arg**2 for arg in args]
</code></pre>
<p>Note that this will always return a list:</p>
<pre><code>y = square(2,4,6,8)

y = square(4)
</code></pre>
<p>Yields:</p>
<pre><code>[4, 16, 36, 64]
[16]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can check for the type of the passed in argument and act accordingly:</p>
<pre><code># check the variable instance type
def square (x):
    """Returns squares of ints and lists of ints - even if boxed inside each other.
    It uses recursion, so do not go too deep ;o)"""

    if isinstance(x,int):
        return x**2

    elif isinstance(x,list):
        return [square(b) for b in x] #  recursion for lists of ints/lists of ints

    else:
        raise ValueError("Only ints and list of ints/list of ints allowed")


print(square(4))
print(square([2,3,4]))
print(square([2,3,[9,10],11]))

try:
    print(square(2.6))
except ValueError as e:
    print(e)
</code></pre>
<p>Output:</p>
<pre><code>16
[4, 9, 16]
[4, 9, [81, 100], 121]

Only ints and list of ints/list of ints allowed
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Treat the argument as list input and handle the exception if it's not.</p>
<blockquote>
<p>EAFP
  Easier to ask for forgiveness than permission. This common Python coding style assumes the existence of valid keys or attributes and catches exceptions if the assumption proves false. This clean and fast style is characterized by the presence of many try and except statements. The technique contrasts with the LBYL style common to many other languages such as C. <a href="https://docs.python.org/3.6/glossary.html" rel="nofollow noreferrer">docs</a></p>
</blockquote>
<pre><code>def square(x):    
    try:
        y = [e ** 2 for e in x]
    except TypeError:
        y = x ** 2
    return y

square(2)
# Out: 4
square([2, 3])
# Out: [4, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As other answers have explained, this probably isn't a great design. </p>
<p>First, a "number" could be an <code>int</code>, or some user-defined subclass of <code>int</code>, or a <code>float</code>, or some user-defined <code>Quaternion</code> type. Normally, you just use duck-typing: it <code>x ** 2</code> works, then <code>x</code> is quacking like a number, and that's good enough.</p>
<p>But a list of ints doesn't quack like an int. So, what can you do?</p>
<p>Well, usually, you'll want to explicitly loop over them:</p>
<pre><code>&gt;&gt;&gt; xs = [1, 2, 3]
&gt;&gt;&gt; sqs = [square(x) for x in xs]
</code></pre>
<p>… or write a function that does that:</p>
<pre><code>&gt;&gt;&gt; def squares(xs): return [square(x) for x in xs]
&gt;&gt;&gt; sqs = squares(xs)
</code></pre>
<p>… or use a type that knows how to vectorize mathematical operators:</p>
<pre><code>&gt;&gt;&gt; xs = np.array([1, 2, 3])
&gt;&gt;&gt; sqs = square(xs)
</code></pre>
<hr/>
<p>In fact, even when you <em>do</em> want to handle two different types, you can often rely on duck typing:</p>
<pre><code>def square(x):
    try:
        return x**2
    except ValueError:
        return [i**2 for i in x]
</code></pre>
<p>This will square anything that's number-like enough to be squarable, and iterate over squaring all of the elements of anything that isn't, and raise a reasonable exception for anything that fails (either because it's not iterable, or because its elements aren't squarable).</p>
<hr/>
<p>Occasionally, you really do need to type-switch. But you still want to keep as close to duck-typing as possible, and that means using <code>isinstance</code> (so that, e.g., a user subtype of <code>int</code> still counts as a number) and, usually, using <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">abstract base classes</a> (so that, e.g., a user <code>Quaternion</code> type still counts as a number).</p>
<p>In this case, that means either treating <a href="https://docs.python.org/3/library/numbers.html#numbers.Number" rel="nofollow noreferrer">numbers</a> specially and assuming anything else is an iterable:</p>
<pre><code>def square(x):
    if isinstance(x, numbers.Number):
        return x**2
    else:
        return [i**2 for i in x]
</code></pre>
<p>… or treating <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable" rel="nofollow noreferrer">iterables</a> specially and assuming everything else is a number:</p>
<pre><code>def square(x):
    if isinstance(x, collections.abc.Iterable):
        return [i**2 for i in x]
    else:
        return x**2
</code></pre>
<p>Or maybe treating both specially and calling everything else an error:</p>
<pre><code>def square(x):
    if isinstance(x, numbers.Number):
        return x**2
    elif isinstance(x, collections.abc.Iterable):
        return [i**2 for i in x]
    raise ValueError(f"'{type(x).__name__}' instance is not a number or numbers")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can write one line return but using type:</p>
<pre><code>def square(x):
    return(x**2 if type(x) is int else [i**2 for i in x])
</code></pre>
</div>
<span class="comment-copy">Yes, it will work for a single number also</span>
<span class="comment-copy">Yeah, while this doesn't really <i>directly</i> answer the question, anyone who's thinking "I want to be able to treat collections of numbers as numbers and do math on them" is already thinking in numpy array-processing terms, and should probably should be using numpy unless they have a good reason not to.</span>
