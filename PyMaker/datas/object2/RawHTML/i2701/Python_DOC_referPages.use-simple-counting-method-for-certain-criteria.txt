<div class="post-text" itemprop="text">
<p>I have a dataset like</p>
<pre><code>x y
1 0.34
2 0.3432
3 0.32
4 0.35
5 0.323
6 0.3623
7 0.345
8 0.32
9 0.31
10 0.378
11 0.34
12 0.33
13 0.31
14 0.33
15 0.34
</code></pre>
<p>For this dataset I want to perform a task which will go through my dataset and will count the number of occurrences above a cutoff if the length of occurrence is above M.</p>
<p>The cutoff and M will be system arguments.</p>
<p>So if the cutoff is 0.32 and M is 1 it will print out a list like</p>
<pre><code>[2, 4, 3, 2]
</code></pre>
<p>Logic: First two values in second column are above 0.32 and the length of the is greater than M=1 hence it printed out 2 and 4,3,2 so on.</p>
<p>I need a help to write the argument so that if x &gt;cutoff and length of broken is &gt;M it will print out the length of broken frames (so the same out put as above). Any help?</p>
<p>The structure should look like following (I am not sure how to place the argument in place of XXX)</p>
<pre><code>def get_input(filename):
    with open(filename) as f:
        next(f) # skip the first line
        input_list = []
        for line in f:
            input_list.append(float(line.split()[1]))

    return input_list


def countwanted(input_list, wantbroken, cutoff,M):

    def whichwanted(x):
        if(wantbroken): return x &gt; cutoff
        else: return x &lt; cutoff

XXX I think here I need to add the criteria for M but not sure how?

filename=sys.argv[1]
wantbroken=(sys.argv[2]=='b' or sys.argv[2]=='B')
cutoff=float(sys.argv[3])
M=int(sys.argv[4])

input_list = get_input(filename)

broken,lifebroken=countwanted(input_list,True,cutoff,M)
#closed,lifeclosed=countwanted(input_list,False,cutoff,M)
print(lifebroken)
#print(lifeclosed)
</code></pre>
<p>Or maybe there is a simpler way to write it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are OK with using numpy, which makes life a lot easier.</p>
<p>First off, let's take a look at the file loader. <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html" rel="nofollow noreferrer"><code>np.loadtxt</code></a> can do the same thing in one line.</p>
<pre><code>y = np.loadtxt(filename, skiprows=1, usecols=1)
</code></pre>
<p>Now to create a mask of which values that make up your above-threshold runs:</p>
<pre><code>b = (y &gt; cutoff)  # I think you can figure out how to switch the sense of the test
</code></pre>
<p>The rest is easy, and based off <a href="https://stackoverflow.com/q/1066758/2988730">this question</a>:</p>
<pre><code>b = np.r_[0, b, 0]       # pad the ends
d = np.diff(b)           # find changes in state
start, = np.where(d &gt; 0) # convert switch up to start indices
end, = np.where(d &lt; 0)   # convert switch down to end indices
len = end - start        # get the lengths
</code></pre>
<p>Now you can apply <code>M</code> to <code>len</code>:</p>
<pre><code>result = len[len &gt;= M]
</code></pre>
<p>If you want to work with lists, <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> also offers a good solution:</p>
<pre><code>grouper = it.groupby(y, key=lambda x: x &gt; cutoff)
result = [x for x in (len(list(group)) for key, group in grouper if key) if x &gt;= M]
</code></pre>
</div>
<span class="comment-copy">There's an awful amount of code. Could you show an expected output given the above input (and any additional input required)?</span>
<span class="comment-copy">@CristiFati [2, 4, 3, 2] if executed like python myscript.py test.dat b 0.32 1 where 0.32 is cutoff and M=1. this is the expected output</span>
<span class="comment-copy">Are you open to using numpy?</span>
<span class="comment-copy">@MadPhysicist yes sure</span>
<span class="comment-copy">OK. Enjoy. I've posted with and without numpy.</span>
<span class="comment-copy">Well I put your command in a script <code>#!/usr/bin/python import numpy as np import sys y = np.loadtxt(filename, skiprows=1, usecols=1) b = (y &gt; cutoff)  b = np.r_[0, b, 0] d = np.diff(b) start, = np.where(d &gt; 0) end, = np.where(d &lt; 0) len = end - start result = len[len &gt;= M]  filename=sys.argv[1] cutoff=int(sys.argv[1]) M=int(sys.argv[2]) print(result)</code> and trying to run it like python broken_nogroupby.py test.dat 0.33 1 but it is saying   NameError: name 'filename' is not defined Maybe I am doing a silly mistake. any help?</span>
<span class="comment-copy">am I inputting the filename, cutoff wrongly in the system argument?</span>
<span class="comment-copy">Well, you have to set filename somewhere. Keep your original argument processing.</span>
<span class="comment-copy">Silly question when I am using print(result) it is giving [37 34 56 ..., 30 43 12] So it is doing the right thing but not printing out the full list but rather giving .... Any tricks to make it print the full list</span>
<span class="comment-copy">Okay I fixed it <code>def fullstring(k): return " ".join([str(x) for x in k]) pd.options.display.max_seq_items = 10000 print(fullstring(result))</code></span>
