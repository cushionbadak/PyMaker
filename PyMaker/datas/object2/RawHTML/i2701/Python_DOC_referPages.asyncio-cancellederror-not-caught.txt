<div class="post-text" itemprop="text">
<p>Why is the <code>CancelledError</code> not caught in this example?</p>
<pre><code>import asyncio

q = asyncio.Queue()

async def getter():
    try:
        v = await q.get()
        print(f"getter got {v}")
    except asyncio.CancelledError:
        print("getter cancelled")

async def test():
    task = asyncio.ensure_future(getter())
    task.cancel()
    await task

def main():
    loop = asyncio.get_event_loop()
    loop.run_until_complete(test())

if __name__ == '__main__':
    main()
</code></pre>
<p>I excpected to get the "getter cancelled" message, but received a stack trace instead:</p>
<pre>
Traceback (most recent call last):
  File "ce.py", line 22, in 
    main()
  File "ce.py", line 19, in main
    loop.run_until_complete(test())
  File "/usr/lib64/python3.6/asyncio/base_events.py", line 468, in run_until_complete
    return future.result()
concurrent.futures._base.CancelledError
</pre>
<p><a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel" rel="nofollow noreferrer">Task.cancel</a> states:</p>
<blockquote>
<p>This arranges for a CancelledError to be thrown into the wrapped
  coroutine on the next cycle through the event loop. The coroutine then
  has a chance to clean up or even deny the request using
  try/except/finally.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <code>getter</code> didn't even <em>start</em> executing, which you can confirm by adding a print at its beginning. Since the <code>try</code> block was never entered, the <code>except</code> didn't run either.</p>
<p>This happens because, in contrast to <code>await</code>, <code>ensure_future</code> doesn't start executing the coroutine right away, it just schedules it to run at the next event loop iteration, like <code>call_soon</code> does for ordinary functions. Since you cancel the task immediately, it gets removed from the runnable set and its coroutine gets closed without ever having started.</p>
<p>Add an <code>await asyncio.sleep(0)</code> before <code>task.cancel()</code> and you should observe the behavior you expect. I suspect you don't need to make such change in your actual code - in the unlikely case that the task gets cancelled before it ran, as in the example, it won't get a chance to acquire the resources that try/except cleans up in the first place.</p>
<p>Two tangential remarks:</p>
<ul>
<li><p>You probably want to re-raise <code>asyncio.CancelledError</code> after handling it, otherwise it will be suppressed. That's not a problem in <code>getter</code> as shown in the question, but it could be an issue if the code were buried in a function call. Even better, consider using <code>finally</code> or <code>with</code>, which propagate the exception and ensure that the resources are released regardless of exception type.</p></li>
<li><p>When you need to create a task and run a coroutine, <code>loop.create_task</code> is <a href="https://github.com/python/asyncio/issues/477#issuecomment-268709555" rel="nofollow noreferrer">preferred</a> to <code>asyncio.ensure_future</code>. In short, although both do the same thing for coroutines, <code>create_task</code> makes the intention clearer; <code>ensure_future</code> is designed to accept a wider range of objects and procure a future of an unspecified type.</p></li>
</ul>
</div>
<span class="comment-copy">Yes, <code>create_task</code> is at least a much better name, but it was added only recently and is not available in 3.6.</span>
<span class="comment-copy">@VPfB That is true for <code>asyncio.create_task</code>, a shorthand for <code>get_event_loop().create_task(...)</code>. However, the <code>create_task</code> <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_task" rel="nofollow noreferrer">method</a> on the event loop has been there since the beginning.</span>
<span class="comment-copy">Thank you for answering my question and adding precise information about <code>create_task</code></span>
