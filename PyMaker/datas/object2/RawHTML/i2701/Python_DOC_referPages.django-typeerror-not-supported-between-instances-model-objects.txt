<div class="post-text" itemprop="text">
<p>I'm trying to migrate my Django project from Python 2.7/Django 1.11 to Python 3.7/Django 2.1.</p>
<p>I've found one issue and I want to understand its cause.</p>
<p>I have 3 models in my project:</p>
<pre><code>class DeviceModel(models.Model):
    name = models.CharField(max_length=255)
    pirsh = models.CharField(max_length=255)

    def __str__(self):
        return self.name + " - " + self.pirsh

class Device(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    device_model = models.ForeignKey(DeviceModel, on_delete=models.CASCADE)
    serial_number = models.CharField(max_length=255)


    def __str__(self):
        return self.device_model.name + " - " + self.device_model.pirsh + " - " \
                + self.serial_number

class DeviceTest(models.Model):
    device = models.ForeignKey(Device, on_delete=models.CASCADE)
    created_at = models.DateTimeField()

    TEST_OK = '+'
    TEST_ERROR = '-'
    TEST_PENDING = '?'
    TEST_RESULT_CHOICES = (
        (TEST_OK, 'Success'),
        (TEST_ERROR, 'Fail'),
        (TEST_PENDING, 'Not checked'),
    )
    status = models.CharField(max_length=1, choices=TEST_RESULT_CHOICES, default=TEST_PENDING)

    comment = models.TextField(blank=True, default="")
    tester = models.CharField(max_length=255)
    action = models.CharField(max_length=255)

    def save(self, *args, **kwargs):
        ''' On save, update timestamps '''
        if not self.created_at:
            self.created_at = timezone.now()
        return super(DeviceTest, self).save(*args, **kwargs)

    def __str__(self):
        return  self.device_id.device_model.name + " - " + \
                self.device_id.device_model.pirsh + " - " + \
                self.device_id.serial_number + " - " + \
                str(self.created_at) + " - " + \
                "Result (" + self.status + ")"
</code></pre>
<p>And this is my code to sort <code>Device</code> objects by latest test status ('dev_filter', 'field' and 'order' parameters are parsed from GET request):</p>
<pre><code>if (dev_filter!="") and (dev_filter!="-1"):
    device_list = Device.objects.all().filter(device_model = dev_filter)
else:
    device_list = Device.objects.all()

dev_status_list = []
for dev in device_list:
    try:
        dev_status_list.append(DeviceTest.objects.filter(device_id=dev.pk).latest('created_at').status)
    except:
        dev_status_list.append("Not checked")

device_list = [device_list for (dev_status_list, device_list) in sorted(zip(dev_status_list, device_list))]

if (order == '-'):
    device_list.reverse()
</code></pre>
<p>This code worked fine in Python 2.7/Django 1.11 but it doesn't in Python 3.7/Django 2.1</p>
<p>Django marks as error <code>sorted(zip(dev_status_list, device_list))</code> function:</p>
<pre><code>TypeError: '&lt;' not supported between instances of 'Device' and 'Device'
</code></pre>
<p>I see two solutions to this problem: either use</p>
<pre><code>device_list = [device_list for (dev_status_list, device_list) in sorted(zip(dev_status_list, device_list), key=lambda x: (x[0],x[1].__str__()))]
</code></pre>
<p>or add <code>__lt__</code> method to <code>Device</code> model:</p>
<pre><code>def __lt__(self, other):
    return self.__str__() &lt; other.__str__()
</code></pre>
<p>My question is - what is changed? Does this error happen because of Python upgrade or Django upgrade? What was default sorting method in Python 2.7/Django 1.11 framework for <code>Device</code> objects? Am I correct that it was string representation? And which of my solutions is preferred?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 introduces new <a href="https://docs.python.org/3.0/whatsnew/3.0.html#ordering-comparisons" rel="nofollow noreferrer">ordering comparison</a>:</p>
<blockquote>
<p>The ordering comparison operators (&lt;, &lt;=, &gt;=, &gt;) raise a <strong>TypeError</strong> exception when the operands don’t have a meaningful natural ordering.</p>
</blockquote>
<p>A simple example which prints <code>True</code> in Python2 and raises a <code>TypeError</code> in Python3</p>
<pre><code>class A:
    pass

print(A() &lt; A())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason is because <em>Python 3 has simplified the <a href="https://docs.python.org/3/whatsnew/3.0.html#ordering-comparisons" rel="nofollow noreferrer">rules for ordering</a> comparisons which changes the behavior of sorting lists when their contents are dictionaries.</em><br/>
The ordering comparison operators (&lt;, &lt;=, &gt;=, &gt;) raise a TypeError exception when the operands don’t have a meaningful natural ordering</p>
<p>Also there is another interesting example</p>
<p>Quoting the example from the mentioned <a href="http://atodorov.org/blog/2016/08/05/python-2-vs-python-3-list-sort-causes-bugs/" rel="nofollow noreferrer">in this link</a></p>
<p><strong>Python 2.7</strong></p>
<pre><code>&gt;&gt;&gt; [{'a':1}, {'b':2}] &lt; [{'a':1}, {'b':2, 'c':3}]
True
</code></pre>
<p><strong>Python 3.5</strong></p>
<pre><code>&gt;&gt;&gt; [{'a':1}, {'b':2}] &lt; [{'a':1}, {'b':2, 'c':3}]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: dict() &lt; dict()
</code></pre>
<blockquote>
<p>The problem is that the second elements in both lists have different
  keys and Python doesn't know how to compare them. In earlier Python
  versions this has been special cased as <a href="https://stackoverflow.com/questions/3484293/is-there-a-description-of-how-cmp-works-for-dict-objects-in-python-2/3484456#3484456">described here</a> by Ned
  Batchelder (the author of Python's coverage tool) but in Python 3
  dictionaries have no natural sort order.</p>
</blockquote>
<p>You can read more about the problem <a href="http://atodorov.org/blog/2016/08/05/python-2-vs-python-3-list-sort-causes-bugs/" rel="nofollow noreferrer">here</a>.</p>
</div>
<span class="comment-copy">You can use an annotate here, and sort on the status by the database.</span>
<span class="comment-copy">Your code is broken in Python2. It does not really "sort" the elements... the elements were ordered by id, which basically means randomly. Define a proper <code>__lt__</code> method if <code>Device</code> has a natural sorting order. If <code>Device</code> has no single-natural ordering (because there are more sensible ways to order it "naturally") then you might consider adding some <code>@classmethod</code>s that do the various orderings (and maybe choose a default one used for <code>__lt__</code>). In this way you can then do <code>sorted(..., key=Device.sort_by_&lt;something&gt;)</code></span>
<span class="comment-copy">There are several problems here. First is that you should not fetch the data and sort it in django. The database is far better equipped to handle it there. Secondly looping and querying leads to very very poor performance, you should be using joins instead for that. Instead of trying to do a 1:1 translation of this code, you will be better off re writing it.</span>
<span class="comment-copy">@WillemVanOnsem how can I annotate objects with latest test status? I only know how to annotate objects with latest lest time. If you know, please check my question <a href="https://stackoverflow.com/questions/32611275/django-database-sorting-by-field-in-latest-object-in-relative-database" title="django database sorting by field in latest object in relative database">stackoverflow.com/questions/32611275/…</a></span>
<span class="comment-copy">@e4c5 I'm aware about poor performance of this code. Could you point me in right direction to rewrite it? I've asked a question about how this sorting should be done long time ago <a href="https://stackoverflow.com/questions/32611275/django-database-sorting-by-field-in-latest-object-in-relative-database" title="django database sorting by field in latest object in relative database">stackoverflow.com/questions/32611275/…</a></span>
<span class="comment-copy">And based on what parameter Python 2 will sort these objects?</span>
<span class="comment-copy">The docs state that <a href="https://docs.python.org/2/reference/expressions.html#value-comparisons" rel="nofollow noreferrer">default ordering comparison</a> gives a consistent but <b>arbitrary order</b>.</span>
<span class="comment-copy">This is not the case, in python 3: <code>dict(a=3) &lt; dict(a=3)</code> also crashes. See @ikkuh's answer for the reason.</span>
<span class="comment-copy">Right. My answer is partial correct. I will update it.</span>
