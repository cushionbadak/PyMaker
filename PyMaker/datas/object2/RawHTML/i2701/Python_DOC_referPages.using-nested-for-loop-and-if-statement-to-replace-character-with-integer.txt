<div class="post-text" itemprop="text">
<p>I need to output any repeated character to refer to the previous character. </p>
<p>For example: <code>a(-1)rdv(-4)(-4)k</code> or <code>hel(-1)o</code></p>
<p>This is my code so far:</p>
<pre><code>text= 'aardvark'
i=0
j=0
for i in range(len(text)-1):
    for j in range(i+1, len(text)):
        if text[j]==text[i]:
            sub= text[j]
            val2=text.find(sub, i+1, len(text))
            p=val2+1
            val=str(i-j)
            text= text[:val2] + val + text[p:] 
            break
print(text)
</code></pre>
<p>Output: <code>a-1rdva-4k</code></p>
<p>The second <code>'a'</code> is not recognised. And I'm not sure how to include brackets in my print.</p>
</div>
<div class="post-text" itemprop="text">
<p>By updating the text in-place each time you find a back-reference, you muck up your indices (your text gets longer each time) and you never process the last characters properly. You <em>stop</em> checking when you find the first repeat of the 'current' character, so the 3rd <code>a</code> is never processed. This applies to every 3rd repeat in an input string.  In addition, if your input text contains any <code>-</code> characters or digits they'll end up being tested against the <code>-offset</code> references you inserted before them too!</p>
<p>For your specific example of <code>aardvark</code>, a string with 8 characters, what happens is this:</p>
<ul>
<li><p>You find the second <code>a</code> and set <code>text</code> to <code>a-1rdvark</code>. The text is now 9 characters long, so the last <code>r</code> will never be checked (you loop to <code>i = 6</code> at most); this would be a problem if your test string ended in a double letter. You break out of the loop, so the <code>j</code> <code>for</code> loop never comes to the 3rd <code>a</code>, and the second <code>a</code> can't be tested for anymore as it has already been replaced.</p></li>
<li><p>Your code finds <code>-</code> (not repeated), <code>1</code> (not repeated) and then <code>r</code> (repeated once), so now you replace <code>text</code> with <code>a-1rdva-4k</code>. Now you have a string of 10 characters, so <code>-</code>, and <code>4</code> will never be tested. Not a big problem anymore, but what if there was a repeat in just the last 3 positions of the string?</p></li>
</ul>
<p>Build a <em>new</em> object for the output (adding both letters you haven't seen before and backreferences). That way you won't cause the text you are looping over to grow, and you will continue to find repeats; for the parentheses you could use more string concatenation. You'll need to scan the part of the string <em>before</em> <code>i</code>, not after, for this to work, and go backwards! Testing <code>i - 1</code>, <code>i - 2</code>, etc, down to 0. Naturally, this means your <code>i</code> loop should then range up to the full length:</p>
<pre><code>output = ''

for i in range(len(text)):
    current = text[i]
    for j in range(i - 1, -1, -1):
        if text[j] == current:
            current = '(' + str(j - i) + ')'
            break  
    output = output + current

print(output)
</code></pre>
<p>I kept the fix to a minimum here, but ideally I'd also make some more changes:</p>
<ul>
<li><p>Add all processed characters and references to a new <em>list</em> instead of a string, then use <code>str.join()</code> to join that list into the output afterwards. This is far more efficient than rebuilding the string each iteration.</p></li>
<li><p>Using two loops means you check every character in the string again while looping over the text, so the number of steps the algorithm takes grows exponentially with the length of the input. In Computer Science we talk about the time complexity of algorithms, and yours is a O(N^2) (N squared) <em>exponential</em> algorithm. A text with 1000 letters would take up to 1 million steps to process! Rather than loop an exponential number of times, you can use a <em>dictionary</em> to track indices of letters you have seen. If the <em>current</em> character is in the dictionary you can then trivially calculate the offset. Dictionary lookups take constant time (O(1)), making the whole algorithm take <em>linear</em> time (O(N)), meaning that the time the process takes is directly proportional to the length of the input string.</p></li>
<li><p>Use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate()</code></a> to add a counter to the loop so you can just loop over the characters directly, no need to use <code>range()</code>.</p></li>
<li><p>You can use string formatting to build a <code>"(&lt;offset&gt;)"</code> string; Python 3.6 and newer have <a href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings" rel="nofollow noreferrer">formatted string literals</a>, where <code>f'...'</code> strings take <code>{}</code> placeholders that are just expressions. <code>f'({some - calculation + or * other})' will execute the expression and put the result in a string that has</code>(<code>and</code>)<code>characters in it too. For earlier Python versions, you can use the [</code>str.format()<code>method](https://docs.python.org/3/library/stdtypes.html#str.format) to get the same result; the syntax then becomes</code>'({})'.format(some - calculation + or * other)`.</p></li>
</ul>
<p>Put together, that becomes:</p>
<pre><code>def add_backrefs(text):
    output = []
    seen = {}
    for i, character in enumerate(text):
        if character in seen:
            # add a back-reference, we have seen this already
            output.append(f'({seen[character] - i})')
        else:
            # add the literal character instead
            output.append(character)
        # record the position of this character for later reference
        seen[character] = i
    return ''.join(output)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; add_backrefs('aardvark')
'a(-1)rdv(-4)(-4)k'
&gt;&gt;&gt; add_backrefs('hello')
'hel(-1)o'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>text= 'aardvark'
d={}  # create a dictionary to keep track of index of element last seen at
new_text=''  # new text to be generated
for i in range(len(text)):  # iterate in text from index 0 up to length of text
    c = text[i]  # storing a character in temporary element as used frequently 
    if c not in d:  # check if character which is explored is visited before or not
        d[c] = i  # if character visited first time then just add index value of it in dictionary
        new_text += c  # concatenate character to result text
    else:  # visiting alreaady visited character
        new_text += '({0})'.format(d[c]-i)  # used string formatting which will print value of difference of last seen repeated character with current index instead of {0}
        d[c] = i  # change last seen character index
print(new_text)
</code></pre>
<p>Output:</p>
<pre><code>a(-1)rdv(-4)(-4)k
</code></pre>
</div>
<span class="comment-copy">Why is it <code>(-4)</code> for the 3rd a and not <code>(-5)</code>? Should the previous position be referenced and not the first?</span>
<span class="comment-copy">The previous repeating letter must be referred to.  In aardvark the last a should be referred to the second a (previous instance of letter)</span>
<span class="comment-copy">Check, thanks for confirming!</span>
<span class="comment-copy">@MartijnPieters The python version is not specified in question, and many are not aware with f string which only support for python3.6 and above (beginner might need a explanation or compatible answer!!)</span>
<span class="comment-copy">I'm a few weeks into coding and in my subject we haven't covered the above. We use nested for loops, if, else etc. basics. I'm not sure of the version as it is an inbuilt uni environment that we work on.</span>
<span class="comment-copy">@MartijnPieters This is exactly the better solution I had in mind. Good job</span>
<span class="comment-copy">@RaquelBisogno: I've included a more detailed explanation of where you went wrong. Does that help you figure it out a bit more?</span>
<span class="comment-copy">@RaquelBisogno: and I now added a fixed 'simple' version for you that further explains how a double-loop version can be made to work.</span>
