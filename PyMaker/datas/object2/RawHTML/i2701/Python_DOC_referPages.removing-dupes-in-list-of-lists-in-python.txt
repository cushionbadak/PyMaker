<div class="post-text" itemprop="text">
<p>Basically, I'm trying to do remove any lists that begin with the same value. For example, two of the below begin with the number 1:</p>
<pre><code>a = [[1,2],[1,0],[2,4],[3,5]]
</code></pre>
<p>Because the value 1 exists at the start of two of the lists -- I need to remove both so that the new list becomes:</p>
<pre><code>b = [[2,4],[3,5]]
</code></pre>
<p>How can I do this?</p>
<p>I've tried the below, but the output is: <code>[[1, 2], [2, 4], [3, 5]]</code></p>
<pre><code>def unique_by_first_n(n, coll):
    seen = set()
    for item in coll:
        compare = tuple(item[:n])
        print compare   # Keep only the first `n` elements in the set
        if compare not in seen:
            seen.add(compare)
            yield item

a = [[1,2],[1,0],[2,4],[3,5]]

filtered_list = list(unique_by_first_n(1, a))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>collections.Counter</code> with list comprehension to get sublists whose first item appears only once:</p>
<pre><code>from collections import Counter
c = Counter(n for n, _ in a)
b = [[x, y] for x, y in a if c[x] == 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An efficient solution would be to create a <a href="https://docs.python.org/3/library/collections.html?highlight=namedtuple#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> object to hold the occurrences of the first elements, and then filter the sub-lists in the main list:</p>
<pre><code>from collections import Counter
counts = Counter(l[0] for l in a)
filtered = [l for l in a if counts[l[0]] == 1]
#[[2, 4], [3, 5]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are happy to use a 3rd party library, you can use Pandas:</p>
<pre><code>import pandas as pd

a = [[1,2],[1,0],[2,4],[3,5]]

df = pd.DataFrame(a)
b = df.drop_duplicates(subset=[0], keep=False).values.tolist()

print(b)

[[2, 4], [3, 5]]
</code></pre>
<p>The trick is the <code>keep=False</code> argument, described in the docs for <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.drop_duplicates.html" rel="noreferrer"><code>pd.DataFrame.drop_duplicates</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Solution 1</strong></p>
<pre><code>a = [[1,2],[1,0],[2,4],[3,5]]
b = []
for item in a:
    i = 0
    if item[0] == a[i][0]:
        i =+ 1
        continue
    else:
        b.append(item)
        i += 1
</code></pre>
<p><strong>Solution 2</strong></p>
<pre><code>a = [[1,2],[1,0],[2,4],[3,5]]
b = []

for item in a:
    for i in range(0, len(a)):
        if item[0] == a[i][0]:
            break
        else:
            if item in b:
                continue
            else:
                b.append(item)
</code></pre>
<p><strong>Output</strong></p>
<blockquote>
<pre><code>(xenial)vash@localhost:~/pcc/10$ python3 remove_help.py 
[[1, 2], [1, 0], [2, 4], [3, 5]]
[[2, 4], [3, 5]]
</code></pre>
</blockquote>
<p>Achieved your goal no complex methods involed!
Enjoy!</p>
</div>
<span class="comment-copy">2 also exists in both. Why don't you remove them?</span>
<span class="comment-copy">good point -- i only need to remove where the first item is the same. so just the 1 in this case</span>
<span class="comment-copy">that sounds overcomplicated</span>
<span class="comment-copy">@Jean-FrançoisFabre its basically <code>[[x,y] for key, counterValue in counterItems if counterValue == 1 for x, y in my_list if x == key]</code></span>
<span class="comment-copy">what annoys me is the double loop. The other answer has less O complexity (and also your rewrite with new variable names is clearer)</span>
<span class="comment-copy">@Jean-FrançoisFabre Indeed thanks. I've fixed my answer accordingly, although it is now admittedly the same as Joe's answer.</span>
<span class="comment-copy">since it seems to be the best way, I don't see a problem. I just didn't want people copy an unefficient answer (even if it worked).</span>
<span class="comment-copy"><code>filtered = [l for l in a if counts[l[0]] == 1]</code> is probably clearer but yes.</span>
<span class="comment-copy">@Jean-FrançoisFabre Fair enough. Do you understand the logic in blhsing's answer? It certainly doesn't guarantee the order of the list is maintained.</span>
<span class="comment-copy">no I don't but I see a loop which makes the solution overcomplex</span>
<span class="comment-copy">I never used pandas, always did things like that manually, like the other answers but THIS is another level of readability -&gt; sparked my interest in the library -&gt; have a +1</span>
<span class="comment-copy">@FabianN., I certainly don't recommend Pandas as a means of <i>learning</i>, but vectorised operations do have their use. And I would be disappointed to make people believe Python <code>list</code> + <code>dict</code> are the only way to structure data!</span>
<span class="comment-copy">never used pandas myself, but I'm pretty sure it beats the pure python answers in terms of speed (well, don't count the <code>import pandas</code> part obviously :)</span>
<span class="comment-copy">@FabianN. You should also checkout <code>numpy</code> - very fast, especially on large data sets like when image processing.</span>
<span class="comment-copy">@JoeIddon I'm aware of numpy, I think that's the main reason I always ignored pandas. For simple things, I just used native python and for vectorized operations I used numpy so I never felt it was worth the effort to put even more layers on top... but from what I see above, with pandas, one can write code that's almost a sentence.</span>
