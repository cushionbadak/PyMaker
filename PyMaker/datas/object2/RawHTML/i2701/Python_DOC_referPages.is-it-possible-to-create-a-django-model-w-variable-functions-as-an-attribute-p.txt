<div class="post-text" itemprop="text">
<p>I'm creating an app. that will generate math problems. They're specific problems where some parameters can be altered. Each problem will be different, and require a different method to solve (all of which will be programatically implemented).</p>
<p>For example:
<strong>models.py</strong></p>
<pre><code>import random
from django.db import models

class Problem(models.Model):
    unformattedText = models.TextField()

    def __init__(self, unformattedText, genFunction, *args, **kwargs):
        super(Problem, self).__init__(*args, **kwargs)
        self.unformatedText = unformattedText
        self.genFunction = genFunction

    def genQAPair():
        self.genFunction(self.unformattedText)
</code></pre>
<p><strong>views.py</strong></p>
<pre><code>def genP1(text):
    num_1 = random.randrange(0, 100)
    num_2 = random.randrange(0, 100)
    text.format((num_1, num_2))
    return {'question':text, 'answer':num_1 - num_2}

def genP2(text, lim=4):
    num_1 = random.randrange(0, lim)
    text.format(num_1)
    return {'question':text, 'answer':num_1*40}


p1 = Problem(
        unformattedText='Sally has {} apples. Frank takes {}. How many apples does Sally have?',
        genFunction=genP1
)
p1.save()

p2 = Problem(
        unformattedText='John jumps {} feet into the air. How long does it take for him to age?',
        genFunction=genP2
)
p2.save()
</code></pre>
<p>When I try this, the function isn't actually saved. Django just saves the integer <code>1</code>. When I initiate an instance of the model, the function is there as intended, but apparently only <code>1</code> is saved to the database.</p>
<p>Bonus question: I'm actually beginning to question whether or not I even need Django models for this. I'm using Django because it's super easy to get everything onto a webpage. Is there a better way to do this? (Maybe store the text of each problem in a JSON file and the generating functions in some separate script.)</p>
</div>
<div class="post-text" itemprop="text">
<p>The persistence layer for a Django application is the database, and the database schema is specified by your model definitions. In this case you've only defined a single field in your model, <code>unformattedText</code>; you haven't specified any storage for the corresponding function. Your <code>self.genFunction = genFunction</code> is just creating an attribute on an object in memory; it won't be persisted.</p>
<p>There are various possible ways to store the function. You could store it as raw text; you could store it as a <code>pickle</code> blob; you could store the function path and name (e.g. <code>"my.path.to.problems.genP1"</code>); or do something else. In any case, you'll need to create a database field for that information.</p>
<p>Here is a rough outline of an example solution using the function path:</p>
<p><strong>models.py</strong></p>
<pre><code>class Problem(models.Model):
    unformattedText = models.TextField()
    genPath = models.TextField()
</code></pre>
<p><strong>views.py</strong></p>
<pre><code>import importlib

def problem_view(request, problem_id):
    problem = Problem.objects.get(id=problem_id)
    gen_path, gen_name = problem.genPath.rsplit(".", 1)
    gen_module = importlib.import_module(gen_path)
    gen_function = getattr(gen_module, gen_name)

    context = gen_function(problem.unformattedText)
    return render(request, 'template.html', context)
</code></pre>
<p>Only you can determine if you need to use a database at all. If you only have a few fixed questions then you could just stuff everything into a Python file and be done with it. But there are advantages to using Django's models, including the ability to use the admin.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of options, depending on the actual task. I ranged them starting with the most safe option to the most dangerous (but flexible):</p>
<h2>1. Store function identifiers:</h2>
<p>You can store <code>genP1</code> and <code>genP2</code> as <code>'genP1'</code> and <code>'genP2'</code> - i.e. by name (or you can use any other unique identifier). </p>
<p>Pros:</p>
<ol>
<li>You can validate user input and execute trusted code only, because in this case you control almost everything.</li>
<li>You can easily debug your functions, because they are part of your system.</li>
</ol>
<p>Cons:</p>
<ol>
<li>You need to define all your functions in the code. That means if you want to add new function, you need to redeploy your application.</li>
<li>If you are storing function names, you need to manually import module (or package) with the functions and call them.</li>
<li>If you are storing identifiers, you need to define a mapping <code>{identifier: path to actual function}</code>.</li>
</ol>
<h2>2. Use DSL</h2>
<p>You can write your own DSL (or use existing)</p>
<p>Pros:</p>
<ol>
<li>You can add new functions at runtime without redeploying application.</li>
<li>You can control which code can user execute.</li>
<li>You can see source code for your functions.</li>
</ol>
<p>Cons:</p>
<ol>
<li>It is hard to write safe and flexible DSL, especially if you want to call some python code from it. </li>
<li>It is hard to debug huge functions.</li>
</ol>
<h2>3. Serialize them</h2>
<p>You can serialize functions using <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer">pickle</a></p>
<p>Pros:</p>
<ol>
<li>You can add new functions at runtime without redeploying application.</li>
<li>Easier than writing own DSL.</li>
</ol>
<p>Cons:</p>
<ol>
<li><strong>Unsafe</strong> - you must not execute untrusted code. If you allow users to create their own functions, serialization is not your way - define (or use existing) safe DSL instead.</li>
<li>It might be impossible to show source python code for the serialized function. For more information: <a href="https://stackoverflow.com/questions/427453/how-can-i-get-the-source-code-of-a-python-function">How can I get the source code of a Python function?</a></li>
<li>It is hard to debug huge functions.</li>
</ol>
<h2>4. Just store actual Python code</h2>
<p>Just store the python source code in the DB as a string.</p>
<p>Pros:</p>
<ol>
<li>You can add new functions at runtime without redeploying application.</li>
<li>You can see source code without any additional processing.</li>
<li>Easier than writing own DSL.</li>
</ol>
<p>Cons:</p>
<ol>
<li><strong>Unsafe</strong> - you must not execute untrusted code. If you allow users to create their own functions, storing source code is not your way - define (or use existing) safe DSL instead.</li>
<li>It is hard to debug huge functions.</li>
</ol>
</div>
