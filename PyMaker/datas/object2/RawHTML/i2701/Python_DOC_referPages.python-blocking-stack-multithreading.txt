<div class="post-text" itemprop="text">
<p>I am learning multithreading in python, what I am trying to achieve is a stack class that append(v) wait until size is not full, and a pop() wait until stack is not empty. My implementation is as follows, does it seems correct?</p>
<pre><code>import threading
class BlockingStack(object):
    def __init__(self,max_size=1000):
        self.max_size = max_size
        self.stack = []
        self.notifynonempty = threading.Condition()
        self.notifynotfull = threading.Condition()

    def append(self,v):
        self.notifynonempty.acquire()
        while len(self.stack) == self.max_size:
            self.notifynotfull.wait()
        self.stack.append(v)
        if len(self.stack) == 1:
            self.notifynonempty.notify()
        self.notifynonempty.release()

    def pop(self):
        self.notifynotfull.acquire()
        while len(self.stack) == 0:
            self.notifynonempty.wait()
        v = self.stack.pop()
        if len(self.stack)==self.max_size - 1:
            self.notifynotfull.notify()
        self.notifynotfull.release()
        return v
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first problem in your <code>append</code> here:</p>
<pre><code>self.notifynonempty.acquire()
</code></pre>
<p>Never <code>acquire</code> a condition and hold it when you're going to block on another sync object, or you're going to deadlock. Move this until after the other condition's <code>wait</code> has succeeded.</p>
<hr/>
<p>Next:</p>
<pre><code>while len(self.stack) == self.max_size:
    self.notifynotfull.wait()
</code></pre>
<p>Trying to <code>wait</code> on a condition that you haven't acquired is a race that's roughly equivalent to not having a condition in the first place. You need to <code>acquire</code> this condition before the loop.</p>
<hr/>
<p>Also, if there's an exception anywhere, you're going to leak locks, which will deadlock your program. You <em>can</em> fix this with careful <code>try</code>/<code>finally</code> work, but it's much simpler to just use a <code>with</code> statement, as shown in the docs.</p>
<hr/>
<p>So:</p>
<pre><code>with self.notifynonfull:
    while len(self.stack) == self.max_size:
        self.notifynotfull.wait()
    with self.notifynonempty:
        self.stack.append(v)
        if len(self.stack) == 1:
            self.notifynonempty.notify()
</code></pre>
<p>The issues with <code>pop</code> are the same in reverse.</p>
<hr/>
<p>However, for most usage patterns, it's going to be more efficient to make both conditions share the same mutex, like this:</p>
<pre><code>self.mutex = threading.Lock()
self.notifynonempty = threading.Condition(self.mutex)
self.notifynotfull = threading.Condition(self.mutex)
</code></pre>
<p>â€¦ and that also makes things simpler.</p>
<p>Plus, the check before the <code>notify()</code> isn't necessary. It <em>will</em> probably make things more efficient for certain cases (only a single producer, or only a single consumer), but it may make other cases slower, and it makes things more complicated, and also makes races harder to detect during debugging. So, I'd leave it off for now. Once you have everything working, write some benchmarks with whatever you actual usage patterns are and test it both ways (and with just the append-check and with just the pop-check, of course).</p>
<pre><code>def append(self, v):
    with self.notifynonfull:
        while len(self.stack) == self.max_size:
            self.notifynotfull.wait()
        self.stack.append(v)
        self.notifynonempty.notify()

def pop(self):
    with self.notifynonempty:
        while len(self.stack) == 0:
            self.notifynonempty.wait()
        v = self.stack.pop()
        self.notifynotfull.notify()
        return v
</code></pre>
<hr/>
<p>As a side note, if you're not doing this to learn about conditions, but just because you need a self-synchronizing stack, <a href="https://docs.python.org/3/library/queue.html#queue.LifoQueue" rel="nofollow noreferrer"><code>queue.LifoQueue</code></a> already provides that.</p>
<p>And, even if it didn't, you could write it like this:</p>
<pre><code>import queue

class Stack(queue.Queue):
    def _init(self, maxsize):
        self.queue = []
    def _qsize(self):
        return len(self.queue)
    def _put(self, item):
        self.queue.append(item)
    def _get(self):
        return self.queue.pop()
</code></pre>
<p>For that matter, now that I think about it, the <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer"><code>queue</code></a> docs link to <a href="https://github.com/python/cpython/blob/3.7/Lib/queue.py" rel="nofollow noreferrer">the source</a>, which should provide solid example code. It's a bit more complicated than you need, what with all the block-vs.-try-vs.-timeout options, and the whole <code>task_done</code>/<code>join</code> feature, but it's still pretty clear and readable.</p>
</div>
<span class="comment-copy">Thanks for the answer, I have another question here, when notifynonempty and notifynonfull is using same underlying lock object. would it be a deadlock if we call pop() when it's empty, then another thread call append()?</span>
<span class="comment-copy">I think I get the answer from python doc, wait method release the underlying lock</span>
<span class="comment-copy">@DDD Yes, <code>wait</code> releases the underlying lock, and then reaquires it upon waking up (or timing out). So, you have to have acquired the underlying lock before waiting. (Also, it's important that release-and-sleep and wake-and-acquire are atomic; that's why you can't just use an Event in place of a Condition.)</span>
