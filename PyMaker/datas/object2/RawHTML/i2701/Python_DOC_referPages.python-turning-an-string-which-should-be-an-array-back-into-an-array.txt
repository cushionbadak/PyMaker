<div class="post-text" itemprop="text">
<p>I have a string which should be a 3x3x3 array. Just looking for an easy way to convert this back to its 'truth' so i can access the values. It is Newline, [ ] and what i thought were tabs but are either 7 or 6 spaces.... separated. </p>
<p>I saved an array into a pandas DataFrame thinking it would work but gave me this:</p>
<pre><code>'[[[      nan       nan       nan]\n  [      nan       nan      
nan]\n  [      nan       nan       nan]]\n\n [[ 0.005506  0.005506    
nan]\n  [ 0.006684       nan       nan]\n  [ 0.006684       nan      
nan]]\n\n [[      nan       nan       nan]\n  [      nan       nan    
nan]\n  [      nan       nan       nan]]]'
</code></pre>
<p>I have tried <code>.split('\n')</code> and various other separators and combinations with little success.</p>
<p>Looking for array (#'s just example):</p>
<pre><code>x = [[[0,0,0],[0,0,0],[0,0,0]],[[1,1,1],[1,1,1],[1,1,1]],[[2,2,2],[2,2,2],[2,2,2]]]
</code></pre>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>A rare use for <code>eval()</code>:</p>
<pre><code>s = '[[[0,0,0],[0,0,0],[0,0,0]],[[1,1,1],[1,1,1],[1,1,1]],[[2,2,2],[2,2,2],[2,2,2]]]'
x = eval(s)
print(x) #[[[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[1, 1, 1], [1, 1, 1], [1, 1, 1]], [[2, 2, 2], [2, 2, 2], [2, 2, 2]]]
</code></pre>
<p>EDIT: as pointed out eval is insufficient for what you're asking.  What I eventually got working was built off json and numpy</p>
<pre><code>s = '''[[[ nan nan nan]\n [ nan nan\nnan]\n [ nan nan nan]]\n\n [[ 0.005506 0.005506\nnan]\n [ 0.006684 nan nan]\n [ 0.006684 nan\nnan]]\n\n [[ nan nan nan]\n [ nan nan\nnan]\n [ nan nan nan]]]'''

import numpy, json
x = numpy.array(json.loads(','.join(s.split()).replace('[,','[').replace('nan','NaN')))

print(x)

#array([[[      nan,       nan,       nan],
#        [      nan,       nan,       nan],
#        [      nan,       nan,       nan]],
#       [[ 0.005506,  0.005506,       nan],
#        [ 0.006684,       nan,       nan],
#        [ 0.006684,       nan,       nan]],
#       [[      nan,       nan,       nan],
#        [      nan,       nan,       nan],
#        [      nan,       nan,       nan]]])
</code></pre>
<p>You can easily replace <code>numpy.array()</code> with <code>pandas.DataFrame()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try using the <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">json library</a> included in Python.<br/>
Specifically you would need to use the <a href="https://docs.python.org/3/library/json.html#json.loads" rel="nofollow noreferrer"><code>json.loads()</code></a> function. Remember to still split the string with <code>\n</code> using the <code>str.split()</code></p>
<p>Here's an example on how you would use it:</p>
<pre><code>import json
json.loads('[[0,1,0],[0,0,0]]')
</code></pre>
</div>
<span class="comment-copy">This is a tiny array with only 4 non-nan values, and apparently you want to change the nan values to 0 anyway… it's probably easier to just create it again from scratch. And meanwhile, don't try to save arrays this way again; use functions like <code>savetxt</code>, <code>save</code>, tobuffer`, etc.</span>
<span class="comment-copy">I am saving several thousand of these to part of an existing pandas df, some have more or less non-nans. This was just an example.</span>
<span class="comment-copy">Then the solution is to stop saving thousands of files in a format you don't know how to parse, and instead save them in a format that's easy to parse.</span>
<span class="comment-copy">I did a test where a=pd.DataFrame({'test':[]}),a=a.append({'test':x},ignore_index=True) which seemed to work fine for my purposes however after running my whole script something obviously broke. Just trying to keep it all organised in one file.</span>
<span class="comment-copy">My Issue was that I was saving my Pandas DF including several numpy array of arrays as pd.to_csv which was flattening them into strings rather than pd.to_pickle which saves it as is. Thanks for your help! The problem hopefully doesn't exist anymore :)</span>
<span class="comment-copy"><code>literal_eval</code> would do just as well here. And neither one is going to work for the OP's actual input, because <code>nan</code> will just raise a <code>NameError</code>. (Although you can go out of your way to do something like <code>nan=np.nan; x = eval(s); del nan</code>, that seems pretty silly…) Plus, this gives him a list of lists, not a numpy array.</span>
<span class="comment-copy">Ahh Fantastic! Not the optimal solution due to the fact I need to do something earlier in the pipeline. Thanks for the help. This is great while I debug the true problem.</span>
<span class="comment-copy">Even in that case, eval is not safe. Who knows what could lurk into that file.</span>
<span class="comment-copy">Sure if you're working on some kind of production database that other people are relying on, but the risk of eval for this kind of use is typically massively overstated.  Anyone who could realistically put something malicious in likely already has access to the computer directly.</span>
<span class="comment-copy">@Turksarama It's not so much about malicious content. It's rather about the fact that format bugs are very common, they usually happen, raise an exception and require someone to manually fix the database. Relying on an eval may cause some side effects before the exception is raised. The bottom line is that the risk is very small, but the consequence can be big and thus eval should not be used whenever there is a safer option available.</span>
<span class="comment-copy">Why split the string? The OP wants one array, not a bunch of them, and none of the lines in that array are valid JSON on their own. And  <code>json.loads([\n[0,1,\n0]\n,[0,0\n0]]'</code> is going to give you the same result as your example.</span>
