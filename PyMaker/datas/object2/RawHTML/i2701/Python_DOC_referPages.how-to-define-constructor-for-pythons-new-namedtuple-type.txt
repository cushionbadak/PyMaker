<div class="post-text" itemprop="text">
<p>As you may know, this is most recent type of defining named tuples in python:</p>
<pre><code>from typing import NamedTuple


class MyType(NamedTuple):
    id: int = 0
    name: str = 0
</code></pre>
<p>After defining the type, Python interpreter defines a default constructor getting id and name and you can instantiate a new object using your fields.
Now I want to initialise a new object using a string and within the function I parse it. How can I define another constructor without spoiling the good default ones?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How can I define another constructor without spoiling the good default ones?</p>
</blockquote>
<p>You can't. Python classes can't have multiple <code>__new__</code> methods (or, if you meant "initializer", <code>__init__</code> methods), just one.</p>
<hr/>
<p>But there's an easy way to work around this: the <em>alternate constructor idiom</em>: you write a <code>@classmethod</code> that provides an alternate way to construct instances. There are plenty of examples in the standard library, like <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.now" rel="nofollow noreferrer"><code>datetime.now</code></a> and <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.utcfromtimestamp" rel="nofollow noreferrer"><code>datetime.utcfromtimestamp</code></a>. There are even a few examples in the basic builtin types, like <a href="https://docs.python.org/3/library/stdtypes.html#int.from_bytes" rel="nofollow noreferrer"><code>int.from_bytes</code></a>.</p>
<p>Here's how that works:</p>
<pre><code>class MyType(NamedTuple):
    id: int = 0
    name: str = 0

    @classmethod
    def from_string(cls, string_to_parse):
        id, name = … your parsing code here …
        return cls(id, name)
</code></pre>
<p>This is, of course, the same thing you'd do with a <code>collections.namedtuple</code> subclass, a <code>@dataclass</code>, or a plain-old class that had too many different ways to construct it.</p>
<hr/>
<p>If you really want to, the other way to do it is to provide an ugly constructor with either keyword-only parameters, or parameters that have different meanings depending on what you pass. With <code>NamedTuple</code>, you'll have to either insert an extra class in the way, or monkeypatch the class after creation, because otherwise there's no documented way of getting at the default constructor implementation.</p>
<p>So:</p>
<pre><code>class _MyType(NamedTuple):
    id: int = 0
    name: str = 0

class MyType(_MyType):
    def __new__(cls, id: int=None, name: str=None, *, parseything: str=None):
        if parseything:
            if id is not None or str is not None:
                raise TypeError("don't provide both")
            id, name = … your parsing code here …
        return super().__new__(cls, id, name)
</code></pre>
<p>… or, if you prefer monkeypatching:</p>
<pre><code>class MyType(NamedTuple):
    id: int = 0
    name: str = 0

_new = MyType.__new__
def __new__(cls, id=None, name=None, *, parseything=None):
    if parseything:
        if id is not None or str is not None:
            raise TypeError("don't provide both")
        id, name = … your parsing code here …
    return _new(cls, id, name)
MyType.__new__ = __new__
del _new
del __new__
</code></pre>
<p>… or, if you want more of a <code>range</code>-style ugly API you can do either of the above with:</p>
<pre><code>def __new__(cls, id_or_parsey_thing: Union[int,str]=None, 
            name: str=None):
    if isinstance(id_or_parsey_thing, str):
        if name is not None:
            raise TypeError("don't provide both")
        id, name = … your parsing code here …
    else:
        id = id_or_parsey_thing
    # super().__new__ or _new here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes since Python 3.6 there is a new alternative for <a href="https://kite.com/python/docs/collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a> - NamedTuple. Thanks to variable annotations now it is possible. So, if you previously wrote something like:</p>
<pre><code>MyType = namedtuple('MyType', ('a', 'b', 'c'))
</code></pre>
<p>Now you can define it as follows.
To add a new constructor just define a <a href="https://kite.com/python/docs/__builtin__.classmethod" rel="nofollow noreferrer"><code>classmethod</code></a>:</p>
<pre><code>from typing import NamedTuple


class MyType(NamedTuple):
    a: str
    b: int
    c: float

    @classmethod
    def from_string(cls, s):
        a, b, c = s.split()
        return cls(a, int(b), float(c))


print(MyType.from_string('1 2 3'))
</code></pre>
</div>
<span class="comment-copy">@abarnert There's <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="nofollow noreferrer"><code>typing.NamedTuple</code></a> now.</span>
<span class="comment-copy">@Aran-Fey Ah, yeah, forgot about that…</span>
<span class="comment-copy">This is not a constructor! This is a factory method! I need a real constructor, <b>init</b> function</span>
