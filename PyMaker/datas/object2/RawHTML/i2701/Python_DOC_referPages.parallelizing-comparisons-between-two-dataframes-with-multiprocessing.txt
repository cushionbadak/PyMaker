<div class="post-text" itemprop="text">
<p>I've got the following function that allows me to do some comparison between the rows of two dataframes (<code>data</code> and <code>ref</code>)and return the index of both rows if there's a match.</p>
<pre><code>def get_gene(row):

    m = np.equal(row[0], ref.iloc[:,0].values) &amp; np.greater_equal(row[2], ref.iloc[:,2].values) &amp; np.less_equal(row[3], ref.iloc[:,3].values)

    return ref.index[m] if m.any() else None
</code></pre>
<p>Being a process that takes time (25min for 1.6M rows in <code>data</code> versus 20K rows in <code>ref</code>), I tried to speed things up by parallelizing the computation. As pandas doesn't support multiprocessing natively, I used this piece of code that I found on SO and it worked ok with my function <code>get_gene</code>.</p>
<pre><code>def _apply_df(args):
    df, func, kwargs = args
    return df.apply(func, **kwargs)


def apply_by_multiprocessing(df, func, **kwargs):

    workers = kwargs.pop('workers')
    pool = multiprocessing.Pool(processes=workers)

    result = pool.map(_apply_df, [(d, func, kwargs) for d in np.array_split(df, workers)])

    pool.close()

    df = pd.concat(list(result))

    return df
</code></pre>
<p>It allowed me to go down to 9min of computation. But, if I understood correctly, this code just breaks down my dataframe <code>data</code> in 4 pieces and send each one to each core of the CPU. Hence, each core ends up doing a comparisons between 400K rows (from <code>data</code> split in 4) versus 20K rows (<code>ref</code>).</p>
<p>What I would actually want to do is to split both dataframes based on a value in one of their column so that I only compute comparisons between dataframes of the same 'group':</p>
<ul>
<li><p><code>data.get_group(['a'])</code> versus <code>ref.get_group(['a'])</code></p></li>
<li><p><code>data.get_group(['b'])</code> versus <code>ref.get_group(['b'])</code></p></li>
<li><p><code>data.get_group(['c'])</code> versus <code>ref.get_group(['c'])</code></p></li>
<li><p>etc...</p></li>
</ul>
<p>which would reduce the amount of computation to do. Each row in <code>data</code> would only be able to be matched against ~3K rows in <code>ref</code>, instead of all 20K rows.</p>
<p>Therefore, I tried to modify the code above but I couldn't manage to make it work. </p>
<pre><code>def apply_get_gene(df, func, **kwargs):

    reference = pd.read_csv('genomic_positions.csv', index_col=0)
    reference = reference.groupby(['Chr'])

    df = df.groupby(['Chr'])
    chromosome = df.groups.keys()



    workers = multiprocessing.cpu_count()
    pool = multiprocessing.Pool(processes=workers)


    args_list = [(df.get_group(chrom), func, kwargs, reference.get_group(chrom)) for chrom in chromosome]

    results = pool.map(_apply_df, args_list)

    pool.close()                                                          
    pool.join()                                                           

    return pd.concat(results)


def _apply_df(args):

    df, func, kwarg1, kwarg2 = args

    return df.apply(func, **kwargs)


def get_gene(row, ref):

    m = np.equal(row[0], ref.iloc[:,0].values) &amp; np.greater_equal(row[2], ref.iloc[:,2].values) &amp; np.less_equal(row[3], ref.iloc[:,3].values)

    return ref.index[m] if m.any() else None
</code></pre>
<p>I'm pretty sure it has to do with the way of how <code>*args</code> and <code>**kwargs</code> are passed trough the different functions (because in this case I have to take into account that I want to pass my splitted <code>ref</code> dataframe with the splitted <code>data</code> dataframe..). 
I think the problem lies within the function <code>_apply_df</code>. I thought I understood what it really does but the line <code>df, func, kwargs = args</code> is still bugging me and I think I failed to modify it correctly..</p>
<p>All advices are appreciated !</p>
</div>
<div class="post-text" itemprop="text">
<p>Take a look at <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.starmap" rel="nofollow noreferrer"><code>starmap()</code></a>:</p>
<blockquote>
<p>starmap(func, iterable[, chunksize])
  Like map() except that the elements of the iterable are expected to be iterables that are unpacked as arguments.</p>
<p>Hence an iterable of [(1,2), (3, 4)] results in [func(1,2), func(3,4)].</p>
</blockquote>
<p>Which seems to be exactly what you need.</p>
</div>
<div class="post-text" itemprop="text">
<p>I post the answer I came up with for readers who might stumble upon this post:</p>
<p>As noted by @Michele Tonutti, I just had to use <code>starmap()</code> and do a bit of tweaking here and there. The tradeoff is that it applies only my custom function <code>get_gene</code> with the setting <code>axis=1</code> but there's probably a way to make it more flexible if needed.</p>
<pre><code>def Detect_gene(data):

    reference = pd.read_csv('genomic_positions.csv', index_col=0)
    ref = reference.groupby(['Chr'])

    df = data.groupby(['Chr'])
    chromosome = df.groups.keys()

    workers = multiprocessing.cpu_count()
    pool = multiprocessing.Pool(processes=workers)


    args = [(df.get_group(chrom), ref.get_group(chrom)) 
            for chrom in chromosome]

    results = pool.starmap(apply_get_gene, args)

    pool.close()                                                          
    pool.join()                                                           

    return pd.concat(results)


def apply_get_gene(df, a):

    return df.apply(get_gene, axis=1, ref=a)


def get_gene(row, ref):

    m = np.equal(row[0], ref.iloc[:,0].values) &amp; np.greater_equal(row[2], ref.iloc[:,2].values) &amp; np.less_equal(row[3], ref.iloc[:,3].values)

    return ref.index[m] if m.any() else None
</code></pre>
<p>It now takes ~5min instead of ~9min with the former version of the code and ~25min without multiprocessing.</p>
</div>
<span class="comment-copy">so that mean I could get rid of the <code>_apply_df</code> function who's just here because <code>map()</code> just takes one argument unlike apply ? I'm gonna take a look at that, thanks !</span>
<span class="comment-copy">Indeed, let me know if it doesn't work for some reason!</span>
<span class="comment-copy">Maybe I missed something but I'm not sure <code>starmap()</code> behave like <code>apply()</code>. The good thing with the <code>_apply_df</code> function was that it allowed to return something like <code>df.apply(func, axis=1)</code> and I'm not sure I can get that with <code>starmap()</code> ..</span>
<span class="comment-copy">I came up with something that works. Please see my post if needed. Thanks for the help !</span>
