<div class="post-text" itemprop="text">
<p>Code:</p>
<pre><code>from weakref import WeakSet
se = WeakSet()
se.add(1)
</code></pre>
<p>Output:</p>
<pre><code>TypeError: cannot create weak reference to 'int' object
</code></pre>
<p><a href="https://docs.python.org/3.7/library/weakref.html" rel="noreferrer">Doc</a>:</p>
<blockquote>
<p>Several built-in types such as list and dict do not directly support weak references but can add support through subclassing:</p>
<p>...</p>
<p>Other built-in types such as tuple and int do not support weak references even when subclassed (This is an implementation detail and may be different across various Python implementations.).</p>
</blockquote>
<p>This isn't expressive enough to explain:</p>
<ul>
<li><p>Why some built-in types don't support weak references?</p></li>
<li><p>What are exactly those types that support weak references?</p></li>
</ul>
<hr/>
<p>To add some thoughts:</p>
<p>For the above example you can wrap the int within a user-defined wrapper class, and that wrapper class supports weak references (Those who are familiar with Java will recall <code>int</code> and <code>Integer</code>):</p>
<pre><code>from weakref import WeakSet
se = WeakSet()

class Integer:
    def __init__(self, n=0):
        self.n = n

i = 1
I = Integer(1)

se.add(i)   # fail
se.add(I)   # ok
</code></pre>
<p>I'm not sure why Python doesn't provide auto-wrapping for commonly used built-in types (<code>int</code>, <code>str</code>, etc.) but instead simply say they don't support weak references. It might be due to performance issues, but not being able to weakref these built-in types greatly reduced its usage. </p>
</div>
<div class="post-text" itemprop="text">
<p>First: this is all CPython-specific. Weakrefs work differently on different Python implementations.</p>
<p>Most built-in types don't support weak references because Python's weak reference mechanism adds some overhead to every object that supports weak references, and the Python dev team decided they didn't want most built-in types to pay that overhead. The simplest way this overhead manifests is that any object with weak reference support needs space for an extra pointer for weakref management, and most built-in objects don't reserve space for that pointer.</p>
<p>Attempting to compile a complete list of all types with weak reference support is about as fruitful as trying to compile a complete list of all humans with red hair. If you want to determine whether a type has weak reference support, you can check its <code>__weakrefoffset__</code>, which is nonzero for types with weak reference support:</p>
<pre><code>&gt;&gt;&gt; int.__weakrefoffset__
0
&gt;&gt;&gt; type.__weakrefoffset__
368
&gt;&gt;&gt; tuple.__weakrefoffset__
0
&gt;&gt;&gt; class Foo(object):
...     pass
... 
&gt;&gt;&gt; class Bar(tuple):
...     pass
... 
&gt;&gt;&gt; Foo.__weakrefoffset__
24
&gt;&gt;&gt; Bar.__weakrefoffset__
0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are two things that aren’t covered by <a href="https://stackoverflow.com/a/52011601/908494">user’s excellent answer</a>.</p>
<hr/>
<p>First, weakref was added to Python in version 2.1.</p>
<p>For everything added after 2.1 (and that includes <code>object</code> and <code>type</code>), the default was to add weakref support unless there was a good reason not to.</p>
<p>But for everything that already existed, especially pretty small ones like <code>int</code>, adding another 4 bytes (most Python implementations were 32-bit at the time, so let’s just call a pointer 4 bytes) could cause a noticeable performance regression for all of the Python code out there that had been written for 1.6/2.0 or earlier. So, there was a higher bar to pass for adding weakref support to those types.</p>
<hr/>
<p>Second, Python allows the implementation to merge values of builtin types that it can prove are immutable, and for a few of those builtin types, CPython takes advantage of that. For example (the details vary across versions, so take this only as an example):</p>
<ul>
<li>Integers from -5 to 255, the empty string, single-character printable ASCII strings, the empty bytes, single-byte bytes, and the empty tuple get singleton instances created at startup, and most attempts to construct a new value equal to one of these singletons instead get a reference to the singleton.</li>
<li>Many strings are cached in a string intern table, and many attempts to construct a string with the same value as an interned string instead get a reference to the existing one.</li>
<li>Within a single compilation unit, the compiler will merge two separate constants that are equal ints, strings, tuples of ints and strings, etc. into two references to the same constant.</li>
</ul>
<p>So, weakrefs to these types wouldn’t be as useful as you’d initially think. Many values just aren’t ever going to go away, because they’re references to singletons or module constants or interned strings. Even those that aren’t immortal, you probably have more references to them than you expected.</p>
<p>Sure, there are some cases where weakrefs would be useful anyway. If I calculate a billion large integers, most of those won’t be immortal, or shared. But it means they’re useful <em>less often</em> for these types, which has to be a factor when weighing the tradeoffs of making every int 4 bytes larger so you can save memory by safely releasing them in some relatively uncommon cases.</p>
</div>
<span class="comment-copy">Related: <a href="//stackoverflow.com/q/36787603">What exactly is __weakref__ in Python?</a> (arguably the same question but backwards)</span>
<span class="comment-copy">Do you know anything about the C API, and have you followed the link (immediately after the docs you quoted) to <a href="https://docs.python.org/3/extending/newtypes.html#weakref-support" rel="nofollow noreferrer">Weak Reference Support</a>? If so, part 1 of the answer is pretty simple, although part 2 is still not so much. If not, it's a lot more complicated, because it would require explaining most of what those docs explain.</span>
<span class="comment-copy">@Aran-Fey <i>What is <code>__weakref__</code></i> is not <i>What is weakref</i>? That question mentions nothing about built-in types.</span>
<span class="comment-copy">@abarnert I followed the link but it doesn't tell you why built-in types don't support weakrefs. The only conclusion you can draw from that section might be *built-in types are too simple to support weakref`, but this is not expressive enough.</span>
<span class="comment-copy">@Cyker Thats why I said that answering part 1 would be pretty simple if you’d read that, rather than saying that reading it would give you the answer. (It tells you what builtin types would have to do if they wanted to be weakref-able, but you still need the explanation of why they don’t do that. And, for part 2, the only answer is slogging through each builtin type, either in source or in the REPL, to check which ones do.)</span>
<span class="comment-copy">There’s also the historical fact that most of the builtin types predate weakrefs, so adding weakref support would have been a performance regression for tons of existing Python code. But otherwise I think this covers everything.</span>
<span class="comment-copy">Thank you for providing <code>__weakrefoffset__</code>. From the code you posted, can we safely say all user-defined classes directly inheriting from <code>object</code> (possibly recursively, but doesn't involve another built-in class in the chain) would support weak references?</span>
<span class="comment-copy">@Cyker: No, because <code>__slots__</code> complicates things.</span>
<span class="comment-copy">@user2357112 Could you please give an example about that? I think most developer won't bother with <code>__slots__</code> when defining a custom class. If so, and they define the subclass by <code>class Foo(object): ...</code>, then <code>Foo</code> seems to always support weak references in CPython. Not sure about this on different Python implementations.</span>
<span class="comment-copy">@Cyker Any developer who needs to optimize memory usage will definitely think about using <code>__slots__</code> on their types, and any developer who doesn't need to optimize memory usage probably isn't looking for weakrefs, so I think user's point is pretty relevant. And meanwhile, <a href="https://repl.it/repls/ToughShowyArtificialintelligence" rel="nofollow noreferrer">here's a trivial example</a>.</span>
