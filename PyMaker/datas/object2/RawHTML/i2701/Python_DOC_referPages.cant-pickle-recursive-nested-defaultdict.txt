<div class="post-text" itemprop="text">
<p>I have a recursive nested <code>defaultdict</code> class defined as</p>
<pre><code>from collections import defaultdict

class NestedDict(defaultdict):
    def __init__(self):
        super().__init__(self.__class__)
</code></pre>
<p>sitting in a <code>nested_dict.py</code> file.</p>
<p>When I try to pickle it, e.g.</p>
<pre><code>import pickle
from nested_dict import NestedDict

d = NestedDict()
pickle.loads(pickle.dumps(d))
</code></pre>
<p>I get <code>TypeError: __init__() takes 1 positional argument but 2 were given</code>.</p>
<p>What's exactly happening here? </p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>defaultdict</code> class implements a <a href="https://docs.python.org/3/library/pickle.html#object.__reduce__" rel="nofollow noreferrer"><code>object.__reduce__()</code> method</a> where the second element of the returned tuple (the arguments for the constructor) is always going to be the factory object:</p>
<pre><code>&gt;&gt;&gt; d = NestedDict()
&gt;&gt;&gt; d.__reduce__()
(&lt;class '__main__.NestedDict'&gt;, (&lt;class '__main__.NestedDict'&gt;,), None, None, &lt;dict_itemiterator object at 0x110df59a8&gt;)
</code></pre>
<p>That argument is then passed to the <code>NestedDict()</code> call to re-build the object. The exception is thrown because the <code>NestedDict</code> class doesnâ€™t accept an argument. </p>
<p>You can override the <code>__reduce__</code> method in your subclass:</p>
<pre><code>class NestedDict(defaultdict):
    def __init__(self):
        super().__init__(self.__class__)
    def __reduce__(self):
        return (type(self), (), None, None, iter(self.items()))
</code></pre>
<p>The above produces the exact same elements <code>defaultdict.__reduce__()</code> returns, except that the second element is now an empty tuple.</p>
<p>You could also just accept and ignore a single argument:</p>
<pre><code>class NestedDict(defaultdict):
    def __init__(self, _=None):  # accept a factory and ignore it
        super().__init__(self.__class__)
</code></pre>
<p>The <code>_</code> name is commonly used to mean <em>I am ignoring this value</em>.</p>
<p>An alternative implementation could just subclass <code>dict</code> and provide a custom <a href="https://docs.python.org/3/reference/datamodel.html#object.__missing__" rel="nofollow noreferrer"><code>__missing__</code> method</a>; this method is called for keys not in the dictionary:</p>
<pre><code>class NestedDict(dict):
    def __missing__(self, key):
        nested = self[key] = type(self)()
        return nested
    def __repr__(self):
        return f'{type(self).__name__}({super().__repr__()})'
</code></pre>
<p>This works exactly like your version, but doesn't need additional pickle support methods:</p>
<pre><code>&gt;&gt;&gt; d = NestedDict()
&gt;&gt;&gt; d['foo']
NestedDict({})
&gt;&gt;&gt; d['foo']['bar']
NestedDict({})
&gt;&gt;&gt; d
NestedDict({'foo': NestedDict({'bar': NestedDict({})})})
&gt;&gt;&gt; pickle.loads(pickle.dumps(d))
NestedDict({'foo': NestedDict({'bar': NestedDict({})})})
</code></pre>
</div>
<span class="comment-copy">Changing the <code>super().__init__(self.__class__)</code> line to <code>super().__init__()</code> would make this class a <code>defaultdict</code> without a factory, which essentially works like the built-in <code>dict</code>. Not a good idea.</span>
<span class="comment-copy">oh, sorry about that, nevermind then.</span>
<span class="comment-copy">this may be the problem. <a href="https://stackoverflow.com/questions/16439301/cant-pickle-defaultdict" title="cant pickle defaultdict">stackoverflow.com/questions/16439301/cant-pickle-defaultdict</a></span>
<span class="comment-copy">@goldy021 - it's not the same problem, pickle can't serialize lambdas</span>
