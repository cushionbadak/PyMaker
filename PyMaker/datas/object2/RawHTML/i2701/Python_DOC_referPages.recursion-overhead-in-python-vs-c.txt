<div class="post-text" itemprop="text">
<p>It is a well-known problem in python that recursion involves a lot of overhead.  So much so, that even relatively shallow recursive calls cause programs to crash.  One possible workaround would be to implement fancy recursive algorithms in C, and provide python hooks.  However, it is also well-known that a recursive implementation of an algorithm is more expensive than, say, a loop almost no matter what, unless your compiler recognizes some very specific opportunities (such as tail recursion) to loop-ify the whole business.</p>
<p>Anyhoo, since recursion involves the overhead of a function call, I was wondering what the relative expense of function calls (and thus recursion) is in python vs C?  I realize I could <code>timeit</code>, but I was hoping for a principled explanation.  What all goes into a python function call vs a C one?  Also, are there a difference in the function call stack between python and C that would affect performance for deep call stacks?</p>
</div>
<div class="post-text" itemprop="text">
<p>You’re starting from a set of faulty premises:</p>
<blockquote>
<p>It is a well-known problem in python that recursion involves a lot of overhead. </p>
</blockquote>
<p>No it isn’t. The overhead for recursive function calls is essentially the same as for any other function calls. There’s probably a small difference in that you keep allocating new stack frames and loading them into the cache, whereas the same thing implemented with a loop with a non-recursive call inside would be able to reuse the same stack frame. But it’s going to be pretty minor.</p>
<blockquote>
<p>So much so, that even relatively shallow recursive calls cause programs to crash. </p>
</blockquote>
<p>No they don’t. Recursion beyond a depth of 1000 cleanly fails with an exception. This is in part to prevent such crashes, but also to make it easier to detect accidental infinite recursion.</p>
<blockquote>
<p>One possible workaround would be to implement fancy recursive algorithms in C</p>
</blockquote>
<p>That’s not going to help anything. Most C implementations handle recursion essentially the same way most Python implementations do (in fact. In CPython, recursion can just be a matter of C-recursing the main eval loop). There’s still no tail call elimination, no special handling for keeping only live variables from a frame alive, etc. While C stack frames are a little smaller than Python ones, this is just a small multiplicative factor.</p>
<p>And, meanwhile, unlike Python programs,, C programs actually <em>will</em> crash if you recurse too deeply.</p>
<hr/>
<p>Of course C code does tend to be an order of magnitude or two faster than Python code when what you’re doing is low-level computation, and that will help you here the same way it well anywhere else (although maybe not as much as usual, because function calls in C are, while not as slow as Python, still far from free). Plus, C does force you to be more explicit about some things—e.g., there are no closures, so if you want the effect of <code>nonlocal</code> you’ll need to pass down pointers to locals—which could lead to you optimizing things you wouldn’t think to in Python.</p>
<p>But in general, there is if anything less benefit here than there is in non-recursive code.</p>
<hr/>
<p>There are also some cases where a good C optimizer can see that the whole frame is useless and drop it. In some cases, it can even completely eliminate a tail call. This isn’t as good as universal tail call elimination that you can rely on for correctness, but it’s certainly helpful.</p>
<p>But a good JIT optimizer can sometimes do the same thing. And running your existing code in PyPy or Jython is certainly a lot simpler than rewriting it in C.</p>
<p>(I’m sure there will be some cases where, e.g., LLVM’s AOT optimizer can help but PyPy’s JIT cannot, but I also suspect that anyone who could reliably guess what those cases are wouldn’t have asked this question in the first place.)</p>
<hr/>
<p>There <em>are</em> languages that handle recursion better than Python and C.</p>
<p>If you code your algorithm in, say, Haskell, and then wrap it in a C API that you can call via <code>ctypes</code> or via a simple extension written on C (or maybe even just compile it as a program and subprocess it, if you’re talking about something that takes many seconds to run); that would work.</p>
<hr/>
<p>But if you instead rewrite your recursion as a loop with an explicit stack, you will eliminate all of the problems associated with using recursion in a language that wasn’t designed to encourage it (that’s both Python and C), and open the doors for other optimizations.</p>
<p>For example, you (or LLVM’s optimizer, or PyPy’s JIT) can inline a function call in the middle of an inner loop, which you obviously can’t do with a recursive call.</p>
<p>Also, it generally becomes easier to pull out pieces of your code without having to call back and forth across the Python boundary, so you can port the bottleneck to a C extension module without having to port the whole thing.</p>
</div>
<span class="comment-copy">You want to implement recursive algorithms in C so you get a segfault instead of a nice exception when the stack overflows? =P</span>
<span class="comment-copy">Any recursive process can be re-implemented using iteration; just rework your algorithm if the stack depth limits are an issue.</span>
<span class="comment-copy">I wouldn't say that it's the overhead that causes recursive Python programs to crash. I reckon that's an intentional design choice. You can raise the <a href="https://docs.python.org/3/library/sys.html#sys.setrecursionlimit" rel="nofollow noreferrer">maximum recursion depth</a> by a couple orders of magnitude before it causes an actual stack overflow. Or are you saying "even when setting the recursion limit very high, stack overflows occur sooner in Python than in C?"? I suppose that's true, but then it's probably true of most languages built on top of C.</span>
<span class="comment-copy">I am not aware of recursive function calls in particular being any more expensive than any other function calls, either in Python or especially in C.</span>
<span class="comment-copy">If you are rewriting it in C for performance reasons, then why do you insist on writing it recursive? The primary reason for writing recursive functions is that it makes the code clean, short and easy to read.</span>
<span class="comment-copy">"In CPython, recursion can just be a matter of C-recursing the main eval loop" Does this just depend on the options when I compiled python, or is there some black magic happening here?</span>
<span class="comment-copy">@Scott In CPython, there’s no way to get it to never use the C stack. However, it only takes some small changes to the code to do that. This is what Stackless Python (and the Stackless branch of PyPy) does.</span>
<span class="comment-copy">For example, <a href="https://gcc.godbolt.org/z/VBXz0C" rel="nofollow noreferrer">gcc.godbolt.org/z/VBXz0C</a> (where clang not only found the tail call optimisation, but also unrolled the recursion by a factor of 8). GCC, ICC and MSVS all produce a simple loop (as long as the optimisation level is sufficiently high; -O2, -O1 and /O2 respectively).</span>
<span class="comment-copy">@rici OK, but if your problem is "I need TCO or my algorithm is incorrect", the answer is not "I'll rewrite my Python in C and hope that many compilers can often eliminate the tail call". You either rewrite the algorithm to not need TCO, or you write it in a language that has defined guarantees for tail calling.</span>
<span class="comment-copy">@abarnert: I agree. But there's a difference between saying "you cannot rely on C to optimise tail calls" and saying that there is no tail-call optimisation at all. Python does not optimise tail calls at all. But most popular C compilers do, in fact, optimise many tail calls if optimisation is enabled.</span>
