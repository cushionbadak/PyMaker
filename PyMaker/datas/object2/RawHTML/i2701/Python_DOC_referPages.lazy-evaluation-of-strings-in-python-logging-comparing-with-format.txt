<div class="post-text" itemprop="text">
<p>Is there any difference between these two calls:</p>
<pre><code>import logging

logging.getLogger().debug('test: %i' % 42)
</code></pre>
<p>and</p>
<pre><code>logging.getLogger().debug('test: {}'.format(42))
</code></pre>
<p>Where we assume <code>42</code> is replaced by some long computation when cast to a string (7.5 million years, for example) that produces a final answer of 42.</p>
<p>Is the former approach lazily evaluated in case logging is set to debug?</p>
</div>
<div class="post-text" itemprop="text">
<p>Neither are lazy. Both strings are interpolated before sent to logger. Lazy evaluation in terms of python logging is done with separate arguments. The documentation <a href="https://docs.python.org/2/library/logging.html" rel="nofollow noreferrer">https://docs.python.org/2/library/logging.html</a> suggest the following for lazy evaluation of string interpolation;</p>
<pre><code>logging.getLogger().debug('test: %i', 42)
</code></pre>
<p><strong>TL;DR</strong>
In this case it’s easier to consider the following. We sent a primitive type (string) but only one argument to the logger. Thus it can’t be lazy.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd take a look in the references I posted in the comments for more detailed information on <code>%</code> and <code>.format()</code>. </p>
<p>For the lazy evaluation question, the answer is <em>no</em>.</p>
<p>A simple test will do</p>
<pre><code>def func1(x):
    time.sleep(5)
    return(x)

def func2(x):
    #time.sleep(5)
    return(x)

%timeit 'debug1: %s' % func1(3)
5 s ± 1.31 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
%timeit 'debug2: {}'.format(func1(3))
5 s ± 1.45 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit 'debug1: %s' % func2(3)
297 ns ± 11.2 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
%timeit 'debug2: {}'.format(func2(3))
404 ns ± 4.56 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
<p>In both <code>.format</code> (obviously) and <code>%</code> approaches,<code>func()</code> is calculated anyway.</p>
</div>
<span class="comment-copy">Check: <a href="https://stackoverflow.com/questions/40714555/python-string-formatting-is-more-efficient-than-format-function" title="python string formatting is more efficient than format function">stackoverflow.com/questions/40714555/…</a> , for performance, probably will want <code>f-strings</code> which are faster than these methods, check: <a href="https://stackoverflow.com/questions/43123408/f-strings-in-python-3-6" title="f strings in python 3 6">stackoverflow.com/questions/43123408/f-strings-in-python-3-6</a></span>
<span class="comment-copy">Super useful reference, thanks RafaelC, though it hasn't clarified the lazy evaluation question.</span>
<span class="comment-copy">In both of your examples, the formatted string gets fully evaluated by Python before the <code>logging</code> module gets involved in the process at all.  You probably want to pass the format string and its parameters as <i>separate parameters</i> to <code>.debug()</code>, so that it actually does the formatting - I assume that it only does this if the message isn't going to be filtered out, but I'm not 100% sure of that.</span>
<span class="comment-copy">If you really want laziness, you need something like <code>if logging.getLogger().isEnabledFor(logging.DEBUG): …</code>. From your comments on the answers, though, it sounds like you don't need that.</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/q/4148790/2864740">stackoverflow.com/q/4148790/2864740</a>, perhaps. Solutions also show a proxy-object to <i>defer the cost of value generation</i>. Of course, generating debug values should still be "relatively quick" and "side-effect free" or the very act of enabling debugging will still be problematic/unexpected..</span>
<span class="comment-copy">Note that in Python 3.2+, <a href="https://docs.python.org/3/library/logging.html#logging.Formatter" rel="nofollow noreferrer">you can also do lazy evaluation with <code>str.format</code> style strings</a>, although <code>%</code>-style is still the default.</span>
<span class="comment-copy">This is still <i>not lazy</i> in in the sense asked: <code>.debug('test: %i', takes_75_million_years_to_generate)</code> -- it only defers the creation of the <i>string</i> itself, not the generation of the value supplied as an argument, which is inconsequentially comparatively :} The original question is vague with "Where we assume 42 is replaced by some long computation (7.5 million years, for example) that produces a final answer of 42.", but once 42 is produced, the <i>cost has been paid</i>.</span>
<span class="comment-copy">The original question was vague that way, my bad. I did only mean to ask about the evaluation of the string concatenation. Thank you bringing clarity to that point.</span>
<span class="comment-copy">I added "when cast to a string" to the original question to clarify this detail.</span>
