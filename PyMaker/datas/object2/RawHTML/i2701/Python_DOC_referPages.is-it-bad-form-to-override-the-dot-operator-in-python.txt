<div class="post-text" itemprop="text">
<p>Usually, a period in Python denotes class membership:</p>
<pre><code>class A:
    a = 1

&gt;&gt;&gt; A.a
1
</code></pre>
<p>Sometimes the language doesn't seem quite flexible enough to completely express an idea from domains outside of computer science though. Consider the following example which (fairly brittly for brevity) uses the same operator to seem like something completely different.</p>
<pre><code>class Vector:
    def __init__(self, data):
        self.data = list(data)

    def dot(self, x):
        return sum([a*b for a, b in zip(self.data, x.data)])

    def __getattr__(self, x):
        if x == 'Vector':
            return lambda p: self.dot(Vector(p))
        return self.dot(globals()[x])
</code></pre>
<p>Here we've taken over <code>__getattr__()</code> so that in many scenarios where Python would attempt to find an attribute from our vector it instead computes the mathematical dot product.</p>
<pre><code>&gt;&gt;&gt; v = Vector([1, 2])
&gt;&gt;&gt; v.Vector([3, 4])
11

&gt;&gt;&gt; v.v
5
</code></pre>
<p>If such behavior is kept restricted in scope to the domain of interest, <strong>is there anything wrong with such a design pattern?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p><strong>It's a bad idea.</strong></p>
<p>Why? Because the "dot operator", as you call it, isn't really an operator to begin with. That's because the "operand" on the right-hand side is interpreted as a string, not as an expression. This may seem insignificant to you, but it has plenty of problematic consequences:</p>
<ul>
<li><p>Python programmers are used to <code>foo.bar</code> meaning "Take the <code>bar</code> attribute of the <code>foo</code> object". Turning the dot into a dot product operator breaks this expectation and will confuse people who read your code. It's unintuitive.</p></li>
<li><p>It's ambiguous, because you cannot know if the user is trying to calculate a dot product or access an attribute. Consider:</p>
<pre><code>&gt;&gt;&gt; data = Vector([1, 2])
&gt;&gt;&gt; v.data  # dot product or accessing the data attribute?
</code></pre>
<p>Keep in mind that methods are attributes, too:</p>
<pre><code>&gt;&gt;&gt; dot = Vector([1, 2])
&gt;&gt;&gt; v.dot  # dot product or accessing the dot method?
</code></pre></li>
<li><p>Because the right-hand operand is interpreted as a string, you have to jump through a whole bunch of hoops to turn that string into something useful - as you've tried to do with <code>globals()[x]</code>, which looks up a variable in the global scope. The problem is that - in certain situations - it's completely impossible to access a variable just by its name. No matter what you do, you will never be able to access a variable that no longer exists because it's already been garbage collected:</p>
<pre><code>def func():
    v2 = Vector([1, 2])

    def closure_func():
        return v.v2  # this will never work because v2 is already dead!

    return closure_func

closure_func = func()
result = closure_func()
</code></pre></li>
<li><p>Because the right-hand operand is a string, you cannot use arbitrary expressions on the right-hand side. You're limited to variables; trying to use anything else on the right-hand side will throw some kind of exception. And to make it worse, it won't even throw the appropriate <code>TypeError</code> like other operators would:</p>
<pre><code>&gt;&gt;&gt; [] + 1
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only concatenate list (not "int") to list
&gt;&gt;&gt; v.1
  File "&lt;stdin&gt;", line 1
    v.1
      ^
SyntaxError: invalid syntax
</code></pre></li>
<li><p>Unlike real operators, the "dot operator" can only be implemented in the left-hand operand. All other operators can be implemented in either one of two corresponding dundermethods, for example <a href="https://docs.python.org/3/reference/datamodel.html#object.__add__" rel="nofollow noreferrer"><code>__add__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__radd__" rel="nofollow noreferrer"><code>__radd__</code></a> for the <code>+</code> operator. Example:</p>
<pre><code>&gt;&gt;&gt; class Incrementer:
...     def __radd__(self, other):
...         return other + 1
... 
&gt;&gt;&gt; 2 + Incrementer()
3
</code></pre>
<p>This isn't possible with your dot product:</p>
<pre><code>&gt;&gt;&gt; my_v = MyCustomVector()
&gt;&gt;&gt; v.my_v
AttributeError: 'MyCustomVector' object has no attribute 'data'
</code></pre></li>
</ul>
<p>Bottom line: Implementing a <code>dot</code> method in your <code>Vector</code> class is the way to go. Since the dot isn't a real operator, trying to turn it into one is bound to backfire.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would not recommend it. What do you mean by "the language isn't flexible enough to express an idea"? In your example, <code>v.dot(u)</code> is expressive and has the desired effect. This is, by the way, exactly how <code>numpy</code> does it.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use vectors, there's a special method name that isn't mentioned in th most part called <code>__matmul__</code>. This comes with its corresponding in-place and reflected methods <code>__imatmul__</code> and <code>__rmatmul__</code>. The operator is an <code>@</code>:</p>
<pre><code>a @ b
# corresponds to
a.__matmul__(b)
</code></pre>
</div>
<span class="comment-copy">Why implement this in python when we have numpy? I don't see the benefit of messing with syntax</span>
<span class="comment-copy">I think many would agree that repurposing the <code>.</code> from its standard meaning of attribute access to use as a crude imitation of a <i>raised</i> dot would decrease the readability of your code. There are people who argue that using <code>+</code> for both numerical addition and list concatenation was a mistake; this is a far more divergent overloading.</span>
<span class="comment-copy">Arguing with people about language design in Stack Overflow questions is a little weird. Not Every Character Matters, and if you are reusing specific functionality repeatedly my assessment is you probably have an architectural problem where you haven't written reusable libraries.</span>
<span class="comment-copy">@roganjosh Numpy is a heavyweight dependency, and you could do the same thing to modify numpy's behavior if you wanted. Plus it was a toy example. I had an example with syntax for trees and graphs that in hindsight might have not been received so negatively.</span>
<span class="comment-copy">The GC example isn't super applicable both since you couldn't call <code>v.dot(v2)</code> on a GC'ed object either and since in that case <code>v2</code> would be in <code>locals()</code>. If you modify the code so that <code>v2</code> is not in locals (e.g. by setting <code>v2</code> in the locally scoped function after attempting to access it in that scope), then normal code wouldn't be able to access <code>v2</code> without additional work anyway. That additional work is the <code>nonlocal</code> keyword which will bring <code>v2</code> back to <code>locals()</code>. In all cases, if the variable is accessible it's in <code>locals()</code> or <code>globals()</code>. Otherwise everything looks good.</span>
<span class="comment-copy">@HansMusgrave The point is that <code>v.v2</code> doesn't hold a reference to the <code>v2</code> object (because that <code>v2</code> is just a string representing the name of an attribute), so you're always in danger of <code>v2</code> being garbage collected even though you're still planning on using it.</span>
<span class="comment-copy">GC should be easy to understand. What am I missing? The code <code>v.dot(v2)</code> doesn't hold a reference to the <code>v2</code> object till that line is interpreted anyway, so the difference as far as GC is concerned is between <code>v.dot(v2)</code>, where the reference count increases as soon as the argument is passed, and <code>v.dot(globals()['v2'])</code>, where you didn't actually call <code>globals()['v2']</code> until after the method call <code>v.__getattr__('v2')</code> so that garbage collection could have run in between if <code>v2</code> dereferenced its object between the two calls. Could there ever be a longer gap?</span>
<span class="comment-copy">@HansMusgrave I'm not sure if I understood what you said correctly, but the duration of the gap doesn't matter. The simple fact that there <i>is</i> a gap means that there's a chance of the object being garbage collected. If you look at the updated the code snippet, you'll see it now encapsulates <code>v2</code> in a closure (well, it tries to). But since <code>v.v2</code> doesn't actually reference the <code>v2</code> object, its reference count immediately drops to 0 after <code>return closure_func</code> and it is destroyed. No matter when you call <code>closure_func</code>, <code>v2</code> <i>will</i> be gone.</span>
<span class="comment-copy">The closure example is nice and something I hadn't considered. It's still rectifiable with <code>nonlocal</code>, but it's a nice concrete example of a place where the modification would have unintended side effects with questionable workarounds due to GC. Thank you.</span>
<span class="comment-copy">By that same logic, <code>v.add(u)</code>, <code>v.sub(u)</code>, <code>v.mul(u)</code>, and so on are expressive and have the desired effect. For that matter, why use regex when we could explicitly build those queries with appropriate method calls? We have operators for those use cases because when you're using a feature a lot every character helps.</span>
<span class="comment-copy">"By that same logic, v.add(u), v.sub(u), v.mul(u), and so on are expressive and have the desired effect." Yes.</span>
<span class="comment-copy">Matrix multiplication is more similar to a cross product than a dot product. If you're trying to support vector operations, it would be better to use <code>*</code> for dot and scalar products and use <code>@</code> for cross products.</span>
<span class="comment-copy">Acknowledged. I haven't covered vectors much at school</span>
