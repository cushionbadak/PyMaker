<div class="post-text" itemprop="text">
<p>I have a list named <code>mylist</code></p>
<p>What is the difference between </p>
<p><code>newlist = mylist</code></p>
<p>and </p>
<p><code>newlist = mylist[:]</code></p>
<p>it would seem that the latter is safer to use as it will not mutate <code>mylist</code> based on any manipulation of <code>newlist</code></p>
<p>`</p>
</div>
<div class="post-text" itemprop="text">
<p>The first only creates another name for the list. It is still the same list.</p>
<p>This means mutating <code>newlist</code> also mutates <code>mylist</code>.</p>
<pre><code>&gt;&gt;&gt; mylist = [1, 2, 3]
&gt;&gt;&gt; newlist = mylist
&gt;&gt;&gt; newlist.append(4)
&gt;&gt;&gt; mylist
[1, 2, 3, 4]
</code></pre>
<p>The second example actually creates a copy of the list, an actual new list.</p>
<pre><code>&gt;&gt;&gt; mylist = [1, 2, 3]
&gt;&gt;&gt; newlist = mylist[:]
&gt;&gt;&gt; newlist.append(4)
&gt;&gt;&gt; newlist
[1, 2, 3, 4]
&gt;&gt;&gt; mylist
[1, 2, 3]
</code></pre>
<p>You have little reason to have two names for the same object as this can be both confusing and lead to mutation bugs.</p>
<p>A mutation bug is when some object is needed in some part of your code, say a function <code>func1</code>, but mutated beforehand by some other part of your code, say a function <code>func2</code>. If the object in its initial state was expected by <code>func1</code>, it can be very tedious to track down where the mutation happened.</p>
<p>Example:</p>
<pre><code>obj = [list of data]
same_obj = obj

func2(same_obj) # mutates the object

# hundreds of lines of code

func1(obj) # needs the initial state of the object
</code></pre>
<p>In the above example, it would have been better to pass <code>func2</code> a copy of <code>obj</code>. Since a lot happen between the first and last lines, it can be very tedious to track down the mutation bug.</p>
</div>
<div class="post-text" itemprop="text">
<p>The difference is: the first one creates (or rebinds) another name in the local namespace referencing the same <code>mylist</code> instance.  You can think of it as an alias. The second one creates a shallow copy of <code>mylist</code>.</p>
<p>This line:</p>
<pre><code>newlist = mylist
</code></pre>
<p>is terrible Python.  Because that is not a "newlist" <em>as the variable name is suggesting</em>, it's just adding another name for the same list.</p>
<p>This is acceptable:</p>
<pre><code>mylist_again = mylist
</code></pre>
<p>Whether that's preferable to taking a slice with <code>mylist[:]</code> or not depends entirely on context. Sometimes you want a copy, sometimes you want another reference to existing data.</p>
<blockquote>
<p>it would seem that the latter is safer to use as it will not mutate mylist based on any manipulation of newlist</p>
</blockquote>
<p>That's not entirely true, since the slice is only a shallow copy.  The newlist could still be sharing state:</p>
<pre><code>&gt;&gt;&gt; mylist = [0, [1]]
&gt;&gt;&gt; newlist = mylist[:]
&gt;&gt;&gt; newlist[0] = 123
&gt;&gt;&gt; newlist[1][0] = 456
&gt;&gt;&gt; mylist
[0, [456]]
&gt;&gt;&gt; newlist
[123, [456]]
</code></pre>
<p>Again, whether a shallow copy is sufficient or not depends on the data. If you use nested data and a shallow copy is not enough, or there are mutable elements that should be copied, you can look into using <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer"><code>copy.deepcopy</code></a>.</p>
</div>
<span class="comment-copy">Any comment from downvoters?</span>
