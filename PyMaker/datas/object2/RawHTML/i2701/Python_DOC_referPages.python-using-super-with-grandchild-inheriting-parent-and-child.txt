<div class="post-text" itemprop="text">
<p>[using Python3.6]
I have a design where Grandchild inherits a Parent and Child (of Parent).</p>
<pre><code>class Parent:
    def aux_func(self):
        return "[parent aux]"

    def main_func(self):
        print("[parent main]" + self.aux_func())


class Child(Parent):
    def aux_func(self):
        return "[child aux]"

    def main_func(self):
        print("[child main]" + self.aux_func())


class Grandchild(Child, Parent):
    @classmethod
    def do_something(cls):
        g = Grandchild()
        g.main_func()
        super(Child, g).main_func()
        Parent.main_func(g)

Grandchild.do_something()
</code></pre>
<p>the result is -</p>
<pre><code>[child main][child aux]
[parent main][child aux]
[parent main][child aux]
</code></pre>
<p>Calling a function from Parent causes the aux_func to resolve from the Child class. I tried to go through MRO process but can't explain functions being called from different classes. Could someone help me with</p>
<ol>
<li>Why this is happening ?</li>
<li>What would be a workaround to achieve [parent main][parent aux] ?  </li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You are misunderstanding what <code>super()</code> does. <code>super()</code> does not alter the type of the <code>self</code> reference. <code>super(..., self).method()</code> will still pass in that <code>self</code> reference to the method being called, so <code>self</code> is, in all three cases, the <code>Grandchild()</code> instance.</p>
<p>That means that in all cases, <code>self.aux_func()</code> follows the normal attribute resolution order, and for <code>Grandchild()</code> instances, <code>self.aux_func()</code> will always find <code>Child.aux_func</code> and call that.</p>
<p>Put differently, the only lookup that is altered, is the attribute you look up on the <code>super()</code> object itself. If you need more such alterations, you need to use <code>super()</code> <em>again</em>, <em>or</em> you need to give your <code>aux_func()</code> functions <em>different names per class</em>. One way to do that is to make the methods <em>class private</em>.</p>
<p>The latter can be done by naming your function with two underscores at the start (but not at the end). Such names are then <em>altered at compile time</em> to inject the class names in all places that it is referenced:</p>
<pre><code>class Parent:
    def __aux_func(self):
        # class private to Parent
        return "[parent aux]"

    def main_func(self):
        # any reference to __aux_func *in this class* will use
        # the Parent class-private version
        print("[parent main]" + self.__aux_func())


class Child(Parent):
    def __aux_func(self):
        # class private to Child
        return "[child aux]"

    def main_func(self):
        # any reference to __aux_func *in this class* will use
        # the Child class-private version
        print("[child main]" + self.__aux_func())
</code></pre>
<p>See the <a href="https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers" rel="nofollow noreferrer"><em>Reserved classes of identifiers</em> documentation</a>:</p>
<blockquote>
<p><code>__*</code><br/>
  Class-private names. Names in this category, when used within the context of a class definition, are re-written to use a mangled form to help avoid name clashes between “private” attributes of base and derived classes.</p>
</blockquote>
<p>and the <a href="https://docs.python.org/3/reference/expressions.html#atom-identifiers" rel="nofollow noreferrer"><em>Identifiers (Names)</em> section</a>:</p>
<blockquote>
<p><strong>Private name mangling</strong>: When an identifier that textually occurs in a class definition begins with two or more underscore characters and does not end in two or more underscores, it is considered a private name of that class. Private names are transformed to a longer form before code is generated for them. The transformation inserts the class name, with leading underscores removed and a single underscore inserted, in front of the name. For example, the identifier <code>__spam</code> occurring in a class named <code>Ham</code> will be transformed to <code>_Ham__spam</code>. This transformation is independent of the syntactical context in which the identifier is used.</p>
</blockquote>
<p>By using class private naming for <code>__aux_func</code>, any reference to it from methods defined on <code>Parent</code> will look up and find <code>_Parent__aux_func</code>, and any reference to the same name in <code>Child</code> will look up and find <code>_Child__aux_func</code>. The two names are distinct and thus don't clash:</p>
<pre><code>&gt;&gt;&gt; class Grandchild(Child, Parent):
...     @classmethod
...     def do_something(cls):
...         g = Grandchild()
...         g.main_func()
...         super(Child, g).main_func()
...         Parent.main_func(g)
...
&gt;&gt;&gt; Grandchild.do_something()
[child main][child aux]
[parent main][parent aux]
[parent main][parent aux]
</code></pre>
<p>A different way to achieve this is to use distinct names, explicitly; say <code>parent_aux_func()</code> and <code>child_aux_func()</code>. Class private names are really only <em>intended</em> in APIs that are meant to be subclassed by third-party code without too many restrictions on what names the subclass can use.</p>
</div>
<span class="comment-copy">You are passing in the wrong class to <code>super()</code>. Pass in the <b>current</b> class, <code>Grandchild</code>.</span>
<span class="comment-copy">@MartijnPieters - Thanks for chiming in. Problem is <code>super(Grandchild, g).main_func()</code> gives me <code>[child main][child aux]</code>. I'm trying to get both parent functions called.</span>
<span class="comment-copy">Well, <code>self</code> is still an instance of the <code>Grandchild()</code> class. <code>super()</code> does not alter what <code>self</code> is bound to.</span>
<span class="comment-copy">@MartijnPieters - That'd explain it. Thanks! I'm trying to come up with a design that allows me to call all functions from Parent or Child but not both. Any suggestions ?</span>
