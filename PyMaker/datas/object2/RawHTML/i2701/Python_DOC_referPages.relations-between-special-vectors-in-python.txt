<div class="post-text" itemprop="text">
<p>I am wondering if there is a way to establish a relation between some special "vectors".</p>
<p>Example:</p>
<p>Suppose these are my vectors (I will only choose 3 special vectors):</p>
<pre><code>   a=[1,2,[1]]
   b=[1,2,[2]]
   c=[1,3,[1]]
</code></pre>
<p>and I want to add the following rules when comparing them (lexicographic order):</p>
<p>I wish to say that  </p>
<pre><code>   a&lt;b 
</code></pre>
<p>because </p>
<pre><code>  a[0]=b[0] and a[1]=b[1] but *a[2]&lt;b[2]*
</code></pre>
<p>but I also want to say</p>
<pre><code>  a&lt;c
</code></pre>
<p>because </p>
<pre><code>  a[0]=b[0] and a[1]&lt;c[1] and a[2]&lt;=c[2]
</code></pre>
<p>but note that things are a little different for "b" and "c" since these are not comparable because even though</p>
<pre><code>  b[0]=c[0] and b[1]&lt;c[1], the last term changes everything since b[2]&gt;c[2]
</code></pre>
<p>In other words, the rules I am applying, will first compare the "normal" entries of two vectors x and y, if a certain entry of vector x is bigger than a certain entry of vector y, we take a look at the last entry. If the last entry of vector x is greater than Or equal, then we say x&gt;y, if this is not the case, then x and y are not comparable.</p>
<p>In case all "normal" entries of x and y are the same, we compare the last entry. If the last entry of x is bigger than the last entry of y, we also say x&gt;y. </p>
<p>I am thinking that this has to do with a while loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make <code>vector</code> a subclass of <code>list</code> and overload the <code>__lt__</code> and <code>__gt__</code> methods so that the last item is checked before the default behavior. Also overload the <code>__le__</code> and <code>__ge__</code> methods for completeness:</p>
<pre><code>class vector(list):
    def __lt__(self, other):
        lt = super().__lt__(other)
        if lt and self[-1] &gt; other[-1]:
            return False
        return lt
    def __gt__(self, other):
        gt = super().__gt__(other)
        if gt and self[-1] &lt; other[-1]:
            return False
        return gt
    def __le__(self, other):
        if self == other:
            return True
        return self &lt; other
    def __ge__(self, other):
        if self == other:
            return True
        return self &gt; other
</code></pre>
<p>so that:</p>
<pre><code>a=vector([1,2,[1]])
b=vector([1,2,[2]])
c=vector([1,3,[1]])
print(a&lt;b)
print(a&lt;c)
print(b&lt;c)
print(c&lt;b)
print(b&gt;c)
print(c&gt;b)
print(b&lt;=c)
print(c&lt;=b)
</code></pre>
<p>will output:</p>
<pre><code>True
True
False
False
False
False
False
False
</code></pre>
<p><strong>EDIT</strong>: In light of the comments made below, I would also like to point out that this is case where <code>functools.total_ordering</code> doesn't work because of the atypical logic required by the OP, where one object can be not less than, not greater than and not equal to the other at the same time.</p>
<p>So if we define only the <code>__lt__</code> method for the <code>vector</code> class and apply the <code>total_ordering</code> decorator:</p>
<pre><code>from functools import total_ordering
@total_ordering
class vector(list):
    def __lt__(self, other):
        lt = super().__lt__(other)
        if lt and self[-1] &gt; other[-1]:
            return False
        return lt
</code></pre>
<p>The test code above would produce the following incorrect output instead:</p>
<pre><code>True
True
False
False
False
True
True
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can easily write a function to do what you described.</p>
<pre><code>def special_lt(vec1, vec2):
</code></pre>
<p>You've defined the "normal" values as all but the last one, and the "special" values as the last one, so that's easy:</p>
<pre><code>    normal1, normal2 = vec1[:-1], vec2[:-1]
    special1, special2 = vec1[-1], vec2[-1]
</code></pre>
<p>Now, if I understand it correctly, you want to do a lexicographical comparison of the normal values, and then defer to the special values if they're equal…</p>
<pre><code>    if normal1 == normal2:
        return special1 &lt; special2
</code></pre>
<p>… but otherwise use the special values as a check to make sure they're ordered in the same way as the normal values:</p>
<pre><code>    elif normal1 &lt; normal2:
        if special1 &lt;= special2:
            return True
        raise ValueError('not comparable')
    else:
        if special2 &lt;= special1:
            return False
        raise ValueError('not comparable')
</code></pre>
<p>Notice that for comparing the lists of normal values, and the lists of special values, I didn't use a loop; I just compared the lists. That's because lists already compare lexicographically (which, internally, is done with a loop, of course, but I don't have to write it).</p>
</div>
<span class="comment-copy">Do you need to contain the 3rd value in its own single-item list?</span>
<span class="comment-copy">So it can happen that some two vectors in your space are <i>not comparable</i>? Sounds weird. No guarantee that a set defined on vectors in your space is orderable.</span>
<span class="comment-copy">So do you want <code>b &lt; c</code> and <code>c &lt; b</code> to <i>both</i> be false? You likely want to define a class which can override <code>__lt__</code> et al. to represent your vectors, rather than just implicitly using lists.</span>
<span class="comment-copy">yes, b and c are not comparable so b&lt;c and c&lt;b are false. This has to do with a "special" lexicographic order. The last term of the vector gives a certain spice to things.</span>
<span class="comment-copy">Better to just define <code>__lt__</code> (and <code>__eq__</code> if needed) and then use <code>@functools.total_ordering</code>. Then you don't have to repeat the logic four times. (Sometimes you kind of have to repeat them for performance reasons, but in that case, for non-trivial classes, I usually still write code to generate the methods, just at class definition time rather than on the fly.)</span>
<span class="comment-copy">No, <code>@functools.total_ordering</code> is no magic. <code>@functools.total_ordering</code> relies on the relations of the objects being logical, so that if I define only <code>__lt__</code> then the returning value of <code>__gt__</code> is always the negation of the <code>__lt__</code>'s, which in the OP's case is not.</span>
<span class="comment-copy"><code>total_ordering</code> does depend on what you give it, but <code>__gt__(self, other)</code> is not <code>not __lt__(self, other)</code>, it's <code>__lt__(other, self)</code>. More generally, it works on total orderings, and on partial orderings where everything is either the same as a total ordering or an exception; it does not necessarily work on weird NaN-style orderings. If that's what the OP wants, then yeah, you probably can't use it.</span>
<span class="comment-copy">Since the desired logic works against intuitive <code>total_ordering</code>, i'd suggest mixing in this "special ordering" as a separate class into a normal <code>Vector</code> class.  Reference <a href="https://github.com/python/cpython/blob/e42b705188271da108de42b55d9344642170aa2b/Lib/functools.py#L83" rel="nofollow noreferrer">github.com/python/cpython/blob/…</a></span>
<span class="comment-copy">@pylang For what it's worth, writing a <code>@weird_ordering</code> decorator is pretty simple (I have a <code>@nan_ordering</code> somewhere on GitHub)—but unless you're planning on multiple such types, or you can come up with a name that makes the meaning of the rules a lot clearer than the code, I wouldn't bother with that abstraction; I'd just write it manually the way blhsing did after all.</span>
<span class="comment-copy">Thank you. This has been real helpful.</span>
<span class="comment-copy">I have one last question about this. Is it possible to sort the vectors from greatest to least if comparable? For example, if I have [v1,v2] and they both are comparable, but v1&lt;v2, can I obtain a special command to get [v2,v1]?. Thank you.</span>
<span class="comment-copy">@Stiven <code>if v1 &lt; v2: return [v2, v1]</code> but then you would be returning two types (bool and list).  At that point, you should rethink the design.   Example: you could return lists when comparable and raise exceptions when not.</span>
<span class="comment-copy">@StivenG For sort, you can only pass a <code>key</code> function that transforms each value. If you write an old-style <code>cmp</code> function (that returns -1, 0, or 1) instead of a <code>lt</code> function, you can use <a href="https://docs.python.org/3/library/functools.html#functools.cmp_to_key" rel="nofollow noreferrer"><code>cmp_to_key</code></a> to create a <code>key</code> function from your <code>cmp</code>. But if you primarily want to use this for sorting, you're probably better off creating a <code>key</code> function in the first place, or creating a wrapper type as in blhsing's answer.</span>
