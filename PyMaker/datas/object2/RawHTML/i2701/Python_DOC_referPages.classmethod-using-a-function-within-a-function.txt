<div class="post-text" itemprop="text">
<p>I have a situation where I'm using <code>@classmethod</code> to create a constructor for a class. Within this constructor, a function gets called, which then in turn calls another function. But either this doesn't work or (more probably) I'm doing something to make it not work. Here's an example in miniature:</p>
<pre><code>class testclass:
    def __init__(self, x):
        self.x = x

    @classmethod
    def constructor(cls, x):
        adj_x = cls.outer_adjust(cls, x)
        return testclass(adj_x)

    def outer_adjust(self, x):
        return self.inner_adjust(x)

    def inner_adjust(self, x):
        return x + 1

test_instance = testclass.constructor(4)
</code></pre>
<p>This produces an error message:</p>
<pre><code>inner_adjust() missing 1 required positional argument: 'x'
</code></pre>
<p>I can make it work by explicitly passing self to <code>inner_adjust</code>, eg</p>
<pre><code>def outer_adjust(self, x):
    return self.inner_adjust(self, x)
</code></pre>
<p>But this then means that the <code>outer_adjust</code> method can't be used outside of the <code>constructor</code>, which is not what I want.</p>
<p>Any assistance gratefully received.</p>
<p>Here's a more detailed example, with two constructors shown. I'm trying to follow the approach to constructors described in
<a href="https://stackoverflow.com/questions/682504/what-is-a-clean-pythonic-way-to-have-multiple-constructors-in-python">What is a clean, pythonic way to have multiple constructors in Python?</a>
Which is essentially that the constructors do some processing to figure out what variables they should pass to <strong>init</strong> when instantiating the class.
Both constructors give the same error:</p>
<pre><code>if_char_is_z_make_it_a() missing 1 required positional argument: 'char_input'
</code></pre>
<p>As before, I need to be able to use the if_char_is_make_it_a function outside of the constructor (ie, when using the class normally).</p>
<pre><code>class testclass:
    def __init__(self, char):
        self.char = char

    @classmethod
    def constructor_from_int(cls, int_input):
        as_char = chr(int_input)
        char = cls.process_char(cls, as_char)
        return testclass(char)

    @classmethod
    def constructor_from_char(cls, char_input):
        char = cls.process_char(cls, char_input)
        return testclass(char)

    def process_char(self, char_input):
        processed_char = '(' + char_input + ')'
        output_char = self.if_char_is_z_make_it_a(processed_char)
        return output_char

    def if_char_is_z_make_it_a(self, char_input):
        if char_input == '(z)':
            return '(a)'
        return char_input

test_instance = testclass.constructor_from_char('a')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you call <code>cls.outer_adjust</code> from <code>constructor</code> you are calling the unbound <code>outer_adjust</code> method.</p>
<p>Thus, you pass the class itself as <code>self</code> and not an instance to a method that expects to receive an instance as argument.</p>
<p>Although, there is no real reason to have a <code>constructor</code> method. This is exactly what <code>__init__</code> is for.</p>
<pre><code>class testclass:
    def __init__(self, x):
        self.x = self.outer_adjust(x)

    def outer_adjust(self, x):
        return self.inner_adjust(x)

    def inner_adjust(self, x):
        return x + 1

test_instance = testclass(4)
</code></pre>
<p>If you absolutely need the transformation on <code>x</code> to be done <em>before</em> the instantiation, then use <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a> instead. Although, this is generally not necessary.</p>
<h2>Multiple constructors</h2>
<p>If for some reason you still need to have a <code>constructor</code> method, by example if you want multiple constructors. Then keep in mind that <code>outer_adjust</code> and <code>inner_adjust</code> are instance methods, this means they must be called <em>after</em> you have created an instance.</p>
<pre><code>class testclass:
    def __init__(self, x):
        self.x = x

    @classmethod
    def constructor1(cls, x):
        instance = cls(x)
        instance.outer_adjust()
        return instance

    @classmethod
    def constructor2(cls, x):
        instance = cls(x)
        instance.inner_adjust()
        return instance

    def outer_adjust(self):
        print('Do something else')
        return self.inner_adjust()

    def inner_adjust(self):
        self.x += 1
</code></pre>
<p>As a sidenote, notice how I did not need to call <code>testclass</code>, but simply called <code>cls</code> in the constructor methods. Since this is a class method, we do not need to explicitly name the class. This is better, especially if you are to use inheritance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Basically what you are doing here shall be done via the <a href="https://docs.python.org/2/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">__new__</a> which serve as constructor.</p>
<pre><code>class testclass:
    def __init__(self, x):
        self.x = x

    def __new__(cls, *args, **kwargs):
        instance = super(testclass, cls).__new__(cls, *args, **kwargs)
        instance.outer_adjust(args[0])
        return instance

    def outer_adjust(self, x):
        return self.inner_adjust(x)

    def inner_adjust(self, x):
        self.x = x + 1

test_instance = testclass(4)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are abusing <code>self</code>. The point of the class method is to use the <code>cls</code> argument as constructor, instead of explicitly naming the class by <code>testclass(adj_x)</code>. Also, during the <code>cls.outer_adjust(cls, x)</code> call, you are passing the class instead of the instance, which <em>happens</em> to work because you are not using any instance attributes. </p>
<p>As to your questions, there's no way to avoid the <code>x</code> argument. <code>inner_adjust</code> increases some value by <code>1</code>, so you must give it something to increase. The idea would be to have</p>
<pre><code>def constructor(cls, x):
    return cls(x)

def inner_adjust(self):
    return self.x += 1
</code></pre>
<p>and then do something like</p>
<pre><code>object= testclass.constructor(12)
object.inner_adjust()
</code></pre>
</div>
<span class="comment-copy">Thanks - I do understand what you're saying but this is a class (maybe not obvious from my shortened example) that has multiple constructors, so I can't just use <b>init</b>.</span>
<span class="comment-copy">@ChrisHarris You might need to share more details. What you describe looks a bit like code smell to me and you might want to consider a better way to do it, by example using inheritance.</span>
<span class="comment-copy">@ChrisHarris Nonetheless, see my updated answer.</span>
<span class="comment-copy">thanks for the detailed response. I'm trying to use the approach to using constructors described here:  <a href="https://stackoverflow.com/questions/682504/what-is-a-clean-pythonic-way-to-have-multiple-constructors-in-python" title="what is a clean pythonic way to have multiple constructors in python">stackoverflow.com/questions/682504/…</a>  Where the constructor function does most of the work to figure out what variables should ultimately be passed when instantiating the class via <b>init</b>. I'll edit my original post to include a more detailed example which hopefully makes it a bit clearer.</span>
<span class="comment-copy">@glibdud yeah, I was wrong and updated answer.</span>
<span class="comment-copy">I'm finding that code doesn't work on my setup. I'd also like to stick to the usual approach when using constructors of figuring out the variables within the @classmethod function, then creating an instance based on <b>init</b> using them.</span>
<span class="comment-copy">Also, I should point out that in your example <code>inner_adjust</code> simply returns the value and <code>adj_x</code> is thrown away, so <code>__new__</code> does nothing here.</span>
<span class="comment-copy">@OlivierMelançon yes, you are right, but maybe it's some placeholders...</span>
<span class="comment-copy">@OlivierMelançon yeah, thanks, honestly didn't catch from the begining your thought, no need to set <code>adj_x</code> variable</span>
<span class="comment-copy">Thanks for the response. I see what you're saying about using cls rather than naming the class to create the instance. However I don't think the method you're describing is going to work in this case, because I need to use the inner_adjust function elsewhere in the code, where I may want to pass it parameters other than self.x.</span>
<span class="comment-copy">@ChrisHarris: 1) that's the point of classmethod. If you use the name the class, it will fail with inheritance, or if the name changes. 2) if you are not using <code>self</code> attributes, but only parameters, maybe it should be a <code>@staticmethod</code></span>
