<div class="post-text" itemprop="text">
<p>I met this problem when I want to try a python version of:
<a href="https://leetcode.com/problems/first-missing-positive/discuss/17071/My-short-c++-solution-O(1)-space-and-O(n)-time" rel="noreferrer">https://leetcode.com/problems/first-missing-positive/discuss/17071/My-short-c++-solution-O(1)-space-and-O(n)-time</a></p>
<p>I am not sure why <code>a[0], a[a[0]] = a[a[0]], a[0]</code> this one does not do the swap?</p>
<pre><code>&gt;&gt;&gt; nums
[2, 1, 0]
&gt;&gt;&gt; a = [2,1,0]
&gt;&gt;&gt; a[0], a[a[0]] = a[a[0]], a[0]
&gt;&gt;&gt; a
[2, 1, 0]
&gt;&gt;&gt; a[0]
2
&gt;&gt;&gt; a[0],a[2] = a[2], a[0]
&gt;&gt;&gt; a
[0, 1, 2]
</code></pre>
<p>My guess is that the implementation of a, b = b, a syntax is something like:</p>
<pre><code>tmp = a[0] (tmp = 2)
a[0]  = a[a[0]] (a[0] = a[2] = 0)
a[a[0]] = tmp (a[a[0]] = a[0] = tmp = 2)
</code></pre>
<p>Then I checked the implementation of swap function in C++. I know nothing about C++, but it looks like the idea is the same
:
<a href="http://www.cplusplus.com/reference/algorithm/swap/" rel="noreferrer">http://www.cplusplus.com/reference/algorithm/swap/</a></p>
<pre><code>The behavior of these function templates is equivalent to:
template &lt;class T&gt; void swap (T&amp; a, T&amp; b)
{
  T c(std::move(a)); a=std::move(b); b=std::move(c);
}
template &lt;class T, size_t N&gt; void swap (T (&amp;a)[N], T (&amp;b)[N])
{
  for (size_t i = 0; i&lt;N; ++i) swap (a[i],b[i]);
}
</code></pre>
<p>we have c = a, then a = b and b = a
So why C++ swap function does not have this problem?
And how to write this kind of swap function in a pythonic way?</p>
</div>
<div class="post-text" itemprop="text">
<p>To understand this you need to go inside the implementation using <code>dis</code>.</p>
<p>First lets consider a <strong>simple swap function</strong>:</p>
<pre><code>from dis import dis

def swap(i, j):
    i, j = j, i

dis(swap)
</code></pre>
<p><strong>Output Byte Code:</strong></p>
<pre><code>4             0 LOAD_FAST                1 (j)
              2 LOAD_FAST                0 (i)
              4 ROT_TWO
              6 STORE_FAST               0 (i)
              8 STORE_FAST               1 (j)
             10 LOAD_CONST               0 (None)
             12 RETURN_VALUE
</code></pre>
<p>You can see that there is <a href="https://docs.python.org/3/library/dis.html#opcode-ROT_TWO" rel="nofollow noreferrer">ROT_TWO</a> which means that </p>
<blockquote>
<p>Swaps the two top-most stack items.</p>
</blockquote>
<p>This <code>ROT_TWO</code> is mainly responsible for the swapping.</p>
<p><strong>Now coming to your question:</strong></p>
<p>Lets take the <strong>example which is working:</strong></p>
<pre><code>from dis import dis

def swap():
    a = [2, 1]
    a[0], a[1] = a[1], a[0]

dis(swap)
</code></pre>
<p><strong>Output Byte Code</strong> :</p>
<pre><code>  4           0 LOAD_CONST               1 (2)
              2 LOAD_CONST               2 (1)
              4 BUILD_LIST               2
              6 STORE_FAST               0 (a)

  5           8 LOAD_FAST                0 (a)
             10 LOAD_CONST               2 (1)
             12 BINARY_SUBSCR
             14 LOAD_FAST                0 (a)
             16 LOAD_CONST               3 (0)
             18 BINARY_SUBSCR
             20 ROT_TWO
             22 LOAD_FAST                0 (a)
             24 LOAD_CONST               3 (0)
             26 STORE_SUBSCR
             28 LOAD_FAST                0 (a)
             30 LOAD_CONST               2 (1)
             32 STORE_SUBSCR
             34 LOAD_CONST               0 (None)
             36 RETURN_VALUE
</code></pre>
<p>Output byte code is similar to what we have when it is a simple swap function. </p>
<p>But <strong>when the code is changed</strong>:</p>
<pre><code>from dis import dis

def swap():
    a = [1, 0]
    a[0], a[a[0]] = a[a[0]], a[0]
dis(swap)

swap()
</code></pre>
<p><strong>Output is</strong> </p>
<pre><code>  4           0 LOAD_CONST               1 (1)
              2 LOAD_CONST               2 (0)
              4 BUILD_LIST               2
              6 STORE_FAST               0 (a)

  5           8 LOAD_FAST                0 (a)
             10 LOAD_FAST                0 (a)
             12 LOAD_CONST               2 (0)
             14 BINARY_SUBSCR
             16 BINARY_SUBSCR
             18 LOAD_FAST                0 (a)
             20 LOAD_CONST               2 (0)
             22 BINARY_SUBSCR
             24 ROT_TWO
             26 LOAD_FAST                0 (a)
             28 LOAD_CONST               2 (0)
             30 STORE_SUBSCR
             32 LOAD_FAST                0 (a)
             34 LOAD_FAST                0 (a)
             36 LOAD_CONST               2 (0)
             38 BINARY_SUBSCR
             40 STORE_SUBSCR
             42 LOAD_CONST               0 (None)
             44 RETURN_VALUE
</code></pre>
<p>You can see the output byte code that <strong>top two items are the same</strong>. Hence it doesn't swap</p>
</div>
<div class="post-text" itemprop="text">
<p>This kind of the behaviour is indeed related to the way Python evaluates the expression of the type</p>
<pre><code>a,b=b,a
</code></pre>
<p>In fact, what Python does is first it "prepares" the values of the right side by creating a tuple <code>(b,a)</code>. Then this tuple is unpacked and assigned to the variables in the reverse order.</p>
<p>It is important to note that the temporary tuple is created using <em>values</em> of variables (de facto copies of values), not <em>references</em> to the variables (you can read here about <a href="https://stackoverflow.com/a/986145/6573902">the difference between passing by value and by reference</a>).</p>
<p>To break down the example with reference types (lists) that you used:</p>
<pre><code>a = [2,1,0]    
a[0], a[a[0]] = a[a[0]], a[0]
</code></pre>
<ol>
<li><code>a[a[0]]</code> takes the value from the <code>a[0]</code> element (equal to <code>2</code>) of the list <code>a</code> (value <code>0</code>).</li>
<li><code>a[0]</code> is <code>2</code> hence the tuple created is <code>(0,2)</code></li>
<li>Tuple <code>(0,2)</code> is unpacked and <code>0</code> replaces <code>2</code> in the list (0th element).</li>
<li>Now, <code>a[a[0]]</code> can be read as: take 0th element of list <code>a</code> (which is currently <code>0</code>) and then replace the value in the list at that place with <code>2</code> from tuple unpacking (now <code>0</code> is replaced by <code>2</code> - which make the operation  look like it does nothing to the list).</li>
</ol>
<p>As suggested in <a href="https://stackoverflow.com/a/51950307/6573902">the answer from <code>von Oak</code></a> changing the order helps because the step from the point 4. above does not replace the value again.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python and C++ are different languages with different rules. That's largely the reason why superficially similar constructs behave differently in these languages.</p>
<p>You cannot write a generic <code>swap</code> in Python that would work with input like <code>a[0], a[a[0]]</code>. This is not a problem. You shouldn't ever try to swap such things in any language in order to avoid confusion and improve your chances for future employment as a programmer.</p>
<p>If you absolutely positively need to swap array elements indexed by elements of the same array, you can do it like so in Python:</p>
<pre><code>p, q, a[p], a[q] = index0, index1, a[q], a[p]
</code></pre>
<p>where <code>index0</code> and <code>index1</code> may be any expression involving <code>a[i]</code>, <code>a[a[i]]</code>, <code>a[a[a[i]]]</code> or anything similar. For example</p>
<pre><code>p, q,  a[p], a[q] = a[0], a[a[0]],  a[q], a[p]
</code></pre>
<p>works.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's easy to think about it also only on the paper (e.g. at the job interview) and you don't need to debug or disassemble code to bytecode for understanding. </p>
<p>I also think it hasn't anything to do with the implementation of swap function in C++. These are unrelated things.</p>
<p>What you only need to know is that the right side is completely evaluated first and then the values from the right side of the expression are assigned to the values on the left side in the order from the left to the right. <a href="https://stackoverflow.com/questions/51950193/python-a-b-b-a-implementation-how-is-it-different-from-c-swap-function/51950571#51950571">Sophros answered it right way</a> I only expand the idea further and in more detail.</p>
<p><strong>Imagine the first case. We have:</strong></p>
<pre><code>a = [2,1,0]

a[0], a[a[0]] = a[a[0]], a[0]
</code></pre>
<p>When we start to execute this code, the right side evaluates first, so we will have</p>
<pre><code>a[0], a[a[0]] = a[a[0]], a[0]    # a[a[0]] == 0, a[0] == 2, a == [2, 1, 0]
</code></pre>
<p>On the right side, we have tuple <code>(0, 2)</code> and <code>a</code> is still <code>[2, 1, 0]</code></p>
<p>Next, we start to assign to the left side of the expression from the left, so to the <code>a[0]</code> we assign the first item from the tuple, which is <code>0</code>. Now we have</p>
<pre><code>a[0], a[a[0]] = (0, 2)   # a[0] == 0, a == [0, 1, 0]
</code></pre>
<p>And now we execute the last part of the assignment, which is to <code>a[a[0]]</code> assign <code>2</code>. But <code>a[0]</code> is now <code>0</code>, so after reduction we assign to <code>a[0]</code> value <code>2</code>. Therefore values after the last assignment are</p>
<pre><code>a[0], a[a[0]] = (0, 2)   # a[a[0]] == 2, a == [2, 1, 0]
</code></pre>
<p>Which seems, that nothing changed and values didn't swap, but as is apparent from above <code>a</code> was <code>[2,1,0]</code>, then <code>[0,1,0]</code> and lastly again <code>[2,1,0]</code>. So it seems, nothing changed and swap doesn't work.</p>
<p><strong>And now the second case, where we only change the order of variables in the expression:</strong></p>
<pre><code>a = [2,1,0]

a[a[0]], a[0] = a[0], a[a[0]]
</code></pre>
<p>When we start to execute this code, the right side evaluates first, so we will have</p>
<pre><code>a[a[0]], a[0] = a[0], a[a[0]]    # a[0] == 2, a[a[0]] == 0, a == [2, 1, 0]
</code></pre>
<p>On the right side, we have tuple <code>(2, 0)</code> and <code>a</code> is still <code>[2, 1, 0]</code></p>
<p>Next, we start to assign to the left side of the expression from the left, so to the <code>a[a[0]]</code> we assign the first item from the tuple, which is <code>2</code>. <code>a[0]</code> is <code>2</code>, so after reduction, we assign to <code>a[2]</code> value <code>2</code>. Now we have</p>
<pre><code>a[a[0]], a[0] = (2, 0)   # a[a[0]] == 2, a == [2, 1, 2]
</code></pre>
<p>And now we execute the last part of the assignment, which is to <code>a[0]</code> assign <code>0</code>. Therefore values after the last assignment are</p>
<pre><code>a[a[0]], a[0] = (2, 0)   # a[0] == 0, a == [0, 1, 2]
</code></pre>
<p>Now this works as expected.</p>
<p>So it is necessary also think about the order when you have dependent variables in your swap expression. As dependent variables I mean that in the first case we have on the left side <code>a[0], a[a[0]]</code> that means <code>a[0]</code> change it's value and <code>a[a[0]]</code> use this changed value, which leads to unwanted behavior.</p>
<p>Finally, regardless of the programming language, it's better not to use dependent variables (array index for another array index etc.), when you want to swap their values.</p>
</div>
<span class="comment-copy">if you use a different list (like <code>a = [1,2,3,4]</code>) you will see it does change the values, but the problem is in the order of execution, so <code>a[a[0]]</code> points to different elements the two times its called.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/8725673/multiple-assignment-and-evaluation-order-in-python">Multiple assignment and evaluation order in Python</a></span>
<span class="comment-copy">Fun fact: if you use <code>a = [2,3,4]</code> instead, you get "List assignment index out of range".</span>
<span class="comment-copy">I believe there's a problem somewhat related to the "sequence points" problem in C++, in that your left-hand side both modifies and uses <code>a[0]</code>.</span>
<span class="comment-copy">I think <code>Swaps the two top-most stack items.</code> is still not an implementation detail. How do these two items swap?</span>
<span class="comment-copy">@Sraw check my updated explanation. I think it would make more sense now</span>
<span class="comment-copy">What about swapping <code>a[a[a[0]]]</code> and <code>a[a[0]]</code>? Would it work?</span>
<span class="comment-copy">I vastly extended my answer, so now you can try your example as the exercise:-)</span>
