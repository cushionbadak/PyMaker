<div class="post-text" itemprop="text">
<p>I have this following list of integers:</p>
<pre><code>prime_factors = [2,3,5,7,11,13,17,19,23]
</code></pre>
<p>What would be an efficient way to multiply elements of each subset of consecutive integers? </p>
<p>To clarify further, I would need the output to include the results of the following multiplications: <code>2*3</code> , <code>3*5</code>, <code>2*3*5</code>, <code>13*17*19</code>, <code>7*11*13*17*19</code>, <code>2*3*5*7*11*13*17*19*23</code> and all other possible combinations of consecutive primes. The output should NOT include <code>2*5</code> or <code>5*7*13</code> etc. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this using <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate</code></a>.</p>
<pre><code>from itertools import accumulate
from operator import mul

def consec_mult(data):
    for i in range(len(data) - 1):
        it = accumulate(data[i:], mul)
        # Skip the single item
        next(it)
        yield from it

# Test

prime_factors = [2, 3, 5, 7, 11]
print(*consec_mult(prime_factors))
</code></pre>
<p><strong>output</strong></p>
<pre><code>6 30 210 2310 15 105 1155 35 385 77
</code></pre>
<p>Or if you want the results sorted in numerical order:</p>
<pre><code>print(*sorted(consec_mult(prime_factors)))
</code></pre>
<p><strong>output</strong></p>
<pre><code>6 15 30 35 77 105 210 385 1155 2310
</code></pre>
</div>
<span class="comment-copy">What have you done so far to solve the problem?</span>
<span class="comment-copy">Seems like an interesting problem.</span>
<span class="comment-copy">@JamesKPolk I used a short list of <code>prime_factors</code> to keep the output short, and easy to verify by eye.</span>
<span class="comment-copy">Ok, I got it. I think another interesting question which I <i>thought</i> OP was asking is how to minimize the number of multiplications. But OP wasn't too clear on that.</span>
<span class="comment-copy">@JamesKPolk Fair enough. My solution doesn't minimize the number of multiplications. OTOH, <code>accumulate</code> is quite efficient, so it may be faster than code that does do that, especially if that code is recursive (since Python function calls are relatively slow). And my code is certainly more compact than code that does fewer multiplications but more explicit loops.</span>
<span class="comment-copy">@PM2Ring thanks for the solution, I think it is efficient enough. What would be a way to include multiplications with repeatable consecutive integers (example 2*3*3, 2*3*3*3, 5*7*7*7*7, 11*11*13 etc) for results under 270059790 (which is the product of all the primes in my original list).  Sorry but I am quite new to itertools and python itself. Hoping to deconstruct your code and understand it better.</span>
<span class="comment-copy">@cheech It depends on what you want to do, exactly. You can just put repeated prime factors in the data you pass to <code>consec_mult</code>, and filter out results that are too high. If that doesn't do what you want then you probably should ask a fresh question, explaining exactly what you need with sample input &amp; output. You can link that question to this one if you like, explaining that it's a follow-on question.</span>
