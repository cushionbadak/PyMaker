<div class="post-text" itemprop="text">
<p>Trying to download and process jpegs from URLs. My issue isn't that certificate verification fails for some URLs, as these URLs are old and may no longer be trustworthy, but that when I <code>try...except...</code> the <code>SSLCertVerificationError</code>, I still get the traceback.</p>
<p>System:
Linux 4.17.14-arch1-1-ARCH, python 3.7.0-3, aiohttp 3.3.2</p>
<p>Minimal example:</p>
<pre><code>import asyncio
import aiohttp
from ssl import SSLCertVerificationError

async def fetch_url(url, client):
    try:
        async with client.get(url) as resp:
            print(resp.status)
            print(await resp.read())
    except SSLCertVerificationError as e:
        print('Error handled')

async def main(urls):
    tasks = []
    async with aiohttp.ClientSession(loop=loop) as client:
        for url in urls:
            task = asyncio.ensure_future(fetch_url(url, client))
            tasks.append(task)
        return await asyncio.gather(*tasks)

loop = asyncio.get_event_loop()
loop.run_until_complete(main(['https://images.photos.com/']))
</code></pre>
<p>Output:</p>
<pre><code>SSL handshake failed on verifying the certificate
protocol: &lt;asyncio.sslproto.SSLProtocol object at 0x7ffbecad8ac8&gt;
transport: &lt;_SelectorSocketTransport fd=6 read=polling write=&lt;idle, bufsize=0&gt;&gt;
Traceback (most recent call last):
  File "/usr/lib/python3.7/asyncio/sslproto.py", line 625, in _on_handshake_complete
    raise handshake_exc
  File "/usr/lib/python3.7/asyncio/sslproto.py", line 189, in feed_ssldata
    self._sslobj.do_handshake()
  File "/usr/lib/python3.7/ssl.py", line 763, in do_handshake
    self._sslobj.do_handshake()
ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: Hostname mismatch, certificate is not valid for 'images.photos.com'. (_ssl.c:1045)
SSL error in data received
protocol: &lt;asyncio.sslproto.SSLProtocol object at 0x7ffbecad8ac8&gt;
transport: &lt;_SelectorSocketTransport closing fd=6 read=idle write=&lt;idle, bufsize=0&gt;&gt;
Traceback (most recent call last):
  File "/usr/lib/python3.7/asyncio/sslproto.py", line 526, in data_received
    ssldata, appdata = self._sslpipe.feed_ssldata(data)
  File "/usr/lib/python3.7/asyncio/sslproto.py", line 189, in feed_ssldata
    self._sslobj.do_handshake()
  File "/usr/lib/python3.7/ssl.py", line 763, in do_handshake
    self._sslobj.do_handshake()
ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: Hostname mismatch, certificate is not valid for 'images.photos.com'. (_ssl.c:1045)
Error handled
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The traceback is generated by asyncio's implementation of the SSL protocol, which invokes the event loop's <a href="https://github.com/python/cpython/blob/5f79b50763d687aeeed8edcb4efcc7ac9f8fa186/Lib/asyncio/base_events.py#L1610" rel="nofollow noreferrer">exception handler</a>. Through a maze of interactions between the transport and the streaming interface, it happens that this exception is both logged by the event loop and propagated to the API user. The way it happens is as follows:</p>
<ul>
<li>An exception occurs during the SSL handshake.</li>
<li><a href="https://github.com/python/cpython/blob/5f79b50763d687aeeed8edcb4efcc7ac9f8fa186/Lib/asyncio/sslproto.py#L618" rel="nofollow noreferrer"><code>SSLProtocol._on_handshake_complete</code></a> receives non-None <code>handshake_exc</code> and treats it as a "fatal error" (in the handshake context), i.e. invokes <code>self._fatal_error</code> and returns.</li>
<li><a href="https://github.com/python/cpython/blob/5f79b50763d687aeeed8edcb4efcc7ac9f8fa186/Lib/asyncio/sslproto.py#L698" rel="nofollow noreferrer"><code>_fatal_error</code></a> calls the event loop's exception handler to log the error. The handler is normally invoked for exceptions that occur in queued callbacks where there is no longer a caller to propagate them to, so it just logs the traceback to standard error to ensure that the exception doesn't pass silently. However...</li>
<li><code>_fatal_error</code> goes on to call <a href="https://github.com/python/cpython/blob/5f79b50763d687aeeed8edcb4efcc7ac9f8fa186/Lib/asyncio/selector_events.py#L683" rel="nofollow noreferrer"><code>transport._force_close</code></a>, which calls <code>connection_lost</code> back on the protocol.</li>
<li>The stream reader protocol's <code>connection_lost</code> <a href="https://github.com/python/cpython/blob/5f79b50763d687aeeed8edcb4efcc7ac9f8fa186/Lib/asyncio/streams.py#L241" rel="nofollow noreferrer">implementation</a> sets the exception as the result of the stream reader's future, thus propagating it to the users of the stream API that await it.</li>
</ul>
<p>It is not obvious if it is a bug or a feature that the same exception is both logged by the event loop and passed to <code>connection_lost</code>. It might be a workaround for <code>BaseProtocol.connection_lost</code> being <a href="https://github.com/python/cpython/blob/5f79b50763d687aeeed8edcb4efcc7ac9f8fa186/Lib/asyncio/protocols.py#L27" rel="nofollow noreferrer">defined a no-op</a>, so the extra log ensures that a protocol that simply inherits from <code>BaseProtocol</code> doesn't silence the possibly sensitive exceptions occurring during SSL handshake. Whichever the reason, the current behavior leads to the problem experienced by the OP: catching the exception is not enough to suppress it, a traceback will still be logged.</p>
<p>To work around the issue, one can temporarily set the exception handler to one that doesn't report <code>SSLCertVerificationError</code>:</p>
<pre><code>@contextlib.contextmanager
def suppress_ssl_exception_report():
    loop = asyncio.get_event_loop()
    old_handler = loop.get_exception_handler()
    old_handler_fn = old_handler or lambda _loop, ctx: loop.default_exception_handler(ctx)
    def ignore_exc(_loop, ctx):
        exc = ctx.get('exception')
        if isinstance(exc, SSLCertVerificationError):
            return
        old_handler_fn(loop, ctx)
    loop.set_exception_handler(ignore_exc)
    try:
        yield
    finally:
        loop.set_exception_handler(old_handler)
</code></pre>
<p>Adding <code>with suppress_ssl_exception_report()</code> around the code in <code>fetch_url</code> suppresses the unwanted traceback.</p>
<p>The above works, but it strongly feels like a workaround for an underlying issue and not like correct API usage, so I filed a <a href="https://bugs.python.org/issue34506" rel="nofollow noreferrer">bug report</a> in the tracker.</p>
</div>
<div class="post-text" itemprop="text">
<p>For unknown reason (bug?) aiohttp prints error output to console even before any exception thrown. You can avoid it temporary redirecting error output with <a href="https://docs.python.org/3/library/contextlib.html#contextlib.redirect_stderr" rel="nofollow noreferrer">contextlib.redirect_stderr</a>:</p>
<pre><code>import asyncio
import aiohttp
from ssl import SSLCertVerificationError

import os
from contextlib import redirect_stderr


async def fetch_url(url, client):
    try:

        f = open(os.devnull, 'w')
        with redirect_stderr(f):  # ignore any error output inside context

            async with client.get(url) as resp:
                print(resp.status)
                print(await resp.read())
    except SSLCertVerificationError as e:
        print('Error handled')

# ...
</code></pre>
<p><strong>P.S.</strong> I think you can use more common exception type to catch client <a href="https://docs.aiohttp.org/en/stable/client_reference.html#connection-errors" rel="nofollow noreferrer">errors</a>, for example:</p>
<pre><code>except aiohttp.ClientConnectionError as e:
    print('Error handled')
</code></pre>
</div>
<span class="comment-copy">The exception is logged not by aiohtp itself but by asyncio. Nothing to do on aiohttp side.</span>
<span class="comment-copy">Noted, thank you.</span>
<span class="comment-copy">I see. Thank you for this detailed explaination. I'm grateful to learn more about how things work under the hood.</span>
<span class="comment-copy">Tried it out and it seems to work in my actual function. Thank you.</span>
<span class="comment-copy">Bug report <a href="https://bugs.python.org/issue34506" rel="nofollow noreferrer">logged</a> to the bug tracker.</span>
<span class="comment-copy">It seems this solution sometimes raises another exception when handling <code>asyncio.TimeoutError</code>, saying that <code>ignore_exc</code> is missing an argument <code>ctx</code> with traceback to the line <code>old_handler_fn(ctx)</code> withiin <code>ignore_exc</code> itself (so some kind of unexpected recursion).</span>
<span class="comment-copy">Should be noted that in my program I modified your example to ignore the more general <code>ssl.SSLError</code>.</span>
<span class="comment-copy">Your solution works in the example but doesn't work in my actual code. The code in the redirect block doesn't get excuted.</span>
