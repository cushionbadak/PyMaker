<div class="post-text" itemprop="text">
<p>I have a string that holds data. And I want everything in between <strong>({ and })</strong><br/></p>
<pre><code>"({Simple Data})"
</code></pre>
<p>Should return "Simple Data"</p>
</div>
<div class="post-text" itemprop="text">
<p>Or regex:</p>
<pre><code>s = '({Simple Data})'
print(re.search('\({([^})]+)', s).group(1))
</code></pre>
<p>Output:</p>
<pre><code>'Simple Data'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try the following:</p>
<pre><code>^\({(.*)}\)$
</code></pre>
<p>Group 1 will contain <code>Simple Data</code>.</p>
<p>See an <a href="https://regexr.com/3ub9m" rel="nofollow noreferrer">example on regexr</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the brackets are always positioned at the beginning and the end of the string, then you can do this:</p>
<pre><code>l = "({Simple Data})"
print(l[2:-2])
</code></pre>
<p>Which resulst in:</p>
<pre><code>"Simple Data"
</code></pre>
<p>In Python you can access single characters via the [] operator. With this you can access the sequence of characters starting with the third one (index = 2) up to the second-to-last (index = -2, second-to-last is not included in the sequence).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try this regex <code>(?s)\(\{(.*?)\}\)</code><br/>
which simply captures the contents between the delimiters.  </p>
<p>Beware though, this doesn't account for nesting.   </p>
<p>If nesting is a concern, the best you can to with standard Python <code>re</code> engine<br/>
is to get the inner nest only, using this regex:  </p>
<p><code>\(\{((?:(?!\(\{|\}\).)*)\}\)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Hereby I designed a tokenizer aimming at nesting data. OP should check out <a href="https://docs.python.org/3/library/re.html?highlight=flags#writing-a-tokenizer" rel="nofollow noreferrer">here</a>.</p>
<pre><code>import collections
import re

Token = collections.namedtuple('Token', ['typ', 'value', 'line', 'column'])

def tokenize(code):
    token_specification = [
        ('DATA',        r'[ \t]*[\w]+[\w \t]*'),
        ('SKIP',        r'[ \t\f\v]+'),
        ('NEWLINE',     r'\n|\r\n'),
        ('BOUND_L',     r'\(\{'),
        ('BOUND_R',     r'\}\)'),
        ('MISMATCH',    r'.'),
    ]
    tok_regex = '|'.join('(?P&lt;%s&gt;%s)' % pair for pair in token_specification)
    line_num = 1
    line_start = 0
    lines = code.splitlines()
    for mo in re.finditer(tok_regex, code):
        kind = mo.lastgroup
        value = mo.group(kind)
        if kind == 'NEWLINE':
            line_start = mo.end()
            line_num += 1
        elif kind == 'SKIP':
            pass
        else:
            column = mo.start() - line_start
            yield Token(kind, value, line_num, column)

statements = '''
    ({Simple Data})
    ({
        Parent Data Prefix
        ({Nested Data (Yes)})
        Parent Data Suffix
    })
'''

queue = collections.deque()

for token in tokenize(statements):
    if token.typ == 'DATA' or token.typ == 'MISMATCH':
        queue.append(token.value)
    elif token.typ == 'BOUND_L' or token.typ == 'BOUND_R':
        print(''.join(queue))
        queue.clear()
</code></pre>
<p>Output of this code should be:</p>
<pre><code>Simple Data
    Parent Data Prefix
Nested Data (Yes)
    Parent Data Suffix
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/38999344/extract-string-within-parentheses-python">Extract string within parentheses - PYTHON</a></span>
<span class="comment-copy">@U9-Forward I believe this question is about tokenizer and parser if it involves nesting structures.</span>
<span class="comment-copy">Doesn't work for: <code>'blah({Simple Data})'</code></span>
<span class="comment-copy">@U9-Forward That is why I specified that this solution is valid if the brackets are always positioned at the end and the beginning of the string.</span>
