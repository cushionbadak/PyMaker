<div class="post-text" itemprop="text">
<p>I'm tasked with building a consumer of an API that requires an encrypted token with a seed value that is the UNIX time. The example I was shown was implemented using Java which I'm unfamiliar with, and after reading through documentation and other stack articles have been unable to find a solution.</p>
<p>Using the <code>javax.crypto.SecretKey</code>, <code>javax.crypto.SecretKeyFactory</code>, <code>javax.crypto.spec.PBEKeySpec</code>, and <code>javax.crypto.spec.SecretKeySpec</code> protocols, I need to generate a token similar to the below:</p>
<pre><code>public class EncryptionTokenDemo {

    public static void main(String args[]) {
        long millis = System.currentTimeMillis();
        String time = String.valueOf(millis);
        String secretKey = "somekeyvalue";
        int iterations = 12345;
        String iters = String.valueOf(iterations);
        String strToEncrypt_acctnum = "somevalue|" + time + "|" + iterations;

        try {

            byte[] input = strToEncrypt_acctnum.toString().getBytes("utf-8");
            byte[] salt = secretKey.getBytes("utf-8");
            SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
            SecretKey tmp = factory.generateSecret(new PBEKeySpec(secretKey.toCharArray(), salt, iterations, 256));
            SecretKeySpec skc = new SecretKeySpec(tmp.getEncoded(), "AES");
            Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, skc);
            byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
            int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
            ctLength += cipher.doFinal(cipherText, ctLength);
            String query = Base64.encodeBase64URLSafeString(cipherText);
            // String query = cipherText.toString();
            System.out.println("The unix time in ms is :: " + time);
            System.out.println("Encrypted Token is :: " + query);
        } catch (Exception e) {
            System.out.println("Error while encrypting :" + e);

        }

    }
}
</code></pre>
<p>Should I be using the built-in library <code>hashlib</code> to implement something like this? I can't really find documentation for implementing a <code>PBKDF2</code> encryption with iterations/salt as inputs. Should I be using <code>pbkdf2</code>? Sorry for the vague questions, I'm unfamiliar with the encryption process and feel like even just knowing what the correct constructor would be is a step in the right direction. </p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, the Python equivalent is <a href="https://docs.python.org/3/library/hashlib.html#hashlib.pbkdf2_hmac" rel="noreferrer"><code>hashlib.pbkdf2_hmac</code></a>. For example this code:  </p>
<pre><code>from hashlib import pbkdf2_hmac

key = pbkdf2_hmac(
    hash_name = 'sha1', 
    password = b"somekeyvalue", 
    salt = b"somekeyvalue", 
    iterations = 12345, 
    dklen = 32
)

print(key)
</code></pre>
<p>produces the same key as your Java code.  </p>
<p>However, the problem with this code (as mentioned in memo's <a href="https://stackoverflow.com/questions/52009682/python-equivalent-of-java-pbkdf2withhmacsha1#comment91054901_52009682">comment</a>) is the use of salt. The salt should be random and unique for each password. You can create secure random bytes with <code>os.urandom</code>, so a better example would be:  </p>
<pre><code>from hashlib import pbkdf2_hmac
from os import urandom

salt = urandom(16)
key = pbkdf2_hmac('sha1', b"somekeyvalue", salt, 12345, 32)
</code></pre>
<p>You may also want to increase the number of iterations (I think the recommended minimum number is 10,000).  </p>
<hr/>
<p>The rest of the code is easy to 'translate'.  </p>
<ul>
<li><p>For the timestamp, use <code>time.time</code> to get the current time and multiply by 1000.  </p>
<pre><code>import time

milliseconds = str(round(time.time() * 1000))
</code></pre></li>
<li><p>For encoding you can use <a href="https://docs.python.org/3/library/base64.html#base64.urlsafe_b64encode" rel="noreferrer"><code>base64.urlsafe_b64encode</code></a> (it includes padding, but you could remove it with <code>.rstrip(b'=')</code>).</p></li>
<li><p>Now, for the encryption part, Python doesn't have a built-in encryption module, so you'll have to use a third party library. I recommend <a href="https://pycryptodome.readthedocs.io/en/latest/index.html" rel="noreferrer"><code>pycryptodome</code></a> or <a href="https://cryptography.io/en/latest/" rel="noreferrer"><code>cryptography</code></a>.<br/>
At this point I must warn you that the AES mode you're using is very weak. Please consider using CBC or CTR, or better yet use an <a href="https://en.wikipedia.org/wiki/Authenticated_encryption" rel="noreferrer">authenticated encryption</a> algorithm. </p></li>
</ul>
</div>
<span class="comment-copy">Wrote this years ago, should be an OK starting point: <a href="https://gist.github.com/is/13a519282e676dca861e" rel="nofollow noreferrer">gist.github.com/is/13a519282e676dca861e</a></span>
<span class="comment-copy">Just a remark: the salt in your code is not supposed to be same as the key. Either generate a deterministic <i>non-repeating</i> sequence, or use SecureRandom to generate it; then transmit it along with the encrypted message.</span>
<span class="comment-copy">Thanks for the great info adam. The information on salt is especially helpful. The API service actually provided this example to me with regard to salt creation so I can provide that feedback moving forward. Accepted and appreciated</span>
<span class="comment-copy">Thanks again for this Adam; just to follow-up; what is the difference between <code>skc</code> and <code>tmp</code> in the above <code>java</code> example? I was able to reproduce <code>tmp</code> using the method you had mentioned but do I need an <code>AES</code> instance to create the <code>SecretKeySpec</code>? if not how would I go getting the equivalent value of skc?</span>
<span class="comment-copy">Both <code>skc</code> and <code>tmp</code> contain the same key - the same bytes. We must specify the encryption algorithm for the <code>key</code> parameter in <a href="https://docs.oracle.com/javase/8/docs/api/javax/crypto/Cipher.html#init-int-java.security.Key-" rel="nofollow noreferrer"><code>cipher.init</code></a>, so we use a <a href="https://docs.oracle.com/javase/8/docs/api/javax/crypto/spec/SecretKeySpec.html#SecretKeySpec-byte:A-java.lang.String-" rel="nofollow noreferrer"><code>SecretKeySpec</code></a> object with <code>"AES"</code> for the <code>algorithm</code> parameter. It's basically the same key, just different objects.</span>
<span class="comment-copy">Ah ok, so the actual bytes are the same but the <code>AES</code> field on that <code>SecretKey</code> object is what is used by the <code>Cipher</code> object? is there any examples of the implementation of that type of cypher in python?</span>
<span class="comment-copy">Yes, we use <code>SecretKey</code> because it's a more suitable  type, but the actual key is the same. Python doesn't have a built-in encryption library, but I can recommend <a href="https://pycryptodome.readthedocs.io/en/latest/index.html" rel="nofollow noreferrer">pycryptodome</a>. You'll find some AES examples in <a href="https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html" rel="nofollow noreferrer"><code>Crypto.Cipher.AES</code></a>. I would provide a compatible Python example, but your java code has vary poor security. It uses ECB and doesn't perform authentication. I would advise the api developers to hire a security expert.</span>
