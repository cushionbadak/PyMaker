<div class="post-text" itemprop="text">
<p>I want to implement a function, generate_perm(m,n), where it takes two arguments, one is for numbers to permutate (m) and second is to what the sum of the permutation must equate to (n).</p>
<pre><code>def generate_perm(m,n):
    '''
     implement this
    '''
    return
</code></pre>
<p><code>generate_perm(2,5)</code> should output</p>
<pre><code>[(1,4), (2,3), (3,2) (4,1)]
</code></pre>
<p>and</p>
<p><code>generate_perm(3,5)</code> should output:</p>
<pre><code>[(1,1,3), (1,2,2), (1,3,1), (2,1,2), (2,2,1), (3,1,1)]
</code></pre>
<p>EDIT
i havent gotten far</p>
<pre><code>def generate_permutations(m, n):
    all = []
    cur = [0 for i in range(m)]
    len_perm = m*2
    while True:
        for i in range(m):
            if cur[i] == 0: # initial case
                if i != m-1:
                    cur[i] = 1
                else:
                    cur[i] = n-m

        all.append(cur)
        if len(all) &gt;= len_perm:
            break
    return all
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One simple recursive approach without any libraries:</p>
<pre><code>def perm(m, n):
  if m == 1:  # base case
    return [(n,)]
  perms = []
  for s in range(1, n):  # combine possible start values: 1 through n-1 ...
    for p in perm(m-1, n-s):  # ... with all appropriate smaller perms 
      perms.append((s,) + p)
  return perms

&gt;&gt;&gt; perm(1, 5)
[(5,)]
&gt;&gt;&gt; perm(2, 5)
[(1, 4), (2, 3), (3, 2), (4, 1)]
&gt;&gt;&gt; perm(3, 5)
[(1, 1, 3), (1, 2, 2), (1, 3, 1), (2, 1, 2), (2, 2, 1), (3, 1, 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Consider a list <code>l = [1,2,3,4,5]</code></p>
<p>You can get all the permutations with <code>itertools.permutations</code></p>
<pre><code>p = itertools.permutations(list(range(1,6)),2)
</code></pre>
<p>and then filter them</p>
<pre><code>my_elems = [el for el in p if sum(el) == 5]
</code></pre>
<p>outputs </p>
<pre><code>[(1, 4), (2, 3), (3, 2), (4, 1)]
</code></pre>
<p>Looking at the second example you give, I think what you want is a <code>product</code>, not <code>permutations</code>:</p>
<pre><code>p = itertools.product(list(range(1,6)),repeat=3)

my_elems = [el for el in p if sum(el) == 5]

#[(1, 1, 3), (1, 2, 2), (1, 3, 1), (2, 1, 2), (2, 2, 1), (3, 1, 1)]
</code></pre>
<p>and which works also for the first case.</p>
</div>
<span class="comment-copy">You are supposed to submit your attempts so far.</span>
<span class="comment-copy">Have a look at <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>itertools.permutations</code></a> for a start.</span>
<span class="comment-copy">@coldspeed this is not a homework. im not even in school</span>
<span class="comment-copy">@MisterMiyagi i would like to do this without using any liberaries which already calculate permuations</span>
<span class="comment-copy">@taras i am practicing coding for my personal fun ie there is no benefit for me to actually get the func implemented other than to learn the algorithm so if i use some library to accomplish that, then i wouldn't really learn</span>
<span class="comment-copy">thank you! this seems to work. so this would be O(n^m)?</span>
<span class="comment-copy">I don't think it is that simple. One would have to solve the appropriate recurrence equation :( the data structures used here also aren't optimal, e.g. <code>(s,) + p</code> itself is <code>O(len(p))</code> for tuples.</span>
