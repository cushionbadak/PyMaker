<div class="post-text" itemprop="text">
<p>I am trying to implement logging for my flask project on a virtual machine (running Ubuntu-16.04). I have the following function for creating a new directory.</p>
<pre><code>def mkdir_p(path):
    try:
        pathlib.Path(path).mkdir(parents=True, exist_ok=True)
    except FileExistsError as exc:
        raise
</code></pre>
<p>And the following file handler inheriting from RotatingFileHandler.</p>
<pre><code>class MyRotatingFileHandler(RotatingFileHandler):
    def __init__(self, filename, mode='a', maxBytes=0, backupCount=0, encoding=None, delay=0):
        mkdir_p(os.path.dirname(filename))
        RotatingFileHandler.__init__(self, filename, mode, maxBytes, backupCount, encoding, delay)
</code></pre>
<p>This all works fine when registering a new logger at runtime, on my local machine, but when I try and run this same code on an azure instance, the path and file I am passing in ('log/error.log'), isn't created.</p>
<p>I have made sure the user running the code has write permissions set on the directory. I really can't think of any other reason why this might be happening though.</p>
</div>
<div class="post-text" itemprop="text">
<p>For anyone it might help, the <a href="https://stackoverflow.com/questions/48836470/uwsgi-flask-logging-config-not-working-and-also-breaks-application">following</a> link may provide some useful explanation, but in essence, when using external application server to serve your application (as opposed to the dedicated Flask runtime, Werkzeug) you need to make sure your logger definitions occur <strong>before</strong> you register your Flask app, as follows.</p>
<pre><code># add logger
logger = logging.getLogger('flask.app')
...
# register flask
app = Flask(__name__)

...

if __name__ == '__main__':
    app.run("0.0.0.0", threaded=True)
</code></pre>
<blockquote>
<p>When you want to configure logging for your project, you should do it as soon as possible when the program starts. If app.logger is accessed before logging is configured, it will add a default handler. If possible, configure logging before creating the application object. - <a href="http://flask.pocoo.org/docs/1.0/logging/" rel="nofollow noreferrer">Flask Docs - Logging</a> </p>
</blockquote>
<p>I was using uWSGI to serve my application, but I was instantiating my logger after my Flask app, and inside the <code>if __name__ = '__main__':</code> blocks, which is why it worked fine in my local configuration but stopped working the minute I pushed it to production.</p>
</div>
<span class="comment-copy">can you make sure, that MyRotatingFileHandler.__init__() is actually called?</span>
<span class="comment-copy">why not use <code>os.makedirs(os.path.dirname(filename))</code> and what's with the redundant raise in mkdir_p?</span>
<span class="comment-copy">Exception <code>TypeError: mkdir() got an unexpected keyword argument 'exist_ok'</code> was raised on Python3.4.4</span>
<span class="comment-copy">@JoshuaNixon That arg is new with 3.5. See <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir" rel="nofollow noreferrer">docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir</a></span>
<span class="comment-copy">So it's probably a Good Idea to verify that azure is running 3.5, at least.</span>
