<div class="post-text" itemprop="text">
<p>In Python 3, it is standard procedure to make a class an iterable and iterator at the same time by defining both the <code>__iter__</code> and <code>__next__</code> methods. But I have problems to wrap my head around this. Take this example which creates an iterator that produces only even numbers:</p>
<pre><code>class EvenNumbers:

    def __init__(self, max_):
        self.max_ = max_

    def __iter__(self):
        self.n = 0
        return self

    def __next__(self):
        if self.n &lt;= self.max:
            result = 2 * self.n
            self.n += 1
            return result

        raise StopIteration

instance = EvenNumbers(4)

for entry in instance:
    print(entry)
</code></pre>
<p>To my knowledge (correct me if I'm wrong), when I create the loop, an iterator is created by calling something like <code>itr = iter(instance)</code> which internally calls the <code>__iter__</code> method. This is expected to return an iterator object (which the instance is due to defining <code>__next__</code> and therefore I can just return self). To get an element from it, <code>next(itr)</code> is called until the exception is raised. </p>
<p>My question here is now: if and how can <code>__iter__</code> and <code>__next__</code> be separated, so that the content of the latter function is defined somewhere else? And when could this be useful? I know that I have to change <code>__iter__</code> so that it returns an iterator.</p>
<p>Btw the idea to do this comes from this site (<a href="https://nvie.com/posts/iterators-vs-generators/" rel="nofollow noreferrer">LINK</a>), which does not state how to implement this.</p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you're confusing <strong>iterators</strong> and <strong>iterables</strong>. Iterables have an <code>__iter__</code> method which returns an iterator. Iterators have a <code>__next__</code> method which returns either their next value or raise a <code>StopIteration</code>. Now in python, it is <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">stated</a> that iterators are also iterables (but not visa versa) and that <code>iter(iterator) is iterator</code> so an iterator, <code>itr</code>, should return only itself from it's <code>__iter__</code> method.</p>
<blockquote>
<p>Iterators are required to have an <code>__iter__()</code> method that returns the iterator object itself so every iterator is also iterable and may be used in most places where other iterables are accepted</p>
</blockquote>
<p>In code:</p>
<pre><code>class MyIter:
   def __iter__(self):
       return self

   def __next__(self):
       # actual iterator logic
</code></pre>
<p>If you want to make a custom iterator class, the easiest way is to inherit from <a href="https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L259" rel="nofollow noreferrer"><code>collections.abc.Iterator</code></a> which you can see defines <code>__iter__</code> as above (it is also a subclass of <code>collections.abc.Iterable</code>). Then all you need is</p>
<pre><code>class MyIter(collections.abc.Iterator):
    def __next__(self):
        ...
</code></pre>
<p>There is of course a much easier way to make an iterator, and thats with a generator function</p>
<pre><code>def fib():
    a = 1
    b = 1
    yield a
    yield b
    while True:
        b, a = a + b, b
        yield b

list(itertools.takewhile(lambda x: x &lt; 100, fib()))
# --&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
</code></pre>
<hr/>
<p>Just for reference, this is (simplified) code for an abstract iterator and iterable</p>
<pre><code>from abc import ABC, abstractmethod

class Iterable(ABC):

    @abstractmethod
    def __iter__(self):
        'Returns an instance of Iterator'
        pass

class Iterator(Iterable, ABC):

    @abstractmethod
    def __next__(self):
        'Return the next item from the iterator. When exhausted, raise StopIteration'
        pass

    # overloads Iterable.__iter__
    def __iter__(self):
        return self
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think I have grasped the concept now, even if I do not fully understand the passage from the documentation by @FHTMitchell. I came across an example on how to separate the two methods and wanted to document this.</p>
<p>What I found is a very <a href="https://dbader.org/blog/python-iterators" rel="nofollow noreferrer">basic tutorial</a> that clearly distinguishes between the iterable and the iterator (which is the cause of my confusion).</p>
<p>Basically, you define your iterable first as a separate class:</p>
<pre><code>class EvenNumbers:

    def __init__(self, max_):
        self.max = max_

    def __iter__(self):
        self.n = 0
        return EvenNumbersIterator(self)
</code></pre>
<p>The <code>__iter__</code> method only requires an object that has a <code>__next__</code> method defined. Therefore, you can do this:</p>
<pre><code>class EvenNumbersIterator:

    def __init__(self, source):
        self.source = source       

    def __next__(self):
        if self.source.n &lt;= self.source.max:
            result = 2 * self.source.n
            self.source.n += 1
            return result
        else:
            raise StopIteration
</code></pre>
<p>This separates the iterator part from the iterable class. It now makes sense that if I define <code>__next__</code> within the iterable class, I have to return the reference to the instance itself as it basically does 2 jobs at once.</p>
</div>
<span class="comment-copy">Even when you seperate them, the one that implements <code>__next__</code> also <i>has</i> to implement <code>__iter__</code> (returning itself).</span>
<span class="comment-copy">Thank you, but I need some clarification: if I define <code>__iter__</code> in a class, I tell the interpreter that it is an iterable. When I return self in this method, then I return the instance and not an iterator object, right? But according to the docs this should be an iterator object and this confuses me.</span>
<span class="comment-copy">If you define <code>__iter__</code> then the object is <b>iterable</b>. If you define <code>__next__</code> the object is an <b>iterator</b>. On <b>iterator</b> objects, you should set <code>__iter__</code> to return the object itself, which as I said, is an <b>iterator</b>. <b>iterators</b> are <b>iterables</b> that when iterated over (e.g. for loop), return themselves.</span>
<span class="comment-copy">Your iterator isn't a valid iterator (or at least breaks conventions and could lead to confusing errors) since iterators must also be iterable as discussed in my answer. You either need to inherit from <code>collections.abc.Iterator</code> or define <code>def __iter__(self): return self</code>.</span>
