<div class="post-text" itemprop="text">
<p>Let's say I have a class, members of which I want to compare with the usual operators <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p>
<p>As I understand, this could be accomplished by initializing defining magic method <code>__cmp__(a, b)</code> which returns -1 (<code>a &lt; b</code>), 0 (<code>a == b</code>), or 1 (<code>a &gt; b</code>).</p>
<p>It seems like <code>__cmp__</code> <a href="https://docs.python.org/release/3.0.1/whatsnew/3.0.html#ordering-comparisons" rel="nofollow noreferrer">was deprecated since Python 3</a> in favor of defining <code>__eq__</code>, <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, and <code>_ge__</code> methods separately.</p>
<p>I defined <code>__eq__</code> and <code>__lt__</code> assuming that the default values for <code>__le__</code> would look something like <code>return a == b or a &lt; b</code>. It seems to be not the case with the following class:</p>
<pre><code>class PQItem:
    def __init__(self, priority, item):
        self.priority = priority
        self.item = item

    def __eq__(self, other):
        return isinstance(other, PQItem) and self.priority == other.priority

    def __lt__(self, other):
        return isinstance(other, PQItem) and self.priority &lt; other.priority

class NotComparable:
    pass

x = NotComparable()
y = NotComparable()
# x &lt; y gives error
</code></pre>
<p>And I get this outcome:</p>
<pre><code>&gt;&gt;&gt; PQItem(1, x) == PQItem(1, y)
True
&gt;&gt;&gt; PQItem(1, x) &lt; PQItem(1, y)
False
&gt;&gt;&gt; PQItem(1, x) &lt;= PQItem(1, y)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: PQItem() &lt;= PQItem()
</code></pre>
<p>This has left me to conclude that I'll have to define all the comparison magic methods manually to make a class comparable. Is there any better way?</p>
<p>Why has <code>__cmp__</code> been deprecated? That seems like a much nicer way to deal with it</p>
</div>
<div class="post-text" itemprop="text">
<p>For two objects <code>a</code> and <code>b</code>, <code>__cmp__</code> requires that <em>one of</em> <code>a &lt; b</code>, <code>a == b</code>, and <code>a &gt; b</code> is true.  But that might not be the case: consider sets, where it's very common that <em>none of those</em> are true, e.g. <code>{1, 2, 3}</code> vs <code>{4, 5, 6}</code>.</p>
<p>So <code>__lt__</code> and the likes were introduced.  But that left Python with two separate ordering mechanisms, which is kind of ridiculous, so the less flexible one was removed in Python 3.</p>
<p>You don't actually have to implement all six comparison methods. You can use the <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="noreferrer"><code>functools.total_ordering</code></a> class decorator to help define the rest of the magic comparison methods:</p>
<pre><code>from functools import total_ordering
@total_ordering
class PQItem:
    def __init__(self, priority, item):
        self.priority = priority
        self.item = item

    def __eq__(self, other):
        return isinstance(other, PQItem) and self.priority == other.priority

    def __lt__(self, other):
        return isinstance(other, PQItem) and self.priority &lt; other.priority
</code></pre>
</div>
