<div class="post-text" itemprop="text">
<p>Hi I want to merge two dictionaries' values if the keys are the same. </p>
<pre><code>DIC_01
{'A': ['Zero'],
 'B': ['Zero'],
 'C': ['Zero'],
 'D': ['Zero']}

DIC_02
 {'A': [2338.099365234375,
  -3633.070068359375,
  -73.45938873291016],
 'D':[2839.291015625,
  -2248.350341796875,
  1557.59423828125]}
</code></pre>
<p>Idea output</p>
<pre><code>{'A': [[2338.099365234375,
-3633.070068359375,
-73.45938873291016],['Zero']],
'D': [[2839.291015625,
-2248.350341796875,
1557.59423828125]['Zero']]}
</code></pre>
<p>Output for the Keys that cannot be found</p>
<pre><code>{'B': ['Zero'],'C': ['Zero']}
</code></pre>
<p>I tried</p>
<pre><code>NO_MATCH={}
for k in DIC_01.keys():
    DOC={}
    for k2 in DIC_02.keys():
        if k == k2:
            DOC = k.values().update(k2.values())
        else:
            NO_MATCH.update(DIC_01)
</code></pre>
<p>There is nothing in DOC and all the dictionary elements are in NO_MATCH, no error message. don't know where goes wrong, also I think there must be better ways to do this.
Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>Edited: You can declare two separate dictionaries and iterate through all the keys of both dictionaries. For every iteration, check if the key exists in <code>DIC_02</code> and <code>DIC_01</code> and concatenate the two corresponding lists  </p>
<pre><code>match, no_match = {}, {}
for i in {**DIC_01,**DIC_02}.keys():
    if i in DIC_01 and i in DIC_02:
        match[i] = DIC_01[i] + DIC_02[i]
    else:
        no_match[i] = DIC_01.get(i,[]) + DIC_02.get(i,[])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not particularly fancy but this should solve what you're looking for</p>
<pre><code>def merge(a, b):
  out = {}
  for key in a.keys() | b.keys():
    if key in a and key in b:
      out[key] = [a[key], b[key]]
    elif key in a:
      out[key] = a[key]
    else:
      out[key] = b[key]
  return out
</code></pre>
<p>where <code>a</code> and <code>b</code> are <code>dict</code>s. The <code>|</code> takes the union of the two key sets.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>As for why your code goes wrong.</p>
</blockquote>
<pre><code>NO_MATCH={}
for k in DIC_01.keys():
    DOC={}                   # (1)
    for k2 in DIC_02.keys(): # (2)
        if k == k2:
            DOC = k.values().update(k2.values()) # (3)
        else:
            NO_MATCH.update(DIC_01) # (4)
</code></pre>
<ol>
<li>Not there! Everything you define inside a loop, will be redefined everytime the loop goes around.</li>
<li>This goes to the else block even if there's a matched key. For instance, in your case, it compares <code>A</code> in <code>DIC_01</code> with <code>A</code> in <code>DIC_02</code>, <code>"ok, A matched"</code>. BUT, then it proceeds to compare <code>A</code> in <code>DIC_01</code> with <code>D</code> in <code>DIC_02</code>, <code>"ok, A not found in DIC_02, not matched, add to NOT_MATCH"</code> which is wrong, because <code>A</code> IS a matched key and <code>A</code> IS in <code>DIC_02</code>.</li>
<li>Not sure how you didn't get an error, seems very erroneous.</li>
<li>This lines add the entire <code>DIC_01</code> to <code>NO_MATCH</code>, wrong!</li>
</ol>
<p><strong><em>FIX:</em></strong></p>
<pre><code>MATCH = {}
NO_MATCH = {}

# This goes through all keys in DIC_01. If a key is also found in DIC_02,
# it's a "matched" key so it adds that key to the MATCH variable. If it's
# not in DIC_02, it's a "no matched" key -&gt; add key to NO_MATCH variable.
for k in DIC_01.keys():
    if k in DIC_02.keys():
        MATCH[k] = [DIC_01[k], DIC_02[k]]
    else:
        NO_MATCH[k] = DIC_01[k]

# BUT...We are still missing the keys that are only in DIC_02. So we need
# another loop
for k in DIC_02.keys():
    if k not in DIC_01.keys():
        NO_MATCH[k] = DIC_02[k]
# This is the same as the loop above, without the if block.
</code></pre>
<blockquote>
<p><strong><em>BETTER WAY</em></strong></p>
</blockquote>
<p>Some list comprehensions would keep things clean.</p>
<pre><code>MATCH = {key:[DIC_01[key], DIC_02[key]] for key in DIC_01 if key in DIC_02}

unmatch_1 = {key:DIC_01[key] for key in DIC_01 if key not in DIC_02}
unmatch_2 = {key:DIC_02[key] for key in DIC_02 if key not in DIC_01}
NOT_MATCH = {**unmatch_1, **unmatch_2}
</code></pre>
<p><strong><em>EXPLAINATION:</em></strong></p>
<pre><code>MATCH = {key:[DIC_01[key], DIC_02[key]] for key in DIC_01 if key in DIC_02}
</code></pre>
<p>This, in English, create a new dictionary called <code>match</code>.For every key in <code>DIC_01</code>, if the key is also in <code>DIC_02</code>, create the same key in <code>match</code> and assign both the values of that key from <code>DIC_01</code> and <code>DIC_02</code>.</p>
<pre><code>unmatch_1 = {key:DIC_01[key] for key in DIC_01 if key not in DIC_02}
</code></pre>
<p>This ... For every key in <code>DIC_01</code>, if it's not in <code>DIC_02</code>, create a key and assign the associated value from <code>DIC_01</code></p>
<pre><code>unmatch_2 = {key:DIC_02[key] for key in DIC_02 if key not in DIC_01}
</code></pre>
<p>This ... For every key in <code>DIC_02</code>, if it's not in <code>DIC_01</code>, create a key and assign the associated value from <code>DIC_02</code></p>
<pre><code>UNMATCH = {**unmatch_1, **unmatch_2}
</code></pre>
<p>This ... is a cool way of merging 2 dictionaries (Only for Python 3.5 and up)</p>
</div>
<div class="post-text" itemprop="text">
<p>This looks like a great use for <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer"><code>ChainMap</code></a></p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>&gt;&gt;&gt; a={'A': ['Zero'],
...  'B': ['Zero'],
...  'C': ['Zero'],
...  'D': ['Zero']}
&gt;&gt;&gt; b={'A': [2338.099365234375,
...   -3633.070068359375,
...   -73.45938873291016],
...  'D':[2839.291015625,
...   -2248.350341796875,
...   1557.59423828125]}
&gt;&gt;&gt; map=ChainMap(b,a)
&gt;&gt;&gt; map['A']
[2338.099365234375, -3633.070068359375, -73.45938873291016]
&gt;&gt;&gt; map['C']
['Zero']</code></pre>
</div>
</div>
</p>
<p>The key precedence will be on the order of the dictionaries, so if you can't control order or if the <code>['Zero']</code> are mixed and matched: this way can't help.</p>
</div>
<span class="comment-copy">Do you want one dict for the output,  or two separate dicts?</span>
<span class="comment-copy">@DYZ I researched online but haven't found a way to give me the output i want.</span>
<span class="comment-copy">@wim  I want one dictionary for matched key found, and another one for no matched key found.</span>
<span class="comment-copy">There is nothing to research here, just use your programming skills. SO is not a free coding service, you must demostrate your effort to get help.</span>
<span class="comment-copy">Hint: <code>D1.keys() &amp; D2.keys()</code> gives keys that are in both dicts.  <code>D1.keys() - D2.keys()</code> gives keys that are only in D1 dict.</span>
<span class="comment-copy">What happens if <code>DIC_02</code> (I assume the smaller of the two dicts) has a key that <code>DIC_01</code> does not have?  i.e. <code>DIC_01 = {'a': 1, 'b': 2} and DIC_02 = {'c': 1}</code></span>
<span class="comment-copy">@kingkupps Thanks for catching that! I updated my code, although I still assumed all the dict values are lists</span>
