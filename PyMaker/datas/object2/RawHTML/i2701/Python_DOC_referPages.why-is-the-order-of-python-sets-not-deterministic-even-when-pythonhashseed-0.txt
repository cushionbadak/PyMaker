<div class="post-text" itemprop="text">
<p>I am developing an agent based model in which I use different type of agents classes whose instances are assigned to different types of objects such as schools, companies, homes, etc. The problem I have is that I cannot enforce reproducibility of runs when debugging, which makes the task very hard because of the model complexity. After a long investigation, I realised that the problem is linked to the order of sets ( built-in random and numpy random seeds are of course applied). Even when I set PYHTONHASHSEED=0, I observe that the order of sets is random at each run. This makes each run of my model different when agents move.</p>
<p>Of course I know that sets are not meant to have an order. I want to use them to make the model as light and fast an possible when removing agents from objects. I want them to behave randomly, except when I need to debug a specific run that raises an exception.</p>
<p>I add the following code so that my claims can be verified. I always set PYTHONHASHSEED from command line via export before launching the code. I print the PYTHONHASHSEED value from code to check that the value has indeed been updated</p>
<pre><code>import os
import random
import numpy as np

print('PYTHON HASH SEED IS', os.environ['PYTHONHASHSEED'])

random.seed(1)
np.random.seed(2)

class S:
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def __repr__(self):
        return "".join([type(self).__name__, "_{0.a!r}_",
                        "School", "_{0.b!r}" ]).format(self)

list1 = np.random.randint(1, 100,size=40)
list2 = np.random.randint(1, 10,size=40)
d1 = dict()
s1 = set()
d1['students'] = s1
# assign students to d1
for s_id, sch_id in zip(list1, list2):
    d1['students'].add(S(s_id, sch_id))

print(s1)
</code></pre>
<p>The strange thing is that if I use integers as set members instead of class instances, I cannot detect the randomness. Does the problem have to do with the fact that the set members are class instances ? Why ?</p>
<p>Of course I could remodel the way agents are assigned to model objects and replace sets with lists, but if possible I would like to understand the problem. The version I use is python 3.5.4</p>
</div>
<div class="post-text" itemprop="text">
<p>The objects you're storing (of type <code>S</code>) are from a class for which no override of <code>__eq__</code> and <code>__hash__</code> has been provided, so <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">they use the default implementation, which is object <em>identity</em> based</a>:</p>
<blockquote>
<p>User-defined classes have <code>__eq__()</code> and <code>__hash__()</code> methods by default; with them, all objects compare unequal (except with themselves) and <code>x.__hash__()</code> returns an appropriate value such that <code>x == y</code> implies both that <code>x is y</code> and <code>hash(x) == hash(y)</code>.</p>
</blockquote>
<p>Object identity is (as an implementation detail of CPython) equivalent to the memory address at which the object was allocated (the raw pointer value), and the allocator is going to return different addresses on each run, so ordering will differ each time. <code>int</code>s don't have this problem because they have non-identity based equality and hashing; they hash based on value, not identity, so the precise memory address is irrelevant.</p>
<p>To get consistent ordering for your custom class with a fixed seed, you'd need to define the special equality and hashing methods, e.g.:</p>
<pre><code>def __hash__(self):
    return hash((self.a, self.b))

def __eq__(self, other):
    if not isinstance(other, S):
        return NotImplemented
    return self.a == other.a and self.b == other.b
</code></pre>
</div>
