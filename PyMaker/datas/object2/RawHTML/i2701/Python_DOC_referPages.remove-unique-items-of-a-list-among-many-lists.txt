<div class="post-text" itemprop="text">
<p>I have these lists which are correct the scenario needed correction is in the explanation part at the end of the question.</p>
<pre><code>ps
['C:\\Users\\user\\Desktop\\sa\\43001\\PST\\PST.shp',
 'C:\\Users\\user\\Desktop\\sa\\43003\\PST\\PST.shp']
</code></pre>
<p>and </p>
<pre><code>db
['C:\\Users\\user\\Desktop\\sa\\43001\\DBOUND\\DBOUND.shp',
 'C:\\Users\\user\\Desktop\\sa\\43003\\DBOUND\\DBOUND.shp']
</code></pre>
<p>I want to compare these lists and if one of them has an item that is unique by means that the [-3] position where is a number as 43001 is unique then that item should be removed. In the end only pairs with same number items should remain.</p>
<p>How do I do that?</p>
<p>my code:</p>
<pre><code>for i,v in list(zip(ps,db)):
    if i.split("\\")[-3] not in v.split("\\")[-3]:
    ps.remove(i)
</code></pre>
<p><strong>Explanation</strong></p>
<p>if the lists are like that:</p>
<pre><code>ps
['C:\\Users\\user\\Desktop\\sa\\43001\\PST\\PST.shp',
 'C:\\Users\\user\\Desktop\\sa\\43003\\PST\\PST.shp']
</code></pre>
<p>and </p>
<pre><code>db
['C:\\Users\\user\\Desktop\\sa\\43001\\DBOUND\\DBOUND.shp',
 'C:\\Users\\user\\Desktop\\sa\\43003\\DBOUND\\DBOUND.shp',
 'C:\\Users\\user\\Desktop\\sa\\43009\\DBOUND\\DBOUND.shp']
</code></pre>
<p>the item with 43009 should be removed  because it doesn't exist in the <code>ps</code> list, and eventually the lists will look like this:</p>
<pre><code>ps
 ['C:\\Users\\user\\Desktop\\sa\\43001\\PST\\PST.shp',
 'C:\\Users\\user\\Desktop\\sa\\43003\\PST\\PST.shp']
</code></pre>
<p>and </p>
<pre><code>db
['C:\\Users\\user\\Desktop\\sa\\43001\\DBOUND\\DBOUND.shp',
 'C:\\Users\\user\\Desktop\\sa\\43003\\DBOUND\\DBOUND.shp']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-python prettyprint-override"><code>ps = ['C:\\Users\\user\\Desktop\\sa\\43001\\PST\\PST.shp',
      'C:\\Users\\user\\Desktop\\sa\\43003\\PST\\PST.shp']

db = ['C:\\Users\\user\\Desktop\\sa\\43001\\DBOUND\\DBOUND.shp',
      'C:\\Users\\user\\Desktop\\sa\\43003\\DBOUND\\DBOUND.shp',
      'C:\\Users\\user\\Desktop\\sa\\43009\\DBOUND\\DBOUND.shp']

filtered_db = [i for i in db if i.split('\\')[-3] in {j.split('\\')[-3] for j in ps}]
print(filtered_db)
# ['C:\\Users\\user\\Desktop\\sa\\43001\\DBOUND\\DBOUND.shp',
#  'C:\\Users\\user\\Desktop\\sa\\43003\\DBOUND\\DBOUND.shp']


filtered_ps = [i for i in ps if i.split('\\')[-3] in {j.split('\\')[-3] for j in db}]
print(filtered_ps)
# ['C:\\Users\\user\\Desktop\\sa\\43001\\PST\\PST.shp',
#   'C:\\Users\\user\\Desktop\\sa\\43003\\PST\\PST.shp']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a set of unique ids. Then use that set to check for paths containing unique ids and remove them accordingly. Something like this:</p>
<pre><code>def get_id(path):
    return path.split('\\')[-3]

unique_ids = [get_id(path) for path in ps+db]
unique_ids = [id_ for id_ in unique_ids if unique_ids.count(id_)==1]

ps = [path for path in ps if get_id(path) not in unique_ids]
db = [path for path in db if get_id(path) not in unique_ids]
</code></pre>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>you can create a temporary list with parsed keys from <code>ps</code> and then create filtered <code>db</code> according to the keys...</p>
<pre><code>parse_key = lambda s: s.split('\\')[-3]

ps = ['C:\\Users\\user\\Desktop\\sa\\43001\\PST\\PST.shp',
      'C:\\Users\\user\\Desktop\\sa\\43003\\PST\\PST.shp']
ps_key = [parse_key(s) for s in ps]
print (ps_key)  # ['43001', '43003']

db = ['C:\\Users\\user\\Desktop\\sa\\43001\\DBOUND\\DBOUND.shp',
      'C:\\Users\\user\\Desktop\\sa\\43003\\DBOUND\\DBOUND.shp',
      'C:\\Users\\user\\Desktop\\sa\\43009\\DBOUND\\DBOUND.shp']
db_key = [parse_key(s) for s in db]
print (db_key)  # ['43001', '43003', '43009']

db_new = [s for s in db if parse_key(s) in ps_key]
print (db_new)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>new_list = [i for i in max(lists, key=len) if i.split('\\')[-3] in {j.split('\\')[-3] for j in min(lists, key=len)}]
</code></pre>
<p>This will even out the larger list, regardless of which one it is, and both will end up having the same number of elements (with the same IDs) in the end. </p>
<p><strong>NOTE</strong>: Only works if you have two lists as presented in the question itself.</p>
</div>
<span class="comment-copy">Could you show what result you want and what your code is returning instead? This could help better understand the issue.</span>
<span class="comment-copy">Please give better examples</span>
<span class="comment-copy">Not completely familiar with Python, but isn't <code>list(zip(ps,db)</code> supposed to be <code>list(zip(ps,db))</code>?</span>
<span class="comment-copy">You want the intersection of the 2 lists</span>
<span class="comment-copy">@bigbounty based on the number only in the [-3] position</span>
<span class="comment-copy">Out of curiosity, why use a dict in that list comprehension? +1 for pythonic as heck :)</span>
<span class="comment-copy">It's not dict, but set. From <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">docs.python.org/3/tutorial/datastructures.html#sets</a> : Similarly to list comprehensions, set comprehensions are also supported: &gt;&gt;&gt; &gt;&gt;&gt; a = {x for x in 'abracadabra' if x not in 'abc'} &gt;&gt;&gt; a {'r', 'd'}</span>
<span class="comment-copy">He wants to remove paths with unique ids from both the lists?</span>
<span class="comment-copy">so when lists have a lot of items and don't know which one of the two lists has the extras that need to be removed how do we proceed for both lists with the filter operation?</span>
<span class="comment-copy">@RishabhAgrahari Don't know. If from both,  apply similay operations on <code>ps</code></span>
<span class="comment-copy">I believe that only <code>db</code> should be filtered, not also <code>ps</code></span>
