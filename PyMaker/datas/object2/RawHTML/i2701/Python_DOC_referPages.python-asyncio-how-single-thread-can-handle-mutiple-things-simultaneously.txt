<div class="post-text" itemprop="text">
<p>Hi I am new to asyncio and concept of event loops (Non-blocking IO)</p>
<pre><code>async def subWorker():
    ...

async def firstWorker():
    await subWorker()


async def secondWorker():
    await asyncio.sleep(1)


loop = asyncio.get_event_loop()
asyncio.ensure_future(firstWorker())
asyncio.ensure_future(secondWorker())
loop.run_forever()
</code></pre>
<p>here, when code starts, <code>firstWorker()</code> is executed and paused until it encounters <code>await subWorker()</code>. While <code>firstWorker()</code> is waiting, <code>secondWorker()</code> gets started.</p>
<p>Question is, when <code>firstWorker()</code> encounters <code>await subWorker()</code> and gets paused, the computer then will execute <code>subWorker()</code> and <code>secondWorker()</code> at the same time. Since the program has only 1 thread now, and I guess the single thread does <code>secondWorker()</code> work. Then who executes <code>subWorker()</code>? If single thread can only do 1 thing at a time, who else does the other jobs?</p>
</div>
<div class="post-text" itemprop="text">
<p>The assumption that <code>subWorker</code> and <code>secondWorker</code> execute at the same time is false.</p>
<p>The fact that <code>secondWorker</code> simply sleeps means that the available time will be spent in <code>subWorker</code>.</p>
<p><code>asyncio</code> by definition is single-threaded; see the <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>This module provides infrastructure for writing single-threaded concurrent code</p>
</blockquote>
<p>The event loop executes a task at a time, switching for example when one task is blocked while waiting for I/O, or, as here, voluntarily sleeping.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a little old now, but I've found the visualization from the <code>gevent</code> docs (about 1 screen down, beneath "Synchronous &amp; Asynchronous Execution") to be helpful while teaching asynchronous flow control to coworkers: <a href="http://sdiehl.github.io/gevent-tutorial/" rel="nofollow noreferrer">http://sdiehl.github.io/gevent-tutorial/</a></p>
<p>The most important point here is that only one coroutine is <em>running</em> at any one time, even though many may be <em>in process</em>.</p>
</div>
<span class="comment-copy">I gave a wrong example then. Then what if secondWorker() does cpu bound job, not <code>await asyncio.sleep(1)</code>? Then subWorker and secondWorker execute at the same time?</span>
<span class="comment-copy">No, then one executes before the other. Updated the answer slightly.</span>
<span class="comment-copy">Again, the asyncio architecture runs a single event loop which interrupts individual tasks when they are in I/O wait. When you try to print something, you are in I/O wait while the output buffer gets handled by the operating system. In which order exactly buffers get handled over on the OS side is obviously OS-dependent and basically unpredictable as far as Python is concerned.  This is "concurrent" in the sense that the interrupted task is "in progress" somewhere else outside of your program (perhaps with a DMA transfer running without the CPU doing anything, etc).</span>
<span class="comment-copy">Yes, the <code>io</code> in the name means this particular component handles I/O concurrency. The basic <code>async</code> still lets you handle some async tasks in what on some level can be regarded as concurrent execution, though (of course, just like threads) this is an abstraction which in the end runs on a single CPU.</span>
<span class="comment-copy">I/O is pretty simple, it's anything which touches the <code>open()</code>, <code>read()</code>, <code>write()</code>, and <code>close()</code> system calls.</span>
