<div class="post-text" itemprop="text">
<p>I am trying following regex with text below.</p>
<p>Regex:</p>
<pre><code>(\d+[\s\,\d.]*\s*(carpet|sft|feet|sqft|yard|gaj|feet|s.ft|sq.ft|sq feet|fq.ft.|sq.ft.
|pt|crpt|ft|sq.mt.|sq.mtr|sq.mt|plot|sf|sfqt|acer|gj|vigha|anna|gunta|sq|
gunthe|guntha|bigha|sqd|sqm|sqyd|area|acre|square|yrd|
sq.yard|sq yd|sq.yd|sq. yd.|gaj|sqt)s?)
</code></pre>
<p>Input text:</p>
<pre><code>kanakiya area 1350     sqft asking price : 95 lacs destination properties azymn - 9920902674 
 plot on rent near sp ring road rajpath club ki gali me road touch 5000 war na 350000 rent owner side no b
</code></pre>
<p>It is matching all the required string correctly but it also matching <code>9920902674<br/>
plot</code></p>
<p>I don't want match words in the text which are separated by a new line.</p>
<p>You can <a href="https://regex101.com/r/h8NLhr/12" rel="nofollow noreferrer">Compile above regex</a> to understand better.
How can we not include new line between matches .Want to match words having spaces between words.</p>
<p>Thanks</p>
<p>PS: I have changed this question from previous questions as it was not well received and my accounts was closed. So trying to improve the questions to unlock the accounts. </p>
<p>Please ignore previous answer and comments.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are using <code>\s</code> that matches any kind of vertical and horizontal whitespaces. If you plan to just match spaces and tabs, replace it with <code>[ \t]</code>.</p>
<p>Besides, you should consider escaping dots in your pattern (they are all outside of character classes) to match <em>literal</em> dots, else, they match any char but a line break char.</p>
<p>Also, you do not need a capturing group around the whole pattern, you may always get the whole match via Group 0 (that you may access when iterating all match data objects returned with <a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow noreferrer"><code>re.finditer</code></a>).</p>
<p>So, you may use</p>
<pre><code>\d[\d \t,.]*(?:carpet|sft|feet|sqft|yard|gaj|feet|s\.ft|sq\.ft|sq feet|fq\.ft\.|sq\.ft\.|pt|crpt|ft|sq\.mt\.|sq\.mtr|sq\.mt|plot|sf|sfqt|acer|gj|vigha|anna|gunta|sq|gunthe|guntha|bigha|sqd|sqm|sqyd|area|acre|square|yrd|sq\.yard|sq yd|sq\.yd|sq\. yd\.|gaj|sqt)s?
</code></pre>
<p>See the <a href="https://regex101.com/r/h8NLhr/14" rel="nofollow noreferrer">regex demo</a>.</p>
<p>You may use <code>re.findall(pattern, s)</code> to get all matches as a list. Or, if you need a list of tuples containing specific submatches, wrap those parts with capturing parentheses. E.g., to capture the number to one group and the measurement unit into another, use <code>(\d(?:[\d ,.]*\d)?)[ \t]*((?:carpet|sft|feet|sqft|yard|gaj|feet|s\.ft|sq\.ft|sq feet|fq\.ft\.|sq\.ft\.|pt|crpt|ft|sq\.mt\.|sq\.mtr|sq\.mt|plot|sf|sfqt|acer|gj|vigha|anna|gunta|sq|gunthe|guntha|bigha|sqd|sqm|sqyd|area|acre|square|yrd|sq\.yard|sq yd|sq\.yd|sq\. yd\.|gaj|sqt)s?)</code>. Note I revamped <code>\d(?:[\d \t,.]*\d)? *</code> into <code>(\d(?:[\d ,.]*\d)?)[ \t]*</code> to make sure the spaces after the number are not captured.</p>
<p><a href="https://ideone.com/82id5W" rel="nofollow noreferrer">Python demo</a>:</p>
<pre><code>import re
s = "kanakiya area 1350     sqft asking price : 95 lacs destination properties azymn - 9920902674 \n plot on rent near sp ring road rajpath club ki gali me road touch 5000 war na 350000 rent owner side no b"
pattern = r'\d[\d ,.]*(?:carpet|sft|feet|sqft|yard|gaj|feet|s\.ft|sq\.ft|sq feet|fq\.ft\.|sq\.ft\.|pt|crpt|ft|sq\.mt\.|sq\.mtr|sq\.mt|plot|sf|sfqt|acer|gj|vigha|anna|gunta|sq|gunthe|guntha|bigha|sqd|sqm|sqyd|area|acre|square|yrd|sq\.yard|sq yd|sq\.yd|sq\. yd\.|gaj|sqt)s?'
print(re.findall(pattern, s))
pattern1 = r'(\d(?:[\d ,.]*\d)?)[ \t]*((?:carpet|sft|feet|sqft|yard|gaj|feet|s\.ft|sq\.ft|sq feet|fq\.ft\.|sq\.ft\.|pt|crpt|ft|sq\.mt\.|sq\.mtr|sq\.mt|plot|sf|sfqt|acer|gj|vigha|anna|gunta|sq|gunthe|guntha|bigha|sqd|sqm|sqyd|area|acre|square|yrd|sq\.yard|sq yd|sq\.yd|sq\. yd\.|gaj|sqt)s?)'
print("Now, with captures:")
for m in re.finditer(pattern1, s):
    print("{} =&gt; {}".format(m.group(1), m.group(2)))
</code></pre>
<p>Output:</p>
<pre><code>['1350     sqft']
Now, with captures:
1350 =&gt; sqft
</code></pre>
</div>
<span class="comment-copy">I'd advise to split the regex into 2 alternatives, <code>&lt;prefixes&gt;\s*(&lt;NUM&gt;)|(&lt;NUM&gt;)\s*&lt;suffixes&gt;</code>. Something like <a href="https://regex101.com/r/xsDcQ9/1" rel="nofollow noreferrer"><code>(\d[. \d\t]*)(?:pkg\b|k\b|lac\.|lakh\.|crore\.|cr\.|l\b)|\b(?:rent|rs)\.\s*(\d[. \d\t]*)</code></a>. See <a href="https://ideone.com/Dpt0BE" rel="nofollow noreferrer">this Python demo, too</a>.</span>
<span class="comment-copy">Try <a href="https://regex101.com/r/ziAOMw/3" rel="nofollow noreferrer">regex101.com/r/ziAOMw/3</a></span>
<span class="comment-copy">You might not need regex. Here is a better way: (1) create dict with all currency types (2) split the input text and look to the left of currency types.</span>
<span class="comment-copy">Based on what you really want you could go with <code>(rent|rs)?([\s.]*\d+[\s\d.]*)(pkg|k|(?:la(?:c|kh)|crore|cr)s?|l)</code> too. See live demo here <a href="https://regex101.com/r/ziAOMw/4" rel="nofollow noreferrer">regex101.com/r/ziAOMw/4</a></span>
<span class="comment-copy">Thanks all . It works great.</span>
