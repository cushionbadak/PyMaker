<div class="post-text" itemprop="text">
<p>In Python3,</p>
<pre><code>a = b = 3
a is None == b is None
</code></pre>
<p>returns False, but</p>
<pre><code>(a is None) == (b is None)
</code></pre>
<p>returns True. So I would assume based on this example alone, == has precedence over <em>is</em>.</p>
<p>However,</p>
<pre><code>a = b = None
a is None == b is None
</code></pre>
<p>returns True. And</p>
<pre><code>(a is None) == (b is None)
</code></pre>
<p>returns True. But</p>
<pre><code>a is (None == b) is None
</code></pre>
<p>returns False. In this case, it would seem as if <em>is</em> has precedence over ==.</p>
<p>To give another example, and this expression isn't meant to do anything, but bear with me please. If I say</p>
<pre><code>None is None == None
</code></pre>
<p>it returns True. But both of the following return False.</p>
<pre><code>None is (None == None)
(None is None) == None
</code></pre>
<p>So clearly, Python isn't evaluating these with some strict precedence, but I'm confused what is going on. How is it evaluating this expression with 2 different operators, but differently from either order?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you see here is <strong>operator chaining</strong> and there is no precedence involved at all!</p>
<p>Python supports expressions like</p>
<pre><code>1 &lt; a &lt; 3
</code></pre>
<p>To test that a number is in between 1 and 3; it's equal to <code>(1 &lt; a) and (a &lt; 3)</code> except that <code>a</code> is only evaluated once.</p>
<p>Unfortunately that also means that e.g.</p>
<pre><code>None is None == None
</code></pre>
<p>actually means</p>
<pre><code>(None is None) and (None == None)
</code></pre>
<p>which is of course True, and the longer example you started with</p>
<pre><code>a = b = 3
a is None == b is None
</code></pre>
<p>means</p>
<pre><code>(a is None) and (None == b) and (b is None)
</code></pre>
<p>which can only be <code>True</code> if both <code>a</code> and <code>b</code> are <code>None</code>.</p>
<p>Documentation <a href="https://docs.python.org/3/reference/expressions.html#comparisons" rel="noreferrer">here</a>, see the bit about chaining.</p>
<p>Very useful sometimes but it also pops up when you least expect it!</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the documentation, all <a href="https://docs.python.org/3/library/stdtypes.html#comparisons" rel="nofollow noreferrer">python comparisons operators</a> has same priority:</p>
<blockquote>
<p>There are eight comparison operations in Python. They all have the
  same priority (which is higher than that of the Boolean operations).</p>
</blockquote>
<p>However by wrapping comparisons with the brackets, they start to be the <a href="https://docs.python.org/3/reference/expressions.html#atoms" rel="nofollow noreferrer">atoms expressions</a>, so statements in brackets evaluated before statements outside, that impacts the order of the evalutation, I will decompose the first "contradictional" case, the all others is similar:</p>
<pre><code>a = b = 3
a is None == b is None
</code></pre>
<p>Per documentation the priority is the same, so evaluation is next:</p>
<pre><code>1. a is None ? -&gt; False # Because a == 3
2. False == b -&gt; False # Because b == 3
3. False is None
</code></pre>
<p>Please see order for the second case below:</p>
<pre><code>(a is None) == (b is None)

1. a is None ? -&gt; False # Because a == 3
2. b is None -&gt; False # Because b == 3
3. False is False -&gt; True
</code></pre>
</div>
<span class="comment-copy">I think the more useful example is their original confusing code: <code>a is None == b is None</code>, which translates to <code>a is None and None == b and b is None</code>. Looked at that way, it's clear that in general, that test only passes if both <code>a</code> and <code>b</code> are <code>None</code>, not if the "<code>None</code>ness" of <code>a</code> matches that of <code>b</code> (which is what the OP intended).</span>
<span class="comment-copy">@ShadowRanger: good point, added</span>
