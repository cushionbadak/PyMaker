<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; from typing import overload

&gt;&gt;&gt; @overload
... def hello(s: int):
...     return "Got an integer!"

&gt;&gt;&gt; def hello(s: str):
...     return "Got a string"
</code></pre>
<p>Why does the calling <code>hello(1)</code> call the function with the string argument? Ideally, the <code>@overload</code> operator should handle it, right?</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately, python does not allow function overloading. Each time you think you are overloading function, you are just overwriting previous function declaration. Quote from the <a href="https://docs.python.org/3/library/typing.html#typing.overload" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>The @overload decorator allows describing functions and methods that
  support multiple different combinations of argument types. A series of
  @overload-decorated definitions must be followed by exactly one
  non-@overload-decorated definition (for the same function/method). <strong>The
  @overload-decorated definitions are for the benefit of the type
  checker only, since they will be overwritten by the
  non-@overload-decorated definition, while the latter is used at
  runtime but should be ignored by a type checker</strong>. At runtime, calling a
  @overload-decorated function directly will raise NotImplementedError.</p>
</blockquote>
<p>The correct usage of <code>typing.overload</code> is as follows:</p>
<pre><code>from typing import overload


@overload
def hello(s: int) -&gt; str:
    ...


@overload
def hello(s: str) -&gt; str:
    ...


def hello(s):
    if isinstance(s, int):
        return "Got an integer!"
    if isinstance(s, str):
        return "Got a string"
    raise ValueError('You must pass either int or str')


if __name__ == '__main__':
    print(hello(1))
</code></pre>
<p>To show the actual benefit of <code>typing.overload</code> lets change <code>def hello(s: int)</code> to return <code>int</code> instead of <code>str</code>:</p>
<pre><code>from typing import overload


@overload
def hello(s: int) -&gt; int:
    ...


@overload
def hello(s: str) -&gt; str:
    ...


def hello(s):
    if isinstance(s, int):
        return "Got an integer!"
    if isinstance(s, str):
        return "Got a string"
    raise ValueError('You must pass either int or str')


if __name__ == '__main__':
    print(hello(1))
    a = hello(1) + 1
    b = hello(1) + 'a'
</code></pre>
<p>Note, that the actual implementation still returns <code>str</code> - python does not perform any checks here. However, PyCharm raises a warning:</p>
<p><a href="https://i.stack.imgur.com/GtFqA.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/GtFqA.png"/></a></p>
<p><code>mypy</code> also complains about invalid types:</p>
<pre><code>âžœ mypy test.py 
test.py:25: error: Unsupported operand types for + ("int" and "str")
</code></pre>
<p>The purpose of <code>typing</code> module is to allow third party tools to perform static checking of your code. There is no magic here - all types are ignored at runtime.  </p>
</div>
<span class="comment-copy">You need to decorate both definitions, otherwise you're just overriding whatever <code>hello</code> was with a normal function.</span>
<span class="comment-copy">To be precise, only stub functions should be decorated. Calling decorated function will raise <code>NotImplementedError</code>. The idea of <code>overload</code> <b>is to overwrite stubs</b> with actual implementation.</span>
<span class="comment-copy">Then what's the point of <code>@overload</code> if we're anyway going to check the types? EDIT: No point. Got it.</span>
<span class="comment-copy">The reason for my doubt was one of the Pycon talks where the speaker did exactly what's mentioned in the question. Weird.</span>
<span class="comment-copy">@saruftw Please check updated answer. In short - the point of the <code>typing</code> module (and in <code>@overload</code> in particular) is to allow 3rd party tools (e.g. mypy) to run static checks</span>
<span class="comment-copy">Got it. Thanks for explaining.</span>
