<div class="post-text" itemprop="text">
<p>In Python 3, is a list comprehension simply syntactic sugar for a generator expression fed into the <code>list</code> function?</p>
<p>e.g. is the following code:</p>
<pre><code>squares = [x**2 for x in range(1000)]
</code></pre>
<p>actually converted in the background into the following?</p>
<pre><code>squares = list(x**2 for x in range(1000))
</code></pre>
<p>I know the output is identical, and Python 3 fixes the surprising side-effects to surrounding namespaces that list comprehensions had, but in terms of what the CPython interpreter does under the hood, is the former converted to the latter, or are there any difference in how the code gets executed?
<br/></p>
<h2>Background</h2>
<p>I found this claim of equivalence in the comments section to <a href="https://stackoverflow.com/questions/47789/generator-expressions-vs-list-comprehension">this question</a>, and a quick google search showed the same claim being made <a href="http://python3porting.com/improving.html" rel="noreferrer">here</a>.</p>
<p>There was also some mention of this in the <a href="https://docs.python.org/3/whatsnew/3.0.html#changed-syntax" rel="noreferrer">What's New in Python 3.0 docs</a>, but the wording is somewhat vague:</p>
<blockquote>
<p>Also note that list comprehensions have different semantics: they are closer to syntactic sugar for a generator expression inside a list() constructor, and in particular the loop control variables are no longer leaked into the surrounding scope.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Both work differently, the list comprehension version takes the advantage of special bytecode <a href="https://github.com/python/cpython/blob/master/Python/ceval.c#L1476" rel="nofollow noreferrer"><code>LIST_APPEND</code></a> which calls <a href="https://hg.python.org/cpython/file/c79fd57f86b6/Objects/listobject.c#l303" rel="nofollow noreferrer">PyList_Append</a> directly for us. Hence it avoids attribute lookup to <code>list.append</code> and function call at Python level.</p>
<pre><code>&gt;&gt;&gt; def func_lc():
    [x**2 for x in y]
...
&gt;&gt;&gt; dis.dis(func_lc)
  2           0 LOAD_CONST               1 (&lt;code object &lt;listcomp&gt; at 0x10d3c6780, file "&lt;ipython-input-42-ead395105775&gt;", line 2&gt;)
              3 LOAD_CONST               2 ('func_lc.&lt;locals&gt;.&lt;listcomp&gt;')
              6 MAKE_FUNCTION            0
              9 LOAD_GLOBAL              0 (y)
             12 GET_ITER
             13 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             16 POP_TOP
             17 LOAD_CONST               0 (None)
             20 RETURN_VALUE

&gt;&gt;&gt; lc_object = list(dis.get_instructions(func_lc))[0].argval
&gt;&gt;&gt; lc_object
&lt;code object &lt;listcomp&gt; at 0x10d3c6780, file "&lt;ipython-input-42-ead395105775&gt;", line 2&gt;
&gt;&gt;&gt; dis.dis(lc_object)
  2           0 BUILD_LIST               0
              3 LOAD_FAST                0 (.0)
        &gt;&gt;    6 FOR_ITER                16 (to 25)
              9 STORE_FAST               1 (x)
             12 LOAD_FAST                1 (x)
             15 LOAD_CONST               0 (2)
             18 BINARY_POWER
             19 LIST_APPEND              2
             22 JUMP_ABSOLUTE            6
        &gt;&gt;   25 RETURN_VALUE
</code></pre>
<p>On the other hand the <code>list()</code> version simply passes the generator object to list's <a href="https://hg.python.org/cpython/file/c79fd57f86b6/Objects/listobject.c#l2295" rel="nofollow noreferrer"><code>__init__</code></a> method which then calls its <a href="https://hg.python.org/cpython/file/c79fd57f86b6/Objects/listobject.c#l782" rel="nofollow noreferrer"><code>extend</code></a> method internally. As the object is not a list or tuple CPython then gets its <a href="https://hg.python.org/cpython/file/c79fd57f86b6/Objects/listobject.c#l828" rel="nofollow noreferrer">iterator first</a> and then simply adds the items to the list until the <a href="https://hg.python.org/cpython/file/c79fd57f86b6/Objects/listobject.c#l854" rel="nofollow noreferrer">iterator is exhausted</a>:</p>
<pre><code>&gt;&gt;&gt; def func_ge():
    list(x**2 for x in y)
...
&gt;&gt;&gt; dis.dis(func_ge)
  2           0 LOAD_GLOBAL              0 (list)
              3 LOAD_CONST               1 (&lt;code object &lt;genexpr&gt; at 0x10cde6ae0, file "&lt;ipython-input-41-f9a53483f10a&gt;", line 2&gt;)
              6 LOAD_CONST               2 ('func_ge.&lt;locals&gt;.&lt;genexpr&gt;')
              9 MAKE_FUNCTION            0
             12 LOAD_GLOBAL              1 (y)
             15 GET_ITER
             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             19 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             22 POP_TOP
             23 LOAD_CONST               0 (None)
             26 RETURN_VALUE
&gt;&gt;&gt; ge_object = list(dis.get_instructions(func_ge))[1].argval
&gt;&gt;&gt; ge_object
&lt;code object &lt;genexpr&gt; at 0x10cde6ae0, file "&lt;ipython-input-41-f9a53483f10a&gt;", line 2&gt;
&gt;&gt;&gt; dis.dis(ge_object)
  2           0 LOAD_FAST                0 (.0)
        &gt;&gt;    3 FOR_ITER                15 (to 21)
              6 STORE_FAST               1 (x)
              9 LOAD_FAST                1 (x)
             12 LOAD_CONST               0 (2)
             15 BINARY_POWER
             16 YIELD_VALUE
             17 POP_TOP
             18 JUMP_ABSOLUTE            3
        &gt;&gt;   21 LOAD_CONST               1 (None)
             24 RETURN_VALUE
&gt;&gt;&gt;
</code></pre>
<p><strong>Timing comparisons:</strong></p>
<pre><code>&gt;&gt;&gt; %timeit [x**2 for x in range(10**6)]
1 loops, best of 3: 453 ms per loop
&gt;&gt;&gt; %timeit list(x**2 for x in range(10**6))
1 loops, best of 3: 478 ms per loop
&gt;&gt;&gt; %%timeit
out = []
for x in range(10**6):
    out.append(x**2)
...
1 loops, best of 3: 510 ms per loop
</code></pre>
<p>Normal loops are slightly slow due to slow attribute lookup. Cache it and time again.</p>
<pre><code>&gt;&gt;&gt; %%timeit
out = [];append=out.append
for x in range(10**6):
    append(x**2)
...
1 loops, best of 3: 467 ms per loop
</code></pre>
<hr/>
<p>Apart from the fact that list comprehension don't leak the variables anymore one more difference is that something like this is not valid anymore:</p>
<pre><code>&gt;&gt;&gt; [x**2 for x in 1, 2, 3] # Python 2
[1, 4, 9]
&gt;&gt;&gt; [x**2 for x in 1, 2, 3] # Python 3
  File "&lt;ipython-input-69-bea9540dd1d6&gt;", line 1
    [x**2 for x in 1, 2, 3]
                    ^
SyntaxError: invalid syntax

&gt;&gt;&gt; [x**2 for x in (1, 2, 3)] # Add parenthesis
[1, 4, 9]
&gt;&gt;&gt; for x in 1, 2, 3: # Python 3: For normal loops it still works
    print(x**2)
...
1
4
9
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Both forms create and call an anonymous function. However, the <code>list(...)</code> form creates a generator function and passes the returned generator-iterator to <code>list</code>, while with the <code>[...]</code> form, the anonymous function builds the list directly with <code>LIST_APPEND</code> opcodes.</p>
<p>The following code gets decompilation output of the anonymous functions for an example comprehension and its corresponding genexp-passed-to-<code>list</code>:</p>
<pre><code>import dis

def f():
    [x for x in []]

def g():
    list(x for x in [])

dis.dis(f.__code__.co_consts[1])
dis.dis(g.__code__.co_consts[1])
</code></pre>
<p>The output for the comprehension is</p>
<pre><code>  4           0 BUILD_LIST               0
              3 LOAD_FAST                0 (.0)
        &gt;&gt;    6 FOR_ITER                12 (to 21)
              9 STORE_FAST               1 (x)
             12 LOAD_FAST                1 (x)
             15 LIST_APPEND              2
             18 JUMP_ABSOLUTE            6
        &gt;&gt;   21 RETURN_VALUE
</code></pre>
<p>The output for the genexp is</p>
<pre><code>  7           0 LOAD_FAST                0 (.0)
        &gt;&gt;    3 FOR_ITER                11 (to 17)
              6 STORE_FAST               1 (x)
              9 LOAD_FAST                1 (x)
             12 YIELD_VALUE
             13 POP_TOP
             14 JUMP_ABSOLUTE            3
        &gt;&gt;   17 LOAD_CONST               0 (None)
             20 RETURN_VALUE
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can actually show that the two can have different outcomes to prove they are inherently different:</p>
<pre><code>&gt;&gt;&gt; list(next(iter([])) if x &gt; 3 else x for x in range(10))
[0, 1, 2, 3]

&gt;&gt;&gt; [next(iter([])) if x &gt; 3 else x for x in range(10)]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 1, in &lt;listcomp&gt;
StopIteration
</code></pre>
<p>The expression inside the comprehension is not treated as a generator since the comprehension does not handle the <code>StopIteration</code>, whereas the <code>list</code> constructor does.</p>
</div>
<div class="post-text" itemprop="text">
<p>They aren't the same, <code>list()</code> will evaluate what ever is given to it after what is in the parentheses has finished executing, not before.</p>
<p>The <code>[]</code> in python is a bit magical, it tells python to wrap what ever is inside it as a list, more like a type hint for the language.</p>
</div>
<span class="comment-copy">I'm not sure that this <i>assumption</i> is correct. AFAIK a list comprehension is syntactic sugar for a for loop whereas a generator expression has much different semantics -- namely that it "generates" values iteratively. <i>shrugs</i> Maybe the semantics have changed in Python 3 :)</span>
<span class="comment-copy"><b>NB:</b> The exact wording is "closer to a generator expression in the <code>list()</code> constructor" -- Not that they are exactly that.</span>
<span class="comment-copy">@JamesMills Thanks, right, precisely - 'closer to syntactic sugar' is the bit that has me somewhat baffled.  I mean, how close exactly?  Is it definitively <b>not</b> syntactic sugar?</span>
<span class="comment-copy">When in doubt, use the <code>dis</code> module to check.</span>
<span class="comment-copy">Thanks for the detailed response!  Interesting how timeit shows negligiable differences between the list comprehensions and the generator expressions being thrown into <code>list</code>, despite very different underlying bytecode (and C code).</span>
<span class="comment-copy">@zehnpaard Quoting from Guido's <a href="http://python-history.blogspot.in/2010/06/from-list-comprehensions-to-generator.html" rel="nofollow noreferrer">post</a>: <i>And before you start worrying about list comprehensions becoming slow in Python 3: thanks to the enormous implementation effort that went into Python 3 to speed things up in general, both list comprehensions and generator expressions in Python 3 are actually faster than they were in Python 2! (And there is no longer a speed difference between the two.)</i></span>
<span class="comment-copy">How do you manage to run timeit with percentage signs directly from the python shell?</span>
<span class="comment-copy">@ZaarHai This is ipython shell, ran using <code>--classic</code> argument.</span>
<span class="comment-copy">@zehnpaard The difference is (no longer) negligible - the first version is about 30% faster, see also <a href="https://stackoverflow.com/q/52053579/5769463">stackoverflow.com/q/52053579/5769463</a></span>
<span class="comment-copy">Note that the name <code>list</code> also needs to be looked up explicitly, since it may have been shadowed.</span>
<span class="comment-copy">Thanks for this, the <code>dis</code> module is always insightful but also occasionally a bit of a mystery - in your genexp example, it looks like the list creation is omitted completely if I read correctly, but I have no idea why...</span>
<span class="comment-copy">@zehnpaard: That's not part of the anonymous function; the <code>list</code> call handles that.</span>
<span class="comment-copy">Ah fair enough, and <code>g.__code__.co_consts[1]</code> specifically points to the anonymous function?</span>
<span class="comment-copy">@zehnpaard: It points to the code object used to construct the anonymous function.</span>
<span class="comment-copy">Note, in Python 3.7/3.8 the top one raises <code>RuntimeError: generator raised StopIteration</code> see <a href="https://www.python.org/dev/peps/pep-0479/" rel="nofollow noreferrer">python.org/dev/peps/pep-0479</a></span>
