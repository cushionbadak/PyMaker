<div class="post-text" itemprop="text">
<p>I am trying to extract the body of GMAIL emails via GMAIL API, using Python well.</p>
<p>I am able to extract the messages using the commands below.  However, there seems to be an issue with the encoding of the email text (Original email has html in it) - for some reason, every time before each quote <strong>3D</strong> appears.  </p>
<p>Also, within the a href="my_url", I have random equal signs <strong>=</strong> appearing, and at the end of the link, there is <strong>&amp;amp</strong> character which is not in the original HTML of the email.</p>
<p>Any idea how to fix this? </p>
<p>Code I use to extract the email:</p>
<pre><code>from __future__ import print_function
from googleapiclient.discovery import build
from httplib2 import Http
from oauth2client import file, client, tools

from apiclient import errors
import base64
msgs = service.users().messages().list(userId='me', q="no-reply@hello.com",maxResults=1).execute()
for msg in msgs['messages']:message = service.users().messages().get(userId='me', id=m_id, format='raw').execute()
</code></pre>
<h1>"raw": Returns the full email message data with body content in the raw field as a base64url encoded string; the payload field is not used."</h1>
<pre><code>print(base64.urlsafe_b64decode(message['raw'].encode('ASCII')))
</code></pre>
<p>td style=<strong>3D</strong>"padding:20px; color:#45555f; font-family:Tahoma,He=
lvetica; font-size:12px; line-height:18px; " </p>
<p>JPk79hd <strong>=</strong>
JFQZEhc6%2BpAiQKF8M85SFbILbNd6IG8%2FEAWwe3VTr2jPzba4BHf%2FEnjMxq66fr228I7OS <strong>=</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Sadly I wasn't able to figure out the proper way to decode the message.</p>
<p>I ended up using the following workaround, which:</p>
<p>1) splits the message into a list, with each separate line as a list item</p>
<p>2) Figures out the list location of one of the strings, and location of ending string.</p>
<p>3) Generates a new list out of #2, then regenerates the same list, cutting out the last character (equals sign)</p>
<p>4) Generates a string out of the new list</p>
<p>5) searches for the URL I want</p>
<pre><code>    x= mime_msg.splitlines() #convert to list
    a = ([i for i, s in enumerate(x) if 'My unique start string' in s])[0] #get list# of beginning
    b = ([i for i, s in enumerate(x) if 'my end id' in s])[0] #end
    y = x[a:b]   #generate list w info we want
    new_list=[]
    for item in y:new_list.append(item[:-1]) #get rid of last character, which bs base64 encoding is "="
    url = ("".join(new_list)) #convert to string
    url = url.replace("3D","").replace("&amp;amp","") #cleaner for some reason - encoding gives us random 3Ds + &amp;amps
    csv_url = re.search('Whatever message comes before the URL (.*)',url).group(1)
</code></pre>
<p>The above uses </p>
<pre><code>import re 
from __future__ import print_function
from googleapiclient.discovery import build
from httplib2 import Http
from oauth2client import file, client, tools

from apiclient import errors
import base64
import email
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should check the <code>Content-Transfer-Encoding</code> header to see if it specifies <code>quoted-printable</code> because that looks like <a href="https://en.wikipedia.org/wiki/Quoted-printable" rel="nofollow noreferrer">quoted-printable</a> encoded text.</p>
<p>Per <a href="https://tools.ietf.org/html/rfc1521.html#section-5.1" rel="nofollow noreferrer">RFC 1521, Section 5.1</a>:</p>
<blockquote>
<p>The Quoted-Printable encoding is intended to represent data that largely consists of octets that correspond to printable characters in the US-ASCII character set.  It encodes the data in such a way that the resulting octets are unlikely to be modified by mail transport. If the data being encoded are mostly US-ASCII text, the encoded form of the data remains largely recognizable by humans.  A body which is entirely US-ASCII may also be encoded in Quoted-Printable to ensure the integrity of the data should the message pass through a character-translating, and/or line-wrapping gateway.</p>
</blockquote>
<p>Python's <a href="https://docs.python.org/3/library/quopri.html" rel="nofollow noreferrer">quopri</a> module can be used to decode emails with this encoding.</p>
</div>
<span class="comment-copy">after putting the whole document in front of me - it looks like python marked the end of each line with equal signs, because it seems to be trying to keep each line to ### characters.  any thoughts on what could cause that?  If I can at least get rides of equal signs at the end of each string, I can accomplish the rest with find-replace_with_black.  Thank you in advance</span>
<span class="comment-copy">looks like the equal signs are related to base64's encoding - <a href="https://stackoverflow.com/questions/6916805/why-does-a-base64-encoded-string-have-an-sign-at-the-end" title="why does a base64 encoded string have an sign at the end">stackoverflow.com/questions/6916805/â€¦</a></span>
