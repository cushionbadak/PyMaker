<div class="post-text" itemprop="text">
<p>In Python is it possible to use a string as an operator in an if statement condition?</p>
<p>I would like to have an object with two values and an operator to test them.
For Example:</p>
<pre><code>class Condition:
    def __init__(self, value1, operator, value2):
        self.value1 = value1
        self.operator = operator
        self.value2 = value2

    def test(self):
        if self.value1 self.operator self.value2: &lt;- THIS IS NOT CORRECT.
            return True
        else:
            return False

condition = Condition(5, "&gt;", 4)
if condition.test() == True:
    print("passed")
else:
    print("failed")
</code></pre>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's <a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer">operator</a> module provides functions corresponding to all the built-in operators, so you can write:</p>
<pre><code>import operator

class Condition:
    def __init__(self, value1, op, value2):
        self.value1 = value1
        self.op = op
        self.value2 = value2
    def test(self):
        return self.op(self.value1, self.value2)

condition = Condition(5, operator.gt, 4)

if condition.test():
    print("passed")
else:
    print("failed")
</code></pre>
<p>If you want to pass strings instead of the functions, you can use a <code>dict</code> to map them:</p>
<pre><code>import operator

OPERATOR_SYMBOLS = {
    '&lt;': operator.lt,
    '&lt;=': operator.le,
    '==': operator.eq,
    '!=': operator.ne,
    '&gt;': operator.gt,
    '&gt;=': operator.ge
}

class Condition:
    def __init__(self, value1, op, value2):
        self.value1 = value1
        self.op = op
        self.value2 = value2
    def test(self):
        return OPERATOR_SYMBOLS[self.op](self.value1, self.value2)

condition = Condition(5, '&gt;', 4)

if condition.test():
    print("passed")
else:
    print("failed")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>eval('{}{}{}'.format(v1,op,v2))</code></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer">The <code>operator</code> module</a> provides the various comparators as functions, so you could map from string form to a function to perform the comparison:</p>
<pre><code>import operator

class Condition:

    cmp_to_op = {'==': operator.eq,
                  '!=': operator.ne,
                  '&lt;': `operator.lt,
                  '&lt;=': `operator.le,
                  '&gt;': `operator.gt,
                  '&gt;=': `operator.ge}

    def __init__(self, value1, operator, value2):
        self.value1 = value1
        self.operator = self.cmp_to_op(operator)
        self.value2 = value2

    def test(self):
        # No need for if return True else return False; comparison already returns
        # True or False for normal objects
        return self.operator(self.value1, self.value2)
</code></pre>
</div>
<span class="comment-copy">Works great. Thanks!</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/1832940/why-is-using-eval-a-bad-practice">this is bad practice</a></span>
<span class="comment-copy">I am going to use what @dan04 suggested but I will keep this in mind if I ever need it in the future. Thanks.</span>
