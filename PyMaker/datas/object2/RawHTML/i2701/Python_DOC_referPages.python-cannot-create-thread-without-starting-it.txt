<div class="post-text" itemprop="text">
<p>I am trying to make a python program that would download multiple images simultaneously by means of threading. However, the problem is that I have to ask the user how many images he/she wants to download, so I have to create a new thread for each download using a loop.</p>
<p>I tried that, and it turns out that I cannot create a thread without starting it too. I want both the threads created by the loop to start at roughly the same time. However, the loop progresses only after the thread constructed in the loop has finished executing -  so I cannot simultaneously download the images.</p>
<pre><code>import urllib.request
import threading
import time

def set_name(url, name):   #This function tells the compiler what extension  to save the image by, so that the computer can read it.
    if url.endswith("png"):
        return name + ".png"
    elif url.endswith("jpg"):
        return name + ".jpg"
    elif url.endswith("gif"):
        return name + ".gif"
    else:
        print("Please check your link")

links = []
names = []

def get_img_parameters():   #Takes the name and url of the images and stores them in separate lists.
    img_count = int(input("How many images would you like to download?"))
    x = 1
    while x &lt; img_count + 1:
        link = str(input("Paste the link of the image %d: " % x))
        links.append(link)
        name = str(input("Name your image: "))
        full_name = name + str(set_name(link, name))
        names.append(full_name)
        x += 1 

def img_down(url, name):
    urllib.request.urlretrieve(url, name)

get_img_parameters()

for i in range(len(links)): #len(links) just tells how many threads I have to make
    t = threading.Thread(target = img_down(links[i], names[i]))
    continue
</code></pre>
<p>It seems like it does not matter if I include t.start() in the loop, since the thread starts automatically due to the line - </p>
<pre><code>t = threading.Thread(target = img_down(links[i], names[i]))
</code></pre>
<p>I want the first thread to start and the loop to repeat with the next thread, so that both downloads can run simultaneously. For now, the loop moves to the next iteration only when the first thread has finished.</p>
</div>
<div class="post-text" itemprop="text">
<p>Form python <a href="https://docs.python.org/3/library/threading.html#thread-objects" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>class threading.Thread(group=None, target=None, name=None, args=(),
  kwargs={}, *, daemon=None)</p>
</blockquote>
<p>You should instantiate your threading object as follows:</p>
<pre><code>t = threading.Thread(target=img_down, args=(links[i], names[i]))
</code></pre>
<p>Otherwise you just calling your <code>img_down</code> method without passing it to Threading object</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to call <code>.start()</code> for your thread to start. If you want to wait until all threads have finished, you should <code>.join()</code> the thread as well.</p>
<p>For example,</p>
<pre><code>import threading

def foo(*args):
    print args

def main():
    links = [1,2,3]
    names = ['a', 'b', 'b']
    _args = zip(links, names)
    threadList = [threading.Thread(target=foo, args=arg) for arg in _args]
    for thread in threadList:
        thread.start()
</code></pre>
<blockquote>
<p>(2, 'b')(3, 'b')(1, 'a')</p>
</blockquote>
<p>Here my main will exit while the threads are still running. In order to prevent it from doing so until all threads have finished, call join.</p>
<pre><code>for thread in threadList:
    thread.start()
    thread.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ok so as you can see in <a href="https://docs.python.org/3.5/library/threading.html" rel="nofollow noreferrer">documentation</a> you have to do 2 things:</p>
<p><strong>Instantiate</strong> the thread in the correct way :</p>
<pre><code>t = threading.Thread(target = img_down(links[i], names[i]))
</code></pre>
<p>this is blocking because it's a method call not a thread instantiation
you have to instantiate it this way:</p>
<pre><code>t = threading.Thread(target = img_down, args=(links[i], names[i])
</code></pre>
<p><strong>Start the threads</strong> this way :</p>
<pre><code>t.start()
</code></pre>
<p>otherwise the threads will not make the work.</p>
<p>By the way you can first instantiate all the threads and then start them with another cycle.</p>
</div>
<div class="post-text" itemprop="text">
<p>Creating a thread does not start it. You have to start it explicity, by calling the objects <code>.start()</code>method. However, two points to notice for your use case</p>
<ul>
<li>adding one thread per file to download does not improve performance. Something in the order of ~10 threads would be good, for much more you have diminishing returns, and after a point performance could actually decrease.</li>
<li>For your use case it would be easier and better to use a thread pool.</li>
</ul>
<p>for example</p>
<pre><code>with futures.ThreadPoolExecutor(workers=10) as executor:
    result = executor.map(download_function, list_of_files)
</code></pre>
</div>
<span class="comment-copy">You're <i>not</i> starting your threads. The problem is that you're calling <code>img_down(links[i], names[i])</code>, and then passing the result of that call as the thread function.</span>
