<div class="post-text" itemprop="text">
<p>Since examples of asynchronous programming are still fairly sparse, I am trying to come up with my own using the new <code>async def</code>. I figured the most basic example I could make would be an event loop which listens to the user inputs and prints them back.</p>
<p>I want an event loop which listens to the keys the user presses and prints them every second. I'm trying to do so by having one task that prints from a queue of keys and a second task that listens to pressed keys and adds them to the queue.</p>
<p>I am missing a good way to asynchronously listen to key strokes. Here is what I have for now.</p>
<pre><code>import asyncio

KEY_QUEUE = []

async def printer():
    while True:
        await asyncio.sleep(1)
        print('In the last second you pressed:', *KEY_QUEUE)
        KEY_QUEUE.clear()

async def listener():
    while True:
        ... # await a key to be pressed and add it to KEY_QUEUE

loop = asyncio.get_event_loop()

loop.create_task(printer())
loop.create_task(listener())

loop.run_forever()
</code></pre>
<p>Expected output would look like this</p>
<pre><code>In the last second you pressed: h e l l o
In the last second you pressed: w o r
In the last second you pressed: l d 
In the last second you pressed:
In the last second you pressed: i t    w o
In the last second you pressed: r k s
</code></pre>
<p>I doubt there is an awaitable coroutine such as <code>asyncio.await_pressed_key</code>, how would we proceed to create one?</p>
<p>Any other approach is welcome as well as my goal is not to make this specific example work, but rather to generate meaningful asynchronous programmign examples.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that you want to read characters from a TTY (terminal device on Unix-like system), accessing characters as they are typed requires:</p>
<ul>
<li><p>the TTY to be in "raw mode", so that the system returns characters without waiting for a newline to be typed by the user;</p></li>
<li><p>the standard input, which are blocking, to be wrapped into an asyncio non-blocking stream.</p></li>
</ul>
<p>The former is provided by the <a href="https://docs.python.org/2/library/tty.html" rel="nofollow noreferrer"><code>tty</code></a> module that comes with the Python standard library, and the latter by the <a href="https://github.com/vxgmichel/aioconsole" rel="nofollow noreferrer"><code>aioconsole</code></a> third-party library.</p>
<p>With those two, your example could look like this:</p>
<pre><code>import asyncio, aioconsole, sys, tty

async def main():
    loop = asyncio.get_event_loop()
    typed = []
    p = loop.create_task(printer(typed))
    await listener(typed)
    p.cancel()

async def listener(typed):
    tty.setraw(sys.stdin.fileno())
    stdin, _ = await aioconsole.stream.get_standard_streams()
    while True:
        ch = await stdin.read(1)
        if ch == b'\x03':  # ctrl-c
            break
        typed.append(ch)
    tty.setcbreak(sys.stdin.fileno())

async def printer(typed):
    while True:
        await asyncio.sleep(1)
        print('In the last second you pressed', typed, end='\r\n')
        del typed[:]

asyncio.get_event_loop().run_until_complete(main())
</code></pre>
<p>This example will only work on Unix-like systems.</p>
</div>
<span class="comment-copy">Listening to keystrokes systemwide is not a problem that is solvable by means of asyncio. If you rather mean listening to input sent to a certain fd I can help you.</span>
<span class="comment-copy">Can you provide a briefing explanation of why this is not possible and sure please provide your alternative</span>
<span class="comment-copy">Basically keystrokes send so called hardware interrupts which are handled by your CPU. Interrupt requests are called shortly IRQs. Depending on your OS an interrupt handler will be invoked to deal with that request. IRQs need to be handled fast, so in Linux we find usually that the handler queues them and returns directly. The queued events are then handled by a separate component called "tasklet" or "Soft IRQ" handler. Obviously some userland component then get's the event. But that is not easily intercept-able unless you run a privileged process that can hook into it. On windows there are</span>
<span class="comment-copy">APIs like: win32event, win32api, winerror and _winreg which you can use to intercept them. On Unix systems it's a bit more unhomogenous. What kind of OS do you run ?</span>
<span class="comment-copy">Any approach as to how to achieve the same on Windows?</span>
<span class="comment-copy">@OlivierMelan√ßon On windows instead of reading from stdin in raw mode, you'd read from the console by calling something like <a href="https://docs.microsoft.com/en-us/windows/console/readconsoleinput" rel="nofollow noreferrer"><code>ReadConsoleInput</code></a>. <a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow noreferrer"><code>ctypes.windll</code></a> would be used to invoke the function, and <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" rel="nofollow noreferrer"><code>run_in_executor</code></a> to avoid blocking the event loop. (The latter is provided by aioconsole in the answer.)</span>
