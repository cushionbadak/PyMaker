<div class="post-text" itemprop="text">
<p>My machine is Win7 with anaconda. 
i am recently converting C++ dll functions to a python project.
There are numbers of difficulty I had overcame yet I have no idea how to deal with the following conversion:</p>
<pre><code>typedef int (__stdcall *p_API_GetOrder)(vector&lt;ApiOrder&gt;&amp; apiOrderList);
</code></pre>
<p>where,</p>
<pre><code>class ApiOrder(Structure):
  _fields_ = [
  ('Timestamp',      c_long),
  ('Item',           c_char * 16),
  ('Qty',            c_long),
  ]
</code></pre>
<p>In python, I tried,</p>
<pre><code>mydll.API_GetOrder(POINTER(ApiOrder()))
</code></pre>
<p>The error is:</p>
<pre><code>TypeError: must be a ctypes type
</code></pre>
<p>i am not an export in C++ or programming. So not quite sure what byref is. It would be nice if someone can clear my concept.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/ctypes.html#ctypes.POINTER" rel="nofollow noreferrer"><code>POINTER(…)</code></a> constructs a new <em>pointer type</em>, not a value of that type. So, when you do this:</p>
<pre><code> mydll.API_GetOrder(POINTER(ApiOrder()))
</code></pre>
<p>… you’re passing a Python type object, not a ctypes wrapper around a C pointer object.</p>
<hr/>
<p>To get a pointer to a <code>ctypes</code> wrapper object, you want to call either <a href="https://docs.python.org/3/library/ctypes.html#ctypes.pointer" rel="nofollow noreferrer"><code>pointer</code></a> or <a href="https://docs.python.org/3/library/ctypes.html#ctypes.byref" rel="nofollow noreferrer"><code>byref</code></a>. The former constructs a <code>POINTER(…)</code> instance, sets it to point to your object, and passes the wrapped pointer; the latter just directly passes a pointer to your object without constructing a pointer wrapper object, and usually that’s all you need. See Passing pointers in the docs for further details.</p>
<hr/>
<p>However, I don’t think this is going to do much good, for two reasons.</p>
<hr/>
<p>First, most functions that take a pointer to some struct and return an int are doing it so they can fill in that struct with useful values. Constructing a new empty struct and passing a pointer to it and not holding onto a reference to it means you have no way to look at whatever values got filled in. </p>
<p>Also, you probably want to check the return value.</p>
<p>In general, you need to do something like this:</p>
<pre><code>order = ApiOrder()
ret = mydll.API_GetOrder(byref(order))
if ret:
    do some error handling with either ret or errno 
else:
    so something with order
</code></pre>
<p>While we’re at it, you almost certainly want to <a href="https://docs.python.org/3/library/ctypes.html#specifying-the-required-argument-types-function-prototypes" rel="nofollow noreferrer">set the <code>argtypes</code> and <code>restype</code> of the function</a>, so <code>ctypes</code> knows how to convert things properly, and can give you an exception if you do something that makes no sense, instead of making it guess how to convert and pass things and segfault if it guesses wrong.</p>
<p>Also, for the case of functions that return a success-or-error <code>int</code>, it's usually better to assign a function to the <code>restype</code>, which looks up the error and <code>raise</code>s an appropriate exception. (Use an <a href="https://docs.python.org/3/library/ctypes.html#ctypes._FuncPtr.errcheck" rel="nofollow noreferrer"><code>errcheck</code></a> if you need anything more flexible than just checking that an int return is nonzero or a pointer return is zero.)</p>
<hr/>
<p>But even this isn’t going to help here, because the function you’re trying to call doesn’t take a pointer to an <code>ApiOrder</code> in the first place, it takes a reference to a <code>std::vector</code> of them. So you need to call into the C++ stdlib to construct an object of <em>that</em> type, then you can <code>byref</code> that as the argument.</p>
<p>But usually, it’s easier to write some C++ code that provides a C API to the library, then use <code>ctypes</code> to call that C API, instead of trying to build and use C++ objects from Python.</p>
<p>Your C++ code would look something like this:</p>
<pre><code>int call_getorder(p_API_GetOrder func, ApiOrder *apiOrderArray, size_t apiOrderCount) {
    std::vector&lt;ApiOrder&gt; vec(apiOrderArray, apiOrderCount);
    ret = func(vec);
    if (ret) return ret;
    std::copy(std::begin(vec), std::end(vec), apiOrderArray);
    return 0;
}
</code></pre>
<p>Now, you can call this from Python by creating <a href="https://docs.python.org/3/library/ctypes.html#arrays" rel="nofollow noreferrer">an array</a> of 1 <code>ApiOrder</code> (or creating a <code>POINTER</code> to an <code>ApiOrder</code> and passing it directly, if you prefer):</p>
<pre><code>orders = (ApiOrder*1)()
ret = mywrapperdll.call_order(mydll.API_GetOrder, byref(order), 1)
if ret:
    do some error handling with either ret or errno 
else:
    do something with order[0]
</code></pre>
<p>Of course you're still going to want <code>argtypes</code> and <code>restype</code>.</p>
</div>
<span class="comment-copy">Great, your words and examples are compact and clear. I should have visited stackoverflow earlier...When you suggest to write some code in C++, i afraid I cannot access the dll source code.</span>
<span class="comment-copy">@CherrimonShop I'm not telling you to access the DLL source, I'm telling you to write a new DLL that imports the C++ DLL and exports a simpler, C-friendly API.</span>
<span class="comment-copy">I understand you now. Before I implement it, I wonder if there is any way without creating new DLL since there are &gt;30 similar (byref) functions in the existing DLL. My thought is, maybe, obtain the object pointer in python and try to search the whole list until the next is pointing to NULL, or sth like this?</span>
<span class="comment-copy">@CherrimonShop Do they all use the same <code>vector&lt;ApiOrder&gt;</code> type? If so, creating either a single <code>call_vector_function</code> function that takes a function pointer, <code>ApiOrder*</code>, and <code>size_t</code> may be sufficient. Or just a single <code>make_vector</code> function that takes an <code>ApiOrder*</code> and <code>size_t</code> and returns a <code>vector&lt;ApiOrder&gt;*</code> plus a <code>free_vector</code> function that takes that <code>vector*</code> and <code>delete</code>s it.</span>
<span class="comment-copy">@CherrimonShop Another option is to use PyCxx, Cython, boost::python, or SWIG to create Python bindings from your C++ interface, instead of using <code>ctypes</code> at all. Or, alternatively, just use SWIG or whatever to provide wrappers for <code>std::vector</code> specialized on <code>ApiOrder</code> and whatever types, not to wrap up the actual functions from your library.</span>
