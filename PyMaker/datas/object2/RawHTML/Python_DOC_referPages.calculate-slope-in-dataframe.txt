<div class="post-text" itemprop="text">
<p>This question is just about calculating the slope at each timestep in a dataframe. There's a lot of extra detail here, that you are welcome to peruse or not, but that one step is all Im looking for.</p>
<p>I have a forecast and an observed dataframe. I am trying to calculate the "interesting" changes in the forecast. </p>
<p>I'd like to try to accomplish that by:</p>
<ul>
<li>calculate the best fit of the observed data (ie, linear regression).</li>
<li>find its slope</li>
<li>find the difference between the slope and the slope at each moment of the observed data</li>
</ul>
<p>To do this, I need to generate the slope at each moment in the time series.</p>
<ul>
<li>calculate the stddev and mean of that difference</li>
<li>use that to generate z-scores for the values in the forecast DF. </li>
</ul>
<p>How do I calculate the slope at each point in the data?</p>
<h2>original</h2>
<pre><code>from sklearn import linear_model

original = series.copy() # the observations
f = y.copy() # the forecast

app = ' app_2'

original.reset_index(inplace=True)
original['date'] = pd.to_timedelta(original['date'] ).dt.total_seconds().astype(int)    

# * calculate the best fit of the observed data (ie, linear regression).
reg = linear_model.LinearRegression()

# * find its slope
reg.fit(original['date'].values.reshape(-1, 1), original[app].values)
slope = reg.coef_

# * find the difference between the slope and the slope at each moment of the observed data
delta = original[app].apply(lambda x: abs(slope - SLOPE_OF(x)))

# * calculate the stddev and mean of that difference
odm = delta.mean()
ods = delta.std(ddof=0)

# * use that to generate z-scores for the values in the forecast DF. 
# something like
f['test_delta'] = np.cumsum(f[app]).apply(lambda x: abs(slope - x))
f['z'] = f['test_delta'].apply(lambda x: x - odm / ods)

# from that I might find interesting segments of the forecast:
sig = f.index[f['z'] &gt; 2].tolist()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To "calculate the slope at each point in the data," the simplest is to compute "rise over run" for each adjacent row using <code>Series.diff()</code> as follows. The resulting Series gives (an estimate of) the instantaneous rate of change (IROC) between the previous and current row.</p>
<pre><code>iroc = original[app].diff() / original['date'].diff()
</code></pre>
<p>Also, you don't need <code>apply</code>. Thanks to numpy vectorization, <code>scalar - array</code> behaves as expected:</p>
<pre><code>delta = slope - iroc
</code></pre>
<p>Hope this works. As Wen-Ben commented, it would really help to see actual data and your expected output.</p>
</div>
<span class="comment-copy">Would you like show us sample data and the expected output ?</span>
<span class="comment-copy">all the numbers are normalized -- they are values between 0 and 1.</span>
<span class="comment-copy">I added a lot of clarity to the post... I dont think specific numbers are important. .. [0,0.5,2,3.5,4.5,5.5,6,6.5,8,9], [10.2, 11.4, 12, 16, 13.5] would be fine input values ... getting a collection back with only 16 would be the expected result.</span>
<span class="comment-copy">I thought that looked elegant and just perfect, but when I apply it and then calculate zscores: <code>original['z'] = delta.apply(lambda x: x - odm / ods)</code> the min and max value in that range are both negative. That shouldnt be possible right? they should be normally distributed around 0</span>
<span class="comment-copy">Just needs parentheses for proper order of operations :) <code>lambda x: (x - odm) / ods</code>. This can be achieved without <code>apply(lambda)</code> as well.</span>
