<div class="post-text" itemprop="text">
<p>I have a project with the following structure:</p>
<pre><code>proj
  src
    application
      app.py
      manage.py
      migrations
  Dockerfile
  docker-compose.yaml
</code></pre>
<p>My goal is to run migrations from the application directory to create tables in the database during docker-compose.</p>
<pre><code>python manage.py db upgrade
</code></pre>
<p>Dockerfile</p>
<pre><code>FROM python:3.7-alpine

ADD requirements.txt /code/
WORKDIR /code

RUN apk add --no-cache postgresql-dev gcc python3 musl-dev &amp;&amp; \
    pip3 install -r requirements.txt


ADD . /code

EXPOSE 5000
WORKDIR /code/src/application

CMD ["flask", "run", "--host=0.0.0.0"]
</code></pre>
<p>docker-compose.yaml</p>
<pre><code>---
version: "3"
services:
  web:
    links:
      - "db"
    build: .
    ports:
      - "5000:5000"
    volumes:
      - .:/code
    depends_on:
      - db
    env_file:
      - .env

  db:
    image: postgres:10
    restart: always
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=app
    ports:
      - "5432:5432"
    expose:
      - 5432

</code></pre>
<p>How can I do that?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd add a bash script that has the commands you want to run during startup and use that as the default entry point in your image. It's usually best practice to call this script <code>entrypoint.sh</code></p>
<pre><code>#!/usr/bin/env bash
python manage.py db upgrade
flask run --host=0.0.0.0
</code></pre>
<p>And then, in your Dockerfile, replace the last line with the following</p>
<pre><code>RUN chmod u+x ./entrypoint.sh
ENTRYPOINT ["./entrypoint.sh"]
</code></pre>
<p>If you want to run the upgrade command only in Docker compose then instead of changing the default entry point in the image you can just override it in the compose file like this</p>
<pre><code>  web:
    links:
      - "db"
    build: .
    ports:
      - "5000:5000"
    volumes:
      - .:/code
    depends_on:
      - db
    entrypoint: /code/entrypoint.sh
    env_file:
      - .env
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>let's try with docker-compose.yml</p>
<pre><code>---
version: "3"
services:
  web:
    links:
      - "db"
    build: .
    ports:
      - "5000:5000"
    volumes:
      - .:/code
    entrypoint:
      - python
      - manage.py
      - db
      - upgrade
    depends_on:
      - db
    env_file:
      - .env

  db:
    image: postgres:10
    restart: always
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=app
    ports:
      - "5432:5432"
    expose:
      - 5432
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about using a third container for this task? As it needs to be execute only one time as far as i know, so adding it to an entrypoint might not the best thing to be done unless you have some checks to avoid running it each time the container starts even if it wont harm, its an unnecessary process to do.</p>
<p>Using a third container will do the following:</p>
<p>When you run <code>docker-compose up</code> it will start according to the order you want and run the command then exit. Regarding the path you may create a shared named volume between the actual application container and the migration-task container. For example:</p>
<blockquote>
<p>I have added a <code>base</code> service to avoid duplication in the docker-compose</p>
</blockquote>
<pre><code>version: "3"
services:
  base:
    build: .
    volumes:
      - .:/code
    env_file:
      - .env
    command: 'false'

  web:
    extends:
      service: base
    command: flask run --host=0.0.0.0
    links:
      - "db"
    ports:
      - "5000:5000"
    depends_on:
      - db

  db:
    image: postgres:10
    restart: always
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=app
    ports:
      - "5432:5432"
    expose:
      - 5432

  migrations:
    extends:
      service: base
    command: python manage.py db upgrade
    depends_on:
      - db
</code></pre>
<p>Other notes:</p>
<ul>
<li><code>links</code> is not needed because docker-compose by default creates a network.</li>
<li><code>expose</code> is not needed too, container will see each other's port as long as they are in the same network.</li>
<li>You might face some kind of race conditioning where your database is not actually ready for connections and your django application tries to connect to it. So in order to solve this issue you will need to use <code>wait-for-it</code> or <code>wait-for</code> as explained in <a href="https://stackoverflow.com/a/55033751/2336650">the following answer</a></li>
</ul>
</div>
<span class="comment-copy">Without having any clue what your Dockerfile or docker-compose files look like I can only say; Add a <code>RUN python manage.py db upgrade</code> to your Dockerfile.</span>
