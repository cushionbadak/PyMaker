<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/9358983/dictionaries-and-default-values">Dictionaries and default values</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<pre><code>ex1 = {'value': '1, 2, 2, 3, 2, 2, 3, 3, 4, 3, 3, 5, 5, 5, 5, 5, 5, 5', 'number': '1197916152', 'key': '44'}
ex2 = {'number': '1197916152', 'key': '2'}
</code></pre>
<p>I've got a dictionaries like above. I need to check if a <code>dict</code> contains <code>value</code> key, and if not, return <code>1</code>. I tried with the following:</p>
<pre><code>np.where('value' in ex1, ex1['value'], 1)
np.where('value' in ex2, ex2['value'], 1)
</code></pre>
<p>And while it works fine with <code>ex1</code>, it returns an error with <code>ex2</code>:</p>
<blockquote>
<p>KeyError                                  Traceback (most recent call
  last) ' in ()
  ----&gt; 1 np.where('value' in ex2, ex2['value'], 1)</p>
<p>KeyError: 'value'</p>
</blockquote>
<p>It seems <code>ex2['value']</code> seems to be evaluated even when a condition is not fulfilled. Am I right? And how can I adjust that?</p>
</div>
<div class="post-text" itemprop="text">
<p>For a simpler solution, use the dictionary <code>.get</code> method to fetch the content of the <code>value</code> key, and set <code>1</code> as default in case it does not exist:</p>
<pre><code>ex1.get('value', 1)
</code></pre>
<hr/>
<pre><code>ex1.get('value', 1)
# '1, 2, 2, 3, 2, 2, 3, 3, 4, 3, 3, 5, 5, 5, 5, 5, 5, 5'

ex2.get('value', 1)
# 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>np.where('value' in ex2, ex2.get('value'), 1)
</code></pre>
</div>
<span class="comment-copy">Yes, but I was expecting that <code>ex2['value']</code> is not evaluated as condition <code>'value' in ex2</code> is not met.</span>
<span class="comment-copy">The problem is <code>np.where</code> evaluates both arguments and then decides what to pick based on the condition.</span>
<span class="comment-copy">Calling <code>np.where</code>, or any other function, always evaluates all the passed arguments, and trying to evaluate <code>ex2['value']</code> fails. Use instead the native Python construct, which is <code>&lt;value-if-true&gt; if &lt;condition&gt; else &lt;value-if-false&gt;</code> (e.g. <code>ex1['value'] if 'value' in ex1 else 1</code>), or, in the case of dicts, you can just do <code>ex1.get('value', 1)</code>.</span>
