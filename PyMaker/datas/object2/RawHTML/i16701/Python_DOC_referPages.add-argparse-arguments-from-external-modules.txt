<div class="post-text" itemprop="text">
<p>I'm trying to write a Python program that could be extended by third parties.  The program will be run from the command line with whatever arguments are supplied.</p>
<p>In order to allow third parties to create their own modules, I've created the following (simplified) base class:</p>
<pre><code>class MyBaseClass(object):
    def __init__(self):
        self.description = ''
        self.command = ''

    def get_args(self):
        # code that I can't figure out to specify argparse arguments here
        # args = []
        # arg.append(.....)
        return args
</code></pre>
<p>Any arguments that they supply via get_args() will be added to a subparser for that particular module.  I want them to be able to specify any type of argument.</p>
<p>I'm not sure of the best way to declare and then get the arguments from the subclassed modules into my main program.  I successfully find all subclasses of MyBaseClass and loop through them to create the subparsers, but I cannot find a clean way to add the individual arguments to the subparser.</p>
<p>Here is the current code from the main program:</p>
<pre><code>for module in find_modules():
    m = module()
    subparser_dict[module.__name__] = subparsers.add_parser(m.command, help=m.help)
    for arg in m.get_args():
            subparser_dict[module.__name__].add_argument(...)
</code></pre>
<p>How can I best specify the arguments in the external modules via get_args() or similar and then add them to the subparser?  One of my failed attempts looked like the following, which doesn't work because it tries to pass every possible option to add_argument() whether it has a value or is None:</p>
<pre><code>            subparser_dict[module.__name__].add_argument(arg['long-arg'],
                action=arg['action'],
                nargs=arg['nargs'],
                const=arg['const'],
                default=arg['default'],
                type=arg['type'],
                choices=arg['choices'],
                required=arg['required'],
                help=arg['help'],
                metavar=arg['metavar'],
                dest=arg['dest'],
                )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without trying to fully understand your module structure, I think you want to be able to provide the arguments to a <code>add_argument</code> call as objects that you can import.</p>
<p>You could, for example, provide a list of positional arguments, and dictionary of keyword arguments:</p>
<pre><code>args=['-f','--foo']
kwargs={'type':int, 'nargs':'*', 'help':'this is a help line'}

parser=argparse.ArgumentParser()
parser.add_argument(*args, **kwargs)
parser.print_help()
</code></pre>
<p>producing</p>
<pre><code>usage: ipython [-h] [-f [FOO [FOO ...]]]

optional arguments:
  -h, --help            show this help message and exit
  -f [FOO [FOO ...]], --foo [FOO [FOO ...]]
                        this is a help line
</code></pre>
<p>In <code>argparse.py</code>, the <code>add_argument</code> method (of a super class of <code>ArgumentParser</code>), has this general signature</p>
<pre><code>def add_argument(self, *args, **kwargs):
</code></pre>
<p>The code of this method manipulates these arguments, adds the <code>args</code> to the <code>kwargs</code>, adds default values, and eventually passes <code>kwargs</code> to the appropriate <code>Action</code> class, returning the new action.  (It also 'registers' the action with the parser or subparser).  It's the <code>__init__</code> of the Action subclasses that lists the arguments and their default values.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would just return an <code>ArgumentParser</code> instance from your <code>get_args</code> method. Then you can create a new <code>ArgumentParser</code> to join all other argument parsers using the <code>parents</code> argument: <a href="https://docs.python.org/3/library/argparse.html#parents" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#parents</a>.</p>
</div>
