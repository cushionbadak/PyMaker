<div class="post-text" itemprop="text">
<p>I'm writing my first program which is a 'Trivia' style game. Questions are asked based on the round you've selected, so selecting round 1 gives you questions from list 1, round 2 questions from list 2 etc. </p>
<p>I've written a piece of code which allows you to change rounds mid game, but if you do this only the first question asked comes from the new round, any subsequent question asked reverts back to the previous round. </p>
<p>So: </p>
<ol>
<li>I select round 1. </li>
<li>Get asked questions from round 1. </li>
<li>Switch to round 2.</li>
<li>Get asked a single question from round 2.</li>
<li>All the questions after that revert back to round 1.</li>
</ol>
<p>I'm not sure why, and I can't seem to find any reason it should do this. </p>
<p>A stripped down version of the code with the problem is: </p>
<pre><code>round = raw_input ("Round?: ")

def turn(round):
    print "Current Round = " + round 
    if round == "1":
        print (choice (ssq1))
        play_again = raw_input("Again?: ")
        repeat(play_again)

    elif round == "2":
        print (choice (ssq2))
        play_again = raw_input("Again?: ")
        repeat(play_again)

def repeat(play_again): 

    if play_again == "Yes" or play_again == "Y":
        turn(round)

    elif play_again == "New":
        new_round = True
        new_turn(new_round)

def new_turn(new_round):
    round = raw_input("Okay, Which round?: ")
    turn(round)

from random import choice

ssq1 = ["Round1Q1", "Round1Q2", "Round1Q3"]
ssq2 = ["Round2Q1", "Round2Q2", "Round2Q3"]

turn(round)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>round</code> in <code>repeat()</code> is the <em>global</em> variable, the one set right at the start. You need to pass in the <em>current</em> round instead; the local name <code>round</code> used in <code>turn()</code>:</p>
<pre><code>repeat(play_again, round)
</code></pre>
<p>and use that in the <code>repeat()</code> function as an additional argument:</p>
<pre><code>def repeat(play_again, round): 
    if play_again == "Yes" or play_again == "Y":
        turn(round)

    elif play_again == "New":
        new_round = True
        new_turn(new_round)
</code></pre>
<p>Your recursive functions are rather convoluted. Consider using a <code>while</code> loop instead:</p>
<pre><code>def turn(round):
    print "Current Round = " + round 
    if round == "1":
        print (choice (ssq1))

    elif round == "2":
        print (choice (ssq2))

round = None

while True:
    if round is None:
        round = raw_input ("Round?: ")

    turn(round)

    play_again = raw_input("Again?: ")
    if play_again == 'New':
        # clear round so you are asked again
        round = None
    elif play_again not in ('Yes', 'Y'):
        # end the game
        break
</code></pre>
<p>Now the <code>turn()</code> function <strong>only</strong> handles a turn of the game. Repetition, asking for what round to play and ending the game is all handled in the one endless <code>while</code> loop. The <code>break</code> statement is used to end that loop.</p>
<p>Another improvement you could consider is using a dictionary or list to hold your rounds, instead of sequentially named variables:</p>
<pre><code>round_questions = {
    "1": ["Round1Q1", "Round1Q2", "Round1Q3"],
    "2": ["Round2Q1", "Round2Q2", "Round2Q3"],
}
</code></pre>
<p>This removes the need to use a large set of conditionals; you simply retrieve the right list by key instead:</p>
<pre><code>def turn(round):
    if round in round_questions:
        print "Current Round = " + round 
        ssq = round_questions[round]
        print choice(ssq)

    else:
        print "No such round", round
</code></pre>
<p>This makes handling erroneous input easier too; if the picked round is not a key in the dictionary, the first <code>if</code> statement will be false and you can print an error message instead.</p>
<p>Note that by using <code>round</code> as a variable name, you <em>are</em> masking the <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow">built-in function by the same name</a>. That's fine here, you are not using any maths that requires rounding, but take that this into account if you ever did need to use that function.</p>
</div>
<span class="comment-copy">probably should not use round as a variable name either</span>
<span class="comment-copy">@PadraicCunningham: Addressed that as a separate point at the end. It's not as big a problem as using <code>dict</code>, <code>list</code> or <code>str</code> as a name.</span>
<span class="comment-copy">@martjin Pieters, not a big issue here but still I think shadowing built-in names is best avoided, no shortage of words in the english language ;).</span>
