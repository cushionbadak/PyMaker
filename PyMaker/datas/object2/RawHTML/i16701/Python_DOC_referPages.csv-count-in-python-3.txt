<div class="post-text" itemprop="text">
<p>I'm switching over my python script into python 3 and I'm having trouble porting a portion of my csv evaluation code.</p>
<p>In python 2.7.5, this segment of code worked just fine:</p>
<pre><code>filename=askopenfilename()

with open(filename, 'rb') as Order:
    reader = csv.reader(Order, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
    OrderList = []
    first = Order.next()
    if (first.count("Web ID") == 1):
        OrderList.append("Digi-key")
        OrderList.append(first)
</code></pre>
<p>Now I've since changed the <code>Order.next()</code> line to next(Order) so it'll work w/ python 3, although I can't seem to find the python 3 equivalent of <code>if (first.count("Web ID") == 1):</code></p>
<p>I've looked through the CSV module documentation for Python 3 and I may have missed something and I am not doing the greatest trying to figure it out. </p>
<p>The portion I'm trying to evaulate is this (changed numbers to maintain privacy):</p>
<pre><code>Web ID,Access ID,Salesorder Number,Shipping Method,Payment Method,
49488634,84901,37873472,U.S. Postal Service Priority Mail* (2-3 Day Delivery to most US addresses)(order by 8:00 PM CT),Foo,

Shipping Address
...
</code></pre>
<p>The current error is this:</p>
<pre><code>TypeError: Type str doesn't support the buffer API
</code></pre>
<p>any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>The method <code>count</code> is implemented by strings or lists. In your case, you are calling it on a string, which you retrieve from the file object by calling its <code>next</code> method. On Python 3, when you open a file in binary mode, you get an iterable of bytestrings, not strings. Type <code>bytes</code> also implements <code>count</code>, but you can only count occurrences of bytestrings in a bytestring, otherwise you get a <code>TypeError</code>:</p>
<pre><code>In [1]: b'hello'.count(b'el')
Out[1]: 1

In [2]: b'hello'.count('el')
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-2-df699ac18654&gt; in &lt;module&gt;()
----&gt; 1 b'hello'.count('el')

TypeError: Type str doesn't support the buffer API
</code></pre>
<p>You are probably going to have to open the file in text mode for CSV parsing anyway, because
the <a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow"><code>csv.reader</code> documentation</a> says:</p>
<blockquote>
<p><code>csv.reader(csvfile, dialect='excel', **fmtparams)</code></p>
<p>Return a reader
  object which will iterate over lines in the given csvfile. csvfile can
  be any object which supports the iterator protocol and returns a
  <strong>string</strong> each time its <code>__next__()</code> method is called — file objects and
  list objects are both suitable.</p>
</blockquote>
<p>Note the emphasis on the word "string" that I added.  You should open the file in text mode, and preferably, with <code>newline=''</code>, as suggested at the linked page.</p>
<p>As an aside, you can probably change <code>first = next(order)</code> to <code>first = next(reader)</code>. This way you'll have a list of strings (a row), and counting the occurrences of a certain string in it may be more robust.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the python documentation of the csv module (<a href="https://docs.python.org/3.4/library/csv.html?highlight=csv#csv" rel="nofollow">https://docs.python.org/3.4/library/csv.html?highlight=csv#csv</a>), in order to translate that method in Python 3 you should use the next() function on your CSV reader object:</p>
<pre><code>csvreader.__next__()

Return the next row of the reader’s iterable object as a list, parsed according to the current dialect. Usually you should call this as next(reader).
</code></pre>
<p>I hope that this will help you</p>
<p>Cheers</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is in opening the file with mode='rb'. I found that if you open with mode 'r', then it should work:</p>
<pre><code>with open(filename, 'r') as Order:
</code></pre>
<p>When openning with 'rb', Python3 interpret the file as a series of bytes and read the contents as such. With mod 'r', Python3 reads the file as strings.</p>
</div>
<span class="comment-copy">Can you post, or make up, a portion of the CSV file? Just the first few lines.</span>
<span class="comment-copy">What exactly happens when you run the code with Python 3?</span>
<span class="comment-copy">In python 2, you open csv files as <code>open(csvfile, 'rb')</code>, in 3 you do <code>open(csvfile, newline='')</code>.  This may (or may not) be your exact problem here, but it can definitely lead to hard-to-track-down bugs down the line.</span>
<span class="comment-copy">That worked, thanks!</span>
<span class="comment-copy">But the problem is not with the <code>next</code> method. Replacing it with the call to the <code>next()</code> function is the right thing to do and works on both versions of Python.</span>
