<div class="post-text" itemprop="text">
<p>Python 3</p>
<p>Data might be a string, bytes or an EmailMessage.</p>
<p>Is this the most effective way to get the bytes out of data?</p>
<pre><code>    while True:
        try:
            # data is a string
            f.write(data.encode('utf-8'))
            break
        except:
            pass
        try:
            # data is an EmailMessage
            f.write(data.get_bytes())
            break
        except:
            pass
        try:
            # data is bytes
            f.write(data)
            break
        except:
            pass
        else:
            self.log.info('Exiting, unknown attachment type')
            sys.exit(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>if hasattr(data, "encode"):
    f.write(data.encode('utf-8'))
elif hasattr(data, "get_bytes"):
    f.write(data.get_bytes())
else:
    try:
        f.write(data)
    except TypeError:
        self.log.info('Exiting, unknown attachment type')
        sys.exit(1)
</code></pre>
<p><strong>Edit:</strong></p>
<p>This is ducktyping - as in "if it quacks like a duck, it is a duck; if it encodes, it is a string".</p>
<p>This is preferred over <code>if isinstance(data, str)</code> because it is less restrictive; so long as an object knows how to encode itself to bytes, we don't really care if it is actually a string or not.</p>
<p>Exceptions are relatively slow and should be reserved for handling unexpected or unlikely errors.</p>
</div>
<div class="post-text" itemprop="text">
<p>From wikipedia:</p>
<blockquote>
<p>For example, in a non-duck-typed language, one would create a function
  that requires that the object passed into it be of type Duck, in order
  to ensure that that function can then use the object's walk and quack
  methods. In a duck-typed language, the function would take an object
  of any type and simply call its walk and quack methods, producing a
  run-time error if they are not defined. Instead of specifying types formally, duck typing practices rely on documentation, clear code, and testing <strong>to ensure correct use</strong>.</p>
</blockquote>
<p>This doesn't mean you can call whatever methods you feel like, and catch an exception if it doesn't exist. You still need to make some effort to only call methods you are sure will be there. Duck-typing is more related to the fact that you don't care what the type of the object is (if you passed it into a function, you don't specify the type as you would in Java), but are still sure that it will respond to a specific method call.</p>
<p>In your case, what I would do is create a wrapper around each of those objects (String, EmailMessage, bytes), with a common method <code>get_data</code>, where each implementation of get_data is specific to the type of object it wraps around (<code>encode</code>, <code>get_bytes</code> etc.). Then your loop would look as follows:</p>
<pre><code>while True:
    try:
        # data is a string
        f.write(data.get_data())
        break
    except:
        pass
</code></pre>
<p><strong>Edit:</strong> You may also want to see this question which is related to yours: <a href="https://stackoverflow.com/questions/6589967/how-to-handle-duck-typing-in-python">How to handle "duck typing" in Python?</a></p>
</div>
<span class="comment-copy">Really? I've been reading about ducktyping and that I should be just trying to use expected methods and exception handle them if the method is not present.</span>
<span class="comment-copy">@DukeDougal That's not really a good characterisation of duck typing. Duck typing is "just use the properties of the input that you need"; whether you handle the exceptions that result when those properties do <b>not</b> hold is mostly irrelevant. The key point is that if someone can make those properties hold for some other type that's completely different from what you were thinking of when you wrote your code, your code should still work on it.</span>
<span class="comment-copy">@DukeDougal In this case, you're trying to make code that works provided the input has an <code>encode</code> method, <i>or</i> a <code>get_bytes</code> method, <code>or</code> can be directly handled by <code>f.write</code>. Those are the properties you need, so directly testing for those is fine; there's no "virtue" in using exceptions to switch between the different cases you're trying to handle. It's duck typing because you're not checking whether <code>data</code> is an <code>EmailMessage</code> before treating it like one, you're just seeing whether it has a <code>get_bytes</code> method.</span>
<span class="comment-copy"><code>hasattr</code> is implemented (<a href="https://docs.python.org/3/library/functions.html#hasattr" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#hasattr</a>) by trying to get the attribute and handling the exception. So performance is a red herring. But your answer is nice otherwise.</span>
<span class="comment-copy">@aychedee, compared to real work, sure. But if this is all you're doing in a tight loop, handling an exception has about a 25% performance penalty. <code>hasattr</code> intercepts the exception at the C API level, which is more efficient than handling it in bytecode in the ceval loop.</span>
