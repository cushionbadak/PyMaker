<div class="post-text" itemprop="text">
<p>I use boost.python for calling script. Each python script has 3 functions:</p>
<ul>
<li>Initialize - that have to be called at start</li>
<li>Uninitialize - that have to be called at finish for closing every object.</li>
<li>Process - that have to be called multiple times between Initialize and Uninitialize.</li>
</ul>
<p>This class don't need in explanation:</p>
<pre><code>class PyInit
{
public:
    PyInit() { Py_Initialize(); }
    ~PyInit() {  Py_Finalize();  }
};
</code></pre>
<p>This class creates PyInit object instance, then initialize all Python objects and makes call to "Initialize()" python function at constructor.
And calls "Uninitialize()" at destructor.</p>
<p>And this class has function "Process" to call it outside of class multiple times. </p>
<pre><code>class PyGuard
{
public:
    explicit PyGuard(const char* pypath)
    {
      try
      {
        _main_module = boost::python::import("__main__");
        _main_namespace = _main_module.attr("__dict__");
        boost::python::object ignored = exec_file(pypath, _main_namespace);
        _Initialize = _main_namespace["Initialize"];
        _Process = _main_namespace["Process"];
        _Uninitialize = _main_namespace["Uninitialize"];

        _InitRes = _Initialize();
        _ProcRes = boost::python::object();
      }
      catch(boost::python::error_already_set&amp;)
      {
        string res;
        py_utils::err_parse(res);
        throw string("Python exception: " + res);
      }
      catch(std::exception&amp; e)
      {
          throw string("C++ exception: " + string(e.what()));
      }
      catch(...)
      {
          throw string("Unhandled exception!");
      }
    }
    virtual ~PyGuard()
    {
        _Uninitialize(_InitRes, _ProcRes);
    }
    void Process()
    {
        _ProcRes = _Process(_InitRes, _ProcRes);
    }


private:
    py_utils::PyInit _initPython;

    boost::python::object _InitRes;
    boost::python::object _ProcRes; 

    boost::python::object _Process;
    boost::python::object _Initialize;
    boost::python::object _Uninitialize;

    boost::python::object _main_module;
    boost::python::object _main_namespace;
};
</code></pre>
<p>As only "Process" fails with "boost::python::error_already_set" exception, current instance of PyGuard is deleted and then created new one. To avoid hidden dependencies that could be as hidden exception result. </p>
<p>So, after exception, all python stuff is removed (even calls Py_Finalize()), and then created again.</p>
<p>Still, after 4-10 such exceptions, whole c++ process falls.</p>
<p>Falls, avoiding even catchers:</p>
<pre><code>  try
  {
      _PyGuard = make_shared&lt;PyGuard&gt;("my script");
      while(true)
      {
        try {
          _PyGuard-&gt;Process();
        }
        catch()
        {
              bool inited = false;
              while(!inited)
              {
                try
                {
                _pyGuard = nullptr;
                _pyGuard = make_shared&lt;PyGuard&gt;("script path.txt");
                inited = true;
                }
                catch(string&amp; e)
                {
                }
              }
        }
      } 
      _PyGuard = nullptr;
  } 
  catch(...)
  {
      //falling, it never being catched here.
  }
</code></pre>
<p>So, my question is, why can it falls and being uncatchable?</p>
<p>I just found that it falls at line:</p>
<pre><code>_pyGuard = make_shared&lt;PyGuard&gt;("script path.txt"); 
</code></pre>
<p>call, so I feel it is Python raise exception that can't be catched. Why? And how to prevent it?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's possible that your use of <code>Py_Finalize()</code> is the problem. According to the Boost 1.55 documentation, you <a href="http://www.boost.org/doc/libs/1_55_0/libs/python/doc/tutorial/doc/html/python/embedding.html" rel="nofollow">shouldn't use <code>Py_Finalize()</code> with Boost.Python</a>. It doesn't look like your program really needs finalization, so you might try just removing the call from <code>~PyInit()</code>.</p>
<p>If you really do need finalization for some reason, you might look at <a href="https://docs.python.org/3/c-api/init.html#c.Py_NewInterpreter" rel="nofollow"><code>Py_NewInterpreter()</code></a>.</p>
<p>As for your "uncatchable exceptions" problem, that's often an effect of having two active exceptions at once. When that happens, C++ will simply abort. That may (or may not) be what's happening with your code. </p>
</div>
<span class="comment-copy">Thank you, I will try to test it!</span>
<span class="comment-copy">Am I right thinking that there can be two exception at once just if before it finished parsing first exception, it raised second one?</span>
<span class="comment-copy">No, throwing an exception from inside a catch-block is perfectly fine. In that situation, the first exception is considered "handled". Where you run into problems is when one exception is being propagated and - outside of a catch block - a new exception is thrown.</span>
