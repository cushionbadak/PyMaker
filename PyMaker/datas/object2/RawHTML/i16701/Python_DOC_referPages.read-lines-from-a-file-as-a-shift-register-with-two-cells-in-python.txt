<div class="post-text" itemprop="text">
<p>I need to read the lines of a file in such way that will behave as a shift register with two cell.
For example:</p>
<pre><code>with open("filename", 'r') as file:

 --first iteration--
 present = line1
 next  = line2
    do something

 --second iteration--
 present = line2
 next = line3
   do something

 --third iteration--
 present = line3
 next = line 4
    do someting

 and so on....
</code></pre>
<p>It can be done with <code>open(file, 'r')</code> but it does not guarantee that the file will be closed as the script may stop
due to of a "do something" before the last iteration.</p>
<p>Any elegant way to do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Sure:</p>
<pre><code>with open("filename", 'r') as file:
    current_line = next(file)  # Get 1st line, advance iterator to 2nd line
    for next_line in file:
        do_something(current_line, next_line)
        current_line = next_line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Tim's answer is a good one. A "fancier" solution is to use the <code>pairwise</code> recipe using <code>itertools.tee</code> shown in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertoos</code> docs</a>:</p>
<pre><code>def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)
</code></pre>
<p><code>tee</code> is a pretty neat function. It can be used any time you want to iterate over the same iterable more than once. If you're consuming all of the iterators more or less in parallel (rather than running one iteration to completion, then doing the next, etc.), it can be more space efficient than dumping the whole iterable into a <code>list</code> or some other container that can be iterated over and over.</p>
<p>Basically, you pass it one iterable object and it returns a number of independent iterators (by default, two). The original iterable is only advanced as far as is necessary to handle the furthest ahead of the returned iterators.</p>
<p>Here's a <code>tee</code> demo with a generator that prints a message before yielding a value:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; def gen():
        for i in range(3):
            print("gen yielding {}".format(i))
            yield i


&gt;&gt;&gt; a, b = itertools.tee(gen())
&gt;&gt;&gt; next(a)
gen yielding 0
0
&gt;&gt;&gt; next(a)
gen yielding 1
1
&gt;&gt;&gt; next(b)
0
&gt;&gt;&gt; next(b)
1
&gt;&gt;&gt; next(b)
gen yielding 2
2
&gt;&gt;&gt; next(b)
Traceback (most recent call last):
  File "&lt;pyshell#245&gt;", line 1, in &lt;module&gt;
    next(b)
StopIteration
&gt;&gt;&gt; next(a)
2
&gt;&gt;&gt; next(a)
Traceback (most recent call last):
  File "&lt;pyshell#247&gt;", line 1, in &lt;module&gt;
    next(a)
StopIteration
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/23823376/1142167">Tim's answer</a> and <a href="https://stackoverflow.com/a/23823711/1142167">Blckknght's answer</a> are good. To add to the pool of solutions, you can also do this using a deque:</p>
<pre><code>from collections import deque
n = 2
with open('myfile', 'r') as infile:
    window = deque(maxlen=n)
    for line in infile:
        window.append(line)
        do_something(*window)
</code></pre>
<p>More generally, you can create a generator that yields from a deque:</p>
<pre><code>def sliding_window(iterable, n=2, fill_value=None, add_padding=False):
    it = iter(iterable)
    if add_padding:
        window = deque([fill_value for _ in range(n-1)], maxlen=n)
        window.append(next(it))
    else:
        window = deque([next(iterable) for _ in range(n)], maxlen=n)

    yield tuple(window)

    for item in it:
        window.append(it)
        yield tuple(window)

    if add_padding:
        for _ in range(n-1):
            window.append(fill_value)
            yield tuple(window)
</code></pre>
<p>Note that the above implementation will yield an empty generator if there are fewer values in <code>iterable</code> than <code>n</code>.</p>
</div>
<span class="comment-copy">Maybe I'm not understanding, but opening a file with a <code>with</code> block guarantees that the file will be closed if the program exits for some reason.</span>
<span class="comment-copy">@Joel: True, file gets closed in case of <code>with open(....)</code> but I was referring to the case where it can be open as <code>f = open(...)</code> and then it needs to be closed manually. This was before getting help from you guys. Thanks!</span>
<span class="comment-copy">Gotcha. Incidentally doing <code>with open(...)</code> is equivalent to doing <code>try: f = open(...); finally: f.close()</code>...</span>
<span class="comment-copy">Thank you! Right on the money!:)</span>
<span class="comment-copy">Oh, I like this. +1</span>
<span class="comment-copy">@Blckknght: I looked the the <code>tee</code> function in the <code>itertools</code> but could not make sense out of it. Can you explain how your solution works?</span>
<span class="comment-copy">@flamenco: I've added an explanation of what <code>tee</code> does to my answer. You don't really need to know the details of the implementation to understand what it does.</span>
<span class="comment-copy">@Blckknght: This is good! Thanks for taking your time to explain it!</span>
<span class="comment-copy">@ Joel: I like the windowing idea, too. All answers are great. I leant something new. Thank you!</span>
<span class="comment-copy">@flamenco: Don't forget to upvote all the answers, then. And don't hesitate to accept a different answer if it works better for you.</span>
<span class="comment-copy">@Tim: Done! I would accept all of them if I could as all of them equally gave me something to take home. I have something for you--look at this question that I just posted: What would be the pythonic way to simulate communication with an external equipment? RPyC?</span>
