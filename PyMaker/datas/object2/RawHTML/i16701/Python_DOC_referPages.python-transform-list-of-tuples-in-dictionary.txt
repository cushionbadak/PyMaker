<div class="post-text" itemprop="text">
<p>Wondering if there is a more idiomatic (pythonic) way of doing this. I have a list of tuples returned by a cursor object, and I'm trying to regroup the data in a dictionary. The data I get is formatted as such:</p>
<pre><code>[("Département d'informatique", 119, 74, 193),
 ("Département d'informatique", 193, 67, 260), 
 ("Département de chimie", 355, 44, 399) ... ]
</code></pre>
<p>Notice that departments repeat. Each line with the same department represents a different kind of data. I need to regroup that data in a dictionary that contains a key (department name) and the value would be a list of all the tuples that have that department as its first member. So something like this:</p>
<pre><code>{ "Département d'informatique": [(119, 74, 193), (193,67,260) ...] }
</code></pre>
<p>Here is my code. It's working at the moment but I'm not sure if it's the most efficient/pythonic way of doing things.</p>
<pre class="lang-py prettyprint-override"><code>def preparer_donnees(data):
    ret = { ligne[0] : [] for ligne in data }

    for ligne in data:
        for entree in ligne[1:]:
            ret[ligne[0]].append(entree)

    return ret
</code></pre>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a>:</p>
<pre><code>def preparer_donnees(data):
    from collections import defaultdict

    ret = defaultdict(list)

    for v in data:
        ret[v[0]].append(v[1:])

    return ret
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a nested list comprehension:</p>
<pre><code>{line[0] : [tup[1:] for tup in data if tup[0] == line[0]] for line in data}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If all the tuples have 4 elements, you could just unpack the tuples:</p>
<pre><code>my_d = {}

for k, v1, v2, v3 in l:
    if my_d.get(k):
        my_d[k] += [(v1,v2,v3)]
    else:
        my_d[k] = [(v1,v2, v3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the dictionary "setdefault" method ( which can be replaced in many cases by using the defaultdict - but not always - I like the setdefault as its more general and quite powerful )</p>
<p><a href="https://stackoverflow.com/questions/3483520/use-cases-for-the-setdefault-dict-method">Use cases for the 'setdefault' dict method</a></p>
<pre><code>def process( data ):
    result = {}
    for vals in data:
        result.setdefault( vals[0], [] ).append( vals[1:] )
    return result
</code></pre>
<p>Also, mathsaey's answer </p>
<pre><code>{line[0] : [tup[1:] for tup in data if tup[0] == line[0]] for line in data}
</code></pre>
<p>is wrong as the values of his dictionary are list of lists rather than list of values. I don't have enough reputation to comment (new account), so adding this observation here.</p>
</div>
<span class="comment-copy">Perfect! Thank you.</span>
