<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; datetime.strptime('2014-02-13 11:55:00 -0800', '%Y-%m-%d %H:%M:%S %z')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_strptime.py", line 317, in _strptime
    (bad_directive, format))
ValueError: 'z' is a bad directive in format '%Y-%m-%d %H:%M:%S %z'
</code></pre>
<p>I understand that it's not supported, but don't know why. Seems it's not hard to support that. And '<a href="http://en.wikipedia.org/wiki/ISO_8601#Time_offsets_from_UTC" rel="nofollow">Offset from UTC</a>' is not as ambiguous as timezone abbreviation. </p>
</div>
<div class="post-text" itemprop="text">
<p>Until Python 3.2, Python's <code>datetime</code> module <em>had no <code>timezone()</code> object</em>. It supported 3rd-party libraries providing timezones by providing a <a href="https://docs.python.org/2/library/datetime.html#tzinfo-objects" rel="noreferrer"><code>datetime.tzinfo()</code> abstract base class</a>, but no timezone object was included. Without a timezone object, no support for parsing timezone offsets either.</p>
<p>As of Python 3.2, <code>z</code> is supported, because that version (and up) added a <a href="https://docs.python.org/3/library/datetime.html#timezone-objects" rel="noreferrer"><code>datetime.timezone()</code> type</a>:</p>
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; datetime.datetime.strptime('2014-02-13 11:55:00 -0800', '%Y-%m-%d %H:%M:%S %z')
datetime.datetime(2014, 2, 13, 11, 55, tzinfo=datetime.timezone(datetime.timedelta(-1, 57600)))
&gt;&gt;&gt; _.tzinfo
datetime.timezone(datetime.timedelta(-1, 57600))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a fix for python 2.7</p>
<p>Instead of using:</p>
<pre><code>datetime.strptime(t,'%Y-%m-%dT%H:%M %z')
</code></pre>
<p>use the <code>timedelta</code> to account for the timezone, like this:</p>
<pre><code>from datetime import datetime,timedelta
def dt_parse(t):
    ret = datetime.strptime(t[0:16],'%Y-%m-%dT%H:%M')
    if t[18]=='+':
        ret+=timedelta(hours=int(t[19:22]),minutes=int(t[23:]))
    elif t[18]=='-':
        ret-=timedelta(hours=int(t[19:22]),minutes=int(t[23:]))
    return ret
</code></pre>
</div>
<span class="comment-copy">Duplicate: <a href="http://stackoverflow.com/questions/1101508/how-to-parse-dates-with-0400-timezone-string-in-python" title="how to parse dates with 0400 timezone string in python">stackoverflow.com/questions/1101508/…</a></span>
<span class="comment-copy">@IanStevens: that says nothing about <i>why</i>.</span>
<span class="comment-copy">There's some speculation under a comment in that link. The linked mailing list archive, <a href="https://mail.python.org/pipermail/python-bugs-list/2003-November/021063.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-bugs-list/2003-November/…</a>, suggests it's a feature of libc: "it's not a Python bug but a bug in the platform libc." Whether or not that's still true, I don't know.</span>
<span class="comment-copy">That's a bug report about <code>time.strptime()</code> though. The reliance on the libc parser has long since been replaced by a <a href="http://hg.python.org/cpython/file/90dab7696e89/Lib/_strptime.py" rel="nofollow noreferrer">pure-Python implementation</a> used by both the <code>time.strptime()</code> and <code>datetime.datetime.strptime()</code> functions.</span>
