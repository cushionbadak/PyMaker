<div class="post-text" itemprop="text">
<p>I recently discovered some interesting behavior that left me wondering about how an object knows about which global variables exist. For example, suppose I have a file "test.py":</p>
<pre><code>globalVar = 1
toDelete = 2

class Test(object):
    classVar = 3

    def runTest1(self):
        print globalVar
        print toDelete
        print missingVar

    def runTest2(self):
        print self.classVar
        print toCreate
        print missingVar
</code></pre>
<p>Then in an interactive shell I do this:</p>
<pre><code>&gt;&gt;&gt; import test
&gt;&gt;&gt; tester = test.Test()
&gt;&gt;&gt; tester.runTest1()
1
2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "test.py", line 10, in runTest1
    print missingVar
NameError: global name 'missingVar' is not defined
&gt;&gt;&gt; tester.runTest2()
3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "test.py", line 14, in runTest2
    print toCreate
NameError: global name 'toCreate' is not defined
</code></pre>
<p>Nothing surprising. Then I change the first few lines of "test.py" to this:</p>
<pre><code>globalVar = 4 
toCreate = 5

class Test(object):
    classVar = 6
</code></pre>
<p>Now back to the interactive shell:</p>
<pre><code>&gt;&gt;&gt; reload(test) # test = reload(test) gives the same result 
&lt;module 'test' from 'test.py'&gt;
&gt;&gt;&gt; tester.runTest1()
4
2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "test.py", line 10, in runTest1
    print missingVar
NameError: global name 'missingVar' is not defined
&gt;&gt;&gt; tester.runTest2()
3
5
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "test.py", line 15, in runTest2
    print missingVar
NameError: global name 'missingVar' is not defined
&gt;&gt;&gt; dir(test)
['Test', '__builtins__', '__doc__', '__file__', '__name__', '__package__', 'globalVar', 'toCreate', 'toDelete']
</code></pre>
<p>So <code>tester</code> now knows about <code>toCreate</code>, which showed up after <code>tester</code> itself was created. It still knows about <code>toDelete</code> because reloading a module apparently doesn't affect a global variable that was deleted. Here comes a twist:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; import importlib
&gt;&gt;&gt; del(sys.modules['test']) # remove cached version
&gt;&gt;&gt; test = importlib.import_module('test') # same result if I don't have 'test = '
&gt;&gt;&gt; tester.runTest1()
None
None
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "test.py", line 10, in runTest1
    print missingVar
NameError: global name 'missingVar' is not defined
&gt;&gt;&gt; tester.runTest2()
3
None
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "test.py", line 15, in runTest2
    print missingVar
NameError: global name 'missingVar' is not defined
&gt;&gt;&gt; dir(test)
['Test', '__builtins__', '__doc__', '__file__', '__name__', '__package__', 'globalVar', 'toCreate']
</code></pre>
<p>Deleting the module from <code>sys.modules</code> and then reimporting the module results in all the global variables becoming <code>None</code>.</p>
<p>Also of interest is that if I delete <code>test</code> and <code>sys.modules['test']</code>, it still knows about the values of the variables for a while. After a little while (which I assume is how long it takes for the module to be garbage collected) the values become <code>None</code>. Reimporting the module causes the garbage collection (or whatever is going on) to happen immediately.</p>
<p>So how does <code>tester</code> find out about a new global variable being created, and then once the module is gone why does it still know which variables existed even though it no longer knows what values they held?</p>
</div>
<div class="post-text" itemprop="text">
<p>Any name that is not a local (has not been assigned to in the current scope) is instead assumed to be a global. The name is looked up every time the code runs.</p>
<p>So at <em>runtime</em> the name is looked up in the global namespace, which is just a dictionary. If the name doesn't exist at that time, a <code>NameError</code> exception is raised.</p>
<p>You can see this when you disassemble a function; bytecode is shown when using the <a href="https://docs.python.org/2/library/dis.html" rel="nofollow"><code>dis</code> module</a>:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def foo():
...     bar = 'baz'  # local
...     bar  # reference the local
...     baz  # reference something else; e.g. a global
... 
&gt;&gt;&gt; dis.dis(foo)
  2           0 LOAD_CONST               1 ('baz')
              3 STORE_FAST               0 (bar)

  3           6 LOAD_FAST                0 (bar)
              9 POP_TOP             

  4          10 LOAD_GLOBAL              0 (baz)
             13 POP_TOP             
             14 LOAD_CONST               0 (None)
             17 RETURN_VALUE        
</code></pre>
<p><code>bar</code> is a local (it was assigned to in the block), while <code>baz</code> is a global. The local is referenced by <code>LOAD_FAST</code>, while the global is referenced by <code>LOAD_GLOBAL</code>.</p>
<p>To do this, function objects have a <code>function.__globals__</code> reference linking it to the module globals mapping; see the <em>User-defined functions</em> section in the <a href="https://docs.python.org/2/reference/datamodel.html" rel="nofollow">datamodel documentation</a>:</p>
<pre><code>&gt;&gt;&gt; foo.__globals__ is globals()
True
</code></pre>
<p>Python also <em>cleans up globals</em> when deleting modules; to prevent circular references holding up finalisation globals are rebound to <code>None</code> at that time (although this behaviour <a href="https://docs.python.org/3/whatsnew/3.4.html#whatsnew-pep-442" rel="nofollow">changed in Python 3.4</a>). If you however maintain a reference to <code>tester</code>, your code will find those <code>None</code> values.</p>
<p>Your <code>tester</code> instance, still referencing the original class and it's methods, are still referencing their module through their <code>function.__globals__</code> references. So, although you deleted the <code>sys.modules</code> reference to the module, triggering the module cleanup, the <em>globals dictionary</em> is still referenced by the class methods. This globals dictionary now holds <code>None</code> values for each global.</p>
</div>
<span class="comment-copy">Objects know nothing about scopes. <i>Functions</i> do.</span>
<span class="comment-copy">@delnan Functions are objects, so... <i>*ducks and runs*</i></span>
<span class="comment-copy">So why do I get <code>None</code> for the variables rather than a <code>NameError</code>? <code>toDelete</code> no longer exists, but <code>tester</code> still knows that it did.</span>
<span class="comment-copy">@RobWatts In Python 2 when a module gets deleted all of its global variables are set to <code>None</code>. This is now fixed: <a href="http://legacy.python.org/dev/peps/pep-0442/" rel="nofollow noreferrer">legacy.python.org/dev/peps/pep-0442</a></span>
<span class="comment-copy">@Martijn I think it would be useful to explain <i>how</i> functions get their globals (<code>f.__globals__</code>), where that dict comes from, and what happens to a module when it's garbage collected (clearing its <code>__dict__</code>). (I don't have time right now to write a competing answer.)</span>
<span class="comment-copy">I didn't know about how global variables were cleaned up. I believe that's what's going on here.</span>
<span class="comment-copy">@delnan yes; I was time constrained as well (distractions elsewhere).</span>
