<div class="post-text" itemprop="text">
<p>My problem is pretty straight forward. I have a client program written in Java which has a method that generates an ID. I'm writing Python scripts to parse and correct the output of this client program. The method in the client that creates the ID's uses bitwise operations to create the ID. Unfortunately, the ID generator is unique though it says it's UUID, it's not.</p>
<p>The code I'm trying to convert is open source and in the EMF EcoreUtil.java file<a href="http://grepcode.com/file/repository.grepcode.com/java/eclipse.org/4.2/org.eclipse.emf/ecore/2.8.0/org/eclipse/emf/ecore/util/EcoreUtil.java/#EcoreUtil.generateUUID%28byte%5B%5D%29" rel="nofollow">1</a>. If you have the time or looking for a fun coding, you're welcome to translate this code. But I'd like to know how to do bitwise operations like this in python like I would in C/C++ and Java.</p>
</div>
<div class="post-text" itemprop="text">
<p>The bitwise operations in python are the same as they are in C/Java (though python lacks the <code>&gt;&gt;&gt;</code> operation of Java as it is not needed; sign extension is always done, but even 0xFFFF_FFFF_FFFF_FFFF can be represented as a positive integer).</p>
<p>As an added bonus, Python integers can be used positive for whatever size, unlike in Java, where there are signedness issues with bit-twiddling.</p>
<p>Looking at the linked file, it seems that the value indeed should be an UUID, only that it is base64-encoded:</p>
<blockquote>
<p>Generates a universally unique identifier, i.e., a UUID. It encodes
  the 128 bit UUID in base 64, but rather than padding the encoding with
  two "=" characters, it prefixes the encoding with a single "_"
  character, to ensure that the result is a valid ID, i.e., an NCName</p>
</blockquote>
<p>In Python there is <a href="https://docs.python.org/3/library/uuid.html" rel="nofollow">UUID</a> class, and <a href="https://docs.python.org/3/library/base64.html" rel="nofollow">base64</a> encoding module; thus the whole identifier handling could be written in Python as</p>
<pre><code>import uuid
import base64

gen_id = uuid.uuid1()  # generate type 1 UUID
id_bytes = gen_id.bytes  # take its bytes
encoded = base64.b64encode(id_bytes, b'-_')
encoded = encoded.replace(b'=', b'')  # remove the padding bytes
result = '_' + encoded.decode('ascii')  # result is a string with '_' prepended.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The Python wiki has a <a href="https://wiki.python.org/moin/BitwiseOperators" rel="nofollow">good page on this</a>.  I don't know Java that well, but at first look I think many of the operators are the same: </p>
<p>In addition, you may want to look at the <a href="https://docs.python.org/2/library/uuid.html" rel="nofollow">uuid module</a>.</p>
<p>The Operators:</p>
<pre><code>x &lt;&lt; y Returns x with the bits shifted to the left by y places (and new bits on the right-hand-side are zeros). This is the same as multiplying x by 2**y.
x &gt;&gt; y Returns x with the bits shifted to the right by y places. This is the same as //'ing x by 2**y.
x &amp; y  Does a "bitwise and". Each bit of the output is 1 if the corresponding bit of x AND of y is 1, otherwise it's 0.
x | y  Does a "bitwise or". Each bit of the output is 0 if the corresponding bit of x AND of y is 0, otherwise it's 1.
~ x    Returns the complement of x - the number you get by switching each 1 for a 0 and each 0 for a 1. This is the same as -x - 1.
x ^ y  Does a "bitwise exclusive or". Each bit of the output is the same as the corresponding bit in x if that bit in y is 0, and it's the complement of the bit in x if that bit in y is 1.
</code></pre>
</div>
<span class="comment-copy">Python has the same bitwise operators as the languages you already know. The primary difference is built-in bignums, which will require a few extra masks here and there if you need left shifts to discard bits.</span>
<span class="comment-copy">I know that the operations are the same, but the data types don't seem to support the operations in the same way. In C/C++ and Java, you can just signed char a=-8; signed char b= a &gt;&gt; 1; and have 'b' be -4.</span>
<span class="comment-copy">You can do the same thing in Python: <code>a = -8; b = a &gt;&gt; 1</code>. Now <code>b</code> is <code>-4</code>.</span>
<span class="comment-copy">The reason for the java code to do lots of bit twiddling is because Eclipse still nominally supported Java 1.4; the UUID class does exist in Java 1.5, and thus there the code could be much simpler.</span>
<span class="comment-copy">I fixed the uuid generation</span>
<span class="comment-copy">That works so well. Thank you! I didn't even think to look at it that way.</span>
