<div class="post-text" itemprop="text">
<p>I want to parse strings into python enums. Normally one would implement a parse method to do so. A few days ago I spotted the <strong>__new__</strong> method which is capable of returning different instances based on a given parameter.</p>
<p>Here my code, which will not work:</p>
<pre><code>import enum
class Types(enum.Enum):
  Unknown = 0
  Source = 1
  NetList = 2

  def __new__(cls, value):
    if (value == "src"):  return Types.Source
#    elif (value == "nl"): return Types.NetList
#    else:                 raise Exception()

  def __str__(self):
    if (self == Types.Unknown):     return "??"
    elif (self == Types.Source):    return "src"
    elif (self == Types.NetList):   return "nl"
</code></pre>
<p>When I execute my Python script, I get this message:</p>
<pre><code>[...]
  class Types(enum.Enum):
File "C:\Program Files\Python\Python 3.4.0\lib\enum.py", line 154, in __new__
  enum_member._value_ = member_type(*args)
TypeError: object() takes no parameters
</code></pre>
<p>How can I return a proper instance of a enum value?</p>
<h2>Edit 1:</h2>
<p>This Enum is used in URI parsing, in particular for parsing the schema. So my URI would look like this</p>
<pre><code>nl:PoC.common.config
&lt;schema&gt;:&lt;namespace&gt;[.&lt;subnamespace&gt;*].entity
</code></pre>
<p>So after a simple string.split operation I would pass the first part of the URI to the enum creation.</p>
<pre><code>type = Types(splitList[0])
</code></pre>
<p>type should now contain a value of the enum Types with 3 possible values (Unknown, Source, NetList)</p>
<p>If I would allow aliases in the enum's member list, it won't be possible to iterate the enum's values alias free.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can override the <code>__new__()</code> method of an <code>enum</code> subclass to implement a parse method if you're careful, but in order to avoid specifying the integer encoding in two places, you'll need to define the method separately, <em>after</em> the class, so you can reference the symbolic names defined by the enumeration.</p>
<p>Here's what I mean:</p>
<pre><code>import enum

class Types(enum.Enum):
    Unknown = 0
    Source = 1
    NetList = 2

    def __str__(self):
        if (self == Types.Unknown):     return "??"
        elif (self == Types.Source):    return "src"
        elif (self == Types.NetList):   return "nl"
        else:                           raise TypeError(self)

def _Types_parser(cls, value):
    if not isinstance(value, str):
        # forward call to Types' superclass (enum.Enum)
        return super(Types, cls).__new__(cls, value)
    else:
        # map strings to enum values, default to Unknown
        return { 'nl': Types.NetList,
                'ntl': Types.NetList,  # alias
                'src': Types.Source,}.get(value, Types.Unknown)

setattr(Types, '__new__', _Types_parser)

print("Types('nl') -&gt;",  Types('nl'))   # Types('nl') -&gt; nl
print("Types('ntl') -&gt;", Types('ntl'))  # Types('ntl') -&gt; nl
print("Types('wtf') -&gt;", Types('wtf'))  # Types('wtf') -&gt; ??
print("Types(1) -&gt;",     Types(1))      # Types(1) -&gt; src
</code></pre>
<p><strong>Update</strong></p>
<p>Here's a more table-driven version that helps eliminates some of the repetitious coding that would otherwise be involved:</p>
<pre><code>from collections import OrderedDict
import enum

class Types(enum.Enum):
    Unknown = 0
    Source = 1
    NetList = 2
    __str__ = lambda self: Types._value_to_str.get(self)

# define after Types class
Types.__new__ = lambda cls, value: (cls._str_to_value.get(value, Types.Unknown)
                                    if isinstance(value, str) else
                                    super(Types, cls).__new__(cls, value))
# define look-up table and its inverse
Types._str_to_value = OrderedDict((( '??', Types.Unknown),
                                   ('src', Types.Source),
                                   ('ntl', Types.NetList),  # alias
                                   ( 'nl', Types.NetList),))
Types._value_to_str = {val: key for key, val in Types._str_to_value.items()}
Types._str_to_value = dict(Types._str_to_value) # convert to regular dict (optional)

if __name__ == '__main__':
    print("Types('nl')  -&gt;", Types('nl'))   # Types('nl')  -&gt; nl
    print("Types('ntl') -&gt;", Types('ntl'))  # Types('ntl') -&gt; nl
    print("Types('wtf') -&gt;", Types('wtf'))  # Types('wtf') -&gt; ??
    print("Types(1)     -&gt;", Types(1))      # Types(1)     -&gt; src

    print()
    print(list(Types))  # iterate values

    import pickle  # demostrate picklability
    print(pickle.loads(pickle.dumps(Types.NetList)) == Types.NetList)  # -&gt; True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__new__</code> method on the your <code>enum.Enum</code> type is used for creating new instances of the enum <em>values</em>, so the <code>Types.Unknown</code>, <code>Types.Source</code>, etc. singleton instances. The enum call (e.g. <code>Types('nl')</code> is handled by <code>EnumMeta.__call__</code>, which you could subclass.</p>
<h2>Using name aliases fits your usecases</h2>
<p>Overriding <code>__call__</code> is perhaps overkill for this situation. Instead, you can easily use <a href="https://docs.python.org/3/library/enum.html#duplicating-enum-members-and-values" rel="noreferrer">name aliases</a>:</p>
<pre><code>class Types(enum.Enum):
    Unknown = 0

    Source = 1
    src = 1

    NetList = 2
    nl = 2
</code></pre>
<p>Here <code>Types.nl</code> is an alias and will return <em>the same object</em> as <code>Types.Netlist</code>. You then <a href="https://docs.python.org/3/library/enum.html#programmatic-access-to-enumeration-members-and-their-attributes" rel="noreferrer">access members by <em>names</em></a> (using <code>Types[..]</code> index access); so <code>Types['nl']</code> works and returns <code>Types.Netlist</code>.</p>
<p>Your assertion that <em>it won't be possible to iterate the enum's values alias free</em> is <strong>incorrect</strong>. Iteration <a href="https://docs.python.org/3/library/enum.html#iteration" rel="noreferrer"><em>explicitly doesn't include aliases</em></a>:</p>
<blockquote>
<p>Iterating over the members of an enum does not provide the aliases</p>
</blockquote>
<p>Aliases are part of the <code>Enum.__members__</code> ordered dictionary, if you still need access to these.</p>
<p>A demo:</p>
<pre><code>&gt;&gt;&gt; import enum
&gt;&gt;&gt; class Types(enum.Enum):
...     Unknown = 0
...     Source = 1
...     src = 1
...     NetList = 2
...     nl = 2
...     def __str__(self):
...         if self is Types.Unknown: return '??'
...         if self is Types.Source:  return 'src'
...         if self is Types.Netlist: return 'nl'
... 
&gt;&gt;&gt; list(Types)
[&lt;Types.Unknown: 0&gt;, &lt;Types.Source: 1&gt;, &lt;Types.NetList: 2&gt;]
&gt;&gt;&gt; list(Types.__members__)
['Unknown', 'Source', 'src', 'NetList', 'nl']
&gt;&gt;&gt; Types.Source
&lt;Types.Source: 1&gt;
&gt;&gt;&gt; str(Types.Source)
'src'
&gt;&gt;&gt; Types.src
&lt;Types.Source: 1&gt;
&gt;&gt;&gt; str(Types.src)
'src'
&gt;&gt;&gt; Types['src']
&lt;Types.Source: 1&gt;
&gt;&gt;&gt; Types.Source is Types.src
True
</code></pre>
<p>The only thing missing here is translating unknown schemas to <code>Types.Unknown</code>; I'd use exception handling for that:</p>
<pre><code>try:
    scheme = Types[scheme]
except KeyError:
    scheme = Types.Unknown
</code></pre>
<h2>Overriding <code>__call__</code></h2>
<p>If you want to treat your strings as values, and use calling instead of item access, this is how you override the <code>__call__</code> method of the metaclass:</p>
<pre><code>class TypesEnumMeta(enum.EnumMeta):
    def __call__(cls, value, *args, **kw):
        if isinstance(value, str):
            # map strings to enum values, defaults to Unknown
            value = {'nl': 2, 'src': 1}.get(value, 0)
        return super().__call__(value, *args, **kw)

class Types(enum.Enum, metaclass=TypesEnumMeta):
    Unknown = 0
    Source = 1
    NetList = 2
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class TypesEnumMeta(enum.EnumMeta):
...     def __call__(cls, value, *args, **kw):
...         if isinstance(value, str):
...             value = {'nl': 2, 'src': 1}.get(value, 0)
...         return super().__call__(value, *args, **kw)
... 
&gt;&gt;&gt; class Types(enum.Enum, metaclass=TypesEnumMeta):
...     Unknown = 0
...     Source = 1
...     NetList = 2
... 
&gt;&gt;&gt; Types('nl')
&lt;Types.NetList: 2&gt;
&gt;&gt;&gt; Types('?????')
&lt;Types.Unknown: 0&gt;
</code></pre>
<p>Note that we translate the string value to integers here and leave the rest to the original Enum logic.</p>
<h2>Fully supporting <em>value</em> aliases</h2>
<p>So, <code>enum.Enum</code> supports <em>name</em> aliases, you appear to want <em>value</em> aliases. Overriding <code>__call__</code> can offer a facsimile, but we can do better than than still by putting the definition of the value aliases into the enum class itself. What if specifying duplicate <em>names</em> gave you value aliases, for example?</p>
<p>You'll have to provide a subclass of the <code>enum._EnumDict</code> too as it is that class that prevents names from being re-used. We'll assume that the <em>first</em> enum value is a default:</p>
<pre><code>class ValueAliasEnumDict(enum._EnumDict):
     def __init__(self):
        super().__init__()
        self._value_aliases = {}

     def __setitem__(self, key, value):
        if key in self:
            # register a value alias
            self._value_aliases[value] = self[key]
        else:
            super().__setitem__(key, value)

class ValueAliasEnumMeta(enum.EnumMeta):
    @classmethod
    def __prepare__(metacls, cls, bases):
        return ValueAliasEnumDict()

    def __new__(metacls, cls, bases, classdict):
        enum_class = super().__new__(metacls, cls, bases, classdict)
        enum_class._value_aliases_ = classdict._value_aliases
        return enum_class

    def __call__(cls, value, *args, **kw):
        if value not in cls. _value2member_map_:
            value = cls._value_aliases_.get(value, next(iter(Types)).value)
        return super().__call__(value, *args, **kw)
</code></pre>
<p>This then lets you define aliases <em>and</em> a default in the enum class:</p>
<pre><code>class Types(enum.Enum, metaclass=ValueAliasEnumMeta):
    Unknown = 0

    Source = 1
    Source = 'src'

    NetList = 2
    NetList = 'nl'
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class Types(enum.Enum, metaclass=ValueAliasEnumMeta):
...     Unknown = 0
...     Source = 1
...     Source = 'src'
...     NetList = 2
...     NetList = 'nl'
... 
&gt;&gt;&gt; Types.Source
&lt;Types.Source: 1&gt;
&gt;&gt;&gt; Types('src')
&lt;Types.Source: 1&gt;
&gt;&gt;&gt; Types('?????')
&lt;Types.Unknown: 0&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the by far easiest solution to your problem is to use the functional API of the <code>Enum</code> class which gives more freedom when it comes to choosing names since we specify them as strings:</p>
<pre><code>from enum import Enum

Types = Enum(
    value='Types',
    names=[
        ('??', 0),
        ('Unknown', 0),
        ('src', 1),
        ('Source', 1),
        ('nl', 2),
        ('NetList', 2),
    ]
)
</code></pre>
<p>This creates an enum with name aliases. Mind the order of the entries in the <code>names</code> list. The first one will be chosen as default value (and also returned for <code>name</code>), further ones are considered as aliases but both can be used:</p>
<pre><code>&gt;&gt;&gt; Types.src
&lt;Types.src: 1&gt;
&gt;&gt;&gt; Types.Source
&lt;Types.src: 1&gt;
</code></pre>
<p>To use the <code>name</code> property as a return value for <code>str(Types.src)</code> we replace the default version from <code>Enum</code>:</p>
<pre><code>&gt;&gt;&gt; Types.__str__ = lambda self: self.name
&gt;&gt;&gt; Types.__format__ = lambda self, _: self.name
&gt;&gt;&gt; str(Types.Unknown)
'??'
&gt;&gt;&gt; '{}'.format(Types.Source)
'src'
&gt;&gt;&gt; Types['src']
&lt;Types.src: 1&gt;
</code></pre>
<p>Note that we also replace the <code>__format__</code> method which is called by <code>str.format()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't have enough rep to comment on the accepted answer, but in Python 2.7 with the enum34 package the following error occurs at run-time:</p>
<p>"unbound method &lt;lambda&gt;() must be called with instance MyEnum as first argument (got EnumMeta instance instead)"</p>
<p>I was able to correct this by changing:</p>
<pre><code># define after Types class
Types.__new__ = lambda cls, value: (cls._str_to_value.get(value, Types.Unknown)
                                    if isinstance(value, str) else
                                    super(Types, cls).__new__(cls, value))
</code></pre>
<p>to the following, wrapping the lambda in with staticmethod():</p>
<pre><code># define after Types class
Types.__new__ = staticmethod(
    lambda cls, value: (cls._str_to_value.get(value, Types.Unknown)
                        if isinstance(value, str) else
                        super(Types, cls).__new__(cls, value)))
</code></pre>
<p>This code tested correctly in both Python 2.7 and 3.6.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is it possible to override <code>__new__</code> in a python enum to parse strings to an instance?</p>
</blockquote>
<p>In a word, yes.  As martineau illustrates you can replace the <code>__new__</code> method <em>after</em> the class has been instanciated (his original code):</p>
<pre><code>class Types(enum.Enum):
    Unknown = 0
    Source = 1
    NetList = 2
    def __str__(self):
        if (self == Types.Unknown):     return "??"
        elif (self == Types.Source):    return "src"
        elif (self == Types.NetList):   return "nl"
        else:                           raise TypeError(self) # completely unnecessary

def _Types_parser(cls, value):
    if not isinstance(value, str):
        raise TypeError(value)
    else:
        # map strings to enum values, default to Unknown
        return { 'nl': Types.NetList,
                'ntl': Types.NetList,  # alias
                'src': Types.Source,}.get(value, Types.Unknown)

setattr(Types, '__new__', _Types_parser)
</code></pre>
<p>and also as his demo code illustrates, if you are not extremely careful you will break other things such as pickling, and even basic member-by-value lookup:</p>
<pre><code>--&gt; print("Types(1) -&gt;", Types(1))  # doesn't work
Traceback (most recent call last):
  ...
TypeError: 1
--&gt; import pickle
--&gt; pickle.loads(pickle.dumps(Types.NetList))
Traceback (most recent call last):
  ...
TypeError: 2
</code></pre>
<p>Martijn showed is a clever way of enhancing <code>EnumMeta</code> to get what we want:</p>
<pre><code>class TypesEnumMeta(enum.EnumMeta):
    def __call__(cls, value, *args, **kw):
        if isinstance(value, str):
            # map strings to enum values, defaults to Unknown
            value = {'nl': 2, 'src': 1}.get(value, 0)
        return super().__call__(value, *args, **kw)

class Types(enum.Enum, metaclass=TypesEnumMeta):
    ...
</code></pre>
<p>but this puts us having duplicate code, and working against the Enum type.</p>
<p>The only thing lacking in basic Enum support for your use-case is the ability to have one member be the default, but even that can be handled gracefully in a normal <code>Enum</code> subclass by creating a new class method.</p>
<p>The class that you want is:</p>
<pre><code>class Types(enum.Enum):
    Unknown = 0
    Source = 1
    src = 1
    NetList = 2
    nl = 2
    def __str__(self):
        if self is Types.Unknown:
            return "??"
        elif self is Types.Source:
            return "src"
        elif self is Types.NetList:
            return "nl"
    @classmethod
    def get(cls, name):
        try:
            return cls[name]
        except KeyError:
            return cls.Unknown
</code></pre>
<p>and in action:</p>
<pre><code>--&gt; for obj in Types:
...   print(obj)
... 
??
src
nl

--&gt; Types.get('PoC')
&lt;Types.Unknown: 0&gt;
</code></pre>
<p>If you really need value aliases, even that can be handled without resorting to metaclass hacking:</p>
<pre><code>class Types(Enum):
    Unknown = 0, 
    Source  = 1, 'src'
    NetList = 2, 'nl'
    def __new__(cls, int_value, *value_aliases):
        obj = object.__new__(cls)
        obj._value_ = int_value
        for alias in value_aliases:
            cls._value2member_map_[alias] = obj
        return obj

print(list(Types))
print(Types(1))
print(Types('src'))
</code></pre>
<p>which gives us:</p>
<pre><code>[&lt;Types.Unknown: 0&gt;, &lt;Types.Source: 1&gt;, &lt;Types.NetList: 2&gt;]
Types.Source
Types.Source
</code></pre>
</div>
<span class="comment-copy">Definitely possible. <a href="http://stackoverflow.com/a/10555965/3438854">This answer</a> has some good examples.</span>
<span class="comment-copy">@JohnC: except the <code>__new__</code> method is <b>not used</b> for <code>Types(0)</code> or <code>Types('nl')</code>. It is used to create the <code>Types.Source</code> and <code>Types.Unknown</code> <i>value objects</i> instead.</span>
<span class="comment-copy">To clarify some points: a) the enum members should be unique (I removed @enum.unique in front of the class definition to simplify the code. b) so adding all possible matching values as a enum member (like NetList, nl, list, ...) is no option. c) yes writing a parse(value) method would work fine (e.g. .NET uses this pattern) but I'm locking for a nicer solution in a python way :)</span>
<span class="comment-copy">You don't want aliases, yet you are adding aliases?  That doesn't make sense.</span>
<span class="comment-copy">Aliases in value which is to be parses are allowed, but aliases in the enum itself ware not allowd. As mentioned some comments down: the value to parse <b>can</b> be a string and if so, there is no garantied 1-to-1 mapping of names.</span>
<span class="comment-copy">This is also a nice solution, thanks.</span>
<span class="comment-copy">@Ethan: It's fairly easy to make basic lookup work. However I don't have time right now to see if pickling could also be supporedt -- but suspect that it, too, could be.</span>
<span class="comment-copy">@Ethan: Thanks for pointing out the lookup issue and following-up with pickling tidbit -- which I've verified to indeed be the case.</span>
<span class="comment-copy">@Ethan: Hmmm, this code seems to contradict what it says in the notes at the end of the <a href="https://pypi.python.org/pypi/enum34#interesting-examples" rel="nofollow noreferrer">Interesting Examples</a> section of the pypi's <code>enum34</code> module's documentation -- namely that "there is no way to customize Enum's <code>__new__</code>".</span>
<span class="comment-copy">Yeah, I'll have to fix that.  :/  At the time I was thinking of writing a normal <code>__new__</code> inside the class, and completely forgot about just replacing <code>__new__</code> after the fact.</span>
<span class="comment-copy">Interesting example of using and extending <code>EnumMeta</code>.</span>
<span class="comment-copy">@MartijnPieters thanks for your two solutions. Solution 1: The first one would not serve all my requirements, because the enum members aren't unique - see my clarification comment on the original post for details</span>
<span class="comment-copy">Solution 2: This locks more like what I'm locking for. <b>But</b> in this solution the integer encoding is located in two classes / code places. Is it possible to combine them?</span>
<span class="comment-copy">@Paebbels: You could extend the <code>__new__</code> method of the metaclass to build that map. I can try and extend that tomorrow.</span>
<span class="comment-copy">@Paebbels: Given your question update I am not convinced you need to use value aliases at all, but I've expanded my answer to support defining those fully as part of the enum class now. But do read up on the first solution again, iteration over an enum does <i>not</i> include aliases.</span>
