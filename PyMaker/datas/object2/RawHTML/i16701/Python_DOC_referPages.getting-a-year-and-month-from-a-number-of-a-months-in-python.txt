<div class="post-text" itemprop="text">
<p>I'd like to write a function which:</p>
<ul>
<li>takes in parameter: a number of months (int)</li>
<li>returns the year (int) and the month (int) of the timedelta between now and the number of input months.</li>
</ul>
<p>Example : we are in may 2014, so:</p>
<ul>
<li>myfunc(0) should return (2014, 5)</li>
<li>myfunc(12) should return (2013, 5)</li>
<li>myfunc(5) should return (2013, 12)</li>
<li>etc.</li>
</ul>
<p>There is lots of documentation about datetime and calendar, so much that I'm a bit lost. Thanks for help.</p>
<p><strong>Note</strong>: I need to get an accurate way to do it, not an approximation :)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import datetime

def myfunc(num_of_months):
    today = datetime.date.today()
    num_of_months = today.year * 12 + today.month - 1 - num_of_months
    year = num_of_months / 12
    month = num_of_months % 12 + 1
    return year, month
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from time import strftime, localtime, time
from calendar import monthrange
def uberdate(n):
    if n == 0: return strftime('%Y, %m').split(', ')
    month = int(strftime('%m'))
    aDay = 60*60*24
    offset = aDay # One day to start off with
    for i in range(0, n):
        while int(strftime('%m', localtime(time()-offset))) == month:
            offset = offset+aDay
        month = int(strftime('%m', localtime(time()-offset)))
    return strftime('%Y, %m', localtime(time()-offset)).split(', ')

print(uberdate(5))
</code></pre>
<p>This produces:</p>
<pre><code>[torxed@archie ~]$ python test.py 
[2013, 12]
</code></pre>
<p>Don't know why i got the downvote, but to quote OP:</p>
<blockquote>
<p>Example : we are in may 2014, so:</p>
<p>myfunc(5) should return (2013, 12) etc.</p>
</blockquote>
<p>And this is what my function produces...<br/>
Feedback people, give it before downvoting randomly.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>python-dateutil</code> module for this. <a href="https://pypi.python.org/pypi/python-dateutil" rel="nofollow">https://pypi.python.org/pypi/python-dateutil</a></p>
<pre><code>def return_year_date(delta_month):
    from datetime import date
    from dateutil.relativedelta import relativedelta

    new_date = date.today() + relativedelta(months= -delta_month)

    return new_date.year, new_date.month
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>EDITED</strong> (Changed the month addition to make the accuracy perfect)</p>
<p><strong>Now you can put negative number of months and get past dates</strong>
I think this is what youre looking for</p>
<pre><code>import datetime
from dateutil.relativedelta import * 

def calculate_date(number_months):
    time_now = datetime.datetime.now()  # Get now time
    time_future = time_now + relativedelta(months=+number_months)   # Add months
    return time_future.year,time_future.month  #Return year,month
</code></pre>
<p>I've tested this script in my coputer and works perfectly</p>
<pre><code>&gt;&gt;&gt; calculate_data(5)
(2014, 10)
</code></pre>
</div>
<span class="comment-copy"><code>time.strftime('%Y, %m%'), time.localtime(time.time() - n*(60*60*24*30)))</code> ish.. averaged the number of days to 30 per month so that will be a bit off :) Use <a href="https://docs.python.org/3/library/calendar.html#calendar.monthrange" rel="nofollow noreferrer">monthrange</a> to calculate the ammont of days by looping backwards in your function (instead of doing a one-liner)</span>
<span class="comment-copy">Thanks for this but I need an accurate solution, not an approximation. I'll add it in my question.</span>
<span class="comment-copy">We're more interested in what you've tried so far actually.. Cause you show 0 effort and you ask us to solve the problem for you.. Which we probably will because we just want to get this over with :P</span>
<span class="comment-copy">I NEVER downvoted your answer...</span>
<span class="comment-copy">I was thinking about posting an answer but it has become a dangerous thread now, any ways answer is achieve. One more point, I dnt want to sound professor 'by the book', but lets keep everything we do here as constructive as we can :) cheers</span>
<span class="comment-copy">You can get current_year by datetime.date.today().year and use the same for month (warning, this seems to be one-based).</span>
<span class="comment-copy">That works very well, thanks. I actually had the feeling the modulo was a good solution to do it, but had no idea how to do this. I just replaced <code>datetime.date.today()</code>by <code>datetime.now()</code> but this changes nothing.</span>
<span class="comment-copy">You have to use datetime.datetime.now() instead of datetime.now(). I recomend you to check my solution is accuracy and easy to understand</span>
<span class="comment-copy">What's the complexity of this solution?</span>
<span class="comment-copy">You ment to say why*? If so this isn't really complex, it's just a manually programmable solution to the problem.. Since the OP didn't give any specifics I didn't think of looking much into existing libraries since he didn't bother to.</span>
<span class="comment-copy">I'm talking about algorithmic complexity. If it does an operation for each month, not sure how it will work for a large input. Anyway it doesn't seem to work with years before 1900.</span>
<span class="comment-copy">That's probably because unix <code>time()</code> stamps will become a negative value and the mathematical operation in my logic will fail.</span>
<span class="comment-copy">@torxed Thanks for your help. I didn't downvoted, but I'm almost sure who did it..just watching who is so eager to get upvotes..</span>
<span class="comment-copy">This assumes 31 days in each month, not counting leap years.. OP asked for a accurate solution (see comments above)</span>
<span class="comment-copy">You are right, but through documentation I found this relativedelta that works perfectly for this situation, and the code is easy to understand in this way and the accuracy is perfect</span>
