<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/15710515/python-3-bytes-formatting">Python 3 bytes formatting</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>I know this question has been asked before, but couldn't get it working for me though.
What I want to do is sent a prefix with my message like so:</p>
<pre><code>msg = pickle.dumps(message)
prefix = b'{:0&gt;5d}'.format(len(msg))
message = prefix + msg
</code></pre>
<p>This gives me</p>
<pre><code>AttributeError: 'bytes' object has no attribute 'format'
</code></pre>
<p>I tried formatting with <code>%</code> and encoding but none of them worked.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't <code>format</code> a <a href="https://docs.python.org/3/library/stdtypes.html#bytes-and-bytearray-operations" rel="nofollow noreferrer"><code>bytes</code> literal</a>. You also can't concatenate <code>bytes</code> objects with <code>str</code> objects. Instead, put the whole thing together as a <code>str</code>, and then convert it to <code>bytes</code> using the proper encoding.</p>
<pre><code>msg = 'hi there'
prefix = '{:0&gt;5d}'.format(len(msg)) # No b at the front--this is a str
str_message = prefix + msg # still a str
encoded_message = str_message.encode('utf-8') # or whatever encoding

print(encoded_message) # prints: b'00008hi there'
</code></pre>
<hr/>
<p>Or if you're a fan of one-liners:</p>
<pre><code>encoded_message = bytes('{:0&gt;5d}{:1}'.format(len(msg), msg), 'utf-8')
</code></pre>
<hr/>
<p>According your comment on <a href="https://stackoverflow.com/a/24065644/2069350">@Jan-Philip's answer</a>, you need to specify how many bytes you're about to transfer? Given that, you'll need to encode the message first, so you can properly determine how many bytes it will be when you send it. <a href="https://stackoverflow.com/q/3842487/2069350">The <code>len</code> function produces a proper byte-count when called on <code>bytes</code></a>, so something like this should work for arbitrary text:</p>
<pre><code>msg = 'Ã¼' # len(msg) is 1 character
encoded_msg = msg.encode('utf-8') # len(encoded_msg) is 2 bytes
encoded_prefix = '{:0&gt;5d}'.format(len(encoded_msg)).encode('utf-8')
full_message = encoded_prefix + encoded_msg # both are bytes, so we can concat

print(full_message) # prints: b'00002\xc3\xbc'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Edit: I think I misunderstood your question. Your issue is that you can't get the length into a bytes object, right?</p>
<p>Okay, you would usually use the <a href="https://docs.python.org/2/library/struct.html" rel="nofollow"><code>struct</code></a> module for that, in this fashion:</p>
<pre><code>struct.pack("!i", len(bindata)) + bindata
</code></pre>
<p>This writes the length of the (binary!) message into a four byte integer object. The return value of <code>pack()</code> is this object (of type <code>bytes</code>). For decoding this on the receiving end you need to read exactly the first 4 bytes of your message into a bytes object. Let's call this <code>first_four_bytes</code>. Decoding is done using <code>struct.unpack</code>, using the same format specifier (!i) in this case:</p>
<pre><code>messagesize, = struct.unpack("!i", first_four_bytes)
</code></pre>
<p>Then you know exactly how many of the following bytes belong to the message: <code>messagesize</code>. Read exactly that many bytes, and decode the message. </p>
<p>Old answer:</p>
<p>In Python 3, the <code>__add__</code> operator returns what we want:</p>
<pre><code>&gt;&gt;&gt; a = b"\x61"
&gt;&gt;&gt; b = b"\x62"
&gt;&gt;&gt; a + b
b'ab'
</code></pre>
</div>
<span class="comment-copy"><code>bytes</code> doesn't support formatting, not before Python 3.5 (not yet out). Decode to <code>str</code>, then encode again, or use rethink what you are doing.</span>
<span class="comment-copy">He is dealing with a stream transport (saying "so the server knows what length will come"), so he needs to know how many bytes exactly encode the message length. Is that deterministic with your approach? Can you show how you would decode the message size from a byte stream?</span>
<span class="comment-copy">@Jan-PhilipGehrcke Depends on his encoding, presumably. If that's the case, he's got other problems, since he's got his <code>msg</code> set up as a string, and the <code>len</code> of that isn't necessarily the number of bytes he'll be sending, as you say.</span>
<span class="comment-copy">@Jan-PhilipGehrcke I've updated the answer with a stable solution for his actual use case.</span>
<span class="comment-copy">Thank you both for the replies! I found this answer the most helpfull, since I didn't need to change anything on the server side.</span>
<span class="comment-copy">@Barto: just note that the custom protocol above requires 5 bytes for length encoding, with a maximum length of 99999. Using a native data type such as unsigned long (<code>L</code> format specifier for Python's <code>struct</code> methods) the maximum encodable message length is 2^32-1 (4294967295), i.e. 5 order of magnitudes larger, within 4 bytes only, i.e. one byte less than in the approach above. In real-world protocols you would use the latter approach in order to optimize the ratio between protocol overhead and actual payload.</span>
<span class="comment-copy">Indeed, so the server knows what length will come</span>
