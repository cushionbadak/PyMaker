<div class="post-text" itemprop="text">
<p>I have some code that contains two objects something to this effect: </p>
<pre><code>class Parent(object): 
    def __init__(): 
        self.child = None

    def stuffParentDoes(): 
        while True: 
            if self.child is None: 
                self.child = Child(randint(1,1000))
                self.child.start()
            else:
                print self.child

            time.sleep(3)

class Child(Thread): 
    def __init__(self, name):
        super(Child, self).__init__()
        self.name = name

    def run(): 
        print "%s child doing child stuff" % self.name
        time.sleep(3)


parent = Parent()        
parent.stuffParentDoes()
</code></pre>
<p><strong>My problem is this.</strong>  If <code>Child</code> is spawned and running properly, the <code>print Child</code> will give something like this  <code>&lt;Child(Thread-2, started 140038530209536)&gt;</code>.  If it raises an exception, it'll print something like this  <code>&lt;Child(Thread-2, stopped 140038530209536)&gt;</code></p>
<p>My <code>Parent</code> object need to know that its stopped, clean up it's own <code>self.child</code> variable, then restart another <code>Child</code> in its place.  Obviously this is over simplified but hopefully you get my point.  Calling <code>join()</code> on the child doesn't work either because <code>Parent</code> has many other things to do and since <code>join()</code> is blocking that causes a problem.  </p>
<p><strong>EDIT:</strong> 
What ended up solving my problem was moving my reference to the child thread outside the scope of my parent object.  When the reference was in the global scope, I didn't have a problem unsetting it when I needed to restart the child. </p>
</div>
<div class="post-text" itemprop="text">
<p>The following code maintains a 'pool' of threads (aka children).  Every second, dead threads are removed, and new ones added to maintain 3 threads at all times.</p>
<p>For a larger projects consider going to the <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow">concurrent.futures</a> module, specifically the <code>ThreadPoolExecutor</code> function.  I also recommend 3rd party library <code>gevent</code> (flexible, fast, Python2 only) and internal module <code>multiprocessing</code> (has Pool, is included in all Pythons).</p>
<h1>source</h1>
<pre><code>import threading, time
from random import random

class Child(threading.Thread): 
    def run(self): 
        print "\t%s: child doing child stuff" % self
        # sleep 1-3 seconds
        time.sleep( 1. + random()*2 )


nchildren = 3
tpool = []

for _ in range(4):
    diff = nchildren - len(tpool)
    if diff &lt; 1:
        print '* okay'
    else:
        print '* starting {} children'.format(diff)
        new_children = [ Child() for _ in xrange(diff) ]
        for thread in new_children:
            thread.start()
        tpool.extend( new_children )

    time.sleep(1)
    print '* scan...', 
    tpool = [ thread for thread in tpool
              if thread.isAlive()
              ]
    print '{} children'.format(len(tpool))
</code></pre>
<h2>output</h2>
<pre><code>* starting 3 children
    &lt;Child(Thread-1, started 47211446597376)&gt;: child doing child stuff
    &lt;Child(Thread-2, started 47211448698624)&gt;: child doing child stuff
    &lt;Child(Thread-3, started 47211450799872)&gt;: child doing child stuff
* scan... 3 children
* okay
* scan... 2 children
* starting 1 children
    &lt;Child(Thread-4, started 47211448698624)&gt;: child doing child stuff
* scan... 1 children
* starting 2 children
    &lt;Child(Thread-5, started 47211450799872)&gt;: child doing child stuff
    &lt;Child(Thread-6, started 47211446597376)&gt;: child doing child stuff
* scan... 3 children
</code></pre>
</div>
<span class="comment-copy">There are two ways: either parent waits until child terminates or raising a volatile flag. The parent have to poll that flag periodically. Third method is that parent is a service. It has a message que and operates by consuming and executing the message-specified commands.</span>
<span class="comment-copy"><code>join()</code> can be nonblocking, give it a timeout like <code>join(0.)</code></span>
<span class="comment-copy">@shavenwarthog what would it do after it executes its timeout if the child hasn't thrown an exception yet and is still running?  the python docs are a little confusing to me there</span>
<span class="comment-copy">Thanks for the help.  This didn't solve my problem but it lead to the solution.  When I moved my reference to the children threads outside the parent object, all worked as I expected.</span>
