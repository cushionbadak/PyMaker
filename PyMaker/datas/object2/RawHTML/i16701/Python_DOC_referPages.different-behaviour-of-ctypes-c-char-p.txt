<div class="post-text" itemprop="text">
<p>I am confused with this behaviour of different versions of python and dont understand why ? </p>
<pre><code>Python 2.7.5 (default, Aug 25 2013, 00:04:04) 
[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.0.68)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; c="hello"
&gt;&gt;&gt; a=ctypes.c_char_p(c)
&gt;&gt;&gt; print(a.value) 
hello

Python 3.3.5 (default, Mar 11 2014, 15:08:59) 
[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.2.79)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; c="hello" 
&gt;&gt;&gt; a=ctypes.c_char_p(c)
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: bytes or integer address expected instead of str instance
</code></pre>
<p>One works while the other gives me an error. Which one is correct ? </p>
<p>If both of them are correct, how can i achieve the same behaviour as 2.7 in 3.3.5 ? I want to pass the char pointer to C from python.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>c_char_p</code> is a subclass of <code>_SimpleCData</code>, with <code>_type_ == 'z'</code>. The <code>__init__</code> method calls the type's <code>setfunc</code>, which for simple type <code>'z'</code> is <code>z_set</code>.</p>
<p>In Python 2, the <a href="http://hg.python.org/cpython/file/f89216059edf/Modules/_ctypes/cfield.c#l1333"><code>z_set</code> function</a> (2.7.7) is written to handle both <code>str</code> and <code>unicode</code> strings. Prior to Python 3, <code>str</code> is an 8-bit string. CPython 2.x <code>str</code> internally uses a C null-terminated string (i.e. an array of bytes terminated by <code>\0</code>), for which <code>z_set</code> can call <a href="https://docs.python.org/2/c-api/string.html#PyString_AS_STRING"><code>PyString_AS_STRING</code></a> (i.e. get a pointer to the internal buffer of the <code>str</code> object). A <code>unicode</code> string needs to first be encoded to a byte string. <code>z_set</code> handles this encoding automatically and keeps a reference to the encoded string in the <code>_objects</code>  attribute. </p>
<pre><code>&gt;&gt;&gt; c = u'spam'
&gt;&gt;&gt; a = c_char_p(c)
&gt;&gt;&gt; a._objects
'spam'
&gt;&gt;&gt; type(a._objects)
&lt;type 'str'&gt;
</code></pre>
<p>On Windows, the default ctypes string encoding is <code>'mbcs'</code>, with error handling set to <code>'ignore'</code>. On all other platforms the default encoding is <code>'ascii'</code>, with <code>'strict'</code> error handling. To modify the default, call <a href="https://docs.python.org/2/library/ctypes.html#ctypes.set_conversion_mode"><code>ctypes.set_conversion_mode</code></a>. For example, <code>set_conversion_mode('utf-8', 'strict')</code>. </p>
<p>In Python 3, the <a href="http://hg.python.org/cpython/file/c0e311e010fc/Modules/_ctypes/cfield.c#l1326"><code>z_set</code> function</a> (3.4.1) does not automatically convert <code>str</code> (now Unicode) to <code>bytes</code>. The paradigm shifted in Python 3 to strictly divide character strings from binary data. The ctypes default conversions were removed, as was the function <code>set_conversion_mode</code>. You have to pass <code>c_char_p</code> a <code>bytes</code> object (e.g. <code>b'spam'</code> or <code>'spam'.encode('utf-8')</code>). In CPython 3.x, <code>z_set</code> calls the C-API function <a href="https://docs.python.org/3/c-api/bytes.html#c.PyBytes_AsString"><code>PyBytes_AsString</code></a> to get a pointer to the internal buffer of the <code>bytes</code> object. </p>
<p>Note that if the C function modifies the string, then you need to instead use <a href="https://docs.python.org/3/library/ctypes.html#ctypes.create_string_buffer"><code>create_string_buffer</code></a> to create a <code>c_char</code> array. Look for a parameter to be typed as <code>const</code> to know that it's safe to use <code>c_char_p</code>.</p>
</div>
<span class="comment-copy">In Python 3 use <code>bytes</code>, i.e. <code>c = b"hello"</code>. The <code>c_char_p</code> instance points at the private buffer of the <code>bytes</code> object, so only use this for <code>const</code> parameters that won't modify the string.</span>
<span class="comment-copy">@eryksun If you could add that as an answer with reason of why it changed in python3, I would be happy to accept it.</span>
<span class="comment-copy">Thanks for your detailed answer.</span>
