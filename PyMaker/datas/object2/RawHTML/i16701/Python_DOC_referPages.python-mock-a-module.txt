<div class="post-text" itemprop="text">
<p>Is it possible to mock a module in python using <code>unittest.mock</code>? I have a module named <code>config</code>, while running tests I want to mock it by another module <code>test_config</code>. how can I do that ? Thanks.</p>
<p>config.py:</p>
<pre><code>CONF_VAR1 = "VAR1"
CONF_VAR2 = "VAR2"
</code></pre>
<p>test_config.py:</p>
<pre><code>CONF_VAR1 = "test_VAR1"
CONF_VAR2 = "test_VAR2" 
</code></pre>
<p>All other modules read config variables from the <code>config</code> module. While running tests I want them to read config variables from <code>test_config</code> module instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're always accessing the variables in config.py like this:</p>
<pre><code>import config
...
config.VAR1
</code></pre>
<p>You can replace the <code>config</code> module imported by whatever module you're actually trying to test. So, if you're testing a module called <code>foo</code>, and it imports and uses <code>config</code>, you can say:</p>
<pre><code>from mock import patch
import foo
import config_test
....
with patch('foo.config', new=config_test):
   foo.whatever()
</code></pre>
<p>But this isn't actually replacing the module globally, it's only replacing it within the <code>foo</code> module's namespace. So you would need to patch it everywhere it's imported. It also wouldn't work if <code>foo</code> does this instead of <code>import config</code>:</p>
<pre><code>from config import VAR1
</code></pre>
<p>You can also mess with <code>sys.modules</code> to do this:</p>
<pre><code>import config_test
import sys
sys.modules["config"] = config_test
# import modules that uses "import config" here, and they'll actually get config_test
</code></pre>
<p>But generally it's not a good idea to mess with <code>sys.modules</code>, and I don't think this case is any different. I would favor all of the other suggestions made over it.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>foo.py:</strong></p>
<pre><code>import config

VAR1 = config.CONF_VAR1

def bar():
    return VAR1
</code></pre>
<p><strong>test.py:</strong></p>
<pre><code>import unittest
import unittest.mock as mock

import test_config


class Test(unittest.TestCase):

    def test_one(self):
        with mock.patch.dict('sys.modules', config=test_config):
            import foo
            self.assertEqual(foo.bar(), 'test_VAR1')
</code></pre>
<p>As you can see, the patch works even for code executed during <code>import foo</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your application ("app.py" say) looks like</p>
<pre><code>import config
print config.var1, config.var2
</code></pre>
<p>And gives the output:</p>
<pre><code>$ python app.py
VAR1 VAR2
</code></pre>
<p>You can use <code>mock.patch</code> to patch the individual config variables:</p>
<pre><code>from mock import patch

with patch('config.var1', 'test_VAR1'):
    import app
</code></pre>
<p>This results in:</p>
<pre><code>$ python mockimport.py
test_VAR1 VAR2
</code></pre>
<p>Though I'm not sure if this is possible at the module level.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider this following setup</p>
<p>configuration.py:</p>
<pre><code>import os

class Config(object):
    CONF_VAR1 = "VAR1"
    CONF_VAR2 = "VAR2"

class TestConfig(object):
    CONF_VAR1 = "test_VAR1"
    CONF_VAR2 = "test_VAR2"


if os.getenv("TEST"):
    config = TestConfig
else:
    config = Config
</code></pre>
<p>now everywhere else in your code you can use:</p>
<pre><code>from configuration import config
print config.CONF_VAR1, config.CONF_VAR2
</code></pre>
<p>And when you want to mock your coniguration file just set the environment variable "TEST". </p>
<p>Extra credit:
If you have lots of configuration variables that are shared between your testing and non-testing code, then you can derive TestConfig from Config and simply overwrite the variables that need changing:</p>
<pre><code>class Config(object):
    CONF_VAR1 = "VAR1"
    CONF_VAR2 = "VAR2"
    CONF_VAR3 = "VAR3"

class TestConfig(Config):
    CONF_VAR2 = "test_VAR2"
    # CONF_VAR1, CONF_VAR3 remain unchanged
</code></pre>
</div>
<span class="comment-copy">Very nice, although when I test this I can't get it to mock <code>foo.config</code> before actually importing foo (as I can with <code>config.var1</code> say). This means that any code executed when foo is imported will use the original config module. Any suggestions?</span>
<span class="comment-copy">This is exactly what I needed, thanks a lot.</span>
<span class="comment-copy">@PeterGibson Right, that's another limitation of this approach.  I'm not aware of any way around it.</span>
<span class="comment-copy">@PeterGibson I don't think there is a way to patch code executed when foo is imported without messing with <code>sys.modules</code>. I've described it in my answer. But unless this import patching is necessary, I would stick to dano's approach.</span>
<span class="comment-copy">splendid, just what I needed, thank you!</span>
<span class="comment-copy">what if your module is not called <code>config</code> but <code>config.foo</code>? Wrinting  <code>mock.patch.dict('sys.modules', config.foo=test_config)</code> would not do...</span>
<span class="comment-copy">@naxa, you can pass a dictionary to this function <code>patch.dict('sys.modules', {'config.foo': test_config})</code> (<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.dict" rel="nofollow noreferrer">docs</a>)</span>
<span class="comment-copy">How would you patch a module for <b>all</b> tests?</span>
<span class="comment-copy">@kev, if you mean all tests in a TestCase, you should create a patcher with <code>patch.dict()</code> and <code>start()</code> it in <code>setUp()</code>, then <code>stop()</code> it in <code>tearDown()</code>. If you mean all tests in a project, this sounds like a good Question on it own. I suppose you could have a custom test runner with separate config (django seems to do something like this). But first of all I would consider changing design to avoid patching altogether.</span>
