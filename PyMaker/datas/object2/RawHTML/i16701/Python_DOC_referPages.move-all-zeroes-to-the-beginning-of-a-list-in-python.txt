<div class="post-text" itemprop="text">
<p>I have a list like below:  </p>
<pre><code>a = [4, 5, 0, 0, 6, 7, 0, 1, 0, 5]
</code></pre>
<p>and I want to push all zeroes to the beginning of that list. The result must be like below.  </p>
<pre><code>a = [0, 0, 0, 0, 4, 5, 6, 7, 1, 5]
</code></pre>
<p>How to do it in Python 2?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could sort the list:</p>
<pre><code>a.sort(key=lambda v: v != 0)
</code></pre>
<p>The <code>key</code> function tells Python to sort values by wether or not they are <code>0</code>. <code>False</code> is sorted before <code>True</code>, and values are then sorted based on their original relative position.</p>
<p>For <code>0</code>, <code>False</code> is returned, sorting all those values first. For the rest <code>True</code> is returned, leaving sort to put them last but leave their relative positions untouched.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; a = [4, 5, 0, 0, 6, 7, 0, 1, 0, 5]
&gt;&gt;&gt; a.sort(key=lambda v: v != 0)
&gt;&gt;&gt; a
[0, 0, 0, 0, 4, 5, 6, 7, 1, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be done without sorting. </p>
<h2>Solutions</h2>
<p>Initialization:</p>
<pre><code>In [8]: a = [4, 5, 0, 0, 6, 7, 0, 1, 0, 5]

In [9]: from itertools import compress, repeat, chain
</code></pre>
<p><code>list.count</code> and <a href="https://docs.python.org/3/library/itertools.html#itertools.compress" rel="nofollow"><code>itertools.compress</code></a></p>
<pre><code>In [10]: x = [0] * a.count(0); x.extend(compress(a, a))

In [11]: x
Out[11]: [0, 0, 0, 0, 4, 5, 6, 7, 1, 5]
</code></pre>
<p>Same as before, but without <code>list.count</code></p>
<pre><code>In [12]: c = list(compress(a, a)); [0] * (len(a) - len(c)) + c
Out[12]: [0, 0, 0, 0, 4, 5, 6, 7, 1, 5]
</code></pre>
<p><code>list.count</code>, <a href="https://docs.python.org/3/library/itertools.html#itertools.compress" rel="nofollow"><code>itertools.compress</code></a>, <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow"><code>itertools.repeat</code></a>, <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow"><code>itertools.chain</code></a></p>
<pre><code>In [13]: list(chain(repeat(0, a.count(0)), compress(a, a)))
Out[13]: [0, 0, 0, 0, 4, 5, 6, 7, 1, 5]
</code></pre>
<p>Same as the previous one, but without <code>list.count</code></p>
<pre><code>In [14]: c = list(compress(a, a)); list(chain(repeat(0, len(a) - len(c)), c))
Out[14]: [0, 0, 0, 0, 4, 5, 6, 7, 1, 5]
</code></pre>
<h2>Benchmarks</h2>
<p>For small lists:</p>
<pre><code>In [21]: %timeit x = [0] * a.count(0); x.extend(compress(a, a))
1000000 loops, best of 3: 583 ns per loop

In [22]: %timeit c = list(compress(a, a)); [0] * (len(a) - len(c)) + c
1000000 loops, best of 3: 661 ns per loop

In [23]: %timeit list(chain(repeat(0, a.count(0)), compress(a, a)))
1000000 loops, best of 3: 762 ns per loop

In [24]: %timeit c = list(compress(a, a)); list(chain(repeat(0, len(a) - len(c)), c))
1000000 loops, best of 3: 900 ns per loop
</code></pre>
<p>For large lists:</p>
<pre><code>In [28]: a *= 10000000

In [29]: %timeit x = [0] * a.count(0); x.extend(compress(a, a))
1 loops, best of 3: 1.43 s per loop

In [30]: %timeit c = list(compress(a, a)); [0] * (len(a) - len(c)) + c
1 loops, best of 3: 1.37 s per loop

In [31]: %timeit list(chain(repeat(0, a.count(0)), compress(a, a)))
1 loops, best of 3: 1.79 s per loop

In [32]: %timeit c = list(compress(a, a)); list(chain(repeat(0, len(a) - len(c)), c))
1 loops, best of 3: 1.47 s per loop
</code></pre>
<p>As you can see, in some cases <code>itertools</code>-based solutions tend to be slower, because of the big number of function calls.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here are some better timings, with two new methods:</p>
<pre><code>SETUP="
from itertools import compress, repeat, chain
a = [4, 5, 0, 0, 6, 7, 0, 1, 0, 5]
"
</code></pre>
<p>First the sorting:</p>
<pre><code>python -m timeit -s "$SETUP" "a.sort(key=bool)"
# 1000000 loops, best of 3: 1.51 usec per loop
</code></pre>
<p>Then frostnational's methods:</p>
<pre><code>python -m timeit -s "$SETUP" "list(chain(repeat(0, a.count(0)), compress(a, a)))"
# 1000000 loops, best of 3: 1.16 usec per loop

python -m timeit -s "$SETUP" "cs = list(compress(a, a)); list(chain(repeat(0, len(a)-len(cs)), cs))"
# 1000000 loops, best of 3: 1.37 usec per loop
</code></pre>
<p>Then methods more directly working from lists:</p>
<pre><code>python -m timeit -s "$SETUP" "[0] * a.count(0) + list(filter(bool, a))"
# 1000000 loops, best of 3: 1.04 usec per loop

python -m timeit -s "$SETUP" "nonzero = list(filter(bool, a)); [0] * (len(a)-len(nonzero)) + nonzero"
# 1000000 loops, best of 3: 0.87 usec per loop
</code></pre>
<p>And again with larger sized input:</p>
<pre><code>SETUP="
from itertools import compress, repeat, chain
a = [4, 5, 0, 0, 6, 7, 0, 1, 0, 5] * 1000
"
</code></pre>
<p>Sorting:</p>
<pre><code>python -m timeit -s "$SETUP" "a.sort(key=bool)"
# 1000 loops, best of 3: 1.08 msec per loop
</code></pre>
<p>frostnational's:</p>
<pre><code>python -m timeit -s "$SETUP" "list(chain(repeat(0, a.count(0)), compress(a, a)))"
# 1000 loops, best of 3: 333 usec per loop

python -m timeit -s "$SETUP" "cs = list(compress(a, a)); list(chain(repeat(0, len(a)-len(cs)), cs))"
# 1000 loops, best of 3: 206 usec per loop
</code></pre>
<p>New:</p>
<pre><code>python -m timeit -s "$SETUP" "[0] * a.count(0) + list(filter(bool, a))"
# 1000 loops, best of 3: 295 usec per loop

python -m timeit -s "$SETUP" "nonzero = list(filter(bool, a)); [0] * (len(a)-len(nonzero)) + nonzero"
# 10000 loops, best of 3: 143 usec per loop
</code></pre>
<p>That said, despite being relatively slow, Martijn Pieters' decision to use sorting is actually pretty competitive for reasonably-sized lists and premature optimisation is the root of all evil.</p>
<hr/>
<p>FWIW, here are some timings for very long lists:</p>
<pre><code>SETUP="
from itertools import compress, repeat, chain
a = [4, 5, 0, 0, 6, 7, 0, 1, 0, 5] * 1000000
"
python -m timeit -s "$SETUP" "a.sort(key=bool)"
# 10 loops, best of 3: 1.21 sec per loop

python -m timeit -s "$SETUP" "list(chain(repeat(0, a.count(0)), compress(a, a)))"
# 10 loops, best of 3: 347 msec per loop

python -m timeit -s "$SETUP" "cs = list(compress(a, a)); list(chain(repeat(0, len(a)-len(cs)), cs))"
# 10 loops, best of 3: 226 msec per loop

python -m timeit -s "$SETUP" "[0] * a.count(0) + list(filter(bool, a))"
# 10 loops, best of 3: 310 msec per loop

python -m timeit -s "$SETUP" "nonzero = list(filter(bool, a)); [0] * (len(a)-len(nonzero)) + nonzero"
# 10 loops, best of 3: 153 msec per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Try this simple process:-</h2>
<pre><code>from collections import deque
a = [4, 5, 0, 0, 6, 7, 0, 1, 0, 5]
b = deque([x for x in a if x!=0])
for i in a:
    if i==0:
        b.appendleft(0)
print list(b)
#output -&gt; [0, 0, 0, 0, 4, 5, 6, 7, 1, 5]
</code></pre>
</div>
<span class="comment-copy">does the order matter??? if not you can just a.sort().</span>
<span class="comment-copy">Is there any guarantee that the sort is stable? The language docs don't mention it as far as I can tell.</span>
<span class="comment-copy">@viraptor: yes, the sort is guaranteed to be stable.</span>
<span class="comment-copy">@viraptor: see <a href="http://stackoverflow.com/q/1915376">Is python's sorted() function guaranteed to be stable?</a></span>
<span class="comment-copy">I like the simplicity of this approach, but for larger lists keep in mind that sorting algorithms usually have computational time complexity <b>n ln n</b>. Moving all zeros to the end of list should be possible in linear time (<b>n</b>) - see other answers.</span>
<span class="comment-copy">@Messa: note that that solution loops through the list <i>twice</i> though. Once for the <code>a.count(0)</code> call, a second for the filtered list comprehension. The cost of the list multiplication and the concatenations also need to be factored in. In <i>practice</i>, I expect the sort to win.</span>
<span class="comment-copy">What does it do when the list contains <code>None</code> or <code>False</code>? :)</span>
<span class="comment-copy"><code>None</code> and <code>False</code> are falsy, so all of them will be replaced with zeros. But the original list contains only numbers, so I don't think this a problem.</span>
<span class="comment-copy">Another option would be <code>x = [0] * a.count(0); x += compress(a, a)</code>, which happens to be faster in all cases on my machine.  That said, your benchmark isn't really fair since <code>sorted(a, ...)</code> is slower than <code>a.sort(...)</code> due to the additional copy of the list, and you would use <code>key=bool</code> instead of <code>key=lambda x: x != 0</code> if you were trying to optimise for speed.</span>
