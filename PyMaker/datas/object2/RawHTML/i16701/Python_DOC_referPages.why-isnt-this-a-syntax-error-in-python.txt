<div class="post-text" itemprop="text">
<p>Noticed a line in our codebase today which I thought surely would have failed the build with syntax error, but tests were passing so apparently it was actually valid python (in both 2.x and 3).  </p>
<p>Whitespace is sometimes not required in the conditional expression:</p>
<pre><code>&gt;&gt;&gt; 1if True else 0
1
</code></pre>
<p>It doesn't work if the LHS is a variable:</p>
<pre><code>&gt;&gt;&gt; x = 1
&gt;&gt;&gt; xif True else 0
  File "&lt;stdin&gt;", line 1
    xif True else 0
           ^
SyntaxError: invalid syntax
</code></pre>
<p>But it does seem to still work with other types of literals:</p>
<pre><code>&gt;&gt;&gt; {'hello'}if False else 'potato'
'potato'
</code></pre>
<p>What's going on here, is it intentionally part of the grammar for some reason?  Is this odd quirk a known/documented behaviour?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h3><a href="https://docs.python.org/3/reference/lexical_analysis.html#whitespace-between-tokens" rel="noreferrer">Whitespace between tokens</a></h3>
<p>Except at the beginning of a logical line or in string literals, the whitespace characters space, tab and formfeed can be used interchangeably to separate tokens. Whitespace is needed between two tokens only if their concatenation could otherwise be interpreted as a different token (e.g., ab is one token, but a b is two tokens).</p>
</blockquote>
<p>So in this case, <code>1if</code> is not a valid token, so the whitespace is optional. The <code>1</code> is interpreted as an integer literal of which the <code>if</code> is not a part. So <code>if</code> is interpreted separately and recognized as a keyword.</p>
<p>In <code>xif</code> however, an identifier is recognized, so Python is not able to see that you wanted to do <code>x if</code> there.</p>
</div>
<div class="post-text" itemprop="text">
<p>The Python lexer generates two tokens for the input <code>1if</code>: the integer <code>1</code> and the keyword <code>if</code>, since no token that begins with a digit can contain the string <code>if</code>. <code>xif</code>, on the other hand, is recognized as a valid identifier; there is no reason to believe that it is an identifier followed by a keyword, and so is passed to the parser as a single token.</p>
</div>
<div class="post-text" itemprop="text">
<p>With my limited knowledge of lexical processing and tokenizing I'd say what you're seeing is that any piece that can be lexical parsed as "different" (i.e. numbers/dictionaries, etc...) from the <code>if</code> are being done so. Most languages ignore spaces and I imagine that Python does the same (excluding, of course indentation levels). Once tokens are generated the grammar itself doesn't care, it most likely looks for an <code>[EXPRESSION] [IF] [EXPRESSION] [ELSE] [EXPRESSION]</code> grouping, which, again with your examples, would work fine.</p>
</div>
<span class="comment-copy">Python names cannot start with digits, so that's one reason. The parser knows that <code>if</code> is a new token.</span>
<span class="comment-copy">@MartijnPieters That's true, but that doesn't really explain what exactly is happening.</span>
<span class="comment-copy">@BrandonBuck: Poke found the relevant portion of the reference docs already, but that's exactly what is happening here.</span>
<span class="comment-copy">Note: If the code is harder to understand, it's also helpful to <a href="https://stackoverflow.com/a/51530110/5267751">tokenize</a>, <a href="https://stackoverflow.com/a/51525049/5267751">get the abstract syntax tree</a>, or <a href="https://stackoverflow.com/a/51521261/5267751">disassemble</a> the code.</span>
<span class="comment-copy">By that reasoning, shouldn't <code>1 if 1else 0</code> parse?  (it doesn't)</span>
<span class="comment-copy">@wim I was confused for a moment and thought it should parse as well, but <code>1e</code> is actually interpreted as the start of a literal in scientific notation; e.g. <code>1e3 == 1000</code></span>
<span class="comment-copy">Interesting!  After reading your comment, I have noticed that <code>1 if 1jelse 0</code> <i>does</i> parse.</span>
<span class="comment-copy">@wim: or <code>1 if 0b1else 0</code>. The fact that <code>1else</code> doesn't parse shows that the rule cited in this answer is not entirely consistent with the implementation, because <code>1else</code> could not otherwise be interpreted as a different token, and neither can <code>1e</code>. (<code>0x1else</code> doesn't parse either, but that's because the maximal munch rule makes it into <code>0x1e</code> <code>lse</code>, both of which are valid.)</span>
<span class="comment-copy"><a href="http://bugs.python.org/issue21642" rel="nofollow noreferrer">bugs.python.org/issue21642</a></span>
