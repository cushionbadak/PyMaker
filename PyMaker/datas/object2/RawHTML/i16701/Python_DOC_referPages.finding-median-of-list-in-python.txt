<div class="post-text" itemprop="text">
<p>How do you find the median of a list in Python? The list can be of any size and the numbers are not guaranteed to be in any particular order.</p>
<p>If the list contains an even number of elements, the function should return the average of the middle two.</p>
<p>Here are some examples (sorted for display purposes):</p>
<pre><code>median([1]) == 1
median([1, 1]) == 1
median([1, 1, 2, 4]) == 1.5
median([0, 2, 5, 6, 8, 9, 9]) == 6
median([0, 0, 0, 0, 4, 4, 6, 8]) == 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.4 has <a href="https://docs.python.org/3/library/statistics.html#statistics.median" rel="noreferrer"><code>statistics.median</code></a>:</p>
<blockquote>
<p>Return the median (middle value) of numeric data.</p>
<p>When the number of data points is odd, return the middle data point.
  When the number of data points is even, the median is interpolated by taking the average of the two middle values:</p>
<pre><code>&gt;&gt;&gt; median([1, 3, 5])
3
&gt;&gt;&gt; median([1, 3, 5, 7])
4.0
</code></pre>
</blockquote>
<p>Usage:</p>
<pre><code>import statistics

items = [6, 1, 8, 2, 3]

statistics.median(items)
#&gt;&gt;&gt; 3
</code></pre>
<p>It's pretty careful with types, too:</p>
<pre><code>statistics.median(map(float, items))
#&gt;&gt;&gt; 3.0

from decimal import Decimal
statistics.median(map(Decimal, items))
#&gt;&gt;&gt; Decimal('3')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For <a class="post-tag" href="/questions/tagged/python-2.x" rel="tag" title="show questions tagged 'python-2.x'">python-2.x</a>:</p>
<p>Use <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.median.html" rel="noreferrer"><code>numpy.median()</code></a> to make a one-line function:</p>
<pre><code>&gt;&gt;&gt; from numpy import median
&gt;&gt;&gt; median([1, -4, -1, -1, 1, -3])
-1.0
</code></pre>
<p>Or, to <a href="https://stackoverflow.com/questions/24101524/finding-median-of-list-in-python/24101655#comment37177662_24101655"><strong>write a function</strong></a>:</p>
<pre><code>def median(lst):
    n = len(lst)
    if n &lt; 1:
            return None
    if n % 2 == 1:
            return sorted(lst)[n//2]
    else:
            return sum(sorted(lst)[n//2-1:n//2+1])/2.0
</code></pre>
<hr/>
<pre><code>&gt;&gt;&gt; median([-5, -5, -3, -4, 0, -1])
-3.5
</code></pre>
<hr/>
<p>For <a class="post-tag" href="/questions/tagged/python-3.x" rel="tag" title="show questions tagged 'python-3.x'">python-3.x</a>, use <a href="https://docs.python.org/3/library/statistics.html#statistics.median" rel="noreferrer"><code>statistics.median</code></a>:</p>
<pre><code>&gt;&gt;&gt; from statistics import median
&gt;&gt;&gt; median([5, 2, 3, 8, 9, -2])
4.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The sorted() function is very helpful for this. Use the sorted function
to order the list, then simply return the middle value (or average the two middle
values if the list contains an even amount of elements).</p>
<pre><code>def median(lst):
    sortedLst = sorted(lst)
    lstLen = len(lst)
    index = (lstLen - 1) // 2

    if (lstLen % 2):
        return sortedLst[index]
    else:
        return (sortedLst[index] + sortedLst[index + 1])/2.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a cleaner solution:</p>
<pre><code>def median(lst):
    quotient, remainder = divmod(len(lst), 2)
    if remainder:
        return sorted(lst)[quotient]
    return sum(sorted(lst)[quotient - 1:quotient + 1]) / 2.
</code></pre>
<p>Note: Answer changed to incorporate suggestion in comments.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try the <a href="http://en.wikipedia.org/wiki/Quickselect" rel="noreferrer">quickselect</a> algorithm if faster average-case running times are needed. Quickselect has average (and best) case performance <code>O(n)</code>, although it can end up <code>O(n²)</code> on a bad day.</p>
<p>Here's an implementation with a randomly chosen pivot:</p>
<pre><code>import random

def select_nth(n, items):
    pivot = random.choice(items)

    lesser = [item for item in items if item &lt; pivot]
    if len(lesser) &gt; n:
        return select_nth(n, lesser)
    n -= len(lesser)

    numequal = items.count(pivot)
    if numequal &gt; n:
        return pivot
    n -= numequal

    greater = [item for item in items if item &gt; pivot]
    return select_nth(n, greater)
</code></pre>
<p>You can trivially turn this into a method to find medians:</p>
<pre><code>def median(items):
    if len(items) % 2:
        return select_nth(len(items)//2, items)

    else:
        left  = select_nth((len(items)-1) // 2, items)
        right = select_nth((len(items)+1) // 2, items)

        return (left + right) / 2
</code></pre>
<p>This is very unoptimised, but it's not likely that even an optimised version will outperform Tim Sort (CPython's built-in <code>sort</code>) because that's <em>really fast</em>. I've tried before and I lost.</p>
</div>
<div class="post-text" itemprop="text">
<p>Of course you can use build in functions, but if you would like to create your own you can do something like this. The trick here is to use ~ operator that flip positive number to negative. For instance ~2 -&gt; -3 and using negative in for list in Python will count items from the end. So if you have mid == 2 then it will take third element from beginning and third item from the end.</p>
<pre><code>def median(data):
    data.sort()
    mid = len(data) // 2
    return (data[mid] + data[~mid]) / 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>list.sort</code> to avoid creating new lists with <code>sorted</code> and sort the lists in place.</p>
<p>Also you should not use <code>list</code> as a variable name as it shadows  python's own <a href="https://docs.python.org/2/tutorial/datastructures.html#more-on-lists" rel="nofollow">list</a>.</p>
<pre><code>def median(l):
    half = len(l) // 2
    l.sort()
    if not len(l) % 2:
        return (l[half - 1] + l[half]) / 2.0
    return l[half]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def median(array):
    """Calculate median of the given list.
    """
    # TODO: use statistics.median in Python 3
    array = sorted(array)
    half, odd = divmod(len(array), 2)
    if odd:
        return array[half]
    return (array[half - 1] + array[half]) / 2.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here what I came up with during this exercise in Codecademy:</p>
<pre><code>def median(data):
    new_list = sorted(data)
    if len(new_list)%2 &gt; 0:
        return new_list[len(new_list)/2]
    elif len(new_list)%2 == 0:
        return (new_list[(len(new_list)/2)] + new_list[(len(new_list)/2)-1]) /2.0

print median([1,2,3,4,5,9])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import numpy as np
def median(x):

    if len(x)%2==0:
        x = sorted(x)
        num = round(len(x)/2)
        num2 = num-1
        middlenum = (x[num]+x[num2])/2
    else:
        x = sorted(x)
        listlength = len(x) 
        num = round(listlength / 2)
        middlenum = x[num]
    return middlenum
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>median Function</strong></p>
<pre><code>def median(midlist):
    midlist.sort()
    lens = len(midlist)
    if lens % 2 != 0: 
        midl = (lens / 2)
        res = midlist[midl]
    else:
        odd = (lens / 2) -1
        ev = (lens / 2) 
        res = float(midlist[odd] + midlist[ev]) / float(2)
    return res
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I posted my solution at <a href="https://stackoverflow.com/questions/10806303/python-implementation-of-median-of-medians-algorithm/34911527#34911527">Python implementation of "median of medians" algorithm</a> , which is a little bit faster than using sort().  My solution uses 15 numbers per column, for a speed ~5N which is faster than the speed ~10N of using 5 numbers per column.  The optimal speed is ~4N, but I could be wrong about it.</p>
<p>Per Tom's request in his comment, I added my code here, for reference.  I believe the critical part for speed is using 15 numbers per column, instead of 5.</p>
<pre><code>#!/bin/pypy
#
# TH @stackoverflow, 2016-01-20, linear time "median of medians" algorithm
#
import sys, random


items_per_column = 15


def find_i_th_smallest( A, i ):
    t = len(A)
    if(t &lt;= items_per_column):
        # if A is a small list with less than items_per_column items, then:
        #
        # 1. do sort on A
        # 2. find i-th smallest item of A
        #
        return sorted(A)[i]
    else:
        # 1. partition A into columns of k items each. k is odd, say 5.
        # 2. find the median of every column
        # 3. put all medians in a new list, say, B
        #
        B = [ find_i_th_smallest(k, (len(k) - 1)/2) for k in [A[j:(j + items_per_column)] for j in range(0,len(A),items_per_column)]]

        # 4. find M, the median of B
        #
        M = find_i_th_smallest(B, (len(B) - 1)/2)


        # 5. split A into 3 parts by M, { &lt; M }, { == M }, and { &gt; M }
        # 6. find which above set has A's i-th smallest, recursively.
        #
        P1 = [ j for j in A if j &lt; M ]
        if(i &lt; len(P1)):
            return find_i_th_smallest( P1, i)
        P3 = [ j for j in A if j &gt; M ]
        L3 = len(P3)
        if(i &lt; (t - L3)):
            return M
        return find_i_th_smallest( P3, i - (t - L3))


# How many numbers should be randomly generated for testing?
#
number_of_numbers = int(sys.argv[1])


# create a list of random positive integers
#
L = [ random.randint(0, number_of_numbers) for i in range(0, number_of_numbers) ]


# Show the original list
#
# print L


# This is for validation
#
# print sorted(L)[int((len(L) - 1)/2)]


# This is the result of the "median of medians" function.
# Its result should be the same as the above.
#
print find_i_th_smallest( L, (len(L) - 1) / 2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had some problems with lists of float values. I ended up using a code snippet from the python3 <a href="https://docs.python.org/3/library/statistics.html#statistics.median" rel="nofollow noreferrer">statistics.median</a> and is working perfect with float values without imports. <a href="https://github.com/python/cpython/blob/3.6/Lib/statistics.py" rel="nofollow noreferrer">source</a></p>
<pre><code>def calculateMedian(list):
    data = sorted(list)
    n = len(data)
    if n == 0:
        return None
    if n % 2 == 1:
        return data[n // 2]
    else:
        i = n // 2
        return (data[i - 1] + data[i]) / 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def midme(list1):

    list1.sort()
    if len(list1)%2&gt;0:
            x = list1[int((len(list1)/2))]
    else:
            x = ((list1[int((len(list1)/2))-1])+(list1[int(((len(list1)/2)))]))/2
    return x


midme([4,5,1,7,2])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I defined a median function for a list of numbers as</p>
<pre><code>def median(numbers):
    return (sorted(numbers)[int(round((len(numbers) - 1) / 2.0))] + sorted(numbers)[int(round((len(numbers) - 1) // 2.0))]) / 2.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def median(array):
    if len(array) &lt; 1:
        return(None)
    if len(array) % 2 == 0:
        median = (array[len(array)//2-1: len(array)//2+1])
        return sum(median) / len(median)
    else:
        return(array[len(array)//2])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is very simple;</p>
<pre><code>def median(alist):
    #to find median you will have to sort the list first
    sList = sorted(alist)
    first = 0
    last = len(sList)-1
    midpoint = (first + last)//2
    return midpoint
</code></pre>
<p>And you can use the return value like this <code>median = median(anyList)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here's the tedious way to find median without using the <code>median</code> function: </p>
<pre><code>def median(*arg):
    order(arg)
    numArg = len(arg)
    half = int(numArg/2)
    if numArg/2 ==half:
        print((arg[half-1]+arg[half])/2)
    else:
        print(int(arg[half]))

def order(tup):
    ordered = [tup[i] for i in range(len(tup))]
    test(ordered)
    while(test(ordered)):
        test(ordered)
    print(ordered)


def test(ordered):
    whileloop = 0 
    for i in range(len(ordered)-1):
        print(i)
        if (ordered[i]&gt;ordered[i+1]):
            print(str(ordered[i]) + ' is greater than ' + str(ordered[i+1]))
            original = ordered[i+1]
            ordered[i+1]=ordered[i]
            ordered[i]=original
            whileloop = 1 #run the loop again if you had to switch values
    return whileloop
</code></pre>
</div>
<span class="comment-copy"><a href="http://en.wikipedia.org/wiki/Selection_algorithm" rel="nofollow noreferrer">Selection Algorithm</a></span>
<span class="comment-copy">The answers here are good, so I think I want this to be roughly a canonical answer for finding medians, <a href="http://stackoverflow.com/questions/10482339/how-to-find-median">largely so I could close this</a>. Note that that question has <i>30 thousand</i> views. I'd appreciate if this question wasn't closed or obliviated in any manner so that it can stay on the search results and suck up those views instead.</span>
<span class="comment-copy">You don't mention it but the list doesn't need to be sorted before computing median. Your answer is confusing because you only use sorted lists as your examples.</span>
<span class="comment-copy">While it is not writing a function, it is still a more "pythonic" solution imho</span>
<span class="comment-copy">@dartdog Not really; it's unadvisable to coerce to a Numpy array without good reason. You've coerced types and, worse, lost support for arbitrary types.</span>
<span class="comment-copy">Points taken, useful.</span>
<span class="comment-copy">The function is much more laborious than it needs to be, though.</span>
<span class="comment-copy"><a href="https://www.python.org/dev/peps/pep-0450/" rel="nofollow noreferrer">PEP 450</a> makes a good argument against not using a library. You will eventually make a mistake.</span>
<span class="comment-copy"><code>float(sum(…) / 2)</code> should be replaced with <code>sum(…) / 2.0</code>; otherwise, if <code>sum(…)</code> is an integer, you'll get a float version of the integer quotient. For example: <code>float(sum([3, 4]) / 2)</code> is <code>3.0</code>, but <code>sum([3, 4]) / 2.0</code> is <code>3.5</code>.</span>
<span class="comment-copy">For completeness, @musiphil: only in python 2, and only if you haven't done <code>from __future__ import division</code>.</span>
<span class="comment-copy">So why even think about this if sort() is faster?</span>
<span class="comment-copy">@Max If you're using PyPy, or some type you can't <code>sort</code> easily, or willing to write a C extension for speed, etc.</span>
<span class="comment-copy">Simple utility functions probably shouldn't mutate any arguments (Especially if the function name is a noun IMO). Also using sorted over .sort() means the argument doesn't have to be a list. It could be any iterator.</span>
<span class="comment-copy">My point was about the function mutating the list. I mentioned supporting any iterable as a nice side-affect of sorted, but that's not it's main benefit. I for one would expect median(list) to work like almost all other builtins or mathematical functions. next() mutates, but I can't think of any others. Surprise mutation is a pain in the ass for debugging.</span>
<span class="comment-copy">@WillS, how is it a surprise when it is documented?  What if you are dealing with large data or you have restricted amounts of memory and you cannot make a copy of the list, what then?</span>
<span class="comment-copy">Make the function expect a sorted list and document that. <code>mylist.sort(); middle(mylist)</code>, but then it's undeniably a matter of taste. I just think mutation in general should be reserved for methods as far as is possible. The reason list.sort() returns None instead of the list itself is to make the behaviour as obvious and clear as possible. Hiding everything in documentation is like hiding stuff in small-print.</span>
<span class="comment-copy">Let us <a href="http://chat.stackoverflow.com/rooms/97277/discussion-between-will-s-and-padraic-cunningham">continue this discussion in chat</a>.</span>
<span class="comment-copy">It looks like your first line of code got left out, you can solve this by editing your post and indent the function header with 4 spaces.</span>
<span class="comment-copy">While this code may answer the question, providing additional context regarding why and/or how this code answers the question improves its long-term value.</span>
<span class="comment-copy">I'm very sorry! I just started, Stack Overflow, and I don't know how to add a summary....</span>
<span class="comment-copy">Click the "Edit" link below your post and add a summary, then save.</span>
<span class="comment-copy">Median requires you to sort your array before you find the midpoint.</span>
<span class="comment-copy">I think you should return <code>sList[midpoint]</code></span>
<span class="comment-copy"><code>sList</code> return the sorted array. Doesn't return the median</span>
<span class="comment-copy">Is this bubble sort? Why?</span>
<span class="comment-copy">why are you swapping values ?</span>
