<div class="post-text" itemprop="text">
<p>I am not a programming genius, but just in the beginning of this year, when being taught propositional logic my teacher told me (and it was quite obvious) that if P is True, not(P) or ~P was False, and the opposite if P was False.</p>
<p>Reading the Python docs about creating custom objects, I found that they claim that <code>a==b</code> being <code>True</code> does not imply that <code>a!=b</code> is <code>False</code>. This confused my mind as I thought that <code>!=</code> was the negation of <code>==</code> and therefore, whenever evaluating with <code>==</code> returned a boolean result, the expression <code>!=</code> would always evaluate to the opposite... And as far as I know, <code>not(True)</code> evaluates to <code>False</code> and <code>not(False)</code> evaluates to <code>True</code>. Can someone please help me understand how this happens? Perhaps with an example?</p>
<p>I read about this right <a href="https://docs.python.org/3/reference/datamodel.html#object.__ge__" rel="nofollow">here</a></p>
<p>quoting:</p>
<blockquote>
<p>The truth of x==y does not imply that x!=y is false.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>It's because they are operators which can be custom implemented separately, and the operators themselves (at a high level) don't dictate that if <code>x==y</code> is true then <code>x!=y</code> is false (one <strong>could</strong> implement them such that that relationship does not follow).</p>
<p>The key is the statement in the doc that follows that:</p>
<blockquote>
<p>Accordingly, when defining <code>__eq__()</code>, one should also define <code>__ne__()</code>
  so that the operators will behave as expected</p>
</blockquote>
<p>When both are implemented, then there is an explicit relationship between the operators.</p>
</div>
<div class="post-text" itemprop="text">
<p>Largely this is just because we <em>can</em> do silly stuff:</p>
<pre><code>class MessedUpShizzle:
    def __eq__(self, other):
        return True

    def __ne__(self, other):
        return True

MessedUpShizzle() == MessedUpShizzle()
#&gt;&gt;&gt; True

MessedUpShizzle() != MessedUpShizzle()
#&gt;&gt;&gt; True
</code></pre>
<p>If you're wondering what this if <em>for</em>, I'd imagine it's largely for symmetry (and thus a pretty implementation). Consider that <code>x &lt; y</code> and <code>x &gt;= y</code> are <em>not</em> inverses:</p>
<pre><code>{1} &lt; {2}
#&gt;&gt;&gt; False

{1} &gt;= {2}
#&gt;&gt;&gt; False
</code></pre>
<p>so we need both <code>__ge__</code> and <code>__le__</code> separately defined.</p>
</div>
<span class="comment-copy">So does this mean that that behaviour is not self exclusive just when we are talking about custom objects?</span>
<span class="comment-copy">No. While customization is essentially the reason there are no implied relationships, since there are no implied relationships, one should always keep the documented behavior in mind. (Behind the scenes, both <code>__eq__()</code> and <code>__ne__()</code> need to be defined to get the expected behavior.</span>
<span class="comment-copy">Ok. so would it be "correct" to have <code>__ne__()</code> defined as <code>not(self.__eq__())</code>?</span>
<span class="comment-copy">Sure. The key is that if you define it that way, you're explicitly making the relationship; it's just not made for you implicitly.</span>
<span class="comment-copy">FYI if you want python to fill in the "implied relationships", use <a href="https://docs.python.org/2/library/functools.html#functools.total_ordering" rel="nofollow noreferrer"><code>functools.total_ordering</code></a></span>
