<div class="post-text" itemprop="text">
<pre><code>class MSG_TYPE(IntEnum):
    REQUEST = 0
    GRANT = 1
    RELEASE = 2
    FAIL = 3
    INQUIRE = 4
    YIELD = 5

    def __json__(self):
        return str(self)

class MessageEncoder(JSONEncoder):
    def default(self, obj):
        return obj.__json__()

class Message(object):
    def __init__(self, msg_type, src, dest, data):
        self.msg_type = msg_type
        self.src = src
        self.dest = dest
        self.data = data

    def __json__(self):
        return dict (\
            msg_type=self.msg_type, \
            src=self.src, \
            dest=self.dest, \
            data=self.data,\
            )

    def ToJSON(self):
        return json.dumps(self, cls=MessageEncoder)

msg = Message(msg_type=MSG_TYPE.FAIL, src=0, dest=1, data="hello world")
encoded_msg = msg.ToJSON()
decoded_msg = yaml.load(encoded_msg)
print type(decoded_msg['msg_type'])
</code></pre>
<p>When calling <code>print type(decoded_msg['msg_type'])</code>, I get the result <code>&lt;type 'str'&gt;</code> instead of the original <code>MSG_TYPTE</code> type. I feel like I should also write a custom json decoder but kind of confused how to do that. Any ideas? Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>When calling print type(decoded_msg['msg_type']), I get the result  instead of the original MSG_TYPTE type.</p>
</blockquote>
<p>Well, yeah, that's because you told <code>MSG_TYPE</code> to encode itself like this:</p>
<pre><code>def __json__(self):
    return str(self)
</code></pre>
<p>So, that's obviously going to decode back to a string. If you don't want that, come up with some unique way to encode the values, instead of just encoding their string representations.</p>
<p>The most common way to do this is to encode all of your custom types (including your enum types) using some specialized form of <code>object</code>—just like you've done for <code>Message</code>. For example, you might put a <code>py-type</code> field in the <code>object</code> which encodes the type of your object, and then the meanings of the other fields all depend on the type. Ideally you'll want to abstract out the commonalities instead of hardcoding the same thing 100 times, of course.</p>
<hr/>
<blockquote>
<p>I feel like I should also write a custom json decoder but kind of confused how to do that. </p>
</blockquote>
<p>Well, have you read <a href="https://docs.python.org/3/library/json.html#encoders-and-decoders" rel="noreferrer">the documentation</a>? Where exactly are you confused? You're not going to get a complete tutorial by tacking on a followup to a StackOverflow question…</p>
<p>Assuming you've got a special <code>object</code> structure for all your types, you can use an <code>object_hook</code> to decode the values back to the originals. For example, as a quick hack:</p>
<pre><code>class MessageEncoder(JSONEncoder):
    def default(self, obj):
        return {'py-type': type(obj).__name__, 'value': obj.__json__()}

class MessageDecoder(JSONDecoder):
    def __init__(self, hook=None, *args, **kwargs):
        if hook is None: hook = self.hook
        return super().__init__(hook, *args, **kwargs)
    def hook(self, obj):
        if isinstance(obj, dict):
            pytype = obj.get('py-type')
            if pytype:
                t = globals()[pytype]
                return t.__unjson__(**obj['value'])
        return obj
</code></pre>
<p>And now, in your <code>Message</code> class:</p>
<pre><code>@classmethod
def __unjson__(cls, msg_type, src, dest, data):
    return cls(msg_type, src, dest, data)
</code></pre>
<p>And you need a <code>MSG_TYPE.__json__</code> that returns a dict, maybe just <code>{'name': str(self)}</code>, then an <code>__unjson__</code> that does something like <code>getattr(cls, name)</code>.</p>
<p>A real-life solution should probably either have the classes register themselves instead of looking them up by name, or should handle looking them up by qualified name instead of just going to <code>globals()</code>. And you may want to let things encode to something other than <code>object</code>—or, if not, to just cram <code>py-type</code> into the object instead of wrapping it in another one. And there may be other ways to make the JSON more compact and/or readable. And a little bit of error handling would be nice. And so on.</p>
<hr/>
<p>You may want to look at the implementation of <a href="https://jsonpickle.github.io/" rel="noreferrer"><code>jsonpickle</code></a>—not because you want to do the exact same thing it does, but to see how it hooks up all the pieces.</p>
</div>
<div class="post-text" itemprop="text">
<p>Overriding the default method of the encoder won't matter in this case because your object never gets passed to the method. It's treated as an int.</p>
<p>If you run the encoder on its own:</p>
<pre><code>msg_type = MSG_TYPE.RELEASE
MessageEncoder().encode(msg_type)
</code></pre>
<p>You'll get:</p>
<pre><code>'MSG_TYPE.RELEASE'
</code></pre>
<p>If you can, use an Enum and you shouldn't have any issues. I also asked a similar question:</p>
<p><a href="https://stackoverflow.com/questions/32444933/how-do-i-serialize-intenum-from-enum34-to-json-in-python">How do I serialize IntEnum from enum34 to json in python?</a></p>
</div>
<span class="comment-copy">btw, you don't need <code>\  </code> after  <code>,</code></span>
