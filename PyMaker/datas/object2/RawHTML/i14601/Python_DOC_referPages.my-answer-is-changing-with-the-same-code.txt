<div class="post-text" itemprop="text">
<p>I am a complete python beginner and I am trying to solve this problem :</p>
<blockquote>
<p>A number is called triangular if it is the sum of the first n positive
  integers for some n For example, 10 is triangular because 10 = 1+2+3+4
  and 21 is triangular because 21 = 1+2+3+4+5+6. Write a Python program
  to find the smallest 6-digit triangular number. Enter it as your
  answer below.</p>
</blockquote>
<p>I have written this program:</p>
<pre><code>n = 0
trinum = 0
while len(str(trinum)) &lt; 6:
    trinum = n*(n+1)/2
    n += 1
print(trinum)
</code></pre>
<p>And it only works in the python I have installed on my computer if I say <code>while len(str(trinum)) &lt; 8:</code> but it is supposed to be <code>while len(str(trinum)) &lt; 6:</code>. So I went to <a href="http://www.skulpt.org/" rel="noreferrer">http://www.skulpt.org/</a> and ran my code there and it gave me the right answer with <code>while len(str(trinum)) &lt; 6:</code> <em>like it's supposed to</em>. But it doesn't work with 6 with the python i have installed on my computer. Does anyone have any idea what's going on?</p>
</div>
<div class="post-text" itemprop="text">
<h3>Short Answer</h3>
<p>In Python 3, division is always floating point division. So on the first pass you get something like <code>str(trinum) == '0.5'</code>. Which isn't what you want.</p>
<p>You're looking for integer division. The operator for that is <code>//</code>. </p>
<h3>Long Answer</h3>
<p>The division operator changed in Python 2.x to 3.x. Previously, the type of the result was dependent on the arguments. So <code>1/2</code> does integer division, but <code>1./2</code> does floating point division.</p>
<p>To clean this up, a new operator was introduced: <code>//</code>. This operator will always do integer division.</p>
<p>So in Python 3.x, this expression <code>(4 * 5)/2</code> is equal to <code>10.0</code>. Note that this number is less than 100, but it has 4 characters in it.</p>
<p>If instead, we did <code>(4*5)//2</code>, we would get the integer <code>10</code> back. Which would allow your condition to hold true.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2, the <code>/</code> operator performs integer division when possible: "x divided by y is a remainder b," throwing away the "b" (use the <code>%</code> operator to find "b"). In Python 3, the <code>/</code> operator always performs float division: "x divided by y is a.fgh." Get integer division in Python 3 with the <code>//</code> operator.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have two problems here, that combine to give you the wrong answer.</p>
<p>The first problem is that you're using <code>/</code>, which means integer division in Python 2 (and the almost-Python language that Skulpt implements), but float division in Python 3. So, when you run it on your local machine with Python 3, you're going to get floating point numbers.</p>
<p>The second problem is that you're not checking for "under 6 digits" you're checking for "under 6 characters long". For positive integers, those are the same thing, but for floats, say, <code>1035.5</code> is only 4 digits, but it's 6 characters. So you exit early.</p>
<p>If you solve either problem, it will work, at least most of the time. But you really should solve both.</p>
<p>So:</p>
<pre><code>n = 0
trinum = 0
while trinum &lt; 10**6: # note comparing numbers, not string length
    trinum = n*(n+1)//2 # note // instead of /
    n += 1
print(trinum)
</code></pre>
<p>The first problem is fixed by using <code>//</code>, which always means integer division, instead of <code>/</code>, which means different things in different Python versions.</p>
<p>The second problem is fixed by comparing the number as a number to <code>10**6</code> (that is, 10 to the 6th power, which means 1 with 6 zeros, or 1000000) instead of comparing its length as a string to 6.</p>
</div>
<div class="post-text" itemprop="text">
<p>Taking <a href="https://stackoverflow.com/a/29708947/908494">Malik Brahimi's answer</a> further:</p>
<pre><code>from itertools import *
print(next(dropwhile(lambda n: n &lt;= 99999, accumulate(count(1))))
</code></pre>
<ul>
<li><a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>count(1)</code></a> is all the numbers from 1 to infinity.</li>
<li><a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>accumulate(count(1))</code></a> is all the running totals of those numbers.</li>
<li><a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" rel="nofollow noreferrer"><code>dropwhile(…)</code></a> is skipping the initial running totals until we reach 100000, then all the rest of them.</li>
<li><a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next(…)</code></a> is the next one after the ones we skipped.</li>
</ul>
<p>Of course you could argue that a 1-liner that takes 4 lines to describe to a novice isn't as good as a 4-liner that doesn't need any explanation. :)</p>
<p>(Also, the <code>dropwhile</code> is a bit ugly. Most uses of it in Python are. In a language like Haskell, where you can write that predicate with operator sectioning instead of a lambda, like <code>(&lt;= 99999)</code>, it's a different story.)</p>
</div>
<div class="post-text" itemprop="text">
<p>The division method in Py2.x and 3.x is different - so that is probably why you had issues.
Just another suggestion - which doesn't deal with divisions and lengths - so less buggy in general. Plus addition is addition anywhere. </p>
<pre><code>trinum = 0
idx =0

while trinum &lt; 99999: #largest 5 digit number
    idx += 1
    trinum += idx

print trinum
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools # to get the count function
n, c = 0, itertools.count(1) # start at zero 

while n &lt;= 99999:
    n = n + next(c)
</code></pre>
</div>
<span class="comment-copy">define <i>"it doesn't work"</i></span>
<span class="comment-copy">Incidentally, converting numbers to strings is usually a Bad Idea.  Better to do something like <code>trinum &lt; 1e6</code>.</span>
<span class="comment-copy">@Kevin: It's probably better to use <code>1000000</code> instead of introducing floats and having to convince yourself that there's no possibility of a rounding error affecting you here…</span>
<span class="comment-copy">@Kevin: Well then, <code>10**6</code>, which is still an int in Python.</span>
<span class="comment-copy">As a side note, Skulpt is not a complete or fully-compliant Python implementation. It's not even sure which Python 2.x version it's implementing. So, while it's a very cool project, using it to figure out what Python is "supposed to do" is generally not a good idea.</span>
<span class="comment-copy">I don't know if the OP will get that this is what leads to the problem without more explanation: eventually he's got, say, <code>1035.0</code>, which is not under 6 characters long, even though it's under 6 digits.</span>
<span class="comment-copy">It should be noted that to get Python 2.2 and up to do floating point division for the normal operator (consistent with 3), you can use <code>from __future__ import division</code>. This will allow the OP to get the same (and incorrect) behavior between the two different interpreters.</span>
<span class="comment-copy">Note: <code>//</code> is <b>not</b> a new operator. It's been there since <a href="https://docs.python.org/2/whatsnew/2.2.html#pep-238-changing-the-division-operator" rel="nofollow noreferrer">python <b>2.2</b></a>.  So, if you don't really really have to run a python version that was released more than 13/14 years ago just use <code>//</code> <i>any</i> time you want integer divisor and add the <code>__future__</code> import as suggested by <code>jpmc26</code>.</span>
<span class="comment-copy">Your "if necessary" comment is mostly incorrect. In Python 3, <code>x/y</code> is never going to be an <code>int</code>, even if the result is integral. <code>4/2</code> is <code>2.0</code>, not <code>2</code>. In Python 2, your phrasing is also a bit misleading, as <code>/</code> only does integer division if both numbers are <code>int</code>s. If one is a float, you'll get the same result as you do in Python 3.</span>
<span class="comment-copy">Thanks; I'll tidy that up.</span>
<span class="comment-copy">"addition is addition everywhere"—except in many languages, where it's actually addition modulo <code>INT_MAX</code> (or, in C, where it's undefined for signed numbers if it may possibly overflow). :) But yeah, I get the point.</span>
<span class="comment-copy">If you're going to go iterator-style, why not use <code>for n in count(1):</code> instead of a <code>while</code> loop with explicit incrementing?</span>
<span class="comment-copy">Is <code>itertools.count</code> just a <i>infinite</i> generator like the one I have made?</span>
<span class="comment-copy">Exactly; <code>count(i=0)</code> counts from <code>i</code> to infinity.</span>
<span class="comment-copy">Actually, everything you're doing here is a simple itertools function, not just that. See <a href="http://stackoverflow.com/a/29709367/908494">here</a>. I'm pretty sure I've crossed the horizon where more conciseness doesn't mean more clarity at some point there. :)</span>
<span class="comment-copy">So my code is good?</span>
