<div class="post-text" itemprop="text">
<p>I have come across some strange behavior when using <code>multiprocessing</code> and the <code>range()</code> generator, and I can't figure out what's going on.</p>
<p>Here is the code:</p>
<pre><code>from multiprocessing import Pool
import time

def worker_thread(param):
    time.sleep(1)
    print(param, end=' ', flush=True)

p = Pool(1)
inp = list(range(0, 100))

p.map(worker_thread, inp)
</code></pre>
<p>When this code is executed (with only 1 thread), the output is as expected:</p>
<pre><code>0 1 2 3 4 5 6 7 ...
</code></pre>
<p>However, when I raise the thread count to, let's say, 2, the output becomes unexplained:</p>
<pre><code>0 13 1 14 2 15 3 16 4 17 ...
</code></pre>
<p>And so on, and this behavior appears for higher thread counts. Since <code>list(range(0,100))</code> generates a list of numbers from 0 to 99 in ascending order, why doesn't <code>map()</code> scan the list in the order it's in?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're seeing the printed items appear in an unexpected order because <code>multiprocessing.Pool.map</code> divides the input into chunks that are worked on by each worker process. This <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map" rel="nofollow">is documented</a> (italics added to emphasise the important bits):</p>
<blockquote>
<p><code>map(func, iterable[, chunksize])</code></p>
<p>A parallel equivalent of the map() built-in function (it supports only one iterable argument though). It blocks until the result is ready.</p>
<p><em>This method chops the iterable into a number of chunks which it submits to the process pool as separate tasks.</em> The (approximate) size of these chunks can be specified by setting chunksize to a positive integer.</p>
</blockquote>
<p>In the example output you show, it looks like Python has chosen a <code>chunksize</code> of 13, since you didn't specify a size of your own. Try passing <code>1</code> as the <code>chunksize</code> and I think you'll get the output you expected (perhaps at the cost of slower performance, though).</p>
</div>
<span class="comment-copy">Correct and well-explained!</span>
