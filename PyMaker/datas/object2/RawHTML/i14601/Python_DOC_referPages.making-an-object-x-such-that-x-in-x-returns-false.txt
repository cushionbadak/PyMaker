<div class="post-text" itemprop="text">
<p>If we make a pathological potato like this:</p>
<pre><code>&gt;&gt;&gt; class Potato:
...     def __eq__(self, other):
...         return False
...     def __hash__(self):
...         return random.randint(1, 10000)
... 
&gt;&gt;&gt; p = Potato()
&gt;&gt;&gt; p == p
False
</code></pre>
<p>We can break sets and dicts this way (<em>note:</em> it's the same even if <code>__eq__</code> returns <code>True</code>, it's mucking with the hash that broke them):</p>
<pre><code>&gt;&gt;&gt; p in {p}
False
&gt;&gt;&gt; p in {p: 0}
False
</code></pre>
<p>Also <code>len({p: 0, p: 0}) == 2</code>, and <code>{p: 0}[p]</code> raises KeyError, basically all mapping related stuff goes out the window, as expected.  </p>
<p>But what I didn't expect is that we <em>can't</em> break lists</p>
<pre><code>&gt;&gt;&gt; p in [p]
True
</code></pre>
<p>Why is that?  It seems that <code>list.__contains__</code> iterates, but it's first <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool">checking identity</a> before checking equality.  Since it is not the case that identity implies equality (see for example NaN object), what is the reason for lists short-circuiting on identity comparisons?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>list</code>, <code>tuple</code>, etc., does indeed do an identity check before an equality check, and this behavior is motivated by <a href="http://bugs.python.org/issue4296#msg75735">these invariants</a>:</p>
<pre><code>assert a in [a]
assert a in (a,)
assert [a].count(a) == 1
for a in container:
    assert a in container    # this should ALWAYS be true
</code></pre>
<p>Unfortunately, <code>dict</code>s, <code>set</code>s, and friends operate by hashes, so if you mess with those you can indeed effectively break them.</p>
<p>See <a href="http://bugs.python.org/issue4296">this issue</a> and <a href="http://bugs.python.org/issue11945">this issue</a> for some history.</p>
</div>
<div class="post-text" itemprop="text">
<p>In general, breaking the assumption that identity implies equality can break a variety of things in Python.  It is true that NaN breaks this assumption, and thus NaN breaks some things in Python.  Discussion can be found in <a href="http://bugs.python.org/issue4296">this Python bug</a>. In a pre-release version of Python 3.0, reliance on this assumption was removed, but the resolution of the bug was to put it back in (i.e., make Python 3 give the same behavior as Python 2, in which the identity check shortcut is done).  The <a href="https://docs.python.org/3/reference/expressions.html#comparisons">documentation</a> for Python 3 correctly says:</p>
<blockquote>
<p>For container types such as list, tuple, set, frozenset, dict, or collections.deque, the expression <code>x in y</code> is equivalent to <code>any(x is e or x == e for e in y)</code>.</p>
</blockquote>
<p>However, it appears the documentation for Python 2 is incorrect, since it says:</p>
<blockquote>
<p>For the list and tuple types, x in y is true if and only if there exists an index i such that x == y[i] is true.</p>
</blockquote>
<p>You could raise a documentation bug about this if you want, although it is a pretty esoteric issue so I doubt it will be high on anyone's priority list.</p>
</div>
<span class="comment-copy">Maybe <code>list.__contains__</code> compares objects by <code>id()</code> instead of <code>eq()</code> ?  <code>(id(p) == id(p)) is True</code></span>
<span class="comment-copy">@jonrsharpe OP already knows about it. I think he wants to understand why List checks object identity first instead of equality, I guess.</span>
<span class="comment-copy">@HÃ¥kenLid yes, that's what it does, I think the OP is asking <i>why</i>.</span>
<span class="comment-copy">@wim per the bug comments linked by BrenBarn, <a href="http://bugs.python.org/issue4296#msg75735" rel="nofollow noreferrer"><code>for a in container: assert a in container    # this should ALWAYS be true</code></a> is a good summary of the logical reason.</span>
<span class="comment-copy">The problem is that identity <b>should</b> imply equality. The NaN object didn't do this only because the standard says Syu, but by all means it's a very bad idea to make a type that doesn't follow that implication. And if you do you should 1) know that you really cannot do otherwise and 2) be prepared to break some code.</span>
<span class="comment-copy">I don't understand what you mean by saying "this behavior is motivated by NaNs".  Why would a behavior that causes strange behavior with NaNs be motivated by NaNs?  That makes it sound like they made it that way specifically to break NaNs.</span>
<span class="comment-copy">Isn't that documentation in 3.x wrong for e.g. <code>set</code>, as the OP documents? That checks hashes, not identity.</span>
<span class="comment-copy">@jonrsharpe: That's true.  I was focusing on the anomalous behavior of the list/tuple case.  Using a randomized hash like that is even more pathological than a non-self-equal object, though.</span>
<span class="comment-copy">Now I'm confused - I was running on Code2Go for iPhone, where <code>p in {p}</code> was <code>True</code> for 2.7.9 and 3.4.2. Now I'm on a Yosemite MacBook, where <code>p in {p}</code> is <code>False</code> for 2.7.9 and 3.4.3.</span>
<span class="comment-copy">@EthanFurman I agree with that up to a point, but <i>"<code>x in y</code> is equivalent to <code>any(x is e or x == e for e in y)</code>"</i> seems pretty unambiguous - identity is checked first, so <code>p in {p}</code> should be <code>True</code> <i>however it is implemented</i> (as you can't override identity). Python is a very dynamic language, and assuming pretty much anything about the implementation of <code>x</code> is foolish, but if that's <b>not</b> actually equivalent to the underlying implementation it should at least be caveated.</span>
<span class="comment-copy">@jonrsharpe: <a href="http://bugs.python.org/issue23987" rel="nofollow noreferrer">bug created</a> -- at least the resolution will be documented.</span>
