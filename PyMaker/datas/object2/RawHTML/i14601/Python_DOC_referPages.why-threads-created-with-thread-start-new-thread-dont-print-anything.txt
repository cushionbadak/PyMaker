<div class="post-text" itemprop="text">
<p>I found this simple code at <a href="https://code.google.com/p/pyloadtools/wiki/CodeTutorialMultiThreading" rel="nofollow">https://code.google.com/p/pyloadtools/wiki/CodeTutorialMultiThreading</a></p>
<pre><code>import _thread

def hello(num):
    print('hello from thread %s\n' % num)

_thread.start_new_thread(hello, (0,))
_thread.start_new_thread(hello, (1,))
_thread.start_new_thread(hello, (2,))
</code></pre>
<p>But when I run this, it works on IDLE, but not on eclipse which uses PyDev.  Any idea how to fix it?</p>
<p><strong>Note</strong>:  I think the main program terminates before the threads run. The threads dont get enough time to run I guess. How do I fix it? May be should I use join?</p>
</div>
<div class="post-text" itemprop="text">
<p>Quoting the <code>Caveats</code> section of <a href="https://docs.python.org/3.5/library/_thread.html" rel="nofollow"><code>_thread</code></a> documentation,</p>
<blockquote>
<ul>
<li><p>When the main thread exits, it is system defined whether the other threads survive. On most systems, they are killed without executing <code>try ... finally</code> clauses or executing object destructors.</p></li>
<li><p>When the main thread exits, it does not do any of its usual cleanup (except that <code>try ... finally</code> clauses are honored), and the <strong>standard I/O files are not flushed</strong>.</p></li>
</ul>
</blockquote>
<p>There are two possibilities here.</p>
<ol>
<li><p>The main thread starts three threads but it exits before the threads finish the execution. So, the standard I/O files are not flushed, <a href="https://docs.python.org/3/library/sys.html#sys.stdin" rel="nofollow">as they are buffered, by default</a>.</p></li>
<li><p>Or, the main thread dies, and as per the first bullet point quoted, all the child threads are killed in action.</p></li>
</ol>
<p>Either way, you need to make sure the main thread doesn't die before the children complete.</p>
<p>But when you run from IDLE, the main thread still exists, so, the I/O buffers are flushed when the threads actually complete. That is why it works in IDLE but not in eclipse.</p>
<hr/>
<p>To make sure that the main thread exits only after all the threads complete, you can make it wait for the child threads with</p>
<h3>1. <a href="https://docs.python.org/2/library/threading.html#semaphore-objects" rel="nofollow"><code>Semaphore</code></a></h3>
<p>You can use <code>Semaphore</code>, like this</p>
<pre><code>import _thread
import threading


def hello(num):
    print('hello from thread %s' % num)
    # Release semaphore when the thread is actually done
    sem.release()


def create_thread(value):
    # Acquire semaphore when the thread is actually created
    sem.acquire()
    _thread.start_new_thread(hello, (value,))

# Counting semaphore. Maximum three threads can acquire.
# Next acquire call has to wait till somebody releases
sem = threading.Semaphore(3)

for i in range(3):
    create_thread(i)

# We are capturing the semaphore three times again, because 
# whenever a thread completes it releases it. So, only when we 
# acquire it thrice to make sure that all threads have completed.
for i in range(3):
    sem.acquire()
</code></pre>
<h3><a href="https://docs.python.org/3/library/_thread.html#_thread.allocate_lock" rel="nofollow">2. <code>Lock Objects</code></a></h3>
<p>Alternatively, you can use the <code>_thread.lock</code> objects, like this</p>
<pre><code>import _thread

locks = []


def hello(num, lockobject):
    print('hello from thread %s' % num)
    # Release the lock as we are done here
    lockobject.release()


def create_thread(value):
    # Create a lock and acquire it
    a_lock = _thread.allocate_lock()
    a_lock.acquire()

    # Store it in the global locks list
    locks.append(a_lock)

    # Pass it to the newly created thread which can release the lock once done
    _thread.start_new_thread(hello, (value, a_lock))

for i in range(3):
    create_thread(i)

# Acquire all the locks, which means all the threads have released the locks
all(lock.acquire() for lock in locks)
</code></pre>
<p>Now you will see that the program always prints the <code>hello from</code> message.</p>
<hr/>
<p><strong>Note:</strong> As the documentation says, <code>_thread</code> is a <code>Low-level threading API</code>. So, better use higher level module like <a href="https://docs.python.org/3/library/threading.html#module-threading" rel="nofollow"><code>threading</code></a>, where you can simply wait for the all the threads to exit with <a href="https://docs.python.org/3/library/threading.html#threading.Thread.join" rel="nofollow"><code>join</code></a> method.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/_thread.html#module-_thread" rel="nofollow">https://docs.python.org/3/library/_thread.html#module-_thread</a></p>
<blockquote>
<p>The <code>threading</code> module provides an easier to use and higher-level threading API built on top of this module.</p>
<p>The module is optional.</p>
</blockquote>
<p>So please use <a href="https://docs.python.org/3/library/threading.html" rel="nofollow"><code>threading</code></a>, not the <em>optional</em> <code>_thread</code> module.</p>
</div>
<span class="comment-copy">How does it not work? What is the error?</span>
<span class="comment-copy"><code>May be should I use join?</code> - Unfortunately, it is not available in the low-level <code>_thread</code> API. You should use <code>threading</code> module, or resort to make the main thread wait for the child threads to exit, like I have shown in my answer.</span>
