<div class="post-text" itemprop="text">
<p>I'm writing some software in python and had a question on the preferred coding style of python.
Imagine you have a function that takes some raw data, decodes it to a dict and prints the key-value pairs</p>
<pre><code>def printdata(rawdata):
    data = decode(rawdata)
    for key, value in data.items():
        print(key, value)
</code></pre>
<p>This is all fine until <code>decode</code> starts throwing exceptions everywhere and the whole program comes crashing down. So, we use a try/catch block. But there are a couple ways of doing this and I'm wondering what method is preferred.</p>
<ol>
<li><p>Everything inside <code>try</code></p>
<pre><code>def printdata(rawdata):
    try:
        data = decode(rawdata)
        for key, value in data.items():
           print(key, value)
    except ValueError:
        print("error")
</code></pre></li>
<li><p>Only <code>decode</code> inside <code>try</code> with <code>return</code></p>
<pre><code>def printdata(rawdata):
    data = None
    try:
        data = decode(rawdata)
    except ValueError:
        print("error")
        return
    for key, value in data.items():
       print(key, value)
</code></pre></li>
<li><p>Only <code>decode</code> inside <code>try</code> with <code>if</code></p>
<pre><code>def printdata(rawdata):
    data = None
    try:
        data = decode(rawdata)
    except ValueError:
        print("error")
    if data is not None:
        for key, value in data.items():
           print(key, value)
</code></pre></li>
</ol>
<p>All of these methods have some advantages and disadvantages and I don't know which one to pick, and whether it really matters.</p>
</div>
<div class="post-text" itemprop="text">
<p>The first one is clearly the <em>simplest</em>, but it has a problem: If anything else in the rest of the suite could possibly raise a <code>ValueError</code>, it's not clear whether you caught the <code>ValueError</code> you expected and wanted to handle, or an unexpected one that probably means a bug in your code so you probably should have let abort and print a traceback.</p>
<p>When you know for sure that's not an issue, go for it.</p>
<p>Although really, you should almost certainly be handling the error like this:</p>
<pre><code>except ValueError as e:
    print("error: {!r}".format(e))
</code></pre>
<p>… or something similar. That way, if you <em>do</em> get that impossible unexpected <code>ValueError</code>, you'll be able to tell from the unexpected message, instead of not knowing that you've been throwing away valid data because of a bug for the last 3 months of runs.</p>
<hr/>
<p>When that isn't appropriate, the other two ideas both <em>work</em>, but it's usually more idiomatic to use an <code>else</code> block.</p>
<pre><code>def printdata(rawdata):
    try:
        data = decode(rawdata)
    except ValueError:
        print("error")
    else:
        for key, value in data.items():
           print(key, value)
</code></pre>
<hr/>
<p>If you do need to do #2 (maybe you've got, say, a mess of <code>try</code> statements inside <code>try</code> statements or something…), you don't need the <code>data = None</code> at the top, and shouldn't have it. There <em>should</em> be no way you could have gotten past the <code>return</code> without assigning to <code>data</code>. So, if somehow the impossible has happened, you want to get an exception and see that, not silently treat it as <code>None</code>.</p>
<hr/>
<p>In #3, the <code>None</code> actually is necessary. Which is a problem. The whole idea of "predeclaring" variables before setting them, then checking whether they've been set, is not only not idiomatic, it also often disguises bugs—e.g., what if <code>None</code> is a valid return from <code>decode</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The "prefered coding style" is to <em>not</em> "handle" errors unless you can <em>really</em> handle them. This means that at the library level, you should have almost none error handling - just let errors propagate to the application level. At the application level you want</p>
<ol>
<li><p>a top-level error handler that will properly log unhandled errors <em>with the full traceback</em> (<code>logging.exception()</code> is your friend), present the user a user-friendly error message and crash.</p></li>
<li><p>where you actually can ask the user for a correction (try again, select another file, whatever), do it. </p></li>
</ol>
<p>Just printing the error message - without teh full traceback etc - is just a waste of everyone time. </p>
</div>
<span class="comment-copy">It doesn't matter too much though 1 isn't equivalent to 2 or 3. Use the one that looks good to you and that has the logic you want. Catching all ValueErrors isn't the same as only ValueErrors from decode().</span>
<span class="comment-copy">Wow, I didn't even know you could have an else clause after a try/except. This is definitely the best option. Thanks! The print("error") was just to keep the example simple, no worries there.</span>
<span class="comment-copy">@Dokahl: When you're trying to learn more about some language feature, always <a href="https://docs.python.org/3/reference/compound_stmts.html#the-try-statement" rel="nofollow noreferrer">check the docs</a> first. :)</span>
<span class="comment-copy">@abarnert: I just can't believe <i>you</i> advise to just print the error and call it a day instead of letting it propagate to somewhere it can be handled. Stupidiest "error handling" scheme ever :(</span>
<span class="comment-copy">@brunodesthuilliers: I don't think you understood the advice. Look at the very first sentence. That's the key. So, <i>if</i> the design goal is to log and ignore a possible specific <code>ValueError</code> from <code>decode</code>, <i>then</i> the most important consideration is not the style, but making sure that you are logging and ignoring <i>only that specific error</i>. Make doubly sure by thinking through the structure, then make triply sure by logging enough information to catch you if you didn't think of something.</span>
<span class="comment-copy">I don't think this is relevant here. Presumably he has a reason to want to log and ignore these decode errors. For example, maybe 3% of the data are garbled, and he wants to get on with processing the 97% that aren't. In that case, it makes perfect sense to write a one-line log message and move on.</span>
<span class="comment-copy">More generally, this advice seems geared to a very different language than Python. In Python, exceptions get thrown all over the place. Every <code>for</code> loop ends with an exception. So "Always log all the information about every exception" is not appropriate for Python. "Always log all the information about every <i>unexpected</i> exception" is still definitely true—but the easiest way to do that, as long as it's appropriate for your app, is just to not catch unexpected exceptions and let them abort and print a traceback.</span>
