<div class="post-text" itemprop="text">
<p>I am a fan of the outmoded game Age of Empires II(AoE). I want to write a parser of AoE game record(.mgx files) using Python.</p>
<p>I did some searching on GitHub and found little projects on this, the most useful one is <a href="https://github.com/stefan-kolb/aoc-mgx-format" rel="noreferrer"><strong>aoc-mgx-format</strong></a> which provide <a href="https://github.com/stefan-kolb/aoc-mgx-format/blob/master/references/mgx_format_total.html" rel="noreferrer">some details of <strong>.mgx</strong> game record files</a>.</p>
<p>Here is the problem:</p>
<p>according to the reference, structure of a <strong>.mgx</strong> file is like:</p>
<blockquote>
<p>| header_len(4byte int) | next_pos(4byte int) | header_data | ... ... |</p>
</blockquote>
<p>The hex data's byte order in mgx format is <strong>little endian</strong>.</p>
<p><strong>header_len</strong> stores data length of the Header part(header_len + next_post + header_data) </p>
<p><strong>header_data</strong> stores useful imformation i need, but its compressed with <strong>zlib</strong></p>
<p>i tried to decompress data in header_data with zlib module like this:</p>
<pre><code>import struct
import zlib

with open('test.mgx', "rb") as fp:
    # read the header_len bytes and covert it to a int reprents length of Header part
    header_len = struct.unpack("&lt;i", fp.read(4))[0]

    # read next_pos (this is not important for me)
    next_pos = struct.unpack("&lt;i", fp.read(4))[0]

    # then I can get data length of header_data part(compressed with zlib)
    header_data_len = header_len - 8

    compressed_data = fp.read(header_data_len)[::-1] # need to be reversed because byte order is little endian?

    try:
        zlib.decompress(compressed_data)
        print "can be decompressed!"
    except zlib.error as e:
        print e.message
</code></pre>
<p>but i got this after running the program:</p>
<blockquote>
<p>Error -3 while decompressing data: incorrect header check</p>
</blockquote>
<p>ps: sample .mgx files can be found here: <a href="https://github.com/stefan-kolb/aoc-mgx-format/tree/master/parser/recs" rel="noreferrer">https://github.com/stefan-kolb/aoc-mgx-format/tree/master/parser/recs</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Your first problem is that you shouldn't be reversing the data; just get rid of the <code>[::-1]</code>.</p>
<p>But if you do that, instead of getting that error -3, you get a different error -3, usually about an unknown compression method.</p>
<p>The problem is that this is <em>headerless</em> zlib data, much like what gzip uses. In theory, this means the information about the compression method, window, start dict, etc. has to be supplied somewhere else in the file (in gzip's case, by information in the gzip header). But in practice, everyone uses deflate with the max window size and no start dict, so if I were designing a compact format for a game back in the days when every byte counted, I'd just hardcode them. (In modern times, exactly that has been standardized in an RFC as "DEFLATE Compressed Data Format", but most 90s PC games weren't following RFCs by design...)</p>
<p>So:</p>
<pre><code>&gt;&gt;&gt; uncompressed_data = zlib.decompress(compressed_data, -zlib.MAX_WBITS)
&gt;&gt;&gt; uncompressed_data[:8] # version
b'VER 9.8\x00'
&gt;&gt;&gt; uncompressed_data[8:12] # unknown_const
b'\xf6(&lt;A'
</code></pre>
<p>So, it not only decompressed, that looks like a version and… well, I guess anything looks like an unknown constant, but it's the same unknown constant in the spec, so I think we're good.</p>
<p>As the <a href="https://docs.python.org/3/library/zlib.html#zlib.decompress" rel="nofollow noreferrer"><code>decompress</code></a> docs explain, <code>MAX_WBITS</code> is the default/most common window size (and the only size used by what's usually called "zlib deflate" as opposed to "zlib"), and passing a negative value means that the header is suppressed; the other arguments we can leave to defaults.</p>
<p>See also <a href="https://stackoverflow.com/a/22311297/4799491">this answer</a>, the <a href="http://www.zlib.net/manual.html#Advanced" rel="nofollow noreferrer">Advanced Functions</a> section in the <code>zlib</code> docs, and <a href="http://www.ietf.org/rfc/rfc1951.txt" rel="nofollow noreferrer">RFC 1951</a>. (Thanks to the OP for finding the links.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Old but here is a sample of what I did :</p>
<pre><code>class GameRecordParser:

def __init__(self, filename):
    self.filename = filename
    f = open(filename, 'rb')

    # Get header size
    header_size = struct.unpack('&lt;I', f.read(4))[0]
    sub = struct.unpack('&lt;I', f.read(4))[0]
    if sub != 0 and sub &lt; os.stat(filename).st_size:
        f.seek(4)
        self.header_start = 4
    else:
        self.header_start = 8

    # Get and decompress header
    header = f.read(header_size - self.header_start)
    self.header_data = zlib.decompress(header, -zlib.MAX_WBITS)

    # Get body
    self.body = f.read()
    f.close()

    # Get players data
    sep = b'\x04\x00\x00\x00Gaia'
    pos = self.header_data.find(sep) + len(sep)
    players = []
    for k in range(0, 8):
        id = struct.unpack('&lt;I', self.header_data[pos:pos+4])[0]
        pos += 4
        type = struct.unpack('&lt;I', self.header_data[pos:pos+4])[0]
        pos += 4
        name_size = struct.unpack('&lt;I', self.header_data[pos:pos+4])[0]
        pos += 4
        name = self.header_data[pos:pos+name_size].decode('utf-8')
        pos += name_size
        if id &lt; 9:
            players.append(Player(id, type, name))
</code></pre>
<p>Hope it helps future programmer :)</p>
<p>By the wway I am planning on writting such a library.</p>
</div>
<span class="comment-copy">Data don't need to be reversed because the byte-order is little-endian. You already converted them from little-endian to native by using <code>"&lt;i"</code> instead of just <code>"i"</code> in your <code>unpack</code> calls. (And besides, I'll bet your computer is natively little-endian anyway.)</span>
<span class="comment-copy">There is a typo in your question, where you say "outmoded game Age of Empires", I think you mean "wonderfully awesome game Age of Empires".</span>
<span class="comment-copy">@abarnert you are great!!! i googled with  "zlib without a zlib" and found some useful! <code>zlib.decompress(compressed_data, -zlib.MAX_WBITS)</code> will work</span>
<span class="comment-copy">@abarnert certainly i will use decompressor object in real project, its just test code above. thanks again, i guess you have played this game, too XDDD</span>
<span class="comment-copy">I think that last comment was for @LegoStormtroopr, not me. :) I have played it, but not for a long time. I like Europa Universalis and Crusader Kings for my strategy fix, so my questions are about writing an iterative parser for human-readable-text-but-300MB files. :)</span>
<span class="comment-copy">thx a lot, i found this with some keywords you provided, also useful <a href="http://stackoverflow.com/a/22311297/4799491">http://stackoverflow.com/a/22311297/4799491</a></span>
<span class="comment-copy">@lichifeng: I added the links to the answer. Nice find.</span>
<span class="comment-copy">Did you write that library?</span>
<span class="comment-copy">@Bastiano it is still in progress but I have not much more time these days (<a href="https://github.com/voblivion/AoE2RecordsParser" rel="nofollow noreferrer">github.com/voblivion/AoE2RecordsParser</a>). Feel free to contribute ;) I'll check any pull request/suggestion.</span>
