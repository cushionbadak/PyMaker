<div class="post-text" itemprop="text">
<p>I was doing some work with python iterable parameters.</p>
<p>I was making a function something like this :</p>
<pre><code>def once_in_a_row(iterable):
  pass
</code></pre>
<p>This function should take any iterable: It should produce every value in the iterable, but does not produce the same value twice in a row: if the current value is the same as the last one yielded, it skips yielding the current value. </p>
<p><strong>Example</strong> : </p>
<pre><code>for i in once_in_a_row('abbcccaadd'):
  print(i,end=' ')
</code></pre>
<p>It produces the values 'a', 'b', 'c', 'a', and 'd'.</p>
<p>What can be best simple way to do it ? I am having a hide(iterable) definition too.</p>
<pre><code>def hide(iterable):
  for v in iterable:
    yield v
</code></pre>
<p>This function is called to ensure that code works on general iterable parameters (not just a string, tuple, list, etc.). For example, although we can call <code>len(string)</code> we cannot call <code>len(hide(string))</code>, so the function once_in_a_row should not call <code>len</code> on their parameters</p>
</div>
<div class="post-text" itemprop="text">
<p>Something like this:</p>
<pre><code>def once_in_a_row(iterable):
     last_item = object()
     for item in iterable:
         if item != last_item:
             last_item = item
             yield item
</code></pre>
<p>Or if you want it to take a variable number of arguments:</p>
<pre><code>def once_in_a_row(*args):
     last_item = object()
     for iterable in args:
         for item in iterable:
             if item != last_item:
                 last_item = item
                 yield item
</code></pre>
<p>See <a href="https://wiki.python.org/moin/Generators" rel="nofollow noreferrer">https://wiki.python.org/moin/Generators</a> or <a href="https://stackoverflow.com/questions/1756096/understanding-generators-in-python">Understanding Generators in Python</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If by "simplest" you mean "most novice-friendly" or "least abstract", just keep track of the last value and skip it:</p>
<pre><code>def once_in_row(iterable):
    last_value = object() # won't match anything
    for value in iterable:
        if value != last_value:
            yield value
        last_value = value
</code></pre>
<hr/>
<p>But if by "simplest" you mean "fewest things to keep track of", there's an even simpler way: use <code>groupby</code> to group the values into runs, then just print one value for each run. In fact, this is useful enough that it's included in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertools</code> recipes</a> as <code>unique_justseen</code>:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

def unique_justseen(iterable, key=None):
    "List unique elements, preserving order. Remember only the element just seen."
    # unique_justseen('AAAABBBCCDAABBB') --&gt; A B C D A B
    # unique_justseen('ABBCcAD', str.lower) --&gt; A B C A D
    return map(next, map(itemgetter(1), groupby(iterable, key)))
</code></pre>
<p>Personally, I would have written this with a generator expression rather than two <code>map</code> calls:</p>
<pre><code>    return (next(group) for key, group in groupby(iterable, key))
</code></pre>
<p>… but the <code>itertools</code> docs are somewhat geared toward people who are thinking in Haskell or ML terms…</p>
<hr/>
<p>Also, let me add a quick plus for Erik Rose's <a href="https://pypi.python.org/pypi/more-itertools" rel="nofollow"><code>more-itertools</code></a>, which gives you all of the recipes from the <code>itertools</code> docs as code you can just import and run (after you <code>pip install more-itertools</code>, of course):</p>
<pre><code>from more_itertools import unique_justseen as once_in_row
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow"><code>itertools.groupby</code></a></p>
<pre><code>from itertools import groupby
def once_in_a_row(iterable):
    for k, g in groupby(iterable):
        yield k

&gt;&gt;&gt;generator = once_in_a_row("abbcccaadd")
&gt;&gt;&gt;list(generator)
['a', 'b', 'c', 'a', 'd']
</code></pre>
</div>
<span class="comment-copy">This sounds like homework. You should show us what you have tried so far. And I don't understand what the <code>hide</code> function is for.</span>
<span class="comment-copy">@DanielRoseman: I believe <code>hide</code> came from his teacher, and it's there to prevent his <code>once_in_row</code> function from finding out anything about the iterable other than that it's an iterable (in particular, to explicitly break code that relies on the input data being sequences). At least I think that's what the last paragraph is trying to say. Of course you could just write that as <code>hide = iter</code>, which does the same thing but more efficiently and more obviously. :)</span>
<span class="comment-copy">This won't work correctly if the first variable in your iterator is None... Using <code>object()</code> for <code>last_value</code> as in @abarnet's answer avoids this</span>
<span class="comment-copy">Good point Claude, I fixed it :)</span>
<span class="comment-copy"><code>Object</code> --&gt; <code>object</code>. It's one of those nice python inconsitencies :(</span>
<span class="comment-copy">@Claude: Yep, "all classes must have capitalized names… except a handful that were in the language before 2.2 when types and classes weren't the same thing".</span>
<span class="comment-copy">@user3185653: You've still got indentation errors. And they're still your fault, not JosiahDaniels' fault. Also, at this point it's becoming clear that you're not actually trying to understand the answers, you just want someone to hand you something that works so you can turn it in as your own work.</span>
<span class="comment-copy">I dont want to modify hide function. I need to modify once_in_row function</span>
<span class="comment-copy">@user3185653: OK, so take the same code and call it <code>once_in_row</code> instead of <code>hide</code>.</span>
<span class="comment-copy">Why build a list instead of a lazy generator?</span>
<span class="comment-copy">Or shorter: <code>for k, g in groupby(iterable): yield k</code></span>
<span class="comment-copy">@tobias_k updated :). Feel free to edit my answer.</span>
