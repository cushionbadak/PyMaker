<div class="post-text" itemprop="text">
<p>I am reading the <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow">Multiprocessing</a> topic for Python 3 and trying to incorporate the method into my script, however I receive the following error:</p>
<blockquote>
<p>AttributeError: __ exit __</p>
</blockquote>
<p>I use Windows 7 with an i-7 8-core processor, I have a large shapefile which I want processed (with the mapping software, QGIS) using all 8 cores preferably. Below is the code I have, I would greatly appreciate any help with this matter:</p>
<pre><code>from multiprocessing import Process, Pool

def f():
    general.runalg("qgis:dissolve", Input, False, 'LAYER_ID', Output)

if __name__ == '__main__':
    with Pool(processes=8) as pool:
        result = pool.apply_async(f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The context manager feature of <code>multiprocessing.Pool</code> was only added into Python 3.3:</p>
<blockquote>
<p>New in version 3.3: Pool objects now support the context
  management protocol â€“ see Context Manager Types. <code>__enter__()</code> returns
  the pool object, and <code>__exit__()</code> calls <code>terminate()</code>.</p>
</blockquote>
<p>The fact that <code>__exit__</code> is not defined suggests you're using 3.2 or earlier. You'll need to manually call <code>terminate</code> on the <code>Pool</code> to get equivalent behavior:</p>
<pre><code>if __name__ == '__main__':
    pool = Pool(processes=8)
    try:
        result = pool.apply_async(f)
    finally:
        pool.terminate()
</code></pre>
<p>That said, you probably don't want to use <code>terminate</code> (or the <code>with</code> statement, by extension) here. The <code>__exit__</code> method of the <code>Pool</code> calls <code>terminate</code>, which will forcibly exit your workers, even if they're not done with their work. You probably want to actually wait for the worker to finish before you exit, which means you should call <code>close()</code> instead, and then use <code>join</code> to wait for all the workers to finish before exiting:</p>
<pre><code>if __name__ == '__main__':
    pool = Pool(processes=8)
    result = pool.apply_async(f)
    pool.close()
    pool.join()
</code></pre>
</div>
<span class="comment-copy">First thing I would do is replace the content of f() with, for example print to narrow down the issue. If that passes then there is something wrong with your general.runalg</span>
<span class="comment-copy">@TymoteuszPaul - Thank you, I will try this. The <code>general.runal</code> works fine on its own so my guess is something to do with the <code>Pool</code> method.</span>
<span class="comment-copy">Also you've mentioned that you are writing this for python3, and yet you are using print in 2.7 fashion which will throw an error. And may be the cause of all things ;)</span>
<span class="comment-copy">@TymoteuszPaul - I wish :). Removed <code>print</code> but still get an error so will continue your first suggestion.</span>
<span class="comment-copy">Is <code>dissolve</code> defined somewhere before passing it to apply_async?</span>
<span class="comment-copy">Brilliant, many thanks for this! I can see the 8 separate processes ocurring in the Task Manager. The function doesn't run correctly but I think that's in my end so will play around with the script. Thanks again!</span>
