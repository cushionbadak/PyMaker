<div class="post-text" itemprop="text">
<p>so far i'm trying to create a frequency analysis program.
so far I have:</p>
<pre><code>`frequency_analysis = { "a" : 0,  "b" : 0,  "c" : 0,  "d" : 0,  "e" : 0,                      "f" : 0,  "g" : 0,
    "h" : 0,  "i" : 0,  "j" : 0,  "k" : 0,  "l" : 0,  "m" : 0,  "n" : 0,  "o" :   0,
    "p" : 0,  "q" : 0,  "r" : 0,  "s" : 0,  "t" : 0,  "u" : 0,  "v" : 0,  "w" : 0,
    "x" : 0,  "y" : 0,  "z" : 0 }

        listing = []

        letters = 'eatniroshlcdguwpbfynkvxzjq'
        alphabet = 'abcdefghijklmnopqrstuvwxyz'

        text = input("Please Enter text to decipher").lower()

        for letter in text:

            if letter.isalpha():
              frequency_analysis[letter] += 1

        def get_num (frequency_analysis):
            return frequency_analysis[1]


        unsorted_items = frequency_analysis.items()
        sorted_items = sorted(unsorted_items, key = get_num)

        descending = reversed(sorted_items)
        descending = list(descending)

        inorder = list()
        for char in descending:
            inorder.append(char)


        for key in inorder:

            if key[1] &gt; 0:

                print (key)
</code></pre>
<p>We now need to swap the key with the most frequent letters.<br/>
EG. input: Hello<br/>
find frequency: L,L,O,H,E<br/>
swap with most frequency letters from top of code(letters).  </p>
<pre><code>L = E
o = A
H = T
E = n
</code></pre>
<p>then put back in order of hello.</p>
<pre><code>outcome = TNEEA
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>what @tommy was suggesting does help, but you have to read through a bit of text.</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; c = Counter("Hello")
&gt;&gt;&gt; c.most_common()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a bit of code I have that performs frequency analysis alright. I notice that this is basically an implementation of what paddyg suggested:</p>
<pre><code>import collections

ALPHABET = "abcdefghijklmnopqrstuvwxyz"
ETAOIN = 'etaoinshrdlcumwfgypbvkjxqz'

def generate_caesar_key(offset):
    dictionary = {}
    index = 0
    for letter in ALPHABET:
        if index+offset &gt;= 26:
            index -= 26
        dictionary.update({letter:ALPHABET[index+offset]})
        index += 1
    return dictionary

def switch_encode(string, key):
    encoded = ""
    for letter in string.lower():
        if letter in key.keys():
            encoded += key[letter]
        else:
            encoded += letter
    return encoded

def switch_decode(string, key):
    key = dict(zip(key.values(),key.keys()))
    decoded = ""
    for letter in string.lower():
        if letter in key.keys():
            decoded += key[letter]
        else:
            decoded += letter
    return decoded

def switch_crack(string):
    key = {}
    frequent_letters = collections.Counter(string).most_common()
    index = 0
    for letter in frequent_letters:
        if letter[0] in ALPHABET:
            key[ETAOIN[index]] = letter[0]
            index += 1
    return key
</code></pre>
<p>I also included some other functions to generate a caesar cipher key and encode and decode things with a key, so that the switch_crack function that performs frequency analysis can be put to use immediately.</p>
<h2>However</h2>
<p>This does letter frequency analysis. While one can certainly rank the frequency of letters in the English language, this is far from infallible. This method would require a huge sample to reliably guess the key of a switch cipher. For example, I pasted the entire wikipedia entry on elephants into this. It correctly guessed some of the letters, like which letter was e, however, it had a number of letters switched or misplaced.</p>
<p>What I am saying is, this basic algorithm can be made much, much better if one includes ways to pay attention to the words. It could, for example, conceivably know which combinations <em>are</em> words, and switch around its letter guesses if it recognizes that gibberish is coming out. Or it could look at a three letter word it is pretty sure ends with e and guess that it is "the" and update it's key accordingly. The functions I have above are a clean implementation of basic frequency analysis with letters, but there is a lot more to good frequency analysis then just looking at letters.</p>
</div>
<span class="comment-copy">Python comes with batteries included: <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">docs.python.org/3/library/collections.html#collections.Counter</a></span>
<span class="comment-copy">thanks for the reply, but it still doesn't help. Am I needing to count over the  collection?</span>
<span class="comment-copy">this part will cause error: <code>def get_num (frequency_analysis): return frequency_analysis[1]</code>. <code>frequency_analysis</code> has no such key.</span>
<span class="comment-copy">When you have more letters with the same frequency, what do yo want to do? in your example 'O' 'H' and 'E' have all a count of 1 and there is no apparent order in associating these letters to the 2nd to 4th most common letters, 'A' 'T' 'N'</span>
<span class="comment-copy">I am just using "hello" as an example. so basically each characters needs swapping with the most frequent letters. then putting back into the order of  hello. It doesnt matter which order the the (1) frequent letters are associated in the frequent letters</span>
