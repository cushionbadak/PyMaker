<div class="post-text" itemprop="text">
<p>I have Flask application that exposed API that can run application in background and can kill it later by specifying the PID. However, for unit testing purpose, after killing the PID and checking if the PID is killed using <code>psutil.pid_exists(pid)</code> it seems to always returning true. I have checked manually that PID does not exist and run <code>psutil.pid_exists(pid)</code> on different python console and it returned true. This is causing my test to fail.</p>
<p>In <code>views.py</code>, I have:</p>
<pre><code>@api.route('/cancel/&lt;pid&gt;', methods=['POST'])
def cancel(pid=None):
    try:
        os.kill(int(pid), signal.SIGTERM)

        data = dict(
            message = 'Successfully killed pid ' + pid)

        return jsonify(status='success', data=data), 200
    except:
        data = dict(
            message = 'Fail to kill job with pid ' + pid)
        return jsonify(status='error', data=data), 400
</code></pre>
<p>And in my test:</p>
<pre><code>def test_cancel_job(self):
    # run_script will run something in the background and return the PID
    jobid, pid, cmd = run_script('fake_db', 'fake_cancel_jobid', 'tests/doubles/child.py')

    if not psutil.pid_exists(pid):
        raise Exception('Process is not running')

    # kill the job and assert it is successful
    resp = self.client.post('/api/cancel/' + str(pid))
    self.assert200(resp)

    # at this point, I have confirmed that the PID has been killed
    # but, the line below still get executed
    # psutil.pid_exists(pid) returns true

    # check pid is really killed
    if psutil.pid_exists(pid):
        raise Exception('Process {0} still exist'.format(pid))
</code></pre>
<p>I'm running on OSX if that make any difference.</p>
<p>Update:
I've tried running on the test on my build server (Ubuntu 14.04) and the test failed.</p>
<p>This is my <code>run_script</code></p>
<pre><code>def run_script(db, jobid, script):
    log = SCRIPTS_LOG + jobid + ".log"

    if not os.path.exists(SCRIPTS_LOG):
        os.makedirs(SCRIPTS_LOG)

    with open(log, "w") as output:
        cmd = ["nohup", "python", script, db]
        p = subprocess.Popen(cmd, stdout=output)

        return jobid, p.pid, " ".join(cmd)
</code></pre>
<p>and my <code>child.py</code></p>
<pre><code>#!/usr/bin/env python

import time
import os, sys
if 'TEST_ENV' not in os.environ:
    os.environ['TEST_ENV'] = 'Set some env'

    try:
        os.execv(sys.argv[0], sys.argv)
    except Exception, exc:
        print "Failed re-exec:", exc
        sys.exit(1)


def main(argv):
    db = argv[0]

    while True:
        print 'Running child with params ', db
        time.sleep(1)


if __name__ == '__main__':
    main(sys.argv[1:])
</code></pre>
<p>I added a simple scripts that demonstrate this. <a href="https://github.com/shulhi/kill-pid/tree/master" rel="nofollow">https://github.com/shulhi/kill-pid/tree/master</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It takes time to terminate a running process. In this case it's a child process, so <a href="https://docs.python.org/3/library/os.html#os.wait" rel="nofollow noreferrer"><code>os.wait()</code></a> or one of its variants will know exactly how long to wait. To future-proof, i'd use <a href="https://docs.python.org/3/library/os.html#os.waitpid" rel="nofollow noreferrer"><code>os.waitpid(pid, os.WEXITED)</code></a>.</p>
</div>
<span class="comment-copy">try using <code>signal.CTRL_C_EVENT</code> ?</span>
<span class="comment-copy">Are you running your Flask app as root? also what's the version of <code>psutil</code>?</span>
<span class="comment-copy">Can you check <code>pid</code> existence by sending <a href="http://stackoverflow.com/questions/13595076/why-does-os-killpid-0-return-none-although-process-has-terminated"><code>os.kill(pid, 0)</code></a> on OS X?</span>
<span class="comment-copy">@number5 I'm using version 2.2.1. I tried running the test both with and without sudo. Both are giving me the same result.</span>
<span class="comment-copy">I solved this. Apparently I need <code>os.wait()</code> right after I kill the process so the process can be reaped. If not, it will become zombie process and stop being zombie after the parent is killed.</span>
