<div class="post-text" itemprop="text">
<p>I want to use Python multiprocessing to run grid search for a predictive model.
When I look at core usage, it always seem to be using only one core. Any idea what I'm doing wrong?</p>
<pre><code>import multiprocessing
from sklearn import svm
import itertools

#first read some data
#X will be my feature Numpy 2D array
#y will be my 1D Numpy array of labels

#define the grid        
C = [0.1, 1]
gamma = [0.0]
params = [C, gamma]
grid = list(itertools.product(*params))
GRID_hx = []

def worker(par, grid_list):
    #define a sklearn model
    clf = svm.SVC(C=g[0], gamma=g[1],probability=True,random_state=SEED)
    #run a cross validation function: returns error
    ll = my_cross_validation_function(X, y, model=clf, n=1, test_size=0.2)
    print(par, ll)
    grid_list.append((par, ll))


if __name__ == '__main__':
   manager = multiprocessing.Manager()
   GRID_hx = manager.list()
   jobs = []
   for g in grid:
      p = multiprocessing.Process(target=worker, args=(g,GRID_hx))
      jobs.append(p)
      p.start()
      p.join()

   print("\n-------------------")
   print("SORTED LIST")
   print("-------------------")
   L = sorted(GRID_hx, key=itemgetter(1))
   for l in L[:5]:
      print l
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that you <em>join</em> each job immediately after you started it:</p>
<pre><code>for g in grid:
    p = multiprocessing.Process(target=worker, args=(g,GRID_hx))
    jobs.append(p)
    p.start()
    p.join()
</code></pre>
<p><em>join</em> blocks until the respective process has finished working. This means that your code starts <strong>only one process at once, waits until it is finished and then starts the next one</strong>.</p>
<p>In order for all processes to run in parallel, you need to <strong>first start them all</strong> and then <strong>join them all</strong>:</p>
<pre><code>jobs = []
for g in grid:
    p = multiprocessing.Process(target=worker, args=(g,GRID_hx))
    jobs.append(p)
    p.start()

for j in jobs:
    j.join()
</code></pre>
<p>Documentation: <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.Process.join" rel="noreferrer">link</a></p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.Process.join">the documentation</a> the join() command locks the current thread until the specified thread returns. So you are basically starting each thread in the for loop and then wait for it to finish, BEFORE you proceed to the next iteration.</p>
<p>I would suggest moving the joins outside the loop!</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd say :</p>
<pre><code>for g in grid:
    g.p = multiprocessing.Process(target=worker, args=(g,GRID_hx))
    jobs.append(g.p)
    g.p.start()
for g in grid:
    g.p.join()
</code></pre>
<p>Currently you're spawning a job, then waithing for it to be done, then going to the next one.</p>
</div>
<span class="comment-copy">Once you fix that join, you may also want to read up on the Global Interpreter Lock (GIL).  Python cannot be executing python code on two threads at the same time.  However, in the case of C libraries for python like numpy, those libraries can <i>elect</i> to give up the GIL while doing very computationally intensive tasks.  If you want to use multiple cores effectively, make sure most of your work is done in one of those C libraries which drops the GIL while doing work.</span>
<span class="comment-copy">Note: you probably want to use a <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool" rel="nofollow noreferrer"><code>Pool</code></a> instead of manually creating and joining every single process. Just do <code>pool.map(worker, args=zip(grid, [GRID_hx]*len(grid))])</code> and this will automatically launch the different processes (in parallel) and join them.</span>
<span class="comment-copy">@CortAmmon What you are writing is completely irrelevant. He is using multi <b>processing</b> not multi <i>threading</i>, so the GIL doesn't plain <i>any</i> role in that code.  Also: the fact that he's using <code>multiprocessing</code> instead of <code>threading</code> probably means he already know of the GIL.</span>
<span class="comment-copy">@Bakuriu you are absolutely right.  I'm sorry I missed that!</span>
<span class="comment-copy">The <code>p.start()</code> line will raise a <code>NameError</code> as <code>p</code> doesn't exist.</span>
