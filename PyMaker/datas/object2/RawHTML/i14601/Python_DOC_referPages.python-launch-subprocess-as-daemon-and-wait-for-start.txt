<div class="post-text" itemprop="text">
<p>I have some python code that relies on an external server to be running. On launch, the server outputs a string to STDOUT indicating that it is ready to receive requests. What I am hoping to do is, from my python code, launch the server, wait for the output string, run the rest of my python code, then shut down the server. So far however, all I have been able to figure out how to do is either a) launch the server and continue immediately (creating a race condition that typically fails), or b) launch the server and wait for it to complete (which never happens since it is a server)</p>
<p>Is there any way to launch the process, and then block until output is received (but not until the process finishes, as communicate does)? I can, of course, simply put in a time delay, but this is obviously kludgy at best.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is nothing complicated here. To "launch the process, and then block until output is received", you just do those two things. The problem seems to be that you're looking for a wrapper function (ala <code>check_output</code> or the <code>communicate</code> method) that does it all in one go; there isn't one, but what you want is trivial.</p>
<p>You presumably already know how to launch the process if you know about <code>communicate</code>:</p>
<pre><code>p = subprocess.Popen(args, other=flags, stdout=subprocess.PIPE)
</code></pre>
<p>And to block until output is received:</p>
<pre><code>_ = p.stdout.read()
</code></pre>
<p>And that's it.</p>
<hr/>
<p>Later, to shut down the server, if you want to hard-kill it:</p>
<pre><code>p.kill()
p.wait() # or p.communicate()
</code></pre>
<p>If your server shuts down gracefully when its pipes are closed, you may want to look at this example from the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow"><code>communicate</code></a> docs:</p>
<pre><code>try:
    outs, errs = proc.communicate(timeout=15)
except TimeoutExpired:
    proc.kill()
    outs, errs = proc.communicate()
</code></pre>
<p>Or if it expects a specific signal to ask it to shutdown gracefully, you may want to try a similar kill, timeout-wait, hard-kill, wait.</p>
</div>
<span class="comment-copy">connect the server's stdout to a PIPE and read that.</span>
<span class="comment-copy">@cdarke Ah, .readline() seems to work here. Thanks for the pointer!</span>
<span class="comment-copy">Not quite that simple though. From the docs: "If the size argument is negative or omitted, read all data until EOF" So either a) I try to figure out the proper size, or b) it blocks until EOF, which will never come (EOL yes. EOF, no). Yes, stopping the process is easy, but you'll notice that's not what I asked about :-)</span>
<span class="comment-copy">Ah, in looking further, it would appear that if I change read() to readline() this should work. So small change, but significant. And not mentioned in the popen docs, from what I can see. Thanks!</span>
<span class="comment-copy">@ibrewster:   It is not mentioned because we just get a file object, which has the attributes of other file objects (except it is not seekable).  Don't mix-up <code>Popen</code> (from <code>subprocess</code>) with <code>popen</code> (from <code>os</code>).  Confusing, but <code>os.popen()</code> is considered deprecated.</span>
