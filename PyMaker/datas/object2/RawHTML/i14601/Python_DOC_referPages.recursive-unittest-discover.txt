<div class="post-text" itemprop="text">
<p>I have a package with a directory "tests" in which I'm storing my unit tests. My package looks like:</p>
<pre><code>.
├── LICENSE
├── models
│   └── __init__.py
├── README.md
├── requirements.txt
├── tc.py
├── tests
│   ├── db
│   │   └── test_employee.py
│   └── test_tc.py
└── todo.txt
</code></pre>
<p>From my package directory, I want to be able to find both <code>tests/test_tc.py</code> and <code>tests/db/test_employee.py</code>. I'd prefer not to have to install a third-party library (<code>nose</code> or etc) or have to manually build a <code>TestSuite</code> to run this in.</p>
<p>Surely there's a way to tell <code>unittest discover</code> not to stop looking once it's found a test? <code>python -m unittest discover -s tests</code> will find <code>tests/test_tc.py</code> and <code>python -m unittest discover -s tests/db</code> will find <code>tests/db/test_employee.py</code>. Isn't there a way to find both?</p>
</div>
<div class="post-text" itemprop="text">
<p>In doing a bit of digging, it seems that as long as deeper modules remain importable, they'll be discovered via <code>python -m unittest discover</code>. The solution, then, was simply to add a <code>__init__.py</code> file to each directory to make them packages.</p>
<pre><code>.
├── LICENSE
├── models
│   └── __init__.py
├── README.md
├── requirements.txt
├── tc.py
├── tests
│   ├── db
│   │   ├── __init__.py       # NEW
│   │   └── test_employee.py
│   ├── __init__.py           # NEW
│   └── test_tc.py
└── todo.txt
</code></pre>
<p>So long as each directory has an <code>__init__.py</code>, <code>python -m unittest discover</code> can import the relevant <code>test_*</code> module.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're okay with adding a <code>__init__.py</code> file inside tests, you can put a <code>load_tests</code> function there that will handle discovery for you.</p>
<blockquote>
<p>If a test package name (directory with <code>__init__.py</code>) matches the
          pattern then the package will be checked for a 'load_tests' function. If
          this exists then it will be called with loader, tests, pattern.</p>
<p>If load_tests exists then discovery does  <em>not</em> recurse into the package,
          load_tests is responsible for loading all tests in the package.</p>
</blockquote>
<p>I'm far from confident that this is the best way, but one way to write that function would be:</p>
<pre><code>import os
import pkgutil
import inspect
import unittest

# Add *all* subdirectories to this module's path
__path__ = [x[0] for x in os.walk(os.path.dirname(__file__))]

def load_tests(loader, suite, pattern):
    for imp, modname, _ in pkgutil.walk_packages(__path__):
        mod = imp.find_module(modname).load_module(modname)
        for memname, memobj in inspect.getmembers(mod):
            if inspect.isclass(memobj):
                if issubclass(memobj, unittest.TestCase):
                    print("Found TestCase: {}".format(memobj))
                    for test in loader.loadTestsFromTestCase(memobj):
                        print("  Found Test: {}".format(test))
                        suite.addTest(test)

    print("=" * 70)
    return suite
</code></pre>
<p>Pretty ugly, I agree.</p>
<p>First you add all subdirectories to the test packages's path (<a href="https://docs.python.org/2/tutorial/modules.html#packages-in-multiple-directories" rel="nofollow">Docs</a>).</p>
<p>Then, you use <a href="https://docs.python.org/3/library/pkgutil.html" rel="nofollow"><code>pkgutil</code></a> to walk the path, looking for packages or modules.</p>
<p>When it finds one, it then checks the module members to see whether they're classes, and if they're classes, whether they're subclasses of <code>unittest.TestCase</code>.  If they are, the tests inside the classes are loaded into the test suite.</p>
<p>So now, from inside your project root, you can type</p>
<pre><code>python -m unittest discover -p tests
</code></pre>
<p>Using the <code>-p</code> pattern switch.  If all goes well, you'll see what I saw, which is something like:</p>
<pre><code>Found TestCase: &lt;class 'test_tc.TestCase'&gt;
  Found Test: testBar (test_tc.TestCase)
  Found Test: testFoo (test_tc.TestCase)
Found TestCase: &lt;class 'test_employee.TestCase'&gt;
  Found Test: testBar (test_employee.TestCase)
  Found Test: testFoo (test_employee.TestCase)
======================================================================
....
----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK
</code></pre>
<p>Which is what was expected, each of my two example files contained two tests, <code>testFoo</code> and <code>testBar</code> each.</p>
<p><strong>Edit:</strong> After some more digging, it looks like you could specify this function as:</p>
<pre><code>def load_tests(loader, suite, pattern):
    for imp, modname, _ in pkgutil.walk_packages(__path__):
        mod = imp.find_module(modname).load_module(modname)
        for test in loader.loadTestsFromModule(mod):
            print("Found Tests: {}".format(test._tests))
            suite.addTests(test)
</code></pre>
<p>This uses the <code>loader.loadTestsFromModule()</code> method instead of the <code>loader.loadTestsFromTestCase()</code> method I used above.  It still modifies the <code>tests</code> package path and walks it looking for modules, which I think is the key here.</p>
<p>The output looks a bit different now, since we're adding a found testsuite at a time to our main testsuite <code>suite</code>:</p>
<pre><code>python -m unittest discover -p tests
Found Tests: [&lt;test_tc.TestCase testMethod=testBar&gt;, &lt;test_tc.TestCase testMethod=testFoo&gt;]
Found Tests: [&lt;test_employee.TestCase testMethod=testBar&gt;, &lt;test_employee.TestCase testMethod=testFoo&gt;]
======================================================================
....
----------------------------------------------------------------------
Ran 4 tests in 0.000s

OK
</code></pre>
<p>But we still get the 4 tests we expected, in both classes, in both subdirectories.</p>
</div>
<span class="comment-copy">Have you looked at e.g. <a href="http://stackoverflow.com/q/644821/3001761">stackoverflow.com/q/644821/3001761</a>? I think some of those answers could be adapted for your purposes.</span>
<span class="comment-copy">I consider this to be the correct answer.</span>
<span class="comment-copy">This is massively harder than <code>python -m unittest discover -s tests --recursive</code>, which is what I was REALLY hoping someone would snarkily comment before voting to close. (that is to say, <i>thank you!</i>)</span>
<span class="comment-copy">@AdamSmith no problem, I hope it helps -- after a bit of digging, there looks to be a method that is a bit simpler, relying more on the unittest discovery than the explicit checking I had -- I'll edit my answer to include this alternative.</span>
<span class="comment-copy">Hmm there's a yet easier way I just accidentally discovered. I'll self-answer, though yours is still more foolproof.</span>
