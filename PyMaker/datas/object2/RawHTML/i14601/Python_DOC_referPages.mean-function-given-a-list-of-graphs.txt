<div class="post-text" itemprop="text">
<p>I need a function that, given a list of graphs, builds a new
graph in which for each abscissa the ordinate is the average of the ordinate of the several graphs supplied.</p>
<p>The data for each graph is a pair of lists of numbers, the first of which is the abscissa and the ordinate the second.</p>
<p>The function should assume that all graphs have the same abscissa lists.</p>
<p>For example:</p>
<pre><code>abscissa = range(1, 4)
graphs = [
    (abscissa, [1, 2, 3]),
    (abscissa, [4, 5, 6]),
    (abscissa, [7, 8, 9])
]

function(graphs)
</code></pre>
<p>Expected return from <code>function(graphs)</code>:</p>
<pre><code>([1, 2, 3], [4.0, 5.0, 6.0]) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can use the <code>zip</code> function to easily add the corresponding ordinates from each ordinate list, by using the "splat" operator <code>*</code>. This tells <code>zip</code> to treat each list in <code>ylists</code> as an argument, so it zips all of those lists together, creating a list of tuples. The first tuple in the resulting list contains all the 1st members of each list in <code>ylist</code>, the 2nd tuple in the resulting list contains all the 2nd members of each list in <code>ylist</code>, etc. </p>
<pre><code>#!/usr/bin/env python

''' Find means of graph data '''

def mean_graph(graphs):
    abscissa = graphs[0][0]

    #Extract ordinate lists
    ylists = [g[1] for g in graphs]

    #Find means of corresponding ordinates
    size = float(len(graphs))
    means = [sum(v) / size for v in zip(*ylists)]

    return abscissa, means


abscissa = range(1, 4)
graphs = [
    (abscissa, [1, 2, 3]),
    (abscissa, [4, 5, 6]),
    (abscissa, [7, 8, 9]),
]

print(mean_graph(graphs))
</code></pre>
<p><strong>output</strong></p>
<pre><code>([1, 2, 3], [4.0, 5.0, 6.0])
</code></pre>
<p>I developed the above code on Python 2.6.6. On Python 3 you can change<br/>
<code>size = float(len(graphs))</code><br/>
to<br/>
<code>size = len(graphs)</code></p>
<hr/>
<p>FWIW, it's possible to condense the <code>mean_graph</code> function into one line, although it does make it a little harder to read:</p>
<pre><code>def mean_graph(graphs):
    return graphs[0][0], [sum(v) / float(len(graphs)) for v in zip(*[g[1] for g in graphs])]
</code></pre>
<p>or for Python 3:</p>
<pre><code>def mean_graph(graphs):
    return graphs[0][0], [sum(v) / len(graphs) for v in zip(*[g[1] for g in graphs])]
</code></pre>
</div>
<span class="comment-copy">What is "a list of graphics"?</span>
<span class="comment-copy">pair of lists of numbers , the first of which is the abscissa and the second ordered</span>
<span class="comment-copy">Please give proper information and post complete questions</span>
<span class="comment-copy">@Lusokid: please edit your question providing a more precise definition of the expected input and a sample so that we can better help you. Thank you.</span>
<span class="comment-copy">@Lusokid: Put a small example of this input data (formatted in a code block) into your question. Even better: also add some code that attempts to do what you want, and we'll help you fix it. But show us the data first!</span>
<span class="comment-copy">thank you,very much!</span>
<span class="comment-copy">can you explain me what you did after the first return?</span>
<span class="comment-copy">@Lusokid: <code>return abscissa, means</code> creates a tuple of the <code>abscissa</code> and  <code>means</code> lists, and returns that tuple. So you <i>could</i> write it as <code>return (abscissa, means)</code>, but it looks cleaner to leave the <code>(</code> and <code>)</code> out. See the example of tuple packing in <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="nofollow noreferrer">Tuples and Sequences</a> in the official Python Tutorial.</span>
<span class="comment-copy">thank you ,you were great</span>
