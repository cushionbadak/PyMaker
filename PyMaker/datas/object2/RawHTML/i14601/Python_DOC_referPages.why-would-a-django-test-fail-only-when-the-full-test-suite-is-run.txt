<div class="post-text" itemprop="text">
<p>I have a test in Django 1.5 that passes in these conditions:</p>
<ul>
<li>when run by itself in isolation</li>
<li>when the full <code>TestCase</code> is run</li>
<li>when all of my app's tests are run</li>
</ul>
<p>But it fails when the full test suite is run with <code>python manage.py test</code>.  Why might this be happening?</p>
<p>The aberrant test uses <code>django.test.Client</code> to <code>POST</code> some data to an endpoint, and then the test checks that an object was successfully updated.  Could some other app be modifying the test client or the data itself?</p>
<p>I have tried some print debugging and I see all of the data being sent and received as expected.  The specific failure is a does-not-exist exception that is raised when I try to fetch the to-be-updated object from the db.  Strangely, in the exception handler itself, I can query for all objects of that type and see that the target object does in fact exist.</p>
<p>Edit:</p>
<p>My issue was resolved when I found that I was querying for the target object by <code>id</code> and <code>User</code> and not <code>id</code> and <code>UserProfile</code>, but it's still confusing to me that this would work in some cases but fail in others.</p>
<p>I also found that the test would fail with <code>python manage.py test auth &lt;myapp&gt;</code></p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like your problem does not involve mocks, but I just spent all day debugging an issue with similar symptoms, and your question is the first one that came up when I was searching for a solution, so I wanted to share my solution here, just in case it will prove helpful for others. In my case, the issue was as follows.</p>
<p>I had a single test that would pass in isolation, but fail when run as part of my full test suite. In one of my view functions I was using the Django <code>send_mail()</code> function. In my test, rather than having it send me an email every time I ran my tests, I <code>patch</code>ed <code>send_mail</code> in my test method:</p>
<pre><code>from mock import patch
...

def test_stuff(self):
    ...

    with patch('django.core.mail.send_mail') as mocked_send_mail:

    ...
</code></pre>
<p>That way, after my view function is called, I can test that <code>send_mail</code> was called with:</p>
<pre><code>self.assertTrue(mocked_send_mail.called)
</code></pre>
<p>This worked fine when running the test on its own, but failed when run with other tests in the suite. The reason this fails is that when it runs as part of the suite other views are called beforehand, causing the <code>views.py</code> file to be loaded, causing <code>send_mail</code> to be imported <em>before</em> I get the chance to <code>patch</code> it. So when <code>send_mail</code> gets called in my view, it is the actual <code>send_mail</code> that gets called, not my patched version. When I run the test alone, the function gets mocked <em>before</em> it is imported, so the patched version ends up getting imported when <code>views.py</code> is loaded. This situation is described in the <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="noreferrer">mock documentation</a>, which I had read a few times before, but now understand quite well after learning the hard way...  </p>
<p>The solution was simple: instead of patching <code>django.core.mail.send_mail</code> I just patched the version that had already been imported in my <code>views.py</code> - <code>myapp.views.send_mail</code>. In other words:</p>
<pre><code>with patch('myapp.views.send_mail') as mocked_send_mail:
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another possibility is that you've disconnected signals in the setUp of a test class and did not re-connect in the tearDown. This explained my issue.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a lot of nondeterminism that can come from tests that involve the database.</p>
<p>For instance, most databases don't offer deterministic selects unless you do an order by. This leads to the strange behavior where when the stars align, the database returns things in a different order than you might expect, and tests that look like</p>
<pre><code>result = pull_stuff_from_database()
assert result[0] == 1
assert result[1] == 2
</code></pre>
<p>will fail because <code>result[0] == 2 and result[1] == 1</code>.</p>
<p>Another source of strange nondeterministic behavior is the id autoincrement together with sorting of some kind.</p>
<p>Let's say each tests creates two items and you sort by item name before you do assertions. When you run it by itself, "Item 1" and "Item 2" work fine and pass the test. However, when you run the entire suite, one of the tests generates "Item 9" and "Item 10". "Item 10" is sorted ahead of "Item 9" so your test fails because the order is flipped.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this to help you debug:</p>
<pre><code>./manage.py test --reverse
</code></pre>
<p>In my case I realised that one test was updating certain data which would cause the following test to fail.</p>
</div>
<div class="post-text" itemprop="text">
<p>So I first read @elethan's answer and went 'well this is certainly not my problem, I'm not patching anything'. But it turned out I was indeed patching a method in a different test suite, which stayed permanently patched for the rest of the time the tests were run.</p>
<p>I had something of this sort going on;</p>
<pre><code>send_comment_published_signal_mock = MagicMock()
comment_published_signal.send = send_comment_published_signal_mock
</code></pre>
<p>You can see why this would be a problem if some things are not cleaned up after running the test suite. The solution in my case was to use the helpful <code>with</code> to restrict the scope.</p>
<pre><code>signal = 'authors.apps.comments.signals.comment_published_signal.send'
with patch(signal) as comment_published_signal_mock:
    do_your_test_stuff()
</code></pre>
<p>This is the easy part though, after you know where to look. The guilty test could come from anywhere. The solution to this is to run the failing test and other tests together until you find the cause, and then again, progressively narrowing it down, module by module.</p>
<p>Something like;</p>
<pre><code>./manage.py test A C.TestModel.test_problem
./manage.py test B C.TestModel.test_problem
./manage.py test D C.TestModel.test_problem
</code></pre>
<p>Then recursively, if for example <code>B</code> is the problem child;</p>
<pre><code>./manage.py test B.TestModel1 C.TestModel.test_problem
./manage.py test B.TestModel2 C.TestModel.test_problem
./manage.py test B.TestModel3 C.TestModel.test_problem
</code></pre>
<p>This <a href="https://groups.google.com/d/msg/django-users/OedhPc5bXYE/7C-1r3LkUesJ" rel="nofollow noreferrer">answer</a> gives a good explanation for all this.</p>
<p>This answer is in the context of <code>django</code>, but can really apply to any python tests.</p>
<p>Good luck.</p>
</div>
<div class="post-text" itemprop="text">
<p>This was happening to me too.</p>
<p>When running the tests individually they passed, but running all tests with <code>./manage.py test</code> it failed.</p>
<p>The problem in my case is because I had some tests inheriting from <code>unittest.TestCase</code> instead of from <code>django.test.TestCase</code>, so some tests were failing because there were registers on the database from previous tests.</p>
<p>After making all tests inherit from <code>django.test.TestCase</code> this problem has gone away.</p>
<p>I found the answer on <a href="https://stackoverflow.com/a/436795/6490637">https://stackoverflow.com/a/436795/6490637</a></p>
</div>
<span class="comment-copy">the database may not be being cleared between each test. What are your test cases inheriting from?</span>
<span class="comment-copy">Wow! I can't thank you enough! Don't know how much I would have ended up wasting behind this tricky issue. Thanks a lot for sharing your solution!</span>
<span class="comment-copy">It still took me close to an hour to figure it out, this answer was so useful!</span>
<span class="comment-copy">The name can influence too, based on that the unittest knows in which order to run them.</span>
<span class="comment-copy">Please consider editing your post to add more explanation about what your code does and why it will solve the problem. An answer that mostly just contains code (even if it's working) usually wont help the OP to understand their problem. It's also recommended that you don't post an answer if it's just a guess. A good answer will have a plausible reason for why it could solve the OP's issue.</span>
<span class="comment-copy">This is a useful debug command to help determine where the error might be, but isn't an answer.</span>
