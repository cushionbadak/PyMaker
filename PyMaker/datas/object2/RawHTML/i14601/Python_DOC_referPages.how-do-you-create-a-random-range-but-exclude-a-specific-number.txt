<div class="post-text" itemprop="text">
<p>I have the following code:</p>
<pre><code>while True:
    if var_p1 != "0":
        break
    else:
        import random
        var_p1 = random.randint(-5,5)
</code></pre>
<p>I want the loop to repeat until <code>var_p1</code> equals anything but zero. However, I get zero all the time. What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>Answering the question in the title, not the real problem (which was answered by Daniel Roseman):</p>
<p><strong>How do you create a random range, but exclude a specific number?</strong></p>
<p>Using <a href="https://docs.python.org/3/library/random.html#random.choice" rel="noreferrer"><code>random.choice</code></a>:</p>
<pre><code>import random
allowed_values = list(range(-5, 5+1))
allowed_values.remove(0)

# can be anything in {-5, ..., 5} \ {0}:
random_value = random.choice(allowed_values)  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>"0" != 0</code>.</p>
<p>You are comparing against a string, but <code>randint</code> gives you an integer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well you check against a string to break the loop. So use:</p>
<pre><code>if var_p1 != 0:
</code></pre>
<p>instead of:</p>
<pre><code>if var_p1 != "0":
</code></pre>
<p>A memory efficient way to generate from <code>a</code> to <code>b</code> but not including a value <code>c</code> is:</p>
<pre><code>r = random.randint(a, b - 1)
if r &gt;= c:
    r += 1 
</code></pre>
<p>This way, in the first step we'll generate a random int between <code>a</code> and <code>c - 1</code> or between <code>c</code> and <code>b - 1</code>. In the second case we increment by one and we get a random number between <code>c + 1</code> and <code>b</code>. It's easy to see that each number between <code>a..(c - 1)</code> and <code>(c + 1)..b</code> has the same probability.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code fails because you're comparing an integer to a string. There are other problems with your code:</p>
<ul>
<li>You have an <code>import</code> statement inside a loop.</li>
<li>There's no telling how many times your loop will run.</li>
</ul>
<p>Here is a loop-free way to randomly generate a non-zero integer from -5 to +5, inclusive.</p>
<pre><code>import random
x = random.randint(1, 5)
if random.randrange(2) == 1:
  x = -x
</code></pre>
<p>This code is guaranteed to call <code>random.randrange</code> exactly twice.</p>
</div>
<div class="post-text" itemprop="text">
<p>As an alternative method, just pick one random element from the array, [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5].  Guaranteed to work with just one call.</p>
</div>
<span class="comment-copy">Do you understand the difference between "0" and 0 ? At least in Python ?</span>
<span class="comment-copy">Not really.... I have been teaching myself slowly using online tutorials etc. However I do not recall the difference being properly explained...</span>
<span class="comment-copy">Hmm. I think that part is left for the user to understand. Anyways remember this, anything within single/double quotes is a string in python.Eg : x = "1234" is a string ( not integer/number) but x = 1234 is integer value (number). If you aren't clear yet then I will answer with further explanation.</span>
<span class="comment-copy">i don't see the reason for the +1 after the 5. Why couldn't you have just used (-5,5) ?</span>
<span class="comment-copy">You need <code>range(5,6)</code> as range does exclude the right boundary. See <a href="https://docs.python.org/3/library/stdtypes.html#range" rel="nofollow noreferrer"><code>range</code></a></span>
<span class="comment-copy">This code makes the optimal number of calls to a <code>random</code> function, so it's (probably) the most efficient, assuming that <code>allowed_values</code> doesn't get generated in a loop (eg, if it's generated as a local variable in a randomizer function).</span>
<span class="comment-copy">Ooh, very tricky. I love it!</span>
<span class="comment-copy">I <i>was</i> going to suggest this approach, but I figured using <code>choice</code> was better since it avoids the <code>if</code>... but Moose beat me to submitting an answer. :)</span>
<span class="comment-copy"><code>choice</code> has the drawback of having to store the choices....</span>
<span class="comment-copy">Indeed, and as I mentioned in the comment on Moose's answer, if you create it locally in the function that generates the random numbers that's very wasteful. Typically, I'd create it (as a tuple) in the global context, just above the definition of the randomizer function.</span>
<span class="comment-copy">@moose Yes both methods give the same probability. I think choice is surely very good when your data don't follow a pattern and you don't have problem with the space. Otherwise, you could end up storing a million ints for selecting a random one because you need only one exception.</span>
<span class="comment-copy">Thanks for mentioning that <code>import</code> should be at the top of the script. Putting it inside a loop is not an error, per se, and subsequent attempts to import the same module will have no effect, but it's still poor style.</span>
<span class="comment-copy">Yes, there's no way to know how many times the loop in the OP's code will run. However, the expected value is 1.1 loops per number returned, i.e. to return 1000 numbers 1100 random numbers will typically be generated. So although the OP's algorithm's runtime is non-deterministic, actually it's not that bad, since both your algorithm and JuniorCompressor's both need to generate 2000 random numbers to return 1000 results.</span>
<span class="comment-copy">Yes, you're right. An expected value of 1.1 is better than a guaranteed value of 2.</span>
<span class="comment-copy">Dear people of the future: JuniorCompressor's code has changed so my previous remark no longer applies to it. :)</span>
