<div class="post-text" itemprop="text">
<p>What could possibly go wrong if I unintentionally overwrite/mask build-in function in Python?</p>
<p>Can I experience anything worse than the obvious pitfall of accessing a local function instead of a built-in function?</p>
<p>For example:</p>
<pre><code>def max(a, b):
  pass

class MyCompileTool(object):
    def __init__(self, id):
        self.id = id

    def compile(self):
        min = "3.4.4"
        ...
</code></pre>
<p>Even in some official modules: <a href="https://docs.python.org/3/library/argparse.html#type" rel="nofollow">argparse.add_argument(..., type, ...)</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You do not overwrite builtin <code>min</code> here, you just create a <code>min</code> local, which will be preferred if subsequent code of <code>compile</code> will contain calls to <code>min</code>:</p>
<pre><code>class MyCompileTool(object):
    ...

    def compile(self):
        min = "3.4.4"
        x = min(1, 2)
        #   ^^^ "3.4.4".__call__(1, 2)
        #   This will throw exception because strings doesn't have __call__
x = min(3, 4)
#   ^^^ __builtins__.min
</code></pre>
<p>To shadow <code>min</code> in entire module, do that in global namespace:</p>
<pre><code>min = "3.4.4"
# Now all calls of min will go to that string

class MyCompileTool(object):
     pass
</code></pre>
<p>For more information on how names are resolved in Python, check documentation: <a href="https://docs.python.org/2/reference/executionmodel.html#naming-and-binding" rel="nofollow">4.1. Naming and binding</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In this particular situation, there probably isn't much that can/will go wrong.  You're just shadowing <code>min</code> with a local variable in your method, so you're probably not going to do much damage.  In general though, you could see something like this:</p>
<pre><code>&gt;&gt;&gt; min = "3.4.4"
&gt;&gt;&gt; x = min(3, 4, 5)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'str' object is not callable
&gt;&gt;&gt;
</code></pre>
<p>This might confuse you or (even worse) it might confuse the person who has to go in and support your code later.  It would be even worse if you did it globally, like:</p>
<pre><code>min = "3.4.4"

def main():
    x = min(3, 4, 5)
</code></pre>
<p>Overall, it's bad practice.  Don't do it.</p>
</div>
<span class="comment-copy">There are many possible scenarios, all basing on a fact that someone/you will not now/forget about this and will try to call these functions. This questions seems too broad. Also, note that in your example you are not modifying built-ins, just create local variables that shadow the built-ins only in the scope of the <code>compile</code> method.</span>
<span class="comment-copy">Isn't it obvious?! You could accidentally call the wrong function, and either get an error or (worse) quietly get the wrong result. Note that <b>overwriting</b> built-ins is (intentionally) very difficult to do by accident, it's <b>shadowing</b> them that you need to watch out for. Tools like <code>pylint</code> will warn you of this. Also avoid wildcard imports (<code>from foo import *</code>) for the same reason.</span>
<span class="comment-copy">I feel like the OP is actually asking, "besides the obvious pitfall of not being able to access that function anymore, are there any consequences, such as 'internal Python functions that use <code>max</code> will get confused and crash when they can't find the usual implementation'?". To which the answer is, IIRC, "no".</span>
<span class="comment-copy">@Kevin ah, possibly - is that the case, OP? Is this really a question about the scope of names in Python?</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/20125172/how-bad-is-shadowing-names-defined-in-outer-scopes">How bad is shadowing names defined in outer scopes?</a></span>
<span class="comment-copy">About the word "<i>completely</i>": Wouldn't any call to <code>min()</code> in an imported module still reference the regular <code>min()</code>? I am not too sure how those rules work...</span>
<span class="comment-copy">@HannesOvr√©n, thanks for that note, you absolutely correct -- it is done in global namespace of single module. I have my answer fixed.</span>
<span class="comment-copy">@myaut "single module", unless another module will do <code>from x import *</code>.</span>
<span class="comment-copy">@BartoszKP: if we count that as a syntactic sugar for <code>import x; min = x.min; ...</code>, than it is no different than my example ;)</span>
