<div class="post-text" itemprop="text">
<p>I've been experimenting with Python dictionaries and discovered that <code>__gt__</code> and <code>__lt__</code> are implemented for dictionaries.</p>
<p>I've tested them and it appears that they somehow compare the keys, but it is not quite clear to me how that is done; for example, I'm not quite sure how <code>{1: 1} &gt; {'0': 0}</code> returns <code>False</code> (as a matter of fact, <code>'0' &gt; 100000</code> returns <code>True</code> as well).</p>
<p>Is there any document with specifics on the implementation of these two functions?</p>
</div>
<div class="post-text" itemprop="text">
<p>The documentation has a <a href="https://docs.python.org/2/library/stdtypes.html#comparisons" rel="nofollow">section on comparisons</a>. In particular:</p>
<blockquote>
<p>Objects of different types, except different numeric types and different string types, never compare equal; such objects are ordered consistently but arbitrarily (so that sorting a heterogeneous array yields a consistent result).</p>
</blockquote>
<p>The reason for behaviour like:</p>
<pre><code>&gt;&gt;&gt; '0' &lt; 0
False
&gt;&gt;&gt; 0 &lt; '0'
True
</code></pre>
<p>in CPython is that the <em>"consistently but arbitrarily"</em> comparison method selected was to order alphabetically by type name, and <code>'str' &gt; 'int'</code>:</p>
<blockquote>
<p><strong>CPython implementation detail</strong>: Objects of different types except numbers are ordered by their type names; objects of the same types that donâ€™t support proper comparison are ordered by their address.</p>
</blockquote>
<p>This behaviour was <a href="https://docs.python.org/3/whatsnew/3.0.html#ordering-comparisons" rel="nofollow">altered for Python 3.x</a> and you can no longer compare heterogeneous types (or dictionaries, for that matter):</p>
<pre><code>&gt;&gt;&gt; '0' &gt; 0
Traceback (most recent call last):
  File "&lt;pyshell#1&gt;", line 1, in &lt;module&gt;
    '0' &gt; 0
TypeError: unorderable types: str() &gt; int()
&gt;&gt;&gt; {'a': None} &gt; {'b': None}
Traceback (most recent call last):
  File "&lt;pyshell#0&gt;", line 1, in &lt;module&gt;
    {'a': None} &gt; {'b': None}
TypeError: unorderable types: dict() &gt; dict()
</code></pre>
<hr/>
<p>In terms of dictionaries specifically, they are sorted such that:</p>
<pre><code>d1 &gt; d2
</code></pre>
<p>becomes:</p>
<pre><code>(len(d1) &gt; len(d2) or 
 (len(d1) == len(d2) and
  sorted(d1.items()) &gt; sorted(d2.items()))
</code></pre>
<p><em>(you can see this implemented in the <a href="https://hg.python.org/releasing/2.7.9/file/753a8f457ddc/Objects/dictobject.c#l1792" rel="nofollow">CPython source code</a>)</em>. So if they aren't the same length the "longer" one is "larger":</p>
<pre><code>&gt;&gt;&gt; {1: 2, 3: 4} &gt; {1: 2}
True
</code></pre>
<p>if they have matching keys, the one with "larger" values is "larger":</p>
<pre><code>&gt;&gt;&gt; {1: 2} &gt; {1: 1}
True
</code></pre>
<p>and if they have mismatching keys, the one with the "larger" keys is "larger":</p>
<pre><code>&gt;&gt;&gt; {1: 2} &gt; {2: 1}
False
</code></pre>
</div>
<span class="comment-copy">Only in Python 2.x - in 3.x you'd get <code>TypeError: unorderable types: dict() &gt; dict()</code>. Is your question about <b>dictionary</b> comparisons, or why strings are "larger than" numbers?</span>
<span class="comment-copy">At the python repr (Python 2.7.9 Anaconda 2.2.0) i can type the following code:&lt;br/&gt;<code>tmp1 = dict();tmp2 = dict();tmp1[1] = 1;tmp2['1'] = 2;tmp2 &gt; tmp1</code> and that returns <code>True</code>... I'm not quite sure how that's done...</span>
<span class="comment-copy">and dictionaries keywords are sorted before comparing them? As in, if I create a dictionary with mixed type keywords (str, int, etc), what keyword is compared with what?</span>
<span class="comment-copy">It's not quite equivalent to <code>sorted(d1.items()) &gt; sorted(d2.items())</code>; the lengths are compared first.</span>
<span class="comment-copy">before item compare, it must do a key compare, as in: <code>sorted(d1.keys()) &gt; sorted(d2.keys())</code>. For example <code>{'1': 1} &gt; {1: 1}; </code> returns <code>True</code>, while <code>{1: 1} &gt; {'1': 1}</code> returns <code>False</code>. I guess the implementation has contains something like <code>if sorted(self.keys()) == sorted(other.keys()) then: return sorted(self.keys()) &gt; sorted(other.keys())</code></span>
<span class="comment-copy">@LorenzoTrojan: Are you mixing up <code>items()</code> and <code>values()</code>?</span>
<span class="comment-copy">@LorenzoTrojan no, it doesn't <i>"do a key compare"</i>; <code>items</code> includes <b>both keys and values</b>. If you want to look at the <i>actual implementation</i> for CPython, go to the source code.</span>
