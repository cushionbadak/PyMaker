<div class="post-text" itemprop="text">
<p>I have spent the day trying to find an answer to this question but have come up with nothing.</p>
<p>Suppose I have several classes, each containing a methods that are identical to those in the others.</p>
<pre><code>class A:
    def __init__(self, attr1, attr2, color):
        self.__attr1 = attr1
        self.__attr2 = attr2
        self.__color = color

    def set_color(self, color):
        self.__color = color

class B:
    def __init__(name, attr3, attr4, color):
         self.__attr3 = attr3
         self.__attr4 = attr4
         self.__color = color

    def set_color(self, color):
        self.__color = color
</code></pre>
<p>In this example, the identical methods are reduced to just one identical method, set_color, to illustrate what I am trying to do.</p>
<p>Is there a way to eliminate repeating code, perhaps with an abstract class  as follows?</p>
<pre><code>class Parent:
    def set_color(self, color):
        self.__color = color

class A(Parent):
    def __init__(self, attr1, attr2, color):
        self.__attr1 = attr1
        self.__attr2 = attr2
        self.__color = color


class B(Parent):
    def __init__(name, attr3, attr4, color):
         self.__attr3 = attr3
         self.__attr4 = attr4
         self.__color = color

exampleA = A(attr1, attr2, "blue)
</code></pre>
<p>I want to be able change from blue to red in a way like this
so that I don't have to define the same methods within each class <code>A</code> and <code>B</code></p>
<pre><code>exampleA.set_color("red")
</code></pre>
<p>but this doesn't work as I expected it to, it doesn't change the value of <code>exampleA.__color</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can't. The whole point of <code>__private</code>-style attributes is that they're private. Base classes, subclasses, outsiders, nobody else can see the or modify them. If a base class or subclass tries, they will end up creating their <em>own</em> private attribute on the instance, completely independent of yours.</p>
<p>If you don't want that, just don't use <code>__private</code>-style attributes.</p>
<p>So, what <em>should</em> you do?</p>
<p>Well, the most Pythonic thing is to just use public attributes, and scrap your getters and setters entirely: <code>exampleA.color = 'red'</code>. </p>
<p>If you have a really good reason you need to hide the attributes, maybe you wanted to make them <code>_private</code> instead of <code>__private</code>, which means they're private only by convention, so your code will just work as-is. But again, I doubt you really need to hide them.</p>
<p>If you really, really need <code>__private</code> members, but still really need to defeat the entire purpose of <code>__private</code> members… well, in that case, I lied; you actually <em>can</em> access them, by manually mangling the names. For example, the attribute that's named <code>__color</code> from inside class <code>A</code> is named <code>_A__color</code> from outside of class <code>A</code>.</p>
<p>If you're wondering why Python lets you violate the <code>__private</code> protection... well, unlike the similar feature in Java, this isn't meant to protect you against someone else's malicious code. What it protects you from is a scenario like this: You write a class <code>A</code> with a an attribute <code>__x</code>. I write a class <code>B</code> with an attribute <code>__x</code>. Someone else composes our classes by inheriting from both, without telling either you or me. My code still works, so does yours.</p>
<p>For further information, see the tutorial section on <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow">private variables</a>, and the reference documentation on <a href="https://docs.python.org/3.4/reference/expressions.html?#atom-identifiers" rel="nofollow">identifiers</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The only reason this wouldn't work exactly as you have it is because you're using attributes prefixed with <code>__</code>, which makes them "private" and so not accessible to the parent class. Don't do that: just use normal attribute names.</p>
</div>
<span class="comment-copy">For more info, please see <a href="http://stackoverflow.com/q/1301346/4014959">The meaning of a single- and a double-underscore before an object name in Python</a></span>
<span class="comment-copy">I realise that this is just an example, but setter methods (and getter methods) are not considered Pythonic unless you need them to do "magical" things. If you merely want to set the value of an attribute, just set it directly.</span>
<span class="comment-copy">@PM2Ring: In fact, even when you <i>do</i> want them to do magical things, unless you need to make it explicit, as part of the interface, that magicalness is happening, you're still usually better off putting the getter and setter behind an <code>@property</code>…</span>
<span class="comment-copy">@abarnert. Indeed!</span>
