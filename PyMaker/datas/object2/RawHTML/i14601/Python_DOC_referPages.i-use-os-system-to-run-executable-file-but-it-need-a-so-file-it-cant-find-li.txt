<div class="post-text" itemprop="text">
<p>When I call a executable in python using <code>os.system("./mydemo")</code> in Ubuntu, it can't find the .so file (libmsc.so) needed for mydemo. I used <code>os.system("export LD_LIBRARY_PATH=pwd:$LD_LIBRARY_PATH;")</code>, but it still can't find libmsc.so.</p>
<p>The libmsc.so is in the current directory. and shouldn't be global.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you do <code>os.system("export LD_LIBRARY_PATH=pwd:$LD_LIBRARY_PATH;")</code>, you run new instance of shell, alter <code>LD_LIBRARY_PATH</code> there than immediately exit from it. Also, pwd mean nothing in the context of Python.</p>
<p>Try to set env variables like this:</p>
<pre><code>os.system("LD_LIBRARY_PATH={} ./mydemo".format(os.getcwd())) 
</code></pre>
<p>Or maybe it is better to use subprocess module?</p>
<pre><code>import subprocess
env = os.environ.copy()
env['LD_LIBRARY_PATH'] = os.getcwd()
proc = subprocess.Popen("./mydemo", shell=True, env=env)
proc.wait()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I remember correctly, executing <code>export ...</code> via <code>os.system</code> will only set that shell variable within the scope, thus it's not available in the following <code>os.system</code> scopes. You should set the <code>LD_LIBRARY_PATH</code> in the shell, before executing the Python script.</p>
<p>Btw. also avoid setting relative paths…</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <code>export</code> only exports its variables to children of the current shell. As in the shell that you created by calling <code>os.system</code>, which then immediately exits.</p>
<p>If you want the simplest fix to make this work, you can do both the <code>export</code> and the target program inside a single shell:</p>
<pre><code>os.system("export LD_LIBRARY_PATH=pwd:$LD_LIBRARY_PATH; ./mydemo")
</code></pre>
<p>There are some other problems with this. For example, <code>export</code>ing and assigning a variable in the same command is a <code>bash</code>-ism that may not be available in all shells. With <a href="https://docs.python.org/3/library/subprocess.html#module-subprocess" rel="nofollow"><code>subprocess</code></a> you can specify a specific shell, but with <code>system</code> you just get whatever the OS considers the default shell—on Linux, the <a href="http://linux.die.net/man/3/system" rel="nofollow">manpage</a> says this means <code>/bin/sh -c</code>.</p>
<p>Really, the best way to solve this is to just not use a shell in the first place, and set the environment variables the way you want. That's exactly why the <a href="https://docs.python.org/3/library/os.html#os.system" rel="nofollow"><code>os.system</code></a> docs say: "The <code>subprocess</code> module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function." For example:</p>
<pre><code>env = dict(os.environ)
env['LD_LIBRARY_PATH'] = '"{}":{}'.format(
    os.getcwd(), env.get('LD_LIBRARY_PATH', ''))
subprocess.check_call(['./mydemo'], env=env)
</code></pre>
<p>Or, if you want to be really safe (unlike your shell code):</p>
<pre><code>LD_LIBRARY_PATH = env.get('LD_LIBRARY_PATH', '')
if LD_LIBRARY_PATH:
    LD_LIBRARY_PATH = ':' + LD_LIBRARY_PATH
LD_LIBRARY_PATH = shlex.quote(os.getcwd()) + LD_LIBRARY_PATH
subprocess.check_call(['./mydemo'], env=env)
</code></pre>
<p>I've written this out more explicitly and verbosely than you'd normally write it, to make the steps obvious: don't include a trailing <code>:</code> before an empty path, and use <code>shlex.quote</code> in case someone does something tricky with the current working directory.</p>
</div>
<span class="comment-copy">First, why are you using <code>os.system</code> in the first place? <a href="https://docs.python.org/3/library/os.html#os.system" rel="nofollow noreferrer">Its own docs</a> say "The subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function."</span>
<span class="comment-copy">Why use <code>shell=True</code> here?</span>
<span class="comment-copy">@abarnert: Backward compability with <code>os.system</code> :)</span>
<span class="comment-copy">THANK YOU!!! you guys are amazing!! I struggle with the problem for 2 days!!! thank you very much.</span>
<span class="comment-copy">I didn't try this , but still thank you very much!!!!</span>
<span class="comment-copy">&gt; <code>env['LD_LIBRARY_PATH'] = ...</code> &lt; If variable is empty (which is most likely), you will get "path:" which is insecure (it seeks for so's in <i>current</i> directory). Not the OPs, case, but if <code>./mydemo</code> chdirs to another directory and runs some binary then...</span>
<span class="comment-copy">thank you very much!!</span>
<span class="comment-copy">@myaut: It's modifying the environment in exactly the same way his shell code intended to. And notice that he's explicitly <i>trying</i> to set it to the current directory, so… Anyway, <i>not</i> doing the <code>:</code> and current value means that if the variable <i>isn't</i> empty, you'll erase any existing paths, which could break <code>mydemo</code> (or some other program it spawns).</span>
