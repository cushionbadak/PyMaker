<div class="post-text" itemprop="text">
<p>I have following code in Pyhton:</p>
<pre><code># myFile.csv tend to looks like:
# 'a1',   'ふじさん',   'c1'
# 'a2',   'ふじさん',   'c2'
# 'a3',   'ふじさん',   'c3'

s = u"unicodeText" # unicodeText like, ふじさん بعدة أش  일본富士山Ölkələr
with codecs.open('myFile.csv', 'w+', 'utf-8') as f: # codecs open
    f.write(s.encode('utf-8', 'ignore'))
</code></pre>
<ol>
<li>I was using Vim to edit the code and using Vim to open "myFile.csv";</li>
<li>It can success display unicode text from terminal;</li>
<li>but not able to display unicode text from Excel, nor from browser;</li>
<li>My platform is osx</li>
</ol>
<p>I don't know if is my configuration problem or actually I code it wrong way, if you any idea, please advise. Deeply appreciate!</p>
<hr/>
<p>change <code>open</code> to <code>codecs.open</code>.<br/>
Thanks for point out f.close(), deleted.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems you're <em>trying</em> to open the file in text mode (because you specify an encoding), but then you try to write binary data (because you encode the text before writing it to the file). You need to either open the file as binary and write encoded text, or open it as text and write text.</p>
<p>Furthermore, your attempt to open it as text isn't even working because  you're passing <code>utf-8</code> as the <em>buffering</em> parameter instead of the <code>encoding</code> parameter. See <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow">the open() documentation</a>`.</p>
<p>But even if you did all that correctly, this still wouldn't really help you with an Excel file, because those have a complicated binary structure. I recommend you use something like the <a href="https://pypi.python.org/pypi/xlrd/0.9.3" rel="nofollow">xlrd</a> to read xls files and <a href="https://pypi.python.org/pypi/XlsxWriter/0.7.2" rel="nofollow">Xlswriter</a> to write them.</p>
<p>Here is a simple example that should work for .csv:</p>
<pre><code>with open('file.csv', 'w', encoding='utf-8') as fh:
    fh.write('This &gt;µ&lt; is a unicode GREEK LETTER MU\n')
</code></pre>
<p>or alternatively</p>
<pre><code>with open('file.csv', 'wb') as fh:
    fh.write('This &gt;µ&lt; is a unicode GREEK LETTER MU\n'.encode('utf-8'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>codecs.open</em> opens a wrapped reader/writer which will do encoding/decoding for you. So you do not need to encode your string for writing. You need to pass the 'ignore' parameter in your open call.</p>
<pre><code>with open('myFile.csv', 'w+', 'utf-8', 'ignore') as f:
    f.write(s)
</code></pre>
<p>Note that you do not need to call <em>close</em> as you use a <em>with</em> statement.</p>
<p>Original answer, scratch that:</p>
<p>Third parameter of <em>open</em> is <em>buffering</em> requiring an integer.
You should write pass the encoding like this:</p>
<pre><code>with open('myFile.xls', 'w+', encoding='utf-8') as f:
</code></pre>
<p>Note that you open the file in text mode. No need to encode the string for writing.</p>
<p>Also your file mode 'w+' is a bit odd. I'm not sure, but I think it will truncate your file. If you want to append to the file you should use 'a' as mode.</p>
</div>
<div class="post-text" itemprop="text">
<p>Excel (at least on Windows) likes a Unicode BOM at the start of a <code>.csv</code> file even with UTF-8.  There is a codec for that, <code>utf-8-sig</code>.</p>
<p>Also, Python 3's normal <code>open</code> is all that is required and no need for <code>f.close()</code> in a <code>with</code>:</p>
<pre><code>#coding:utf8
data = '''\
a1,ふじさん,c1
a2,ふじさん,c2
a3,ふじさん,c3
'''
with open('myFile.csv', 'w', encoding='utf-8-sig') as f:
    f.write(data)
</code></pre>
</div>
<span class="comment-copy">what is somestring?</span>
<span class="comment-copy">It makes no sense to read/write <code>xls</code> or <code>csv</code> files in the way you are trying to do it. You need to use a specialized module, such as <a href="http://pypi.python.org/pypi/xlrd" rel="nofollow noreferrer">xlrd</a> for <code>xls</code> files, or the <a href="https://docs.python.org/3/library/csv.html#module-csv" rel="nofollow noreferrer">csv module</a> for <code>csv</code> files.</span>
<span class="comment-copy">@ekhumoro you're right about <code>xls</code>, but writing a <code>csv</code> file does not require a special module.</span>
<span class="comment-copy">@dbliss. I didn't claim that it wasn't possible. But the <code>csv</code> module exists for a good reason, and since it's part of the stdlib, it makes no sense not to use it.</span>
<span class="comment-copy">You don't need to call <code>f.close()</code> when the file is opened as the context manager for the <code>with</code> statement.</span>
<span class="comment-copy">Thanks! I think codecs.open actually can pass parameter as 'uft-8', and you are right, io.open should pass parameter as encoding='utf-8'.</span>
<span class="comment-copy">How about accepting this answer then? :-)</span>
<span class="comment-copy">The OP seems to be using <a href="https://docs.python.org/3/library/codecs.html#codecs.open" rel="nofollow noreferrer"><code>codecs.open</code></a>, which has a different signature to the built-in <code>open</code> function.</span>
<span class="comment-copy">Ooops. My fault. Didn't notice the comment, only tried to get the code working.</span>
<span class="comment-copy">Corrected the answer, but leaving the first try for consistency at the bottom.</span>
<span class="comment-copy"><code>utf-8-sig</code> works. Thanks for point out. deleted <code>f.close()</code>, thx so much</span>
