<div class="post-text" itemprop="text">
<p>for example,</p>
<pre><code>listOne = [1,2,6]
listTwo = [3,2,4]

checkLists(listOne, listTwo)

should return [3,2,6]
</code></pre>
<p>1 &lt; 3 therefore [3,?,?]</p>
<p>2 = 2 therefore [3,2,?]</p>
<p>6 &gt; 4 therefore [3,2,6]</p>
<p>I have recently started python and don't know how to use a loop that checks two lists at once.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a> to make a new list.<br/>
You can use <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow"><code>zip</code></a> to iterate through both lists at once.<br/>
You can use <a href="https://docs.python.org/2/library/functions.html#max" rel="nofollow"><code>max</code></a> to give you the greater of two items.</p>
<pre><code>def checkLists(a, b):
    return [max(ai, bi) for ai, bi in zip(a,b)]
</code></pre>
<p>This gives:</p>
<pre><code>&gt;&gt;&gt; checkLists([1,2,6], [3,2,4])
[3, 2, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow"><code>map</code></a> built-in function here:</p>
<pre><code>result_iter = map(max, list_one, list_two)
</code></pre>
<p>which will create a list on Python 2 and an iterator (a map object) on Python 3 - if you do need a list, on Python 3 wrap the <code>map</code> with <code>list()</code>:</p>
<pre><code>result_list = list(map(max, list_one, list_two))
</code></pre>
<hr/>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; list_one = [1, 2, 6]
&gt;&gt;&gt; list_two = [3, 2, 4]
&gt;&gt;&gt; list(map(max, list_one, list_two))
[3, 2, 6]
</code></pre>
<hr/>
<p>How this works is that the <code>map</code> function takes 1 function as an argument, followed by 1 to n iterables; the iterables are iterated over simultaneously and their values are passed as arguments to the given function; whatever is returned from the function (<code>max</code> in this case) is yielded from the <code>map</code> into the result value.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>[max(x,y) for x,y in zip(listOne, listTwo)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>listOne = [1,2,6]
listTwo = [3,2,4]

import itertools
def checkLists(listOne, listTwo):
    lsttmp=[]
    for i , j in itertools.izip(listOne,listTwo):

        lsttmp.append(max(i,j))
    return  lsttmp
print checkLists(listOne, listTwo)
</code></pre>
</div>
<span class="comment-copy">Hint: <a href="http://stackoverflow.com/q/1663807/1903116">How can I iterate through two lists in parallel in Python?</a></span>
<span class="comment-copy">I didn't realise that <code>map</code> was so fast! For small lists, a <code>map</code> based function runs in 2/3 the time of a function containing a list comprehension using <code>zip</code> (in Python 2); for a list of length 1000, the <code>map</code> version runs in less than half the time of the list comp. And because this version is so compact there's little point in wrapping it in a function, and of course calling it directly would be even faster.</span>
<span class="comment-copy">This is fast because in Python resolving global names is slow; with list comprehension or generator expression you pay the price of finding out "<i>what's this <code>max</code>?</i>" 1000 times where the <code>map</code> does it once. Furthermore <code>map</code> does not need to rebuild tuples twice in this case.</span>
<span class="comment-copy">Why import <code>.izip</code> when you can use the built-in <code>zip</code> for this? OTOH, <code>.izip</code> creates an iterator whereas <code>zip</code> creates a list, so <code>.izip</code> can be better if the input lists are very large.</span>
<span class="comment-copy">@PM2Ring zip computes all the list at once, izip computes the elements only when requested.So i have used the izip</span>
<span class="comment-copy">Ok. I just did some timing tests. <code>izip</code> and <code>zip</code> are roughly the same speed for very small lists, but for larger lists (&gt;100 elements) <code>izip</code> is a little faster. However, using a list comprehension makes more of a difference: a list comp using <code>izip</code> on lists of 1000 elements runs in 2/3 the time of <code>zip</code> in a <code>for... append</code> loop.</span>
