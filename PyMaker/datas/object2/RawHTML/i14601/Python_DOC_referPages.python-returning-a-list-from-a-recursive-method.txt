<div class="post-text" itemprop="text">
<p>Im using a binary tree described in this book
<a href="http://interactivepython.org/LpOMZ/courselib/static/pythonds/Trees/implementation.html" rel="nofollow">problem solving with algorithms and data structures</a></p>
<pre><code>class BinaryTree:
    def __init__(self,rootObj):
        self.key = rootObj
        self.leftChild = None
        self.rightChild = None
</code></pre>
<p>There is already a preorder traversal method defined as follows.</p>
<pre><code>def preorder(tree):
    if tree:
        print(tree.self.key)
        preorder(tree.getLeftChild())
        preorder(tree.getRightChild())
</code></pre>
<p>I just want to add a return value of the list of nodes visited. So I can do something like</p>
<pre><code>for i in preorder(tree):
    etc...
</code></pre>
<p>Im having trouble returning a list from a recursive method. The recursion stops as soon as it hits the 'return' I've tried variations using</p>
<pre><code>return [tree.self.key] + preorder()
</code></pre>
<p>Or</p>
<pre><code>yield ...
</code></pre>
<p>Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you sure you want <code>tree.self.key</code> and not simply <code>tree.key</code> when you print?</p>
<p>Otherwise, a solution with <a href="https://www.python.org/dev/peps/pep-0380/" rel="nofollow"><code>yield from</code></a> (Python 3.3+):</p>
<pre><code>def preorder(tree):
    if tree:
        yield tree
        yield from preorder(tree.getLeftChild())
        yield from preorder(tree.getRightChild())
</code></pre>
<p>Or with simple <code>yield</code>:</p>
<pre><code>def preorder(tree):
    if tree:
        yield tree
        for e in preorder(tree.getLeftChild()):
            yield e
        for e in preorder(tree.getRightChild()):
            yield e
</code></pre>
<p>Note that using <code>yield</code> or <code>yield from</code> transforms the function into a <a href="https://docs.python.org/3/reference/expressions.html?highlight=yield#yield-expressions" rel="nofollow">generator function</a>; in particular, if you want an actual list (for indexing, slicing, or displaying for instance), you'll need to explicitly create it: <code>list(preorder(tree))</code>.</p>
<p>If you have a varying number of children, it's easy to adapt:</p>
<pre><code>def preorder(tree):
    if tree:
        yield tree
        for child in tree.children:
            yield from preorder(child)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have to actually <em>return</em> a value from the recursive function (currently, it's just printing values). And you should build the list as you go, and maybe clean the code up a bit - something like this:</p>
<pre><code>def preorder(tree):
    if not tree:
        return []
    # optionally, you can print the key in this line: print(self.key)
    return [tree.key] + preorder(tree.leftChild) + preorder(tree.rightChild)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can add second argument to <code>preorder</code> function, something like</p>
<pre><code>def preorder(tree, visnodes):
    if tree:
        visnodes.append(tree.self.key)
        print(tree.self.key)
        preorder(tree.getLeftChild(), visnodes)
        preorder(tree.getRightChild(), visnodes)

...
vn = []
preorder(tree, vn)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply return a concatenated list for each recursive call, which combines the current key, the left subtree and the right subtree:</p>
<pre><code>def preorder(tree):
        if tree:
            return ([tree.key] + preorder(tree.getLeftChild()) +
                    preorder(tree.getRightChild()))
        return []
</code></pre>
<p>For an n-ary tree:</p>
<pre><code>def preorder(tree):
    if tree:
        lst = [tree.key]
        for child in tree.children:
            lst.extend(preorder(child))
        return lst
    return []
</code></pre>
</div>
<span class="comment-copy">What error are you getting? Is it something about concatenating None and list?</span>
<span class="comment-copy">1). It appears that <code>preorder()</code> is a helper function and not actually a method of the <code>BinaryTree</code> class, so calling it a method is a little confusing. 2). If <code>tree</code> is an instance of <code>BinaryTree</code>, then <code>tree.self.key</code> is wrong. 3). In Python you rarely need getter (or setter) methods, you just access the attributes directly. Eg, <code>preorder(tree.leftChild)</code>.</span>
<span class="comment-copy">Since you're directly accessing <code>tree.key</code>, you might as well use <code>preorder(tree.leftChild)</code> and <code>preorder(tree.getRightChild)</code>. In addition, you should mention that to get the list of nodes this way you'd need to do something like <code>nodes = list(preorder(tree))</code> or <code>nodes = [node for node in preorder(tree)]</code>.</span>
<span class="comment-copy">Thanks for the suggestion about the list. As for your other point, I'm accessing <code>tree.key</code> because I don't want to guess if there is a <code>getKey()</code> method but I believe that OP's <code>tree.self.key</code> might be faulty. There is already a comment about the lack of need of getters and setters in Python but here it's really besides the point.</span>
<span class="comment-copy">I mentioned showing how to create a list because of the title of the question. Also note that it should be <code>print tree.key</code>, not <code>yield tree.key</code> â€” the OP wants a list of nodes, not one with a mixture of nodes and keys.</span>
<span class="comment-copy">There was no nodes but only keys (by induction: <code>preorder</code> only yielded <code>tree.key</code> or what <code>preorder</code> yielded). But indeed OP seems to want a list of nodes so I've edited for <code>yield tree</code>.</span>
<span class="comment-copy">Thanks very much for the replies. I'm using python v3.4, I didn't get the yield expression working, Im still a bit lost between iterators and generators... Anyway this 'if not tree return empty list' fixes the problem I was having with 'can not + NoneType'</span>
<span class="comment-copy">Thanks for your reply works perfectly. Just wandering if its not a binary tree how can I loop over all the children e.g.     def preorder(tree):         if tree:             return [tree.key] + [preorder(child, msg) for child in tree.children]</span>
<span class="comment-copy">@DamianSavage Yeah, but using list comprehension here would lead to a list of lists, since each <code>preorder</code> call returns a list. You can use a loop to to achieve this. I'll update my answer with that.</span>
<span class="comment-copy">that's exactly what I was looking for, thanks :)</span>
<span class="comment-copy">Instead of explicitly looping you can use <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer"><code>sum</code></a>: <code>return sum((preorder(child) for child in tree.children), [tree.key])</code>.</span>
