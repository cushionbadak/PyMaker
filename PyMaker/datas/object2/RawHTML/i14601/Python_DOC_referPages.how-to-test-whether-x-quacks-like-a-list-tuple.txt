<div class="post-text" itemprop="text">
<p>How do we test whether X quacks like a list/tuple?</p>
<p>By that I mean we can possibly subset it by 0 and 1 (etc), though it cannot be a string (which could also be subset).</p>
<p>I thought to test <code>hasattr(X, '__iter__')</code> and <code>not isinstance(X, str)</code>, but that would mean a dictionary would still pass which I do not want it to. You could then also test it is not a dictionary, but I wouldn't be so sure about sublasses of dicts etc.</p>
<p>Is there a more official way to test whether something quacks like a list or tuple under this simple specification?</p>
<p>E.g. allowed input should be:</p>
<pre><code>'emailaddr' --&gt; ('emailaddr', 'emailaddr')
('emailaddr', 'alias')
['emailaddr', 'alias']
SequenceThing('emailaddr', 'alias')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Would you like to check if a value is a <a href="https://docs.python.org/3/glossary.html#term-sequence" rel="nofollow">sequence</a>?</p>
<blockquote>
<p>An iterable which supports efficient element access using integer indices via the <strong>getitem</strong>() special method and defines a <strong>len</strong>() method that returns the length of the sequence. Some built-in sequence types are list, str, tuple, and bytes. Note that dict also supports <strong>getitem</strong>() and <strong>len</strong>(), but is considered a mapping rather than a sequence because the lookups use arbitrary immutable keys rather than integers.</p>
</blockquote>
<p>Old way (deprecated in 2.7):</p>
<pre><code>import operator
print operator.isSequenceType(x)
</code></pre>
<p>New way:</p>
<pre><code>import collections
print isinstance(x, collections.Sequence)
</code></pre>
<p>They are not equivalent - the latter is more accurate but custom types need to be <a href="https://docs.python.org/2/library/abc.html#abc.ABCMeta.register" rel="nofollow">registered</a> withÂ it.</p>
<p>Also, strings are sequences according to both definitions. You might want to treat <code>basestring</code> specially.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't allow a bare string as an argument; it's a special case waiting to bite you. Instead, document that the input must be in the form of a tuple/list/whatever, but the second element is optional. That is,</p>
<pre><code>['emailaddr', ]
('emailaddr', )
SequenceThing('emailaddr')
</code></pre>
<p>are legal, but not</p>
<pre><code>'emailaddr'
</code></pre>
<p>This way, your function can assume that <code>X[0]</code> will be an email address, and <code>X[1]</code> may exist and be an alias, but it is the user's problem if they supply something else.</p>
</div>
<div class="post-text" itemprop="text">
<p>Duck typing means you just do want you want to do, and if it doesn't work it means you're not dealing with a duck.</p>
<p>If you specifically don't want to get strings, check for strings and raise an exception.</p>
<p>And then do whatever you want to do, no type checking.</p>
</div>
<div class="post-text" itemprop="text">
<p>A solution based on Kevin's useful comment:</p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; isinstance([], collections.Sequence) and not isinstance([], str)
True
&gt;&gt;&gt; isinstance((), collections.Sequence) and not isinstance((), str)
True
&gt;&gt;&gt; isinstance('', collections.Sequence) and not isinstance('', str)
False
&gt;&gt;&gt; isinstance({}, collections.Sequence) and not isinstance({}, str)
False
&gt;&gt;&gt; isinstance(set(), collections.Sequence) and not isinstance(set(), str)
False
</code></pre>
<p>Mappings such as dicts and sets will not pass the first test. Strings will, but they will obviously fail on the second test.</p>
</div>
<span class="comment-copy">What benefit will you gain from the (duck) type check?</span>
<span class="comment-copy">Seems to me that a string is effectively/informally a tuple anyway. Can you give a practical example of a function where you would want to accept <code>('a', 'b', 'c')</code> as an argument, but reject <code>'abc'</code>?</span>
<span class="comment-copy">I want to have an <code>('emailaddr@something', 'alias')</code> tuple, but also accept a list. I'd look up <code>X[0]</code> to get the email, and <code>X[1]</code> to get the alias. If only a string is given rather than a list or tuple, I'd assume the emailaddress is given and the alias should be equal to the emailaddress (if you can still follow, that would make <code>(X, X)</code>)</span>
<span class="comment-copy">@PascalvKooten quacks = "functions as" .... i misunderstood</span>
<span class="comment-copy">@PascalvKooten: check if the value is a string.  If so, use it as a string.  Otherwise, access the [0] and [1] elements and use them.  If you get an exception, you get an exception.  No need to check first.</span>
<span class="comment-copy">Yea, that seems to work.</span>
<span class="comment-copy">Exactly, you throw the animal inside of the function, and if no exception is raised, then you got your duck!</span>
<span class="comment-copy">Python 3 can also use isinstance(x, collections.Iterable)</span>
<span class="comment-copy">@JustinEngel Not for this case. Mappings are iterables, but not sequences, and the OP wants sequences alone.</span>
