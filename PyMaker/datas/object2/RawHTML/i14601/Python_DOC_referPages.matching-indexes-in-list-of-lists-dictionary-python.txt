<div class="post-text" itemprop="text">
<p>I have a dictionary containg a list of lists:</p>
<pre><code>d = [('Locus_1',
  [['&gt;Safr02', 'R', '104'],
   ['&gt;Safr03', 'G', '104'],
   ['&gt;Safr04', 'A', '104'],
   ['&gt;Safr10', 'A', '104'],
   ['&gt;Safr02', 'K', '110'],
   ['&gt;Safr03', 'T', '110'],
   ['&gt;Safr04', 'T', '110'],
   ['&gt;Safr10', 'T', '110']]),
 ('Locus_2',
  [['&gt;Safr01', 'C', '15'],
   ['&gt;Safr02', 'Y', '15'],
   ['&gt;Safr04', 'Y', '15'],
   ['&gt;Safr07', 'Y', '15'],
   ['&gt;Safr01', 'Y', '78'],
   ['&gt;Safr02', 'T', '78'],
   ['&gt;Safr04', 'T', '78'],
   ['&gt;Safr07', 'T', '78']])]
</code></pre>
<p>The dictionary is created with the following code:</p>
<pre><code>snp_file = open(sys.argv[2], 'r')
snps = csv.reader(snp_file, delimiter=',')

d = OrderedDict()

for row in snps:
    key = row[0]
    d.setdefault(key,[])
    d[key].append(row[1:])
</code></pre>
<p>The data can be found here: <a href="https://www.dropbox.com/sh/3j4i04s2rg6b63h/AADkWG3OcsutTiSsyTl8L2Vda?dl=0" rel="nofollow">https://www.dropbox.com/sh/3j4i04s2rg6b63h/AADkWG3OcsutTiSsyTl8L2Vda?dl=0</a></p>
<p>I have a (for me) bit of a complex task to do on this data, I want to split it up into several steps, but I am not sure how to do this:</p>
<p>I need to look at the data pairwise with regards to the Locus_X-name (I have a list of pairs in another file, but for this question, lets just say <code>Locus_1</code> and <code>Locus_2</code> is a pair).</p>
<p>So for the pair <code>Locus_1:Locus_2</code> I need to match the names at position 0 inside each locus-list (SafrXX). For those that are equal (So <code>Locus_1:Safr02-Locus_2:Safr02</code>), I need to compare the letters at position 1 - so for this example the letters would be: <code>R:Y</code>.</p>
<p>To make it even more tricky, I need to do this for all combinations of the value at position 2.</p>
<p>So the letters I need to compare in the above, would be:</p>
<pre><code>R:Y
R:T
K:Y
K:T
</code></pre>
<p>Now, I am not asking that you write a piece of code, that can actually do this, but just, what would be the most logical way to split up and approach this task? Is there something I can do first, so I do not have to do everything in a complicated multiple nested loop?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the problem is not good described here. Or better, the dependencies of the data you provided that would explain the output you need.</p>
<p>I played around a bit with your code, first I thought this is going to be simple by just using the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow">zip function</a> of python like this:</p>
<pre><code>import csv
from collections import OrderedDict

snp_file = open('data.txt', 'r')
snps = csv.reader(snp_file, delimiter=',')
d = OrderedDict()
for row in snps:
    key = row[0]
    d.setdefault(key,[])
    d[key].append(row[1:])

for left,right in zip(d['Locus_1'],d['Locus_2']):
    print(left,right)
</code></pre>
<p>That gave me the following output, which won't help you either, since the first colums are unsorted AND do not match:</p>
<pre><code>['&gt;Safr02', 'R', '104'] ['&gt;Safr01', 'C', '15']
['&gt;Safr03', 'G', '104'] ['&gt;Safr02', 'Y', '15']
['&gt;Safr04', 'A', '104'] ['&gt;Safr04', 'Y', '15']
['&gt;Safr10', 'A', '104'] ['&gt;Safr07', 'Y', '15']
['&gt;Safr02', 'K', '110'] ['&gt;Safr01', 'Y', '78']
['&gt;Safr03', 'T', '110'] ['&gt;Safr02', 'Y', '78']
['&gt;Safr04', 'T', '110'] ['&gt;Safr04', 'T', '78']
['&gt;Safr10', 'T', '110'] ['&gt;Safr07', 'T', '78']
</code></pre>
<p>Adding a sort to the script like this didn't help again, since the lists are equal in length, but the first keys do not match up in your data:</p>
<pre><code>loc1 = sorted(d['Locus_1'], key=lambda lst: lst[0]): 
loc2 = sorted(d['Locus_2'], key=lambda lst: lst[0]): 

for left,right in zip(loc1,loc2):
    print(left,right)
</code></pre>
<p>Which puts the following to screen:</p>
<pre><code>['&gt;Safr02', 'R', '104'] ['&gt;Safr01', 'C', '15']
['&gt;Safr02', 'K', '110'] ['&gt;Safr01', 'Y', '78']
['&gt;Safr03', 'G', '104'] ['&gt;Safr02', 'Y', '15']
['&gt;Safr03', 'T', '110'] ['&gt;Safr02', 'Y', '78']
['&gt;Safr04', 'A', '104'] ['&gt;Safr04', 'Y', '15']
['&gt;Safr04', 'T', '110'] ['&gt;Safr04', 'T', '78']
['&gt;Safr10', 'A', '104'] ['&gt;Safr07', 'Y', '15']
['&gt;Safr10', 'T', '110'] ['&gt;Safr07', 'T', '78']
</code></pre>
<p>So I switched to nested loops to see if I can grasp a bit more of how your data is to handle:</p>
<pre><code>for l1 in loc1:
    for l2 in loc2:
        if l1[0] == l2[0]:
            print('{}-{}({}):{}({})'.format(l1[0],l1[1],l1[2],l2[1],l2[2]))
</code></pre>
<p>But that doesn't give me a clue either, but see yourself (output is brief cause I still do not grasp the gist):</p>
<pre><code>&gt;Safr02-R(104):Y(15)
&gt;Safr02-R(104):Y(78)
&gt;Safr02-K(110):Y(15)
&gt;Safr02-K(110):Y(78)
&gt;Safr04-A(104):Y(15)
&gt;Safr04-A(104):T(78)
&gt;Safr04-T(110):Y(15)
&gt;Safr04-T(110):T(78)
</code></pre>
<p>So you see, if you do it in a nested loop, you will get fairly easy to your goal - at least one step nearer to it. But you seem to search for a logic that is needed to handle the data correctly, without telling us the logic, that is behind your data. </p>
<p>With the code you can already match the lists and compare the letters in field1 by the match of field2 for all combinations of this, but how the numbers of field3 are supposed to affect your output is unclear to me.</p>
<p>Anyway, I hope this helps at least a little.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution. Substitute the <code>pair</code> variable for whatever pair locus-pair you want to check. I added the index of the rows into the tuples, incase the ordering is important.</p>
<pre><code>import csv

snp_file = open('input.txt', 'r')
snps = csv.reader(snp_file, delimiter=',')
pair=(1,2)#the choosen pair

dic={}
i=0
for row in snps:
    if row==[]: break
    locus=int(row[0][len('locus_'):])
    safr=int(row[1][len('&gt;safr'):])
    letter=row[2]
    number=row[3]
    index=i
    if (locus, safr) in dic:
        dic[locus, safr].append((letter, number, index))
    else:
        dic[locus, safr]=[(letter, number, index)]
    i+=1

for key in dic:
    if key[0]==pair[0] and (pair[1], key[1]) in dic:
        for e in dic[key]:
            for f in dic[pair[1], key[1]]:
                print e, ' ', f
</code></pre>
<p>This gives the following output:</p>
<pre><code>('R', '104', 0)   ('Y', '15', 9)
('R', '104', 0)   ('T', '78', 13)
('K', '110', 4)   ('Y', '15', 9)
('K', '110', 4)   ('T', '78', 13)
('A', '104', 2)   ('Y', '15', 10)
('A', '104', 2)   ('T', '78', 14)
('T', '110', 6)   ('Y', '15', 10)
('T', '110', 6)   ('T', '78', 14)
</code></pre>
</div>
<span class="comment-copy">Could you post a line of what your output should look like? Looking at your data, there is no clear depency for the lines, other than the first field.</span>
