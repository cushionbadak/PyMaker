<div class="post-text" itemprop="text">
<p>I have a subprocess running:</p>
<pre><code>cmd="bin/candc --models models"
subprocess.check_output('{} | tee /dev/stderr'.format( cmd ), shell=True,cwd=os.path.abspath('candc'))
</code></pre>
<p>and i want to be able to insert more commands that is recognized only by the currently running subprocess.<br/>
note that there must be a <code>cwd=os.path.abspath('candc')</code> parameter so that the subprocess would be called from outside of the binary folder, otherwise it won't run.<br/>
<strong><a href="http://svn.ask.it.usyd.edu.au/trac/candc/wiki/Documentation" rel="nofollow">C&amp;C</a></strong> is a NLP library and what it is actually going to do is to parse a given sentence. I want to be able to pass a sentence to the subprocess. how can I do this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think what you're asking is how to pass commands to the standard input of <code>candc</code>, as if you'd run it on the command line and typed commands on its interface.</p>
<hr/>
<p>If you can pass all the commands at once as one big string (presumably joined by newlines), you can do that with the <code>input</code> parameter, as shown in the examples in the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow"><code>check_output</code></a> docs:</p>
<pre><code>cmd="bin/candc --models models"
commands="""first candc command
second candc command
third candc command
"""
subprocess.check_output('{} | tee /dev/stderr'.format(cmd), shell=True,
                        cwd=os.path.abspath('candc'),
                        input=commands)
</code></pre>
<p>If this is Python 3.x, you have to also use encoded bytes for <code>commands</code>, or add <code>universal_newlines=True</code> to make <code>check_output</code> do it for you. If your commands are pure ASCII, the former is easier; just change that line to <code>commands = b"""…</code>.</p>
<p>If this is an old enough version (I think that means 2.6/3.2, but I'm not sure—check the docs linked above), the <code>input</code> parameter didn't exist yet. In that case, you have three options:</p>
<ul>
<li>Install <a href="https://pypi.python.org/pypi/subprocess32/" rel="nofollow"><code>subprocess32</code></a> off PyPI, which backports the newer version of the library to older versions of Python.</li>
<li>Look at how the <a href="https://hg.python.org/cpython/file/default/Lib/subprocess.py#l588" rel="nofollow">current source</a> handles the <code>input</code> argument and do exactly the same thing yourself.</li>
<li><code>Popen.communicate</code> took an <code>input</code> argument before <code>check_output</code> did, so, you can just manually create a <code>Popen</code> and call <code>communicate</code> on it.</li>
</ul>
<p>The last one is basically just a simpler version of the second one… but it is a lot simpler. In fact, it's just a two-liner if you don't need all the extra complexity of handling timeouts and doing something with the output and so on:</p>
<pre><code>p = subprocess.Popen('{} | tee /dev/stderr'.format(cmd), shell=True,
                     cwd=os.path.abspath('candc'), stdin=PIPE)
p.communicate(commands)
</code></pre>
<hr/>
<p>If you need to send the commands interactively (wait for one response before sending the next), then <code>check_output</code> can't do that. It's just a convenience wrapper around the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow"><code>Popen</code></a> object. You will instead want to create a <code>Popen</code> object explicitly, then do <code>p.stdin.write</code> and <code>p.stdout.read</code> to communicate with it.</p>
<p>For example, a quick&amp;dirty version might be:</p>
<pre><code>p = subprocess.Popen('{} | tee /dev/stderr'.format(cmd), shell=True,
                     cwd=os.path.abspath('candc'), 
                     stdin=PIPE, stdout=PIPE)
for command in commands.splitlines():
    p.stdout.readline() # read and ignore a prompt
    p.stdin.write(command + '\n')
rc = p.wait()
if rc: raise SomeException() # this is the check in check_output
</code></pre>
<p>But that code can block if, say, the prompt is ever more than one line, or it isn't guaranteed to fit in one buffer, or…</p>
<p>In general, this can be very hard to get right. (Python itself didn't get it right in the <code>communicate</code> function until 3.2 or 3.3…) Especially if you don't understand what the docs are talking about with blocking the output pipe. So if that's really what you need, you may want to consider using a third-party library that's made for driving interactive command-line programs, like <a href="https://pexpect.readthedocs.org/en/latest/" rel="nofollow"><code>pexpect</code></a>, instead of doing it yourself.</p>
</div>
<span class="comment-copy">Why do you mean by "insert more commands"? You want to pass commands to <code>candc</code>'s standard input?</span>
<span class="comment-copy">yes. when the above subprocess is running, it is in the candc environment and is waiting to receive a sentence. so I simply want to pass any sentence.</span>
<span class="comment-copy">There's about 30 different things named <code>candc</code>, so I don't know which one you're using; it would help to put a link in the question. But the important part is: does it have an interactive prompt, that you want to use interactively (as in, you don't know what to send, or at least when to send the next thing, until you get the response/prompt)?</span>
<span class="comment-copy">this candc is an NLP library. yes it has an interactive prompt.</span>
<span class="comment-copy">If you want to send commands you need to use Popen</span>
<span class="comment-copy">this would be helpful if only it worked. by doing what you suggested I get this erorr : <code>TypeError: __init__() got an unexpected keyword argument 'input'</code></span>
<span class="comment-copy">@mid: If you check the docs I linked, it'll tell you what version of Python added each wrapper function and each argument to that wrapper. Or, if you told us what version of Python you're on, I could check it.</span>
<span class="comment-copy">I guess its because of python 2.7 that "input" is unexpected.</span>
<span class="comment-copy">@mid: OK, edited the answer to explain.</span>
<span class="comment-copy">thank you @abarnet1 for your time :)</span>
