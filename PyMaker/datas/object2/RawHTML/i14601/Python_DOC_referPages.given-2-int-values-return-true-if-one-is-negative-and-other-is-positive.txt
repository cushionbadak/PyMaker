<div class="post-text" itemprop="text">
<pre><code>def logical_xor(a, b): # for example, -1 and 1
    print (a &lt; 0) # evaluates to True
    print (b &lt; 0) # evaluates to False
    print (a &lt; 0 != b &lt; 0) # EVALUATES TO FALSE! why??? it's True != False
    return (a &lt; 0 != b &lt; 0) # returns False when it should return True

print ( logical_xor(-1, 1) ) # returns FALSE!

# now for clarification

print ( True != False) # PRINTS TRUE!
</code></pre>
<p>Could someone explain what is happening? I'm trying to make a one liner:</p>
<pre><code>lambda a, b: (a &lt; 0 != b &lt; 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All comparison operators in Python have the <a href="https://docs.python.org/3/reference/expressions.html#not-in">same precedence.</a> In addition, Python does chained comparisons. Thus, </p>
<pre><code>(a &lt; 0 != b &lt; 0)
</code></pre>
<p>breaks down as:</p>
<pre><code>(a &lt; 0) and (0 != b) and (b &lt; 0)
</code></pre>
<p>If any one of these is false, the total result of the expression will be <code>False</code>. </p>
<p>What you want to do is evaluate each condition separately, like so:</p>
<pre><code>(a &lt; 0) != (b &lt; 0)
</code></pre>
<p>Other variants, from comments:</p>
<pre><code>(a &lt; 0) is not (b &lt; 0) # True and False are singletons so identity-comparison works

(a &lt; 0) ^ (b &lt; 0) # bitwise-xor does too, as long as both sides are boolean

(a ^ b &lt; 0) # or you could directly bitwise-xor the integers; 
            # the sign bit will only be set if your condition holds
            # this one fails when you mix ints and floats though

(a * b &lt; 0) # perhaps most straightforward, just multiply them and check the sign
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><s>Your code doesn't work as intended because <code>!=</code> takes higher <a href="https://docs.python.org/2/reference/expressions.html#operator-precedence" rel="nofollow">precedence</a> than <code>a &lt; 0</code> and <code>b &lt; 0</code>. As itzmeontv suggests in his answer, you can simply decide the precedence yourself by surrounding logical components with parentheses:</s></p>
<pre><code>(a &lt; 0) != (b &lt; 0)
</code></pre>
<p>Your code attempts to evaluate <code>a &lt; (0 != b) &lt; 0</code></p></div>
<div class="post-text" itemprop="text">
<p>You can use this</p>
<pre><code>return (a &lt; 0) != (b &lt; 0)
</code></pre>
<blockquote>
<p>Comparisons can be chained arbitrarily, e.g., x &lt; y &lt;= z is equivalent to x &lt; y and y &lt;= z, except that y is evaluated only once (but in both cases z is not evaluated at all when x &lt; y is found to be false).</p>
</blockquote>
<p>So it becomes</p>
<pre><code>(a &lt; 0) and (0 != b) and (b &lt; 0)
</code></pre>
<p>See <a href="https://docs.python.org/3/reference/expressions.html#not-in" rel="nofollow">https://docs.python.org/3/reference/expressions.html#not-in</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, comparison operators are of the same precedence, and they are non-associative. There is a separate rule for sequences of comparison operators, the chaining rule. <a href="https://docs.python.org/3/reference/expressions.html#not-in" rel="nofollow">Python documentation</a> states about that:</p>
<blockquote>
<p>if <code>a, b, c, ..., y, z</code> are expressions and <code>op1, op2, ..., opN</code> are comparison operators, then a <code>op1 b op2 c ... y opN z</code> is equivalent to <code>a op1 b and b op2 c and ... y opN z</code>, except that each expression is evaluated at most once.  </p>
</blockquote>
<p>Further, <code>a op1 b and b op2 c and ... y opN z</code> evaluates left to right.  </p>
<pre><code> a &lt; 0 and 0 != b and b &lt; 0  
</code></pre>
<p><code>a &lt; 0</code> will evaluated to <code>False</code>, and the further evaluation will be stopped due to <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation" rel="nofollow">short-circuit evaluation</a>. So, the whole expression will be evaluated as <code>False</code>.</p>
</div>
<span class="comment-copy">There's a lesson to be learned here: Use parentheses. Or, alternatively, use <code>print (a*b &lt; 0)</code>.</span>
<span class="comment-copy"><code>return math.copysign(1, a) != math.copysign(1, b)</code></span>
<span class="comment-copy"><code>print ( True != False) # PRINTS TRUE!</code> why are you so surprised by that? It <i>is</i> true that true is not equal to false.</span>
<span class="comment-copy">@mikeTheLiar: The OP is <i>not</i> surprised by that; it's the behavior (s)he originally expected.</span>
<span class="comment-copy">Note that <code>(a &lt; 0) ^ (b &lt; 0)</code> also works, and it's using the xor operator. :) Alternatively, <code>(a &lt; 0) is not (b &lt; 0)</code>, since <code>True</code> and <code>False</code> are singletons, although some might object to that syntax: see here for a discussion: <a href="http://stackoverflow.com/q/9494404/4014959">stackoverflow.com/q/9494404/4014959</a></span>
<span class="comment-copy"><code>^</code> for <i>xor</i> does work if booleans are compared but it won't work for all values like <code>and</code> and <code>or</code> would...</span>
<span class="comment-copy">OP specifically tagged Python 3.x so I linked to Python 3 manuals.</span>
<span class="comment-copy"><code>(a ^ b) &lt; 0</code>……</span>
<span class="comment-copy">@supercat: Unfortunately python doesn't have a sign() method. One was proposed for the math package, but there wasn't agreement on edge-cases, so it wasn't integrated (according to a quick google). A workaround is using cmp(number, 0), which will return +1/0/-1. This would indeed work for the question</span>
<span class="comment-copy">They're actually the <b>same</b> precedence; the failure is because it's treated as a chained comparison. See <a href="https://docs.python.org/2/reference/expressions.html#not-in" rel="nofollow noreferrer">docs</a>.</span>
<span class="comment-copy">@Xis88: Yes, it's equivalent to  <code>(a &lt; 0) and (0 != b) and (b &lt; 0)</code>.</span>
<span class="comment-copy">Op specifically tagged Python 3 so please link to Python 3 manuals.</span>
<span class="comment-copy">why first one doesn't work?</span>
<span class="comment-copy">May be it of part of precedence of <code>!=</code> and <code>&lt;</code></span>
<span class="comment-copy"><code>&lt;&gt;</code> is not "considered obsolescent", it was removed from Python 3.0 altogether.</span>
<span class="comment-copy">(do note that OP tagged the question with [python-3.x])</span>
<span class="comment-copy">This is wrong! The documentation you're quoting right there states that the comparisons are chained. <i>NOT</i> the same thing as left-associative.</span>
<span class="comment-copy">@tzaman; You are right.</span>
