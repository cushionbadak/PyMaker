<div class="post-text" itemprop="text">
<p>What I was trying to achieve, was something like this:</p>
<pre><code>&gt;&gt;&gt; camel_case_split("CamelCaseXYZ")
['Camel', 'Case', 'XYZ']
&gt;&gt;&gt; camel_case_split("XYZCamelCase")
['XYZ', 'Camel', 'Case']
</code></pre>
<p>So I searched and found this <a href="https://stackoverflow.com/a/7599674/1654255">perfect regular expression</a>:</p>
<pre><code>(?&lt;=[a-z])(?=[A-Z])|(?&lt;=[A-Z])(?=[A-Z][a-z])
</code></pre>
<p>As the next logical step I tried:</p>
<pre><code>&gt;&gt;&gt; re.split("(?&lt;=[a-z])(?=[A-Z])|(?&lt;=[A-Z])(?=[A-Z][a-z])", "CamelCaseXYZ")
['CamelCaseXYZ']
</code></pre>
<p>Why does this not work, and how do I achieve the result from the linked question in python?</p>
<p><strong>Edit: Solution summary</strong></p>
<p>I tested all provided solutions with a few test cases:</p>
<pre><code>string:                 ''
nfs:                    ['']
casimir_et_hippolyte:   []
two_hundred_success:    []
kalefranz:              string index out of range # with modification: either [] or ['']

string:                 ' '
nfs:                    [' ']
casimir_et_hippolyte:   []
two_hundred_success:    [' ']
kalefranz:              [' ']

string:                 'lower'
all algorithms:         ['lower']

string:                 'UPPER'
all algorithms:         ['UPPER']

string:                 'Initial'
all algorithms:         ['Initial']

string:                 'dromedaryCase'
nfs:                    ['dromedary', 'Case']
casimir_et_hippolyte:   ['dromedary', 'Case']
two_hundred_success:    ['dromedary', 'Case']
kalefranz:              ['Dromedary', 'Case'] # with modification: ['dromedary', 'Case']

string:                 'CamelCase'
all algorithms:         ['Camel', 'Case']

string:                 'ABCWordDEF'
nfs:                    ['ABC', 'Word', 'DEF']
casimir_et_hippolyte:   ['ABC', 'Word', 'DEF']
two_hundred_success:    ['ABC', 'Word', 'DEF']
kalefranz:              ['ABCWord', 'DEF']
</code></pre>
<p>In summary you could say the solution by @kalefranz does not match the question (see the last case) and the solution by @casimir et hippolyte eats a single space, and thereby violates the idea that a split should not change the individual parts. The only difference among the remaining two alternatives is that my solution returns a list with the empty string on an empty string input and the solution by @200_success returns an empty list.
I don't know how the python community stands on that issue, so I say: I am fine with either one. And since 200_success's solution is simpler, I accepted it as the correct answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>As @nfs has explained, <code>re.split()</code> never splits on an empty pattern match.  Therefore, instead of splitting, you should try finding the components you are interested in.</p>
<p>Here is a solution using <code>re.finditer()</code> that emulates splitting:</p>
<pre><code>def camel_case_split(identifier):
    matches = finditer('.+?(?:(?&lt;=[a-z])(?=[A-Z])|(?&lt;=[A-Z])(?=[A-Z][a-z])|$)', identifier)
    return [m.group(0) for m in matches]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>re.sub()</code> and <code>split()</code></p>
<pre><code>import re

name = 'CamelCaseTest123'
splitted = re.sub('(?!^)([A-Z][a-z]+)', r' \1', name).split()
</code></pre>
<p>result</p>
<pre><code>['Camel', 'Case', 'Test123']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Most of the time when you don't need to check the format of a string, a global research is more simple than a split (for the same result):</p>
<pre><code>re.findall(r'[A-Z](?:[a-z]+|[A-Z]*(?=[A-Z]|$))', 'CamelCaseXYZ')
</code></pre>
<p>returns</p>
<pre><code>['Camel', 'Case', 'XYZ']
</code></pre>
<p>To deal with dromedary too, you can use:</p>
<pre><code>re.findall(r'[A-Z]?[a-z]+|[A-Z]+(?=[A-Z]|$)', 'camelCaseXYZ')
</code></pre>
<p>Note: <code>(?=[A-Z]|$)</code> can be shorten using a double negation (a negative lookahead with a negated character class): <code>(?![^A-Z])</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow">documentation</a> for python's <code>re.split</code> says:</p>
<blockquote>
<p>Note that split will never split a string on an empty pattern match.</p>
</blockquote>
<p>When seeing this:</p>
<pre><code>&gt;&gt;&gt; re.findall("(?&lt;=[a-z])(?=[A-Z])|(?&lt;=[A-Z])(?=[A-Z][a-z])", "CamelCaseXYZ")
['', '']
</code></pre>
<p>it becomes clear, why the split does not work as expected. The <code>re</code>module finds empty matches, just as intended by the regular expression.</p>
<p>Since the documentation states that this is not a bug, but rather intended behavior, you have to work around that when trying to create a camel case split:</p>
<pre><code>def camel_case_split(identifier):
    matches = finditer('(?&lt;=[a-z])(?=[A-Z])|(?&lt;=[A-Z])(?=[A-Z][a-z])', identifier)
    split_string = []
    # index of beginning of slice
    previous = 0
    for match in matches:
        # get slice
        split_string.append(identifier[previous:match.start()])
        # advance index
        previous = match.start()
    # get remaining string
    split_string.append(identifier[previous:])
    return split_string
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I just stumbled upon this case and wrote a regular expression to solve it. It should work for any group of words, actually.</p>
<pre><code>RE_WORDS = re.compile(r'''
    # Find words in a string. Order matters!
    [A-Z]+(?=[A-Z][a-z]) |  # All upper case before a capitalized word
    [A-Z]?[a-z]+ |  # Capitalized words / all lower case
    [A-Z]+ |  # All upper case
    \d+  # Numbers
''', re.VERBOSE)
</code></pre>
<p>The key here is the <em>lookahead</em> on the first possible case. It will match (and preserve) uppercase words before capitalized ones:</p>
<pre><code>assert RE_WORDS.findall('FOOBar') == ['FOO', 'Bar']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another solution that requires less code and no complicated regular expressions:</p>
<pre><code>def camel_case_split(string):
    bldrs = [[string[0].upper()]]
    for c in string[1:]:
        if bldrs[-1][-1].islower() and c.isupper():
            bldrs.append([c])
        else:
            bldrs[-1].append(c)
    return [''.join(bldr) for bldr in bldrs]
</code></pre>
<h2>Edit</h2>
<p>The above code contains an optimization that avoids rebuilding the entire string with every appended character. Leaving out that optimization, a simpler version (with comments) might look like</p>
<pre><code>def camel_case_split2(string):
    # set the logic for creating a "break"
    def is_transition(c1, c2):
      return c1.islower() and c2.isupper()

    # start the builder list with the first character
    # enforce upper case
    bldr = [string[0].upper()]
    for c in string[1:]:
        # get the last character in the last element in the builder
        # note that strings can be addressed just like lists
        previous_character = bldr[-1][-1]
        if is_transition(previous_character, c):
            # start a new element in the list
            bldr.append(c)
        else:
            # append the character to the last string
            bldr[-1] += c
    return bldr
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I know that the question added the tag of regex. But still, I always try to stay as far away from regex as possible. So, here is my solution without regex:</p>
<pre><code>def split_camel(text, char):
    if len(text) &lt;= 1: # To avoid adding a wrong space in the beginning
        return text+char
    if char.isupper() and text[-1].islower(): # Regular Camel case
        return text + " " + char
    elif text[-1].isupper() and char.islower(): # Detect Camel case in case of abbreviations
        return text[:-1] + " " + text[-1] + char
    else: # Do nothing part
        return text + char

text = "PathURLFinder"
text = reduce(split_camel, a, "")
print text
# prints "Path URL Finder"
print text.split(" ")
# prints "['Path', 'URL', 'Finder']"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think below is the optimim </p>
<p>Def count_word():
    Return(re.findall(‘[A-Z]?[a-z]+’, input(‘please enter your string’))</p>
<p>Print(count_word())</p>
</div>
<span class="comment-copy">Other Qs to do what you're trying to do: <a href="http://stackoverflow.com/q/21326963/1578604">first</a>, <a href="http://stackoverflow.com/q/17361768/1578604">second</a> and I'm pretty sure there are others.</span>
<span class="comment-copy">How is it <code>ABC</code> CamelCase?!</span>
<span class="comment-copy">@Mihai I do not understand your question. If you wonder how the regex performs on <code>"ABCCamelCase"</code>, it works as expected: <code>['ABC', 'Camel', 'Case']</code>. If you interpreted <code>ABC</code> to stand for <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">AbstractBaseClass</a>, then I am sorry for the confusion, as <code>ABC</code> is just three arbitrary uppercase letters in my question.</span>
<span class="comment-copy">Read <a href="http://stackoverflow.com/questions/5020906#9283563">my answer to a similar question</a>.</span>
<span class="comment-copy">Also a good answer, but I did not find the question as the wording was too specific for my search. Also your answer does not quite do what is asked for here, as it produces a converted string with an arbitrary separation character which you would need to split with <code>str.split(' ')</code>, instead of a (more versatile) list of its parts.</span>
<span class="comment-copy">I found one difference (according to my test cases) between your solution and mine: <code>camel_case_split("")</code> returns <code>[]</code>in your case and <code>[""]</code> in mine. The question is, which of those you would rather consider to be expected. Since either one works in my application, I consider this to be a valid answer!</span>
<span class="comment-copy">Another question that remains, is whether this, or my proposed solution performs better. I am no expert on the complexity of regular expressions, so this would have to be evaluated by someone else.</span>
<span class="comment-copy">Our regexes are basically the same, except that mine starts with a <code>.+?</code> that captures the text instead of discarding it, and ends with a <code>$</code> to make it go all the way to the end. Neither change changes the search strategy.</span>
<span class="comment-copy">Doesn't support digits.  For example, <code>"L2S"</code> is not split into <code>["L2", "S"]</code> .  Use <code>[a-z0-9]</code> rather than <code>[a-z]</code> in the above regular expression to fix this.</span>
<span class="comment-copy">@Neapolitan The question seemed not to want a split there.</span>
<span class="comment-copy">Does not correctly split <code>"camelCase"</code> as it returns <code>['Case']</code> only.</span>
<span class="comment-copy">@SheridanVespo: This is a way only for camel, not for dromedary (as asked). But it's possible to do it in the same way with few changes.</span>
<span class="comment-copy">I was not aware that there is something with the name of dromedary case. Since the <a href="https://en.wikipedia.org/wiki/CamelCase" rel="nofollow noreferrer">wikipedia page for camel case</a> does not mention it, I must assume it is not a commonly known term. Nevertheless, your code seems to work just as requested. Since your regex includes one lookaround and "mine" contains 4, I assume yours is more efficient. Is that correct?</span>
<span class="comment-copy">@SheridanVespo: Yes "dromedary-case" doesn't exist, but since the dromedary has only one hump, and the camel two... About efficiency: it is not the pattern itself but all the code after that you avoid since you obtain directly the list of strings you want. About lookarounds in general: lookarounds do not come straight from hell and are not so slow (they can slow down a pattern only if they are badly used). As I was saying to an other SO user there's a few minutes, there are cases where you can optimize a pattern with lookaheads.</span>
<span class="comment-copy">I like this one because it's clearer, and it does a better job for "strings people enter in real-life" like <code>URLFinder</code> and <code>listURLReader</code>.</span>
<span class="comment-copy">Your code fails on something like <code>camel_case_split("XYZCamelCase")</code> which was specifically requested in the question I linked and is therefore also part of my question.</span>
<span class="comment-copy">Also: Could you please add comments to your code to make it easier to see what it actually does?</span>
<span class="comment-copy">@SheridanVespo I think the first version may have had an extraneous <code>)</code> that you caught and corrected for me :)</span>
<span class="comment-copy">I found another case, where the behavior of your code differs from the requested behavior: Whenever a string starts with a lower case letter, that letter will be converted to upper case. As a <b>split</b> function should not change anything, I consider this to be a bug. While that could be easily corrected, the problem from my first comment remains.</span>
<span class="comment-copy">@SheridanVespo Apparently there are <a href="https://en.wikipedia.org/wiki/CamelCase" rel="nofollow noreferrer">varied definitions</a> for camel case. Some definitions (and the one I was originally assuming) enforce the first letter being capitalized. No worries; the "bug" is an easy fix.  Just remove the <code>.upper()</code> call when initializing the list.</span>
<span class="comment-copy">Can you elaborate please?</span>
