<div class="post-text" itemprop="text">
<p>I want to efficiently find the intersection of two lists , keeping duplicates from <strong>both</strong>, e.g. A=[1,1,2,3], B=[1,1,2,4] should return [1,1,1,1,2]</p>
<p>I know a similar question was asked previously (<a href="https://stackoverflow.com/questions/26663371/python-intersection-of-two-lists-keeping-duplicates">Python intersection of two lists keeping duplicates</a>)
however this does not help me because only the duplicates from one list are retained.</p>
<p>The following works</p>
<pre><code>def intersect(A,B):
    C=[]
    for a in A:
        for b in B:
            if a==b:
                C.append(a)
    return C
</code></pre>
<p>however it isn't efficient enough for what I'm doing! To speed things up I tried sorting the lists</p>
<pre><code>def intersect(A,B):
    A.sort()
    B.sort()
    C=[]
    i=0
    j=0
    while i&lt;len(A) and j&lt;len(B):
        if A[i]&lt;=B[j]:
            if A[i]==B[j]: 
                C.append(A[i])
            i+=1
        else:
            j=j+1
    return C
</code></pre>
<p>however this only keeps the duplicates from list B. Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is the answer to your question as asked:</p>
<pre><code>import collections
for A,B,expected_output in (
    ([1,1,2,3], [1,1,2,4], [1,1,1,1,2]),
    ([1,1,2,3], [1,2,4], [1,1,2])):
    cntA = collections.Counter(A)
    cntB = collections.Counter(B)
    output = [
        x for x in sorted(set(A) &amp; set(B)) for i in range(cntA[x]*cntB[x])]
    assert output == expected_output
</code></pre>
<p>Here is the answer to the question as originally interpreted by myself and two others:</p>
<pre><code>import collections
A=[1,1,2,3]
B=[1,1,2,4]
expected_output = [1,1,1,1,2,2]
cntA = collections.Counter(A)
cntB = collections.Counter(B)
cnt_sum = collections.Counter(A) + collections.Counter(B)
output = [x for x in sorted(set(A) &amp; set(B)) for i in range(cnt_sum[x])]
assert output == expected_output
</code></pre>
<p>You can find the <code>collections.Counter()</code> documentation <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow">here</a>. <code>collections</code> is a great module and I highly recommend giving the documentation on the whole module a read.</p>
<p>I realized you don't actually need to find the intersection of the sets, because the "count of a missing element is zero" according to the documentation:</p>
<pre><code>import collections
for A,B,expected_output in (
    ([1,1,2,3], [1,1,2,4], [1,1,1,1,2]),
    ([1,1,2,3], [1,2,4], [1,1,2])):
    cntA = collections.Counter(A)
    cntB = collections.Counter(B)
    output = [
        x for x in sorted(set(A)) for i in range(cntA[x]*cntB[x])]
    assert output == expected_output
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>a_set = set(A)
b_set = set(B)
intersect = [i for i in A if i in b_set] + [j for j in B if j in a_set]
</code></pre>
<p>Two list comprehensions concatenated.  A bit of extra time and memory is used to create sets of A and B, but that will be more than offset by the efficiency of checking membership of items in a set vs list.</p>
<p>You could also spruce it up a bit:</p>
<pre><code>set_intersect = set(A) &amp; set(B)
list_intersect = [ele for ele in A+B if ele in set_intersect]
</code></pre>
<p>Coerce both lists to sets, take their intersection, then use a list comprehension to add all elements from both lists A and B if they appear in the set intersection.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm having a hard time speeding your code since I don't know what are you running it on. It makes a lot of difference whether you run it on small or large lists and how many distinct elements are there. Anyway, here are some suggestions:</p>
<p>1.</p>
<pre><code>def intersect(a, b):
    count_a = Counter(a)
    count_b = Counter(b)
    count_mul = []
    for i in count_a:
        count_mul.extend([i] * (count_a[i] * count_b[i]))
    return count_mul
</code></pre>
<p>2.</p>
<p>This returns an iterator, you can use <code>list(iterator)</code> to turn it into a list</p>
<pre><code>def intersect(a, b):
    count_a = Counter(a)
    count_b = Counter(b)
    count_mul = Counter()
    for i in count_a:
        count_mul[i] += count_a[i] * count_b[i]
    return count_mul.elements()
</code></pre>
<p>3.</p>
<p>Very similar to your way but without changing the size of the list which takes time.</p>
<pre><code>def intersect(A, B):
    return [a for a in A for b in B if a == b]
</code></pre>
<p>I'm not sure this gives any improvement to your original way, it really depends on the inputs, but your way is <code>O(n*m)</code> and mine is <code>O(n+m)</code>.</p>
<p>You can use the module <code>timeit</code> to check how fast it runs on your input:</p>
<pre><code>from timeit import timeit
timeit('test.intersect(A, B)', 'import test; A = [1,1,2,3]; B = [1,1,2,4]')
</code></pre>
</div>
<span class="comment-copy">Just to clarify by "intersection of the lists" here you mean "if an item occurs N times in list A and M times in list B, it should occur N+M times in the new list, but if it either N or M is zero then it should occur zero times in the new list"?  (That is an unusual use of the term "intersection".)</span>
<span class="comment-copy">You have 4 <code>1</code>'s in the result because there are 2 in <code>A</code> and 2 in <code>B</code>, so why does the result not have two <code>2</code>s?</span>
<span class="comment-copy">I realized my above interpretation is incorrect based on your data.  Why do you have only one 2 in the example result, but four 1s?</span>
<span class="comment-copy">The reason there are four 1s there is because each 1 in list A is matched with the 1s in list B, whereas the 2 in list A is matched uniquely to the 2 in list B. Another example is A=[1,1,2,3], B=[1,2,4] should return [1,1,2]</span>
<span class="comment-copy">Are you working with large lists, or are you working with small lists but many intersections? Are there many repeating elements in your lists? Please show some examples for the time.</span>
<span class="comment-copy">I want the code to do the same job as the first piece of code in the question but more efficiently, the expected output is [1,1,1,1,2]</span>
<span class="comment-copy">@user141647 I edited the answer.</span>
<span class="comment-copy"><code>cnt_sum</code> is redundant in the first one</span>
<span class="comment-copy">@EllaShar Yes, definitely do xrange instead of range if Python2. I assumed Python3, but question just tagged Python.</span>
<span class="comment-copy">@EllaShar: As a rule of thumb, it's preferable to provide an answer that works with both Python 2 and Python 3, especially when the version is not stated or tagged in the question.</span>
<span class="comment-copy">this gives [1,1,1,1,2,2] for the example I gave, not [1,1,1,1,2]</span>
<span class="comment-copy">the inputs will be tuples of length 3 consisting of large integers</span>
