<div class="post-text" itemprop="text">
<p>I made a big mistake, when I choose the way of dumping data;
Now I have a text file, that consist of</p>
<pre><code>{ "13234134": ["some", "strings", ...]}{"34545345": ["some", "strings", ...]} ..so on
</code></pre>
<p>How can I read it into python?</p>
<p><strong>edit:</strong>
I have tried json,
when I add at begin and at end of file curly-braces manually, I have "ValueError: Expecting property name:", because "13234134" string maybi invalid for json, I do not know how to avoid it.</p>
<p><strong>edit1</strong></p>
<pre><code>with open('new_file.txt', 'w') as outfile:
    for index, user_id in enumerate(users):
        json.dump(dict = get_user_tweets(user_id), outfile)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Consider simply rewriting it to something that is valid json. If indeed your bad data only contains the format that you've shown (a series of json structures that are not comma-separated), then just add commas and square braces:</p>
<pre><code>with open('/tmp/sto/junk.csv') as f:
    data = f.read()

print(data)
s = "[ {} ]".format(data.strip().replace("}{", "},{"))
print(s)
import json
data = json.loads(s)
print(type(data))
</code></pre>
<p>Output:</p>
<pre><code>{ "13234134": ["some", "strings"]}{"34545345": ["some", "strings", "like", "this"]}

[ { "13234134": ["some", "strings"]},{"34545345": ["some", "strings", "like", "this"]} ]
&lt;class 'list'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It looks like what you have is an undelimited stream of JSON objects. As if you'd called <code>json.dump</code> over and over on the same file, or <code>''.join(json.dumps(…) for …)</code>. And, in fact, the first one is exactly what you did. :)</p>
<p>So, you're in luck. JSON is a self-delimiting format, which means you can read up to the end of the first JSON object, then read from there up to the end of the next JSON object, and so on. The <a href="https://docs.python.org/3/library/json.html#json.JSONDecoder.raw_decode" rel="nofollow"><code>raw_decode</code></a> method essentially does the hard part.</p>
<p>There's no stdlib function that wraps it up, and I don't know of any library that does it, but it's actually very easy to do yourself:</p>
<pre><code>def loads_multiple(s):
    decoder = json.JSONDecoder()
    pos = 0
    while pos &lt; len(s):
        pos, obj = decoder.raw_decode(s, pos)
        yield obj
</code></pre>
<p>So, instead of doing this:</p>
<pre><code>obj = json.loads(s)
do_stuff_with(obj)
</code></pre>
<p>… you do this:</p>
<pre><code>for obj in loads_multi(s):
    do_stuff_with(obj)
</code></pre>
<p>Or, if you want to combine all the objects into one big list:</p>
<pre><code>objs = list(loads_multi(s))
</code></pre>
</div>
<span class="comment-copy">How are you trying to read it in, and how is that succeeding or failing?</span>
<span class="comment-copy">Is your text file in JSON format?</span>
<span class="comment-copy">Is the only error the lack of commas between dictionaries/json elements? Are there nested sub dicts/json blocks?</span>
<span class="comment-copy">are they all on one line exactly as posted?</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/2835559/parsing-values-from-a-json-file-in-python">Parsing values from a JSON file in Python</a></span>
<span class="comment-copy">This is somewhat brittle; e.g., <code>}{</code> can appear in the middle of a string, in which case you'll break the string.</span>
<span class="comment-copy">@abarnert, entirely correct. I was assuming the strings were well-behaved. That'd get me fired if I was working with databases in real-life. I do hope the OP accepts your answer, you already have my upvote. Nevertheless I'll leave mine, because it will get repeated of course. And in x months from now, who will add the correct comment, pointing out the potential flaw?</span>
<span class="comment-copy">@OliverW., I will use this solution, because I only interested in normalized words of each user: my next step is deleting all non-letter symbols and creation vocabulary. Here is no matter is there curly-braces or not, they will be deleted. I can't say anything about correctness of this approach in common case. Thank you!</span>
<span class="comment-copy">Neat! Well explained too. Thanks.</span>
<span class="comment-copy">In case you're wondering, I've written this before because JSON-RPC over TCP is effectively your format (except you also have to deal with the possibility that you only have part of an object), and surprisingly nobody had really implemented it properly. At least in Python you can use <code>raw_decode</code>; for JavaScript and Ruby, I couldn't find a library that had an equivalent, and had to write my own…</span>
<span class="comment-copy">@abarnert, Thank you very much for explanation.</span>
