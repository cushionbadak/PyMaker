<div class="post-text" itemprop="text">
<p>Ipython Notebook doesn't seem to print results in real time, but seems to buffer in a certain way and then bulk output the prints. How can I make ipython print my results as soon as the print command is processed?</p>
<p><strong>Example code:</strong></p>
<pre><code>import time


def printer():
    for i in range(100):
        time.sleep(5)
        print i
</code></pre>
<p>Supposing that the above code is in a file that is imported. How could I make it that when I call the printer function it prints a number every 5 seconds and not all the numbers at the very end?</p>
<p>Please note that I cannot edit the function <code>printer()</code> because I get it from some external module. I want the to change the configs of ipython notebook somehow so that it doesn't use a buffer. Therefore, I also do not wish to use sys.stdout.flush(), I want to do it in real-time according to the question, I don't want any buffer to start with.</p>
<p>I also tried loading ipython notebook with the command:</p>
<pre><code>ipython notebook --cache-size=0
</code></pre>
<p>but that also doesn't seem to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.3, <code>print()</code> has an <a href="https://docs.python.org/3/library/functions.html#print" rel="noreferrer">additional flush</a> argument that can be used to force flushing:</p>
<pre><code>for i in range(10):
    print(i, flush=True)
    time.sleep(1)  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is merely <a href="https://stackoverflow.com/a/231216/420867">one of the answers</a> to the question suggested by <a href="https://stackoverflow.com/users/1071311/carsten">Carsten</a> incorporating the <code>__getattr__</code> delegation suggested by <a href="https://stackoverflow.com/users/234261/diedthreetimes">diedthreetimes</a> in a comment:</p>
<pre><code>import sys
oldsysstdout = sys.stdout
class flushfile():
    def __init__(self, f):
        self.f = f
    def __getattr__(self,name): 
        return object.__getattribute__(self.f, name)
    def write(self, x):
        self.f.write(x)
        self.f.flush()
    def flush(self):
        self.f.flush()
sys.stdout = flushfile(sys.stdout)
</code></pre>
<p>In the original answer, the <code>__getattr__</code> method is not implemented. Without that, it fails. Other variants in answers to that question also fail in a notebook. </p>
<p>In a notebook, <code>sys.stdout</code> is an instance of <code>IPython.kernel.zmq.iostream.OutStream</code> and has a number of methods and attributes not present in the usual <code>sys.stdout</code>. Delegating <code>__getattr__</code> allows a <code>flushfile</code> to masquerade as a <code>...zmq.iostream.OutStream</code> duck.</p>
<p>This works in a python 2.7 notebook run with ipython 3.1.0</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>from IPython.display import display, clear_output

display("Hello World") # print string
display(df) # print object such as dataframe

clear_output(wait=True) # use this if need to clear the output before display, good for dynamic updates
</code></pre>
</div>
<span class="comment-copy">Thanks. My question is slighly different. I don't want to change the function printer() because I get it though importing a module which I don't want to change. I simply want to change the behaviour of ipython. So the solutions proposed in the above question don't work for me because I can't add  sys.stdout.flush() to the function. What I want is that there be no buffer in ipython notebook. That it outputs everything automatically.</span>
<span class="comment-copy">You could monkeypatch the printer function.</span>
<span class="comment-copy">Possibly, but there should be a way to unbuffer ipython notebook stdout no?</span>
<span class="comment-copy">With the added requirement you can find <a href="http://stackoverflow.com/questions/230751/how-to-flush-output-of-python-print?rq=1">some answers here</a></span>
<span class="comment-copy">Thanks, but I couldn't really find anything that works.</span>
<span class="comment-copy">It's quite a work around, but thank you! I will try it.</span>
<span class="comment-copy">It works!! :) Thank you! I'll attribute the bounty in 2 days.</span>
<span class="comment-copy">Is this still the best workaround for Jupyter?</span>
