<div class="post-text" itemprop="text">
<p>Is there an established approach to embed gettext <code>locale/xy/LC_MESSAGES/*</code> in a <a href="https://www.python.org/dev/peps/pep-0441/"><strong>PYZ</strong> bundle</a>? Specifically to have Gtks automatic widget translation pick them up <em>from within</em> the ZIP archive.</p>
<p>For other embedded resources <code>pkgutil.get_deta</code> or <code>inspect</code>/<code>get_source</code> work well enough. But system <em>and</em> Python <a href="https://docs.python.org/3/library/locale.html">gettext APIs</a> depend on <code>bindtextdomain</code> being supplied a plain old <code>localedir</code>; no resources or strings etc.</p>
<p>So I couldn't contrive a workable or even remotely practical workaround:</p>
<ol>
<li><p><strong>Virtual <code>gvfs</code>/<code>gio</code> paths</strong><br/>
Now using <code>archive://file%3A%2F%2Fmypkg.pyz%2Fmessages%2F</code> IRIs would be an alternative to read other files directly from a zip. But <a href="https://github.com/GNOME/glib/blob/master/glib/ggettext.c">glibs g_dgettext</a> is still just a thin wrapper around the system lib. And therefore any such URLs can't be used as <code>localedir</code>.</p></li>
<li><p><strong>Partially extracting the zip</strong><br/>
That's how PyInstaller works I think. But it's of course somewhat ridiculous to bundle something as <em>.pyz</em> application, only to have it preextracted on each invocation.</p></li>
<li><p><strong>Userland gettext <code>.mo</code>/<code>.po</code> extraction</strong><br/>
Now reading out the message catalogues manually or just using trivial dicts instead would be an option. But only for in-application strings. That's again no way to have Gtk/GtkBuilder pick them up implicitly.<br/>
Thus I had to manually traverse the whole widget tree, Labels, text, inner widgets, markup_text, etc. Possible, but <em>meh</em>.</p></li>
<li><p><strong>FUSE mounting</strong><br/>
This would be superflaky. But of course, the zip contents could be accessed <code>gvfs-mount</code> etc. Just seems like a certain memory hog. And I doubt it's gonna stay reliable with e.g. two app instances running, or a previous uncleanly terminated. (Like dunno, due to a system library, like gettext, stumbling over a fragile zip fuse point..)</p></li>
<li><p><strong>Gtk signal/event for translation</strong>(?)<br/>
I've found squat <a href="http://faq.pygtk.org/index.py?req=show&amp;file=faq22.002.htp">about this</a>, so I'm somewhat certain there's no alternative mechanism for widget translations in Gtk/PyGtk/GI. Gtk/Builder expects and is <a href="https://github.com/GNOME/gtk/blob/master/gtk/gtkintl.h">tied to</a> gettext.</p></li>
</ol>
<p>Is there a more dependable approach perhaps? </p>
</div>
<div class="post-text" itemprop="text">
<p>This my example Glade/GtkBuilder/Gtk application. I've defined a function <code>xml_gettext</code> which transparently translates glade xml files and passes to <code>gtk.Builder</code> instance as a string.  </p>
<pre><code>import mygettext as gettext
import os
import sys

import gtk
from gtk import glade

glade_xml = '''&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;!-- interface-requires gtk+ 3.0 --&gt;
  &lt;object class="GtkWindow" id="window1"&gt;
    &lt;property name="can_focus"&gt;False&lt;/property&gt;
    &lt;signal name="delete-event" handler="onDeleteWindow" swapped="no"/&gt;
    &lt;child&gt;
      &lt;object class="GtkButton" id="button1"&gt;
        &lt;property name="label" translatable="yes"&gt;Welcome to Python!&lt;/property&gt;
        &lt;property name="use_action_appearance"&gt;False&lt;/property&gt;
        &lt;property name="visible"&gt;True&lt;/property&gt;
        &lt;property name="can_focus"&gt;True&lt;/property&gt;
        &lt;property name="receives_default"&gt;True&lt;/property&gt;
        &lt;property name="use_action_appearance"&gt;False&lt;/property&gt;
        &lt;signal name="pressed" handler="onButtonPressed" swapped="no"/&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;'''

class Handler:
    def onDeleteWindow(self, *args):
        gtk.main_quit(*args)

    def onButtonPressed(self, button):
       print('locale: {}\nLANGUAGE: {}'.format(
              gettext.find('myapp','locale'),os.environ['LANGUAGE']))

def main():
    builder = gtk.Builder()
    translated_xml = gettext.xml_gettext(glade_xml)
    builder.add_from_string(translated_xml)
    builder.connect_signals(Handler())

    window = builder.get_object("window1")
    window.show_all()

    gtk.main()

if __name__ == '__main__':
    main()  
</code></pre>
<p>I've archived my locale directories into <code>locale.zip</code> which is included in the <code>pyz</code> bundle.<br/>
This is contents of <code>locale.zip</code> </p>
<pre><code>(u'/locale/fr_FR/LC_MESSAGES/myapp.mo',
 u'/locale/en_US/LC_MESSAGES/myapp.mo',
 u'/locale/en_IN/LC_MESSAGES/myapp.mo')
</code></pre>
<p>To make the locale.zip as a filesystem I use ZipFS from <a href="https://pypi.python.org/pypi/fs/0.5.1" rel="nofollow">fs</a>.  </p>
<p>Fortunately Python <code>gettext</code> is not GNU gettext. <code>gettext</code> is pure Python it doesn't use GNU gettext but mimics it. <code>gettext</code> has two core functions <code>find</code> and <code>translation</code>. I've redefined these two in a seperate module named <code>mygettext</code> to make them use files from the <code>ZipFS</code>.  </p>
<p><code>gettext</code> uses <code>os.path</code> ,<code>os.path.exists</code> and <code>open</code> to find files and open them which I replace with the equivalent ones form <code>fs</code> module.  </p>
<p>This is contents of my application.  </p>
<pre><code>pyzzer.pyz -i glade_v1.pyz  
# A zipped Python application
# Built with pyzzer

Archive contents:
  glade_dist/glade_example.py
  glade_dist/locale.zip
  glade_dist/__init__.py
  glade_dist/mygettext.py
  __main__.py
</code></pre>
<p>Because <code>pyz</code> files have text, usually a shebang, prepended to it, I skip this line after opening the <code>pyz</code> file in binary mode. Other modules in the application that want to use the <code>gettext.gettext</code> function, should import <code>zfs_gettext</code> instead from <code>mygettext</code> and make it an alias to <code>_</code>.  </p>
<p>Here goes <code>mygettext.py</code>.  </p>
<pre><code>from errno import ENOENT
from gettext import _expand_lang, _translations, _default_localedir
from gettext import GNUTranslations, NullTranslations
import gettext
import copy
import os
import sys
from xml.etree import ElementTree as ET
import zipfile

import fs
from fs.zipfs import ZipFS


zfs = None
if zipfile.is_zipfile(sys.argv[0]):
    try:
        myself = open(sys.argv[0],'rb')
        next(myself)
        zfs = ZipFS(ZipFS(myself,'r').open('glade_dist/locale.zip','rb'))
    except:
        pass
else:
    try:
        zfs = ZipFS('locale.zip','r')
    except:
        pass
if zfs:
    os.path = fs.path
    os.path.exists = zfs.exists
    open = zfs.open

def find(domain, localedir=None, languages=None, all=0):

    # Get some reasonable defaults for arguments that were not supplied
    if localedir is None:
        localedir = _default_localedir
    if languages is None:
        languages = []
        for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
            val = os.environ.get(envar)
            if val:
                languages = val.split(':')
                break
                                                                                     if 'C' not in languages:
            languages.append('C')
    # now normalize and expand the languages
    nelangs = []
    for lang in languages:
        for nelang in _expand_lang(lang):
            if nelang not in nelangs:
                nelangs.append(nelang)
    # select a language
    if all:
        result = []
    else:
        result = None
    for lang in nelangs:
        if lang == 'C':
            break
        mofile = os.path.join(localedir, lang, 'LC_MESSAGES', '%s.mo' % domain)
        mofile_lp = os.path.join("/usr/share/locale-langpack", lang,
                               'LC_MESSAGES', '%s.mo' % domain)

        # first look into the standard locale dir, then into the 
        # langpack locale dir

        # standard mo file
        if os.path.exists(mofile):
            if all:
                result.append(mofile)
            else:
                return mofile

        # langpack mofile -&gt; use it
        if os.path.exists(mofile_lp): 
            if all:
                result.append(mofile_lp)
            else:
               return mofile

        # langpack mofile -&gt; use it
        if os.path.exists(mofile_lp): 
            if all:
                result.append(mofile_lp)
            else:
                return mofile_lp

    return result

def translation(domain, localedir=None, languages=None,
                class_=None, fallback=False, codeset=None):
    if class_ is None:
        class_ = GNUTranslations
    mofiles = find(domain, localedir, languages, all=1)
    if not mofiles:
        if fallback:
            return NullTranslations()
        raise IOError(ENOENT, 'No translation file found for domain', domain)
    # Avoid opening, reading, and parsing the .mo file after it's been done
    # once.
    result = None
    for mofile in mofiles:
        key = (class_, os.path.abspath(mofile))
        t = _translations.get(key)
        if t is None:
            with open(mofile, 'rb') as fp:
                t = _translations.setdefault(key, class_(fp))
        # Copy the translation object to allow setting fallbacks and
        # output charset. All other instance data is shared with the
        # cached object.
        t = copy.copy(t)
        if codeset:
            t.set_output_charset(codeset)
        if result is None:
            result = t
        else:
            result.add_fallback(t)
    return result

def xml_gettext(xml_str):
    root = ET.fromstring(xml_str)
    labels = root.findall('.//*[@name="label"][@translatable="yes"]')
    for label in labels:
        label.text = _(label.text)
    return ET.tostring(root)

gettext.find = find
gettext.translation = translation
_ = zfs_gettext = gettext.gettext

gettext.bindtextdomain('myapp','locale')
gettext.textdomain('myapp')
</code></pre>
<p>The following two shouldn't be called because <code>glade</code> doesn't use Python <code>gettext</code>.  </p>
<pre><code>glade.bindtextdomain('myapp','locale')
glade.textdomain('myapp')
</code></pre>
</div>
<span class="comment-copy">I have to admit I don't understand what you mean by "Glib is tightly chained to gettext". Those are just a couple of conveniency macros, absolutely nothing in GLib forces you to use them or gettext.</span>
<span class="comment-copy">Well of course. That's also what the glib documentation asserts ("doesn't force any particular localization method.."). In the context of Gtk, it's just not so much feasible. (Even if recompilation was an option, the macro schemes wouldn't permit e.g. ICU substitution easily). So if you're using anything but gettext, then you're stuck with translating all Gtk widgets iteratively.</span>
<span class="comment-copy">If your problem is GtkBuilder xml file localization being tied to gettext  (which seems a valid issue to me), you should clearly say so. When you imply that GLib (or Gtk application code) translation is somehow tied to gettext it makes the question harder to understand: I'm guessing I wasn't the only one scratching my head thinking "these things have no connection to how the translation is actually made: GTK widgets don't care about translation they just expect to get the translated string"...</span>
<span class="comment-copy">Fixed that note. I initially looked to glib for a workaround (gio paths and all), so suspected a workaround there. But the GtkBuilder UI file is an even better hint. Might be simpler to find an alternative to pretranslate its text nodes than looking for a widget hook.</span>
<span class="comment-copy">Is there an established approach to embed gettext locale/xy/LC_MESSAGES/* in a PYZ bundle?,   What 'established approach' means? You could or could not embed. If I understand it correctly, you want to include the <code>gettext</code> locale dir into the app pyz bundle. Right?</span>
<span class="comment-copy">Wow, lot of code. Still reading it through... Looks pretty practical. And moreover seems useful to other users too. I'm going to test it through.  --(Already seen the answer notification. So please ease up on the comment pinging!)</span>
<span class="comment-copy">Hey mario, you're super cool! Thank you very much. Happy coding!</span>
