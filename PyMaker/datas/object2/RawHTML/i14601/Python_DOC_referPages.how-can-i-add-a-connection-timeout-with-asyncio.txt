<div class="post-text" itemprop="text">
<p>I want to connect to a list of a lot of different sites very fast. 
Im using asyncio to do this in an asynchronous manner and now want to
add a timeout for when connections should be ignored if they take too long to respond. </p>
<p>How do I implement this?</p>
<pre><code>import ssl
import asyncio
from contextlib import suppress
from concurrent.futures import ThreadPoolExecutor
import time


@asyncio.coroutine
def run():
    while True:
        host = yield from q.get()
        if not host:
            break

        with suppress(ssl.CertificateError):
            reader, writer = yield from asyncio.open_connection(host[1], 443, ssl=True) #timout option?
            reader.close()
            writer.close()


@asyncio.coroutine
def load_q():
    # only 3 entries for debugging reasons
    for host in [[1, 'python.org'], [2, 'qq.com'], [3, 'google.com']]:
        yield from q.put(host)
    for _ in range(NUM):
        q.put(None)


if __name__ == "__main__":
    NUM = 1000
    q = asyncio.Queue()

    loop = asyncio.get_event_loop()
    loop.set_default_executor(ThreadPoolExecutor(NUM))

    start = time.time()
    coros = [asyncio.async(run()) for i in range(NUM)]
    loop.run_until_complete(load_q())
    loop.run_until_complete(asyncio.wait(coros))
    end = time.time()
    print(end-start)
</code></pre>
<p>(On a sidenote: Has somebody an idea how to optimize this?)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can wrap the call to <code>open_connection</code> in <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for"><code>asyncio.wait_for</code></a>, which allows you to specify a timeout:</p>
<pre><code>    with suppress(ssl.CertificateError):
        fut = asyncio.open_connection(host[1], 443, ssl=True)
        try:
            # Wait for 3 seconds, then raise TimeoutError
            reader, writer = yield from asyncio.wait_for(fut, timeout=3)
        except asyncio.TimeoutError:
            print("Timeout, skipping {}".format(host[1]))
            continue
</code></pre>
<p>Note that when <code>TimeoutError</code> is raised, the <code>open_connection</code> coroutine is also cancelled. If you don't want it to be cancelled (though I think you <em>do</em> want it to be cancelled in this case), you have wrap the call in <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.shield"><code>asyncio.shield</code></a>.</p>
</div>
<span class="comment-copy">You forgot to <code>yield from</code> the calls to <code>q.put(None)</code> inside <code>load_q</code>, so this code won't work as currently written.</span>
<span class="comment-copy">you don't need reader,writer here. You could use <code>asyncio.create_connection</code> with <code>Protocol</code> that does nothing (it closes the network connection as soon as it is established). Here's <a href="http://stackoverflow.com/a/20722204/4279">code example that I've tried on top million Alexa site list</a> (it might be slightly outdated e.g., it doesn't use some convience functions such as <code>asyncio.wait_for()</code>). It uses a single thread and opens upto <code>limit</code> ssl connections.</span>
<span class="comment-copy">but this will also make it a blocking call no? Like opening connections in normal loop one after other.</span>
<span class="comment-copy">@ali No, because all the calls to the <code>run</code> method are wrapped in an <code>asyncio.async</code> call, which means they all run concurrently.</span>
<span class="comment-copy">If the connection timeout needs to be inside another coroutine, see [<a href="https://stackoverflow.com/questions/28609534/python-asyncio-force-timeout/48546189#48546189](Python" title="python asyncio force timeout">stackoverflow.com/questions/28609534/â€¦</a> asyncio force timeout) about stacking <code>asyncio.ensure_future(asyncio.wait_for(create_connection()))</code></span>
