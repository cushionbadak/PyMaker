<div class="post-text" itemprop="text">
<p>I am given a number of iterables , I need to produces all the values in the first iterable, followed by all in the second, ... , all values in the last iterable alternatively. </p>
<p><strong>Example</strong> :</p>
<pre><code>for i in alternate('abcde','fg','hijk'): 
      print(i,end=' ')
</code></pre>
<p>It is expected to produce the values</p>
<pre><code>a f h b g i c
</code></pre>
<p>I know to print all the characters in sequence like</p>
<pre><code>'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'
</code></pre>
<p>Here is the code:</p>
<pre><code>def alternate(*args):
    for iterable in args:
        for item in iterable:
            yield item
</code></pre>
<p>But how do I yield them alternatively?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to terminate on shortest list use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a>:</p>
<blockquote>
<p>Make an iterator that aggregates elements from each of the iterables.</p>
</blockquote>
<pre><code>def alternate(*args):
    # note: python 2 - use izip_longest
    for iterable in zip(*args):
        for item in iterable:
            if item is not None:
                yield item
</code></pre>
<p>If you want to use all items use <a href="https://docs.python.org/2/library/itertools.html#itertools.izip_longest" rel="nofollow">itertools.izip_longest</a>:</p>
<blockquote>
<p>Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue.</p>
</blockquote>
<pre><code>def alternate(*args):
    # note: python 2 - use izip_longest
    for iterable in itertools.zip_longest(*args):
        for item in iterable:
            if item is not None:
                yield item
</code></pre>
<p>Note that it skips <code>None</code> values (can be changed with <code>fillvalue</code>).</p>
<p>Without <code>itertools</code>:</p>
<pre><code>def alternate(*args):
    max_len = max(map(len, args))
    for index in range(max_len):
        for lst in args:
            try:
                yield lst[index]
            except IndexError:
                continue
</code></pre>
<p>To stop on first "missing" item:</p>
<pre><code>def alternate(*args):
    index = 0
    while True:
        for lst in args:
            try:
                yield lst[index]
            except IndexError:
                return
        index += 1
</code></pre>
<p>And if you're using generators (or iterators) you'll get <code>StopIteration</code> when one of them is done, so you can use <code>iter</code> to create a general function:</p>
<pre><code>def alternate(*args):
    iters = [iter(lst) for lst in args]
    while True:
        for itr in iters:
            try:
                yield next(itr)
            except StopIteration:
                return
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will do what you want.  It works for any input, it won't trip up if one of the items is <code>None</code>.  It uses the builtin <code>itertools</code> module, and will work on python 3.x and python 2.7 with only the builtin python modules.  It is based on the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>roundrobin</code></a> function from the Python <code>itertools</code> documentation:</p>
<pre><code>from itertools import cycle

def roundrobin_shortest(*iterables):
    "roundrobin_shortest('ABCD', 'EF', 'GHI') --&gt; A E G B F H C"
    nexts = cycle(iter(it).__next__ for it in iterables)
    while True:
        try:
            for inext in nexts:
                yield inext()
        except StopIteration:
            break
</code></pre>
<p>This version works basically the same, but is a bit shorter:</p>
<pre><code>from itertools import chain, cycle

def roundrobin_shortest(*iterables):
    "roundrobin_shortest('ABCD', 'EF', 'GHI') --&gt; A E G B F H C"
    nexts = cycle(iter(it).__next__ for it in iterables)
    yield from chain.from_iterable(inext() for inext in nexts)
</code></pre>
<p>And a version without itertools:</p>
<pre><code>def roundrobin_shortest(*iterables):
    "roundrobin_shortest('ABCD', 'EF', 'GHI') --&gt; A E G B F H C"
    items = [iter(item) for item in iterables]
    while True:
       try:
           for it in items:
               yield next(it)
       except StopIteration:
           break
</code></pre>
<p>You can use any of these like so:</p>
<pre><code>&gt;&gt;&gt; for i in roundrobin_shortest('abcde','fg','hijk'): 
...     print(i, end=' ')
...
a f h b g i c 
</code></pre>
<p>Or here is a simpler one-liner</p>
<pre><code>&gt;&gt;&gt; from itertools import chain, cycle
&gt;&gt;&gt; iters = ('abcde','fg','hijk')
&gt;&gt;&gt; res = chain.from_iterable(j() for j in cycle(iter(j).__next__ for j in iters))
&gt;&gt;&gt; print(' '.join(res))
a f h b g i c
</code></pre>
</div>
<span class="comment-copy">What python version?</span>
<span class="comment-copy">@ReutSharabani Python 3.</span>
<span class="comment-copy">What's the expected output of <code>alternate('a', 'bcdefg', 'hijkl')</code> for instance?</span>
<span class="comment-copy">@JonClements a b h</span>
<span class="comment-copy">Can there be a way without using izip_longest(*args) ?</span>
<span class="comment-copy">@Hacker688 Why?</span>
<span class="comment-copy">@orlp Just asking</span>
<span class="comment-copy">@orlp I am working on python 3 and does it have itertools ??</span>
<span class="comment-copy">@Hacker688 <code>itertools</code> has been in the standard library since Python 2.3.</span>
<span class="comment-copy">Runtime error <a href="http://ideone.com/kcDNMI" rel="nofollow noreferrer">ideone.com/kcDNMI</a></span>
<span class="comment-copy">Fixed.  These versions are tested and work properly</span>
