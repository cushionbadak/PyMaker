<div class="post-text" itemprop="text">
<p>Given a string as user input to a Python function, I'd like to get a class object out of it if there's a class with that name in the currently defined namespace. Essentially, I want the implementation for a function which will produce this kind of result:</p>
<pre><code>class Foo:
    pass

str_to_class("Foo")
==&gt; &lt;class __main__.Foo at 0x69ba0&gt;
</code></pre>
<p>Is this, at all, possible?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Warning</strong>: <code>eval()</code> can be used to execute arbitrary Python code. You should <strong><em>never</em></strong> use <code>eval()</code> with untrusted strings. (See <em><a href="https://stackoverflow.com/q/661084/3357935">Security of Python's eval() on untrusted strings?</a></em>)</p>
</blockquote>
<p>This seems simplest.</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...     pass
... 
&gt;&gt;&gt; eval("Foo")
&lt;class '__main__.Foo'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This could work:</p>
<pre><code>import sys

def str_to_class(classname):
    return getattr(sys.modules[__name__], classname)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do something like:</p>
<pre><code>globals()[class_name]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You want the class <code>Baz</code>, which lives in module <code>foo.bar</code>. With Python 2.7,
you want to use <code>importlib.import_module()</code>, as this will make transitioning to Python 3 easier: </p>
<pre><code>import importlib

def class_for_name(module_name, class_name):
    # load the module, will raise ImportError if module cannot be loaded
    m = importlib.import_module(module_name)
    # get the class, will raise AttributeError if class cannot be found
    c = getattr(m, class_name)
    return c
</code></pre>
<p>With Python &lt; 2.7:</p>
<pre><code>def class_for_name(module_name, class_name):
    # load the module, will raise ImportError if module cannot be loaded
    m = __import__(module_name, globals(), locals(), class_name)
    # get the class, will raise AttributeError if class cannot be found
    c = getattr(m, class_name)
    return c
</code></pre>
<p>Use:</p>
<pre><code>loaded_class = class_for_name('foo.bar', 'Baz')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import sys
import types

def str_to_class(field):
    try:
        identifier = getattr(sys.modules[__name__], field)
    except AttributeError:
        raise NameError("%s doesn't exist." % field)
    if isinstance(identifier, (types.ClassType, types.TypeType)):
        return identifier
    raise TypeError("%s is not a class." % field)
</code></pre>
<p>This accurately handles both old-style and new-style classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've looked at how django handles this</p>
<p>django.utils.module_loading has this</p>
<pre><code>def import_string(dotted_path):
    """
    Import a dotted module path and return the attribute/class designated by the
    last name in the path. Raise ImportError if the import failed.
    """
    try:
        module_path, class_name = dotted_path.rsplit('.', 1)
    except ValueError:
        msg = "%s doesn't look like a module path" % dotted_path
        six.reraise(ImportError, ImportError(msg), sys.exc_info()[2])

    module = import_module(module_path)

    try:
        return getattr(module, class_name)
    except AttributeError:
        msg = 'Module "%s" does not define a "%s" attribute/class' % (
            module_path, class_name)
        six.reraise(ImportError, ImportError(msg), sys.exc_info()[2])
</code></pre>
<p>You can use it like <code>import_string("module_path.to.all.the.way.to.your_class")</code></p>
</div>
<div class="post-text" itemprop="text">
<p>In terms of arbitrary code execution, or undesired user passed names, you could have a list of acceptable function/class names, and if the input matches one in the list, it is eval'd.</p>
<p>PS: I know....kinda late....but it's for anyone else who stumbles across this in the future.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can do this. Assuming your classes exist in the global namespace, something like this will do it:</p>
<pre><code>import types

class Foo:
    pass

def str_to_class(s):
    if s in globals() and isinstance(globals()[s], types.ClassType):
            return globals()[s]
    return None

str_to_class('Foo')

==&gt; &lt;class __main__.Foo at 0x340808cc&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow">importlib</a> worked the best for me.</p>
<pre><code>import importlib

importlib.import_module('accounting.views') 
</code></pre>
<p>This uses <em>string dot notation</em> for the python module that you want to import.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really want to retrieve classes you make with a string, you should store (or properly worded, <em>reference</em>) them in a dictionary. After all, that'll also allow to name your classes in a higher level and avoid exposing unwanted classes.</p>
<p>Example, from a game where actor classes are defined in Python and you want to avoid other general classes to be reached by user input.</p>
<p>Another approach (like in the example below) would to make an entire new class, that holds the <code>dict</code> above. This would:</p>
<ul>
<li>Allow multiple class holders to be made for easier organization (like, one for actor classes and another for types of sound);</li>
<li>Make modifications to both the holder and the classes being held easier;</li>
<li>And you can use class methods to add classes to the dict. (Although the abstraction below isn't really necessary, it is merely for... <em>"illustration"</em>).</li>
</ul>
<p>Example:</p>
<pre><code>class ClassHolder(object):
    def __init__(self):
        self.classes = {}

    def add_class(self, c):
        self.classes[c.__name__] = c

    def __getitem__(self, n):
        return self.classes[n]

class Foo(object):
    def __init__(self):
        self.a = 0

    def bar(self):
        return self.a + 1

class Spam(Foo):
    def __init__(self):
        self.a = 2

    def bar(self):
        return self.a + 4

class SomethingDifferent(object):
    def __init__(self):
        self.a = "Hello"

    def add_world(self):
        self.a += " World"

    def add_word(self, w):
        self.a += " " + w

    def finish(self):
        self.a += "!"
        return self.a

aclasses = ClassHolder()
dclasses = ClassHolder()
aclasses.add_class(Foo)
aclasses.add_class(Spam)
dclasses.add_class(SomethingDifferent)

print aclasses
print dclasses

print "======="
print "o"
print aclasses["Foo"]
print aclasses["Spam"]
print "o"
print dclasses["SomethingDifferent"]

print "======="
g = dclasses["SomethingDifferent"]()
g.add_world()
print g.finish()

print "======="
s = []
s.append(aclasses["Foo"]())
s.append(aclasses["Spam"]())

for a in s:
    print a.a
    print a.bar()
    print "--"

print "Done experiment!"
</code></pre>
<p>This returns me:</p>
<pre><code>&lt;__main__.ClassHolder object at 0x02D9EEF0&gt;
&lt;__main__.ClassHolder object at 0x02D9EF30&gt;
=======
o
&lt;class '__main__.Foo'&gt;
&lt;class '__main__.Spam'&gt;
o
&lt;class '__main__.SomethingDifferent'&gt;
=======
Hello World!
=======
0
1
--
2
6
--
Done experiment!
</code></pre>
<p>Another fun experiment to do with those is to add a method that pickles the <code>ClassHolder</code> so you never lose all the classes you did :^)</p>
</div>
<span class="comment-copy">There are some useful answers here, but I found the answer to this question particularly useful: <a href="http://stackoverflow.com/questions/452969/does-python-have-an-equivalent-to-java-class-forname" title="does python have an equivalent to java class forname">stackoverflow.com/questions/452969/â€¦</a></span>
<span class="comment-copy">Beaware the ramification of using eval. You better make sure the string you passed in is not from user.</span>
<span class="comment-copy">Using eval() leaves the door open for arbitrary code execution, for security's sake it should be avoided.</span>
<span class="comment-copy">Eval does not leave the door open to anything. If you have malicious, evil users who might maliciously and evilly pass bad values to eval, they can just edit the python source. Since they can just edit the python source, the door is, was, and always will be open.</span>
<span class="comment-copy">Unless the program in question is running on a server.</span>
<span class="comment-copy">@s-lott I'm sorry, but I think you are giving very bad advice here. Consider: When your computer prompts you for a password, the evil, malicious user might just as well modify the corresponding executable or library and bypass this check. Therefore, one might argue that is is pointless to add password checks in the first place. Or is it?</span>
<span class="comment-copy">What will happen if the class does not exist?</span>
<span class="comment-copy">It will only work for the class defined in the current module</span>
<span class="comment-copy">Sorry to raise this answer from the dead. @luc is right, but we can replace last line with <code>return reduce(getattr, str.split("."), sys.modules[__name__])</code>. This will give the same effect as <code>eval()</code> but won't allow to run arbitrary code.</span>
<span class="comment-copy">Really nice solution: here you are not using  <b>import</b> but a more generic sys module.</span>
<span class="comment-copy">Would this be any different from <code>def str_to_class(str): return vars()[str]</code>?</span>
<span class="comment-copy">I like this better than the 'eval' solution because (1) it's just as easy, and (2) it doesn't leave you open to arbitrary code execution.</span>
<span class="comment-copy">but you're using <code>globals()</code>... another thing that should be avoided</span>
<span class="comment-copy">@Greg Perhaps, but <code>globals()</code> is arguably far less bad than <code>eval</code>, and not really any worse than <code>sys.modules[__name__]</code> AFAIK.</span>
<span class="comment-copy">Yeah I see your point, because you're only grabbing from it not setting anything</span>
<span class="comment-copy">nice one, it works even when class is not originally imported in this module</span>
<span class="comment-copy">You don't need types.TypeType; it's just an alias for the builtin "type".</span>
<span class="comment-copy">Yeah I know, but I feel it's just clearer to read.  I guess it just boils down to preference, though.</span>
<span class="comment-copy">If you're going to maintain the list, might as well maintain a dict from name to class instead.  Then there's no need for eval().</span>
<span class="comment-copy">In Python 3, there is no more ClassType.</span>
<span class="comment-copy">Use isinstance(x, type).</span>
