<div class="post-text" itemprop="text">
<p>I'm writing code in python 3.5 that uses hashlib to spit out MD5 encryption for each packet once it is is given a pcap file and the password. I am traversing through the pcap file using pyshark. Currently, the values it is spitting out are not the same as the MD5 encryptions on the packets in the pcap file. </p>
<p>One of the reasons I have attributed this to is that in the hex representation of the packet, the values are represented with leading 0s. Eg: Protocol number is shown as b'06'. But the value I am updating the hashlib variable with is b'6'. And these two values are not the same for same reason:</p>
<pre><code>&gt;&gt; b'06'==b'6'
False
</code></pre>
<p>The way I am encoding integers is:</p>
<pre><code>(hex(int(value))[2:]).encode()
</code></pre>
<p>I am doing this encoding because otherwise it would result in this error: "TypeError: Unicode-objects must be encoded before hashing"</p>
<p>I was wondering if I could get some help finding a python encoding library that ignores leading 0s or if there was any way to get the inbuilt hex method to ignore the leading 0s.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Hashing <code>b'06'</code> and <code>b'6'</code> gives different results because, in this context, '06' and '6' are different.</p>
<p>The <code>b</code> string prefix in Python tells the Python interpreter to convert each character in the string into a byte. Thus, <code>b'06'</code> will be converted into the two bytes <code>0x30 0x36</code>, whereas <code>b'6'</code> will be converted into the single byte <code>0x36</code>. Just as hashing <code>b'a'</code> and <code>b' a'</code> (note the space) produces different results, hashing <code>b'06'</code> and <code>b'6'</code> will similarly produce different results.</p>
<hr/>
<p>If you don't understand why this happens, I recommend looking up how bytes work, both within Python and more generally - Python's handling of bytes has always been a bit counterintuitive, so don't worry if it seems confusing! It's also important to note that the way Python represents bytes has changed between Python 2 and Python 3, so be sure to check which version of Python any information you find is talking about. You can comment here, too, </p>
</div>
<span class="comment-copy">I can't seem to reproduce this using your code - what number are you using for <code>value</code> to make your expression return <code>b'01'</code>?</span>
<span class="comment-copy">I apologize, I should have given more information on my assignment. So I'm writing python code that spits out MD5 encryption once it is given a pcap file. Currently, the value it is spitting out is not the same as the MD5 encryption on the pcap file. One of the reasons I have attributed this to is that in the hex representation of the packet, the values are represented with leading 0s. Eg: Protocol number is shown as b'06'. But the value I am updating the hashlib variable with is b'6'. And these two values are not the same for same reason (b'06'!=b'6')</span>
<span class="comment-copy">Awesome - you might want to edit your question to include that information, so others can see it more easily and are more likely to be able to help find an answer. I'll post an answer shortly which will hopefully explain the behaviour of <code>hashlib.md5</code> in more detail (and might even solve the problem :P ).</span>
<span class="comment-copy">Why are you converting to hex? Usually you get a hash of a file by running  each byte of the file through the hashing function, as-is (not hex).</span>
<span class="comment-copy">The result from pyshark is of the class: &lt;class 'pyshark.packet.layer.LayerFieldsContainer'&gt; And this cannot be directly updated to the hashlib method because it results in a "TypeError" saying "Unicode-objects must be encoded before hashing". I converted it to hex so that it would be of the same type as is on the pcap file</span>
<span class="comment-copy">Hi Josh, Thanks for your answer, it's really helped clear up why this was happening. I have a follow-up question though: do you know any python encoding method I could use so that encoding 06 and 6 would give me the same result?</span>
<span class="comment-copy">@Parampara well, calling <code>int(b'06')</code> returns <code>6</code> - <code>str(int(b'06')).encode("utf-8")</code> (turn the bytes into an integer to remove leading zero, then convert back to string and encode back into bytes) will return <code>b'6'</code>. You should be able to use that in <code>hashlib.md5()</code> to treat them the same.</span>
<span class="comment-copy">Thanks @josh that was in an innovative fix to the problem. But the issue is that in the pcap file, the protocol number is represented as b'06' so is there anyway to do the opposite of what you have suggested i.e. convert b'6' to b'06'?</span>
<span class="comment-copy">@Parampara <code>b'6'.zfill(2)</code> returns <code>b'06'</code>, as does <code>b'06'.zfill(2)</code>. See the <a href="https://docs.python.org/3/library/stdtypes.html#str.zfill" rel="nofollow noreferrer">zfill documentation</a>.</span>
<span class="comment-copy">Thanks @Josh that's helped fix the current issue!</span>
