<div class="post-text" itemprop="text">
<p>I've got a python dictionary of the form <code>{'ip1:port1' : &lt;value&gt;, 'ip1:port2' : &lt;value&gt;, 'ip2:port1' : &lt;value&gt;, ...}</code>. Dictionary keys are strings, consisting of ip:port pairs. Values are not important for this task.</p>
<p>I need a list of <code>ip:port</code> combinations with unique IP addresses, ports can be any of those that appear among original keys. For example above, two variants are acceptable: <code>['ip1:port1', ip2:port1']</code> and <code>['ip1:port2', ip2:port1']</code>.</p>
<p>What is the most pythonic way for doing it?</p>
<p>Currently my solution is</p>
<pre><code>def get_uniq_worker_ips(workers):
    wip = set(w.split(':')[0] for w in workers.iterkeys())
    return [[worker for worker in workers.iterkeys() if worker.startswith(w)][0] for w in wip]
</code></pre>
<p>I don't like it, because it creates additional lists and then discards them.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a> to group by same IP addresses:</p>
<pre><code>data = {'ip1:port1' : "value1", 'ip1:port2' : "value2", 'ip2:port1' : "value3", 'ip2:port2': "value4"}
by_ip = {k: list(g) for k, g in itertools.groupby(sorted(data), key=lambda s: s.split(":")[0])}
by_ip
# {'ip1': ['ip1:port1', 'ip1:port2'], 'ip2': ['ip2:port1', 'ip2:port2']}
</code></pre>
<p>Then just pick any one from the different groups of IPs.</p>
<pre><code>{v[0]: data[v[0]] for v in by_ip.values()}
# {'ip1:port1': 'value1', 'ip2:port1': 'value3'}
</code></pre>
<p>Or shorter, making a generator expression for just the first key from the groups:</p>
<pre><code>one_by_ip = (next(g) for k, g in itertools.groupby(sorted(data), key=lambda s: s.split(":")[0]))
{key: data[key] for key in one_by_ip}
# {'ip1:port1': 'value1', 'ip2:port1': 'value3'}
</code></pre>
<p>However, note that <code>groupby</code> requires the input data to be sorted. So if you want to avoid sorting all the keys in the dict, you should instead just use a <code>set</code> of already seen keys. </p>
<pre><code>seen = set()
not_seen = lambda x: not(x in seen or seen.add(x))
{key: data[key] for key in data if not_seen(key.split(":")[0])}
# {'ip1:port1': 'value1', 'ip2:port1': 'value3'}
</code></pre>
<p>This is similar to your solution, but instead of looping the unique keys and finding a matching key in the dict for each, you loop the keys and check whether you've already seen the IP.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to do this is to transform your keys into a custom class that only looks at the IP part of the string when doing an equality test. It also needs to supply an appropriate <code>__hash__</code> method.</p>
<p>The logic here is that the <code>set</code> constructor will "see" keys with the same IP as identical, ignoring the port part in the comparison, so it will avoid adding a key to the set if a key with that IP is already present in the set.</p>
<p>Here's some code that runs on Python 2 or Python 3.</p>
<pre><code>class IPKey(object):
    def __init__(self, s):
        self.key = s
        self.ip, self.port = s.split(':', 1)

    def __eq__(self, other):
        return self.ip == other.ip

    def __hash__(self):
        return hash(self.ip)

    def __repr__(self):
        return 'IPKey({}:{})'.format(self.ip, self.port)

def get_uniq_worker_ips(workers):
    return [k.key for k in set(IPKey(k) for k in workers)]

# Test

workers = {
    'ip1:port1' : "val", 
    'ip1:port2' : "val", 
    'ip2:port1' : "val", 
    'ip2:port2' : "val", 
}

print(get_uniq_worker_ips(workers))    
</code></pre>
<p><strong>output</strong></p>
<pre><code>['ip2:port1', 'ip1:port1']
</code></pre>
<p>If you are running Python 2.7 or later, the function can use a set comprehension instead of that generator expression inside the <code>set()</code> constructor call.</p>
<pre><code>def get_uniq_worker_ips(workers):
    return [k.key for k in {IPKey(k) for k in workers}]
</code></pre>
<p>The <code>IPKey.__repr__</code> method isn't strictly necessary, but I like to give all my classes a <code>__repr__</code> since it can be handy during development.</p>
<hr/>
<p>Here's a much more succinct solution which is very efficient, courtesy of <a href="https://stackoverflow.com/users/1252759/jon-clements">Jon Clements</a>. It builds the desired list via a dictionary comprehension.</p>
<pre><code>def get_uniq_worker_ips(workers):
    return list({k.partition(':')[0]:k for k in workers}.values())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've changed few characters in my solution and now am satisfied with it.</p>
<pre><code>def get_uniq_worker_ips(workers):
    wip = set(w.split(':')[0] for w in workers.iterkeys())
    return [next(worker for worker in workers.iterkeys() if worker.startswith(w)) for w in wip]
</code></pre>
<p>Thanks to @Ignacio Vazquez-Abrams and @M.T. for explanations.</p>
</div>
<span class="comment-copy">So then use genexs instead.</span>
<span class="comment-copy">Sorry, could you be more specific?</span>
<span class="comment-copy">by "genexs", I think he means "generator expressions", which essentially means you create a generator instead of a list. This could be done by changing out the square brackets <code>[]</code> with parantheses <code>()</code> in a list comprehension.</span>
<span class="comment-copy">Note that the OP asked for a list of keys, not a dict. Even though I love groupby, I prefer your 2nd solution since it avoids the O(nlogn) sort.</span>
<span class="comment-copy">@PM2Ring Right, but that will make the last step(s) just easier. I agree that the <code>set</code> solution is probably best, requiring the least time and space. <code>groupby</code> was just the first thing I thought off and I did not want to remove it after it had a few upvotes.</span>
<span class="comment-copy">Fair enough. And I certainly agree that you shouldn't remove code from an answer that's already received upvotes.</span>
<span class="comment-copy">Note that this has quadratic complexity, i.e. O(nÂ²) for finding the <code>next</code> matching entry for each of the unique IPs. Also, <code>startswith</code> will fail if you have, e.g.,  IPs <code>1.1.1.1</code> and <code>1.1.1.11</code>.</span>
<span class="comment-copy">@tobias_k, I cannot understand why the complexity is quadratic. Outer loop is over <code>set</code> elements... Do you mean that inner loop will iterate all keys and create generator only after that iteration completes?</span>
<span class="comment-copy">If k is the number of unique IP addresses and n the number of entries in the dict, then the complexity is k*n, which is, granted, not exactly quadratic (at least if k &lt;&lt; n), but still much higher than necessary.</span>
