<div class="post-text" itemprop="text">
<p>I wrote an extension for Python 3 in C++</p>
<p>My module is capable of handling arrays like <code>[1.0, 0.0, 0.0]</code>.
I want to add support for numpy arrays as well.</p>
<p>I process arrays with the following code:</p>
<pre><code>PyObject * MyFunction(PyObject * self, PyObject * args) {
    PyObject * list;

    if (!PyArg_ParseTuple(args, "O!:MyFunction", PyList_Type, &amp;list)) {
        return 0;
    }

    int count = (int)PyList_Size(list);
    for (int i = 0; i &lt; count; ++i) {
        double value = PyFloat_AsDouble(PyList_GET_ITEM(list, i));

        // ...
    }
}
</code></pre>
<p>I want a function that can iterate through this: <code>np.array([2,3,1,0])</code></p>
<p><strong>TL;DR:</strong></p>
<p>Numpy equivalent for:</p>
<ul>
<li><code>PyList_Type</code></li>
<li><code>PyList_Size</code></li>
<li><code>PyList_GET_ITEM</code> or <code>PyList_GetItem</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>First of all there is no <code>numpy</code> equivalent for:</p>
<ul>
<li>PyList_Type</li>
<li>PyList_Size</li>
<li>PyList_GET_ITEM or PyList_GetItem</li>
</ul>
<p>The <code>numpy.array</code> implements the <a href="https://docs.python.org/3/c-api/buffer.html" rel="nofollow">buffer interface</a>, so one can write:</p>
<pre><code>const char * data;
int size;

PyArg_ParseTuple(args, "y#:MyFunction", &amp;data, &amp;size);
</code></pre>
<p>The <code>numpy.array([1.0, 0.0, 0.0])</code> uses <code>double</code> precision:</p>
<pre><code>double * array = (double *)data;
int length = size / sizeof(double);
</code></pre>
<p><strong>The full example:</strong></p>
<ul>
<li><p><strong>C++</strong></p>
<pre><code>PyObject * MyFunction(PyObject * self, PyObject * args) {
    const char * data;
    int size;

    if (!PyArg_ParseTuple(args, "y#:MyFunction", &amp;data, &amp;size)) {
        return 0;
    }

    double * content = (double *)data;
    int length = size / sizeof(double);

    for (int i = 0; i &lt; length; ++i) {
        double value = content[i];

        // ...
    }

    Py_RETURN_NONE;
}
</code></pre></li>
<li><p><strong>Python</strong></p>
<pre><code>MyFunction(numpy.array([1.0, 2.0, 3.0]))
</code></pre></li>
</ul>
</div>
<span class="comment-copy">No real answer and maybe you got good reasons to use this native way of interfacing c++, but did you consider <a href="http://cython.org/" rel="nofollow noreferrer">cython</a>. This makes all that stuff much easier/nicer and is used by some very cool projects (e.g. scikit-learn).</span>
<span class="comment-copy">normally, it's the other way round: you write a numpy-function, which also can handle lists.</span>
<span class="comment-copy">I just wan't to be able to iterate through a numpy array in C++</span>
<span class="comment-copy">Now I will check <code>cython</code> @sascha</span>
<span class="comment-copy">I'm not an expert, but what's the problem there? Cython surely needs a C++ compiler (which could be awkward for windows-users) if you are interfacing C++ code, but the same should apply to the native-bindings. A lot of projects use cython and are available on PyPI.</span>
