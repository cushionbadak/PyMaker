<div class="post-text" itemprop="text">
<p>Does this:</p>
<pre><code>for i,v in enumerate(lst[from:to]):
</code></pre>
<p>or this:</p>
<pre><code>for  i,v in enumerate(itertools.islice(lst,from,to)): 
</code></pre>
<p>...make a copy of iterated sublist?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that <code>lst</code> is a regular Python list, and not a Numpy array, Pandas dataframe, or some custom class supporting slice indexing, then the slice <code>[...:...]</code> will create a new list, whereas <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow"><code>itertools.islice</code></a> does not.</p>
<p>As suggested in comments, you can see this for yourself by creating both <code>enumerate</code> objects and modifying the original list before consuming them:</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]
&gt;&gt;&gt; e1 = enumerate(lst[1:4])
&gt;&gt;&gt; e2 = enumerate(itertools.islice(lst, 1, 4))
&gt;&gt;&gt; del lst[2]  # remove second element
&gt;&gt;&gt; list(e1)
[(0, 2), (1, 3), (2, 4)]  # shows content of original list
&gt;&gt;&gt; list(e2)
[(0, 2), (1, 4), (2, 5)]  # second element skipped
</code></pre>
<p>Also note that this does in fact have nothing to do with <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a>, which will create a generator in both cases (on top of whatever iterable was created before by the slice).</p>
<p>You could also just create the two variants of slices and check their types:</p>
<pre><code>&gt;&gt;&gt; type(lst[1:4])
list  # a new list
&gt;&gt;&gt; type(itertools.islice(lst, 1, 4))
itertools.islice  # some sort of generator
</code></pre>
</div>
<span class="comment-copy">First yes, second no.</span>
<span class="comment-copy">Why not perform an experiment? Mutate the slices that you iterate over. Does this change the original object?</span>
<span class="comment-copy">@JohnColeman How would you do that for the second version?</span>
<span class="comment-copy">If you're going to have to pause and resume... why not store it outside the loop, <code>it = enumerate(lst)</code>, then <code>for i, v in it: #... whatever and break</code>, then you can re-use <code>it</code> after again and it'll resume from where you broke. (If that's what you're trying to do by list slicing - but I'm not sure...)</span>
<span class="comment-copy">@StefanPochmann Good question. I just noticed that <code>'itertools.islice' object does not support item assignment</code> so it isn't as easy as I thought it would be to see that it isn't a copy. In the first case a simple experiment (on the slice itself -- <code>enumerate</code> is a bit of a distraction) will show that the slice is a copy rather than an alias.</span>
