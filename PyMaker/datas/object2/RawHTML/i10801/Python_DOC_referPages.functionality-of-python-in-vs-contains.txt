<div class="post-text" itemprop="text">
<p>I implemented the <code>__contains__</code> method on a class for the first time the other day, and the behavior wasn't what I expected. I suspect there's some subtlety to the <a href="https://docs.python.org/2/library/operator.html" rel="noreferrer"><code>in</code></a> operator that I don't understand and I was hoping someone could enlighten me.</p>
<p>It appears to me that the <code>in</code> operator doesn't simply wrap an object's <code>__contains__</code> method, but it also attempts to coerce the output of <code>__contains__</code> to boolean. For example, consider the class</p>
<pre><code>class Dummy(object):
    def __contains__(self, val):
        # Don't perform comparison, just return a list as
        # an example.
        return [False, False]
</code></pre>
<p>The <code>in</code> operator and a direct call to the <code>__contains__</code> method return very different output:</p>
<pre><code>&gt;&gt;&gt; dum = Dummy()
&gt;&gt;&gt; 7 in dum
True
&gt;&gt;&gt; dum.__contains__(7)
[False, False]
</code></pre>
<p>Again, it looks like <code>in</code> is calling <code>__contains__</code> but then coercing the result to <code>bool</code>. I can't find this behavior documented anywhere except for the fact that the <code>__contains__</code> <a href="https://docs.python.org/2/reference/datamodel.html#object.__contains__" rel="noreferrer">documentation</a> says <code>__contains__</code> should only ever return <code>True</code> or <code>False</code>.</p>
<p>I'm happy following the convention, but can someone tell me the precise relationship between <code>in</code> and <code>__contains__</code>?</p>
<h1>Epilogue</h1>
<p>I decided to choose @eli-korvigo answer, but everyone should look at @ashwini-chaudhary <a href="https://stackoverflow.com/questions/38542543/functionality-of-python-in-vs-contains/38542777?noredirect=1#comment64477339_38542543">comment</a> about the <a href="https://bugs.python.org/issue16011" rel="noreferrer">bug</a>, below.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the source, Luke!</p>
<p>Let's trace down the <code>in</code> operator implementation</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; class test(object):
...     def __contains__(self, other):
...         return True

&gt;&gt;&gt; def in_():
...     return 1 in test()

&gt;&gt;&gt; dis.dis(in_)
    2           0 LOAD_CONST               1 (1)
                3 LOAD_GLOBAL              0 (test)
                6 CALL_FUNCTION            0 (0 positional, 0 keyword pair)
                9 COMPARE_OP               6 (in)
               12 RETURN_VALUE
</code></pre>
<p>As you can see, the <code>in</code> operator becomes the <code>COMPARE_OP</code> virtual machine instruction. You can find that in <a href="http://hg.python.org/cpython/file/tip/Python/ceval.c" rel="noreferrer">ceval.c</a></p>
<pre><code>TARGET(COMPARE_OP)
    w = POP();
    v = TOP();
    x = cmp_outcome(oparg, v, w);
    Py_DECREF(v);
    Py_DECREF(w);
    SET_TOP(x);
    if (x == NULL) break;
    PREDICT(POP_JUMP_IF_FALSE);
    PREDICT(POP_JUMP_IF_TRUE);
    DISPATCH(); 
</code></pre>
<p>Take a look at one of the switches in <code>cmp_outcome()</code></p>
<pre><code>case PyCmp_IN:
    res = PySequence_Contains(w, v);
    if (res &lt; 0)
         return NULL;
    break;
</code></pre>
<p>Here we have the <code>PySequence_Contains</code> call</p>
<pre><code>int
PySequence_Contains(PyObject *seq, PyObject *ob)
{
    Py_ssize_t result;
    PySequenceMethods *sqm = seq-&gt;ob_type-&gt;tp_as_sequence;
    if (sqm != NULL &amp;&amp; sqm-&gt;sq_contains != NULL)
        return (*sqm-&gt;sq_contains)(seq, ob);
    result = _PySequence_IterSearch(seq, ob, PY_ITERSEARCH_CONTAINS);
    return Py_SAFE_DOWNCAST(result, Py_ssize_t, int);
}
</code></pre>
<p>That always returns an <code>int</code> (a boolean). </p>
<p>P.S.</p>
<p>Thanks to Martijn Pieters for providing the <a href="https://stackoverflow.com/a/12244378/3846213">way</a> to find the implementation of the <code>in</code> operator.</p>
</div>
<div class="post-text" itemprop="text">
<p>In <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer">Python reference for <code>__contains__</code></a> it's written that <code>__contains__</code> should return <code>True</code> or <code>False</code>.</p>
<p>If the return value is not boolean it's converted to boolean. Here is proof:</p>
<pre><code>class MyValue:
    def __bool__(self):
        print("__bool__ function ran")
        return True

class Dummy:
    def __contains__(self, val):
        return MyValue()
</code></pre>
<p>Now write in shell:</p>
<pre><code>&gt;&gt;&gt; dum = Dummy()
&gt;&gt;&gt; 7 in dum
__bool__ function ran
True
</code></pre>
<p>And <code>bool()</code> of nonempty list returns <code>True</code>.</p>
<p><strong>Edit:</strong></p>
<p>It's only documentation for <code>__contains__</code>, if you really want to see precise relation you should consider looking into source code although I'm not sure where exactly, but it's already answered. In <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow noreferrer">documentation for comparison</a> it's written:</p>
<blockquote>
<p>However, these methods can return any value, so if the comparison operator is used in a Boolean context (e.g., in the condition of an <code>if</code> statement), Python will call <a href="https://docs.python.org/3/library/functions.html#bool" rel="nofollow noreferrer">bool()</a> on the value to determine if the result is true or false.</p>
</blockquote>
<p>So you can guess that it's similar with <code>__contains__</code>.</p>
</div>
<span class="comment-copy">Because your contains-method returns equivalent of bool([False, False])</span>
<span class="comment-copy">Related bug: <a href="https://bugs.python.org/issue16011" rel="nofollow noreferrer"><code>in</code> should be consistent with return value of <code>__contains__</code></a></span>
<span class="comment-copy">@AshwiniChaudhary: Can you write this comment up as an answer? Just a one-liner or so is fine. I had never seen this bug report and it precisely answers my question. I don't so much care about the specific implementation of <code>in</code> as I care about the design reasoning and apparent lack of documentaiton. If you post this answer, I will select your answer as the accepted one.</span>
<span class="comment-copy">Thanks for the thorough answer, but I was looking for more of the reasoning behind the design and apparent lack of documentation than the implementation of <code>in</code>. I'm upvoting your answer anyway because it is useful info.</span>
<span class="comment-copy">@joshua.r.smith I guess, in this case the implementation is directly related to the reasoning. Basically, this is how Python-C API was conceived. As for the lack of documentation, the docs don't really reference <code>True</code> or <code>False</code>, they only say that <code>__cointains__</code>  should return something either true or false (i.e. that can be evaluated as <code>True</code> or <code>False</code>). You can see throughout the docs, that they explicitly use <code>True</code> and <code>False</code> where important. Anyway, they could've written it less ambiguously, so you can file a documentation patch report.</span>
<span class="comment-copy">I think <code>"__bool__ function runned"</code> should be <code>"__bool__ function ran"</code></span>
