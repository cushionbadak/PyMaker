<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow">Chapter "Classes"</a> of the official Python tutorial:</p>
<blockquote>
<p>[...] if a function modifies an object passed as an argument, the caller will see the change â€” this eliminates the need for two different argument passing mechanisms as in Pascal.</p>
</blockquote>
<p>What would be an example of how exactly the caller will see a change? Or how could it be (not in Python but in general) that the caller doesn't see the change?</p>
</div>
<div class="post-text" itemprop="text">
<p>It basically means that if a mutable object is changed, it will change everywhere.</p>
<p>For an example of passing by reference (which is what Python does):</p>
<pre><code>x = []
def foo_adder(y):
    y.append('foo')
foo_addr(x)
print(x)  # ['foo']
</code></pre>
<p>vs something like Pascal, where you can pass copies of an object as a parameter, instead of the object itself:</p>
<pre><code># Pretend this is Pascal code.
x = []
def foo_adder(y):
    y.append('foo')
foo_adder(x)
print(x)  # []
</code></pre>
<p>You can get the behavior of the second example in Python if you pass a copy of the object. For lists, you use <code>[:]</code>.</p>
<pre><code># Pretend this is Pascal code.
x = []
def foo_adder(y):
    y.append('foo')
foo_adder(x[:])
print(x)  # []
</code></pre>
<p>For your second question about how the caller might not see the change, let's take that same <code>foo_adder</code> function and change it a little so that it doesn't modify the object, but instead replaces it.</p>
<pre><code>x = []
def foo_adder(y):
    y = y + ['foo']
foo_adder(x)
print(x)  # []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>What would be an example of how exactly the caller will see a change?</p>
</blockquote>
<pre><code>&gt;&gt;&gt; def modify(x):
...     x.append(1)
...
&gt;&gt;&gt; seq = []
&gt;&gt;&gt; print(seq)
[]
&gt;&gt;&gt; modify(seq)
&gt;&gt;&gt; print(seq)
[1]
</code></pre>
<blockquote>
<p>Or how could it be (not in Python but in general) that the caller doesn't see the change?</p>
</blockquote>
<p>Hypothetically, a language could exist where a deep copy of <code>seq</code> is created and assigned to <code>x</code>, and any change made to <code>x</code> has no effect on <code>seq</code>, in which case <code>print(seq)</code> would display <code>[]</code> both times. But this isn't what happens in Python.</p>
<hr/>
<p>Edit: note that assigning a new value to an old variable name typically doesn't count as "modification".</p>
<pre><code>&gt;&gt;&gt; def f(x):
...     x = x + 1
...
&gt;&gt;&gt; y = 23
&gt;&gt;&gt; f(y)
&gt;&gt;&gt; print(y)
23
</code></pre>
</div>
<span class="comment-copy">You missed out the step where you actually call <code>foo_adder</code> in both snippets...</span>
<span class="comment-copy">@DanielRoseman I don't know what you're talking about. ;) (Thanks for pointing that out).</span>
<span class="comment-copy">In your edit: Isn't is because <code>int</code> is immutable?</span>
<span class="comment-copy">Local assignments aren't visible outside their current scope even if you're assigning to an identifier that currently contains a mutable object. Suppose the function did <code>x = x + [1]</code>. Then <code>z = []; f(z); print(z)</code> would print <code>[]</code> even though lists are mutable.</span>
