<div class="post-text" itemprop="text">
<p>From what I’ve read, unit test should test only one function/method at a time. But I’m not clear on how to test methods that only set internal object data with no return value to test off of, like the setvalue() method in the following Python class (and this is a simple representation of something more complicated):</p>
<pre><code>class Alpha(object):

    def __init__(self):
        self.__internal_dict = {}

    def setvalue(self, key, val):
        self.__internal_dict[key] = val

    def getvalue(self, key):
        return self.__internal_dict[key]
</code></pre>
<p>If unit test law dictates that we should test every function, one at a time, then how do I test the setvalue() method on its own? One "solution" would be to compare what I passed into setvalue() with the return of getvalue(), but if my assert fails, I don't know which method is failing - is it setvalue() or getvalue()? Another idea would be to compare what I passed into setvalue() with the object's private data, __internal_dict[key] - a HUGE disgusting hack!</p>
<p>As of now, this is my solution for this type of problem, but if the assert raises, that would only indicate that 1 of my 2 main methods is not properly working.</p>
<pre><code>import pytest

def test_alpha01():
    alpha = Alpha()
    alpha.setvalue('abc', 33)

    expected_val = 33
    result_val = alpha.getvalue('abc')

    assert result_val == expected_val
</code></pre>
<p>Help appreciated</p>
</div>
<div class="post-text" itemprop="text">
<h2>The misconception</h2>
<p>The real problem you have here is that you are working on a false premise:</p>
<blockquote>
<p>If unit test law dictates that we should test every function, one at a time...</p>
</blockquote>
<p>This is not at all what good unit testing is about.</p>
<p>Good unit testing is about decomposing your code into logical components, putting them into controlled environments and testing that their <em>actual</em> behaviour matches their <em>expected</em> behaviour - <strong>from the perspective of a consumer</strong>.</p>
<p>Those "units" may be (depending on your environment) anonymous functions, individual classes or clusters of tightly-coupled classes (and don't let anyone tell you that class coupling is inherently bad; some classes are made to go together).</p>
<p>The important thing to ask yourself is - <em>what does a consumer care about</em>?</p>
<p>What they certainly <em>don't</em> care about is that - when they call a <em>set</em> method - some internal private member that they can't even access is set.</p>
<h2>The solution</h2>
<p>Naively, from looking at your code, it seems that what the consumer cares about is that when they call <code>setvalue</code> for a particular key, calling <code>getvalue</code> for that same key gives them back the value that they put in. If that's the intended behaviour of the unit (class), then that's what you should be testing. </p>
<p>Nobody should care what happens behind the scenes as long as the <em>behaviour</em> is correct.</p>
<p>However, I would also consider if that's really all that this class is for - what else does that value have an impact on? It's impossible to say from the example in your question but, whatever it is, that should be tested too.</p>
<p>Or maybe, if that's hard to define, this class in itself isn't very meaningful and your "unit" should actually be an independent set of small classes that only really have meaningful behaviour when they're put together and should be tested as such.</p>
<p>The balance here is subtle, though, and difficult to be less cryptic about without more context.</p>
<h1>The pitfall</h1>
<p>What you certainly <em>shouldn't</em> (ever ever ever) do is have your tests poking around internal state of your objects. There are two very important reasons for this:</p>
<p>First, as already mentioned, unit tests are about behaviour of units as perceived by a client. Testing that it does what I believe it should do as a consumer. I don't - and shouldn't - care about how it does it under the hood. That dictionary is irrelevant to me.</p>
<p>Second, good unit tests allow you to verify behaviour while still giving you the freedom to change how that behaviour is achieved - if you tie your tests to that dictionary, it ceases to be an implementation detail and becomes part of the contract, meaning any changes to how this unit is implemented force you either to retain that dictionary or change your tests.</p>
<p>This is a road that leads to the opposite of what unit testing is intended to achieve - painless maintenance.</p>
<p>The bottom line is that consumers - and therefore your tests - do not care about whether <code>setvalue</code> updates an internal dictionary. Figure out what they actually care about and test that instead.</p>
<p>As an aside, this is where TDD (specifically test-first) really comes into its own - if you state the intended behaviour with a test up-front, it's difficult to find yourself stuck in that "what am I trying to test?" rut.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would consider accessing your internal data structure in your test less of a "disgusting hack" since it tests one function at a time and you know what's wrong almost immediately.</p>
<p>I admit it's not a great idea to access private members from the test, but still I see this adding more value:</p>
<pre><code>class Alpha(object):
    def __init__(self):
        self._internal_dict = {}

    def setvalue(self, key, val):
        self._internal_dict[key] = val

    def getvalue(self, key):
        return self._internal_dict[key]


def test_alpha_setvalue():
    alpha = Alpha()
    alpha.setvalue('abc', 33)
    assert alpha._internal_dict['abc'] == 33


def test_alpha_getvalue():
    alpha = Alpha()
    alpha._internal_dict['abc'] = 33
    assert alpha.getvalue('abc') == 33
</code></pre>
<p>Please note that this approach requires that you use a single underscore for your internal data structure for the test to be able to access it. It is a convention followed to indicate to other programmers that it is non-public.</p>
<p>More info about this in python docs: <a href="https://docs.python.org/3/tutorial/classes.html#tut-private" rel="nofollow">https://docs.python.org/3/tutorial/classes.html#tut-private</a></p>
</div>
<span class="comment-copy">Since you're using a "private" dict, these are a "unit" -- your access to that dict. This is no different than any other set and retrieval operation in Python, since that could be carried out by descriptors (think <code>@property</code>) which would potentially invoke more than one function. Is there extra behavior in one or the other that merits testing?</span>
<span class="comment-copy">It doesn't mean you can't use an other function to check the resultat. often i'll look like <code>a.set_stuff(5) if a.get_stuff()==5 return True</code>. Also, you'll have to check if <code>get_stuff()</code> is working properly before checking <code>set_stuff()</code>.</span>
<span class="comment-copy">You are making a really good point here, but I doubt this is the answer to every scenario. What would happen if method <code>getvalue</code> was calling another method <code>is_cache_expired</code>, and if the cache expired that it should get the value from the database instead of the dictionary, by calling another method. If any of those dependent methods break, we immediately have 3 failed tests. Is that accurate of what's wrong and painless maintenance? Maybe the answer is it depends..</span>
<span class="comment-copy">@fips then you would stub out the cache to return nothing, stub out the data store to return <code>somevalue</code> for <code>key</code>, and test that asking for <code>key</code> returns <code>somevalue</code>.  If that test fails, you know that that behaviour is not being observed. Then the data store and cache would be tested as separate units.</span>
<span class="comment-copy">Also, having multiple tests fail because of one "broken" line of code is not really a bad thing - the tests tell you which pieces of behaviour work and which don't; if one broken line of code causes 3 scenarios not to perform correctly then it's entirely correct that your tests should say "Hey, this thing isn't honouring the cache <i>or</i> the DB, what gives?"</span>
<span class="comment-copy">I agree with stubbing you can get both isolation and respect the interface/internals of the object with freedom to change it. If done correctly usually no other tests will fail. Nevertheless, I wouldn't consider it too bad if 2-3 tests failed, but I've seen much worse in some collaborative environments and I wasn't happy about it.</span>
<span class="comment-copy">@fips when that happens, though, the culprit is invariably poor encapsulation/isolation - if a unit really has one responsibility, then there will be a small number of scenarios and all dependencies will be stubbed or mocked (depending on whether they are to be queried or invoked). Again, TDD can help there as your test helps to push things that "aren't my problem" out to dependencies (i.e. you'd work from the front and just say "if I get nothing back from the cache..." in your test, which naturally pushes caching to another unit).</span>
<span class="comment-copy">This works. I'm starting to warm up to the idea of considering my 2 methods as 1 unit in terms of unit testing (for now :) ). But your example is a card I'll have in case I need to get extra granular with my unit tests.</span>
<span class="comment-copy">we experience and we learn. hope everybody cares about testing this much! :)</span>
