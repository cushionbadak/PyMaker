<div class="post-text" itemprop="text">
<p>I'd like to create a class in Python that takes a single argument in the constructor, another Python class. The instance of the Copy class should have all the attributes and methods of the original class, without knowing what they should be beforehand. Here's some code that almost works:</p>
<pre><code>import copy

class A():
    l = 'a'

class Copy():

    def __init__(self, original_class):
        self = copy.deepcopy(original_class)
        print(self.l)

c = Copy(A)
print(c.l)
</code></pre>
<p>The print statement in the constructor prints 'a', but the final one gives the error <code>AttributeError: Copy instance has no attribute 'l'</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am unsure why you would wish to do this, but you probably have your reasons.</p>
<p>You can leverage off normal inheritance:</p>
<p>eg:</p>
<pre><code>    class A(object):
        l = 'a'

    class C(object):
        l = 'c'

    def createClass(cls):

        class B(cls):
            pass

        return B

    cls = createClass(C) # or A or whatever
    print cls.l

=&gt; result: 'c'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to copy the <code>__dict__</code>:</p>
<pre><code>import copy

class A():
    l = 'a'

class Copy():
    def __init__(self, original_class):
        self.__dict__ = copy.deepcopy(original_class.__dict__)
        print(self.l)

c = Copy(A)  # -&gt; a
print(c.l)  # -&gt; a
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is an interesting question to point out a pretty cool feature of Python's pass-by-value semantics, as it is intimately tied to why your original code doesn't work correctly and why @martineau's solution works well.</p>
<h2>Why Your Code As Written Doesn't Work</h2>
<p>Python doesn't support pure pass-by-reference or pass-by-value semantics - instead, it does the following:</p>
<pre><code># Assume x is an object
def f(x):
    # doing the following modifies `x` globally
    x.attribute = 5 
    # but doing an assignment only modifies x locally!
    x = 10
    print(x)
</code></pre>
<p>To see this in action,</p>
<pre><code># example
class Example(object):
    def __init__(self):
        pass

 x = Example()

 print(x)
 &gt;&gt;&gt; &lt;__main__.Example instance at 0x020DC4E0&gt;

 f(e) # will print the value of x inside `f` after assignment 
 &gt;&gt;&gt; 10

 print(x) # This is unchanged
 &gt;&gt;&gt; &lt;__main__.Example instance at 0x020DC4E0&gt;
 e.attribute # But somehow this exists!
 &gt;&gt;&gt; 5
</code></pre>
<p>What happens? Assignment creates a <em>local</em> <code>x</code> which is then assigned a value. Once this happens, the original parameter that was passed in as an argument is inaccessible.</p>
<p>However, so long as the <em>name</em> <code>x</code> is bound to the object that's passed in, you can modify attributes and it will be reflected in the object you passed in. The minute you 'give away' the name <code>x</code> to something else, however, that name is no longer bound to the original parameter you passed in.</p>
<hr/>
<p>Why is this relevant here? </p>
<p>If you pay careful attention to the signature for <code>__init__</code>, you'll notice it takes <code>self</code> as a parameter. What is <code>self</code>? </p>
<p>Ordinarily, <code>self</code> refers to the object instance. So the name <code>self</code> is bound to the object instance. </p>
<p>This is where the fun starts. <strong>By assigning to <code>self</code> in your code, this property no longer holds true!</strong></p>
<pre><code>def __init__(self, original_class):
    # The name `self` is no longer bound to the object instance,
    # but is now a local variable!
    self = copy.deepcopy(original_class)
    print(self.l) # this is why this works!
</code></pre>
<p>The minute you leave <code>__init__</code>, this new local variable <code>self</code> goes out of scope. That is why doing <code>c.l</code> yields an error outside of the constructor - you never actually assigned to the object in the first place!</p>
<h2>Why @martineau's Solution Works</h2>
<p>@martineau simply took advantage of this behaviour to note that the <code>__dict__</code> attribute exists on the <code>self</code> object, and assigns to it:</p>
<pre><code>class Copy():
    def __init__(self, original_class):
        # modifying attributes modifies the object self refers to!
        self.__dict__ = copy.deepcopy(original_class.__dict__)
        print(self.l)
</code></pre>
<p>This now works because the <code>__dict__</code> attribute is what Python calls when Python needs to lookup a method signature or attribute when it sees the namespace operator <code>.</code>, and also because <code>self</code> has not been changed but still refers to the object instance. By assigning to <code>self.__dict__</code>, you obtain an almost exact copy of the original class ('almost exact' because even <code>deepcopy</code> has limits).</p>
<hr/>
<p>The moral of the story should be clear: never assign anything to <code>self</code> directly. Instead, <em>only</em> assign to attributes of <code>self</code> if you ever need to. Python's metaprogramming permits a wide degree of flexibility in this regard, and you should always consult <a href="https://docs.python.org/3/library/stdtypes.html#special-attributes" rel="nofollow">the documentation</a> in this regard.</p>
</div>
<span class="comment-copy">Is there any particular reason you want this to be a <i>class</i>? Why not just use <code>copy.deepcopy</code>?</span>
<span class="comment-copy">You should look into python metaprogramming, the <code>__new__</code> method, and the <code>type()</code> function.</span>
<span class="comment-copy">Note that you're not actually assigning the result of <code>copy.deepcopy()</code> to the <code>Copy</code> instance. Thanks to Python's pass-by-value behaviour, assignment effectively changes what <code>self</code> points to - it no longer means what you think it means.</span>
