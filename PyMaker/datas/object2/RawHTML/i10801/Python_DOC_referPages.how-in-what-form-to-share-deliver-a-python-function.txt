<div class="post-text" itemprop="text">
<p>The final outcome of my work should be a Python function that takes a JSON object as the only input and return another JSON object as output. To keep it more specific, I am a data scientist, and the function that I am speaking about, is derived from data and it delivers predictions (in other words, it is a machine learning model).</p>
<p>So, my question is how to deliver this function to the "tech team" that is going to incorporate it into a web-service.</p>
<p>At the moment I face few problems. First, the tech team does not necessarily work in Python environment. So, they cannot just "copy and paste" my function into their code. Second, I want to make sure that my function runs in the same environment as mine. For example, I can imagine that I use some library that the tech team does not have or they have a version that differ from the version that I use.</p>
<p><strong>ADDED</strong></p>
<p>As a possible solution I consider the following. I start a Python process that listen to a socket, accept incoming strings, transforms them into JSON, gives the JSON to the "published" function and returns the output JSON as a string. Does this solution have disadvantages? In other words, is it a good idea to "publish" a Python function as a background process listening to a socket?</p>
</div>
<div class="post-text" itemprop="text">
<p>You have the right idea with using a socket but there are tons of frameworks doing exactly what you want. Like <a href="https://stackoverflow.com/users/6464893/hleggs">hleggs</a>, I suggest you checkout <a href="http://flask.pocoo.org/" rel="nofollow noreferrer">Flask</a> to build a microservice. This will let the other team post JSON objects in an HTTP request to your flask application and receive JSON objects back. No knowledge of the underlying system or additional requirements required!</p>
<p>Here's a template for a flask app that replies and responds with JSON</p>
<pre><code>from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/', methods=['POST'])
def index():
    json = request.json
    return jsonify(your_function(json))


if __name__=='__main__':
    app.run(host='0.0.0.0', port=5000)
</code></pre>
<p><strong>Edit</strong>: embeded my code directly as per <a href="https://stackoverflow.com/users/4994021/peter-brittain">Peter Britain</a>'s advice</p>
</div>
<div class="post-text" itemprop="text">
<p>My understanding of your question boils down to: </p>
<p><em>How can I share a Python library with the rest of my team, that may not be using Python otherwise?</em></p>
<p><em>And how can I make sure my code and its dependencies are what the receiving team will run?</em></p>
<p><em>And that the receiving team can install things easily mostly anywhere?</em></p>
<p>This is a simple question with no straightforward answer... as you just mentioned that this may be integrated in some webservice, but you do not know the actual platform for this service.</p>
<p>You also ask:</p>
<blockquote>
<p>As a possible solution I consider the following. I start a Python process that listen to a socket, accept incoming strings, transforms them into JSON, gives the JSON to the "published" function and returns the output JSON as a string. Does this solution have disadvantages? In other words, is it a good idea to "publish" a Python function as a background process listening to a socket?</p>
</blockquote>
<p>In the most simple case and for starting I would say <strong>no</strong> in general. Starting network servers such as an HTTP server (which is built-in Python) is super easy. But a service (even if qualified as "micro") means infrastructure, means security, etc. </p>
<ul>
<li>What if the port you expect is not available on the deployment machine? - What happens when you restart that machine?</li>
<li>How will your server start or restart when there is a failure? </li>
<li>Would you need also to eventually provide an upstart or systemd service (on Linux)? </li>
<li>Will your simple socket or web server support multiple concurrent requests? </li>
<li>is there a security risk to expose a socket?</li>
</ul>
<p>Etc, etc. When deployed, my experience with "simple" socket servers is that they end up being not so simple after all.</p>
<p>In most cases, it will be simpler to avoid redistributing a socket service at first. And the proposed approach here could be used to package a whole service at a later stage in a simpler way if you want.</p>
<p>What I suggest instead is a <strong>simple command line interface nicely packaged for installation</strong>.</p>
<p>The minimal set of things to consider would be:</p>
<ol>
<li>provide a portable mechanism to call your function on many OSes</li>
<li>ensure that you package your function such that it can be installed with all the correct dependencies</li>
<li>make it easy to install and of course provide some doc!</li>
</ol>
<p><strong>Step 1.</strong> The simplest common denominator would be to provide a command line interface that accepts the path to a JSON file and spits JSON on the stdout. 
This would run on Linux, Mac and Windows. </p>
<p>The instructions here should work on Linux or Mac and would need a slight adjustment for Windows (only for the <code>configure.sh</code> script further down)</p>
<p>A minimal Python script could be:</p>
<pre><code>#!/usr/bin/env python

"""
Simple wrapper for calling a function accepting JSON and returning JSON.
Save to predictor.py and use this way::
    python predictor.py sample.json
    [
      "a",
      "b",
      4
    ]
"""

from __future__ import absolute_import, print_function
import json
import sys


def predict(json_input):
    """
    Return predictions as a JSON string based on the provided `json_input` JSON
    string data.
    """
    # this will error out immediately if the JSON is not valid
    validated = json.loads(json_input)
    # &lt;....&gt; your code there
    with_predictions = validated
    # return a pretty-printed JSON string
    return json.dumps(with_predictions, indent=2)


def main():
    """
    Print the JSON string results of a prediction, loading an input JSON file from a
    file path provided as a command line argument.
    """
    args = sys.argv[1:]
    json_input = args[0]
    with open(json_input) as inp:
        print(predict(inp.read()))


if __name__ == '__main__':
    main()
</code></pre>
<p>You can process eventually large inputs by passing the path to a JSON file.</p>
<p><strong>Step 2.</strong> Package your function. In Python this is achieved by creating a <code>setup.py</code> script. This takes care of installing any dependent code from Pypi too. This will ensure that the version of libraries you depend on are the ones you expect. Here I added <code>nltk</code> as an example for a dependency. Add yours: this could be <code>scikit-learn</code>, <code>pandas</code>, <code>numpy</code>, etc. This <code>setup.py</code> also creates automatically a <code>bin/predict</code> script which will be your main command line interface:</p>
<pre><code>#!/usr/bin/env python
# -*- encoding: utf-8 -*-

from __future__ import absolute_import, print_function
from setuptools import setup
from setuptools import find_packages


setup(
    name='predictor',
    version='1.0.0',
    license='public domain',
    description='Predict your life with JSON.',
    packages=find_packages(),
    # add all your direct requirements here
    install_requires=['nltk &gt;= 3.2, &lt; 4.0'],
    # add all your command line entry points here
    entry_points={'console_scripts': ['predict = prediction.predictor:main']}
)
</code></pre>
<p>In addition as is common for Python and to make the setup code simpler I created a "Python package" directory moving the predictor inside this directory.</p>
<p><strong>Step 3.</strong> You now want to package things such that they are easy to install. A simple <code>configure.sh</code> script does the job. It installs <code>virtualenv</code>, <code>pip</code> and <code>setuptools</code>, then creates a <code>virtualenv</code> in the same directory as your project and then installs your prediction tool in there (<code>pip install .</code> is essentially the same as <code>python setup.py install</code>). With this script you ensure that the code that will be run is the code you want to be run with the correct dependencies. Furthermore, you ensure that this is an isolated installation with minimal dependencies and impact on the target system. This is tested with Python 2 but should work quite likely on Python 3 too.</p>
<pre><code>#!/bin/bash
#
# configure and installs predictor
#

ARCHIVE=15.0.3.tar.gz
mkdir -p tmp/
wget -O tmp/venv.tgz https://github.com/pypa/virtualenv/archive/$ARCHIVE
tar --strip-components=1 -xf tmp/venv.tgz -C tmp
/usr/bin/python tmp/virtualenv.py .
. bin/activate
pip install .
echo ""
echo "Predictor is now configured: run it with:"
echo "   bin/predict &lt;path to JSON file&gt;"
</code></pre>
<p>At the end you have a fully configured, isolated and easy to install piece of code with a simple highly portable command line interface.
You can see it all in this small repo: <a href="https://github.com/pombredanne/predictor" rel="nofollow">https://github.com/pombredanne/predictor</a> 
You just clone or fetch a zip or tarball of the repo, then go through the README and you are in business.</p>
<p>Note that for a more engaged way for more complex applications including vendoring the dependencies for easy install and not depend on the network you can check this <a href="https://github.com/nexB/scancode-toolkit" rel="nofollow">https://github.com/nexB/scancode-toolkit</a> I maintain too.</p>
<p>And if you really want to expose a web service, you could reuse this approach and package that with a simple web server (like the one built-in in the Python standard lib or bottle or flask or gunicorn) and provide <code>configure.sh</code> to install it all and generate the command line to launch it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your task is (in generality) about productionizing a machine learning model, where the consumer of the model may not be working in the same environment as the one which was used to develop the model. I've been trying to tackle this problem since past few years. The problem is faced by many companies and it is aggravated due to skill set, objectives as well as environment (languages, run time) mismatch between data scientists and developers. From my experience, following solutions/options are available, each with its unique advantages and downsides.</p>
<ul>
<li><p><strong>Option 1</strong> : Build the prediction part of your model as a standalone web service using any lightweight tool in Python (for example, Flask). You should try to decouple the model development/training and prediction part as much as possible. The model that you have developed, must be serialized to some form so that the web server can use it. </p>
<ul>
<li>How frequently is your machine learning model updated? If it is not done very frequently, the serialized model file (example: Python pickle file) can be saved to a common location accessible to the web server (say s3), loaded in memory. The standalone web server should offer APIs for prediction.</li>
<li><p>Please note that exposing a single model prediction using Flask would be simple. But scaling this web server if needed, configuring it with right set of libraries, authentication of incoming requests are all non-trivial tasks. You should choose this route only if you have dev teams ready to help with these.</p></li>
<li><p>If the model gets updated frequently, versioning your model file would be a good option. So in fact, you can piggyback on top of any version control system by checking in the whole model file if it is not too large. The web server can de-serialize (pickle.load) this file at startup/update and convert to a Python object on which you can call prediction methods.</p></li>
</ul></li>
<li><p><strong>Option 2</strong> : use <a href="https://en.wikipedia.org/wiki/Predictive_Model_Markup_Language" rel="nofollow" title="predictive modeling markup language">predictive modeling markup language</a>. PMML was developed specifically for this purpose: predictive modeling data interchange format independent of environment. So data scientist can develop model, export it to a PMML file. The web server used for prediction can then consume the PMML file for doing predictions. You should definitely check <a href="https://github.com/jpmml/openscoring" rel="nofollow">the open scoring project</a> which allows you to expose machine learning models via REST APIs for deploying models and making predictions.</p>
<ul>
<li>Pros: PMML is standardized format, open scoring is a mature project with good development history.</li>
<li>Cons: PMML may not support all models. Open scoring is primarily useful if your tech team's choice of development platform is JVM. Exporting machine learning models from Python is not straightforward. But R has good support for exporting models as PMML files.</li>
</ul></li>
<li><strong>Option 3</strong> : There are <a href="https://www.yhat.com/products/scienceops" rel="nofollow">some vendors offering dedicated solutions for this problem</a>. You will have to evaluate cost of licensing, cost of hardware as well as stability of the offerings for taking this route.</li>
</ul>
<p>Whichever option you choose, please consider the long term costs of supporting that option. If your work is in a proof of concept stage, Python flask based web server + pickled model files will be the best route. Hope this answer helps you!</p>
</div>
<div class="post-text" itemprop="text">
<p>As already suggested in other answers the best option would be creating a simple web service. Besides Flask you may want to try <a href="http://bottlepy.org" rel="nofollow">bottle</a> which is very thin one-file web framework. Your service may looks as simple as:</p>
<pre><code>from bottle import route, run, request

@route('/')
def index():
    return my_function(request.json)

run(host='0.0.0.0', port=8080)
</code></pre>
<p>In order to keep environments the same check <a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" rel="nofollow">virtualenv</a> to make isolated environment for avoiding conflicts with already installed packages and <a href="https://pip.pypa.io/en/stable/" rel="nofollow">pip</a> to install exact version of packages into virtual environment.</p>
</div>
<div class="post-text" itemprop="text">
<p>I guess you have 3 possibilities :</p>
<ul>
<li>convert python function to javascript function:</li>
</ul>
<p><em>Assuming the "tech-team" use Javascript for web-service, you may try to convert your python function directly to a Javascript function (which will be really easy to integrate on web page) using <a href="https://github.com/replit/empythoned" rel="nofollow">empythoned</a> (based on <a href="https://github.com/kripken/" rel="nofollow">emscripten</a>)</em></p>
<p>The bad point of this method is that each time you need update/upgrade your python function, you need also to convert to Javascript again, then check &amp; validate that the function continue to work.</p>
<ul>
<li>simple API server + JQuery</li>
</ul>
<p>If the conversion method is impossible, I am agree with @justin-bell, you may use  FLASK</p>
<p><em>getting JSON as input &gt; JSON to your function parameter &gt; run python function &gt; convert function result to JSON &gt; serve the JSON result</em> </p>
<p>Assuming you choose the FLASK solution, "tech-team" will only need to send an async. GET/POST request containing all the arguments as JSON obj, when they need to get some result from your python function.</p>
<ul>
<li>websocket server + socket.io</li>
</ul>
<p>You can also use take a look on Websocket to dispatch to the webservice (look at flask + websocket for your side &amp; <a href="http://socket.io/" rel="nofollow">socket.io</a> for webservice side.) </p>
<p>=&gt; <em>websocket is really usefull when you need to push/receive data with low cost and latency to (or from) a lot of users</em>  (Not sure that websocket will be the best fit to your need)</p>
<p>Regards</p>
</div>
<span class="comment-copy">try to look at <code>pex</code> tool <a href="https://github.com/pantsbuild/pex" rel="nofollow noreferrer">github.com/pantsbuild/pex</a></span>
<span class="comment-copy">You might try standing up a Django server and using the Django REST framework, <a href="http://www.django-rest-framework.org/" rel="nofollow noreferrer">django-rest-framework.org</a>. You could control the environment, those who know how to code could edit functions. Those who do not could simply call a URL and pass JSON data back and forth using curl or similar. This can easily be integrated into a higher level web-service.</span>
<span class="comment-copy">Regarding question 2, you might want to write some unit tests. If the unit tests passes on the web team, then it should be good to go.</span>
<span class="comment-copy">Can you explain a bit about their web service? Does your function have to work seamlessly with theirs? I mean that in the sense that does it have to be automatic and migrated into their service? If not you could just have a flask web application with basic html input (text field, text area, file upload, etc etc etc whatever fits your needs) that would take your input and return your output to the user. They could access the application from a link. You can entirely disregard this idea if it doesn't apply. As I really don't know much about how your tech team works I don't know if this will help</span>
<span class="comment-copy">However, if you went with this approach it could still be automatic in the sense that they could have a super simple web scraper that would go to your tool, input the data, and scrape the output. Depending on their knowledge (do they have any programming skills?), it would be a simple task and only a couple lines of code. If any of this seems like it could work I could walk you through writing the flask application. It would be relatively short. Just an html input routed to a function that grabs the input, which passes it to your function.</span>
<span class="comment-copy">Two further thoughts...  1) Your answer would be better (and it is generally encoraged on SO) if you embedded your code directly rather than linked to an external gist.  2) What about the version control aspect of the OP's question?</span>
<span class="comment-copy">What's the meaning of the <code>@app</code> notation? It's the first time I ever see something like that in Python. Also, please suggest using HTTP<b>S</b> rather than HTTP.</span>
<span class="comment-copy">I am not sure this answers fully the main question: how do you distribute a Python function?</span>
<span class="comment-copy">@PeterBrittain in my answer <a href="http://stackoverflow.com/a/38891638/302521">stackoverflow.com/a/38891638/302521</a> I am trying to address more specifically the OP's question. What do you think?</span>
<span class="comment-copy">@ray - The <code>@</code> indicates a decorator in python. You can read more in the <a href="https://docs.python.org/3/glossary.html#term-decorator" rel="nofollow noreferrer">docs</a>. <a href="http://stackoverflow.com/a/15839702/4991266">This answer</a> does a great job of explaining it's use in Flask</span>
