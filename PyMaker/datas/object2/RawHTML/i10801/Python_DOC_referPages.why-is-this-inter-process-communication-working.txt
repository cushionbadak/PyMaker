<div class="post-text" itemprop="text">
<p>In Python, exchanging objects between processes is well documented: queues, pipes or pools should be used (see <a href="https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes" rel="nofollow">doc</a>). So why is this super simple code working without any of these communication tools?</p>
<pre><code>from multiprocessing import Process
from time import sleep
from random import random

class Child_process(Process):

  def __init__(self):
    super(Child_process,self).__init__()
    self._memory = {'a':1}

  def writeInMemory(self,key,value):
    self._memory[key]=value

  def readFromMemory(self,key):
    return self._memory[key]

  def run(self):
    while True:
      sleep(random())

def main():
  # start up the child process:
  child = Child_process()
  child.daemon=True
  child.start()
  print 'Type Ctrl C to stop'
  while True:
    print "in sub process a = ", child.readFromMemory('a')
    child.writeInMemory('b',random())
    print "in sub process b = ", child.readFromMemory('b')
    sleep(5*random())
  # exiting
  child.terminate()
  child.join()

if __name__ == '__main__':
  main()
</code></pre>
<p>Result is</p>
<pre><code>Type Ctrl C to stop
in sub process a =  1
in sub process b =  0.469400505093
in sub process a =  1
in sub process b =  0.43154478374
in sub process a =  1
in sub process b =  0.519863589476
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That's because <strong>no</strong> interprocess communication is happening.</p>
<p>Modify the code to print the value of <code>_memory</code> in the child process:</p>
<pre><code>def run(self):
    while True:
        print('Memory is', self._memory)
        sleep(random())
</code></pre>
<p>And you'll see that the memory inside the subprocess never changes.</p>
<p>A sample output is:</p>
<pre><code>Type Ctrl C to stop
in sub process a =  1
in sub process b =  0.571476878791
('memory', {'a': 1})
('memory', {'a': 1})
('memory', {'a': 1})
('memory', {'a': 1})
in sub process a =  1
in sub process b =  0.0574249557159
('memory', {'a': 1})
('memory', {'a': 1})
</code></pre>
<p>Note how it always prints:</p>
<pre><code>('memory', {'a':1})
</code></pre>
<p>instead of, say:</p>
<pre><code>('memory', {'a': 1, 'b': 0.0574249557159})
</code></pre>
<p>So what is happening is that all your calls are <em>local</em>. you are spawning a subprocess that does nothing and you aren't performing any communication with it. The subprocess when is spawned <em>copies</em> the <code>_memory</code> attribute but that attribute is then never modified, and your changes in the main process do not affect the child process.</p>
<hr/>
<p>To be dead clear: you are basically wasting a subprocess. You are spawning one without making <em>any</em> use out of it, and after spawning it you are treating your <code>child</code> exactly as any other python object. </p>
</div>
<span class="comment-copy">As far as I see you are initiating only one child process. You are printing "In sub-process a/b" in a while loop which is running in main method. I don't see any inter-process communication.</span>
<span class="comment-copy">OK. I understand now. Thanks a lot.</span>
<span class="comment-copy">Do you mean that self._memory in child  is different from child._memory in main process?</span>
<span class="comment-copy">@user3650925 Yes. When you call <code>start()</code> this starts the subprocess which basically <b>copies</b> the memory of the current process and then executes the code of the <code>run</code> method (in the subprocess). Note that the behaviour can be different between Windows and Linux/Os X due to how they handle subprocesses...</span>
<span class="comment-copy">Thanks it is clear now :-)</span>
<span class="comment-copy">Should my question title be changed in order not to confuse others ?</span>
