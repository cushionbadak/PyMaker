<div class="post-text" itemprop="text">
<p>I'm trying to validate a certificate with a CA bundle file. The original Bash command takes two file arguments like this;</p>
<pre><code>openssl verify -CAfile ca-ssl.ca cert-ssl.crt
</code></pre>
<p>I'm trying to figure out how to run the above command in python subprocess whilst having ca-ssl.ca and cert-ssl.crt as variable strings (as opposed to files). </p>
<p>If I ran the command with variables (instead of files) in bash then this would work;</p>
<pre><code>ca_value=$(&lt;ca-ssl.ca)
cert_value=$(&lt;cert-ssl.crt)

openssl verify -CAfile &lt;(echo "$ca_value") &lt;(echo "$cert_value")
</code></pre>
<p>However, I'm struggling to figure out how to do the above with Python, preferably without needing to use <code>shell=True</code>. I have tried the following but doesn't work and instead prints 'help' commands for openssl;</p>
<pre><code>certificate = ''' cert string '''
ca_bundle = ''' ca bundle string '''

def ca_valid(cert, ca):
    ca_validation = subprocess.Popen(['openssl', 'verify', '-CAfile', ca, cert], stdin=subprocess.PIPE, stdout=subprocess.PIPE,  bufsize=1)
    ca_validation_output = ca_validation.communicate()[0].strip()
    ca_validation.wait()

ca_valid(certificate, ca_bundle)
</code></pre>
<p>Any guidance/clues on what I need to look further into would be appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<p>Bash process substitution <code>&lt;(...)</code> in the end is supplying a file path as an argument to  <code>openssl</code>. </p>
<p>You will need to make a helper function to create this functionality since Python doesn't have any operators that allow you to inline pipe data into a file and present its path:</p>
<pre><code>import subprocess
def validate_ca(cert, ca):
    with filearg(ca) as ca_path, filearg(cert) as cert_path:
        ca_validation = subprocess.Popen(
            ['openssl', 'verify', '-CAfile', ca_path, cert_path],
            stdout=subprocess.PIPE,
        )
        return ca_validation.communicate()[0].strip()
</code></pre>
<p>Where <code>filearg</code> is a context manager which creates a named temporary file with your desired text, closes it, hands the path to you, and then removes it after the <code>with</code> scope ends.</p>
<pre><code>import os
import tempfile
from contextlib import contextmanager

@contextmanger
def filearg(txt):
    with tempfile.NamedTemporaryFile('w', delete=False) as fh:
        fh.write(txt)
    try:
        yield fh.name
    finally:
        os.remove(fh.name)
</code></pre>
<p>Anything accessing this temporary file(like the subprocess) needs to work inside the context manager.</p>
<p>By the way, the  <code>Popen.wait(self)</code> is redundant since <code>Popen.communicate(self)</code> waits for termination.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use process substitution, you will <em>have</em> to use <code>shell=True</code>. This is unavoidable. The <code>&lt;(...)</code> process substitution syntax is bash syntax; you simply must call bash into service to parse and execute such code.</p>
<p>Additionally, you have to ensure that <code>bash</code> is invoked, as opposed to <code>sh</code>. On some systems <code>sh</code> may refer to an old Bourne shell (as opposed to the Bourne-again shell <code>bash</code>) in which case process substitution will definitely not work. On some systems <code>sh</code> will invoke <code>bash</code>, but process substitution will still not work, because when invoked under the name <code>sh</code> the <code>bash</code> shell enters something called POSIX mode. Here are some excerpts from the <code>bash</code> man page:</p>
<blockquote>
<p>...</p>
<p>INVOCATION</p>
<p>... When invoked as sh, bash enters posix mode after the startup files are read. ....</p>
<p>...</p>
<p>SEE ALSO</p>
<p>...</p>
<p><a href="http://tiswww.case.edu/~chet/bash/POSIX" rel="nofollow">http://tiswww.case.edu/~chet/bash/POSIX</a> -- a description of posix mode</p>
<p>...</p>
</blockquote>
<p>From the above web link:</p>
<blockquote>
<ol start="28">
<li>Process substitution is not available.</li>
</ol>
</blockquote>
<p><code>/bin/sh</code>  seems to be the default shell in python, whether you're using <code>os.system()</code> or <code>subprocess.Popen()</code>. So you'll have to specify the argument <code>executable='bash'</code>, or <code>executable='/bin/bash'</code> if you want to specify the full path.</p>
<p>This is working for me:</p>
<pre><code>subprocess.Popen('printf \'argument: "%s"\\n\' verify -CAfile &lt;(echo ca_value) &lt;(echo cert_value);',executable='bash',shell=True).wait();
## argument: "verify"
## argument: "-CAfile"
## argument: "/dev/fd/63"
## argument: "/dev/fd/62"
## 0
</code></pre>
<hr/>
<p>Here's how you can actually embed the string values from variables:</p>
<pre><code>bashEsc = lambda s: "'"+s.replace("'","'\\''")+"'";
ca_value = 'x';
cert_value = 'y';
cmd = 'printf \'argument: "%%s"\\n\' verify -CAfile &lt;(echo %s) &lt;(echo %s);'%(bashEsc(ca_value),bashEsc(cert_value));
subprocess.Popen(cmd,executable='bash',shell=True).wait();
## argument: "verify"
## argument: "-CAfile"
## argument: "/dev/fd/63"
## argument: "/dev/fd/62"
## 0
</code></pre>
</div>
<span class="comment-copy">As an easy way out, would you consider using <a href="https://docs.python.org/3/library/tempfile.html" rel="nofollow noreferrer">tempfile</a> module?</span>
<span class="comment-copy">Maybe use <code>os.system()</code> instead?</span>
<span class="comment-copy">are you sure you have the command right? when I run the command that would be constructed by your list directly in a terminal, I also get openssl's usage help string.</span>
<span class="comment-copy">One more thing, you forgot to <code>import subprocess</code></span>
<span class="comment-copy">Process substitution actually does use files in <code>/dev/fd/</code> You may want to just use <a href="https://docs.python.org/2/library/tempfile.html" rel="nofollow noreferrer"><code>tempfile</code></a> to create a NamedTemporaryFile object, write to it, and pass its .name attribute to subprocess.</span>
