<div class="post-text" itemprop="text">
<p>If I have an IP address I can use it as a key in a dict as follows:</p>
<pre><code>dict = {}
IP = "172.23.1.99"
dict[IP] = "pear"
</code></pre>
<p>However, if I have a lot of them this is very memory inefficient. </p>
<blockquote>
<p>How can I convert the IP to a 32 bit representation which I can still
  use a key in a dict?</p>
</blockquote>
<p>I could just convert the IP to an int. But python ints seem to consume 24 bytes each which is 192 bits so this <strong>does not</strong> solve my problem.</p>
<pre><code>In [2]: sys.getsizeof(2**32-1)
Out[2]: 24
</code></pre>
<p>As I have  100s of millions of these IPs I would really like to represent them as 32 bits each.</p>
<p>From the comments it seems this may be hard in pure Python. I would be happy with a practical non-pure solution too (including using numpy or any other easily available package).</p>
</div>
<div class="post-text" itemprop="text">
<p>Given the number of entries you intend to store, I suggest you use SQLite. It's both easy and probably efficient enough. In fact, it has the nice property that for every record it uses only as much space as necessary. For an IP address that is between 1 and 5 bytes depending on the IP address (so on average, 3 bytes).</p>
<p>Here's an example:</p>
<pre><code>from ipaddress import ip_address
import sqlite3

# Create an in-memory database.*
db_connection = sqlite3.connect(':memory:')
cursor = db_connection.cursor()
cursor.execute('''
    CREATE TABLE ip_address_associations (
        ip_address INTEGER PRIMARY KEY, 
        value TEXT
    )
''')

# Store the value for an IP address
cursor.execute(
    'INSERT OR REPLACE INTO ip_address_associations VALUES (?, ?)', 
    (int(ip_address('172.23.1.99')), 'pear')
)

# Retrieve the value for an IP address
row = cursor.execute(
    'SELECT value FROM ip_address_associations WHERE ip_address = ?', 
    (int(ip_address('172.23.1.99')),)
).fetchone()
if row:
    value = row[0]
    print(value)
else:
    print('No results found.')
</code></pre>
<p>*Although I don't know exactly what your application is about, I highly suspect that there's no need to keep the whole database in memory all the time. You can save greatly on memory usage while not losing too much in access time by using a (temporary) file and relying on file caching. Replace <code>':memory:'</code> by <code>''</code> for a temporary file, or by a filename for a persistent one. </p>
</div>
<div class="post-text" itemprop="text">
<p>Yes you can use the <a href="https://docs.python.org/3/library/ipaddress.html#module-ipaddress" rel="nofollow"><code>ipaddress</code></a>  module:</p>
<pre><code>from ipaddress import ip_address
int(ip_address('172.23.1.99'))
</code></pre>
<p>output:</p>
<pre><code>2887188835
</code></pre>
<p>and back:</p>
<pre><code>from ipaddress import ip_address
str(ip_address(2887188835))
</code></pre>
<p>output:</p>
<pre><code>'172.23.1.99'
</code></pre>
</div>
<span class="comment-copy">How many are 'a lot'? What 32 bit represenation to you want?</span>
<span class="comment-copy">You can convert with this <code>first_part+2**8*second_part+2**16*third_part+2**32*fourth_part</code>. This will be 64-bit though</span>
<span class="comment-copy">@eleanora: you cannot make "standalone" integers smaller in Python, that's the best you can get; objects in general are really fat in Python. If you have 100s of millions of IPs to keep in memory probably a Python dictionary is not a good idea anyway (you could use instead a custom, compact data structure exported by a C or C++ extension).</span>
<span class="comment-copy">@caiohamamura: that's what I thought, but a numpy array is - well - an array, while she's trying to have an associative container. If this data structure is not updated often an easy solution could be a numpy array for the keys and a regular list for the values, sorted by keys. The lookup then could be O(log n) through binary search. But again, the exact choice of a "big" data structure is extremely dependent from the required access pattern.</span>
<span class="comment-copy">@eleanora: it's not like integers in particular are "fat", it's that <i>all</i> objects in Python are fat. Every "standalone" object in CPython/64 bit has a pointer to its type (8 bytes) and a reference count (8 byte), so it's 16 bytes <i>minimum</i> for everything (that's the price to pay to have the type on the value instead of on the variable, plus the reference counting); then, any kind of payload you may add requires <i>at least</i> other 8 bytes to keep stuff aligned, so 24 bytes is the minimum you can get on a 64 bit system.</span>
<span class="comment-copy">This is an interesting suggestion.</span>
<span class="comment-copy">@eleanora Interesting enough to accept it? ;)</span>
<span class="comment-copy">This doesn't answer the question sadly.</span>
