<div class="post-text" itemprop="text">
<p>For my project I need to dynamically create custom (Class) methods.</p>
<p>I found out it is not so easy in Python:</p>
<pre><code>class UserFilter(django_filters.FilterSet):
    '''
    This filter is used in the API
    '''
    # legacy below, this has to be added dynamically
    #is_field_type1 = MethodFilter(action='filter_field_type1') 

    #def filter_field_type1(self, queryset, value):
    #    return queryset.filter(related_field__field_type1=value)

    class Meta:
        model = get_user_model()
        fields = []
</code></pre>
<p>But it is giving me errors (and headaches...). Is this even possible?</p>
<p>I try to make the code between #legacy dynamic</p>
<p>One option to do this I found was to create the class dynamically</p>
<pre><code>def create_filter_dict():
    new_dict = {}
    for field in list_of_fields:

        def func(queryset, value):
            _filter = {'stableuser__'+field:value}
            return queryset.filter(**_filter)

        new_dict.update({'filter_'+field: func})

        new_dict.update({'is_'+field: MethodFilter(action='filter_'+field)})

    return new_dict


meta_model_dict = {'model': get_user_model(), 'fields':[]}
meta_type = type('Meta',(), meta_model_dict)

filter_dict = create_filter_dict()
filter_dict['Meta'] = meta_type
UserFilter = type('UserFilter', (django_filters.FilterSet,), filter_dict)
</code></pre>
<p>However, this is giving me</p>
<pre><code>TypeError at /api/v2/users/
func() takes 2 positional arguments but 3 were given
</code></pre>
<p>Does anyone know how to solve this dilemma?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Exception Value: 'UserFilter' object has no attribute 'is_bound'</p>
</blockquote>
<p>You are getting this error because the class methods you are generating, are not bound to any class. To bound them to the class, you need to use setattr()</p>
<p>Try this on a console:</p>
<pre><code>class MyClass(object):
    pass

@classmethod 
def unbound(cls):
    print "Now I'm bound to ", cls


print unbound
setattr(MyClass, "bound", unbound) 
print MyClass.bound 
print MyClass.bound()
</code></pre>
<blockquote>
<p>Traceback:
      UserFilter = type('Foo', (django_filters.FilterSet, ), create_filter_dict().update({'Meta':type('Meta',(), {'model':
  get_user_model(), 'fields':[]} )})) TypeError: type() argument 3 must
  be dict, not None</p>
</blockquote>
<p>Now, this is failing because dict.update() doesn't return the same instance, returns None. That can be fixed easily </p>
<pre><code>class_dict = create_filter_dict()
class_dict.update({'Meta':type('Meta',(), {'model': get_user_model(), 'fields':[]})}
UserFilter = type('Foo', (django_filters.FilterSet, ), class_dict))
</code></pre>
<p>However, just look how messy that code looks. I recommend to you to try to be
clearer with the code you write even if it requires to write a few extra lines. In the long run, the code will be easier to maintain for you and your team.</p>
<pre><code>meta_model_dict = {'model': get_user_model(), 'fields':[]}
meta_type = type('Meta',(), meta_model_dict)

filter_dict = create_filter_dict()
filter_dict['Meta'] = meta_type
UserFilter = type('Foo', (django_filters.FilterSet,), filter_dict)
</code></pre>
<p>This code might not be perfect but it is more readable than the original line of code you posted: </p>
<pre><code>UserFilter = type('Foo', (django_filters.FilterSet, ), create_filter_dict().update({'Meta':type('Meta',(), {'model': get_user_model(), 'fields':[]})}))
</code></pre>
<p>And removes a complication on an already kinda difficult concept to grasp.</p>
<p>You might want to learn about metaclasses. Maybe you can overwrite the <strong>new</strong> method of a class. I can recommend you <a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/" rel="nofollow">1</a> or <a href="http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example" rel="nofollow">2</a> posts about that. </p>
<p>Another option is that maybe you are not adding the filters correctly or in a way django doesn't expect? That would explain why you get no errors but none of your functions gets called.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html?highlight=classmethod#classmethod" rel="nofollow">classmethod</a>. Here is example how you can use it:</p>
<pre><code>class UserFilter:
    @classmethod
    def filter_field(cls, queryset, value, field = None):
        # do somthing
        return "{0} ==&gt; {1} {2}".format(field, queryset, value)
    @classmethod
    def init(cls,list_of_fields ):
        for field in list_of_fields:
            ff = lambda cls, queryset, value, field=field: cls.filter_field(queryset, value, field )
            setattr(cls, 'filter_'+field, classmethod( ff ))

UserFilter.init( ['a','b'] )
print(UserFilter.filter_a(1,2)) # a ==&gt; 1 2
print(UserFilter.filter_b(3,4)) # b ==&gt; 3 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are asking for:</p>
<blockquote>
<p>custom (Class) methods.</p>
</blockquote>
<p>So we take an existing class and derive a subclass where you can add new methods or overwrite the methods of the original existing class (look into the code of the original class for the methods you need) like this:</p>
<pre><code>from universe import World
class NewEarth(World.Earth):
   def newDirectionUpsideDown(self,direction):
       self.rotationDirection = direction
</code></pre>
<p>All the other Methods and features of World.Earth apply to NewEarth only you can now change the direction to make the world turn your new way.</p>
<p>To overwrite an existing method of a class is as as easy as this.</p>
<pre><code>class NewEarth(World.Earth):
   def leIitRain(self,amount): # let's assume leIitRain() is a standard-function of our world
       return self.asteroidStorm(amount) #let's assume this is possible Method of World.Earth
</code></pre>
<p>So if someone likes a cool shower on earth he/she/it or whatever makes room for new development on the toy marble the burning way.</p>
<p>So have fun in your way learning python - and don't start with complicated things.</p>
<p>If I got you completely wrong - you might explain your problem in more detail - so more wise people than me can share their wisdom.</p>
</div>
<span class="comment-copy">"this does not work" is probably just about the worst way you could possibly give a diagnosis of your issue</span>
<span class="comment-copy">That's not how you create a classmethod. What are you even trying to do here? You have a class definition inside another class definition (which is totally possible, just surely not what you want)... wha problem are you even trying to solve?</span>
<span class="comment-copy">show the complete traceback</span>
<span class="comment-copy">Trying to change the <code>FilterSet</code> class in <code>__init__()</code> is already much too late. At that point, <a href="https://github.com/carltongibson/django-filter/blob/a21dc78fee0d8c7bef093ea20633d7c11e8859f5/django_filters/filterset.py#L146" rel="nofollow noreferrer"><code>FilterSetMetaclass</code></a> has already done all the relevant setup. You need to either build the <code>FilterSet</code> class dynamically (<code>type()</code>) or dig into django-filter and find a better way.</span>
<span class="comment-copy">The error you're getting in EDIT 3 is because <code>dict.update</code> returns <code>None</code>, not the <code>dict</code>.</span>
<span class="comment-copy">Wow, I really learned something today and although I did not check the answer yet, this is really going to help me build it! Also the references you mention about metaclass are great! Bounty well spent :)</span>
<span class="comment-copy">Okay, it does not work yet. Still trying, so any thoughts would be much appreciated!</span>
<span class="comment-copy">Have you tried to add a simple filter that works well maybe for just one case? Try to see what it's making that work, and what you might be missing.</span>
<span class="comment-copy">It does not give me any errors, but is also does not add the filter to the query. I think your code does not play well with django_filters.</span>
<span class="comment-copy">Sorry, I mean a custom <i>dynamiccally generated</i> class method. So your example of inheritance is not going to answer the question.</span>
<span class="comment-copy">If I search on <a href="http://django-filter.readthedocs.io/en/latest/index.html" rel="nofollow noreferrer">django-filter.readthedocs.io/en/latest/index.html</a> nothing states that you should use dynamic classes or dynamic functions/methods. MAYBE the word "dynamically" in the comments is misleading?</span>
