<div class="post-text" itemprop="text">
<p>I want to populate three lists: <code>A</code>, <code>B</code> and <code>C</code></p>
<p>I have a function that based on a singular input returns N objects that should append to each list. That is, <code>f</code> returns <code>stuff_for_A</code>, <code>stuff_for_B</code>, <code>stuff_for_C</code> where each <code>stuff</code> is a list containing N items. I want to <em>join</em> each of those to their respective lists as I loop over the iterable that sends input to <code>f</code>.</p>
<p>How can I write a super fast list comprehension to create these 3 lists?</p>
<p>Note: I can restructure the output of <code>f</code> (such as zipping the items together) if that makes things easier.</p>
<p>EDIT: Here's some pseudo-code with the bottom list comprehension being incorrect.</p>
<pre><code>def f(input):
    x = precompute(input)
    stuff_for_A = create_A_list(x)
    stuff_for_B = create_B_list(x)
    stuff_for_C = create_C_list(x)
    return stuff_for_A,stuff_for_B,stuff_for_C
A,B,C = [f(input) for input in iterable]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If <code>A</code>, <code>B</code>, and <code>C</code> exist, the following will update them with the returned values from <code>f</code>:</p>
<p><code>list(map(lambda x: x[0].extend(x[1]), zip([A,B,C], f())))</code></p>
<p><code>list</code> is called, cause <code>map</code> is lazy in python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>It appears that you want the same result as</p>
<pre><code>A = [create_A_list(input) for input in iterable]
B = [create_B_list(input) for input in iterable]
C = [create_C_list(input) for input in iterable]
</code></pre>
<p>but with only one pass over <code>iterable</code>. With an explicit <code>for</code> loop, you would use</p>
<pre><code>A = []
B = []
C = []
for input in iterable:
    A.append(create_A_input(input))
    B.append(create_B_input(input))
    C.append(create_C_input(input))
</code></pre>
<p>With a single list comprehension, you can get a list of triples:</p>
<pre><code>triples = [ (create_A_input(input),
             create_B_input(input),
             create_C_input(input)) for input in iterable ]
</code></pre>
<p>which you could then transpose into a triple of lists:</p>
<pre><code>A, B, C = map(list, zip(*[(create_A_input(input),
                           create_B_input(input),
                           create_C_input(input)) for input in iterable]))
</code></pre>
<p>Your original <code>f</code> function returns a triple, so you can use use that in place of the triple in the preceding:</p>
<pre><code>A, B, C = map(list, zip(*[f(input) for input in iterable)]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To create the lists from the <em>returned</em> tuples, you can use that multiple assignment with <code>zip</code> and <em>unpacking</em> on a generator expression:</p>
<pre><code>def f(input):
    ...
    return stuff_for_A,stuff_for_B,stuff_for_C

A, B, C = zip(*(f(input) for input in iterable))
</code></pre>
<p>This will return the respective items for each list grouped in 3 tuples.</p>
<hr/>
<p><em>Trial:</em></p>
<pre><code>&gt;&gt;&gt; A, B, C = zip(*[(1,2,3), (4,5,6), ('x', 'y', 'z'), (8,9,0)])
&gt;&gt;&gt; A
(1, 4, 'x', 8)
&gt;&gt;&gt; B
(2, 5, 'y', 9)
&gt;&gt;&gt; C
(3, 6, 'z', 0)
</code></pre>
<p>To return them as lists instead, you can use a <em>list comprehension</em> with the previous operation:</p>
<pre><code>&gt;&gt;&gt; A, B, C = [list(i) for i in zip(*[(1,2,3), (4,5,6), ('x', 'y', 'z'), (8,9,0)])]
&gt;&gt;&gt; A
[1, 4, 'x', 8]
&gt;&gt;&gt; B
[2, 5, 'y', 9]
&gt;&gt;&gt; C
[3, 6, 'z', 0]
</code></pre>
<hr/>
<p>In the event the function returns a tuple of 3 iterables, then you can use <code>itertools.chain</code> to flatten the results from <code>zip</code>:</p>
<pre><code>from itertools import chain

A, B, C =  (list(chain.from_iterable(i))
            for i in zip(*(f(input) 
                           for input in iterable)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Extend A, B, C directly, without returning things?</p>
<pre><code>iterable = range(10)
A, B, C = [], [], []

def f(item):
    A.extend([item * 2])
    B.extend([item * 3])
    C.extend([item * 4])

map(f, iterable)
print A
print B
print C
</code></pre>
<p><a href="https://repl.it/Chl6" rel="nofollow">https://repl.it/Chl6</a></p>
<p>(I use <code>.extend()</code> with lists inside because your functions return lists, otherwise use <code>A.add(thing)</code> to add individual things. I also renamed <code>input</code> to <code>item</code> because <code>input()</code> is a built-in function in Python)</p>
</div>
<span class="comment-copy">Your question is grammatically clear, but one can't understand precisely what you want to do without seeing some code or pseudo-code.</span>
<span class="comment-copy">Can you add your code? As for function <code>f</code>, does it return a dictionary mapping each list to its relevant object?</span>
<span class="comment-copy">Added some pseudo code. f doesn't currently return a dictionary, should it?</span>
<span class="comment-copy">Are lists <code>A,B,C</code> already existing? And do you want to extend the list with- or append the new items?</span>
<span class="comment-copy">@MosesKoledoye, nope, A,B,C don't exist yet, I want the list comprehension to create them. As you can see there are many opportunities to restructure...</span>
<span class="comment-copy">Not sure what <code>zip([A,B,C], f())</code> does, is the parenthesis mismatched?</span>
<span class="comment-copy">From the docs: "Zip makes an iterator that aggregates elements from each of the iterables". Here it returns a tuple matching each list to its relevant data returned by <code>f</code>, then <code>map</code> applies the <code>extend</code> function <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#zip</a></span>
<span class="comment-copy">Very clear. One question: would you expect the list comprehension here to be faster than the explicit for loop? Would it be better to have some generator expression instead of (createA(),createB(),createC())? I'm not sure under what conditions the comprehension is faster in general, probably that's another question...</span>
<span class="comment-copy">I suspect there isn't much difference in speed between the explicit loop and the list comprehension. The generator-based solution is possibly <i>slower</i> than <code>zip(*[...])</code>, but is visually cleaner; generators are optimized for memory usage, not speed of execution.</span>
<span class="comment-copy"><code>A, B, C = zip([f(x) for f in (create_A_input, create_B_input, create_C_input)] for x in iterable]</code> should work as well.</span>
<span class="comment-copy">Right, so problem with this answer is that it doesn't join the results from create_A_input etc, it makes a list of their results.</span>
<span class="comment-copy">Updated (with a couple of small fixes) to use <code>f</code>.</span>
<span class="comment-copy">Problem: in your trial you aren't testing the right thing. <code>f</code> outputs a list of lists, say <code>[A1,A2,A3],[B1,B2,B3],[C1,C2,C3]</code> for each in <code>iterable</code>. I want to join all the As (etc) together across all the iterables so I end up with three lists <code>[A1,A2,A3,A4,A5,...]</code>,<code>[B1,B2,B3,B4,B5...]</code> etc</span>
<span class="comment-copy">@cgreen You can use <code>chain</code> to flatten the lists like I've done. You may however consider rewriting that function e.g. to mutate <code>A,B,C</code> instead :)</span>
<span class="comment-copy">Sorry, what would you return from <code>f</code> so you don't have to use <code>chain</code>?</span>
<span class="comment-copy"><code>extend</code> the lists <code>A,B,C</code> (passed as parameters) with the results whenever the function is called.</span>
<span class="comment-copy">Try not to use <code>map</code> just for the side effect of <code>f</code>; it creates a list (of <code>None</code> values, in this case) that is immediately discarded. Just use a <code>for</code> loop instead: <code>for i in iterable: f(i)</code>.</span>
