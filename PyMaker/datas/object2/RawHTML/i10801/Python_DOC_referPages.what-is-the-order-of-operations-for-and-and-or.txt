<div class="post-text" itemprop="text">
<p>In Python is this:</p>
<pre><code>def blackjack_check(hand): # hand is a tuple
    winning_cards = [10,'Jack','Queen','King']
    if hand[0] in winning_cards and hand[1] == 'Ace':
        return True
    elif hand[0] == 'Ace' and hand[1] in winning_cards:
        return True
    else:
        return False
</code></pre>
<p>the same as this...?</p>
<pre><code>def blackjack_check(hand): # hand is a tuple
    winning_cards = [10,'Jack','Queen','King']
    if (hand[0] in winning_cards and hand[1]=='Ace' or 
        hand[0] == 'Ace' and hand[1] in winning_cards):
        return True
    else:
        return False
</code></pre>
<p>Can I use the second code block instead of the first?  It would eliminate an extra elif statement and it just seems cleaner.
My concern is how the 'and' and 'or' operators work.  Are the two 'and' comparisons separate and the 'or' compares them?  Is there an order of operations for 'and' and 'or'?
I ran the code and it works both ways but I want to make sure I understand exactly how the operators work.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, the second code block is equivalent to the first one. According to <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="nofollow">the documentation</a>, <code>or</code> has lower precedence than <code>and</code>. It means that the if statement is evaluated as</p>
<pre><code>if ((hand[0] in winning_cards and hand[1] == 'Ace') or 
    (hand[0] == 'Ace' and hand[1] in winning_cards)):
</code></pre>
<p>which is what you want.</p>
<p>You could return the result of that boolean expression to shorten the code:</p>
<pre><code>def blackjack_check(hand):
    winning_cards = [10, 'Jack', 'Queen', 'King']
    return (hand[0] in winning_cards and hand[1] == 'Ace' or 
            hand[0] == 'Ace' and hand[1] in winning_cards)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/38733915/736937">vaultah's answer</a> addresses your actual question perfectly -- they deserve the upvote and checkmark.</p>
<p>But I think programming blackjack in every language you're learning is an excellent way to better understand it, so I threw together code to show a different way to implement the blackjack test.  More for educational purposes than to actually answer your question:</p>
<pre><code># Note: sometimes an Ace should be 1, but when checking for blackjack you can always 
#   consider it 11
def card_value(c):
    if isinstance(c, int):
        return c
    elif c in ['Jack', 'Queen', 'King']:
        return 10
    elif c == 'Ace':
        return 11

def blackjack_check(hand):
    hand_value = sum(card_value(c) for c in hand)
    return hand_value == 21

print(blackjack_check((2, 10)))             # False
print(blackjack_check((10, 10)))            # False
print(blackjack_check((2, 'Ace')))          # False
print(blackjack_check(('King', 'Jack')))    # False
print(blackjack_check(('King', 'Ace')))     # True
print(blackjack_check(('Ace', 'Queen')))    # True
</code></pre>
<p>If I were to implement it today, Cards and Hands would be classes, and there'd be a <code>Hand.is_blackjack()</code> method, like:</p>
<pre><code>import random

class Card:
    NAMES = {1: 'Ace', 11:'Jack', 12:'Queen', 13:'King'}
    def __init__(self, pips, suit):
        self.pips = pips
        self.suit = suit

    def __repr__(self):
        name = Card.NAMES.get(self.pips, "%d" % self.pips)
        return "%s of %s" % (name, self.suit)

    def value(self, ace_hi=True):
        # Handle Ace
        if self.pips == 1:
            return 11 if ace_hi else 1
        return min(self.pips, 10)

class Hand(list):
    def is_blackjack(self):
        hand_value = sum(c.value() for c in self)
        return hand_value == 21

CARDS = [Card(p,s) for p in range(1,14) for s in ['Spades', 'Hearts', 'Clubs', 'Diamonds']]

h = Hand(random.sample(CARDS, 2))

print("Hand:")
for c in h:
    print("  %s" % c)

print("Blackjack? %s" % h.is_blackjack())
</code></pre>
<p>Examples:</p>
<pre>
Hand:
  Jack of Spades
  Ace of Spades
Blackjack? True

Hand:
  Queen of Spades
  9 of Diamonds
Blackjack? False
</pre>
<p>Sorry for the silly non-answer, but these are just different ideas to think about.  Don't worry if they're over your head, you'll get there.</p>
</div>
<div class="post-text" itemprop="text">
<p>The usual advice is if you don't know, then your readers might not know either, and it would be better for everybody if you use parentheses.</p>
<pre><code>if ((hand[0] in winning_cards and hand[1]=='Ace') or 
    (hand[0] == 'Ace' and hand[1] in winning_cards)):
</code></pre>
<p>although you might try other formulations, such as</p>
<pre><code>if (any(card == 'Ace' for card in hand) and
    any(card in winning_cards for card in hand)):
</code></pre>
<p>or writing a helper function and using</p>
<pre><code>if hascard(hand, ('Ace',)) and hascard(hand, winning_cards):
</code></pre>
</div>
<span class="comment-copy"><code>'Ace' in hand and any(x in winning_cards for x in hand[0:2])</code></span>
<span class="comment-copy">Thank you, I really appreciate your answer here, it was really helpful.  I was curious about how you are using your classes.  It looks to me like you're using Python3 because of your print statements...When you define the Card class I notice that you don't have an argument in parenthesis after, is that just a python2 vs 3 thing?   Also, you use list as your argument for the Hand class...does that mean you plan on passing a list object into that class?</span>
<span class="comment-copy">I see...random.sample() returns a list object that you can then pass into the Hand class</span>
<span class="comment-copy">@Chris do you mean the line <code>class Card:</code>?  That just means there is no explicit superclass that <code>Card</code> should be extending.  On the other hand, <code>Hand</code> extends the standard <code>list</code> class.  I did write this in Python 3, in Python 2 you'd likely want to use <code>class Card(object):</code> as good practice, but I'm not sure it's necessary.  To your second question, <code>class Hand(list):</code> means that I want <code>Hand</code> to operate exactly as a list would (indexing, <code>.append()</code> method, etc), except in cases where I define.  Here, I added a <code>is_blackjack()</code> method to the class.  Minus that method, <code>Hand</code> instances...</span>
<span class="comment-copy">... (cont'd) will behave exactly as standard <code>list</code>s would.  More specifically, I'm making <code>Hand</code> a <i>subclass</i> of <code>list</code> and <i>extending</i> it (via the <code>is_blackjack()</code> method).  Hope this helps and let me know if you have any more questions :)</span>
