<div class="post-text" itemprop="text">
<p>I want to insert an item into an OrderedDict at a certain position.
Using the <a href="https://gist.github.com/jaredks/6276032" rel="nofollow noreferrer">gist</a> of <a href="https://stackoverflow.com/a/18326914/1504082">this</a> SO answer i have the problem that it doesn't work on python 3.</p>
<p>This is the implementation used</p>
<pre><code>from collections import OrderedDict

class ListDict(OrderedDict):

    def __init__(self, *args, **kwargs):
        super(ListDict, self).__init__(*args, **kwargs)

    def __insertion(self, link_prev, key_value):
        key, value = key_value
        if link_prev[2] != key:
            if key in self:
                del self[key]
            link_next = link_prev[1]
            self._OrderedDict__map[key] = link_prev[1] = link_next[0] = [link_prev, link_next, key]
        dict.__setitem__(self, key, value)

    def insert_after(self, existing_key, key_value):
        self.__insertion(self._OrderedDict__map[existing_key], key_value)

    def insert_before(self, existing_key, key_value):
        self.__insertion(self._OrderedDict__map[existing_key][0], key_value)
</code></pre>
<p>Using it like</p>
<pre><code>ld = ListDict([(1,1), (2,2), (3,3)])
ld.insert_before(2, (1.5, 1.5))
</code></pre>
<p>gives</p>
<pre><code>File "...", line 35, in insert_before
    self.__insertion(self._OrderedDict__map[existing_key][0], key_value)
AttributeError: 'ListDict' object has no attribute '_OrderedDict__map'
</code></pre>
<p>It works with python 2.7. What is the reason that it fails in python 3?
Checking the source code of the <a href="https://hg.python.org/cpython/file/3.5/Lib/collections/__init__.py" rel="nofollow noreferrer">OrderedDict</a> implementation shows that <code>self.__map</code> is used instead of <code>self._OrderedDict__map</code>. Changing the code to the usage of <code>self.__map</code> gives</p>
<pre><code>AttributeError: 'ListDict' object has no attribute '_ListDict__map'
</code></pre>
<p>How come? And how can i make this work in python 3? OrderedDict uses the internal <code>__map</code> attribute to store a doubly linked list. So how can i access this attribute properly?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure you wouldn't be better served just keeping up with a separate list and dict in your code, but here is a stab at a pure Python implementation of such an object. This will be an order of magnitude slower than an actual <code>OrderedDict</code> in Python 3.5, which as I pointed out in my comment <a href="https://bugs.python.org/issue16991" rel="nofollow">has been rewritten in C</a>.</p>
<pre><code>"""
A list/dict hybrid; like OrderedDict with insert_before and insert_after
"""
import collections.abc


class MutableOrderingDict(collections.abc.MutableMapping):
    def __init__(self, iterable_or_mapping=None, **kw):
        # This mimics dict's initialization and accepts the same arguments
        # Of course, you have to pass an ordered iterable or mapping unless you
        # want the order to be arbitrary. Garbage in, garbage out and all :)
        self.__data = {}
        self.__keys = []
        if iterable_or_mapping is not None:
            try:
                iterable = iterable_or_mapping.items()
            except AttributeError:
                iterable = iterable_or_mapping
            for key, value in iterable:
                self.__keys.append(key)
                self.__data[key] = value
        for key, value in kw.items():
            self.__keys.append(key)
            self.__data[key] = value

    def insert_before(self, key, new_key, value):
        try:
            self.__keys.insert(self.__keys.index(key), new_key)
        except ValueError:
            raise KeyError(key) from ValueError
        else:
            self.__data[new_key] = value

    def insert_after(self, key, new_key, value):
        try:
            self.__keys.insert(self.__keys.index(key) + 1, new_key)
        except ValueError:
            raise KeyError(key) from ValueError
        else:
            self.__data[new_key] = value

    def __getitem__(self, key):
        return self.__data[key]

    def __setitem__(self, key, value):
        self.__keys.append(key)
        self.__data[key] = value

    def __delitem__(self, key):
        del self.__data[key]
        self.__keys.remove(key)

    def __iter__(self):
        return iter(self.__keys)

    def __len__(self):
        return len(self.__keys)

    def __contains__(self, key):
        return key in self.__keys

    def __eq__(self, other):
        try:
            return (self.__data == dict(other.items()) and
                    self.__keys == list(other.keys()))
        except AttributeError:
            return False

    def keys(self):
        for key in self.__keys:
            yield key

    def items(self):
        for key in self.__keys:
            yield key, self.__data[key]

    def values(self):
        for key in self.__keys:
            yield self.__data[key]

    def get(self, key, default=None):
        try:
            return self.__data[key]
        except KeyError:
            return default

    def pop(self, key, default=None):
        value = self.get(key, default)
        self.__delitem__(key)
        return value

    def popitem(self):
        try:
            return self.__data.pop(self.__keys.pop())
        except IndexError:
            raise KeyError('%s is empty' % self.__class__.__name__)


    def clear(self):
        self.__keys = []
        self.__data = {}

    def update(self, mapping):
        for key, value in mapping.items():
            self.__keys.append(key)
            self.__data[key] = value

    def setdefault(self, key, default):
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return self[key]

    def __repr__(self):
        return 'MutableOrderingDict(%s)' % ', '.join(('%r: %r' % (k, v)
                                                      for k, v in self.items()))
</code></pre>
<p>I ended up implementing the whole <code>collections.abc.MutableMapping</code> contract because none of the methods were very long, but you probably won't use all of them. In particular, <code>__eq__</code> and <code>popitem</code> are a little arbitrary. I changed your signature on the <code>insert_*</code> methods to a 4-argument one that feels a little more natural to me. Final note: Only tested on Python 3.5. Certainly will not work on Python 2 without some (minor) changes.</p>
</div>
<div class="post-text" itemprop="text">
<p>Trying out the new dict object in 3.7 and thought I'd try to implement what Two-Bit Alchemist had done with his answer but just overriding the native dict class because in 3.7 dict's are ordered.</p>
<pre><code>''' Script that extends python3.7 dictionary to include insert_before and insert_after methods. '''
from sys import exit as sExit

class MutableDict(dict):
    ''' Class that extends python3.7 dictionary to include insert_before and insert_after methods. '''

    def insert_before(self, key, newKey, val):
        ''' Insert newKey:value into dict before key'''
        try:
            __keys = list(self.keys())
            __vals = list(self.values())

            insertAt = __keys.index(key)

            __keys.insert(insertAt, newKey)
            __vals.insert(insertAt, val)

            self.clear()
            self.update({x: __vals[i] for i, x in enumerate(__keys)})

        except ValueError as e:
            sExit(e)

    def insert_after(self, key, newKey, val):
        ''' Insert newKey:value into dict after key'''
        try:
            __keys = list(self.keys())
            __vals = list(self.values())

            insertAt = __keys.index(key) + 1

            if __keys[-1] != key:
                __keys.insert(insertAt, newKey)
                __vals.insert(insertAt, val)
                self.clear()
                self.update({x: __vals[i] for i, x in enumerate(__keys)})
            else:
                self.update({newKey: val})

        except ValueError as e:
            sExit(e)
</code></pre>
<p>A little testing:</p>
<pre><code> In: v = MutableDict([('a', 1), ('b', 2), ('c', 3)])
Out: {'a': 1, 'b': 2, 'c': 3}

 In: v.insert_before('a', 'g', 5)
Out: {'g': 5, 'a': 1, 'b': 2, 'c': 3}

 In: v.insert_after('b', 't', 5)
Out: {'g': 5, 'a': 1, 'b': 2, 't': 5, 'c': 3}
</code></pre>
<p>Edit: I decided to do a little benchmark test to see what kind of performance hit this would take. I will use <code>from timeit import timeit</code></p>
<p>Get a baseline. Create a dict with arbitrary values.</p>
<pre><code> In: timeit('{x: ord(x) for x in string.ascii_lowercase[:27]}', setup='import string', number=1000000)
Out: 1.8214202160015702
</code></pre>
<p>See how much longer it would take to initialize the MutableDict with the same arbitrary values as before.</p>
<pre><code> In: timeit('MD({x: ord(x) for x in string.ascii_lowercase[:27]})', setup='import string; from MutableDict import MutableDict as MD', number=1000000)
Out: 2.382507269998314
</code></pre>
<p>1.82 / 2.38 = 0.76. So if I'm thinking about this right MutableDict is 24% slower on creation.</p>
<p>Lets see how long it takes to do an insert. For this test I'll use the insert_after method as it is slightly bigger. Will also look for a key close to the end for insertion. 't' in this case. </p>
<pre><code> In: timeit('v.insert_after("t", "zzrr", ord("z"))', setup='import string; from MutableDict import MutableDict as MD; v = MD({x: ord(x) for x in string.ascii_lowercase[:27]})' ,number=1000000)
Out: 3.9161406760104
</code></pre>
<p>2.38 / 3.91 = 0.60, 40% slower inserting_after than it's initialization. Not bad on a small test of 1 million loops. For a comparison in time relation we'll test this:</p>
<pre><code> In: timeit('"-".join(map(str, range(100)))', number=1000000)
Out: 10.342204540997045
</code></pre>
<p>Not quite an apples to apples comparison but I hope these tests will aid you in your(reader not necessarily OP) decision to use or not use this class in your 3.7 projects.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.2, <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict.move_to_end" rel="nofollow"><code>move_to_end</code></a> can be used to move items around in an <a href="https://docs.python.org/3/library/collections.html#ordereddict-objects" rel="nofollow"><code>OrderedDict</code></a>. The following code will implement the <code>insert</code> functionality by moving all items after the provided index to the end.</p>
<p>Note that this isn't very efficient and should be used sparingly (if at all).</p>
<pre><code>def ordered_dict_insert(ordered_dict, index, key, value):
    if key in ordered_dict:
        raise KeyError("Key already exists")
    if index &lt; 0 or index &gt; len(ordered_dict):
        raise IndexError("Index out of range")

    keys = list(ordered_dict.keys())[index:]
    ordered_dict[key] = value
    for k in keys:
        ordered_dict.move_to_end(k)
</code></pre>
<p>There are obvious optimizations and improvements that could be made, but that's the general idea.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import OrderedDict

od1 = OrderedDict([
    ('a', 1),
    ('b', 2),
    ('d', 4),
])

items = od1.items()
items.insert(2, ('c', 3))
od2 = OrderedDict(items)

print(od2)  # OrderedDict([('a', 1), ('b', 2), ('c', 3), ('d', 4)])
</code></pre>
</div>
<span class="comment-copy">If the question is why <code>self.__map</code> doesn't work, see <a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python">this question</a>. As for why the code works in python2 but not in python3, I have no idea.</span>
<span class="comment-copy">Very helpful, thanks. Did know this double underscore rule. But it doesn't answer the question.</span>
<span class="comment-copy">I believe <code>OrderedDict</code> was <a href="https://bugs.python.org/issue16991" rel="nofollow noreferrer">redone in Python 3.5 to be in C, not Python</a>, so probably whatever private structure was <code>self.__map</code> before is no longer accessible in Python. This is why when devs use whatever little they have available to say something is not to be messed with in Python, you should listen and not try to depend on it in your subclasses.</span>
<span class="comment-copy">This is what happens when you screw with implementation details. The implementation details change, and you get screwed.</span>
<span class="comment-copy">Thanks for this complete code snippet! I tried to use the python only implementation of ordered dict of the <b>init</b> file in my question and reimplemented the insert_* methods there. Interestingly a performance benchmark showed that its 3 times slower (for a small dict) than your or a "list and create a new ordered dict from the modified list" implementation. I just would love to see it beeing easier to subclass an OrderedDict...</span>
<span class="comment-copy">Python 3, not 2.</span>
<span class="comment-copy">This doesn't implement insertion on an <code>OrderedDict</code>. This creates an entirely new OrderedDict.</span>
