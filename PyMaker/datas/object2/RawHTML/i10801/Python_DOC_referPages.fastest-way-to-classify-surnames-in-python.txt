<div class="post-text" itemprop="text">
<p>I have a list with 12K asian surnames from a census and a list with 200K names. I'd like to classify those 200K people as asians or non-asians based on wether their surname appears on my 12K list.</p>
<p>Is there a fast way to verify if one of the elemenst in the list contains one of the surnames in the 12K list?</p>
</div>
<div class="post-text" itemprop="text">
<p>The best way to do this is to convert your 12K list into a set data structure. Then you can iterate over the census data and check if each is in the set.</p>
<pre><code># O(n) where n is the length of the surname_list
surname_set = set(surname_list)

for name in census:
    # This is now O(1) operation
    if name in surname_set:
        do whatever...
</code></pre>
<p>This is almost certainly the fastest way to accomplish what you need in Python or any language, and should be reasonably fast on a 200K sized list.</p>
<p>Wai Leong Yeow suggests a binary search, which is faster than just checking the list directly, but that will still be a O(log n) operation on 200K different names, where N is 12,000, meaning it will likely be more than 10x slower just for the iterative part (This is a simplification - in reality there are some constant factors masked by the big O notation, but the constant time solution is certainly still faster). Sorting it will take O(n log n) time, where as turning it into a set takes O(n) time, meaning that this method has faster preprocessing as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>It depend to your real problem. do you want machine learning(as you tag: classification) to predict asian/non-asian name?</p>
<p>If yes: Try some semi supervised methods. To do this, first randomly select(near 10%) of your 200k data, then search for it in 12k, if it exist, label it to 1, else label it to 0. then use some classification algorithm like, Random Forest,SVM or KNN. You can also model your names something like Bag Of word(In your problem Bag Of Letter! or something like that): <a href="https://en.wikipedia.org/wiki/Bag-of-words_model" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Bag-of-words_model</a></p>
<p>for classification task, take a look at scikit-learn lib: <a href="http://scikit-learn.org/" rel="nofollow noreferrer">http://scikit-learn.org/</a></p>
<hr/>
<p>If NO(you don't want to use machine learning solutions):
There exist some fast string search algorithm that search a string in a corpus of other string with some Technics. there are many algorithm, like Boyer Moore: <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm</a></p>
<p>For more details this can be good: <a href="https://softwareengineering.stackexchange.com/questions/183725/which-string-search-algorithm-is-actually-the-fastest">https://softwareengineering.stackexchange.com/questions/183725/which-string-search-algorithm-is-actually-the-fastest</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I would recommend to use <a href="https://en.wikipedia.org/wiki/Locality-sensitive_hashing" rel="nofollow">local sensitive hashing</a> in the first step before training any machine learning models. That probably will help as you don't have many features. If you want something stronger you can use Naive Bayes and some feature engineering. </p>
</div>
<div class="post-text" itemprop="text">
<p>Depends on what you mean by "fast".</p>
<p>James suggested using Python's built-in <code>set</code> to test for membership. Python's <code>set</code> implementation uses hash tables. <strong>Average</strong> time complexity is O(1) but the worst case <em>can</em> be O(n) where n is the cardinality of the set of asian surnames. So in the <strong>worst case</strong> scenario, you <em>might</em> just end up with O(mn) instead of O(m) where m is the cardinality of the set of names to classify.</p>
<p>For reference, see: <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow">https://wiki.python.org/moin/TimeComplexity</a></p>
<p>If you want to have a guarantee on the worst case, you can achieve it with sorting the set <code>n</code> and doing binary search. This will end up with O(m lg n) time complexity.</p>
<p>Binary search: <a href="https://docs.python.org/3.1/library/bisect.html" rel="nofollow">https://docs.python.org/3.1/library/bisect.html</a></p>
<p>It really depends on how well the hashing function works for your data.</p>
</div>
<span class="comment-copy">Make a <code>set</code> from your list of surnames then <a href="https://docs.python.org/3/reference/expressions.html#membership-test-operations" rel="nofollow noreferrer">test for membership</a></span>
<span class="comment-copy">It's  socially biased to consider names-&gt;race and even the motivation race classification itself is rather disturbing: <a href="https://techcrunch.com/2015/08/02/machine-learning-and-human-bias-an-uneasy-pair/" rel="nofollow noreferrer">techcrunch.com/2015/08/02/â€¦</a> and <a href="http://www.fatml.org/cfp.html" rel="nofollow noreferrer">fatml.org/cfp.html</a></span>
<span class="comment-copy">OP is also going to have some ambiguous classifications with names like Lee or Long. Non-Asians can have those names, too.</span>
<span class="comment-copy">What happen if they're american chinese having last names like <code>Scotts</code>?</span>
<span class="comment-copy">What's the point of training a model to emulate looking up words in a list you already have? If you want to train a model, find negative data that is <i>not</i> just as likely to be false negatives. And if you want to do straight string matching, there is a far simpler solution: <code>set()</code>.</span>
<span class="comment-copy">@alexis, as I mentioned, it depend to a problem, for example you want to classify 200k name, per second and want to retrieve the result as fastest as possible(because user ask 'the fastest way'), I mentioned 'it Depend'</span>
<span class="comment-copy">Are you saying that a statistical classifier would be faster than a lookup in a set? That's just impossible.</span>
<span class="comment-copy">@alexis almost No, but sometime you don't have lookup table</span>
<span class="comment-copy">The question states there is a lookup table, and your answer requires one.</span>
<span class="comment-copy">Please add <i>why</i> you solution is the fastest. According to the answer by <a href="http://stackoverflow.com/a/38548652/5488275">James</a>, your approach might be quite slow for this particular problem.</span>
<span class="comment-copy">@NanderSpeerstra I've edited the answer. Basically it's the worst case guarantee.</span>
<span class="comment-copy">When you're hashing strings, the chances of running up against that worst case are slim to none. It's very unlikely you'll run up against the worst case with anything <i>unless</i> you're writing your own hash function - the built-in has functions are certainly robust enough to handle strings. I removed my downvote because your answer does add something now, but it's certainly worth mentioning that it's astronomically unlikely for the asker to run up against this worst case.</span>
