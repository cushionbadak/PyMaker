<div class="post-text" itemprop="text">
<p>I have class Count which takes 3 parameters including self, mystart and myend. It should count from mystart until myend (also reversed)  using magic methods <code>__iter__</code>, <code>__next__</code> and <code>__reversed__</code>.  I have implemented all three magic methods. But I am still not sure whether it is the right way to implemnet next and reversed methods. Is it possible that I can call built-in functions next and reversed inside my  <code>__next__</code> and <code>__reversed__</code> methods or is there any pythonic way?</p>
<pre><code>class Count:

    def __init__(self,mystart,myend):
        self.mystart=mystart
        self.myend=myend
        self.current=mystart
        self.reverse=[]


    def __iter__(self):
        "Returns itself as an Iterator Object"
        return self

    def __next__(self):
        if self.current &gt; self.myend:
            raise StopIteration
        else:
            self.current+=1
            return self.current-1

    def __reversed__(self):
        for i in range(self.myend,self.mystart,-1):
            self.reverse.append(i)
        return self.reverse


obj1=Count(0,10)
print("FOR LOOP")
for i in obj1:
    print (i,end=",")

print ("\nNEXT")
obj2=Count(1,4)
print(next(obj2))
print(next(obj2))

print ("Reversed")
print(reversed(obj1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Now I have done it using yield statement. @jedwards thanks for your tipp.</p>
<pre><code>class Count:

    def __init__(self, mystart,myend):
        self.mystart = mystart
        self.myend = myend
        self.current=None

    def __iter__(self):
        self.current = self.mystart
        while self.current &lt; self.myend:
            yield self.current
            self.current += 1 

    def __next__(self):
        if self.current is None:
            self.current=self.mystart                
        if self.current &gt; self.myend:
            raise StopIteration
        else:
            self.current+=1
            return self.current-1

    def __reversed__(self):
        self.current = self.myend
        while self.current &gt;= self.mystart:
            yield self.current
            self.current -= 1

obj1=Count(0,10)    
for i in obj1:
    print (i)

obj2=reversed(obj1)
for i in obj2:
    print (i)

obj3=Count(0,10)
print (next(obj3))
print (next(obj3))
print (next(obj3))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are mixing up Iterators and Iterables:</p>
<p>Iterators:</p>
<ol>
<li>Keep a state associated with their current iteration progress</li>
<li>Implement <code>__next__</code> to get the next state</li>
<li>Implement <code>__iter__</code> to return themselves.</li>
</ol>
<p>Iterables:</p>
<ol>
<li>Contain (or define with some rule) a collection of elements that can be traversed</li>
<li>Implement <code>__iter__</code> to return an iterator that can traverse the elements</li>
<li>can implement <code>__reversed__</code> to return an iterator that goes backwards.</li>
</ol>
<p><a href="https://docs.python.org/3/reference/datamodel.html#object.__reversed__" rel="nofollow noreferrer">The <code>__reversed__</code> magic method is:</a></p>
<blockquote>
<p>Called (if present) by the reversed() built-in to implement reverse
  iteration. It should return <em>a new iterator object</em> that iterates over
  all the objects in the container in reverse order.</p>
</blockquote>
<p>So you probably don't want to implement an iterator that can be <code>__reversed__</code> mid iteration, for example the implementation <a href="https://stackoverflow.com/a/38750543/5827215">in your answer</a> means that this code:</p>
<pre><code>x = Count(1,10)
for i in x:
    for j in x:
        print(i,j)
</code></pre>
<p>Will cause an infinite loop, the output is just this pattern repeated:</p>
<pre><code>1 4
1 3
1 2
1 1
</code></pre>
<p>the reason for this is because both <code>for</code> loops are changing <code>self.current</code> in opposite directions, the outer loop will increment it by 1 then the inner loop will set it to <code>self.myend</code> and lower it back to 0, then the process repeats.</p>
<p>The only way to properly implement all three magic methods is to use two classes, one for the iterator and one for the iterable:</p>
<pre><code>class _Count_iter:
    def __init__(self, start, stop, step=1):
        self.current = start
        self.step = step
        self.myend = stop

    def __iter__(self):return self

    def __next__(self):
        #if current is one step over the end
        if self.current == self.myend+self.step: 
            raise StopIteration
        else:
            self.current+=self.step
            return self.current-self.step


class Count:

    def __init__(self, mystart,myend):
        self.mystart = mystart
        self.myend = myend

    def __iter__(self):
        return _Count_iter(self.mystart,self.myend,1)
    def __reversed__(self):
        return _Count_iter(self.myend, self.mystart, -1)
</code></pre>
</div>
<span class="comment-copy">In order for us to know what the "right" way is, what is the desired result. Your code doesn't look that bad</span>
<span class="comment-copy">But I am creating a new list in my <b>reversed</b> method which does not give me good feeling. :)</span>
<span class="comment-copy">It doesn't make much sense to give an iterator a <code>__reversed__</code> method. That's for sequences and other multi-shot iterables with an ordering notion.</span>
<span class="comment-copy">You're right in that it's probably not "the right way".  "The right way" would be to make <code>__reversed__</code> a generator of some sort.  Using <code>yield</code> would probably be the easiest approach.  (You'll have to compute the indices going backwards, but this doesn't seem too difficult given your example)</span>
<span class="comment-copy">Note: your <code>__next__</code> method is useless, because when iterating python will call <code>__next__</code> of <i>the generator</i> returned by <code>__iter__</code> (add a <code>print</code> and check that it is never called). this said <code>current</code> is now only a <i>local variable</i> for <code>__iter__</code> and <code>__reversed__</code> so you should really just use <code>current</code> in place of <code>self.current</code> and remove <code>self.current = None</code> from <code>__init__</code>.</span>
<span class="comment-copy">Yes, you are right.</span>
