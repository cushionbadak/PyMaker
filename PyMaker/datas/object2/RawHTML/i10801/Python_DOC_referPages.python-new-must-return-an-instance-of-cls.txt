<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow">According to the docs,</a></p>
<blockquote>
<p>Typical implementations create a new instance of the class by invoking
  the superclass’s <code>__new__()</code> method using <code>super(currentclass,
  cls).__new__(cls[, ...])</code> with appropriate arguments and then modifying
  the newly-created instance as necessary before returning it. <br/>
  ...</p>
<p>If <code>__new__</code> does not return an instance of cls, then the new
  instance’s <code>__init__()</code> method will not be invoked.</p>
</blockquote>
<p>The <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow">simplest implementation of <code>__new__</code>:</a></p>
<pre><code>class MyClass:
    def __new__(cls):
        RetVal = super(currentclass, cls).__new__(cls)
        return RetVal
</code></pre>
<p>How exactly does <code>super(currentclass, cls).__new__(cls[, ...])</code> return an object of type <code>cls</code>?</p>
<p>That statement calls <code>object.__new__(cls)</code> where <code>cls</code> is <code>MyClass</code>.</p>
<p>So how would class <code>object</code> know how to create the type <code>MyClass</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>super(MyClass, cls).__new__(cls)</code> first searches the MRO (method resolution order) of the <code>cls</code> object (skipping past <code>MyClass</code> in that sequence), until it finds an object with a <code>__new__</code> attribute.</p>
<p>In your case, that is <code>object.__new__</code>:</p>
<pre><code>&gt;&gt;&gt; class MyClass:
...     def __new__(cls):
...         RetVal = super(MyClass, cls).__new__(cls)
...         return RetVal
...
&gt;&gt;&gt; MyClass.__mro__
(&lt;class '__main__.MyClass'&gt;, &lt;class 'object'&gt;)
&gt;&gt;&gt; hasattr(MyClass.__mro__[1], '__new__')
True
</code></pre>
<p>but if you subclassed <code>MyClass</code> and mixed in another class into the MRO with a <code>__new__</code> method then it <em>could</em> be another method.</p>
<p><code>object.__new__</code> is implemented in C, see the <a href="https://hg.python.org/cpython/file/v3.5.1/Objects/typeobject.c#l3405" rel="nofollow"><code>object_new()</code> function</a>; it contains a hook for abstract base classes to make sure you are not trying to instantiate an abstract class, then delegates to the <code>tp_alloc</code> slot, which usually will be set to <a href="https://hg.python.org/cpython/file/v3.5.1/Objects/typeobject.c#l933" rel="nofollow"><code>PyType_GenericAlloc</code></a>, which adds a new <code>PyObject</code> struct to the heap. It is that struct that represents the instance to the interpreter.</p>
</div>
<div class="post-text" itemprop="text">
<p>Few things, first of all you need to write explicit inheritance from <code>object</code> like this:</p>
<pre><code>class MyClass(object):
</code></pre>
<p>You should read about <a href="https://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python">old classes and new classes</a> on python(only on python 2, in python 3 it does not matter)</p>
<p>For your question, I think you missed the point or syntax of <code>super()</code> functions. Again, small change to your code:</p>
<pre><code>RetVal = super(MyClass, cls).__new__(cls)
</code></pre>
<p>In this way you reference to the parent-class by using <code>super(MyClass, cls)</code> and calling a method from this parent-class <strong>new</strong>(of course you can use any other method)</p>
<p><strong>edit</strong>
After reading your comments, I'll just add that <code>super()</code> doesn't have to take any arguments in Python 3 so maybe it's more trivial for you.  Highly recommended to read more about the <code>super()</code> <a href="https://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods">here</a></p>
</div>
<span class="comment-copy">You <i>told</i> it what type the returned object should have. That's what the <code>cls</code> parameter is for.</span>
<span class="comment-copy">@user2357112 I don't get your answer. The return type it expects is <code>cls</code>. How does <code>super(currentclass, cls).__new__(cls)</code> return a <code>cls</code>? Are you saying it implicitly casts it?</span>
<span class="comment-copy"><code>object.__new__</code> looks at the <code>cls</code> parameter you passed it and says, "Gee, I guess Adrian wants an object of type <code>cls</code>. I should make one of those."</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/38661438/python-super-two-argument-version-in-context-of-new">Didn't I just answer that for you a few hours ago?</a></span>
<span class="comment-copy">@Adrian: that's an entirely different question; I have written <a href="https://stackoverflow.com/search?q=user%3A100297+super+self+class+type">several answers about <code>super()</code> that cover this</a> and more.</span>
<span class="comment-copy">Shouldn't <code>currentclass</code> be replaced by <code>MyClass</code>?</span>
<span class="comment-copy">@Adrian: I was following your example in your question. Yes, a correct invocation would use <code>MyClass</code>.</span>
<span class="comment-copy">@Adrian: then I don't know what to point you to. That documentation is spot on.</span>
<span class="comment-copy">@Adrian: <code>super(type)</code> returns an unbound proxy, <code>super(type, object-or-type)</code> produces bound attributes. The proxy uses attribute access to search the MRO in the same way <code>getattr()</code> does, skipping <code>type</code> in that order.</span>
<span class="comment-copy">@Adrian: the documentation makes assumptions about you knowing what MRO is, and what binding does. Also see <a href="https://stackoverflow.com/q/30190185">How can I use super() with one argument in python</a> where I dive into what binding means and how the one-argument from can be bound after-the-fact.</span>
<span class="comment-copy">I understand the intended effects. I don't get what passing <code>cls</code> to <code>super</code> <b>in addition to</b> <code>MyClass</code> does.</span>
<span class="comment-copy">I know that <code>issubclass(class2, class1)</code> must be true but why does <code>super</code> need <code>cls</code> to return whatever it returns?</span>
<span class="comment-copy">That's a question about <code>super()</code>, not about <code>__new__()</code>.</span>
<span class="comment-copy">@Adrian I added links so you can read more about it, it's different question and should be answer on different thread.</span>
