<div class="post-text" itemprop="text">
<p>I know rounding errors happen in floating point arithmetic but can somebody explain the reason for this one:</p>
<pre><code>&gt;&gt;&gt; 8.0 / 0.4  # as expected
20.0
&gt;&gt;&gt; floor(8.0 / 0.4)  # int works too
20
&gt;&gt;&gt; 8.0 // 0.4  # expecting 20.0
19.0
</code></pre>
<p>This happens on both Python 2 and 3 on x64.</p>
<p>As far as I see it this is either a bug or a very dumb specification of <code>//</code> since I don't see any reason why the last expression should evaluate to <code>19.0</code>.</p>
<p>Why isn't <code>a // b</code> simply defined as <code>floor(a / b)</code> ?</p>
<p><strong>EDIT</strong>: <code>8.0 % 0.4</code> also evaluates to <code>0.3999999999999996</code>. At least this is consequent since then <code>8.0 // 0.4 * 0.4 + 8.0 % 0.4</code> evaluates to <code>8.0</code></p>
<p><strong>EDIT</strong>: This is not a duplicate of <a href="https://stackoverflow.com/questions/588004">Is floating point math broken?</a> since I am asking why this specific operation is subject to (maybe avoidable) rounding errors, and why <code>a // b</code> isn't defined as / equal to <code>floor(a / b)</code></p>
<p><strong>REMARK</strong>: I guess that the deeper reason why this doesn't work is that floor division is discontinuous and thus has an infinite <a href="https://en.wikipedia.org/wiki/Condition_number" rel="nofollow noreferrer">condition number</a> making it an ill-posed problem. Floor division and floating-point numbers simply are fundamentally incompatible and you should never use <code>//</code> on floats. Just use integers or fractions instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>As you and khelwood already noticed, <code>0.4</code> cannot be exactly represented as a float. Why? It is two fifth (<code>4/10 == 2/5</code>) which does not have a finite binary fraction representation.</p>
<p>Try this:</p>
<pre><code>from fractions import Fraction
Fraction('8.0') // Fraction('0.4')
    # or equivalently
    #     Fraction(8, 1) // Fraction(2, 5)
    # or
    #     Fraction('8/1') // Fraction('2/5')
# 20
</code></pre>
<p>However</p>
<pre><code>Fraction('8') // Fraction(0.4)
# 19
</code></pre>
<p>Here, <code>0.4</code> is interpreted as a float literal (and thus a floating point binary number) which requires (binary) rounding, and only <em>then</em> converted to the rational number <code>Fraction(3602879701896397, 9007199254740992)</code>, which is almost but not exactly 4 / 10. Then the floored division is executed, and because </p>
<pre><code>19 * Fraction(3602879701896397, 9007199254740992) &lt; 8.0
</code></pre>
<p>and </p>
<pre><code>20 * Fraction(3602879701896397, 9007199254740992) &gt; 8.0
</code></pre>
<p>the result is 19, not 20.</p>
<p>The same probably happens for</p>
<pre><code>8.0 // 0.4
</code></pre>
<p>I.e., it seems floored division is determined atomically (but on the only approximate float values of the interpreted float literals).</p>
<p>So why does</p>
<pre><code>floor(8.0 / 0.4)
</code></pre>
<p>give the "right" result? Because there, two rounding errors cancel each other out. <em>First</em><sup> 1)</sup> the division is performed, yielding something slightly smaller than 20.0, but not representable as float. It gets rounded to the closest float, which happens to be <code>20.0</code>. Only <em>then</em>, the <code>floor</code> operation is performed, but now acting on <em>exactly</em> <code>20.0</code>, thus not changing the number any more.</p>
<hr/>
<p><sup>1)</sup> As Kyle Strand <a href="https://stackoverflow.com/questions/38588815/rounding-errors-in-python-floor-division/38589899?noredirect=1#comment64578429_38589356">points out</a>, that the exact result is determined <em>then</em> rounded <strong>isn't</strong> what <em>actually</em> happens low<sup>2)</sup>-level (CPython's C code or even CPU instructions). However, it can be a useful model for determining the expected<sup> 3)</sup> result.</p>
<p><sup>2)</sup> On the <em>lowest</em><sup> 4)</sup> level, however, this might not be too far off. Some chipsets determine float results by first computing a more precise (but still not exact, simply has some more binary digits) internal floating point result and then rounding to IEEE double precision.</p>
<p><sup>3)</sup> "expected" by the Python specification, not necessarily by our intuition.</p>
<p><sup>4)</sup> Well, lowest level <em>above</em> logic gates. We don't have to consider the quantum mechanics that make semiconductors possible to understand this.</p>
</div>
<div class="post-text" itemprop="text">
<p>@jotasi explained the true reason behind it.</p>
<p>However if you want to prevent it, you can use <code>decimal</code> module which was basically designed to represent decimal floating point numbers exactly in contrast to binary floating point representation.</p>
<p>So in your case you could do something like:</p>
<pre><code>&gt;&gt;&gt; from decimal import *
&gt;&gt;&gt; Decimal('8.0')//Decimal('0.4')
Decimal('20')
</code></pre>
<p><strong>Reference:</strong> <a href="https://docs.python.org/2/library/decimal.html" rel="nofollow">https://docs.python.org/2/library/decimal.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Ok after a little bit of research I have found this <a href="https://bugs.python.org/issue27463" rel="nofollow noreferrer">issue</a>. 
What seems to be happening is, that as @khelwood suggested <code>0.4</code> evaluates internally to <code>0.40000000000000002220</code>, which when dividing <code>8.0</code> yields something slightly smaller than <code>20.0</code>. The <code>/</code> operator then rounds to the nearest floating point number, which is <code>20.0</code>, but the <code>//</code> operator immediately truncates the result, yielding <code>19.0</code>.</p>
<p>This should be faster and I suppose its "close to the processor", but I it still isn't what the user wants / is expecting.</p>
</div>
<div class="post-text" itemprop="text">
<p>That's because there is no 0.4 in python (floating-point finite representation) it's actually a float like <code>0.4000000000000001</code> which makes the floor of division to be 19.</p>
<pre><code>&gt;&gt;&gt; floor(8//0.4000000000000001)
19.0
</code></pre>
<p>But the true division (<code>/</code>) <a href="https://www.python.org/dev/peps/pep-0238/" rel="nofollow">returns a reasonable approximation of the division result if the arguments are floats or complex.</a> And that's why the result of <code>8.0/0.4</code> is 20. It actually depends on the size of arguments (in C double arguments). (<strong>not rounding to nearest float</strong>)</p>
<p>Read more about <a href="http://python-history.blogspot.co.uk/2010/08/why-pythons-integer-division-floors.html" rel="nofollow">pythons integer division floors</a> by Guido himself.</p>
<p>Also for complete information about the float numbers you can read this article <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="nofollow">https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html</a></p>
<p>For those who have interest, the following function is the <code>float_div</code> that does the true division task for float numbers, in Cpython's source code:</p>
<pre><code>float_div(PyObject *v, PyObject *w)
{
    double a,b;
    CONVERT_TO_DOUBLE(v, a);
    CONVERT_TO_DOUBLE(w, b);
    if (b == 0.0) {
        PyErr_SetString(PyExc_ZeroDivisionError,
                        "float division by zero");
        return NULL;
    }
    PyFPE_START_PROTECT("divide", return 0)
    a = a / b;
    PyFPE_END_PROTECT(a)
    return PyFloat_FromDouble(a);
}
</code></pre>
<p>Which the final result would be calculated by function <code>PyFloat_FromDouble</code>:</p>
<pre><code>PyFloat_FromDouble(double fval)
{
    PyFloatObject *op = free_list;
    if (op != NULL) {
        free_list = (PyFloatObject *) Py_TYPE(op);
        numfree--;
    } else {
        op = (PyFloatObject*) PyObject_MALLOC(sizeof(PyFloatObject));
        if (!op)
            return PyErr_NoMemory();
    }
    /* Inline PyObject_New */
    (void)PyObject_INIT(op, &amp;PyFloat_Type);
    op-&gt;ob_fval = fval;
    return (PyObject *) op;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After checking the semi-official sources of the float object in cpython on github (<a href="https://github.com/python/cpython/blob/966b24071af1b320a1c7646d33474eeae057c20f/Objects/floatobject.c" rel="noreferrer">https://github.com/python/cpython/blob/966b24071af1b320a1c7646d33474eeae057c20f/Objects/floatobject.c</a>) one can understand what happens here.</p>
<p>For normal division <code>float_div</code> is called (line 560) which internally converts the python <code>float</code>s to c-<code>double</code>s, does the division and then converts the resulting <code>double</code> back to a python <code>float</code>. If you simply do that with <code>8.0/0.4</code> in c you get:</p>
<pre><code>#include "stdio.h"
#include "math.h"

int main(){
    double vx = 8.0;
    double wx = 0.4;
    printf("%lf\n", floor(vx/wx));
    printf("%d\n", (int)(floor(vx/wx)));
}

// gives:
// 20.000000
// 20
</code></pre>
<p>For the floor division, something else happens. Internally, <code>float_floor_div</code> (line 654) gets called, which then calls <code>float_divmod</code>, a function that is supposed to return a tuple of python <code>float</code>s containing the floored division, as well as the mod/remainder, even though the latter is just thrown away by <code>PyTuple_GET_ITEM(t, 0)</code>. These values are computed the following way (After conversion to c-<code>double</code>s):</p>
<ol>
<li>The remainder is computed by using <code>double mod = fmod(numerator, denominator)</code>.</li>
<li>The numerator is reduced by <code>mod</code> to get a integral value when you then do the division.</li>
<li>The result for the floored division is calculated by effectively computing <code>floor((numerator - mod) / denominator)</code></li>
<li>Afterwards, the check already mentioned in @Kasramvd's answer is done. But this only snaps the result of <code>(numerator - mod) / denominator</code> to the nearest integral value.</li>
</ol>
<p>The reason why this gives a different result is, that <code>fmod(8.0, 0.4)</code> due to floating-point arithmetic gives <code>0.4</code> instead of <code>0.0</code>. Therefore, the result that is computed is actually <code>floor((8.0 - 0.4) / 0.4) = 19</code> and snapping <code>(8.0 - 0.4) / 0.4) = 19</code> to the nearest integral value does not fix the error made introduced by the "wrong" result of <code>fmod</code>. You can easily chack that in c as well:</p>
<pre><code>#include "stdio.h"
#include "math.h"

int main(){
    double vx = 8.0;
    double wx = 0.4;
    double mod = fmod(vx, wx);
    printf("%lf\n", mod);
    double div = (vx-mod)/wx;
    printf("%lf\n", div);
}

// gives:
// 0.4
// 19.000000
</code></pre>
<p>I would guess, that they chose this way of computing the floored division to keep the validity of <code>(numerator//divisor)*divisor + fmod(numerator, divisor) = numerator</code> (as mentioned in the link in @0x539's answer), even though this now results in a somewhat unexpected behavior of <code>floor(8.0/0.4) != 8.0//0.4</code>.</p>
</div>
<span class="comment-copy">Interestingly, <code>'%.20f'%0.4</code> gives <code>'0.40000000000000002220'</code>, so <code>0.4</code> is apparently just a little bit over <code>0.4</code>.</span>
<span class="comment-copy">@khelwood how does <code>floor(8.0/0.4)</code> produce correct results?</span>
<span class="comment-copy">First, floating-point numbers with the <code>float</code> type are usually wrong. Second, <code>//</code> and <code>%</code> are pretty unreliable (meaning, unexpected behavior) with negative numbers and <code>float</code> numbers. The <a href="https://docs.python.org/3/library/decimal.html#decimal-objects" rel="nofollow noreferrer">documentation on Decimal objects</a> briefly discusses <code>//</code> with negative integers and how the <code>Decimal</code> library handles it differently.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a></span>
<span class="comment-copy">@AlexanderVogt Not really, is it? The question is not why floating point results are not exact but more about why python does two different things for <code>floor(8.0/0.4)</code> and the"floor-division" <code>8.0//0.4</code>.</span>
<span class="comment-copy">"it seems floored division is determined atomically" -- excellent guess, and I suppose correct semantically, but in terms of what the implementation must do, it's sort of backwards: since there's no hardware support that supports the "atomic" <code>//</code> semantics, the remainder is pre-calculated and subtracted from the numerator to ensure that the floating point division (when it finally occurs) simply <i>computes</i> the correct value immediately, without needing further adjustment.</span>
<span class="comment-copy">Yeah, I'm using term "atomic" from the user's (i.e., Python programmer's) view, here. Similar to how e.g. certain database operations may be described as "atomic" that also do not map to a single hardware instruction. So I'm talking about effect, not implementation.</span>
<span class="comment-copy">Apropos implementation, whether or not hardware supports a native instruction equivalent to Python's <code>//</code> operator would of course depend on the hardware and on the operand types. Early CPUs certainly had integer division support for integer operands. There might not be any chipset with native support for floored division of floats, but it wouldn't be inconceivable either, as it'd be merely impractical, not impossible.</span>
<span class="comment-copy">"The same probably happens for <code>8.0//0.4</code>". Not really, at least for cpython. They actually rather do <code>round((8.0 - fmod(8.0, 0.4)) / 0.4)</code> which gives <code>19</code> because (at least for my machine/compiler version) <code>fmod(8.0/0.4)</code> results in <code>0.4</code> (also in pure C). See my answer for details.</span>
<span class="comment-copy">Although it's not an answer to question, it's not a proper use of <code>decimal</code> either, since when we can simply use <i>true division</i> in order to get this result.</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/fractions.html" rel="nofollow noreferrer"><code>fractions</code></a> module seems to be doing the job as well.</span>
<span class="comment-copy">@0x539's explanation is not actually correct. See jotasi's answer and my comment below 0x539's answer.</span>
<span class="comment-copy">@KyleStrand that reservation of course also applies to <a href="http://stackoverflow.com/questions/38588815/rounding-errors-in-python-floor-division/38589899#38589899">my answer</a>, to I've made some amendments to it.</span>
<span class="comment-copy">@das-g Ah, very nice!</span>
<span class="comment-copy">Good find, that. But what <i>would</i> a user want here? Correct mathematical behavior on numbers that are inherently incorrect to begin with? (Of which that same average 'typical user' is <a href="http://stackoverflow.com/questions/14368893/why-is-decimal-multiplication-slightly-inaccurate">usually blissfully unaware</a>.)</span>
<span class="comment-copy">@RadLexus A User wants the best possible approximation for this operation. In this case that is <code>20.0</code></span>
<span class="comment-copy">@0x539: What about the poor users who are relying on <code>//</code> to truncate things slightly less than <code>20.0</code> to <code>19.0</code>? The problem here is that the user wants to do exact arithmetic and is using the wrong tools for the job.</span>
<span class="comment-copy">Actually, truncation is not what happens, at least if I understand the sources of cpython correctly. They go through a rather large ordeal to keep the identity mentioned in your link by actually computing <code>floor((8.0 - fmod(8.0, 0.4)) / 0.4)</code> and the error is introduced by <code>fmod(8.0, 0.4)=0.4</code>. (See my answer for the link and more explanation).</span>
<span class="comment-copy">Mathematically, you'd be correct that <code>8.0 / 0.40000000000000002220</code> "yields something slightly smaller than <code>20.0</code>." However, it's not correct to think of floating-point operations happening as a series of steps in which the <i>actual real mathematical value</i> is calculated, and <i>then</i> rounded (which you imply when you say "The <code>/</code> operator <i>then</i> rounds..."). Of course, this wouldn't be possible, since computers <i>must</i> have a way to internally represent all intermediate steps of a computation! See @jotasi 's answer.</span>
<span class="comment-copy">@Kasramvd Thanks for the extensive answer. Maybe I am just dense but I don't get, what you mean with "snapping to next integral value". Obviously, not all floating point divisions will be rounded to next integral value (<code>3./4.</code> will not give <code>1</code>). Therefore, the decision for that couldn't be as simple as you present it, as far as I understand it. Did I understand you correctly?</span>
<span class="comment-copy">Actually, after checking the source code myself, I guess floating point division is done in the function <code>float_div</code>, whereas <code>float_divmod</code> is only called by <code>float_floor_div</code> which does the floor-division which in turn gives the "wrong" result <code>19</code> instead of <code>20</code>.</span>
<span class="comment-copy">@jotasi Yes, exactly. It's more complicated than a simple snapping. And yes it's <code>float_div</code> function which does the true dive task. It seems that it calculates the final result somehow based on arguments size. I updated the answer. thanks for your attention.</span>
<span class="comment-copy">I double checked with simply checking the important lines in c and apparently the important part is that they compute <code>8.0/0.4 = 20</code> by simple <code>double</code> division in c whereas the floor division actually computes <code>floor((8.0 - fmod(8.0, 0.4)) / 0.4) = 19</code> because <code>fmod(8.0, 0.4) = 0.4</code> due to floating point arithmetic. See my answer below for more info.</span>
<span class="comment-copy">"the fact is that it depends on size of available <code>PyFloatObjects</code>" - what? No it doesn't. <code>PyFloatObject</code>s are all the same size, and the storage details of <code>PyFloatObject</code>s have pretty much nothing to do with any of this behavior.</span>
<span class="comment-copy">You seem to be the only person with the correct answer. Props! Since you had to dig into the sources to find it, though, I wonder if this is a mandatory part of all Python implementations?</span>
<span class="comment-copy">It does appear that as of <a href="https://www.python.org/dev/peps/pep-0238/" rel="nofollow noreferrer">PEP 238</a>, it was expected that <code>floor(a/b) == a // b</code> would be true, since that is explicitly stated as the semantics for "floor-division".</span>
<span class="comment-copy">In the issue report (<a href="https://bugs.python.org/issue27463" rel="nofollow noreferrer">bugs.python.org/issue27463</a>) already referenced by @0x539, it doesn't seem to be considered as wrong. and this is the python bugtracker. So I guess "floor-division" is more of a name than being ment to define the implementation.</span>
<span class="comment-copy">"The result for the floored division is calculated by effectively computing <code>floor((numerator - mod) / denominator)</code>" - no, it's more like <code>round((numerator - mod) / denominator)</code>. The source code does use <code>floor</code>, but then it immediately adjusts the result upward if <code>floor</code> rounded the wrong way. It relies on the <code>- mod</code> part to "effectively floor" <code>numerator / denominator</code>.</span>
<span class="comment-copy">@user2357112 You are right. Effectively, the result is rather <code>round</code>ed than just <code>floor</code>ed. Nontheless, the <code>-mod</code> causes the strange result.</span>
