<div class="post-text" itemprop="text">
<p>I have a time series that I have pulled from a netCDF file and I'm trying to convert them to a datetime format. The format of the time series is in 'days since 1990-01-01 00:00:00 +10' (+10 being GMT: +10) </p>
<pre><code>time = nc_data.variables['time'][:]
time_idx = 0  # first timestamp 
print time[time_idx]

9465.0
</code></pre>
<p>My desired output is a datetime object like so (also GMT +10):</p>
<pre><code>2015-12-01 00:00:00
</code></pre>
<p>I have tried converting this using the time module without much success although I believe I may be using wrong (I'm still a novice in python and programming). </p>
<pre><code>import time
time_datetime = time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(time[time_idx]*24*60*60))
</code></pre>
<p>Any advice appreciated,
Cheers! </p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>datetime</code> module's <a href="https://docs.python.org/3/library/datetime.html#timedelta-objects" rel="nofollow"><code>timedelta</code></a> is probably what you're looking for.</p>
<p>For example:</p>
<pre><code>from datetime import date, timedelta

days = 9465                 # This may work for floats in general, but using integers
                            #   is more precise (e.g. days = int(9465.0))

start = date(1990,1,1)      # This is the "days since" part

delta = timedelta(days)     # Create a time delta object from the number of days

offset = start + delta      # Add the specified number of days to 1990

print(offset)               # &gt;&gt;&gt;  2015-12-01
print(type(offset))         # &gt;&gt;&gt;  &lt;class 'datetime.date'&gt;
</code></pre>
<p>You can then use and/or manipulate the offset object, or convert it to a string representation however you see fit.</p>
<p>You can use the same format as for this date object as you do for your <code>time_datetime</code>:</p>
<pre><code>print(offset.strftime('%Y-%m-%d %H:%M:%S'))
</code></pre>
<p>Output:</p>
<pre><code>2015-12-01 00:00:00
</code></pre>
<hr/>
<p>Instead of using a <code>date</code> object, you could use a <code>datetime</code> object instead if, for example, you were later going to add hours/minutes/seconds/timezone offsets to it.</p>
<p>The code would stay the same as above with the exception of two lines:</p>
<pre><code># Here, you're importing datetime instead of date
from datetime import datetime, timedelta

# Here, you're creating a datetime object instead of a date object
start = datetime(1990,1,1)   # This is the "days since" part
</code></pre>
<p><strong>Note:</strong> Although you don't state it, but the other answer suggests you might be looking for <em>timezone aware</em> datetimes.  If that's the case, <code>dateutil</code> is the way to go in Python 2 as the other answer suggests.  In Python 3, you'd want to use the <code>datetime</code> module's <a href="https://docs.python.org/3/library/datetime.html#datetime.tzinfo" rel="nofollow"><code>tzinfo</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://unidata.github.io/netcdf4-python/#netCDF4.num2date" rel="nofollow">netCDF num2date</a> is the correct function to use here:</p>
<pre><code>import netCDF4

ncfile = netCDF4.Dataset('./foo.nc', 'r')
time = ncfile.variables['time'] # do not cast to numpy array yet 
time_convert = netCDF4.num2date(time[:], time.units, time.calendar)
</code></pre>
<p>This will convert number of days since 1900-01-01 (i.e. the <code>units</code> of <code>time</code>) to python datetime objects.  If <code>time</code> does not have a <code>calendar</code> attribute, you'll need to specify the calendar, or use the default of standard. </p>
</div>
<div class="post-text" itemprop="text">
<p>We can do this in a couple steps. First, we are going to use the <a href="https://dateutil.readthedocs.io/en/latest/" rel="nofollow noreferrer"><code>dateutil</code></a> library to handle our work. It will make some of this easier.</p>
<p>The first step is to get a <code>datetime</code> object from your string (<code>1990-01-01 00:00:00 +10</code>). We'll do that with the following code:</p>
<pre><code>from datetime import datetime
from dateutil.relativedelta import relativedelta
import dateutil.parser

days_since = '1990-01-01 00:00:00 +10'
days_since_dt = dateutil.parser.parse(days_since)
</code></pre>
<p>Now, our <code>days_since_dt</code> will look like this:</p>
<pre><code>datetime.datetime(1990, 1, 1, 0, 0, tzinfo=tzoffset(None, 36000))
</code></pre>
<p>We'll use that in our next step, of determining the new date. We'll use <code>relativedelta</code> in dateutils to handle this math.</p>
<pre><code>new_date = days_since_dt + relativedelta(days=9465.0)
</code></pre>
<p>This will result in your value in <code>new_date</code> having a value of:</p>
<pre><code>datetime.datetime(2015, 12, 1, 0, 0, tzinfo=tzoffset(None, 36000))
</code></pre>
<hr/>
<p>This method ensures that the answer you receive continues to be in GMT+10. </p>
</div>
<span class="comment-copy">Thanks for detailed answer! The datetime object is preferred as there are timestamps for each hour of December.</span>
<span class="comment-copy">Great happy it helped -- and happy I included that then :)</span>
<span class="comment-copy">Thanks Andy, the dateutil library is a great tool I was unaware of.</span>
