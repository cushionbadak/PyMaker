<div class="post-text" itemprop="text">
<p>I have different text files and I want to extract the values from there into a csv file.
Each file has the following format</p>
<pre><code>main cost: 30
additional cost: 5
</code></pre>
<p>I managed to do that but the problem that I want it to insert the values of each file into a different columns I also want the number of text files to be a user argument </p>
<p>This is what I'm doing now </p>
<pre><code>  numFiles = sys.argv[1]
  d = [[] for x in xrange(numFiles+1)]
  for i in range(numFiles): 
      filename = 'mytext' + str(i) + '.text'
      with open(filename, 'r') as in_file:
      for line in in_file:
        items = line.split(' : ')
        num = items[1].split('\n')

        if i ==0:
            d[i].append(items[0])

        d[i+1].append(num[0])

        grouped = itertools.izip(*d[i] * 1)
        if i == 0:
            grouped1 = itertools.izip(*d[i+1] * 1)

        with open(outFilename, 'w') as out_file:
            writer = csv.writer(out_file)
            for j in range(numFiles):
                for val in itertools.izip(d[j]):
                    writer.writerow(val)
</code></pre>
<p>This is what I'm getting now, everything in one column </p>
<pre><code>main cost   
additional cost   
30   
5   
40   
10
</code></pre>
<p>And I want it to be </p>
<pre><code>main cost        | 30  | 40
additional cost  | 5   | 10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a dictionary to do this where the key will be the "header" you want to use and the value be a list.</p>
<p>So it would look like <code>someDict = {'main cost': [30,40], 'additional cost': [5,10]}</code></p>
<p>edit2: Went ahead and cleaned up this answer so it makes a little more sense.</p>
<p>You can build the dictionary and iterate over it like this:</p>
<pre><code>from collections import OrderedDict

in_file = ['main cost : 30', 'additional cost : 5', 'main cost : 40', 'additional cost : 10']
someDict = OrderedDict()

for line in in_file:
    key,val = line.split(' : ')
    num = int(val)
    if key not in someDict:
        someDict[key] = []

    someDict[key].append(num)

for key in someDict:
    print(key)
    for value in someDict[key]:
        print(value)
</code></pre>
<p>The code outputs:</p>
<pre><code>main cost
30
40
additional cost
5
10
</code></pre>
<p>Should be pretty straightforward to modify the example to fit your desired output.</p>
<p>I used the example @ <a href="https://stackoverflow.com/questions/3199171/append-multiple-values-for-one-key-in-python-dictionary">append multiple values for one key in Python dictionary</a> and thanks to @wwii for some suggestions.</p>
<p>I used an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a> since a dictionary won't keep keys in order.</p>
<p>You can run my example @ <a href="https://ideone.com/myN2ge" rel="nofollow noreferrer">https://ideone.com/myN2ge</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This is how I might do it. Assumes the fields are the same in all the files. Make a list of names, and a dictionary using those field names as keys, and the list of values as the entries. Instead of running on <code>file1.text</code>, <code>file2.text</code>, etc. run the script with <code>file*.text</code> as a command line argument.</p>
<pre><code>#! /usr/bin/env python

import sys

if len(sys.argv)&lt;2:
    print "Give file names to process, with wildcards"
else:
    FileList= sys.argv[1:]
    FileNum = 0
    outFilename = "myoutput.dat"
    NameList = []
    ValueDict = {}
    for InfileName in FileList:
        Infile = open(InfileName, 'rU') 
        for Line in Infile: 
            Line=Line.strip('\n')
            Name,Value = Line.split(":")
            if FileNum==0:
                NameList.append(Name.strip())
            ValueDict[Name] = ValueDict.get(Name,[]) + [Value.strip()]
        FileNum += 1 # the last statement in the file loop
        Infile.close()
    # print NameList
    # print ValueDict

    with open(outFilename, 'w') as out_file:
        for N in NameList:
            OutString =  "{},{}\n".format(N,",".join(ValueDict.get(N)))
            out_file.write(OutString)
</code></pre>
<p>Output for my four fake files was:</p>
<pre><code>main cost,10,10,40,10
additional cost,25.6,25.6,55.6,25.6
</code></pre>
</div>
<span class="comment-copy">have you tried using tuples ?</span>
<span class="comment-copy">Where does the last column come from in the desired output?  Are ther only two lines in each input file?</span>
<span class="comment-copy">I'm assuming the input file looks something like:  main cost: 30 additional cost: 5 main cost: 40 additional cost: 10</span>
<span class="comment-copy">ahh ..., so each file would be a new column.</span>
<span class="comment-copy">@wwii yes as Michael said</span>
<span class="comment-copy">For this solution, you can be sure that there are only two keys, so you could construct the dictionary before-hand with those two keys and an empty list for values - then you can get rid of the <code>if/else</code> for the dictionary assignment.  Alternatively if you are not sure about the keys beforehand you could use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>.</span>
<span class="comment-copy">When you split text and plan on using the individual items later in your code, it is nice to give them names - it makes subsequent code easier to read.  Take advantage of unpacking: in this case something like - <code>key, value = line.split(':') ; value = value.strip()</code></span>
<span class="comment-copy">Both great examples.  For the first, I would probably keep it my way so in the future the file formats can change without having to modify the code.  I agree with your second example.</span>
<span class="comment-copy">Play around with <code>collections.defaultdict</code>, it solves the problem of trying to assign to a missing key without using <code>if/then</code>s or <code>try/except</code>s.</span>
<span class="comment-copy">That works as well unless you want to use an OrderedDict, which is probably what OP wants.  Otherwise, it won't always output in the same order.  I'll edit my example to include your first suggestion though.  It's much easier to read that way.</span>
<span class="comment-copy">Thanks @beroe but I want the output to be saved in an csv file and the <code>|</code> representing a different column</span>
<span class="comment-copy">Just change the ` | ` in the code to a comma...</span>
<span class="comment-copy">this is what I get when I try the above code TypeError: can only join an iterable</span>
<span class="comment-copy">Insert a line that prints ValueDict  and see what it says. Each value should be a list of strings (numbers) if the data match your example. If there are blank lines or header lines, you could insert a check in the loop before the <code>ValueDict[Name]=</code> part...</span>
