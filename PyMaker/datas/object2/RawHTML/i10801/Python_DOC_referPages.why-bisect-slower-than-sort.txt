<div class="post-text" itemprop="text">
<p>I know that bisect is using binary search to keep lists sorted. However I did a timing test that the values are being read and sorted. But, on the contrary to my knowledge, keeping the values and then sorting them win the timing by high difference. Could more experienced users please explain this behavior ? Here is the code I use to test the timings.</p>
<pre><code>import timeit

setup = """
import random
import bisect
a = range(100000)
random.shuffle(a)
"""

p1 = """
b = []
for i in a:
    b.append(i)
b.sort()
"""

p2 = """
b = []
for i in a:
    bisect.insort(b, i)
"""

print timeit.timeit(p1, setup=setup, number = 1)
print timeit.timeit(p2, setup=setup, number = 1)

# 0.0593081859178
# 1.69218442959
# Huge difference ! 35x faster.
</code></pre>
<p>In the first process I take values one-by-one instead of just sorting <code>a</code> to obtain a behavior like file reading. And it beats bisect very hard.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your algorithmic complexity will be worse in the bisect case ...</p>
<p>In the <code>bisect</code> case, you have <code>N</code> operations (each at an average cost of <code>log(N)</code> to find the insertion point and then an additional <code>O(N)</code> step to insert the item).  <strong>Total complexity:  <code>O(N^2)</code></strong>.</p>
<p>With <code>sort</code>, you have a single <code>Nlog(N)</code> step (plus <code>N</code> <code>O(1)</code> steps to build the list in the first place).  <strong>Total complexity: <code>O(Nlog(N))</code></strong></p>
<p>Also note that <code>sort</code> is implemented in very heavily optimized C code (<code>bisect</code> isn't quite as optimized since it ends up calling various comparison functions much more frequently...)</p>
</div>
<div class="post-text" itemprop="text">
<p>Sorting a list takes about <code>O(N*log(N))</code> time. Appending N items to a list takes <code>O(N)</code> time. Doing these things consecutively takes about <code>O(N*log(N))</code> time.</p>
<p>Bisecting a list takes <code>O(log(n))</code> time. Inserting an item into a list takes <code>O(N)</code> time. Doing both N times inside a for loop takes <code>O(N * (N + log(n))) == O(N^2)</code> time.</p>
<p><code>O(N^2)</code> is worse than <code>O(N*log(N))</code>, so your <code>p1</code> is faster than your <code>p2</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To understand the time difference, let’s look at what you are actually doing there.</p>
<p>In your first example, you are taking an empty list, and append items to it, and sorting it in the end.</p>
<p>Appending to lists is really cheap, it has an <a href="https://en.wikipedia.org/wiki/Amortized_analysis" rel="nofollow">amortized time complexity</a> of O(1). It cannot be really constant time because the underlying data structure, a simple array, eventually needs to be expanded as the list grows. This is done every so often which causes a new array to be allocated and the data being copied. That’s a bit more expensive. But in general, <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow">we still say this is O(1)</a>.</p>
<p>Next up comes the sorting. Python is using <a href="https://en.wikipedia.org/wiki/Timsort" rel="nofollow">Timsort</a> which is very efficient. This is O(n log n) at average and worst case. So overall, we get constant time following <code>O(n log n)</code> so the sorting is the only thing that matters here. In total, this is pretty simple and very fast.</p>
<p>The second example uses <a href="https://docs.python.org/3/library/bisect.html#bisect.insort" rel="nofollow"><code>bisect.insort</code></a>. This utilizes a list and binary search to ensure that the list <em>is sorted at all times</em>.</p>
<p>Essentially, on every insert, it will use binary search to find the correct location to insert the new value, and then shift all items correctly to make room at that index for the new value. Binary search is cheap, O(log n) on average, so this is not a problem. Shifting alone is also not that difficult. In the worst case, we need to move all items one index to the right, so we get O(n) (this is basically the <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow">insert operation on lists</a>).</p>
<p>So in total, we would get linear time at worst. However, we do this <em>on every single iteration</em>. So when inserting <code>n</code> elements, we have O(n) each time. This results in a quadratic complexity, O(n²). This is a problem, and will ultimately slow the whole thing down.</p>
<p>So what does this tell us? <a href="https://en.wikipedia.org/wiki/Insertion_sort" rel="nofollow">Sorted inserting</a> into a list to get a sorted result is not really performant. We can use the <code>bisect</code> module to keep an already sorted list ordered when we only do a few operations, but when we actually have unsorted data, it’s easier to sort the data as a whole.</p>
</div>
<div class="post-text" itemprop="text">
<p>Insertion and deletion operations in a data structure can be surprisingly expensive sometimes, particularly if the distribution of incoming data values is random. Whereas, <em>sorting</em> can be unexpectedly fast.</p>
<p>A key consideration is whether-or-not you can "accumulate all the values," then sort them <em>once,</em> then use the sorted result "all at once." If you can, then sorting is almost always very-noticeably faster.</p>
<p>If you remember the old sci-fi movies (back when computers were called "giant brains" and a movie always had spinning tape-drives), that's the sort of processing that they were supposedly doing: applying <em>sorted</em> updates to <em>also-sorted</em> master tapes, to produce a new <em>still-sorted</em> master. Random-access was not needed. (Which was a good thing, because at that time we really couldn't do it.) It is <em>still</em> an efficient way to process vast amounts of data.</p>
</div>
<span class="comment-copy">Because timsort is an efficient sorting algorithm and list inserts are slow?</span>
<span class="comment-copy">That is probably the reason but then what is the advantage of bisect ?</span>
<span class="comment-copy">What do you mean? If you already have a sorted list, and you want to keep it sorted, that's the best way. And many other operations are more efficient on a sorted list.</span>
<span class="comment-copy"><code>bisect</code> is for when you are searching the list far more often than you are adding items to it.</span>
<span class="comment-copy">That <b>is</b> insertion sort.</span>
<span class="comment-copy">To be fair, <code>timsort</code> also shines after you've just added an element to an already sorted list since it would have a <i>really</i> long <a href="https://en.wikipedia.org/wiki/Timsort#Galloping_mode" rel="nofollow noreferrer">"gallop"</a> phase.  It might <i>still</i> have comparable performance to <code>bisect.insort</code>...</span>
