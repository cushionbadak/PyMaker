<div class="post-text" itemprop="text">
<p>I want to use <strong>string.replace</strong> using for loop. This is my code: </p>
<pre><code>new = ['p','q','r']
my_str = 'there are two much person a, person b, person c.'
old = ['a','b','c']

for i in range(0,len(old)):
    my_str = string.replace(my_str,old[i],new[i])

print(my_str)
</code></pre>
<p>But it is giving me error:</p>
<blockquote>
<p>TypeError: 'str' object cannot be interpreted as an integer</p>
</blockquote>
<p>Desired output:</p>
<blockquote>
<p>there are two much person p, person q, person r.</p>
</blockquote>
<p>This is just an example, I want to run a for loop for 10,000 length list. </p>
</div>
<div class="post-text" itemprop="text">
<p>Actually, I can not reproduce your problem; your code runs fine on Python 2.7. However, there are better ways to do it. First, instead of using a <code>range</code>, you could <code>zip</code> the <code>old</code> and <code>new</code> lists:</p>
<pre><code>for i in range(0,len(old)):
    my_str = string.replace(my_str,old[i],new[i])
</code></pre>
<p>However, this will still replace the <code>a</code> in <code>are</code> and the <code>c</code> in <code>much</code>, and it might also replace characters that were introduced in an earlier replacement, which is probably not what you want. Instead, you could use the <a href="https://docs.python.org/3/library/re.html" rel="nofollow"><code>re</code></a> module, joining the strings to be replaced with <code>|</code> to a regex and delimiting it with <code>\b</code> word boundary characters, e.g. <code>\b(a|b|c)\b</code> in your case, and use a dictionary to look up the proper replacements.    </p>
<pre><code>d = dict(zip(old, new))
p = r'\b(' + '|'.join(old) + r')\b'
my_str = re.sub(p, lambda m: d.get(m.group()), my_str)
</code></pre>
<p>Result: <code>there are two much person p, person q, person r.</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Try</p>
<pre><code>new = ['p','q','r']
my_str = 'there are two much person a, person b, person c.'
old = ['a','b','c']

for i in range(len(old)):
    my_str = my_str.replace(old[i],new[i])

print(my_str)
</code></pre>
<p>but that is propably not very fast</p>
<p>If entries in old are all letters-only you can do</p>
<pre><code>import re

new = ['p','q','r']
my_str = 'there are two much person a, person b, person c.'
old = ['a','b','c']

word=re.compile(r"\w*") # word characters
old_new=dict(zip(old,new))
ong=old_new.get
my_str=word.sub((lambda s:ong(s,s)),my_str)

print(my_str)
</code></pre>
<p>this also avoids the double replacement problem if an entry is in both old and new (not avoided in the shorter solution)</p>
</div>
<div class="post-text" itemprop="text">
<p><code>string.replace()</code> is available on Python 2.x but deprecated in python 3.x.</p>
<p>Below is how you can use it in Python 3.x</p>
<blockquote>
<p>str.replace(old, new[, count])
  Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced.</p>
</blockquote>
<p>In your case, it is <code>my_str.replace(old[index], new[index])</code></p>
</div>
<span class="comment-copy">Can not reproduce. Your code runs fine on Python 2.7</span>
<span class="comment-copy">The <code>string.replace</code> function has been deprecated for a very long time. You should use the<code>str.replace</code> method instead.</span>
<span class="comment-copy">You know, even if you fix whatever weird problem you had, you're still going to replace the <code>a</code> in <code>are</code> and the <code>c</code> in <code>much</code>.</span>
<span class="comment-copy">But it doesnt work for this example, I have written in answer part.</span>
<span class="comment-copy">Based on your update, which you've since deleted, the problem is the 'Y' in Years is caps, and in 'years' is lower case. Next time, post a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">like my solution this only works if entries in old only consist of word-characters</span>
<span class="comment-copy"><code>.join(old)</code> may not be a good idea if <code>len(old)</code> is 10000. OTOH, the OP may have an XY problem...</span>
<span class="comment-copy">@PM2Ring Good point, in this light janbrohl's solution might work better. +1</span>
