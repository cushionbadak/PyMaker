<div class="post-text" itemprop="text">
<p>I have a big array and a part of that is shown below. in each list, the first number is start and the 2nd number is end (so there is a range). what I want to do is:</p>
<p>1:
 filter out those lists (ranges) which are smaller than 300 (e.g. the 18th list in the following array must be removed) </p>
<p>2:
 get a smaller ranges (lists) in this way: (start+100) to (start+200). e.g the first list would be [ 569, 669]. </p>
<p>I tried to use different split functions in numpy but non of them gives what I am looking for.</p>
<pre><code>array([[ 469, 1300],
       [ 171, 1440],
       [ 187, 1564],
       [ 204, 1740],
       [  40, 1363],
       [  56, 1457],
       [ 132,  606],
       [1175, 2096],
       [ 484, 2839],
       [ 132, 4572],
       [ 166, 1693],
       [  69, 3300],
       [ 142, 1003],
       [2118, 2118],
       [ 715, 1687],
       [ 301, 1006],
       [  48, 2142],
       [  63,  330],
       [ 479, 2411]], dtype=uint32)
</code></pre>
<p>do you guys know how to do that in python?</p>
<p>thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming your array is called <code>A</code>, then:</p>
<pre><code>import numpy as np

# Filter out differences not wanted
gt300 = A[(np.diff(A) &gt;= 300).flatten()]

# Set new value of first column
gt300[:,0] += 100

# Set value of second column
gt300[:,1] = gt300[:,0] + 100
</code></pre>
<p>Or maybe something like:</p>
<pre><code>B = A[:,0][(np.diff(A) &gt;= 300).flatten()]
C = np.repeat(B, 2).reshape((len(B), 2)) + [100, 200]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A general note before:
You should use <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="nofollow">tuples</a> to represnt such ranges, not lists, They are immutable data types with a meaning to the order of items in them.</p>
<p>As for 1, it is pretty easy to filter in python:</p>
<pre><code>filter(lambda single_range: single_range[1] - single_range[0] &gt; 300, ranges)
</code></pre>
<p>A clearer way (in my opinion) to do this is with a list comprehension:</p>
<pre><code>[(start, end) for start, end in ranges if end - start &gt; 300]
</code></pre>
<p>As for 2, I don't fully understand what you mean, but if you mean creating a new list of ranges, where each range is changes using a single function, you mean a map (or my preferred way, a list comprehension which is equal but more descriptive):</p>
<pre><code>[(start + 100, start + 200) for start, end in ranges]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>data = [[ 469, 1300],
        # ...
        [  63,  330],
        [ 479, 2411]]

print(
    filter(lambda v: v[1] - v[0] &gt;= 300, data)
)

print(
    [[v[0] + 100, v[0] + 200] for v in data]
)
</code></pre>
<p>Explanation:</p>
<p>The first command uses the builtin <a href="https://docs.python.org/3.5/library/functions.html#filter" rel="nofollow">filter</a> method to filter the remaining elements based on a <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow">lambda</a> expression.</p>
<p>The second iterates over the list and generates a new one while doing so.</p>
<p>If the input and output should be numpy arrays try the following. Note: There is no way to filter an numpy array without creating a new one.</p>
<pre><code>data = array([
    ( 469, 1300),
    ( 171, 1440),
    # ...
    (  63,  330),
    ( 479, 2411)], dtype=(uint32, uint32))

print(
    array(filter(lambda v: v[1] - v[0] &gt;= 300, data), dtype=(uint32, uint32))
)

print(
    array([[v[0] + 100, v[0] + 200] for v in data], dtype=(uint32, uint32))
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can find which rows have the small difference with:</p>
<pre><code>In [745]: mask=(x[:,1]-x[:,0])&lt;300
In [746]: mask
Out[746]: 
array([False, False, False, False, False, False, False, False, False,
       False, False, False, False,  True, False, False, False,  True, False], dtype=bool)
</code></pre>
<p>We can use that <code>mask</code> to select those rows, or to deselect them</p>
<pre><code>In [747]: x[mask,:]
Out[747]: 
array([[2118, 2118],
       [  63,  330]], dtype=uint32)
In [748]: x[~mask,:]
Out[748]: 
array([[ 469, 1300],
       [ 171, 1440],
       [ 187, 1564],
       [ 204, 1740],
       ...
       [ 479, 2411]], dtype=uint32)
</code></pre>
<p>To make a new set of ranges; get the first column; here I am using <code>[0]</code> so the selection remains a column array:</p>
<pre><code>In [750]: x[:,[0]]
Out[750]: 
array([[ 469],
       [ 171],
       [ 187],
        ...
       [  48],
       [  63],
       [ 479]], dtype=uint32)
</code></pre>
<p>Add to that the desired offsets.  This takes advantage of broadcasting.</p>
<pre><code>In [751]: x[:,[0]]+[100,200]
Out[751]: 
array([[ 569,  669],
       [ 271,  371],
       [ 287,  387],
       [ 304,  404],
       [ 140,  240],
       [ 156,  256],
      ...
       [ 401,  501],
       [ 148,  248],
       [ 163,  263],
       [ 579,  679]], dtype=int64)
</code></pre>
<p>There are other ways of constructing such an array</p>
<pre><code>np.column_stack([x[:,0]+100,x[:,0]+200])
np.array([x[:,0]+100, x[:,0]+200]).T   # or vstack
</code></pre>
<p>Other answers have suggested the <code>Python</code> list <code>filter</code>.  I'm partial to list comprehensions in this kind of use, for example:</p>
<pre><code>In [756]: np.array([i for i in x if (i[1]-i[0])&lt;300])
Out[756]: 
array([[2118, 2118],
       [  63,  330]], dtype=uint32)
</code></pre>
<p>For small lists of lists, the pure Python approach tends to be faster.  But if the object is already a <code>numpy</code> array, it is faster to use the <code>numpy</code> operations that work on the whole array at once (i.e. do the iteration in compiled code).  Hence my suggestion to use the boolean mask.</p>
</div>
<span class="comment-copy">Filter should be easy... Python has an explicit filter function</span>
<span class="comment-copy">Hi Jon, when I run the last line it gives this error:   "TypeError: list indices must be integers, not tuple"</span>
<span class="comment-copy">@user3925736 which line exactly?</span>
<span class="comment-copy">Hi Ehud, this is a numpy array. and I would like to get the same array for further handling.</span>
<span class="comment-copy">HI Simon, great. it works perfectly for matrix (list of lists), but my data is array and I have to get array (that is a numpy array). do you know how to manipulate the input array to get a numpy array like input but with the mentioned changes?</span>
