<div class="post-text" itemprop="text">
<p>Yes, I know this subject has been covered before (<a href="https://stackoverflow.com/questions/120886">here</a>, <a href="https://stackoverflow.com/questions/406121">here</a>, <a href="https://stackoverflow.com/questions/457215">here</a>, <a href="https://stackoverflow.com/questions/952914">here</a>), but as far as I know, all solutions, except for one, fail on a list like this:</p>
<pre><code>L = [[[1, 2, 3], [4, 5]], 6]
</code></pre>
<p>Where the desired output is</p>
<pre><code>[1, 2, 3, 4, 5, 6]
</code></pre>
<p>Or perhaps even better, an iterator. The only solution I saw that works for an arbitrary nesting is found <a href="https://stackoverflow.com/questions/406121">in this question</a>:</p>
<pre><code>def flatten(x):
    result = []
    for el in x:
        if hasattr(el, "__iter__") and not isinstance(el, basestring):
            result.extend(flatten(el))
        else:
            result.append(el)
    return result

flatten(L)
</code></pre>
<p>Is this the best model? Did I overlook something? Any problems?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using generator functions can make your example a little easier to read and probably boost the performance.</p>
<h2>Python 2</h2>
<pre><code>def flatten(l):
    for el in l:
        if isinstance(el, collections.Iterable) and not isinstance(el, basestring):
            for sub in flatten(el):
                yield sub
        else:
            yield el
</code></pre>
<p>I used the <a href="http://docs.python.org/library/collections.html#abcs-abstract-base-classes" rel="noreferrer">Iterable ABC</a> added in 2.6.</p>
<h2>Python 3</h2>
<p>In Python 3, the <code>basestring</code> is no more, but you can use a tuple of <code>str</code> and <code>bytes</code> to get the same effect there.</p>
<p>The <code>yield from</code> operator returns an item from a generator one at a time. This <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="noreferrer">syntax for delegating to a subgenerator</a> was added in 3.3</p>
<pre><code>def flatten(l):
    for el in l:
        if isinstance(el, collections.Iterable) and not isinstance(el, (str, bytes)):
            yield from flatten(el)
        else:
            yield el
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My solution:</p>
<pre><code>def flatten(x):
    if isinstance(x, collections.Iterable):
        return [a for i in x for a in flatten(i)]
    else:
        return [x]
</code></pre>
<p>A little more concise, but pretty much the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>Generator version of @unutbu's non-recursive solution, as requested by @Andrew in a comment:</p>
<pre><code>def genflat(l, ltypes=collections.Sequence):
    l = list(l)
    i = 0
    while i &lt; len(l):
        while isinstance(l[i], ltypes):
            if not l[i]:
                l.pop(i)
                i -= 1
                break
            else:
                l[i:i + 1] = l[i]
        yield l[i]
        i += 1
</code></pre>
<p>Slightly simplified version of this generator:</p>
<pre><code>def genflat(l, ltypes=collections.Sequence):
    l = list(l)
    while l:
        while l and isinstance(l[0], ltypes):
            l[0:1] = l[0]
        if l: yield l.pop(0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Generator using recursion and duck typing (updated for Python 3):</p>
<pre><code>def flatten(L):
    for item in L:
        try:
            yield from flatten(item)
        except TypeError:
            yield item

list(flatten([[[1, 2, 3], [4, 5]], 6]))
&gt;&gt;&gt;[1, 2, 3, 4, 5, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This version of <code>flatten</code> avoids python's recursion limit (and thus works with arbitrarily deep, nested iterables). It is a generator which can handle strings and arbitrary iterables (even infinite ones).</p>
<pre><code>import itertools as IT
import collections

def flatten(iterable, ltypes=collections.Iterable):
    remainder = iter(iterable)
    while True:
        first = next(remainder)
        if isinstance(first, ltypes) and not isinstance(first, basestring):
            remainder = IT.chain(first, remainder)
        else:
            yield first
</code></pre>
<p>Here are some examples demonstrating its use:</p>
<pre><code>print(list(IT.islice(flatten(IT.repeat(1)),10)))
# [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

print(list(IT.islice(flatten(IT.chain(IT.repeat(2,3),
                                       {10,20,30},
                                       'foo bar'.split(),
                                       IT.repeat(1),)),10)))
# [2, 2, 2, 10, 20, 30, 'foo', 'bar', 1, 1]

print(list(flatten([[1,2,[3,4]]])))
# [1, 2, 3, 4]

seq = ([[chr(i),chr(i-32)] for i in xrange(ord('a'), ord('z')+1)] + range(0,9))
print(list(flatten(seq)))
# ['a', 'A', 'b', 'B', 'c', 'C', 'd', 'D', 'e', 'E', 'f', 'F', 'g', 'G', 'h', 'H',
# 'i', 'I', 'j', 'J', 'k', 'K', 'l', 'L', 'm', 'M', 'n', 'N', 'o', 'O', 'p', 'P',
# 'q', 'Q', 'r', 'R', 's', 'S', 't', 'T', 'u', 'U', 'v', 'V', 'w', 'W', 'x', 'X',
# 'y', 'Y', 'z', 'Z', 0, 1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<p>Although <code>flatten</code> can handle infinite generators, it can not handle infinite nesting:</p>
<pre><code>def infinitely_nested():
    while True:
        yield IT.chain(infinitely_nested(), IT.repeat(1))

print(list(IT.islice(flatten(infinitely_nested()), 10)))
# hangs
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my functional version of recursive flatten which handles both tuples and lists, and lets you throw in any mix of positional arguments. Returns a generator which produces the entire sequence in order, arg by arg:</p>
<pre><code>flatten = lambda *n: (e for a in n
    for e in (flatten(*a) if isinstance(a, (tuple, list)) else (a,)))
</code></pre>
<p>Usage:</p>
<pre><code>l1 = ['a', ['b', ('c', 'd')]]
l2 = [0, 1, (2, 3), [[4, 5, (6, 7, (8,), [9]), 10]], (11,)]
print list(flatten(l1, -2, -1, l2))
['a', 'b', 'c', 'd', -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another answer that is even more interesting...</p>
<pre><code>import re

def Flatten(TheList):
    a = str(TheList)
    b,crap = re.subn(r'[\[,\]]', ' ', a)
    c = b.split()
    d = [int(x) for x in c]

    return(d)
</code></pre>
<p>Basically, it converts the nested list to a string, uses a regex to strip out the nested syntax, and then converts the result back to a (flattened) list.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def flatten(xs):
    res = []
    def loop(ys):
        for i in ys:
            if isinstance(i, list):
                loop(i)
            else:
                res.append(i)
    loop(xs)
    return res
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html" rel="noreferrer"><code>deepflatten</code></a> from the 3rd party package <a href="https://iteration-utilities.readthedocs.io/en/latest/index.html" rel="noreferrer"><code>iteration_utilities</code></a>:</p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import deepflatten
&gt;&gt;&gt; L = [[[1, 2, 3], [4, 5]], 6]
&gt;&gt;&gt; list(deepflatten(L))
[1, 2, 3, 4, 5, 6]

&gt;&gt;&gt; list(deepflatten(L, types=list))  # only flatten "inner" lists
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>It's an iterator so you need to iterate it (for example by wrapping it with <code>list</code> or using it in a loop). Internally it uses an iterative approach instead of an recursive approach and it's written as C extension so it can be faster than pure python approaches:</p>
<pre><code>&gt;&gt;&gt; %timeit list(deepflatten(L))
12.6 µs ± 298 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
&gt;&gt;&gt; %timeit list(deepflatten(L, types=list))
8.7 µs ± 139 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

&gt;&gt;&gt; %timeit list(flatten(L))   # Cristian - Python 3.x approach from https://stackoverflow.com/a/2158532/5393381
86.4 µs ± 4.42 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)

&gt;&gt;&gt; %timeit list(flatten(L))   # Josh Lee - https://stackoverflow.com/a/2158522/5393381
107 µs ± 2.99 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)

&gt;&gt;&gt; %timeit list(genflat(L, list))  # Alex Martelli - https://stackoverflow.com/a/2159079/5393381
23.1 µs ± 710 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre>
<hr/>
<p>I'm the author of the <code>iteration_utilities</code> library.</p>
</div>
<div class="post-text" itemprop="text">
<p>It was fun trying to create a function that could flatten irregular list in Python, but of course that is what Python is for (to make programming fun). The following generator works fairly well with some caveats:</p>
<pre><code>def flatten(iterable):
    try:
        for item in iterable:
            yield from flatten(item)
    except TypeError:
        yield iterable
</code></pre>
<p>It will flatten datatypes that you might want left alone (like <code>bytearray</code>, <code>bytes</code>, and <code>str</code> objects). Also, the code relies on the fact that requesting an iterator from a non-iterable raises a <code>TypeError</code>.</p>
<pre><code>&gt;&gt;&gt; L = [[[1, 2, 3], [4, 5]], 6]
&gt;&gt;&gt; def flatten(iterable):
    try:
        for item in iterable:
            yield from flatten(item)
    except TypeError:
        yield iterable


&gt;&gt;&gt; list(flatten(L))
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt;
</code></pre>
<hr/>
<p><strong>Edit:</strong></p>
<p>I disagree with the previous implementation. The problem is that you should not be able to flatten something that is not an iterable. It is confusing and gives the wrong impression of the argument.</p>
<pre><code>&gt;&gt;&gt; list(flatten(123))
[123]
&gt;&gt;&gt;
</code></pre>
<p>The following generator is almost the same as the first but does not have the problem of trying to flatten a non-iterable object. It fails as one would expect when an inappropriate argument is given to it.</p>
<pre><code>def flatten(iterable):
    for item in iterable:
        try:
            yield from flatten(item)
        except TypeError:
            yield item
</code></pre>
<p>Testing the generator works fine with the list that was provided. However, the new code will raise a <code>TypeError</code> when a non-iterable object is given to it. Example are shown below of the new behavior.</p>
<pre><code>&gt;&gt;&gt; L = [[[1, 2, 3], [4, 5]], 6]
&gt;&gt;&gt; list(flatten(L))
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; list(flatten(123))
Traceback (most recent call last):
  File "&lt;pyshell#32&gt;", line 1, in &lt;module&gt;
    list(flatten(123))
  File "&lt;pyshell#27&gt;", line 2, in flatten
    for item in iterable:
TypeError: 'int' object is not iterable
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I prefer simple answers.  No generators.  No recursion or recursion limits.  Just iteration:</p>
<pre><code>def flatten(TheList):
    listIsNested = True

    while listIsNested:                 #outer loop
        keepChecking = False
        Temp = []

        for element in TheList:         #inner loop
            if isinstance(element,list):
                Temp.extend(element)
                keepChecking = True
            else:
                Temp.append(element)

        listIsNested = keepChecking     #determine if outer loop exits
        TheList = Temp[:]

    return TheList
</code></pre>
<p>This works with two lists: an inner for loop and an outer while loop.  </p>
<p>The inner for loop iterates through the list.  If it finds a list element, it (1) uses list.extend() to flatten that part one level of nesting and (2) switches keepChecking to True.  keepchecking is used to control the outer while loop.  If the outer loop gets set to true, it triggers the inner loop for another pass.  </p>
<p>Those passes keep happening until no more nested lists are found.  When a pass finally occurs where none are found, keepChecking never gets tripped to true, which means listIsNested stays false and the outer while loop exits.  </p>
<p>The flattened list is then returned.</p>
<p>Test-run   </p>
<pre><code>flatten([1,2,3,4,[100,200,300,[1000,2000,3000]]])
</code></pre>
<p><code>[1, 2, 3, 4, 100, 200, 300, 1000, 2000, 3000]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Although an elegant and very pythonic answer has been selected I would present my solution just for the review:</p>
<pre><code>def flat(l):
    ret = []
    for i in l:
        if isinstance(i, list) or isinstance(i, tuple):
            ret.extend(flat(i))
        else:
            ret.append(i)
    return ret
</code></pre>
<p>Please tell how good or bad this code is?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simple function that flattens lists of arbitrary depth. No recursion, to avoid stack overflow.</p>
<pre><code>from copy import deepcopy

def flatten_list(nested_list):
    """Flatten an arbitrarily nested list, without recursion (to avoid
    stack overflows). Returns a new list, the original list is unchanged.

    &gt;&gt; list(flatten_list([1, 2, 3, [4], [], [[[[[[[[[5]]]]]]]]]]))
    [1, 2, 3, 4, 5]
    &gt;&gt; list(flatten_list([[1, 2], 3]))
    [1, 2, 3]

    """
    nested_list = deepcopy(nested_list)

    while nested_list:
        sublist = nested_list.pop(0)

        if isinstance(sublist, list):
            nested_list = sublist + nested_list
        else:
            yield sublist
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's the <code>compiler.ast.flatten</code> implementation in 2.7.5:</p>
<pre><code>def flatten(seq):
    l = []
    for elt in seq:
        t = type(elt)
        if t is tuple or t is list:
            for elt2 in flatten(elt):
                l.append(elt2)
        else:
            l.append(elt)
    return l
</code></pre>
<p>There are better, faster methods (If you've reached here, you have seen them already)</p>
<p>Also note:</p>
<blockquote>
<p>Deprecated since version 2.6: The compiler package has been removed in Python 3.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I'm surprised no one has thought of this. Damn recursion I don't get the recursive answers that the advanced people here made. anyway here is my attempt on this. caveat is it's very specific to the OP's use case</p>
<pre><code>import re

L = [[[1, 2, 3], [4, 5]], 6]
flattened_list = re.sub("[\[\]]", "", str(L)).replace(" ", "").split(",")
new_list = list(map(int, flattened_list))
print(new_list)
</code></pre>
<p>output:</p>
<pre><code>[1, 2, 3, 4, 5, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I didn't go through all the already available answers here, but here is a one liner I came up with, borrowing from lisp's way of first and rest list processing </p>
<pre><code>def flatten(l): return flatten(l[0]) + (flatten(l[1:]) if len(l) &gt; 1 else []) if type(l) is list else [l]
</code></pre>
<p>here is one simple and one not-so-simple case -</p>
<pre><code>&gt;&gt;&gt; flatten([1,[2,3],4])
[1, 2, 3, 4]

&gt;&gt;&gt; flatten([1, [2, 3], 4, [5, [6, {'name': 'some_name', 'age':30}, 7]], [8, 9, [10, [11, [12, [13, {'some', 'set'}, 14, [15, 'some_string'], 16], 17, 18], 19], 20], 21, 22, [23, 24], 25], 26, 27, 28, 29, 30])
[1, 2, 3, 4, 5, 6, {'age': 30, 'name': 'some_name'}, 7, 8, 9, 10, 11, 12, 13, set(['set', 'some']), 14, 15, 'some_string', 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>totally hacky but I think it would work (depending on your data_type)</p>
<pre><code>flat_list = ast.literal_eval("[%s]"%re.sub("[\[\]]","",str(the_list)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is another py2 approach, Im not sure if its the fastest or the most elegant nor safest ...</p>
<pre><code>from collections import Iterable
from itertools import imap, repeat, chain


def flat(seqs, ignore=(int, long, float, basestring)):
    return repeat(seqs, 1) if any(imap(isinstance, repeat(seqs), ignore)) or not isinstance(seqs, Iterable) else chain.from_iterable(imap(flat, seqs))
</code></pre>
<p>It can ignore any specific (or derived) type you would like, it returns an iterator, so you can convert it to any specific container such as list, tuple, dict or simply consume it in order to reduce memory footprint, for better or worse it can handle initial non-iterable objects such as int ...</p>
<p>Note most of the heavy lifting is done in C, since as far as I know thats how itertools are implemented, so while it is recursive, AFAIK it isn't bounded by python recursion depth since the function calls are happening in C, though this doesn't mean you are bounded by memory, specially in OS X where its stack size has a hard limit as of today (OS X Mavericks) ...</p>
<p>there is a slightly faster approach, but less portable method, only use it if you can assume that the base elements of the input can be explicitly determined otherwise, you'll get an infinite recursion, and OS X with its limited stack size, will throw a segmentation fault fairly quickly ...</p>
<pre><code>def flat(seqs, ignore={int, long, float, str, unicode}):
    return repeat(seqs, 1) if type(seqs) in ignore or not isinstance(seqs, Iterable) else chain.from_iterable(imap(flat, seqs))
</code></pre>
<p>here we are using sets to check for the type so it takes O(1) vs O(number of types) to check whether or not an element should be ignored, though of course any value with derived type of the stated ignored types will fail, this is why its using <code>str</code>, <code>unicode</code> so use it with caution ...</p>
<p>tests:</p>
<pre><code>import random

def test_flat(test_size=2000):
    def increase_depth(value, depth=1):
        for func in xrange(depth):
            value = repeat(value, 1)
        return value

    def random_sub_chaining(nested_values):
        for values in nested_values:
            yield chain((values,), chain.from_iterable(imap(next, repeat(nested_values, random.randint(1, 10)))))

    expected_values = zip(xrange(test_size), imap(str, xrange(test_size)))
    nested_values = random_sub_chaining((increase_depth(value, depth) for depth, value in enumerate(expected_values)))
    assert not any(imap(cmp, chain.from_iterable(expected_values), flat(chain(((),), nested_values, ((),)))))

&gt;&gt;&gt; test_flat()
&gt;&gt;&gt; list(flat([[[1, 2, 3], [4, 5]], 6]))
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt;  

$ uname -a
Darwin Samys-MacBook-Pro.local 13.3.0 Darwin Kernel Version 13.3.0: Tue Jun  3 21:27:35 PDT 2014; root:xnu-2422.110.17~1/RELEASE_X86_64 x86_64
$ python --version
Python 2.7.5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>itertools.chain</code>:</p>
<pre><code>import itertools
from collections import Iterable

def list_flatten(lst):
    flat_lst = []
    for item in itertools.chain(lst):
        if isinstance(item, Iterable):
            item = list_flatten(item)
            flat_lst.extend(item)
        else:
            flat_lst.append(item)
    return flat_lst
</code></pre>
<p>Or without chaining:</p>
<pre><code>def flatten(q, final):
    if not q:
        return
    if isinstance(q, list):
        if not isinstance(q[0], list):
            final.append(q[0])
        else:
            flatten(q[0], final)
        flatten(q[1:], final)
    else:
        final.append(q)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I used recursive to solve <strong><em>nested list with any depth</em></strong></p>
<pre><code>def combine_nlist(nlist,init=0,combiner=lambda x,y: x+y):
    '''
    apply function: combiner to a nested list element by element(treated as flatten list)
    '''
    current_value=init
    for each_item in nlist:
        if isinstance(each_item,list):
            current_value =combine_nlist(each_item,current_value,combiner)
        else:
            current_value = combiner(current_value,each_item)
    return current_value
</code></pre>
<p>So after i define function combine_nlist, it is easy to use this function do flatting. Or you can combine it into one function. I like my solution because it can be applied to any nested list.</p>
<pre><code>def flatten_nlist(nlist):
    return combine_nlist(nlist,[],lambda x,y:x+[y])
</code></pre>
<p>result</p>
<pre><code>In [379]: flatten_nlist([1,2,3,[4,5],[6],[[[7],8],9],10])
Out[379]: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way is to use the <a href="https://github.com/metagriffin/morph" rel="nofollow">morph</a> library using <code>pip install morph</code>.</p>
<p>The code is:</p>
<pre><code>import morph

list = [[[1, 2, 3], [4, 5]], 6]
flattened_list = morph.flatten(list)  # returns [1, 2, 3, 4, 5, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am aware that there are already many awesome answers but i wanted to add an answer that uses the functional programming method of solving the question. In this answer i make use of double recursion :</p>
<pre><code>def flatten_list(seq):
    if not seq:
        return []
    elif isinstance(seq[0],list):
        return (flatten_list(seq[0])+flatten_list(seq[1:]))
    else:
        return [seq[0]]+flatten_list(seq[1:])

print(flatten_list([1,2,[3,[4],5],[6,7]]))
</code></pre>
<p>output:</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure if this is necessarily quicker or more effective, but this is what I do:</p>
<pre><code>def flatten(lst):
    return eval('[' + str(lst).replace('[', '').replace(']', '') + ']')

L = [[[1, 2, 3], [4, 5]], 6]
print(flatten(L))
</code></pre>
<p>The <code>flatten</code> function here turns the list into a string, takes out <strong>all</strong> of the square brackets, attaches square brackets back onto the ends, and turns it back into a list. </p>
<p>Although, if you knew you would have square brackets in your list in strings, like <code>[[1, 2], "[3, 4] and [5]"]</code>, you would have to do something else.</p>
</div>
<div class="post-text" itemprop="text">
<p>When trying to answer such a question you really need to give the limitations of the code you propose as a solution. If it was only about performances I wouldn't mind too much, but most of the codes proposed as solution (including the accepted answer) fail to flatten any list that has a depth greater than 1000.</p>
<p>When I say <em>most of the codes</em> I mean all codes that use any form of recursion (or call a standard library function that is recursive). All these codes fail because for every of the recursive call made, the (call) stack grow by one unit, and the (default) python call stack has a size of 1000. </p>
<p>If you're not too familiar with the call stack, then maybe the following will help (otherwise you can just scroll to the <strong>Implementation</strong>).</p>
<h2>Call stack size and recursive programming (dungeon analogy)</h2>
<h3>Finding the treasure and exit</h3>
<p>Imagine you enter a huge <em>dungeon with numbered rooms</em>, looking for a treasure. You don't know the place but you have some <strong>indications</strong> on how to find the treasure. Each indication is a riddle (difficulty varies, but you can't predict how hard they will be). You decide to think a little bit about a strategy to save time, you make two observations: </p>
<ol>
<li>It's hard (long) to find the treasure as you'll have to solve (potentially hard) riddles to get there. </li>
<li>Once the treasure found, returning to the entrance may be easy, you just have to use the same path in the other direction (though this needs a bit of memory to recall your path). </li>
</ol>
<p>When entering the dungeon, you notice a small <strong>notebook</strong> here. You decide to use it to write down every room you exit after solving a riddle (when entering a new room), this way you'll be able to return back to the entrance. That's a genius idea, you <em>won't even spend a cent</em> implementing your strategy.</p>
<p>You enter the dungeon, solving with great success the first 1001 riddles, but here comes something you hadn't planed, you have no space left in the notebook you borrowed. You decide to <em>abandon</em> your quest as you prefer not having the treasure than being lost forever inside the dungeon (that looks smart indeed).</p>
<h3>Executing a recursive program</h3>
<p>Basically, it's the exact same thing as finding the treasure. The dungeon is the <em>computer's memory</em>, your goal now is not to find a treasure but to <em>compute some function</em> (find <em>f(x)</em> for a given <em>x</em>). The indications simply are sub-routines that will help you solving <em>f(x)</em>. Your strategy is the same as the <em>call stack</em> strategy, the notebook is the stack, the rooms are the functions' return addresses: </p>
<pre><code>x = ["over here", "am", "I"]
y = sorted(x) # You're about to enter a room named `sorted`, note down the current room address here so you can return back: 0x4004f4 (that room address looks weird)
# Seems like you went back from your quest using the return address 0x4004f4
# Let's see what you've collected 
print(' '.join(y))
</code></pre>
<p>The problem you encountered in the dungeon will be the same here, the call stack has a finite size (here 1000) and therefore, if you enter too many functions without returning back then you'll fill the call stack and have an error that look like <strike>"Dear adventurer, I'm very sorry but your notebook is full"</strike>: <code>RecursionError: maximum recursion depth exceeded</code>. Note that you don't need recursion to fill the call stack, but it's very unlikely that a non-recursive program call 1000 functions without ever returning. It's important to also understand that once you returned from a function, the call stack is freed from the address used (hence the name "stack", return address are pushed in before entering a function and pulled out when returning). In the special case of a simple recursion (a function <code>f</code> that call itself once -- over and over --) you will enter <code>f</code> over and over until the computation is finished (until the treasure is found) and return from <code>f</code> until you go back to the place where you called <code>f</code> in the first place. The call stack will never be freed from anything until the end where it will be freed from all return addresses one after the other. </p>
<h3>How to avoid this issue?</h3>
<p>That's actually pretty simple: "don't use recursion if you don't know how deep it can go". That's not always true as in some cases, <a href="https://stackoverflow.com/questions/310974/what-is-tail-call-optimization">Tail Call recursion can be Optimized (TCO)</a>. But in python, this is not the case, and even "well written" recursive function will <strong>not</strong> optimize stack use. There is an interesting post from Guido about this question: <a href="http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html" rel="nofollow noreferrer"><em>Tail Recursion Elimination</em></a>.</p>
<p>There is a technique that you can use to make any recursive function iterative, this technique we could call <em><strong>bring your own notebook</strong></em>. For example, in our particular case we simply are exploring a list, entering a room is equivalent to entering a sublist, the question you should ask yourself is <em>how can I get back from a list to its parent list?</em> The answer is not that complex, repeat the following until the <code>stack</code> is empty:</p>
<ol>
<li>push the current list <code>address</code> and <code>index</code> in a <code>stack</code> when entering a new sublist (note that a list address+index is also an address, therefore we just use the exact same technique used by the call stack);</li>
<li>every time an item is found, <code>yield</code> it (or add them in a list);</li>
<li>once a list is fully explored, go back to the parent list using the <code>stack</code> <em>return <code>address</code> (and <code>index</code>)</em>.</li>
</ol>
<p>Also note that this is equivalent to a DFS in a tree where some nodes are sublists <code>A = [1, 2]</code> and some are simple items: <code>0, 1, 2, 3, 4</code> (for <code>L = [0, [1,2], 3, 4]</code>). The tree looks like this:</p>
<pre><code>                    L
                    |
           -------------------
           |     |     |     |
           0   --A--   3     4
               |   |
               1   2
</code></pre>
<p>The DFS traversal pre-order is: L, 0, A, 1, 2, 3, 4. Remember, in order to implement an iterative DFS you also "need" a stack. The implementation I proposed before result in having the following states (for the <code>stack</code> and the <code>flat_list</code>): </p>
<pre><code>init.:  stack=[(L, 0)]
**0**:  stack=[(L, 0)],         flat_list=[0]
**A**:  stack=[(L, 1), (A, 0)], flat_list=[0]
**1**:  stack=[(L, 1), (A, 0)], flat_list=[0, 1]
**2**:  stack=[(L, 1), (A, 1)], flat_list=[0, 1, 2]
**3**:  stack=[(L, 2)],         flat_list=[0, 1, 2, 3]
**3**:  stack=[(L, 3)],         flat_list=[0, 1, 2, 3, 4]
return: stack=[],               flat_list=[0, 1, 2, 3, 4]
</code></pre>
<p>In this example, the stack maximum size is 2, because the input list (and therefore the tree) have depth 2.</p>
<h2>Implementation</h2>
<p>For the implementation, in python you can simplify a little bit by using iterators instead of simple lists. References to the (sub)iterators will be used to store <em>sublists return addresses</em> (instead of having both the list address and the index). This is not a big difference but I feel this is more readable (and also a bit faster):</p>
<pre><code>def flatten(iterable):
    return list(items_from(iterable))

def items_from(iterable):
    cursor_stack = [iter(iterable)]
    while cursor_stack:
        sub_iterable = cursor_stack[-1]
        try:
            item = next(sub_iterable)
        except StopIteration:   # post-order
            cursor_stack.pop()
            continue
        if is_list_like(item):  # pre-order
            cursor_stack.append(iter(item))
        elif item is not None:
            yield item          # in-order

def is_list_like(item):
    return isinstance(item, list)
</code></pre>
<p>Also, notice that in <code>is_list_like</code> I have <code>isinstance(item, list)</code>, which could be changed to handle more input types, here I just wanted to have the simplest version where (iterable) is just a list. But you could also do that:</p>
<pre><code>def is_list_like(item):
    try:
        iter(item)
        return not isinstance(item, str)  # strings are not lists (hmm...) 
    except TypeError:
        return False
</code></pre>
<p>This considers strings as "simple items" and therefore <code>flatten_iter([["test", "a"], "b])</code> will return <code>["test", "a", "b"]</code> and not <code>["t", "e", "s", "t", "a", "b"]</code>. Remark that in that case, <code>iter(item)</code> is called twice on each item, let's pretend it's an exercise for the reader to make this cleaner. </p>
<h2>Testing and remarks on other implementations</h2>
<p>In the end, remember that you can't print a infinitely nested list <code>L</code> using <code>print(L)</code> because internally it will use recursive calls to <code>__repr__</code> (<code>RecursionError: maximum recursion depth exceeded while getting the repr of an object</code>). For the same reason, solutions to <code>flatten</code> involving <code>str</code> will fail with the same error message. </p>
<p>If you need to test your solution, you can use this function to generate a simple nested list:</p>
<pre><code>def build_deep_list(depth):
    """Returns a list of the form $l_{depth} = [depth-1, l_{depth-1}]$
    with $depth &gt; 1$ and $l_0 = [0]$.
    """
    sub_list = [0]
    for d in range(1, depth):
        sub_list = [d, sub_list]
    return sub_list
</code></pre>
<p>Which gives: <code>build_deep_list(5)</code> &gt;&gt;&gt; <code>[4, [3, [2, [1, [0]]]]]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you like recursion, this might be a solution of interest to you:</p>
<pre><code>def f(E):
    if E==[]: 
        return []
    elif type(E) != list: 
        return [E]
    else:
        a = f(E[0])
        b = f(E[1:])
        a.extend(b)
        return a
</code></pre>
<p>I actually adapted this from some practice Scheme code that I had written a while back. </p>
<p>Enjoy!</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm new to python and come from a lisp background. This is what I came up with (check out the var names for lulz):</p>
<pre><code>def flatten(lst):
    if lst:
        car,*cdr=lst
        if isinstance(car,(list,tuple)):
            if cdr: return flatten(car) + flatten(cdr)
            return flatten(car)
        if cdr: return [car] + flatten(cdr)
        return [car]
</code></pre>
<p>Seems to work. Test:</p>
<pre><code>flatten((1,2,3,(4,5,6,(7,8,(((1,2)))))))
</code></pre>
<p>returns:</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 1, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't see anything like this posted around here and just got here from a closed question on the same subject, but why not just do something like this(if you know the type of the list you want to split):</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 5, 10, [1, 25, 11, [1, 0]]]    
&gt;&gt;&gt; g = str(a).replace('[', '').replace(']', '')    
&gt;&gt;&gt; b = [int(x) for x in g.split(',') if x.strip()]
</code></pre>
<p>You would need to know the type of the elements but I think this can be generalised and in terms of speed I think it would be faster.</p>
</div>
<div class="post-text" itemprop="text">
<p>Without using any library:</p>
<pre><code>def flat(l):
    def _flat(l, r):    
        if type(l) is not list:
            r.append(l)
        else:
            for i in l:
                r = r + flat(i)
        return r
    return _flat(l, [])



# example
test = [[1], [[2]], [3], [['a','b','c'] , [['z','x','y']], ['d','f','g']], 4]    
print flat(test) # prints [1, 2, 3, 'a', 'b', 'c', 'z', 'x', 'y', 'd', 'f', 'g', 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Shamelessly taken from my own answer to <a href="https://stackoverflow.com/a/33109485/418374">another question</a>.</p>
<p>This function</p>
<ul>
<li>Does not use <code>isinstance</code>, because it's evil and breaks duck typing.</li>
<li>Uses <code>reduce</code> recursively.  There has to be an answer using <code>reduce</code>.</li>
<li>Works with arbitrary nested-lists whose elements are either nested-lists, or non-nested lists of atoms, or atoms (subjected to recursion limit).</li>
<li>Does not LBYL.</li>
<li>But not with nested-lists that contain strings as atoms.</li>
</ul>
<p>Code below:</p>
<pre><code>def flattener(left, right):
    try:
        res = reduce(flattener, right, left)
    except TypeError:
        left.append(right)
        res = left
    return res


def flatten(seq):
    return reduce(flattener, seq, [])


&gt;&gt;&gt; nested_list = [0, [1], [[[[2]]]],
                   [3, [], [4, 5]],
                   [6, [7, 8],
                    9, [[[]], 10,
                        []]],
                   11, [], [],
                   [12]]
&gt;&gt;&gt; flatten(nested_list)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can also use the 'type' function of python. When iterating the list we check if the item is a list or not. If not we 'append' it else we 'extend' it. Here is a sample code - </p>
<pre><code>l=[1,2,[3,4],5,[6,7,8]]
x=[]
for i in l:
    if type(i) is list:
        x.extend(i)
    else:
        x.append(i)
print x
</code></pre>
<p>Output:</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<p>For more info on append() and extend() check this website :
<a href="https://docs.python.org/2/tutorial/datastructures.html" rel="nofollow">https://docs.python.org/2/tutorial/datastructures.html</a></p>
</div>
<span class="comment-copy">The fact that there are this many answers and so much action on this question really suggests that this should be a built-in function somewhere, right?  It's especially too bad the compiler.ast was removed from Python 3.0</span>
<span class="comment-copy">I would say that what Python really needs is unbroken recursion rather than another builtin.</span>
<span class="comment-copy">It's a bit late in the game, but the simplest answer I think is here. The answer provided by @AChampion is resolves the problem by only using lambda function and list comprehension, which I think is pretty elegant <a href="https://stackoverflow.com/questions/50127177/can-i-flatten-a-list-using-recursive-function-and-list-comprehension">Here</a></span>
<span class="comment-copy">I like that this is a generator, and very clear.  Adding a guard against having a string in the list (not in the original spec, but will definitely blow the recursion limit), would make it perfect.</span>
<span class="comment-copy">You're right. I added a string check.</span>
<span class="comment-copy">Of all the suggestions on this page, this is the only one that flattened this list <code>l = ([[chr(i),chr(i-32)] for i in xrange(ord('a'), ord('z')+1)] + range(0,9))</code> in a snap when i did this  <code>list(flatten(l))</code>. All the others, would start working and take forever!</span>
<span class="comment-copy">Can be further simplified in python3.3+ using <code>yield from flatten(el)</code> instead of that loop.</span>
<span class="comment-copy">This also flattens dictionaries. Maybe you want to use <code>collections.Sequence</code> instead of <code>collections.Iteratable</code>?</span>
<span class="comment-copy"><code>import collections</code> is required, but it works fine for <code>[[[1, 2, 3], [4, 5]], 6]</code></span>
<span class="comment-copy">You can do this without importing anything if you just <code>try: iter(x)</code> to test whether it's iterable… But I don't think having to import a stdlib module is a downside worth avoiding.</span>
<span class="comment-copy">Worth to note that this solution works only if all the items are of type <code>int</code></span>
<span class="comment-copy">Could make it more concise, <code>def flatten(x): return [a for i in x for a in flatten(i)] if isinstance(x, collections.Iterable) else [x]</code> - but readability might be subjective here.</span>
<span class="comment-copy">this doesn't work on strings because strings are iterable too. Replace the condition with <code>if isinstance(x, collections.Iterable) and not isinstance(x, basestring)</code></span>
<span class="comment-copy">it's a pre-order traversal of the tree formed by the nested lists.  only the leaves are returned.  Note that this implementation will consume the original data structure, for better or worse.  Could be fun to write one that both preserves the original tree, but also doesn't have to copy the list entries.</span>
<span class="comment-copy">I think you need to test for strings -- eg add "and not isinstance(l[0], basestring)" as in Cristian's solution. Otherwise you get an infinite loop around l[0:1] = l[0]</span>
<span class="comment-copy">This is a good example of making a generator, but as c-urchin mentions, the algorithm itself fails when the sequence contains strings.</span>
<span class="comment-copy">Thanks for this solution. Point for improvement: <code>yield from flatten(item)</code>.</span>
<span class="comment-copy">Thanks, that works nice for Python 3.  For 2.x the previous is needed:  <code>for i in flatten(item):    yield i</code></span>
<span class="comment-copy">list(flatten([['X'], 'Y'])) fails on 2.X variant</span>
<span class="comment-copy">@user1019129 see my comment above yours</span>
<span class="comment-copy">yes it fails with the cycle.. i think because a string is also an "array"-of-chars</span>
<span class="comment-copy">So the best answer would be to somehow make this a generator.</span>
<span class="comment-copy">any consensus on whether to use ABC Iterable or ABC Sequence?</span>
<span class="comment-copy"><code>sets</code>, <code>dicts</code>, <code>deques</code>, <code>listiterators</code>, <code>generators</code>, filehandles, and custom classes with <code>__iter__</code> defined are all instances of <code>collections.Iterable</code>, but not <code>collections.Sequence</code>. The result of flattening a <code>dict</code> is a bit iffy, but otherwise, I think <code>collections.Iterable</code> is a better default than <code>collections.Sequence</code>. It's definitely the more liberal.</span>
<span class="comment-copy">@wim: One problem with using <code>collections.Iterable</code> is that this includes infinite generators. I've changed my answer handle this case.</span>
<span class="comment-copy">great solution, however would be much helpful if you added some comment to describe what <code>e</code>, <code>a</code>, <code>n</code> refer to</span>
<span class="comment-copy">@WolfgangKuehne: Try <code>args</code> for <code>n</code>, <code>intermediate</code> (or the shorter <code>mid</code> or you might prefer <code>element</code>) for <code>a</code> and <code>result</code> for <code>e</code>, so: <code>flatten = lambda *args: (result for mid in args for result in (flatten(*mid) if isinstance(mid, (tuple, list)) else (mid,)))</code></span>
<span class="comment-copy">This is significantly faster than <code>compiler.ast.flatten</code>. Great, compact code, works for any (I think) object type.</span>
<span class="comment-copy">If you try to generalize this to something other than int values, it'll be fun with, e.g., <code>[['C=64', 'APPLE ]['], ['Amiga', 'Mac', 'ST']]</code> :) On the other hand, given a list that contains itself, it'll do a little better than the other answers, raising an exception instead of just looping until you run out of memory/recursing until you exhaust the stack…</span>
<span class="comment-copy">The original prompt was about flattening a list of integers. If you just change the list comprehension to d=[x for x in c] it should work fine for your sample.</span>
<span class="comment-copy">First, <code>[x for x in c]</code> is just a slow and verbose way to make a copy of <code>c</code>, so why would you do that? Second, your code is clearly going to convert <code>'APPLE ]['</code> into <code>'APPLE   '</code>, because it doesn't handle quoting, it just assumes any brackets are list brackets.</span>
<span class="comment-copy">Well, at any rate, the obvious solution is to upgrade from an APPLE ][ to an APPLE //e or Apple //c, right? :)</span>
<span class="comment-copy">Even better...upgrade to the Apple IIGS: the first computer I ever had and the one that always gets forgotten. Everybody rants about how great the Amiga was, but the IIGS had fantastic graphics too. I still remember the first time I saw it load up a true IIGS game. It was like science fiction.   And then...Apple crippled the IIGS so that it wouldn't send the Macintosh the way of the Lisa.</span>
<span class="comment-copy">I wonder why this package has caused so less attention...</span>
<span class="comment-copy">@displayname There are several (lots) of libraries that provide such tools or similar ones: <code>more-itertools</code>, <code>toolz</code>, ... that have been around for much longer. They just differ a bit in available functionality/speed/options but they overlap in many respects. <code>iteration_utilities</code> is quite new and the only "advantage" is that it's faster in some cases than the alternatives. So it's really not surprising that it doesn't get much attention.</span>
<span class="comment-copy">I tried and thanks for the great package. It's super fast!</span>
<span class="comment-copy">I like simple too.  In this case though, you iterate over the list as many times as there are nestings or levels.  Could get expensive.</span>
<span class="comment-copy">@telliott99: You're right if your lists are really big and/or nested to great depths.  However, if that isn't the case, then the simpler solution works just as well, and without the deep magic of some of the other answers.  There is a place for multi-stage recursive generator comprehensions, but I'm not convinced that should be where you look first.  (I guess you know where I fall in the "Worse is Better" debate.)</span>
<span class="comment-copy">@telliott99: Or to put that another way, you won't have to "try to Grok" my solution.  If performance isn't a bottleneck, what matters most to you as a programmer?</span>
<span class="comment-copy">Simpler solutions have less logic. Recursion is a pretty fundamental programming construct that anyone who considers themselves a programmer should be completely comfortable with. Generators are very much the Python Way and (along with comprehensions) are something that any professional Python programmer should grok instantly.</span>
<span class="comment-copy">I agree about recursion. When I wrote my answer, python still broke recursion at 1000 cycles. Have they changed this? As for being a professional python programmer, I'm not. Moreover, I imagine many people programming in python do not do so full time.</span>
<span class="comment-copy">Use <code>isinstance(i, (tuple, list))</code>. Initializing empty variables is a flag for me to look to alternate code structures, typically comprehensions, generators, recursion, etc.</span>
<span class="comment-copy"><code>return type(l)(ret)</code> will get you the same container type back as was passed in, also. :)</span>
<span class="comment-copy">@dash-tom-bang Can you please explain what it means in a bit detail.</span>
<span class="comment-copy">If you pass in a list, you probably want a list back. If you pass in a tuple, you probably want a tuple back. If you pass in a mishmash of the two, you'll get whatever the outer enclosing thing was.</span>
<span class="comment-copy">Yes! Very similar to my code at <a href="https://github.com/jorgeorpinel/flatten_nested_lists/blob/master/flatten.py" rel="nofollow noreferrer">github.com/jorgeorpinel/flatten_nested_lists/blob/master/…</a></span>
<span class="comment-copy">It's not a one liner.  No matter how much you attempt to fit it into one, the <code>def foo():</code> is a separate line. Also, this is very unreadable.</span>
<span class="comment-copy">I've de-one-line-ified the code, and did some further refactoring. (edit is pending peer review as I write this) This particular method seemed very readable to me, though the original code did need some refactoring.</span>
<span class="comment-copy">"nested list with any depth" not true. Just try you'll see:  <code>current_value = combiner(current_value,each_item) RecursionError: maximum recursion depth exceeded</code></span>
<span class="comment-copy">hmmm I are you trying to flaten list with more than 1000 layers?</span>
<span class="comment-copy">Of course, that's the whole point of the discussion about recursive vs. iterative solutions. If you know in advance that the number of layers is &lt; than 1000 then the most simple solution will work. When you say "any depth" this includes list with depth &gt; 1000.</span>
<span class="comment-copy">This has no advantage over the simple solution as this fails to process deep lists, ie "RecursionError: maximum recursion depth exceeded while getting the repr of an object".</span>
<span class="comment-copy">This is clever (and probably fast)... but it's not very pythonic.</span>
<span class="comment-copy">"why not just do something like this"  you say? Because it is very easy to break! Very bad idea. One example, what if your items are strings, not ints? Then if a string contains a '[' you are doomed. And what if your items have no good (or very long) string representation?</span>
<span class="comment-copy">Hey I did this!</span>
<span class="comment-copy">@gb. Well what if this was what the op needed? and the example was clearly a list of <code>ints</code> so "what if's" don't apply here, had the OP stated otherwise, but then again he didn't so, this is the one of the simplest and most valid answers according to what was given.</span>
<span class="comment-copy">Well sorry, "what ifs" apply, careful considerations of all "what ifs" is the blood and guts of programming.</span>
<span class="comment-copy">Only works for single level nested list.</span>
