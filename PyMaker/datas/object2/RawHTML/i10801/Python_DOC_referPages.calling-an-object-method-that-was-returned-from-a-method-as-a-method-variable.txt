<div class="post-text" itemprop="text">
<p>I have a list of things, I'll use files as an example.  Each type of file needs to be processed in a different manner.  I created a class, "MyFile" and rather than maintaining a giant if:elif:else: structure I created a dictionary with the file type as the key. This is stored as a class variable.  </p>
<pre><code>class MyFile(object):

    def process_xlsx(self):
        #process file stuff for Excel
        pass

    def process_docx(self):
        #process file stuff for Word
        pass

    def get_filetype(self):
        try: 
            return self.FileTypes[file_extension]
        except KeyError:
            return None #filetype not handled... yet

    FileTypes = {
        "XLSX": ("Excel File", process_xlsx), 
        "DOCX": ("Word   Document", process_docx)
        }
</code></pre>
<p>Within a different class/object/module I instantiate the MyFile class and start stepping through the files.  The MyFile objects are created properly.</p>
<pre><code>f = MyFile("full_file_path_and_name")
file_type = f.get_filetype()
</code></pre>
<p>file_type has a tuple with the key and a function object. Here is an example:
    xls_0386.xlsx - ('Excel File', )
    doc_0386.docx - ('Word File', )</p>
<p><strong>Question: How do I call the function that was returned from f.get_filetype()?</strong></p>
<pre><code>file_type[1]()
</code></pre>
<p>Returns: process_xlsx() missing 1 required positional argument: 'self'</p>
<pre><code>file_type[1]
</code></pre>
<p>Creates no errors, but never actually makes the call (breakpoints never reached within the process_???? methods)</p>
<p>So again, What is the syntax to call an object method in this manner?</p>
<p>I know this is a bit convoluted to explain with my specifics, and for that I apologize.</p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You call it with the first argument being what you want self to be. For example:</p>
<pre><code>f = MyFile("full_file_path_and_name")
file_type = f.get_filetype()
file_type[1](f)
</code></pre>
<p>This way, you can also use any other file with the function. If you want to only call the specific file with <code>file_type[1]</code>, have a function that is partially filled in, so <code>self</code> is already an argument. You can do this with <a href="https://docs.python.org/2/library/functools.html#functools.partial" rel="nofollow">functools.partial</a></p>
<pre><code>import functools

class MyFile(object):

    # ...

    def get_filetype(self):
        def partial(func):
            return functools.partial(func, self)
        return {"XLSX": ("Excel File", partial(process_xlsx)),
                "DOCX": ("Word   Document", partial(process_docx))
               }.get(self.file_extension)

# Then you just do

f = MyFile("full_file_path_and_name")
file_type = f.get_filetype()
file_type[1]()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you create a <code>class</code>, the methods you define in it are <em>just functions</em>. Only when you retrieve their names from an <em>instance</em> of the class, will they be bound to that instance, producing bound methods. This is done via the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow">descriptor protocol</a>.</p>
<p>So when you create your <code>FileTypes</code> dictionary:</p>
<pre><code>FileTypes = {
    "XLSX": ("Excel File", process_xlsx), 
    "DOCX": ("Word   Document", process_docx)
    }
</code></pre>
<p>those are plain functions.</p>
<p>You have three options, basically:</p>
<ol>
<li><p>Don't create the dictionary at class definition time. Create it when you create an instance, so you can store <em>bound methods</em> in it:</p>
<pre><code>class MyFile(object):
    def __init__(self):    
        self.FileTypes = {
            "XLSX": ("Excel File", self.process_xlsx), 
            "DOCX": ("Word   Document", self.process_docx)
        }
</code></pre>
<p>Because this looks up the methods on <code>self</code>, they are bound.</p></li>
<li><p>Bind the method 'manually' when you look them up in <code>get_filetype()</code>:</p>
<pre><code>def get_filetype(self):
    try: 
        return self.FileTypes[file_extension].__get__(self)  # binding!
    except KeyError:
        return None #filetype not handled... yet
</code></pre></li>
<li><p>Return a <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial()</code> object</a> with <code>self</code> as a positional argument instead of just the function:</p>
<pre><code>from functools import partial

def get_filetype(self):
    try: 
        return partial(self.FileTypes[file_extension], self)  # also a kind of binding
    except KeyError:
        return None #filetype not handled... yet
</code></pre></li>
</ol>
<p>All three approaches result in an object being returned to the caller that, when called, will pass in the right instance of <code>MyFile()</code> to the chosen function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because those functions are declared inside a class, they have the argument <code>self</code> representing the object from that class that's calling the function. When you try to call that function separately, outside of the context of a <code>MyFile</code> object, there is no <code>self</code> variable anymore associated with the function call. That's why you get the error:</p>
<blockquote>
<p>missing 1 required positional argument: 'self'</p>
</blockquote>
<p>Just give it the instance of <code>MyFile</code> that you already created to use as the <code>self</code> variable:</p>
<pre><code>file_type[1](f)
</code></pre>
</div>
<span class="comment-copy">As you already know, this worked perfectly!  Thank you.  I am new to Python and I am still trying to get my head around some of the details.  This filled in yet another for me.    Also, thank you for the additional info regarding "partial".  I will delve into this more, but it is a definitely where I thought I was headed.  Many kudos.</span>
<span class="comment-copy">This is also all very correct.  I like some of the options you have laid out and will consider them and how they fit with my development style.  Thank you very much for your insights.  They are quite helpful.</span>
<span class="comment-copy">Thank you.  This is spot on.  I knew that "self" was missing, but didn't have the experience as to where to get it.  Now I know.</span>
