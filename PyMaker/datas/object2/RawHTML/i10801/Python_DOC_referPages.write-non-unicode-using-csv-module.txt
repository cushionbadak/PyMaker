<div class="post-text" itemprop="text">
<p>While migrating to Python 3, I noticed some files we generate using the built-in <code>csv</code> now have <code>b'</code> prefix around each strings...</p>
<p>Here's the code, that should generate a .csv for a list of <code>dogs</code>, according to some parameters defined by <code>export_fields</code> (thus always returns unicode data):</p>
<pre><code>file_content = StringIO()
csv_writer = csv.writer(
    file_content, delimiter='\t', quotechar='"', quoting=csv.QUOTE_MINIMAL
)
csv_writer.writerow([
    header_name.encode('cp1252') for _v, header_name in export_fields
])
# Write content
for dog in dogs:
    csv_writer.writerow([
        get_value(dog).encode('cp1252') for get_value, _header in export_fields
    ])
</code></pre>
<p>The problem is once I returns <code>file_content.getvalue()</code>, I get:</p>
<pre><code>b'Does he bark?'    b'Full     Name'    b'Gender'
b'Sometimes, yes'   b'Woofy the dog'    b'Male' 
</code></pre>
<p>Instead of <sup><sub>(indentation has been modified to be readable on SO)</sub></sup>:</p>
<pre><code>'Does he bark?'   'Full     Name'   'Gender'
'Sometimes, yes'  'Woofy the dog'   'Male' 
</code></pre>
<p>I did not find any <code>encoding</code> parameter in the <code>csv</code> module. I would like the whole file to be encoded in cp1252, so I don't really care either the encoding is done through the iteration of the lines or on the file construted itself. </p>
<p>So, does anyone know how to generate a proper string, containing only cp1252 encoded strings?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>csv</code> module deals with <em>text</em>, and converts anything that is not a string to a string using <code>str()</code>. </p>
<p>Don't pass in <code>bytes</code> objects. Pass in <code>str</code> objects or types that cleanly convert to strings with <code>str()</code>. That means you <em>should not encode strings</em>.</p>
<p>If you need <code>cp1252</code> output, encode the <code>StringIO</code> value:</p>
<pre><code>file_content.getvalue().encode('cp1252')
</code></pre>
<p>as <code>StringIO</code> objects also deal in text only.</p>
<p>Better yet, use a <a href="https://docs.python.org/3/library/io.html#io.BytesIO" rel="nofollow"><code>BytesIO</code> object</a> with a <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow"><code>TextIOWrapper()</code></a> to do the encoding for you as the <code>csv</code> module writes to the file object:</p>
<pre><code>from io import BytesIO, TextIOWrapper

file_content = BytesIO()
wrapper = TextIOWrapper(file_content, encoding='cp1252', line_buffering=True)
csv_writer = csv.writer(
    wrapper, delimiter='\t', quotechar='"', quoting=csv.QUOTE_MINIMAL)

# write rows

result = file_content.getvalue()
</code></pre>
<p>I've enabled line-buffering on the wrapper so that it'll auto-flush to the <code>BytesIO</code> instance every time a row is written.</p>
<p>Now <code>file_content.getvalue()</code> produces a bytestring:</p>
<pre><code>&gt;&gt;&gt; from io import BytesIO, TextIOWrapper
&gt;&gt;&gt; import csv
&gt;&gt;&gt; file_content = BytesIO()
&gt;&gt;&gt; wrapper = TextIOWrapper(file_content, encoding='cp1252', line_buffering=True)
&gt;&gt;&gt; csv_writer = csv.writer(wrapper, delimiter='\t', quotechar='"', quoting=csv.QUOTE_MINIMAL)
&gt;&gt;&gt; csv_writer.writerow(['Does he bark?', 'Full     Name', 'Gender'])
36
&gt;&gt;&gt; csv_writer.writerow(['Sometimes, yes', 'Woofy the dog', 'Male'])
35
&gt;&gt;&gt; file_content.getvalue()
b'Does he bark?\tFull     Name\tGender\r\nSometimes, yes\tWoofy the dog\tMale\r\n'
</code></pre>
</div>
<span class="comment-copy">Why are you encoding in the first place? The open file object takes care of that.</span>
<span class="comment-copy">@MartijnPieters Maybe my question is incomplete then: I want to return the string through Django: <code>return HttpResponse(generate_csv_file())</code>. Should I handle encoding at Django level instead?</span>
<span class="comment-copy">See my answer; you are approaching this at the wrong level; tabs and quotechars need to be encoded too, but this is the job of the I/O level, not the <code>csv</code> module or the code producing rows.</span>
<span class="comment-copy">Looks like it works with the wrapper indeed (once flushed, but you made the edit before I has the time to comment). Tests passed so 99% sure it is the right answer :)</span>
<span class="comment-copy">@MaximeLorant: I've now switched it to using line-buffering; avoids having to manually flush. Sorry about that.</span>
<span class="comment-copy">Seems cleaner indeed! Thanks for the tip.</span>
