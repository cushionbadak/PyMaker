<div class="post-text" itemprop="text">
<p>Is there a way to make a thread go to sleep if the list is empty and wake it up again when there are items? I don't want to use Queues since I want to be able to index into the datastructure.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, the solution will probably involve a <a href="https://docs.python.org/3/library/threading.html#condition-objects" rel="nofollow"><code>threading.Condition</code></a> variable as you note in comments.</p>
<p>Without more information or a code snippet, it's difficult to know what API suits your needs.  How are you producing new elements?  How are you consuming them?  At base, you could do something like this:</p>
<pre><code>cv = threading.Condition()
elements = []  # elements is protected by, and signaled by, cv

def produce(...):
  with cv:
    ... add elements somehow ...
    cv.notify_all()

def consume(...):
  with cv:
    while len(elements) == 0:
      cv.wait()
    ... remove elements somehow ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would go with this:</p>
<pre><code>import threading

class MyList (list):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._cond = threading.Condition()

    def append(self, item):
        with self._cond:
            super().append(item)
            self._cond.notify_all()

    def pop_or_sleep(self):
        with self._cond:
            while not len(self):
                self._cond.wait()
            return self.pop()
</code></pre>
</div>
<span class="comment-copy">@AkshatMahajan My mistake. I meant "list".</span>
<span class="comment-copy">But you then need to make a loop that asks for the state of the list if I understand it right. Or fire the thread when you set the list</span>
<span class="comment-copy">I am going with conditional locks. If it works, I will post my solution here.</span>
<span class="comment-copy">you could create a list subclass with a lock on it that opens when there are items in the list... it wouldn't be fast or efficient, but it should work</span>
