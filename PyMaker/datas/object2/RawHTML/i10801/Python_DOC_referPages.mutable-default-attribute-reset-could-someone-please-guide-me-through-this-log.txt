<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1132941/least-astonishment-and-the-mutable-default-argument">“Least Astonishment” and the Mutable Default Argument</a>
<span class="question-originals-answer-count">
                    32 answers
                </span>
</li>
</ul>
</div>
<p>I am confused by the following example:</p>
<pre><code>def append(elem, to=None):
if to is None:
    to = []
to.append(elem)
return to

append(5)
# Out: [5]    
append(3)   # A new list is created
# Out: [3]
</code></pre>
<p>The point here is supposed to be that you are resetting "to" to an empty list at the beginning of every function call to avoid the following:</p>
<pre><code>append(5)
# Out: [5]    
append(3)   # A new list is created
# Out: [5, 3]
</code></pre>
<p>But how can you check that "to" is None to set it to []? It seems to me that you are either pulling in the "to" defined in the definition, or you are pulling in the "to" modified by the last call. How does this work?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you define a function with a default argument, the function uses that default values for that argument if it is not supplied. So in the case of <code>append(5)</code>, <code>to</code> is not specified, so the function assumes the value of <code>to</code> to be <code>None</code> - it's effectively the same as calling <code>append(5, None)</code>.</p>
<p>So now, the function checks <code>if to is None</code>, which it is, so <code>to</code> gets reassigned to an empty list. <code>5</code> gets appended to the list, and the list is returned.</p>
<p>When you make the second call <code>append(3)</code>, it is again as if you called <code>append(3, None)</code>. Again, the <code>if to is None</code> evaluates to <code>True</code>, and <code>to</code> is reassigned to an empty list. Then, <code>3</code> is appended to that empty list, and the list is returned.</p>
<p>Since the default argument (in this case <code>None</code>) is immutable, the operations on <code>to</code> do not persist the end of the function call. The function has its own chunk of memory which gets cleared when the function returns.</p>
<p>However, if the default argument was mutable (like for instance <code>[]</code>), that value is created when the function is defined (i.e. when python sees <code>def func(arg1, arg2=[])</code>, it creates an empty list in memory and uses that list every time this function is called). Thus, any changes made to that list will persist the end of the function, since that mutable default argument was created when the function was <strong>defined</strong> (before the function was ever <strong>called</strong>).</p>
</div>
<div class="post-text" itemprop="text">
<p>I'll be quoting <a href="http://docs.python-guide.org/en/latest/writing/gotchas/" rel="nofollow">Common Gotchas — The Hitchhiker's Guide to Python</a> here:</p>
<p>For example like:</p>
<pre><code>def append_to(element, to=[]):
    to.append(element)
    return to
</code></pre>
<blockquote>
<p>A new list is created once when the function is defined, and the same
  list is used in each successive call.</p>
<p>Python’s default arguments are evaluated once when the function is
  defined, not each time the function is called (like it is in say,
  Ruby). This means that if you use a mutable default argument and
  mutate it, you will and have mutated that object for all future calls
  to the function as well.</p>
</blockquote>
<p>Also if you don't like to use none ant consider it an <a href="http://www.yegor256.com/2014/05/13/why-null-is-bad.html" rel="nofollow">antipattern</a>, you can use more fancier kind of this:</p>
<pre><code>def append_to(element, to=list):
    if callable(to):
        to = to()
    to.append(element)
    return to
</code></pre>
<p>I don't know if it's better though</p>
</div>
<span class="comment-copy">In the example you gave where <code>to</code> is assigned a value in the function, <code>to</code> only <i>exists</i> <i>inside</i> the function (its scope is only the function) - once the function returns, <code>to</code>'s scope vanishes so it vanishes - it is created again during the next call.  <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">docs.python.org/3/reference/…</a>, <a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow noreferrer">docs.python.org/3/tutorial/…</a></span>
<span class="comment-copy">I don't know enough about this topic to know whether this should be reopened, but if it does reopen, please do remove the meta commentary. We often discourage these addendums altogether since they are rarely updatd/removed if they no longer apply.</span>
<span class="comment-copy">Wow. So I knew most of this already, but I'm understanding that just because the default value's <i>type</i> is immutable, the value of the list doesn't persist. So the value of "to" always does reset to None here, and the list is recreated. Thanks!</span>
