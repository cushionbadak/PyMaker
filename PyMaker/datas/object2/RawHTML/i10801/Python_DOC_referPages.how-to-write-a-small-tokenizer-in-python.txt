<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/214881/can-you-add-new-statements-to-pythons-syntax">Can you add new statements to Python's syntax?</a>
<span class="question-originals-answer-count">
                    13 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/1547782/mini-languages-in-python">Mini-languages in Python</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>Normally, Python calls functions by</p>
<pre><code>func(arg0, arg1)
</code></pre>
<p>But I would like to change to</p>
<pre><code>func arg0 arg1
</code></pre>
<p>For example,</p>
<pre><code>#Something...
cmd = input()
interpret(cmd)
#Something...
</code></pre>
<p>If I input <code>'func arg0 arg1'</code>, then I expect Python to execute <code>func(arg0, arg1)</code>.</p>
<p><strong>Args will contain string, so that we can't simply split words.</strong></p>
<p>Actually, I would like to write some scripts to use on my mobile. So it would be a little annoying to type parentheses.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this : </p>
<pre><code>class  tryClass:
    def callFunction(self, arg, arg2):
        print("In call")
        print(arg)
        print(arg2)

input = str(input())
input = input.split(" ")
funcName = input[0]
my_cls = tryClass()

method = getattr(my_cls, funcName)
method(input[1], input[2])
</code></pre>
<p>If I put in input callFunction hello world it works :)</p>
</div>
<div class="post-text" itemprop="text">
<p>if none of the args contains whitespace you could do</p>
<pre><code>fn_args=cmd.split()
python_code="%s(%s)" % (fn[0], ", ".join(fn_args[1:]))
eval(python_code)
</code></pre>
<p>Edit:</p>
<p>If it is not that simple you should have a look at <a href="https://docs.python.org/3/library/cmd.html" rel="nofollow">https://docs.python.org/3/library/cmd.html</a> and <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow">https://docs.python.org/3/library/argparse.html</a> but these require some preparation before you can execute arbitrary code</p>
<p>Edit2:</p>
<p>If you do not need your args to be exact python, you could parse them as json <a href="https://docs.python.org/3/library/json.html#json.JSONDecoder.raw_decode" rel="nofollow">with the standard library</a></p>
<p>you could do it like</p>
<pre><code>import json
cmd='fname "a" "b" 1'
fn,sep,args=cmd.strip().partition(" ")
end=0
largs=[]
d=json.JSONDecoder()
while end &lt; len(args):
    args=args[end:].strip()
    arg,end=d.raw_decode(args)
    largs.append(arg)
exec(fn)(*largs) # better look into exec docs
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The builtin <code>shlex</code> module is probably what you want:</p>
<pre><code>&gt;&gt;&gt; import shlex
&gt;&gt;&gt; cmd = "func arg0 arg1 'arg2 has spaces'"
&gt;&gt;&gt; list(shlex.shlex(cmd))
['func', 'arg0', 'arg1', "'arg2 has spaces'"]
</code></pre>
<p>If you can trust the input, then actually calling this will look like:</p>
<pre><code>&gt;&gt;&gt; tokens = list(shlex.shlex(cmd))
&gt;&gt;&gt; # here is a stupid func function that reverses its input args
&gt;&gt;&gt; func = lambda *args: print(*reversed(args))
&gt;&gt;&gt; eval(tokens[0])(*tokens[1:])
'arg2 has spaces' arg1 arg0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All I want is a simple tokenizer. And I would like to run functions by calling <code>eval()</code>. So that's what I did for my project.</p>
<p>Here's the result:</p>
<pre><code>&gt;&gt;&gt; tokenizer('func 123 abc')
[('func', 'func'), ('arg', '123'), ('arg', 'abc')]
&gt;&gt;&gt; tokenizer('func 123.5 abc')
[('func', 'func'), ('arg', '123.5'), ('arg', 'abc')]
&gt;&gt;&gt; tokenizer('func 123.5 abc "Hello, World!"')
[('func', 'func'), ('arg', '123.5'), ('arg', 'abc'), ('arg', 'Hello, World!')]
&gt;&gt;&gt; tokenizer("func 123.5 abc 'Hello, World!'")
[('func', 'func'), ('arg', '123.5'), ('arg', 'abc'), ('arg', 'Hello, World!')]
</code></pre>
<p><strong>Attentsion: This may not suitable for everyone, this's not a complete parser or tokenizer.</strong></p>
<p>Code:</p>
<pre><code>def isNumber(cmd):
    try:
        int(cmd)
        return True
    except ValueError:
        try:
            float(cmd)
            return True
        except ValueError:
            return False
    return False

def isWord(cmd):
    if len(cmd) == 0:
        return False
    if cmd[0].isalpha():
        for i in cmd[1:]:
            if not i.isalpha() and i != '_' and i != '-':
                return False
        return True
    return False
def spaceParser(cmd):
    i = 0
    for i in range(len(cmd)):
        if cmd[i] == ' ':
            continue
        break
    return cmd[i:]

def funcNameParser(cmd):
    cmd = spaceParser(cmd)
    i = 0
    word = ''
    for i in range(len(cmd)):
        if cmd[i] != ' ':
            word += cmd[i]
        else:
            break
    if i + 1 &gt; len(word):
        return (word, cmd[i:])
    return (word, cmd[i+1:])

def argumentParser(cmd):
    cmd = spaceParser(cmd)
    if cmd[0] == '\'':
        word = ''
        i = 0
        for i in range(1, len(cmd)):
            if cmd[i] != '\'':
                word += cmd[i]
            else:
                return (word, cmd[i+1:])
        assert False, 'Fatal exception: String not finished.'
    if cmd[0] == '"':
        word = ''
        i = 0
        for i in range(1, len(cmd)):
            if cmd[i] != '"':
                word += cmd[i]
            else:
                return (word, cmd[i+1:])
        assert False, 'Fatal exception: String not finished.'            
    i = 0
    word = ''
    for i in range(len(cmd)):
        if cmd[i] != ' ':
            word += cmd[i]
        else:
            break
    assert isWord(word) or isNumber(word), 'Fatal exception: Not a valid name.'
    if i + 1 &gt; len(word):
        return (word, cmd[i:]) 
    return (word, cmd[i+1:])

def tokenizer(cmd):
    token = []
    result = funcNameParser(cmd)
    token += [('func', result[0])]
    while len(result[1]) != 0:
        result = argumentParser(result[1])
        token += [('arg', result[0])]
    return token
</code></pre>
</div>
<span class="comment-copy">So you want to rewrite the Python parser to create your own language...? I think that's a bit out of scope here.</span>
<span class="comment-copy">@deceze No. Because I would like to use it on a terminal on my phone. It's annoying to type parentheses on my phone.</span>
<span class="comment-copy">So you just want to split the first word from the input, look up the function by that name, and call it with the rest of the arguments like <code>f(*args)</code>...?</span>
<span class="comment-copy">Yes. But arg may be a string like `'Hello, World!'. So I think it should not simply split them. Should have a little parser I suppose.</span>
<span class="comment-copy">In the end you <i>are</i> looking to create a new mini language. If you need to take strings with spaces etc. into account, you need a parser, and <i>boom</i>, you're in DSL territory.</span>
<span class="comment-copy">Actually there will be spaces and commas.</span>
<span class="comment-copy">@ZhipengYANG Added links for not-that-simple cases</span>
<span class="comment-copy">@ZhipengYANG Added JSON hack</span>
