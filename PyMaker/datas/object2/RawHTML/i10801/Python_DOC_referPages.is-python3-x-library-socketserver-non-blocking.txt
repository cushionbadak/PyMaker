<div class="post-text" itemprop="text">
<p>I'm reading socketserver.py code, and I've found that it is using selectors.PollSelector if available. But there is no setblocking(0) on master socket or tcp connection socket. Can somebody explain why are sockets set to block as it is default socket behavior?</p>
<p>edit</p>
<p>I've done few tests and I've should even change the title...but when you choose to use select, does it matter if socket is in blocking state?Because in this code snippet, True/False on setblocking have no effect.</p>
<pre><code>import sys
import socket
from time import sleep
import select

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(('127.0.0.1',9999))
s.setblocking(1) # does it matter?
s.listen(10)
timeout=100
inp = [s]
out = []

def worker(client,num):
    print('Worker sending out',client,num)
    client.send( str(str(num)+'\n').encode('utf-8'))
    sleep(0.3)

server_client = {}
while True:
    print('in loop')
    try:
       inputready,outputready,_ = select.select(inp,out,[],timeout)
       for server in inputready:
           if server == s:
               print('accept',server)
               client, address = server.accept()
               client.setblocking(1) # does it matter?
               inp.append(client)
               out.append(client)
       for server in outputready:
           if server in server_client:
               server_client[server] += 1
           else:
               server_client[server] = 0
           worker(server,server_client[server])

    except BlockingIOError:
        print('ERR blocking')
        pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>The short answer:</h2>
<p>For select() it makes no difference if a socket/stream/filehandle is blocking or not. 
Only reading from or writing to a socket, and only if no data is available, the behavior will be different.</p>
<h2>Explanation (based on Linux):</h2>
<ul>
<li>A read call on a <strong>blocking socket</strong> will wait until data becomes available or return zero bytes if the socket has been closed.</li>
<li>A read call on a <strong>non-blocking socket</strong> will either return data if available or return the error EAGAIN under the hood. The latter signals the upper library that no data was available.</li>
<li>A write call on a <strong>blocking socket</strong> might block, if the underlying transport layer's send buffer is full.</li>
<li>A write call on a <strong>non-blocking socket</strong> would return the error EAGAIN in case the send buffer is full, signaling the caller to try again later. </li>
</ul>
</div>
<span class="comment-copy">Sockets being set to block is default in general, not just in the <a href="https://docs.python.org/3.4/library/socketserver.html#module-socketserver" rel="nofollow noreferrer"><code>socketserver</code></a> module, so it doesn't surprise me that the module authors chose to implement the default similarly.  However, it's worth pointing out that both the <code>socketserver</code> and <a href="https://docs.python.org/3/library/socket.html#socket.socket.settimeout" rel="nofollow noreferrer"><code>socket</code></a> modules support nonblocking mode.  It may be harder to identify in  the socket module, but look for "timeout".</span>
