<div class="post-text" itemprop="text">
<p>I am trying to write a test that mocks raising <code>PermissionError</code> on a call to <code>open()</code> when attempting to open a file for reading. However I cannot seem to get the test working. The <code>PermissionError</code> appears to be thrown but my test fails because of this even though I am trying to assert it is thrown. </p>
<p>Below contains one of my attempts:</p>
<p><strong>fileMethods.py</strong></p>
<pre><code>def readfile(myfile):
    with open(myfile, 'r') as file:
        filecontent = file.read()
    file.close()
    return filecontent
</code></pre>
<p><strong>fileMethods_test.py</strong></p>
<pre><code>def test_readfile_throws_PermissionError(self):
    with mock.patch('fileMethods.open') as openMock:
        openMock.side_effect = PermissionError
        self.assertRaises(PermissionError, fileMethods.readfile('file_to_readin'))
</code></pre>
<p>Am I missing something obvious or is the way I am testing this method incorrect?</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason this will not work is because you are mocking <code>fileMethods.open</code> and so the <code>open</code> function (which raises the <code>PermissionError</code> you're looking for) is not even called.</p>
<p>If the <code>open</code> function is mocked (and therefore, the called function will do nothing), you can't assert that the exception raised by that function is called.</p>
<p>The way it works is that when you mock a function it will, by default, not do anything. Look into the documentation <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow">here</a> which explains this in further depth.</p>
</div>
<span class="comment-copy">Either you open a file with <code>with</code> OR you close it manually.</span>
<span class="comment-copy">So have I reference the wrong open then in the mock? And how would I go about testing the <code>readFile</code> method?</span>
