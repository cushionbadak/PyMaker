<div class="post-text" itemprop="text">
<p>I was wondering if there is a way to print the object name in python as a string.  For example I want to be able to say ENEMY1 has 2 hp left or ENEMY2 has 4 hp left.  Is there a way of doing that?\</p>
<pre><code>class badguy:
    def __init__(self):
        self.hp = 4

    def attack(self):
        print("hit")
        self.hp -= 1

    def still_alive(self):
        if self.hp &lt;=0:
            print("enemy destroyed")
        else :
            print (str(self.hp) + " hp left")

    # creating objects

    enemy1 = badguy()
    enemy2 = badguy()

    enemy1.attack()
    enemy1.attack()
    enemy1.still_alive()
    enemy2.still_alive()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You'd have to first give them names. E.g.</p>
<pre><code>class badguy:
    def __init__(self, name):
        self.hp = 4
        self.name = name

    def attack(self):
        print("hit")
        self.hp -= 1

    def still_alive(self):
        if self.hp &lt;=0:
            print("enemy destroyed")
        else :
            print (self.name + " has " + str(self.hp) + " hp left")

    # creating objects

    enemy1 = badguy('ENEMY1')
    enemy2 = badguy('ENEMY2')

    enemy1.attack()
    enemy1.attack()
    enemy1.still_alive()
    enemy2.still_alive()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A much better <strong>design principle</strong> is not to rely on the specific name of the object as shown below:</p>
<pre><code>class badguy(object):
    def __init__(self):
        pass

b = badguy()
print b
&gt;&gt;&gt; &lt;__main__.badguy object at 0x7f2089a74e50&gt;  # Not a great name huh? :D
</code></pre>
<p>This can lead to a whole wealth of <em>issues</em> with assignment binding, referencing, and most importantly does not allow you to name your objects per <em>user</em> or <em>program</em> choice.</p>
<p>Instead add an instance variable to your class called <code>self._name</code> (<a href="https://docs.python.org/3/tutorial/classes.html#tut-private" rel="nofollow">9.6 Classes - Private Variables</a>) or <code>self.name</code> if you want to allow access outside the scope of the class (<em>in this example, you can name it anything</em>). Not only is this more <em>Object-Oriented</em> design, but now you can implement methods like <code>__hash__</code> to be able to create a <strong>hash</strong> based on a name for example to use an object as a key (<em>there are many more reasons why this design choice is better!</em>).</p>
<pre><code>class badguy(object):
    def __init__(self, name=None):
        self.hp = 4
        self._name = name   

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        self._name = name

    def attack(self):
        print("hit")
        self.hp -= 1

    def still_alive(self):
        if self.hp &lt;=0:
            print("enemy destroyed")
        else :
            print ("{} has {} hp left.".format(self.name, self.hp))
</code></pre>
<p><strong>Sample output:</strong></p>
<pre><code>b = badguy('Enemy 1')
print b.name
&gt;&gt;&gt; Enemy 1

b.still_alive()
&gt;&gt;&gt; Enemy 1 has 4 hp left.

b.name = 'Enemy One'  # Changing our object's name.
b.still_alive()
&gt;&gt;&gt; Enemy One has 4 hp left.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have posted a complete solution here:</p>
<p><a href="https://stackoverflow.com/a/49331683/7386061">https://stackoverflow.com/a/49331683/7386061</a></p>
<p>It works without parameters. For example you could just do:</p>
<pre><code>class badguy(RememberInstanceCreationInfo):
    def __init__(self):
        super().__init__()
        self.hp = 4

    def attack(self):
        print("hit")
        self.hp -= 1

    def still_alive(self):
        if self.hp &lt;=0:
            print("enemy destroyed")
        else :
            print (self.creation_name + " has " + str(self.hp) + " hp left")

enemy1 = badguy()
enemy2 = badguy()

enemy1.attack()
enemy1.attack()
enemy1.still_alive()
enemy2.still_alive()

out: hit
out: hit
out: enemy1 has 2 hp left
out: enemy2 has 4 hp left
</code></pre>
</div>
<span class="comment-copy">You can, but you may find that it makes more sense to just have a <code>name</code> field on the <code>badguy</code> class. Reflecting against variable names is almost always a bad idea. Plus, what if you had a huge list of enemies?</span>
<span class="comment-copy">Objects don't have unique names.  If you do <code>newname = enemy1</code>, then what is the "name" of that object?</span>
<span class="comment-copy">Most objects don't have names. Variables have names, but there is no one-to-one correspondence between variables and objects.</span>
<span class="comment-copy">It's actually impossible to do this, since multiple "names" can refer to the same object: <code>a = object(); b = a; print(a is b)  # True</code></span>
<span class="comment-copy">I see the issue not putting in the self, name.  That does make it easier to use, although I was hoping that the actual variable name could have been used so there isn't the redundancy of making the object name and then naming it again in quotes. Thank you.</span>
<span class="comment-copy">@netrate As commenters have pointed out, there's no such thing as an "object name." The <i>variable</i> has a name, but there can be lots of variables pointing to the same object, so how would you decide which one to use?</span>
<span class="comment-copy">Good answer, but my eyes bleed at <code>set_name(..)</code>. Can you please use <code>@property</code> instead?</span>
<span class="comment-copy">@SuperSaiyan Changed it aha, I agree <code>@property</code> is the way to go, simply didn't include it in the answer originally.</span>
