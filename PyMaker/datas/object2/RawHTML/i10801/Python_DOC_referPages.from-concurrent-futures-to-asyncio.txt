<div class="post-text" itemprop="text">
<p>I have two problems with <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">concurrent.futures</a>:</p>
<h1>How to break time.sleep() in a python concurrent.futures?</h1>
<p>Conclusion: time.sleep() cannot be interrupted. One solution is: You can write a loop around it and do short sleeps.</p>
<p>See <a href="https://stackoverflow.com/questions/38461603/how-to-break-time-sleep-in-a-python-concurrent-futures">How to break time.sleep() in a python concurrent.futures</a></p>
<h1>Individual timeouts for concurrent.futures?</h1>
<p>Conclusion: individual timeouts need to implemented by the user. For example: for each timeout you  can call to <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.wait" rel="nofollow noreferrer">wait()</a>.</p>
<p>See  <a href="https://stackoverflow.com/questions/38456357/individual-timeouts-for-concurrent-futures">Individual timeouts for concurrent.futures</a></p>
<h1>Question</h1>
<p>Does <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a> solve theses problems?</p>
</div>
<div class="post-text" itemprop="text">
<p>In the asyncio model, execution is scheduled and coordinated by an event loop. To cancel execution of a currently suspended task, you essentially simply have to <em>not resume</em> it. While this works a little different in practice, it should be obvious that this makes cancelling a suspended task simple in theory.</p>
<p>Individual timeouts are certainly possible the same way: whenever you suspend a coroutine to wait for a result, you want to supply a timeout value. The event loop will ensure to cancel the waiting task when that timeout is reached and the task hasn't completed yet.</p>
<p>Some concrete samples:</p>
<pre><code>&gt;&gt;&gt; import asyncio
&gt;&gt;&gt; loop = asyncio.get_event_loop()
&gt;&gt;&gt; task = asyncio.ensure_future(asyncio.sleep(5))
&gt;&gt;&gt; task.cancel()
&gt;&gt;&gt; loop.run_until_complete(task)
Traceback (most recent call last):
   ...
concurrent.futures._base.CancelledError
</code></pre>
<p>In practice, this might be implemented using something like this:</p>
<pre><code>class Foo:
    task = None

    async def sleeper(self):
        self.task = asyncio.sleep(60)
        try:
            await self.task
        except concurrent.futures.CancelledError:
            raise NotImplementedError
</code></pre>
<p>While this method is asleep, somebody else can call <code>foo.task.cancel()</code> to wake up the coroutine and let it handle the cancellation. Alternatively whoever calls <code>sleeper()</code> can cancel <em>it</em> directly without giving it a chance to clean up.</p>
<p>Setting timeouts is similarly easy:</p>
<pre><code>&gt;&gt;&gt; loop.run_until_complete(asyncio.wait_for(asyncio.sleep(60), 5))
[ ... 5 seconds later ... ]
Traceback (most recent call last):
   ...
concurrent.futures._base.TimeoutError
</code></pre>
<p>Particularly in the context of HTTP request timeouts, see <a href="http://aiohttp.readthedocs.io" rel="nofollow">aiohttp</a>:</p>
<pre><code>async def fetch_page(session, url):
    with aiohttp.Timeout(10):
        async with session.get(url) as response:
            assert response.status == 200
            return await response.read()

with aiohttp.ClientSession(loop=loop) as session:
    content = loop.run_until_complete(fetch_page(session, 'http://python.org'))
</code></pre>
<p>Obviously each call to <code>fetch_page</code> can decide on its own <code>aiohttp.Timeout</code> value, and each individual instance will throw its own exception when that timeout is reached.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could raise immediately in its exception (with <code>asyncio.CancelledError</code>).</p>
<p>I'm using this catch to overcome it:</p>
<pre><code>import asyncio

async def worker():
    try:
        # await some coroutine process
    except asyncio.CancelledError:
        # Do stuff
        raise asyncio.CancelledError()
    except Exception as exc:
        # Do stuff
        print(exc)
    finally:
        await asyncio.sleep(2)
</code></pre>
</div>
<span class="comment-copy">For the sake of self-containment, can you summarise those other two questions here?</span>
<span class="comment-copy">@deceze, I updated the question and added my conclusion. Is this ok, or still something missing?</span>
<span class="comment-copy">Looks more answerable now, thanks.</span>
<span class="comment-copy">Wow, great answer. Thank you. Imagine I use the subprocess module (I read that it is supported), then I want to terminate the subprocess somehow. Do you have a hint how to do this?</span>
<span class="comment-copy">Not really, no. You should open a new question for that.</span>
<span class="comment-copy">@guettli Have a look at the <a href="https://docs.python.org/3/library/asyncio-subprocess.html" rel="nofollow noreferrer">asyncio.subprocess</a> module and those <a href="http://asyncio.readthedocs.io/en/latest/subprocess.html" rel="nofollow noreferrer">examples</a>.</span>
