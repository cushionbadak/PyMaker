<div class="post-text" itemprop="text">
<p>Is there an equivalent to R's <code>do.call</code> in python?</p>
<pre><code>do.call(what = 'sum', args = list(1:10)) #[1] 55
do.call(what = 'mean', args = list(1:10)) #[1] 5.5

?do.call
# Description
# do.call constructs and executes a function call from a name or a function and a list of arguments to be passed to it.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no built-in for this, but it is easy enough to construct an equivalent.</p>
<p>You can look up any object from the built-ins namespace using the <a href="https://docs.python.org/2/library/__builtin__.html" rel="nofollow"><code>__builtin__</code></a> (Python 2) or <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow"><code>builtins</code></a> (Python 3) modules then apply arbitrary arguments to that with <code>*args</code> and <code>**kwargs</code> syntax:</p>
<pre><code>try:
    # Python 2
    import __builtin__ as builtins
except ImportError:
    # Python 3
    import builtins

def do_call(what, *args, **kwargs):
    return getattr(builtins, what)(*args, **kwargs)

do_call('sum', range(1, 11))
</code></pre>
<p>Generally speaking, we don't do this in Python. If you must translate strings into function objects, it is generally preferred to build a custom dictionary:</p>
<pre><code>functions = {
    'sum': sum,
    'mean': lambda v: sum(v) / len(v),
}
</code></pre>
<p>then look up functions from that dictionary instead:</p>
<pre><code>functions['sum'](range(1, 11))
</code></pre>
<p>This lets you strictly control what names are available to dynamic code, preventing a user from making a nuisance of themselves by calling built-ins for their destructive or disruptive effects.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>do.call</code> is pretty much the equivalent of the <a href="https://stackoverflow.com/q/2322355/1968">splat operator</a> in Python:</p>
<pre><code>def mysum(a, b, c):
    return sum([a, b, c])

# normal call:
mysum(1, 2, 3)

# with a list of arguments:
mysum(*[1, 2, 3])
</code></pre>
<p>Note that I’ve had to define my own <code>sum</code> function since Python’s <code>sum</code> already expects a <code>list</code> as an argument, so your original code would just be</p>
<pre><code>sum(range(1, 11))
</code></pre>
<p>R has another peculiarity: <code>do.call</code> internally performs a function lookup of its first argument. This means that it finds the function even if it’s a character string rather than an actual function. The Python equivalent above doesn’t do this — see Martijn’s answer for a solution to this. Two things about this though:</p>
<ol>
<li>It’s not specific to <code>do.call</code> in R. In fact, the function lookup is probably internally performed by <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.fun.html" rel="nofollow noreferrer"><code>match.fun</code></a>.</li>
<li>It’s a case of “too much magic” and I would strongly discourage writing such code in R, let alone more strongly-typed languages: it subverts the type system and that generally leads to bugs. Case in point, the R documentation of <code>do.call</code> is pretty vague on what action is performed when <code>what</code> is a character string. For instance, given its description it would be reasonable to expect that <code>do.call('base::sum', list(1, 2))</code> should work. Alas, it doesn’t.</li>
</ol>
</div>
<span class="comment-copy">The next question is: is this a good idea? — No. No, it isn’t.</span>
<span class="comment-copy">@KonradRudolph: nope; there are better ways of parameterising functions.</span>
<span class="comment-copy">Thanks @KonradRudolph for your help. In principle, I am parsing a text file, in which the aggregation function is specified there. I would like to avoid using a switch/dictionary that maps such string to its function. Any ideas on that as well?</span>
<span class="comment-copy">@Dee Use the dictionary (actually, no: use a <code>context</code> object that provides a dictionary-like interface, but isolates side-effects of the called functions from the rest of the program). It’s the appropriate solution for this case, both in Python and in R. Letting the user execute arbitrary functions is never a good idea anyway.</span>
