<div class="post-text" itemprop="text">
<p>I don't seem to be able to monkey patch a <code>__call__</code> method of class instance (and yes, I want to patch just single instances, not all of them).</p>
<p>The following code:</p>
<pre><code>class A(object):
    def test(self):
        return "TEST"

    def __call__(self):
        return "EXAMPLE"

a = A()
print("call method: {0}".format(a.__call__))
print("test method: {0}".format(a.test))
a.__call__ = lambda : "example"
a.test = lambda : "test"
print("call method: {0}".format(a.__call__))
print("test method: {0}".format(a.test))

print(a())
print("Explicit call: {0}".format(a.__call__()))
print(a.test())
</code></pre>
<p>Outputs this:</p>
<pre><code>call method: &lt;bound method A.__call__ of &lt;__main__.A object at 0x7f3f2d60b6a0&gt;&gt;
test method: &lt;bound method A.test of &lt;__main__.A object at 0x7f3f2d60b6a0&gt;&gt;
call method: &lt;function &lt;lambda&gt; at 0x7f3f2ef4ef28&gt;
test method: &lt;function &lt;lambda&gt; at 0x7f3f2d5f8f28&gt;
EXAMPLE
Explicit call: example
test
</code></pre>
<p>While I'd like it to output:</p>
<pre><code>...
example
Explicit call: example
test
</code></pre>
<p><strong>How do I monkeypatch <code>__call__()</code>? Why I can't patch it the same way as I patch other methods?</strong></p>
<p>While <a href="https://stackoverflow.com/a/14590308/462370">this answer</a> tells how to do it (supposedly, I haven't tested it yet), it doesn't explain the <em>why</em> part of the question.</p>
</div>
<div class="post-text" itemprop="text">
<p>So, as <a href="https://stackoverflow.com/users/5781248/j-j-hakala">J.J. Hakala</a> commented, what Python really does, is to call:</p>
<pre><code>type(a).__call__(a)
</code></pre>
<p>as such, if I want to override the <code>__call__</code> method, I <strong>must</strong> override the <code>__call__</code> of a class, but if I don't want to affect behaviour of other instances of the same class, I need to create a new class with the overriden <code>__call__</code> method.</p>
<p>So an example of how to override <code>__call__</code> would look like this:</p>
<pre><code>class A(object):
    def test(self):
        return "TEST"

    def __call__(self):
        return "EXAMPLE"

def patch_call(instance, func):
    class _(type(instance)):
        def __call__(self, *arg, **kwarg):
           return func(*arg, **kwarg)
    instance.__class__ = _

a = A()
print("call method: {0}".format(a.__call__))
print("test method: {0}".format(a.test))
patch_call(a, lambda : "example")
a.test = lambda : "test"
print("call method: {0}".format(a.__call__))
print("test method: {0}".format(a.test))

print("{0}".format(a()))
print("Explicit a.__call__: {0}".format(a.__call__()))
print("{0}".format(a.test()))

print("Check instance of a: {0}".format(isinstance(a, A)))
</code></pre>
<p>Running it produces following output:</p>
<pre><code>call method: &lt;bound method A.__call__ of &lt;__main__.A object at 0x7f404217a5f8&gt;&gt;
test method: &lt;bound method A.test of &lt;__main__.A object at 0x7f404217a5f8&gt;&gt;
call method: &lt;bound method patch_call.&lt;locals&gt;._.__call__ of &lt;__main__.patch_call.&lt;locals&gt;._ object at 0x7f404217a5f8&gt;&gt;
test method: &lt;function &lt;lambda&gt; at 0x7f404216d048&gt;
example
Explicit a.__call__: example
test
Check instance of a: True 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary. That behaviour is the reason why the following code raises an exception:</p>
<pre><code>&gt;&gt;&gt; class C:
...     pass
...
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.__len__ = lambda: 5
&gt;&gt;&gt; len(c)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: object of type 'C' has no len()
</code></pre>
</blockquote>
<p>Source: <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow">https://docs.python.org/3/reference/datamodel.html#special-lookup</a></p>
</div>
<span class="comment-copy">Could you make the 2-character difference between the outputs  a little more obvious? I stared for three minutes trying to see the difference, but most peoples' brains does autocorrect on small errors.</span>
<span class="comment-copy">@cat: sure, done</span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">Special method lookup</a></span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/34443595/5781248">answer</a> tells that "a() does not call a.__call__. It calls type(a).__call__(a)"</span>
<span class="comment-copy">so, to override a <code>__call__</code> I need to change the <i>type</i> of the instance? Is there a way to make <code>isinstance(a, A) == True</code> even after <code>__call__</code> is overridden?</span>
<span class="comment-copy">yes, you can subclass <code>A</code>, like <code>class B(A): def __call__(self): return example</code>. Then, you can just create instance of <code>B</code> instead of <code>A</code>, or, if you're brave enough, <code>a.__class__ = B</code>.</span>
<span class="comment-copy">Hmm, the <code>a.__class__ = B</code> may actually work (I need to override <b>call</b> only on <i>some</i> not all instances of the base class), let me test.</span>
<span class="comment-copy">Would it make a difference if A._<i>call_</i> actually turned around and did <i>return self.mycall()</i>?  I sometimes do that when I only later decide to make classes callable directly. Then your monkey patch becomes a standard one.</span>
<span class="comment-copy">@JLPeyret If I'm doing a <code>mycall()</code> I could as well just call <code>mycall()</code> where I use it. I think it would also be harder to read, provided you know about the behaviour of Python with magic methods</span>
