<div class="post-text" itemprop="text">
<p>I enabled the compatibility check in my Python IDE and now I realize that the inherited Python 2.7 code has a lot of calls to <code>unicode()</code> which are not allowed in Python 3.x.</p>
<p>I looked at the <a href="https://docs.python.org/2/library/functions.html#unicode" rel="noreferrer">docs</a> of Python2 and found no hint how to upgrade: </p>
<p>I don't want to switch to Python3 now, but maybe in the future.</p>
<p>The code contains about 500 calls to <code>unicode()</code></p>
<p>How to proceed?</p>
<p><strong>Update</strong></p>
<p>The comment of user vaultah to read the  <a href="https://docs.python.org/3/howto/pyporting.html" rel="noreferrer">pyporting</a> guide has received several upvotes.</p>
<p>My current solution is this (thanks to Peter Brittain):</p>
<pre><code>from builtins import str
</code></pre>
<p>... I could not find this hint in the pyporting docs.....</p>
</div>
<div class="post-text" itemprop="text">
<p>As has already been pointed out in the comments, there is already <a href="https://docs.python.org/3/howto/pyporting.html">advice on porting from 2 to 3</a>.</p>
<p>Having recently had to port some of my own code from 2 to 3 and maintain compatibility for each for now, I wholeheartedly recommend using <a href="http://python-future.org/overview.html">python-future</a>, which provides a great tool to help update your code (<code>futurize</code>) as well as clear guidance for <a href="http://python-future.org/compatible_idioms.html">how to write cross-compatible code</a>.</p>
<p>In your specific case, I would simply convert all calls to unicode to use str and then <a href="http://python-future.org/compatible_idioms.html#unicode">import str from builtins</a>.  Any IDE worth its salt these days will do that global search and replace in one operation.</p>
<p>Of course, that's the sort of thing futurize should catch too, if you just want to use automatic conversion (and to look for other potential issues in your code).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can test whether there is such a function as <code>unicode()</code> in the version of Python that you're running. If not, you can create a <code>unicode()</code> alias for the <code>str()</code> function, which does in Python 3 what <code>unicode()</code> did in Python 2, as all strings are unicode in Python 3.</p>
<pre><code># Python 3 compatibility hack
try:
    unicode('')
except NameError:
    unicode = str
</code></pre>
<p>Note that a more complete port is probably a better idea; see <a href="https://docs.python.org/3/howto/pyporting.html" rel="nofollow">the porting guide</a> for details.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, as a strategy, I would take a small part of your program and try to port it.  The number of <code>unicode</code> calls you are describing suggest to me that your application cares about string representations more than most and each use-case is often different.</p>
<p>The important consideration is that <em>all strings are unicode in Python 3</em>.  If you are using the <code>str</code> type to store "bytes" (for example, if they are read from a file), then you should be aware that those will not be bytes in Python3 but will be unicode characters to begin with.</p>
<p>Let's look at a few cases.</p>
<p>First, if you do not have any non-ASCII characters at all and really are not using the Unicode character set, it is easy.  Chances are you can simply change the <code>unicode()</code> function to <code>str()</code>.  That will assure that any object passed as an argument is properly converted.   However, it is wishful thinking to assume it's that easy.</p>
<p>Most likely, you'll need to look at the argument to <code>unicode()</code> to see what it is, and determine how to treat it.</p>
<p>For example, if you are reading UTF-8 characters from a file in Python 2 and converting them to Unicode your code would look like this:</p>
<pre><code>data = open('somefile', 'r').read()
udata = unicode(data)
</code></pre>
<p>However, in Python3, <code>read()</code> returns Unicode data to begin with, and the unicode decoding must be specified when opening the file:</p>
<pre><code>udata = open('somefile', 'r', encoding='UTF-8').read()
</code></pre>
<p>As you can see, transforming <code>unicode()</code> simply when porting may depend heavily on how and why the application is doing Unicode conversions, where the data has come from, and where it is going to.</p>
<p>Python3 brings greater clarity to string representations, which is welcome, but can make porting daunting.  For example, Python3 has a proper <code>bytes</code> type, and you convert byte-data to unicode like this:</p>
<pre><code>udata = bytedata.decode('UTF-8')
</code></pre>
<p>or convert Unicode data to character form using the opposite transform.</p>
<pre><code>bytedata = udata.encode('UTF-8')
</code></pre>
<p>I hope this at least helps determine a strategy.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short answer: Replace all <code>unicode</code> calls with <code>str</code> calls.</p>
<p>Long answer: In Python 3, Unicode was replaced with strings because of its abundance. The following solution should work if you are only using Python 3:</p>
<pre><code>unicode = str
# the rest of your goes goes here
</code></pre>
<p>If you are using it with both Python 2 or Python 3, use this instead:</p>
<pre><code>import sys
if sys.version_info.major == 3:
    unicode = str
# the rest of your code goes here
</code></pre>
<p>The other way: run this in the command line</p>
<pre><code>$ 2to3 package -w
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/howto/pyporting.html" rel="nofollow noreferrer">docs.python.org/3/howto/pyporting.html</a></span>
<span class="comment-copy">@vaultah this is not a general question. It is only about <code>unicode()</code> calls. I the code base which I currently work on, there are about 700 calls to this method. What should I do?</span>
<span class="comment-copy">There is no good answer to this question. If you're lucky, you can just remove the calls to <code>unicode</code> and you're good to go. All strings are unicode in Python 3. If this does not work, then expect <i>lots</i> of work. The transition from str to unicode literals and bytes is by far the most incompatible change when switching from Python 2 to 3.</span>
<span class="comment-copy">Couldn't you just define your own <code>unicode()</code> function that does nothing but <code>return str(arg)</code> in Python 3?</span>
<span class="comment-copy">you can assign <code>str</code> to <code>unicode</code> - <code>unicode = str</code> (without parenthesis). It should work.</span>
<span class="comment-copy">Yes, <code>futurize</code> will help transform the codebase; <code>unicode()</code> calls will be transformed to <code>str()</code> calls with a <code>from builtins import str</code> import at the top. Do take into account that generally does add an install-type requirement for the <code>future</code> library on Python 2 (to provide the backported <code>builtins</code> module).</span>
<span class="comment-copy">this will break sqlalchemy, among other libraries.</span>
<span class="comment-copy">The "advice on porting from 2 to 3" mentions unicode a lot, but doesn't really mention the unicode function itself.</span>
<span class="comment-copy">@cowlinator That's why I also referenced the python future docs.  See <a href="http://python-future.org/compatible_idioms.html#unicode" rel="nofollow noreferrer">python-future.org/compatible_idioms.html#unicode</a></span>
<span class="comment-copy">Yes, this handmade solution should work. But I guess I will use the future library as explained in the answer by Peter Brittain.</span>
<span class="comment-copy">very simple and useful, perfect solution for the asked question. also, no additional dependencies.</span>
<span class="comment-copy">Great answer, which explains the importance of replacing <code>unicode()</code> properly</span>
