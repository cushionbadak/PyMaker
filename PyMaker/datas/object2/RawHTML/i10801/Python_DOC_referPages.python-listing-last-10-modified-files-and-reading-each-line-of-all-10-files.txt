<div class="post-text" itemprop="text">
<p>I need some help listing files in a directory and reading through each file using Python.  I know how to do this using shell commands but is there a Pythonic way to do it?</p>
<p>I would like to:</p>
<p>1.) List all files in a directory.</p>
<p>2.) Grab the last 10 modified/latest files (preferably using a wildcard)</p>
<p>3.) Read through each line of all 10 files</p>
<p>Using shell commands I can:</p>
<pre><code>Linux_System# ls -ltr | tail -n 10 
-rw-rw-rw- 1 root root  999934 Jul 26 01:06 data_log.569
-rw-rw-rw- 1 root root  999960 Jul 26 02:05 data_log.570
-rw-rw-rw- 1 root root  999968 Jul 26 03:13 data_log.571
-rw-rw-rw- 1 root root  999741 Jul 26 04:20 data_log.572
-rw-rw-rw- 1 root root  999928 Jul 26 05:31 data_log.573
-rw-rw-rw- 1 root root  999942 Jul 26 06:45 data_log.574
-rw-rw-rw- 1 root root  999916 Jul 26 07:46 data_log.575
-rw-rw-rw- 1 root root  999862 Jul 26 08:59 data_log.576
-rw-rw-rw- 1 root root  999685 Jul 26 10:15 data_log.577
-rw-rw-rw- 1 root root  999633 Jul 26 11:26 data_log.578

Linux_System# cat data_log.{569..578}
</code></pre>
<p>Using glob I am able to list the files and open a specific file but not sure how I can list only the last 10 modified files and feed the wildcard file list to the open function.</p>
<pre><code>import os, fnmatch, glob

files = glob.glob("data_event_log.*")
files.sort(key=os.path.getmtime)
print("\n".join(files))

data_event_log.569
data_event_log.570
data_event_log.571
data_event_log.572
data_event_log.573
data_event_log.574
data_event_log.575
data_event_log.576
data_event_log.577
data_event_log.578

with open(data_event_log.560, 'r') as f:
    output_list = []
    for line in f.readlines():
        if line.startswith('Time'):
            lineRegex = re.compile(r'\d{4}-\d{2}-\d{2}')
            a = (lineRegex.findall(line))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>it looks alike you almost did everything already</p>
<pre><code>import os.path, glob

files = glob.glob("data_event_log.*")
files.sort(key=os.path.getmtime)
latest=files[-10:] # last 10 entries
print("\n".join(latest))
lineRegex = re.compile(r'\d{4}-\d{2}-\d{2}')
for fn in latest:
    with open(fn) as f:
        for line in f:
            if line.startswith('Time'):          
                a = lineRegex.findall(line)
</code></pre>
<p>Edit:</p>
<p>Especially if you have many files a better and simpler solution would be </p>
<pre><code>import os.path, glob, heapq

files = glob.iglob("data_event_log.*")
latest=heapq.nlargest(10, files, key=os.path.getmtime) # last 10 entries
print("\n".join(latest))
lineRegex = re.compile(r'\d{4}-\d{2}-\d{2}')
for fn in latest:
    with open(fn) as f:
        for line in f:
            if line.startswith('Time'):          
                a = lineRegex.findall(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>pythonic answer: </p>
<p>use <code>sorted()</code> with a lambda function, then use list slicing to get the 10 earliest or 10 latest or what have you.</p>
<pre><code>from glob import glob
from os import stat

files = glob("*")
sorted_list = sorted(files, key=lambda x: stat(x).st_mtime)

truncated_list = sorted_list[-10:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you are looking for is a fixed-size sorted buffer. <code>collections.deque</code> does this, albeit without the sorting. So, here's a buffer that'll do what you need, and <code>main</code> shows you how to use it</p>
<pre><code>import bisect
import glob
import operator
import os


class Buffer:
    def __init__(self, maxlen, minmax=1, key=None):
        if key is None: key = lambda x: x
        self.key = key
        self.maxlen = maxlen
        self.buffer = []
        self.keys = []
        self.minmax = minmax  # 1 to track max values, -1 to track min values

        # iterator variables
        self.curr = 0

    def __iter__(self): return self

    def __next__(self):
        if self.curr &gt;= len(self.buffer): raise StopIteration
        self.curr += 1
        return self.buffer[self.curr-1]

    def insert(self, x):
        key = self.key(x)
        idx = bisect.bisect_left(self.keys, key)
        self.keys.insert(idx, key)
        self.buffer.insert(idx, x)
        if len(self.buffer) &gt; self.maxlen:
            if self.minmax&gt;0:
                self.buffer = self.buffer[-1 * self.maxlen :]
                self.keys = self.keys[-1 * self.maxlen :]
            elif self.minmax&lt;0:
                self.buffer = self.buffer[: self.maxlen]
                self.keys = self.keys[: self.maxlen]


def main():
    dirpath = "/path/to/directory"
    modtime = lambda fpath: os.stat(fpath).st_mtime
    buffer = Buffer(10, 1, modtime)
    for fpath in glob.glob(os.path.join(dirpath, "*data_event_log.*")):
        buffer.insert(fpath)

    for fpath in buffer:
        # open the file path and print whatever
</code></pre>
</div>
<span class="comment-copy">Please share the code you've written so far and specifically where you got stuck.</span>
<span class="comment-copy">what do you mean by wildcard?</span>
<span class="comment-copy"><code>for file in files[-10:]:</code>?</span>
<span class="comment-copy">You can use <a href="https://docs.python.org/3/library/os.html#os.stat" rel="nofollow noreferrer"><code>os.stat</code></a> to get file modification time data. So you just need to sort  your fillenames list with a key function that grabs the timestamp info you want.</span>
<span class="comment-copy">@PM2Ring That's already done.</span>
<span class="comment-copy">This was exactly what I was looking for. Worked like a charm. Thank you!</span>
<span class="comment-copy">Looks like severe overkill, compared to basically just adding <code>for file in files[-10:]:</code> to their code. What's the advantage of this?</span>
<span class="comment-copy">@StefanPochmann: The advantage is that this is constant space, whereas <code>files[-10:]</code> stores all the files, most of which will never be used. Thus, this way is far more scalable</span>
<span class="comment-copy">Then I'd say using <code>heapq.nlargest</code> would still be better and a lot simpler. Btw, I think you got a bug, for example <code>b = Buffer(5); b.insert(2); b.insert(3); print(list(b))</code> prints <code>[3]</code>. Where did the <code>2</code> go?</span>
<span class="comment-copy">@StefanPochmann: oh right! I forgot about <code>heapq</code>. Also, I fixed that bug. Thanks for pointing it out :)</span>
<span class="comment-copy">Still buggy, for example <code>b = Buffer(5); b.insert(1); b.insert(2); b.insert(3); print(list(b))</code> prints the unsorted <code>[2, 3, 1]</code>.</span>
