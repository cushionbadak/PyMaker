<div class="post-text" itemprop="text">
<p>Say I have some very long function <code>module.my_function</code> that's something like this:</p>
<pre><code>def my_function(param1,param2,param3='foo',param4='bar',param5=None,...)
</code></pre>
<p>With a large number of args and keyword args. I want this function to be usable both as a part of module <code>module</code> and as a class method for <code>myClass</code>. The code for the function will remain exactly the same, but in <code>myClass</code> a few keyword args may take different default values. </p>
<p>What's the best way of doing this? Previously I was doing something like:</p>
<pre><code>class myCLass(object):
    def __init__(self,...
    def my_function(self, param1,param2,param3='hello',param4='qaz',param5=['baz'],...):
        module.my_function(param1,param2,param3=param3,param4=param4,param5=param5,...)
</code></pre>
<p>It seems a little silly to write all these arguments that many times, especially with a very large number of arguments. I also considered doing something like <code>module.my_function(**locals())</code> inside the class method, but I'm not sure how to handle the <code>self</code> argument and I don't know if this would lead to other issues. </p>
<p>I could just copy paste the entire code for the function, but that doesn't really seem very efficient, when all that's changing is a few default values and the code for <code>my_function</code> is <em>very</em> long. Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can convert the function to bound method by calling its <code>__get__</code> method (since all function as <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow">descriptors</a> as well, thus have this method)</p>
<pre><code>def t(*args, **kwargs):
    print(args)
    print(kwargs)

class Test():
    pass
Test.t = t.__get__(Test(), Test) # binding to the instance of Test
</code></pre>
<p>For example</p>
<pre><code>Test().t(1,2, x=1, y=2)
(&lt;__main__.Test object at 0x7fd7f6d845f8&gt;, 1, 2)
{'y': 2, 'x': 1}
</code></pre>
<p>Note that the instance is also passed as an positional argument. That is if you want you function to be instance method, the function should have been written in such a way that first argument behaves as instance of the class. Else, you can bind the function to None instance and the class, which will be like <code>staticmethod</code>.</p>
<pre><code>Test.tt = t.__get__(None, Test)
Test.tt(1,2,x=1, y=2)
(1, 2)
{'y': 2, 'x': 1}
</code></pre>
<p>Furthermore, to make it a <code>classmethod</code> (first argument is class):</p>
<pre><code>Test.ttt = t.__get__(Test, None) # bind to class
Test.ttt(1,2, x=1, y=2)
(&lt;class '__main__.Test'&gt;, 1, 2)
{'y': 2, 'x': 1}
</code></pre>
</div>
<span class="comment-copy">Is there a reason that all of the keyword args have to be explicit and you can't just use kwargs?</span>
<span class="comment-copy">The reason is probably that I'm not too experienced a coder... how would I use kwargs in this situation and set some of the default values to something different? Say 3-5  in the above example are the ones I'm changing.. would I just specify params 1-5 and use kwargs for the rest?</span>
