<div class="post-text" itemprop="text">
<p>I stumbled upon this behavior for double underscore name that I don't understand:</p>
<pre><code>class A:
    pass

class B:
    pass

class C(A,B):
    __id__ = 'c'

c = C()
print(C.__mro__)  # print the method resolution order of class C
#print(c.__mro__) # AttributeError: 'C' object has no attribute '__mro__'
print(C.__id__)   # print 'c'
print(c.__id__)   # print 'c'
</code></pre>
<p>I know about the name mangling for <code>__name</code>, which doesn't apply for <code>__name__</code> (more for overloading operator methods). <code>__id__</code> behaves just like a regular class variable which can be accessed via Class name as well as instance.</p>
<p>However, <code>__mro__</code> can only be accessed via Class name and in fact I can even explicitly introduce <code>__mro__</code> in C:</p>
<pre><code>class C(A,B):
    __mro__ = 'bla'

print(C.__mro__) # print the method resolution order of class C
print(c.__mro__) # print 'bla'
</code></pre>
<p>I'd like to understand if this behavior is some python internal magic or can it be achieved in regular python code.</p>
<p>[<strong>python version 3.4.3</strong>]</p>
</div>
<div class="post-text" itemprop="text">
<p>This has to do with the lookup order.</p>
<p>Letting <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow">descriptors</a> aside, python first checks the objects <code>__dict__</code> to find an attribute. If it cannot find it, it will look at the class of the object and the bases of the class to find the attribute. If it cannot be found there either, AttributeError is raised.</p>
<p>This is probably not understandable, so let us show this with a short example:</p>
<pre class="lang-python prettyprint-override"><code>#!/usr/bin/python3

class Foo(type):
    X = 10

class Bar(metaclass=Foo):
    Y = 20

baz = Bar()

print("X on Foo", hasattr(Foo, "X")) 
print("X on Bar", hasattr(Bar, "X")) 
print("X on baz", hasattr(baz, "X")) 

print("Y on Foo", hasattr(Foo, "Y")) 
print("Y on Bar", hasattr(Bar, "Y")) 
print("Y on baz", hasattr(baz, "Y")) 
</code></pre>
<p>The output is:</p>
<pre class="lang-python prettyprint-override"><code>X on Foo True
X on Bar True
X on baz False
Y on Foo False
Y on Bar True
Y on baz True
</code></pre>
<p>As you can see, <code>X</code> has been declared on the <em>metaclass</em> <code>Foo</code>. It is accessible through the instance of the <em>metaclass</em>, the class <code>Bar</code>, but not on the instance <code>baz</code> of <code>Bar</code>, because it is only in the <code>__dict__</code> in <code>Foo</code>, not in the <code>__dict__</code> of <code>Bar</code> or <code>baz</code>. Python only checks <em>one</em> step up in the "meta" hierarchy.</p>
<p>For more on metaclass magic, see the excellent answers on the question <a href="https://stackoverflow.com/q/100003/1248008">What is a metaclass in python?</a>.</p>
<p>This, however, is not sufficient to describe the behaviour, because <code>__mro__</code> is different for each <em>instance</em> of <code>Foo</code> (that is, for each class).</p>
<p>This can be achieved using descriptors. <em>Before</em> the attribute name is looked up at the objects <code>__dict__</code>, python checks the <code>__dict__</code> of the class and its bases to see if there is a descriptor object assigned to the name. A descriptor is any object which has a <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow"><code>__get__</code> method</a>. If that is the case, the descriptor objects  <code>__get__</code> method is called and the result is returned from the attribute lookup. With a descriptor assigned to an attribute of the metaclass, the behaviour seen can be achieved: The descriptor can return a different value based on the <em>instance</em> argument, but nevertheless the attribute can only be accessed through the class and the metaclass, not instances of the class.</p>
<p>A prime example of descriptors is <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow"><code>property</code></a>. Here is a simple example with a descriptor which has the same behaviour as <code>__mro__</code>:</p>
<pre class="lang-python prettyprint-override"><code>class Descriptor:
   def __get__(self, instance, owner):
      return "some value based on {}".format(instance)


class OtherFoo(type):
   Z = Descriptor()

class OtherBar(metaclass=OtherFoo):
   pass

other_baz = OtherBar()

print("Z on OtherFoo", hasattr(OtherFoo, "Z"))
print("Z on OtherBar", hasattr(OtherBar, "Z"))
print("Z on other_baz", hasattr(other_baz, "Z"))

print("value of Z on OtherFoo", OtherFoo.Z)
print("value of Z on OtherBar", OtherBar.Z)
</code></pre>
<p>The output is:</p>
<pre class="lang-python prettyprint-override"><code>Z on OtherFoo True
Z on OtherBar True
Z on other_baz False
value of Z on OtherFoo some value based on None
value of Z on OtherBar some value based on &lt;class '__main__.OtherBar'&gt;
</code></pre>
<p>As you can see, <code>OtherBar</code> and <code>OtherFoo</code> both have the <code>Z</code> attribute accessible, but <code>other_baz</code> does not. Still, <code>Z</code> can have a different value for each <code>OtherFoo</code> instance, that is, each class using the <code>OtherFoo</code> metaclass.</p>
<p>Metaclasses are confusing at first, and even more so when descriptors are in play. I suggest reading up on metaclasses the <a href="https://stackoverflow.com/q/100003/1248008">linked question</a>, as well as descriptors in python in general.</p>
</div>
<span class="comment-copy">The last output box looks like you copy-pasted the wrong block in. :)</span>
<span class="comment-copy">@acdr Fixed, thanks!</span>
<span class="comment-copy">@Jonas, didn't know about metaclass so took a while to understand your answer. Just to summarize, <code>__mro__</code> is an attribute defined on a metaclass that can only be accessed via the class that is an instance of the said metaclass. On top of it, it is defined as a descriptor so takes precedence over the <code>__mro__</code> explicitly defined on the class itself. Correct?</span>
<span class="comment-copy">@KevinS. Pretty much correct! The reasoning for the descriptor part is however that <code>__mro__</code> has a different value for each class of the metaclass, even though it is not accessible through instances of the classes. Normally, to get a different value for each class, you would have to set the attribute in the classes <code>__dict__</code>, which would make it accessible in instances of the class. Using a descriptor on the metaclass, you get different values for each class without it being accessible on the instances of the classes.</span>
<span class="comment-copy">A (hopefully) helpful example: <code>cls.__mro__ == type(cls).__dict__['__mro__'].__get__(cls)</code>.</span>
