<div class="post-text" itemprop="text">
<p>I have a Python project with the following structure:</p>
<pre><code>testapp/
├── __init__.py
├── api
│   ├── __init__.py
│   └── utils.py
└── utils.py
</code></pre>
<p>All of the modules are empty except <code>testapp/api/__init__.py</code> which has the following code:</p>
<pre><code>from testapp import utils

print "a", utils

from testapp.api.utils import x

print "b", utils
</code></pre>
<p>and <code>testapp/api/utils.py</code> which defines <code>x</code>:</p>
<pre><code>x = 1
</code></pre>
<p>Now from the root I import <code>testapp.api</code>:</p>
<pre><code>$ export PYTHONPATH=$PYTHONPATH:.
$ python -c "import testapp.api"
a &lt;module 'testapp.utils' from 'testapp/utils.pyc'&gt;
b &lt;module 'testapp.api.utils' from 'testapp/api/utils.pyc'&gt;
</code></pre>
<p>The result of the import surprises me, because it shows that the second <code>import</code> statement has overwritten <code>utils</code>. Yet the docs state that the <a href="https://docs.python.org/2/reference/simple_stmts.html#the-import-statement" rel="nofollow noreferrer">from statement will not bind a module name</a>:</p>
<blockquote>
<p>The from form does not bind the module name: it goes through the list
  of identifiers, looks each one of them up in the module found in step
  (1), and binds the name in the local namespace to the object thus
  found.</p>
</blockquote>
<p>And indeed, when in a terminal I use a <code>from ... import ...</code> statement, no module names are introduced:</p>
<pre><code>&gt;&gt;&gt; from os.path import abspath
&gt;&gt;&gt; path
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'path' is not defined
</code></pre>
<p>I suspect this has to do with Python, at the time of the second import statement, trying to import <code>testapp.api.utils</code> which refers to <code>testapp.utils</code> and failing but I'm not certain.</p>
<p>What is happening here?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/reference/import.html#submodules" rel="noreferrer">import system documentation</a>:</p>
<blockquote>
<p>When a submodule is loaded using any mechanism (e.g. <code>importlib</code> APIs,
  the <code>import</code> or <strong><code>import-from</code></strong> statements, or built-in <code>__import__()</code>)
  a binding is placed in the parent module’s namespace to the submodule
  object. For example, if package <code>spam</code> has a submodule <code>foo</code>, after
  importing <code>spam.foo</code>, <code>spam</code> will have an attribute <code>foo</code> which is
  bound to the submodule. Let’s say you have the following directory
  structure:</p>
<pre><code>spam/
    __init__.py
    foo.py
    bar.py
</code></pre>
<p>and <code>spam/__init__.py</code> has the following lines in it:</p>
<pre><code>from .foo import Foo
from .bar import Bar
</code></pre>
<p>then executing the following puts a name binding to <code>foo</code> and <code>bar</code> in
  the <code>spam</code> module:</p>
<pre><code>&gt;&gt;&gt; import spam
&gt;&gt;&gt; spam.foo
&lt;module 'spam.foo' from '/tmp/imports/spam/foo.py'&gt;
&gt;&gt;&gt; spam.bar
&lt;module 'spam.bar' from '/tmp/imports/spam/bar.py'&gt;
</code></pre>
<p>Given Python’s familiar name binding rules this might seem surprising,
  but it’s actually a fundamental feature of the import system. The
  invariant holding is that if you have <code>sys.modules['spam']</code> and
  <code>sys.modules['spam.foo']</code> (as you would after the above import), the
  latter must appear as the <code>foo</code> attribute of the former.</p>
</blockquote>
<p>If you do <code>from testapp.api.utils import x</code>, the import statement will not load <code>utils</code> into the local namespace. However, the import machinery <em>will</em> load <code>utils</code> into the <code>testapp.api</code> namespace, to make further imports work right. It just happens that in your case, <code>testapp.api</code> is also the local namespace, so you're getting a surprise.</p>
</div>
<span class="comment-copy">I would not have expected this behavior and I'm eager to hear the answer as well.</span>
<span class="comment-copy">can you add some code from the various utils files?</span>
<span class="comment-copy">@NikosM. as I mentioned, all of the other files are empty.</span>
<span class="comment-copy">yes i see, you will have to use <code>from module.name import property as alias</code> structure to avoid namespace colissions, as the local namespace is the same for your init file</span>
<span class="comment-copy">did not downvote, but can you explain more, it is not clear to me</span>
<span class="comment-copy">If you use the <code>from</code> form, no names are imported into the local namespace. You're saying they're bound anyway if they refer to something though? If that were true, then <code>path = 1; from os.path import abspath; path</code> should not evaluate to <code>1</code>.</span>
<span class="comment-copy">@CeasarBautista: The module name is not bound in the <i>local</i> namespace, but it <i>is</i> bound in the package's namespace. It's just that in this case, those are the same namespace.</span>
<span class="comment-copy">That makes sense. Do you remember how you can upon this? Is it in the docs somewhere?</span>
<span class="comment-copy">@CeasarBautista: Doc reference added. I couldn't find the Python 2 version, so I've linked the Python 3 version, but the behavior is the same.</span>
