<div class="post-text" itemprop="text">
<p>I am currently trying to work through an OLD python CTF challenge, the script of the server is provided, and the idea is to send the correct data to this server,</p>
<pre><code>#!/usr/bin/env python3
# from dis import dis
import socketserver
import types


class RequestHandler(socketserver.BaseRequestHandler):

    def handle(self):
        self.request.sendall(b'PyDRM Proof of Concept version 0.7\n')
        self.request.sendall(
            b'Submit the secret password to retrieve the flag:\n')
        user_input_bytes = self.request.recv(4096).strip()
        user_input = user_input_bytes.decode('utf-8', 'ignore')
        if validate_password(user_input):
            self.request.sendall(read_flag())
        else:
            self.request.sendall(b'Invalid password\n')


class RequestServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    pass


def read_flag():
    with open('flag.txt', 'rb') as fh:
        return fh.read()


def generate_validation_function():
    code_obj = types.CodeType(
        1,
        0,
        5,
        32,
        67,
        b'd\x01\x00d\x02\x00d\x03\x00d\x04\x00d\x05\x00d\x06\x00d\x05\x00d\x07'
        b'\x00d\x08\x00d\x05\x00d\t\x00d\x08\x00d\n\x00d\x01\x00d\x07\x00d\x07'
        b'\x00d\x01\x00d\x0b\x00d\x08\x00d\x07\x00d\x0c\x00d\r\x00d\x0e\x00d'
        b'\x08\x00d\x05\x00d\x0f\x00d\x03\x00d\x04\x00d\x05\x00d\x06\x00d\x05'
        b'\x00d\x07\x00g \x00}\x01\x00g\x00\x00}\x02\x00x+\x00|\x01\x00D]#\x00'
        b'}\x03\x00|\x02\x00j\x00\x00t\x01\x00t\x02\x00|\x03\x00\x83\x01\x00d'
        b'\x10\x00\x18\x83\x01\x00\x83\x01\x00\x01qs\x00Wd\x11\x00j\x03\x00|'
        b'\x02\x00\x83\x01\x00}\x04\x00|\x00\x00|\x04\x00k\x02\x00r\xb9\x00d'
        b'\x12\x00Sd\x13\x00S',
        (None, '\x87', '\x9a', '\x92', '\x8e', '\x8b', '\x85', '\x96', '\x81',
         '\x95', '\x84', '\x94', '\x8a', '\x83', '\x90', '\x8f', 34, '', True,
         False),
        ('append', 'chr', 'ord', 'join'),
        ('a', 'b', 'c', 'd', 'e'),
        'drm.py',
        'validate_password',
        5,
        b'\x00\x01$\x01$\x01\x1e\x01\x06\x01\r\x01!\x01\x0f\x01\x0c\x01\x04'
        b'\x01',
        (),
        ()
    )
    func_obj = types.FunctionType(code_obj, globals())
    return func_obj


def main():
    setattr(__import__(__name__), 'validate_password',
            generate_validation_function())
    server = RequestServer(('0.0.0.0', 8765), RequestHandler)
    try:
        server.serve_forever()
    except (SystemExit, KeyboardInterrupt):
        server.shutdown()
        server.server_close()

if __name__ == '__main__':
    main()
</code></pre>
<p><strong>EDIT</strong></p>
<p>I understand, what is going on to the point that a validate_password function is created by using a CodeType and FunctionType objects. I also understand that if validate_password(user_input) evaluates as True, the flag will be sent. meaning that the return type must be boolean. The documentation for CodeType along with the server script also reveals that validate_password has only one argument.</p>
<p><strong>My Actual Question</strong></p>
<p>The source contains compiled python bytecode. <code>b'd\x01\x00d\x02\x00d\x03\x00d\x04\x00d\x05\x00d\x06\x00d\x05\x00d\x07'</code>for example. I have tried numerous ways to decode/encode these strings to get some meaningful data, the only data i have managed to extract is hexadecimal. </p>
<p>How do i convert this data into actual code, therefore being able to reconstruct the <code>validate_password</code> function.</p>
<p><strong>What I have Tried</strong></p>
<p><a href="https://stackoverflow.com/questions/9711465/python-convert-string-to-packed-hex-01020304-x01-x02-x03-x04">SO - Python: convert string to packed hex ( '01020304' -&gt; '\x01\x02\x03\x04' )</a> - I have attempted to basically do what this answer suggests but in reverse, i have either not understood it correctly, or this doesn't work</p>
<p>binascii.b2a_hex() - This is how I managed to convert the strings into hex, like i stated earlier however, i cannot yield utf-8 data from this hex.</p>
<p>struct.unpack() - Had some success with this method, yet am at a loss of what the data would mean in the context of the validate_password function, I can only get integers with this method. (Unless i have misunderstood)</p>
</div>
<div class="post-text" itemprop="text">
<p>Riffing off of das-g's answer, this code works. Sorta. </p>
<pre><code>import uncompyle6
import types
code_obj = types.CodeType(
        1, 0, 5, 32, 67, b'd\x01\x00d\x02\x00d\x03\x00d\x04\x00d\x05\x00d\x06\x00d\x05\x00d\x07'
        b'\x00d\x08\x00d\x05\x00d\t\x00d\x08\x00d\n\x00d\x01\x00d\x07\x00d\x07'
        b'\x00d\x01\x00d\x0b\x00d\x08\x00d\x07\x00d\x0c\x00d\r\x00d\x0e\x00d'
        b'\x08\x00d\x05\x00d\x0f\x00d\x03\x00d\x04\x00d\x05\x00d\x06\x00d\x05'
        b'\x00d\x07\x00g \x00}\x01\x00g\x00\x00}\x02\x00x+\x00|\x01\x00D]#\x00'
        b'}\x03\x00|\x02\x00j\x00\x00t\x01\x00t\x02\x00|\x03\x00\x83\x01\x00d'
        b'\x10\x00\x18\x83\x01\x00\x83\x01\x00\x01qs\x00Wd\x11\x00j\x03\x00|'
        b'\x02\x00\x83\x01\x00}\x04\x00|\x00\x00|\x04\x00k\x02\x00r\xb9\x00d'
        b'\x12\x00Sd\x13\x00S',
        (None, '\x87', '\x9a', '\x92', '\x8e', '\x8b', '\x85', '\x96', '\x81',
         '\x95', '\x84', '\x94', '\x8a', '\x83', '\x90', '\x8f', 34, '', True,
         False),
        ('append', 'chr', 'ord', 'join'),
        ('a', 'b', 'c', 'd', 'e'),
        'drm.py',
        'validate_password',
        5,
        b'\x00\x01$\x01$\x01\x1e\x01\x06\x01\r\x01!\x01\x0f\x01\x0c\x01\x04'
        b'\x01',
        freevars=(),
        cellvars=()
    )

import sys
uncompyle6.main.uncompyle(3.5, code_obj, sys.stdout)
</code></pre>
<p>What's missing here is that this code is really wrapped inside a function that takes an "a" parameter. </p>
<p>I won't spoil the fun giving the answer. Instead:</p>
<ol>
<li>Run the above program.</li>
<li>Wrap the output in something like:<br/>
<code>
def drm(a): 
   # Output from run above.
</code></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Start an interactive Python 3 session. If you use the plain python interpreter, type</p>
<pre><code>import types
help(types.CodeType)
</code></pre>
<p>If you're using IPython, you might instead write</p>
<pre><code>import types
types.CodeType?
</code></pre>
<p>You'll learn that <code>types.CodeType</code> is there to</p>
<blockquote>
<p>Create a code object.  Not for the faint of heart.</p>
</blockquote>
<p>Uh hu. What are code objects? Let's have a look at the <a href="https://docs.python.org/3/library/types.html#types.CodeType" rel="nofollow">Python documentation</a>.</p>
<blockquote>
<p>The type for code objects such as returned by <a href="https://docs.python.org/3/library/functions.html#compile" rel="nofollow"><code>compile()</code></a>.</p>
</blockquote>
<p>So the bytestring arguments might, at least partially be binary data (or binary instructions), rather than (text) string encoded somehow.</p>
<p>The <code>help</code> or <code>?</code> invocation also told us the signature of this type's initializer:</p>
<blockquote>
<pre><code>code(argcount, kwonlyargcount, nlocals, stacksize, flags, codestring,
      constants, names, varnames, filename, name, firstlineno,
      lnotab[, freevars[, cellvars]])
</code></pre>
</blockquote>
<p>With that, we can write the construction more self-descriptively:</p>
<pre><code>    code_obj = types.CodeType(
        argcount=1,
        kwonlyargcount=0,
        nlocals=5,
        stacksize=32,
        flags=67,
        codestring=b'd\x01\x00d\x02\x00d\x03\x00d\x04\x00d\x05\x00d\x06\x00d\x05\x00d\x07'
        b'\x00d\x08\x00d\x05\x00d\t\x00d\x08\x00d\n\x00d\x01\x00d\x07\x00d\x07'
        b'\x00d\x01\x00d\x0b\x00d\x08\x00d\x07\x00d\x0c\x00d\r\x00d\x0e\x00d'
        b'\x08\x00d\x05\x00d\x0f\x00d\x03\x00d\x04\x00d\x05\x00d\x06\x00d\x05'
        b'\x00d\x07\x00g \x00}\x01\x00g\x00\x00}\x02\x00x+\x00|\x01\x00D]#\x00'
        b'}\x03\x00|\x02\x00j\x00\x00t\x01\x00t\x02\x00|\x03\x00\x83\x01\x00d'
        b'\x10\x00\x18\x83\x01\x00\x83\x01\x00\x01qs\x00Wd\x11\x00j\x03\x00|'
        b'\x02\x00\x83\x01\x00}\x04\x00|\x00\x00|\x04\x00k\x02\x00r\xb9\x00d'
        b'\x12\x00Sd\x13\x00S',
        constants=(None, '\x87', '\x9a', '\x92', '\x8e', '\x8b', '\x85', '\x96', '\x81',
         '\x95', '\x84', '\x94', '\x8a', '\x83', '\x90', '\x8f', 34, '', True,
         False),
        names=('append', 'chr', 'ord', 'join'),
        varnames=('a', 'b', 'c', 'd', 'e'),
        filename='drm.py',
        name='validate_password',
        firstlineno=5,
        lnotab=b'\x00\x01$\x01$\x01\x1e\x01\x06\x01\r\x01!\x01\x0f\x01\x0c\x01\x04'
        b'\x01',
        freevars=(),
        cellvars=()
    )
</code></pre>
<p>(This is just for illustration. It isn't actually executable like this, because <code>types.CodeType()</code> expects all arguments to be passed positionally rather than as keyword arguments.)</p>
<p>Now what does all that mean?</p>
<p>You can disassemble the code object to get closer to that question:</p>
<pre><code>import dis
dis.dis(code_obj)
</code></pre>
<p>(output:)</p>
<pre><code>  6           0 LOAD_CONST               1 ('\x87') 
              3 LOAD_CONST               2 ('\x9a') 
              6 LOAD_CONST               3 ('\x92') 
              9 LOAD_CONST               4 ('\x8e') 
             12 LOAD_CONST               5 ('\x8b') 
             15 LOAD_CONST               6 ('\x85') 
             18 LOAD_CONST               5 ('\x8b') 
             21 LOAD_CONST               7 ('\x96') 
             24 LOAD_CONST               8 ('\x81') 
             27 LOAD_CONST               5 ('\x8b') 
             30 LOAD_CONST               9 ('\x95') 
             33 LOAD_CONST               8 ('\x81') 

  7          36 LOAD_CONST              10 ('\x84') 
             39 LOAD_CONST               1 ('\x87') 
             42 LOAD_CONST               7 ('\x96') 
             45 LOAD_CONST               7 ('\x96') 
             48 LOAD_CONST               1 ('\x87') 
             51 LOAD_CONST              11 ('\x94') 
             54 LOAD_CONST               8 ('\x81') 
             57 LOAD_CONST               7 ('\x96') 
             60 LOAD_CONST              12 ('\x8a') 
             63 LOAD_CONST              13 ('\x83') 
             66 LOAD_CONST              14 ('\x90') 
             69 LOAD_CONST               8 ('\x81') 

  8          72 LOAD_CONST               5 ('\x8b') 
             75 LOAD_CONST              15 ('\x8f') 
             78 LOAD_CONST               3 ('\x92') 
             81 LOAD_CONST               4 ('\x8e') 
             84 LOAD_CONST               5 ('\x8b') 
             87 LOAD_CONST               6 ('\x85') 
             90 LOAD_CONST               5 ('\x8b') 
             93 LOAD_CONST               7 ('\x96') 
             96 BUILD_LIST              32 
             99 STORE_FAST               1 (b) 

  9         102 BUILD_LIST               0 
            105 STORE_FAST               2 (c) 

 10         108 SETUP_LOOP              43 (to 154) 
            111 LOAD_FAST                1 (b) 
            114 GET_ITER             
        &gt;&gt;  115 FOR_ITER                35 (to 153) 
            118 STORE_FAST               3 (d) 

 11         121 LOAD_FAST                2 (c) 
            124 LOAD_ATTR                0 (append) 
            127 LOAD_GLOBAL              1 (chr) 
            130 LOAD_GLOBAL              2 (ord) 
            133 LOAD_FAST                3 (d) 
            136 CALL_FUNCTION            1 
            139 LOAD_CONST              16 (34) 
            142 BINARY_SUBTRACT      
            143 CALL_FUNCTION            1 
            146 CALL_FUNCTION            1 
            149 POP_TOP              
            150 JUMP_ABSOLUTE          115 
        &gt;&gt;  153 POP_BLOCK            

 12     &gt;&gt;  154 LOAD_CONST              17 ('') 
            157 LOAD_ATTR                3 (join) 
            160 LOAD_FAST                2 (c) 
            163 CALL_FUNCTION            1 
            166 STORE_FAST               4 (e) 

 13         169 LOAD_FAST                0 (a) 
            172 LOAD_FAST                4 (e) 
            175 COMPARE_OP               2 (==) 
            178 POP_JUMP_IF_FALSE      185 

 14         181 LOAD_CONST              18 (True) 
            184 RETURN_VALUE         

 15     &gt;&gt;  185 LOAD_CONST              19 (False) 
            188 RETURN_VALUE         
</code></pre>
<p>See the <code>dis</code> documentation for <a href="https://docs.python.org/3/library/dis.html#python-bytecode-instructions" rel="nofollow">the meaning of the bytecode operations</a> (<code>LOAD_CONST</code>, <code>BUILD_LIST</code>, etc.).</p>
<p>To get an even better grasp of what the function is doing, one would then try to decompile it back to Python code. I didn't manage to do that, though. (Tried with <a href="https://pypi.python.org/pypi/uncompyle6" rel="nofollow">uncompyle6</a>.)</p>
</div>
<span class="comment-copy">Thank you for helping me through that. No need to apologise, glad that a valuable tool is still being maintained, successfully updated through pip, so everything has been done to keep package up to date :) @das-g provided a rich answer, with plenty of evidence ect, however this method basically automates the steps i went through for the their method.</span>
<span class="comment-copy">To clarify, the above method worked. I wont spoil it for anyone else running through this CTF. But a closer look at  the PEP docs would give you the password also :)</span>
<span class="comment-copy">The first line of the  assembly is equivalent to: b = [1,2,3,4,5,6,5,7,8,9,8 (newline) 10, 1, ... ] ; c = [] and a for loop that is accumulating to c and then e = ''.join(c) and returning true or false if a == e. (A is passed in or set previously?)</span>
<span class="comment-copy">@rocky how did you find that out? Might be worth an answer of its own.</span>
<span class="comment-copy">a quick inspection of the code. Looking more c is what's getting built up via chr(ord(d)) where d's the loop iterator.  You could let uncompyle6 do the work If you provide a Python version number, e.g 3.5 or 2.7. See <a href="https://github.com/rocky/python-uncompyle6/blob/master/uncompyle6/main.py#L12" rel="nofollow noreferrer">github.com/rocky/python-uncompyle6/blob/master/uncompyle6/…</a></span>
<span class="comment-copy">I'm having some issues with the uncompyle function. Passing python version and code_obj. Error is thrown in <code>scannerX.py</code> (where x is major python version) <code>from xdis.bytecode import Bytecode, findlinestarts ImportError: cannot import name findlinestarts</code></span>
<span class="comment-copy">To clarify, the xdis package is seemingly installed correctly, with Bytecode.py containing the _findlinestarts function</span>
