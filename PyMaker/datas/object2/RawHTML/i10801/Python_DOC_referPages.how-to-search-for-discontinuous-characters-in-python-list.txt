<div class="post-text" itemprop="text">
<p>I am trying to search a list (DB) for possible matches of fragments of text. For instance, I have a DB with text "evilman". I want to use user inputs to search for any possible matches in the DB and give the answer with a confidence. If the user inputs "hello", then there are no possible matches. If the user inputs "evil", then the possible match is evilman with a confidence of 57% (4 out of 7 alphabets match) and so on.</p>
<p>However, I also want a way to match input text such as "evxxman". 5 out of 7 characters of evxxman match the text "evilman" in the DB. But a simple check in python will say no match since it only outputs text that matches consecutively. I hope it makes sense. Thanks</p>
<p>Following is my code:</p>
<pre><code>db = []
possible_signs = []
db.append("evilman")

text = raw_input()

for s in db:
 if text in s:
  if len(text) &gt;= len(s)/2:                              
   possible_signs.append(s)

    count += 1
    confidence = (float(len(text)) / float(len(s))) * 100
    print "Confidence:", '%.2f' %(confidence), "&lt;possible match:&gt;", possible_signs[0] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This first version seems to comply with your exemples. It make the strings "slide" against each other, and count the number of identical characters.
The ratio is made by dividing the character count by the reference string length. Add a max and voila.
Call it for each string in your DB.</p>
<pre><code>def commonChars(txt, ref):
    txtLen = len(txt)
    refLen = len(ref)
    r = 0
    for i in range(refLen + (txtLen - 1)):
        rStart = abs(min(0, txtLen - i - 1))
        tStart = txtLen -i - 1 if i &lt; txtLen else 0
        l = min(txtLen - tStart, refLen - rStart)
        c = 0
        for j in range(l):
            if txt[tStart + j] == ref[rStart + j]:
                c += 1
        r = max(r, c / refLen)
    return r

print(commonChars('evxxman', 'evilman')) # 0.7142857142857143
print(commonChars('evil', 'evilman')) # 0.5714285714285714
print(commonChars('man', 'evilman')) # 0.42857142857142855
print(commonChars('batman', 'evilman')) # 0.42857142857142855
print(commonChars('batman', 'man')) # 1.0
</code></pre>
<p>This second version produces the same results, but using the difflib mentioned in other answers.
It computes matching blocks, sum their lengths, and computes the ratio against the reference length.</p>
<pre><code>import difflib

def commonBlocks(txt, ref):
    matcher = difflib.SequenceMatcher(a=txt, b=ref)
    matchingBlocks = matcher.get_matching_blocks()
    matchingCount = sum([b.size for b in matchingBlocks])
    return matchingCount / len(ref)

print(commonBlocks('evxxman', 'evilman')) # 0.7142857142857143
print(commonBlocks('evxxxxman', 'evilman')) # 0.7142857142857143
</code></pre>
<p>As shown by the calls above, the behavior is slightly different. "holes" between matching blocks are ignored, and do not change the final ratio.</p>
</div>
<div class="post-text" itemprop="text">
<p>For finding matches with a quality-estimation, have a look at <a href="https://docs.python.org/3/library/difflib.html#difflib.SequenceMatcher.ratio" rel="nofollow">difflib.SequenceMatcher.ratio</a> and friends - these functions might not be the fastest match-checkers but they are easy to use.</p>
<p>Example copied from difflib docs</p>
<pre><code>&gt;&gt;&gt; s = SequenceMatcher(None, "abcd", "bcde")
&gt;&gt;&gt; s.ratio()
0.75
&gt;&gt;&gt; s.quick_ratio()
0.75
&gt;&gt;&gt; s.real_quick_ratio()
1.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on your description and examples, it seems to me that you're actually looking for something like the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="nofollow">Levenshtein (or edit) distance</a>. Note that it does not quite give the scores you specify, but I think it gives the scores you actually want.</p>
<p>There are several packages implementing this efficiently, e.g., <a href="https://pypi.python.org/pypi/Distance/" rel="nofollow"><code>distance</code></a>:</p>
<pre><code>In [1]: import distance

In [2]: distance.levenshtein('evilman', 'hello')
Out[2]: 6L

In [3]: distance.levenshtein('evilman', 'evil')
Out[3]: 3L

In [4]: distance.levenshtein('evilman', 'evxxman')
Out[4]: 2L
</code></pre>
<p>Note that the library contains several measures of similarity, e.g., jaccard and sorensen return a normalized value per default:</p>
<pre><code>&gt;&gt;&gt; distance.sorensen("decide", "resize")
0.5555555555555556
&gt;&gt;&gt; distance.jaccard("decide", "resize")
0.7142857142857143
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Create a while loop and track two iterators, one for your key word ("evil") and one for your query word ("evilman"). Here is some pseudocode:</p>
<pre><code>key = "evil"
query = "evilman"
key_iterator = 0
query_iterator = 0
confidence_score = 0

while( key_iterator &lt; key.length &amp;&amp; query_iterator &lt; query.length ) {
    if (key[key_iterator] == query[query_iterator]) {
        confidence_score++
        key_iterator++
    }
    query_iterator++
}

// If we didnt reach the end of the key
if (key_iterator != key.length) { 
    confidence_score = 0
}
print ("Confidence: " + confidence_score + " out of " + query.length)
</code></pre>
</div>
<span class="comment-copy">Can't you have two for loops, one iterates through user input and other goes through your "evilman", and the outter for loop will have one character at a time and check with every character in the inner for loop and if matches then add to a counter. But this wouldn't take into consideration duplicates. I would just sort the two strings based on their ascii values of each character, and straight up you can compare see how many match.</span>
<span class="comment-copy">evilman would be aeilmnv and user input is hello changes to ehllo and you compare e to a not match, then e to e and it matches, then just remove e from the aeilmnv list and make it ailmnv and the loop would move to the h in ehllo and continue on.</span>
<span class="comment-copy">@Omid-CompSCI you wouldn't want to sort the strings because I believe an important part of the question is that while they may be discontinuous, they are ordered. So "EILV" would not match "EVIL" per his spec, but it would in your suggestion.</span>
<span class="comment-copy">@Caius you are correct, sorting is not beneficial. Then wouldn't two simple for loops be correct in this scenario if he just wants to search sequentially and increment a counter on matches?</span>
<span class="comment-copy">Thanks for your answer. For some reason, both versions suggested by you return 0 instead of the actual ratio. Am I missing something?</span>
<span class="comment-copy">I just tested them again and I get the results I previously put in the comments. My versions expect 2 strings, while you initial question was working with a list (db) and a string. If you called it directly with your list, you need to add an extra loop to iterate on the database.</span>
<span class="comment-copy">Thank You. I might not require this right now but it is good to know and gives me some interesting ideas to play with in future.</span>
<span class="comment-copy">You're very welcome.</span>
<span class="comment-copy">Interestingly, Levenshtein will blindly try to transform one string into another and give us the length of operations required to do so. For example distance.levenshtein('evilman', 'XXX') would give us a distance of 7. It does not consider whether the two given strings have any characters in common to begin with. Furthermore, to solve this, we could call distance.levenshtein() only when a given input matches a string using python operator "in" . But then we can not calculate the distance for inputs such as "evilxxman" as the python "in"  operator will return False.</span>
<span class="comment-copy">Edit: Ok looks like distance.ilevenshtein() can solve this as well by going through a list of sequences and indicating the one that is closest to the reference input.</span>
