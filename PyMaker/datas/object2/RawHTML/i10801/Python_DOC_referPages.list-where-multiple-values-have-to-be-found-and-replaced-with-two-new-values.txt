<div class="post-text" itemprop="text">
<p>The basis is:<br/>
I want to iterate a certain number of times, each time I take a list, find a certain value, replace that value with two new values and make that the new list what goes into the iteration.  </p>
<p>Here is what I have:</p>
<pre><code>list1 = ['ad', 'sbe', 'k3', 'lm0']
list2 = ['sb', 'e', 'lm', '0']
list3 = [1, 3]
</code></pre>
<p><code>list1</code> is the list I want to change<br/>
<code>list2</code> are the elements I want to replace<br/>
<code>list3</code> are the locations in the original list that values I want to replace are</p>
<p>The output would ideally look like this:</p>
<pre><code>list1 = ['ad', 'sb', 'e', 'k3', 'lm', '0']
</code></pre>
<p>This is what I had, but it ended up getting too complicated and filled with errors, I figure their has to be a simpler way to do this. I have also looked at itertools, but couldn't get that to do what I wanted.</p>
<pre><code>list4 = list1
count = 0
for i in range(int(len(list2)/2)):
    del list4[int(list3[i]) + count]
    for j in range(2):
        if j == 1:
            j = j + 1
            list4.insert(int(list3[i]) + count, list2[(i + j)])
        else:
            list4.insert(int(list3[i]) + count, list2[(i + j)])
</code></pre>
<p>Any help is much appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could start from the end and do extends or the following will work, add the next two elements from <em>list2</em> if the current index is in a <em>set</em> of indexes we create from <em>list3</em> or just keep the original element, then <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow"><em>chain</em></a> all the elements into one list:</p>
<pre><code> In [1]: from itertools import chain
   ...: list1 = ['ad', 'sbe', 'k3', 'lm0']
   ...: list2 = ['sb', 'e', 'lm', '0']
   ...: list3 = [1, 3]
   ...: it = iter(list2) # create iterator so we can pull pairs
   ...: inds = set(list3) # create set from indexes list
   ...: list1[:]= chain(*([next(it), next(it)] if ind in inds else [ele] for in
   ...: d,ele in enumerate(list1)))
   ...: 

In [2]: list1
Out[2]: ['ad', 'sb', 'e', 'k3', 'lm', '0']
</code></pre>
<p>Or create a simple generator function:</p>
<pre><code>def inserts(l1, l2, indexes):
    it, index_set = iter(l2), set(indexes)
    for ind, ele in enumerate(l1):
        if ind in index_set:
            yield next(it)
            yield next(it)
        else:
            yield ele
</code></pre>
<p>Same output:</p>
<pre><code>In [5]: list1 = ['ad', 'sbe', 'k3', 'lm0']
   ...: list2 = ['sb', 'e', 'lm', '0']
   ...: list3 = [1, 3]
   ...: 

In [6]: list1[:] = inserts(list1, list2, list3)
   ...: 
   ...: print(list1)
   ...: 
['ad', 'sb', 'e', 'k3', 'lm', '0']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The way I've approached this problem is by first creating your list by zipping together the lists, and with some simple arithmetic, decide at which index to delete elements from. This <em>does not</em> 
account for the possibility of <strong>duplicate</strong> values in the indices list (<em>this input can be sanitized with a <code>set</code> or edge case error handling</em>) <br/><strong>Possible solution:</strong></p>
<pre><code>def f(list1, list2, list3):
    result=[]
    for item_one, item_two in zip(list1,list2):
        result.extend((item_one, item_two))

    len_factor = float(len(result))/len(list1)
    len_factor = len_factor if len_factor.is_integer() else int(len_factor) + 1
    for index, item in enumerate(set(list3)): 
        del result[item * len_factor - index]
    return result
</code></pre>
<p>Calling the method <code>f()</code>:</p>
<pre><code>list1 = ['ad', 'sbe', 'k3', 'lm0']
list2 = ['sb', 'e', 'lm', '0']
list3 = [1, 3]
print f(list1, list2, list3)
&gt;&gt;&gt; ['ad', 'sb', 'e', 'k3', 'lm', '0']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use list-comprehension with filter:</p>
<pre><code>sum([list2[i:i+2]if i in list3 else [v] for i,v in enumerate(list2)], [])
</code></pre>
<p>You can loop through and check, an imperative-version:</p>
<pre><code>res = []
for i,v in enumerate(list1):
    if i in list3:
        res += list2[i:i+2]
    else:
        res.append(v)
</code></pre>
</div>
<span class="comment-copy">This does not match the expected output at all, also flattening a list with sum is not  a very good approach.</span>
