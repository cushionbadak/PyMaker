<div class="post-text" itemprop="text">
<p>I am trying to send large <strong>byte arrays</strong> of a Protobuf class from a Java client to the Python server. However, they have a <strong>variable</strong> length, because sometimes I send the bytes of an object from <code>ClassA</code> and sometimes from <code>ClassB</code>.</p>
<p>I have a Python socket server with the following code inside the function that listens to the socket:</p>
<pre class="lang-py prettyprint-override"><code>byte_array = bytearray()

# receive the data in small chunks and print it
while True:
    data = connection.recv(64)
    if data:
        # output received data
        logger.debug("Data: %s" % data)
        byte_array.extend(data)

    else:
        # no more data -- quit the loop
        logger.debug("no more data.")
        break

logger.info("Generating response...")
connection.send(generate_response(byte_array))
logger.info("Sent response.")
</code></pre>
<p>I am assembling the large byte array that I receive by putting together the 64 bytes as I get them.</p>
<p>However, when the byte array is fully transmitted and there is nothing left to send, the server hangs on the <code>connection.recv</code> line. </p>
<p>I read that this is because <code>recv</code> blocks until either it receives something or the connection is closed. However, I do not want to close the connection because I want to send my response back to the client after processing the whole byte array.</p>
<p><strong>I want to know when the byte array I am receiving has been fully transmitted,</strong> so that I can avoid this blocking.</p>
<p>I can think of three options:</p>
<ul>
<li>Set a predefined "end" byte, delimiting the end of the byte array.</li>
<li>Send the size of the byte array beforehand and then instead of <code>while True</code> I have a <code>while bytes_read &lt; expected_bytes</code> cycle.</li>
<li>Set a timeout on the connection and I assume that when a timeout occurs it means everything has already been sent.</li>
</ul>
<p>I am inclined for the first option, however I do not know what character I should use to end the byte array nor how to read it in my Python code.</p>
<p>Any suggestions?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Option 1 :</strong></p>
<p>So for the first option you could set end byte which won't occur anywhere in your actual message.
You can create a string for eg."END" and convert it into byte array and send it through your java program. After recieving you could use decode() to convert it to string and compare it. :</p>
<p>Note : The end byte which you will send must be less than or equal to the size of chunk to decode and get the exact end byte.</p>
<pre><code>byte_array = bytearray()

# receive the data in small chunks and print it
while True:
    data = connection.recv(64)
    command = data.decode()
    if command != "END":
        # output received data
        logger.debug("Data: %s" % data)
        byte_array.extend(data)

    else:
        # no more data -- quit the loop
        logger.debug("no more data.")
        break

logger.info("Generating response...")
connection.send(generate_response(byte_array))
logger.info("Sent response.")
</code></pre>
<p><strong>Option 2 :</strong></p>
<p>For the second option you will need to modify the while loop to run according to metadata. I have considered the metadata will consist of first chunk which will be the number of chunks that will be sent.It could go something like :</p>
<p>byte_array = bytearray()</p>
<pre><code># receive the data in small chunks and print it
loop_count = 0
count = 1
meta = 1
while loop_count &gt;= count:
    data = connection.recv(64)
    if(meta):
        count = int(data.decode()) # first chunk is the number of chunks that will be sent 
        meta = 0
    logger.debug("Data: %s" % data)
    byte_array.extend(data)
    loop_count = loop_count + 1
else:
    # no more data
    logger.debug("no more data.")
logger.info("Generating response...")
connection.send(generate_response(byte_array))
logger.info("Sent response.")
</code></pre>
<p><strong>Option 3 :</strong> </p>
<p>It will also work fine provided you are sure there will be no network delay and only issue will be your java program will have to wait for the response from the python server untill the timeout takes place</p>
<p><strong>Option 4 :</strong></p>
<p>You could use a non blocking socket which will run untill it dosen't recieve for a pre determined period of time. Although i don't recommend it for your situation you can read about it and see if it suits your needs.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would personally go for the second option (combined with a reasonable timeout to cater for evil clients that send only half of the file and hang there forever). Delimiting character is good if you can absolutely guarantee it is unique in your stream (but you still need the timeout).  </p>
<p>If you cannot guarantee your delimiter to be unique, sending the size the client needs to expect solves the problem. If your metadata is padded to a fixed length, you do not need to worry about delimiters and detecting them. </p>
</div>
<span class="comment-copy">i had to do the same thing but in reverse, i ended up sending a small "header" packet with size and other meta data which had a constant size, and then receive the variable length using the data from the header and its been working well even for a large number of packet</span>
<span class="comment-copy">The non-blocking socket does not really fit what I need, but I agree with the other options. As I mentioned in a comment, I believe option 2 is the one that suits me the best. In the beginning of the loop you meant to write <code>loop_count &lt;= count</code>, no? I have implemented a similar cycle and it works well. Thanks! ;)</span>
<span class="comment-copy">Thanks! Yeah, I agree that the better option is the second one, because since it's Protobuf generated data I have no idea what bytes there are. I upvoted your answer, but because @AshishGhodake has the code in it, I'll declare it as the correct answer. Cheers.</span>
<span class="comment-copy">That's fine, as long as your problem is solved.   You might also want to take a look at zeromq module.  It offers a higher level of abstraction - taking care of message delivery in its entirety for example. Its interface is very socket-like but it takes care of all the routine stuff you need to consider when using sockets - like assembling partial messages and ensuring they actually get delivered entirely.</span>
