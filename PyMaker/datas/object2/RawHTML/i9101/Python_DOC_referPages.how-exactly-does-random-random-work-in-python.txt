<div class="post-text" itemprop="text">
<p>I am a bit confused about how the random.random() function works in python.</p>
<p>The <a href="https://docs.python.org/3/library/random.html#random.random" rel="nofollow noreferrer">docs</a> say that it 'Return the next random floating point number in the range [0.0, 1.0)'. 
I understand that pseudo-random number generators work by performing some operation on a value. Generally this value is the previous number generated by the generator. So I think that's what <strong>'next random floating point'</strong> means here. (Please correct me if I am wrong)</p>
<p>But when I saw the <a href="https://hg.python.org/cpython/file/3.6/Lib/random.py" rel="nofollow noreferrer">source code</a> of the random library, random function is not defined in the <code>class Random</code>. Instead, its defined in the <code>class SystemRandom</code> as follows (line 671 of the code): </p>
<pre><code> def random(self):
        """Get the next random number in the range [0.0, 1.0)."""
        return (int.from_bytes(_urandom(7), 'big') &gt;&gt; 3) * RECIP_BPF
</code></pre>
<p>If I understand this correctly, this function generates a random number using os.urandom. Which, according to the <a href="https://docs.python.org/2/library/os.html#os.urandom" rel="nofollow noreferrer">documentation</a>, returns random bytes from an OS-specific randomness source. So this will not give the 'next' floating point random number.</p>
<p>How are the two connected? or are they two different things? </p>
<p>I am quite confused here. Any kind of help would be appreciated.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>random.random()</code> is actually defined <a href="https://hg.python.org/cpython/file/3.6/Lib/random.py#l744" rel="nofollow noreferrer">here</a>:</p>
<pre><code>random = _inst.random
</code></pre>
<p>However, it is just a reference to C implementation.</p>
<p>Here is a quote from the source:</p>
<blockquote>
<p>General notes on the underlying Mersenne Twister core generator:</p>
<ul>
<li>The period is 2**19937-1.</li>
<li>It is one of the most extensively tested generators in existence.</li>
<li>The random() method is implemented in C, executes in a single Python step,   and is, therefore, threadsafe.</li>
</ul>
</blockquote>
<p>You probably want to look at the article on <a href="https://en.wikipedia.org/wiki/Mersenne_Twister" rel="nofollow noreferrer">Mersenne Twister</a>. To speak briefly, the state of the generator is not the same as "previous number", it is much more complicated thing. So you are wrong in «…pseudo-random number generators work by performing some operation on a value. Generally this value is the previous number generated by the generator».</p>
<p>As for <code>SystemRandom.random()</code>, it is in a way unrelated to <code>random.random()</code>. It is possible in Python that function with the same name imported from different modules are different, so you can't rely on function's name here.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is the fragment you missed (CPython32):</p>
<pre><code>import _random

class Random(_random.Random):
</code></pre>
<p>where the <code>_random.Random</code> class is</p>
<pre><code>&gt;&gt;&gt; import _random
&gt;&gt;&gt; dir(_random.Random)
[(...) 'getrandbits', 'getstate', 'jumpahead', 'random', 'seed', 'setstate']
</code></pre>
<p>and, from docstring at the beginning of the same random.py implementation file</p>
<blockquote>
<p>General notes on the underlying Mersenne Twister core generator:</p>
<ul>
<li>The period is 2**19937-1.</li>
<li>It is one of the most extensively tested generators in existence.</li>
<li><strong>The random() method is implemented in C, executes in a single Python step,
  and is, therefore, threadsafe.</strong></li>
</ul>
</blockquote>
<p>The _random is a compiled C library that contains few basic operations, which are further extended in Python's implementation contained at random.py file.</p>
</div>
<div class="post-text" itemprop="text">
<p>you are correct this is using os.urandom function as</p>
<pre><code>from os import urandom as _urandom

BPF = 53        # Number of bits in a float
RECIP_BPF = 2**-BPF

def random():
    """Get the next random number in the range [0.0, 1.0)."""
    return (int.from_bytes(_urandom(7), 'big') &gt;&gt; 3) * RECIP_BPF

print(random())
print(RECIP_BPF)
print(int.from_bytes(_urandom(7), 'big')&gt;&gt; 3)
print(int.from_bytes(_urandom(7), 'little') &gt;&gt; 3)
</code></pre>
<p>play with it and you will get it properly.</p>
</div>
<span class="comment-copy">I get it now. Thanks!</span>
<span class="comment-copy">Do you know where one could find the C module?</span>
<span class="comment-copy">You have my upvote, although 53 is not number of bits in a float. It is number of bits in float64 i.e. double used to contain mantisa. Exponent is here ignored. Therefore calling variable BPF is also a bit dubious. But we can skip over such details because Python is always using doubles for his floats  unless "explicitly ordered" not to by using ctypes.c_float() or numpy.float(). But say that 53 is number of bits in the float(64) is simply wrong. It's just mantisa.</span>
<span class="comment-copy">Using 2**-53 as a maximal reciprocal (1.0/2**53) to turn int into Python float ranging from 0 to 1 does the trick though. Well, shifting does its part as well. :D</span>
<span class="comment-copy">Yeah I know I also had doubt over 53 as bits in float but as it was defined in the random py itself thought to give it benefit of doubt cause it works correctly and in python float and double aren't that different at least as much as I have used.</span>
<span class="comment-copy">thats why made sure to mention the exact comment present in the random py for BPF definition.</span>
