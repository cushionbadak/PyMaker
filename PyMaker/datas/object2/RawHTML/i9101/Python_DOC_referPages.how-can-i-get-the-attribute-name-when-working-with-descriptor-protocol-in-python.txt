<div class="post-text" itemprop="text">
<p>The descriptor protocol works fine but I still have one issue I would like to resolve.</p>
<p>I have a descriptor:</p>
<pre><code>class Field(object):
    def __init__(self, type_, name, value=None, required=False):
        self.type = type_
        self.name = "_" + name
        self.required = required
        self._value = value

    def __get__(self, instance, owner):
        return getattr(instance, self.name, self.value)

    def __set__(self, instance, value):
        if value:
            self._check(value)
            setattr(instance, self.name, value)
        else:
            setattr(instance, self.name, None)

    def __delete__(self, instance):
        raise AttributeError("Can't delete attribute")

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        self._value = value if value else self.type()

    @property
    def _types(self):
        raise NotImplementedError

    def _check(self, value):
        if not isinstance(value, tuple(self._types)):
            raise TypeError("This is bad")
</code></pre>
<p>This is subclassed:</p>
<pre><code>class CharField(Field):
    def __init__(self, name, value=None, min_length=0, max_length=0, strip=False):
        super(CharField, self).__init__(unicode, name, value=value)
        self.min_length = min_length
        self.max_length = max_length
        self.strip = strip

    @property
    def _types(self):
        return [unicode, str]

    def __set__(self, instance, value):
        if self.strip:
            value = value.strip()

        super(CharField, self).__set__(instance, value)
</code></pre>
<p>And then used is a model class:</p>
<pre><code>class Country(BaseModel):
    name = CharField("name")
    country_code_2 = CharField("country_code_2", min_length=2, max_length=2)
    country_code_3 = CharField("country_code_3", min_length=3, max_length=3)

    def __init__(self, name, country_code_2, country_code_3):
        self.name = name
        self.country_code_2 = country_code_2
        self.country_code_3 = country_code_3
</code></pre>
<p>So far, so good, this works just as expected.</p>
<p>The only issue I have here is that we have to give a field name every time a field is declared. e.g. <code>"country_code_2"</code> for the <code>country_code_2</code> field. </p>
<p>How would it be possible to get the attribute name of the model class and use it in the field class?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a simple way, and there is a hard way.</p>
<p>The simple way is to use Python 3.6 (or newer), and give your descriptor an additional <a href="https://docs.python.org/3/reference/datamodel.html#object.__set_name__" rel="noreferrer"><code>object.__set_name__()</code> method</a>:</p>
<pre><code>def __set_name__(self, owner, name):
    self.name = '_' + name
</code></pre>
<p>When a class is created, Python automatically will call that method on any descriptors you set on the class, passing in the class object and the attribute name.</p>
<p>For earlier Python versions, the best next option is to use a <a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">metaclass</a>; it'll be called for every subclass that is created, and given a handy dictionary mapping attribute name to attribute value (including you descriptor instances). You can then use this opportunity to pass that name to the descriptor:</p>
<pre><code>class BaseModelMeta(type):
    def __new__(mcls, name, bases, attrs):
        cls = super(BaseModelMeta, mcls).__new__(mcls, name, bases, attrs)
        for attr, obj in attrs.items():
            if isinstance(obj, Field):
                obj.__set_name__(cls, attr)
        return cls
</code></pre>
<p>This calls the same <code>__set_name__()</code> method on the field, that Python 3.6 supports natively. Then use that as the metaclass for <code>BaseModel</code>:</p>
<pre><code>class BaseModel(object, metaclass=BaseModelMeta):
    # Python 3
</code></pre>
<p>or</p>
<pre><code>class BaseModel(object):
    __metaclass__ = BaseModelMeta
    # Python 2
</code></pre>
<p>You could also use a class decorator to do the <code>__set_name__</code> calls for any class you decorate it with, but that requires you to decorate every class.  A metaclass is automatically propagated through the inheritance hierarchy instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>I go through this in my book, <em><a href="https://rads.stackoverflow.com/amzn/click/com/148422504X" rel="nofollow noreferrer">Python Descriptors</a></em>, though I haven't updated to a second edition to add the new feature in 3.6. Other than that, it's a fairly comprehensive guide on descriptors, taking 60 pages on just the one feature.</p>
<p>Anyway, a way to get the name without metaclasses is with this very simple function:</p>
<pre><code>def name_of(descriptor, instance):
    attributes = set()
    for cls in type(instance).__mro__:
        # add all attributes from the class into `attributes`
        # you can remove the if statement in the comprehension if you don't want to filter out attributes whose names start with '__'
        attributes |= {attr for attr in dir(cls) if not attr.startswith('__')}
    for attr in attributes:
        if type(instance).__dict__[attr] is descriptor:
            return attr
</code></pre>
<p>Considering every time you use the name of the descriptor, the instance is involved, this shouldn't be too difficult to figure out how to use. You could also find a way to cache the name once you've looked it up the first time.</p>
</div>
<span class="comment-copy">unfortunately <code>__set_name__</code> isn't called on class attributes which are set like <code>MyClass.aDescriptor = MyDescriptor()</code> which would be helpful when adding descriptors dynamically.  Granted you can still call it manually - it just feels unnecessary.</span>
<span class="comment-copy">@aaaaaa: <code>__set_name__</code> is only called <i>when a class is created</i>, so no, it won't kick in merely on setitem. You can give <code>MyDescriptor()</code> an optional <code>name</code> argument to use to set the same value as <code>__set_name__</code> would? <code>MyClass.aDescriptor = MyDescriptor('aDescriptor')</code></span>
<span class="comment-copy">Oh I didn't realize it was on class creation - thanks.  And yeah setting the name manually works just fine in that case.</span>
<span class="comment-copy">This is not enough; the descriptors follow the MRO.</span>
<span class="comment-copy">Your comment was quite difficult to decipher; I assume you meant to say that the function doesn't get the members of super classes? I'm working on it; I'll get that done in a few minutes.</span>
<span class="comment-copy">Edit is finished</span>
