<div class="post-text" itemprop="text">
<p>I have the following list:</p>
<pre><code>initial_list = [['B', 'D', 'A', 'C', 'E']]
</code></pre>
<p>On each element of the list I apply a function and put the results in a dictionary:</p>
<pre><code>for state in initial_list:
    next_dict[state] = move([state], alphabet)
</code></pre>
<p>This gives the following result:</p>
<pre><code>next_dict = {'D': ['E'], 'B': ['D'], 'A': ['C'], 'C': ['C'], 'E': ['D']}
</code></pre>
<p>What I would like to do is separate the keys from initial_list based on their 
values in the next_dict dictionary, basically group the elements of the first list to elements with the same value in the next_dict:</p>
<pre><code>new_list = [['A', 'C'], ['B', 'E'], ['D']]
</code></pre>
<p>'A' and 'C' will stay in the same group because they have the same value 'C', 'B' and 'D' will also share the same group because their value is 'D' and then 'D' will be in it's own group.</p>
<p>How can I achieve this result?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>next_next_dict = {}
for key in next_dict:
    if next_dict[key][0] in next_next_dict:
        next_next_dict[next_dict[key][0]] += key
    else:
        next_next_dict[next_dict[key][0]] = [key]
new_list = next_next_dict.values()
</code></pre>
<p>Or this:</p>
<pre><code>new_list = []
for value in next_dict.values():
    new_value = [key for key in next_dict.keys() if next_dict[key] == value]
    if new_value not in new_list:
        new_list.append(new_value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a>, after having sorted your list by <code>next_dict</code> values :</p>
<blockquote>
<p>It generates a break or new group every time the value of the key
  function changes (which is why it is usually necessary to have sorted
  the data using the same key function).</p>
</blockquote>
<pre><code>from itertools import groupby

initial_list = ['B', 'D', 'A', 'C', 'E']

def move(letter):
    return {'A': 'C', 'C': 'C', 'D': 'E', 'E': 'D', 'B': 'D'}.get(letter)
sorted_list = sorted(initial_list, key=move)
print [list(v) for k,v in groupby(sorted_list, key=move)]
#=&gt; [['A', 'C'], ['B', 'E'], ['D']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simplest way to achieve this will be to use <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> with key as <code>dict.get</code> as:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; next_dict = {'D': ['E'], 'B': ['D'], 'A': ['C'], 'C': ['C'], 'E': ['D']}
&gt;&gt;&gt; initial_list = ['B', 'D', 'A', 'C', 'E']

&gt;&gt;&gt; [list(i) for _, i in groupby(sorted(initial_list, key=next_dict.get), next_dict.get)]
[['A', 'C'], ['B', 'E'], ['D']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not exactly sure that's what you want but you can group the values based on their values in the <code>next_dict</code>:</p>
<pre><code>&gt;&gt;&gt; next_dict = {'D': 'E', 'B': 'D', 'A': 'C', 'C': 'C', 'E': 'D'}

&gt;&gt;&gt; # external library but one can also use a defaultdict.
&gt;&gt;&gt; from iteration_utilities import groupedby  

&gt;&gt;&gt; groupings = groupedby(['B', 'D', 'A', 'C', 'E'], key=next_dict.__getitem__)
&gt;&gt;&gt; groupings
{'C': ['A', 'C'], 'D': ['B', 'E'], 'E': ['D']}
</code></pre>
<p>and then convert that to a list of their values:</p>
<pre><code>&gt;&gt;&gt; list(groupings.values())
[['A', 'C'], ['D'], ['B', 'E']]
</code></pre>
<hr/>
<p>Combine everything into a one-liner (not really recommended but a lot of people prefer that):</p>
<pre><code>&gt;&gt;&gt; list(groupedby(['B', 'D', 'A', 'C', 'E'], key=next_dict.__getitem__).values())
[['A', 'C'], ['D'], ['B', 'E']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can sort your list with your dictionary mapping, and then use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to form the groups. The only amendment I made here is making your initial list an actual flat list. </p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; initial_list = ['B', 'D', 'A', 'C', 'E']
&gt;&gt;&gt; next_dict = {'D': ['E'], 'B': ['D'], 'A': ['C'], 'C': ['C'], 'E': ['D']}
&gt;&gt;&gt; s_key = lambda x: next_dict[x]
&gt;&gt;&gt; [list(v) for k, v in groupby(sorted(initial_list, key=s_key), key=s_key)]
[['A', 'C'], ['B', 'E'], ['D']]
</code></pre>
</div>
<span class="comment-copy">The initial list is likely wrong as a list in a list.</span>
<span class="comment-copy">I just want to partition the first list into groups with the same value from the dicionary</span>
