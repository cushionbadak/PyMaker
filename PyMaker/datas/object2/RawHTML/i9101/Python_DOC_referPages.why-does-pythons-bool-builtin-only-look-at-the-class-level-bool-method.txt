<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/38133096/assigning-instead-of-defining-a-getitem-magic-method-breaks-indexing">Assigning (instead of defining) a __getitem__ magic method breaks indexing [duplicate]</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>The <a href="https://docs.python.org/3.6/reference/datamodel.html#object.__bool__" rel="nofollow noreferrer">documentation</a> clearly states that</p>
<blockquote>
<p>When this method <strong>(<code>__bool__</code>)</strong> is not defined, <code>__len__()</code> is called, if it is defined, and the object is considered true if its result is nonzero. If a <em>class</em> defines neither <code>__len__()</code> nor <code>__bool__()</code>, all its instances are considered true.</p>
</blockquote>
<p>Bold is my insertion, italics is mine but the text is actually there. The fact that the class must contain the method is readily tested by</p>
<pre><code>class A:
    pass

a = A()
a.__bool__ = (lamda self: False).__get__(a, type(a))

print(bool(A()), bool(a))
</code></pre>
<p>The result is <code>True True</code>, as the documentation claims. Overriding <code>__len__</code> yields the same result:</p>
<pre><code>b = A()
b.__len__ = (lambda self: 0).__get__(b, type(b))

print(bool(A()), bool(b))
</code></pre>
<p>This works exactly as the documentation claims it will. However, I find the reasoning behind this to be a little counter-intuitive. I understand that the <code>bool</code> builtin does not look at the methods of the instance, but I do not understand why. Does someone with a knowledge of the internal workings know why only the class-level <code>__bool__</code> and <code>__len__</code> methods affect truthiness while instance-level methods are ignored?</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason is <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">how special methods are looked up</a>.</p>
<blockquote>
<p>For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary.</p>
</blockquote>
<p>...</p>
<blockquote>
<p>The rationale behind this behaviour lies with a number of special methods such as <code>__hash__()</code> and <code>__repr__()</code> that are implemented by all objects, including type objects. If the implicit lookup of these methods used the conventional lookup process, they would fail when invoked on the type object itself.</p>
</blockquote>
<p>...</p>
<blockquote>
<p>In addition to bypassing any instance attributes in the interest of correctness, implicit special method lookup generally also bypasses the <code>__getattribute__()</code> method even of the object’s metaclass.</p>
</blockquote>
<p>...</p>
<blockquote>
<p>Bypassing the <code>__getattribute__()</code> machinery in this fashion provides significant scope for speed optimisations within the interpreter, at the cost of some flexibility in the handling of special methods (the special method must be set on the class object itself in order to be consistently invoked by the interpreter).</p>
</blockquote>
</div>
