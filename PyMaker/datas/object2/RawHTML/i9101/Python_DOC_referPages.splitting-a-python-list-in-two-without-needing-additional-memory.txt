<div class="post-text" itemprop="text">
<p>I would like to split an <code>int</code> list <code>l</code> in two small lists <code>l1</code>, <code>l2</code> (I know the split point <code>n</code>).</p>
<p>I am already able to perform the splitting by copying <code>l2</code> elements in another list and then removing them from <code>l</code>, but this requires to have space for at least <code>n + n/2</code> elements in memory and this is not affordable since <code>l</code> is big.</p>
<p>Does someone has a solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you do not want to spend additional memory on the smaller lists, you have two possibilities:</p>
<ol>
<li><p>Either you can destroy/reduce the original list as you create the smaller lists. You could use <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a>, providing O(1) removal and insertion at both ends:</p>
<pre><code>&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; deq = deque(range(20))
&gt;&gt;&gt; front = deque(deq.popleft() for _ in range(10))
&gt;&gt;&gt; front
deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; deq  # original list reduced, can be used as 2nd list
deque([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
</code></pre></li>
<li><p>Or you can create two views on parts of the smaller lists, meaning that the original list would be altered if the smaller lists are modified, and vice versa. For instance, use <code>numpy.array</code> for your numbers and create slices (being views) on that array:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; arr = np.array(range(20))
&gt;&gt;&gt; front = arr[:10]
&gt;&gt;&gt; back = arr[10:]
&gt;&gt;&gt; front[3] = 100
&gt;&gt;&gt; arr  # original list modified
array([  0,   1,   2, 100,   4,   5,   6,   7,   8,   9,  10,  11,  12,
        13,  14,  15,  16,  17,  18,  19])
</code></pre></li>
</ol>
<p>If you have to use plain Python <code>list</code>, you could also use <code>list.pop</code>. However, as explained in the <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer">documentation for <code>deque</code></a>, you should not use <code>pop(0)</code>, as this will have to re-organize the entire list each time you pop an element, giving you O(nÂ²) for extracting half of the list. Instead, use <code>pop()</code> to pop from the end of the list. To restore the original order, you could first pop into a temporary list, and then pop from that list, reversing it twice.</p>
<pre><code>&gt;&gt;&gt; lst = list(range(10))
&gt;&gt;&gt; tmp = [lst.pop() for _ in range(5)]
&gt;&gt;&gt; front, back = lst, [tmp.pop() for _ in range(len(tmp))]
&gt;&gt;&gt; front, back
([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about trying this</p>
<pre><code>class mylist(list):
    def split_by_position_n(self, n):
        return self[:int(n)], self[int(n):]
</code></pre>
<p>then, <code>l = mylist(range(1,10))</code></p>
<pre><code>l.split_by_position_n(4)
&gt;&gt;&gt;([1, 2, 3, 4], [5, 6, 7, 8, 9])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can slice the list with <a href="https://docs.python.org/2/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a> at <code>n</code>. The slice objects are lazy and are only loaded into memory when you iterate on them:</p>
<pre><code>from itertools import islice

def split_list(lst, n):
    return islice(lst, n), islice(lst, n, None)

A, B = split_list(range(10), 5)

print(list(A))
# [0, 1, 2, 3, 4]
print(list(B))
# [5, 6, 7, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I came with a simple solution. What about</p>
<pre><code>l1 = [l.pop(0) for i in range(n)]
</code></pre>
<p>It seems to work and it should not require additional memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>Helo AreTor,</p>
<p>This is my solution:</p>
<pre><code>list = [1,2,3,4,5,6,7,8,9]
l1 = list[0:n]
l2 = list[n:]
</code></pre>
<ul>
<li>list is the list of elements.</li>
<li>n is the number of elements you want in the first list (the split point index).</li>
</ul>
<p>list[0:n] will return the first n items of you list.</p>
<p>list[n:] will return the rest of the list.</p>
<p>Hope it helps you</p>
<p>EDIT: If you worry about memory problems, you can delete the list once you split it.. Even you can use list[0:n] / list[n:] in your code and you dont use more memory.. </p>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/752308/split-list-into-smaller-lists">Split list into smaller lists</a></span>
<span class="comment-copy">Why splitting anyway? You could construct some sort of "view" that treats a part of the list as if it was a full list.</span>
<span class="comment-copy">Show list example and expected output to clarify issue</span>
<span class="comment-copy">@asongtoruin: This question is more specific about how to do this without having a huge memory burden.</span>
<span class="comment-copy">@WillemVanOnsemusing for a view, <a href="https://docs.python.org/2/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><b><code>itertools.islice</code></b></a> would seem a good option</span>
<span class="comment-copy">This is similar to my first solution, but note that on regular lists, <code>pop(0)</code> is <i>very</i> wasteful. You do not need additional memory, but with each <code>pop</code>, all the elements have to be repositioned. Better use a <code>deque</code>. In fact, the <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer">documentation on <code>deque</code></a> even mentions O(n) <i>memory</i> cost for <code>pop(0)</code> on lists, which is exactly what you are trying to avoid.</span>
<span class="comment-copy">(Misread the documentation, it's O(n) cost for moving memory, not O(n) memory cost, but still quadratic complexity for popping half the list, which is quite bad if the list is long.)</span>
<span class="comment-copy">@tobias_k what about <code>pop()</code> only? Does it require O(n) cost for moving elements? I don't really need to keep the elements ordered.</span>
<span class="comment-copy"><code>pop()</code> should not be as bad; it will probably still do some under-the-hood data reorganization from time to time as the list shrinks, and the elements in <code>li</code> will be reversed, but otherwise... to be sure you'll just have to try with your big list. Still, what's wrong with using a <code>deque</code>?</span>
<span class="comment-copy">well <code>deque</code> is not <code>list</code> or a subclass of <code>list</code> I would be bound to use <code>deque</code> class without all the features of the <code>list</code> class, or do something like <code>deq = deque(l)</code> and then <code>l = list(deq)</code>. Would it be helpful to put my option as the 3rd choice in your answer, along with these considerations?</span>
