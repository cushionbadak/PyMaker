<div class="post-text" itemprop="text">
<p>I have several lists of lists, and I want to be able to edit the items in the lists throughout my code, and then reset them all to their initial values later.</p>
<p>Here's an example:</p>
<pre><code>list_a = [0, 1, 2]
list_b = [list_a, 3, 4]
list_c = [6, 7]
list_d = [8, 9]
lists = [0, list_b, 5, list_c, list_d]
#As you can see, lists are of varying length, and sometimes nested multiple times.

print(lists)
Out&gt;&gt;&gt; [0, [[0, 1, 2], 3, 4], 5, [6, 7], [8, 9]]

#Currently, I'm saving the important items of "lists" in the first item, like this:
lists[0] = lists[1:]

#Then I edit the values of various items, like this:
lists[1][0][2] = 0
lists[2] = 0
lists[3][1] = 0
lists[4][1] = 0

print(lists[1:])
Out&gt;&gt;&gt; [[[0, 1, 0], 3, 4], 0, [6, 0], [8, 0]]

#Then I try to reset those values to the originals that I stored in lists[0]
lists[1:] = lists[0]

print(lists[1:])
Out&gt;&gt;&gt; [[[0, 1, 0], 3, 4], 5, [6, 0], [8, 0]]
</code></pre>
<p>As you can see, this method works for list[2] because that item is a value, and not a nested list. It seems that even though I use [1:] to make a copy in lists[0], the references to nested lists are what get copied, rather than the values in those nested lists.</p>
<p>How can I properly copy the values of lists[1:] into lists[0] and then back again, without having both copies reference the same index?</p>
<p>Or perhaps there's a simpler way to achieve the same intended result, returning all items in lists to their original values?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use deep copy: <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">https://docs.python.org/3/library/copy.html</a></p>
<p>This will copy the object as well the child objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://pyrsistent.readthedocs.io/en/latest/" rel="nofollow noreferrer">persistent data structures</a>.  Avoiding mutation allows greater sharing and avoids spooky action at a distance like this.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; from pyrsistent import pvector
&gt;&gt;&gt; list_a = pvector([0, 1, 2])
&gt;&gt;&gt; list_b = pvector([list_a, 3, 4])
&gt;&gt;&gt; list_c = pvector([6, 7])
&gt;&gt;&gt; list_d = pvector([8, 9])
&gt;&gt;&gt; lists = pvector([0, list_b, 5, list_c, list_d])
&gt;&gt;&gt; print(lists)
pvector([0, pvector([pvector([0, 1, 2]), 3, 4]), 5, pvector([6, 7]), pvector([8, 9])])
&gt;&gt;&gt; lists = lists.set(0, lists[1:])
&gt;&gt;&gt; lists = lists.transform([1, 0, 2], 0)
&gt;&gt;&gt; lists = lists.transform([2], 0)
&gt;&gt;&gt; lists = lists.transform([3, 1], 0)
&gt;&gt;&gt; lists = lists.transform([4, 1], 0)
&gt;&gt;&gt; print(lists[1:])
pvector([pvector([pvector([0, 1, 0]), 3, 4]), 0, pvector([6, 0]), pvector([8, 0])])
&gt;&gt;&gt; lists = lists[:1] + lists[0]
&gt;&gt;&gt; print(lists[1:])
pvector([pvector([pvector([0, 1, 2]), 3, 4]), 5, pvector([6, 7]), pvector([8, 9])])
&gt;&gt;&gt;
</code></pre>
<p>Also, Python has non-list variables.  The first element of a list of random values is a strange place to "save" things.  Given the above, you could just keep the original values around in another variable.  For example:</p>
<pre><code>&gt;&gt;&gt; list_a = pvector([0, 1, 2])
&gt;&gt;&gt; list_b = pvector([list_a, 3, 4])
&gt;&gt;&gt; list_c = pvector([6, 7])
&gt;&gt;&gt; list_d = pvector([8, 9])
&gt;&gt;&gt; lists = original = pvector([list_b, 5, list_c, list_d])
</code></pre>
<p>Now you can screw around with <code>lists</code> and when you get tired of it, <code>lists = original</code> brings you right back to the initial state.</p>
</div>
