<div class="post-text" itemprop="text">
<p>I have code like the following:</p>
<h3>server.py</h3>
<pre><code>import queue
from multiprocessing.managers import BaseManager

class QueueManager(BaseManager):
    pass

q = queue.Queue()
QueueManager.register('queue', callable=lambda:q)
m = QueueManager(address=('localhost', 51000), authkey=b'pass')
s = m.get_server()
s.serve_forever()
</code></pre>
<h3>producer.py</h3>
<pre><code>from multiprocessing.managers import BaseManager
import time

class QueueManager(BaseManager):
    pass

QueueManager.register('queue')
m = QueueManager(address=('localhost', 51000), authkey=b'pass')
m.connect()
queue = m.queue()

idx = 0
while True:
    time.sleep(2)
    queue.put(idx)
    idx += 1
</code></pre>
<h3>consumer.py</h3>
<pre><code>from multiprocessing.managers import BaseManager

class QueueManager(BaseManager):
    pass

QueueManager.register('queue')
m = QueueManager(address=('localhost', 51000), authkey=b'pass')
m.connect()
queue = m.queue()

while True:
    message = queue.get()
    print(message)
</code></pre>
<p>If I run the server and the producer and then start the consumer I see all messages that the producer put in the queue appear at the consumer. However, if I stop the consumer and immediately restart it it always skips a message. </p>
<p>To illustrate what I see as output of the consumer.py:</p>
<pre><code>0
1
2
3
&lt;restart the consumer&gt;
5
6
7
etc.
</code></pre>
<p>Is this just how the python multiprocessing queue is supposed to work, is it a bug or am I doing something wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the issue lies in either the way pipes are implemented in python, or it might even be a limitation on the OS. Here's the full stack trace:</p>
<pre><code>Traceback (most recent call last):
  File "consumer.py", line 12, in &lt;module&gt;
    message = queue.get()
  File "&lt;string&gt;", line 2, in get
  File "/usr/local/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/multiprocessing/managers.py", line 757, in _callmethod
    kind, result = conn.recv()
  File "/usr/local/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/multiprocessing/connection.py", line 250, in recv
    buf = self._recv_bytes()
  File "/usr/local/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/multiprocessing/connection.py", line 407, in _recv_bytes
    buf = self._recv(4)
  File "/usr/local/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/multiprocessing/connection.py", line 379, in _recv
    chunk = read(handle, remaining)
KeyboardInterrupt
</code></pre>
<p>The value seems to be lost in the <code>queue.get()</code> call which is not properly terminated with the <code>SIGINT</code>. The <code>queue.get()</code> gets instantly cancelled, so it's not that python would finish the <code>get()</code> call and then lose the value. It looks more like python does not properly cancel the <code>recv</code> on the pipe.</p>
<p>If you are changing the consumer to this:</p>
<pre><code>while True:
    while queue.empty():
        sleep(0.1)
    message = queue.get()
    print(message)
</code></pre>
<p>it will work. But of course it's a workaround and not the real solution.</p>
<p><strong>Update:</strong></p>
<p>After playing around more with your code I think this is a bug, since:</p>
<ol>
<li>you <a href="https://docs.python.org/3/library/multiprocessing.html#using-a-remote-manager" rel="nofollow noreferrer">followed their coding example one by one</a></li>
<li>no type of queue solves the problem (neither <code>multiprocessing.Queue</code> nor <code>multiprocessing.JoinableQueue</code></li>
<li>also sending <code>task_done()</code> is not helping</li>
</ol>
<p>The bug is happening both on python2 and python3. I suggest you <a href="https://bugs.python.org/" rel="nofollow noreferrer">report this as a bug</a>. In the worst case, if it is not a bug, you at least get an explanation why python would behave this way.</p>
</div>
<span class="comment-copy">How you restart the consumer?</span>
<span class="comment-copy">I just kill it with Ctrl+C and start it again</span>
<span class="comment-copy">You are killing the consumer while the producer is putting the integers to queue so how do you expect it prints the previous item?</span>
<span class="comment-copy">It also happens if I kill the consumer before the producer puts the next integer in the queue. I would expect this integer to just remain in the queue until there is a consumer to consume it, however it seems as if killing the consumer affects the queue.</span>
<span class="comment-copy">@Semi: I played about 1 more hour with your code and couldn't get it to work, see my updated answer below, I would file this as a bug</span>
<span class="comment-copy">Thanks for putting your time into this, I have tried several things too, but without success. For now I reported it as a bug: <a href="http://bugs.python.org/issue29454" rel="nofollow noreferrer">bugs.python.org/issue29454</a></span>
