<div class="post-text" itemprop="text">
<p>I have to port a legacy code ( ~60K LOC) from Python 2 to 3 which has a couple of thousand of structures like below:</p>
<pre><code>class Sample(object):
    __slots__ = ('both', 'advertise')
    class __metaclass__(type):
        __instancecheck__ = classmethod(
                lambda cls, inst: inst in ('both', 'advertise'))
    both = 'both'
    advertise = 'advertise'
</code></pre>
<p>This code works fine with Python 2 but doesn't compile with Python 3 and to resolve it I need to change it to </p>
<pre><code>class Sample(object):
    __slots__ = ('both', 'advertise')
    class __metaclass__(type):
        __instancecheck__ = classmethod(
                lambda cls, inst: inst in ('both', 'advertise'))
    def __init__(self):
        both = 'both'
        advertise = 'advertise'
</code></pre>
<p><strong>What would be an efficient way to handle this change given that it has to be done over such a large file multiple times?</strong></p>
<p>We have to consider that there may or may not be a <code>__init__</code> function definition already for the class and there can be nested class definitions as well.</p>
<p>This is what I have tried so far.</p>
<ul>
<li><code>2to3</code> doesn't recognize this as an issue and hence doesn't change it. </li>
<li>One possible way could be to use <code>ast</code> module to modify the parse tree in memory and then use <code>unparse</code> to write back the modified code. But it is not straightforward. </li>
<li>If nothing else works, I will consider writing a simple Shell/Python script which will read the source file, make changes and write it back. </li>
</ul>
<p>Can there be another quick and simple way to handle this change. </p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know of any better way than to write a small script. I think the changes are small enough that you can get away with some nice heuristics and don't need the full power of <code>ast</code>.</p>
<p>However, if you have this much repetition of code, I would remove the classes from your code altogether. You can replace them with either a code generator or write a factory function for these classes. This is going to future-proof your code for any changes.</p>
<p>Such a factory could look like this:</p>
<pre><code>class HasStringInstances(type):
    def __instancecheck__(cls, instance):
        return instance in cls.__slots__

def create_special_class(*slots):
    class SpecialClass(object, metaclass=HasStringInstances):
        __slots__ = slots

        def __init__(self):
            for slot in self.__slots__:
                 # assign name as value
                 setattr(self, slot, slot)

    return SpecialClass

Sample = create_special_class('both', 'advertise')
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">Metaclasses have changed in Python 3</a>, <code>__metaclass__</code> doesn't work anymore. You could also replace the metaclasses (one for each class here) with one common metaclass and use <code>lambda cls, inst: inst in cls.__slots__)</code> which should work for all classes.</span>
<span class="comment-copy">And you could also replace the code in <code>__init__</code> with <code>for slot in __slots__: setattr(self, slot, slot)</code></span>
<span class="comment-copy">Thanks. That sounds like a good feedback. Yes, <code>ast</code> seemed too heavyweight for this. Moreover , nodes in the <code>ast.NodeVisitor</code> class doesn't have pointer / link to parent, so it seemed difficult to move nodes in the parse tree.</span>
