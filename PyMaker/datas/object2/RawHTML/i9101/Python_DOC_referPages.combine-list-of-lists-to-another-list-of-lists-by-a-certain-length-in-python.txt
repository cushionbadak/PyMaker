<div class="post-text" itemprop="text">
<p>I'm looking for a one liner to convert</p>
<pre><code>[[1], [1, 1], [1, 1, 1], [1], [1], [1], [1, 1, 1, 1]]
</code></pre>
<p>to</p>
<pre><code>[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1, 1]]
</code></pre>
<p>where the algorithm combines the lists up to a certain threshold length.</p>
<p>I currently have this</p>
<pre><code>batched = []
batch = []
for l in lists:
    batch.extend(l)
    if len(batch) &gt; threshold:
        batched.append(batch)
        batch = []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's nothing wrong with your original implementation but if you insist oneliner here's one ugly option:</p>
<pre><code>from itertools import accumulate, chain, groupby

THRESHOLD = 3
l = [[1], [1, 1], [1, 1, 1], [1], [1], [1], [1, 1, 1, 1]]
res = [[y for x in g for y in x[1]]
       for k, g in groupby(zip(chain([0], accumulate(len(x) for x in l)), l),
                           lambda x: x[0] // THRESHOLD)]
print(res)
</code></pre>
<p>Output:</p>
<pre><code>[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1, 1]]
</code></pre>
<p>The idea is to generate list of <code>(item count so far, sublist)</code> tuples and group them by dividing count by <code>THRESHOLD</code>.</p>
<pre><code>&gt;&gt;&gt; temp = list(zip(chain([0], accumulate(len(x) for x in l)), l))
&gt;&gt;&gt; temp
[(0, [1]), (1, [1, 1]), (3, [1, 1, 1]), (6, [1]), (7, [1]), (8, [1]), (9, [1, 1, 1, 1])]
&gt;&gt;&gt; groups = [list(g) for k, g in groupby(temp, lambda x: x[0] // THRESHOLD)]
&gt;&gt;&gt; groups
[[(0, [1]), (1, [1, 1])], [(3, [1, 1, 1])], [(6, [1]), (7, [1]), (8, [1])], [(9, [1, 1, 1, 1])]]
&gt;&gt;&gt; [[y for x in g for y in x[1]] for g in groups]
[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1, 1]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Cracked it but only because I'm stubborn. It's really ugly and inefficient though and maybe there's a cleaner way but, even if there is, it's not worth it.</p>
<pre><code>a = [[1], [1, 1], [1, 1, 1], [2], [1], [1], [1, 1, 1, 1]]

b = [[[item for sublist in a for item in sublist][x+(y*3)] for x in range(1,4)] for y in range(0, (len([i for j in a for i in j])/3))]
</code></pre>
<p>EDIT: Because I was testing this in Python 2.7 I missed the fact that division works differently in Python 3. Thanks @nexus66 for pointing out a modification (which just makes it even longer!).</p>
<pre><code>c = [[[item for sublist in a for item in sublist][x+(y*3)] for x in range(1,4)] for y in range(0, int((len([i for j in a for i in j])/3)))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This may not be ideal, but it would be my attempt. The idea is to chain your lists together with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> , then pull from the chain with <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a> and append a new list until you cannot any longer. It admittedly isn't a one liner.  </p>
<pre><code>from itertools import chain, islice
def grouper(n, li):
    it = chain(*li)
    out_l = []
    while True:
        chunk = list(islice(it, n))
        if len(chunk) &lt; n:
            if chunk:
                out_l[-1] += chunk
            return out_l
        out_l.append(chunk)
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>In[238]: orig = [[1], [1, 1], [1, 1, 1], [1], [1], [1], [1, 1, 1, 1]]
In[239]: grouper(3, orig)
Out[239]: [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1, 1]]
In[240]: grouper(4, orig)
Out[240]: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1, 1]]
In[241]: grouper(5, orig)
Out[241]: [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1]]
Out[242]: grouper(1, orig)
Out[242]: [[1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is an ugly one-liner... <strong>It's not <em>exactly</em> what you asked for</strong> (pretty close), but maybe it'll give you some idea of how to approach it...</p>
<pre><code>arr = [[1], [1, 1], [1, 1, 1], [1], [1], [1], [1, 1, 1, 1]]

threshold = 4

[[x for y in arr for x in y][i:i+threshold] 
     for i, _ in enumerate([x for y in arr for x in y])
       if i % threshold == 0]

Out[31]:
[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I appreciate all the help, and I learned that a one liner is not be best for this problem as it is ugly and unreadable and probably inefficient. That being said I did come up with this which seems to work from a different slightly cleaner approach.</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; l = [[1], [2, 3], [4, 5, 6], [7], [8], [9], [10, 11, 12, 13]]
&gt;&gt;&gt; t = 3
&gt;&gt;&gt; b = reduce(lambda p, n: p[:-1] + [p[-1] + n] if len(p[-1]) + len(n) &lt;= t or not p[-1] else p + [n], l, [[]])
&gt;&gt;&gt; b
[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12, 13]]
</code></pre>
</div>
<span class="comment-copy">that could have been a good question.</span>
<span class="comment-copy">What is the question?  You don't seem to have any issues w/ your attempt.</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre challenge accepted, though it's already looking ugly</span>
<span class="comment-copy">I'm not sure why this question is being downvoted, it seems fairly common for questions regarding python one liners to be asked, here is an example <a href="http://stackoverflow.com/questions/3508766/python-one-liner">stackoverflow.com/questions/3508766/python-one-liner</a></span>
<span class="comment-copy">Also, @shane - It is being downvoted because it doesn't show any research effort into addressing the actual question (and its also unlikely to be useful)</span>
<span class="comment-copy">Your code produce an exception. You could update it to <code>[[[item for sublist in a for item in sublist][x+(y*3)] for x in range(1,4)] for y in range(0, int((len([i for j in a for i in j])/3)))]</code></span>
<span class="comment-copy">@nexus66 what exception? I don't get any index error.</span>
<span class="comment-copy">@nexus66 both approaches give me the same answer in 2.7, I wonder if this is Python 3 division?</span>
<span class="comment-copy">It produces this exception <code>TypeError: 'float' object cannot be interpreted as an integer</code> within Python3</span>
<span class="comment-copy">@nexus66 I just realised that the flattening of the list ends up losing the initial structure so the threshold is missed on the final element. That's frustrating.</span>
<span class="comment-copy">Downvoter, something I could improve here?</span>
