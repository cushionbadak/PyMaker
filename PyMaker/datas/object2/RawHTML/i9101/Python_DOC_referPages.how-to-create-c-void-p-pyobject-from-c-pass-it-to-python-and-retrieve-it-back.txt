<div class="post-text" itemprop="text">
<p>I need to share an ArrayFire array creating in C++ to Python. That works OK:</p>
<pre><code>PyObject* arrayToPyObject(const af::array&amp; arr)
{
    // Create arrayfire array and set 
    PyObject* afArray = createObject("arrayfire", "Array");

    PyObject* ctypes_mod = PyImport_ImportModule("ctypes");
    PyObject* c_void_p = PyObject_GetAttrString(ctypes_mod, "c_void_p");
    PyObject* p = PyObject_CallFunction(c_void_p, "O", PyLong_FromVoidPtr(arr.get()));

    if (PyObject_SetAttr(afArray, PyUnicode_FromString("arr"), p) == 0)
    {
        return afArray;
    }
    else
    {
        Py_XDECREF(afArray);
        return nullptr;
    }
}
</code></pre>
<p>Now if my Python script return an ArrayFire array I need to read the arr attribute and get my pointer back and assign it to a C++ array</p>
<pre><code>af::array pyObjectToArray(PyObject* obj)
{
    af::array tmp;
    PyObject* arr = PyObject_GetAttr(obj, PyUnicode_FromString("arr"));
    if (arr)
    {
        af_array ref = (af_array)(PyLong_AsVoidPtr(arr));

        if (ref)
        {
            tmp.set(ref);
        }
    }

    return tmp;
}
</code></pre>
<p>Issue here is that PyLong_AsVoidPtr failswith class 'TypeError': an integer is required.</p>
<p><a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow noreferrer">ctypes doc</a> (16.16.1.4. Fundamental data types) says the Python type for c_void_p is either int or None. Obviously it is None in my case</p>
<p>How can I convert c_void_p to python using the C API?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>I solved it.</p>
<p>The ctypes type objects values can be read from the <strong>value</strong> attribute.</p>
<pre><code>af::array pyObjectToArray(PyObject* obj)
{
    af::array tmp;
    PyObject* arr = PyObject_GetAttr(obj, PyUnicode_FromString("arr")); // &lt;-- c_void_p object
    PyObject* p = PyObject_GetAttr(arr, PyUnicode_FromString("value") // &lt;-- int value

    if (arr)
    {
        af_array ref = (af_array)(PyLong_AsVoidPtr(p));

        if (ref)
        {
            tmp.set(ref);
        }
    }

    return tmp;
}
</code></pre>
</div>
<span class="comment-copy">Curious. Any reason you are not using the Python wrapper for arrayfire ?</span>
<span class="comment-copy">I am using it. But if you need to share pass an af::array created in your application to the arrayfire python binding type Array, then you'll need that trick. The good thing about passing the af_array ref is that if you are using a CUDA backend, the memory stays in GPU and you won't get overhead from copying data.</span>
