<div class="post-text" itemprop="text">
<p>I want to sort a list by the number of occurrences of the elements in the list.<br/>
When I use this form:    </p>
<pre><code>A=[2,1,3,4,2,2,3]
A.sort(key=lambda x:A.count(x))  
print(A)
</code></pre>
<p>the result is not what I want: <code>[2, 1, 3, 4, 2, 2, 3]</code>.<br/>
But, when I write like it using <code>sorted</code>:    </p>
<pre><code>B=sorted(A,key=lambda x:A.count(x))
print(B)
</code></pre>
<p>the result is right: <code>[1, 4, 3, 3, 2, 2, 2]</code>.<br/>
what's the reason for this behavior?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is by design and intentional. CPython temporarily "disallows" access to the list while the list is being sorted in place, the behavior is <a href="https://docs.python.org/3/library/stdtypes.html#list.sort">documented here</a>:</p>
<blockquote>
<p><strong>CPython implementation detail:</strong> <em>While a list is being sorted, the
  effect of attempting to mutate, or even inspect, the list is
  undefined.</em> The C implementation of Python makes the list appear empty
  for the duration, and raises ValueError if it can detect that the list
  has been mutated during a sort.</p>
</blockquote>
<p>You can inspect that by printing <code>A</code> inside the key function - you'll get an <em>empty list</em>:</p>
<pre><code>In [2]: def key_function(x):
    ...:     print(A, x)
    ...:     return A.count(x)
    ...: 

In [3]: A.sort(key=key_function)  
([], 2)
([], 1)
([], 3)
([], 4)
([], 2)
([], 2)
([], 3)
</code></pre>
<p>But, if you do that for <code>sorted()</code>:</p>
<pre><code>In [4]: sorted(A, key=key_function)
([2, 1, 3, 4, 2, 2, 3], 2)
([2, 1, 3, 4, 2, 2, 3], 1)
([2, 1, 3, 4, 2, 2, 3], 3)
([2, 1, 3, 4, 2, 2, 3], 4)
([2, 1, 3, 4, 2, 2, 3], 2)
([2, 1, 3, 4, 2, 2, 3], 2)
([2, 1, 3, 4, 2, 2, 3], 3)
Out[4]: [1, 4, 3, 3, 2, 2, 2]
</code></pre>
<hr/>
<p>It is also documented inside the <a href="https://github.com/python/cpython/blob/b9e40ed1bcce127893e40dd355087cda7187ac27/Objects/listobject.c#L1933"><code>sort()</code> implementation</a>:</p>
<pre><code>/* The list is temporarily made empty, so that mutations performed
 * by comparison functions can't affect the slice of memory we're
 * sorting (allowing mutations during sorting is a core-dump
 * factory, since ob_item may change).
 */.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems that <code>A</code> is changed during the in-place sort process, so you cannot rely on the value of <code>A</code> during the sort process.</p>
<p>Making a copy also works.</p>
<pre><code>A=[2,1,3,4,2,2,3]
B=A[:]
A.sort(key=lambda x:B.count(x))
print(A)
</code></pre>
<p>Confirmed by this line in <a href="https://docs.python.org/3/library/stdtypes.html#list" rel="nofollow noreferrer">python documentation</a></p>
<blockquote>
<p>CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I believe it's because <code>A.sort</code> is modifying the list in place underneath while computing. <code>sorted()</code> doesn't modify the list and returns therefore a correct result.</p>
</div>
<div class="post-text" itemprop="text">
<p>The built-in <a href="https://github.com/python/cpython/blob/master/Python/bltinmodule.c#L2125" rel="nofollow noreferrer"><code>sorted</code> <em>creates a list out of the sequence</em></a> provided and then sorts that based on the key argument (omitting error checking):</p>
<pre><code>/* copy sequence provided */
newlist = PySequence_List(seq);

/* get list.sort for the list object */
callable = _PyObject_GetAttrId(newlist, &amp;PyId_sort);

/* call it and then return later on */
v = _PyObject_FastCallKeywords(callable, args + 1, nargs - 1, kwnames);
</code></pre>
<p>This essentially translates to something like what Jean provided in his answer:</p>
<pre><code>B = list(A)
B.sort(key=lambda x: A.count(x))
</code></pre>
<p>By making that copy <code>B</code> and referencing <code>A</code> in the <code>key</code> function, this removes the restriction imposed by <code>A.sort</code> which can't peek in itself.</p>
</div>
<span class="comment-copy">Side note, you don't need <code>lambda</code>, e.g. <code>A.sort(key = A.count)</code></span>
<span class="comment-copy">This returns the number of occurencies for each element in A: <code>[A.count(element) for element in set(A)]</code></span>
<span class="comment-copy">Using a <code>Counter</code> (<code>A.sort(key=collections.Counter(A).get)</code>) here would be more efficient and would work for both <code>sort</code> and <code>sorted</code>.</span>
<span class="comment-copy">Python objects are distinguished two types of that mutable and immutable. If a value in mutable object changes, it affects original data. Because of that <code>list object</code> is mutable, the index of data is changing dynamically.</span>
<span class="comment-copy">it's not because it's documented that it doesn't suck :)</span>
<span class="comment-copy">This restriction probably shouldn't apply to <code>key=</code> functions.  I'd suggest filing a bug report at <a href="http://bugs.python.org/" rel="nofollow noreferrer">bugs.python.org</a></span>
<span class="comment-copy">Whoa! Principle of Least Astonishment violated. An error would be an improvement, imo.</span>
<span class="comment-copy">That doesn't sound like an implementation detail to me.</span>
<span class="comment-copy">I'm not sure this is a full answer, seems like more of a guess ;)</span>
<span class="comment-copy">A right guess then :)</span>
<span class="comment-copy">@Chris_Rands it <i>was</i> a guess, but now I've found backup in the documentation :) shoot, accepted answer has it right from the start :)</span>
