<div class="post-text" itemprop="text">
<p>I'm writing an implementation of doubly linked lists. In order to traverse the list, I'm using something like:</p>
<pre><code>class Node:
    """ A node in our linked list """
    def __init__(self, value: Any, next: Union['Node', None] =None,
            previous: Union['Node', None] =None) -&gt; None:
        self.value = value
        self.next = next
        self.previous = previous

    ...

    def __next__(self, direction: int =1) -&gt; Union['Node', None]:
        if direction == 1:
            return self.get_next()
        else:
            return self.get_previous()

    ...
</code></pre>
<p>where <code>get_next</code> and <code>get_previous</code> are just getters of <code>self.next</code> and <code>self.previous</code>. </p>
<p>However, PyCharm yells at me for trying to call <code>next</code> as
<code>next(some_node, direction=-1)</code>. What's the proper way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Besides <code>__iter__</code> there is also <code>__reversed__</code>. Both are required to return <code>iterators</code>. The <code>__next__</code> method should be implemented on <code>iterators</code> (not on node-classes). Note that all magic methods (when called by a function like <code>next</code> instead of directly invoked) need to implement the <strong>expected arguments</strong> not more - not less.</p>
<p>For example a doubly linked list could just implement <code>__iter__</code> and <code>__reversed__</code> and rely on <code>next</code> and <code>previous</code> attribute of the Node:</p>
<pre><code>class Node(object):
    def __init__(self, val, nxt, prv):
        self.val = val
        self.nxt = nxt
        self.prv = prv


class DoublyLinkedList(object):
    def __init__(self, base=None, last=None):
        self.base = base
        self.last = last

    def prepend(self, val):
        new = Node(val, self.base, None)
        if self.base is None:
            self.base = new
            self.last = new
        else:
            self.base.prv = new
            self.base = new

    def append(self, val):
        new = Node(val, None, self.last)
        if self.last is None:
            self.base = new
            self.last = new
        else:
            self.last.nxt = new
            self.last = new

    def __iter__(self):
        current = self.base
        while current is not None:
            yield current
            current = current.nxt

    def __reversed__(self):
        current = self.last
        while current is not None:
            yield current
            current = current.prv
</code></pre>
<p>For example:</p>
<pre><code>dl = DoublyLinkedList()
dl.prepend(10)
dl.prepend(20)
dl.prepend(30)

for i in dl:
    print(i.val)
</code></pre>
<p>gives:</p>
<pre><code>30
20
10
</code></pre>
<p>similar for <code>reversed</code>:</p>
<pre><code>for i in reversed(dl):
    print(i.val)

# prints:
10
20
30
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The extra argument to <code>next</code> is a default value, and <code>__next__</code> doesn't take any extra arguments. Python doesn't have any sort of two-way iterators. If your interface is not exactly the same as <code>for i in obj:</code>, then you should write your own.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__next__</code> is part of the <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">iterator protocol</a> and should be used as described in said protocol, doing otherwise only make problems with the rest python.</p>
<p>In your case just rename the function to simple <code>next</code> and use as <code>some_node.next(-1)</code>, though I would change the <code>direction</code> argument to a boolean, as that is how you use it, and its name too. Like this for example</p>
<pre><code>class None: 
    ...

    def next(self, forward:bool=True) -&gt; Union['Node', None]:
        if forward:
            return self.get_next()
        else:
            return self.get_previous()
</code></pre>
<p>and use as <code>some_node.next()</code>, <code>some_node.next(False)</code> or even <code>some_node.next(0)</code> (using 0 instead of False for the same effect)</p>
</div>
<span class="comment-copy">You can't just add arbitrary arguments to magic methods, you need to match the data model definition. If you want to offer an iterator the other way, that's <a href="https://docs.python.org/3/reference/datamodel.html#object.__reversed__" rel="nofollow noreferrer"><code>__reversed__</code></a>.</span>
<span class="comment-copy">Thank you, this was <i>really</i> helpful.</span>
