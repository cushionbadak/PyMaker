<div class="post-text" itemprop="text">
<p>I have a method in my <code>Enemy</code> class called <code>huntPlayer</code>.  It takes a player object <code>p</code>. Here it is:</p>
<pre><code>def huntPlayer(self, p):   
  if self.dist2p &lt; 200:
    self.hunting = True
    if p.x &gt; self.rect.x:
      self.rect.x += self.speed #this is a constant at value 1
    elif p.x &lt; self.rect.x:
      self.rect.x -= self.speed
    else:
      self.rect.x += 0
    if p.y &gt; self.rect.y:
      self.rect.y += self.speed
    elif p.y &lt; self.rect.y:
      self.rect.y -= self.speed 
    else:
      self.rect.y += 0
  else:
    self.rect.x += 0
    self.rect.y += 0
</code></pre>
<p>The enemies are randomly placed around a 2d top down plain, they randomly roam this plain.  I have calculated the hypotenuse which is shortest distance to the player = <code>Enemy.dist2p</code> -- When the <code>dist2p</code> value &lt; 200. The enemy will move towards player, <code>p.x</code> and <code>p.y</code> respectively. </p>
<p>My solution above is crude so therefore my problem is the enemy equally moves 1 place on the x or y axis resulting in a diagonal movement to each axis, then sliding along the axis until it reaches the player.  (The player is in a fixed position near the centre screen.)</p>
<p>Can you help me fix the <code>huntPlayer</code> method/algorithm so the enemy follows the hypotenuse path to the player, rather than quickest path to x/y axis?</p>
<p>EDIT: If you need any further info I may have left out, let me know. </p>
</div>
<div class="post-text" itemprop="text">
<p>Moving on the hypotenuse will most likely require your object to move less than one pixel each frame in either the y or x-axis, and since <code>rects</code> only can hold integers you'd need a new attribute <code>position</code> which contains the position of the sprite in float precision. You can use <code>pygame.math.Vector2</code> to create a vector with useful methods such as <code>normalize()</code> and adding, subtracting, multiplying with other vectors etc.</p>
<p>Assuming you've created an attribute <code>self.position = pygame.math.Vector2(0, 0)</code> (or whatever position you want it to start on) you could do something like this: </p>
<pre><code>def hunt_player(self, player):
    player_position = pygame.math.Vector2(player.rect.topleft)
    direction = player_position - self.position
    velocity = direction.normalize() * self.speed

    self.position += velocity
    self.rect.topleft = self.position
</code></pre>
<p>By subtracting the player's position with the enemy's position, you'll get a vector that points from the enemy to the player. If we would to add the direction vector to our position we would teleport to the player immediately. Instead we normalize the vector (making it to length 1 pixel) and multiply our speed attribute. The newly created vector will be an vector pointing towards the player with the length of our speed.</p>
<h2>Full example</h2>
<pre><code>import pygame
pygame.init()


SIZE = WIDTH, HEIGHT = 720, 480
FPS = 60
BACKGROUND_COLOR = pygame.Color('white')

screen = pygame.display.set_mode(SIZE)
clock = pygame.time.Clock()


class Hunter(pygame.sprite.Sprite):

    def __init__(self, position):
        super(Hunter, self).__init__()

        self.image = pygame.Surface((32, 32))
        self.image.fill(pygame.Color('red'))
        self.rect = self.image.get_rect(topleft=position)
        self.position = pygame.math.Vector2(position)
        self.speed = 2

    def hunt_player(self, player):
        player_position = player.rect.topleft
        direction = player_position - self.position
        velocity = direction.normalize() * self.speed

        self.position += velocity
        self.rect.topleft = self.position

    def update(self, player):
        self.hunt_player(player)


class Player(pygame.sprite.Sprite):

    def __init__(self, position):
        super(Player, self).__init__()

        self.image = pygame.Surface((32, 32))
        self.image.fill(pygame.Color('blue'))
        self.rect = self.image.get_rect(topleft=position)

        self.position = pygame.math.Vector2(position)
        self.velocity = pygame.math.Vector2(0, 0)
        self.speed = 3

    def update(self):
        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT]:
            self.velocity.x = -self.speed
        elif keys[pygame.K_RIGHT]:
            self.velocity.x = self.speed
        else:
            self.velocity.x = 0

        if keys[pygame.K_UP]:
            self.velocity.y = -self.speed
        elif keys[pygame.K_DOWN]:
            self.velocity.y = self.speed
        else:
            self.velocity.y = 0

        self.position += self.velocity
        self.rect.topleft = self.position

player = Player(position=(350, 220))
monster = Hunter(position=(680, 400))
running = True
while running:

    clock.tick(FPS)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    player.update()
    monster.update(player)

    screen.fill(BACKGROUND_COLOR)
    screen.blit(player.image, player.rect)
    screen.blit(monster.image, monster.rect)

    pygame.display.update()
</code></pre>
<h2>Result</h2>
<p><a href="https://i.stack.imgur.com/bef2Y.gif" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/bef2Y.gif"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Since we want to move along the hypotenuse we can use Pythagoras theorem. Here's a brief snippet the should give you the general idea.</p>
<p>I'll use <code>p.x, p.y</code> for the player's position and <code>e.x, e.y</code> for the enemy's position. </p>
<pre><code># Find the horizontal &amp; vertical distances between player &amp; enemy
dx = p.x - e.x
dy = p.y - e.y

#Get the hypotenuse
d = sqrt(dx*dx + dy*dy)

#Calculate the change to the enemy position
cx = speed * dx / d
cy = speed * dy / d
# Note that sqrt(cx*cx + cy*cy) == speed

# Update enemy position
e.x += cx
e.y += cy
</code></pre>
<p>You need to add some extra code to this to make sure that <code>d</code> isn't zero, or you'll get a division by zero error, but that only happens when the enemy reaches the player, so I assume you want to do something special when that happens anyway. :)</p>
<p>I should mention that this technique works best if the positions are floats, not integer pixel coordinates.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just calculating the distance based on the hypotenuse is not enough. You must pass the coordinates of the enemy into the function and calculate the slope or pass the slope also into the function by value. Then you should move to one of 8 pixels around about your current position where the one you move to is most representative of the path of direction to the enemy. Essentially you move diagonally if the tan of the angle is less than 2 or great that 1/2 otherwise you move in a vertical or horizontal direction. You need to draw a 3x3 set of pixels to see what is actually going on if you can't visualise it.</p>
<p><a href="https://i.stack.imgur.com/h2AsS.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/h2AsS.png"/></a></p>
</div>
<span class="comment-copy">Hint: Instead of considering each coordinate separately, it might help to store an enemy's velocity as a vector.</span>
<span class="comment-copy">Hi Jack, I'm an enthusiastic noob at game development, would you mind elaborating on using velocity?  Am I going the completely wrong way about how the enemy moving to player is implemented?</span>
<span class="comment-copy">...velocity is a vector quantity. That means it has magnitude and direction. <a href="https://en.wikipedia.org/wiki/Velocity" rel="nofollow noreferrer">en.wikipedia.org/wiki/Velocity</a></span>
<span class="comment-copy">Thank you - very informative.</span>
<span class="comment-copy">Great answer. I thought I had posted almost the same answer as well, but that must have been on another website. Personally I always write <code>self.velocity.x</code> instead of <code>self.velocity[0]</code> but that's no problem. And congrats for 2000 points. :)</span>
<span class="comment-copy">@skrx Thanks! Yes, that's a good point! I have to edit the answer anyway since I've noticed a couple of spelling errors :P</span>
<span class="comment-copy">Thankyou - very helpful.</span>
<span class="comment-copy">The <code>math</code> module has a <a href="https://docs.python.org/3/library/math.html#math.hypot" rel="nofollow noreferrer"><code>hypot</code></a> function to compute <code>sqrt(x*x + y*y)</code> which is likely faster than doing it in pure Python.</span>
