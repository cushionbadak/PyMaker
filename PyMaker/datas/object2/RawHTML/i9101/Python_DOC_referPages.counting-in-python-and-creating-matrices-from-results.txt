<div class="post-text" itemprop="text">
<p>I have a set of tags I care about counting. Let's say they are:</p>
<pre><code>pos_tags = ["NN", "NNS", "JJ"]
</code></pre>
<p>I want my program to iterate through a list of sentences that perhaps looks like this:</p>
<pre><code>sents = ["I want to go home.", "I have five dollars.", "The grass is green and wet."]
</code></pre>
<p>I used nltk.pos_tag to label each word with the result being:</p>
<pre><code>['I', 'want', 'to', 'go', 'home', '.']
[('I', 'PRP'), ('want', 'VBP'), ('to', 'TO'), ('go', 'VB'), ('home', 'NN'), ('.', '.')]
['I', 'have', 'five', 'dollars', '.']
[('I', 'PRP'), ('have', 'VBP'), ('five', 'CD'), ('dollars', 'NNS'), ('.', '.')]
['The', 'grass', 'is', 'green', 'and', 'wet', '.']
[('The', 'DT'), ('grass', 'NN'), ('is', 'VBZ'), ('green', 'JJ'), ('and', 'CC'), ('wet', 'NN'), ('.', '.')]
</code></pre>
<p>I want to check if there are any words in here that have the pos_tags and I think I have seem to accomplished that; however, I am having huge amounts of trouble returning the result in the form that I want, which is a matrix style.</p>
<p>The rows would be the number of sentences there are. In this case, 3. The columns would be the number of tags there are. In this case, also 3.</p>
<p>The final result would look like:</p>
<pre><code>[1, 0, 0 
 0, 1, 0
 2, 0, 1]
</code></pre>
<p>This is what I have so far:</p>
<pre><code>def tagging(sents):

    matrix = []
    pos_tags = ["NN", "NNS", "JJ"]

    for sent in sents:

        tokens = nltk.word_tokenize(sent)

        tagged_tokens = nltk.pos_tag(tokens)
        tagged_tokens_final = tagged_tokens


    for key, val in tagged_tokens_final:
        if val in common_pos_tags:
            counting = val.count(val)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>there are various Matrix types in Python, Libs, but I just made a list of lists </p>
<pre><code>s1 = ['I', 'want', 'to', 'go', 'home', '.']
ts1 = [('I', 'PRP'), ('want', 'VBP'), ('to', 'TO'), ('go', 'VB'), ('home', 'NN'), ('.', '.')]
s2 = ['I', 'have', 'five', 'dollars', '.']
ts2 = [('I', 'PRP'), ('have', 'VBP'), ('five', 'CD'), ('dollars', 'NNS'), ('.', '.')]
s3 = ['The', 'grass', 'is', 'green', 'and', 'wet', '.']
ts3 = [('The', 'DT'), ('grass', 'NN'), ('is', 'VBZ'), ('green', 'JJ'), ('and', 'CC'), ('wet', 'NN'), ('.', '.')]

pos_tags = ["NN", "NNS", "JJ"]
</code></pre>
<p>a nested list comprehension does fine here constructing the list of lists<br/>
the <code>sum(sen,())</code> flattens the list of tuples - but isn't the most recommended for performance</p>
<pre><code>tagd_sents = [ts1, ts2, ts3]

tagm = [[sum(sen,()).count(tag) for tag in pos_tags] for sen in tagd_sents]

print(*tagm, sep='\n')
[1, 0, 0]
[0, 1, 0]
[2, 0, 1]
</code></pre>
<p>Mad Physicist is correct about the quick and dirty above counting tags that are also words in the sentence, respecting the data structure would be safer</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of different ways of approaching this problem. Probably the easiest is to notice that each sentence is handled independently of the others. You can therefore put all the operations for one sentence into a single function and then run it for each sentence independently:</p>
<pre><code>tags = ['NN', 'NNS', 'JJ'] 

matrix = [None] * len(sents)
for index, sent in enumerate(sents):
    matrix[index] = do_counting(sent, tags)
</code></pre>
<p>If you prefer to expand the matrix dynamically instead of preallocating with <code>[None] * len(sents)</code>, you can do that too:</p>
<pre><code>matrix = []
for sent in sents:
    matrix.append(do_counting(sent, tags))
</code></pre>
<p>In both cases, <code>do_counting</code> is a function that takes a sentence string and a list of tags, returning a single row of the matrix. The tags are an input in case you decide to change the order or names of the tags you are interested in. The output will always match the input list.</p>
<p>The parsing will be done with <code>nltk</code> the same way you have already figured out to do. The counting is most easily accomplished with a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> object, which is pretty much made for the purpose. It will count the number of occurrences of each tag. We can then select the tags we want based on the list you pass in as the second argument:</p>
<pre><code>from collections import Counter
def do_counting(sentence, tags)
    tokens = nltk.word_tokenize(sent)
    tagged_tokens = nltk.pos_tag(tokens)
    counts = Counter(tag for _, tag in tagged_tokens)
    tag_counts = [counts[tag] for tag in tags]
    return tag_counts
</code></pre>
<p>Notice that I ignore the tokens for the purposes of counting. <code>_</code> is a valid variable name in Python, but is conventionally used to indicate discarded parameters. The counter could have been written as</p>
<pre><code>counts = Counter(item[0] for item in tagged_tokens)
</code></pre>
<p>It would not be too difficult to do the counting yourself instead of using <code>Counter</code>:</p>
<pre><code>def do_counting(sentence, tags)
    tokens = nltk.word_tokenize(sent)
    tagged_tokens = nltk.pos_tag(tokens)
    counts = [sum(items[1] == tag for items in tagged_tokens) for tag in tags]
    return counts
</code></pre>
<p>Hopefully I have layed out an approach you can follow, but more importantly understand. I have tried to present you with a couple of options for doing some of the tasks to give you a feel for the possibilities as you study more on your own.</p>
</div>
<span class="comment-copy">Definitely upvoting this for a clever approach. Particularly <code>sum(sen, ())</code> made my day. That being said, this will fail if one of the tags appears as-is in a sentence. <code>sum(x[1] for x in sen, ())</code> might be a better alternative. A triple-nested comprehension that is still quite legible :)</span>
<span class="comment-copy">Thanks so much your thorough explanation - the counting part especially helped! For the matrix part, I ended up using np.array in the numpy library - worked like a charm!</span>
<span class="comment-copy">No problem. You can creat a numpy array out of the final result, or use one to fill in from the start. I wanted to stick to core Python for this answer because it seemed like you wanted something more basic.</span>
