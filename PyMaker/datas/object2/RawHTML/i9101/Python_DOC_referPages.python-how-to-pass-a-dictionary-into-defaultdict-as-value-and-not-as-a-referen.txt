<div class="post-text" itemprop="text">
<p>So say that I have a dictionary with a default value of another dictionary</p>
<pre><code>attributes = { 'first_name': None, 'last_name': None, 'calls': 0 }
accounts = defaultdict(lambda: attributes)
</code></pre>
<p>The problem is that the default dictionary that I pass into defaultdict (attributes) is passed as a reference. How can I pass it as a value? So that changing the values in one key doesn't change the values in other keys</p>
<p>For example - </p>
<pre><code>accounts[1]['calls'] = accounts[1]['calls'] + 1
accounts[2]['calls'] = accounts[2]['calls'] + 1
print accounts[1]['calls'] # prints 2
print accounts[2]['calls'] # prints 2
</code></pre>
<p>I want each of them to print 1, since I only incremented their respective values for 'calls' once.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try:</p>
<pre><code>accounts = defaultdict(attributes.copy)
</code></pre>
<p>Since Python 3.3 <code>lists</code>s <a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="nofollow noreferrer">also have <code>copy</code> method</a> so you can use it the same way as above with <code>defaultdict</code>s when you need a dict with a list as a default value.</p>
</div>
<div class="post-text" itemprop="text">
<p>I really like warvariuc's solution. However,  remember, you are not passing a <code>dict</code> into <code>defaultdict</code>... that would result in a <code>TypeError</code>, because that argument must be a <em>callable</em>. You could have just used a literal in a lambda. Or better yet, define a helper function:</p>
<pre><code>&gt;&gt;&gt; def attribute():
...     return { 'first_name': None, 'last_name': None, 'calls': 0 }
...
&gt;&gt;&gt; accounts = defaultdict(attribute)
&gt;&gt;&gt; accounts[1]['calls'] = accounts[1]['calls'] + 1
&gt;&gt;&gt; accounts[2]['calls'] = accounts[2]['calls'] + 1
&gt;&gt;&gt; print(accounts[1]['calls'])
1
&gt;&gt;&gt; print(accounts[2]['calls'])
1
</code></pre>
</div>
<span class="comment-copy">You have to explicitly make a copy if that is what you want. Passing parameters always is like passing a reference.</span>
<span class="comment-copy">Python has one and only one evaluation strategy: <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" rel="nofollow noreferrer">call by sharing</a>.</span>
<span class="comment-copy">You will like this: <a href="http://stackoverflow.com/questions/3975376/understanding-dict-copy-shallow-or-deep/3975388#3975388" title="understanding dict copy shallow or deep">stackoverflow.com/questions/3975376/â€¦</a></span>
<span class="comment-copy">ooooooo very clever!</span>
<span class="comment-copy">Yep! The factory can be any function that returns the value you want to use for missing keys (as long as it can be called without arguments), <code>attributes.copy</code> is just such a function!</span>
<span class="comment-copy">Yep! works flawlessly</span>
