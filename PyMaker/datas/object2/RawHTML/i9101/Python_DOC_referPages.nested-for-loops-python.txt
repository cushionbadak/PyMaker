<div class="post-text" itemprop="text">
<p>I am trying to build a decoding function. This function should find the distance between the letters in 'phrase' and the letters in 'key' and the distance should be followed by the corresponding letter in 'key'. </p>
<p>For example, let the 'phrase' = 'hello' and the 'key' = 'sam' then, since 'h' is 11 letters away from 's', one iteration through the function should return 's11'</p>
<p>I have no clue as to why my 'decode_phrase' function is not working.</p>
<pre><code>def get_distance(letter1, letter2):

    if letter1 &lt; letter2:
        x = (ord(letter2) - ord(letter1))
    elif letter1 == letter2:
        x = 0
    elif letter1 &gt; letter2:
        x = (ord(letter2) - ord(letter1)) + 26
    return x



def decode_phrase(phrase, key):


    new_word = ''
    i = 0
    k = 0

    for p in range(len(phrase)):
        for q in range(len(key)):
            y = get_distance(phrase[i], key[k])
            new_word = new_word + key[k] + str(y)
            k = k +1
            i = i +1
    return new_word
</code></pre>
<p>When I input decode_phrase('mike','sam') I am currently getting string index out of range.  But there are more serious issues to the code than that I am sure</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're supposed to repeat the key string when you get to its end, then you only need one loop, generating an index into the phrase. You can use the <code>%</code> modulus operator to get a second index into the key, wrapping around if necessary:</p>
<pre><code>def decode_phrase(phrase, key):
    for i in range(len(phrase)): # use just one loop for the phrase index
        j = i % len(key)         # take a mod to get a key index
        y = get_distance(phrase[i], key[j])
        new_word += key[j] + str(y)
    return new_word
</code></pre>
<p>That is probably the simplest solution when <code>phrase</code> and <code>key</code> are strings. But if you wanted to be a bit fancy, you could use <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle</code></a> to make a version that would work for any kind of iterable (not only indexable sequences):</p>
<pre><code>import itertools

def decode_phrase(phrase, key):
    for p, k in zip(phrase, itertools.cycle(key)):
        new_word += k + str(get_distance(p, k))
    return new_word
</code></pre>
</div>
<span class="comment-copy">Do not post pictures of code, place the code in your question</span>
<span class="comment-copy">Also provide more information as to how decode_phrase is not working. Provide an example of what it returns when given a specific input, and what you expect it to return.</span>
<span class="comment-copy">BTW <code>get_distance</code> can be made quite simpler: something like <code>x = ord(letter2) - ord(letter1); if x &lt; 0: x += 26</code> would suffice.</span>
<span class="comment-copy">Post a full traceback</span>
<span class="comment-copy">What is your function supposed to do when the length of the key is less than the length of the phrase? Does the key repeat? If so, you probably want to have just one loop for an index, and you can use <code>key[i % len(key)]</code> to get the appropriate character from the key.</span>
