<div class="post-text" itemprop="text">
<p>I have a list of namedtuples that can be quite long (for the moment it can reach 10.000 rows but in the future it could be much more). </p>
<p>I need to compare several elements of each namedtuple with all other namedtuples from the list. I am looking for an <strong>efficient and generic way</strong> to do so.</p>
<p>For simplicity, I will make an analogy with cakes, that should make understanding the problem easier.</p>
<p>Having a list of namedtuples, where each namedtuple is a cake:</p>
<pre><code>Cake = namedtuple('Cake', 
                       ['cake_id',
                        'ingredient1', 'ingredient2', 'ingredient3',
                        'baking_time', 'cake_price']
                 )
</code></pre>
<p>Both <code>cake_price</code> and <code>baking_time</code> are important. If the cakes have the same ingredients, I want to remove from the list the ones that are not relevant. So any cake (with the same ingredients) that is both equal or more expensive and takes same or longer to bake is not relevant (below there is a detailed example).</p>
<p>What would be the best way to do it?</p>
<hr/>
<h1>Approach</h1>
<p>What I have done so far is to sort the list of named_tuples by <code>cake_price</code> and <code>baking_time</code>:</p>
<pre><code>sorted_cakes = sorted(list_of_cakes, key=lambda c: (c.cake_price, c.baking_time))
</code></pre>
<p>And then creating a new list where I am adding all cakes as long as no cake previously added has the same ingredients, is cheaper and faster to bake.</p>
<pre><code>list_of_good_cakes = []
    for cake in sorted_cakes:
        if interesting_cake(cake, list_of_good_cakes):
            list_of_good_cakes.append(cake)

def interesting_cake(current_cake, list_of_good_cakes):
    is_interesting = True
    if list_of_good_cakes: #first cake to be directly appended
        for included_cake in list_of_good_cakes:
            if (current_cake.ingredient1 == included_cake.ingredient1 and
                current_cake.ingredient2 == included_cake.ingredient2 and
                current_cake.ingredient3 == included_cake.ingredient3 and
                current_cake.baking_time &gt;= included_cake.baking_time):

                if current_cake.cake_price &gt;= included_cake.cake_price:
                    is_interesting = False

    return is_interesting
</code></pre>
<p>(I know that having a nested loop is far from optimal, but I cannot think of any other way to do it...)</p>
<hr/>
<h1>Example:</h1>
<p>Having</p>
<pre><code>list_of_cakes = [cake_1, cake_2, cake_3, cake_4, cake_5]
</code></pre>
<p>where</p>
<pre><code>cake_1 = Cake('cake_id'=1,
              'ingredient1'='dark chocolate', 
              'ingredient2'='cookies', 
              'ingredient3'='strawberries',
              'baking_time'=60, 'cake_price'=20)

cake_2 = Cake('cake_id'=2,
              'ingredient1'='dark chocolate', 
              'ingredient2'='cookies', 
              'ingredient3'='strawberries',
              'baking_time'=80, 'cake_price'=20)

cake_3 = Cake('cake_id'=3,
              'ingredient1'='white chocolate', 
              'ingredient2'='bananas', 
              'ingredient3'='strawberries',
              'baking_time'=150, 'cake_price'=100)

cake_4 = Cake('cake_id'=4,
              'ingredient1'='dark chocolate', 
              'ingredient2'='cookies', 
              'ingredient3'='strawberries',
              'baking_time'=40, 'cake_price'=30)

cake_5 = Cake('cake_id'=5,
              'ingredient1'='dark chocolate', 
              'ingredient2'='cookies', 
              'ingredient3'='strawberries',
              'baking_time'=10, 'cake_price'=80)
</code></pre>
<p>The expected result would be:</p>
<pre><code>list_of_relevant_cakes = [cake_1, cake_3, cake_4, cake_5]
</code></pre>
<ul>
<li>cake_1 is the cheapest (and the fastest among the same price) --&gt; IN</li>
<li>cake_2 has the same price as cake1 and takes longer to bake --&gt; OUT</li>
<li>cake_3 is a different kind of cake --&gt; IN</li>
<li>cake_4 is more expensive than cake_1, but faster to bake --&gt; IN</li>
<li>cake_5 is more expensive than cake_1 and cake_4, but even faster to bake --&gt; IN</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The running time of your approach is going to be roughly proportional to </p>
<pre><code>len(list_of_cakes) * len(list_of_relevant_cakes)
</code></pre>
<p>... which could get quite large, if you have a lot of cakes and a lot of them are relevant.</p>
<p>We can improve on this by taking advantage of the fact that each cluster of cakes with the same ingredients is likely to be much smaller. First of all, we need a function that checks a new cake against an existing, already optimized cluster with the same ingredients:</p>
<pre><code>from copy import copy

def update_cluster(cakes, new):
    for c in copy(cakes):
        if c.baking_time &lt;= new.baking_time and c.cake_price &lt;= new.cake_price:
            break
        elif c.baking_time &gt;= new.baking_time and c.cake_price &gt;= new.cake_price:
            cakes.discard(c)
    else:
        cakes.add(new)
</code></pre>
<p>What this does is check the <code>new</code> cake against each cake <code>c</code> in a copy of <code>cakes</code>, and then:</p>
<ol>
<li><p>If its baking time and price are both greater than or equal to an existing cake, immediately exit (you could <code>return</code> rather than <code>break</code>ing, but I prefer to be explicit about control flow).</p></li>
<li><p>If its baking time and price are both less than or equal to an existing cake, remove that existing cake from the cluster</p></li>
<li><p>If it makes it past all the existing cakes (and so reaches the <code>for</code> statement's <code>else</code> clause), add it to the cluster.</p></li>
</ol>
<p>Once we have that, we can use it to filter the cakes:</p>
<pre><code>def select_from(cakes):
    clusters = {}
    for cake in cakes:
        key = cake.ingredient1, cake.ingredient2, cake.ingredient3
        if key in clusters:
            update_cluster(clusters[key], cake)
        else:
            clusters[key] = {cake}
    return [c for v in clusters.values() for c in v]
</code></pre>
<p>Here it is in action:</p>
<pre><code>&gt;&gt;&gt; select_from(list_of_cakes)
[Cake(cake_id=1, ingredient1='dark chocolate', ingredient2='cookies', ingredient3='strawberries', baking_time=60, cake_price=20),
 Cake(cake_id=4, ingredient1='dark chocolate', ingredient2='cookies', ingredient3='strawberries', baking_time=40, cake_price=30),
 Cake(cake_id=5, ingredient1='dark chocolate', ingredient2='cookies', ingredient3='strawberries', baking_time=10, cake_price=80),
 Cake(cake_id=3, ingredient1='white chocolate', ingredient2='bananas', ingredient3='strawberries', baking_time=150, cake_price=100)]
</code></pre>
<p>The running time of this solution is roughly proportional to</p>
<pre><code>len(list_of_cakes) * len(typical_cluster_size)
</code></pre>
<p>I did a little testing with a list of random cakes, each using a selection from your five different ingredients and random prices and baking times, and </p>
<ol>
<li><p>This approach consistently produces the same results as yours (albeit unsorted)</p></li>
<li><p>It runs considerably faster â€“ 0.2 seconds on my machine for 100,000 random cakes, compared to about three seconds for yours.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Untested code, but should help point to a better way:</p>
<pre><code>equivalence_fields = operator.attrgetter('ingredient1', 'ingredient2', 'ingrediant3')
relevant_fields = operator.attrgetter('baking_time', 'cake_price')

def irrelevent(cake1, cake2):
    """cake1 is irrelevant if it is both
       more expensive and takes longer to bake.
    """
    return cake1.cake_price &gt; cake2.cake_price and cake1.baking_time &gt; cake2.bake_time

# Group equivalent cakes together
equivalent_cakes = collections.defaultdict(list)
for cake in cakes:
    feature = equivalence_fields(cake)
    equivalent_cakes[feature].append(cake)

# Weed-out irrelevant cakes within an equivalence class
for feature, group equivalent_cakes.items():
    best = min(group, key=relevant_fields)
    group[:] = [cake for cake in group if not irrelevant(cake, best)]
</code></pre>
</div>
<span class="comment-copy">Brilliant! I adapted it to my real case. Testing it with a list of 5330 namedtuples the difference is huge. Running times before: <code>25.2s</code>, <code>14.1s</code>, <code>14.8s</code>; running times after: <code>0.04s</code>, <code>0.2s</code>, <code>0.04s</code>. Just one question that confused me: How does the <code>else</code> in <code>update_cluster</code> function work? It does not have the same indent as the <code>if</code> clause, so at the beginning, I thought it was a typo. Then I realized the results were not properly calculated unless the <code>else</code> was indented as you wrote it...</span>
<span class="comment-copy">Glad it helped :-) The <code>else</code> in <code>update_cluster()</code> is attached to the <code>for</code>, not the <code>if</code> ... documentation for the <code>for-else</code> construct is <a href="https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops" rel="nofollow noreferrer">here</a>, and a nice explanatory article is <a href="http://python-notes.curiousefficiency.org/en/latest/python_concepts/break_else.html" rel="nofollow noreferrer">here</a>. Basically, it runs if the <code>break</code> isn't triggered.</span>
