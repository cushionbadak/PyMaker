<div class="post-text" itemprop="text">
<p>I have two dictionaries:</p>
<pre><code>dict1 = {'a': 1,
         'b': 2,
         'c': 3,
         'd': 4,
         'x': 5}
</code></pre>
<p>and</p>
<pre><code>dict2 = {'a': 'start',
         'b': 'start',
         'c': 'end',
         'd': 'end'}
</code></pre>
<p>I am trying to create a new dictionary that maps the values <code>start</code> and <code>end</code> as keys to a dictionary that would contain the info of <code>dict1</code>, while keeping those that are not present in <code>dict2</code> as keys, e.g.:</p>
<pre><code>dict3 = {'start': {'a': 1, 'b': 2},
         'end': {'c': 3, 'd': 4},
         'x': {'x': 5}
        }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault()</code></a> to create the nested dictionaries in <code>dict3</code> if not yet there, and <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><code>dict.get()</code></a> to determine the key in the top-level output dictionary:</p>
<pre><code>dict3 = {}
for k, v in dict1.items():
    nested = dict3.setdefault(dict2.get(k, k), {})
    nested[k] = v
</code></pre>
<p>So <code>dict2.get(k, k)</code> will produce the value from <code>dict2</code> for a given key from <code>dict1</code>, using the key itself as a default. So for the <code>'x'</code> key, that'll produce <code>'x'</code> as there is no mapping in <code>dict2</code> for that key.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; dict3 = {}
&gt;&gt;&gt; for k, v in dict1.items():
...     nested = dict3.setdefault(dict2.get(k, k), {})
...     nested[k] = v
...
&gt;&gt;&gt; dict3
{'start': {'a': 1, 'b': 2}, 'end': {'c': 3, 'd': 4}, 'x': {'x': 5}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I actually figured it out while abstracting the example and typing up my question here (should have maybe done this earlier...). Anyways: Yay!</p>
<p>So here is my solution, in case it may help someone. If someone knows a swifter or more elegant way to do it, I would be glad to learn!</p>
<pre><code>dict3 = dict()

for k, v in dict1.items():
    # if the key of dict1 exists also in dict2
    if k in dict2.keys():
        # get its value (the keys-to-be for the new dict3)
        new_key = dict2[k]
        # if the new key is already in the new dict
        if new_key in dict3.keys():
            # appends new dict entry to dict3
            dict3[new_key].update({k: v})
        # otherwise create a new entry
        else:
            dict3[new_key] = {k: v}
    # if there is no corresponding mapping present
    else:
        # treat the original key as the new key and add to dict3
        no_map = k
        dict3[no_map] = {k: v}
</code></pre>
</div>
<span class="comment-copy">Readability note: if you do this, <i>please</i> leave a comment as to what this is doing. This is using setdefault in a novel way and as such would be quite cryptic without some sort of explanation.</span>
<span class="comment-copy">@TemporalWolf this is using <code>dict.setdefault()</code> <i>as designed</i>. I'm not sure what is novel about how it used here.</span>
<span class="comment-copy">It may be obvious how this works for you, but it was not clear to me and I would consider this a spot where <a href="https://google.github.io/styleguide/pyguide.html?showone=Comments#Comments" rel="nofollow noreferrer">block or inline comments</a> applies: "Complicated operations get a few lines of comments before the operations commence. Non-obvious ones get comments at the end of the line."</span>
<span class="comment-copy">@TemporalWolf: What I meant was that using <code>dict.setdefault()</code> to fetch a value for a key, setting a default value if missing before doing so, is a straightforward uses of the method, but you called it novel. Is it perhaps that I use <code>dict.setdefault()</code> <i>at all</i> that is new to you? It's been part of the standard library <code>dict</code> object since Python 2.0 at least (so 2001).</span>
<span class="comment-copy">My comment was poorly worded: I still think this, as an invert &amp; merge, deserves a comment.</span>
