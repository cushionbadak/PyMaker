<div class="post-text" itemprop="text">
<p>I have a python3 object (class instance), generated by an</p>
<pre><code>myObj = myClass()
</code></pre>
<p>line. I have also a <code>myMethodName</code> string:</p>
<pre><code>myMethodName = "exampleName"
</code></pre>
<p>. How can I call a method of <code>myObj</code> named by <code>myMethodName</code>? Thus, in this case, I want to call <code>myObj.exampleName</code>, which is coming from like a <code>getAttr(myObj, myMethodName)</code>.</p>
<p>Unfortunately, a naive solution refered by the python docs (for example, <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer">here</a>) gives my only a <code>KeyError</code> or <code>AttributeError</code>.</p>
<p>This fails on that myObj doesn't have a <code>method</code> method:</p>
<pre><code>method = getAttr(myObj, myMethodName)
myObj.method(param)
</code></pre>
<p>This fails on that <code>myMethodName</code> has more of fewer arguments:</p>
<pre><code>method = getAttr(myObj, myMethodName)
method(myObj, param)
</code></pre>
<p>Calling simply</p>
<pre><code>method = getAttr(myObj, myMethodName)
method(param)
</code></pre>
<p>which would be the most logical, gives</p>
<pre><code>TypeError: exampleName() takes 1 positional argument but 2 were given
</code></pre>
<p>So, how can I do this?</p>
<p>I use python 3.6, if it matters.</p>
<hr/>
<p>Extension: here is an MCVE:</p>
<pre><code>class Test:
  name = None
  def __init__(name):
    self.name = name
  def process():
    method = getattr(self, 'process_' + name)
    method("param")
  def process_test(param):
    print ("process_test(): "+param)

test = Test("cica")
test.process("test")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your example can be changed for the following:</p>
<pre><code>class Test:
   def __init__(self, name):
       self.name = name
   def process(self, param):
       method = getattr(self, 'process_' + param)
       method("param")
   def process_test(self, param):
       print ("process_test(): "+param)


test = Test("cica")
test.process("test")
</code></pre>
<p>I think you are missing the concept of bound/static method in Python. See this <a href="https://stackoverflow.com/a/114267/1388292">answer</a>, it is describing the different types of methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the attribute passed to <code>getattr()</code> is a method name then it returns a callable which is already bound to the object:</p>
<blockquote>
<p><code>getattr(object, name[, default])</code></p>
<p>Return the value of the named attribute of object. <code>name</code> must be a string. If the string is the name of one of the <code>object</code>â€™s
  attributes, the result is the value of that attribute. <strong>For example,
  <code>getattr(x, 'foobar')</code> is equivalent to <code>x.foobar</code></strong>. If the named
  attribute does not exist, <code>default</code> is returned if provided, otherwise
  <code>AttributeError</code> is raised.</p>
</blockquote>
<p>Proof:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 1, 3, 1, 1]
&gt;&gt;&gt; f = getattr(x, 'count') # same as f = x.count
&gt;&gt;&gt; f(1)
4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first error is caused, because <code>getattr</code> returns a method that is already bound to the object instance (<code>myObj</code>).</p>
<p>So all you have to do is call your <code>method</code> variable as if it was a function.</p>
<p>The second error is probably due to your exampleName not having the same number of parameters as the number of arguments passed to <code>method</code>.</p>
<p>All you have to do for the second error is to add the same parameters to the method in the class:</p>
<pre><code>myObj = myClass()class myClass:
    def exampleName(self, *args, **keyargs):
        print('Method exampleName was called')

myObj = myClass()

myMethodName = "exampleName"

method = getattr(myObj, myMethodName)
method('some param')
</code></pre>
<p>Update:</p>
<p>You have some more problems in the example you added:</p>
<pre><code>class Test:
    # This was removed, as you already initialize the instance variable in the constructor.
    # Setting it here would cause the variable to be shared by all instances of the class,
    # which you probably do not want, as you are passing the value as argument to the constructor below.
    # name = None

    # You missed to add the self parameter
    def __init__(self, name):
        self.name = name

    # Again, self parameter was missed
    # Additionally, we added a `suffix` parameter, that will accept the `test` value from the `process` call
    # We also added *args and **keyargs that will accept arbitrary number of parameters. Those will be
    # passed down to the `process_test` method.
    def process(self, suffix, *args, **keyargs):
        # We use the `suffix` parameter here, (instead of `name`)
        method = getattr(self, 'process_' + suffix)
        method(*args, **keyargs)

    def process_test(self, param):
        print("process_test(): " + param)


test = Test("cica")
test.process("test", "some param")
</code></pre>
</div>
<span class="comment-copy">Your <code>method</code> already is the method, can't you just call it like <code>method(params)</code>? I'd test it myself if you had provided an MCVE...</span>
<span class="comment-copy">@StefanPochmann Also this gives an error. I extended it into the question.</span>
<span class="comment-copy">@StefanPochmann MCVE added.</span>
<span class="comment-copy">That already fails at the <b>initializer</b> with <code>TypeError: __init__() takes 1 positional argument but 2 were given</code>. Actual working MCVE, please.</span>
<span class="comment-copy">@StefanPochmann Exactly this actually working MCVE what I couldn't produce. The cause of the problem was that I didn't give <code>self</code> to the first argument of <code>process_test()</code>... It should have been <code>def process_test(self, param)</code>. Thanks!</span>
<span class="comment-copy">Sorry, I've forgot to parametrize the <code>process_*</code> functions with <code>self</code>...</span>
<span class="comment-copy">The result: <code>TypeError: exampleName() takes 1 positional argument but 2 were given</code>. Note: It is not a builtin class, it is a class defined by me.</span>
<span class="comment-copy">@peterh Your problem is that you don't specify the <code>self</code> formal argument in your method signatures. <a href="http://stackoverflow.com/users/1388292/jacques-gaudin">Jacques Gaudin's answer</a> fixes that problem.</span>
<span class="comment-copy">Exactly, solved. Thanks!</span>
<span class="comment-copy">Minor format fix, I hope it is okay. Now I am testing.</span>
<span class="comment-copy">I see you reverted it, are you sure it is correct syntax?</span>
<span class="comment-copy">Thanks! Solution found, it was a trivial problem.</span>
