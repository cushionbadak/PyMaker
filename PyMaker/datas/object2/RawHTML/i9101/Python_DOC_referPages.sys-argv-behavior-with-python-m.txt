<div class="post-text" itemprop="text">
<p>question about __init__.py behavior in python 3.5.2. I've noticed that "sys.argv" and "import __main__" behave differently depending on when their called. For example:</p>
<pre><code>$ tree 
└── subdir
    ├── __init__.py : "import sys; print(sys.argv)"
    ├── __main__.py : "import sys; print(sys.argv)"

$ python -m subdir
['-m']
['/path/to/code/subdir/__main__.py']
</code></pre>
<p>Here I'm caught off guard as I'd expect sys.argv to be the same throughout a processes lifetime. I have an intuition as to why this happens but I'm wondering if there is any way of knowing at import time what the true sys.argv is in the __init__.py module.</p>
<p>For reference it looks like argv is altered in Lib/runpy.py@_run_module_as_main</p>
</div>
<div class="post-text" itemprop="text">
<p>Short Version: there is no way to find __main__ before it is run</p>
<p>Long Version:</p>
<ul>
<li>the -m flag causes sys.argv[0] to be manipulated</li>
<li>the problem is in the timing with which sys.argv is manipulated

<ul>
<li>main.c@Py_main does some flag parsing and pops off the module name to call</li>
<li>main.c@RunModule a wrapper around runpy.py@_run_module_as_main</li>
<li>_run_module_as_main sets the sys.argv[0] but does not do so until after  calling runpy.py@_get_main_module_details 

<ul>
<li>a side effect in _get_module_details actually imports the package and its ancestors which executes the __init__.py script before _get_main_module_details can resolve thus _run_module_as_main can't set sys.argv</li>
</ul></li>
</ul></li>
</ul>
<p>I think this could be refactored such that sys.argv is set before _get_module_details imports the package and ancestors (I think made possible by <a href="https://www.python.org/dev/peps/pep-0451/" rel="nofollow noreferrer">module specs</a>) but will have to wait for an enhancement to the runpy architecture, possibly in the form of <a href="http://bugs.python.org/issue26388" rel="nofollow noreferrer">this</a> which was in the works as of late last year.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/using/cmdline.html#cmdoption-m" rel="nofollow noreferrer">docs.python.org/3/using/cmdline.html#cmdoption-m</a> describes exactly this.</span>
<span class="comment-copy">@JoshLee good call,  "the first element of sys.argv will be the full path to the module file" shows the implementation relevance of sys.argv changing but I'm still wondering how at import time in _<i>init_</i>.py I can concisely accommodate for sys.argv possibly not being finalized.</span>
<span class="comment-copy">@Buck I think the best way to <i>accommodate</i> for this would be to be not interested in <code>sys.argv</code> in <code>__init__.py</code>. What do you do with it in <code>__init__</code> what you can't do in <code>__main__</code>?</span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/q/8348726/95735">How to know if python script was run using interpreter's -m option?</a></span>
<span class="comment-copy">@PiotrDobrogost the reason I want sys.argv is just to know which file is being run as _<i>main_</i>, in practice I have modules that initialize their loggers at import time i.e. <code>logger = getLogger(__name__)</code> and want these loggers to be able to attach information about the main process as extra information but find there is no good way for them to have that at import time consistently.</span>
