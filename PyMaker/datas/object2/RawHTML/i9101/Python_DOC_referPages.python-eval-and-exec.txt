<div class="post-text" itemprop="text">
<p>Is there a way I can use Python <code>eval()</code> and/or <code>exec()</code> to maintain state between program runs without writing data to a file or database.
Here's the question more specifically. I want to write a program that prints out a number and then keeps adding 1 to itself every time it's run again without persisting any variable in a file or database.
I got asked this question in a recent interview. 
Any help appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Disclaimer</strong>: I do <em>not</em> recommend doing this. 99.999% of the time, it's better to store serializable information in its own file.</p>
<p>If by "without writing data to a file", you mean "without writing data to <em>its own</em> file",
you can open the Python file that is running and rewrite the data in-place:</p>
<pre><code>import re

x = 0
print "The value of the variable x is: {}".format(x)

with open("test.py") as file:
    data = file.read()

data = re.sub(r"x = (\d+)", "x = {}".format(x+1), data)

with open("test.py", "w") as file:
    file.write(data)
</code></pre>
<p>Now the value will change with each subsequent execution.</p>
<pre><code>C:\Users\Kevin\Desktop&gt;test.py
The value of the variable x is: 0

C:\Users\Kevin\Desktop&gt;test.py
The value of the variable x is: 1

C:\Users\Kevin\Desktop&gt;test.py
The value of the variable x is: 2

C:\Users\Kevin\Desktop&gt;test.py
The value of the variable x is: 3

C:\Users\Kevin\Desktop&gt;test.py
The value of the variable x is: 4
</code></pre>
<hr/>
<p>But again, it's preferable to just keep the data in a separate file, using for example <code>shelve</code>:</p>
<pre><code>import shelve

d = shelve.open("data.dat")
if "x" not in d:
    d["x"] = 0

print "The value of x is: {}".format(d["x"])
d["x"] += 1
</code></pre>
<p>Or perhaps json if you value human-readability:</p>
<pre><code>import json

try:
    with open("data.dat") as file:
        d = json.load(file)
except IOError: #first execution. file doesn't exist yet.
    d = {"x":0}

print "The value of x is: {}".format(d["x"])
d["x"] += 1

with open("data.dat", "w") as file:
    json.dump(d, file)
</code></pre>
<p>Or even a full-fledged database if you've got a lot of data.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should ideally be code-golf, but it was fun!<br/>
Here is a solution using <code>exec</code> and <code>eval</code> as you requested.<br/>
The code is 15 lines long, on each run an additional line <code>(z=1)</code> is added to the .py file<br/>
and what is printed is <code>number of lines in file now - 15</code>, thus printing increments on each run</p>
<pre><code>initial_num_lines = 15
def get_lines_in_file():
    f = open('evalexec.py', 'r')
    num_lines = len(f.readlines())
    return num_lines

lines = str(get_lines_in_file() - initial_num_lines)
print eval(lines+'+1')
exec_code = '''
f = open('evalexec.py', 'a')
f.write("\\nz=1")
f.close()
'''
exec(exec_code)
</code></pre>
<p>OUTPUT:<br/></p>
<pre><code>&gt;python evalexec.py
0

&gt;python evalexec.py
1

&gt;python evalexec.py
2

&gt;python evalexec.py
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the file <a href="https://docs.python.org/3/library/os.html#os.stat" rel="nofollow noreferrer">stats</a> to keep track of the last modified value (which is an integer), and update it each run using <a href="https://docs.python.org/3/library/os.html#os.utime" rel="nofollow noreferrer"><strong><code>os.utime</code></strong></a>:</p>
<pre><code>import os

last_modified = os.stats(__file__).st_mtime
print(int(last_modified))

os.utime(__file__, (last_modified, last_modified + 1))
</code></pre>
<p>Consecutive runs:</p>
<pre><code>Petes-Mac:~ petewood$ python inc.py
1486149574
Petes-Mac:~ petewood$ python inc.py
1486149575
Petes-Mac:~ petewood$ python inc.py
1486149576
</code></pre>
</div>
<span class="comment-copy">No. Why would you think those would help you? <code>eval</code> and <code>exec</code> don't have some magical persistent storage associated with them.</span>
<span class="comment-copy">Did the interviewer specifically ask how to do this using eval and exec, or did he just ask how to maintain state in general, and you came up with the idea to use eval/exec on your own?</span>
<span class="comment-copy">That was part of the hint provided to me during the interview. Apparently eval can somehow be used to self modify code, which I cant think of how.</span>
<span class="comment-copy">Wouldn't modifying the code count as "writing data to a file?" .py files are still files.</span>
<span class="comment-copy">I think you've misunderstood the question and the hint. This is unclear, too broad, and off topic.</span>
<span class="comment-copy">Well this is excellent, I guess the first option is what the interviewer had in mind. It's convoluted, but well it's a solution still.</span>
<span class="comment-copy">Ah nice. I guess this is closest to what I had in mind.</span>
