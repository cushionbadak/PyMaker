<div class="post-text" itemprop="text">
<p>I need to extract (a lot of) info from different text files. 
I wonder if there is a shorter and more efficient way than the following:</p>
<p>First part: (N lines long)</p>
<pre><code>N1 = re.compile(r'')
N2 = re.compile(r'')
.
Nn = re.compile(r'')
</code></pre>
<p>Second part: (2N lines long)</p>
<pre><code>with open(filename) as f:
  for line in f:
    if N1.match(line):
      var1 = N1.match(line).group(x).strip()
    elif N2.match(line):
      var2 = N1.match(line).group(x).strip()
    elif Nn.match(line):
      varn = Nn
</code></pre>
<p>Do you recommend having the re.compile vars (part 1) separate from the part 2. What do you people use in this cases? Perhaps a function pasing the regex as argument? and call it every time.</p>
<p>In my case N is 30, meaning I have 90 lines for feeding a dictionary with very little, or no logic at all.</p>
</div>
<div class="post-text" itemprop="text">
<p>I’m going to attempt to answer this without really knowing what you are <em>actually</em> doing there. So this answer might help you, or it might not.</p>
<p>First of all, what <code>re.compile</code> does is pre-compile a regular expression, so you can use it later and do not have to compile it every time you use it. This is primarily useful when you have a regular expression that is used multiple times throughout your program. But if the expression is only used a few times, then there is not really that much of a benefit to compiling it up front.</p>
<p>So you should ask yourself, how often the code runs that attempts to match all those expressions. Is it just once during the script execution? Then you can make your code simpler by inlining the expressions. Since you’re running the matches for each line in a file, pre-compiling likely makes sense here.</p>
<p>But just because you pre-compiled the expression, that does not mean that you should be sloppy and match the same expression too often. Look at this code:</p>
<pre><code>if N1.match(line):
    var1 = N1.match(line).group(x).strip()
</code></pre>
<p>Assuming there is a match, this will run <code>N1.match()</code> twice. That’s an overhead you should avoid since matching expressions can be relatively expensive (depending on the expression), even if the expression is already pre-compiled.</p>
<p>Instead, just match it once, and then reuse the result:</p>
<pre><code>n1_match = N1.match(line)
if n1_match:
    var1 = n1_match.group(x).strip()
</code></pre>
<p>Looking at your code, your regular expressions also appear to be mutally exclusive—or at least you only ever use the first match and skip the remaining ones. In that case, you should make sure that you order your checks 
so that the most common checks are done first. That way, you avoid running too many expressions that won’t match anyway. Also, try to order them so that more complex expressions are ran less often.</p>
<p>Finally, you are collecting the match result in separate variables <code>varN</code>. At this point, I’m questioning what exactly you are doing there, since after all your if checks, you do not have a clear way of figuring out what the result was and which variable to use. At this point, it might make more sense to just collect it in a single variable, or to move specific logic within the condition bodies. But it’s difficult to tell with the amount of information you gave.</p>
</div>
<div class="post-text" itemprop="text">
<p>As mentionned in <a href="https://docs.python.org/3/library/re.html#re.compile" rel="nofollow noreferrer"><code>re</code> module documentation</a>, the regexes you pass through <code>re</code> methods are cached: depending on the number of expressions you have, caching them yourself might not be useful.</p>
<p>That being said, you should make a list of your regexes, so that a simple for loop would allow you to test all your patterns.</p>
<pre><code>regexes = map(re.compile, ['', '', '', '', ...])
vars = ['']*len(regexes)
with open(filename) as f:
  for line in f:
    for i,regex in enumerate(regexes):
      if regex.match(line):
         var[i] = regex.match(line).group(x).strip()
         break  # break here if you only want the first match for any given line.
</code></pre>
</div>
<span class="comment-copy">In general, if you want <code>n</code> things, use a <i>list</i>.</span>
<span class="comment-copy">the data extracted will be stored in lists and dictionaries, but why using a list before extracting?</span>
<span class="comment-copy">...because you want something shorter and more efficient than defining <code>n</code> compiled regexes with separate names?</span>
<span class="comment-copy">what he means is that maybe use something like [re.compile(r''), re.compile(r''), re.compile(r'')] instead of N1 N2 N3 and then you could do for lines in f: for r in regexes</span>
<span class="comment-copy">Can you maybe make your question a bit more specific and less general? It’s really difficult to suggest anything when it’s unclear (a) what kind of things you want to match, (b) how the regular expressions differ, (c) what you are going to do with the matches, (d) what purpose the separate variables serve, (e) and why those expressions are apparently exclusive to another (since you’re only using <code>elif</code>s).</span>
<span class="comment-copy">Most of the pre-compiled REs would be used once (or two) per file, but the script will run for a hundred files every day.   Yes. They are mutually exclusive, if they match a line I'm 100% sure that that line won't have any other info. I know the file structure, so if I know that the last line always has a data I need, I put that re.match last.   At the end of the for, each var will feed 3 dicts. For this reason I have those vars there. The main dict will be feeded by more or less 110 files.   I really do not know if this is the best way of get data from more or less structured text/log fi</span>
<span class="comment-copy">If the script runs multiple times but the Python process running it terminates in between, then precompiling the expressions will not help.</span>
<span class="comment-copy">Note that OP’s code stops at the first match while your loop will always match all expressions.</span>
<span class="comment-copy">@poke You're right, I've updated my example.</span>
