<div class="post-text" itemprop="text">
<p>I'm writing a dynamic array implementation in Python (similar to the built-in list class), for which I need to observe the growth in capacity (which doubles each time the limit is reached). For that I have the following code, but the output is weird. It looks like the <code>sys.getsizeof()</code> never calls my class's <code>__sizeof__()</code>. For the purpose of testing, I'm making the <code>__sizeof__()</code> return <code>0</code>, but as per <code>sys.getsizeof()</code> it is non-zero.</p>
<p>What's the catch?</p>
<pre class="lang-py prettyprint-override"><code>import ctypes

class DynamicArray(object):
    '''
    DYNAMIC ARRAY CLASS (Similar to Python List)
    '''

    def __init__(self):
        self.n = 0 # Count actual elements (Default is 0)
        self.capacity = 1 # Default Capacity
        self.A = self.make_array(self.capacity)

    def __len__(self):
        """
        Return number of elements sorted in array
        """
        return self.n

    def __getitem__(self,k):
        """
        Return element at index k
        """
        if not 0 &lt;= k &lt;self.n:
            return IndexError('K is out of bounds!') # Check it k index is in bounds of array

        return self.A[k] #Retrieve from array at index k

    def append(self, ele):
        """
        Add element to end of the array
        """
        if self.n == self.capacity:
            self._resize(2*self.capacity) #Double capacity if not enough room

        self.A[self.n] = ele #Set self.n index to element
        self.n += 1

    def _resize(self,new_cap):
        """
        Resize internal array to capacity new_cap
        """
        print("resize called!")

        B = self.make_array(new_cap) # New bigger array

        for k in range(self.n): # Reference all existing values
            B[k] = self.A[k]

        self.A = B # Call A the new bigger array
        self.capacity = new_cap # Reset the capacity

    def make_array(self,new_cap):
        """
        Returns a new array with new_cap capacity
        """
        return (new_cap * ctypes.py_object)()

    def __sizeof__(self):
        return 0
</code></pre>
<p>The code used to test the resizing:</p>
<pre><code>arr2 = DynamicArray()

import sys

for i in range(100):
    print(len(arr2), " ", sys.getsizeof(arr2))
    arr2.append(i)
</code></pre>
<p>And the output:</p>
<pre><code>0   24
1   24
resize called!
2   24
resize called!
3   24
4   24
resize called!
5   24
6   24
7   24
8   24
resize called!
9   24
10   24
11   24
12   24
13   24
14   24
15   24
16   24
resize called!
17   24
18   24
19   24
20   24
21   24
22   24
23   24
24   24
25   24
26   24
27   24
28   24
29   24
30   24
31   24
32   24
resize called!
33   24
34   24
35   24
36   24
37   24
38   24
39   24
40   24
41   24
42   24
43   24
44   24
45   24
46   24
47   24
48   24
49   24
50   24
51   24
52   24
53   24
54   24
55   24
56   24
57   24
58   24
59   24
60   24
61   24
62   24
63   24
64   24
resize called!
65   24
66   24
67   24
68   24
69   24
70   24
71   24
72   24
73   24
74   24
75   24
76   24
77   24
78   24
79   24
80   24
81   24
82   24
83   24
84   24
85   24
86   24
87   24
88   24
89   24
90   24
91   24
92   24
93   24
94   24
95   24
96   24
97   24
98   24
99   24
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>__sizeof__</code> <em>is</em> getting called, it's just adding the garbage collector overhead to it which is why the result isn't zero.</p>
<p><a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="nofollow noreferrer">From the docs on <code>sys.getsizeof</code></a>:</p>
<blockquote>
<p><code>getsizeof()</code> calls the objectâ€™s <code>__sizeof__</code> method and adds an additional garbage collector overhead if the object is managed by the garbage collector.</p>
</blockquote>
<p>Returning <code>0</code> is one way in which you make it hard for your self to understand that it's called since you'll always get the same result back (<code>0</code> + overhead). </p>
<p>Return a size based on the contents of the dynamic array to see it change.</p>
<hr/>
<p>To further elaborate:</p>
<p>Each object in CPython has some administrative information attached to it in a <code>PyGC_head</code> struct <a href="https://github.com/python/cpython/blob/master/Python/sysmodule.c#L1108" rel="nofollow noreferrer">that gets added</a>:</p>
<pre class="lang-c prettyprint-override"><code>/* add gc_head size */
if (PyObject_IS_GC(o))
    return ((size_t)size) + sizeof(PyGC_Head);
return (size_t)size;
</code></pre>
<p>that is used by the garbage collector. </p>
<p>Why this is added to the overall size is probably because it <em>does</em> represent additional memory required by the object. On the Python level, you don't need to worry about the collection of garbage and treat it all like magic, but, when asking for information on the size of an object you should not sacrifice correct results just to keep the illusion alive.</p>
</div>
<span class="comment-copy">+1 Make your <code>__sizeof__()</code> return a non-zero value and you'll see that the observed value is incremented by that amount</span>
<span class="comment-copy">@Leon exactly, just added that to the answer :-)</span>
<span class="comment-copy">Garbage collector <i>overhead</i>? I'm not sure I understand at all. What overhead? And why should overhead be added as an integer? Isn't garbage collection supposed to be automatic and implicit and magical and non-interfering and all that? :)</span>
<span class="comment-copy">@dotslash I added a bit more to my answer, I hope it helps with your further concerns.</span>
<span class="comment-copy">Yes, that helps. Thank you for the effort. I do think now I shoulf brush up my C and dive more into Python source code.</span>
