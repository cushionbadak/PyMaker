<div class="post-text" itemprop="text">
<p>I want to create method (say <code>copy</code>) in a class (<code>Parent</code>) that will return an object of either the class <em>or the subclass</em> that invokes it. I want <code>type(x) == type(x.copy())</code>. </p>
<p>None of the approaches I tried were satisfactory. </p>
<ul>
<li>Using the superclass constructor returns the superclass (make senses but I figured it was worth a try). </li>
<li>Creating a function <code>init_me</code> in each subclass that the super class uses but that defeats the purpose of inheritance. </li>
<li>I started to explore <code>__new__</code> and <code>__init__</code>, but quickly decided Python must have a better way.</li>
</ul>
<p>Sample code</p>
<pre><code>class Parent(object):
    def __init__(self, p1=p1_default, p2=p2_default, p3=p3_default):
        ...   # common stuff
        self._special_suff()
    def copy_works_if_subclass_does_extra(self):
        return self.init_me()
    def copy_only_does_superclass(self):
        return Parent()
    def copy_with_init(self):
        return self.__init__()
    def whoami(self):
        print('I am just a parent')

class Dad(Parent):
    def _special_stuff():
        ...     # Dad special stuff
        return 
    def whoami(self):
        print('I am a dad')
    def init_me(self):
        return Dad()

class Mom(Parent):
    def _special_stuff():
        ...     # Mom special stuff
        return 
    def whoami(self):
        print('I am a mom')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understand correctly, you're trying to write a <code>copy</code> method in your base class that will still work when called on an instance of a derived class. This can be made to work, but it's only easy if your child classes only expect the same set of arguments as the base class. If their <code>__init__</code> method expects different arguments you'll need separate <code>copy</code> methods for each derived class.</p>
<p>Here's a quick example of how it can work. The trick is to call <code>type(self)</code> to get the right class, and then call the class with appropriate constructor arguments to get the new instance:</p>
<pre><code>class Base(object):
    def __init__(self, arg1, arg2, arg3):
        self.attr1 = arg1
        self.attr2 = arg2
        self.attr3 = arg3

    def copy(self):
        cls = type(self)
        return cls(self.attr1, self.attr2, self.attr3)

class Derived(Base):
    def __init__(self, arg1, arg2, arg3):
        super().__init__(arg1, arg2, arg3)
        self.some_other_attr = "foo"
</code></pre>
<p>In practice this tends not to work as well, since the <code>Derived</code> class will usually want to take an extra argument to set up its extra attribute. An option that might work in that situation is to use <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">the <code>copy</code> module</a> rather than writing your own <code>copy</code> method. The function <code>copy.copy</code> will be able to copy many Python instances without any special support.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are overcomplicating things a <em>lot</em>. Minimal example with a simple constructor implemented on the child class:</p>
<pre><code>import copy

class Parent():
    def whoami(self):
        print('Just a parent')
    def __init__(self, name):
        self.name = name
    def copy(self):
        # Maybe copy.deepcopy instead
        return copy.copy(self)


class Dad(Parent):
    def whoami(self):
        print('I am a dad')
    def __init__(self, name):
        super().__init__(name)
        self.gender = 'Male'
</code></pre>
<p>You don't even need a constructor in Python if you don't need. Or you can have one on the superclass and nothing on the child.</p>
<p>Some usage:</p>
<pre><code>&gt;&gt;&gt; dad = Dad("Clark Griswold")
&gt;&gt;&gt; dad.name
'Clark Griswold'
&gt;&gt;&gt; dad.whoami()
I am a dad
&gt;&gt;&gt; isinstance(dad, Dad)
True
&gt;&gt;&gt; isinstance(dad, Parent)
True
&gt;&gt;&gt; type(dad.copy()) == type(dad)
True
</code></pre>
</div>
<span class="comment-copy">The <code>cls = type(self)</code> followed by <code>return cls(...)</code> answers my question. My impression is that if I need to use <code>type</code>, then I need to reconsider my <i>design</i>.</span>
<span class="comment-copy">I don't think using <code>type</code> is inherently bad design. There <i>are</i> some kinds of bad code that rely upon it (especially beginner code that does <code>if type(foo) == Bar</code> instead of using <code>isinstance</code>), but it is perfectly reasonable to use <code>type</code> when you need to deal with class objects along with their instances. It's one of Python's basic introspection tools.</span>
<span class="comment-copy">I am trying out a design approach that may be a dead end. The superclass constructor had several arguments. These arguments would be the same for all inherited classes.  So the idea is to have the subclasses implement a 'private' method use to do their specialized construction.  Polymorphic dispatch would handle the variations in the subclasses.  Then I realized a base function (more than just <code>copy</code> from the example) needed to return subtypes. <b>Over complicating?</b> Perhaps. But before changing the design, I wanted to check my options.</span>
<span class="comment-copy">Could you include an example of the specialized construction in the original post. I'm not sure I understand.</span>
<span class="comment-copy">My last comment was true, but misleading. The main challenge is the reuse of the <code>copy</code> function.  I want <code>Dad().copy</code> and <code>Mom.copy()</code> to use the same code in the superclass but in both cases return the subclass. So how to I make the superclass base code smart enough to use constructor of subclass?</span>
<span class="comment-copy">I added a <code>copy</code> to the my example. Not exactly sure how yours will work.</span>
