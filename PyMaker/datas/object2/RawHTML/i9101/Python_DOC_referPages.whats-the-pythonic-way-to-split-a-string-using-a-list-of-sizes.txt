<div class="post-text" itemprop="text">
<p>What's the pythonic way to implement this:</p>
<pre><code>s = "thisismystring"
keys = [4, 2, 2, 6]
new = []
i = 0
for k in keys:
    new.append(s[i:i+k])
    i = i+k
</code></pre>
<p>This does give me <code>['this', 'is', 'my', 'string']</code> as I need but I fell there's a more elegant way to do it. Suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate()</code></a>, perhaps:</p>
<pre><code>from itertools import accumulate

s = "thisismystring"
keys = [4, 2, 2, 6]
new = []
start = 0
for end in accumulate(keys):
    new.append(s[start:end])
    start = end
</code></pre>
<p>You could inline the <code>start</code> values by adding another <code>accumulate()</code> call starting at zero:</p>
<pre><code>for start, end in zip(accumulate([0] + keys), accumulate(keys)):
    new.append(s[start:end])
</code></pre>
<p>This version can be made into a list comprehension:</p>
<pre><code>[s[a:b] for a, b in zip(accumulate([0] + keys), accumulate(keys))]
</code></pre>
<p>Demo of the latter version:</p>
<pre><code>&gt;&gt;&gt; from itertools import accumulate
&gt;&gt;&gt; s = "thisismystring"
&gt;&gt;&gt; keys = [4, 2, 2, 6]
&gt;&gt;&gt; [s[a:b] for a, b in zip(accumulate([0] + keys), accumulate(keys))]
['this', 'is', 'my', 'string']
</code></pre>
<p>The double accumulate could be replaced with a <code>tee()</code>, wrapped in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>pairwise()</code> function from the <code>itertools</code> documentation</a>:</p>
<pre><code>from itertools import accumulate, chain, tee

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)

[s[a:b] for a, b in pairwise(accumulate(chain([0], keys)))]
</code></pre>
<p>I threw in an <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain()</code> call</a> to prefix that 0 starting position, rather than create a new list object with concatenation.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use <code>enumerate</code> for that, with accumulating:</p>
<pre><code>[s[sum(keys[:i]): sum(keys[:i]) + k] for i, k in enumerate(keys)]
</code></pre>
<p>With your example:</p>
<pre><code>&gt;&gt;&gt; s = "thisismystring"
&gt;&gt;&gt; keys = [4, 2, 2, 6]
&gt;&gt;&gt; new = [s[sum(keys[:i]): sum(keys[:i]) + k] for i, k in enumerate(keys)]
&gt;&gt;&gt; new
['this', 'is', 'my', 'string']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Could use <code>islice</code>. Probably not efficient, but maybe at least interesting and simple.</p>
<pre><code>&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; s = 'thisismystring'
&gt;&gt;&gt; keys = [4, 2, 2, 6]

&gt;&gt;&gt; it = iter(s)
&gt;&gt;&gt; [''.join(islice(it, k)) for k in keys]
['this', 'is', 'my', 'string']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just because I believe there have to be ways to do this without explicit loops:</p>
<pre><code>import re

s = "thisismystring"

keys = [4, 2, 2, 6]

new = re.findall((r"(.{{{}}})" * len(keys)).format(*keys), s)[0]

print(new)
</code></pre>
<p><strong>OUTPUT</strong></p>
<pre><code>('this', 'is', 'my', 'string')
</code></pre>
</div>
<span class="comment-copy">I had considered it, but with the <code>''.join()</code> required for strings it's not as elegant. It's great for sublists, rather than substrings!</span>
<span class="comment-copy">@MartijnPieters Yeah, I'm not exactly excited about it, either. Though for lists it would look the same, except with <code>list</code> instead of <code>''.join</code>. Not much different.</span>
<span class="comment-copy">good point; <code>tuple()</code> for sub-tuples, <code>list()</code> for sub-lists, <code>''.join()</code> for substrings.</span>
