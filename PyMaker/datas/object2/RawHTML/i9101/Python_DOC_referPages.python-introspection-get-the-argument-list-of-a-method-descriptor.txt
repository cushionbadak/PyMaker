<div class="post-text" itemprop="text">
<p>A code illustration as an intro to my questions:</p>
<pre><code>import re, inspect, datetime

inspect.getargspec (re.findall)
# =&gt;
# ArgSpec(args = ['pattern', 'string', 'flags'], varargs=None,
# keywords=None, defaults = (0,))

type (datetime.datetime.replace)
# =&gt; &lt;type 'method_descriptor'&gt;

inspect.getargspec (datetime.datetime.replace)
# =&gt; Traceback (most recent call last):
#      File "&lt;stdin&gt;", line 1, in &lt;module&gt;
#      File "/usr/lib/python2.7/inspect.py", line 816, in getargspec
#        raise TypeError('{!r} is not a Python function'.format(func))
# TypeError: &lt;method 'replace' of 'datetime.datetime' objects&gt; is
# not a Python function
</code></pre>
<p>It seems that the only way for me to find the signature of <code>datetime.datetime.replace</code> while I code is to look it up in <a href="https://docs.python.org/2/library/datetime.html#datetime.date.replace" rel="noreferrer">the doc</a>: <code>date.replace(year, month, day)</code>.</p>
<p>The only introspection part that seems to work:</p>
<pre><code>datetime.datetime.replace.__doc__
# =&gt; 'Return datetime with new specified fields.'
</code></pre>
<p>I've examined how the Jupyter function arglist tool-tip works, they have the exact same problem, i.e. no arglist available for <code>datetime.datetime.replace</code>.</p>
<p>So here are the questions:</p>
<ol>
<li><p>Is it still possible to get the argument list somehow? Maybe I could install the C sources for <code>datetime</code> and connect them via the <code>__file__</code> attribute?</p></li>
<li><p>Is it possible to annotate a <code>&lt;type 'method_descriptor'&gt;</code> with the arglist information? In that case, I could parse the linked doc's markdown definition and automatically annotate the built-in module functions.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>No, you can't get more information; installing the C sources would not give you easy access to the same. That's because <em>most</em> methods defined in C code do not actually expose this information; you'd have to parse out a <a href="https://github.com/python/cpython/blob/v3.6.0/Modules/_datetimemodule.c#L4998-L5001" rel="nofollow noreferrer">rather cryptic piece of C code</a>:</p>
<pre class="lang-c prettyprint-override"><code>if (! PyArg_ParseTupleAndKeywords(args, kw, "|iiiiiiiO$i:replace",
                                  datetime_kws,
                                  &amp;y, &amp;m, &amp;d, &amp;hh, &amp;mm, &amp;ss, &amp;us,
                                  &amp;tzinfo, &amp;fold))
</code></pre>
<p>The <code>re.findall()</code> function is a <a href="https://github.com/python/cpython/blob/v3.6.0/Lib/re.py#L214-L222" rel="nofollow noreferrer"><em>pure Python function</em></a>, so is introspectable.</p>
<p>I said <em>most</em> methods defined in C, because as of Python 3.4 and up, methods that use the new <a href="https://docs.python.org/3/howto/clinic.html" rel="nofollow noreferrer">Argument Clinic preprocessor</a> will include a new <code>__text_signature__</code> attribute, which the internal <a href="https://github.com/python/cpython/blob/v3.6.0/Lib/inspect.py#L1909-L2047" rel="nofollow noreferrer"><code>inspect._signature_fromstr()</code> function</a> can parse. This means that even for such C-defined methods, you can introspect the arguments:</p>
<pre><code>&gt;&gt;&gt; import io
&gt;&gt;&gt; import inspect
&gt;&gt;&gt; type(io.BytesIO.read)
&lt;class 'method_descriptor'&gt;
&gt;&gt;&gt; inspect.signature(io.BytesIO.read)
&lt;Signature (self, size=None, /)&gt;
</code></pre>
<p>Also see <a href="https://stackoverflow.com/questions/25847035/what-are-signature-and-text-signature-used-for-in-python-3-4">What are __signature__ and __text_signature__ used for in Python 3.4</a></p>
<p>The <code>datetime</code> module has not yet received much Argument Clinic love. We'll have to be patient, or if you really care a lot about this, supply patches that convert the module to using Argument Clinic.</p>
<p>If you want to see what modules <em>do</em> have support already, look at the <a href="https://github.com/python/cpython/tree/master/Modules/clinic" rel="nofollow noreferrer"><code>Modules/clinic</code> subdirectory</a> which contains the generated clinic output; for the <code>datetime</code> module, only <code>datetime.datetime.now()</code> is currently included. That method <a href="https://github.com/python/cpython/blob/v3.6.0/Modules/_datetimemodule.c#L4322-L4337" rel="nofollow noreferrer">defines a clinic block</a>:</p>
<pre class="lang-c prettyprint-override"><code>/*[clinic input]
@classmethod
datetime.datetime.now
    tz: object = None
        Timezone object.
Returns new datetime object representing current time local to tz.
If no tz is specified, uses local timezone.
[clinic start generated code]*/

static PyObject *
datetime_datetime_now_impl(PyTypeObject *type, PyObject *tz)
/*[clinic end generated code: output=b3386e5345e2b47a input=80d09869c5267d00]*/
</code></pre>
<p>making the method introspectable:</p>
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; inspect.signature(datetime.datetime.now)
&lt;Signature (tz=None)&gt;
</code></pre>
<p>There is no way to directly attach information to those C functions and methods that are not introspectable; they don't support attributes either.</p>
<p>Most autocomplete solutions that want to support such objects use separate data structures where the information is maintained independently (with all the inherent risks of the data getting out of sync). Some of these are available for your own purposes:</p>
<ul>
<li><p>The Komodo IDE code intelligence library (open source, used other editors too) uses the <a href="https://community.activestate.com/faq/codeintel-cix-schema" rel="nofollow noreferrer">CIX format</a> to encode this data; you could <a href="https://github.com/Komodo/KomodoEdit/tree/master/src/codeintel/lib/codeintel2/stdlibs" rel="nofollow noreferrer">download the Python 3 catalog</a>. Unfortunately for your specific example, the <code>datetime.replace()</code> function signature has not been fleshed out <em>either</em>:</p>
<pre class="lang-xml prettyprint-override"><code>&lt;scope doc="Return datetime with new specified fields." ilk="function" name="replace" /&gt;
</code></pre></li>
<li><p>The new Python 3.5 type hinting syntax also needs to know what types of arguments objects expect, and to this end stub files need to be provided for objects that can't be introspected. The <a href="https://github.com/python/typeshed" rel="nofollow noreferrer">Python typeshed project</a> provides these. This includes all argument names for the <a href="https://github.com/python/typeshed/blob/master/stdlib/3/datetime.pyi" rel="nofollow noreferrer"><code>datetime</code> module</a>:</p>
<pre><code>class datetime:
    # ...
    def replace(self, year: int = ..., month: int = ..., day: int = ..., hour: int = ...,
        minute: int = ..., second: int = ..., microsecond: int = ..., tzinfo:
        Optional[_tzinfo] = None) -&gt; datetime: ...
</code></pre>
<p>You'd have to parse such a file yourself; they can't always be imported as the stubs reference types not yet defined, rather than use <a href="https://www.python.org/dev/peps/pep-0484/#forward-references" rel="nofollow noreferrer">forward references</a>:</p>
<pre><code>&gt;&gt;&gt; import importlib.machinery
&gt;&gt;&gt; path = 'stdlib/3/datetime.pyi'
&gt;&gt;&gt; loader = importlib.machinery.SourceFileLoader('datetime', path)
&gt;&gt;&gt; loader.load_module()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;frozen importlib._bootstrap_external&gt;", line 399, in _check_name_wrapper
  File "&lt;frozen importlib._bootstrap_external&gt;", line 823, in load_module
  File "&lt;frozen importlib._bootstrap_external&gt;", line 682, in load_module
  File "&lt;frozen importlib._bootstrap&gt;", line 251, in _load_module_shim
  File "&lt;frozen importlib._bootstrap&gt;", line 675, in _load
  File "&lt;frozen importlib._bootstrap&gt;", line 655, in _load_unlocked
  File "&lt;frozen importlib._bootstrap_external&gt;", line 678, in exec_module
  File "&lt;frozen importlib._bootstrap&gt;", line 205, in _call_with_frames_removed
  File "stdlib/3/datetime.pyi", line 12, in &lt;module&gt;
    class tzinfo:
  File "stdlib/3/datetime.pyi", line 13, in tzinfo
    def tzname(self, dt: Optional[datetime]) -&gt; str: ...
NameError: name 'datetime' is not defined
</code></pre>
<p>You may be able to work around that by using a pre-defined module object and globals, then iterating on name errors until it imports though. I'll leave that as an exercise for the reader. Mypy and other type checkers don't try to execute the code, they merely build an AST. </p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The issue you are having is caused by the fact that C-coded functions do not expose their signature. You'll find more information on this <a href="https://stackoverflow.com/a/990022/1104488">answer to "How to find out the arity of a method in Python"</a>.</p>
<p>In your case, <code>re.findall</code> is defined in Python (see <a href="https://github.com/python/cpython/blob/master/Lib/re.py#L214" rel="nofollow noreferrer"><code>def findall(pattern, string, flags=0):</code></a>) while <code>datetime.datetime.replace</code> is written in C (see <a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Modules/_datetimemodule.c#L5015" rel="nofollow noreferrer"><code>datetime_replace(PyDateTime_DateTime *self, PyObject *args, PyObject *kw)</code></a>).</p>
<p>You can see see using the different attributes available (and the <code>__code__</code> attribute in particular) on the function with the <code>dir</code> builtin :</p>
<pre><code>&gt;&gt;&gt; dir(datetime.datetime.replace)
['__call__', '__class__', '__delattr__', '__doc__', '__format__', '__get__', '__getattribute__', '__hash__', '__init__', '__name__', '__new__', '__objclass__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
&gt;&gt;&gt; dir(re.findall)
['__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__doc__', '__format__', '__get__', '__getattribute__', '__globals__', '__hash__', '__init__', '__module__', '__name__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'func_closure', 'func_code', 'func_defaults', 'func_dict', 'func_doc', 'func_globals', 'func_name']
&gt;&gt;&gt; datetime.datetime.replace.__code__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'method_descriptor' object has no attribute '__code__'
&gt;&gt;&gt; re.findall.__code__
&lt;code object findall at 0x7fe7234e74b0, file "/usr/lib/python2.7/re.py", line 173&gt;
</code></pre>
<p>Usually, the <code>help</code> gives you what you need (based on the <code>__doc__</code> attribute) but in your case, it doesn't seem to help much:</p>
<pre><code>&gt;&gt;&gt; help(datetime.datetime.replace)
Help on method_descriptor:

replace(...)
    Return datetime with new specified fields.
</code></pre>
<p>Also, an idea could be to try to set the <code>__code__</code> attribute to something corresponding to your needs but <a href="https://stackoverflow.com/a/4698550/1104488">you can't tweak much on builtin types without subclassing</a>.</p>
</div>
