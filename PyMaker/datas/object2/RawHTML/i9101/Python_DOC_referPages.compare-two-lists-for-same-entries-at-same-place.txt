<div class="post-text" itemprop="text">
<p>I am trying to compare two lists for the same element at the same index. The idea is to verify whether both lists contain same element at the same index. If yes, I want to count such occurrences. Here is my code:</p>
<pre><code> count = 0
 a = ['.ps2\n &gt;|&lt;4 *|*.ps2xml', '.c\n &gt;|&lt;2 *|*.wsc', '.h\n &gt;|&lt;2 *|*.wsh', '.c\n &gt;|&lt;2 *|*.chm', '.h\n &gt;|&lt;2 *|*.hta'  ]
 b = ['.ps2xml', '.chm', '.hta']

 for x in a:
  for y in b:
   if y==x[x.index(" *|*")+4:]:
    print "match"
    count += 1

 print count
</code></pre>
<p>This gives me a count of 3. What I expect is 1 because only first element of b matched with a's first element. The second element of both lists differ. The third elements are also different. The remaining elements in list a should not count as there is no such index in b.</p>
<p>Hope it makes sense. Thanks </p>
</div>
<div class="post-text" itemprop="text">
<p>In that case, you should <strong>not use nested loops</strong> (since this means you will repeat the search over <code>b</code> for each line in <code>a</code>); <strong>but use a <code>zip(..)</code></strong>:</p>
<pre><code>for x,y in zip(a,b):
    if y==x[x.index(" *|*")+4:]:
        print "match"
        count += 1

print count
</code></pre>
<p><code>zip</code> takes some iterators and generates tuples. In this case the <em>i</em>-th tuple is thus <code>(a[i],b[i])</code> so to speak.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short solution using <a href="https://docs.python.org/3/library/functions.html#min" rel="nofollow noreferrer">min()</a> function(<strong><em>to get a limit size of compared sequences</em></strong>):</p>
<pre><code>for i in range(min([len(a), len(b)])):
    if (a[i][a[i].index('*|*') + 3:] == b[i]):
        count += 1

print(count)
</code></pre>
<p>The output:</p>
<pre><code>1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>does the match have to be qualified as following <code>'*|*'</code> ?</p>
<p>if not then really simple is: </p>
<pre><code>sum([1 for e, f in zip(a, b) if f in e])
</code></pre>
<p>or in later versions of python where iterator args are automatically unpacked:  </p>
<pre><code>sum(f in e for e, f in zip(a, b)) # relies on bools True, False = ints 1, 0
</code></pre>
<p>if the match is just the last bit you could split</p>
<pre><code>'.ps2\n &gt;|&lt;4 *|*.ps2xml'.split(" *|*")
Out[13]: ['.ps2\n &gt;|&lt;4', '.ps2xml']

'.ps2\n &gt;|&lt;4 *|*.ps2xml'.split(" *|*")[1]
Out[14]: '.ps2xml'

sum([1 for e, f in zip(a, b) if f in e.split(" *|*")[1]])
</code></pre>
<p>and while <code>sum()</code> is more "intentional" <code>len()</code> could be used for a speed advantage since it doesn't have to iterate over the list</p>
</div>
<span class="comment-copy">What exactly is the matching pattern here?</span>
<span class="comment-copy">how <code>a[0] == b[0]</code>?</span>
<span class="comment-copy">@MoinuddinQuadri: If I understand it correctly the op uses a "special" way to match by first finding a pattern (<code>" *|*"</code>) and looks whether it is followed by the query.</span>
<span class="comment-copy">Thank you. I did not know about zip. Will read more it.</span>
