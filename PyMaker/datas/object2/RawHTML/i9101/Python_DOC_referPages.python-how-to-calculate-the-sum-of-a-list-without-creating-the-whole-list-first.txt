<div class="post-text" itemprop="text">
<p>Usually we have to (1) declare a list (2) calculate a sum of this list using <code>sum()</code></p>
<p>But now I wish to specify a list start with 1 and interval 4, 100 elements, like this:</p>
<pre><code>[1,5,9,13,17,21,25,29,33,37,…]
</code></pre>
<p>I don’t want to envolve mathematical formula, so</p>
<blockquote>
<p>(1) How to get the sum without even declaring this list?</p>
<p>(2) How to quickly get sum from 101st element to 200th element of this list?</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Simply use <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count</code></a> to get a counter and <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a> to get the required number of elements (you can iterate these instances but they don't create a list!):</p>
<pre><code>&gt;&gt;&gt; from  itertools import count, islice
&gt;&gt;&gt; sum(islice(count(1, step=4), 100))  # get the first 100 elements and sum them
19900
</code></pre>
<p>The <code>islice</code> also supports start/stop:</p>
<pre><code>&gt;&gt;&gt; sum(islice(count(1, step=4), 101, 200))  # 101st element to 200th
59499
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The built-in class <a href="https://docs.python.org/3/library/stdtypes.html#range" rel="nofollow noreferrer"><code>range</code></a> does does exactly what you want in Python 3. In Python 2, use <a href="https://docs.python.org/2/library/functions.html#xrange" rel="nofollow noreferrer"><code>xrange</code></a>. instead. For example:</p>
<pre><code>for i in range(1, 401, 4): ... 
</code></pre>
<p>The <code>range</code> object does not contain a full list. It records only the start, end and step size. The iterator will also record the current position.</p>
<p>It is important to use <code>xrange</code> in Python 2 because the range function will return the entire list, which is exactly the opposite of what you want. </p>
<pre><code>a = range(1, 401, 4)
sum(a) 
</code></pre>
<p>will compute the sum you want and allow you to reuse <code>a</code> afterwards.</p>
<p><strong>A note on the number 401</strong></p>
<p>The end of a range is exclusive. There are a couple of common formulas to get the correct number of elements in the range. <code>start + count * step</code> is the one I have chosen here because it is the easiest. It is also the largest number that will give <code>count</code> rather than <code>count + 1</code> elements to the range. <code>start + (count - 1) * step + 1</code> is the formula for the smallest number that will give you <code>count</code> elements. Since you want 100 elements, an end value of 398, 399, or 400 would give you the same result as 401. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can write a generator:</p>
<pre><code>def ir(start=1, end=400, step=4):
    while True:
        yield start
        start+=step
        if start&gt;=end: break
</code></pre>
<p>Or, if you want a specific number of elements:</p>
<pre><code>def ir(start=1, n=100, step=4):
    cnt=0
    while True:
        yield start
        cnt+=1
        start+=step
        if cnt&gt;=n: break
</code></pre>
<p>And then sum that:</p>
<pre><code> &gt;&gt;&gt; sum(ir())
 19900
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use generators with <code>sum</code> to avoid creating a list at first:</p>
<pre><code>result = sum(x for x in range(1, 401, 4))
</code></pre>
<p>As @Mad Physicist mentioned in the comment, you don't even need the <code>x for x</code> part:</p>
<pre><code>result = sum(range(1, 401, 4))
</code></pre>
</div>
<span class="comment-copy">It's not really accurate to describe Python 3's <code>range</code> object as a generator. It's a sequence object, not an iterator. In addition to reusing it, you can do stuff like <code>len(range(...))</code> and <code>range(...)[index_or_slice]</code> and it works. That's not possible with generators.</span>
<span class="comment-copy">@Blckknght. It absolutely is if the generator defines the appropriate methods. But you are right, range is not a generator since you can't call next on it.</span>
<span class="comment-copy">You can't define methods on a generator object. You create one by calling a generator function (a function with <code>yield</code> expressions in it), or using a generator expression. You can write your own iterator class, but that's not the same thing as a generator. And if you want to have <code>__len__</code> and <code>__getitem__</code> methods, you probably want your type to be a sequence (like <code>range</code> is) and not be an iterator.</span>
<span class="comment-copy">@Blckknght What if you define a class with a <code>__call__</code> method that does <code>yield</code>?</span>
<span class="comment-copy">Just so we're clear, I'm about to fix my answer because I basically agree with you. Just super slow on mobile</span>
<span class="comment-copy">Why reinvent the wheel?</span>
<span class="comment-copy">Because you can include a whole lot more in a custom function, like skip ever 20th or simulate the <a href="https://en.wikipedia.org/wiki/Leap_year" rel="nofollow noreferrer">Gregorian Calendar</a></span>
<span class="comment-copy">That's not a list comprehension and passing in range by itself is fine.</span>
<span class="comment-copy">No problem. See the comment I made for the other answer. <code>x for x in... </code> is almost never necessary.</span>
<span class="comment-copy">It's technically called a generator expression, not a comprehension: <a href="http://stackoverflow.com/documentation/python/292/generators#t=201609020956268959493">stackoverflow.com/documentation/python/292/…</a></span>
<span class="comment-copy">Last point: you are only generating 25 elements, not 100.</span>
