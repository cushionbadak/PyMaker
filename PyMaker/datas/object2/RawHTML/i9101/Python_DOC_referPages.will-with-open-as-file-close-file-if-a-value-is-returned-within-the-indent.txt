<div class="post-text" itemprop="text">
<p>I have the following function,</p>
<pre><code>def load():
    with open(PATH_CONFIG, 'r') as file:
        return json.loads(file.read())
</code></pre>
<p>Will there be a <code>file.close()</code> called? I know that the <code>with</code> keyword normally calls the <code>close()</code> method for the file at the end of the indented block, but at the same time the <code>return</code> keyword means that the rest of the function does not run. </p>
</div>
<div class="post-text" itemprop="text">
<p>Just like <code>try</code>/<code>finally</code>, <em>anything</em> that exits the <code>with</code> block (<code>return</code>, <code>break</code>/<code>continue</code> that affects a loop surrounding it, exception thrown, <code>sys.exit</code> called, etc.) will perform appropriate cleanup as execution bubbles out of the <code>with</code> block.</p>
<p>The only exceptions are:</p>
<ol>
<li>When there are actual bugs (in the interpreter, or in misuse of intrinsically dangerous tools like <code>ctypes</code>) where the interpreter itself crashes or otherwise exits "forcefully" (e.g. due to a segfault)</li>
<li>Calling <a href="https://docs.python.org/3/library/os.html#os._exit" rel="nofollow noreferrer"><code>os._exit</code></a> bypasses all cleanup procedures (that's why it should never be used in anything but forked worker processes)</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Return exits the with block like a normal dedent</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes.</p>
<p>If an exception is raised, a context manager has the option of changing its behavior, but there's no difference between a return and falling off the end of the statement body, and with few exceptions most context managers will perform their cleanup and allow the exception to propagate.</p>
<p>The idea is that it's comparable to a <code>finally</code> statement, and will be executed no matter how the block is exited. The <code>contextmanager</code> class from the standard library makes this analogy concrete.</p>
<pre><code>from contextlib import contextmanager
@contextmanager
def example():
    print('enter')
    try:
        yield
        print('unexceptional return')
    finally:
        print('exit')
</code></pre>
<p>We can use <code>with example():</code> in various ways to see how the with statement performs in a more visible example than closing a file.</p>
</div>
<span class="comment-copy">Well, the <code>return</code> takes you out of the context manager of <code>file</code>...</span>
<span class="comment-copy"><code>return</code> means the next statements do not run, and control flow goes out of current function. That does not mean nothing happens on the way out. Locals still get deallocated, exceptions' open <code>finally</code> and <code>else</code> clauses are still run andâ€¦ context managers' <code>__exit__</code> still get invoked.</span>
