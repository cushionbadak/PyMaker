<div class="post-text" itemprop="text">
<p>I have a file with the first two lines looking like this:</p>
<pre><code>(1,233)(44,444)(2323,545)(0,0)(22,2)(5,0)(222,2)(0,5)(12,2)(22,3)
(0,223)(44,424)(123,545)(0,1)(42,2)(5,0)(52,2)(0,6)(17,4)(3,3)
</code></pre>
<p>I want to read each tuple and get each number (without the commas and parenthesis). I read like this:</p>
<pre><code>file = filedialog.askopenfilename(filetypes=[("Text files","*.txt")])
if file is None:
    return False

with open(file, 'r') as f:
    lines = f.read().split("\n")
    firstLine = lines[0]
    secondLine = lines[1]

    # Run loop here to get the tuple values
    # firstNum = tuple[0]
    # secondNum = tuple[1]

    # Go to next line and do the same
</code></pre>
<p>How can I go about doing the above? Any help would be appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<h2>First way</h2>
<p>Replace all brackets and commas with spaces and then split the line removing the spaces. Thus, you obtain a flat list of all the numbers. By iterating through the list and getting the numbers at indices <code>i</code> and <code>i+1</code>, you can get them in pairs.</p>
<pre><code>&gt;&gt;&gt; line = "(1,233)(44,444)(2323,545)(0,0)(22,2)(5,0)(222,2)(0,5)(12,2)(22,3)"
&gt;&gt;&gt; line_edited = line.replace("(", " ").replace(")", " ").replace(",", " ").split()
&gt;&gt;&gt; line_edited
['1', '233', '44', '444', '2323', '545', '0', '0', '22', '2', '5', '0', '222', '2', '0', '5', '12', '2', '22', '3']
&gt;&gt;&gt; for i in xrange(0, len(line_edited), 2):
    print line_edited[i], line_edited[i+1]


1 233
44 444
2323 545
0 0
22 2
5 0
222 2
0 5
12 2
22 3
</code></pre>
<h2>Second way</h2>
<p>Similar to the first way, except that you only replace the brackets with spaces and split. Now, you get a list of strings <code>"first_number,second_number"</code>, so you iterate through those and split at the comma to get the pair.</p>
<pre><code>&gt;&gt;&gt; line_edited = line.replace("(", " ").replace(")", " ").split()
&gt;&gt;&gt; line_edited
['1,233', '44,444', '2323,545', '0,0', '22,2', '5,0', '222,2', '0,5', '12,2', '22,3']
&gt;&gt;&gt; for pair in line_edited:
    first_number, second_number = pair.split(",")
    print first_number, second_number


1 233
44 444
2323 545
0 0
22 2
5 0
222 2
0 5
12 2
22 3
</code></pre>
<p>You can read more about replacing multiple characters in a string <a href="https://stackoverflow.com/questions/3411771/multiple-character-replace-with-python">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would go for regular expressions:</p>
<pre><code>[(int(x), int(y)) for x,y in re.findall(r"\((\d+),\s*(\d+)\)", line)]
# [(1, 233), (44, 444), (2323, 545), (0, 0), (22, 2), (5, 0), (222, 2), ...]
</code></pre>
<p>Another interesting solution is to convert the line into a valid Python tuple by inserting commas between the pairs and then apply <code>ast.litereal_eval</code>:</p>
<pre><code>list(ast.literal_eval(line.replace(")", "),")))
# [(1, 233), (44, 444), (2323, 545), (0, 0), (22, 2), (5, 0), (222, 2), ...]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a relatively simple way of doing it that uses <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval()</code></a>:</p>
<pre><code>import ast

with open('tuple.txt') as file:
    for line in file:
        numbers = ast.literal_eval(line.replace(')(', '),('))
        print('numbers: {}'.format(numbers))
        for _1st_num, _2nd_num in numbers:
            print(_1st_num, _2nd_num)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>numbers: ((1, 233), (44, 444), (2323, 545), (0, 0), (22, 2), (5, 0), (222, 2), (0, 5), (12, 2), (22, 3))
1 233
44 444
2323 545
0 0
22 2
5 0
222 2
0 5
12 2
22 3
numbers: ((0, 223), (44, 424), (123, 545), (0, 1), (42, 2), (5, 0), (52, 2), (0, 6), (17, 4), (3, 3))
0 223
44 424
123 545
0 1
42 2
5 0
52 2
0 6
17 4
3 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can, also, do it like this example (i assume your input file is called <code>input_file</code>):</p>
<pre><code>data = (k.rstrip().replace("(", "").replace(")", " ").strip().split(" ") for k in open("input_file", 'r'))

for k in data:
    for j in (i.split(',') for i in k):
        print("{} {}".format(j[0], j[1]))
</code></pre>
<p>Output:</p>
<pre><code>1 233
44 444
2323 545
0 0
22 2
5 0
222 2
0 5
12 2
22 3
0 223
44 424
123 545
0 1
42 2
5 0
52 2
0 6
17 4
3 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will do it - if you can hold your gag reflex long enough:</p>
<pre><code>with open(file, 'r') as f:
    lines = f.read().split("\n")
    for line in lines:
      input=[scanf("%d,%d)",a) for a in line[1:].split('(')]
      # process each tuple in 'input' before continuing with next line
</code></pre>
<p>Maybe just go with DYZs answer.</p>
</div>
<span class="comment-copy">To be clear, do you want to get the numbers in one flat list like so: 1, 233, 44, 444, 2323, 545, etc, or do you still want them in pairs, e.g., (1, 233), (44, 444), etc?</span>
<span class="comment-copy">Whichever one would be easier so I can just do <code>firstNum = first number in tuple, secondNum = second number in tuple</code>. I'm assuming saving them in pairs would be better as I can just reference them by their index: <code>[0]</code> and <code>[1]</code>.</span>
<span class="comment-copy">Thanks for the detailed explanation! Very helpful.</span>
<span class="comment-copy">Thank you very much! I'll need to learn regex as it seems quote useful. Why is <code>eval()</code> dangerous?</span>
<span class="comment-copy">@DYZ you may be able to avoid any future scolding by using <code>ast.literal_eval</code> rather than <code>eval</code>.</span>
<span class="comment-copy">@cress <a href="http://stackoverflow.com/questions/1832940/is-using-eval-in-python-a-bad-practice" title="is using eval in python a bad practice">stackoverflow.com/questions/1832940/â€¦</a></span>
<span class="comment-copy">@PaulRooney You saved me!</span>
<span class="comment-copy">Nice. You just taught me <code>literal_eval()</code>.</span>
<span class="comment-copy">@Reti43: Thanks.<code>ast.literal_eval()</code> is a safe alternative to the built-in <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer"><code>eval()</code></a> function because it only works for strings containing expressions referencing literal values. Also note my updated answer in which I've simplified the processing even more.</span>
<span class="comment-copy">Thank you as well. Similar to Reti43's answer to strip it.</span>
<span class="comment-copy">Yes, it's the first and trivial solution. I hope it solves your question.</span>
