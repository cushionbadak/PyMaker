<div class="post-text" itemprop="text">
<p>I'm trying to write a function that returns the next element of a generator and  if it is at the end of the generator it resets it and returns the next result. The expected output of the code below would be:</p>
<pre><code>1
2
3
1
2
</code></pre>
<p>However that is not what I get obviously. What am I doing that is incorrect?</p>
<pre><code>a = '123'

def convert_to_generator(iterable):
    return (x for x in iterable)

ag = convert_to_generator(a)

def get_next_item(gen, original):
    try:
        return next(gen)
    except StopIteration:
        gen = convert_to_generator(original)
        get_next_item(gen, original)

for n in range(5):
        print(get_next_item(ag,a))

 1
 2
 3
 None
 None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is <a href="https://docs.python.org/2/library/itertools.html#itertools.cycle" rel="nofollow noreferrer">itertools.cycle(iterable)</a> a possible alternative?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to return the result of your recursive call:</p>
<pre><code>return get_next_item(gen, original)
</code></pre>
<p>which still does not make this a working approach.
The generator <code>ag</code> used in your for-loop is not changed by the rebinding of the local variable <code>gen</code> in your function. It will stay exhausted...</p>
<p>As has been mentioned in the comments, check out <a href="https://docs.python.org/2/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>the easy way is just use <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer">itertools.cycle</a>, otherwise you would need to remember the elements in the iterable if said iterable is an iterator (aka a generator) becase those can't be reset, if its not a iterator, you can reuse it many times.</p>
<p>the documentation include a example implementation</p>
<pre><code>def cycle(iterable):
    # cycle('ABCD') --&gt; A B C D A B C D A B C D ...
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
            yield element
</code></pre>
<p>or for example, to do the reuse thing </p>
<pre><code>def cycle(iterable):
    # cycle('ABCD') --&gt; A B C D A B C D A B C D ...
    if iter(iterable) is iter(iterable): # is a iterator
        saved = []
        for element in iterable:
            yield element
            saved.append(element)
    else:
        saved = iterable
    while saved:
        for element in saved:
            yield element
</code></pre>
<p>example use</p>
<pre><code>test = cycle("123")
for i in range(5):
    print(next(test))    
</code></pre>
<p>now about your code, the problem is simple, it don't remember it state</p>
<pre><code>def get_next_item(gen, original):
    try:
        return next(gen)
    except StopIteration:
        gen = convert_to_generator(original)  # &lt;-- the problem is here
        get_next_item(gen, original)          #and you should return something here
</code></pre>
<p>in the marked line a new generator is build, but you would need to update your <code>ag</code> variable outside this function to get the desire behavior, there are ways to do it, like changing your function to return the element and the generator, there are other ways, but they are not recommended or more complicated like building a class so it remember its state</p>
</div>
<div class="post-text" itemprop="text">
<p><code>get_next_item</code> is a generator, that returns an iterator, that gives you the values it <code>yield</code>s via the <code>__next__</code> method. For that reason, your statement doesn't do anything.</p>
<p>What you want to do is this:</p>
<pre><code>def get_next_item(gen, original):
    try:
        return next(gen)
    except StopIteration:
        gen = convert_to_generator(original)
        for i in get_next_item(gen, original):
            return i
</code></pre>
<p>or shorter, and completely equivalent (as long as <code>gen</code> has a <code>__iter__</code> method, which it probably has):</p>
<pre><code>def get_next_item(gen, original):
    for i in gen:
        yield i
    for i in get_next_item(convert_to_generator(original)):
        yield i
</code></pre>
<p>Or without recursion (which is a big problem in python, as it is 1. limited in depth and 2. slow):</p>
<pre><code>def get_next_item(gen, original):
    for i in gen:
        yield i
    while True:
        for i in convert_to_generator(original):
            yield i
</code></pre>
<p>If convert_to_generator is just a call to <code>iter</code>, it is even shorter:</p>
<pre><code>def get_next_item(gen, original):
     for i in gen:
         yield i
     while True:
         for i in original:
             yield i
</code></pre>
<p>or, with <code>itertools</code>:</p>
<pre><code>import itertools

def get_next_item(gen, original):
    return itertools.chain(gen, itertools.cycle(original))
</code></pre>
<p>and <code>get_next_item</code> is equivalent to itertools.cycle if <code>gen</code> is guaranteed to be an iterator for <code>original</code>.</p>
<p>Side note: You can exchange <code>for i in x: yield i</code> for <code>yield from x</code> (where <code>x</code> is some expression) with Python 3.3 or higher.</p>
</div>
<span class="comment-copy">What does <code>convert_to_generator</code> do ? Please post its code as well.</span>
<span class="comment-copy">You might be interested in <a href="https://docs.python.org/2/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle</code></a>, which also provides an example implementation.</span>
<span class="comment-copy">I added it @Jarvis</span>
<span class="comment-copy">@VincentSavard provided the answer.</span>
<span class="comment-copy">I had tried this already actually. It begins only returning the first element <code>1,2,3,1,1</code>.</span>
<span class="comment-copy">This shouldn't work, as <code>return</code> throws a <code>StopIteration</code>...</span>
<span class="comment-copy">this would fall in a infinite loop of nothing if <code>original</code> is a empty sequence</span>
<span class="comment-copy">@Copperfield what should it do differently? Stop iteration? Throw an exception? Or repeat the last element? My code snippets do exactly what mnky9800n's code does. EDIT: What he <i>wants</i> his code to do.</span>
<span class="comment-copy">simple, instead of <code>while True</code> do <code>while original</code> so it don't fall in a infinite loop of nothingness if <code>original</code> is empty</span>
<span class="comment-copy">@Copperfield that is an option, but I'd guess that throwing a exception is the better way. The problem with this is, that it is primarily opinion based. And I agree, the current solution is the worst of the bunch, but it can be expanded to fit the style of the programmer who is using it.</span>
