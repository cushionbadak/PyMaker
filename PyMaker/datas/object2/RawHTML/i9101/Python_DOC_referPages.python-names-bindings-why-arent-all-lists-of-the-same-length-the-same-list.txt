<div class="post-text" itemprop="text">
<p>I know there are tons of resources out there about pointers and references (or rather: names, and bindings!) in Python, but I am struggling to understand one last point:</p>
<p>I get that if <code>a = 1</code> and if <code>b = 1</code> than they both are 'bound' to the same exact 1 and will have the same <code>id()</code> (and therefore, I think memory address). I also get that if you set:</p>
<pre><code>a = [1, 2, 4]
b = a
b[0] = 45
# a is now [45, 2, 4]
</code></pre>
<p>because <code>a</code> and <code>b</code> are bound to the same list (object), and changes in one result in changes to another. Similarly, <code>a[0]</code> and <code>b[0]</code> are the same object. The list contains other objects with different ids - aka list identity is not bound to its contents.</p>
<p>Okay. So far so good. I can accept that there are 'unborn' lists and numbers floating around waiting to initialized (only once though!), and that Python takes care of assigning a memory space for them once we want them. Why then, if I do:</p>
<pre><code>d = [1, 2]
e = [145, 7]
# id(d) and id(e) are not the same?!
</code></pre>
<p>Shouldn't there only be a single 2-element list in Python's existence? This would be consistent to me (and then there is only a single 1, a single 2, a single 145...etc). </p>
<p>Any explanation would appreciated - and that includes ones that relate it back to pointers (since I am also somewhat mystified about the decisions that are made at a memory management level, but I suppose that's the concern of Python's execution model and not me!)</p>
</div>
<div class="post-text" itemprop="text">
<p>You are being misled by an optimization present in CPython for <code>int</code>s, namely, int-caching. See <a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">this</a> famous question. This is documented <a href="https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong" rel="nofollow noreferrer">here</a>:</p>
<blockquote>
<p>The current implementation keeps an array of integer objects for all
  integers between -5 and 256, when you create an int in that range you
  actually just get back a reference to the existing object.</p>
</blockquote>
<p>In almost every other instance, using a literal creates a <em>new object</em>. Indeed, use <code>int</code>s outside that range, and you'll see the normal behavior:</p>
<pre><code>&gt;&gt;&gt; a = 100000
&gt;&gt;&gt; b = 100000
&gt;&gt;&gt; id(a)
4322630608
&gt;&gt;&gt; id(b)
4322630640
&gt;&gt;&gt; c = a
&gt;&gt;&gt; id(a) == id(b)
False
&gt;&gt;&gt; id(a) == id(c)
True
</code></pre>
<p>And I need to repeat this almost every single day, but <em>assignment in Python <strong>never</strong> copies</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>=</code> is an assignment.</p>
<p><code>[1, 2, 3]</code> and <code>10</code> are objects.</p>
<p>if you write <code>10</code> or <code>[1, 2, 3]</code> python creates an objects. if you don't use an assignment, garbage collector will remove it. but if you do, python will assign a pointer to the newly created object to a given name/variable, ie:</p>
<pre><code>a = [1, 2]
</code></pre>
<p>next, when you assign a variable to another variable, python will copy a pointer from the first variable, ie:</p>
<pre><code>b = a
</code></pre>
<p><code>b</code> now contains pointer to the same object as <code>a</code>. but any newly created object, even if the content is the same, is a different object. so:</p>
<pre><code>id(a) != id([1, 2])
</code></pre>
<p>now, depending on implementation (so it can change at any time and you should not depend on it) there might be a "shortcut" for speed efficiency, and objects representing some common values might be created by default. and that's why on some implementations <code>id(1) == id(1)</code>, but what's confusing <code>id(5555) != id(5555)</code>.</p>
</div>
<span class="comment-copy">Euhh...Because they <b>contain different elements</b>? Say they were the same object, what would you return for <code>d[0]</code>? <code>1</code> or <code>145</code>?</span>
<span class="comment-copy">Seems like an odd question, kind of like: Why should there be more that one 2-child family in existence?</span>
<span class="comment-copy">But if I read the question correctly, the OP is not asking about <code>int</code>s, but about lists, which makes the question more, well, <i>weird</i>.</span>
<span class="comment-copy">Amazing - thank you so much. I would have never found that question on my own. I was trying hard to nod my head and be like "this is reasonable, this makes sense, there's only one of everything!" Thank goodness that's not how Python actually works</span>
<span class="comment-copy">@WillemVanOnsem True, but his intuitions are being colored by a weird exception to the general rule regarding literals.</span>
<span class="comment-copy">@HFBrowning please please please read this: <a href="http://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">nedbatchelder.com/text/names.html</a> and make sure you understand it.</span>
<span class="comment-copy">Thanks for the link @juanpa.arrivillaga, I will. This model is super different than R (where everything is copied) so I appreciate any new-to-me reference</span>
