<div class="post-text" itemprop="text">
<p>The new Python 3.6 f-strings seem like a huge jump in string usability to me, and I would love to jump in and adopt them whole heartedly on new projects which might be running on older interpreters. 2.7, 3.3-3.5 support would be great but at the very least I would like to use these in Python 3.5 code bases. How can I import 3.6's formatted string literals for use by older interpreters?</p>
<p>I understand that formatted string literals like <code>f"Foo is {age} {units} old"</code> are not breaking changes, so would not be included in a <code>from __future__ import ...</code> call. But the change is not back-ported (AFAIK) I would need to be sure that whatever new code I write with f-strings is only ran on Python 3.6+ which is a deal breaker for a lot of projects.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunatly if you want to use it you must require <code>Python 3.6+</code>, same with the matrix multiplication operator <code>@</code> and <code>Python 3.5+</code> or <code>yield from</code> (<code>Python 3.4+</code> I think)</p>
<p>These made changes to how the code is interpreted and thus throw SyntaxErrors when imported in older versions. That means you need to put them somewhere where these aren't imported in older Pythons or guarded by an <code>eval</code> or <code>exec</code> (I wouldn't recommend the latter two!).</p>
<p>So yes, you are right, if you want to support multiple python versions you can't use them easily.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://github.com/asottile/future-fstrings" rel="noreferrer">future-fstrings</a> brings f-strings to Python 2.7 scripts. (And I assume 3.3-3.5 based on the documentation.)</p>
<p>Once you pip install it via <code>pip install future-fstrings</code>, you have to place a special line at the top of your code. That line is:</p>
<pre><code># -*- coding: future_fstrings -*-
</code></pre>
<p>Then you can use formatted string literals (f-strings) within your code:</p>
<pre><code># -*- coding: future_fstrings -*-
var = 'f-string'
print(f'hello world, this is an {var}')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>here's what I use:</p>
<pre><code>text = "Foo is {age} {units} old".format(**locals())
</code></pre>
<p>it unpacks (<code>**</code>) the dict returned by <code>locals()</code> which has all your local variables as a dict <code>{variable_name: value}</code></p>
<p><strong>Note</strong> this will not work for variables declared in an outer scope, unless you import it to the local scope with <code>nonlocal</code> (Python 3.0+).</p>
<p>you can also use</p>
<pre><code>text.format(**locals(),**globals())
</code></pre>
<p>to include global variables in your string.</p>
</div>
<div class="post-text" itemprop="text">
<p>The f-strings are created by the interpreter upon tokening the <code>f</code> prefix - that feature alone will kill any compatibility chances.</p>
<p>Your closest shot is to use the keyword formatting, like </p>
<pre><code>'Foo is {age} {units} old'.format(age=age, units=units)
</code></pre>
<p>which can be more easily refactored upon the termination of requirement for compatibility. </p>
</div>
<div class="post-text" itemprop="text">
<p>I just wrote a back-port compiler for <em>f-string</em>, called <a href="https://github.com/JarryShaw/f2format#f2format" rel="nofollow noreferrer"><code>f2format</code></a>. Just as you requests, you may write <em>f-string</em> literals in <strong>Python 3.6</strong> flavour, and compile to a compatible version for end-users to run, just like <a href="https://github.com/babel/babel" rel="nofollow noreferrer"><code>Babel</code></a> for JavaScript.</p>
<p><code>f2format</code> provides an intelligent, yet imperfect, solution of a <strong>back-port compiler</strong>. It shall replace <em>f-string</em> literals with <code>str.format</code> methods, whilst maintaining the original layout of source code. You can simply use</p>
<p><code>f2format /path/to/the/file_or_directory</code></p>
<p>which will rewrite all Python files in place. For instance,</p>
<p><code>var = f'foo{(1+2)*3:&gt;5}bar{"a", "b"!r}boo'</code></p>
<p>will be converted to</p>
<p><code>var = ('foo{:&gt;5}bar{!r}boo').format(((1+2)*3), ("a", "b"))</code></p>
<p>String concatenation, conversion, format specification, multi-lines and unicodes are all treated right. Also, <code>f2format</code> will archive original files in case there're any syntax breaches.</p>
</div>
<span class="comment-copy">Is there any reason not to use the package `future-fstrings' as mentioned in an answer below? I appreciate this option may not have been available when you answered this question in any case.</span>
<span class="comment-copy">@Siwel It's a really clever way to backport this. I don't think there are any serious reasons to not use it. However using a custom encoding could probably conflict with some IDEs. I don't think it's opposed to <a href="https://www.python.org/dev/peps/pep-0263/" rel="nofollow noreferrer">PEP 263 Defining Python Source Code Encodings</a> but it's not really the use-case the "encoding line" was made for. However, it's a very clever approach and I'll certainly test it in the future.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/stdtypes.html?highlight=format_map#str.format_map" rel="nofollow noreferrer">format_map</a> can be a useful workaround if passed the <code>locals()</code> variables dictionary... haven't tested it myself, but it should work</span>
<span class="comment-copy">Unfortunately this breaks emacs: <code>Warning (mule): Invalid coding system </code>future_fstrings' is specified`</span>
<span class="comment-copy">If you remove <code>-*-</code> bits then Python will still recognize it.</span>
<span class="comment-copy">This works but this kind of "hacks" should probably be avoided, in my humble opinion!</span>
<span class="comment-copy">If using this method, and assuming age and units are already variables, it would probably make more sense to write this as <code>'Foo is {age} {units} old'.format(age=age, units=units)</code> for python2.7 so it can be quickly be updated to <code>f'Foo is {age} {units} old'</code> when moving to python3.6</span>
<span class="comment-copy">@petiepooo updated</span>
<span class="comment-copy">What about <code>'Foo is {age} {units} old'.format(**locals(), **globals())</code>?</span>
<span class="comment-copy">@MadPhysicist , works but considered bad form, due to including the kitchen sink in a format call.</span>
<span class="comment-copy">@GringoSuave. Agreed, but that's pretty close to how an actual f-string is evaluated.</span>
<span class="comment-copy">I hope it's open source because i'm not letting a random program run over my source code :(</span>
<span class="comment-copy">@Walter yes, it is open source under Apache License 2.0; just check out the <a href="https://github.com/JarryShaw/f2format/" rel="nofollow noreferrer">repo</a> :)</span>
