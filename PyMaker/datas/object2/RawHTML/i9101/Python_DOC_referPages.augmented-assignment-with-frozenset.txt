<div class="post-text" itemprop="text">
<p>I just tried an augmented assignment on a frozenset, and the result surprised me:</p>
<pre><code>&gt;&gt;&gt; x = frozenset(['foo', 'bar', 'baz'])
&gt;&gt;&gt; x
frozenset({'foo', 'baz', 'bar'})
&gt;&gt;&gt; x &amp;= {'baz', 'qux', 'quux'}
&gt;&gt;&gt; x
frozenset({'baz'})
</code></pre>
<p>This isn't supposed to happen, is it?  Aren't frozensets immutable?</p>
</div>
<div class="post-text" itemprop="text">
<p>Why are you surprised? </p>
<p>You knew the term "augmented assignment" so there is no problem finding the <a href="https://docs.python.org/reference/datamodel.html#object.__iand__" rel="nofollow noreferrer">"Python Data Model on augmented arithmetic assignments"</a> (emphasis mine):</p>
<blockquote>
<p>These [<code>__i***__</code>] methods should attempt to do the operation in-place (modifying self) and return the result (which could be, but does not have to be, self). <strong>If a specific method is not defined, the augmented assignment falls back to the normal methods.</strong> For instance, if <code>x</code> is an instance of a class with an <code>__iadd__()</code> method, x += y is equivalent to <code>x = x.__iadd__(y)</code> . Otherwise, <code>x.__add__(y)</code> and <code>y.__radd__(x)</code> are considered, [...]</p>
</blockquote>
<pre><code>&gt;&gt;&gt; x = frozenset(['foo', 'bar', 'baz'])
&gt;&gt;&gt; x.__iand__
[...]
AttributeError: 'frozenset' object has no attribute '__iand__'
</code></pre>
<p>So it has no <code>__iand__</code> method so the code you perform is:</p>
<pre><code>&gt;&gt;&gt; x = x &amp; {'baz', 'qux', 'quux'}
</code></pre>
<p>The <code>__and__</code> method however is defined by <code>frozenset</code>:</p>
<pre><code>&gt;&gt;&gt; x &amp; {'baz', 'qux', 'quux'}
frozenset({'baz'})
</code></pre>
<p>However you lost your reference to the original <code>frozenset</code>: <code>x</code>:</p>
<pre><code>&gt;&gt;&gt; y = x   # that doesn't do a copy, it's just to check if `x` has changed"
&gt;&gt;&gt; x &amp;= {'baz', 'qux', 'quux'}
&gt;&gt;&gt; x is y  # check if they reference the same object!
False
&gt;&gt;&gt; x, y
(frozenset({'baz'}), frozenset({'bar', 'baz', 'foo'}))
</code></pre>
<p>But that just follows the <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment" rel="nofollow noreferrer">"Principle of least astonishment"</a>. You wanted the <code>__and__</code> and you made it clear that you didn't want to keep your original <code>x</code> - an in-place operation also would have altered it!</p>
<p>So again: Why did that surprise you?</p>
</div>
<div class="post-text" itemprop="text">
<p>Frozensets <em>are</em> immutable, except your assignment isn't mutating the original frozenset - you are just reassigning the variable <code>x</code> to the result of your binary operator <code>&amp;</code>. As noted by user2357112 in the comments, <code>x &amp;= {'baz', 'qux', 'quux'}</code> falls back on <code>x = x  &amp; {'baz', 'qux', 'quux'}</code> after an <a href="https://docs.python.org/3/reference/datamodel.html#object.__iand__" rel="nofollow noreferrer"><code>__iand__</code></a> method is not found, leaving you with a non-mutating operation. </p>
<p>This behavior can be seen for other augmented operations on immutable types that don't supply <code>__iand__</code>, e.g. </p>
<pre><code>In[1]: x = (1, 2, 3)
In[2]: id(x)
Out[2]: 761782862328
In[3]: x += (4, 5)
In[4]: id(x)   # we now have a different id
Out[4]: 761780182888
In[5]: x[2] = 3  # an actual mutating operation
TypeError: 'tuple' object does not support item assignment
</code></pre>
</div>
<span class="comment-copy">Check the <code>id</code> of <code>x</code> before and after the operation.</span>
