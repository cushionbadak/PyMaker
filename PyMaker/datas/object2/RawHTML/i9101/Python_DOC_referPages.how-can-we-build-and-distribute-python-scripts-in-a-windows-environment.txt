<div class="post-text" itemprop="text">
<p>My team is enjoying using python to solve problems for our business. We write many small independent scripty applications.</p>
<p>However, we have to have a central windows box that runs these along with legacy applications.</p>
<p>Our challenge is going through a build and deploy process.</p>
<p>We want to have Bamboo check the script out of git, install requirements and run tests, then if all is green, just deploy to our production box.</p>
<p>We'd like libraries to be isolated from script to script so we don't have dependency issues.</p>
<p>We've tried to get virtualenvs to be portable but that seems a no go.</p>
<p>Pex looked promising, but it doesn't work on windows.</p>
<p>Ideally you'd see a folder like so:</p>
<pre><code>AppOne
  /Script.py
  /Libs
    /bar.egg
    /foo.egg
AppTwo
  /Script2.py
  /Libs
    /fnord.egg
    /fleebly.py
</code></pre>
<p>Are we thinking about this wrong? What's the pythonic way to distribute scripts within an enterprise?</p>
</div>
<div class="post-text" itemprop="text">
<p>You may be able to do that with a neat if relatively unknown <a href="https://bugs.python.org/issue1739468" rel="nofollow noreferrer">feature</a> that was <a href="https://docs.python.org/2/whatsnew/2.6.html#other-language-changes" rel="nofollow noreferrer">sneaked into Python 2.6</a> without much ado: executing zip files as Python applications. It got a bit (just a bit) more of publicity after <a href="https://www.python.org/dev/peps/pep-0441/" rel="nofollow noreferrer">PEP 441</a> (which is the one PEX is inspired in), although I think most people is still unaware of it. The idea is that you create a zip file (the recommeded extension is <code>.pyz</code> or <code>.pyzw</code> for windowed applications, but that's obviously not important) with all the code and modules that you want and then you simply run it with Python. The interpreter will add the contents of the zip file to <code>sys.path</code> and look for a top level module named <code>__main__</code> and run it. Python 3.5 even introduced the convenience module <a href="https://docs.python.org/3/library/zipapp.html" rel="nofollow noreferrer"><code>zipapp</code></a> to create such packaged applications, but there is really no magic in it and you may as well create it by hand or script.</p>
<p>In your case, I guess Bamboo could do the check out, dependency install and tests in virtualenvs and then package the application along with the environment libraries. It's not a one-click solution but it may do the trick without additional tools.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>TL:DR:</strong><br/>
Use <a href="https://www.docker.com/what-docker" rel="nofollow noreferrer">Docker</a></p>
<hr/>
<p><strong>A short story long:</strong></p>
<p>You can use docker to create an independent image for every script that you want to deploy. </p>
<p>You can install a <a href="https://hub.docker.com/_/python/" rel="nofollow noreferrer">python image</a> (<code>slim</code> is the lightest) as a base environment for each script or a group of scripts/applications and use it like a "virtualenv" in which you can install all your dependencies for that script.</p>
<p>There is also an integration for <a href="https://confluence.atlassian.com/bamboo/getting-started-with-docker-and-bamboo-687213473.html" rel="nofollow noreferrer">Bamboo and Docker</a> which you may find useful.</p>
<p>Here is the <a href="https://docs.docker.com/" rel="nofollow noreferrer">Docker documentation</a> for reference.</p>
<p>You can test each script individually in a separated container and if it passes then you can use the same container to deploy it in your main server.</p>
<p>It is not exactly what you are asking, but you can use this solution in every platform (Windows, Linux, etc.), you can deploy all your scripts to the enterprise server (or anywhere for that matter) and use them across your company.  </p>
<p><hr/>
<strong>Disclaimer:</strong> This is not THE solution, it is a solution that I am aware of which applies to the time of this answer (2017)</p>
</div>
<div class="post-text" itemprop="text">
<p>Another possibility is pyinstaller. It creates an executable that can be deployed. Python is not even required to be installed on the deployed production box. It is harder to debug problems that occur only on the deployed box. You also can't modify the scripts on the deployed box which depending on your trust of the owners of the machine is either a positive or negative. See <a href="http://www.pyinstaller.org/" rel="nofollow noreferrer">http://www.pyinstaller.org/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As I understand it, you want to create self-contained application directories on a build server, then copy them over to a production server and run scripts directly from them. In particular, you want all dependencies (your own and external packages) installed within a <code>Libs</code> subdirectory in each application directory. Here's a fairly robust way to do that:</p>
<ol>
<li>Create the top-level application directory (<code>AppOne</code>) and the <code>Libs</code> subdirectory inside it.</li>
<li>Use <code>pip install --ignore-installed --target=Libs package_name</code> to install dependencies into the <code>Libs</code> subdirectory.</li>
<li>Copy your own packages and modules into the <code>Libs</code> subdirectory (or install them there with pip).</li>
<li>Copy Script.py into the top-level directory.</li>
<li><p>Include code at the top of <code>Script.py</code> to add the <code>Libs</code> directory to <code>sys.path</code>:</p>
<pre><code>import os, sys
app_path = os.path.dirname(__file__)
lib_path = os.path.abspath(os.path.join(app_path, 'Libs'))
sys.path.insert(0, lib_path)
</code></pre></li>
</ol>
<p>This will make packages like <code>Libs\bar.egg</code> and modules like <code>Libs\fleebly.py</code> available to your script via <code>import bar</code> or <code>import fleebly</code>. Without code like this, there is no way for your script to find those packages and modules.</p>
<p>If you want to streamline this part of your script, there are a couple of options: (1) Put these lines in a separate <code>fix_path.py</code> module in the top-level directory and just call <code>import fix_path</code> at the start of your script. (2) Create a <code>Libs\__init__.py</code> file with the line <code>sys.path.insert(0, os.path.dirname(__file__))</code>, and then call <code>import Libs</code> from your script. After that, <code>Libs\x</code> can be imported via <code>import x</code>. This is neat, but it's a nonstandard use of the package and path mechanisms (it uses <code>Libs</code> as both a library directory and a package), so it could create some confusion about how importing works.</p>
<p>Once these directories and files are in place, you can copy this whole structure over to any Windows system with Python installed, and then run it using <code>cd AppOne; python Script.py</code> or <code>python AppOne\Script.py</code>. If you name your top-level script <code>__main__.py</code> instead of <code>Script.py</code>, then you can run your app just by executing <code>python AppOne</code>. </p>
<p>Further, as @jdehesa pointed out, if your script is named <code>__main__.py</code>, you can compress the contents of the <code>AppOne</code> directory (but not the <code>AppOne</code> directory itself) into a file called <code>AppOne.zip</code>, and then copy that to your production server and run it by calling <code>python AppOne.zip</code>. (On Python 3.5 or later, you can also create the zip file via <code>python -m zipapp AppOne</code> if your script is called <code>__main__.py</code>. You may also be able to use  <code>python -m zipapp AppOne -m Script</code> if your script is called <code>Script.py</code>. See <a href="https://docs.python.org/3/library/zipapp.html" rel="nofollow noreferrer">https://docs.python.org/3/library/zipapp.html</a>.)</p>
</div>
<div class="post-text" itemprop="text">
<p>This kind of thing can be easily dealt with python setup.py</p>
<p>Sample setup.py</p>
<pre><code>from setuptools import setup

setup(
    name=name_for_distribution,
    version=version_number,
    py_modules=[pythonfiles],
    install_requires=[
        python packages that need to be installed
    ]
)
</code></pre>
<p>Create a virtual environment , activate it and run :
python setup.py install</p>
<p>I feel this is the most pythonic way to distribute and package your project.</p>
<p>Reading links:</p>
<p><a href="https://pythonhosted.org/an_example_pypi_project/setuptools.html" rel="nofollow noreferrer">https://pythonhosted.org/an_example_pypi_project/setuptools.html</a>
<a href="https://docs.python.org/2/distutils/setupscript.html" rel="nofollow noreferrer">https://docs.python.org/2/distutils/setupscript.html</a></p>
</div>
<span class="comment-copy">First of all please look into the Wheel format (<code>.whl</code>), it supersedes <code>.egg</code> and could make your life a bit easier</span>
<span class="comment-copy">Anyway, have you tried just packaging your scripts as normal python libs, uploading them to a server managed by your company and then just installing via <code>pip</code> wherever necessary?</span>
<span class="comment-copy">We use both wheels and eggs. They aren't really causing us problems either way. We do package and depend on some internal libs. However, you are talking about having your PROD box pulling from pip to install the dependencies instead of having a build box push a built app to the prod server. At that point, you're having your production box installing things itself and pulling from the internet.</span>
<span class="comment-copy">yes, except that I meant an internal PyPI mirror, rather than 'the internet'</span>
<span class="comment-copy">Agreed - not the internet.  But we want to know that what is deployed in production was built on our build server and then pushed out.</span>
<span class="comment-copy">nowadays <code>docker</code> becomes essential for enterprise products development</span>
<span class="comment-copy">Indeed @AzatIbrakov</span>
<span class="comment-copy">Hey @Mattk I was passing through my answers. Did you find my answer helpful? Care to accept?</span>
<span class="comment-copy">actually relative path to "the main script" works just fine, we just have a one-liner (plus import): <code>sys.path.append('Libs')</code>. The <code>__init__</code> file adding the libs - at first it sounds sexy but I prefer a bootstrap.py which is in the app dir containing that code.</span>
<span class="comment-copy">@dualed, Relative paths are calculated relative to the process's current working directory, which is usually the directory from which you started the script. So if someone starts the script from outside <code>AppOne</code> (e.g., they go up a level and call <code>python AppOne\__master__.py</code> or  <code>python AppOne</code>), then <code>sys.path.append('Libs')</code> will not point to the <code>AppOne\Libs</code> directory and the script will break. The code I suggested is much more stable, since it calculates the path relative to the script's location, not the current working directory.</span>
