<div class="post-text" itemprop="text">
<p>I've been struggling for a couple of days with the proper way to address this solution, and I am seeking some assistance.</p>
<p>I have two files and need to create a third that shows the relationship.</p>
<ol>
<li>IP Address file - ip.csv</li>
<li>Subnet file - subnet.csv</li>
</ol>
<p>I need to specify what subnet that each IP is in, and create a third file</p>
<p>The ip.csv file will contain about 1.5 million IP's and the subnet.csv file will contain around 140,000 subnets.</p>
<p>ip.csv file sample:</p>
<pre class="lang-none prettyprint-override"><code>IP,Type
10.78.175.167,IPv4
10.20.3.56,IPv4
</code></pre>
<p>subnet.csv file sample:</p>
<pre class="lang-none prettyprint-override"><code>Subnet,Netmask
10.176.122.136/30,255.255.255.252
10.20.3.0/24,255.255.254.0
</code></pre>
<p>Format of file I need to create:</p>
<pre class="lang-none prettyprint-override"><code>Subnet,IP
10.20.3.0/24,10.20.3.56
</code></pre>
<p>I've tried to make use of things from these pages:</p>
<ul>
<li><a href="https://pypi.python.org/pypi/pysubnettree/0.23" rel="nofollow noreferrer">subnettree module</a></li>
<li><a href="https://docs.python.org/3/library/ipaddress.html#module-ipaddress" rel="nofollow noreferrer">ipaddress module</a></li>
<li><a href="http://terminalmage.net/2012/06/10/how-to-find-out-the-cidr-notation-for-a-subnet-given-an-ip-and-netmask.html" rel="nofollow noreferrer">random page with cidr help</a></li>
<li><a href="http://cmikavac.net/2011/09/11/how-to-generate-an-ip-range-list-in-python/" rel="nofollow noreferrer">IP range help</a></li>
</ul>
<p>This is the code that I have tried.  It works on small sets, but I'm having problems running it with the full set of files.</p>
<pre><code>#!/usr/local/bin/python2.7
import csv
import ipaddress
import iptools
import re
import SubnetTree
import sys
from socket import inet_aton

testdir = '/home/test/testdir/'
iprelfile = testdir + 'relationship.csv'
testipsub = testdir + 'subnet.csv'
testipaddr = testdir + 'ip.csv'

o1 = open (iprelfile, "a")

# Subnet file
IPR = set()
o1.write('Subnet,IP\n')
with open(testipsub, 'rb') as master:
    reader = csv.reader(master)
    for row in reader:
        if 'Subnet' not in row[0]:
            # Convert string to unicode to be parsed with ipaddress module
            b = unicode(row[1])
            # Using ipaddress module to create list containing every IP in subnet
            n2 = ipaddress.ip_network(b)
            b1 = (list(n2.hosts()))
            # IP address file
            with open(testipaddr, 'rb') as ipaddy:
                readera = csv.reader(ipaddy)
                for rowa in readera:
                    if 'IP' not in rowa[0]:
                        bb = rowa[0]
                        for ij in b1:
                            # Convert to string for comparison
                            f = str(ij)
                            # If the IP address is in subnet range
                            if f == bb:
                                IPR.update([row[0] + ',' + bb + '\n'])


for ip in IPR:
    o1.write(ip + '\n')

# Closing the file
o1.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could read all the subnets to memory and sort them by network address. This would allow you to use <a href="https://docs.python.org/3.6/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code></a> to do a binary search in order to find the subnet for every IP. This only works if the subnets don't overlap each other, if they do you'll probably need to use <a href="https://stackoverflow.com/questions/18179680/finding-a-set-of-ranges-that-a-number-fall-in">segment tree</a>.</p>
<pre><code>import bisect
import csv
import ipaddress

def sanitize(ip):
    parts = ip.split('/', 1)
    parts[0] = '.'.join(str(int(x)) for x in parts[0].split('.'))

    return '/'.join(parts)

with open('subnet.csv') as subnet_f:
    reader = csv.reader(subnet_f)
    next(reader)    # Skip column names

    # Create list of subnets sorted by network address and
    # list of network addresses in the same order
    subnets = sorted((ipaddress.IPv4Network(sanitize(row[0])) for row in reader),
                     key=lambda x: x.network_address)
    network_addrs = [subnet.network_address for subnet in subnets]

with open('ip.csv') as ip_f, open('output.csv', 'w', newline='') as out_f:
    reader = csv.reader(ip_f)
    next(reader)

    writer = csv.writer(out_f)
    writer.writerow(['Subnet', 'IP'])

    for row in reader:
        ip = ipaddress.IPv4Address(sanitize(row[0]))
        index = bisect.bisect(network_addrs, ip) - 1

        if index &lt; 0 or subnets[index].broadcast_address &lt; ip:
            continue    # IP not in range of any networks
        writer.writerow([subnets[index], ip])
</code></pre>
<p>Output:</p>
<pre><code>Subnet,IP
10.20.3.0/24,10.20.3.56
</code></pre>
<p>Above has time complexity of <strong>O(n log m)</strong> where n is the number of IPs and m number of networks. Note that it only runs with Python 3 since <a href="https://docs.python.org/3/library/ipaddress.html#module-ipaddress" rel="nofollow noreferrer"><code>ipaddress</code></a> is not included to Python 2.7. If you need to use Python 2.7 there are <a href="https://pypi.python.org/pypi/ipaddress" rel="nofollow noreferrer">backports</a> available. </p>
<p><strong>Update</strong> The first goal for efficient solution is to find a way to process each individual IP in efficient manner. Looping through all subnets is terribly expensive so it won't do. It's much better to create a sorted list of first IP in each subnet. For given data it would look like this:</p>
<pre><code>[IPv4Address('10.20.3.0'), IPv4Address('10.176.122.136')]
</code></pre>
<p>This will allow us to execute binary search in order to find index of IP address that is equal or lower than individual IP. For example when we search for IP 10.20.3.56 we use <code>bisect.bisect</code> to provide us the first index greater than IP and decrement it by one:</p>
<pre><code>&gt;&gt;&gt; l = [IPv4Address('10.20.3.0'), IPv4Address('10.176.122.136')]
&gt;&gt;&gt; index = bisect.bisect(l, IPv4Address('10.20.3.56'))
&gt;&gt;&gt; index
1
&gt;&gt;&gt; l[index - 1]
IPv4Address('10.20.3.0')
</code></pre>
<p>Since we have stored the networks to another list which is in the same order we can use index to retrieve given subnet. Once we have the subnet we still need to check that the individual IP is equal or lower than the last IP within the subnet. If the individual IP is within the subnet then write a row to result, if not move to next IP.</p>
</div>
<span class="comment-copy">What kind of problems? Errors or low speed?</span>
<span class="comment-copy">You should open the two first CSV files at the same time, not open the second one for every line of the first file</span>
<span class="comment-copy">I'm fairly new to Python.  Can you help me swap my code so that I'm opening the files at the same time?</span>
<span class="comment-copy">It's just really slow, no errors.  If I do a small sample, it works fine.</span>
<span class="comment-copy">maybe first read all subnets and later read IPs and check with every subnet. You cound use dictionary (or binary-tree) to search subnets which you have to check.</span>
<span class="comment-copy">Python3 and can run the script for most of the data.  The problem I'm running into is that it is failing if there is an IPv6 address.  I am also getting problems if someone has a leading zero.  For example, if there is an IP like 192.168.010.199 instead of 192.168.10.199.  Also, what if my source file has more than two columns?</span>
<span class="comment-copy">@DDIGuy Updated answer to handle longer rows, do input sanitation to remove leading zeros and added longer explanation.</span>
<span class="comment-copy">thanks for the explanation.  any suggestions on what to do if i have a mix of IPv4 and IPv6?  Should I run through this once for the IPv4 and then do it again for IPv6?  Or is there an easy way to add it here.</span>
<span class="comment-copy">@DDIGuy: Probably the easiest way is to have two scripts, one for IPv4 and another for IPv6. Shouldn't be that difficult to modify to skip IPv6 and the other one to use IPv6 related classes instead and skip IPv4.</span>
<span class="comment-copy">thanks for the help.  I'll give it a go tomorrow and post the results.</span>
