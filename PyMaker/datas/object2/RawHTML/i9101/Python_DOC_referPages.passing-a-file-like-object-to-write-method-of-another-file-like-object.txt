<div class="post-text" itemprop="text">
<p>I am trying to get a large file from the web, and stream it directly into the zipfile writer provided by the <code>zipfile</code> module, something like:</p>
<pre class="lang-python prettyprint-override"><code>from urllib.request import urlopen
from zipfile import ZipFile

zip_file = ZipFile("/a/certain/local/zip/file.zip","a")
entry = zip_file.open("an.entry","w")
entry.write( urlopen("http://a.certain.file/on?the=web") )
</code></pre>
<p>Apparently, this doesn't work because <code>.write</code> accepts a <code>bytes</code> argument, not an I/O reader. However, since the file is rather large I don't want to load the whole file into RAM before compressing it.</p>
<p>The simple solution is to use bash (never really tried, could be wrong):</p>
<pre class="lang-bash prettyprint-override"><code>curl -s "http://a.certain.file/on?the=web" | zip -q /a/certain/local/zip/file.zip
</code></pre>
<p>but it wouldn't be a very elegant, nor convenient, thing to put a single line of bash in a Python script.</p>
<p>Another solution is to use <code>urllib.request.urlretrieve</code> to download the file and then pass the path to <code>zipfile.ZipFile.open</code>, but that way I would still have to wait for the download to complete, and besides that also consume a lot more disk I/O resource.</p>
<p>Is there a way, in Python, to directly pass the download stream to a zipfile writer, like the the bash pipeline above?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobj" rel="nofollow noreferrer"><code>shutil.copyfileobj()</code></a> to efficiently copy data between file objects:</p>
<pre><code>from shutil import copyfileobj

with ZipFile("/a/certain/local/zip/file.zip", "w") as zip_file:
    with zip_file.open("an.entry", "w") as entry:
        with urlopen("http://a.certain.file/on?the=web") as response:
            shutil.copyfileobj(response, entry)
</code></pre>
<p>This'll call <code>.read()</code> with a given chunksize on the source file object, then pass that chunk to the <code>.write()</code> method on the target file object.</p>
<p>If you are using Python 3.5 or older (where you can't yet directly write to a <code>ZipFile</code> member), your only option is to stream to a temporary file first:</p>
<pre><code>from shutil import copyfileobj
from tempfile import NamedTemporaryFile

with ZipFile("/a/certain/local/zip/file.zip", "w") as zip_file:
    with NamedTemporaryFile() as cache:
        with urlopen("http://a.certain.file/on?the=web") as response:
            shutil.copyfileobj(response, cache)
            cache.flush()
            zipfile.write('an.entry', cache.name)
</code></pre>
<p>Using a <code>NamedTemporaryFile()</code> like this only works on POSIX systems, on Windows, you can't open the same filename again, so you'd have to use a <a href="https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp" rel="nofollow noreferrer"><code>tempfile.mkstemp()</code> generated name</a>, open the file from there, and use <code>try...finally</code> to clean up afterwards.</p>
</div>
<span class="comment-copy">you have some alternatives like <code>gzopen</code> to create a .gz file.</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre I need an archive, so in that case I would need <code>tar</code> if I want to use <code>gzip</code>.</span>
<span class="comment-copy">you can use <code>.read(size)</code> to get data in chunk</span>
<span class="comment-copy">problem is that <a href="https://docs.python.org/3.5/library/zipfile.html#zipfile.ZipFile.open" rel="nofollow noreferrer">zip_file.open()</a> can be used only to read - <code>"r"</code>. And <a href="https://docs.python.org/3.5/library/zipfile.html#zipfile.ZipFile.write" rel="nofollow noreferrer">ZipFile.write()</a> expects only filename :(</span>
<span class="comment-copy">@furas: I was looking at the <a href="https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile.open" rel="nofollow noreferrer">Python 3.6 revision</a>.</span>
<span class="comment-copy">@furas: For Python &lt; 3.6, you'd have to add a <code>NamedTempFile()</code> in between, I fear.</span>
<span class="comment-copy">Luckily I'm using Python 3.6. Just for the sake of understanding, doesn't copying to <code>cache</code> block until the download is complete?</span>
<span class="comment-copy">@busukxuan: yes, the <code>copyfileobj()</code> call won't return until <code>response.read()</code> no longer produces data (and that data was written out to <code>cache</code>).</span>
