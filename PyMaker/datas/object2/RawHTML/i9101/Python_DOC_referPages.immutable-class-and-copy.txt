<div class="post-text" itemprop="text">
<p>For a class which is intended to be used as immutable, such as:</p>
<pre><code>class Immutable:
    def __init__(self, field):
        self._field = field
    def field(self):
        return self._field
</code></pre>
<p>is it ok, to return <code>self</code> in <code>__copy__</code>?</p>
<pre><code>    def __copy__(self):
        return self
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your goal is to make it so that users of your class can safely call <code>copy.copy</code> on its instances, then by all means feel free to add a <code>__copy__</code> method:</p>
<pre><code>def __copy__(self): 
    return self
</code></pre>
<p>However, this isn't really necessary. The documentation for your class should make it clear that its instances are immutable, so anyone using your class should know that they can safely re-use an instance if they want to refer to it in multiple places, just like they do with the built-in immutable types like <code>int</code>, <code>str</code>, <code>tuple</code>, and <code>frozenset</code>. Eg,</p>
<pre><code>a, b, c = Immutable(123), Immutable(456), 42
d = {'one': a, 'two': b, 'three': c}
</code></pre>
<p>If you don't supply a <code>__copy__</code> method and someone <em>does</em> call <code>copy.copy</code> on an instance, then they'll get a new object that's a clone of the original instance. With <code>__copy__</code> defined as above they will of course just get a reference to the original object.</p>
<p>BTW, you should make <code>.field</code> (and any other attributes) into a <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">property</a>, and don't supply a setter.</p>
<pre><code>class Immutable:
    def __init__(self, field):
        self._field = field

    @property
    def field(self):
        return self._field
</code></pre>
<p>And now you can call the field method as if it were a simple attribute:</p>
<pre><code>a = Immutable(123) 
print(a.field)
</code></pre>
<p>Of course, you can still mutate the <code>._field</code> attribute in the normal way, but anyone using your class ought to know they aren't supposed to do that. :)</p>
<hr/>
<p>In the question comments we discussed the fact that calling <code>copy.copy</code> on a tuple returns a reference to the original tuple, even though <code>tuple</code> doesn't define <code>__copy__</code>. None of the built-in types define <code>__copy__</code>, but bear in mind that they are all defined in C, so they work a little differently to classes defined in Python. FWIW, calling <code>copy.copy</code> on any of the built-in immutable types returns a reference to the original object, and calling <code>copy.copy</code> on any of the built-in mutable types returns a clone.</p>
</div>
<span class="comment-copy">Not a bit in the above code makes  this class immutable.</span>
<span class="comment-copy">@DeepSpace of course, it's Python. That's why I said "intended to be used".</span>
<span class="comment-copy">"of course, it's Python." There <b>are</b> ways to make a class immutable in Python.</span>
<span class="comment-copy">@DeepSpace sure. Above example, named tuple subclass, custom <code>__setattr__</code>, ... whatever, is it ok to return <code>self</code> from <code>__copy__</code>?</span>
<span class="comment-copy">No, the above example is not immutable at all. As such, it doesn't matter what <code>__copy__</code> returns.</span>
