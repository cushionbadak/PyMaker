<div class="post-text" itemprop="text">
<p>Consider the code in the file my_module.py:</p>
<pre><code>class A(object):
  def __init__(self, x=er()):
    self.x = x
</code></pre>
<p>Now, when I import this module</p>
<pre><code>import my_module
</code></pre>
<p>I get an error,</p>
<pre><code>name 'er is not defined
</code></pre>
<p>While I understand that my_module does not have <code>er</code> defined, but I am never creating an instance of <code>class A</code>. Therefore it is puzzling that python tries to execute the <code>__init__</code> callback when simply importing the module. Although, the <code>__init__</code> call is not fully executed as explained by the example below:</p>
<pre><code>class A(object):
  def __init__(self, x=5):
    self.x = x
    print ('I am here')
</code></pre>
<p>Now, when I import the module - nothing is printed and this is expected behavior. </p>
<p>I am puzzled why is function <code>er</code> called in the first example when I donot instantiate an object of <code>class A</code>. Any pointers to the documentation that explains this? </p>
</div>
<div class="post-text" itemprop="text">
<p>Because in Python, default argument values are evaluated at <em>definition time</em>. See, for example this <a href="https://stackoverflow.com/questions/1651154/why-are-default-arguments-evaluated-at-definition-time-in-python">question</a>, or <a href="https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument">this notorious question</a>. </p>
<p>This is documented <a href="https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions" rel="nofollow noreferrer">here</a></p>
<blockquote>
<p>The default values are evaluated at the point of function definition
  in the defining scope, so that</p>
<pre><code>i = 5

def f(arg=i):
    print(arg)

i = 6
</code></pre>
<p><code>f()</code> will print 5.</p>
<p><strong>Important warning</strong>: The default value is evaluated only once. This
  makes a difference when the default is a mutable object such as a
  list, dictionary, or instances of most classes. For example, the
  following function accumulates the arguments passed to it on
  subsequent calls:</p>
<pre><code>def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))
</code></pre>
<p>This will print</p>
<pre><code>[1]
[1, 2]
[1, 2, 3]
</code></pre>
<p>If you donâ€™t want the default to be shared between subsequent calls,
  you can write the function like this instead:</p>
<pre><code>def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
</code></pre>
</blockquote>
</div>
<span class="comment-copy">Anyway, <code>x</code> isn't acting as a callback here, if that's what you mean. You can just have a parameter <code>er</code>, and in <code>__init__</code> you can do <code>self.x = er()</code></span>
