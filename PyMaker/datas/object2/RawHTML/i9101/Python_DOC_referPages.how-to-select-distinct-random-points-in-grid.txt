<div class="post-text" itemprop="text">
<p>I have a 2D list, I need to select <code>n</code> distinct random points (x, y coordinates) from this 2D list. Let me first write what occured to me when I tried to solve the problem.</p>
<p>Let's say the grid is <code>300 x 400</code>.</p>
<ul>
<li>Do cartesian product <code>300 x 400</code> get a list of <code>120000</code> elements, than use <code>random.choice</code> <strong>(Slow for large grids)</strong></li>
<li>Keep the selected points in a set, randomize again in a while loop if a duplicate point is produced. <strong>(Very slow and unpredictable if n is large)</strong></li>
</ul>
<p>I searched some similar questions in SO, none of them address the problem directly. I did found <a href="https://stackoverflow.com/questions/10754392/different-random-points-from-a-2-dimensional-grid">This question</a>, though the users answer the problem, they do not offer a Python solution, which we may produce here in this question. Maybe usage of appropriate data structures in Python standard library can be suggested if not code itself.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/random.html#random.sample" rel="nofollow noreferrer"><code>random.sample</code></a> to sample without replacement from a range -- there's a fast special case for range objects. <code>divmod(i, h)</code> is the lexicographic mapping from <code>i</code> in the 1D range with <code>w * h</code> elements to <code>(x, y)</code> in the 2D grid.</p>
<p>Python 3:</p>
<pre><code>import random
def samplegrid(w, h, n):
    return [divmod(i, h) for i in random.sample(range(w * h), n)]
</code></pre>
<p>Python 2:</p>
<pre><code>import random
def samplegrid(w, h, n):
    return [divmod(i, h) for i in random.sample(xrange(w * h), n)]
</code></pre>
</div>
<span class="comment-copy">This appears to be working, could you please explain how does this work and how it avoids duplicates ?</span>
<span class="comment-copy">@Rockybilly <code>random.sample</code> samples without replacement. I linked the docs.</span>
<span class="comment-copy">I used <code>random.sample</code> before, just the trick with the dividing confused me, dividing the random number to <code>h</code> actually provides distinction ?</span>
<span class="comment-copy">@Rockybilly It's the quotient and the remainder, so yes. The inverse is <code>lambda x, y: x * h + y</code>.</span>
<span class="comment-copy">@Rockybilly Depends on how picky you are about the distribution. If approximately uniform is OK, use a <a href="https://en.wikipedia.org/wiki/Cover_tree" rel="nofollow noreferrer">cover tree</a> to find the previous point closest to a randomly chosen candidate, retaining those candidates that are sufficiently far.</span>
