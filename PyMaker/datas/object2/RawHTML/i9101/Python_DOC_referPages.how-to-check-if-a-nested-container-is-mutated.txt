<div class="post-text" itemprop="text">
<p>I have arbitrarily nested container object (e.g. lists and dicts).</p>
<p>I would like to test if after calling a function, if the container object was mutated.</p>
<pre><code>&gt;&gt;&gt; x = [[1,2,3], {1,2,3}, "other data", 1]
&gt;&gt;&gt; non_mutating_func(x)
&gt;&gt;&gt; x
[[1,2,3], {1,2,3}, "other data", 1] 
&gt;&gt;&gt; mutating_func(x)
&gt;&gt;&gt; x
[[100,2,3], {1,2,3}, "other data", 1] # One of the inner lists got changed. x got mutated.
</code></pre>
<p>I would like to also check for object identites.
Here is a example of what I mean by check of object idenitites:</p>
<pre><code>&gt;&gt;&gt; a = [[1,2],1,2]
&gt;&gt;&gt; def f(x):
...     x[0] = [1,2]
...
&gt;&gt;&gt; b = a[0]
&gt;&gt;&gt; f(a)
&gt;&gt;&gt; b is a[0]
False
</code></pre>
<p>The list <code>[1,2]</code> from <code>a[0]</code> was replaced by another list <code>[1,2]</code> but the lists are different objects. So it counts as mutated.</p>
<p>Note:
Previously, for a non-nested list, I could do something like this:</p>
<pre><code>x = [1,2,3,4]
x_ori = x[:]
f(x)
mutated = False
if len(x) != len(x_ori):
    mutated = True
for i,j in zip(x, x_ori):
    if not (i is j):
        mutated = True
        break
</code></pre>
<p>Also, it is possible for the original container to be a dict instead of a list.</p>
<pre><code>x = {1:1, "2":"2"}
x_ori = x.copy()
f(x)
mutated = False
if len(x) != len(x_ori):
    mutated = True
for k,v in x_ori.items():
    if not (k in x):
        mutated = True
        break
    if not (x[k] is v):
        mutated = True
        break
</code></pre>
<p>Is this possible for nested containers? And if so, how do I do so?</p>
</div>
<div class="post-text" itemprop="text">
<p>The tricky bit is the "same instance" check. You could recursively create a hash code for the entire structure, or create a deep-copy and compare the two, but both will fail the "same instance" check.</p>
<p>You could create a copy of the original list, as a reference for later, but more than that: You have to pair each element in the structure with its original <code>id</code>:</p>
<pre><code>def backup(data):
    # similar for set, dict, tuples, etc.
    if isinstance(data, list):
        return id(data), [backup(x) for x in data]
    # basic immutable stuff, string, numbers, etc.
    return id(data), data
</code></pre>
<p>Then, you can recursively check the structure and compare all the IDs <em>and</em> recursively compare the content of any sub-structures:</p>
<pre><code>def check(backup, data):
    id_, copy = backup
    # check whether it's still the same instance
    if id_ != id(data):
        return False
    # similar for set, dict, tuples, etc.
    if isinstance(data, list):
        return len(data) == len(copy) and all(check(b, d) for b, d in zip(copy, data))
    # basic immutable stuff must be equal due to equal ID
    return True
</code></pre>
<p>Here's an example, along with some example modifications:</p>
<pre><code>data = [[1,2,3], [4, [5,6], [7,8]], 9]
b = backup(data)
# data[1][0] = 4        # check -&gt; True, replaced with identical value
# data[1][1] = [5,6]    # check -&gt; False, replaced with equal value
# data[1][1].append(10) # check -&gt; False, original value modified
print(check(b, data))
</code></pre>
<p>Of course, both those methods are not complete and have to be extended for other structures, e.g. <code>dict</code>, <code>set</code>, <code>tuple</code>, etc. For <code>set</code> and <code>dict</code>, you might want to compare the <code>sorted</code> entries, but otherwise those should be very similar in nature.</p>
<p>Note that technically it does not <em>guarantee</em> that the list is not modified, e.g. IDs could be reused after the original object with that ID has been garbage collected, but in the general case, the above should work.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two broad approaches: Verifying after the fact, or preventing mutating operations as they happen. Here's a sketch of a proxy class that prevents <code>__setitem__</code> and similar methods from being accessed.</p>
<pre><code>names = ['__setitem__', 'append', 'pop', 'add', 'remove', 'update']
class immutable_mixin:
    def __getattribute__(self, name):
        if name in names: raise TypeError
        return super().__getattribute__(name)
    def __getitem__(self, k): return wrap(super().__getitem__(k))
    def __iter__(self): return map(wrap, super().__iter__())
    def __repr__(self): return '&gt;&gt;{}&lt;&lt;'.format(super().__repr__())

class immutable_list(immutable_mixin, list): pass
class immutable_set(immutable_mixin, set): pass
class immutable_dict(immutable_mixin, dict): pass

def wrap(x):
    if isinstance(x, (int, str, bytes)): return x
    elif isinstance(x, list): return immutable_list(x)
    elif isinstance(x, set): return immutable_set(x)
    elif isinstance(x, dict): return immutable_dict(x)
    else: return 'FIXME' + repr(x)
</code></pre>
<p>In short, the mutating operations raise <code>TypeError</code>, and the getter operations ensure that the returned values are proxied (or are types that cannot contain other values).</p>
<pre><code>&gt;&gt;&gt; x = [[1,2,3], {1,2,3}, "other data", 1, {1:1, "2":"2"}]
&gt;&gt;&gt; m = wrap(x)
&gt;&gt;&gt; m
&gt;&gt;[[1, 2, 3], {1, 2, 3}, 'other data', 1, {1: 1, '2': '2'}]&lt;&lt;
&gt;&gt;&gt; list(m)
[&gt;&gt;[1, 2, 3]&lt;&lt;, &gt;&gt;immutable_set({1, 2, 3})&lt;&lt;, 'other data', 1, &gt;&gt;{1: 1, '2': '2'}&lt;&lt;]
</code></pre>
<p>It's probably brittle in the face of non-standard containers such as defaultdict. It also needs to be comprehensive to work -- I forgot to include <code>__delitem__</code> and <code>__reversed__</code>, for example, and <code>list.extend</code>; set arithmetic also acts as an escape hatch (but list slicing does not!). See <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">Python Data Model</a>. It may be more robust to list the allowed methods rather than the disallowed methods, but the code would be longer.</p>
</div>
<span class="comment-copy">is the structure fixed? I mean, will the first element always be a list, etc etc?</span>
<span class="comment-copy">If the list has been modified, what will be your reference to test against? You could create a deep copy first and then compare the two, but is it worth it? What do you need this for, testing? (Also, this will obviously not work if you want to check identities...)</span>
<span class="comment-copy">Alternatively, you could calculate a hash code for the structure, but you will have to implement that yourself, as lists and dicts are not hashable. Also, this won't check identities.</span>
<span class="comment-copy">Also, this part "I would like to also check for object identites" is unclear. What if they are equal but not identical? Should the structure be regarded as "mutated" or not?</span>
<span class="comment-copy">Could you give some more context - what's the problem you're trying to solve with this?</span>
<span class="comment-copy">This will not work if you change your <code>[1,2,3]</code> list to a different one(witht the same numbers), since python cache common ints(and many other common types), so <code>id(1)</code>/<code>id(2)</code>/<code>id(3)</code> will be the same all the time. It means you can not check if it has been changed like the PO asked for.</span>
<span class="comment-copy">@OrDuan Did you try it? When I replace one of the sublists with an equal sublist, it detects the change (see my 2nd test case). Note that I also compare the <code>id</code> of the list itself! Only if a single int is replace (as shown in my first example) the change is not detected, but then: Is it even a change if the "new" element is the same (pooled) instance as the original?</span>
<span class="comment-copy">@OrDuan Has it really been mutated in that case?  If there's no change to its representation in memory, there's really no way to check if its been mutated at all.</span>
<span class="comment-copy">Interesting approach... so you would just <code>wrap</code> the argument to the method to test and see whether it raises a TypeError. However, it does not prevent methods like <code>append</code>, <code>extend</code>, <code>update</code>, etc.</span>
<span class="comment-copy">@tobias_k I did say it was brittle :) but updated a bit, thanks.</span>
