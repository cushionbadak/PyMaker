<div class="post-text" itemprop="text">
<p>Use <code>zipfile</code> to archive <code>data</code> dictionary:</p>
<pre><code>import os, sys, cPickle, zipfile 
data = {1: 'one'}
pfile = r'c:\temp\myPickle.p'
cPickle.dump( data, open( pfile, "wb" ))

zfilename = r'c:\temp\myArchive.zip'
zfile = zipfile.ZipFile(zfilename, "w", zipfile.ZIP_DEFLATED)
zfile.write(pfile, os.path.basename(pfile))
zfile.close()
</code></pre>
<p>The approach results two files on a local drive: one is pickle and another is zip.
To get pickled <code>data</code> zip file needs to be un-archived:</p>
<pre><code>fh = open(zfilename, 'rb')
z = zipfile.ZipFile(fh)
for each in z.namelist():
    z.extract(each, r'c:\temp')
fh.close()
</code></pre>
<p>How to simplify the process?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>gzip</code> instead. It compresses the file as you write it so there is no need for intermediate files.</p>
<pre><code>import cPickle as pickle
import gzip

data = {1: 'one'}

pfile = r'test.pkl.gz'
pickle.dump(data, gzip.open(pfile, "w"), pickle.HIGHEST_PROTOCOL)
print pickle.load(gzip.open(pfile))
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile.open" rel="nofollow noreferrer">ZipFile.open</a>, <a href="https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile.read" rel="nofollow noreferrer">ZipFile.read</a>, <a href="https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile.writestr" rel="nofollow noreferrer">ZipFile.writestr</a></span>
<span class="comment-copy">from some quick googling i found the functions you probably need: <code>preserved = pickle.dumps(data)</code> dumps generates a string. zipfile has .writestr() for turning strings into zip. this way only one file.</span>
