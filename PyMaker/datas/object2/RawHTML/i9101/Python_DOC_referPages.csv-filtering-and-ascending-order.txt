<div class="post-text" itemprop="text">
<p>New to Python, so I need a bit of help.</p>
<p>I have a CSV file that has an id, created_at date, first/last name columns.</p>
<pre class="lang-none prettyprint-override"><code>id  created_at  first_name last_name
1   1309380645  Cecelia    Holt
2   1237178109  Emma       Allison
3   1303585711  Desiree    King
4   1231175716  Sam        Davidson
</code></pre>
<p>I want to filter the rows between two dates lets say <code>03-22-2016</code> and <code>04-15-2016</code>(dates don't really matter), and then order those rows in ascending order (by created_at)</p>
<p>I know this code will just show all or most of the data</p>
<pre><code>import csv
from datetime import datetime

with open("sample_data.csv") as f:
    reader = csv.reader(f)
    for row in reader:
        print(" ".join(row[]))
</code></pre>
<p>But I'm not sure how to do the rest, or how to filter using this timestamp <code>1309380645</code>
would using <code>pandas</code> be more beneficial for me, over using csv?</p>
<p>Any help is much appreciated or a guide/book to read for more understanding.</p>
</div>
<div class="post-text" itemprop="text">
<p>I recommend using pandas since it will help you filter and perform further analysis faster.</p>
<pre><code># import pandas and datetime
import pandas as pd
import datetime

# read csv file
df = pd.read_csv("sample_data.csv")

# convert created_at from unix time to datetime
df['created_at'] = pd.to_datetime(df['created_at'], unit='s')

# contents of df at this point
#   id          created_at first_name last_name
# 0   1 2011-06-29 20:50:45    Cecelia      Holt
# 1   2 2009-03-16 04:35:09       Emma   Allison
# 2   3 2011-04-23 19:08:31    Desiree      King
# 3   4 2009-01-05 17:15:16        Sam  Davidson

# filtering example
df_filtered = df[(df['created_at'] &lt;= datetime.date(2011,3,22))]

# output of df_filtered
#    id          created_at first_name last_name
# 1   2 2009-03-16 04:35:09       Emma   Allison
# 3   4 2009-01-05 17:15:16        Sam  Davidson

# filter based on dates mentioned in the question
df_filtered = df[(df['created_at'] &gt;= datetime.date(2016,3,22)) &amp; (df['created_at'] &lt;= datetime.date(2016,4,15))]

# output of df_filtered would be empty at this point since the 
# dates are out of this range

# sort
df_sorted = df_filtered.sort_values(['created_at'])
</code></pre>
<h3>Explanation of filtering in pandas:</h3>
<p>First thing that you need to know is that using a comparison operator on a dataframe returns a dataframe with boolean values.</p>
<pre><code>df['id'] &gt; 2
</code></pre>
<p>Would return </p>
<pre><code>False
False
 True
 True
</code></pre>
<p>Now, pandas supports logical indexing. So if you pass a dataframe with boolean values to pandas, if will return only the ones that correspond to True.</p>
<pre><code>df[df['id'] &gt; 2]
</code></pre>
<p>Returns</p>
<pre><code>3   1303585711  Desiree    King
4   1231175716  Sam        Davidson
</code></pre>
<p>This is how you can filter easily in pandas</p>
</div>
<div class="post-text" itemprop="text">
<p>Downloading and installing (and learning) <code>pandas</code> just to do this seems like overkill. </p>
<p>Here's how to do it using only Python's built-in modules: </p>
<pre><code>import csv
from datetime import datetime, date
import sys

start_date = date(2011, 1, 1)
end_date = date(2011, 12, 31)

# Read csv data into memory filtering rows by the date in column 2 (row[1]).
csv_data = []
with open("sample_data.csv", newline='') as f:
    reader = csv.reader(f, delimiter='\t')
    header = next(reader)
    csv_data.append(header)
    for row in reader:
        creation_date = date.fromtimestamp(int(row[1]))
        if start_date &lt;= creation_date &lt;= end_date:
            csv_data.append(row)

if csv_data:  # Anything found?
    # Print the results in ascending date order.
    print(" ".join(csv_data[0]))
    # Converting the timestamp to int may not be necessary (but doesn't hurt)
    for row in sorted(csv_data[1:], key=lambda r: int(r[1])): 
        print(" ".join(row))
</code></pre>
</div>
<span class="comment-copy">Sorry had to create a new comment since I couldn't edit my old one. So I understand a bit more about pandas and filtering, thank you for that. But when I run your code it gives me a couple of errors.   From this, <code>=&gt;</code> I get invalid syntax  and going with this instead <code>&gt;</code> gives me "FutureWarning: sort(columns=....) is deprecated, use sort_values(by=.....)   df_filtered.sort(['created_at'], inplace=True)"  "SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame"  So I'm not really sure what to do.</span>
<span class="comment-copy">The =&gt; was a typo. I meant to type &gt;=. And the <i>sort</i> function has been deprecated and replaced by <i>sort_values</i>. The "SettingWithCopyWarning" error is a little more difficult to explain. Pandas was trying to be more efficient by making df_filtered a slice of the original df rather than actually copying the values. The inplace operation would've changed the original dataframe (df) and hence the warning. If we just copy the data to another dataframe the error should be gone. I have edited the original answer to reflect the changes.</span>
<span class="comment-copy">Thanks again for your help. I'm still seem to be getting something wrong. When I run your code this time it prints nothing at all. I'm still going to mark your answer as correct, as you've been very helpful.</span>
<span class="comment-copy">@Mr.Monsieur that's because the timestamps are outside the range of dates you are filtering for. For example, 1309380645 converts to 2011-06-29 20:50:45 and hence isn't included in the filtered result. Let me edit the answer to add an example with different filtering.</span>
<span class="comment-copy">Hey, I went and read then re-read the docs for pandas. My code is a bit different than yours but its working. I use yours as an example and then worked it out for what I was trying to do. It's was a bit tricky to get the filtering to work. But after reading the docs and now looking at your code, I understand it a bit more. Thanks for updating, and for helping me understand pandas more!</span>
<span class="comment-copy">Hello, I'm using python3.6. So the proper way of opening the CSV file with this version would be? Sorry if this is such an easy question, I'm just not getting it for some reason. Also, if I'm just learning this for basic filtering would the CSV module be better suited for me instead of learning pandas ... at least for now?</span>
<span class="comment-copy">To read a CSV file with Python 3.x, you should use <code>open(&lt;filename&gt;, newline='')</code> as shown in the examples in the <a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow noreferrer">documentation</a> for that version of the module. It might be a good idea get into the habit of always looking in the document before asking such basic questions. It's how I learned how to do it (and by comparing that documentation with what the <a href="https://docs.python.org/2/library/csv.html#csv.reader" rel="nofollow noreferrer">Python 2.x version</a> says, I was able to obtain the information needed to write the <code>open_csv()</code> function.</span>
<span class="comment-copy">Ok, so I thought I needed to specify which version I was using in my code. As the sample I provided does show <code>with open("sample_data.csv") as f:</code> just without the <code>newline=''</code> It was my misunderstand that confused me. I'll keep up with reading and re-reading the doc. Thanks again</span>
<span class="comment-copy">Yes, it can be a little confusing at times. However, the documentation does have a footnote <a href="https://docs.python.org/3/library/csv.html#id3" rel="nofollow noreferrer">[1]</a> that explains what happens if the <code>newline=''</code> isn't specified.</span>
