<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/4945155/how-to-clone-a-python-generator-object">How to clone a Python generator object?</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>In python i tried to create a copy of my iterator with using assignment however it create a copy of iterator which reference to the original iterator itself. For instance:</p>
<pre><code>my_list = [5, 4, 3,2]
first_it = iter(my_list)
second_it = first_it 
print next(first_it )        #it will print 5
print next(second_it)        #it will print 4
print next(first_it )        #it will print 3
</code></pre>
<p>As you see in the example first_it and second_it both refer to same iterator object. Is it possible to create a copy of iterator object which is not reference to the original object?<br/></p>
<p><strong>Note</strong>
This question is about how to creating a copy of iterator object by value. So don't mention <code>for item in my_list:</code> like solutions.<br/>
Thanks in advance </p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="noreferrer"><code>itertools.tee()</code> function</a> to produce copies; these use a buffer to share results between different iterators:</p>
<pre><code>from itertools import tee

my_list = [5, 4, 3,2]
first_it = iter(my_list)
first_it, second_it = tee(first_it)
print next(first_it)   # prints 5
print next(second_it)  # prints 5
print next(first_it)   # prints 4
</code></pre>
<p>Note that you should no longer use the original iterator; use only the tees.</p>
<p>Note that the buffer also means that these can incur a significant memory cost if you advance one of the copies far ahead of the others! From the documentation:</p>
<blockquote>
<p>This itertool may require significant auxiliary storage (depending on how much temporary data needs to be stored). In general, if one iterator uses most or all of the data before another iterator starts, it is faster to use <code>list()</code> instead of <code>tee()</code>.</p>
</blockquote>
</div>
<span class="comment-copy">I tried with <code>copy.copy()</code> and it worked too. Maybe there's a hidden catch?</span>
<span class="comment-copy">@Jean-FrançoisFabre: That won't work for a generator. Try with a generator that uses <code>while True: yield random.random()</code> for example.</span>
<span class="comment-copy">related to: "you cannot pickle a generator" probably.</span>
<span class="comment-copy">@Jean-FrançoisFabre: just because <b>some</b> iterator objects are copyable, doesn't mean they all are. The example produces a <code>list_iterator()</code> object, which only needs to store a reference to the original list object and a current position. That's easy to copy. But for an endless random generator there is no 'current position', only something that'll possibly produce another value next.</span>
