<div class="post-text" itemprop="text">
<p>In Python (3.5), if I have a long list like this:</p>
<pre><code>long_list = ['0','1','0','1','0','0'.'0'.'1','1','0']
</code></pre>
<p>and a shorter list equal in length to the number of '1's in the long_list, like this:</p>
<pre><code>short_list = [8,7,6,5]
</code></pre>
<p>How would I create a new list that "inserts" the values of my short_list into my long_list at each of the indices where there is a '1', and for consistency's sake, "replaces" the '0's in the long_list with some number (say 99).</p>
<p>I could do this with an excruciating for loop, but it seems like there should be a way to do this more efficiently with a list comprehension, no?</p>
<pre><code># bad solution
new_list = []
x = 0
for i in range(len(long_list)):
    if long_list[i] == '0':
        new_list.append(99)
    else:
        new_list.append(short_list[x])
        x += 1
</code></pre>
<p>Desired output:</p>
<pre><code>new_list = [99,8,99,7,99,99,99,6,5,99]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Turn <code>short_list</code> to an iterator and use list comprehension get value from there for each <code>'1'</code>, else use fixed value:</p>
<pre><code>&gt;&gt;&gt; long_list = ['0','1','0','1','0','0','0','1','1','0']
&gt;&gt;&gt; short_list = [8,7,6,5]
&gt;&gt;&gt; it = iter(short_list)
&gt;&gt;&gt; [next(it) if x == '1' else 99 for x in long_list]
[99, 8, 99, 7, 99, 99, 99, 6, 5, 99]
</code></pre>
<p>This obviously works only if <code>short_list</code> has the same amount or more elements as there are <code>1</code> on the <code>long_list</code>. Above has <strong>O(n)</strong> time complexity where <strong>n</strong> is the amount of elements in <code>long_list</code>. Note that this works the same for all kinds of iterables, <code>long_list</code> and <code>short_list</code> could have been generators and the end result would have been the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you do not have a problem with changing <code>short_list</code>, you can try the following using a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>:</p>
<pre><code>[short_list.pop(0) if i == '1' else 99 for i in long_list]
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt;&gt;&gt; long_list = ['0', '1', '0', '1', '0', '0', '0', '1', '1', '0']
&gt;&gt;&gt; short_list = [8, 7, 6, 5]
&gt;&gt;&gt;
&gt;&gt;&gt; [short_list.pop(0) if i == '1' else 99 for i in long_list]
[99, 8, 99, 7, 99, 99, 99, 6, 5, 99]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not that this is the best way, but it requires no new variables.</p>
<pre><code>[99 if long_list[i] == '0' else short_list[long_list[:i].count('1')]
 for i in range(len(long_list))]
</code></pre>
</div>
<span class="comment-copy">Are you sure there are always as many values in <code>short_list</code> as there are <code>'1'</code> in <code>long_list</code>?</span>
<span class="comment-copy">Yes, for this application there are. The short list is derived from the long list. Probably too much information to explain the actual usage (the example above is a toy example based off of real data), but I'm sure that the short list has exactly as many values as there are '1's.</span>
<span class="comment-copy">thanks, this works great and is very fast (took less than a second on my real "long_list" of 200,000+ items). I should use iterators more often.</span>
