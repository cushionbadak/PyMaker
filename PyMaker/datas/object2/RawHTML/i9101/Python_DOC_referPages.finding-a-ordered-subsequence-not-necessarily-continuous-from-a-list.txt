<div class="post-text" itemprop="text">
<p>I am stuck with a problem. I have a list for e.g. <code>[A,B,C,D,E]</code>. the size of the list may vary. I have to check whether a sub-sequence for e.g. <code>[A,C,E]</code> occurs in the main list. The size of the sub-sequence may also vary.</p>
<p>The problem here is that the sub-sequence here need not be continuous. Just the order of occurrence matters. </p>
<p>Some examples:</p>
<pre><code>seq = [A,B,C,D,E]

subseq = [A,C,E]
&gt;&gt;&gt;sub-sequence present in sequence

subseq = [B,D,E]
&gt;&gt;&gt; sub-sequence present in sequence

subseq = [A,E]
&gt;&gt;&gt; sub-sequence present in sequence

subseq = [C,B]
&gt;&gt;&gt; sub-sequence not present in sequence

subseq = [B,A,E]
&gt;&gt;&gt; sub-sequence not present in sequence
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter</code></a> to produce an iterator whose consumption enforces order on each member check. </p>
<pre><code>def subcheck(li, sub_li):
    it = iter(li)
    return all(el in it for el in sub_li)
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>In[95]: subcheck([1, 6, 3, 9, 4, 2], [1, 9, 3])
Out[95]: False

In[96]: subcheck([1, 6, 3, 9, 4, 2], [1, 3, 9])
Out[96]: True
</code></pre>
<hr/>
<p>This approach works because the <code>in</code> keyword for a list is implemented as a sequence iteration (<a href="https://docs.python.org/3/reference/expressions.html#in" rel="nofollow noreferrer">the docs</a>): </p>
<blockquote>
<p>For container types such as list, tuple, set, frozenset, dict, or collections.deque, the expression <code>x in y</code> is equivalent to <code>any(x is e or x == e for e in y)</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You could easily write a recursive solution if you want to understand how to solve similar problems:</p>
<pre><code>def isPresent(subseq,seq):
    if not subseq:
        return True
    elif not seq:
        return False
    elif subseq[0]==seq[0]:
        return isPresent(subseq[1:],seq[1:])
    else:
        return isPresent(subseq,seq[1:])
</code></pre>
<p>called like <code>isPresent(['A','C','E'],['A','B','C','D','E'])</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can do a fairly simple iterative solution as long as both inputs are iterable.</p>
<pre><code>def subseq(sub, seq):
    if not sub:
        return True
    it = iter(sub)
    curr = next(it)
    for item in seq:
        if item == curr:
            try:
                curr = next(it)
            except StopIteration:
                return True
    return False
</code></pre>
</div>
<span class="comment-copy">Why not write an algorithm that loops through the list and keeps track of the occuring elements that form the subsequence?</span>
<span class="comment-copy">Very nice use of the iterator!</span>
<span class="comment-copy">Recursion is nice to see, especially if this is educational. One critique - can you please fix the indentation? Also, it may make a bit more sense for your function to return <code>True</code> or <code>False</code>, but that's up to you. You could also recurse via list index as opposed to slicing to avoid making copies of the list on each iteration.</span>
