<div class="post-text" itemprop="text">
<p>I'm writing code that requires the generation of a binary outcome from a given probabilities or list. I'm looking at the random module but was unable to find anything that would solve the problem.</p>
<p>Example</p>
<p>RETURN 1 30% of the time</p>
<p>EXAMPLE</p>
<p>RETURN 1 OR 0 45% and 55% of the time</p>
</div>
<div class="post-text" itemprop="text">
<p>Generate a uniform(0,1) random value, check if it's â‰¤ the desired proportion/p-value, and return 0 or 1 accordingly.  Assuming <code>rand</code> is a U(0,1) generator, pseudocode would look like this:</p>
<pre><code>function bernoulli(p) {
  if rand &lt;= p {
    return 1
  } else {
    return 0
  }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/random.html?highlight=random.choices#random.choices" rel="nofollow noreferrer">random.choices</a> will certainly do what you want, but it might be overkill. It can generate an arbitrarily long sequence if choices from a finite set where each element has an independent frequency. There is an example of its use in the examples section of the linked Python documentation:</p>
<pre><code>&gt;&gt;&gt; # Estimate the probability of getting 5 or more heads from 7 spins
&gt;&gt;&gt; # of a biased coin that settles on heads 60% of the time.
&gt;&gt;&gt; trial = lambda: choices('HT', cum_weights=(0.60, 1.00), k=7).count('H') &gt;= 5
&gt;&gt;&gt; sum(trial() for i in range(10000)) / 10000
0.4169
</code></pre>
<p>In that example, the weights are specified as a cumulative distribution: </p>
<pre><code>cum_weights=(0.60, 1.00)
</code></pre>
<p>An equivalent call using individual weights, as in your example, would be</p>
<pre><code>weights=(0.60, 0.40)
</code></pre>
<p>The weights don't need to add up to Q; they will be normalized.</p>
</div>
<span class="comment-copy">In what language?</span>
<span class="comment-copy">Python language</span>
