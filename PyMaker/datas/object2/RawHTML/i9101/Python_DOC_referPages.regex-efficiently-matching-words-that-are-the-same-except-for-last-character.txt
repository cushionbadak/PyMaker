<div class="post-text" itemprop="text">
<p>How can I <strong>efficiently</strong> match words that are the same except for the last letter? </p>
<pre><code>data = ['ades', 'adey', 'adhere', 'adherent', 'admin', 'admit', 'adverb', 'advert', 'adipocere', 'adipocerous', 'adjoining', 'adjoint', 'adjudicate', 'adjudication', 'adjunct']
</code></pre>
<p>The actual data is longer and my implementation below takes too long to run:</p>
<pre><code>temp_data = data 
count = 0
matches = {}
while count &lt; len(data):
    for word in data:
        if word[:-1] == data[count][:-1] and data.index(word) != count:
            matches[data[count]] = word
            temp_data.remove(data[count])
            temp_data.remove(word)
    count += 1
print(matches)
</code></pre>
<p>this correctly prints:</p>
<pre><code>{'ades': 'adey', 'advert': 'adverb', 'admin': 'admit'}
</code></pre>
<p>I'm new to python so any suggestions would be appreciated  :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming <code>list</code> is already sorted (else you need to sort it first), and there would be only two such elements in the list following the criterion. You may achieve the result via using <em>dictionary comprehension</em> with <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> as:</p>
<pre><code>&gt;&gt;&gt; data = ['ades', 'adey', 'adhere', 'adherent', 'admin', 'admit', 'adverb', 'advert', 'adipocere', 'adipocerous', 'adjoining', 'adjoint', 'adjudicate', 'adjudication', 'adjunct']

# data.sort()  --&gt; if data is not already sorted
&gt;&gt;&gt; {i: j for i, j in zip(data, data[1:]) if i[:-1]==j[:-1]}
{'admin': 'admit', 'adverb': 'advert', 'ades': 'adey'}
</code></pre>
<p>PS: I do not think <code>regex</code> is the right tool for achieving the desired result.</p>
</div>
<div class="post-text" itemprop="text">
<p>You’re comparing every word against every word and using a check that compares every word every time to make sure you’re not comparing a word against itself for O(n³) time. You can get it to O(n²) time by keeping track of the index in the inner loop:</p>
<pre><code>for j, word in enumerate(data):
    if word[:-1] == data[count][:-1] and j != count:
        matches[data[count]] = word
        temp_data.remove(data[count])
        temp_data.remove(word)
</code></pre>
<p>and then get it to O(n) by just grouping the words by their initial letters:</p>
<pre><code>groups = defaultdict(list)

for word in data:
    groups[word[:-1]].append(word)

print(list(groups.values()))
</code></pre>
<p>which can also be done using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> if your list is sorted:</p>
<pre><code>import itertools

def init(word):
    return word[:-1]

print([list(words) for key, words in itertools.groupby(data, init)])
</code></pre>
</div>
<span class="comment-copy">What makes you think regex is the correct tool for this?</span>
<span class="comment-copy">are the pairs supposed to be always together? are there only 2 such strings?</span>
<span class="comment-copy">Are the words already in alphabetical order?  If so, then you need to check only as far as they match to the penultimate letter.  There's no need to run <b>count</b> all the way to the end.</span>
<span class="comment-copy">You might want to use a trie <a href="https://en.wikipedia.org/wiki/Trie" rel="nofollow noreferrer">en.wikipedia.org/wiki/Trie</a></span>
<span class="comment-copy">@Username You will have to just do <code>data.sort()</code> to sort the list (i.e. make it alphabetical)</span>
<span class="comment-copy">Thank you! @Moinuddin Quadri's solution was faster although your explanations helped me understand the underlying cause better.</span>
<span class="comment-copy">@Username: Faster = less typing, or does it actually perform worse?</span>
<span class="comment-copy">It completes between .2-.4 sec faster.</span>
