<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3718657/how-to-properly-determine-current-script-directory">How to properly determine current script directory?</a>
<span class="question-originals-answer-count">
                    13 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/8248397/how-to-know-change-current-directory-in-python-shell">How to know/change current directory in Python shell?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>In Python, what commands can I use to find:</p>
<ol>
<li>the current directory (where I was in the terminal when I ran the Python script), and</li>
<li>where the file I am executing is?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>To get the full path to the directory a Python file is contained in, write this in that file:</p>
<pre><code>import os 
dir_path = os.path.dirname(os.path.realpath(__file__))
</code></pre>
<p>(Note that the incantation above won't work if you've already used <code>os.chdir()</code> to change your current working directory, since the value of the <code>__file__</code> constant is relative to the current working directory and is not changed by an <code>os.chdir()</code> call.)</p>
<hr/>
<p>To get the current working directory use </p>
<pre><code>import os
cwd = os.getcwd()
</code></pre>
<hr/>
<p>Documentation references for the modules, constants and functions used above:</p>
<ul>
<li>The <a href="https://docs.python.org/library/os.html"><code>os</code></a> and <a href="https://docs.python.org/library/os.path.html#module-os.path"><code>os.path</code></a> modules.</li>
<li>The <a href="https://docs.python.org/reference/datamodel.html"><code>__file__</code></a> constant</li>
<li><a href="https://docs.python.org/library/os.path.html#os.path.realpath"><code>os.path.realpath(path)</code></a> (returns <em>"the canonical path of the specified filename, eliminating any symbolic links encountered in the path"</em>)</li>
<li><a href="https://docs.python.org/library/os.path.html#os.path.dirname"><code>os.path.dirname(path)</code></a> (returns <em>"the directory name of pathname <code>path</code>"</em>)</li>
<li><a href="https://docs.python.org/library/os.html#os.getcwd"><code>os.getcwd()</code></a> (returns <em>"a string representing the current working directory"</em>)</li>
<li><a href="https://docs.python.org/library/os.html#os.chdir"><code>os.chdir(path)</code></a> (<em>"change the current working directory to <code>path</code>"</em>)</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Current Working Directory:  <a href="https://docs.python.org/2/library/os.html#os.getcwd" rel="noreferrer"><code>os.getcwd()</code></a></p>
<p>And the <a href="http://docs.python.org/reference/datamodel.html" rel="noreferrer"><code>__file__</code> attribute</a>  can help you find out where the file you are executing is located.  This SO post explains everything:  <a href="https://stackoverflow.com/questions/2632199/how-do-i-get-the-path-of-the-current-executed-file-in-python">How do I get the path of the current executed file in Python?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You may find this useful as a reference:</p>
<pre><code>import os

print("Path at terminal when executing this file")
print(os.getcwd() + "\n")

print("This file path, relative to os.getcwd()")
print(__file__ + "\n")

print("This file full path (following symlinks)")
full_path = os.path.realpath(__file__)
print(full_path + "\n")

print("This file directory and name")
path, filename = os.path.split(full_path)
print(path + ' --&gt; ' + filename + "\n")

print("This file directory only")
print(os.path.dirname(full_path))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>1.To get the current directory full path</p>
<pre><code>    &gt;&gt;import os
    &gt;&gt;print os.getcwd()
</code></pre>
<p>o/p:"C :\Users\admin\myfolder"</p>
<p>1.To get the current directory folder name alone</p>
<pre><code>    &gt;&gt;import os
    &gt;&gt;str1=os.getcwd()
    &gt;&gt;str2=str1.split('\\')
    &gt;&gt;n=len(str2)
    &gt;&gt;print str2[n-1]
</code></pre>
<p>o/p:"myfolder"</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a> module, <a href="https://docs.python.org/3/whatsnew/3.4.html#pathlib" rel="noreferrer">introduced</a> in Python 3.4 (<a href="https://www.python.org/dev/peps/pep-0428/" rel="noreferrer">PEP 428 — The pathlib module — object-oriented filesystem paths</a>), makes path-related experience much much better.</p>
<pre><code>$ pwd
/home/skovorodkin/stack
$ tree
.
└── scripts
    ├── 1.py
    └── 2.py
</code></pre>
<p>In order to get current working directory use <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.cwd" rel="noreferrer"><code>Path.cwd()</code></a>:</p>
<pre><code>from pathlib import Path

print(Path.cwd())  # /home/skovorodkin/stack
</code></pre>
<p>To get an absolute path to your script file, use <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.resolve" rel="noreferrer"><code>Path.resolve()</code></a> method:</p>
<pre><code>print(Path(__file__).resolve())  # /home/skovorodkin/stack/scripts/1.py
</code></pre>
<p>And to get path of a directory where your script is located, access <a href="https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.parent" rel="noreferrer"><code>.parent</code></a> (it is recommended to call <code>.resolve()</code> before <code>.parent</code>):</p>
<pre><code>print(Path(__file__).resolve().parent)  # /home/skovorodkin/stack/scripts
</code></pre>
<p>Remember that <code>__file__</code> is not reliable in some situations: <a href="https://stackoverflow.com/questions/2632199/how-do-i-get-the-path-of-the-current-executed-file-in-python">How do I get the path of the current executed file in Python?</a>.</p>
<hr/>
<p>Please note, that <code>Path.cwd()</code>, <code>Path.resolve()</code> and other <code>Path</code> methods return path objects (<a href="https://docs.python.org/3/library/pathlib.html#pathlib.PosixPath" rel="noreferrer"><code>PosixPath</code></a> in my case), not strings. In Python 3.4 and 3.5 that caused some pain, because <a href="https://docs.python.org/3.5/library/functions.html#open" rel="noreferrer"><code>open</code></a> built-in function could only work with string or bytes objects, and did not support <code>Path</code> objects, so you had to convert <code>Path</code> objects to strings or use <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.open" rel="noreferrer"><code>Path.open()</code></a> method, but the latter option required you to change old code:</p>
<pre><code>$ cat scripts/2.py
from pathlib import Path

p = Path(__file__).resolve()

with p.open() as f: pass
with open(str(p)) as f: pass
with open(p) as f: pass

print('OK')

$ python3.5 scripts/2.py
Traceback (most recent call last):
  File "scripts/2.py", line 11, in &lt;module&gt;
    with open(p) as f:
TypeError: invalid file: PosixPath('/home/skovorodkin/stack/scripts/2.py')
</code></pre>
<p>As you can see <code>open(p)</code> does not work with Python 3.5.</p>
<p><a href="https://www.python.org/dev/peps/pep-0519/" rel="noreferrer">PEP 519 — Adding a file system path protocol</a>, implemented in Python 3.6, adds support of <a href="https://docs.python.org/3/library/os.html#os.PathLike" rel="noreferrer"><code>PathLike</code></a> objects to <a href="https://docs.python.org/3/library/functions.html#open" rel="noreferrer"><code>open</code></a> function, so now you can pass <code>Path</code> objects to <code>open</code> function directly:</p>
<pre><code>$ python3.6 scripts/2.py
OK
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are trying to find the current directory of the file you are currently in:</p>
<p>OS agnostic way:</p>
<pre><code>dirname, filename = os.path.split(os.path.abspath(__file__))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python 3.4, there is the brand new higher-level <code>pathlib</code> module which allows you to conveniently call <code>pathlib.Path.cwd()</code> to get a <code>Path</code> object representing your current working directory, along with many other new features.</p>
<p>More info on this new API can be found <a href="https://docs.python.org/3.4/library/pathlib.html" rel="noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A bit late to the party, but I think the most succinct way to find just the name of your current execution context would be </p>
<pre><code>current_folder_path, current_folder_name = os.path.split(os.getcwd())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Answer to #1:</strong></p>
<p>If you want the current directory, do this:</p>
<pre><code>import os
os.getcwd()
</code></pre>
<p>If you want just any folder name and you have the path to that folder, do this:</p>
<pre class="lang-python prettyprint-override"><code>def get_folder_name(folder):
    '''
    Returns the folder name, given a full folder path
    '''
    return folder.split(os.sep)[-1]
</code></pre>
<p><strong>Answer to #2:</strong></p>
<pre><code>import os
print os.path.abspath(__file__)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To get the current directory full path:<br/></p>
<blockquote>
<p>os.path.realpath('.')</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Pathlib can be used this way to get the directory containing current script :</p>
<pre><code>import pathlib
filepath = pathlib.Path(__file__).resolve().parent
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're searching for the location of the currently executed script, you can use <code>sys.argv[0]</code> to get the full path.</p>
</div>
<div class="post-text" itemprop="text">
<p>In order to see current working directory type following script:</p>
<pre><code>import os
current_working_directory = os.getcwd()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For question 1 use <code>os.getcwd() # get working dir</code> and <code>os.chdir(r'D:\Steam\steamapps\common') # set working dir</code></p>
<hr/>
<p>I recommend using <code>sys.argv[0]</code> for question 2 because <code>sys.argv</code> is immutable and therefore always returns the current file (module object path) and not affected by <code>os.chdir()</code>. Also you can do like this:</p>
<pre><code>import os
this_py_file = os.path.realpath(__file__)

# vvv Below comes your code vvv #
</code></pre>
<p>but that snippet and <code>sys.argv[0]</code> will not work or will work wierd when compiled by PyInstaller because magic properties are not set in <code>__main__</code> level and <code>sys.argv[0]</code> is the way your exe was called (means that it becomes affected by the working dir).</p>
</div>
<div class="post-text" itemprop="text">
<p>To Get your working directory in python. You can Use following code:</p>
<pre><code>import os
cwd = os.getcwd() #to get current working directory
print(cwd)
</code></pre>
</div>
<span class="comment-copy">Not a duplicate of "How to get full path of current directory in Python?" because this question also asks for the current working directory, and that does not.</span>
<span class="comment-copy">Which makes it two questions</span>
<span class="comment-copy">I hate it when I use this to append to sys.path.  I feel so dirty right now.</span>
<span class="comment-copy"><b>file</b> will not work if invoked from an IDE (say IDLE). Suggest os.path.realpath('./') or  os.getcwd(). Best anser in here: <a href="http://stackoverflow.com/questions/2632199/how-do-i-get-the-path-of-the-current-executed-file-in-python?lq=1" title="how do i get the path of the current executed file in python">stackoverflow.com/questions/2632199/…</a></span>
<span class="comment-copy">@Neon22 might suit some needs, but I feel it should be noted that those things aren't the same at all - files can be outside the working directory.</span>
<span class="comment-copy">What about reversing the order, does it matter? <code>os.path.realpath(os.path.dirname(__file__))</code></span>
<span class="comment-copy">@Moberg Often the paths will be the same when reversing <code>realpath</code> with <code>dirname</code>, but it will differ when the file (or its directory) is actually a symbolic link.</span>
<span class="comment-copy">what does <code>__file__</code> signifies here? It does not work for me.</span>
<span class="comment-copy">The <code>__file__</code> is an attribute of the module object. You need run the code inside a Python file, not on the REPL.</span>
<span class="comment-copy">better do it in one line, i think: <code>os.getcwd().split('\\')[-1]</code></span>
<span class="comment-copy">better to use os.sep rather than hardcode for Windows: os.getcwd().split(os.sep)[-1]</span>
<span class="comment-copy">the problem with this approach is that if you execute the script from a different directory, you will get that directory's name instead of the scripts', which may not be what you want.</span>
<span class="comment-copy">Right, the current directory which hosts your file may not be your CWD</span>
<span class="comment-copy">Note also that these methods are chainable, so you can use <code>app_path = Path(__file__).resolve().parent.parent.parent</code> as a parallel to <code>../../../</code> if you need to.</span>
<span class="comment-copy">For Python version &lt; 3.4 you can use <code>pathlib2</code>: <a href="https://pypi.python.org/pypi/pathlib2/" rel="nofollow noreferrer">pypi.python.org/pypi/pathlib2</a></span>
<span class="comment-copy">I don't know how you don't have more thumbs up.</span>
<span class="comment-copy">This one works from inside a jupyter iPython notebook (´__file__´ and getcwd won't)</span>
<span class="comment-copy">Still valid. Thanks from the future @OliverZendel!</span>
<span class="comment-copy">I'm working remotely with a Jupyter Notebook: <code>os.getcwd()</code> and `os.path.realpath('.') return exactly the same string path.</span>
<span class="comment-copy">I like this solution. However can cause some Python 2.X issues.</span>
<span class="comment-copy">For python 3.3 and earlier pathlib has to be installed</span>
<span class="comment-copy">@Kimmo The only reason you should be working in Python 2 code is to convert it to Python 3.</span>
<span class="comment-copy">@kagnirick agreed, but there are still people who don't. I write all my new stuff with formatted string literals (PEP 498) using Python 3.6 so that someone doesn't go and push them to Python2.</span>
<span class="comment-copy">Note also that these methods are chainable, so you can use <code>app_path = Path(__file__).resolve().parent.parent.parent</code> as a parallel to <code>../../../</code> if you need to.</span>
<span class="comment-copy">This is wrong. <code>sys.argv[0]</code> needn't contain the <i>full</i> path to the executing script.</span>
<span class="comment-copy">Not using PEP-8 variable naming standard (snake case instead of camel case).</span>
<span class="comment-copy">what was wrong the identical answers posted years before this?</span>
<span class="comment-copy">you can mark duplicate the question. @CoreyGoldberg I gave this answer year back and I didn't have knowledge about identical questions.</span>
