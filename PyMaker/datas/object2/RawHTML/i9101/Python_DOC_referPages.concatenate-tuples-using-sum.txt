<div class="post-text" itemprop="text">
<p>From <a href="https://stackoverflow.com/a/42046440/7311767">this post</a> I learned that you can concatenate tuples with:</p>
<pre><code>&gt;&gt;&gt; tuples = (('hello',), ('these', 'are'), ('my', 'tuples!'))
&gt;&gt;&gt; sum(tuples, ())
('hello', 'these', 'are', 'my', 'tuples!')
</code></pre>
<p>Which looks pretty nice.  But why does this work?  And, is this optimum, or is there something from <code>itertools</code> that would be preferable to this construct?</p>
</div>
<div class="post-text" itemprop="text">
<p>the addition operator concatenates tuples in python:</p>
<pre><code>('a', 'b')+('c', 'd')
Out[34]: ('a', 'b', 'c', 'd')
</code></pre>
<p>From the docstring of <code>sum</code>:</p>
<blockquote>
<p>Return the sum of a 'start' value (default: 0) plus an iterable of
  numbers</p>
</blockquote>
<p>It means <code>sum</code> doesn't start with the first element of your iterable, but rather with an initial value that is passed through <code>start=</code> argument.</p>
<p>By default <code>sum</code> is used with numeric thus the default start value is <code>0</code>. So summing an iterable of tuples requires to start with an empty tuple. <code>()</code> is an empty tuple:</p>
<pre><code>type(())
Out[36]: tuple
</code></pre>
<p>Therefore the working concatenation.</p>
<p>As per performance, here is a comparison:</p>
<pre><code>%timeit sum(tuples, ())
The slowest run took 9.40 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 285 ns per loop


%timeit tuple(it.chain.from_iterable(tuples))
The slowest run took 5.00 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 625 ns per loop
</code></pre>
<p>Now with t2 of a size 10000:</p>
<pre><code>%timeit sum(t2, ())
10 loops, best of 3: 188 ms per loop

%timeit tuple(it.chain.from_iterable(t2))
1000 loops, best of 3: 526 µs per loop
</code></pre>
<p>So if your list of tuples is small, you don't bother. If it's medium size or larger, you should use <code>itertools</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>That's clever and I had to laugh because help expressly forbids strings, but it works</p>
<pre><code>sum(...)
    sum(iterable[, start]) -&gt; value

    Return the sum of an iterable of numbers (NOT strings) plus the value
    of parameter 'start' (which defaults to 0).  When the iterable is
    empty, return start.
</code></pre>
<p>You can add tuples to get a new, bigger tuple. And since you gave a tuple as a start value, the addition works.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just to complement the accepted answer with some more benchmarks:</p>
<pre><code>import functools, operator, itertools
import numpy as np
N = 10000
M = 2

ll = tuple(tuple(x) for x in np.random.random((N, M)).tolist())

%timeit functools.reduce(operator.add, ll)
# 407 ms ± 5.63 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit functools.reduce(lambda x, y: x + y, ll)
# 425 ms ± 7.16 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit sum(ll, ())
# 426 ms ± 14.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit tuple(itertools.chain(*ll))
# 601 µs ± 5.43 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

%timeit tuple(itertools.chain.from_iterable(ll))
# 546 µs ± 25.1 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p><strong>EDIT</strong>: the code is updated to actually use tuples. And, as per comments, the last two options are now inside a <code>tuple()</code> constructors, and all the times have been updated (for consistency). The <code>itertools.chain*</code> options are still the fastest but now the margin is reduced.</p>
</div>
<div class="post-text" itemprop="text">
<p>It works because addition is overloaded (on tuples) to return the concatenated tuple:</p>
<pre><code>&gt;&gt;&gt; () + ('hello',) + ('these', 'are') + ('my', 'tuples!')
('hello', 'these', 'are', 'my', 'tuples!')
</code></pre>
<p>That's basically what <code>sum</code> is doing, you give an initial value of an empty tuple and then add the tuples to that.</p>
<p>However this is generally a bad idea because addition of tuples creates a new tuple, so you create several intermediate tuples just to copy them into the concatenated tuple:</p>
<pre><code>()
('hello',)
('hello', 'these', 'are')
('hello', 'these', 'are', 'my', 'tuples!')
</code></pre>
<p>That's an implementation that has quadratic runtime behavior. That quadratic runtime behavior can be avoided by avoiding the intermediate tuples.</p>
<pre><code>&gt;&gt;&gt; tuples = (('hello',), ('these', 'are'), ('my', 'tuples!'))
</code></pre>
<p>Using nested generator expressions:</p>
<pre><code>&gt;&gt;&gt; tuple(tuple_item for tup in tuples for tuple_item in tup)
('hello', 'these', 'are', 'my', 'tuples!')
</code></pre>
<p>Or using a generator function:</p>
<pre><code>def flatten(it):
    for seq in it:
        for item in seq:
            yield item


&gt;&gt;&gt; tuple(flatten(tuples))
('hello', 'these', 'are', 'my', 'tuples!')
</code></pre>
<p>Or using <a href="https://docs.python.org/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a>:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; tuple(itertools.chain.from_iterable(tuples))
('hello', 'these', 'are', 'my', 'tuples!')
</code></pre>
<p>And if you're interested how these perform (using my <a href="https://github.com/MSeifert04/simple_benchmark" rel="nofollow noreferrer"><code>simple_benchmark</code> package</a>):</p>
<pre><code>import itertools
import simple_benchmark

def flatten(it):
    for seq in it:
        for item in seq:
            yield item

def sum_approach(tuples):
    return sum(tuples, ())

def generator_expression_approach(tuples):
    return tuple(tuple_item for tup in tuples for tuple_item in tup)

def generator_function_approach(tuples):
    return tuple(flatten(tuples))

def itertools_approach(tuples):
    return tuple(itertools.chain.from_iterable(tuples))

funcs = [sum_approach, generator_expression_approach, generator_function_approach, itertools_approach]
arguments = {(2**i): tuple((1,) for i in range(1, 2**i)) for i in range(1, 13)}
b = simple_benchmark.benchmark(funcs, arguments, argument_name='number of tuples to concatenate')

b.plot()
</code></pre>
<p><a href="https://i.stack.imgur.com/DsjES.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/DsjES.png"/></a></p>
<p>(Python 3.7.2 64bit, Windows 10 64bit)</p>
<p>So while the <code>sum</code> approach is very fast if you concatenate only a few tuples it will be really slow if you try to concatenate lots of tuples. The fastest of the tested approaches for many tuples is <a href="https://docs.python.org/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a></p>
</div>
<span class="comment-copy">Why shouldn't it work? It's just adding the tuples together, but it's not particularly efficient. Take a look at <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer">itertools.chain</a>. Eg, <code>tuple(chain(*tuples))</code></span>
<span class="comment-copy">@PM2Ring. Avoid using <code>chain</code> like that as it's even more inefficient than <code>sum</code> (unless the collection of tuples is very small). Use <code>chain.from_iterable</code> instead.</span>
<span class="comment-copy">@ekhumoro Oops! Yes, chain.from_iterable is better. And as Boud's answer shows, it's actually slower than sum for small collections of tuples.</span>
<span class="comment-copy">Interesting timings. Which Python version did you use?</span>
<span class="comment-copy">@PM2Ring 3.5 64bits</span>
<span class="comment-copy"><code>best of 3</code> =&gt; kindly refer to %timeit documentation in ipython</span>
<span class="comment-copy">In this example, <code>sum</code> hasn't summed strings: there are no two strings that were separate in the input that have been joined here. (E.g. there's no way to turn <code>hello</code> and <code>world</code> into <code>helloworld</code> using <code>sum</code>.)</span>
<span class="comment-copy">IMO what Python does is just stupid. Sum should be able to sum anything that supports the <code>+</code> operator. Strings do. Explicitly disallowing that particular case for strings in the name of performance and good convention (while python has plenty of other antipatterns not disallowed) is just not good design</span>
<span class="comment-copy">@ShreevatsaR i am quite aware of that. The help mentions strings but I went on to state that this is really adding tuples. I just thought it was amusing and assumed people can read.</span>
<span class="comment-copy">@progo - I'm not sure why its forbidden, but I agree, sum should do what plus does. Maybe its to catch the common error where strings are mistaken for ints. But still...</span>
<span class="comment-copy">For the strings part, see <a href="http://stackoverflow.com/questions/3525359/python-sum-why-not-strings" title="python sum why not strings">stackoverflow.com/questions/3525359/python-sum-why-not-strings</a>. It's mainly efficiency.</span>
<span class="comment-copy">Your last two timings are not representative. The <code>itertools.chain</code> and <code>itertools.chain.from_iterable</code> return iterators. For fair timings you need to iterate these using <code>tuple(itertools.chain...)</code>.</span>
<span class="comment-copy">@MSeifert agreed, now should be correct.</span>
