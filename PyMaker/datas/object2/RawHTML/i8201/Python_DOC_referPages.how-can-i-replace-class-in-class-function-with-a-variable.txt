<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/10657022/python-typeerror-str-object-is-not-callable-for-class">Python TypeError: 'str' object is not callable for class</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>I'm using <strong>Python 3.5</strong> for this. So the title is very confusing, I'm still new to python and don't really know how to solve that problem, nor how to give it a proper title as you can see. I do see where my logic flawed me (how the heck did i intend to just replace that argument with another word so easily is beyond me) but I still don't know what the solution is. So basically my problem is trying to run something like this:</p>
<pre><code>def attack(self,target):
    target.hp -= self.attack
</code></pre>
<p>This obviously doesn't work when I try to call it from my permanent game loop:</p>
<pre><code>opponent = Enemy()
player = Enemy()

if action == "a":
    player.attack(opponent)
</code></pre>
<p>And I get a error of:</p>
<pre><code>TypeError: 'int' object is not callable
</code></pre>
<p>I'll paste the entire code just so you guys can have a better look at this. Also, I'd appreciate any tips to what else can be adjusted in the code to make it better. There it is, thanks in advance!</p>
<pre><code>import sys
import random

class Enemy:
    def __init__(self, name, hp, attack):
        self.name = name
        self.hp = hp
        self.attack = attack

    def attack(self,target):
        target.hp -= self.attack
        print(target.name +" just lost" + str(self.attack)+"HP")

    def status(self):
        if self.hp &lt;= 0:
            print(self.name +' has just died!')
            sys.exit(0)

        print(self.name +"'s HP:" +str(self.hp))


opponent = Enemy("Goblin",10,1)
player = Enemy("Player",10,2)

while True:
    attackChance = random.randrange(0,2)
    if attackChance == 0:
        print(opponent.name + ": Damn it!\n")
    else:
        opponent.attack(player)

    action = input('Press "a" to attack')
    if action == "a":
        player.attack(opponent)
    else:
        continue

    player.status()
    opponent.status()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Oh, I see what happened. You declared both an attribute <code>self.attack</code> and a function <code>self.attack</code>. When you initialized <code>self.attack</code> in the constructor, you overwrote the function -- when you write <code>player.attack(opponent)</code>, Python is trying to call a number, which results in an error.</p>
<p>To fix this, just rename either the attribute or the function.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do it by making <code>attack</code> a <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer"><code>property</code></a>. Then inside the class you'll need to reference the value as a private attribute <code>self._attack</code>, but users/clients of the class can continue to use <code>attack</code> as an <code>Enemy</code> instance method.</p>
<p>Here's what I mean (with comments to further help explain):</p>
<pre><code>import random
import sys

class Enemy:
    def __init__(self, name, hp, attack):
        self.name = name
        self.hp = hp
        self._attack = attack

    @property
    def attack(self):  # getter
        return self._do_attack  # return method

    @attack.setter
    def attack(self, attack):
        self._attack = attack  # change value

    def _do_attack(self, target):
        target.hp -= self._attack  # doesn't use property
        print(target.name +" just lost" + str(self._attack)+"HP")

    def status(self):
        if self.hp &lt;= 0:
            print(self.name +' has just died!')
            sys.exit(0)

        print(self.name +"'s HP:" +str(self.hp))


opponent = Enemy("Goblin",10,1)
player = Enemy("Player",10,2)

while True:
    attackChance = random.randrange(0,2)
    if attackChance == 0:
        print(opponent.name + ": Damn it!\n")
    else:
        opponent.attack(player)

    action = input('Press "a" to attack')
    if action == "a":
        player.attack(opponent)
    else:
        continue

    player.status()
    opponent.status()

action = ''
opponent = Enemy()
player = Enemy()

if action == "a":
    player.attack(opponent)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rename <code>self.attack</code> to something else. E.g., <code>self.attack_points</code>.</p>
</div>
<span class="comment-copy"><code>self.attack = attack</code> is overwriting your method.</span>
<span class="comment-copy">Don't use the same names for properties and methods.</span>
<span class="comment-copy">Methods are just properties that happen to hold functions. So you can't use the same name for both things.</span>
<span class="comment-copy">Yeah I kinda understand that by now. What I want to know is how to get around it and make that piece of code above work.  Edit: nvm im stupid</span>
<span class="comment-copy">Oh! That makes sense, and it actually works, so I had the right idea all along. Thanks for pointing this out, didn't really understand what the commenters meant.</span>
