<div class="post-text" itemprop="text">
<pre><code>def insert_env(self, env):
        """Inserts a new environment into ENV_TABLE

        Keyword arguments:
        env -- name of environment to be inserted
        """
        info = {}
        # populate info dictionary
        sql = (
            """INSERT INTO my_table (...) VALUES (...)""")
        try:
            DML(sql, info)
        except oracleException as e:
            logger.debug('dml {0}  resulted in error {1}'.format(sql, e))
</code></pre>
<p>Here I have a function that populations an <code>info</code> dictionary and inserts the values into a table in a database. <code>DML</code> is a helper method from another function that has been there for a while now and makes the call to the oracle database, with most of the database info already hardcoded in that function. How can I unittest this function? I can't mock a database because the helper function is hardcoded to access our production db.</p>
</div>
<div class="post-text" itemprop="text">
<p>The help function <code>DML</code> is not part of the unit you are testing; mock <em>it</em>. The only thing you need to test in <code>insert_env</code>, apparently, is that <code>DML</code> is called with the appropriate arguments, and that the logger is used if <code>DML</code> raises an exception.</p>
<p>The fact that <code>info</code>, a local variable in <code>insert_env</code>, is never used again after <code>DML</code> is called suggests that this is not the full function. There may be more to test, but it is impossible to say with the information given.</p>
</div>
<div class="post-text" itemprop="text">
<p>First make your sql string a global constant preferably in a second file. Then mock the db calls.</p>
<pre><code># Need to test exception scenario
class oracleExceptionStub(oracleException):
  # bypass constructor
  def __init__(self):
    pass

class Test...(unittest.Testcase):
  @mock.patch('path_to_DML')
  def test_insert_valid(self, mock_dml):
    test_env = ...
    expected_info = ...
    insert_env(test_env)
    mock_dml.assert_called_once_with(sql_contant, expected_info) 

 @mock.patch('logger.debug')
 @mock.patch('path_to_DML', side_effect=oracleExceptionStub)
 def test_insert_invalid(self, mock_dml, mock_logger):
   insert_env(..., ...)
   self.assertTrue(mock_logger.called)
</code></pre>
</div>
<span class="comment-copy">You mock the <code>DML</code> call with <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html</a></span>
