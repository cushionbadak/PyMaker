<div class="post-text" itemprop="text">
<p>I want to build two  lists from a document that may vary in formatting but should roughly be two columns with some separator. each row is :</p>
<pre><code>"word1"\t"word2"
</code></pre>
<p>for example.
My lists should be "list_of_word1", "list_of_word2".
I want to build them at once. I know that I could use pandas, but for some reason (the script should be able to work without specific import, only on general library),  I also need to use regular document opening.</p>
<p>My attempt was:  </p>
<pre><code>list_of_word1=[]
list_of_word2=[]
((list_of_word1.extend(line.split()[0]),list_of_word2.extend(line.split()[1])) for line in open(doc))
</code></pre>
<p>The generator doesn't serve any purpose since extend returns None, so that may be seen as bad to use a form that won't be reused there or that might be unnecessary in the first place.
Plus, I would like to know how to avoid to have to reuse the split function, that's "ok" for 2 times per line, but if I was to use the same principle on more columns, it would become very unefficient. </p>
<p>My try to avoid reuse split was to make it like this:  </p>
<pre><code>((list_of_word1.extend(linesplit0),list_of_word2.extend(linesplit1)) for line in open(doc) for (linesplit0,linesplit1) in line.split("\t"))
</code></pre>
<p>but that indeed doesn't work, since it doesn't find tuples to unpack. i also tried starred unpacking but that's not working.</p>
<pre><code>((list_of_word1.extend(linesplit0),list_of_word2.extend(linesplit1)) for linesplit0,linesplit1 in open(doc).readline().split("\n").split("\t"))
</code></pre>
<p>But that somehow feels unsatisfactory, too contrived.
What do you think?</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer will work regardless of the delimiter used (provided it is some number of spaces!)</p>
<pre><code>with open('temp.txt','r') as f:
    data = f.read().strip('\n').split('\n')

dataNoSpace = [filter(lambda a: a!= '', i.split(' ')) for i in data]
list1, list2 = [list(i) for i in zip(*dataNoSpace)]
</code></pre>
<p>For example, if <strong>'temp.txt'</strong> is:</p>
<pre><code>word10 word20
word11    word21
word12       word22
word13  word23
word14    word24
</code></pre>
<p>We get:</p>
<pre><code>list1
['word10', 'word11', 'word12', 'word13', 'word14']

list2
['word20', 'word21', 'word22', 'word23', 'word24']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe this?</p>
<pre><code>lists = [[] for i in range(&lt;number_of_lists&gt;)]
[[z[0] + [z[1]] for z in zip(lists, line.split())] for line in open(doc)]
</code></pre>
<p>(might need some tweaking)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> together with <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">argument unpacking</a> to achieve this.</p>
<p>Example input file <code>data.txt</code>:</p>
<pre class="lang-none prettyprint-override"><code>1 2 3
apple orange banana
one two three
a b c
</code></pre>
<p>Code:</p>
<pre><code>&gt;&gt;&gt; with open('data.txt') as f:
...    list(zip(*(line.split() for line in f)))
... 
[('1', 'apple', 'one', 'a'), ('2', 'orange', 'two', 'b'), ('3', 'banana', 'three', 'c')]
</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/19339/transpose-unzip-function-inverse-of-zip">Transpose/Unzip Function (inverse of zip)?</a></li>
<li><a href="https://stackoverflow.com/questions/6473679/transpose-list-of-lists">Transpose list of lists</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Actually at first I wanted to use zip, hence the generator. But I mixed up things and ended up adding<br/>
    list_of_word1=[]
    list_of_word2=[]</p>
<p>which are useless like that.
What should be done would be:</p>
<pre><code>list_of_word1,list_of_word2=zip(*((line.split()) for line in open(doc)))
</code></pre>
<p>That works like a charm. Still the fundamental problem remains, while I could do what I wanted, I still have the problem of not knowing how to do If I have to manage a split unpacking in a comprehension. if you have any idea...?</p>
</div>
<span class="comment-copy">That's neat, but you end looping two times on your dataclean, which I want to avoid. I would do the same anyway, but I try the most to avoid such things, looping over data structures is computationally unefficient. Plus we would not need to be on the same line by using such form, it is less readable (for me). Still the  data preparation is very nice</span>
<span class="comment-copy">Okay check it out now - not sure it can get any cleaner!</span>
<span class="comment-copy">That's perfect:)</span>
<span class="comment-copy">Great! If this has solved your problem you can mark as correct :-)</span>
<span class="comment-copy">I think it's like my own answer when I sorted it in my head. But while I like the zip, I wonder about other use case like having to build a list of tuples of selected element of the split, and the problem of split unpacking remains... (something like [(line.split()[0],line.split()[-1]) for line in docread], but i would  like to find a way to unpack the split for both element of the initial tuple instead of using split() two times...</span>
<span class="comment-copy">@AndoJurai Sorry, I don't understand what you mean. You should update your question with a specific example input and desired result.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/43656861/unpacking-a-split-inside-a-list-comprehension" title="unpacking a split inside a list comprehension">stackoverflow.com/questions/43656861/â€¦</a></span>
