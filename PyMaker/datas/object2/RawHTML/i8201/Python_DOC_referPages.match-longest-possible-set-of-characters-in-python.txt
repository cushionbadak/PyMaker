<div class="post-text" itemprop="text">
<p>There is a string with characters 0123456789AB.
I have a regexp:</p>
<pre><code>([^1368A]+|[^2479B]+|[^0358A]+|[^1469B]+|[^0257A]+|[^1368B]+|[^02479]+|[^1358A]+|[^2469B]+|[^0357A]+|[^1468B]+|[^02579]+)
</code></pre>
<p>The problem that it match first instead of longest. How to make it match the longest in python? I'm not hoping that it is possible in regexp.
Edit: I need to find all matches. Preferably with index of succeeded pattern.
Example of input:</p>
<pre><code>66666A00666160666106606610666610A60661606661606066160660616A00666160666160606610666610A60661606661066066160660616A00666160666160606616066610A60661606661606066106660616A00666106666160606616066610A60661066661606066160660616A0000000000000666606A100666160666160606616066616060661606661606066106666106606610666616060661606661606066106666160606610666610660661066661606066106666160606610666616060661606661606066106666160606616066616060661606661066066160666160606616066610660661606661066066160666106606616066616060661606661066066160666106606616066616060661606661606066160666160606616066610660661066661606066106666160606610666616060661066661606066160666160606616066616060666066616060666066616060666066616060666066616060666066660606666A
</code></pre>
<p>Another example:</p>
<pre><code>027027240270272402702724027027240270272402702724027027240270272402702724027027240270272402702724027027240270272402702724027027240270272402702724027027240270272402702724027027240270272402702724027027240270272402702724027027240270272402702724027027240270272402702724027027240270272402702724027027240270272402702724027027240270272427BB232B0738310A5320738310A53202735A8310A53202735A8310A53202735A8310A53202735A8310A532249A540249A540249A540249A540792A54002402702724792A540
</code></pre>
<p>Example with output:</p>
<pre><code>'470470574704705747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B57470470574704705747047057B2727875377AA0577AA0577AA0577AA0577AA0577AA059959959959952257777225'
('1368A','470470574704705747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B5747047057570570574704705727027B57470470574704705747047057B2727'),('','8'),('1468B','75377AA0577AA0577AA0577AA0577AA0577AA059959959959952257777225')
</code></pre>
<p>Added: currently I use this code:</p>
<pre><code>import sys,re
from midplay import MidiFile,NoteOn
from collections import deque
notes=("C","C#","D","Eb","E","F","F#","G","G#","A","Bb","B")
noteshex=('0','1','2','3','4','5','6','7','8','9','A','B')
major=lambda x:((x)%12,(x+2)%12,(x+4)%12,(x+5)%12,(x+7)%12,(x+9)%12,(x+11)%12,)
minor=lambda x:((x)%12,(x+2)%12,(x+3)%12,(x+5)%12,(x+7)%12,(x+8)%12,(x+10)%12,)
nomajor=lambda x:{(x+1)%12,(x+3)%12,(x+6)%12,(x+8)%12,(x+10)%12}
nominor=lambda x:{(x+1)%12,(x+4)%12,(x+6)%12,(x+9)%12,(x+11)%12}
nomajortonelist=[re.compile('([^'+''.join([noteshex[note] for note in nomajor(tonality)])+']+)') for tonality in range(12)]
nominortonelist=nomajortonelist[3:]+nomajortonelist[:3]
if len(sys.argv)!=2:
    sys.exit('usage: py tonalitydetect.py [C:\path]filename.mid')
midi=MidiFile(sys.argv[1])
for num, track in enumerate(midi):
    print('Track:',num,'messages:',len(track))
    channelnotes=['','','','','','','','','','','','','','','','']
    channeltonality=[deque(),deque(),deque(),deque(),deque(),deque(),deque(),deque(),deque(),deque(),deque(),deque(),deque(),deque(),deque(),deque()]
    for msg in track:
        if isinstance(msg,NoteOn):
            channelnotes[msg.channel]+=(noteshex[msg.note%12])
    for chnum,channel in enumerate(channelnotes):
        tomatch=[channel]
        matches=[]
        while ''.join(tomatch)!='':
            curchanmaxmatch=deque()
            for string in tomatch:
                for exp in nomajortonelist:
                    curchanmaxmatch.append((exp,max(exp.findall(string)+[''], key=len)))
            matches.append(max(curchanmaxmatch+deque([('','',)]), key=lambda x:len(x[1])))
            newmatch=[]
            found=0
            for x in tomatch:
                if not found:
                    match=x.split(matches[-1][1],1)
                    if len(match)&gt;1:
                        found=1
                    newmatch.extend(match)
                else:
                    newmatch.append(x)
            tomatch=[x for x in newmatch if x!='']
        matches=sorted(matches, key=lambda x:len(x[1]))
        toseek=channel
        while len(matches):
            for num,match in enumerate(matches):
                if not toseek.find(match[1]):
                    channeltonality[chnum].append(match)
                    toseek=toseek[len(match[1]):]
                    del matches[num]
                    break
    for chnum,channel in enumerate(channeltonality):
        print('Channel',chnum,':',[notes[nomajortonelist.index(x[0])]+' major, '+notes[nominortonelist.index(x[0])]+' minor' for x in channel])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edit: See below for a solution that shows the position of the longest match.</strong></p>
<p>The closest build-in tool for your problem is <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer"><code>re.findall(pattern,string,flags=0)</code></a>: <em>'Return all non-overlapping matches of pattern in string, as a list of strings.'</em></p>
<p>A problem for your case is that different matches can overlap --- but <code>findall</code> only returns non-overlapping matches.  For example, the input string <code>2B001AA</code> contains two different matches: <code>2B00</code> and <code>001AA</code>. The <code>re.findall</code> function would find and return the first match <code>2B00</code>.  Then, it continues where it left off --- returning only <code>1AA</code> as the next match.</p>
<p>You can solve this problem by breaking your regexp into pieces to be matched one-by-one:</p>
<pre><code>import re
patterns=[
    r'[^1368A]+', r'[^2479B]+', r'[^0358A]+', r'[^1469B]+',
    r'[^0257A]+', r'[^1368B]+', r'[^02479]+', r'[^1358A]+',
    r'[^2469B]+', r'[^0357A]+', r'[^1468B]+', r'[^02579]+'
]

def match_patterns(string):
    for pattern in patterns:
        for match in re.findall(pattern,string):
            yield match
</code></pre>
<p>The function <code>match_pattern</code> returns all matches (but not always in order). In python3, you can write this function shorter:</p>
<pre><code>def match_patterns(string):
    for pattern in patterns:
        yield from re.findall(pattern,string)
</code></pre>
<p>In any case, you can extract the longest match with the built-in function <code>max</code>:</p>
<pre><code>def find_longest_match(string):
    return max(match_patterns(string), key=len)

print(find_longest_match('12A34B32A43')) # prints: A34B3
</code></pre>
<hr/>
<p>If you also want the position of the longest match, work with 
<a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow noreferrer"><code>re.finditer(pattern, string, flags=0)</code></a>: <em>'Return an iterator yielding <a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow noreferrer">match objects</a> over all non-overlapping matches for the RE pattern in string.'</em>  For each returned <code>match</code>, <code>match.start()</code> gives us the start position and <code>match.group(0)</code> the text of the match.</p>
<pre><code>import re
patterns=[
    r'[^1368A]+', r'[^2479B]+', r'[^0358A]+', r'[^1469B]+',
    r'[^0257A]+', r'[^1368B]+', r'[^02479]+', r'[^1358A]+',
    r'[^2469B]+', r'[^0357A]+', r'[^1468B]+', r'[^02579]+'
]

def match_patterns(string):
    for pattern in patterns:
        yield from re.finditer(pattern, string)

def find_longest_match(string):
    match=max(match_patterns(string), key=lambda m: len(m.group(0)))
    if match:
        return match.start(), match.group(0)
    else:
        return None

print(find_longest_match('12A34B32A43')) # prints: (2, 'A34B3')
</code></pre>
</div>
<span class="comment-copy">what is "the longest" in your case? It's unclear</span>
<span class="comment-copy">Please provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>, which in this case should explicitly include input and expected output.</span>
<span class="comment-copy">Of course it is unclear! That's why I'm asking.</span>
<span class="comment-copy">your description is also unclear, that's why I've commented</span>
<span class="comment-copy">could you provide an expected output of those examples?</span>
<span class="comment-copy">does that mean that some chars may be omitted? i was thinking about examining string with every pattern, find longest patterns, split string by longest patterns, find longest in splitted parts, until no character is overlapped, and every found.</span>
<span class="comment-copy">I added an explanation of the overlap problem into the answer.</span>
