<div class="post-text" itemprop="text">
<p>After going through this <a href="https://stackoverflow.com/questions/22604974/python-memory-model-for-this-program">question</a></p>
<p><code>globals()</code> give the dictionary view of the global namespace(<code>__main__</code> module).</p>
<pre><code>&gt;&gt;&gt; globals()
{'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__name__': '__main__', '__doc__': None, '__package__': None}
&gt;&gt;&gt;
</code></pre>
<p>Any new symbol(name), say <code>operator</code> added to this namespace, will become a member of that global name space.</p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt; globals()
{'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__name__': '__main__', '__doc__': None, 'operator': &lt;module 'operator' (built-in)&gt;, '__package__': None}
&gt;&gt;&gt; globals()['operator']
&lt;module 'operator' (built-in)&gt;
&gt;&gt;&gt; 
</code></pre>
<p>where <code>operator</code> is a new <code>str</code> type key, value is the <code>module</code> type object.</p>
<p>further on using <code>operator</code> module(say <code>__abs__</code>), in current namespace,</p>
<pre><code>&gt;&gt;&gt; globals()['operator']['__abs__']

Traceback (most recent call last):
  File "&lt;pyshell#11&gt;", line 1, in &lt;module&gt;
    globals()['operator']['__abs__']
TypeError: 'module' object has no attribute '__getitem__'
&gt;&gt;&gt; 
</code></pre>
<p>It says, <code>operator</code> module is not a dictionary because there is no attribute by name <code>__getitem__</code>.</p>
<p>But, all the code from my application(in runtime), will be part of the dictionary shown by <code>globals()</code> function.</p>
<p><strong>Question:</strong></p>
<p>Ignoring coding standards, 
In JavaScript, I can use dictionary notation to write my complete code, for example,</p>
<pre><code>&gt; window['Array']

            function Array() { [native code] }


&gt; window['Array']['length']
1
</code></pre>
<p>In python, Why global namespace members(keys) are only viewed as dictionary members but not their values(like <code>operator</code> object)? Despite all the subsequent code of your program, is part of that dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, there is a difference between <a href="https://docs.python.org/3/reference/expressions.html#attribute-references" rel="nofollow noreferrer">attribute references</a>, the syntax where you use dots to access <em>attributes</em> of objects, and <a href="https://docs.python.org/3/reference/expressions.html#subscriptions" rel="nofollow noreferrer">subscriptions</a>, where you use square brackets to access <em>items</em> of an object.</p>
<p>You can use this difference in your custom types by using the special methods <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>__getitem__</code></a> (and the related methods for setting etc.) and <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a> (and related methods). So you <em>can</em> implement your types to support both syntaxes to achieve the same; or you can use it to assign difference semantics to each syntax as it is the case for standard Python types.</p>
<p>As for why this distinction is made, this is simply a language design decision that was made, which ultimately makes the language more powerful. For example, this allows a dictionary to have a key <code>'update'</code>, when there is also an attribute—a method in this case—called <a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow noreferrer"><code>dict.update</code></a>.</p>
<p>Also, not depending on the equivalence of <code>foo.bar</code> and <code>foo['bar']</code> avoids limiting subscription keys to strings, like it is the case with JavaScript. Instead, we can use any hashable object as a key. This makes the <code>dict</code> type similar to JavaScripts newer <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="nofollow noreferrer"><code>Map</code> type</a> which also supports a wide range of key types. Note that because of JavaScript’s inferior syntax choices, there are explit methods <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get" rel="nofollow noreferrer"><code>get</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set" rel="nofollow noreferrer"><code>set</code></a> to access the map items.</p>
</div>
<div class="post-text" itemprop="text">
<p>1.
JS doesn't have dictionaries. They are emulated by using objects.
What you are doing when defining a dictionary or associative array, or however you want to call it in javascript is 
assigning values to attributes of a new object.</p>
<p>2.
Python has actual data type dictionary i.e. dict() which IS AN OBJECT (everything in Python is) specialized to store pairs key: value and optimized for fast access.
This is actually a container that holds Python scopes. I.e. when you call</p>
<pre><code>globals()
</code></pre>
<p>You do not get a view of global variables. You do get a pointer to the real global scope.
So, if you say:</p>
<pre><code>globals()["abcdefgh"] = 123456
</code></pre>
<p>you will be able to</p>
<pre><code>print abcdefgh
</code></pre>
<p>because you directly inserted the variable abcdefgh into interpreters global namespace holder.
This happens when you use = assignment operator automatically.</p>
<p>So, globals() dictionary contains real values, which are objects, but not necessarily dictionaries.</p>
<p>In JS what you describe works, because what you are actually doing is in Python this:</p>
<pre><code>class obj: pass

somevar = obj()
somevar.one = 1
somevar.two = "two"
somevar.something = "nothing"
</code></pre>
<p>And if you want to see them as dict, then you have to get to the somevar instance's namespace dictionary:</p>
<pre><code>print somevar.__dict__
somevar.__dict__["blah"] = "xxx"
print somevar.__dict__
print dir(somevar) # To see all attributes of obj()
</code></pre>
<p>Otherwise it is:</p>
<pre><code>print somevar
&lt;__main__.obj instance at 0xxxxxxxxx&gt;
</code></pre>
<p>And if you want the obj() instance to act as a dict() then you have to implement the dictionary's interface for it.</p>
<p>In JS it is always just another object, so syntax continues to work regardless on how it was defined in the first place.</p>
</div>
<span class="comment-copy">I'm not completely sure that I'm understanding your question.  Just because a module (and indeed, most objects) can be represented as a <code>dict</code> using <code>vars(module)</code> doesn't mean that the module object <i>is</i> a dict and should support item access like a <code>dict</code>.  Are you asking why <code>foo.bar</code> and <code>foo['bar']</code> don't mean the same thing in Python as they do in Javascript?</span>
<span class="comment-copy">@mgilson  In python, why <code>foo.bar</code> and <code>foo['bar']</code> don't mean the same? despite these all name are part of dictionary that <code>globals()</code> output.</span>
<span class="comment-copy">In Javascript, objects and dictionaries are the same thing, and you can use <code>.</code> or <code>[]</code> syntax depending on whether the property is literal or dynamic. Python has distinct object and dictionaries (a dictionary is a specific type of object), and properties are different from dictionary elements.</span>
<span class="comment-copy">The fact that <code>globals()</code> <b>returns a dict</b> does not mean that Python dictionaries are actually how all of this is implemented.</span>
<span class="comment-copy">@juanpa.arrivillaga -- But it <i>is</i> how most of it is implemented.  The most notable exceptions are classes with <code>__slots__</code> and <code>locals()</code>.  The key distinction is that <code>foo.bar</code> usually looks up a <code>bar</code> key inside <code>foo.__dict__</code>.  this allows for a lot of really cool things.  e.g. you can have <code>@property</code> which calls a function on lookup.  You can have an object where <code>foo.get</code> and <code>foo['get']</code> are <i>different</i> things.  It also encourages structure.  <code>foo.bar</code> and <code>foo['bar']</code> have evolved to have <i>very</i> clear and different semantics.</span>
