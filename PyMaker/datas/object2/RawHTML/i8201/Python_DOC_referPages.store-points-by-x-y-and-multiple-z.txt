<div class="post-text" itemprop="text">
<p>I will write an example so you can understand me :</p>
<p>For instance, I have these 3 points : (0, 1, 244) - (0, 1, 255) - (1, 2, 133)</p>
<p>Actually I need to average the Z when 2 points have the same (x, y). My idea is to store them in something (an array, a dictionary ?) with a double index/key where the value is an array of the Z.</p>
<p>So I basically want to have this : [0, 1, [244, 255]] and [1, 2, [133]]</p>
<p>My problem is I don't know what to use to store them the simpliest way to do so...</p>
<p>Thanks in advance !</p>
</div>
<div class="post-text" itemprop="text">
<p>Tuples can be dictionary keys:</p>
<pre><code>myDict = {(1,2): 3}
</code></pre>
<p>is perfectly valid.</p>
<p>Another approach would be to use <code>itertools.groupby</code>, but make sure that your list is already sorted by they key you want to use for your groups (<a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#itertools.groupby</a>):</p>
<pre><code>from itertools import groupby

myList = [(1,2,3), (1,2,4), (1,3,4)]
for grp, values in groupby(myList, lambda x: (x[:2])):
   print(grp, list(values))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a dictionary:</p>
<pre><code>points = [(0, 1, 244), (0, 1, 255), (1, 2, 133)]
d = {}
for point in points:
    key = point[:2]
    if key in d.keys():
        (d[key]).append(point[2])
    else:
        d[key] = [point[2]]
print(d)
</code></pre>
<p>For the mean values:</p>
<pre><code>import numpy as np
for k in d.values():
    print(np.mean(k))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here are a couple of ways of doing this:</p>
<ol>
<li><p>As Geotop suggested, use a dictionary indexed with a tuple.<br/>
This according to me is an elegant solution.  </p></li>
<li><p>Depending on the purpose and ease of traverse, you may convert the same to a nested list as follows:  </p>
<p>a = [ [ (1,2), (3,4), (5,6) ],
      [ [123,234,345], [567,678,543], [433,645,754] ] ]</p></li>
</ol>
<p>Now you may access the list of <code>z</code> values corresponding to <code>(x,y)</code> using <code>a[1][i]</code>, where the tuple <code>(x,y)</code> is stored as <code>a[0][i]</code>.</p>
<p>The second method seems much better to me as it avoids dictionary use and makes indexing much easier (as it is indexed with integers.). But at the end, it all depends on your purpose.</p>
<p>Storing it randomly in a list and getting the values by a search is a bad idea if you look up the data frequently or if the data is huge.</p>
</div>
<span class="comment-copy">double index key is not possible.</span>
<span class="comment-copy">I figured it out :/ Do you have an other idea ? I need to find the Z of a given couple of (x, y) basically</span>
<span class="comment-copy">you can store the data in x --&gt; y --&gt; [z1, z2 ] way. I can help you with the code if you can show me your input data format.</span>
<span class="comment-copy">a dict of dicts storing lists: <code>{0:{1:[244,255]}, 1:{2:[133,]}}</code>. as long as you only use integers ...</span>
<span class="comment-copy">I tried your code with that list : myList = [(1, 2, 3), (1, 2, 4), (5, 6, 7), (5, 7, 8), (5, 6, 9)]  But I got : ((1, 2), [(1, 2, 3), (1, 2, 4)]) ((5, 6), [(5, 6, 7)]) ((5, 7), [(5, 7, 8)]) ((5, 6), [(5, 6, 9)]) It only works when the same (x, y) points are following each other :/</span>
<span class="comment-copy">Solved by doing myList.sort(key=operator.itemgetter(0,1)) !</span>
<span class="comment-copy">Yes, sorry I should have mentioned that the list should be sorted on the key: "Generally, the iterable needs to already be sorted on the same key function" (<a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.groupby</a>)</span>
<span class="comment-copy">You can just do <code>sum(lst) / len(lst)</code> without using numpy</span>
<span class="comment-copy">Thank you man :)</span>
