<div class="post-text" itemprop="text">
<p>I'm a Python newbie, trying to understand the philosophy/logic behind the inheritance methods. Questions ultimately regards why and when one has to use the <code>__init__</code> method in a subclass. Example:</p>
<p>It seems a subclass inheriting from a superclass need not have its own constructor <code>(__init__</code>) method. Below, a dog inherits the attributes (name, age) and methods (makenoise) of a mammal. You can even add a method (<code>do_a_trick</code>) Everything works as it ``should", it seems.</p>
<p>However, if I wanted to add a new attribute in the subclass as I attempt to do in the Cats class, I get an error saying "self" is not defined. Yet I used "self" in the definition of the dog class. What's the nature of the difference?
It seems to define Cats as I wish I need to use <code>__init__(self,name)</code> and <code>super()__init__(name)</code>. Why the difference?</p>
<pre><code>class Mammals(object):

  def __init__(self,name):
    self.name = name
    print("I am a new-born "+ self.name)  
    self.age = 0

  def makenoise(self):
    print(self.name + " says Hello")

class Dogs(Mammals):

  def do_a_trick(self):
    print(self.name + " can roll over")

class Cats(Mammals):

 self.furry = "True"  #results in error `self' is not defined


mymammal = Mammals("zebra") #output "I am a new-born zebra"
mymammal.makenoise()  #output "zebra says hello"
print(mymmmal.age)    #output 0

mydog = Dogs("family pet") #output "I am a new-born family pet"
mydog.makenoise()  #output "family pet says hello"
print(mydog.age)  # output 0
mydog.do_a_trick() #output "family pet can roll over"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>if I wanted to add a new attribute in the subclass as I attempt to do
  in the Cats class, I get an error saying "self" is not defined. Yet I
  used "self" in the definition of the dog class.</p>
</blockquote>
<p>In your superclass, Mammal, you have an <code>__init__</code> function, which takes an argument that you've chosen* to call <code>self</code>. This argument is in scope when you're in the body of the <code>__init__</code> function - it's a local variable like any local variable, and it's not possible to refer to it after its containing function terminates. 
The function defined on the Dog class, <code>do_a_trick</code>, also takes an argument called <code>self</code>, and it is also local to that function. 
What makes these variables special is not their name (you could call them anything you wanted) but the fact that, as the first arguments to instance methods in python, they get a reference to the object on which they're called as their value. (Read that last sentence again a few times, it's the key to understanding this, and you probably won't get it the first time.)</p>
<p>Now, in <code>Cat</code>, you have a line of code which is not in a function at all. Nothing is in scope at this point, including <code>self</code>, which is why this fails. If you were to define a function in <code>Cat</code> that took an argument called <code>self</code>, it would be possible to refer to that argument. If that argument happened to be the first argument to an instance method on <code>Cat</code>, then it would have the value of the instance of <code>Cat</code> on which it had been called. Otherwise, it would have whatever got passed to it. </p>
<p>*you have chosen wisely!</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">Explicit is better than implicit.</a></p>
</blockquote>
<p>However, you can do below:</p>
<pre><code>class Dogs(Mammals):
    def __init__(self):
        #add new attribute
        self.someattribute = 'value'
        Mammals.__init__(self)
</code></pre>
<p>or</p>
<pre><code>class Dogs(Mammals):
    def __init__(self):
        #add new attribute
        self.someattribute = 'value'
        super(Mammals, self).__init__()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do something like in Chankey's answer by initiating all the variables in the constructor method ie <code>__init__</code></p>
<p>However you can also do something like this</p>
<pre><code>class Cats(Mammals):

 furry = "True"
</code></pre>
<p>And then </p>
<pre><code>cat = Cats("Tom")
cat.furry # Returns "True"
</code></pre>
<p>The reason you can't use <code>self</code> outside the functions is because <code>self</code> is used explicitly only for instances of the class. If you used it outside, it would lead to ambiguity. If my answer isn't clear please let me know in comments.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__init__</code> method runs once on the creation of an <em>instance</em> of a class. So if you want to set an attribute on an instance when it's created, that's where you do it. <code>self</code> is a special keyword that is passed as the first argument to every method, and it refers to the instance itself. <code>__init__</code> is no different from other methods in this regard.</p>
<p>"What's the nature of the difference": you define the method <code>Dog.do_a_trick</code>, and you receive <code>self</code>  as an argument to the method as usual. But in <code>Cat</code> you've unintentionally (perhaps subconsciously!) attempted to work on the class scope -- this is how you'd set a <em>class attribute</em> whose value is identical for all cats:</p>
<pre><code>class Cat(object):
    sound = "meow"
</code></pre>
<p>It's different so you can have both options available. Sometimes (not all the time, but once in a while) a class attribute is a useful thing to have. All cats have the same sound. But much of the time you'll work with instance attributes -- different cats have different names; when you need that, use <code>__init__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Declarations at the top level of a Python class become class attributes. If you come from a C++ or Java background, this is similar to declaring a static member variable. You cannot assign instance attributes at that level.</p>
<p>The variable <code>self</code> usually refers to a specific instance of a class, the one from which the method has been called. When a method call is made using the syntax <code>inst.method()</code>, the first argument to the function is the object <code>inst</code> on which the method was called. In your case, and usually by convention, that argument is named <code>self</code> within the function body of methods. You can think of <code>self</code> as only being a valid identifier within method bodies then. Your assignment <code>self.furry = True</code> does not take place in a method, so self isn't defined there.</p>
<p>You have basically two options for achieving what you want. The first is to properly define <code>furry</code> as an attribute of the cat class:</p>
<pre><code>class Cat(Mammals):
    furry = True

    # Rest of Cat implementation ...
</code></pre>
<p>or you can set the value of an instance variable <code>furry</code> in the cat constructor:</p>
<pre><code>class Cat(Mammals):
    def __init__(self):
        super(Mammals, self).__init__(self)
        self.furry = True

    # Rest of Cat implementation ...
</code></pre>
<p>If you're getting into Python I highly recommend to read these two parts of the Python documentation:</p>
<p><a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer" title="Classes">Python classes</a></p>
<p><a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer" title="Data Model Special Methods">Python data model special methods</a> (more advanced)</p>
</div>
<div class="post-text" itemprop="text">
<p>Suppose you have a class named <code>Person</code> which has a method named <code>get_name</code> defined as :</p>
<pre><code> class Person():
     def __init__(self, first_name, last_name):
         self.first_name = first_name
         self.last_name = last_name

     def get_name(self):
         return self.first_name + ' ' + self.last_name
</code></pre>
<p>And, you create an instance of <code>Person</code> as <code>p1</code>. Now when you call the function <code>get_name()</code> with this instance, it will converts internally</p>
<pre><code>    Person.get_name(p1)
</code></pre>
<p>So, self is the instance itself.</p>
<p>Without <code>self</code> you can write above code as :</p>
<pre><code> class Person():
     first_name = None
     last_name = None


     def get_name(personobject):
         return personobject.first_name + ' ' + personobject.last_name
</code></pre>
<p>What I am trying to say is the name <code>self</code> is a convention only.</p>
<p>And for inheritance, if you would like to have extra attributes in your subclass, you need to initiate your super class first and add your parameter as you wanted.
For example, if you want to create a subclass from <code>Person</code> named <code>Boy</code> with new attribute <code>height</code>, the you can define it as:</p>
<pre><code>class Boy(Person):
     def __init__(self, first_name, last_name, height):
         super(Person, self).__init__(first_name, last_name)
         self.height = height
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As pointed out in the other answers, the <code>self</code> that you see in the other
functions is actually a parameter. By Python convention, the first parameter in
an instance method is always <code>self</code>.</p>
<p>The class <code>Cats</code> inherits the <code>__init__</code> function from its base class,
<code>Mammals</code>. You can override <code>__init__</code>, and you can call or not call the base
class implementation.</p>
<p>In case the <code>Cats</code> <code>__init__</code> wants to call the base implementation, but doesn't want to care about the parameters, you can use Python variable arguments. This is shown in the following code.</p>
<p>Class declaration:</p>
<pre><code>class Cats(Mammals):

  def __init__(self, *args):
    super().__init__(*args)
    self.furry = "True"
</code></pre>
<p>See, for example, this Stack Overflow question for something about the star
notation for variable numbers of arguments:
<a href="https://stackoverflow.com/questions/919680/can-a-variable-number-of-arguments-be-passed-to-a-function#919684">Can a variable number of arguments be passed to a function?</a></p>
<p>Additional test code:</p>
<pre><code>cat = Cats("cat")
print(vars(cat))
</code></pre>
<p>Output:</p>
<pre><code>I am a new-born cat
{'name': 'cat', 'age': 0, 'furry': 'True'}
</code></pre>
</div>
<span class="comment-copy"><code>__init__</code> is not a constructor, it is initializer which works on already constructed <code>self</code> instance</span>
<span class="comment-copy">Thx! My mistake I think is to think that an instance method like def makenoise(self) or def __init(self,name) are taking what "self" refer to as <i>input</i> instead they are <i>setting</i> "self" (or whatever term is used) to the name of the object. So using __init__(foo,whatever) would <i>set</i> foo to the name of the object, so that you can subsequently define its attributes and methods. Do I have it?</span>
