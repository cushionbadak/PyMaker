<div class="post-text" itemprop="text">
<p>Given the input:</p>
<pre><code>x = ['foo bar', 'bar blah', 'black sheep']
</code></pre>
<p>I could do this to get the count of each word in the list of space delimited string:</p>
<pre><code>from itertools import chain
from collections import Counter
c = Counter(chain(*map(str.split, x)))
</code></pre>
<p>Or I could simple iterate through and get:</p>
<pre><code>c = Counter()
for sent in x:
    for word in sent.split():
        c[word]+=1
</code></pre>
<p>[out]:</p>
<pre><code>Counter({'bar': 2, 'sheep': 1, 'blah': 1, 'foo': 1, 'black': 1})
</code></pre>
<p>The question is <strong>which is more efficient if the input list of string is extremely huge?</strong> Are there other ways to achieve the same counter object?</p>
<p>Imagine it's a text file object that has billions of lines with 10-20 words each.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you are in Python 3x, both <code>chain(*map(str.split, x))</code> and simple iteration will create intermediate lists sequentially from each line; this will not take up much memory in either case. Performance should be very close and may be implementation-dependent.</p>
<p>However, it is most efficient memory-wise to create a generator function to feed Counter(). Either way you use string.split(), it creates intermediate lists which are not necessary. This could cause slowdown if you have a particularly long line, but to be honest it's unlikely.</p>
<p>Such a generator function is described below. Note that I am using optional typing for clarity.</p>
<pre><code>from typing import Iterable, Generator
def gen_words(strings: Iterable[str]) -&gt; Generator[str]:
    for string in strings:
        start = 0
        for i, char in enumerate(string):
            if char == ' ':
                if start != i:
                    yield string[start:i]
                start = i
        if start != i:
            yield string[start:i]
c = counter(gen_words(strings))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answer to your question is <a href="https://en.wikipedia.org/wiki/Profiling_(computer_programming)" rel="nofollow noreferrer">profiling</a>. </p>
<p>Following are some profiling tools:</p>
<ul>
<li>print <a href="https://docs.python.org/3/library/time.html" rel="nofollow noreferrer">time.time()</a> in strategic places. (or use <a href="https://en.wikipedia.org/wiki/Time_(Unix)" rel="nofollow noreferrer">Unix time</a>)</li>
<li><a href="https://pymotw.com/2/profile/" rel="nofollow noreferrer">cProfile</a></li>
<li><a href="https://github.com/rkern/line_profiler" rel="nofollow noreferrer">line_profiler</a></li>
<li><a href="http://smira.ru/wp-content/uploads/2011/08/heapy.html" rel="nofollow noreferrer">heapy</a> tracks all objects inside Pythonâ€™s memory (good for memory leaks)</li>
<li>For long-running systems, use <a href="http://e-mats.org/2013/01/debugging-pythons-memory-usage-with-dowser/" rel="nofollow noreferrer">dowser</a>: allows live objects introspection (web browser interface)</li>
<li><a href="https://pypi.python.org/pypi/memory_profiler/0.9" rel="nofollow noreferrer">memory_profiler</a> for RAM usage</li>
<li>examine Python bytecode with <a href="https://docs.python.org/2/library/dis.html" rel="nofollow noreferrer">dis</a></li>
</ul>
</div>
<span class="comment-copy">Assuming each <code>sent</code> is reasonably sized, your second solution should be about as good as you can do.  Of course you could manually iterate through the characters, but I don't see that giving any improvement.  I'm not familiar enough with chain to know how it will perform here.</span>
<span class="comment-copy">Why don't you time it and see?</span>
