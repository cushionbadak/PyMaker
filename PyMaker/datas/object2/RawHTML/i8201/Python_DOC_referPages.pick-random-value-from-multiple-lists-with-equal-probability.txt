<div class="post-text" itemprop="text">
<p>Assume I have 3 lists</p>
<pre><code>old_people = ['George', 'Bob', 'Owen']
young_people = ['Sarah', 'Gwen', 'Brittney']
mid_age = ['Larry', 'Missy', 'Greg']


import random
random.choice(old_people)
</code></pre>
<p>That picks from one, how would I pick 1 name from all three lists with equal probability?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that by "1 name from all three lists with equal probability" you mean that each name will have an equal probability of being selected, since the introduction of <a href="https://docs.python.org/3/library/random.html" rel="noreferrer"><code>random.choices</code></a> in python 3.6, it's possible to do this relatively straightforwardly without needing to concatenate to build one giant list.  For example:</p>
<pre><code>In [52]: seqs = [old_people, young_people, mid_age]

In [53]: random.choice(random.choices(seqs, weights=map(len, seqs))[0])
Out[53]: 'Larry'
</code></pre>
<p>where we select one of the lists using the lengths to weight our selection, and then we choose uniformly from that list.  <code>seqs</code> just makes a list of references to the sublists, and so no concatenation is performed.</p>
<p>As a sanity check of the uniformity:</p>
<pre><code>In [65]: seqs = [["Bob"], ["Fred", "Sally"]]

In [66]: Counter(random.choice(random.choices(seqs, weights=map(len, seqs))[0]) 
                 for _ in range(10**6))
Out[66]: Counter({'Bob': 333484, 'Fred': 332755, 'Sally': 333761})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to incur the overhead of concatenating multiple lists together, (in which case I wouldn't blame you - it's O(n) for what should be an O(1) operation), you can do the same thing by choosing an index that corresponds to a location in the concatenated lists, then indexing the appropriate list. In code:</p>
<pre><code>import random

def choose(*lists):
    total_len = sum(map(len, lists))
    index = random.randint(0, total_len - 1)
    for l in lists:
        if index &lt; len(l):
            return l[index]
        else:
            index = index - len(l)
</code></pre>
<p>This computes an index, then iterates over the list of lists until it finds the one it falls in, then returns the appropriate element.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another possible implementation. Assumes input is well formed.</p>
<pre><code>import random
def choose(*lists):
  return lists[random.randint(0, len(lists) - 1)] \
    [random.randint(0, len(lists[0]) - 1)]
</code></pre>
<p><strong>Explanation</strong></p>
<p>This chooses a list randomly from the list of lists:</p>
<pre><code>lists[random.randint(0, len(lists) - 1)]
</code></pre>
<p>This chooses an item randomly from the randomly chosen list:</p>
<pre><code>[random.randint(0, len(lists[0]) - 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the equal probability needs to be between all names combined :</p>
<pre><code>random.choice(old_people + young_people + mid_age)
</code></pre>
<p>The thing to be aware of here is that if one list has more strings, that 'list' has higher probability of being selected.</p>
<p>If the probability needs to be such that the 3 lists should have equal probability to be picked and within that list, each string has equal probability, then it changes to something like :</p>
<pre><code>pick1 = random.choice(old_people)
pick2 = random.choice(young_people)
pick3 = random.choice(mid_age)
foo = [pick1 ,pick2,pick3]
random.choice(foo)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can go with Psidom's suggestion (unless the lists are very big or this is in a tight loop) or shashank's one - depending on your definition of "equal probability":</p>
<pre><code>random.choice(old_people + young_people + mid_age)

#or

random.choice([random.choice(_) for _ in 
              (old_people + young_people + mid_age)])
</code></pre>
<p>The first will create a new list concatenating the 3 lists, pass it as an argument to <code>random.choice</code> and discard it, while the second will pick a random element form each list and then pick again one of the choices (if your definition of "equal probability" fits this one you can stop here.</p>
<p>If the lists are small but you are calling <code>random.choice</code> inside a loop that will repeat a million times, you better store the concatenated lists in a variable:</p>
<pre><code>choices = old_people + young_people + mid_age

while True:
    choice = random.choice(choices)
    do_something_with(choice)
</code></pre>
<p>If the lists are really big, you may want to avoid the creation of a new big-big-big list in memory using something like this (untested):</p>
<pre><code>def choice(*lists):
    lens = [len(_) for _ in lists]
    choice = random.randint(0, sum(lens) - 1)
    i = 0
    for j, size in enumerate(lens):
        i += size
        if choice &lt; i:
           if j:
               return lists[j][choice - i]
           return lists[j][choice]

choice(old_people, young_people, mid_age)    
</code></pre>
<p>[edit]</p>
<p>If you are lucky enough to be using Python 3.6 or newer, you do as suggested by DSM:</p>
<pre><code>choices = old_people, young_people, mid_age
choice = random.choice(random.choices(
    choices, 
    weights=[len(_) for _ in choices]
)[0])
</code></pre>
</div>
<span class="comment-copy"><code>random.choice(old_people + young_people + mid_age)</code>?</span>
<span class="comment-copy">If the lists are small that is fine (@Psidom)</span>
<span class="comment-copy"><code>random.choice([random.choice(x) for x in (old_people , young_people , mid_age)])</code></span>
<span class="comment-copy">@Psidom that works perfectly for me. Is there a limit to how big the lists can be before that starts to cause issues as Paulo seems to suggest?</span>
<span class="comment-copy">@BrettJouwstra on my machine, this takes 1.25 seconds of real time: <code>list(range(10000000)); b =  list(range(10000000)); c = a + b</code></span>
<span class="comment-copy">What's that nice "In" and "out" I see in your code snippets?</span>
