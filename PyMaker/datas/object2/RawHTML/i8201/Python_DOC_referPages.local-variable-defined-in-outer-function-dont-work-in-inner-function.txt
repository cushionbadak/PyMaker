<div class="post-text" itemprop="text">
<p>I define a variable in a function, and I want to use this variable in inner function defined in the outer function. However, there is an error: this variable referenced before assignment. I don't know why.</p>
<pre><code>class Solution(object):
    def findItinerary(self, tickets):
        """
        :type tickets: List[List[str]]
        :rtype: List[str]
        """
        length = len(tickets)
        visit = [1 for i in range(length)]
        tmp = []
        result = []

        def dfs(tickets, ticket):
            if len(tmp) == length:
                tmp.append(ticket[1])
                if len(result) == 0 or (result != [] and result[1:] &gt; tmp[1:]):
                   result = tmp
                tmp.pop()
                return
            for i in range(length):
                if visit[i] == 1 and ticket[1] == tickets[i][0]:
                    tmp.append(ticket[1])
                    visit[i] = 0
                    dfs(tickets, tickets[i])
                    visit[i] = 1
                    tmp.pop()

        for count in range(length):
            if tickets[count][0] == "JFK":
                visit[count] = 0
                tmp.append(tickets[count][0])
                dfs(tickets, tickets[count])
                tmp.pop()
                visit[count] = 1
        return result
</code></pre>
<p>"result" is the variable. And error is like this:</p>
<pre><code>UnboundLocalError: local variable 'result' referenced before assignment
</code></pre>
<p>if I replace</p>
<pre><code>result = tmp
</code></pre>
<p>with</p>
<pre><code>del result[:]
result.extend(tmp)
</code></pre>
<p>Then it works. And I am so confused about this.</p>
</div>
<div class="post-text" itemprop="text">
<p>By setting <code>result</code> you are telling python that it is a local variable, which will be defined in the inner-most scope. If you are using python3, you can use <code>nonlocal</code> for using the same variable as the outer scope. In python2 this variable is essential "read-only" and you can't assign to it within the inner scope.</p>
<p><a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow noreferrer">From the documentation</a>:</p>
<blockquote>
<p>A special quirk of Python is that – if no global statement is in effect – assignments to names always go into the innermost scope. Assignments do not copy data — they just bind names to objects. The same is true for deletions: the statement del x removes the binding of x from the namespace referenced by the local scope. In fact, all operations that introduce new names use the local scope: in particular, import statements and function definitions bind the module or function name in the local scope.</p>
<p>The global statement can be used to indicate that particular variables live in the global scope and should be rebound there; the nonlocal statement indicates that particular variables live in an enclosing scope and should be rebound there.</p>
</blockquote>
</div>
<span class="comment-copy">Note that assignment makes <code>result</code> a local variable. Your change removes the assignment which makes <code>result</code> a global variable (in <code>dfs</code>).</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/37473666/variable-scope-in-python-nested-function" title="variable scope in python nested function">stackoverflow.com/questions/37473666/…</a></span>
<span class="comment-copy">What skyking said. A cleaner way to fix this is to use a slice assignment to copy the contents of <code>tmp</code> to the <code>result</code> list: <code>result[:] = tmp</code>. This works because it just mutates the existing <code>result</code> list object, it's not assigning a new <code>tmp</code> list to the old <code>result</code> name.</span>
