<div class="post-text" itemprop="text">
<p>I am wondering when a blocking get with no timeout on a python3 queue can return None.</p>
<p>The python3 <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">queue documentation</a> states: </p>
<blockquote>
<p><strong>Queue.get(block=True, timeout=None)</strong></p>
<p>Remove and return an item from the queue. If optional args block is true and timeout is None (the default), block if necessary until an item is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. Otherwise (block is false), return an item if one is immediately available, else raise the Empty exception (timeout is ignored in that case).</p>
</blockquote>
<p>For me this means that a get() with no arguments will wait on an element being in the queue and return only then, therefore always will return a value that is not None. Still in the example at the bottom of the <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">queue documentation</a> the following code is given:</p>
<pre><code>while True:
    item = q.get()
    if item is None:
        break
    ...
</code></pre>
<p>The explicit checking against the item being None implies that None can be returned. In which situations can this happen?</p>
</div>
<div class="post-text" itemprop="text">
<p>Frequently, ending threads properly in a clean way is a non-trivial problem in multi-threaded programs.</p>
<p>When the main communication channel between your threads is a queue, which the consuming thread will usually block on while calling <code>get()</code>, a good technique is using a value that cannot normally occur as data to signal that no more data is going to be enqueued and that the consumer thread is supposed to exit.</p>
<p>Producer thread:</p>
<pre><code>with open('/run/myapp/datapipe', 'r') as f:
    for line in f:
        queue.put(line)

# signal end of communication with a sentinel value of None
queue.put(None)

# further clean up
</code></pre>
<p>Consumer thread:</p>
<pre><code>while True:
    line = queue.get()
    if line is None:
        # if sentinel value was found, break and clean up
        queue.task_done()
        break

    # process line here
    queue.task_done()

# clean up
</code></pre>
<p>In case <code>None</code> can occur as part of the normal data stream, you could also come up with another suitable value as end of communication marker.</p>
<p>Also, if you have multiple consumer threads, this simple end marker enqueuing technique won't suffice, as only one of the threads will dequeue the marker. In that case, you could make each consumer thread <code>put()</code> the marker back into the queue once it fetched it, thereby handing the end marker through each consumer thread one-by-one.</p>
</div>
<span class="comment-copy">It's because they <code>put()</code> a <code>None</code> into the queue explicitly as an end marker (which, by the way, is a good technique to signal to the partner thread that no more communication will happen on the queue).</span>
<span class="comment-copy">Oh, thanks. Should have looked at the example more carefully...</span>
