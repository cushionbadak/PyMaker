<div class="post-text" itemprop="text">
<p>I'm writing a rudimentary mocking framework just so I can test some calls to peewee.  </p>
<p>I know in peewee, you can make <code>where()</code> calls like<br/>
<code>model.select().where(model.id == target_id). ...</code> </p>
<p>In order to detect which fields of the model are being compared, I will be overriding the comparison operators of the field.  Then I would inject that model in place of a peewee model.  It would provide the same interface as the peewee model(only as much as needed, though) but instead of accessing a database, it would record comparisons and calls; but it would all depend on the arguments being evaluated <em>before</em> the method is called.  </p>
<p>I've run an example using anaconda, and for whatever python comes with Linux Mint, and they seem to operate as I would like.  I'm not sure if it's a fluke of runtime, or maybe python really does evaluate comparisons just before they are needed.  </p>
<p>So, regarding the following, can I rely on <code>model.id == target_id, ...</code> running the comparison before the first <code>where()</code> is called?  Can I rely on <code>model.name == target_name</code> running its comparison before the second <code>where()</code> is called and after the first <code>where()</code>?  </p>
<pre><code>mockModel.select()
         .where(model.id == target_id, model.number == target_number)
         .where(model.name == target_name)
         ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Method parameters are resolved as they are being marshalled for the call. Since the second <code>where</code> hasn't been looked up when the first <code>where</code> is called, its parameters have not yet been resolved. The sequence for this statement</p>
<pre><code>mockModel.select()\
         .where(model.id == target_id, model.number == target_number)\
         .where(model.name == target_name)
</code></pre>
<p>is </p>
<ul>
<li>lookup <code>mockModel</code></li>
<li>lookup <code>select</code> on that object</li>
<li>it has no parameters, so call it and get its result object</li>
<li>lookup <code>where</code> on the result object</li>
<li>its a function so evaluate its parameters left to right</li>
<li>call the function and get its result object</li>
<li>lookup <code>where</code> on the result object</li>
<li>its a function call, so evaluate its parameters left to right</li>
<li>call the function</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Yes. From the <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>The primary must evaluate to a callable object (user-defined functions, built-in functions, methods of built-in objects, class objects, methods of class instances, and all objects having a <code>__call__()</code> method are callable). <strong>All argument expressions are evaluated before the call is attempted.</strong></p>
</blockquote>
</div>
<span class="comment-copy">Expressions in parameters are fully executed into a result object and that object is passed to the function. so, yes,they have to be fully resolved before the call.</span>
<span class="comment-copy">Ok, cool; but how early is that resolve?  Before the containing line?  Before the first call in a method chain?  Are all the expressions evaluated in method chain before any of the methods are called?</span>
<span class="comment-copy">So, to be certain, and in terms of the example, <code>model.name == target_name</code> will run <code>__eq__(self, other)</code>, <i>after</i> the first <code>where()</code>, but <i>before</i> the second <code>where()</code>?</span>
<span class="comment-copy">@D.Joe: Yup, that's right.</span>
