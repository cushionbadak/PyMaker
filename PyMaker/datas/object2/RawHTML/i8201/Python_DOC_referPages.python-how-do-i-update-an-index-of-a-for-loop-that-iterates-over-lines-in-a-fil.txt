<div class="post-text" itemprop="text">
<p>Using a for loop, I'm iterating over the lines in a file. Given this line: </p>
<pre><code>line= [ â€˜641', '"Tornadus', ' (Incarnate Form)"', '"Flying"', '""', '5', '"TRUE"']
</code></pre>
<p>I need to reformat index [6] from '"TRUE"' to the boolean True. </p>
<p>Full expected output: d={'Tornadus, (Incarnate Form)': (641, 'Flying', None, 5, True}</p>
<p>I used:</p>
<pre><code>if "T" in line[6]:  # format legendary if TRUE
    line[6] = True
</code></pre>
<p>But I get this error:</p>
<blockquote>
<p>Traceback (most recent call last):
  File "tester5p.py", line 305, in test_read_info_file_05
  self.assertEqual(read_info_file(DATAFILE),info_db5())File "/Users/kgreenwo/Desktop/student.py", line 52, in read_info_file
      line[5] = False</p>
<p>TypeError: 'str' object does not support item assignment</p>
</blockquote>
<p>How can I assign it WITHIN the for loop? </p>
<p>To see my full code:</p>
<pre><code>def read_info_file(filename):
    f = open(filename, 'r')  # open file in read mode
    d = {}  # intitialze as empty
    count = 0  # helps to skip first line
    key = ""
    for line in f:  # get each line from file
        if count != 0:  # skip first line
        # 1___________________________________________open file,read, skip 1st line
            id_num = int(line[0])  # make id an integer
        # 2________________________________________________
            if ',' in line[1]:  # two parts to fullname, changes indexes
                part1 = line[1].strip('"')  # get format first part of name
                part2 = line[2].strip()  # get format second part of name
            # 3______________
                fullname = part1 + part2
                key = fullname
            # 4______________
                type1 = line[3].strip('"')
            # 5--------------
                if line[4] == "":  # check if there is not a second type
                    type2 = None  # correct format
                else:  # is a second type
                    type2 = line[4].strip('"')  # format second type
            # 6______________

                generation = line[5]  # format generation
            # 7_____________
                if "T" in line[6]:  # format legendary if TRUE
                    line[6] = True
                    legendary = line[6]
                else:  # format legendary if FALSE
                    line[6] = False
                    legendary = line[6]

            # 8______________________________________________one part to name
            else:  # one part to name
                fullname = line[1].strip('"')
            # 9______________
                type1 = line[2].strip('"')
            # 10_____________
                if line[3] == "":  # if no second type
                    type2 = None
                else:
                    type2 = line[3].strip('"')  # there is a second type
            # 11_____________
                generation = line[4]  # format generation
            # 12_____________
                if "T" in line[5]:  # format legendary if TRUE
                    line[5] = True
                    legendary = line[5]
                else:  # formmat Legendary if False
                    line[5] = False
                    legendary = line[5]

            value = (id_num, type1, type2, generation, legendary)
            d.update([(key, value)])
        count += 1
    return d
</code></pre>
<blockquote>
<p>Reproducible example:
  input: (don't forget to skip first line!)</p>
</blockquote>
<pre><code>info_file1 = '''"ID","Name","Type 1","Type 2","Generation","Legendary"
1,"Bulbasaur","Grass","Poison",1,"FALSE"
</code></pre>
<blockquote>
<p>Output:
          d={'Bulbasaur':(1,'Grass','Poison',1,False)}</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>It is quite unclear from your example, but my thoughts go to:</p>
<pre><code>for line in f:
    line = line.split(',')
</code></pre>
<p>Now you can mess with indexes and see whether you have more errors.
And if you use:</p>
<pre><code>if "T" in line[6]:  # format legendary if TRUE
    line[6] = True
</code></pre>
<p>It will work.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your input file looks like a <a href="https://en.wikipedia.org/wiki/Comma-separated_values" rel="nofollow noreferrer">comma-separated values</a> file. If it is, what you want is pretty easy.</p>
<p>Let's suppose your input file is literally this:</p>
<p><strong>Input_file-43644346.txt</strong></p>
<pre><code>info_file1 = '''"ID","Name","Type 1","Type 2","Generation","Legendary"
1,"Bulbasaur","Grass","Poison",1,"FALSE"
641,"Tornadus', ' (Incarnate Form)","Flying",,5,"TRUE"
</code></pre>
<p>You could do something like that:</p>
<pre><code>#!/usr/bin/env python3

import csv

input_file_name = "Input_file-43644346.txt"

with open(input_file_name, newline='') as input_file:
    next(input_file)        # skip first line
    record_extractor = csv.reader(input_file)
    d = {}
    for row in record_extractor:
        key = row[1].strip()
        row_truth = row[5] == "TRUE"        # simplifying the boolean retrieving
        # Using conditional expressions
        row_second_type = row[3].strip() if row[3] else None   
        output_row = (row[0], row[2], row_second_type, row[4], row_truth)
        d[key] = output_row

print("d=", d)
</code></pre>
<p>Here are some key points of this solution:</p>
<ul>
<li>This example is in Python 3's syntax</li>
<li>Using <code>with</code> makes sure that the input file is closed timely</li>
<li>Since a file object is also an iterator, you can skip the first line by using <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next()</code></a>.</li>
<li><a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow noreferrer"><code>csv.reader()</code></a>  will give you a tuple containing the information from a row. It will process quoted string like you would expect.</li>
<li>The expression <code>row[5] == "TRUE"</code> will yield a boolean expression. You don't need to use an <code>if</code> statement.</li>
<li>An empty string is equivalent to False. Any other string is True.</li>
<li><a href="https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator" rel="nofollow noreferrer">Conditional expressions</a> can be used to change an empty string to <code>None</code> like you wanted.</li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow noreferrer"><code>dict.update()</code></a> is useful if you already have a dictionary or a list of tuples you want to use its values to update an dictionary but you are better off using <code>d[key] = value</code></li>
</ul>
<hr/>
<p>But my guess is that your file is more like that:</p>
<p><strong>Input_file-43644346b.txt</strong></p>
<pre><code>"ID","Name","Type 1","Type 2","Generation","Legendary"
1,"Bulbasaur","Grass","Poison",1,"FALSE"
641,"Tornadus', ' (Incarnate Form)","Flying",,5,"TRUE"
</code></pre>
<p>You can then use <a href="https://docs.python.org/3/library/csv.html#csv.DictReader" rel="nofollow noreferrer"><code>csv.DictReader</code></a> to read your data:</p>
<pre><code>#!/usr/bin/env python3

import csv

input_file_name = "Input_file-43644346b.txt"

with open(input_file_name, newline='') as input_file:
    record_extractor = csv.DictReader(input_file)
    d = {}
    for row in record_extractor:
        key = row["Name"].strip()
        row_truth = row["Legendary"] == "TRUE"
        row_second_type = row["Type 2"].strip() if row["Type 2"] else None
        output_row = (row["ID"], row["Type 1"],
                      row_second_type, row["Generation"], row_truth)
        d[key] = output_row

print("d=", d)
</code></pre>
<p>That enables you to use "column" names to identify different parts of each row</p>
<hr/>
<p>You can simplify even more your code by using a <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">dictionary</a> comprehension:</p>
<pre><code>#!/usr/bin/env python3

import csv

input_file_name = "Input_file-43644346.txt"

with open(input_file_name, newline='') as input_file:
    next(input_file)        # skip first line
    record_extractor = csv.reader(input_file)
    d = { row[1]: (row[0],
                   row[2],
                   row[3].strip() if row[3] else None,
                   row[4],
                   row[5] == "TRUE")
          for row in record_extractor }

print("d=", d)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of reassigning it, I just did this and it worked:</p>
<pre><code>if "T" in line[6]:  # format legendary if TRUE
    legendary = True
else:  # format legendary if FALSE
    legendary = False
</code></pre>
</div>
<span class="comment-copy">You need to provide a <i>reproducible example</i>. Your example of <code>line</code> is not valid Python, and it seems you mean to make it a list, in which case, it would not throw that error.</span>
<span class="comment-copy">I don't know if it's because you typed it in or not, but the first quote mark " ' " is a different symbol.  When I copy your above code into the python interpreter, it says everything after "641'" is a string.</span>
<span class="comment-copy">I added my full code so that you can see what I'm doing. It is commented for clarification. The list of the line is created when I used read(). Everything in that list becomes a string. I have to convert the necessary elements to the output that I need.</span>
<span class="comment-copy">Yeah, the problem is that <code>line</code> is a <code>str</code>, since it is iterating over a file-handler. Indexing into a string gives the <i>character</i> at that position, e.g.<code>"hello"[1] == 'e'</code>. You can't assign to a string. I think you want to split your line on commas... And you have <i>yet to provide a reproducible example</i>.</span>
<span class="comment-copy">Right, as I suspected, you are working with some value-delimited file, i.e. a csv, but when you iterate over that file, line by line, <code>line</code> is a <b>string</b>. When you index into a string you index into the characters, and you can't assign to a string. You are assuming that <code>line</code> is a list of strings based on the delimiter in your file...</span>
<span class="comment-copy">Even using your method returns : ['641', '"Tornadus', ' (Incarnate Form)"', '"Flying"', '""', '5', '"TRUE"']</span>
<span class="comment-copy">Please look at the edit.</span>
