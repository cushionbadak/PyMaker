<div class="post-text" itemprop="text">
<p>I need to append the values from one dictionary (N) to another (M)  -   pseudocode below</p>
<pre><code>if[x] in M:
  M[x]=M[x]+N[x]
else:
  M[x]=N[x] 
</code></pre>
<p>Doing this for every key in N seems quite untidy coding.<br/>
What would be the most efficient way to achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Of course you should be iterating your keys in "x" already - but a single line solution is:</p>
<pre><code>M.update({key:((M[key] + value) if key in M else value) for key, value in N.items()})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>not entirely sure what your <code>x</code> is (guessing the keys of both <code>M</code> and <code>N</code>), then this might work:</p>
<pre><code>M = {key: M.get(key, 0) + N.get(key, 0) for key in set((*M, *N))}
</code></pre>
<p>for the example:</p>
<pre><code>M = {'a': 1, 'c': 3, 'e': 5}
N = {'a': 2, 'b': 4, 'c': 6, 'd': 8}
</code></pre>
<p>you get:</p>
<pre><code>print(M)  # {'a': 3, 'e': 5, 'd': 8, 'c': 9, 'b': 4}
</code></pre>
<p>or please clarify what the desired output for the given example would be.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you say "append", I assume that means that the values in your dicts are lists. However the techniques below can easily be adapted if they're simple objects like integers or strings.</p>
<p>Python doesn't provide any built-in methods for handling dicts of lists, and the <em>most</em> efficient way to do this depends on the data, because some ways work best when there are a high proportion of shared keys, other ways are better when there aren't many shared keys.</p>
<p>If the proportion of shared keys isn't too high, this code is reasonably efficient:</p>
<pre><code>m = {1:[1, 2], 2:[3]}
n = {1:[4], 3:[5]}

for k, v in n.items():
    m.setdefault(k, []).extend(v)

print(m)
</code></pre>
<p><strong>output</strong></p>
<pre><code>{1: [1, 2, 4], 2: [3], 3: [5]}
</code></pre>
<p>You can make this slightly faster by caching the <code>.setdefault</code> method and the empty list:</p>
<pre><code>def merge(m, n):
    setdef = m.setdefault
    empty = []
    for k, v in n.items():
        setdef(k, empty).extend(v)
</code></pre>
<p>If you expect a high proportion of shared keys, then it's better to perform set operations on the keys (in Python 3, dict.keys() return a set-like View object, which is extremely efficient to construct), and handle the shared keys separately from the unique keys of N.</p>
</div>
<span class="comment-copy">@hiroprotagonist update will overwrite, i don't think Op want to overwrite.</span>
<span class="comment-copy">@Hackaholic oops you are right... i should read more than the title... will delete.</span>
<span class="comment-copy">Checkout <code>defaultdict</code> <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">I fail to see how "defaultdict" could simplify anything here. Can you be more explicit?  That is because defaultdict won't allow you to provide a custom expression for value if the key already exists in the dictionary.</span>
<span class="comment-copy">FWIW, this is similar to <a href="http://stackoverflow.com/a/1495821/4014959">Alex's solution</a>, which is a bit outdated (so no longer a good dupe target).</span>
<span class="comment-copy">@PM2Ring: thanks, did not know that post. yes, my solution works with <code>int</code> only; @jsbueno 's works with anything that has an <code>__add__</code> method; the dict could even have mixed values.</span>
<span class="comment-copy">ha! i was trying to use <code>setdefault</code> and failed. came up with a solution using <code>get</code>. but this is nice! +1</span>
<span class="comment-copy">@hiroprotagonist Thanks! I've recently fallen in love with <code>setdefault</code>. :) Why <code>defaultdict</code> when you can <code>setdefault</code>?</span>
<span class="comment-copy">@hiroprotagonist I just realised that the OP didn't actually say their dict values are lists. Oops! :) I guess I can add to my answer if it turns out that I guessed incorrectly...</span>
