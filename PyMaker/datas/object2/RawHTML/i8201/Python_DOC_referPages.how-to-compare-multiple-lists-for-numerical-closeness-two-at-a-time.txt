<div class="post-text" itemprop="text">
<p>Say I have 4 lists:</p>
<pre><code>A = [1.1, 1.4, 2.1, 2.4]
B = [1.3, 6.5, -1.0, 2.3]
C = [0.5, -1.0, -1.1, 2.0]
D = [1.5, 6.3, 2.2, 3.0]
</code></pre>
<p>How do I 1)compare the lists eg A,B  B,C  C,D  A,C so on and 2)return true if the elements are +/-0.2 ?</p>
<pre><code>Example output: (Or any other way to represent the data)
A,B [true, false, false, true]
B,C [false, false, true, false]
</code></pre>
<p>My thoughts are to append the lists have a for loop to iterate through all.</p>
<pre><code>A.append(B)
A.append(C)
.
.
</code></pre>
<p>But then I'm stuck since if I do </p>
<pre><code>for x in A:
    for y in A[x]:
        if A[x][y] - A[x+1][y] &lt;= 0.2
            if A[x+1][y] - A[x][y] &lt;= 0.2
</code></pre>
<p>Obviously it doesn't work.
Are there ways to iterate through the lists without duplicates and compare at the same time?</p>
<p>Thanks in advance</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Update:</strong></p>
<p>OK, now I think I understand both questions you're asking:</p>
<pre><code>from itertools import combinations

A = [1.1, 1.4, 2.1, 2.4]
B = [1.3, 6.5, -1.0, 2.3]
C = [0.5, -1.0, -1.1, 2.0]
D = [1.5, 6.3, 2.2, 3.0]
lists = {'A': A, 'B': B, 'C': C, 'D': D}
tol = 0.2

def compare_lists(a, b, tol):
    return [abs(elem1-elem2) &lt;= tol for elem1, elem2 in zip(a, b)]  # Might want '&lt;' instead

for name1, name2 in combinations(lists.keys(), 2):
    a, b = lists[name1], lists[name2]
    print('{}, {} {}'.format(name1, name2, compare_lists(a, b, tol)))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>A, B [True, False, False, True]
A, C [False, False, False, False]
A, D [False, False, True, False]
B, C [False, False, True, False]
B, D [True, False, False, False]
C, D [False, False, False, False]
</code></pre>
<p><strong>Update 2:</strong></p>
<p>To answer your follow up question, if the lists are actually members of a list-of-lists, you could similarly do something like this:</p>
<pre><code># An alternative for when the lists are nested inside another list

from itertools import combinations

lists = [
    [1.1, 1.4, 2.1, 2.4],
    [1.3, 6.5, -1.0, 2.3],
    [0.5, -1.0, -1.1, 2.0],
    [1.5, 6.3, 2.2, 3.0]
]
tol = 0.2

def compare_lists(a, b, tol):  # unchanged
    return [abs(elem1-elem2) &lt;= tol for elem1, elem2 in zip(a, b)]  # Might want '&lt;' instead

for i, j in combinations(range(len(lists)), 2):  # all combinations of pairs of indices
    a, b = lists[i], lists[j]
    print('{}[{}], [{}] {}'.format('lists', i, j, compare_lists(a, b, tol)))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>lists[0], [1] [True, False, False, True]
lists[0], [2] [False, False, False, False]
lists[0], [3] [False, False, True, False]
lists[1], [2] [False, False, True, False]
lists[1], [3] [True, False, False, False]
lists[2], [3] [False, False, False, False]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You want <a href="https://docs.python.org/3/library/itertools.html?highlight=pairwise#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a></p>
<pre><code>from itertools import combinations

lists = [A, B, C, D]

for first, second in combinations(lists, 2):
    # (first, second) will be (A, B), then (A, C), then (A, D), then
    # (B, C), then (B, D), then (C, D)
</code></pre>
<p>Then you can compare with:</p>
<pre><code>EPSILON = 0.2

for first, second in combinations(lists, 2):
    for a, b in zip(first, second):
        if abs(a-b) &lt; EPSILON:
            print(True)  # or add it to a list, or etc.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a simple way with just <code>zip</code>:</p>
<pre><code>A = [1.1, 1.4, 2.1, 2.4]
B = [1.3, 6.5, -1.0, 2.3]
C = [0.5, -1.0, -1.1, 2.0]
D = [1.5, 6.3, 2.2, 3.0]

second_list = [A, B, C, D]

statements = [[round(abs(c-b), 1) == 0.2 or round(abs(c-b), 1) == 0.1
                for c, b in zip(second_list[i], second_list[i+1])]
                    for i in range(len(second_list)) if i+1 &lt; len(second_list)]

print statements
</code></pre>
</div>
<span class="comment-copy">I am not a big supporter of combinning 2 questions in a single stackoverflow question.</span>
<span class="comment-copy">It looks like require the output format to contain the names of the lists, which is slightly annoying and requires indexing into a list-of-lists and possibly overloading their <code>str()</code> method to get their name.</span>
<span class="comment-copy">thanks for answering! But just as a follow up question are there any ways to do it without having to make a dictionary literal?</span>
<span class="comment-copy">@Steve.C: You're welcome. There may very well be ways—but I need more information. Where are the dictionaries &amp; how (or what) are they named? If they're in a container of some sort, where is it and how would you like their names displayed in that case?</span>
<span class="comment-copy">The lists ABCD are actually a list of lists (say data = [[1.1,....],[1.3,....]]) being generated from a for-loop, and there won't always be 4 lists. Therefore I am not exactly sure how to parse the data to compare_lists and output results using lists={}.</span>
<span class="comment-copy">@Steve. C: Doesn't seem too difficult—see Update 2.</span>
<span class="comment-copy">Not quite, how do you get their name for the required output <code>A,B [true, false...</code>? I guess you'd need to have an overloaded list object whose <code>str()</code> returns its name.</span>
<span class="comment-copy">@smci you don't. You could do some Deep Magic with <code>globals()</code> but as always when it comes to getting identifier names, you should never need to do that.</span>
<span class="comment-copy">The question requires it: output <code>A,B [true, false...</code></span>
<span class="comment-copy">@smci You must not have read the question too closely. "Example output: (Or any other way to represent the data)" the parenthetical is fine for me to handwave away the "A,B" part. martineau produced a solution that builds a new dict to store names. That'd be the way to go if that became necessary.</span>
<span class="comment-copy">@smci sounds good. If you're trying to implement the approach you outlined in your first comment, though, I'd be wary. <a href="https://stackoverflow.com/questions/2553354/how-to-get-a-variable-name-as-a-string-in-python">Variable names aren't that useful in Python</a></span>
<span class="comment-copy">Doesn't look that simple to me...even when better formatted. I also don't think the OP was looking for specific difference values.</span>
