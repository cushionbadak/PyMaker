<div class="post-text" itemprop="text">
<p>I want to compare a list of tuples, if the first elements are the same then compare the second elements and return the highest.</p>
<pre><code>lis = [(1,10, "n"), (1,15,"n1"), (2,20,"n"),(2,35,"n1"),(3,123,"n"),(3,12,"n1")]
</code></pre>
<p>return:</p>
<pre><code>lis = [(1,15,"n1"), (2,35,"n1"), (3,123,"n")]
</code></pre>
<p>I'm not sure how to go about this, any help would be appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<p>I'd use <code>itertools.groupby</code> to first group all items with the same first element together, then <code>max</code> to find the items with the max second element.</p>
<p>Unlike some other answers you may have varying number of elements from different "groups".</p>
<pre><code>from itertools import groupby
from operator import itemgetter

lis = [(1,10, "n"), (1,15,"n1"), (2,20,"n"), (2,35,"n1"), (3,123,"n"),(3,12,"n1")]

lis.sort(key=itemgetter(0))  # groupby requires the iterable to be sorted,
                             # so making sure it is

grouped_by = groupby(lis, key=itemgetter(0))

output = [max(li, key=itemgetter(1)) for group, li in grouped_by]
print(output)

# [(1, 15, 'n1'), (2, 35, 'n1'), (3, 123, 'n')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Tuple comparisons do that already, comparing first elements then second and continuing until a tie-breaker is found.</p>
<p>All you need to do is <code>zip</code> the list in such a way to create the correct comparisons:</p>
<pre><code>zip(lis[::2], lis[1::2])
# This produces:
# (1, 10, 'n') (1, 15, 'n1')
# (2, 20, 'n') (2, 35, 'n1')
# (3, 123, 'n') (3, 12, 'n1')
</code></pre>
<p>Creates the pairs you need, you can then compare them inside a list-comprehension to get the wanted results:</p>
<pre><code>r = [i if i &gt; j else j for i,j in zip(lis[::2], lis[1::2])]
print(r)
# [(1, 15, 'n1'), (2, 35, 'n1'), (3, 123, 'n')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The solution using <a href="https://docs.python.org/3/library/functions.html#func-range" rel="nofollow noreferrer">range()</a> and <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow noreferrer">max()</a> functions:</p>
<pre><code>lis = [(1,10, "n"), (1,15,"n1"), (2,20,"n"),(2,35,"n1"),(3,123,"n"),(3,12,"n1")]
result = [max(lis[i:i+2]) for i in range(0, len(lis), 2)]

print(result)
</code></pre>
<p>The output:</p>
<pre><code>[(1, 15, 'n1'), (2, 35, 'n1'), (3, 123, 'n')]
</code></pre>
</div>
<span class="comment-copy">This will only work if the list contains 2 elements of each "type".</span>
<span class="comment-copy">Judging from the sample and lack of an explicit remark stating otherwise, I was pretty sure that's the only case @DeepSpace. If required, <code>zip_longest</code> with a <code>fillvalue</code> of <code>()</code> can be used.</span>
<span class="comment-copy"><code>result = [[j,i][i&gt;j] for i,j in zip(lis[::2],lis[1::2])]</code> is somehow more "pythonic" isn't it?</span>
<span class="comment-copy">@Claudio I wouldn't say so. That clearly is less readable than the solutions here. Search around and you'll see a number of questions from other people regarding the indexing trick you're employing and how it trips them up :-)</span>
<span class="comment-copy">This will only work if the list contains 2 elements of each "type".</span>
<span class="comment-copy">@DeepSpace what do you mean by this ?</span>
<span class="comment-copy">@qwertyayyy you'd get wrong output if for example <code>lis = [(1,10, "n"), (1,15,"n1"), (1,20,"n1"), (2,20,"n"),(2,35,"n1"),(3,123,"n"),(3,12,"n1")]</code></span>
<span class="comment-copy">@DeepSpace thank you for that. That is exactly what I want the code to do.</span>
