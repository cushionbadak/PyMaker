<div class="post-text" itemprop="text">
<p>Is there any obstacle that prevents <a href="https://docs.python.org/3/library/weakref.html" rel="nofollow noreferrer"><code>weakref</code></a> from doing everything that <code>__del__</code> does but with much stronger guarantees (e.g., <code>finalize</code> guarantees that the call will be made before the interpreter exits, and the order of calls is well-defined, etc.)?</p>
<p>It seems that in the distant past <a href="https://mail.python.org/pipermail/python-list/2005-January/332310.html" rel="nofollow noreferrer">it was thought</a> that <code>weakref</code> would eventually lead to the removal of <code>__del__</code> from the language.</p>
<p>What prevented this from happening?</p>
<p>There seems to be <a href="https://stackoverflow.com/questions/43666794/use-cases-for-del">few use cases for <code>__del__</code></a>, and all the ones I'm aware of seem to work at least as well (and usually much better) with <code>weakref</code> callbacks or <code>weakref.finalize</code>.</p>
<p>Update:</p>
<p>With <a href="https://www.python.org/dev/peps/pep-0442/" rel="nofollow noreferrer">PEP 442</a> dramatically improving the behavior of <code>__del__</code>, and the concerns with <code>weakref</code> mentioned by @gz and @user2357112, I'm wondering if the language is generally moving towards making <code>__del__</code> more reliable, or towards using <code>weakref</code> instead of <code>__del__</code>, or both.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's a somewhat pragmatic reason <code>__del__</code> is still around. Several signficant <code>weakref</code> improvements, including <code>finalize</code>, were <a href="https://docs.python.org/3.4/whatsnew/3.4.html#weakref" rel="nofollow noreferrer">new in Python 3.4</a>. So, replacing <code>__del__</code> with better weakrefs missed the window for language breaking changes with py3k.</p>
<p>I think most uses <em>can</em> be replaced by the base weakref functionality, but I'm struck by this observation from Richard Oudkerk in <a href="https://bugs.python.org/issue15528" rel="nofollow noreferrer">issue 15528</a> where proposed and implemented <code>finalize</code>:</p>
<blockquote>
<p>[Weakref callbacks] are low level, and working out how to use them correctly requires a bit of head scratching.  One must find somewhere to store the weakref till after the referent is dead, and without accidentally keeping the referent alive.  Then one must ensure that the callback frees the weakref (without leaving any remnant ref-cycles).</p>
<p>When it is an option, using a <code>__del__</code> method is far less hassle.</p>
</blockquote>
<p>Anyway, perhaps the question should be brought up again when Python 4 is being considered? ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>Answer to the question is really <em>depends on the use case</em> and would also suggest you consider that different Python interpreter implementations do not have the same GC behaviour as CPython.</p>
<p>PyPy in particular does <em>not</em> call <code>__del__</code> as-soon-as an object is <code>del</code>-eleted or goes out of scope but 'some time later'. So code that relies on CPython's <code>__del__</code> behaviour will break on PyPy, and other alternative interpreters.</p>
<p>What I would recommend is to make use of <code>__enter__</code> and <code>__exit__</code> along with the <code>with</code> keyword. For example</p>
<pre><code>from __future__ import print_function

class MyClass(object):

    def __enter__(self):
        print("Entering")

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Exiting")

# 'with MyClass()' can be used but want to show that
# code in exit is executed regardless of object
# life time
obj = MyClass()
with obj:
    print("Stuff happening in between")
</code></pre>
<p>Result is:</p>
<pre><code>Entering
Stuff happening in between
Exiting
</code></pre>
<p>The above order of statements is guaranteed and does not depend on GC behaviour. </p>
<p>Things that should be done as soon as the code in the <code>with</code> block completes can go in <code>__exit__</code>, such as things that would normally be put in a destructor - clearing file handles, releasing locks and so on.</p>
<p>A subsequent <code>del</code> on the object, or it going out of scope, will clear the object reference eventually, again depending on interpreter implementation, but things that should be done immediately best not rely on that behaviour.</p>
</div>
<span class="comment-copy"><i>"What prevented this from happening?"</i> that's a question that <i>very</i> few might be able to answer. I'd suggest you also post this on <code>python-list</code> to, hopefully, get the attention of some core-devs.</span>
<span class="comment-copy">Python's weakref support is pretty bad, so you can't take weakrefs to lots of object types you'd want to weakref. This usually doesn't matter for types you write yourself, but if your type is something like a <code>tuple</code> subclass, you can't weakref it.</span>
<span class="comment-copy">Also, a weakref callback doesn't have access to the referent, so it needs more careful design.</span>
<span class="comment-copy">@user2357112 For example, according to the docs, weakrefs can't be taken to generators. Does this mean that there's absolutely no way to replace generator <code>__del__</code> with weakrefs at present? Or there's some workaround (like create a separate object linked only from a generator that would serve as the trigger for <code>weakref.finalize</code>)?</span>
