<div class="post-text" itemprop="text">
<p>I want to generate a large number of key value pairs to put in my dictionary using a for loop. For example, the dictionary looks like this:</p>
<pre><code>my_dict = dict()
my_dict["r0"] = "tag 0"
my_dict["r1"] = "tag 1"
my_dict["r2"] = "tag 2"
...
</code></pre>
<p>Note that both the key and value follows a pattern, i.e., the number increase by 1. Now I cannot do this 1M times and would prefer an automatic way to initialize my dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <em>most efficient way</em> to do this is probably with a dict comprehension:</p>
<pre><code>mydict={'r%s'%n : 'tag %s'%n for n in range(10)}
</code></pre>
<p>Which is equivalent to:</p>
<pre><code>mydict=dict()
for n in range(10):
    mydict.update({'r%s'%n:'tag %s'%n})
</code></pre>
<p>... but more efficient. Just change <code>range(10)</code> as necessary.</p>
<hr/>
<p>You could also use <code>.format()</code> formatting instead of percent (C-like) formatting in the dict:</p>
<pre><code>mydict={'r{}'.format(n) : 'tag {}'.format(n) for n in range(10)}
</code></pre>
<hr/>
<p>If you are using Python2 replace all the <code>range()</code> functions with <code>xrange()</code> functions</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>my_dict = dict()
for i in xrange(1000000):
    my_dict["r%s" % i] = "tag %s" % i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>my_dict = dict()
for x in range(1000000):
    key="r"+str(x)
    val="tag " +str(x)
    my_dict[key]=val
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>my_dict = dict()
for i in range(0, 1000000):
    key = "r{}".format(i)
    value = "tag {}".format(i)
    my_dict[key] = value
</code></pre>
<p>EDIT: As pointed out by others, if you are using python 2 use xrange instead since it is lazy (so more efficient). In Python 3 range does the same thing as xrange in python 2</p>
</div>
<div class="post-text" itemprop="text">
<p>simple way is to do the following </p>
<pre><code>#using python format strings
keyf = "r{}"
valf = "tag {}"
#dictionary comprehension
a = {keyf.format(i) : valf.format(i) for i in range(5)}
# can modify range to handle 1,000,000 if you wanted
print(a)
{'r0': 'tag 0', 'r1': 'tag 1', 'r2': 'tag 2', 'r3': 'tag 3', 'r4': 'tag 4', 'r5': 'tag 5'}
</code></pre>
<p>if you wanted to quickly append this to another dictionary you would use the dictionary equivalent of <code>extend</code>, which is called <a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow noreferrer"><code>update</code></a>. </p>
<pre><code>b = dict{"x":1,"y":2}
b.update(a)
print(b)
{'x': 1, 'y': 2, 'r0': 'tag 0', 'r1': 'tag 1', 'r2': 'tag 2', 'r3': 'tag 3', 'r4': 'tag 4'}
</code></pre>
<p>you could also shorten the original comprehension by doing this:</p>
<pre><code>a = {"r{}".format(i) : "tag {}".format(i) for i in range(5)}
</code></pre>
<p>You wouldn't even need to make keyf, or valf</p>
</div>
<div class="post-text" itemprop="text">
<p>Python can build dicts from lists:</p>
<pre><code>$ python2 -c "print dict(map(lambda x: ('r' + str(x), 'tag ' + str(x)), range(10)))"
{'r4': 'tag 4', 'r5': 'tag 5', 'r6': 'tag 6', 'r7': 'tag 7', 'r0': 'tag 0', 'r1': 'tag 1', 'r2': 'tag 2', 'r3': 'tag 3', 'r8': 'tag 8', 'r9': 'tag 9'}
</code></pre>
</div>
<span class="comment-copy">While this code snippet may solve the question, <a href="//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers">including an explanation</a> really helps to improve the quality of your post. Remember that you are answering the question for readers in the future, and those people might not know the reasons for your code suggestion. Please also try not to crowd your code with explanatory comments, this reduces the readability of both the code and the explanations!</span>
<span class="comment-copy">Question asks for 1 Million, not 1 thousand.</span>
<span class="comment-copy">@KeithC, no the question did not explicitly say they needed this a million times, it was a figure of speach, not something to be taken literally...   Regardless you can just change the 1000 to a million and this works...</span>
<span class="comment-copy">changed the answer, same code still applies just with a few more 0s in the range</span>
<span class="comment-copy">You are correct, my apologies</span>
<span class="comment-copy">did this work for you? if so please mark answer as correct</span>
<span class="comment-copy">that is gross, please fix your formatting...</span>
