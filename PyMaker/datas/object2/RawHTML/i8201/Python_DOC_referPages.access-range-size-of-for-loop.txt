<div class="post-text" itemprop="text">
<p>I have a simplified python code looking like the following:</p>
<pre><code>a = 100
x = 0
for i in range(0, a):
    x = x +  i / float(a)
</code></pre>
<p>Is there a way to access the maximum amount of iterations inside a <code>for</code> loop?</p>
<p>Basically the code would change to:</p>
<pre><code>x = 0
for i in range(0, 100):
    x = x + i / float(thisloopsmaxcount)
</code></pre>
<p>where <code>thisloopsmaxcount</code> is some fancy python method.
Another option would be to implement a whole class for this behaviour.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yeah, you can..</p>
<pre><code>a = 100
x = 0
r = range(0,a)

for i in r:
    x = x + i / r.stop
</code></pre>
<p>but if the range isn't counting 1,2,3... then the <code>stop</code> won't be the number of steps, e.g. <code>range(10,12)</code> doesn't have 12 steps it has 2 steps. And <code>range(0,100,10)</code> counts in tens, so it doesn't have 100 steps. So you need to take into account <code>(.stop - .start) / .step</code> as appropriate.</p>
<p>And it only works for range, in general a <code>for</code> loop could be reading from a network, or something based on user input, where the only way to know when the loop stops and how many loops is when it happens to get to the end.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's nothing built-in, but you can easily compute it yourself:</p>
<pre><code>x = 0
myrange = range(0, 100)
thisloopsmaxcount = sum(1 for _ in myrange)
for i in myrange:
    x = x + i / float(thisloopsmaxcount)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In your example, you already know the number of iterations, so why not use that.</p>
<p>But in general, if you want the number of elements in a (Python 3) <code>range()</code>, you can take its <a href="https://docs.python.org/3/library/stdtypes.html#typesseq" rel="nofollow noreferrer"><code>len()</code></a>:</p>
<pre><code>x = 0
rang = range(12,999,123)
for i in rang:
    x = x +  i / float(len(rang))
</code></pre>
<p>You still need the temporary variable since it's not the loop itself that knows the length, but the <code>range</code> object. <code>len()</code> also works on Python 2's <a href="https://docs.python.org/2/library/stdtypes.html#typesseq-xrange" rel="nofollow noreferrer"><code>xrange</code></a>.</p>
</div>
<span class="comment-copy">Fancy things often aren't all that great at all</span>
<span class="comment-copy">Implementing a whole class for that is overkill. Specially when you only need an extra line to achieve what you want. There is nothing wrong about your cpde, except maybe a redundant 0: <code>range(0,a) == range(a)</code>.</span>
<span class="comment-copy">Seems I was wrong, I've deleted my answer. TIL</span>
<span class="comment-copy">That works in Python 3, but of course <code>range()</code> in Python 2 produces a list  and <code>xrange()</code> doesn't have <code>.stop</code> either. But <code>xrange</code> supports <code>len(.)</code></span>
<span class="comment-copy">@ilkkachu but Python 2 is from a time before the iPad, eight major releases of Android ago, before Windows 8, before China landed on the moon, in the early days of Obama's presidency, when you could still find a Pentium 4 cpu in warranty...</span>
<span class="comment-copy">@TessellatingHeckler, at least according to <a href="https://en.wikipedia.org/wiki/Python_(programming_language)#History" rel="nofollow noreferrer">Wikipedia</a>, Python 2.0 is from 2000 (bit before GWB presidency), and Python 3.0 from 2008 (bit before Obama presidency). Python 2.7.13 however, <a href="https://www.python.org/downloads/release/python-2713/" rel="nofollow noreferrer">appears to be released</a> at the end of 2016, not that long ago from now. Also, the question was tagged with just [python], and the <a href="http://stackoverflow.com/tags/python/info">tag description</a> seems to indicate it's for both Python 2.x and 3.x.</span>
<span class="comment-copy">@ilkkachu it's true. Python 2.7 released in July 2010, all 2.7.x releases after that are bugfix / maintenance only; it doesn't get new features or ongoing development, there will never be Python 2.8. It's not quite, but alllmost legacy. (In that time, Python 3 has released 3.2, <a href="https://docs.python.org/3/whatsnew/3.3.html" rel="nofollow noreferrer">3.3</a>, <a href="https://docs.python.org/3/whatsnew/3.4.html" rel="nofollow noreferrer">3.4</a>, <a href="https://docs.python.org/3/whatsnew/3.5.html" rel="nofollow noreferrer">3.5</a>, <a href="https://docs.python.org/3/whatsnew/3.6.html" rel="nofollow noreferrer">3.6</a> all with many new features).</span>
