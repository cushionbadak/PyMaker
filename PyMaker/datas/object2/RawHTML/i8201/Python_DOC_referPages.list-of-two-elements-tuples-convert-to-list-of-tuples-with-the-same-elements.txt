<div class="post-text" itemprop="text">
<p>I have list of 2-elements tuples:</p>
<pre><code>[(7, 3), (4, 3), (5, 3), (6, 3), (0, 1), (1, 1), (2, 1), (3, 1)]
</code></pre>
<p>And I want to convert it to another list of tuples. Each list contains elements with the same second index from first list.</p>
<p>So in this case result should look:</p>
<pre><code>[(7, 4, 5, 6), (0, 1, 2, 3)]
</code></pre>
<p>because 7, 4, 5, and 6 are paired with 3 while 0, 1, 2, 3 are paired with 1.</p>
<p>My attempt is to do it this way: </p>
<blockquote>
<p>x = list(map(operator.itemgetter(0), sorted_countries))</p>
</blockquote>
<p>but I still don't know how to group it, because my result is:</p>
<pre><code>[7, 4, 5, 6, 0, 1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>At this time I am not able to get an inline solution... Hope the code snippet is useful if you need solution rather than clear one liner answer..</p>
<pre><code>tupleList = [(7, 3), (4, 3), (5, 3), (6, 3), (0, 1), (1, 1), (2, 1), (3, 1)]
ex_dict = {}
for (x,y) in tupleList:
   try:
     if(ex_dict[y]):
        ex_dict[y] = ex_dict[y]+(x,)
   except:
     ex_dict[y]= (x,)

ex_list = list(ex_dict[x] for x in ex_dict)
print(ex_list)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Depending on your use case this solution might be overgeneralized, but should work for all cases (i.e. initial tuples are not grouped by their second element). You need an <code>OrderedDict</code> here. If you want to avoid <code>setdefault</code>, you need an <a href="https://stackoverflow.com/questions/6190331/can-i-do-an-ordered-default-dict-in-python">ordered defaultdict</a>.</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; l = [(7, 3), (4, 3), (5, 3), (6, 3), (0, 1), (1, 1), (2, 1), (3, 1)]
&gt;&gt;&gt; 
&gt;&gt;&gt; second2first = OrderedDict()
&gt;&gt;&gt; for first, second in l:
...     second2first.setdefault(second, []).append(first)
... 
&gt;&gt;&gt; result = [tuple(v) for v in second2first.values()]
&gt;&gt;&gt; result
[(7, 4, 5, 6), (0, 1, 2, 3)]
</code></pre>
<p>The idea is to grab all the first values of your original tuples and append them to different lists based on the second element the first value is paired with. The <code>OrderedDict</code> is indexed by the first element of your tuples and is used to keep track of the creation order of the lists.</p>
<p>Afterwards, we just extract the values (lists) and convert them to tuples.</p>
</div>
<div class="post-text" itemprop="text">
<p>Have a look at <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby()</a>. This can do the grouping for you.</p>
<p><em>Notice: the input has to be sorted by group key.</em></p>
<p>Example, to get your desired output:</p>
<pre><code>import itertools
test=[(7, 3), (4, 3), (5, 3), (6, 3), (0, 1), (1, 1), (2, 1), (3, 1), (7, 3), (4, 3)]
groups = []
test.sort(key=lambda x:x[1])
for _, group in itertools.groupby(test, key=lambda x:x[1]):
    groups.append(tuple(elem for elem, _ in group))
print(groups)
</code></pre>
<p>As Jon Clements suggests, all of this can be done in a single line with nested list comprehensions:</p>
<pre><code>groups = [tuple(el[0] for el in g) for k, g in itertools.groupby(sorted(test, key=lambda L: L[1]), key=lambda L: L[1])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>lt = [(7, 3), (4, 3), (5, 3), (6, 3), (0, 1), (1, 1), (2, 1), (3, 1)]

lt_part1 = lt[0:len(lt)//2] #[(7, 3), (4, 3), (5, 3), (6, 3)] 


list1 = []
list2 = [] 

list1.append( tuple([t[0]for t in lt_part1]) )
list2.append( tuple([t[1]for t in lt_part1]) )

print(list1)
print(list2)
</code></pre>
<p><strong>RESULT:</strong></p>
<pre><code>[(7, 4, 5, 6)]
[(3, 3, 3, 3)]
</code></pre>
</div>
<span class="comment-copy">What is the exact logic you are trying to implement? Taking the 1st element from each pair and then splitting the final list in half? How did you try and code this? Where did you go wrong?</span>
<span class="comment-copy">this is way underspecified. what is the order? what if elements are mixed?</span>
<span class="comment-copy">Okay, at least it makes sense now. But you need to make an attempt at doing it first. If you get stuck, post the code and we can help with a specific problem. I'd probably start with a naive implementation with an intermediary dict, maybe storing them in sublists which you can later use to generate the final tuples.</span>
<span class="comment-copy">In each tuple order is not important. I want to group in only by second index in tuples of input list</span>
<span class="comment-copy">If my input would look: <code>[(7, 3), (4, 1), (5, 3), (6, 3), (0, 1), (1, 1), (2, 1), (3, 1)]</code> My output would look: <code>[(7, 5, 6), (4, 0, 1, 2, 3)]</code> Again. Order inside of tuples is not important. Main goal is to group it.</span>
<span class="comment-copy">It looks so simple now! Thank you very much.</span>
<span class="comment-copy">You could just do: <code>groups = [tuple(el[0] for el in g) for k, g in itertools.groupby(sorted(test, key=lambda L: L[1]), key=lambda L: L[1])]</code></span>
<span class="comment-copy">Yes, I added it to my answer - thanks!</span>
<span class="comment-copy">My bad - the first example was incorrect and I updated the comment - might want to use that instead :p</span>
<span class="comment-copy">Too much blind trust in the diamonds... ;-) Thanks again.</span>
