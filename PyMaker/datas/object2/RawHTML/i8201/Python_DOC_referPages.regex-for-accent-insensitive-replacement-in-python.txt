<div class="post-text" itemprop="text">
<p>In Python 3, I'd like to be able to use <code>re.sub()</code> in an "accent-insensitive" way, as we can do with the <code>re.I</code> flag for case-insensitive substitution.</p>
<p>Could be something like a <code>re.IGNOREACCENTS</code> flag:</p>
<pre><code>original_text = "¿It's 80°C, I'm drinking a café in a cafe with Chloë。"
accent_regex = r'a café'
re.sub(accent_regex, 'X', original_text, flags=re.IGNOREACCENTS)
</code></pre>
<p>This would lead to "¿It's 80°C, I'm drinking X in X with Chloë。" (note that there's still an accent on "Chloë") instead of "¿It's 80°C, I'm drinking X in a cafe with Chloë。" in real python.</p>
<p>I think that such a flag doesn't exist. So what would be the best option to do this? Using <code>re.finditer</code> and <code>unidecode</code> on both <code>original_text</code> and <code>accent_regex</code> and then replace by splitting the string? Or modifying all characters in the <code>accent_regex</code> by their accented variants, for instance: <code>r'[cç][aàâ]f[éèêë]'</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://pypi.python.org/pypi/Unidecode" rel="nofollow noreferrer"><code>unidecode</code></a> is often mentioned for removing accents in Python, but it also does more than that : it converts <code>'°'</code> to <code>'deg'</code>, which might not be the desired output.</p>
<p><a href="https://docs.python.org/2/library/unicodedata.html" rel="nofollow noreferrer"><code>unicodedata</code></a> seems to have <a href="https://stackoverflow.com/a/39612904/6419007">enough functionality to remove accents</a>.</p>
<h1>With any pattern</h1>
<p>This method should work with any pattern and any text.</p>
<p>You can temporarily remove the accents from both the text and regex pattern. The match information from <a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow noreferrer"><code>re.finditer()</code></a> (start and end indices) can be used to modify the original, accented text.</p>
<p>Note that the matches must be reversed in order to not modify the following indices.</p>
<pre><code>import re
import unicodedata

original_text = "I'm drinking a 80° café in a cafe with Chloë, François Déporte and Francois Deporte."

accented_pattern = r'a café|François Déporte'

def remove_accents(s):
    return ''.join((c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn'))

print(remove_accents('äöüßéèiìììíàáç'))
# aoußeeiiiiiaac

pattern = re.compile(remove_accents(accented_pattern))

modified_text = original_text
matches = list(re.finditer(pattern, remove_accents(original_text)))

for match in matches[::-1]:
    modified_text = modified_text[:match.start()] + 'X' + modified_text[match.end():]

print(modified_text)
# I'm drinking a 80° café in X with Chloë, X and X.
</code></pre>
<h1>If pattern is a word or a set of words</h1>
<p>You could :</p>
<ul>
<li>remove the accents out of your pattern words and save them in a set for fast lookup</li>
<li>look for every word in your text with <code>\w+</code></li>
<li>remove the accents from the word:

<ul>
<li>If it matches, replace by <code>X</code></li>
<li>If it doesn't match, leave the word untouched</li>
</ul></li>
</ul>
<hr/>
<pre><code>import re
from unidecode import unidecode

original_text = "I'm drinking a café in a cafe with Chloë."

def remove_accents(string):
    return unidecode(string)

accented_words = ['café', 'français']

words_to_remove = set(remove_accents(word) for word in accented_words)

def remove_words(matchobj):
    word = matchobj.group(0)
    if remove_accents(word) in words_to_remove:
        return 'X'
    else:
        return word

print(re.sub('\w+', remove_words, original_text))
# I'm drinking a X in a X with Chloë.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://pypi.python.org/pypi/Unidecode" rel="nofollow noreferrer">Unidecode</a>:</p>
<pre><code>$ pip install unidecode
</code></pre>
<p>In your program:</p>
<pre><code>from unidecode import unidecode

original_text = "I'm drinking a café in a cafe."
unidecoded_text = unidecode(original_text)
regex = r'cafe'
re.sub(regex, 'X', unidecoded_text)
</code></pre>
</div>
<span class="comment-copy"><code>Could be something like...</code> @WiktorStribiżew</span>
<span class="comment-copy">What you are looking for is a equivalence class - though I don't know any python regex module that supports them. Syntax is usually like <code>[[=a=]]</code></span>
<span class="comment-copy">Thanks, this method is smart! How to modify it to replace not only words but also n-gram? (I edited my question to take this option into account, for instance to replace "François Déporte" in a text where only "Francois Deporte" appears)</span>
<span class="comment-copy">@AntoineDusséaux: No problem, the first method works fine.</span>
<span class="comment-copy">Smart! I tried everything to break your solution and it seems it doesn't work with <code>'string_to_change = 'äöüßéèiìììíàáç°。阿bcqf反題梓z≤«»Ωﬁñ한か¿？！''</code> ;) so I changed it a little bit: <code>return ''.join((unidecode.unidecode(c) if len(unidecode.unidecode(c)) == len(c) else c for c in s))</code> and it seems to work fine!</span>
<span class="comment-copy">@AntoineDusséaux: Unicode can be so complex that it's pretty easy to break any code with it.</span>
<span class="comment-copy">To avoid this we could escape all characters: <code>return ''.join(re.escape(unidecode.unidecode(c)) if len(unidecode.unidecode(c)) == len(c) else re.escape(c) for c in s)</code> (tested with <code>string_to_change = 'äöüßéèiìììíàáç°。阿bcqf反題梓z≤«»Ωﬁñ한か¿⸼？！..·⁂‖¦•+⸮…'</code>)</span>
<span class="comment-copy">Thanks but this won't help as I'd like to keep other accents from the origian stirng.</span>
<span class="comment-copy">@AntoineDusséaux Right, I didn't thought about that. The other answer seems to be correct.</span>
