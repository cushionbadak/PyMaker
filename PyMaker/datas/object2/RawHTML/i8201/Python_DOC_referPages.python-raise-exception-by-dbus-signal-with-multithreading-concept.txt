<div class="post-text" itemprop="text">
<p>I have a specific problem.</p>
<ol>
<li>Main content of program starts with creating Process with dbus loop, where I listen for signals.</li>
<li>Content of signals I store in queues. In next part of main I have a threadpool.</li>
<li>When some thread takes item from queue, it use specific function(detection) to handle request - based on content of item from queue. (There is operation on database, from where I take data and make some operations depends on request)</li>
<li>Every thread in thread pool starts one more thread, which should handle signals (current status and interrupt).</li>
</ol>
<p>For example: I receive signal, which means I have to handle something on numbers. Any thread from threadpool takes this item from queue and starts function which handle something on numbers - it can take long time. So after any time, I receive signal for current status and I need to send current status of detection - that's why I use threads (for shared memory).  Also I can receive interrupt signal from D-Bus ("it takes too long time, so stop this detection and be free for another request"). And the interrupt is the main problem...</p>
<p>So my main questions are:</p>
<ol>
<li>Is there any way, I can raise exception on interrupt signal and stop function (detection)? (I just found solution, but only for catch in main... but I need to catch it in thread which is in threadpool and raise in thread which is in thread in threadpool)</li>
<li>Second question is about GIL... does my thread with signal receiving receive all signals? I think it doesn't... (Yes, I use <code>threads_init()</code>)</li>
</ol>
<p>program:</p>
<pre><code>SERVICE = multiprocessing.Process(target=dbus_signal_receiver, args=(...))
SERVICE.daemon = True
SERVICE.start()

class worker(threading.Thread):
    def __init__(self,...):
        threading.Thread.__init__(self)

    def run(self):
        while True:
            #get item from queue
            s = threading.Thread(target=curr_and_interr_signal_handle, args=(ID of item from queue,...))
            s.daemon = True
            s.start()
            #start specific detection based on request

for i in range(number of threads):
    t = worker(...)
    t.daemon = True
    t.start()
</code></pre>
<p>and I hoped, something like this will work... (but it doesn't)</p>
<pre><code>...

class worker(threading.Thread):
    def __init__(self,...):
        threading.Thread.__init__(self)

    def run(self):
        while True:
            try:
                #get item from queue
                s = threading.Thread(target=curr_and_interr_signal_handle, args=(ID of item from queue,...))
                s.daemon = True
                s.start()
                #start specific detection based on request
            except raised_interrupt_exception:
                #continue - wait for another request from queue


...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Read about <a href="https://docs.python.org/3/library/signal.html#signals-and-threads" rel="nofollow noreferrer">18.8.1.2. Signals and threads</a><br/>
  Python signal handlers are always executed in the main Python thread,
  even if the signal was received in another thread.<br/>
  This means that signals canâ€™t be used as a means of inter-thread communication.<br/>
  You can use the synchronization primitives from the threading module instead.<br/>
  Besides, only the main thread is allowed to set a new signal handler.</p>
<p>Read about <a href="https://docs.python.org/3/library/threading.html#event-objects" rel="nofollow noreferrer">17.1.7. Event Objects</a><br/>
  This is one of the simplest mechanisms for communication between threads: one thread signals an event and other threads wait for it</p>
</blockquote>
<hr/>
<p>Isn't clear why you have to use <code>thread in thread</code>.<br/>
Why could your <code>worker thread</code> not handle detection?  </p>
<p>For instance, the following should be do it:  </p>
<pre><code>def run(self):
    while self.running.is_set():
        #get item from queue
        #start specific detection based on request
</code></pre>
</div>
<span class="comment-copy">Maybe this is easier done with <a href="https://github.com/ldo/dbussy" rel="nofollow noreferrer">asyncio</a> ...</span>
<span class="comment-copy">Thread in thread I use because of every item (request) in queue, which I get in threadpool, has it's own unique ID. So every thread in threadpool starts thread for handle signals from D-Bus about current status of detection and interrupt to stop handling request with ID. When interrupt, stop function in thread which handle this ID and continue for getting another item (request) from queue</span>
<span class="comment-copy">For example: I get D-Bus signal which means interrupt request with ID 55. And because this thread - <code>s = threading.Thread(target=curr_and_interr_signal_handle, args=(...))</code> - on start gets ID of item from queue, it can raise any exception if the ID of actual handle item from queue is the same as signal interrupt request ID. But this raised exception I am not able to catch properly.</span>
<span class="comment-copy">Have you got better way to deal with it?</span>
<span class="comment-copy">@M.Ohio: Reading your comments does not open up my understanding why you have raise any exception. But anyway, I have updated my Answer.</span>
<span class="comment-copy">Do you know D-Bus? Its control bus for communication between applications. My aplication gets signals (messages) from D-Bus, must receive them and based od type handle it. If it is request for currect status of item with ID = X, my app send actual status in percentage of it's ID. If it is message, which means interrupt item with ID = X, so in thread which handle interrupt messages and ID of item is same as received, I have to stop executing detection and wait for another item from queue. Detection means object, which operate something on huge dataset.</span>
