<div class="post-text" itemprop="text">
<p>Consider mocking an open call returning a file object</p>
<pre><code>&gt;&gt;&gt; from unittest.mock import MagicMock
&gt;&gt;&gt; mock_fi = MagicMock()
&gt;&gt;&gt; mock_op = MagicMock()  
&gt;&gt;&gt; mock_op.return_value = mock_file
&gt;&gt;&gt; 
&gt;&gt;&gt; f = mock_op()
&gt;&gt;&gt; f is mock_fi
True
</code></pre>
<p>So far so good. The contents of mock_calls are</p>
<pre><code>&gt;&gt;&gt; mock_fi.mock_calls
[]
&gt;&gt;&gt; mock_op.mock_calls
[call()]
</code></pre>
<p>and that is fine too. Now consider looping over lines in the file</p>
<pre><code>&gt;&gt;&gt; for l in mock_fi:
...     break
... 
&gt;&gt;&gt; mock_fi.mock_calls
[call.__iter__()]
</code></pre>
<p>and that is as expected. What I do not understand is why the mock_op object has recorded an <code>__iter__</code> call too</p>
<pre><code>&gt;&gt;&gt; mock_op.mock_calls
[call(), call().__iter__()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to documentation, <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.mock_calls" rel="nofollow noreferrer">mock_calls</a> records all the calls to the object, and to the objects returned by calls on that object.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; my_mock = MagicMock()
&gt;&gt;&gt; my_mock.foo().bar()
&lt;MagicMock name='mock.foo().bar()' id='140397146563528'&gt;
&gt;&gt;&gt; my_mock.mock_calls
[call.foo(), call.foo().bar()] # bar() was not called directly on my_mock,
                               # yet, it is included since it was called on 
                               # the return value of foo() which is a direct 
                               # access to my_mock
</code></pre>
<p>In the original code, <code>mock_op.mock_calls</code> reports <code>call().__iter__()</code> which is the call to <code>__iter__()</code> on <code>mock_fi</code>.</p>
</div>
<span class="comment-copy">Thank you @Elisha!</span>
