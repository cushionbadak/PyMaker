<div class="post-text" itemprop="text">
<p>I am using Anaconda (Python 3.6). </p>
<p>In the interactive mode, I did object identity test for positive integers &gt;256:</p>
<pre><code># Interactive test 1
&gt;&gt;&gt; x = 1000
&gt;&gt;&gt; y = 1000
&gt;&gt;&gt; x is y
False
</code></pre>
<p>Clearly, large integers (&gt;256) writing in separate lines are not reused in interactive mode. </p>
<p>But if we write the assignment in one line, the large positive integer object is reused:</p>
<pre><code># Interactive test 2
&gt;&gt;&gt; x, y = 1000, 1000
&gt;&gt;&gt; x is y
True
</code></pre>
<p>That is, in interactive mode, writing the integer assignments in one or separate lines would make a difference for reusing the integer objects (&gt;256). For integers in [-5,256] (as described <a href="https://docs.python.org/2/c-api/int.html" rel="nofollow noreferrer">https://docs.python.org/2/c-api/int.html</a>), caching mechanism ensures that only one object is created, whether or not the assignment is in the same or different lines. </p>
<p>Now let's consider small negative integers less than -5 (any negative integer beyond the range [-5, 256] would serve the purpose), surprising results come out:</p>
<pre><code># Interactive test 3
&gt;&gt;&gt; x, y = -6, -6
&gt;&gt;&gt; x is y
False     # inconsistent with the large positive integer 1000

&gt;&gt;&gt; -6 is -6
False

&gt;&gt;&gt; id(-6), id(-6), id(-6)
(2280334806256, 2280334806128, 2280334806448)

&gt;&gt;&gt; a = b =-6
&gt;&gt;&gt; a is b
True    # different result from a, b = -6, -6
</code></pre>
<p>Clearly, this demonstrates inconsistency for object identity test between large positive integers (&gt;256) and small negative integers (&lt;-5). And for small negative integers (&lt;-5), writing in the form a, b = -6, -6 and a = b =-6 also makes a difference (in contrast, it doesn't which form is used for large integers). Any explanations for these strange behaviors? </p>
<p>For comparison, let's move on to IDE run (I am using PyCharm with the same Python 3.6 interpreter), I run the following script </p>
<pre><code># IDE test case
x = 1000
y = 1000
print(x is y) 
</code></pre>
<p>It prints True, different from the interactive run. Thanks to @Ahsanul Haque, who already gave a nice explanation to the inconsistency between IDE run and interactive run. But it still remains to answer my question on the inconsistency between large positive integer and small negative integer in the interactive run. </p>
</div>
<div class="post-text" itemprop="text">
<p>When you run <code>1000 is 1000</code> in the interactive shell or as part of the bigger script, CPython generates the bytecode like</p>
<pre><code>In [3]: dis.dis('1000 is 1000')
   ...: 
  1           0 LOAD_CONST               0 (1000)
              2 LOAD_CONST               0 (1000)
              4 COMPARE_OP               8 (is)
              6 RETURN_VALUE
</code></pre>
<p>What it does is:</p>
<ul>
<li>Loads two constants (<em>LOAD_CONST pushes co_consts[consti] onto the stack</em> -- <a href="https://docs.python.org/3/library/dis.html#opcode-LOAD_CONST" rel="nofollow noreferrer">docs</a>)</li>
<li>Compares them using <code>is</code> (<code>True</code> if operands refer to the same object; <code>False</code> otherwise)</li>
<li>Returns the result</li>
</ul>
<p>As <a href="https://stackoverflow.com/a/39325641/2301450">CPython only creates one Python object for a constant used in a code block</a>, <code>1000 is 1000</code> will result in a single integer constant being created:</p>
<pre><code>In [4]: code = compile('1000 is 1000', '&lt;string&gt;', 'single') # code object

In [5]: code.co_consts # constants used by the code object
Out[5]: (1000, None)
</code></pre>
<p>According to the bytecode above, Python will load that same object twice and compare it with itself, so the expression will evaluate to <code>True</code>:</p>
<pre><code>In [6]: eval(code)
Out[6]: True
</code></pre>
<p>The results are different for <code>-6</code>, because <strong><code>-6</code> is not immediately recognized as a constant</strong>:</p>
<pre><code>In [7]: ast.dump(ast.parse('-6'))
Out[7]: 'Module(body=[Expr(value=UnaryOp(op=USub(), operand=Num(n=6)))])'
</code></pre>
<p><code>-6</code> is an expression negating the value of the integer literal <code>6</code>.</p>
<p>Nevertheless, the bytecode for <code>-6 is -6</code> is virtually the same as the first bytecode sample:</p>
<pre><code>In [8]: dis.dis('-6 is -6')
  1           0 LOAD_CONST               1 (-6)
              2 LOAD_CONST               2 (-6)
              4 COMPARE_OP               8 (is)
              6 RETURN_VALUE
</code></pre>
<p>So Python loads two <code>-6</code> constants and compares them using <code>is</code>.</p>
<p>How does the <code>-6</code> expression become a constant? CPython has a peephole optimizer, capable of optimizing simple expressions involving constants by evaluating them right after the compilation, and storing the results in the table of constants.</p>
<p>As of CPython 3.6, folding unary operations is handled by <code>fold_unaryops_on_constants</code> in <a href="https://github.com/python/cpython/blob/master/Python/peephole.c" rel="nofollow noreferrer"><code>Python/peephole.c</code></a>. In particular, <code>-</code> (unary minus) is evaluated by <a href="https://docs.python.org/3/c-api/number.html#c.PyNumber_Negative" rel="nofollow noreferrer"><code>PyNumber_Negative</code></a> that returns a new Python object (<a href="https://stackoverflow.com/a/306353/2301450"><code>-6</code> is not cached</a>). After that, the newly created object is inserted to the <code>consts</code> table. However, the optimizer does not check whether the result of the expression can be reused, so the results of identical expressions end up being distinct Python objects (again, as of CPython 3.6).</p>
<p>To illustrate this, I'll compile the <code>-6 is -6</code> expression:</p>
<pre><code>In [9]: code = compile('-6 is -6', '&lt;string&gt;', 'single')
</code></pre>
<p>There're two <code>-6</code> constants in the <code>co_consts</code> tuple</p>
<pre><code>In [10]: code.co_consts
Out[10]: (6, None, -6, -6)
</code></pre>
<p>and they have different memory addresses</p>
<pre><code>In [11]: [id(const) for const in code.co_consts if const == -6]
Out[11]: [140415435258128, 140415435258576]
</code></pre>
<p>Of course, this means that <code>-6 is -6</code> evaluates to <code>False</code>:</p>
<pre><code>In [12]: eval(code)
Out[12]: False
</code></pre>
<hr/>
<p>For the most part the explanation above remains valid in presence of variables. When executed in the interactive shell, these three lines</p>
<pre><code>&gt;&gt;&gt; x = 1000
&gt;&gt;&gt; y = 1000
&gt;&gt;&gt; x is y
False
</code></pre>
<p>are parts of three different code blocks, so the <code>1000</code> constant won't be reused. However, if you put them all in one code block (like a function body) the constant will be reused.</p>
<p>In contrast, the <code>x, y = 1000, 1000</code> line is always executed in one code block (even in the interactive shell), and therefore CPython always reuses the constant. In <code>x, y = -6, -6</code>, <code>-6</code> isn't reused for the reasons explained in the first part of my answer.</p>
<p><code>x = y = -6</code> is trivial. Since there's exactly one Python object involved, <code>x is y</code> would return <code>True</code> even if you replaced <code>-6</code> with something else.</p>
</div>
<div class="post-text" itemprop="text">
<p>Only one copy of a particular constant is created for a particular source code and reused if needed further. So, in pycharm, you are getting <code>x is y</code> == <code>True</code>.</p>
<p>But, in the interpreter, things are different. Here, only one line/statement runs at once. A particular constant is created for each new line. It is not reused in the next line. So, <code>x is not y</code> here. </p>
<p>But, if you can initialize in same line, you can have the same behavior (Reusing the same constant).  </p>
<pre><code>&gt;&gt;&gt; x,y = 1000, 1000
&gt;&gt;&gt; x is y
True
&gt;&gt;&gt; x = 1000
&gt;&gt;&gt; y = 1000
&gt;&gt;&gt; x is y
False
&gt;&gt;&gt; 
</code></pre>
<p>Edit:</p>
<p>A block is a piece of Python program text that is executed as a unit. </p>
<p>In an IDE, the whole module get executed at once i.e. the whole module is a block. But in interactive mode, each instruction is actually a block of code that is executed at once. </p>
<p>As I said earlier, a particular constant is created once for a block of code and reused if reappears in that block of code again. </p>
<p>This is main difference between IDE and interpreter.</p>
<p>Then, why actually interpreter gives same output as IDE for smaller numbers? This is when, integer caching comes into consideration. </p>
<p>If numbers are smaller, then they are cached and reused in next code block. So, we get the same id in the IDE. </p>
<p>But if they are bigger, they are not cached. Rather a new copy is created. So, as expected, the id is different.</p>
<p>Hope this makes sense now,      </p>
</div>
<div class="post-text" itemprop="text">
<p>For complement the answer of the Ahsanul Haque, Try this in any IDE:</p>
<pre><code>x = 1000
y = 1000
print (x is y)
print('\ninitial id x: ',id(x))
print('initial id y: ',id(y))

x=2000
print('\nid x after change value:   ',id(x))
print('id y after change x value: ', id(y))

initial id x:  139865953872336
initial id y:  139865953872336

id x after change value:    139865953872304
id y after change x value:  139865953872336
</code></pre>
<p>Very likely you will see the same ID for 'x' and 'y', then run the code in the interpreter and ids will be different.</p>
<pre><code>&gt;x=1000
&gt;y=1000

&gt;id(x)
=&gt; 139865953870576
&gt;id(y)
=&gt; 139865953872368
</code></pre>
<p><a href="https://repl.it/H8k5/0" rel="nofollow noreferrer">See Here</a>.</p>
</div>
<span class="comment-copy">According to Learning Python 5e, integer catching works only for "small integers". I wanted to know how small integers will be cached, that's why I am testing the above. My question is why I got inconsistent result from the interactive mode and the IDE run. Which result is correct?</span>
<span class="comment-copy">Yes, I withdrew my close vote almost immediately. I scanned your question too quickly, my mistake.</span>
<span class="comment-copy">Thanks. I also deleted my comment when I saw you withdrew that. Thanks for your help. That link you provided is helpful to me.</span>
<span class="comment-copy">@vaultah  I am sure my question is now different from the one you pointed out. I've completely rewritten my question, in which I described two different strange behaviors, and they are not covered by the link you provided.</span>
<span class="comment-copy">Oh, come on. Anything wrong with this answer? ðŸ™„</span>
<span class="comment-copy">Thanks. Your explanation seems to make a lot of sense. But I am still confused. If the interpreter (in the interactive mode) treats two integer constants in separate  lines as different objects, how it manages to treat two smaller integers in separate lines as the same object? I understand there is a concept called integer caching which works for small integers. But I just don't understand why it matters to write in the same or different lines? It doesn't matter in the IDE whether in the same or different lines. What makes such inconsistency in IDE and interactive mode?</span>
<span class="comment-copy">@Peng, see the updated answer.</span>
<span class="comment-copy">It seems that even if you write in the same line in interactive mode, two different objects might be generated, for example, x, y = -6, -6, x is y becomes False. But x,y = 1000, 1000, x is y is True. Still very confusing  to me due to this inconsistent result even in the same interactive mode, and note that -6 and 1000 are both beyond [-5, 256], which was described as the integer range where caching works (see <a href="https://docs.python.org/2/c-api/int.html" rel="nofollow noreferrer">docs.python.org/2/c-api/int.html</a>).</span>
<span class="comment-copy">I just noticed that even in IDE, small negative integer objects (&lt;-5) cannot be reused: x, y = -6, -6, x is y gives False even in IDE, and this is consistent with the case in interactive mode.</span>
