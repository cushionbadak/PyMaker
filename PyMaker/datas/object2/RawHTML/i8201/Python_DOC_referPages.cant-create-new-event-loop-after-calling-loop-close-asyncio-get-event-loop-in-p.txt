<div class="post-text" itemprop="text">
<p>In Python3.6.1 after calling loop.close() on a loop obtained from asyncio.get_event_loop(), can a new loop be created?  </p>
<p>I've looked at other posts with answers for properly closing a loop, and also how to use task.cancel(), but have not been able to use any of those examples in a way that would let a new loop be created after the first was closed.  I also tried explicitly setting executor and later calling executor.shutdown(wait=True), but that didn't help.  I also tried 'del loop', and del a bunch of other things.</p>
<p>Documentation indicates that closing a an event loop is idempotent and irreversible.  Does that also mean that a new loop cannot be created?</p>
<p>Here is some simple example code to demonstrate the issue:
`<code></code></p>
<pre><code>#!/usr/bin/env python3.6
'''
To demonstrate an issue, the following code was adapted from:
https://docs.python.org/3/library/asyncio-eventloop.html
'''
import asyncio

def hello_world(loop):
    print('Hello World')
    loop.stop()

loop = asyncio.get_event_loop()
loop.call_soon(hello_world, loop)
loop.run_forever()
# loop.close()


'''
If the commented out loop.close() above is uncommented,
the following code will fail with:
    Traceback (most recent call last):
        File "./aquestion.py", line 28, in &lt;module&gt;
            loopNew.call_soon(hello_world, loopNew)
        File "/Library/Frameworks/Python.framework/Versions/3.6/lib    /python3.6/asyncio/base_events.py", line 573, in call_soon
        self._check_closed()
        File "/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/base_events.py", line 357, in _check_closed
            raise RuntimeError('Event loop is closed')
    RuntimeError: Event loop is closed

'''
loopNew = asyncio.get_event_loop()
loopNew.call_soon(hello_world, loopNew)
loopNew.run_forever()
</code></pre>
<p></p></div>
<div class="post-text" itemprop="text">
<p><code>asyncio.get_event_loop</code> returns the current loop. It pays no attention to the state of the loop. If you need a new loop after closing one, you can use <code>asyncio.new_event_loop</code>.</p>
<p>Be aware that getting a new loop won't affect subsequent calls to <code>get_event_loop</code>. If you'd like that to return your new loop instead of the original one (especially since you've probably closed it), you'll need to call <code>asyncio.set_event_loop</code> yourself.</p>
<pre><code>import asyncio

async def f():
    await asyncio.sleep(0)

loop = asyncio.get_event_loop()
loop.run_until_complete(f())
loop.close()

loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)
</code></pre>
</div>
<span class="comment-copy">Thank you very much!!!  That worked great.  I had tried new_event_loop earlier, but I must have done something wrong during that experiment.</span>
<span class="comment-copy">I neglected to mention <code>set_event_loop</code>. That may be related to the problems you ran into. I've updated the answer to include it.</span>
