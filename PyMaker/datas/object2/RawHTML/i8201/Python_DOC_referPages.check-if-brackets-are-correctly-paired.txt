<div class="post-text" itemprop="text">
<p>I have lists of brackets, like </p>
<pre><code>li1 = ['{','[','(',')',']','}' ]  # correctly paired
li2 = ['[','(',')',']']           # correctly paired
li3 = ['{','[','}',']',')','}']   # incorrectly paired
</code></pre>
<p>How can I compare the first element with the last element, then the next element with the next last, using a for loop?</p>
<p>My solution is like </p>
<pre><code>if len(li) %2 == 0:
    for i in range(len(li)):
         if li[0] == li[-1]: #and          if li[1] == li[-2]: and so on.....
           return True
        else:
           return False
else:
    return False
</code></pre>
<p>but this returns the wrong result for <code>li3</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are doing 3 things wrong in your code:</p>
<ul>
<li>you are always returning <em>for the first check</em>; you need to postpone judgement until you tested all pairs.</li>
<li>you are not using the <code>i</code> counter, so your loop only ever tests the very first and very last element</li>
<li>you need to <em>map</em> left brackets to right brackets; <code>'[' == ']'</code> is never going to be true, but the pairing is correct.</li>
</ul>
<p>I wouldn't bother with a counter, use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> and <a href="https://docs.python.org/3/library/functions.html#reversed" rel="nofollow noreferrer"><code>reversed()</code></a> to pair up elements from the start and end; you only need to test the first half of <code>li</code>:</p>
<pre><code>def test_pairs(li, _map={'(': ')', '[': ']', '{': '}'}):
    l = len(li)
    if l % 2 == 1:
        # odd length list, can't be paired
        return False

    # pair up the first half with the second half, reversed
    for first, second in zip(li[:l // 2], reversed(li)):
        if _map.get(first) != second:
            # Either first is not a left bracket, or right bracket is not a match
            return False

    # everything tested, so everything matched
    return True
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; test_pairs(['{', '[', '(', ')', ']', '}'])
True
&gt;&gt;&gt; test_pairs(['[', '(', ')', ']'])
True
&gt;&gt;&gt; test_pairs(['{', '[', '(', ']', ')', '}'])
False
</code></pre>
<p>Testing for a single dimension of nesting is usually <em>not enough</em> however. Most real-world situations will contain multiple groupings, like <code>['(', '{', '}', '[', ']', ')']</code> (note the <code>{</code>, <code>}</code> and <code>[</code>, <code>]</code> pairs are not nested!). If you need to match such a situation, you'll need to use a stack:</p>
<pre><code>def test_groupings(li, _map={'(': ')', '[': ']', '{': '}'}):
    stack = []
    for el in li:
        if el in _map:
            # opening element, add to stack to look for matching close
            stack.append(el)
        elif not stack or _map[stack[-1]] != el:
            # not an opening element; is the stack is empty?
            # or is this element not paired with the stack top?
            return False
        else:
            # closing element matched, remove opening element from stack
            stack.pop()

    # if the stack is now empty, everything was matched
    return not stack
</code></pre>
<p>This then still correctly detects your cases, *but also returns <code>True</code> for my counter example:</p>
<pre><code>&gt;&gt;&gt; test_groupings(['{', '[', '(', ')', ']', '}'])
True
&gt;&gt;&gt; test_groupings(['[', '(', ')', ']'])
True
&gt;&gt;&gt; test_groupings(['{', '[', '(', ']', ')', '}'])
False
&gt;&gt;&gt; test_groupings(['(', '{', '}', '[', ']', ')'])
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your mistakes here are:</p>
<ul>
<li>Using index 0 and -1 instead of i.</li>
<li>Comparing the opening to closing brackets</li>
</ul>
<p>So, here's my solution:</p>
<pre><code>def check(li):
  length = len(li)
  if length % 2 == 0:
    pairs = {'}': '{', ']': '[', ')': '('}
    stack = []
    for i in range(length):
      if li[i] in pairs.values():
        stack.append(li[i])
      elif li[i] in pairs.keys() and stack[-1] == pairs[li[i]]:
        stack.pop()
    return len(stack) == 0
  else:
    return False
</code></pre>
<p>I use stack for opening bracket and if it find a closing bracket, it will pop the stack. At last, check whether the stack is cleared out or not.</p>
<p>Test results using your test case</p>
<pre><code>li1 = ['{','[','(',')',']','}' ]
check(li1)
&gt;&gt;&gt; True
li2 = ['[','(',')',']']
check(li2)
&gt;&gt;&gt; True
li3 = ['{','[','(',']',')','}']
check(li3)
&gt;&gt;&gt; False
</code></pre>
</div>
<span class="comment-copy">Also, you have been here long enough (with over 500 undeleted questions) that I would have expected you to know how to ask a good question by now. This falls way short of the mark.</span>
<span class="comment-copy">Also, are all your pairings nested, or can there be multiple groups? Like <code>['(', '{', '}', '[', ']', ')']</code>? Is such an example valid or invalid?</span>
<span class="comment-copy">Can you please explain the else part w,r,t the input test_groupings(['{', '[', '(', ')', ']', '}']) .My question is how will the matching happen in the else part . Also can you convert the else part to elif for my understanding</span>
<span class="comment-copy">@Rajeev: <code>else</code> is the remaining option, all other possibilities have been covered by the <code>if</code> and <code>elif</code> before it. There is no need to make it another <code>elif</code>, that's just more work for the interpreter. <code>if</code> tests if it is an opening bracket (true for the first three elements of your input), the <code>elif</code> makes sure the stack isn't empty (by the time we get to the 4th element that's not the case) and that the top of the stack is an opening bracket for the current element, so only if there is a matching opening bracket on the stack will we get to <code>else</code>.</span>
<span class="comment-copy">@Rajeev: in other words, <code>else</code> is reached only when all three conditions are true: the element is not an opening bracket, we have seen opening brackets before (because the stack has elements on it) and the top of the stack is the matching opening bracket for this element (so it is a closing bracket). That means we can remove the top from the stack, it has been matched.</span>
<span class="comment-copy">Interesting how you first wrote a corrected version applying all the fixes that I already wrote about, then <i>completely changed your answer</i> to use the stack approach I advocate in my answer in a later edit. Don't plagiarise your solutions please.</span>
<span class="comment-copy">Other than that, your stack approach will fail for inputs with more closing brackets than opening (<code>IndexError</code> is raised). Don't use <code>for i in range(len(it)):</code> then <code>it[i]</code> when you can just iterate directly over the <code>it</code> elements. Don't use <code>something in dict.keys()</code> when <code>something in dict</code> works just fine without the extra call, and the odd/even length check is now semi-redundant, the stack approach will detect the same case. Even if it may save a few milliseconds for large inputs, you'd want to clean up the test by inverting and returning <code>False</code> early, so you can unindent the remainder.</span>
<span class="comment-copy">@MartijnPieters Hi, thank you for your advice. I realized my first submission was flawed after I read your 4th test case. But, let me clear this out. The stack approach is done because I remembered I had done this case in <a href="https://www.hackerrank.com/challenges/ctci-balanced-brackets" rel="nofollow noreferrer">HackerRank</a> before. So, I apologize if it looked like plagriasm. I learned the lesson. So once again, thank you. :)</span>
