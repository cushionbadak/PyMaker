<div class="post-text" itemprop="text">
<p><strong>I have a huge list of integers in Python (1000000+ elements)</strong>, but I will illustrate what I need with an example for the sake of simplicity. Let's suppose I have this list:</p>
<pre><code>A = [1,2,3,4,100]
</code></pre>
<p>Now I'd like to get all the combinations (size 3) of that list, so I use itertools.</p>
<pre><code>combinations = itertools.combinations(A,3)
</code></pre>
<p>But my problem is that this will return the combinations in lexicographical order:</p>
<pre><code>(1,2,3)
(1,2,4)
(1,2,100)
(1,3,4)
</code></pre>
<p>and so on.</p>
<p><strong>I'd like to get the combinations sorted by the sum of its elements</strong>. That would be:</p>
<p>(1,2,3) which sums 6, 
(1,2,4) which sums 7,
(1,3,4) which sums 8,</p>
<p>and so on so forth.</p>
<p>How can I achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Ordered combinations too big to fit in memory</h2>
<p>The number of combinations for 1,000,000 things taken 3 at a time is 166,666,166,667,000,000.  That is too big to fit in memory, too big to sort, and too huge to even loop over in a reasonable amount of time.</p>
<p>For a way to generate these combinations lazily, see <a href="http://www.cs.utsa.edu/~wagner/knuth/fasc3a.pdf" rel="nofollow noreferrer">"GENERATING ALL COMBINATIONS"</a> in Donald Knuth's fascicle on <em>Combinatorial Algorithms</em>.</p>
<h2>Ordered combinations that can fit in memory</h2>
<p>As long as the number of combinations is reasonable, the most straight forward approach is to directly sort the combinations by their sum:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; import pprint

&gt;&gt;&gt; A = [1, 2, 3, 4, 100]
&gt;&gt;&gt; combinations = sorted(itertools.combinations(A, 3), key=sum)
&gt;&gt;&gt; pprint.pprint(combinations)
[(1, 2, 3),
 (1, 2, 4),
 (1, 3, 4),
 (2, 3, 4),
 (1, 2, 100),
 (1, 3, 100),
 (1, 4, 100),
 (2, 3, 100),
 (2, 4, 100),
 (3, 4, 100)]
</code></pre>
<p>The technique uses <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer">sum()</a> as a <a href="https://docs.python.org/3/glossary.html#term-key-function" rel="nofollow noreferrer">key-function</a> for <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer">sorted()</a>.</p>
<h2>Bridging the two worlds</h2>
<p>When <a href="https://en.wikipedia.org/wiki/Combination" rel="nofollow noreferrer">nCr</a> is bigger than can be practically enumerated, it would make sense to reduce the problem by removing the larger elements from list <em>A</em> until the sum gets big enough to include those values.</p>
</div>
<div class="post-text" itemprop="text">
<p>The key thing to consider here is the no.of combinations is really huge ~(1000000)^^3
So, any sorting algorithm with O(NlogN) is going to be bad. We need something in O(N).</p>
<p>We can try create a SortedDictionary (<a href="https://pypi.python.org/pypi/sorteddict" rel="nofollow noreferrer">sorteddict</a>) or use a standard external hash implementation like memcache to store the combination as
{sum:[tuple1, tuple2]}. Complexity for this operation will be ~O(N)</p>
<p>Then, Create a new list, loop through the cache and all values to it. Again the complexity will be O(N).</p>
<p>Overall, we will have O(2N) which is efficient than O(NLogN). Hope this will help!</p>
</div>
<span class="comment-copy">I'd give each combination a summed value and sort by that value as a key <code>[(1,2,3),6]</code> - along those lines</span>
<span class="comment-copy">Have you estimated how many combinations are involved?</span>
<span class="comment-copy">The number of combinations is going to be huge, since there are more than one million elements on the list</span>
<span class="comment-copy">Are you even going to have enough memory to store this many combinations? My guesstimate is that it would require about 1.2e10 <b>gigabytes</b></span>
<span class="comment-copy">it seems like you are trying to use brute force on a problem like knapsack problem. if you describe the actual problem, there is probably a better way to solve it</span>
<span class="comment-copy">I'm not following how your approach would reduce the time complexity of sorting by the sum of the values... Essentially, you create a map <code>sum:List[tuples]</code>, and then you iterate over it again, but how does this <i>sort</i> by <code>sum</code>? Any ordered dictionary implementation that maintais a sorted order, I think, has to use some insertion operation that is more than O(N), no?</span>
<span class="comment-copy">I am not sure about your statement 'Any ordered dictionary implementation that maintais a sorted order, I think, has to use some insertion operation that is more than O(N)' on ordered list. I guess there are better ways to deal than sorting at every insertions like have the hash key as an index into memory or something like that. Agree for some cases we may need to do some sort &amp; copy - but that can be amortized. May be Lets check how it is actually implemented and discuss.</span>
<span class="comment-copy">I ask out of genuine curiosity, I've only taken a few cursory CS classes, since my background is biology, so my depth of knowledge beyond basic algorithms/data-structures is rather limited. But basically, I'm not sure how your approach above provides a <i>sorted</i> sequence of tuples...</span>
<span class="comment-copy">If tuples sum order is guaranteed, then its just a iteration through the entire dictionary and generate the new list of combinations. The new list of combinations will be in the same order right?</span>
<span class="comment-copy">Well, if you use an <code>collections.OrderedDict</code>, then this list will be in the same order, but that order won't be <i>sorted</i>.</span>
