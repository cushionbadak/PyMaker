<div class="post-text" itemprop="text">
<p>What are use cases in python 3 of writing a custom <code>__del__</code> method or relying on one from stdlib<sup>1</sup>? That is, in what scenario is it reasonably safe, and can do something that's hard to do without it?</p>
<p>For many good reasons (<a href="https://stackoverflow.com/a/6104568/336527">1</a> <a href="http://www.andy-pearce.com/blog/posts/2013/Apr/python-destructor-drawbacks/" rel="nofollow noreferrer">2</a> <a href="https://github.com/python-zk/kazoo/issues/384#issuecomment-196536319" rel="nofollow noreferrer">3</a> <a href="https://stackoverflow.com/a/35489349/336527">4</a> <a href="https://stackoverflow.com/a/10352514/336527">5</a> <a href="https://stackoverflow.com/a/7659862/336527">6</a>), the usual recommendation is to avoid <code>__del__</code> and instead use context managers or perform the cleanup manually:</p>
<ol>
<li><code>__del__</code> is not guaranteed to be called if objects are alive on intrepreter exit<sup>2</sup>.</li>
<li>At the point one expects the object can be destroyed, the ref count may actually be non-zero (e.g., a reference may survive through a traceback frame held onto by a calling function). This makes the destruction time far more uncertain than the mere unpredictability of <code>gc</code> implies.</li>
<li>Garbage collector cannot get rid of cycles if they include more than 1 object with <code>__del__</code></li>
<li>The code inside <code>__del__</code> must be written super carefully:

<ul>
<li>object attributes set in <code>__init__</code> may not be present since <code>__init__</code> might have raised an exception;</li>
<li>exceptions are ignored (only printed to <code>stderr</code>);</li>
<li>globals may no longer be available.</li>
</ul></li>
</ol>
<hr/>
<p>Update:</p>
<p><a href="https://www.python.org/dev/peps/pep-0442/" rel="nofollow noreferrer">PEP 442</a> has made significant improvements in the behavior of <code>__del__</code>. It seems though that my points 1-4 are still valid?</p>
<hr/>
<p>Update 2:</p>
<p>Some of the top python libraries <a href="https://github.com/aio-libs/aiohttp/issues/537" rel="nofollow noreferrer">embrace the use of <code>__del__</code></a> in the post-PEP 442 python (i.e., python 3.4+). I guess my point 3 is no longer valid after PEP 442, and the other points are accepted as unavoidable complexity of object finalization. </p>
<hr/>
<p><sup>1</sup>I expanded the question from just writing a custom <code>__del__</code> method to include relying on <code>__del__</code> from stdlib.</p>
<p><sup>2</sup>It seems that <code>__del__</code> is always called on interpreter exit in the more recent versions of Cpython  (does anyone have a counter-example?). However, it doesn't matter for the purpose of <code>__del__</code>'s usablity: the docs explicitly <a href="https://docs.python.org/3/reference/datamodel.html#object.__del__" rel="nofollow noreferrer">provide no guarantee about this behavior</a>, so one cannot rely on it (it may change in future versions, and it may be different in non-CPython interpreters).</p>
</div>
<div class="post-text" itemprop="text">
<p>Context managers (and <code>try</code>/<code>finally</code> blocks) are somewhat more restrictive than <code>__del__</code>. In general they require you to structure your code in such a way that the lifetime of the resource you need to free doesn't extend beyond a single function call at some level in the call stack, rather than, say, binding it to the lifetime of a class instance that could be destroyed at unpredictable times and places. It's usually a good thing to restrict the lifetime of resources to one scope, but there sometimes edge cases where this pattern is an awkward fit.</p>
<p>The only case where I've used <code>__del__</code> (aside from for debugging, c.f. @MSeifert's answer) is for freeing memory allocated outside of Python by an external library. Because of the design of the library I was wrapping, it was difficult to avoid having a large number of objects that held pointers to heap-allocated memory. Using a <code>__del__</code> method to free the pointers was the easiest way to do cleanup, since it would have been impractical to enclose the lifespan of each instance inside a context manager.</p>
</div>
<div class="post-text" itemprop="text">
<p>One use-case is debugging. If you want to track the lifetime of a specific object it's convenient to write a <strong>temporary</strong> <code>__del__</code> method. It can be used to do some logging or just to <code>print</code> something. I have used it a few times especially when I was interested in when and how instances are deleted. It's sometimes good to know when you create and discard a lot of temporary instances. But as I said I only ever used this to satisfy my curiosity or when debugging.</p>
<p>Another use-case is subclassing a class that defines a <code>__del__</code> method. Sometimes you find a class that you want to subclass but the internals require you to actually override <code>__del__</code> to control the <strong>order</strong> in which the instance is cleaned up. That's very rare too because you need to find a class with <code>__del__</code>, you nee to subclass it and you need to introduced some internals that actually require to call the superclass <code>__del__</code> at exactly the right time. I actually did that once but I don't remember where and why it was important (maybe I didn't even know about alternatives then, so treat this as <em>possible</em> use-case).</p>
<p>When you wrap an external object (for example a <a class="post-tag" href="/questions/tagged/c" rel="tag" title="show questions tagged 'c'">c</a> object that isn't tracked by Python) that <strong>really, really</strong> needs to be deallocated even if someone "forgets" (I suspect a lot of people just omit them on purpose!) to use the context manager that you provided.</p>
<hr/>
<p>However all these cases are (or should be) very, very rare. Actually it's a bit like with metaclasses: They are fun and it's really cool to understand the concepts because you can probe the "fun parts" of python. But in practice:</p>
<blockquote>
<p>If you wonder whether you need them [metaclasses], you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).</p>
</blockquote>
<p>Citation (probably) from Tim Peters (I haven't found the original reference).</p>
</div>
<div class="post-text" itemprop="text">
<p>One case where i always use <code>__del__</code>, is for closing a <code>aiohttp.ClientSession</code> object.</p>
<p>When you don't, aiohttp will print warnings about the unclosed client session.</p>
</div>
<span class="comment-copy">Why do you exclude the standard library in this question?</span>
<span class="comment-copy">Because I (over)used <code>__del__</code> in my code, and I am planning to completely abandon it. Before I do, I want to make sure I'm not missing situations where I shouldn't avoid it. Since I (and most people on SO) don't contribute to stdlib, I wanted to keep the question simpler by excluding it.</span>
<span class="comment-copy">@ali_m I was thinking about it too. So let's say your objects' lifetime is too open-ended to enclose in a context manager, so you end up relying on <code>__del__</code>. You must care about cleanup enough to bother writing <code>__del__</code>. And yet you don't mind if the cleanup occsionally never happens or happens much later than expected (since that's the semantics of <code>__del__</code>). What kind of cleanup would be a good fit? Maybe freeing memory, but that's already done by gc. Maybe helping gc to free memory where it struggles?</span>
<span class="comment-copy">@max In some cases you only require the <code>__del__</code> call if you're close to running out of memory and most python implementations collect objects when memory is getting "sparse". So you don't care about "immediate cleanup" but only about "eventual cleanup".</span>
<span class="comment-copy">@max <code>gc</code> can't free memory that was allocated outside of Python (e.g. by a call to <code>malloc</code> from some shared library).</span>
<span class="comment-copy">What did your <code>__del__</code> do that the normal garbage collection couldn't?</span>
<span class="comment-copy">@max It freed memory that had been allocated outside of Python (by a C function in the library I was wrapping), and was therefore invisible to <code>gc</code>.</span>
<span class="comment-copy">I'll accept your answer even though both are very helplful because I think freeing of <code>malloc</code>-allocated memory is a perfect production use case. From my question, point (1) is irrelevant since the process memory will be freed on exit; point (2) is less relevant because (as @MSeifert points out) as long as <code>gc</code> frees it before memory completely runs out, it's good enough; (3) and (4) are just points that implementation needs to be careful about.</span>
<span class="comment-copy">Wouldn't weakref callbacks be suitable for this purpose, without the downsides of <code>__del__</code>?</span>
<span class="comment-copy">@MariusGedminas I asked <a href="http://stackoverflow.com/questions/43758886/can-weakref-callbacks-replace-del">a question</a> about this, since I think it's too much to add more side questions to this post.</span>
<span class="comment-copy">The main problem that prevents destructors from being useful in production code seems to be the lack of predictability of when or whether they are called. The metaclass, being slightly complex but perfectly predictable, is a lot more useful!</span>
<span class="comment-copy">@max Yes, I guess the comparison isn't that useful after all. I was purely thinking about use-cases: Both have use-cases, but they tend to be really sparse (and really complex).</span>
<span class="comment-copy">BTW, another technique (which I just found out about) to help track the objects' lifetime, is to set <code>PYTHONVERBOSE=2</code>.</span>
<span class="comment-copy">@max Isn't that just about modules? I never actually used it yet, I'll definetly give it a try :) But in my debugging scenarios I was only interested in one or two classes so there's no need to track all. :)</span>
<span class="comment-copy">Ah yes, you're right, it only includes module cleanup info.</span>
<span class="comment-copy">But wouldn't that be unreliable, since based on the python documentation, your <code>__del__</code> may never be called?</span>
