<div class="post-text" itemprop="text">
<p><code>type(object)</code> returns type of an object.</p>
<pre><code>&gt;&gt;&gt; type(__builtins__)
&lt;type 'module'&gt;
&gt;&gt;&gt; name = type(__builtins__)
&gt;&gt;&gt; type(name)
&lt;type 'type'&gt;
&gt;&gt;&gt; name
&lt;type 'module'&gt;

&gt;&gt;&gt; name('my_module')
&lt;module 'my_module' (built-in)&gt;
&gt;&gt;&gt; name('xyz')
&lt;module 'xyz' (built-in)&gt;
&gt;&gt;&gt; 
</code></pre>
<p>In this syntax, </p>
<pre><code>my_module = type(__builtins__)('my_module')
</code></pre>
<p><code>type(__builtins__)</code> should return callable object that takes <code>('my_module')</code> as argument. <code>type(object)</code> returns callable object?</p>
<p>How to understand what this is doing?</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's run through some examples:</p>
<hr/>
<pre><code>&gt;&gt;&gt; type(int)
&lt;class 'type'&gt;
</code></pre>
<p>So, since <code>type(int)</code> returns a <code>type</code>, it makes sence that</p>
<pre><code>&gt;&gt;&gt; type(int)(12)
&lt;class 'int'&gt;
</code></pre>
<p>since </p>
<pre><code>&gt;&gt;&gt; type(12)
&lt;class 'int'&gt;
</code></pre>
<p><strong>More importantely:</strong></p>
<pre><code>&gt;&gt;&gt; (type(int)(12) == type(12)) and (type(int)(12) is type(12))
True
</code></pre>
<hr/>
<p>Now, if you instead do:</p>
<pre><code>&gt;&gt;&gt; type(int())
&lt;class 'int'&gt;
</code></pre>
<p>which is also expected since</p>
<pre><code>&gt;&gt;&gt; (int() == 0) and (int() is 0)
True
</code></pre>
<p>and</p>
<pre><code>&gt;&gt;&gt; (type(int()) = type(0)) and (type(int()) is type(0))
True
</code></pre>
<hr/>
<p>So, putting things together: </p>
<ul>
<li><code>int</code> is an object of type <code>type</code></li>
<li><code>int()</code> is an (integer) object of type <code>int</code></li>
</ul>
<hr/>
<p>Another example:</p>
<pre><code>&gt;&gt;&gt; type(str())
&lt;class 'str'&gt;
</code></pre>
<p>which means that </p>
<pre><code>&gt;&gt;&gt; (type(str())() == '') and (type(str())() is '')
True
</code></pre>
<p>therefore, it behaves just like a string object:</p>
<pre><code>&gt;&gt;&gt; type(str())().join(['Hello', ', World!'])
'Hello, World!'
</code></pre>
<hr/>
<p>I have the feeling that I might have made this seem much more complicated than it actually is... it isn't!</p>
<hr/>
<p><code>type()</code> returns the class of an object. So:</p>
<ul>
<li><code>type(12)</code> is just an ugly way of writing <code>int</code></li>
<li><code>type(12)(12)</code> is just an ugly way of writing <code>int(12)</code></li>
</ul>
<p>So, "Yes!", <code>type()</code> returns a callable. But it's much better to think about it as (from <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer">official docs</a> )</p>
<blockquote>
<p><em>class <strong>type</strong>(object)</em></p>
<p>With one argument, return the type of an object. The return value is a type object and generally the same object as returned by object.__class__.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The <em>type()</em> function returns the class of an object.  In the case of <code>type(__builtins__)</code> it returns a <em>Module</em> type.   The semantics of module are detailed at:  <a href="https://docs.python.org/3/library/stdtypes.html#modules" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#modules</a></p>
<p>The source code for CPython has this in Objects/moduleobject.c::<em>module_init()</em>:</p>
<pre><code>static char *kwlist[] = {"name", "doc", NULL};
PyObject *dict, *name = Py_None, *doc = Py_None;
if (!PyArg_ParseTupleAndKeywords(args, kwds, "U|O:module.__init__",
                                 kwlist, &amp;name, &amp;doc))
</code></pre>
<p>That means you can call (instantiate) module objects with the <em>name</em> of the module as a required argument and the docstring as an optional argument.</p>
</div>
<span class="comment-copy">Yes, <code>type</code> returns a type object. Type objects are callable.</span>
<span class="comment-copy">I don't understand your question.</span>
<span class="comment-copy">@vaultah Do you mean, <code>type(__builtins__)</code>  displays <code>&lt;type 'module'&gt;</code> on stdout and returns callable object?</span>
<span class="comment-copy"><code>&lt;type 'module'&gt;</code> is the <code>repr</code> of the <code>module</code> type object.</span>
<span class="comment-copy">@juanpa.arrivillaga  I can apply <code>('my_module')</code> to an object, if it is of type <code>function</code>. Is <code>type(__builtins__)</code> returning some function?</span>
<span class="comment-copy">Can I say, <code>x = 1</code> is nothing but <code>x = int(1)</code> internally? Only difference is, <code>x=int(1)</code> is more OOP way of writing python code. Guido provided syntactic sugar <code>x=1</code> from math sense.</span>
<span class="comment-copy">am still not clear,If x=myClass() is not confusing  then how y=int() is confusing. If my team decides for writing oop style python code, then x=1 looks like math equation despite int(1) gets executed internally.</span>
<span class="comment-copy">Python does not call <code>int()</code> when you run <code>x=1</code>. <code>x=1</code> is faster to type, is faster to run, as is the most pythonic way of writing code. See: <a href="http://stackoverflow.com/questions/2736693/creating-a-list-in-python-something-sneaky-going-on">this</a> and <a href="http://stackoverflow.com/questions/5790860/and-vs-list-and-dict-which-is-better">that</a></span>
