<div class="post-text" itemprop="text">
<p>When I try to unpickle pickled complex enum instance, I always get "ValueError: BLUE is not a valid Colors".</p>
<p>Is there any way how to pickle and unpickle?</p>
<pre><code>from pickle import loads, dumps
from enum import Enum


class ColorType(object):

    def __init__(self, counter, name):
        self.counter = counter
        self.name = name

    def __str__(self):
        return self.name


class Colors(Enum):
    GREEN = ColorType(1, 'GREEN')
    BLUE = ColorType(2, 'BLUE')


color = Colors.BLUE
print(color is loads(dumps(color)))
</code></pre>
<p>I am using Python 2.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use a custom class as the enum values; there is no need here.  Your specific example doesn't need a separate class at all, you could just use:</p>
<pre><code>class Colors(Enum):
    GREEN = 1
    BLUE = 2

    def __str__(self):
        return self.name

    @property
    def counter(self):
        return self.value
</code></pre>
<p>This has <em>better</em> <code>str()</code> and <code>.counter</code> behaviour; your code requires <code>str()</code> to be applied to <code>Color.&lt;name&gt;.value</code> rather than directly to <code>Color.&lt;name&gt;</code>.</p>
<p>For other custom methods and attributes, put those directly on the <code>Enum</code> subclass and they'll be part of the enum members too. If you need more values per entry, set a <em>tuple</em> and pull that tuple apart in a <code>__init__</code> method. The documentation has an excellent <a href="https://docs.python.org/3/library/enum.html#planet" rel="nofollow noreferrer">Planet example</a> that illustrates this further.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; Colors.BLUE
&lt;Colors.BLUE: 2&gt;
&gt;&gt;&gt; Colors.BLUE.value
2
&gt;&gt;&gt; Colors.BLUE.counter
2
&gt;&gt;&gt; str(Colors.BLUE)
'BLUE'
&gt;&gt;&gt; Colors.BLUE is loads(dumps(Colors.BLUE))
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The issue here is basic equality:</p>
<pre><code>&gt;&gt;&gt; ColorType(2, 'BLUE') == ColorType(2, 'BLUE')
False
</code></pre>
<p>So when <code>Colors</code> is trying to find a match for the unpickled value of <code>ColorType(2, 'BLUE')</code> it is failing.</p>
<p>The solution is simple:  add the <code>__eq__</code> and <code>__ne__</code> methods to `ColorType':</p>
<pre><code>class ColorType(object):

    def __init__(self, counter, name):
        self.counter = counter
        self.name = name

    def __str__(self):
        return self.name

    def __eq__(self, other):
        return self.name == other.name and self.counter == other.counter

    def __ne__(self, other):
        # not needed in Python 3
        return self.name != other .name or self.counter != other.counter
</code></pre>
<p><strong>NB</strong> I agree with @MartijnPieters that in most cases you should just add the needed functionality to the <code>Enum</code> itself.</p>
</div>
<span class="comment-copy">Presumably you are using the <code>enum34</code> backport package then?</span>
<span class="comment-copy">And why are you using a <code>ColorType</code> class? IIRC <code>Enum</code> has support for more complex value types directly including additional methods, without using a separate class object. See the documentation for examples.</span>
<span class="comment-copy">yes, I have <code>enum34</code> installed, This example is just to illustrate the real problem that is much more complex.</span>
<span class="comment-copy">So why not use the setup as shown in the <a href="https://docs.python.org/3/library/enum.html#planet" rel="nofollow noreferrer">Planet example</a>?</span>
<span class="comment-copy">Besides, the name is already set for each of those objects; you can safely use <code>GREEN = 1</code> and <code>Colors.GREEN.name</code> will produce <code>'GREEN'</code>. I'm afraid you are using enum in a way that is incompatible with the pickle support.</span>
<span class="comment-copy">Ok, thanks a lot, I put my methods to <code>Colors</code> enum directly.</span>
<span class="comment-copy">But why have the second class <i>in the first place</i>?</span>
<span class="comment-copy">If not using <code>aenum</code> a simple way to get attribute access is to mix-in a <code>namedtuple</code>, for example; the point is it can be done should you need it.  (No, I have no use-cases myself.)</span>
<span class="comment-copy">In Python 3, <code>__ne__</code> would be optional as there <a href="https://docs.python.org/3/reference/datamodel.html#object.__ne__" rel="nofollow noreferrer"><code>__ne__</code> delegates to <code>__eq__</code> and inverts the result</a>. Unfortunately, in Python 2 you are not so lucky.</span>
