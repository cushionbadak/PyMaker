<div class="post-text" itemprop="text">
<p>I have a large directory with PDF files (<strong>images</strong>), how can I extract efficiently the text from all the files inside the directory?. So far I tried to:</p>
<pre><code>import multiprocessing
import textract

def extract_txt(file_path):
    text = textract.process(file_path, method='tesseract')

p = multiprocessing.Pool(2)
file_path = ['/Users/user/Desktop/sample.pdf']
list(p.map(extract_txt, file_path))
</code></pre>
<p>However, it is not working... it takes a lot of time (I have some documents that have 600 pages). Additionally: a) I do not know how to handle efficiently the directory transformation part. b) I would like to add a page separator, let's say: <code>&lt;start/age = 1&gt; ... page content ... &lt;end/page = 1&gt;</code>, but I have no idea of how to do this.</p>
<p>Thus, how can I apply the <code>extract_txt</code> function to all the elements of a directory that end with <code>.pdf</code> and return the same files in another directory but in a <code>.txt</code> format, and add a page separator with OCR text extraction?.</p>
<p>Also, I was curios about using google docs to make this task, is it possible to programmatically use google docs to solve the aforementioned text extracting problem?.</p>
<p><strong>UPDATE</strong></p>
<p>Regarding the "adding a page separator" issue (<code>&lt;start/age = 1&gt; ... page content ... &lt;end/page = 1&gt;</code>) after reading Roland Smith's answer I tried to:</p>
<pre><code>from PyPDF2 import PdfFileWriter, PdfFileReader
import textract


def extract_text(pdf_file):
    inputpdf = PdfFileReader(open(pdf_file, "rb"))
    for i in range(inputpdf.numPages):
        w = PdfFileWriter()
        w.addPage(inputpdf.getPage(i))
        outfname = 'page{:03d}.pdf'.format(i)
        with open(outfname, 'wb') as outfile:  # I presume you need `wb`.
             w.write(outfile)
        print('\n&lt;begin page pos =' , i, '&gt;\n')
        text = textract.process(str(outfname), method='tesseract')
        os.remove(outfname)  # clean up.
        print(str(text, 'utf8'))
        print('\n&lt;end page pos =' , i, '&gt;\n')

extract_text('/Users/user/Downloads/ImageOnly.pdf')
</code></pre>
<p>However, I still have issues with the <code>print()</code> part, since instead of printing, it would be more useful to save into a file all the output. Thus, I tried to redirect the output to a a file:</p>
<pre><code>sys.stdout=open("test.txt","w")
print('\n&lt;begin page pos =' , i, '&gt;\n')
sys.stdout.close()
text = textract.process(str(outfname), method='tesseract')
os.remove(outfname)  # clean up.
sys.stdout=open("test.txt","w")
print(str(text, 'utf8'))
sys.stdout.close()
sys.stdout=open("test.txt","w")
print('\n&lt;end page pos =' , i, '&gt;\n')
sys.stdout.close()
</code></pre>
<p>Any idea of how to make the page extraction/separator trick and saving everything into a file?...</p>
</div>
<div class="post-text" itemprop="text">
<p>In your code, you are extracting the text, <em>but you don't do anything with it</em>.</p>
<p>Try something like this:</p>
<pre><code>def extract_txt(file_path):
    text = textract.process(file_path, method='tesseract')
    outfn = file_path[:-4] + '.txt'  # assuming filenames end with '.pdf'
    with open(outfn, 'wb') as output_file:
        output_file.write(text)
    return file_path
</code></pre>
<p>This writes the text to file that has the same name but a <code>.txt</code> extension.</p>
<p>It also returns the path of the original file to let the parent know that this file is done.</p>
<p>So I would change the mapping code to:</p>
<pre><code>p = multiprocessing.Pool()
file_path = ['/Users/user/Desktop/sample.pdf']
for fn in p.imap_unordered(extract_txt, file_path):
    print('completed file:', fn)
</code></pre>
<ul>
<li>You don't need to give an argument when creating a <code>Pool</code>. By default it will create as many workers as there are cpu-cores.</li>
<li>Using <code>imap_unordered</code> creates an iterator that starts yielding values as soon as they are available.</li>
<li>Because the worker function returned the filename, you can print it to let the user know that this file is done.</li>
</ul>
<hr/>
<p><strong>Edit 1</strong>:</p>
<p>The additional question is if it is possible to mark page boundaries. I think it is.</p>
<p>A method that would <em>surely</em> work is to split the PDF file into pages <em>before</em> the OCR. You could use e.g. <code>pdfinfo</code> from the poppler-utils package to find out the number of pages in a document. And then you could use e.g. <code>pdfseparate</code> from the same poppler-utils package to convert that one pdf file of N pages into N pdf files of one page. You could then OCR the single page PDF files separately. That would give you the text on each page separately.</p>
<p>Alternatively you could OCR the whole document and then search for page breaks. This will <em>only work</em> if the document has a constant or predictable header or footer on every page. It is probably not as reliable as the abovementioned method.</p>
<hr/>
<p><strong>Edit 2:</strong></p>
<p>If you need a file, <em>write</em> a file:</p>
<pre><code>from PyPDF2 import PdfFileWriter, PdfFileReader
import textract

def extract_text(pdf_file):
    inputpdf = PdfFileReader(open(pdf_file, "rb"))
    outfname = pdf_file[:-4] + '.txt' # Assuming PDF file name ends with ".pdf"
    with open(outfname, 'w') as textfile:
        for i in range(inputpdf.numPages):
            w = PdfFileWriter()
            w.addPage(inputpdf.getPage(i))
            outfname = 'page{:03d}.pdf'.format(i)
            with open(outfname, 'wb') as outfile:  # I presume you need `wb`.
                w.write(outfile)
            print('page', i)
            text = textract.process(outfname, method='tesseract')
            # Add header and footer.
            text = '\n&lt;begin page pos = {}&gt;\n'.format(i) + text + '\n&lt;end page pos = {}&gt;\n'.format(i)
            # Write the OCR-ed text to the output file.
            textfile.write(text)
            os.remove(outfname)  # clean up.
            print(text)
</code></pre>
</div>
<span class="comment-copy">All documents were failed to extract? Or only very slow to complete?</span>
<span class="comment-copy">Thanks for the help @thewaywewere both. After 2 hours I got: <code>[None]</code></span>
<span class="comment-copy">Then have you tried to OCR a PDF in command line by Tesseract?</span>
<span class="comment-copy">I tried with a shorter file (33 pages) and still the same issue.... No, could you provide an example of how to do that?..@thewaywewere</span>
<span class="comment-copy">@johndoe Do <i>not</i> redirect the standard streams! Just open a file and <i>write</i>  to it. Read the section on <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" rel="nofollow noreferrer">reading and writing files</a> in the Python tutorial. It's not difficult.</span>
<span class="comment-copy">@johndoe Then you must <code>decode</code> the bytes or write the file in binary mode.</span>
<span class="comment-copy">@johndoe See updated answer.</span>
<span class="comment-copy">@johndoe See updated answer.</span>
<span class="comment-copy">My solution already writes the extracted text for each page to its own file. It would be trivial to add text to the OCR output (using the <code>+</code> operator), but why would you want to to that? The file name already includes the page number...</span>
<span class="comment-copy">@johndoe Update your question with what you tried.</span>
