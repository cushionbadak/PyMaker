<div class="post-text" itemprop="text">
<p>I am monkey patching the <code>__eq__</code> method of a class. I found that the following works:</p>
<pre><code>   def eq(obj, other):
       if isinstance(other, str):
          return obj.name.upper() == other.upper()
       else:
          return object.__eq__(obj, other)
</code></pre>
<p>This does not work:</p>
<pre><code>  def eq(obj, other):
     if isinstance(other, str):
         return obj.name.upper() == other.upper()
     else:
        return super().__eq__(other)
</code></pre>
<p>This sometimes works, but sometimes raises and error:</p>
<pre><code>def eq(obj, other):
   if isinstance(other, str):
       return obj.name.upper() == other.upper()
   else:
       return super().__eq__(self, other)
</code></pre>
<p>The error:</p>
<pre><code>&lt;ipython-input-128-91287536205d&gt; in eq(obj, other)
      3         return obj.name.upper() == other.upper()
      4     else:
----&gt; 5         return super().__eq__(self, other)
      6 
      7 

RuntimeError: super(): __class__ cell not found
</code></pre>
<p>Can you explain what is going on here? How do I properly replace <code>object</code> with <code>super()</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't use <code>super()</code> without arguments in a function defined outside of a class. The <code>__class__</code> cell <code>super()</code> relies on is only provided for functions defined in a <code>class</code> body. From the <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super()</code> documentation</a>:</p>
<blockquote>
<p>The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods.</p>
</blockquote>
<p>Use the 2-argument form, naming the class explicitly:</p>
<pre><code>def eq(obj, other):
   if isinstance(other, str):
       return obj.name.upper() == other.upper()
   else:
       return super(ClassYouPutThisOn, obj).__eq__(other)

ClassYouPutThisOn.__eq__ = eq
</code></pre>
<p>This requires you to explicitly name the class in the monkey patch, making it less useful for reuse.</p>
<p>Instead, you can provide the required <code>__class__</code> cell <em>manually</em> by nesting <code>eq</code> in another function with <code>__class__</code> as a local name:</p>
<pre><code>def patch_eq(cls):
    __class__ = cls  # provide closure cell for super()
    def eq(obj, other):
       if isinstance(other, str):
           return obj.name.upper() == other.upper()
       else:
           return super().__eq__(other)
    cls.__eq__ = eq
</code></pre>
<p><code>super()</code> finds the second argument (reference to the instance), by taking the first local name from the calling frame (i.e. the first parameter passed into the function call, usually called <code>self</code>).</p>
<p>Also see <a href="https://stackoverflow.com/questions/19608134/why-is-python-3-xs-super-magic">Why is Python 3.x's super() magic?</a></p>
<p>Demo using the nested-function approach:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     name = 'bar'
...     def __eq__(self, other):
...         return False
...
&gt;&gt;&gt; Foo() == 'Bar'
False
&gt;&gt;&gt; Foo() == Foo()
False
&gt;&gt;&gt; patch_eq(Foo)
&gt;&gt;&gt; Foo() == 'Bar'
True
&gt;&gt;&gt; Foo() == Foo()
False
</code></pre>
</div>
<span class="comment-copy">There is no difference between your 'does not work' and 'sometimes works' examples, other than indentation. Both only 'sometimes' work as long as the <code>else</code> branch is not reached.</span>
<span class="comment-copy">Note that <code>super(...).__eq__</code> is a <i>bound method</i>, so the first argument (usually named <code>self</code>) is automatically passed in from the second argument to <code>super(cls, instance)</code>. You only need to pass in <code>other</code>: <code>super(...).__eq__(other)</code>.</span>
