<div class="post-text" itemprop="text">
<p>I got the following code from github about MRO and C3, and I don't quite understand the the last three lines, and what the difference among super().foo(), super(B,self).foo() and super(C,self).foo() in python3.x, code as follows:</p>
<pre><code>class A(object):

    def foo(self):
        print('foo of A')

class B(A):
    pass

class C(A):

    def foo(self):
        print('foo fo C')

class D(B, C):
    pass

class E(D):

    def foo(self):
        print('foo in E')
        super().foo()
        super(B, self).foo()
        super(C, self).foo()

if __name__ == '__main__':
    d = D()
    d.foo()
    e = E()
    e.foo()
</code></pre>
<p>the expected and actual results is as follow:</p>
<pre><code>foo fo C
foo in E
foo fo C
foo fo C
foo of A    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all, the form <code>super()</code> in Python 3 is really the same thing as <code>super(&lt;CurrentClass&gt;, self)</code>, where the Python compiler <a href="https://stackoverflow.com/questions/19608134/why-is-python-3-xs-super-magic/19609168#19609168">provides enough information for <code>super()</code> to determine what the correct class to use is</a>. So in <code>E.foo()</code>, <code>super().foo()</code> can be read as <code>super(E, self).foo()</code>.</p>
<p>To understand what is going on, you need to look at the <a href="https://docs.python.org/3/library/stdtypes.html#class.__mro__" rel="nofollow noreferrer"><code>class.__mro__</code> attribute</a>:</p>
<blockquote>
<p>This attribute is a tuple of classes that are considered when looking for base classes during method resolution.</p>
</blockquote>
<p>It is this tuple that shows you what the C3 <em>Method Resolution Order</em> is for any given class hierarchy. For your class <code>E</code>, that order is:</p>
<pre><code>&gt;&gt;&gt; E.__mro__
(&lt;class '__main__.E'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)
&gt;&gt;&gt; for cls in E.__mro__:  # print out just the names, for easier readability.
...     print(cls.__name__)
...
E
D
B
C
A
object
</code></pre>
<p>The <code>super()</code> object bases everything off from that ordered sequence of classes. The call</p>
<pre><code>super(SomeClass, self).foo()
</code></pre>
<p>results in the following series of steps:</p>
<ul>
<li>The <code>super()</code> object retrieves the <code>self.__mro__</code> tuple.</li>
<li><code>super()</code> locates the index for the <code>SomeClass</code> class in that tuple.</li>
<li>Accessing the <code>foo</code> attribute on the <code>super()</code> object triggers a search for a class that has a <code>foo</code> attribute on the MRO, <strong>starting at the next index after the <code>SomeClass</code> index</strong>.</li>
<li>If the attribute found this way is a <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor object</a> binds the attribute found this way to <code>self</code>. Functions are descriptors, binding produces a bound method, and this is how Python passes in the <code>self</code> reference when you call a method.</li>
</ul>
<p>Expressed as simplified Python code that ignores edge cases and other uses for <code>super()</code>,  that would look like:</p>
<pre><code>class Super:
    def __init__(self, type_, obj_or_type):
        self.mro = obj_or_type.__mro__
        self.idx = self.mro.index(type_) + 1
        self.obj_or_type = obj_or_type
    def __getattr__(self, name):
        for cls in self.mro[self.idx:]:
            attrs = vars(cls)
            if name in attrs:
                result = attrs[name]
                if hasattr(result, '__get__'):
                    result = result.__get__(obj_or_type, type(self.obj_or_type))
                return result
        raise AttributeError(name)
</code></pre>
<p>Combining those two pieces of information, you can see what happens when you call <code>e.foo()</code>:</p>
<ul>
<li><code>print('foo in E')</code> is executed, resulting in <em>foo in E</em></li>
<li><code>super().foo()</code> is executed, effectively the same thing as <code>super(E, self).foo()</code>.

<ul>
<li>The MRO is searched, starting at the next index <em>past</em> <code>E</code>, so at <code>D</code> (no <code>foo</code> attribute), moving on to <code>B</code> (no <code>foo</code> attribute), then <code>C</code> (attribute found). <code>C.foo</code> is returned, bound to <code>self</code>.</li>
<li><code>C.foo(self)</code> is called, resulting in <em>foo fo C</em></li>
</ul></li>
<li><code>super(B, self).foo()</code> is executed.

<ul>
<li>The MRO is searched, starting at the next index <em>past</em> <code>B</code>, so at <code>C</code> (attribute found). <code>C.foo</code> is returned, bound to <code>self</code>.</li>
<li><code>C.foo(self)</code> is called, resulting in <em>foo fo C</em></li>
</ul></li>
<li><code>super(C, self).foo()</code> is executed.

<ul>
<li>The MRO is searched, starting at the next index <em>past</em> <code>C</code>, so at <code>A</code> (attribute found). <code>A.foo</code> is returned, bound to <code>self</code>.</li>
<li><code>A.foo(self)</code> is called, resulting in <em>foo of A</em></li>
</ul></li>
</ul>
</div>
<span class="comment-copy">here's <code>E.__mro__</code>: <code>(&lt;class 'SO54756219.E'&gt;, &lt;class 'SO54756219.D'&gt;, &lt;class 'SO54756219.B'&gt;, &lt;class 'SO54756219.C'&gt;, &lt;class 'SO54756219.A'&gt;, &lt;class 'object'&gt;)</code></span>
<span class="comment-copy">It is very clear of the explanation to MRO and C3, thanks a lot..</span>
