<div class="post-text" itemprop="text">
<p>What would I write to iterate over a string and for each letter, if that letter is in a given dictionary (as a key), then add that key's value to an empty list?</p>
<p>For example the string 'cat', I want to search a given dictionary for c, a, and t. Then for each value of each letter, add them to a new list that is a sum of points (values).</p>
<p>I keep getting: TypeError: 'NoneType' object is not iterable</p>
<p>Here's what I have so far:</p>
<pre><code>user_word = cat

values_dict = {'A' : 1, 'E' : 1, 'I' : 1, 'O' : 1, 'U' : 1, 'L' : 1,\
              'N' : 1, 'N' : 1, 'S' : 1, 'T' : 1, 'R' : 1,\
              'D' : 2, 'G' : 2, 'B' : 3, 'C' : 3, 'M' : 3, 'P' : 3,\
              'F' : 4, 'H' : 4, 'V' : 4, 'W' : 4, 'Y' : 4,\
              'K' : 5, 'J' : 8, 'X' : 8, 'Q' : 10, 'Z' : 10,}

def get_word_value(user_word, values_dict):
    word_pts = 0

    for letter in user_word.upper():
        for key, value in values_dict.items:
            for letter in range(value):
                word_pts = word_pts + values_dict[letter]

                print(word_pts, 'TEST GOOD')
    return word_pts

# expected result is 5 (3+1+1= 5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a one liner:</p>
<p><code>sum([values_dict[letter] for letter in user_word.upper()])</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest you to use  </p>
<p><code>sum([values_dict.get(letter, 0) for letter in user_word.upper()])</code></p>
<p>This will avoid error if the key is not found.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>TypeError: 'NoneType' object is not iterable</code> is due to line 
<code>for key, value in values_dict.items:</code>.</p>
<p><code>dict.items</code> is a function and not an iterable. To access the actual values, use the parenthesis to iter over the key and values: <code>for key, value in values_dict.items():</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is your code corrected : </p>
<pre><code>    user_word = "cat"

    values_dict = {'A' : 1, 'E' : 1, 'I' : 1, 'O' : 1, 'U' : 1, 'L': 1,
                  'N' : 1, 'S' : 1, 'T' : 1, 'R' : 1,
                  'D' : 2, 'G' : 2, 'B' : 3, 'C' : 3, 'M' : 3, 'P': 3,
                  'F' : 4, 'H' : 4, 'V' : 4, 'W' : 4, 'Y' : 4,
                  'K' : 5, 'J' : 8, 'X' : 8, 'Q' : 10, 'Z' : 10}


    def get_word_value(user_word, values_dict):
        word_pts = 0

        for letter in user_word.upper():
            for key, value in zip(values_dict.keys(), values_dict.values()):
                if letter == key:
                    word_pts += value

        print('Word pts : {} , TEST GOOD'.format(word_pts))
        return word_pts
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the operator <code>itemgetter()</code>. Itâ€˜s faster than a list comprehension:</p>
<pre><code>from operator import itemgetter

d = {'A': 1, 'T': 1, 'C': 3, 'E': 1}

w = 'cat'
sum(itemgetter(*w.upper())(d))
# 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>user_input = raw_input("Enter Your Word: ")
user_input = user_input.upper()
wordArray = list(user_input)

values_dict = {'A' : 1, 'E' : 1, 'I' : 1, 'O' : 1, 'U' : 1, 'L' : 1,
              'N' : 1, 'N' : 1, 'S' : 1, 'T' : 1, 'R' : 1,
              'D' : 2, 'G' : 2, 'B' : 3, 'C' : 3, 'M' : 3, 'P' : 3,
              'F' : 4, 'H' : 4, 'V' : 4, 'W' : 4, 'Y' : 4,
              'K' : 5, 'J' : 8, 'X' : 8, 'Q' : 10, 'Z' : 10,}

def get_word_value(wordArray, values_dict):
    word_pts = 0
    for letter in wordArray:
        word_pts = word_pts + values_dict[letter]

    print "Word Points: %d, Test Good." % word_pts
get_word_value(wordArray, values_dict)
</code></pre>
</div>
<span class="comment-copy">First, you need to use <code>for key, value in values_dict.items()</code> - so <code>values_dict.items()</code> must be called as method. Then, <code>for letter in range(value)</code> I guess is not correct, because <code>value</code> is scalar (it is value in dictionary, which you iterate over)...</span>
<span class="comment-copy">Thank you! Now i'm getting TypeError: 'NoneType' object is not subscriptable</span>
<span class="comment-copy">This will be thrown if values_dict is None. Are you sure you are initializing it correctly? If you are still facing issue, update the question with the code you tried.</span>
<span class="comment-copy">Yes! You are a lifesaver, thank you so much. You were right, the dictionary in my code was stored in a function, and like an idiot I forgot to write return values_dict in that function so I don't think it was properly initialized like you said. You're awesome</span>
<span class="comment-copy">Allowing it to raise a KeyError may be better. It ensures that <code>user_word</code> only contains letters and that the dictionary has the full alphabet.</span>
<span class="comment-copy">hmmm for this i'm now getting AttributeError: 'NoneType' object has no attribute 'items'</span>
<span class="comment-copy">That typo should have led to an error like <code>TypeError: 'builtin_function_or_method' object is not iterable</code>. I think OP must have written <code>for key, value in values_dict:</code> at some point and didn't update their error message after changing the code.</span>
<span class="comment-copy">Thank you! With this I'm getting the highlighted red box at the end of the print function and it's not running? "unindent does not match any outer indentation level"</span>
<span class="comment-copy">Ok, it depends on the python version you have but try changing {} into {0}. Maybe this will help : <a href="https://docs.python.org/3/library/string.html#formatstrings" rel="nofollow noreferrer">docs.python.org/3/library/string.html#formatstrings</a></span>
