<div class="post-text" itemprop="text">
<p>I hope this isn't a duplicate but I know I'm so close to figuring this out, I just can't quite get the last bit.</p>
<p>I have this issue in Python of running two functions simultaneously. I need to run "top" (linux command) as well as execute each new command in parallel. Here is an example.</p>
<p>A quick discord bot I'm trying to whip up:</p>
<pre><code>import subprocess
import discord

@client.event #Event listener
def on_message(message):
   if message.content.startswith('top'):
       subprocess.call(['top'])
</code></pre>
<p>Now, this snippet will do what I want, it'll call a child process of top and leave it running. The problem is that I can't run another subprocess in this same way. If I add this code:</p>
<pre><code>@client.event #Event listener
def on_message(message):
   if message.content.startswith('top'):
       subprocess.call(['top'])

   if message.content.startswith('kill top')
       subprocess.call('killall', 'top')
</code></pre>
<p>It's a simple example, but It's the same with any program that needs to be left running.</p>
<p>Any attempt to run the second command after already starting top, it will crash the bot and I'm not able to retrieve an error message. My thought is either it's a design within the discord library that I'm not seeing, or I need to incorporate multi-threading somehow, although I'm unsure of the best place to start.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a function to handle asynchronous subprocess in <code>asyncio</code>. You may use this library because you are working on <code>discord.py</code>, so i recommend you to use it.</p>
<p>Reference : <a href="https://docs.python.org/3/library/asyncio-subprocess.html" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio-subprocess.html</a></p>
<pre><code>@client.event
def on_message(message):
    if message.content.startswith('top'):
        proc = await asyncio.create_subprocess_shell(
            'top',
            stdout=asyncio.subprocess.PIPE
            stderr=asyncio.subprocess.PIPE)
        stdout, stderr = await proc.communicate()

    if message.content.startswith('kill top'):
        proc = await asyncio.create_subprocess_shell(
            'killall top',
            stdout=asyncio.subprocess.PIPE
            stderr=asyncio.subprocess.PIPE)
        stdout, stderr = await proc.communicate()
</code></pre>
</div>
<span class="comment-copy">I think that last line should have a list as arg, i.e, <code>subprocess.call(['killall', 'top'])</code></span>
<span class="comment-copy">The thing is that I can't have the function waiting on the top command to terminate, instead I need it to run independently so it can be killed.</span>
