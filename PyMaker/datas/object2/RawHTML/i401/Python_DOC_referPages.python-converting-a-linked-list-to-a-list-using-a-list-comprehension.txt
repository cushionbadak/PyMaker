<div class="post-text" itemprop="text">
<p>Let's say I have a simple <code>linked list</code> implementation using a dictionary called child that associates a node with the following node in the linked list. </p>
<p>For example:</p>
<pre><code> a-&gt;b-&gt;c-&gt;d
</code></pre>
<p>Would be :</p>
<pre><code> {a:b,b:c,c:d,d:None}
</code></pre>
<p>Converting this to a normal list is trivial, </p>
<pre><code>myList=[]
node=a
while node!=None:
    myList.append(node)
    node=child[node]
</code></pre>
<p>I'm struggling to come up with any way this would be possible with a list comprehension. Is there no way?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Summary:</strong> List comprehensions are designed around for-loops rather than while-loops, so this isn't a good fit.</p>
<p><strong>What would be needed:</strong> The for-loop requires an <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">iterator</a> for input.</p>
<p><strong>Alternative 1:</strong> This could work with a list comprehension, but that would entail shifting the work into a <a href="https://docs.python.org/3/glossary.html#term-generator" rel="nofollow noreferrer">generator</a> (which likely isn't what you were hoping for):</p>
<pre><code>&gt;&gt;&gt; child = {'a':'b', 'b': 'c', 'c': 'd', 'd': None}
&gt;&gt;&gt; def ll_iterator(node):
        while node != None:
            yield node
            node = child[node]

&gt;&gt;&gt; [x for x in ll_iterator('a')]
['a', 'b', 'c', 'd']
</code></pre>
<p><strong>Alternative 2:</strong> Besides generators, another way to make an iterator is to use the two argument form of <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer">iter()</a>.  For that to work, you would need a stateful, zero-argument function that emitted successive linked list nodes:</p>
<pre><code>&gt;&gt;&gt; child = {'a':'b', 'b': 'c', 'c': 'd', 'd': None}
&gt;&gt;&gt; def next_ll(state=['a']):
        value = state[0]
        if value is not None:
            state[0] = child[value]
            return value

&gt;&gt;&gt; [x for x in iter(next_ll, None)]
['a', 'b', 'c', 'd']
</code></pre>
<p><strong>Assessment:</strong> Both of these alternatives are a bit gross, so you're better-off without the <a href="https://docs.python.org/3/glossary.html#term-list-comprehension" rel="nofollow noreferrer">list comprehension</a>.  Simple, straight-forward code is the best :-)</p>
<p><strong>Footnote:</strong> This question is a good one.  More than one person has suggested that the language add while-loop comprehensions.  If that suggestion ever came to fruition, Python 3.8's adoption of <a href="https://www.python.org/dev/peps/pep-0572/" rel="nofollow noreferrer">assignment expressions</a> would also help for your use case.</p>
</div>
