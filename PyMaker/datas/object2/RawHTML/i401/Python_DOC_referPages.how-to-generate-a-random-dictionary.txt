<div class="post-text" itemprop="text">
<p>I need to create a dictionary with key and random values given a scope, i.e.</p>
<pre><code>{key 1: value1, key 2: value2, key 3: value1, key 4: value 1, key 5: value 1}
</code></pre>
<p>or</p>
<pre><code>{key 1: value2, key 2: value1, key 3: value1, key 4: value 1, key 5: value 1}
</code></pre>
<p>or</p>
<pre><code>{key 1: value1, key 2: value1, key 3: value1, key 4: value 1, key 5: value 2}
</code></pre>
<p>...and so on</p>
<p>As you can see, the dictionary has the pattern below:</p>
<ul>
<li>the key is generated from the input number of the function, if I input 5, I have 5 keys, if I input 3, I have 3 keys</li>
<li>the value has only 2 different values (<code>value1</code> and <code>value2</code>), but <code>value2</code> can only appear 1 time randomly in any key. The remaining values will be <code>value1</code>.</li>
</ul>
<p>Code:</p>
<pre><code>def function(n):
   from random import randrange
   mydict = {}
   for i in range(5):
         key = "key " + str(i)

   value = ['value1', 'value2']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just default all the values to <code>value1</code> first, and then randomly pick one key to change to <code>value2</code>:</p>
<pre><code>def function(n):
   from random import randrange
   values = ['value1', 'value2']
   mydict = {"key " + str(i): values[0] for i in range(n)}
   mydict["key " + str(random.randrange(n))] = values[1]

   return mydict
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply try this:</p>
<pre><code>&gt;&gt;&gt; def func(n):
...   mydict = {}
...   for i in range(n):
...     mydict['key'+str(i)] = randrange(10)
...   return mydict
... 
&gt;&gt;&gt; print(func(5))
{'key0': 8, 'key1': 2, 'key2': 4, 'key3': 4, 'key4': 7}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>similar to @Idlehands, but parametrized for n and actually returns the dict</p>
<pre><code>def function(n):
    from random import randrange, randint
    mydict = {'key'+str(i):'value1' for i in range(n)}
    mydict['key'+str(randint(0,n-1))] = 'value2'
    return mydict

print(function(5))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the fastest way would be to use the built-in <a href="https://docs.python.org/3/library/stdtypes.html#dict.fromkeys" rel="nofollow noreferrer"><code>dict.fromkeys()</code></a> classmethod to create a dictionary full of <code>value1</code> entries and then randomly change one of them.</p>
<pre><code>import random

def function(n):
   mydict = dict.fromkeys(("key "+ str(i) for i in range(n)), 'value1')
   mydict["key "+ str(random.randrange(n))] = 'value2'  # Change one value.
   return mydict

print(function(3))  # -&gt; {'key 0': 'value1', 'key 1': 'value1', 'key 2': 'value2'}
print(function(5))  # -&gt; {'key 0': 'value2', 'key 1': 'value1', 'key 2': 'value1', 'key 3': 'value1', 'key 4': 'value1'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your question is not terribly clear to me, but I think this is what you are trying to do:</p>
<pre><code>   from random import randrange
   mydict = {}
   value = ['value1', 'value2', 'v3', 'v4', 'v5']

   for i in range(5):
         key = "key " + str(i)
         mydict.update(key: value[i])
</code></pre>
<p>Your list either has to be 5 values long (or more) or your for loop has to iterate only twice.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do it with a <code>dict</code> comprehension and <code>numpy.random</code>:</p>
<pre class="lang-py prettyprint-override"><code>def create_dict(size=5):
    values = ['value_1', 'value2']

    # choose our index randomly
    x = lambda x: np.random.randint(1, len(values)+1)

    # the 1 in x() is a dummy input var
    return {"key %d"%i: values[x(1)] for i in range(size)}

</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are already a few options, but this is what I came up with:</p>
<pre><code>import random
def my_function(n):
    mydict = {}
    value2_index = random.randint(0, n-1)
    for i in range(n):
        key = "key " + str(i)
        if i == value2_index:
            value = ['value2']
        else:
            value = ['value1']
        mydict.update({key: value})
    return mydict
thing = my_function(5)
print(thing)
</code></pre>
<p>It's not the cleanest or most beautiful, but I think it makes sense and is easily readable!</p>
<p>Running it once gave me:</p>
<blockquote>
<p>{'key 3': ['value1'], 'key 4': ['value1'], 'key 2': ['value1'], 'key 1': ['value2'], 'key 0': ['value1']}</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>def randDict(n):
    from random import randint

    keys  = ["key"+str(i) for i in range(n)]
    values = ["value"+str(i) for i in range(n)]
    final_dict={}
    for key in keys:
        final_dict[key]=values.pop(randint(0,n))

    return final_dict
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also increase another wrinkle of randomness as shown below:</p>
<pre><code>from random import randint, sample

def pseudo_rand_dict(n):
    d = dict()
    r = randint(n, n ** n)
    for i in range(n):
        d[f'key_{i}'] = r
    to_change = sample(d.keys(), 1)[0]
    d[to_change] = randint(n, n * r)
    return d

d = pseudo_rand_dict(5)

print(d)

{'key_0': 2523, 'key_1': 2523, 'key_2': 2523, 'key_3': 9718, 'key_4': 2523}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can pick a number first, and then use a dict comprehension to generate the desired dict with values based on whether the index is equal to the picked number or not:</p>
<pre><code>def function(n):
    pick = randrange(n)
    return {'key %d' % i: ('value1', 'value2')[i == pick] for i in range(n)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just for fun:</p>
<pre><code>import random
n = 4
v1, v2 = 1, 2
res = dict(zip([ f"key{n}" for n in [x for x in range(1,n+1)] ], [ f"value{n}" for n in sorted([v1 for _ in range(n-1)] + [v2], key=lambda k: random.random()) ]))
</code></pre>
</div>
<span class="comment-copy">Is there any constraint on the number of key-value pairs that will be present in the dict?</span>
<span class="comment-copy">@Idlehands The OP hasn't mentioned the total number of key-value pairs to be generated.</span>
<span class="comment-copy">@taurus05 The number of keys would be dynamic based on description, but the constraint is that there will always be two values, and only one of them will be <code>value2</code>.  If the conditions are changed we can revisit this solution.</span>
<span class="comment-copy">Thanks. I made some changes and now it works!!  def function(n):     from random import randrange     import random      mydict = {}     mydict = {"key " + str(i): 'value1' for i in range(1,n+1)}     mydict["key "+ str(random.randrange(1,n+1))] = 'value2'     return mydict</span>
<span class="comment-copy">You could also just use <code>str(random.randrange(n)+1)</code> as well :)</span>
<span class="comment-copy">Is <code>fromkeys</code> more efficient than a dict comprehension? Genuinely curious.</span>
<span class="comment-copy">@Idlehands: I haven't actually timed the two, but <code>fromkeys()</code> is written in C, so is likely faster. Using Python's built-ins whenever possible is often a good way to improve performance.</span>
<span class="comment-copy">You piqued my interest, so I timed it.  For a dict generation of 100 keys with <code>n=1000000</code> trial, the performance between <code>fromkeys</code> (53.68s) and dict comp (54.38s) are relatively comparable.  IIRC comprehensions uses C code too so it should be similar.</span>
<span class="comment-copy">@Idlehands: I guess that doesn't surprise me too much in this particular case because it's still generating the keys iteratively using user-supplied (i.e. relatively-slow interpreted) Python code.</span>
