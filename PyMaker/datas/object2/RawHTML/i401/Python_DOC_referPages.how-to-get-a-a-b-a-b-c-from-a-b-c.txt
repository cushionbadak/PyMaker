<div class="post-text" itemprop="text">
<p>How can I go from this structure</p>
<pre><code>&gt;&gt;&gt; input = ['a', 'b', 'c']
</code></pre>
<p>to this one</p>
<pre><code>&gt;&gt;&gt; output 
['a', 'a/b', 'a/b/c']
</code></pre>
<p>in an elegant (functional) way?</p>
<p>For now I have this:</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; res = []
&gt;&gt;&gt; for i in range(len(input)):
...     res.append(reduce(lambda a, b: a + '/' + b, input[:i+1]))
... 
&gt;&gt;&gt; res
['a', 'a/b', 'a/b/c']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer">itertools.accumulate()</a>:</p>
<pre><code>from itertools import accumulate
l = ['a', 'b', 'c']
print(list(accumulate(l, '{}/{}'.format)))
</code></pre>
<p>This outputs:</p>
<pre><code>['a', 'a/b', 'a/b/c']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this using a simple list comprehension.</p>
<pre><code>l = ['a', 'b', 'c']
['/'.join(l[:i]) for i in range(1, len(l)+1)]
# ['a', 'a/b', 'a/b/c']
</code></pre>
<hr/>
<p>If performance is important, you can roll out your own implementation of <code>accumulate</code>:</p>
<pre><code>out = [l[0]]
for l_ in l[1:]:
    out.append('{}/{}'.format(out[-1], l_))

out
# ['a', 'a/b', 'a/b/c']
</code></pre>
<p>This turns out to be slightly faster than <code>itertools</code> for the given problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should work:</p>
<pre><code>l = ['a', 'b', 'c']
new_list =[]
for i in range(len(l)):
    new_list.append("/".join([a for a in l[:i+1]]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you must use reduce you could do it like this:</p>
<pre><code>from functools import reduce

input = ['a', 'b', 'c']
output =  [reduce(lambda a, b: f"{a}/{b}", input[:n + 1]) for n in range(0, len(input))]
</code></pre>
<p>I prefer the built in join function:</p>
<pre><code>output =  ['/'.join(input[:n + 1]) for n in range(0, len(input))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>count</code> to slice a string in steps:</p>
<pre><code>from itertools import count

input = ['a', 'b', 'c']

s = '/'.join(input)
c = count(1, 2)
[s[:next(c)] for _ in input]
# ['a', 'a/b', 'a/b/c']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>a recursive solution:</p>
<p>The idea is quite simple, we use divide and conquer. 
Problem can be solved if we know the answer to the first n-1 string(or char), in this case, what we need to do is just collect all the characters in one string and separate them by '/'('a/b/c' in this case). </p>
<p>we pass an empty list as the 2nd parameter to store the result.</p>
<pre><code>input = ['a', 'b', 'c']

def foo(list1, list2):
    if (len(list1) == 0):
        return list2
    else:
        s = list1[0]
        for char in list1[1:]:
            s += '/' + char
        list2.insert(0, str)
        return foo(list1[:-1], list2)
</code></pre>
<p><code>&gt;&gt;&gt; foo(input, [])</code></p>
<pre><code>['a', 'a/b', 'a/b/c']
</code></pre>
</div>
<span class="comment-copy">what have you tried so far? Do you need these as just strings? If so, as a hint, take a look at string formatting.</span>
