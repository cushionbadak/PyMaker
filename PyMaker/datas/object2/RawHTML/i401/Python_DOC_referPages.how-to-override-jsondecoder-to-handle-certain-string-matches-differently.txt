<div class="post-text" itemprop="text">
<p>I want to change certain values in a json file (nested dicts and arrays). I thought a handy way to do that would be to take advantage of the JSONDecoder.</p>
<p>However, it's not working as I'd expect it to. I've done this exact same approach for getting JSONEncoder to convert np.arrays to lists so it wouldn't break the encoder.</p>
<p>After not getting it to do what I wanted, I thought maybe to try the Decoder instead. Same issue, it never calls default for handling strings it seems. Maybe <code>default</code> is never called when handling a string, just when handling other types of objects?</p>
<pre><code># key, val are arguments passed in, e.g. ("bar", "2.0rc1")
# Replace the value "2.0rc1" everywhere the "bar" key is found

class StringReplaceDecoder(json.JSONDecoder):
    def default(self, obj):
        if isinstance(obj, str):
            print("Handling obj str: {}".format(obj))
            if obj == key:
                return val
        return json.JSONEncoder.default(self, obj)


json_dump = json.dumps(dict)
json_load = json.loads(json_dump, cls=StringReplaceDecoder)

# Example input
{a:{foo:"", bar:"1.3"}, b:{d:{foo:""}, z:{bar:"1.5"}}}
# Example desired output:
{a:{foo:"", bar:"2.0rc1"}, b:{d:{foo:""}, z:{bar:"2.0rc1"}}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After finding a solution that worked, I found a far superior one liner that didn't come up in previous google searches.</p>
<p>The correct answer for my problem is <code>from nested_lookup import nested_update</code></p>
<p>For what it's worth, I also found the object_hook did exactly what I wanted as well:</p>
<pre><code>def val_hook(obj):
    return_d = {}
    if isinstance(obj, dict):
        for k in obj:
            if in_key == k:
                return_d[k] = in_val
            else:
                return_d[k] = obj[k]
        return return_d
    else:
        return obj

json_dump = json.dumps(in_dict)
json_load = json.loads(json_dump, object_hook=val_hook)
</code></pre>
<p>References</p>
<ul>
<li><a href="https://gist.github.com/douglasmiranda/5127251" rel="nofollow noreferrer">https://gist.github.com/douglasmiranda/5127251</a></li>
<li><a href="https://github.com/russellballestrini/nested-lookup" rel="nofollow noreferrer">https://github.com/russellballestrini/nested-lookup</a></li>
<li><a href="https://pypi.org/project/nested-lookup/" rel="nofollow noreferrer">https://pypi.org/project/nested-lookup/</a></li>
</ul>
</div>
<span class="comment-copy">After some testing and looking at the source, I'm almost sure the behavior is that default is never entered for string types. So that method that worked great for np.ndarray types is not going to work here. So is there another way to get custom behavior on particular strings?</span>
<span class="comment-copy">You could create your own "string-like" type (not derived from <code>str</code>) and override what the default encoder does when an instance of one of them is encountered. Also see <a href="https://stackoverflow.com/questions/54370322/how-to-set-the-number-of-float-digits-jsonencoder-produces">How to set the number of float digits JSONEncoder produces?</a>.</span>
<span class="comment-copy">Firstly, your example subclasses <code>JSONDecoder</code>, which does not have a <code>default</code> method (because it only parses json-encoded strings). Secondly, the <code>default</code> method of <code>JSONEncoder</code> is only called for objects which <b><i>aren't</i></b> automatically supported (so not for <code>str</code>, <code>int</code>, <code>list</code>, etc). This is all explained pretty clearly in the <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder" rel="nofollow noreferrer">json docs</a>. I therefore suggest you forget about <code>json</code> and just write a simple recursive function that understands your particular data-structure.</span>
<span class="comment-copy">Ah thanks for that. Makes sense only the encoder has a default.</span>
<span class="comment-copy">I find this all a bit baffling. Why resort to such hackery for something so simple? Sane solution: <code>def func(d): for k, v in d.items(): if in_key == k: d[k] = in_val; elif isinstance(v, dict): func(v)</code>. No need to use <code>json</code> at all.</span>
<span class="comment-copy">You are absolutely right for the stupid way I worded the opening question as "Nested dict". What I meant to say was valid json, so "nested dict/array". I edited the original question to reflect what I was really after. Sorry. And good tip, thanks!</span>
