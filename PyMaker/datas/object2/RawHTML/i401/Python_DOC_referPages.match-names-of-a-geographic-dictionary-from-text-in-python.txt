<div class="post-text" itemprop="text">
<p>I have a list of GeoNames city names I use to export place names from a table of text. How can I match a multi-segment name (e.g. "Santa Barbara", "Los Angeles", etc.) from the list of city names with the text? Cities names that have more than one word are not recognized.</p>
<p>The code which I have tried is:</p>
<pre><code>import csv
import time

#import tab-delimited keywords file
f = open('cities_key.txt','r')
allKeywords = f.read().lower().split(\n)
f.close()
#print(len(allKeywords))

allTexts = []
fullRow = []
with open('adrl_title_desc.csv') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        #the full row for each entry, which will be used to recreate the improved CSV file in a moment
        fullRow.append((row['title'], row['description']))

        #the column we want to parse for our keywords
        row = row['description'].lower()
        allTexts.append(row)
        #print(len(row))

#a flag used to keep track of which row is being printed to the CSV file
counter = 0

#use the current date and time to create a unique output filename
timestr = time.strftime(%Y-%m-%d-(%H-%M-%S))
filename = 'output-' + str(timestr) + '.csv'

#Open the new output CSV file to append ('a') rows one at a time.
with open(filename, 'a') as csvfile:

    #define the column headers and write them to the new file
    fieldnames = ['title', 'description', 'place']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()

    #define the output for each row and then print to the output csv file
    writer = csv.writer(csvfile)

    #this is the same as before, for currentRow in fullRow:
    for entry in allTexts:

        matches = 0
        storedMatches = []

        #for each entry:
        #HOW TO RESOLVE MULTI-PART NAMES? e.g. Santa Barbara
        allWords = entry.split(' ')
        for words in allWords:

            #remove punctuation that will interfere with matching
            words = words.replace(',', '')
            words = words.replace('.', '')
            words = words.replace(';', '')

            #if a keyword match is found, store the result.
            if words in allKeywords:
                if words in storedMatches:
                    continue
                else:
                    storedMatches.append(words)
                matches += 1

        #send any matches to a new row of the csv file.
        if matches == 0:
            newRow = fullRow[counter]
        else:
            matchTuple = tuple(storedMatches)
            newRow = fullRow[counter] + matchTuple

        #write the result of each row to the csv file
        writer.writerows([newRow])
        counter += 1

</code></pre>
<p><strong>City names:</strong></p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/Yxgnkm.png"/></p>
<p><strong>Description:</strong> </p>
<p><img src="https://i.stack.imgur.com/WUIRt.jpg" width="400"/></p>
</div>
<div class="post-text" itemprop="text">
<p>Good work putting the effort before asking for help. Here are my changes to your code. I retained your code and commented it out so that you know what I was doing. Using regular expressions is the best bet for you in this situation. I am using the same loops as you used. I did not split the description. Instead, I ran through the entire description looking for the city names using the regular expression module. I also did not use list for storedMatches. Using a set will make sure you are not adding duplicates. Checking if the city was already added is one more check you don't need. I used Python 3.7.</p>
<p>I used <code>import re</code> to import the regular expression module.</p>
<pre><code>import csv
import time
#Raj006 import regular expression module
import re

#import tab-delimited keywords file
f = open('cities_key.txt','r')
#Raj006 Not making the keywords lower. Will match with lower using regex
#allKeywords = f.read().lower().split('\n')
allKeywords = f.read().split('\n')
f.close()
#print(len(allKeywords))

allTexts = []
fullRow = []
with open('adrl_title_desc.csv') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        #the full row for each entry, which will be used to recreate the improved CSV file in a moment
        fullRow.append((row['title'], row['description']))

        #the column we want to parse for our keywords
        #row = row['description'].lower()
        #Raj006 not making description lower as regular expression takes care of case-insensitive search.
        row = row['description']
        allTexts.append(row)
        #print(len(row))

#a flag used to keep track of which row is being printed to the CSV file
counter = 0

#use the current date and time to create a unique output filename
timestr = time.strftime("%Y-%m-%d-(%H-%M-%S)")
filename = 'output-' + str(timestr) + '.csv'

#Open the new output CSV file to append ('a') rows one at a time.
with open(filename, 'a') as csvfile:

    #define the column headers and write them to the new file
    fieldnames = ['title', 'description', 'place']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()

    #define the output for each row and then print to the output csv file
    writer = csv.writer(csvfile)

    #this is the same as before, for currentRow in fullRow:
    for entry in allTexts:

        #matches = 0
        #Raj006 Changed this to set to make sure the list is unique (which is basically the definiton of the set)
        storedMatches = set()
        #Raj006 looping through all cities and checking if the city name exists in the description.
        #Raj006 re.search looks for the lookup word in the entire string (re.search(lookupword,string)).
        for eachcity in allKewords:
            if re.search('\\b'+eachcity+'\\b',entry,re.IGNORECASE):
                #Adding the matched city to the set
                storedMatches.add(eachcity)
        #for each entry:
        #HOW TO RESOLVE MULTI-PART NAMES? e.g. Santa Barbara
        #allWords = entry.split(' ')
        #for words in allWords:

            #remove punctuation that will interfere with matching
            #words = words.replace(',', '')
            #words = words.replace('.', '')
            #words = words.replace(';', '')

            #if a keyword match is found, store the result.
            #if words in allKeywords:
                #if words in storedMatches:
                    #continue
                #else:
                    #storedMatches.append(words)
                #matches += 1

        #send any matches to a new row of the csv file.
        #if matches == 0:
        #Raj006 Just using the length of the set to determine if any matches found. Reducing one more unnecessary check.
        if len(storedMatches)==0:
            newRow = fullRow[counter]
        else:
            matchTuple = tuple(storedMatches)
            newRow = fullRow[counter] + matchTuple

        #write the result of each row to the csv file
        writer.writerows([newRow])
        counter += 1
</code></pre>
<p>Update: Added ignore case to re.search.</p>
<p>I improved the code above to remove unnecessary loops and confusion in variable names. I don't have the source file, so couldn't test it. If I find any issues, I will update it later.</p>
<pre><code>import csv
import time
import re
allCities = open('cities_key.txt','r').readlines()
timestr = time.strftime("%Y-%m-%d-(%H-%M-%S)")
with open('adrl_title_desc.csv') as descriptions,open('output-' + str(timestr) + '.csv', 'w', newline='') as output:
    descriptions_reader = csv.DictReader(descriptions)
    fieldnames = ['title', 'description', 'cities']
    output_writer = csv.DictWriter(output, delimiter='|', fieldnames=fieldnames)
    output_writer.writeheader()
    for eachRow in descriptions_reader:
        title = eachRow['title']
        description = eachRow['description']
        citiesFound = set()
        for eachcity in allCities:
            eachcity=eachcity.strip()
            if re.search('\\b'+eachcity+'\\b',description,re.IGNORECASE):
                citiesFound.add(eachcity)
        if len(citiesFound)&gt;0:
            output_writer.writerow({'title': title, 'description': description, 'cities': ", ".join(citiesFound)})
</code></pre>
<p>This code has the csv delimiter set to <code>|</code> instead of a <code>,</code>, as I was using it for cities.</p>
<p>Test files.
cities_key.txt</p>
<pre><code>San Francisco
San Gabriel
San Jacinto
San Jose
San Juan Capistrano
Haiti
San Mateo
</code></pre>
<p>adrl_title_desc.csv</p>
<pre><code>key,title,description
1,title1,"some description here with San Francisco"
2,title2,"some, more description here with Haitian info"
3,title3,"some city not a wordSan Mateo"
4,title4,"some city San Juan Capistrano just normal"
5,title5,"multiple cities in one San Jacinto,San Jose and San Gabriel end"
</code></pre>
<p>Code output</p>
<pre><code>title|description|cities
title1|some description here with San Francisco|San Francisco
title4|some city San Juan Capistrano just normal|San Juan Capistrano
title5|multiple cities in one San Jacinto,San Jose and San Gabriel end|San Jacinto, San Jose, San Gabriel
</code></pre>
<p>@itsme, now, this should not go wrong with Python 3.x. I fixed the error with <code>'\\b'+eachcity+'\\b'</code> (missed + sign). You were not able to find any matches because when you use <code>readlines()</code> for some reason it retains line endings. I used <code>strip()</code> to remove them. I had to use <code>newline=''</code> in open file dialogue as the csv writer was creating a new line after each row. You can see that in my sample, you can't find a city for key 2 and key 3 as the cities were not separated as words from the rest of the text.</p>
</div>
<span class="comment-copy">I updated my code for re.search to just look for words instead of a substring. Check the documentation on Python site <a href="https://docs.python.org/3/library/re.html#re.search" rel="nofollow noreferrer">docs.python.org/3/library/re.html#re.search</a>.</span>
<span class="comment-copy">Updated code gives an error <code>'\\b'+eachcity'\\b'</code> of  <code>'</code></span>
<span class="comment-copy">It is running fine on my machine with two backslashes. What is the actual error message?</span>
<span class="comment-copy">ok I have run this code  and in a output file  just this is show in Ist cell " title|description|cities "</span>
<span class="comment-copy">Updated code, and tested. Provided the test files and output.</span>
