<div class="post-text" itemprop="text">
<p>If I try to do:</p>
<pre><code>from base64 import b64encode
b64encode('ffffff')
</code></pre>
<p>I get this error:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;pyshell#13&gt;", line 1, in &lt;module&gt;
    base64.b64encode('ffffff')
  File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/base64.py", line 58, in b64encode
    encoded = binascii.b2a_base64(s, newline=False)
TypeError: a bytes-like object is required, not 'str'
</code></pre>
<p>Because it said bytes-like object I then tried this:</p>
<pre><code>b64encode(bytes('ffffff'))
</code></pre>
<p>Which failed.</p>
<pre><code>Traceback (most recent call last):
  File "&lt;pyshell#10&gt;", line 1, in &lt;module&gt;
    b64encode(bytes('ffffff'))
TypeError: string argument without an encoding
</code></pre>
<p>Finally, using the <code>.encode('utf-8')</code> function:</p>
<pre><code>b64encode('ffffff'.encode('utf-8'))
</code></pre>
<p>With incorrect output <code>b'ZmZmZmZm'</code>, the correct base64 encoding is <code>////</code>.</p>
<p>I already know how to decode b64 to hex so don't say how to do that.</p>
<p>Edit: This question got flagged for being the same as converting hex strings to hex bytes.  This involves base64.</p>
</div>
<div class="post-text" itemprop="text">
<p>To fully go from the string <code>ffffff</code> to base64 of the hex value, you need to run it through some encoding and decoding, using the <code>codecs</code> module:</p>
<pre><code>import codecs
# Convert string to hex
hex = codecs.decode('ffffff', 'hex')
# Encode as base64 (bytes)
codecs.encode(hex, 'base64')
</code></pre>
<p>For an odd-length string like <code>0xfffff</code> you need to put a zero at the beginning of the hex string (<code>0x0fffff</code>), otherwise python will give you an error.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an alternative to using codecs.<br/>
This one is a bit less readable, but works great and hopefully teaches you how codecs, hex and integers work. <em>(word of caution, works on odd lengths, but will ignore the odd byte-string-representation)</em></p>
<pre><code>import struct
s = 'ffffff'
b''.join([struct.pack('B', int(''.join(x), 16)) for x in zip(s[0::2], s[1::2])])
</code></pre>
<p>Which should give you <code>b'\xff\xff\xff'</code>.</p>
<p>Your main problem is probably that you think <code>'ffffff'</code> represents the values <code>255, 255, 255</code>. Which they don't. They're still in a string format with the letters ff. Subsequently you need to parse/convert the string representation of hex, into actual hex. We can do this by first passing the string through <code>int()</code> which can intemperate hex in string representation format.</p>
<p>You will need to convert each pair of <code>ff</code> individually by doing <code>int('ff', 16)</code> which tells Python to intemperate the string as a base-16 integer (hex-numbers).</p>
<p>And then convert that integer into a bytes like object representing that integer. That's where <a href="https://docs.python.org/3/library/struct.html#format-characters" rel="nofollow noreferrer">struct.pack</a> comes in. It's meant for exactly this.</p>
<pre><code>struct.pack('B', 255) # 255 is given to us by int('ff', 16)
</code></pre>
<p>Essentially, <code>'B'</code> tells Python to pack the value 255 into a 1-byte-object, in this case, that gives us <code>b'\xff'</code> which is your end goal. Now, do this for every 2-pair of letters in your original data.</p>
<hr/>
<p>This is more of a manual approach where you'll iterate over 2 characters in the string at a time, and use the above description to bundle them into what you expect them to be. Or just use codecs, either way works.</p>
<p>Expanded version of the above oneliner:</p>
<pre><code>import struct
hex_string = 'ffffff'
result = b''
for pair in zip(hex_string[0::2], hex_string[1::2]):
    value = int(''.join(pair), 16)
    result += struct.pack('B', value)
</code></pre>
<p>At the very least, I hope this explains how hex works on a practical level. And how the computer interpenetrates hour humanly readable version of bits and bytes.</p>
</div>
<span class="comment-copy"><code>bytes('fffff', 'UTF-8')</code> is what you're looking for. But I don't think <code>'ffffff'</code> does what you think it does, it's not the same as <code>'\xff\xff\xff'</code>.</span>
<span class="comment-copy">It didn't work, just returned <code>b'ZmZmZmZm'</code> again. (Assuming you meant: <code>b64encode(bytes('ffffff', 'utf-8'))</code>)</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/10824319/python-how-to-convert-a-string-containing-hex-bytes-to-a-hex-string">Python: How to convert a string containing hex bytes to a hex string</a></span>
<span class="comment-copy">You can also go through <code>struct.pack('B', int('ff',16))</code></span>
<span class="comment-copy">Yes - though if you're pulling in <code>codecs</code> for base64, it seems 'neater' to me to use it for both parts.</span>
<span class="comment-copy">Absolutely agree, there's nothing fancy about going manual to solve this. But hopefully it teaches someone why and how codecs work. So I threw in a small explanation of how hex works.</span>
<span class="comment-copy">@EricJin, you could append using modolus to get the correct length. <code>s = s + '0'*(len(s)%2)</code>. Which would only append <code>0</code> if the length of the string is not equal to a round number. However, this will give you inaccurate results since you probably don't know if you need to append the <code>0</code> at the start or end of your string? My solution works on odd lengths as well. However it simply ignores the odd number that isn't complete. So beware of that.</span>
