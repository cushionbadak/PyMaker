<div class="post-text" itemprop="text">
<h1>Preface</h1>
<p>I understand that <code>dict</code>s/<code>set</code>s should be created/updated with hashable objects only due to their implementation, so when this kind of code fails</p>
<pre><code>&gt;&gt;&gt; {{}}  # empty dict of empty dict
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'dict'
</code></pre>
<p>it's ok and I've seen tons of this kind of messages.</p>
<p>But if I want to check if some unhashable object is in <code>set</code>/<code>dict</code></p>
<pre><code>&gt;&gt;&gt; {} in {}  # empty dict not in empty dict
</code></pre>
<p>I get error as well</p>
<pre><code>Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'dict'
</code></pre>
<h1>Problem</h1>
<p>What is the rationale behind this behavior? I understand that lookup and updating may be logically connected (like in <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault</code> method</a>), but shouldn't it fail on modification step instead of lookup? Maybe I have some hashable "special" values that I handle in some way, but others (possibly unhashable) -- in another:</p>
<pre><code>SPECIAL_CASES = frozenset(range(10)) | frozenset(range(100, 200))
...
def process_json(obj):
    if obj in SPECIAL_CASES:
        ...  # handle special cases
    else:
        ...  # do something else
</code></pre>
<p>so with given lookup behavior I'm forced to use one of the options</p>
<ul>
<li><a href="https://docs.python.org/3/glossary.html#term-lbyl" rel="nofollow noreferrer">LBYL</a> way: check if <code>obj</code> is hashable and only after that check if it is one of <code>SPECIAL_CASES</code> (which is not great since it is based on <code>SPECIAL_CASES</code> structure and lookup mechanism restrictions, but can be encapsulated in separate predicate),</li>
<li><p><a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a> way: use some sort of utility for "safe lookup" like</p>
<pre><code>def safe_contains(dict_or_set, obj):
    try:
        return obj in dict_or_set
    except TypeError:
        return False
</code></pre></li>
<li>use <code>list</code>/<code>tuple</code> for <code>SPECIAL_CASES</code> (which is not <code>O(1)</code> on lookups).</li>
</ul>
<p>Or am I missing something trivial?</p>
</div>
<div class="post-text" itemprop="text">
<p>As you have no doubt realized, sets and dicts are very similar in their inner workings. Basically the concept is that you have key - value pairs (or just keys with a set), and the key must never change (immutable). If an object were mutable, the hash would loose it's meaning as a unique identifier of the underlying data. If you can't tell if an object is unique or not, the meaning of a set of unique keys looses it's key property of uniqueness. This is why mutable types are disallowed in sets and as the keys of a dict. With your example: <code>{} in {}  # empty dict not in empty dict</code> I think you have a slight misunderstanding, as <code>dict.__contains__</code> only checks the keys of the dict, not the values. Since you can never have a dict as a key (because it's mutable) this is invalid.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've found <a href="https://bugs.python.org/issue18510" rel="nofollow noreferrer">this issue</a> on Python bug tracker. Long story short:</p>
<p>if </p>
<pre><code>&gt;&gt;&gt; set([1,2]) in {frozenset([1,2]): 'a'}
</code></pre>
<p>returned <code>False</code> it will be in some way counter-intuitive since values are equal</p>
<pre><code>&gt;&gt;&gt; set([1,2]) == frozenset([1,2])
True
</code></pre>
<p>So I think I'll write &amp; use proper utilities where situation like this can possibly occur.</p>
<hr/>
<p>About the roots of the error: in <a href="https://github.com/python/cpython" rel="nofollow noreferrer">CPython repo</a> <a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c#L2745" rel="nofollow noreferrer"><code>dict___contains__</code> function</a> (which is a <code>dict.__contains__</code> method implementation) calls <a href="https://github.com/python/cpython/blob/master/Objects/object.c#L788" rel="nofollow noreferrer"><code>PyObject_Hash</code> function</a> (which corresponds to <a href="https://docs.python.org/3/library/functions.html#hash" rel="nofollow noreferrer"><code>hash</code> function</a>) -&gt; for unhashable objects (like <code>{}</code> in our first case) calls <a href="https://github.com/python/cpython/blob/ab67281e95de1a88c4379a75a547f19a8ba5ec30/Objects/object.c#L780" rel="nofollow noreferrer"><code>PyObject_HashNotImplemented</code> function</a> -&gt; generates this error.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/3460650/asking-is-hashable-about-a-python-value">Asking "is hashable" about a Python value</a></span>
<span class="comment-copy">@quamrana: this post is not about "how to find if object is hashable", I know how to do that, it's about dict/set lookup mechanism quirks</span>
<span class="comment-copy">It sounds like when python sees: <code>obj in dict_or_set</code>, then the first thing it tries is <code>hash(obj)</code>.</span>
<span class="comment-copy">I know everything that you've written, that <code>key in dct</code> checks if the <code>key</code> is in <code>dct</code>, not in values, my question is why it raises <code>TypeError</code>, not <code>False</code> (since unhashable objects could not be in <code>dict</code> keys/<code>set</code> elements) and how to deal with that in general case</span>
<span class="comment-copy">@AzatIbrakov given that logic, should this be valid? <code>a = [1,2,3]; print(a['key'])</code>. The issue I see here is one that's totally moot in a statically typed language, and a common one in dynamic languages. There are some operations that require the type to be known. I see this as a normal part of programming, and not an error with the language.</span>
<span class="comment-copy">@Aaron: moot not mute.</span>
<span class="comment-copy">@quamrana ty.. haven't digested my morning coffee yet :P</span>
<span class="comment-copy"><code>__getitem__</code> and <code>__contains__</code> are totally different methods, so I don't think your example is somehow relevant</span>
