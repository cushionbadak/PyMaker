<div class="post-text" itemprop="text">
<p>I have a numPy array e.g. <code>arr = [1, 2, 3, 4]</code> and I want to sum over the elements after each element resulting in <code>s = [10, 9, 7, 4]</code>.</p>
<p>In a loop, that can be done as:</p>
<pre><code>for i in range(arr.size):
    if i == 0:
        s[i] = np.sum(arr)
    else:
        s[i] = np.sum(arr[:-i])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use numpy's <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.cumsum.html" rel="nofollow noreferrer">cumulative sum</a> function for this. You need to reverse the original array first, and then reverse the result to get it in the order you want:</p>
<pre><code>a = np.array([1,2,3,4])
np.flip(np.cumsum(np.flip(a)))  # array([10,  9,  7,  4], dtype=int32)
</code></pre>
<p>Alternatively use <code>[::-1]</code> to reverse:</p>
<pre><code>np.cumsum(a[::-1])[::-1]
</code></pre>
<p>The answers to <a href="https://stackoverflow.com/questions/15889131/how-to-find-the-cumulative-sum-of-numbers-in-a-list">this question</a> include a full discussion of different options for calculating a cumulative sum in python. <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer">itertools.accumulate</a> seems a good option in Python 3.2 or newer.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use numpy's <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/ufuncs.html" rel="nofollow noreferrer">ufuncs</a> and their <a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.ufunc.accumulate.html" rel="nofollow noreferrer">accumulate</a> function to get the desired output. </p>
<pre><code>np.add.accumulate(arr[::-1])[::-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a concise (albeit costly) way to do it:</p>
<pre><code>arr = [1, 2, 3, 4] 
s   = np.sum(np.triu(arr),1)
</code></pre>
<p>Although it is a non-procedural (conceptual) approach using only matrix operators, it is by far the slowest solution.</p>
<p>I played around with the various solutions proposed here, and a few of my own to see which approach would be fastest.  Here are the results:</p>
<pre><code>subFromSum     0.06761518699999997  @Sarcoma
procedural     0.07242122200000001  @Alain T.
generator      0.08231979099999998  @Sarcoma
recursive      0.10890062199999995  @Alain T.
arraySum       0.1370264969999999   @JosepJoestar
listComp       0.13318894400000003  @student
iterAccumulate 0.14017220000000008  @Stuart (linked in comment)
funcReduce     0.1828948370000001   @Alain T.
npAccumulate   0.23582439700000002  @user2699  
npCumSum       0.60332129           @Suart
npSumTriu      1.951785406          @Alain T.
</code></pre>
<p>All the numpy functions come dead last on a small list.</p>
<p>The same test performed on a much larger array: [1,2,3,4]*100 (repeated 10000 times instead of 100000) gives different results reflecting the scalability of these solutions:</p>
<pre><code>iterAccumulate 0.12888180999999932  @Stuart (linked in comment)
generator      0.24920542199999995  @Sarcoma
procedural     0.2719608119999999   @Alain T.
npCumSum       0.27731459299999983  @Suart
npAccumulate   0.30234721600000114  @user2699
subFromSum     0.339745362          @Sarcoma
funcReduce     1.845360363000001    @Alain T.
recursive      2.2268321760000003   @Alain T.
npSumTriu      3.234387397999999    @Alain T.
listComp       6.1435246800000005   @student
arraySum       6.342716752          @JosepJoestar
</code></pre>
<p>numpy starts to show its power on large arrays but still not the best for this type of problem. The itertools  module (accumulate) seems to be the most scalable approach.</p>
<p>Here are the functions ...</p>
<pre><code>from timeit import timeit

array = [1, 2, 3, 4] 

# Subtracting from sum :: @Sarcoma
# timeit: 0.6
def subFromSum(arr):
    total = sum(arr)
    result = []
    for value in arr:
        result.append(total)
        total -= value
    return result
print("subFromSum    ", timeit(lambda :subFromSum(array), number=100000))


# Procedure for-loop assigning list items
# timeit: 0.07
def procedural(arr): 
    result = arr.copy()
    total  = 0
    index  = len(arr)-1 
    for value in reversed(arr):
        total += value
        result[index] = total
        index -= 1
    return result
print("procedural    ", timeit(lambda :procedural(array), number=100000))

# generator :: @Sarcoma
# timeit: 0.08
def gen(a):
    r = 0
    for x in a:
        r += x
        yield r
def generator(arr):
    return [*gen(arr[::-1])][::-1]
print("generator     ", timeit(lambda : generator(array), number=100000))


# recursive concatenation
# timeit: 0.11
def recursive(arr,size=None):
    size = (size or len(arr))
    value = arr[size-1]
    if size == 1 : return [value]
    previous = recursive(arr,size-1)
    return previous + [value+previous[-1]]
print("recursive     ", timeit(lambda :recursive(array), number=100000))

# iterative array sum()  :: @JosepJoestar
# timeit: 0.14
def arraySum(arr):
    s = []
    for i in range(len(arr)):
        s.append(sum(arr[i:]))
    return s
print("arraySum      ", timeit(lambda : arraySum(array), number=100000))

# list comprehension :: @student
# timeit: 0.13
def listComp(arr):
    return [sum(arr[i:]) for i in range(len(arr))]
print("listComp      ", timeit(lambda : listComp(array), number=100000))

# accumulate() function form itertools
# timeit: 0.14
def iterAccumulate(arr): 
    from itertools import accumulate
    return list(accumulate(arr[::-1]))[::-1]
print("iterAccumulate", timeit(lambda : iterAccumulate(array), number=100000))

# assigning list items using functools' reduce() function
# timeit: 0.18
def funcReduce(arr):
    from functools import reduce
    return reduce(lambda a,v: a + [a[-1]-v], arr[1:], [sum(arr)])
print("funcReduce    ", timeit(lambda : funcReduce(array), number=100000))

# npAccumulate() function form numpy :: @ user2699
# timeit: 0.24
def mpAccumulate(arr):
    import numpy as np
    return np.add.accumulate(arr[::-1])[::-1]
print("npAccumulate  ", timeit(lambda : mpAccumulate(array), number=100000))

# numpy's cumsum() function
# timeit: 0.55
def npCumSum(arr): 
    from numpy import cumsum
    return cumsum(arr[::-1])[::-1]
print("npCumSum      ", timeit(lambda : npCumSum(array), number=100000))

# conceptual matrix operations (using numpy)
# timeit: 2.05
def npSumTriu(arr): 
    import numpy as np
    return np.sum(np.triu(arr),1)
print("npSumTriu     ", timeit(lambda : npSumTriu(array), number=100000))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sum once, append the current total <code>t</code> to the result array <code>r</code> and deduct the current value <code>a</code>.</p>
<pre><code>arr = [1, 2, 3, 4]

t = sum(arr)
r = []
for a in arr:
    r.append(t)
    t -= a

print r
</code></pre>
<p>It's not a Numpy array though, is that bit important?</p>
<p>Some other answers appear to sum the remainder of the on each iteration. Which seems inefficient to me.</p>
<p>As pointed out by @User2699 reversing the array and simply adding the numbers together is the most efficient way to accomplish this.</p>
<p>The fastest way I could find to do that is with a generator:</p>
<pre><code>def gen(a):
    r = 0
    for x in a:
        r += x
        yield r


def reverse_sum_with_generator(arr):
    return [*gen(arr[::-1])][::-1]
</code></pre>
<p><em>Update</em></p>
<p>I found it interesting how much faster Numpy Arrays appeared to be with the Numpy based scripts. So I ran some further tests to see why that was. </p>
<p>What I realised is that I hadn't taken in to account the way the lists were being generated. Each method for creating the lists has a different amount of overhead which for the most part accounts for the difference in speeds. The standout exception being <code>np.arange()</code> which is much faster with Numpy based scripts.</p>
<p>Benchmarks: <a href="https://repl.it/repls/SumEachItemAfter" rel="nofollow noreferrer">https://repl.it/repls/SumEachItemAfter</a></p>
<p>Benchmark Gist: <a href="https://gist.github.com/sarcoma/8fc4b87c3cf649d6ef9af92bffe5a771" rel="nofollow noreferrer">https://gist.github.com/sarcoma/8fc4b87c3cf649d6ef9af92bffe5a771</a></p>
</div>
<div class="post-text" itemprop="text">
<p>May be you can try simply with <code>list comprehension</code>:</p>
<pre><code>s= [sum(arr[i:]) for i in range(len(arr))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think that you mean <strong>after</strong> instead of <em>before</em>. To sum the elements after each element do the following:</p>
<pre class="lang-py prettyprint-override"><code>s = []
for i in range(len(arr)):
    s.append(sum(arr[i:]))
</code></pre>
<p>Or you can also use the list comprehension notation to make it shorter and much more elegant:</p>
<pre class="lang-py prettyprint-override"><code>s = [sum(arr[i:]) for i in range(len(arr))]
</code></pre>
<p>However, this may lead to bad performance when list is big enough. The best solution in terms of efficiency would be to iterate over the list backwards computing only the sum of the last element seen and the current one, as the last is the sum of all its previous ones:</p>
<pre class="lang-py prettyprint-override"><code>s = list(arr) # Avoid copying reference if modify arr is not desired

#Â Iterate from last position - 1, until first position, descending
for i in range(len(arr) - 2, -1, -1):
    s[i] += s[i + 1]
</code></pre>
</div>
<span class="comment-copy">You mean after right?</span>
<span class="comment-copy">yes I meant after, thanks!</span>
<span class="comment-copy">Very clever, but the most costly in terms of additions and memory out of any answer here.</span>
<span class="comment-copy">Indeed. I should have mentioned that.  I is a conceptual solution, not an efficient one :)</span>
<span class="comment-copy">Interesting performance tests, but if you are starting with a numpy array as in the original post then the numpy solutions are much faster for an array of length 400. Interestingly <code>npAccumulate</code> looks faster than <code>npCumSum</code> in that case. Conversion to a numpy array does take some time and will outweigh the performance gains for a short array/list (but there are other reasons to use numpy).\</span>
<span class="comment-copy">I didn't start from a numpy array in my tests and that will indeed give different results.  On the other hand, I don't think the requirement is specifically for an array of sequential numbers (generated range).  If it were, there could be other algorithms that would go even faster by leveraging â1..n = n(n+1)/2</span>
<span class="comment-copy">count*(count+1)/2 - np.arange(count)*np.arange(1,count+1)/2 gives impressive results with large numbers (not so much for only 4 though).</span>
<span class="comment-copy">You're right about this being a more efficient way, but you can make it even more efficient by iterating over the reversed array and adding rather than subtracting.  No need for the initial sum then.</span>
<span class="comment-copy">Nice benchmarks.  I'm surprised how well the generator works.  Changing <code>arr</code> from a generator to <code>list</code> or <code>np.array</code> also has quite an effect on performance.</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/15889131/how-to-find-the-cumulative-sum-of-numbers-in-a-list" title="how to find the cumulative sum of numbers in a list">stackoverflow.com/questions/15889131/â¦</a> for other options to calculate a cumulative sum and some performance tests.</span>
<span class="comment-copy">@user2699 Wow, Numpy arrays are fast! Looks my generator was aided by the are being a generator too. Never would have that'd make much difference.</span>
<span class="comment-copy">@user2699 New benchmark with comparisons or generator vs list vs np.array</span>
<span class="comment-copy">Very clean, but unless python is adding intelligence in the back this will have poor time complexity. Better to loop backwards over the list with <code>range(len(arr) - 1, -1, -1)</code> and keep the running total</span>
