<div class="post-text" itemprop="text">
<p>I am trying to determine how to efficiently implement a generator over an iterable that yields all look-ahead or look-behind pairs within a defined window. </p>
<p>For example</p>
<pre><code>seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
pairs_lookahead(seq, behind=0, forward=3, empty=None)
</code></pre>
<p>Should produce something similar to</p>
<pre><code>[((1, 2), (1, 3), (1, 4)), ((2, 3), (2, 4), (2, 5)), ...]
</code></pre>
<p>When an element does not exist during look-ahead or look-behind it should be filled with a defined empty value. </p>
<p>This is what I have so far for a lookahead generator</p>
<pre><code>def lookforward(seq, behind, forward, empty=None):
    itr = iter(seq)

    lst = [empty]*behind + [next(itr)]

    # Prime the needed lookforward values:
    for x in range(forward):
        try:
            lst.append(next(itr))
        except StopIteration:
            lst.append(empty)
            forward -= 1

    # Yield the current tuple, then shift the list and generate a new item:
    for item in itr:
        yield tuple(lst)
        lst = lst[1:] + [item]

    # Yield the last full tuple, then continue with None for each lookforward
    # position:
    for x in range(forward + 1):
        yield tuple(lst)
        lst = lst[1:] + [empty]

print(list(lookforward(range(10), 0, 3)))
</code></pre>
<p>Executing the above implementation gives:</p>
<pre><code>&gt; [(0, 1, 2, 3), (1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6), (4, 5, 6, 7), (5, 6, 7, 8), (6, 7, 8,9), (7, 8, 9, None), (8, 9, None, None), (9, None, None, None)]
</code></pre>
<p>I am not sure how I should proceed from here. The above implementation generates look-ahead and look-behind sequences but I am not sure how to approach modifying it to produce the sequences of pairs. I also have concerns that my implementation may not be efficient. I am rather inexperience with the implementation of iterators in Python. Any assistance would be much appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Explanations</h2>
<p>I feel like the best solution is to use as much available tools as possible. In particular, something that is very interesting in this case is to use <a href="https://docs.python.org/3.5/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> (and its alterego <a href="https://docs.python.org/3.7/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>zip_longest</code></a>):</p>
<pre class="lang-py prettyprint-override"><code>from itertools import zip_longest

seq = [1, 2, 3, 4]
print(list(zip(seq, seq[1:])))
print(list(zip_longest(seq, seq[1:])))
</code></pre>
<p>Which produces:</p>
<pre><code>[(1, 2), (2, 3), (3, 4)]
[(1, 2), (2, 3), (3, 4), (4, None)]
</code></pre>
<p>Also note that <code>zip</code> can be used to "unzip": </p>
<pre class="lang-py prettyprint-override"><code>print(list(zip(*[(1, 2), (2, 3), (3, 4)])))
</code></pre>
<p>Outputs: </p>
<pre><code>[(1, 2, 3), (2, 3, 4)]
</code></pre>
<p>The first step is to understand this piece of code which builds the case <code>forward=2</code>: </p>
<pre><code>from itertools import zip_longest

seq = [1, 2, 3, 4]
one_step_ahead = zip_longest(seq, seq[1:])
two_steps_ahead = zip_longest(seq, seq[2:])
# print(list(one_step_ahead))  # =&gt; [(1, 2), (2, 3), (3, 4), (4, None)]
# print(list(two_steps_ahead)) # =&gt; [(1, 3), (2, 4), (3, None), (4, None)]
merged = zip(one_step_ahead, two_steps_ahead)
print(list(merged))
</code></pre>
<p>This prints: </p>
<pre><code>[((1, 2), (1, 3)), ((2, 3), (2, 4)), ((3, 4), (3, None)), ((4, None), (4, None))]
</code></pre>
<p>That's very close from being modulable, the only thing we presume here is that we only have two <code>zip</code> objects to merge, where in the real case we will have an unknown number, therefore we need to be able to translate <code>merged = zip(one_step_ahead, two_steps_ahead)</code> into a case where the list has an unknown size. To do so we will simply add all the "x_steps_ahead" in a list, lets call it <code>pairs</code>, then we will merge all these pairs using the spread operation <code>*pairs</code>. In the end it will look like this: </p>
<pre class="lang-py prettyprint-override"><code>from itertools import zip_longest

seq = [1, 2, 3, 4]

pairs = []
for x in range(2):
  x_step_ahead = zip_longest(seq, seq[x:])
  pairs.append(x_step_ahead)

merged = zip(*pairs)
print(list(merged))
</code></pre>
<p>Which produces the same result as before: </p>
<pre><code>[((1, 2), (1, 3)), ((2, 3), (2, 4)), ((3, 4), (3, None)), ((4, None), (4, None))]
</code></pre>
<p>That's basically the whole idea of the code I'm proposing. The case of looking backward is a bit more unusual but I'll let you understand how it works as an exercise. A slight difference in the final code is also that I try to avoid instantiating lists as much as I can. Iterators/generators are prefered, which makes the code a bit harder to read, but way more efficient in terms of memory usage. </p>
<p>Basically, things like the pair construction will turn to: </p>
<pre><code>def pairs_generator():
  for x in range(2):
    yield zip_longest(seq, seq[x:])

pairs = pairs_generator()
</code></pre>
<p>That does the exact same thing as the previous code, it just avoid having a list of size <code>x</code> in memory to remember all the <code>zips</code> we create. </p>
<p>For the same reason, in the following code I also use <a href="https://docs.python.org/3.7/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a> instead of classical slicing because its a lighter version (unlike <code>slice</code> it doesn't instantiate a copy of the input list).</p>
<h2>Solution implementation</h2>
<pre class="lang-py prettyprint-override"><code>from itertools import zip_longest, islice

def fill_with(iterator, value, times):
  """Add `value` `times` times in front of the iterator."""
  for _ in range(times):
    yield value
  yield from iterator

def pairs(seq, distance, reverse=False, empty=None):
  """Build lookup pairs from a list, for example: 
    list(pairs([1,2,3], 1)) =&gt; [(1, 2), (2, 3), (3, None)]
  and reverse make backward lookups: 
    list(pairs([1,2,3], 1, reverse=True)) =&gt; [(1, None), (2, 1), (3, 2)]
  """
  if reverse:
    return zip(seq, fill_with(seq, empty, distance))
  else:
    return zip_longest(seq, islice(seq, distance, None), fillvalue=empty)

def look_backward(seq, distance, empty=None):
  """Build look backward tuples, for example calling 
  list(look_backward([1,2,3], 2)) will produce: 
    [((1, None), (1, None)), ((2, None), (2, 1)), ((3, 2), (3, 1))]
  """
  return zip(*(pairs(seq, i, empty=empty, reverse=True) for i in range(distance,0, -1)))

def look_forward(seq, distance, empty=None):
  """Build look forward tuples, for example calling 
  list(look_forward([1,2,3], 2)) will produce: 
    [((1, 2), (1, 3)), ((2, 3), (2, None)), ((3, None), (3, None))]
  """
  return zip(*(pairs(seq, i+1, empty=empty) for i in range(distance)))

def pairs_lookahead(seq, behind=0, forward=3, empty=None):
  """Produce the results expected by https://stackoverflow.com/q/54847423/1720199"""
  backward_result = look_backward(seq, behind, empty=empty)
  forward_result = look_forward(seq, forward, empty=empty)
  if behind &lt; 1 and forward &gt; 0:
    return forward_result
  if behind &gt; 0 and forward &lt; 1:
    return backward_result
  return [a+b for a, b in zip(backward_result, forward_result)]
</code></pre>
<p>You can call it as you suggested:</p>
<pre class="lang-py prettyprint-override"><code>seq = [1, 2, 3, 4]
result = pairs_lookahead(seq, behind=2, forward=1, empty="Z")
print(list(result))

result = pairs_lookahead(seq, behind=2, forward=0, empty="Y")
print(list(result))

result = pairs_lookahead(seq, behind=0, forward=1, empty="X")
print(list(result))
</code></pre>
<p>This outputs:</p>
<pre><code>[((1, 'Z'), (1, 'Z'), (1, 2)), ((2, 'Z'), (2, 1), (2, 3)), ((3, 1), (3, 2), (3, 4)), ((4, 2), (4, 3), (4, 'Z'))]
[((1, 'Y'), (1, 'Y')), ((2, 'Y'), (2, 1)), ((3, 1), (3, 2)), ((4, 2), (4, 3))]
[((1, 2),), ((2, 3),), ((3, 4),), ((4, 'X'),)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try something like the following code I wrote:</p>
<p><strong>Explanation:</strong></p>
<p>If <code>behind</code>/<code>forward</code> is 0 we set variable <code>behind_counter</code>/<code>forward_counter</code> to 1 in order for the following loops to atleast loop once.</p>
<p>Outer loop loops over the range of <code>seq</code>, the two inner loops over range of <code>behind_counter</code>(counted down) and <code>forward_counter</code>(counted up),respectively. Inside the most inner loop we set the respective lookahead/-behind indices and then check with help of the three <code>if</code> statements whether indices are out of bound in order to set the respective values to the out of bound value (<code>'null'</code>) if necessary. The fourth <code>if</code> statement is chosen if the indices are not out of bound. Inside each <code>if</code> statement there are <code>if-elif-elif-else</code> statements which change the appended tuple depending on the lookahead/-behind values stored in <code>behind</code> and <code>forward</code>. If both are 0 only append <code>seq[i]</code>, if <code>behind</code> is 0 only append a tuple consisting of <code>seq[i]</code> and current lookahead value, and so on.</p>
<p>After the work is done we print the value of <code>res</code> in order to visualize the result.</p>
<p><strong>Source Code:</strong></p>
<pre><code>seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
behind = 0
forward = 3

res = []

behind_counter = behind
forward_counter = forward

if behind == 0:
    behind_counter = 1
if forward == 0:
    forward_counter = 1

for i in range(len(seq)):
    for j in range(behind_counter,0,-1):
        for k in range(forward_counter):
            index_behind = i - j
            index_forward = i + k + 1
            if index_behind &lt; 0 and index_forward &gt; len(seq):
                index_behind = 'null'
                index_forward = 'null'
                if behind == 0 and forward == 0:
                    res.append(tuple((seq[i])))
                elif behind == 0:
                    res.append(tuple((seq[i],index_forward)))
                elif forward == 0:
                    res.append(tuple((index_behind,seq[i])))
                else:
                    res.append(tuple((index_behind,seq[i],index_forward)))
                continue
            if index_behind &lt; 0:
                index_behind = 'null'
                if behind == 0 and forward == 0:
                    res.append(tuple((seq[i])))
                elif behind == 0:
                    res.append(tuple((seq[i],seq[index_forward])))
                elif forward == 0:
                    res.append(tuple((index_behind,seq[i])))
                else:
                    res.append(tuple((index_behind,seq[i],seq[index_forward])))
                continue
            if index_forward &gt;= len(seq):
                index_forward = 'null'
                if behind == 0 and forward == 0:
                    res.append(tuple((seq[i])))
                elif behind == 0:
                    res.append(tuple((seq[i],index_forward)))
                elif forward == 0:
                    res.append(tuple((seq[index_behind],seq[i])))
                else:
                    res.append(tuple((seq[index_behind],seq[i],index_forward)))
                continue
            if index_forward &lt; len(seq) and index_behind &gt;= 0:
                if behind == 0 and forward == 0:
                    res.append(tuple((seq[i])))
                elif behind == 0:
                    res.append(tuple((seq[i],seq[index_forward])))
                elif forward == 0:
                    res.append(tuple((seq[index_behind],seq[i])))
                else:
                    res.append(tuple((seq[index_behind],seq[i],seq[index_forward])))
print (res)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>[(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (3, 6), (4, 5), (4, 6), (4, 7), (5, 6), (5, 7), (5, 8), (6, 7), (6, 8), (6, 9), (7, 8), (7, 9), (7, 10), (8, 9), (8, 10), (8, 'null'), (9, 10), (9, 'null'), (9, 'null'), (10, 'null'), (10, 'null'), (10, 'null')]
</code></pre>
<hr/>
<h2>First Major Update:</h2>
<p>According to a new comment you want a different ouput when both lookbehind/-forward are specified, so I altered my program to now hopefully fulfill your needs:</p>
<p><strong>Additional explanation for updated program:</strong></p>
<p>In each iteration of the outer loop first the lookbehind pairs are added in a loop, then  the lookforward pairs are added, also in a loop. As before we check for out of bounds and set the value of the lookbehind/forward value accordingly. </p>
<p><strong>Updated source code:</strong></p>
<pre><code>seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
behind = 2
forward = 3

res = []

behind_counter = behind
forward_counter = forward

if behind == 0:
    behind_counter = 1
if forward == 0:
    forward_counter = 1

for i in range(len(seq)):
    for j in range(behind_counter,0,-1):
        index_behind = i - j
        if behind == 0:
            #res.append(tuple((seq[i])))
            continue
        else:
            if index_behind &lt; 0:
                index_behind = 'null'
                res.append(tuple((seq[i],index_behind)))
                continue
            else:
                res.append(tuple((seq[i], seq[index_behind])))
    for k in range(forward_counter):
        index_forward = i + k + 1
        if forward == 0:
            #res.append(tuple((seq[i])))
            continue
        else:
            if index_forward &gt;= len(seq):
                index_forward = 'null'
                res.append(tuple((seq[i],index_forward)))
                continue
            else:
                res.append(tuple((seq[i],seq[index_forward])))
print (res)
</code></pre>
<p><strong>New output: [when lookforward <em>and</em> lookbehind are specified]</strong></p>
<pre><code>[(1, 'null'), (1, 'null'), (1, 2), (1, 3), (1, 4), (2, 'null'), (2, 1), (2, 3), (2, 4), (2, 5), (3, 1), (3, 2), (3, 4), (3, 5), (3, 6), (4, 2), (4, 3), (4, 5), (4, 6), (4, 7), (5, 3), (5, 4), (5, 6), (5, 7), (5, 8), (6, 4), (6, 5), (6, 7), (6, 8), (6, 9), (7, 5), (7, 6), (7, 8), (7, 9), (7, 10), (8, 6), (8, 7), (8, 9), (8, 10), (8, 'null'), (9, 7), (9, 8), (9, 10), (9, 'null'), (9, 'null'), (10, 8), (10, 9), (10, 'null'), (10, 'null'), (10, 'null')]
</code></pre>
<hr/>
<h2>Second Major Update:</h2>
<p>In case you want a list containing tuples of tuples as a result you could do something like this [I slightly modified the code of my first major update]:</p>
<p><strong>Additional explanation:</strong></p>
<p>In the beginning of each outer loop iteration we append an empty list to <code>res</code>. To this list we append the according values of first the lookbehind pairs, then the lookforward pairs. In the end of each outer loop iteration we then convert this newly created list to a tuple.</p>
<pre><code>seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
behind = 2
forward = 3

res = []

behind_counter = behind
forward_counter = forward

if behind == 0:
    behind_counter = 1
if forward == 0:
    forward_counter = 1

for i in range(len(seq)):
    res.append(list())
    for j in range(behind_counter,0,-1):
        index_behind = i - j
        if behind == 0:
            #res.append(tuple((seq[i])))
            continue
        else:
            if index_behind &lt; 0:
                index_behind = 'null'
                res[i].append((seq[i],index_behind))
                continue
            else:
                res[i].append((seq[i], seq[index_behind]))
    for k in range(forward_counter):
        index_forward = i + k + 1
        if forward == 0:
            #res.append(tuple((seq[i])))
            continue
        else:
            if index_forward &gt;= len(seq):
                index_forward = 'null'
                res[i].append((seq[i],index_forward))
                continue
            else:
                res[i].append((seq[i],seq[index_forward]))
    res[i] = tuple(res[i])
print (res) 
</code></pre>
<p><strong>Output: [<em>list containing tuples of tuples</em>]</strong></p>
<pre><code>[((1, 'null'), (1, 'null'), (1, 2), (1, 3), (1, 4)), ((2, 'null'), (2, 1), (2, 3), (2, 4), (2, 5)), ((3, 1), (3, 2), (3, 4), (3, 5), (3, 6)), ((4, 2), (4, 3), (4, 5), (4, 6), (4, 7)), ((5, 3), (5, 4), (5, 6), (5, 7), (5, 8)), ((6, 4), (6, 5), (6, 7), (6, 8), (6, 9)), ((7, 5), (7, 6), (7, 8), (7, 9), (7, 10)), ((8, 6), (8, 7), (8, 9), (8, 10), (8, 'null')), ((9, 7), (9, 8), (9, 10), (9, 'null'), (9, 'null')), ((10, 8), (10, 9), (10, 'null'), (10, 'null'), (10, 'null'))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A useful intermediate step in solving your problem is to produce sequences of adjacent values. So if the input was <code>[1, 2, 3, 4, 5, ...]</code>, you'd iterate and get <code>(1, 2, 3, 4)</code> then <code>(2, 3, 4, 5)</code> and so on.</p>
<p>There's a nifty way to do this using <code>itertools.tee</code>:</p>
<pre><code>import itertools

def n_wise(iterable, n):
    iterators = itertools.tee(iterable, n)
    for i, iterator in enumerate(iterators):
        next(itertools.islice(iterator, i, i), None)  # discard i values from the iterator
    return zip(*iterators)
</code></pre>
<p>Now we can fairly easily do lookahead and lookbehinds (I'm ignoring the <code>empty</code> values for now):</p>
<pre><code>def lookaround(iterable, behind, ahead):
    for values in n_wise(iterable, 1 + behind + ahead):
        behind_values = values[:behind]
        current_value = values[behind]
        ahead_values = values[behind+1:]
        for b in behind_values:
            yield current_value, b
        for a in ahead_values:
            yield current_value, a
</code></pre>
<p>The easiest way to adapt this to support the empty values would just be to pad the iterable. You need <code>behind</code> extra empty values at the start, and <code>ahead</code> extra values at the end.</p>
<pre><code>def lookaround_with_empties(iterable, behind, ahead, empty=None):
    padded_iterable = itertools.chain([empty]*behind, iterable, [empty]*ahead)
    return lookaround(padded_iterable, behind, ahead)
</code></pre>
<p>Now, this behaves a little odd when it looks back or ahead into several empty values in a row (since it repeats the same output for each missing value), but I'm not sure what you expect in those situations. There's probably a simple way to filter the output to avoid the duplicates, if you want that.</p>
</div>
<div class="post-text" itemprop="text">
<p>As a first step write a function that from a <code>pivot</code> index returns the list of look-ahead and look-behind pairs centered in the <code>pivot</code>.</p>
<p>Using <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehensions</a>:</p>
<pre><code>def around_pivot(seq, pivot, behind=2, forward=3):
    return [[seq[pivot], seq[pivot+i] if pivot+i &lt; len(seq) and pivot+i &gt;= 0 else None]
      for i in range(-behind, forward+1) if i != 0]
</code></pre>
<p>If now all pairs are desired it a a matter of applying again list comprehensions, varying the <code>pivot</code>:</p>
<pre><code>all_pairs = [around_pivot(seq, i) for i in range(len(seq))]
</code></pre>
<p>Or if you prefer a one line solution, but please consider code readability/maintenability:</p>
<pre><code>def all_pairs(seq, behind=2, forward=3):
    return [[[seq[p], seq[p+i] if p+i &lt; len(seq) and p+i &gt;= 0 else None]
      for i in range(-behind, forward+1) if i != 0] for p in range(len(seq))]
</code></pre>
<p>If you want optimize memory usage a <a href="https://stackoverflow.com/a/364824/3356777">generator comprehensions</a> may be used instead:</p>
<pre><code>def all_pairs(seq, behind=2, forward=3):
    return (((seq[p], seq[p+i] if p+i &lt; len(seq) and p+i &gt;= 0 else None)
      for i in range(-behind, forward+1) if i != 0) for p in range(len(seq)))
</code></pre>
</div>
<span class="comment-copy">Let's forget for some time about effiency. What is the output of your current implementation? I did not run it myself but I see that it generates tuples - so why it's different from "modifying it to produce the sequences of pairs"? Please explain</span>
<span class="comment-copy">I updated my question to have an example of output. What I want to do is modify this implementation to output sequences of lookahead pairs within a window rather than just lookahead tuples within a window. Does that clarify things?</span>
<span class="comment-copy">I seriously doubt that's your test code. For one thing the function is named <code>lookahead</code> not <code>lookforward</code>, and another is that when that is fixed, ``lookahead<code>, as written, causes a </code>RuntimeError: generator raised StopIteration`.</span>
<span class="comment-copy">Well, that's an improvement, but when I run it with Python 3.7.2 (not that I think the difference matters), I still get a <code>RuntimeError: generator raised StopIteration</code>. Are you sure the code you're running has that <code>raise StopIteration</code> at end? Which is the line it occurs on for me (and isn't needed).</span>
<span class="comment-copy">What should the output be when both <code>behind </code> and <code>forward</code> are specified? Something like <code>[..., ((2, None), (2, 1), (2, 3), (2, 4), ...]</code> if they are both equal to 2?</span>
<span class="comment-copy">This is exactly the sort of solution I was looking for. I also appreciate the amount of depth that you have gone into explaining your reasoning. However, I have a question for how I might use such an implementation for sequences of objects: how might I perform processing on individual non-empty objects to produce some kind of view for the objects in the sequence?  I apologize if this question add far more complexity to the problem. Your current solution is more than sufficient for the original problem.</span>
<span class="comment-copy">I'm not sure to fully understand what you mean here. You want <code>seq</code> to be a sequence of any object instead of a sequence of numbers? Also I don't understand what you mean by "view for the objects".</span>
<span class="comment-copy">I apologize for not explaining what I had in mind very clearly in my previous comment. What I was wondering was how might such an implementation differ if it were desirable to perform computations on elements in the original sequence that would appear in the pairs - regardless of whether they are objects or not. A potential use case is where one wants to construct pairs of meaningful data computed from objects rather than the objects themselves. Does this make more sense? I suspect that imap or map may be helpful for this, but I am unfamiliar with their use.</span>
<span class="comment-copy">Adding empty at the end is a good idea, it avoids having it all around and also avoid constructing useless stuff :p. By the way you are passing the empty param to <code>lookaround</code> and you also have <code>enumerate(it)</code> instead of <code>enumerate(iterators)</code>. Lookup pairs are not grouped by tuple in the output as it was requested.</span>
