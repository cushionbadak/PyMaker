<div class="post-text" itemprop="text">
<p>When writing a script, I sometimes use a function to encapsulate exactly what the script does. This is because I might want to call the function from code or run it as a script. Is there any way to avoid repeating the documentation of the function arguments in the help strings in argparse? For example: </p>
<pre><code>import argparse
def my_function(arg_one, arg_two):
    """
    arg_one: The first argument.
    arg_two: The second argument.
    """
    print("The first argument is %r" % arg_one)
    print("The second argument is %r" % arg_two)

if __name__=="main":
    parser = argparse.ArgumentParser()
    parser.add_argument('--arg-one', help="The first argument.")
    parser.add_argument('--arg-two', help="The second argument.")
    args = parser.parse_args()
    my_function(args.arg_one, args.arg_two)
</code></pre>
<p>Since the arguments of the function and the script exactly correspond, you can see that I've had to document them twice ("The first argument", "The second argument"). Its a trivial problem, but its really annoying. Should I just not be using a function at all? </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is how I would write it...</p>
<pre><code>""" My Crazy Program
Usage:
    my_prog [options]

Options:
"""

def my_function(file_output, file_input, recursive=False):
    """
    output=str: specifies an output path
    input=str: specifies an input path
    recursive: apply recursively
    """
    print("The first argument is %r" % file_output)
    print("The second argument is %r" % file_input)
    print("The third argument is %r" % recursive)

# This is where the magic happens
__doc__ += '\n'.join(f'   --{parsed[0]: &lt;15}  {parsed[1]}'
                     for parsed in (
                         line.strip().split(': ') 
                         for line in my_function.__doc__.split('\n'))
                     if len(parsed) == 2)

if __name__ == "__main__":
    from docopt import docopt
    ARGS = docopt(__doc__)
    my_function(ARGS['--output'], ARGS['--input'], ARGS['--recursive'])
</code></pre>
<p>Ok, you see the magic line (beginning by <code>__doc__ += ...</code>), it makes the documentation for the module which becomes:</p>
<pre><code> My Crazy Program
Usage:
    my_prog [options]

Options:
   --output=str       specifies an output path
   --input=str        specifies an input path
   --recursive        apply recursively
</code></pre>
<p>Then, docopt parses that and returns this dictionary:</p>
<pre><code>$ python my_prog
{'--input': None,
 '--output': None,
 '--recursive': False}

$ python my_prog --output /dev/null --recursive
{'--input': None,
 '--output': '/dev/null',
 '--recursive': True}
</code></pre>
<p>Which can be used to call the function and get the result:</p>
<pre><code>The first argument is '/dev/null'
The second argument is None
The third argument is True
</code></pre>
<p>I like this solution because it is single line but I will agree with you that it isn't beautiful, I will let you write your own beautiful function that does that automatically for every file :o)</p>
</div>
<span class="comment-copy">Take a look at the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">docs.python.org/3/library/inspect.html</a> module</span>
<span class="comment-copy">See <a href="https://docopt.readthedocs.io/en/0.2.0/" rel="nofollow noreferrer">docopt.readthedocs.io/en/0.2.0</a></span>
<span class="comment-copy">This is a good organization, despite the documentation redundancy.  In practice you'll have multiple functions.  Or maybe a <code>main</code> that can call various combinations of functions.  And the parser might handle attributes that aren't used directly any function (e.g  verbosity, logging).  But there are various alternative parsers (or argparse frontends) that try to provide a more direct connection between functions and parser arguments (<code>plac, </code>docopt`).</span>
