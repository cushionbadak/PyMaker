<div class="post-text" itemprop="text">
<p>How would I get a random subset of a set <code>s</code> in python? I tried doing</p>
<pre class="lang-py prettyprint-override"><code>from random import sample, randint

def random_subset(s):
    length = randint(0, len(s))
    return set(sample(s, length))
</code></pre>
<p>But I now realize that this obviously doesn't work since the distribution of the <code>len(s)</code> where <code>s</code> is a random subset is not uniform from <code>0</code> to <code>n</code>.</p>
<p>I'm sure I could compute that distribution and use numpy's sample with probability, or something like that, but I'd like something preferably with pure python.</p>
</div>
<div class="post-text" itemprop="text">
<p>I just realized I can simply go through each element in <code>s</code> and decide independently to keep it or not. Something like this</p>
<pre><code>from random import randint

def random_subset(s):
    out = set()
    for el in s:                                                                                                                    
        # random coin flip
        if randint(0, 1) == 0:
            out.add(el)
    return out
</code></pre>
<p>This has the correct distribution.</p>
</div>
<div class="post-text" itemprop="text">
<p>What subset you obtain will depend largely on the criterion you specify for including or excluding elements. If you have a function <code>criterion</code> that accepts an element and returns a Boolean to indicate inclusion in the subset, the actual creation process becomes simply</p>
<pre><code>from random import randrange

def random_subset(s, criterion=lambda x: randrange(2)):
    return set(filter(criterion, s))
</code></pre>
<p><code>filter</code> creates a lazy generator, so the return subset is the only place the selection gets stored. The default criterion is very simple and has a uniform distribution. <a href="https://docs.python.org/3/library/random.html#random.randrange" rel="nofollow noreferrer"><code>randrange</code></a> is similar to <a href="https://docs.python.org/3/library/random.html#random.randint" rel="nofollow noreferrer"><code>randint</code></a> except that it is exclusive in the right bound. At least as of Python 3.2+, both functions produce fairly uniform results regardless of range size.</p>
<p>You can further refine the criterion by using <a href="https://docs.python.org/3/library/random.html#random.random" rel="nofollow noreferrer"><code>random</code></a>:</p>
<pre><code>from random import random

criterion = lambda x: random() &lt; 0.5
</code></pre>
<p>Applying a threshold like that may seem like overkill, but it lets you adjust the distribution. You can have a function that generates criteria for whatever threshold you like:</p>
<pre><code>def make_criterion(threshold=0.5):
    return lambda x: random() &lt; threshold
</code></pre>
<p>You could use it to get a smaller subset:</p>
<pre><code>random_subset(s, make_criterion(0.1))
</code></pre>
<p>In fact, you can make the criterion as complicated as you would like. The following example is a contrived callable class that operates on sets of strings. If a string with a matching first character has already been added, it automatically rejects the current element. If the second letter has been seen already, it sets the probability of inclusion to 0.25. Otherwise, it flips a coin:</p>
<pre><code>class WeirdCriterion:

    def __init__(self):
        self.first = set()
        self.second = set()

    def __call__(self, x):
        n = len(x)
        if n &gt; 0:
            if x[0] in self.first:
                return False
            self.first.add(x[0])
            if n &gt; 1:
                if x[1] in self.second:
                    return not randrange(4)
                self.second.add(x[1])
        return randrange(2)
</code></pre>
<p>This example wouldn't be very good in practice because sets are unordered, and can give different iteration orders between different runs of the same script. What it shows, however, is a method for creating a criterion that is random, but is adjusted in response to elements that are already in the subset.</p>
<p><strong>Avoiding Numpy</strong></p>
<p>Now that I have a better understanding of your original intent, you can leverage the fact that Python 3 has infinite length integers and that <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>choices</code></a> accepts a length parameter to get the correct length. I don't recommend this approach though:</p>
<pre><code>from random import choices, sample
from math import factorial

def random_subset(s):
    n = len(s)
    nf = factorial(n)
    # yes, there are better ways of doing this, even in pure python
    weights = [nf / (factorial(k) * factorial(n - k)) for k in range(n + 1)]
    length = choices(range(n + 1), weights, k=1)[0]
    return sample(s, length)
</code></pre>
<p>A better solution for computing the binomial coefficients could be something like:</p>
<pre><code>def pascal(n):
    result = [1] * (n + 1)
    if n &lt; 2:
        return result
    for i in range(2, n + 1):
        for j in range(i - 1, 0, -1):
            result[j] += result[j - 1]
    return result
</code></pre>
</div>
<span class="comment-copy">Why is randrange cleaner than randint? I’m pretty sure randint invokes randrange.</span>
<span class="comment-copy">@Enrico. It's cleaner because it involves one less function call. The interface is a matter of preference. I'll modify that bit if you prefer.</span>
<span class="comment-copy">Ah sure I guess it’s one less call. I was just curious what you meant by cleaner. Thank you for the response. Yours is a generalization of my answer. I was looking for a random subset sampled uniformly over all possible subsets of a set S.</span>
<span class="comment-copy">I've updated with an example showing that you could do it the way you originally intended.</span>
