<div class="post-text" itemprop="text">
<p>I would like to get a list of Python modules, which are in my Python installation (UNIX server).</p>
<p>How can you get a list of Python modules installed in your computer?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Solution</h2>
<p>My 50 cents for getting a <code>pip freeze</code>-like list from a Python script:</p>
<pre class="lang-python prettyprint-override"><code>import pip
installed_packages = pip.get_installed_distributions()
installed_packages_list = sorted(["%s==%s" % (i.key, i.version)
     for i in installed_packages])
print(installed_packages_list)
</code></pre>
<p>As a (too long) one liner:</p>
<pre class="lang-python prettyprint-override"><code>sorted(["%s==%s" % (i.key, i.version) for i in pip.get_installed_distributions()])
</code></pre>
<p>Giving:</p>
<pre class="lang-js prettyprint-override"><code>['behave==1.2.4', 'enum34==1.0', 'flask==0.10.1', 'itsdangerous==0.24', 
 'jinja2==2.7.2', 'jsonschema==2.3.0', 'markupsafe==0.23', 'nose==1.3.3', 
 'parse-type==0.3.4', 'parse==1.6.4', 'prettytable==0.7.2', 'requests==2.3.0',
 'six==1.6.1', 'vioozer-metadata==0.1', 'vioozer-users-server==0.1', 
 'werkzeug==0.9.4']
</code></pre>
<h2>Scope</h2>
<p>This solution applies to the system scope or to a virtual environment scope, and covers packages installed by <code>setuptools</code>, <code>pip</code> and (<a href="https://stackoverflow.com/questions/3220404/why-use-pip-over-easy-install">god forbid</a>) <code>easy_install</code>.</p>
<h2>My use case</h2>
<p>I added the result of this call to my flask server, so when I call it with <code>http://example.com/exampleServer/environment</code> I get the list of packages installed on the server's virtualenv. It makes debugging a whole lot easier.</p>
<h2>Caveats</h2>
<p>I have noticed a strange behaviour of this technique - when the Python interpreter is invoked in the same directory as a <code>setup.py</code> file, it does not list the package installed by <code>setup.py</code>.</p>
<h3>Steps to reproduce:</h3>

Create a virtual environment

<pre><code>$ cd /tmp
$ virtualenv test_env
New python executable in test_env/bin/python
Installing setuptools, pip...done.
$ source test_env/bin/activate
(test_env) $ 
</code></pre>

Clone a git repo with <code>setup.py</code>
<pre><code>(test_env) $ git clone https://github.com/behave/behave.git
Cloning into 'behave'...
remote: Reusing existing pack: 4350, done.
remote: Total 4350 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (4350/4350), 1.85 MiB | 418.00 KiB/s, done.
Resolving deltas: 100% (2388/2388), done.
Checking connectivity... done.
</code></pre>
<p>We have behave's <code>setup.py</code> in <code>/tmp/behave</code>:</p>
<pre><code>(test_env) $ ls /tmp/behave/setup.py
/tmp/behave/setup.py
</code></pre>

Install the python package from the git repo

<pre><code>(test_env) $ cd /tmp/behave &amp;&amp; python setup.py install
running install
...
Installed /private/tmp/test_env/lib/python2.7/site-packages/enum34-1.0-py2.7.egg
Finished processing dependencies for behave==1.2.5a1
</code></pre>
<h3>If we run the aforementioned solution from <code>/tmp</code></h3>
<pre><code>&gt;&gt;&gt; import pip
&gt;&gt;&gt; sorted(["%s==%s" % (i.key, i.version) for i in pip.get_installed_distributions()])
['behave==1.2.5a1', 'enum34==1.0', 'parse-type==0.3.4', 'parse==1.6.4', 'six==1.6.1']
&gt;&gt;&gt; import os
&gt;&gt;&gt; os.getcwd()
'/private/tmp'
</code></pre>
<h3>If we run the aforementioned solution from <code>/tmp/behave</code></h3>
<pre><code>&gt;&gt;&gt; import pip
&gt;&gt;&gt; sorted(["%s==%s" % (i.key, i.version) for i in pip.get_installed_distributions()])
['enum34==1.0', 'parse-type==0.3.4', 'parse==1.6.4', 'six==1.6.1']
&gt;&gt;&gt; import os
&gt;&gt;&gt; os.getcwd()
'/private/tmp/behave'
</code></pre>
<p><code>behave==1.2.5a1</code> is missing from the second example, because the working directory contains <code>behave</code>'s <code>setup.py</code> file.</p>
<p>I could not find any reference to this issue in the documentation. Perhaps I shall open a bug for it.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>help('modules')
</code></pre>
<p>in a Python shell/prompt.</p>
</div>
<div class="post-text" itemprop="text">
<p>Now, these methods I tried myself, and I got exactly what was advertised:  All the modules.</p>
<p>Alas, really you don't care much about the stdlib, you know what you get with a python install.  </p>
<p>Really, I want the stuff that <em>I</em> installed. </p>
<p>What actually, surprisingly, worked just fine was:</p>
<pre><code>pip freeze
</code></pre>
<p>Which returned:</p>
<pre><code>Fabric==0.9.3
apache-libcloud==0.4.0
bzr==2.3b4
distribute==0.6.14
docutils==0.7
greenlet==0.3.1
ipython==0.10.1
iterpipes==0.4
libxml2-python==2.6.21
</code></pre>
<p>I say "surprisingly" because the package install tool is the exact place one would expect to find this functionality, although not under the name 'freeze' but python packaging is so weird, that I am flabbergasted that this tool makes sense.  Pip 0.8.2, Python 2.7.  </p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li><p>In <a href="http://ipython.org/"><code>ipython</code></a> you can type "<code>import</code><kbd>Tab</kbd>".</p></li>
<li><p>In the standard Python interpreter, you can type "<code>help('modules')</code>".</p></li>
<li><p>At the command-line, you can use <a href="http://docs.python.org/library/pydoc.html"><code>pydoc</code></a> <code>modules</code>.</p></li>
<li><p>In a script, call <a href="http://docs.python.org/library/pkgutil.html#pkgutil.iter_modules"><code>pkgutil.iter_modules()</code></a>.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Since pip version 1.3, you've got access to:</p>
<pre><code>pip list
</code></pre>
<p>Which seems to be syntactic sugar for "pip freeze".  It will list all of the modules particular to your installation or virtualenv, along with their version numbers.  Unfortunately it does not display the current version number of any module, nor does it wash your dishes or shine your shoes.</p>
</div>
<div class="post-text" itemprop="text">
<p>In normal shell just use</p>
<pre><code>pydoc modules
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I just use this to see currently used modules:</p>
<pre><code>import sys as s
s.modules.keys()
</code></pre>
<p>which shows all modules running on your python.</p>
<p>For all built-in modules use:</p>
<pre><code>s.modules
</code></pre>
<p>Which is a dict containing all modules and import objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>As of pip 10, the accepted answer will no longer work.  The development team has removed access to the <code>get_installed_distributions</code> routine.  There is an alternate function in the <code>setuptools</code> for doing the same thing.  Here is an alternate version that works with pip 10:</p>
<pre><code>import pkg_resources
installed_packages = pkg_resources.working_set
installed_packages_list = sorted(["%s==%s" % (i.key, i.version)
     for i in installed_packages])
print(installed_packages_list)
</code></pre>
<p>Please let me know if it will or won't work in previous versions of pip, too.</p>
</div>
<div class="post-text" itemprop="text">
<p>If we need to list the installed packages in the Python shell, we can use the <code>help</code> command as follows</p>
<pre><code>&gt;&gt;help('modules package')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I normally use <code>pip list</code> to get a list of packages (with version).</p>
<p>This works in a virtual environment too, of course.</p>
</div>
<div class="post-text" itemprop="text">
<p>Very simple searching using <a href="http://docs.python.org/library/pkgutil.html#pkgutil.iter_modules" rel="noreferrer">pkgutil.iter_modules</a></p>
<pre><code>from pkgutil import iter_modules
a=iter_modules()
while True:
    try: x=a.next()
    except: break
    if 'searchstr' in x[1]: print x[1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I ran into a custom installed python 2.7 on OS X. It required X11 to list modules installed (both using help and pydoc).</p>
<p>To be able to list all modules without installing X11 I ran pydoc as http-server, i.e.:</p>
<pre><code>pydoc -p 12345
</code></pre>
<p>Then it's possible to direct Safari to <code>http://localhost:12345/</code> to see all modules.</p>
</div>
<div class="post-text" itemprop="text">
<p>on windows, Enter this in cmd</p>
<pre><code>c:\python\libs&gt;python -m pip freeze
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Aside from using <code>pip freeze</code> I have been installing <a href="http://pypi.python.org/pypi/yolk" rel="nofollow">yolk</a> in my virtual environments.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>to get all available modules, run <code>sys.modules</code></li>
<li>to get all <em>installed</em> modules (read: installed by <code>pip</code>), you may look at <code>pip.get_installed_distributions()</code></li>
</ol>
<p>For the second purpose, example code:</p>
<pre><code>import pip
for package in pip.get_installed_distributions():
    name = package.project_name # SQLAlchemy, Django, Flask-OAuthlib
    key = package.key # sqlalchemy, django, flask-oauthlib
    module_name = package._get_metadata("top_level.txt") # sqlalchemy, django, flask_oauthlib
    location = package.location # virtualenv lib directory etc.
    version = package.version # version number
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This solution is primary based on modules <code>importlib</code> and <code>pkgutil</code> and work with CPython 3.4 and CPython 3.5, but has no support for the CPython 2.</p>
<hr/>
<p><strong>Explanation</strong></p>
<ol>
<li><code>sys.builtin_module_names</code> - names all built-in modules (look my answer <a href="https://stackoverflow.com/a/42673644/6003870">here</a>)</li>
<li><code>pkgutil.iter_modules()</code> - returns an information about all available modules</li>
<li><code>importlib.util.find_spec()</code> - returns an information about importing module, if exists</li>
<li><code>BuiltinImporter</code> - an importer for built-in modules (<a href="https://docs.python.org/3/library/importlib.html#importlib.machinery.BuiltinImporter" rel="nofollow noreferrer">docs</a>)</li>
<li><code>SourceFileLoader</code> - an importer for a standard Python module (by default has extension *.py) (<a href="https://docs.python.org/3/library/importlib.html#importlib.machinery.SourceFileLoader" rel="nofollow noreferrer">docs</a>)</li>
<li><code>ExtensionFileLoader</code> - an importer for modules as <a href="http://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html" rel="nofollow noreferrer">shared library</a> (written on the C or C++)</li>
</ol>
<hr/>
<p><strong>Full code</strong></p>
<pre><code>import sys
import os
import shutil
import pkgutil
import importlib
import collections

if sys.version_info.major == 2:
    raise NotImplementedError('CPython 2 is not supported yet')


def main():

    # name this file (module)
    this_module_name = os.path.basename(__file__).rsplit('.')[0]

    # dict for loaders with their modules
    loaders = collections.OrderedDict()

    # names`s of build-in modules
    for module_name in sys.builtin_module_names:

        # find an information about a module by name
        module = importlib.util.find_spec(module_name)

        # add a key about a loader in the dict, if not exists yet
        if module.loader not in loaders:
            loaders[module.loader] = []

        # add a name and a location about imported module in the dict
        loaders[module.loader].append((module.name, module.origin))

    # all available non-build-in modules
    for module_name in pkgutil.iter_modules():

        # ignore this module
        if this_module_name == module_name[1]:
            continue

        # find an information about a module by name
        module = importlib.util.find_spec(module_name[1])

        # add a key about a loader in the dict, if not exists yet
        loader = type(module.loader)
        if loader not in loaders:
            loaders[loader] = []

        # add a name and a location about imported module in the dict
        loaders[loader].append((module.name, module.origin))

    # pretty print
    line = '-' * shutil.get_terminal_size().columns
    for loader, modules in loaders.items():
        print('{0}\n{1}: {2}\n{0}'.format(line, len(modules), loader))
        for module in modules:
            print('{0:30} | {1}'.format(module[0], module[1]))


if __name__ == '__main__':
    main()
</code></pre>
<hr/>
<p><strong>Usage</strong></p>
<p>For the CPython3.5 (truncated)</p>
<pre><code>$ python3.5 python_modules_info.py 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
30: &lt;class '_frozen_importlib.BuiltinImporter'&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_ast                           | built-in
_codecs                        | built-in
_collections                   | built-in
_functools                     | built-in
_imp                           | None
_io                            | built-in
_locale                        | built-in
_operator                      | built-in
_signal                        | built-in
_sre                           | built-in
_stat                          | built-in
_string                        | built-in
_symtable                      | built-in
_thread                        | built-in
(****************************truncated*******************************)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
227: &lt;class '_frozen_importlib_external.SourceFileLoader'&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
__future__                     | /usr/local/lib/python3.5/__future__.py
_bootlocale                    | /usr/local/lib/python3.5/_bootlocale.py
_collections_abc               | /usr/local/lib/python3.5/_collections_abc.py
_compat_pickle                 | /usr/local/lib/python3.5/_compat_pickle.py
_compression                   | /usr/local/lib/python3.5/_compression.py
_dummy_thread                  | /usr/local/lib/python3.5/_dummy_thread.py
_markupbase                    | /usr/local/lib/python3.5/_markupbase.py
_osx_support                   | /usr/local/lib/python3.5/_osx_support.py
_pydecimal                     | /usr/local/lib/python3.5/_pydecimal.py
_pyio                          | /usr/local/lib/python3.5/_pyio.py
_sitebuiltins                  | /usr/local/lib/python3.5/_sitebuiltins.py
(****************************truncated*******************************)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
64: &lt;class '_frozen_importlib_external.ExtensionFileLoader'&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_bisect                        | /usr/local/lib/python3.5/lib-dynload/_bisect.cpython-35m-x86_64-linux-gnu.so
_bz2                           | /usr/local/lib/python3.5/lib-dynload/_bz2.cpython-35m-x86_64-linux-gnu.so
_codecs_cn                     | /usr/local/lib/python3.5/lib-dynload/_codecs_cn.cpython-35m-x86_64-linux-gnu.so
_codecs_hk                     | /usr/local/lib/python3.5/lib-dynload/_codecs_hk.cpython-35m-x86_64-linux-gnu.so
_codecs_iso2022                | /usr/local/lib/python3.5/lib-dynload/_codecs_iso2022.cpython-35m-x86_64-linux-gnu.so
(****************************truncated*******************************)
</code></pre>
<p>For the CPython3.4 (truncated)</p>
<pre><code>$ python3.4 python_modules_info.py
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
54: &lt;class '_frozen_importlib.BuiltinImporter'&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_ast                           | built-in
_bisect                        | built-in
_codecs                        | built-in
_collections                   | built-in
_datetime                      | built-in
_elementtree                   | built-in
_functools                     | built-in
_heapq                         | built-in
_imp                           | None
_io                            | built-in
_locale                        | built-in
_md5                           | built-in
_operator                      | built-in
_pickle                        | built-in
_posixsubprocess               | built-in
_random                        | built-in
(****************************truncated*******************************)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
246: &lt;class '_frozen_importlib.SourceFileLoader'&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
__future__                     | /usr/lib/python3.4/__future__.py
_bootlocale                    | /usr/lib/python3.4/_bootlocale.py
_collections_abc               | /usr/lib/python3.4/_collections_abc.py
_compat_pickle                 | /usr/lib/python3.4/_compat_pickle.py
_dummy_thread                  | /usr/lib/python3.4/_dummy_thread.py
_markupbase                    | /usr/lib/python3.4/_markupbase.py
_osx_support                   | /usr/lib/python3.4/_osx_support.py
_pyio                          | /usr/lib/python3.4/_pyio.py
(****************************truncated*******************************)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
44: &lt;class '_frozen_importlib.ExtensionFileLoader'&gt;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_bz2                           | /usr/lib/python3.4/lib-dynload/_bz2.cpython-34m-x86_64-linux-gnu.so
_codecs_cn                     | /usr/lib/python3.4/lib-dynload/_codecs_cn.cpython-34m-x86_64-linux-gnu.so
_codecs_hk                     | /usr/lib/python3.4/lib-dynload/_codecs_hk.cpython-34m-x86_64-linux-gnu.so
_codecs_iso2022                | /usr/lib/python3.4/lib-dynload/_codecs_iso2022.cpython-34m-x86_64-linux-gnu.so
_codecs_jp                     | /usr/lib/python3.4/lib-dynload/_codecs_jp.cpython-34m-x86_64-linux-gnu.so
_codecs_kr                     | /usr/lib/python3.4/lib-dynload/_codecs_kr.cpython-34m-x86_64-linux-gnu.so
_codecs_tw                     | /usr/lib/python3.4/lib-dynload/_codecs_tw.cpython-34m-x86_64-linux-gnu.so
_crypt                         | /usr/lib/python3.4/lib-dynload/_crypt.cpython-34m-x86_64-linux-gnu.so
(****************************truncated*******************************)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>pip freeze</strong> does it all finding packages however one can simply write the following command to list all paths where python packages are.</p>
<pre><code>&gt;&gt;&gt; import site; site.getsitepackages()
['/usr/local/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In case you have an <a href="https://store.continuum.io/cshop/anaconda/" rel="nofollow">anaconda python distribution</a> installed, you could also use</p>
<pre><code>$conda list
</code></pre>
<p>in addition to solutions described above.</p>
</div>
<div class="post-text" itemprop="text">
<p>This was inspired by Adam Matan's <a href="https://stackoverflow.com/a/23885252/277267">answer</a> (the accepted one):</p>
<pre><code>import tabulate
try:
  from pip import get_installed_distributions
except:
  from pip._internal.utils.misc import get_installed_distributions

tabpackages = []
for _, package in sorted([('%s %s' % (i.location, i.key), i) for i in get_installed_distributions()]):
  tabpackages.append([package.location, package.key, package.version])

print(tabulate.tabulate(tabpackages))
</code></pre>
<p>which then prints out a table in the form of</p>
<pre><code>19:33 pi@rpi-v3 [iot-wifi-2] ~/python$ python installed_packages.py
-------------------------------------------  --------------  ------
/home/pi/.local/lib/python2.7/site-packages  enum-compat     0.0.2
/home/pi/.local/lib/python2.7/site-packages  enum34          1.1.6
/home/pi/.local/lib/python2.7/site-packages  pexpect         4.2.1
/home/pi/.local/lib/python2.7/site-packages  ptyprocess      0.5.2
/home/pi/.local/lib/python2.7/site-packages  pygatt          3.2.0
/home/pi/.local/lib/python2.7/site-packages  pyserial        3.4
/usr/local/lib/python2.7/dist-packages       bluepy          1.1.1
/usr/local/lib/python2.7/dist-packages       click           6.7
/usr/local/lib/python2.7/dist-packages       click-datetime  0.2
/usr/local/lib/python2.7/dist-packages       construct       2.8.21
/usr/local/lib/python2.7/dist-packages       pyaudio         0.2.11
/usr/local/lib/python2.7/dist-packages       tabulate        0.8.2
-------------------------------------------  --------------  ------
</code></pre>
<p>which lets you then easily discern which packages you installed with and without <code>sudo</code>.</p>
<hr/>
<p>A note aside: I've noticed that when I install a packet once via <code>sudo</code> and once without, one takes precedence so that the other one isn't being listed (only one location is shown). I believe that only the one in the local directory is then listed. This could be improved.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are many ideas, initially I am pondering on these two:</p>
<p><strong>pip</strong></p>
<blockquote>
<p>cons: not always installed</p>
</blockquote>
<p><strong>help('modules')</strong></p>
<blockquote>
<p>cons: output to console; with broken modules (see ubuntu...) can segfault</p>
</blockquote>
<p>I need an easy approach, using basic libraries and compatible with old python 2.x</p>
<p>And I see the light: <a href="http://svn.python.org/projects/python/tags/r256/Doc/tools/listmodules.py" rel="nofollow noreferrer">listmodules.py</a></p>
<p>Hidden in the documentation source directory in 2.5 is a small script that lists all available modules for a Python installation.</p>
<p>Pros:</p>
<blockquote>
<p>uses only <em>imp, sys, os, re, time</em></p>
<p>designed to run on Python 1.5.2 and newer</p>
<p>the source code is really compact, so you can easy tinkering with it, for example to pass an exception list of buggy modules (don't try to import them)</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><em>There are many way to skin a cat.</em></p>
<ul>
<li><p>The most simple way is to use the <code>pydoc</code> function directly from the shell with:<br/>
<code>pydoc modules</code></p></li>
<li><p>But for more information use the tool called <a href="https://github.com/E3V3A/pip-date" rel="nofollow noreferrer">pip-date</a> that also tell you the installation dates.<br/>
<code>pip install pip-date</code></p></li>
</ul>
<hr/>
<p><a href="https://i.stack.imgur.com/9rEqz.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/9rEqz.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>I needed to find the specific version of packages available by default in AWS Lambda. I did so with a mashup of ideas from this page. I'm sharing it for posterity.</p>
<pre><code>import pkgutil

__version__ = '0.1.1'

def get_ver(name):
    try:
        return str(__import__(name).__version__)
    except:
        return None

def lambda_handler(event, context):
    return {
        'statusCode': 200,
        'body': [{
                   'path': m.module_finder.path,
                   'name': m.name,
                   'version': get_ver(m.name),
                 } for m in list(pkgutil.iter_modules())
                 #if m.module_finder.path == "/var/runtime" # Uncomment this if you only care about a certain path
                ],
    }
</code></pre>
<p>What I discovered is that the provided boto3 library was way out of date and it wasn't my fault that my code was failing. I just needed to add boto3 and botocore to my project. But without this I would have been banging my head thinking my code was bad.</p>
<pre><code>{
  "statusCode": 200,
  "body": [
    {
      "path": "/var/task",
      "name": "lambda_function",
      "version": "0.1.1"
    },
    {
      "path": "/var/runtime",
      "name": "bootstrap",
      "version": null
    },
    {
      "path": "/var/runtime",
      "name": "boto3",
      "version": "1.9.42"
    },
    {
      "path": "/var/runtime",
      "name": "botocore",
      "version": "1.12.42"
    },
    {
      "path": "/var/runtime",
      "name": "dateutil",
      "version": "2.7.5"
    },
    {
      "path": "/var/runtime",
      "name": "docutils",
      "version": "0.14"
    },
    {
      "path": "/var/runtime",
      "name": "jmespath",
      "version": "0.9.3"
    },
    {
      "path": "/var/runtime",
      "name": "lambda_runtime_client",
      "version": null
    },
    {
      "path": "/var/runtime",
      "name": "lambda_runtime_exception",
      "version": null
    },
    {
      "path": "/var/runtime",
      "name": "lambda_runtime_marshaller",
      "version": null
    },
    {
      "path": "/var/runtime",
      "name": "s3transfer",
      "version": "0.1.13"
    },
    {
      "path": "/var/runtime",
      "name": "six",
      "version": "1.11.0"
    },
    {
      "path": "/var/runtime",
      "name": "test_bootstrap",
      "version": null
    },
    {
      "path": "/var/runtime",
      "name": "test_lambda_runtime_client",
      "version": null
    },
    {
      "path": "/var/runtime",
      "name": "test_lambda_runtime_marshaller",
      "version": null
    },
    {
      "path": "/var/runtime",
      "name": "urllib3",
      "version": "1.24.1"
    },
    {
      "path": "/var/lang/lib/python3.7",
      "name": "__future__",
      "version": null
    },
...
</code></pre>
<p>What I discovered was also different from <a href="https://docs.aws.amazon.com/lambda/latest/dg/current-supported-versions.html" rel="nofollow noreferrer">what they officially publish</a>. At the time of writing this:</p>
<blockquote>
<ul>
<li>Operating system – Amazon Linux</li>
<li>AMI – amzn-ami-hvm-2017.03.1.20170812-x86_64-gp2</li>
<li>Linux kernel – 4.14.77-70.59.amzn1.x86_64</li>
<li>AWS SDK for JavaScript – 2.290.0\</li>
<li>SDK for Python (Boto 3) – 3-1.7.74 botocore-1.10.74</li>
</ul>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>From the shell</p>
<pre><code>ls site-packages
</code></pre>
<p>If that's not helpful, you can do this.</p>
<pre><code>import sys
import os
for p in sys.path:
    print os.listdir( p )
</code></pre>
<p>And see what that produces.</p>
</div>
<span class="comment-copy">you can just do &gt;&gt;&gt;help() and then &gt;&gt;&gt;modules</span>
<span class="comment-copy">Is there an alternative?  help() hangs for me.</span>
<span class="comment-copy">A lot of these answers assume you have access to a command line. If you are using AWS Lambda, you have to do it all from inside Python. See <a href="https://stackoverflow.com/a/54939905/117471">stackoverflow.com/a/54939905/117471</a></span>
<span class="comment-copy">Thank you for this answer! I think it better answers the question because I ask "locally" installed Python modules. Pip freeze is also not always the way to go. This works better - I think.</span>
<span class="comment-copy">@Masi Just added a detailed explanation of the caveat of this solution. It is indeed a strange one.</span>
<span class="comment-copy">@Masi Done: <a href="http://bugs.python.org/issue21657" rel="nofollow noreferrer">bugs.python.org/issue21657</a></span>
<span class="comment-copy">An alternative: <code>import pkg_resources; installed_packages = [(d.project_name, d.version) for d in pkg_resources.working_set]</code></span>
<span class="comment-copy">As of pip 10, this answer will no longer work. The comment from @ebolyen shows alternative commands that do work.  I came to the same conclusion and posted the complete revised code below.</span>
<span class="comment-copy">Also <code>pydoc modules</code> from the shell should work.</span>
<span class="comment-copy">@dF <code>pydoc modules</code> works. You should submit it as an answer.</span>
<span class="comment-copy">Gave me a seg fault!</span>
<span class="comment-copy">nobar, zanbri, @Joe Frambach: on Ubuntu? There's a bug described here: <a href="https://bugs.launchpad.net/ubuntu/+source/python2.7/+bug/896836" rel="nofollow noreferrer">bugs.launchpad.net/ubuntu/+source/python2.7/+bug/896836</a></span>
<span class="comment-copy">Doesn't work with Enthought Python Distribution either.</span>
<span class="comment-copy">IS there an equivalent command in Windows for this?</span>
<span class="comment-copy">I guess the idea behind the name is that you get a "frozen" snapshot of what is installed right now, which you can later feed back into pip to get exactly the same modules installed in a different environment.</span>
<span class="comment-copy">Arash, you can install pip in Windows too! First install setuptools and then use easy_install to install pip :)</span>
<span class="comment-copy">This is excellent, but it seems to miss some of the libraries I installed. For example, it doesn't list PyQt.</span>
<span class="comment-copy">Starting from pip 1.3 there's the <a href="http://www.pip-installer.org/en/latest/usage.html#pip-list" rel="nofollow noreferrer">list</a> command.</span>
<span class="comment-copy"><code>pkgutil.iter_modules()</code> works, the pip solution above doesn't list all packages, just the ones installed via pip.</span>
<span class="comment-copy">Awesome! I think they have improved documentation, since the question was asked. <b>pydoc modules spam</b> searches spam in docs of modules. The last point seems to give you the sufficient information to use the module. @metaperture Can you, please, give an example how you list all local modules installed (not the massive list of stlib by help('modules')) by <b>pkgutil.iter_modules()</b>.</span>
<span class="comment-copy">@LéoLéopoldHertz준영 Try this snippet: <code>python -c 'import pkgutil;print [x[1] for x in list(pkgutil.iter_modules())]'</code>. It should dump all the module names as one really big Python list.  The <code>x[1]</code> bit is used to pluck the module name out of the tuples generated by <code>pkgutil.iter_modules()</code>.</span>
<span class="comment-copy">There is also <code>pip list --local</code> for distinguishing between <code>virtualenv</code> and global site packages, <a href="http://stackoverflow.com/a/24661035/1959808">discussed here</a>.</span>
<span class="comment-copy">It appears that the above works only on 'nix platforms. In any case, I found and ran the script, adapting the command as follows: c:\bin\pythos_2.7\lib\pydoc.py modules - that list took forever to build, the format sucks, and it omits the installed version number. I'll pass.</span>
<span class="comment-copy">@DavidA.Gray Just tried this on a Windows machine with Python 3, and it does in fact work. Using the python windows launcher you can do <code>py -m pydoc modules</code> in cmd or Powershell.</span>
<span class="comment-copy">import sys as s</span>
<span class="comment-copy"># After you import sys "import sys as s" you can print with:                  print sys.modules.keys()</span>
<span class="comment-copy">More on the sys module can be found here:  <a href="http://effbot.org/librarybook/sys.htm" rel="nofollow noreferrer">effbot.org/librarybook/sys.htm</a></span>
<span class="comment-copy">Upvoted, because this is the only method that seems to work on constrained systems which have neither <code>pydoc</code> nor <code>pip</code> installed (a NAS in my case).</span>
<span class="comment-copy">Agreed with Thomas. I'm using repl.it , for example, which is also a constrained type of environment. <code>help('modules')</code> just hangs without response for me. But this approach with <code>sys</code> works perfectly</span>
<span class="comment-copy">I have been searching for this solution and wracking my brain trying to figure out pkg_resources.  If I could upvote this more than once I would.  Thank you, @Big_Al_Tx !  Update: Except.... when I do a 'pip freeze' in my virtual environment and compare it to the output of this, there are packages that are missing.  Any thoughts on why that could/would happen?</span>
<span class="comment-copy">@numberwhun - I'm glad this worked for you.  I'm sorry, but I don't have an answer for the discrepancy with <code>pip freeze</code>; the depth of my knowledge on this topic is rather limited. I sort-of fumbled my way to the solution when the accepted answer didn't work for me and I tried combining it with an answer related to <code>setuptools</code> and got it to work.</span>
<span class="comment-copy"><a href="https://github.com/pypa/pip/issues/5243" rel="nofollow noreferrer">github.com/pypa/pip/issues/5243</a> -  The talk of development team about removed access to the <code>get_installed_distributions routine</code>.</span>
<span class="comment-copy">@bl79 - I think that's the exact place where I got the reference for <code>setuptools</code>.</span>
<span class="comment-copy">@Big_Al_Tx: Well, I sort of worked around the setuptools option (which was waaaay to obfuscated for my needs) and I went with this:    installed_pkgs = subprocess.check_output(['pip', 'freeze'])  It does exactly what I needed it to do.... Yay!!</span>
<span class="comment-copy">this is the best way</span>
<span class="comment-copy">This worked for me using:  python3 -m pip freeze  - for python 3.5.3.</span>
<span class="comment-copy">This works well and you do not need to be in the libs directory as well if your variables are defined</span>
<span class="comment-copy">The command <b>sys.modules</b> does not work in the newest OSX's Python. <b>NameError: name 'system' is not defined</b>.</span>
<span class="comment-copy">@Masi Did you mean <code>/usr/bin/python</code> or the one come from <a href="http://python.org" rel="nofollow noreferrer">python.org</a> ? For the former one, I can use <code>sys.modules</code> without a problem.</span>
<span class="comment-copy">I mean <b>/usr/bin/python</b>.</span>
<span class="comment-copy">@Masi Not sure if you are still interested in this problem. Apparently you are using <code>system.modules</code> instead of <code>sys.modules</code>.</span>
<span class="comment-copy">Lol. My mistake was that I did not originally import sys -package. So running instead <b>import sys; sys.modules</b> work as expected.</span>
<span class="comment-copy">Can you please compare your approach to Adam's approach here <a href="http://stackoverflow.com/a/23885252/54964">stackoverflow.com/a/23885252/54964</a></span>
<span class="comment-copy">@Léo Léopold Hertz, why are you need it?</span>
<span class="comment-copy">To understand how your approach is better/worser than Adam's approach.</span>
<span class="comment-copy">@Léo Léopold Hertz. A short answer: try it yourself in a production and draw conclusions yourself. Long answer: the Adam's approach is based on the <code>pip</code> - package management system used to install and manage software packages written in Python and a result <code>pip.get_installed_distributions()</code> returns modules installed with the pip. My answer entirely based on the Python`s standard library and cover all modules available for import. A biggest drawback my answer - no a support for the the CPython 2.</span>
<span class="comment-copy">@Léo Léopold Hertz you are mistaken, it does it. I tested it on my computer. My answer contains special meaning <code>**truncated**</code>, where a output is truncated. Maybe you not careful, but if it does not it, so to send me an information about your system and the Python implementation, I will make addition research for fix it.</span>
<span class="comment-copy">Where/how do you run this line?</span>
<span class="comment-copy">If you are on your UNIX/Mac OS X machine, open up your terminal and just type <code>conda install</code>, it should work :)</span>
<span class="comment-copy">I'm on a Windows 7 machine.  I found it in my path actually, but conda.exe is in AppData\Local\Continuum\Anaconda\Scripts.</span>
<span class="comment-copy">which site-packages directory? This might do better:      ls /usr/{local/,}lib/python$(python -V 2&gt;&amp;1|cut -d" " -f2 |cut -d. -f1-2)/site-packages</span>
<span class="comment-copy">Also this will not show built-in modules, or modules in a custom PYTHONPATH, or ones installed in setuptools "development mode" etc.</span>
<span class="comment-copy">My /usr/local/lib/python2.5/site-packages is empty, although I have installed modules.</span>
<span class="comment-copy">Kudos for not deleting this downvoted answer.  It's helpful to the community to be able to see why a common answer is considered wrong.</span>
<span class="comment-copy">@JeremyStein A better strategy (more helpful and probably less rep-damaging) would probably be to edit the question to explain why it's wrong, once this has been explained in the comments...</span>
