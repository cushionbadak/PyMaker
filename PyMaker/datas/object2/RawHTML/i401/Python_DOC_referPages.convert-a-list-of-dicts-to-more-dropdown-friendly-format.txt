<div class="post-text" itemprop="text">
<p>I am trying to create a friendly format for multiple dependent HTML dropdowns.</p>
<p>How can I convert the dictionary <code>d</code> so it looks like the dictionary <code>output</code>?</p>
<pre><code>d = [
    {"state": "California", "county": "Monterey", "city": "Salinas"},
    {"state": "California", "county": "Monterey", "city": "Gonzales"},
    {"state": "Oregon", "county": "Douglas", "city": "Roseburg"},
    {"state": "Oregon", "county": "Douglas", "city": "Winston"},
    {"state": "California", "county": "Alameda", "city": "Berkeley"},
]

output = {
    "California": {
        "Monterey": ["Salinas", "Gonzales"],
        "Alameda": ["Berkeley"],
    },
    "Oregon": {
        "Douglas": ["Roseburg", "Winston"],
    }
}
</code></pre>
<p>I would rather NOT use Pandas for this, just pure Python, as I will need to translate the solution to JavaScript as well (nevertheless, I have tried converting <code>d</code> into a dataframe, applying various orientations, but none have given me the output I want).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this using nothing but <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer">basic dictionaries with setdefault</a>:</p>
<pre><code>d = [
    {"state": "California", "county": "Monterey", "city": "Salinas"},
    {"state": "California", "county": "Monterey", "city": "Gonzales"},
    {"state": "Oregon", "county": "Douglas", "city": "Roseburg"},
    {"state": "Oregon", "county": "Douglas", "city": "Winston"},
    {"state": "California", "county": "Alameda", "city": "Berkeley"},
]

states = {}
for inner_dict in d:
    state  = inner_dict["state"]      # not strictly needed
    county = inner_dict["county"]     # you could simply add them
    city   = inner_dict["city"]       # directly to the setdefaults

    states.setdefault(state, {}).setdefault(county, []).append(city)


print(states)
</code></pre>
<p>Output:</p>
<pre><code>{'California': {'Monterey': ['Salinas', 'Gonzales'], 
                'Alameda': ['Berkeley']}, 
 'Oregon': {'Douglas': ['Roseburg', 'Winston']}}
</code></pre>
<p>If you need it faster, look <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">for <code>collections.defaultdict</code>'s</a> which have no overhead of creating the default-object every time:</p>
</div>
<div class="post-text" itemprop="text">
<p>Loop through the list and process each dictionary, adding each entry to the proper place in your output, creating new dictionaries and lists when necessary.</p>
<pre><code>d = [
    {"state": "California", "county": "Monterey", "city": "Salinas"},
    {"state": "California", "county": "Monterey", "city": "Gonzales"},
    {"state": "Oregon", "county": "Douglas", "city": "Roseburg"},
    {"state": "Oregon", "county": "Douglas", "city": "Winston"},
    {"state": "California", "county": "Alameda", "city": "Berkeley"},
]

output = {}

for place in d:
    if place['state'] not in output:
        output[place['state']] = {}
    if place['county'] not in output[place['state']]:
        output[place['state']][place['county']] = []
    output[place['state']][place['county']].append(place['city'])
</code></pre>
<p>Result:</p>
<pre><code>&gt;&gt;&gt; import pprint
&gt;&gt;&gt; pprint.pprint(output, width=30)
{'California': {'Alameda': ['Berkeley'],
                'Monterey': ['Salinas',
                             'Gonzales']},
 'Oregon': {'Douglas': ['Roseburg',
                        'Winston']}}
</code></pre>
<p>Or, with <code>collections.defaultdict</code>:</p>
<pre><code>from collections import defaultdict as dd
output = dd(lambda: dd(list))
for place in d:
    output[place['state']][place['county']].append(place['city'])
</code></pre>
<p>The result:</p>
<pre><code>&gt;&gt;&gt; pprint.pprint(output)
defaultdict(&lt;function &lt;lambda&gt; at 0x000000E254B53E18&gt;,
            {'California': defaultdict(&lt;class 'list'&gt;,
                                       {'Alameda': ['Berkeley'],
                                        'Monterey': ['Salinas', 'Gonzales']}),
             'Oregon': defaultdict(&lt;class 'list'&gt;,
                                   {'Douglas': ['Roseburg', 'Winston']})})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>These are some utility functions I like to use all the time:</p>
<pre><code>from collections import defaultdict

def group_by_key_func(iterable, key_func):
    result = defaultdict(list)
    for item in iterable:
        result[key_func(item)].append(item)
    return result

def group_by_key(iterable, key):
    return group_by_key_func(iterable, lambda x: x[key])
</code></pre>
<p>With them, the answer becomes:</p>
<pre><code>output = {
    state: {
        county: [row['city'] for row in county_group]
        for county, county_group in group_by_key(state_group, 'county').items()
    }
    for state, state_group in group_by_key(d, 'state').items()
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a version that does a minimal amount of <code>dict</code> look ups (by using <code>dict.get</code> and checking for <code>None</code>) and the minimal creation of empty <code>dict</code>s and <code>list</code>s (by not using something like <code>dict.setdefault(..., [])</code>, where the possible default is always created). For the size of data, this probably makes no difference, but others beat me to my original answer, so thought this might be nice to see.</p>
<pre><code>def make_dropdown_data(items):
    data = {}
    for item in items:
        state = item['state']
        state_data = data.get(state)
        if state_data is None:
            data[state] = state_data = {}
        county = item['county']
        county_data = state_data.get(county)
        if county_data is None:
            state_data[county] = county_data = []
        county_data.append(item['city'])
    return data
</code></pre>
<p>You can easily see where objects are created with:</p>
<pre><code>import dis
dis.disassemble(make_dropdown_data.__code__)
</code></pre>
</div>
<span class="comment-copy">Have you tried looping through <code>d</code>, checking whether the current dictionary's state exists in <code>output</code>, creating it if necessary, checking whether the county exists, creating if necessary, etc.? What else have you tried, if not that?</span>
<span class="comment-copy">As stated in my question, I have tried Pandas. BTW, the output is not given beforehand, so I cannot compare anything with it.</span>
<span class="comment-copy">Excellent use of defaultdict. But I don't think the <code>as dd</code> is a good idea.</span>
