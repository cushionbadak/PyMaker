<div class="post-text" itemprop="text">
<p>I want to refer to an element (<code>mem[0]</code>) of a list (<code>mem</code>) with a different name (<code>fetch</code>):</p>
<pre><code>mem = [0]
f = open("File.lx", "rb").read()
for b in f: mem += [b]
size = len(mem)

while mem[0] &lt; size:        #using mem[0]
    char = (mem[0]*2)+1
    source = mem[char]
    target = mem[char + 1]

    mem[0] += 1
    mem[target] = mem[source]
</code></pre>
<p>And I tried that with the <code>with</code> statement:</p>
<pre><code>mem = [0]
f = open("File.lx", "rb").read()
for b in f: mem += [b]
size = len(mem)

with mem[0] as fetch:        #with statement
   while fetch &lt; size:       #using mem[0] as fetch
    char = (fetch*2)+1
    source = mem[char]
    target = mem[char + 1]

    fetch += 1
    mem[target] = mem[source]
</code></pre>
<p>But I got an error:</p>
<pre><code>Traceback (most recent call last):
  File "C:\documents\test.py", line 6, in &lt;module&gt;
    with mem[0] as fetch:
AttributeError: __enter__
</code></pre>
<p>I thought this would be the way because that's how it's done with file objects:</p>
<pre><code>with open("File.lx", "rb") as file:
    fileBytes = file.read()
</code></pre>
<p>I read the <a href="https://docs.python.org/3/reference/compound_stmts.html#grammar-token-with-stmt" rel="nofollow noreferrer">docs</a> for the <code>with</code> statement and it says that the <code>__exit()__</code> and <code>__enter()__</code> methods are loaded. According to what I understood after reading that and from the <code>AttributeError</code>, my guess is that sequence elements (<code>mem[0]</code>) do not have an <code>__enter()__</code> method.</p>
</div>
<div class="post-text" itemprop="text">
<p>as the comments already mentioned, <code>mem[0]</code> is a literal integer, which doesn't have <code>__enter__</code> and <code>__exit__</code> which are required for the <code>as</code> keyword to work and it would be indeed simpler if you just used <code>mem[0]</code> </p>
<p>but that would be too easy, what you CAN do (as an exercise don't actually do this)
is extend the <code>int</code> class and add <code>__enter__</code> and <code>__exit__</code> like so:</p>
<pre><code>class FancyInt(int):
    def __enter__(self):
        return self
    def __exit__(self, *args):
        pass

mem = [FancyInt(0)]
with mem[0] as fetch:
    print(fetch)
</code></pre>
<p>this is neat but <code>fetch</code> is an alias to a <strong>LITERAL!</strong> if you change <code>fetch</code>, <code>mem[0]</code> will not change!</p>
</div>
<div class="post-text" itemprop="text">
<p>You seem to want a mutable object which functions as an alias for a specific location in a list. I could see <em>some</em> utility in that (since explicit indices are somewhat ugly in Python). You could create such a class. Here is a proof of concept, implementing the three things that you tried to do with <code>fetch</code> in your code:</p>
<pre><code>class Fetcher:
    def __init__(self,target_list, index):
        self._list = target_list
        self._i = index

    def __iadd__(self,v):
        self._list[self._i] += v
        return self

    def __mul__(self,v):
        return self._list[self._i] * v

    def __lt__(self,v):
        return self._list[self._i] &lt; v
</code></pre>
<p>For example,</p>
<pre><code>mem = [0,1,2]
fetch = Fetcher(mem,0)

print(fetch &lt; 2) #true
mem[0] = 1
print(fetch &lt; 2) #still true
fetch += 1
print(fetch &lt; 2) #false!
print(mem[0]) #2, showing that mem[0] was changed
print(fetch*2) #4 -- but 2*fetch won't work!
</code></pre>
<p>The last line shows that there is a limit to what you could achieve here. To make this really useful, you would want to implement many more magic methods (beyond <code>__iadd__</code> etc.). Whether or not all this is useful just to avoid <code>[0]</code>, you be the judge.</p>
</div>
<span class="comment-copy">The item at <code>mem[0]</code> is a literal (in this case, an integer, <code>0</code>). A literal doesn't have the <code>__enter()__</code> method</span>
<span class="comment-copy">Maybe try to explain why you think you need to do this. There is almost certainly a much simpler way to achieve it</span>
<span class="comment-copy">and you need to read the next <a href="https://docs.python.org/3/library/contextlib.html#" rel="nofollow noreferrer">doc</a></span>
<span class="comment-copy">Why not simply <code>fetch = mem[0]</code> without the <code>with</code>? There isn't any clean-up for <code>with</code> to do. Garbage collection will take care of any memory used.</span>
<span class="comment-copy">@JohnColeman In some instances the last line (<code>mem[target] = mem[source]</code>) will refer to <code>mem[0]</code> and the value of <code>fetch</code> has to update as well.</span>
