<div class="post-text" itemprop="text">
<p>I'm working on a brain teaser where I want to calculate all of the possible distances between 4 cities. I wrote a function where you can input the x and y coordinates of the two cities and it'll calculate the distance between them.</p>
<p>While I can individually call the function 6 times,
that seems inefficient if the data set gets bigger. I think I should be using nested "for loops" but I can't figure out a way to properly increment the inner loop.  </p>
<p>My initial idea was to create a list of object and use that in inner loop. </p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>import math #Imports the math module

def calc_euclidean(x1,y1,x2,y2): #Function takes 4 arguments
    xDistancesqrd=math.pow((x2-x1),2) #x2-x1 squared
    yDistancesqrd=math.pow((y2-y1),2) #y2-y1 squared
    euclideanDistance=math.sqrt(xDistancesqrd+yDistancesqrd) #distance=square root (x2-x1)^2+(y2-y1)^2
    return euclideanDistance #Returns the result of the calculation, the euclidean distance between the points.

Budapest=[47.4979, 19.0402]
Vienna=[48.210033, 16.363449]
Sofia=[42.6977, 23.3219]
Zagreb=[45.8150, 15.9819]

cities=[Budapest,Vienna,Sofia,Zagreb]</code></pre>
</div>
</div>
</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations()</code></a> like:</p>
<h3>Code:</h3>
<pre><code>for c1, c2 in it.combinations(cities, 2):
    print(c1, c2, calc_euclidean(c1[0], c1[1], c2[0], c2[1]))
</code></pre>
<h3>Test Code:</h3>
<pre><code>import math  # Imports the math module
import itertools as it


def calc_euclidean(x1, y1, x2, y2):  # Function takes 4 arguments
    xDistancesqrd = math.pow((x2 - x1), 2)  # x2-x1 squared
    yDistancesqrd = math.pow((y2 - y1), 2)  # y2-y1 squared
    euclideanDistance = math.sqrt(
        xDistancesqrd + yDistancesqrd)  # distance=square root (x2-x1)^2+(y2-y1)^2
    return euclideanDistance  # Returns the result of the calculation, the euclidean distance between the points.


Budapest = [47.4979, 19.0402]
Vienna = [48.210033, 16.363449]
Sofia = [42.6977, 23.3219]
Zagreb = [45.8150, 15.9819]

cities = [Budapest, Vienna, Sofia, Zagreb]
for c1, c2 in it.combinations(cities, 2):
    print(c1, c2, calc_euclidean(c1[0], c1[1], c2[0], c2[1]))
</code></pre>
<h3>Results:</h3>
<pre><code>[47.4979, 19.0402] [48.210033, 16.363449] 2.769860885620431
[47.4979, 19.0402] [42.6977, 23.3219] 6.432330443159777
[47.4979, 19.0402] [45.815, 15.9819] 3.4907522541710128
[48.210033, 16.363449] [42.6977, 23.3219] 8.877266213327731
[48.210033, 16.363449] [45.815, 15.9819] 2.4252345681376934
[42.6977, 23.3219] [45.815, 15.9819] 7.974531916670721
</code></pre>
</div>
<span class="comment-copy">You can do calculations on sphere angles (degrees) simply by applying the Pythagoras theorem.</span>
<span class="comment-copy">@KlausD. That's what the OP seems to be doing.</span>
<span class="comment-copy">@Selcuk My autocorrect hit me harder than usual: You <b>can't</b> do...</span>
<span class="comment-copy">@KlausD. It is ironic that it was Pythagoras who first proposed a spherical Earth too. That being said, Pythagoras theorem is a good approximation for cities in Europe, as they are very close to each other when compared to the size of the Earth therefore can be assumed that they are on a plane.</span>
