<div class="post-text" itemprop="text">
<p>Is it possible to patch over a class instance variable and force it to return a different value each time that it's referenced? specifically, I'm interested in doing this with the <strong>side_effect</strong> parameter</p>
<ul>
<li>I know that when patching over a method it is possible to assign a <strong>side_effect</strong> to a mock method. If you set the <strong>side_effect</strong> to be a list it will iterate through the list returning a different value each time it is called. </li>
<li>I would like to do the same thing with a class instance variable but cannot get it to work and I cannot see any documentation to suggest whether this is or is not possible</li>
</ul>
<h3>Example</h3>
<pre><code>from unittest.mock import patch

def run_test():
    myClass = MyClass()
    for i in range(2):
        print(myClass.member_variable)

class MyClass():
    def __init__(self):
        self.member_variable = None

@patch('test_me.MyClass.member_variable',side_effect=[1,2], create=True)
def test_stuff(my_mock):
    run_test()
    assert False
</code></pre>
<h3>Output</h3>
<pre><code>-------------- Captured stdout call ---------------------------------------------------------------------------------------------------------------------
None
None
</code></pre>
<h3>Desired Output</h3>
<pre><code>-------------- Captured stdout call ---------------------------------------------------------------------------------------------------------------------
1
2
</code></pre>
<ul>
<li>To be clear - I'm aware that I can wrap <strong>member_variable</strong> in a <strong>get_member_variable method()</strong>. That is not my question. I just want to know if you can patch a member variable with a side_effect. </li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><code>side_effect</code> can be either a function, an iterable or an exception (<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect</a>). I think that's the reason why it's not working.</p>
<p>Another way to test this would be:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; class Class:
...     member_variable = None
...
&gt;&gt;&gt; with patch('__main__.Class') as MockClass:
...     instance = MockClass.return_value
...     instance.member_variable = 'foo'
...     assert Class() is instance
...     assert Class().member_variable == 'foo'
...
</code></pre>
<p>Here's the docs: <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch</a></p>
</div>
<span class="comment-copy">AFAIK <code>side_effect</code> will only work on callables</span>
<span class="comment-copy">@yorodm Thanks for your response. Do you have any documentation about this that you can direct me to?</span>
<span class="comment-copy">Is all over the place in <a href="https://github.com/python/cpython/blob/master/Lib/unittest/mock.py" rel="nofollow noreferrer">mock.py</a></span>
<span class="comment-copy">Yes, I have tried setting side_effect to an iterable.  That's exactly what I want to do. It works on methods, but I can't get it to work on attributes</span>
