<div class="post-text" itemprop="text">
<p>I have this list of integers:</p>
<pre><code>l = [6, 6, 0, 5, 4, 5, 0, 0, 4, 6]
</code></pre>
<p>and I would have to generate the following list, by splitting the above list using consecutive zeros as a separator, in order to get:</p>
<pre><code>res = [[6, 6], [5, 4, 5] , [4, 6]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> in order to group the elements in the list that appear between <code>0s</code>:</p>
<pre><code>from itertools import groupby
[list(v) for k,v in groupby(l, key = lambda x: x != 0) if k != 0]
# [[6, 6], [5, 4, 5], [4, 6]]
</code></pre>
<hr/>
<p><b> Details </b></p>
<p>The <code>key</code> argument here <code>key = lambda x: x != 0</code> is transforming the list so that it is instead grouped by:</p>
<pre><code>[x != 0 for x in l]
# [True, True, False, True, True, True, False, False, True, True]
</code></pre>
<p>Note that that <code>groupby</code> groups consecutive values that are equal.
So this key will yield the following values as a result of the <code>groupby</code>:</p>
<pre><code>[list(v) for k,v in groupby(l, key = lambda x: x != 0)]
[[6, 6], [0], [5, 4, 5], [0, 0], [4, 6]]
</code></pre>
<p>Now we only have to specify that we want to keep the <code>values</code> if the <code>key</code> is not <code>0</code>, which can be done by adding <code>if k != 0</code> at the end of the list comprehension.</p>
<hr/>
<p>Helpful reads:</p>
<ul>
<li><a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer">List comprehensions</a></li>
<li><a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Python has an amazing feature we can use for that called slicing.
i think this approach is easier than other answer that uses itertools.groupby.</p>
<p><strong>code:</strong></p>
<pre><code>l = [6, 6, 0, 5, 4, 5, 0, 0, 4, 6]
res = list(map(list, zip(l[::2], l[1::2])))
print(res)
</code></pre>
<p><strong>result:</strong></p>
<pre><code>[(6, 6), (0, 5), (4, 5), (0, 0), (4, 6)]
</code></pre>
<p><strong>alternative using list comprehension instead of map built-in func:</strong></p>
<pre><code>res = [list(i) for i in (zip(l[::2], l[1::2]))] 
</code></pre>
<p><strong>explanation:</strong></p>
<p><strong>the zip()</strong> function take iterables (like: list, string, dict), or user-defined iterables and returns an iterator of tuples based on the iterable object.</p>
<p><strong>the map()</strong> function takes two arguments, The first argument is the name of a function and the second a sequence (e.g. a list) seq. </p>
<p>map() applies a function to all the elements of the sequence.</p>
<p>we use it here to apply list built-in function to all tuples results from zip function.</p>
<p>with help of <strong>slicing</strong>, we give zip function two iterables made from your list, one start from first item with increment of two, and other start from the second item, with also increment set to two.</p>
<p><strong>explaining slicing used here:</strong> 
l[::2]   </p>
<blockquote>
<p>Lists have a default bit of functionality when slicing. If there is no
  value before the first colon, it means to start at the beginning index
  of the list. If there isn't a value after the first colon, it means to
  go all the way to the end of the list. That last colon tells Python
  that we'd like to choose our slicing increment. By default, Python
  sets this increment to 1, but that extra colon at the end of the
  numbers allows us to specify what we want it to be.</p>
</blockquote>
<p><strong>slicing tutorial:</strong></p>
<p><a href="https://www.digitalocean.com/community/tutorials/how-to-index-and-slice-strings-in-python-3" rel="nofollow noreferrer">link</a></p>
<p><strong>python zip function docs:</strong></p>
<p><a href="https://docs.python.org/3.3/library/functions.html#zip" rel="nofollow noreferrer">link</a></p>
<p><strong>python map function docs:</strong></p>
<p><a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer">link</a></p>
<p><strong>python list comprehension docs:</strong></p>
<p><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">link</a></p>
</div>
<span class="comment-copy">Welcome to StackOverflow. This question is missing context or other details: Please improve the question by providing additional context, which ideally includes your thoughts on the problem and any attempts you have made to solve it. This information helps others identify where you have difficulties and helps them write answers appropriate to your experience level. You also need to state exactly what your difficulty is, what you expected, what you got, and any traceback.</span>
<span class="comment-copy">Thank you! I'm starting learning python and this kind of syntax is still difficult for me! I will check as answered as soon as I can!</span>
<span class="comment-copy">Hi @Marco, added some explanations. Hope it's clearer now. Let me know if you have any doubts</span>
<span class="comment-copy">This is clever. Even a non-beginner like me had to look twice to understand it. An insight that might help is that it works just as well if <code>key=lambda x: x == 0</code> !</span>
<span class="comment-copy">Yes that's right @BarryRogerson the point is to group the elements by some distinctive key. Thanks :)</span>
<span class="comment-copy">@yatu i think the approach i showed in my answer  is easier and cleaner, using python slicing and zip() built-in func, without loading any modules. check it out and let me know if you agree. in the end, your code work correctly as intended. good job.</span>
