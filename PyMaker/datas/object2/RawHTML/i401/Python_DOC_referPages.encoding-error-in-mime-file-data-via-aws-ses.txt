<div class="post-text" itemprop="text">
<p>I am trying to retrieve attachments data like file format and name of file from MIME via aws SES. Unfortunately some time file name encoding is changed, like file name is "3_amrishmishra_Entry Level Resume - 02.pdf" and in MIME it appears as '=?UTF-8?Q?amrishmishra=5FEntry_Level_Resume_=E2=80=93_02=2Epdf?=', any way to get exact file name?</p>
<pre><code>if email_message.is_multipart():
message = ''
if "apply" in receiver_email.split('@')[0].split('_')[0] and isinstance(int(receiver_email.split('@')[0].split('_')[1]), int):
    for part in email_message.walk():
        content_type = str(part.get_content_type()).lower()
        content_dispo = str(part.get('Content-Disposition')).lower()
        print(content_type, content_dispo)

        if 'text/plain' in content_type and "attachment" not in content_dispo:
            message = part.get_payload()


        if content_type in ['application/pdf', 'text/plain', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'image/jpeg', 'image/jpg', 'image/png', 'image/gif'] and "attachment" in content_dispo:
            filename = part.get_filename()
            # open('/tmp/local' + filename, 'wb').write(part.get_payload(decode=True))
            # s3r.meta.client.upload_file('/tmp/local' + filename, bucket_to_upload, filename)

            data = {
                'base64_resume': part.get_payload(),
                'filename': filename,
            }
            data_list.append(data)
    try:
        api_data = {
            'email_data': email_data,
            'resumes_data': data_list
        }
        print(len(data_list))
        response = requests.post(url, data=json.dumps(api_data),
                                 headers={'content-type': 'application/json'})
        print(response.status_code, response.content)
    except Exception as e:
        print("error %s" % e)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This syntax <code>'=?UTF-8?Q?...?='</code> is a <a href="https://en.wikipedia.org/wiki/MIME#Encoded-Word" rel="nofollow noreferrer">MIME encoded word</a>. It is used in MIME email when a header value includes non-ASCII characters (gory details in <a href="https://tools.ietf.org/html/rfc2047" rel="nofollow noreferrer">RFC 2047</a>). Your attachment filename includes an "en dash" character, which is why it was sent with this encoding.</p>
<p>The best way to handle it depends on which Python version you're using...</p>
<p><strong>Python 3</strong> </p>
<p>Python 3's updated <a href="https://docs.python.org/3/library/email.parser.html" rel="nofollow noreferrer"><code>email.parser</code></a> package can correctly decode RFC 2047 headers for you:</p>
<pre class="lang-py prettyprint-override"><code># Python 3
from email import message_from_bytes, policy

raw_message_bytes = b"&lt;&lt; the MIME message you downloaded from SES &gt;&gt;"
message = message_from_bytes(raw_message_bytes, policy=policy.default)
for attachment in message.iter_attachments():
    # (EmailMessage.iter_attachments is new in Python 3)
    print(attachment.get_filename())
    # amrishmishra_Entry Level Resume – 02.pdf
</code></pre>
<p>You must specifically request <code>policy.default</code>. If you don't, the parser will use a <code>compat32</code> policy that replicates Python 2.7's buggy behavior—including not decoding RFC 2047. (Also, early Python 3 releases were still shaking out bugs in the new email package, so make sure you're on Python 3.5 or later.) </p>
<p><strong>Python 2</strong> </p>
<p>If you're on Python 2, the <strong>best</strong> option is upgrading to Python 3.5 or later, if at all possible. Python 2's email parser has <em>many bugs and limitations</em> that were fixed with a massive rewrite in Python 3. (And the rewrite added handy new features like <code>iter_attachments()</code> shown above.)</p>
<p>If you can't switch to Python 3, you can decode the RFC 2047 filename yourself using <a href="https://docs.python.org/2.7/library/email.header.html?highlight=decode_header#email.header.decode_header" rel="nofollow noreferrer"><code>email.header.decode_header</code></a>:</p>
<pre><code># Python 2 (also works in Python 3, but you shouldn't need it there)
from email.header import decode_header

filename = '=?UTF-8?Q?amrishmishra=5FEntry_Level_Resume_=E2=80=93_02=2Epdf?='
decode_header(filename)
# [('amrishmishra_Entry Level Resume \xe2\x80\x93 02.pdf', 'utf-8')]

(decoded_string, charset) = decode_header(filename)[0]
decoded_string.decode(charset)
# u'amrishmishra_Entry Level Resume – 02.pdf'
</code></pre>
<p>But again, if you're trying to parse real-world email in Python 2.7, be aware that this is probably <em>just the first</em> of several problems you'll encounter.</p>
<p>The <a href="https://anymail.readthedocs.io/" rel="nofollow noreferrer">django-anymail</a> package I maintain includes a <a href="https://github.com/anymail/django-anymail/blob/v6.0/anymail/_email_compat.py" rel="nofollow noreferrer">compatibility version</a> of <code>email.parser.BytesParser</code> that tries to work around several (but not <em>all</em>) <a href="https://github.com/anymail/django-anymail/blob/v6.0/tests/test_inbound.py#L498-L591" rel="nofollow noreferrer">other bugs</a> in Python 2.7 email parsing. You may be able to borrow that (internal) code for your purposes. (Or since you tagged your question Django, you might want to look into Anymail's normalized <a href="https://anymail.readthedocs.io/en/stable/inbound/" rel="nofollow noreferrer">inbound email</a> handling, which includes Amazon SES support.)</p>
</div>
<span class="comment-copy">where's your code?</span>
<span class="comment-copy">@dirkgroten updated :)</span>
<span class="comment-copy">What is <code>email_message</code>? I mean what class? How do you get it from SES?</span>
<span class="comment-copy">I have set rule to save email MIME file directly to save, to S3 bucket from their i am reading the MIME file using Lambda</span>
<span class="comment-copy">Can you edit your question and describe how you open the file and process it to become <code>email_message</code> (and what class is <code>email_message</code>?</span>
<span class="comment-copy">Sorry for the delayed response. Thank you so much. I am on python 2.7.</span>
<span class="comment-copy">That helps @AmrishMishra. I updated my answer to better cover the options for both Python 3 and Python 2.7.</span>
<span class="comment-copy">Once again thank you :)</span>
<span class="comment-copy">My pleasure. (Spent a lot of time debugging this stuff last year for Anymail; glad the info can help someone else.)</span>
