<div class="post-text" itemprop="text">
<p>Edit:
The reason I as getting strange results was that the dictionary I was using(<a href="https://github.com/dwyl/english-words/blob/master/words_alpha.txt" rel="nofollow noreferrer">https://github.com/dwyl/english-words/blob/master/words_alpha.txt</a>) contained many values that were not really words. The code I have below all works as it should. I thought it was because of the <code>if word in words</code> line but I was wrong</p>
<p>This is my code:</p>
<pre><code>cipher = (input('what is your cipher? '))
alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
shift = 0
score=0
answer=''
scores=[]
answers=[]
with open('smalldic.txt') as word_file:
    words2 = set(word_file.read().lower().split())
with open('bigdic.txt') as word_file:
    words = set(word_file.read().split()) 
while shift&lt;26:                           
    shift+=1
    for letter in cipher:                 
        try:
            answer+=alphabet[(alphabet.index(letter)+shift)%26]
        except ValueError:
            answer+=letter
    answer = answer.split()
    for word in answer:
        if word in words:
            score+=len(word)*13
            if word in words2:
                score+=len(word)*26           
    scores.append(score)
    answers.append(answer)
    answer=''
    score=0
maxscore=max(scores)
count=-1
for i in scores:
    count+=1
    if i==maxscore:
        print(i)
        print(answers[count])
pause=input('Press any key to finish')
</code></pre>
<h2>Shell</h2>
<pre><code>Python 3.7.2 (tags/v3.7.2:9a3ffc0492, Dec 23 2018, 22:20:52) [MSC v.1916 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license()" for more information.
&gt;&gt;&gt; 
= RESTART: C:\Program Files (x86)\Python37-32\Scripts\caesarcipherdecoder.py =
what is your cipher? this is the result
['uijt', 'jt', 'uif', 'sftvmu']
['uijt', 'jt', 'uif', 'sftvmu']
['vjku', 'ku', 'vjg', 'tguwnv']
['vjku', 'ku', 'vjg', 'tguwnv']
['wklv', 'lv', 'wkh', 'uhvxow']
['wklv', 'lv', 'wkh', 'uhvxow']
['xlmw', 'mw', 'xli', 'viwypx']
['xlmw', 'mw', 'xli', 'viwypx']
['ymnx', 'nx', 'ymj', 'wjxzqy']
['ymnx', 'nx', 'ymj', 'wjxzqy']
['znoy', 'oy', 'znk', 'xkyarz']
['znoy', 'oy', 'znk', 'xkyarz']
['aopz', 'pz', 'aol', 'ylzbsa']
['aopz', 'pz', 'aol', 'ylzbsa']
['bpqa', 'qa', 'bpm', 'zmactb']
['bpqa', 'qa', 'bpm', 'zmactb']
['cqrb', 'rb', 'cqn', 'anbduc']
['cqrb', 'rb', 'cqn', 'anbduc']
['drsc', 'sc', 'dro', 'bocevd']
['drsc', 'sc', 'dro', 'bocevd']
['estd', 'td', 'esp', 'cpdfwe']
['estd', 'td', 'esp', 'cpdfwe']
['ftue', 'ue', 'ftq', 'dqegxf']
['ftue', 'ue', 'ftq', 'dqegxf']
['guvf', 'vf', 'gur', 'erfhyg']
['guvf', 'vf', 'gur', 'erfhyg']
['hvwg', 'wg', 'hvs', 'fsgizh']
['hvwg', 'wg', 'hvs', 'fsgizh']
['iwxh', 'xh', 'iwt', 'gthjai']
['iwxh', 'xh', 'iwt', 'gthjai']
['jxyi', 'yi', 'jxu', 'huikbj']
['jxyi', 'yi', 'jxu', 'huikbj']
['kyzj', 'zj', 'kyv', 'ivjlck']
['kyzj', 'zj', 'kyv', 'ivjlck']
['lzak', 'ak', 'lzw', 'jwkmdl']
['lzak', 'ak', 'lzw', 'jwkmdl']
['mabl', 'bl', 'max', 'kxlnem']
['mabl', 'bl', 'max', 'kxlnem']
['nbcm', 'cm', 'nby', 'lymofn']
['nbcm', 'cm', 'nby', 'lymofn']
['ocdn', 'dn', 'ocz', 'mznpgo']
['ocdn', 'dn', 'ocz', 'mznpgo']
['pdeo', 'eo', 'pda', 'naoqhp']
['pdeo', 'eo', 'pda', 'naoqhp']
['qefp', 'fp', 'qeb', 'obpriq']
['qefp', 'fp', 'qeb', 'obpriq']
['rfgq', 'gq', 'rfc', 'pcqsjr']
['rfgq', 'gq', 'rfc', 'pcqsjr']
['sghr', 'hr', 'sgd', 'qdrtks']
['sghr', 'hr', 'sgd', 'qdrtks']
['this', 'is', 'the', 'result']
['this', 'is', 'the', 'result']
[1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 2, 0, 1, 1, 0, 1, 0, 1, 2, 1, 1, 1, 1, 0, 2, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As roganjosh observes, the behavior you describe does not happen.</p>
<p>You offered a two-letter input word, <code>'it'</code>. My dictionary lists 160 "valid" two-letter combinations, nearly a quarter of the 676 possible combinations. I don't know exactly what input dictionary you used, but this effect may account for producing lots of <code>1</code> scores. For example I notice "mw" may correspond to megawatt, plus I see some <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Decoding_table" rel="nofollow noreferrer">ISO-3166</a> two-letter country codes in your output. The dictionary I use is the <code>/usr/share/dict/words</code> supplied with OS/X.</p>
<p>To debug, simply use a print statement after incrementing the score:</p>
<pre><code>    for word in answer:
        if word in words:
            score += 1
            print(word)
</code></pre>
<p>That will highlight the "surprising" <code>word</code> values.</p>
<p>Python's <code>in</code> operator is behaving exactly <a href="https://docs.python.org/3/reference/expressions.html#in" rel="nofollow noreferrer">as documented</a>.</p>
<p>EDIT:</p>
<p>People mostly compile word lists to support spell-checking applications, which will tend to favor erring on the side of including <em>everything</em>. A moment's googling yields lots of word lists, but the first one I grabbed, from infochimps, turned out to have 427 two-letter words, an impressive 63%. Perhaps <a href="http://wordlist.aspell.net/" rel="nofollow noreferrer">SCOWL</a> would prove relevant.</p>
<p>You might want to use the enclosed (platform-neutral) code to access a fairly reasonable corpus of English words.</p>
<pre><code>#! /usr/bin/env python

# You will need: pip install pyenchant
import enchant


def letters():
    return range(ord('a'), ord('z') + 1)


def get_2_letter_words():
    for a in letters():
        for b in letters():
            yield chr(a) + chr(b)


def num_valid_2_letter_words():
    d = enchant.Dict("en_US")
    return sum(d.check(word) for word in get_2_letter_words())


if __name__ == '__main__':
    n = num_valid_2_letter_words()
    print(n, n / 26 ** 2)
</code></pre>
<p>What you really want here is unigram frequency. That is, rather than scoring a win for a two-letter word based on some boolean <code>check()</code> function, you would prefer to give a higher score to a common word like <code>'it'</code> and some smaller positive score for a less common word like <code>'id'</code> or <code>'mw'</code>.</p>
<p>I rather like the suggestion from Dunes about paying more attention to longer words. Suppose we lack unigram frequency numbers, and so are forced to assume a uniform prior on n-letter words, e.g. <code>'it'</code> and <code>'id'</code> are equally likely to appear in the plaintext. Count up the number of n-letter words in your dictionary, divide by <code>26 ** n</code>, and use that fraction in your scoring.</p>
<p><a href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="nofollow noreferrer">Levenshtein distance</a> combined with <code>.suggest()</code> would improve resiliency to typos in the plaintext.</p>
</div>
<div class="post-text" itemprop="text">
<p>You code works fine for me.
Are you sure the problem is not in the counter?
The following code below for me is returning 'two', like is supposed to:</p>
<pre><code>answer = ['j', 'mpwf', 'taub', 'tubdl', 'tuba', 'pwfsgmpx', 'apple']
 words = {'jam', 'jelly', 'tuba', 'apple'}
 score = 0
 for word in answer:
     if word in words:
         score += 1
 print(score)
</code></pre>
</div>
<span class="comment-copy">Could you add and expected output?</span>
<span class="comment-copy">The behaviour you describe does not happen.</span>
<span class="comment-copy"><code>"j"</code> should not be matching anything in the <code>words</code> set, the way you have provided it here. Theres something wrong with either your original code, or your original <code>words</code> or <code>answer</code> variables that you might have missed, or with the way you are incrementing the score variable.</span>
<span class="comment-copy">I am not sure what I have done wrong- I have added my full code and the output I got</span>
<span class="comment-copy">Thank you for clarifying the problem for me, the dictionary I was using(<a href="https://github.com/dwyl/english-words/blob/master/words_alpha.txt" rel="nofollow noreferrer">github.com/dwyl/english-words/blob/master/words_alpha.txt</a>) contained some values that are not words. as I am a windows 10 user do you know where I could get a good word list</span>
<span class="comment-copy">Zoran MR, your word likely isn't the biggest problem. Perhaps it is how you score matches that is the problem. Matching a 6 letter word should be valued much more highly than matching a 2-letter word. It should probably be valued at least as highly as matching three 2-letter words! But your current algorithm gives them equal weighting.</span>
<span class="comment-copy">Thanks you J_H and Dunes for helping me with this. I have changed it so the score increases by the length of the word. I also have it so it checks in two words lists, one with 52196 words, giving it a lower score than the list with 4484 words (both generated from SCOWL) to try and represent the unigram frequency. I have found a module for Levenshtein distance(<a href="https://pypi.org/project/python-Levenshtein/0.12.0/" rel="nofollow noreferrer">pypi.org/project/python-Levenshtein/0.12.0</a>) but I don't understand how you are suggesting I implement that with .suggest(). I couldn't find any documentation on .suggest so what is that used for? Thanks again.</span>
<span class="comment-copy">I have attached my full code and the output I get. I don't think it is in the counter. what I am using is a list with all scores and after the for loop: scores.append(score). I then reset the score variable to 0 before it loops again</span>
