<div class="post-text" itemprop="text">
<p>I want to mock something for an entire class but the following minimal example is not working:</p>
<pre><code>import time
import six
if six.PY2:
    import mock
else:
    from unittest import mock

@mock.patch('time.sleep', mock.Mock(side_effect=Exception('dooooom')))
class Foo(object):
    def bar(self):
        print('before')
        time.sleep(1)
        print('after')

f = Foo()
f.bar()
</code></pre>
<p>I get this unexpected output: (why did <code>time.sleep</code> not raise?)</p>
<pre><code>before
after
</code></pre>
<p>However if I move the <code>@mock.patch(...)</code> down 1 line so it is decorating the method <code>bar</code> instead of the class <code>Foo</code> then it works as expected:</p>
<pre><code>before
...
Exception: blah
</code></pre>
<p>Why does <code>@mock.patch</code> not work at the class level?</p>
</div>
<div class="post-text" itemprop="text">
<p>It turns out the class decorator only patches methods beginning with <code>patch.TEST_PREFIX</code> which defaults to <code>test</code>.</p>
<p>So renaming the method to <code>test_bar</code> or even <code>testbar</code> makes the patch start working.</p>
<p><a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer">Docs</a>:</p>
<blockquote>
<p>Patch can be used as a <code>TestCase</code> class decorator. It works by decorating each test method in the class. This reduces the boilerplate code when your test methods share a common patchings set. patch() finds tests by looking for method names that start with <code>patch.TEST_PREFIX</code>. By default this is <code>'test'</code>, which matches the way <code>unittest</code> finds tests. You can specify an alternative prefix by setting <code>patch.TEST_PREFIX</code>.</p>
</blockquote>
<p>Evidently this behaviour applies to any class whether inheriting from <code>unittest.TestCase</code> or not.</p>
</div>
