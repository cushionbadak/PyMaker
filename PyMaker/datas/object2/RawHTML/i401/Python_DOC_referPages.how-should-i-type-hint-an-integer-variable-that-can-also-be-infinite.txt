<div class="post-text" itemprop="text">
<p>Searching for this topic I came across the following: <a href="https://stackoverflow.com/questions/21312081/how-to-represent-integer-infinity">How to represent integer infinity?</a></p>
<p>I agree with Martijn Peeters that adding a separate special infinity value for <code>int</code> may not be the best of ideas.</p>
<p>However, this makes type hinting difficult. Assume the following code:</p>
<pre><code>myvar = 10   # type: int
myvar = math.inf  # &lt;-- raises a typing error because math.inf is a float
</code></pre>
<p>However, the code behaves everywhere just the way as it should. And my type hinting is correct everywhere else.</p>
<p>If I write the following instead:</p>
<pre><code>myvar = 10  # type: Union[int, float]
</code></pre>
<p>I can assign <code>math.inf</code> without a hitch. But now any other float is accepted as well.</p>
<p>Is there a way to properly constrain the type-hint? Or am I forced to use <code>type: ignore</code> each time I assign infinity?</p>
</div>
<div class="post-text" itemprop="text">
<h3>The super lazy (and probably incorrect) solution:</h3>
<p>Rather than adding a specific value, the <code>int</code> class can be extended via subclassing.  This approach is not without a number of pitfalls and challenges, such as the requirement to handle the infinity value for the various <code>__dunder__</code> methods (i.e. <code>__add__</code>, <code>__mul__</code>, <code>__eq__</code> and the like, and all of these should be tested).  This would be an unacceptable amount of overhead in the use cases where a specific value is required.  In such a case, wrapping the desired value with <a href="https://docs.python.org/3/library/typing.html#typing.cast" rel="nofollow noreferrer"><code>typing.cast</code></a> would be able to better indicate to the type hinting system the specific value (i.e. <code>inf = cast(int, math.inf)</code>) be acceptable for assignment.</p>
<p>The reason why this approach is incorrect is simply this: since the value assigned looks/feels exactly like some number, some other users of your API may end up inadvertently use this as an <code>int</code> and then the program may explode on them badly when <code>math.inf</code> (or variations of such) be provided.</p>
<p>An analogy is this: given that lists have items that are indexed by positive integers, we would expect that any function that return an index to some item be some positive integer so we may use it directly (I know this is not the case in Python given there are semantics that allow negative index values be used, but pretend we are working with say C for the moment).  Say this function return the first occurrence of the matched item, but if there are any errors it return some negative number, which clearly exceed the range of valid values for an index to some item.  This lack of guarding against naive usage of the returned value will inevitably result in problems that a type system is supposed to solve.</p>
<p>In essence, creating surrogate values and marking that as an <code>int</code> will offer zero value, and inevitably allow unexpected and broken API/behavior to be exhibited by the program due to incorrect usage be automatically allowed.</p>
<p>Not to mention the fact that <a href="https://math.stackexchange.com/questions/260876/what-exactly-is-infinity">infinity is not a number</a>, thus no <code>int</code> value can properly represent that (given that <code>int</code> represent some finite number by its very nature).</p>
<p>As an aside, check out <a href="https://docs.python.org/3.7/library/stdtypes.html#str.index" rel="nofollow noreferrer"><code>str.index</code></a> vs <a href="https://docs.python.org/3.7/library/stdtypes.html#str.find" rel="nofollow noreferrer"><code>str.find</code></a>.  One of these have a return value that definitely violate user expectations (i.e. exceed the boundaries of the type positive integer; won't be told that the return value may be invalid for the context which it may be used at during compile time, results in potential failure randomly at runtime).</p>
<h3>Framing the question/answer in more correct terms:</h3>
<p>Given the problem is really about the assignment of some integer when a rate exist, and if none exist some other token that represent unboundedness for the particular use case should be done (it could be some built-in value such as <code>NotImplemented</code> or <code>None</code>).  However as those tokens would also not be <code>int</code> values, it means <code>myvar</code> would actually need a type that encompasses those, and with a way to apply operation that would do the right thing.</p>
<p>This unfortunately isn't directly available in Python in a very nice way, however in strongly static typed languages like Haskell, the more accepted solution is to use a <a href="https://stackoverflow.com/questions/3643172/using-maybe-type-in-haskell"><code>Maybe</code></a> type to define a <a href="https://stackoverflow.com/questions/2354707/in-haskell-is-there-infinity-num-a-a">number type that can accept infinity</a>.  Note that while floating point infinity is also available there, it inherits all the problems of floating point numbers that makes that an untenable solution (again, don't use <code>inf</code> for this).</p>
<p>Back to Python: depending on the property of the assignment you actually want, it could be as simple as creating a class with a constructor that can either accept an <code>int</code> or <code>None</code> (or <code>NotImplemented</code>), and then provide a method which the users of the class may make use of the actual value.  Python unfortunately do not provide the advanced constructs to make this elegant so you will inevitably end up with code managing this be splattered all over the place, or have to write a number of methods that handle whatever input as expected and produce the required output in the specific ways your program actual needs.</p>
<p>Unfortunately, type-hinting is really only scratching the surface and simply grazing over of what more advanced languages have provided and solved at a more fundamental level.  I supposed if one must program in Python, it is better than not having it.</p>
</div>
<span class="comment-copy">I'm not a big fan of subclassing <code>int</code>. If not careful it's easy to break things. And it's not worth taking that risk. And to answer the what and why: I'm dealing with rate-limits of service routers. They are specified in kbps (int). But they can also be unlimited (which corresponds to the "infinite" limit).</span>
<span class="comment-copy">One possible dirty hack might be to do something like <code>inf = cast(int, math.inf)</code> then start using your custom <code>inf</code> constant everywhere instead of <code>math.inf</code>.  However, I agree with @metatoaster's analysis here: I think all of the solutions he or she discussed are cleaner and more robust then the one I presented.</span>
<span class="comment-copy">@metatoaster I agree with your assessment as well. If you manage to formulate this into an answer I'll accept it.</span>
<span class="comment-copy">In my case, it's actually useful to distinguish between "value is configured and absolute", "value is configured and unbounded" and "value is unset". So maybe using something like <code>Union[int, MyInfinite, None]</code> might also do the trick. But then I will be forced to handle it everywhere. But as you say, this is an are where Python is a bit lacking.</span>
<span class="comment-copy">Ideally, you definitely want a new type that wraps all of that so that any users of that attribute won't make an assumption about the type currently present there if they might see an <code>int</code> assigned there.  Given that <code>mypy</code> may be optional and not used by a naive dependent of the package containing this type-hinted attribute, the developer might see <code>1000</code> at <code>myvar</code> and then have a formula <code>myvar * 10</code> which will explode later (despite the fact that mypy does flag that operation as invalid since they are type unions).  Ultimately this depend on your exact  use case.</span>
<span class="comment-copy">I agree. This is an internal type though and we enforce mypy in our team. So it's less of an issue overall. But I agree that this could be wrapped to avoid accidents.</span>
