<div class="post-text" itemprop="text">
<p>Is it a way in Python (2.7 preferably) to compress a file in several equally-sized <code>.zip</code> files??</p>
<p>The result would be something like: (lets assume 200MB selected and compressing a file of 1100MB)</p>
<pre><code>compressed_file.zip.001 (200MB)
compressed_file.zip.002 (200MB)
compressed_file.zip.003 (200MB)
compressed_file.zip.004 (200MB)
compressed_file.zip.005 (200MB)
compressed_file.zip.006 (100MB)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you can do it in shell command. Somthing like</p>
<pre><code>gzip -c /path/to/your/large/file | split -b 150000000 - compressed.gz
</code></pre>
<p>and you can execute shell from python.</p>
<p>Regards</p>
<p>Ganesh J</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>NB</strong>: This is based on assumption that the result is just a chopped up ZIP file without any extra headers or anything.</p>
<p>If you check the docs, <a href="https://docs.python.org/2.7/library/zipfile.html" rel="nofollow noreferrer"><code>ZipFile</code></a> can be passed a <a href="https://docs.python.org/2/library/stdtypes.html#bltin-file-objects" rel="nofollow noreferrer">file-like</a> object to use for the I/O. Hence, we should be able to give it our own object which implements the necessary subset of the protocol, and which splits the output into multiple files.</p>
<p>As it turns out, we only need to implement 3 functions:</p>
<ul>
<li><a href="https://docs.python.org/2/library/stdtypes.html#file.tell" rel="nofollow noreferrer"><code>tell()</code></a> -- just return number of bytes written so far</li>
<li><a href="https://docs.python.org/2/library/stdtypes.html#file.write" rel="nofollow noreferrer"><code>write(str)</code></a> -- write to file until max capacity, once full open a new file, repeat until all data written</li>
<li><a href="https://docs.python.org/2/library/stdtypes.html#file.flush" rel="nofollow noreferrer"><code>flush()</code></a> -- flush the currently open file</li>
</ul>
<h2>Prototype Script</h2>
<pre><code>import random
import zipfile


def get_random_data(length):
    return "".join([chr(random.randrange(256)) for i in range(length)])


class MultiFile(object):
    def __init__(self, file_name, max_file_size):
        self.current_position = 0
        self.file_name = file_name
        self.max_file_size = max_file_size
        self.current_file = None        
        self.open_next_file()

    @property
    def current_file_no(self):
        return self.current_position / self.max_file_size

    @property
    def current_file_size(self):
        return self.current_position % self.max_file_size

    @property
    def current_file_capacity(self):
        return self.max_file_size - self.current_file_size

    def open_next_file(self):
        file_name = "%s.%03d" % (self.file_name, self.current_file_no + 1)
        print "* Opening file '%s'..." % file_name
        if self.current_file is not None:
            self.current_file.close()
        self.current_file = open(file_name, 'wb')

    def tell(self):
        print "MultiFile::Tell -&gt; %d" % self.current_position
        return self.current_position

    def write(self, data):
        start, end = 0, len(data)
        print "MultiFile::Write (%d bytes)" % len(data)
        while start &lt; end:
            current_block_size = min(end - start, self.current_file_capacity)
            self.current_file.write(data[start:start+current_block_size])
            print "* Wrote %d bytes." % current_block_size
            start += current_block_size
            self.current_position += current_block_size
            if self.current_file_capacity == self.max_file_size:
                self.open_next_file()
            print "* Capacity = %d" % self.current_file_capacity

    def flush(self):
        print "MultiFile::Flush"
        self.current_file.flush()


mfo = MultiFile('splitzip.zip', 2**18)

zf = zipfile.ZipFile(mfo,  mode='w', compression=zipfile.ZIP_DEFLATED)


for i in range(4):
    filename = 'test%04d.txt' % i
    print "Adding file '%s'..." % filename
    zf.writestr(filename, get_random_data(2**17))
</code></pre>
<h2>Trace Output</h2>
<pre><code>* Opening file 'splitzip.zip.001'...
Adding file 'test0000.txt'...
MultiFile::Tell -&gt; 0
MultiFile::Write (42 bytes)
* Wrote 42 bytes.
* Capacity = 262102
MultiFile::Write (131112 bytes)
* Wrote 131112 bytes.
* Capacity = 130990
MultiFile::Flush
Adding file 'test0001.txt'...
MultiFile::Tell -&gt; 131154
MultiFile::Write (42 bytes)
* Wrote 42 bytes.
* Capacity = 130948
MultiFile::Write (131112 bytes)
* Wrote 130948 bytes.
* Opening file 'splitzip.zip.002'...
* Capacity = 262144
* Wrote 164 bytes.
* Capacity = 261980
MultiFile::Flush
Adding file 'test0002.txt'...
MultiFile::Tell -&gt; 262308
MultiFile::Write (42 bytes)
* Wrote 42 bytes.
* Capacity = 261938
MultiFile::Write (131112 bytes)
* Wrote 131112 bytes.
* Capacity = 130826
MultiFile::Flush
Adding file 'test0003.txt'...
MultiFile::Tell -&gt; 393462
MultiFile::Write (42 bytes)
* Wrote 42 bytes.
* Capacity = 130784
MultiFile::Write (131112 bytes)
* Wrote 130784 bytes.
* Opening file 'splitzip.zip.003'...
* Capacity = 262144
* Wrote 328 bytes.
* Capacity = 261816
MultiFile::Flush
MultiFile::Tell -&gt; 524616
MultiFile::Write (46 bytes)
* Wrote 46 bytes.
* Capacity = 261770
MultiFile::Write (12 bytes)
* Wrote 12 bytes.
* Capacity = 261758
MultiFile::Write (0 bytes)
MultiFile::Write (0 bytes)
MultiFile::Write (46 bytes)
* Wrote 46 bytes.
* Capacity = 261712
MultiFile::Write (12 bytes)
* Wrote 12 bytes.
* Capacity = 261700
MultiFile::Write (0 bytes)
MultiFile::Write (0 bytes)
MultiFile::Write (46 bytes)
* Wrote 46 bytes.
* Capacity = 261654
MultiFile::Write (12 bytes)
* Wrote 12 bytes.
* Capacity = 261642
MultiFile::Write (0 bytes)
MultiFile::Write (0 bytes)
MultiFile::Write (46 bytes)
* Wrote 46 bytes.
* Capacity = 261596
MultiFile::Write (12 bytes)
* Wrote 12 bytes.
* Capacity = 261584
MultiFile::Write (0 bytes)
MultiFile::Write (0 bytes)
MultiFile::Tell -&gt; 524848
MultiFile::Write (22 bytes)
* Wrote 22 bytes.
* Capacity = 261562
MultiFile::Write (0 bytes)
MultiFile::Flush
</code></pre>
<h2>Directory Listing</h2>
<pre><code>-rw-r--r-- 1   2228 Feb 21 23:44 splitzip.py
-rw-r--r-- 1 262144 Feb 22 00:07 splitzip.zip.001
-rw-r--r-- 1 262144 Feb 22 00:07 splitzip.zip.002
-rw-r--r-- 1    582 Feb 22 00:07 splitzip.zip.003
</code></pre>
<h2>Validation</h2>
<pre><code>&gt;7z l splitzip.zip.001

7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18

Listing archive: splitzip.zip.001

--
Path = splitzip.zip.001
Type = Split
Volumes = 3
----
Path = splitzip.zip
Size = 524870
--
Path = splitzip.zip
Type = zip
Physical Size = 524870

   Date      Time    Attr         Size   Compressed  Name
------------------- ----- ------------ ------------  ------------------------
2019-02-22 00:07:34 .....       131072       131112  test0000.txt
2019-02-22 00:07:34 .....       131072       131112  test0001.txt
2019-02-22 00:07:36 .....       131072       131112  test0002.txt
2019-02-22 00:07:36 .....       131072       131112  test0003.txt
------------------- ----- ------------ ------------  ------------------------
                                524288       524448  4 files, 0 folders
</code></pre>
</div>
<span class="comment-copy">The question is, what have you tried in order to do something like that?</span>
<span class="comment-copy">@user5173426 checked on available docs : <a href="https://docs.python.org/3/library/zipfile.html" rel="nofollow noreferrer">docs.python.org/3/library/zipfile.html</a> nothing found so far</span>
<span class="comment-copy">it might not even be possible, im also fine with that.</span>
<span class="comment-copy">Hmm, <code>ZipFile</code> can use a file-like object for IO... so implement one that handles the file rotataion? Not sure if it's worth the effort tho.</span>
<span class="comment-copy">hi thanks, I think in the back of my head i read about this one before. I was more curious about any pythonic approach.</span>
<span class="comment-copy">Just launch this command from Python</span>
<span class="comment-copy">accepted because I ended up using a variation of this answer, thanks!</span>
