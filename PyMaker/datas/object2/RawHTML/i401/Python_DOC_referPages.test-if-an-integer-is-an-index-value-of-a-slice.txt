<div class="post-text" itemprop="text">
<p>Is there a Boolean function to test whether an integer is an index value contained in a <code>slice</code> object? Without unpacking <code>start</code>, <code>stop</code>, <code>step</code> parameters? </p>
<pre><code>3 in slice(1,6,2)
</code></pre>
<p>Throws an error as slices are not iterable. </p>
<p>The predicate should work for arbitrary <code>None</code> <code>start</code>, <code>stop</code>, <code>step</code> parameters. The logic is straightforward but hoping there's a built in or package.</p>
</div>
<div class="post-text" itemprop="text">
<p>The logic is not as straightforward as you think, since it doesn't make sense to do this for a <code>None</code> stop or start (depending on the sign of <code>step</code>), since you need to specify a length.</p>
<p>Essentially, what you are asking for is containment in a <a href="https://docs.python.org/3/library/functions.html#func-range" rel="noreferrer"><code>range</code></a> object, which holds the same information as a slice, but is a valid sequence, and supports fast containment checking. <a href="https://docs.python.org/3/library/functions.html#slice" rel="noreferrer"><code>slice</code></a> has an <code>indices</code> method to help with the transformation, if you provide the length of the sequence you are interested in slicing:</p>
<pre><code>def in_slice(n, s, length):
    return n in range(*s.indices(length))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you can select an appropriately sized range, you can apply the slice to it and determine if the index will be in the range.</p>
<p>for positive/None boundaries, this is merely a matter of having a big enough range to contain the index itself:</p>
<pre><code>i in range(i+1)[slice(start,stop,step)]

3 in range(7)[slice(1,6,2)] --&gt; True
</code></pre>
<p>In order to support negative boundaries (in particular a negative start), you'll need to ensure that index offset from start is a multiple of the step and that the size is small enough to include the index.  This is under the assumption that there exists a range size that will contain the index.  Otherwise you'll have to supply a range size yourself:</p>
<pre><code>def inSlice(i,s, size = None):
    if size is None:
        step  = s.step  or 1
        start = s.start or 0
        size  = size or i+1
        if step &lt; 0 or start &lt;= 0:
           size = (i-min(0,start))//step*step - int(s.stop is None)
    return  i in range(size)[s]
</code></pre>
<p>This will provide the following results:</p>
<pre><code>inSlice( 3 , slice(1, 6, 2) )           --&gt;  True ( size = 4 )
inSlice( 37000216 , slice(10, 100000000, 3) )   --&gt;  True ( size = 37000217 )
inSlice( 17 , slice(-100, 10, -3) )     --&gt;  True ( size = 117 )
inSlice( 17 , slice(-100, -10, 3) )     --&gt;  True ( size = 117 )
inSlice( 97 , slice(100, None, -3) )    --&gt;  True ( size = 98 )
inSlice( 107 , slice(None, 100, -3) )   --&gt;  True ( size = 108 )
inSlice( 97 , slice(-10, None, -3) )    --&gt;  True ( size = 107 )
</code></pre>
</div>
<span class="comment-copy">Does it need to support negative indices? What is the desired output of <code>123 in slice(None, -1, None)</code>?</span>
