<div class="post-text" itemprop="text">
<p>I've never used the <code>async-await</code> syntax but I do often need to make HTTP/S requests and parse responses while awaiting future responses. To accomplish this task, I currently use the <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" rel="nofollow noreferrer">ThreadPoolExecutor</a> class which execute the calls asynchronously anyways; effectively I'm achieving (I believe) the same result I would get with more lines of code  to use <code>async-await</code>.</p>
<p>Operating under the assumption that my current implementations work asynchronously, I am wondering how the <code>async-await</code> implementation would differ from that of my original one which used Threads and a Queue to manage workers; it also used a Semaphore to limit workers.</p>
<p>That implementation was devised under the following conditions:</p>
<ul>
<li>There may be any number of requests</li>
<li>Total number of active requests may be 4</li>
<li>Only send next request when a response is received</li>
</ul>
<p>The basic flow of the implementation was as follows:</p>
<ol>
<li>Generate container of requests</li>
<li>Create a ListeningQueue</li>
<li>For each request create a Thread and pass the URL, ListeningQueue and Semaphore</li>
<li>Each Thread attempts to acquire the Semaphore (limited to 4 Threads)</li>
<li>Main Thread continues in a <code>while</code> checking ListeningQueue</li>
<li>When a Thread receives a response, place in ListeningQueue and release Semaphore</li>
<li>A waiting Thread acquires Semaphore (process repeats)</li>
<li>Main Thread processes responses until count equals number of requests</li>
</ol>
<p>Because I need to limit the number of active Threads I use a Semaphore, and if I were to try this using <code>async-await</code> I would have to devise some logic in the Main Thread or in the <code>async def</code> that prevents a request from being sent if the limit has been reached. Apart from that constraint, I don't see where using <code>async-await</code> would be any more useful. Is it that it lowers overhead and race condition chances by eliminating Threads? Is that the main benefit? If so, even though using a ThreadPoolExecutor is making asynchronous calls it is using a pool of Threads, thus making <code>async-await</code> a better option?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Operating under the assumption that my current implementations work asynchronously, I am wondering how the async-await implementation would differ from that of my original one which used Threads and a Queue to manage workers</p>
</blockquote>
<p>It would not be hard to implement very similar logic using <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a> and async-await, which has its own version of <a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore" rel="nofollow noreferrer">semaphore</a> that is used in much the same way. See answers to <a href="https://stackoverflow.com/q/48483348/1600898">this question</a> for examples of limiting the number of parallel requests with a fixed number of tasks or by using a semaphore.</p>
<p>As for advantages of asyncio over equivalent code using threads, there are several:</p>
<ul>
<li><p>Everything runs in a single thread regardless of the number of active connections. Your program can scale to a large number of concurrent tasks without swamping the OS with an unreasonable number of threads or the downloads having to wait for a free slot in the thread pool before they even start.</p></li>
<li><p>As you pointed out, single-threaded execution is less susceptible to race conditions because the points where a task switch can occur are clearly marked with <code>await</code>, and everything in-between is effectively atomic. The advantage of this is less obvious in small threaded programs where the executor just hands tasks to threads in a fire-and-collect fashion, but as the logic grows more complex and the threads begin to share more state (e.g. due to caching or some synchronization logic), this becomes more pronounced.</p></li>
<li><p>async/await allows you to easily create additional independent tasks for things like monitoring, logging and cleanup. When using threads, those do not fit the executor model and require additional threads, always with a design smell that suggests threads are being abused. With asyncio, each task can be as if it were running in its own thread, and use <code>await</code> to wait for something to happen (and yield control to others) - e.g. a timer-based monitoring task would consist of a loop that awaits <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.sleep" rel="nofollow noreferrer"><code>asyncio.sleep()</code></a>, but the logic could be arbitrarily complex. Despite the code looking sequential, each task is lightweight and carries no more weight to the OS than that of a small allocated object.</p></li>
<li><p>async/await supports reliable <em>cancellation</em>, which threads never did and likely never will. This is often overlooked, but in asyncio it is perfectly possible to <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel" rel="nofollow noreferrer">cancel</a> a running task, which causes it to wake up from <code>await</code> with an exception that terminates it. Cancellation makes it straightforward to implement timeouts, task groups, and other patterns that are impossible or a huge chore when using threads.</p></li>
</ul>
<p>On the flip side, the disadvantage of async/await is that all your code must be async. Among other things, it means that you cannot use libraries like requests, you have to switch to asyncio-aware alternatives like <a href="https://aiohttp.readthedocs.io/en/stable/" rel="nofollow noreferrer">aiohttp</a>.</p>
</div>
<span class="comment-copy">Since ThreadPoolExectuor runs async calls, is the difference the same in that async operations are occurring with Threads instead of a single one?</span>
<span class="comment-copy">I suppose a better way to ask is why use <code>async-await</code> over supplying a method to a ThreadPoolExecutor and process futures as they complete? Why define a method as <code>async def</code> and then run an Executor in a separate thread within?</span>
<span class="comment-copy">@datta This answer refers to using a native async/await library such as <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a>. In that case IO-bound tasks don't require threads <i>at all</i>. Mixing <code>async def</code> with threaded code doesn't make much sense, except when invoking legacy blocking code, which should be done using <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" rel="nofollow noreferrer"><code>run_in_executor</code></a>.</span>
<span class="comment-copy">Right, but I was asking why would I write an <code>async def</code> script and injected an executor for blocking code, when I could do something like <a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-example" rel="nofollow noreferrer">this</a>. If I am querying websites, using <code>async-await</code>, I still have to use an executor to call <code>requests.get</code> for example, thus spawning threads. So whats the tradeoff? Why write a bunch of <code>async def</code> to ultimate use an executor for blocking calls, when I could've used an executor from the start. Whats the major difference?</span>
<span class="comment-copy">A perfect example of your injection is <a href="https://stackoverflow.com/a/33399896/8371266">here</a>. They tell the event loop to await (ultimately suspend) the call that is blocking in the executor. Well had the whole script been written to query websites using an executor, the main thread would be sitting in a loop using <code>as_completed</code> to process futures as the complete since ThreadPoolExecutors are async and main is free to do other stuff. I don't even have to implement a check to see if all futures are done. So again, why use <code>async def/async-await</code> over a full ThreadPoolExecutor?</span>
