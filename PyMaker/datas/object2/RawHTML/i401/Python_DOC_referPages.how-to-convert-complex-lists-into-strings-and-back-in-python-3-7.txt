<div class="post-text" itemprop="text">
<p>I'm trying to save Python lists to a file and read them back again when I re-launch the program. The problem is my lists are complex: i.e. different amounts of tuples within tuples.</p>
<p>The best I could come up with is turning my list into a string initially (which works) but there's no way I can think of to revert the changes.</p>
<pre><code>with open(filename, 'w') as f:
            f.write(str(objs))
            f.close()
</code></pre>
<p>This works but how do I return this to a list?</p>
<p>Just to clarify what my definition of a complex list is, here's an example:</p>
<pre><code>[(((0.0, 0.0, 0.0), (1000.0, 0.0, 0.0), (0.0, 2.0, 0.0), (1000.0, 2.0, 
0.0), (0.0, 0.0, 1000.0), (1000.0, 0.0, 1000.0), (0.0, 2.0, 1000.0), 
(1000.0, 2.0, 1000.0)), ((0, 2, 3, 1), (4, 6, 7, 5), (1, 3, 7, 5), (4, 6, 
2, 0), (2, 6, 7, 3), (4, 0, 1, 5)), ((255, 0, 0), (255, 128, 0), (255, 255, 
0), (255, 255, 255), (0, 0, 255), (0, 255, 0)))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As @snakecharmerb already mentioned you can use <code>json</code> or <code>pickle</code>. Here is an example:</p>
<p>Code:</p>
<pre><code>my_list = [(((0.0, 0.0, 0.0), (1000.0, 0.0, 0.0), (0.0, 2.0, 0.0), (1000.0, 2.0, 
0.0), (0.0, 0.0, 1000.0), (1000.0, 0.0, 1000.0), (0.0, 2.0, 1000.0), 
(1000.0, 2.0, 1000.0)), ((0, 2, 3, 1), (4, 6, 7, 5), (1, 3, 7, 5), (4, 6, 
2, 0), (2, 6, 7, 3), (4, 0, 1, 5)), ((255, 0, 0), (255, 128, 0), (255, 255, 
0), (255, 255, 255), (0, 0, 255), (0, 255, 0)))]
</code></pre>
<hr/>
<pre><code>import json

with open('my_list.json', 'w') as f:
    json.dump(my_list, f)

with open('my_list.json','r') as f:
    loaded_list = json.load(f)

print('Using json:')
print(loaded_list)
</code></pre>
<hr/>
<pre><code>import pickle

with open('my_list.pkl', 'wb') as f:
    pickle.dump(my_list, f)

with open('my_list.pkl', 'rb') as f:
    loaded_list = pickle.load(f)

print('Using pickle:')
print(loaded_list)
</code></pre>
<hr/>
<p>Output:</p>
<pre><code>Using json:
[[[[0.0, 0.0, 0.0], [1000.0, 0.0, 0.0], [0.0, 2.0, 0.0], [1000.0, 2.0, 0.0], [0.0, 0.0, 1000.0], [1000.0, 0.0, 1000.0], [0.0, 2.0, 1000.0], [1000.0, 2.0, 1000.0]], [[0, 2, 3, 1], [4, 6, 7, 5], [1, 3, 7, 5], [4, 6, 2, 0], [2, 6, 7, 3], [4, 0, 1, 5]], [[255, 0, 0], [255, 128, 0], [255, 255, 0], [255, 255, 255], [0, 0, 255], [0, 255, 0]]]]

Using pickle:
[(((0.0, 0.0, 0.0), (1000.0, 0.0, 0.0), (0.0, 2.0, 0.0), (1000.0, 2.0, 0.0), (0.0, 0.0, 1000.0), (1000.0, 0.0, 1000.0), (0.0, 2.0, 1000.0), (1000.0, 2.0, 1000.0)), ((0, 2, 3, 1), (4, 6, 7, 5), (1, 3, 7, 5), (4, 6, 2, 0), (2, 6, 7, 3), (4, 0, 1, 5)), ((255, 0, 0), (255, 128, 0), (255, 255, 0), (255, 255, 255), (0, 0, 255), (0, 255, 0)))]
</code></pre>
<p>As you can see <code>json</code> converts tuples to lists.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>str</code> function will convert your complex list / nested lists and tuple to string
Further, <code>eval</code> converts any string to an actual code snippet</p>
<p>However as mentioned by Taras Savchyn, <code>eval</code> can lead to SQL injections and more. So instead use <code>ast.literal_eval</code></p>
<p>Hence:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt;import ast

&gt;&gt;&gt; mylist = [(((0.0, 0.0, 0.0), (1000.0, 0.0, 0.0), (0.0, 2.0, 0.0), (1000.0, 2.0, 0.0), (0.0, 0.0, 1000.0), (1000.0, 0.0, 1000.0), (0.0, 2.0, 1000.0), (1000.0, 2.0, 1000.0)), ((0, 2, 3, 1), (4, 6, 7, 5), (1, 3, 7, 5), (4, 6, 2, 0), (2, 6, 7, 3), (4, 0, 1, 5)), ((255, 0, 0), (255, 128, 0), (255, 255, 0), (255, 255, 255), (0, 0, 255), (0, 255, 0)))]

&gt;&gt;&gt; mylist
[(((0.0, 0.0, 0.0), (1000.0, 0.0, 0.0), (0.0, 2.0, 0.0), (1000.0, 2.0, 0.0), (0.0, 0.0, 1000.0), (1000.0, 0.0, 1000.0), (0.0, 2.0, 1000.0), (1000.0, 2.0, 1000.0)), ((0, 2, 3, 1), (4, 6, 7, 5), (1, 3, 7, 5), (4, 6, 2, 0), (2, 6, 7, 3), (4, 0, 1, 5)), ((255, 0, 0), (255, 128, 0), (255, 255, 0), (255, 255, 255), (0, 0, 255), (0, 255, 0)))]

&gt;&gt;&gt; mystring = str(mylist)

&gt;&gt;&gt; print(mystring)
'[(((0.0, 0.0, 0.0), (1000.0, 0.0, 0.0), (0.0, 2.0, 0.0), (1000.0, 2.0, 0.0), (0.0, 0.0, 1000.0), (1000.0, 0.0, 1000.0), (0.0, 2.0, 1000.0), (1000.0, 2.0, 1000.0)), ((0, 2, 3, 1), (4, 6, 7, 5), (1, 3, 7, 5), (4, 6, 2, 0), (2, 6, 7, 3), (4, 0, 1, 5)), ((255, 0, 0), (255, 128, 0), (255, 255, 0), (255, 255, 255), (0, 0, 255), (0, 255, 0)))]'

&gt;&gt;&gt; type(mystring)
&lt;class 'str'&gt;

&gt;&gt;&gt; print(ast.literal_eval(mystring))
[(((0.0, 0.0, 0.0), (1000.0, 0.0, 0.0), (0.0, 2.0, 0.0), (1000.0, 2.0, 0.0), (0.0, 0.0, 1000.0), (1000.0, 0.0, 1000.0), (0.0, 2.0, 1000.0), (1000.0, 2.0, 1000.0)), ((0, 2, 3, 1), (4, 6, 7, 5), (1, 3, 7, 5), (4, 6, 2, 0), (2, 6, 7, 3), (4, 0, 1, 5)), ((255, 0, 0), (255, 128, 0), (255, 255, 0), (255, 255, 255), (0, 0, 255), (0, 255, 0)))]

&gt;&gt;&gt; type(ast.literal_eval(mystring))
&lt;class 'list'&gt;

</code></pre>
<p>Hope this solves your problem. You can comment the answer to ask any further queries</p>
</div>
<span class="comment-copy">You could save the list in a <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer">pickle</a> file, or save it as <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">json</a> (though this will convert the tuples to lists).</span>
<span class="comment-copy">"The best I could come up with is turning my list into a string initially" don't do that. Use a supported serialization format, like <code>pickle</code> for arbitrary objects, or even just <code>json</code> will work for a simple list</span>
<span class="comment-copy">Yes, this is spot on. So, instead of initially converting your list to string and writing to a file, you can save this in a pickle file. fileName = "my_list" fileObject = open(fileName,'wb') pickle.dump(my_list,fileObject)    fileObject.close()</span>
<span class="comment-copy">Using eval is a bad practice. <a href="https://stackoverflow.com/questions/1832940/why-is-using-eval-a-bad-practice" title="why is using eval a bad practice">stackoverflow.com/questions/1832940/â€¦</a></span>
<span class="comment-copy">@TarasSavchyn PS corrected it</span>
