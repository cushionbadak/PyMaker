<div class="post-text" itemprop="text">
<p>I have read and read again the Python documentation about multiprocessing module and Queues management but I cannot find anything related to this issue that turns me crazy and is blocking my project:</p>
<p>I wrote a 'JsonLike' class which allows me to create an object such as :</p>
<pre><code>a = JsonLike()
a.john.doe.is.here = True
</code></pre>
<p>...without considering intermediate initialization (very useful)</p>
<p>The following code just creates such an object, set and insert it in a array and tries to send that to a process (this is what I need but <strong>the sending of the object itself leads to the same error</strong>)</p>
<p>Considering this piece of code :</p>
<pre><code>from multiprocessing import Process, Queue, Event

class JsonLike(dict):
    """
    This class allows json-crossing-through creation and setting such as :
    a = JsonLike()
    a.john.doe.is.here = True
    it automatically creates all the hierarchy
    """

    def __init__(self, *args, **kwargs):
        # super(JsonLike, self).__init__(*args, **kwargs)
        dict.__init__(self, *args, **kwargs)
        for arg in args:
            if isinstance(arg, dict):
                for k, v in arg.items():
                    self[k] = v
        if kwargs:
            for k, v in kwargs.items():
                self[k] = v

    def __getattr__(self, attr):
        if self.get(attr) != None:
            return attr
        else:
            newj = JsonLike()
            self.__setattr__(attr, newj)
            return newj

    def __setattr__(self, key, value):
        self.__setitem__(key, value)

    def __setitem__(self, key, value):
        dict.__setitem__(self, key, value)
        self.__dict__.update({key: value})

    def __delattr__(self, item):
        self.__delitem__(item)

    def __delitem__(self, key):
        dict.__delitem__(self, key)
        del self.__dict__[key]


def readq(q, e):
    while True:
        obj = q.get()
        print('got')
        if e.is_set():
            break


if __name__ == '__main__':
    q = Queue()
    e = Event()

    obj = JsonLike()
    obj.toto = 1

    arr=[obj]

    proc = Process(target=readq, args=(q,e))
    proc.start()
    print(f"Before sending value :{arr}")
    q.put(arr)
    print('sending done')
    e.set()
    proc.join()
    proc.close()
</code></pre>
<p>I get the following output (on the <code>q.put</code>):</p>
<pre class="lang-none prettyprint-override"><code>Before sending value :[{'toto': 1}]
Traceback (most recent call last):
sending done
  File "/usr/lib/python3.7/multiprocessing/queues.py", line 236, in _feed
    obj = _ForkingPickler.dumps(obj)
  File "/usr/lib/python3.7/multiprocessing/reduction.py", line 51, in dumps
    cls(buf, protocol).dump(obj)
TypeError: 'JsonLike' object is not callable
</code></pre>
<p>Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you are messing with <code>__getattr__</code>. If you add a print statement inside this method, you will see that running the following code leads to a crash too:</p>
<pre class="lang-py prettyprint-override"><code>obj = JsonLike()
obj.toto.test = 1

q = Queue()
q.put(obj)
q.get()
</code></pre>
<p>This last statement will result in calling (repeatedly) <code>obj.__getattr__</code>, searching for an attribute named <a href="https://docs.python.org/3/library/pickle.html#object.__getstate__" rel="nofollow noreferrer"><code>__getstate__</code></a> (it will later try to find its friend <a href="https://docs.python.org/3/library/pickle.html#object.__setstate__" rel="nofollow noreferrer"><code>__setstate__</code></a>). Here's what the <a href="https://docs.python.org/3/library/pickle.html#module-pickle" rel="nofollow noreferrer">pickle</a> documentations says about this dunder method:</p>
<blockquote>
<p>If the <code>__getstate__()</code> method is absent, the instanceâ€™s <code>__dict__</code> is pickled as usual.</p>
</blockquote>
<p>In your case the problem is that this method doesn't exist, but your code make it look like it does (by creating an attribute with the right name on the fly). Therefore the default behavior is not triggered, instead an empty attribute named <code>__getstate__</code> is called. The problem is that <code>__getstate__</code> is not a callable as it's an empty <code>JsonLike</code> object. This is why you may see errors like "JsonLike is not callable" pop-up here.</p>
<p>One quick fix is to avoid touching attributes that look like <code>__xx__</code> and even <code>_xx</code>. To that matter you can add/modify these lines: </p>
<pre class="lang-py prettyprint-override"><code>import re

dunder_pattern = re.compile("__.*__")
protected_pattern = re.compile("_.*")

class JsonLike(dict):

    def __getattr__(self, attr):
        if dunder_pattern.match(attr) or protected_pattern.match(attr):
            return super().__getattr__(attr)
        if self.get(attr) != None:
            return attr
        else:
            newj = JsonLike()
            self.__setattr__(attr, newj)
            return newj
</code></pre>
<p>Which will allow to make the previous code work (same goes for your code). But on the other hand, you won't be able to write things like <code>obj.__toto__ = 1</code> anymore, but that's probably a good thing anyway. </p>
<p>I feel like you may end-up with similar bugs in other contexts and sadly, in some cases you will find libraries that won't use such predictable attributes names. That's one of the reasons why I wouldn't suggest to use such a mechanism IRL (even though I really like the idea and I would love to see how far this can go). </p>
</div>
<span class="comment-copy">Ugh, not really related, and more of a peet-peeve of mine, but this isn't "Json-like", it is <i>dict like</i>. JSON is a text-based serialization format. When you deserialize it, it is no longer JSON. It is now some materialized data structure</span>
<span class="comment-copy">Ok let's say javascript-like json getter/setter but as you say, not related to the problem exposed.</span>
<span class="comment-copy">Thank you so much, you helped me a lot ! I forgot to double check the Pickle documentation about it. It is clear now.</span>
<span class="comment-copy">If you don't mind, I'll try to find a subject title/tags so people that will have a similar problem will have some hints (even if it's very unlikely that someone ever happen to have a similar issue).</span>
<span class="comment-copy">Of course please do.</span>
