<div class="post-text" itemprop="text">
<p>Is there a better way to <em>iteratively</em> apply a list of functions to a dictionary? Here is an example of what I want to do.  But this uses recursion.</p>
<pre><code>def func1(h: dict):
    h['foo']=10
    return(h)

def func2(h: dict):
    h['bar']=100
    return(h)

def func3(h: dict):
    h['baz']=h['foo']+h['bar']
    return(h)

func3(func2(func1({'firstElement':'good'})))
</code></pre>
<p>Produces expected output:</p>
<pre><code>{'bar': 100, 'baz': 110, 'firstElement': 'good', 'foo': 10}
</code></pre>
<p>I want to provide the functions as a array and produce the same output.  Here is what I have tried and works:</p>
<pre><code>def recApply(flist, h=None):
    """
    Helper Apply the list of functions iteratively over the dictionary passed
    :obj: function list each will be applied to the dictionary sequentially.
    """
    #if no dictionary passed, then set the dictionary.
    if(h == None):
        h = {}

    #iteratively call functions with dictionary as a passed parameter and returning a derived dictionary
    for f in flist:
        h = f(h)

    return(h)

flist = [func1,func2,func3]
recApply(flist,{'firstElement':'good'})
</code></pre>
<p>This produces the desired output:</p>
<pre><code>{'bar': 100, 'baz': 110, 'firstElement': 'good', 'foo': 10}
</code></pre>
<p>Is there a way to do this that is more readable, removes the recApply function and hopefully minimizes dictionary copies? </p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to return your dictionaries and re-assign references - mutable types are passed by reference so:</p>
<pre><code>def func1(h):
    h['foo'] = 10

def func2(h):
    h['bar'] = 100

def func3(h):
    h['baz'] = h['foo'] + h['bar']

start_dict = {'firstElement': 'good'}

for f in (func1, func2, func3):
    f(start_dict)

print(start_dict)
# {'firstElement': 'good', 'baz': 110, 'bar': 100, 'foo': 10}
</code></pre>
<p>would to perfectly fine.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>reduce</code> (or <code>functools.reduce</code> in Python 3) can be used to compose a list of functions into a single function. This requires you to define a composition function:</p>
<pre><code>def compose(f, g):
    def _(x):
        return f(g(x))
    return _
</code></pre>
<p>and an identity function:</p>
<pre><code>def identity(x):
    return x
</code></pre>
<p>Using these, you can create a function <code>g</code> that applies each function in order to an initial input.</p>
<pre><code>g = reduce(compose, [func3, func2, func1], identity)
assert (g({'firstElement': 'good'}) ==
        {'firstElement': 'good', 'foo': 10, 'bar': 100, 'baz': 110})
</code></pre>
<hr/>
<p>Note this works because <code>func1</code>, <code>func2</code> and <code>func3</code> are similar enough to pure functions that you can make use of the function <a href="https://en.wikipedia.org/wiki/Monoid" rel="nofollow noreferrer"><em>monoid</em></a>. Loosely speaking, it just means that function composition is associative (<code>compose(f, compose(g, h))</code> is the same as <code>compose(compose(f, g), h)</code>) and that the identity function is neutral under composition (<code>compose(identity, f)</code> and <code>compose(f, identity)</code> are both the same as <code>f</code> itself).</p>
<p>Your three functions aren't really pure functions; they are more like identity functions with side effects. However, you can treat them as pure functions because you are using them as if they were defined as, for example,</p>
<pre><code>def func1(h):
    h1 = {}
    h1.update(h)
    h1['foo'] = 10
    return h1
</code></pre>
<hr/>
<p>Exercise for the reader: determine if my call to <code>reduce</code> actually defines <code>g(x) = func3(func2(func1(x)))</code> or <code>g(x) = func1(func2(func3(x))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could also use <a href="https://docs.python.org/2/library/functions.html#reduce" rel="nofollow noreferrer"><code>reduce</code></a> (or <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a> in Python 3) with the starting dictionary as the <code>initializer</code> parameter:</p>
<pre><code>&gt;&gt;&gt; from functools import reduce  # Python 3
&gt;&gt;&gt; reduce(lambda (x, f): f(x), (func1, func2, func3), {'firstElement':'good'})
{'bar': 100, 'baz': 110, 'firstElement': 'good', 'foo': 10}
</code></pre>
<p>This will apply the functions one after the other to the initializer or the result of the previous function.</p>
<p>You could also combine this with <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a> to create a chained function that can then be applied to different input dictionaries:</p>
<pre><code>&gt;&gt;&gt; from functools import partial
&gt;&gt;&gt; chain = partial(reduce, lambda (x, f): f(x), (func1, func2, func3))
&gt;&gt;&gt; chain({'firstElement':'good'})
{'bar': 100, 'baz': 110, 'firstElement': 'good', 'foo': 10}
</code></pre>
<p>And you could generalize that further, making it a <code>partial</code> of a <code>partial</code> function...</p>
<pre><code>&gt;&gt;&gt; chainer = partial(partial, reduce, lambda (x, f): f(x))
&gt;&gt;&gt; chain = chainer((func1, func2, func3))
&gt;&gt;&gt; chain({'firstElement':'good'})
{'bar': 100, 'baz': 110, 'firstElement': 'good', 'foo': 10}
</code></pre>
</div>
<span class="comment-copy">This doesn't copy any dictionaries; a reference to the same mutated dictionary is passed into and back from each function.</span>
<span class="comment-copy">All arguments in Python are passed in the same way <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">nedbatchelder.com/text/names.html</a></span>
<span class="comment-copy">@chthonicdaemon - true, but we're talking about semantics here. You always pass a reference to a value, but only mutable types can be changed producing the 'pass-by-reference' vs 'pass-by-value' distinction (that exists in most languages) in practice.</span>
