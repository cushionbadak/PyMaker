<div class="post-text" itemprop="text">
<p>I am trying to make a choice for each element in <code>elements</code>, and then I am pairing up the element in <code>elements</code> list with its preferential choice(one,two or three). The choice is mostly done regarding the probabilities (<code>weights</code>) of the elements. The code until here:</p>
<pre><code>from numpy.random import choice
elements = ['one', 'two', 'three']
weights = [0.2, 0.3, 0.5]
chosenones= []
for el in elements:
    chosenones.append(choice(elements,p=weights))
tuples = list(zip(elements,chosenones))
</code></pre>
<p>Yields:</p>
<pre><code>[('one', 'two'), ('two', 'two'), ('three', 'two')]
</code></pre>
<p>What I need is, for each element to make <strong>two</strong> choices instead of one.</p>
<p>The expected output should look like:</p>
<pre><code>[('one', 'two'), ('one', 'one'), ('two', 'two'),('two', 'three'), ('three', 'two'), ('three', 'one')]
</code></pre>
<p>Do you know how to do have this output?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need two, just tell <code>numpy.random.choice()</code> to pick two values; include the <code>el</code> value as a tuple as you loop (no need to use <code>zip()</code>):</p>
<pre><code>tuples = []
for el in elements:
    for chosen in choice(elements, size=2, replace=False, p=weights):
        tuples.append((el, chosen))
</code></pre>
<p>or by using a list comprehension:</p>
<pre><code>tuples = [(el, chosen) for el in elements
          for chosen in choice(elements, size=2, replace=False, p=weights)]
</code></pre>
<p>By setting <code>replace=False</code>, you get unique values; remove it or set it to <code>True</code> explicitly to allow for repetition. See the <a href="https://docs.scipy.org/doc/numpy-1.12.0/reference/generated/numpy.random.choice.html#numpy.random.choice" rel="nofollow noreferrer"><code>numpy.random.choice()</code> documentation</a>:</p>
<blockquote>
<p><strong>size</strong> : <em>int or tuple of ints, optional</em><br/>
  Output shape. If the given shape is, e.g., <code>(m, n, k)</code>, then <code>m * n * k</code> samples are drawn. Default is <code>None</code>, in which case a single value is returned.</p>
<p><strong>replace</strong> : <em>boolean, optional</em><br/>
  Whether the sample is with or without replacement</p>
</blockquote>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from numpy.random import choice
&gt;&gt;&gt; elements = ['one', 'two', 'three']
&gt;&gt;&gt; weights = [0.2, 0.3, 0.5]
&gt;&gt;&gt; tuples = []
&gt;&gt;&gt; for el in elements:
...     for chosen in choice(elements, size=2, replace=False, p=weights):
...         tuples.append((el, chosen))
...
&gt;&gt;&gt; tuples
[('one', 'three'), ('one', 'one'), ('two', 'three'), ('two', 'two'), ('three', 'three'), ('three', 'two')]
&gt;&gt;&gt; [(el, chosen) for el in elements for chosen in choice(elements, size=2, replace=False, p=weights)]
[('one', 'one'), ('one', 'three'), ('two', 'one'), ('two', 'three'), ('three', 'two'), ('three', 'three')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you accept duplicates, <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices</code></a> will do the job:</p>
<blockquote>
<p>random.choices(population, weights=None, *, cum_weights=None, k=1)</p>
<p>Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises IndexError.</p>
<p>If a weights sequence is specified, selections are made according to the relative weights.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; random.choices(['one', 'two', 'three'], weights=[0.2, 0.3, 0.5], k=2)
['one', 'three']
</code></pre>
</div>
<span class="comment-copy">Those two choices, must they differ or are duplicates allowed? E.g. is <code>('one', 'one'), ('one', 'one')</code> a valid sequence in the output result?</span>
<span class="comment-copy">For this you should use the random in the standard library, you are not really using the numpy version.</span>
<span class="comment-copy">@MartijnPieters Duplicates are allowed, however it would be better if there is none. But, definitely allowed</span>
<span class="comment-copy">@IgnacioVergaraKausel Sorry, I did not understand the suggestion</span>
<span class="comment-copy">Thank you! That's it!</span>
<span class="comment-copy">@jonrsharpe: it is weighted; <code>random.choices()</code> plural is not <code>random.choice()</code> singular. This <i>does</i> allow for repeated values (<code>replace=True</code> in the <code>numpy.random.choice()</code> function).</span>
<span class="comment-copy">@MartijnPieters at the time I wrote the comment it was random.sample...</span>
<span class="comment-copy">@jonrsharpe Yeah sorry about that, I wrote my first answer a bit quickly...</span>
