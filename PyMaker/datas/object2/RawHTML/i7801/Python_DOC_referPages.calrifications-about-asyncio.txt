<div class="post-text" itemprop="text">
<p>I am trying to wrap my head around python asyncio. </p>
<pre><code>from datetime import datetime
import asyncio


def print_time(number, loop):
    et = loop.time() + 10.0
    while True:
        print('loop {} time {}'.format(number, datetime.now()))
        if (loop.time() &gt;= et):
            break
        yield from asyncio.sleep(3)


loop = asyncio.get_event_loop()

asyncio.ensure_future(print_time(1,loop))
asyncio.ensure_future(print_time(2,loop))

loop.run_forever()
</code></pre>
<p>The output (from Jupyter notebook)</p>
<pre><code>loop 1 time 2017-06-11 21:38:47.398280
loop 2 time 2017-06-11 21:38:47.398452
loop 1 time 2017-06-11 21:38:50.401818
loop 2 time 2017-06-11 21:38:50.402335
loop 1 time 2017-06-11 21:38:53.405770
loop 2 time 2017-06-11 21:38:53.406243
loop 1 time 2017-06-11 21:38:56.409524
loop 2 time 2017-06-11 21:38:56.410034
loop 1 time 2017-06-11 21:38:59.413300
loop 2 time 2017-06-11 21:38:59.413846
</code></pre>
<p>I have the following questions about the above program</p>
<ol>
<li><p>In this case is the function <code>print_time</code> considered a coroutine (as in contains <code>yield</code> statement?</p></li>
<li><p>does ensure_future() creates a separate task/process each time it is called? In that sense is it analogous to fork()</p></li>
<li><p>The current loop is running for ever. How do I gracefully exit after say 10 iterations.?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<ol>
<li>In this case is the function print_time considered a coroutine (as in contains yield statement?</li>
</ol>
</blockquote>
<p>You can create coroutine from function when you need it (for example, if it should await another coroutine). To <a href="https://docs.python.org/3/library/asyncio-task.html#tasks-and-coroutines" rel="nofollow noreferrer">create</a> coroutine you should use special decorator <code>@asyncio.coroutine</code> (or define coroutine with <code>async def</code> in Python 3.5+):</p>
<pre><code>@asyncio.coroutine
def print_time(number, loop):
    ...
</code></pre>
<p>In your case generator considered as coroutine only because asyncio's coroutines implemented using generators. You shouldn't use regular generators as coroutines, instead you should always explicitly use decorator <code>@asyncio.coroutine</code> (or <code>async def</code>) to create coroutines.</p>
<blockquote>
<ol start="2">
<li>does ensure_future() creates a separate task/process each time it is called? In that sense is it analogous to fork()</li>
</ol>
</blockquote>
<p><code>ensure_future</code> doesn't create OS thread or process. Usually all your coroutines/tasks run in single OS thread, single process.</p>
<p><code>ensure_future</code> is a way to rule flow of execution your async script. When you just await for some coroutine, code below it would be run only after coroutine finished. <code>ensure_future</code> allows you to <a href="https://stackoverflow.com/a/37345564/1113207">"run coroutine in background"</a> without blocking code below it from execution.</p>
<p>Example 1:</p>
<pre><code>yield from coro_1()
yield from coro_2()  # this line would be started only after coro_1 finished.
</code></pre>
<p>Example 2:</p>
<pre><code>asyncio.ensure_future(coro_1())
yield from coro_2()  # this line would be started immediately.
                     # coro_1 and coro_2 would de facto run parallely.
</code></pre>
<blockquote>
<ol start="3">
<li>The current loop is running for ever. How do I gracefully exit after say 10 iterations.?</li>
</ol>
</blockquote>
<p>You have many ways to do it, depending of how you want your code to work. </p>
<p>Here's one, for example:</p>
<pre><code>from datetime import datetime
import asyncio


# We should somehow limit number of iterations for this coroutine.
# For example we can pass it as param 'tries':
@asyncio.coroutine
def print_time(number, loop, tries):
    et = loop.time() + 10.0
    for _ in range(tries):
        print('loop {} time {}'.format(number, datetime.now()))
        if (loop.time() &gt;= et):
            break
        yield from asyncio.sleep(3)


@asyncio.coroutine
def main():

    # Run to tasks parallely and await both done using 'asyncio.gather':
    yield from asyncio.gather(
        asyncio.ensure_future(print_time(1, loop, tries=5)),
        asyncio.ensure_future(print_time(2, loop, tries=5))
    )


loop = asyncio.get_event_loop()

# Use 'run_until_complete' to finish execution when some coroutine is done:
loop.run_until_complete(main())
</code></pre>
<p>Output:</p>
<pre><code>loop 1 time 2017-06-11 15:16:03.864059
loop 2 time 2017-06-11 15:16:03.864059
loop 1 time 2017-06-11 15:16:06.864826
loop 2 time 2017-06-11 15:16:06.864826
loop 1 time 2017-06-11 15:16:09.865046
loop 2 time 2017-06-11 15:16:09.865046
loop 1 time 2017-06-11 15:16:12.865199
loop 2 time 2017-06-11 15:16:12.865199
loop 1 time 2017-06-11 15:16:15.865978
loop 2 time 2017-06-11 15:16:15.865978
[Finished in 12.2s]
</code></pre>
</div>
