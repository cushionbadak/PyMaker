<div class="post-text" itemprop="text">
<p>I'm looking for an alternative to a dictionary that will allow me to efficiently use ranges as keys. Presumably the data structure needs to be sorted - maybe something like a b tree? I haven't found a good python implementation.</p>
<p>For example, given the following dictionary-like data structure:</p>
<p><code>d = {'38.1003827193': 'value1', '58.29932891733': 'value2'}</code></p>
<p>Searching for the range <code>38 -&gt; 38.337</code> should return <code>value1</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure why your keys are kept as strings, but the <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer">bisect</a> module in the standard library can help you do binary searches in a sorted index. Multidimensional indexing is another chapter in turn, and the primary question is how you use your data; trees may be faster for insertions or particular distributions, for instance. </p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if this is what you meant, but I think this is what you meant:</p>
<pre><code>d = {'38.1003827193': 'value1', '58.29932891733': 'value2'}
d_keys = list(d.keys())

bound_names = ["lower bound", "upper bound"]
bounds = []
for i in range (0, 2):
    while True:
        try:
            bound = float(input("Enter the {} number: ".format(bound_names[i])))
        except ValueError:
            print("Number not entered.")
            continue
        else:
            break
    bounds.append(bound)

for n in range(len(d_keys)):
    if bounds[0] &lt;= d_keys[n] &lt;= bounds[1]:
        print(d[d_keys[n]])
</code></pre>
<p>If 38 (lower bound) and 38.3 (upper bound) are entered <code>value1</code> is printed.</p>
<p>Alternatively you can have search for numbers based on the part before the decimal:</p>
<pre><code>d = {'38.1003827193': 'value1', '58.29932891733': 'value2'}    
d_keys = list(d.keys())

bound_names = [["lower bound", "inclusive"], ["upper bound", "exclusive"]]
bounds = []
for n in range(0, 2):
    while True:
        try:
            number_to_search = int(input("Enter {} number ({}): ".format(bound_names[n][0], bound_names[n][1])))
        except ValueError:
            print("Integer not entered.")
            continue
        else:
            break
    bounds.append(number_to_search)

for n in range(len(d_keys)):
    if int(d_keys[n]) in range(bounds[0], bounds[1]):
        print(d[d_keys[n]])
</code></pre>
<p>When 37 (lower bound) and 39 (upper bound) are entered the code prints: <code>value1</code>, but when 38 is entered as upper bound <code>value1</code> is not printed.</p>
<p>If you dont want it to print you can  have it return a list of all the values that are that number. 
All you would have to do is change the <code>print(d[d_keys[n]])</code> to <code>numbers_in_range.append(d[d_keys[n]])</code> and adding <code>numbers_in_range = []</code> somewhere above.</p>
</div>
<span class="comment-copy"><code>collections.OrderedDict</code> (<code>ordereddict</code> in Python 3) provides a dictionary that maintains the order of keys in the order they were inserted. You might be able to build on this with a range access method. How large do you expect the data structure to get?</span>
<span class="comment-copy">Are the keys integers, strings of any other basic data type? Should the dict keys be ranges or you just want to search using ranges?</span>
<span class="comment-copy">The dictionary is likely to be on the order of 100k items. The keys are a string containing two floats separated by a comma (e.g. '23.29382398, 84.2390230'). The ranges would just be for searching. Thanks for your help.</span>
<span class="comment-copy">The dictionary you showed can be efficiently(?) searched by doing something like: [y for x,y in d.items() if float(x) &gt;= 38.0 and float(x) &lt; 39.0]. The range values would need to be substituted with variable data in the formula.</span>
<span class="comment-copy">Are you looking for something like a <a href="https://en.wikipedia.org/wiki/Range_tree" rel="nofollow noreferrer">range tree</a>?</span>
