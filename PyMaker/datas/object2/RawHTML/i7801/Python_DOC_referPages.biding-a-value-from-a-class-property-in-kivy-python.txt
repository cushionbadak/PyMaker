<div class="post-text" itemprop="text">
<p>I have multiple classes happily communicating thanks to <code>x</code> being an object of class foo:</p>
<pre><code>class foo(EventDispatcher):
   def variable_input(self, *args):
      self.a='This is an observed value being changed'

   def __init__(self):
      self.a=StringProperty('')
</code></pre>
<p>now I create an object <code>X</code> being an instance of class foo</p>
<pre><code>X=foo()
</code></pre>
<p>I have a <code>Screen</code> as a part of a <code>ScreenManager</code> containing a <code>Label</code> with id <code>vystup</code></p>
<pre><code>class Hlavne(Screen):
   pass
</code></pre>
<p>What I am trying to do is to write function <code>on_propname</code> with <code>X.a</code> as a propname. 
How do I point to value belonging to instance of other class.</p>
<p>I have read:</p>
<blockquote>
<p>Warning</p>
<p>Be careful with ‘on_’. If you are creating such a callback on a property you are inheriting, you must not forget to call the superclass function too.</p>
</blockquote>
<p>But as its common with kivy's documentation it does not tell you how.</p>
</div>
<div class="post-text" itemprop="text">
<p>Kivy Properties are declared at <strong>class</strong> level, not in an instance. (bad)</p>
<pre><code>def __init__(self):
   self.a=StringProperty('')
</code></pre>
<p>Binding <strong>to</strong> a property and using an <code>on_property</code> event are two different things.</p>
<pre><code>from kivy.clock import Clock
from kivy.base import runTouchApp
from kivy.uix.widget import Widget
from kivy.properties import NumericProperty


class Test(Widget):
    hop = NumericProperty(0)

    def __init__(self, **kwargs):
        super(Test, self).__init__(**kwargs)
        Clock.schedule_interval(
            lambda *dt: setattr(self, 'hop', self.hop + 1), 0.1
        )

        # bind to property
        self.bind(hop=self.bind_hop)

    def on_hop(self, instance, value):
        # no event, no super() necessary
        # unless inherrited from "Test"
        print('on_hop:', instance, value)

    def bind_hop(self, instance, value):
        print('bind_hop:', instance, value)

runTouchApp(Test())
</code></pre>
<p>You can check for an instance in each of the function with <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer"><code>isinstance</code></a> because of the <code>instance</code> argument passed into each event/bind of a Kivy property mentioned <strong><a href="https://kivy.org/docs/api-kivy.properties.html#observe-using-bind" rel="nofollow noreferrer">here</a></strong>.</p>
</div>
<span class="comment-copy">I will check tomorow, I admit, as a new python user, i do find it dificult to understand syntax of super. Thanx for now</span>
<span class="comment-copy">@Tomas Well, roughly said, imagine a class <code>A</code> with a method <code>A.x</code>. Now you create another class <code>B</code> with the same-named method <code>B.x</code>. Since <code>B</code> inherits from <code>A</code>, it can access everything(mostly) from the class <code>A</code>, therefore even the <code>x</code> method, however with creating <code>B.x</code> you overwrite the content of inherited <code>A.x</code> method. To stop the overwriting i.e. to execute even the code from <code>A.x</code> you call <code>super(current class name, current instance).method(args)</code> which in this particular case would be <code>super(B, self).x()</code>. This way you can execude <code>A.x</code> before or after the new <code>B.x</code> code.</span>
