<div class="post-text" itemprop="text">
<p>I have a syntax/understanding problem in an application using Python 3, PyQt5 and Qt5.  I am unsure which of these is causing the problem.</p>
<p>I am charged with porting a GUI application which worked under Windows to Linux, with newer versions of libraries.  I do not have access to the original running under Windows.</p>
<p>In several places I see:</p>
<pre><code>menu = QMenu(self)
action = menu.addAction("Some string")
action.triggered[()].connect(self.handler)
</code></pre>
<p>I presume this used to work.  I am porting to Python 3.5, PyQt 5.7 &amp; Qt 5.7.  I have reason to believe the code was written for earlier versions of each of these.</p>
<p>Executing it now generates a <code>'there is no matching overloaded signal'</code> error, on the <code>action.triggered[()]</code> segment.</p>
<p>By guesswork and looking at a couple of examples I found somewhere, I have changed the last line to:</p>
<pre><code>action.triggered.connect(self.handler)
</code></pre>
<p>and it seems to work now.</p>
<p>Could someone explain what the original <code>triggered[()]</code> syntax meant/worked, and which "product" the evident change was in --- it would be nice to be able to read about where this got changed?  Is my replacement by simply <code>triggered</code> correct/same behaviour?</p>
</div>
<div class="post-text" itemprop="text">
<p>The relevant change happened in PyQt-5.3. It is <strong>not</strong> entirely safe to simply remove the old syntax, as this could easily create a subtle bug in both current and future code.</p>
<p>The issue is that certain signals like <code>triggered</code> will always send a default boolean value unless you take steps to eliminate it. Qt defines these signals like this:</p>
<pre><code>    triggered(bool checked = false)
</code></pre>
<p>PyQt previously implemented this as two overloads:</p>
<pre><code>    triggered(bool checked)
    triggered()
</code></pre>
<p>and if you wanted to explicitly select the latter overload, you had to use the following slightly awkward sytax:</p>
<pre><code>    triggered[()].connect(slot)
</code></pre>
<p>But this is now no longer an option, as only the first overload is implemented. So to get <em>exactly</em> the same behaviour, it is necessary to either wrap the handler like this:</p>
<pre><code>    triggered.connect(lambda checked: slot())
</code></pre>
<p>or decorate it like this:</p>
<pre><code>    @QtCore.pyqtSlot()
    def handleTriggered(self):
        pass
</code></pre>
<p>Otherwise, it is quite easy to fall into a little trap. Imagine you have a method defined like this:</p>
<pre><code>    def frobnicate(self, foobar=True):
        if foobar:
            # do something nice
        else:
            # empty my home directory without prompting
</code></pre>
<p>Later on, you decide to hook this up to a button, like this:</p>
<pre><code>    self.button.clicked.connect(self.frobnicate)
</code></pre>
<p>Which all seems perfectly fine, until you find out that the <code>clicked</code> signal works just like <code>triggered</code>, and always sends <code>False</code> by default...</p>
<p>Of course, if you're <em>absolutely certain</em> that you will <em>never</em> connect slots which take arguments to signals like <code>triggered</code> and <code>clicked</code>, you could get away with connecting them all in the simplistic fashion shown above. But, really, that is just an accident waiting to happen...</p>
</div>
<span class="comment-copy"><i>This</i> is the kind of answer I was hoping for!  Could you please clarify <i>what</i> (syntactically) <code>triggered[()]</code> meant? I am new to Python.  Is that "an array of <code>()</code>"??</span>
<span class="comment-copy">@JonBrave. A tuple of argument types is used to select the specific overload you want. The <code>()</code> is empty tuple, meaning: select the overload with no arguments.</span>
<span class="comment-copy">@JonBrave. I should probably add that signals are custom python objects that implement the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>__getitem__</code> method</a>. They're conceptually more like a <code>dict</code> (mapping) than an array - although, to some extent, python's duck-typing allows them to be treated in much the same way.</span>
<span class="comment-copy">Is there such a thing as a document link for PyQt-5.3 which enumerates this behaviour change?  I could do with looking through for other potentials!</span>
<span class="comment-copy">@JonBrave. Try: <a href="http://pyqt.sourceforge.net/Docs/PyQt5/incompatibilities.html" rel="nofollow noreferrer">Incompatibilities with Earlier Versions</a> in the <a href="http://pyqt.sourceforge.net/Docs/PyQt5/index.html" rel="nofollow noreferrer">PyQt5 docs</a>.</span>
