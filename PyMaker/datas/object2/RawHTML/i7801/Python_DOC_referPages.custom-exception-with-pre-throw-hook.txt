<div class="post-text" itemprop="text">
<p>I want an <code>Exception</code> class that "does something" when it is thrown.
Dummy example:</p>
<pre><code>class BrowserEatRamError(Exception):
    def __raise__(self):
        os.system('Killall -9 chrome')
        super(BrowserEatRamError, self).__raise__()
</code></pre>
<p>When I throw it using:</p>
<pre><code>raise BrowserEatRamError('Chrome is eating all ram')
</code></pre>
<p>Chrome should be closed before the exception is thrown. Is there a magic method which can achieve it?  If not, what is the most elegant way to achieve similar behavior?</p>
<p>EDIT:</p>
<p>I prefer not to use <strong>init</strong> because <strong>init</strong> would be invoked even if the Exception is raised inside a try cache.</p>
</div>
<div class="post-text" itemprop="text">
<p>No such special method exists. All of these are documented in the <a href="https://docs.python.org/3/reference/datamodel.html#basic-customization" rel="nofollow noreferrer">Data model</a>.</p>
<p>Assuming you are using the (relatively good) practice of creating and initializing errors and then raising them, i.e.,</p>
<pre><code>raise Error(args)
</code></pre>
<p>instead of:</p>
<pre><code>err = Error(args)
# Somewhere else
raise err
</code></pre>
<p>You can simply overload the <code>__intit__</code> method (Called to initialise it).</p>
<p>You can also put it in a try / except. If you do this often, you can use a context manager.</p>
<pre><code>try:
     # ...
except Exception as e:
    # Reraise if the exception doesn't have a `.on_raise()` method
    # Or that method returns a falsey value.
    if not hasattr(e, 'on_raise') or not e.on_raise():
        raise
</code></pre>
<pre><code>class CustomRaiseAction(object):
    def __enter__(self):
        return
    def __exit__(exception_type, exception_value, traceback):
        if hasattr(exception_type, 'on_raise'):
            return exception_type.on_raise(exception_value)
custom_raise_action = CustomRaiseAction()

with custom_raise_action:
    # ...
</code></pre>
<p>In both of these ways, if the <code>on_raise</code> method returns <code>True</code>, the exception will stop propogating. If it returns <code>False</code> (Or other falsey values, like <code>None</code>), it will be thrown further.</p>
<p>You can also do this without a context manager, by overwriting <a href="https://docs.python.org/3/library/sys.html#sys.excepthook" rel="nofollow noreferrer"><code>sys.excepthook</code></a>. This is like an <code>__exit__</code> for the whole program, and is called when the program is about the end, and by default, displays the error. Note that this won't work if another program overrides it, and applies in all situations, including other modules, which may cause unexpected behaviour.</p>
<pre><code>import sys

old_excepthook = sys.excepthook
def new_excepthook(exception_type, exception_value, traceback):
    if hasattr(exception_type, 'on_raise'):
        exception_type.on_raise(exception_value)
    old_excepthook(exception_type, exception_value, traceback)
sys.excepthook = new_excepthook
</code></pre>
<p>And also, you cannot stop the exception and continue.</p>
</div>
<span class="comment-copy">Have you tried doing it in an <code>__init__()</code> method in your subclass.</span>
<span class="comment-copy"><b>init</b> gets invoked even if the exception is raised in a try cache.  CustomRaiseAction forces the user of my exception class to violate "dry".  Overriding sys.excepthook seems to be the best idea.  I think "isinstance(exception_value, MyException)" would be better   check than "hasattr(exception_type, 'on_raise')"</span>
