<div class="post-text" itemprop="text">
<p>I'm getting <code>TypeError: 'float' object cannot be interpreted as an integer</code>.  It appears <code>__mul__()</code> is expecting an integer only argument.  Did I not define it correctly?</p>
<pre><code># Running Python 3.6.0
from math import sqrt


class Vector(object):
    def __init__(self, coordinates):
        try:
            self.dimension = len(coordinates)
            if self.dimension &lt; 2 or self.dimension &gt; 3:
                raise ValueError
            self.coordinates = tuple(coordinates)

        except ValueError:
            raise ValueError('Must have at least 2 coordinates and no more than 3. Length = {}'.format(self.dimension))

        except TypeError:
            raise TypeError('The coordinates must be an iterable')

        self.magnitude = sqrt(sum([n ** 2 for n in self.coordinates]))

    # This fails with a type error
    def normalized(self):
        try:
            normalized = self.coordinates.__mul__(1.0 / self.magnitude)
        except ZeroDivisionError:
            raise Exception("Cannot normalize zero vector")
        return normalized

    # This fails with a type error
    # def normalized(self):
    #     try:
    #         normalized = self.coordinates * (1.0 / self.magnitude)
    #     except ZeroDivisionError:
    #         raise Exception("Cannot normalize zero vector")
    #     return normalized

    # This works fine
    # def normalized(self):
    #     try:
    #         normalized = [n / self.magnitude for n in self.coordinates]
    #     except ZeroDivisionError:
    #         raise Exception("Cannot normalize zero vector")
    #     return Vector(normalized)

    def __iter__(self):
        return self.coordinates

    def __mul__(self, scalar):
        # Vector scalar multiplication
        return Vector([e * scalar for e in self.coordinates])

    def __str__(self):
        return 'Vector: {}'.format(self.coordinates)


# Run the test...
if __name__ == "__main__":
    v1 = Vector([1.996, 3.108, -4.554])
    print(v1)
    print(v1.normalized())
</code></pre>
<p><strong>EDIT:</strong></p>
<p>Now that I understand what happened I'd like to clarify the answer for anyone who might run into this in the future.</p>
<p>The problem was here:</p>
<pre><code>normalized = self.coordinates.__mul__(1.0 / self.magnitude)
</code></pre>
<p>Which, for the purpose of this explanation simplifies to:</p>
<pre><code>a = b.__mul__(c)
</code></pre>
<p>or </p>
<pre><code>a = b * c
</code></pre>
<p>Here <code>b</code> is a tuple and <code>c</code> is a number, a real number.</p>
<p>In Python</p>
<pre><code>(1, 2) * 3
</code></pre>
<p>results in</p>
<pre><code>(1, 2, 1, 2, 1, 2)
</code></pre>
<p>In other words the <code>*</code> operator applied to a tuple results in the replication of that tuple N times.  </p>
<p>Which also means we can't multiply a tuple by a float, it makes no sense.  Hence the error:</p>
<pre><code>TypeError: 'float' object cannot be interpreted as an integer
</code></pre>
<p>Makes sense.</p>
<p>My error was in that I multiplied the tuple by <code>self.magnitude</code> rather than to multiply my <code>Vector</code> object by <code>self.magnitude</code>, like this:</p>
<pre><code>normalized = self.__mul__(1.0 / self.magnitude)
</code></pre>
<p>Given my definition of <code>__mul__()</code> this makes sense and works fine.  And this works too:</p>
<pre><code>normalized = self * (1.0 / self.magnitude)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are applying <code>__mul__</code> to the <strong>tuple</strong> <code>coordinates</code>. That returns n copies, which clearly requires an integer. </p>
<p>Since you've written a <code>__mul__</code> function, you probably meant to call that</p>
<pre><code>normalized = self.__mul__(1.0 / self.magnitude)
</code></pre>
<p>or directly</p>
<pre><code>normalized = Vector([e * 1.0 / self.magnitude for e in self.coordinates])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow noreferrer"><code>__mul__</code> applied to a tuple</a> (like your coordinates) duplicates the contents of the tuple to increase its length, and hence only makes sense with an integer.</p>
<p>You're trying to multiply eavh element of an array by a number. If you make <code>coordinates</code> a numpy array then the multiplication operator will do this correctly. If you want to keep <code>coordinates</code> as a tuple then you will need to iterate through it multiplying each element individually (e.g. like in the <code>__mul__</code> function you define for your vector class).</p>
<p>Personally I recommend using numpy arrays if possible - they'll make a lot of the maths you're doing quicker and easier if used well.</p>
</div>
<span class="comment-copy">I think this is probably a better guess at what OP is trying to achieve than my answer.</span>
<span class="comment-copy">Can you explain how <code>__mul__()</code> applied to a tuple returns multiple copies of the  tuple?  The list comprehension returns a new Vector object with the results of the scalar multiplication.</span>
<span class="comment-copy">I can't see a clear statement in the documentation, but you can test it: <code>(1,2)*2</code> = <code>(1, 2, 1, 2)</code> - just as <code>'ab'*2</code> = <code>'abab'</code></span>
<span class="comment-copy">Ah, OK, that's what you meant.    In this case I am defining multiplication whereby if my Vector type contains <code>(1,2)</code> the result of of <code>my_vector * 2)</code> would be a new Vector with coordinates <code>(2, 4)</code>.  In other words, there's no replication of the list or tuple N times.</span>
<span class="comment-copy">I'll accept this answer and add some comments/clarification to my question now that I understand what happened.</span>
