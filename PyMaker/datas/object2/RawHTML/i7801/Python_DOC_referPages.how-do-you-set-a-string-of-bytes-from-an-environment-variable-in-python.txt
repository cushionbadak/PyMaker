<div class="post-text" itemprop="text">
<p>Say that you have a string of bytes generated via <code>os.urandom(24)</code>,</p>
<pre><code>b'\x1b\xba\x94(\xae\xd0\xb2\xa6\xf2f\xf6\x1fI\xed\xbao$\xc6D\x08\xba\x81\x96v'
</code></pre>
<p>and you'd like to store that in an environment variable,</p>
<pre><code>export FOO='\x1b\xba\x94(\xae\xd0\xb2\xa6\xf2f\xf6\x1fI\xed\xbao$\xc6D\x08\xba\x81\x96v'
</code></pre>
<p>and retrieve the value from within a Python program using <code>os.environ</code>.</p>
<pre><code>foo = os.environ['FOO']
</code></pre>
<p>The problem is that, here, <code>foo</code> has the string literal value <code>'\\x1b\\xba\\x94...</code> instead of the byte sequence <code>b'\x1b\xba\x94...</code>.</p>
<p>What is the proper <code>export</code> value to use, or means of using <code>os.environ</code> to treat <code>FOO</code> as a string of bytes?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can 'unescape' your bytes in Python with:</p>
<pre><code>import os
import sys

if sys.version_info[0] &lt; 3:  # sadly, it's done differently in Python 2.x vs 3.x
    foo = os.environ["FOO"].decode('string_escape')  # since already in bytes...
else:
    foo = bytes(os.environ["FOO"], "utf-8").decode('unicode_escape')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One more option, just set it as binary data in Bash. This uses <a href="https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html" rel="noreferrer">ANSI string quoting</a>:</p>
<pre><code>export FOO=$'\x1b\xba\x94(\xae\xd0\xb2\xa6\xf2f\xf6\x1fI\xed\xbao$\xc6D\x08\xba\x81\x96v'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With zwer's answer I tried the following</p>
<p>first from bash (this is the same binary literal given by ybakos)</p>
<pre><code>export FOO='\x1b\xba\x94(\xae\xd0\xb2\xa6\xf2f\xf6\x1fI\xed\xbao$\xc6D\x08\xba\x81\x96v'
</code></pre>
<p>then I launched the python shell (I have python 3.5.2)</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; # ybakos's original binary literal
&gt;&gt;&gt; foo =  b'\x1b\xba\x94(\xae\xd0\xb2\xa6\xf2f\xf6\x1fI\xed\xbao$\xc6D\x08\xba\x81\x96v'
&gt;&gt;&gt; # ewer's python 3.x solution
&gt;&gt;&gt; FOO = bytes(os.environ["FOO"], "utf-8").decode('unicode_escape')
&gt;&gt;&gt; foo == FOO
False
&gt;&gt;&gt; ^D
</code></pre>
<p>The last line of foo == FOO should return true, so the solution does not appear to work correctly.</p>
<p>I noticed that there is an <a href="https://docs.python.org/3/library/os.html#os.environb" rel="nofollow noreferrer">os.envirnb</a> dictionary, but I couldn't figure out to set an Environment Variable to a binary literal, so I tried the following alternative which uses base64 encoding to get an ASCII version of the binary literal.</p>
<p>First launch python shell</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; import base64
&gt;&gt;&gt; foo = os.urandom(24)
&gt;&gt;&gt; foo
b'{\xd9q\x90\x8b\xba\xecv\xb3\xcb\x1e&lt;\xd7\xba\xf1\xb4\x99\xf056\x90U\x16\xae'
&gt;&gt;&gt; foo_base64 = base64.b64encode(foo)
&gt;&gt;&gt; foo_base64
b'e9lxkIu67Hazyx4817rxtJnwNTaQVRau'
&gt;&gt;&gt; ^D
</code></pre>
<p>Then in the bash shell</p>
<pre><code>export FOO_BASE64='e9lxkIu67Hazyx4817rxtJnwNTaQVRau'
</code></pre>
<p>Then back in the python shell</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; import base64
&gt;&gt;&gt; # the original binary value from the first python shell session
&gt;&gt;&gt; foo = b'{\xd9q\x90\x8b\xba\xecv\xb3\xcb\x1e&lt;\xd7\xba\xf1\xb4\x99\xf056\x90U\x16\xae'
&gt;&gt;&gt; dec_foo = base64.b64decode(bytes(os.environ.get('FOO_BASE64'), "utf-8"))
&gt;&gt;&gt; # the values match!
&gt;&gt;&gt; foo == dec_foo
True
&gt;&gt;&gt; ^D
</code></pre>
<p>The last line shows that the 2 results are the same!!</p>
<p>What we are doing, is first getting a binary value from os.urandom() and Base64 encoding it. We then use the Base64 encoded value to set the environment variable. Note: <a href="https://docs.python.org/2/library/base64.html#base64.b64encode" rel="nofollow noreferrer">base64.b64encode()</a> returns a binary value, but it will only contain printable ASCII characters. </p>
<p>Then in our program we read in the Base64 encode string value from the environment variable, convert the string into it's binary form, and finally Base64 decode it back to its original value.</p>
</div>
<span class="comment-copy">Could be because of the single quotation marks.</span>
<span class="comment-copy">I'm confused; if you print (repr) <code>foo</code> in Python where it came from something like <code>os.urandom</code> and see <code>b'\x1b\xba...'</code> then it is (in Python) raw bytes. If you read it from the envvar and see <code>'\\x1b\\xba'</code> then it's a (Unicode) string that's still escaped. As per <a href="https://stackoverflow.com/questions/43214001/how-to-write-binary-data-in-bash">this question</a>, it seems like bash won't interpret your <code>export FOO</code> line as real binary, but a string with a bunch of <code>\x</code>'s in it.</span>
<span class="comment-copy">An alternative option is to save the bytes in a binary file, and use the filename as an environment variable</span>
<span class="comment-copy">Your Py3 solution produces a <code>str</code>, not a <code>bytes</code> object, and unnecessarily converts the string form to <code>bytes</code>. Replace that second line with: <code>foo = os.environb[b'FOO'].decode('unicode-escape').encode('latin-1')</code> to make it read from <code>os.environb</code> (the <code>bytes</code>-oriented view of the environment), decode the escapes, then convert back to raw <code>bytes</code> (<code>latin-1</code> is a 1-1 mapping that maps the first 256 Unicode ordinals to their ordinal value as bytes).</span>
<span class="comment-copy">This is a great approach, since it makes reading the data in Python as simple as <code>os.environ['FOO']</code> (Py2) or <code>os.environb[b'FOO']</code> (Py3), so you get the data in Python as raw <code>bytes</code> without needing to encode or decode at all. I'd completely forgotten about this feature of Bash, so thanks for the reminder!</span>
