<div class="post-text" itemprop="text">
<p>I have a string:</p>
<pre><code>a = babababbaaaaababbbab
</code></pre>
<p>And it needs to be shortened so it looks like this:</p>
<pre><code>(ba)3(b)2(a)5ba(b)3ab
</code></pre>
<p>So basically it needs to take all repeating characters and write how many times they are repeating instead of printing them.
I managed to do half of this:</p>
<pre><code>from itertools import groupby
a = 'babababbaaaaababbbab'
grouped = ["".join(grp) for patt,grp in groupby(a)]
solved = [str(len(i)) + i[0] for i in grouped if len(i) &gt;= 2]
</code></pre>
<p>but this only does this for characters that are repeating but not patterns. I get it that I could do this by finding 'ab' pattern in string but this needs to be viable for every possible string. Has anyone encountered something similar?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can easily do this with <a href="https://docs.python.org/3/howto/regex.html" rel="noreferrer">regex</a>:</p>
<pre><code>&gt;&gt;&gt; repl= lambda match:'({}){}'.format(match.group(1), len(match.group())//len(match.group(1)))
&gt;&gt;&gt; re.sub(r'(.+?)\1+', repl, 'babababbaaaaababbbab')
'(ba)3(b)2(a)5ba(b)3ab'
</code></pre>
<p>Not much to explain here. The pattern <code>(.+?)\1+</code> matches repeating character sequences, and the lambda function rewrites them to the form <code>(sequence)number</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what I came up with, the code is a mess, but I just wanted to have a quick fun, so I let it be like this</p>
<pre><code>a = 'babababbaaaaababbbab'

def compress(text):
    for i in range(1, len(text) // 2):
        for j, c in enumerate(text[:-i if i &gt; 0 else len(text)]):
            pattern = text[j:i+j]
            new_text = pattern_repeats_processor(pattern, text, j)
            if new_text != text:
                return compress(new_text)
    return text

def pattern_repeats_processor(pattern, text, i):
    chunk = pattern
    count = 1 
    while chunk == pattern and i + (count + 1) * len(pattern) &lt; len(text):
        chunk = text[i + count * len(pattern): i + (count + 1) * len(pattern)] 
        if chunk == pattern:
            count = count + 1
        else:
            break
    if count &gt; 1:
        return text[:i] + '(' + pattern + ')' + str(count) + text[i + (count + 0) * len(pattern):]
    return text

print(compress(a))
print(a)
</code></pre>
<p>It makes 
babababbaaaaababbbab =&gt;
(ba)3(b)2(a)5ba(b)3ab</p>
<p>P.S. Of course answer of Rowing is miles better, pretty impressive even</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure what exactly you're looking for but here hope this helps.</p>
<pre><code>A=a.count('a')
B=a.count('b')
AB=a.count('ab')
BAB=a.count('bab')
BA=a.count('ba')
print(A,'(a)',B,'(b)',AB,'(ab)',BAB,'(bab)',BA,'(ba)')
</code></pre>
</div>
<span class="comment-copy">this may be related: <a href="https://stackoverflow.com/questions/11090289/find-longest-repetitive-sequence-in-a-string" title="find longest repetitive sequence in a string">stackoverflow.com/questions/11090289/â€¦</a></span>
<span class="comment-copy">This is ambiguous.  What is the expected output for <code>aaabbbaaabbb</code>?  Is it <code>(a)3(b)3(a)3(b)3</code> or <code>(aaabbb)2</code>?</span>
<span class="comment-copy">@Nenad Why?  How is the algorithm going to know?</span>
<span class="comment-copy">@SvenMarnach, longest match? I think that would save the most space.</span>
<span class="comment-copy">this might be a good question for <a href="https://codegolf.stackexchange.com">codegolf.stackexchange.com</a></span>
<span class="comment-copy">Awesome ! I think i might spare a good time to master regex. Really good answer.</span>
<span class="comment-copy">For <code>aabaabaab</code>, this gives a rather unintuitive <code>(a)2(baa)2b</code> instead of <code>(aab)3</code>. Although that's not to say it's wrong - the problem is a bit under-specified.</span>
<span class="comment-copy">@Dukeling That's to conform with OP's statement that <code>aaabbbaaabbb</code> is to become <code>(a)3(b)3(a)3(b)3</code> - it repeats the shortest possible sequence. If that's undesirable, you can try changing <code>(.+?)\1+</code> to <code>(.+)\1+</code>, though that also has some weird quirks - for example it'll turn <code>abababab</code> into <code>(abab)2</code>.</span>
<span class="comment-copy">This doesn't even seem to give the correct output for the example in the question, never mind the more general problem.</span>
