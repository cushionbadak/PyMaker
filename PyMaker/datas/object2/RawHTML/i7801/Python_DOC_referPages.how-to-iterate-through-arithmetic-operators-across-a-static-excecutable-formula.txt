<div class="post-text" itemprop="text">
<p>I'm trying to use itertools to iterate through mathematical operators.
Typically with an <code>array</code> of <code>[1, 2, 3]</code>, using <code>combinations</code> I can get the results:</p>
<pre><code>1
1,2
1,3
2,3
1,2,3
</code></pre>
<p>etc.</p>
<p>I want to use this on an <code>array</code> of <code>[1, 2, 3]</code> in such a way that:</p>
<pre><code>1+2+3
1+2-3
1+2/3
1+2*3
1-2+3
1-2-3
1-2/3
1-2*3
...
</code></pre>
<p>arises and gives results of the equation.</p>
<p>How might I go about doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>A solution generalized to any number of operands, and preserving normal precedence of operators:</p>
<pre><code>from itertools import product

operands = [1, 2, 3, 4]
operators = [ '+', '*', '-', '//' ] # change '//' to '/' for floating point division
for opers in product(operators, repeat=len(operands)-1):
    formula = [ str(operands[0]) ]
    for op, operand in zip(opers, operands[1:]):
        formula.extend([op, str(operand)])
    formula = ' '.join(formula)
    print('{} = {}'.format(formula, eval(formula)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is how I would approach it:</p>
<pre><code>import itertools
import operator
</code></pre>
<p>First make the list of all possible combinations:</p>
<pre><code>funcs = [operator.add, operator.sub, operator.mul, operator.div]

combos = list(itertools.product(funcs, repeat=2))

&gt;&gt;[(&lt;function operator.add&gt;, &lt;function operator.add&gt;),
 (&lt;function operator.add&gt;, &lt;function operator.sub&gt;),
 (&lt;function operator.add&gt;, &lt;function operator.mul&gt;),
 (&lt;function operator.add&gt;, &lt;function operator.div&gt;),
 (&lt;function operator.sub&gt;, &lt;function operator.add&gt;),
 (&lt;function operator.sub&gt;, &lt;function operator.sub&gt;),
 (&lt;function operator.sub&gt;, &lt;function operator.mul&gt;),
 (&lt;function operator.sub&gt;, &lt;function operator.div&gt;),
 (&lt;function operator.mul&gt;, &lt;function operator.add&gt;),
 (&lt;function operator.mul&gt;, &lt;function operator.sub&gt;),
 (&lt;function operator.mul&gt;, &lt;function operator.mul&gt;),
 (&lt;function operator.mul&gt;, &lt;function operator.div&gt;),
 (&lt;function operator.div&gt;, &lt;function operator.add&gt;),
 (&lt;function operator.div&gt;, &lt;function operator.sub&gt;),
 (&lt;function operator.div&gt;, &lt;function operator.mul&gt;),
 (&lt;function operator.div&gt;, &lt;function operator.div&gt;)]
</code></pre>
<p>Then we will iterate through this list solving every possible outcome:</p>
<pre><code>for fn in combos:
    print 'This combo {} yielded this result {}'.format(fn, fn[1](fn[0](*seq[:2]), seq[-1]))

This combo (&lt;built-in function add&gt;, &lt;built-in function add&gt;) yielded this result 6
This combo (&lt;built-in function add&gt;, &lt;built-in function sub&gt;) yielded this result 0
This combo (&lt;built-in function add&gt;, &lt;built-in function mul&gt;) yielded this result 9
This combo (&lt;built-in function add&gt;, &lt;built-in function div&gt;) yielded this result 1
This combo (&lt;built-in function sub&gt;, &lt;built-in function add&gt;) yielded this result 2
This combo (&lt;built-in function sub&gt;, &lt;built-in function sub&gt;) yielded this result -4
This combo (&lt;built-in function sub&gt;, &lt;built-in function mul&gt;) yielded this result -3
This combo (&lt;built-in function sub&gt;, &lt;built-in function div&gt;) yielded this result -1
This combo (&lt;built-in function mul&gt;, &lt;built-in function add&gt;) yielded this result 5
This combo (&lt;built-in function mul&gt;, &lt;built-in function sub&gt;) yielded this result -1
This combo (&lt;built-in function mul&gt;, &lt;built-in function mul&gt;) yielded this result 6
This combo (&lt;built-in function mul&gt;, &lt;built-in function div&gt;) yielded this result 0
This combo (&lt;built-in function div&gt;, &lt;built-in function add&gt;) yielded this result 3
This combo (&lt;built-in function div&gt;, &lt;built-in function sub&gt;) yielded this result -3
This combo (&lt;built-in function div&gt;, &lt;built-in function mul&gt;) yielded this result 0
This combo (&lt;built-in function div&gt;, &lt;built-in function div&gt;) yielded this result 0
</code></pre>
<p>Edit: Here is a way that follows the rules of operations</p>
<pre><code>ops = ['+','-','*','/']

combos = list(itertools.product(ops, repeat=2))

for tup in list(itertools.product(combos, [seq])):
    print 'These operations {} evaluate to this ---&gt; {}'.format(tup[0],eval(''.join(*zip(seq[0],tup[0][0],seq[1],tup[0][1],seq[-1]))))

These operations ('+', '+') evaluate to this ---&gt; 6
These operations ('+', '-') evaluate to this ---&gt; 0
These operations ('+', '*') evaluate to this ---&gt; 7
These operations ('+', '/') evaluate to this ---&gt; 1
These operations ('-', '+') evaluate to this ---&gt; 2
These operations ('-', '-') evaluate to this ---&gt; -4
These operations ('-', '*') evaluate to this ---&gt; -5
These operations ('-', '/') evaluate to this ---&gt; 1
These operations ('*', '+') evaluate to this ---&gt; 5
These operations ('*', '-') evaluate to this ---&gt; -1
These operations ('*', '*') evaluate to this ---&gt; 6
These operations ('*', '/') evaluate to this ---&gt; 0
These operations ('/', '+') evaluate to this ---&gt; 3
These operations ('/', '-') evaluate to this ---&gt; -3
These operations ('/', '*') evaluate to this ---&gt; 0
These operations ('/', '/') evaluate to this ---&gt; 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not an elegant one (made on knee) but works, just to point out my logic.
The idea is to reduce the list one by one in correct order. E.g.:</p>
<p>Data: 1 * 2 + 3 * 4</p>
<ul>
<li>After Step 1 ( first * evaluated ): 2 + 3 * 4</li>
<li>After Step 2 ( second * evaluated ): 2 + 12</li>
<li>After Step 3 ( + evaluated ): 14</li>
</ul>
<p>The code:</p>
<pre><code>import operator
import itertools

data = [1.0, 2.0, 3.0, 4.0]
operators_1 = [operator.mul, operator.div] # this operators have priority over that below
operators_2 = [operator.add, operator.sub]

def processOps(formula, data, operators):
    res_formula = list(formula)
    result = list(data)
    for op in formula:
        if op not in operators: continue

        i = res_formula.index(op)
        result = result[:i] + [op(result[i], result[i + 1])] + result[i + 2:]
        res_formula.remove(op)

        if len(result) == 1:
            break

    return (res_formula, result)

for f in itertools.product(operators_1 + operators_2, repeat=len(data)-1):
    result = list(data)
    formula = list(f)
    formula, result = processOps(formula, result, operators_1)
    formula, result = processOps(formula, result, operators_2)
    print f, result
</code></pre>
<p><strong>UDP</strong> This updated logic handles cases like (1 * 2) + (3 / 4) correctly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the corresponding functions in the <code>operator</code> module and iterate over pairs of them.</p>
<pre><code>import itertools
import operator

ops = [operator.add, operator.sub, operator.mul, operator.div]

for f1, f2 in itertools.product(*ops, repeat=2):
    print f1(array[0], f2(array[1], array[2]))
</code></pre>
<p>Now, if <code>array</code> can have an arbitrary length, it gets a bit tricker.</p>
<pre><code>for operations in itertools.product(*ops, repeat=len(array)-1):
  result = operations[0](array[0], array[1])
  for op, operand in zip(operations[1:], array[2:]):
      result = op(result, operand)
  print(result)
</code></pre>
<p>The structure above avoids having to know the appropriate identity element for each operation.</p>
<p>If you want to obey precedence (as seems likely), you'll want to create an expression and evaluate it with <code>eval</code> (standard warnings apply).</p>
<pre><code>for ops in itertool.product("+", "-", "*", "/", repeat=len(array)-1):
  expr = "%s%s%s" % (array[0], ops[0], array[1])
  for op, operand in zip(ops[1:], array[2:]):
    expr = "%s%s%s" % (expr, op, operand)
  result = eval(expr)
</code></pre>
<p>I leave it as an exercise to expand this to produce parenthesized expressions like <code>(1+2)*3</code> in addition to <code>1+2*3</code>.</p>
</div>
<span class="comment-copy">There are functions that perform the standard arithmetic operations in the <a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer">operator</a> module.</span>
<span class="comment-copy">There are two possible approaches: one is creating your formula as a string, then using <code>eval</code> to evaluate it; and another, to use functions from <code>operator</code> module.</span>
<span class="comment-copy">Take a look at <code>__add__</code>, <code>__sub__</code>, <code>__mul__</code> and <code>__div__</code> methods of <code>int</code>.</span>
<span class="comment-copy">is it bound to only starting with addition and subtraction?</span>
<span class="comment-copy">It's not bound for starting with anything in particular, it could go in any order.</span>
<span class="comment-copy">This is really good. However by changing the '//' to a '/' it ends up with the same answer as'//'. So the division is slightly off.</span>
<span class="comment-copy">Erm, do you use Python 2.x? In this case, yes, there is no difference between <code>/</code> and <code>//</code>, unless you add this: <code>from __future__ import division</code></span>
<span class="comment-copy">That fixed it, thank you :)</span>
<span class="comment-copy">So, you mean that <code>This combo (&lt;built-in function sub&gt;, &lt;built-in function mul&gt;) yielded this result -3</code> is 1 - 2 * 3 === 1 - 6 == -3? :) How about the priority of operations?)</span>
<span class="comment-copy">Doesn't respects the <a href="https://en.wikipedia.org/wiki/Order_of_operations" rel="nofollow noreferrer">bodmas rule</a>. 1+2*3 shouldn't result in  9.</span>
<span class="comment-copy">yes you're right I didn't consider order of operations, one second I will revise</span>
<span class="comment-copy">Thanks for this, I think it's a bit heavier than what I was looking for but I appreciate your effort.</span>
<span class="comment-copy">added an approach that follows rules of operations</span>
<span class="comment-copy">I'm getting some mistakes here. For: (&lt;built-in function div&gt;, &lt;built-in function mul&gt;, &lt;built-in function add&gt;) [4.166666666666667] where it should be 1/2*3+4, the answer should be 5.5</span>
<span class="comment-copy">I saw your next edit, this works great. Thank you :)</span>
<span class="comment-copy">@NameyMcNamo, Thank you too, for this question - it was really interesting for me to make it working)</span>
<span class="comment-copy">Replace <code>len(array)</code> with <code>len(array)-1</code> - number of operators is one less than number of operands.</span>
<span class="comment-copy">Thanks; something about <code>operations</code> and <code>array</code> being sliced with different starting indices in the call to <code>zip</code> made me thing something was wrong, but I didn't stop to think what.</span>
<span class="comment-copy">I try running these but it says: TypeError: 'int' object is not iterable I think it refers to the 2.</span>
<span class="comment-copy">I always forget; <code>repeat</code> has to be specified as a keyword argument.</span>
