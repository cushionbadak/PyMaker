<div class="post-text" itemprop="text">
<p>Is there a pythonic way to have a custom iterator on a namedtuple?</p>
<p>A custom iterator appears to require an index attribute. Normally a namedtuple has a "<code>__slots__ = ()</code>" declaration, which avoids the overhead of a dynamic dict and reduces latency in attribute lookup. However, this breaks the iterator (<code>AttributeError: 'Path' object has no attribute '_iidx'</code>). Adding <code>_iidx</code> to the slots results in <code>nonempty __slots__ not supported</code></p>
<p>Context: I will be working with a large number of Bezier splines. Each spline consists of a list of 'knot' points, and list of pairs of control points. By commenting out the <code>__slots__ = ()</code> declaration, my code works. But, at the cost of having a per-instance dynamic dict. The overhead from the dict in attribute lookup is probably negligible compared to everything else, but it doesn't seem pythonic.</p>
<pre><code>class Path(namedtuple('Path', "knots ctrl_pts")):
#    __slots__ = ()

    @property
    def SVG(self):
        s = 'M %s' % self.knots[0].bare
        for cps, k in self:
            s += ' C %s %s' % (cps.bare, k.bare)
        return s

    def __iter__(self):
        self._iidx = 0
        return self

    def __next__(self):
        if self._iidx == len(self.ctrl_pts):
            raise StopIteration
        i = self._iidx
        self._iidx += 1
        return (self.ctrl_pts[i], self.knots[i+1])
</code></pre>
<p>The SVG method uses the iterator to make SVG formating trivial. This:</p>
<pre><code>print('&lt;path d="%s" stroke="black" stroke-width="1" fill="blue" /&gt;'
       % path.SVG)
</code></pre>
<p>Results in:</p>
<pre><code>&lt;path d="M 318.9 179.4 C 279.1 177.6 199.2 270.3 222.4 298.1 C 245.5
326.0 371.6 289.1 420.4 297.0 C 469.2 304.9 440.6 357.6 399.6 352.4
C 388.5 350.9 389.7 345.0 400.4 347.6 C 440.1 357.4 469.4 309.2 419.6
303.0 C 369.8 296.7 240.9 332.5 217.6 301.9 C 194.4 271.2 276.9 174.1
319.1 174.6 C 330.3 174.7 329.9 179.9 318.9 179.4" stroke="black"
stroke-width="1" fill="blue" /&gt;
</code></pre>
<p>But it also is trivial to use in the <code>on_draw(self, wid, cr):</code> of a Gtk.DrawingArea:</p>
<pre><code>        path = self.coords.outline_path 
        cr.set_source_rgb(*LT_BLUE)
        cr.move_to(*path.knots[0])
        for (c,k) in path:
            cr.curve_to(*c.P1, *c.P2, *k)
        cr.fill_preserve()
        cr.set_source_rgb(*BLACK)
        cr.stroke()
</code></pre>
<p>Note: the 'knots' is a <code>List[Point]</code> and 'ctrl_pts' is a <code>List[ControlPoints]</code>:</p>
<pre><code>class Point(namedtuple('Point', "x y")):
    __slots__ = ()
    """&lt;bunch of stuff not shown&gt;"""
    @property
    def bare(self):
        return '%.1f %.1f' % (self.x, self.y)

class ControlPoints(namedtuple('ControlPoints', "P1 P2")):
    __slots__ = ()
    @property
    def bare(self):
        return '%s %s' % (self.P1.bare, self.P2.bare)
</code></pre>
<p>I am very new to python and I am certain this can be done in a more pythonic way.</p>
</div>
<div class="post-text" itemprop="text">
<p>To make your code work as is, add <code>_iidx</code> to the attribute list in the call to namedtuple().</p>
<p>Note that inheriting from a namedtuple class makes further sub-classing less useful because inheritors can not add new attributes. This may or may not matter in your application. As an alternative you can inherit from <code>object</code> and call out the attribute names in <code>__slots__</code>. This will preserve much of the performance benefits of inheriting from a namedtuple, and make it so that inheritors can define new attributes in their <code>__slots__</code>.</p>
<p>Changes below include:</p>
<ol>
<li><code>__iter__</code> now returns a generator that manages looping for you so you don't need <code>_iidx</code> anymore. Check out <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a> for interesting ways of creating iterators. Defining <code>__next__</code> is often more work than is necessary.</li>
<li>The svg property now accumulates strings in a list and then joins them. This is usually faster than the increment operator on str.</li>
<li>The last bit is changing the svg property to lowercase. This is purely style but it is more in line with the core language's <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">style guide</a>. </li>
</ol>
<p>.</p>
<pre><code>from itertools import izip    # python 2 only

class Path(namedtuple('Path', "knots ctrl_pts")):
    __slots__ = ()

    @property
    def svg(self):    # attribute names are usually lower case
        # accumulating strings with += is slow
        # use a list insted
        s = ['M %s' % self.knots[0].bare]
        for cps, k in self:
            s.append('C %s %s' % (cps.bare, k.bare))
        return ' '.join(s)

    def __iter__(self):
        # python 3
        return zip(self.ctrl_pts, self.knots[1:])

        # python 2
        return izip(self.ctrl_pts, self.knots[1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rather than implementing the iterator protocol manually, make <code>__iter__</code> a generator for the values you want.  The generator object implements the iterator protocol for you.</p>
<pre><code>class Path(namedtuple('Path', "knots ctrl_pts")):

    @property
    def SVG(self):
        s = 'M %s' % self.knots[0].bare
        for cps, k in self:
            s += ' C %s %s' % (cps.bare, k.bare)
        return s

    def __iter__(self):
        for t in zip(self.ctrl_pts, self.knots[1:]):
            yield t
</code></pre>
<p>If you only expect <code>__iter__</code> to be used as part of <code>SVG</code>, you really don't need it, and can use something like this:</p>
<pre><code>class Path(namedtuple('Path', "knots ctrl_pts")):

    @property
    def SVG(self):
        return 'M %s%s' % (self.knots[0].bare, 
                           ''.join([' C %s %s' % (cps.bare, k.bare)
                                    for cps, k in zip(self.ctrl_pts, self.knots[1:])]))
</code></pre>
</div>
<span class="comment-copy">Why don't you just not use <code>__slots__</code>?</span>
<span class="comment-copy">Can't use non-empty <code>__slots__</code> on a namedtuple. It results in <code>nonempty __slots__ not supported</code></span>
<span class="comment-copy">I said why don't you just <i>not</i> use <code>__slots__</code>.  Why not just accept the <code>__dict__</code>?</span>
<span class="comment-copy">Sorry for my misunderstanding. Yes, that is exactly what I am currently doing by commenting out the <code>__slots__</code> declaration. As I mention, the extra overhead of a dynamic dict does make every attribute lookup a little slower, but it probably doesn't compare to the rest of the actions. Mostly, it just felt non-pythonic to have a namedtuple with the overhead of a dict, and I was hoping for better.</span>
<span class="comment-copy">Unfortunately, for a namedtuple <code>Field names cannot start with an underscore: '_iidx'</code>. If I drop the underscore, <b>new</b> fails.</span>
<span class="comment-copy">I love the zip solution. Works great!! Please ignore the earlier comment. It was sent when I tried to add a &lt;cr&gt; and I was too slow editing it.</span>
<span class="comment-copy">Love it, works great!</span>
