<div class="post-text" itemprop="text">
<p>In Python 3.5, say I have:</p>
<pre><code>class Foo:
    def __init__(self, bar, barbar):
        self.bar = bar
        self.barbar = barbar
</code></pre>
<p>I want to get the list <code>["bar", "barbar"]</code> from the class.</p>
<p>I know I can do:</p>
<pre><code>foo = Foo(1, 2)
foo.__dict__.keys()
</code></pre>
<p>Is there a way to get <code>["bar", "barbar"]</code> <strong>without</strong> instantiating an object?</p>
</div>
<div class="post-text" itemprop="text">
<p>No because the attributes are dynamic (so called <em>instance attributes</em>).  Consider the following,</p>
<pre><code>class Foo:
    def __init__( self ):
        self.bar = 1

    def twice( self ):
        self.barbar = 2

f = Foo()
print( list(f.__dict__.keys() ) )
f.twice()
print( list(f.__dict__.keys() ) )
</code></pre>
<p>In the first print, only <code>f.bar</code> was set, so that's the only attributes that's shown when printing the attribute keys.  But after calling <code>f.twice()</code>, you create a <em>new</em> attribute to <code>f</code> and now printing it show both <code>bar</code> and <code>barbar</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Warning</strong> -
The following isn't foolproof in always providing 100% correct data. If you end up having something like <code>self.y = int(1)</code> in your <code>__init__</code>, you will end up including the <code>int</code> in your collection of attributes, which is not a wanted result for your goals. Furthermore, if you happen to add a dynamic attribute somewhere in your code like <code>Foo.some_attr = 'pork'</code>, then you will never see that either. Be aware of what it is that you are inspecting at what point of your code, and understand why you have and don't have those inclusions in your result. There are probably other "breakages" that will not give you the full 100% expectation of what are <em>all</em> the attributes associated with this <em>class</em>, but nonetheless, the following should give you <em>something</em> that you might be looking for. </p>
<p>However, I strongly suggest you take the advice of the other answers here and the duplicate that was flagged that explains why you can't/should not do this. </p>
<p>The following is a form of solution you can try to mess around with: </p>
<p>I will expand on the <code>inspect</code> answer.</p>
<p>However, I do question (and probably would advice against) the validity of doing something like this in <em>production</em>-ready code. For investigative purposes, sure, knock yourself out. </p>
<p>By using the <a href="https://docs.python.org/3/library/inspect.html" rel="noreferrer">inspect</a> module as indicated already in one of the other answers, you can use the <a href="https://docs.python.org/3/library/inspect.html#inspect.getmembers" rel="noreferrer">getmembers</a> method which you can then iterate through the attributes and inspect the appropriate data you wish to investigate.</p>
<p>For example, you are questioning the dynamic attributes in the <code>__init__</code></p>
<p>Therefore, we can take this example to illustrate: </p>
<pre><code>from inspect import getmembers


class Foo:
    def __init__(self, x):
        self.x = x
        self.y = 1
        self.z = 'chicken'


members = getmembers(Foo)

for member in members:
    if '__init__' in member:
        print(member[1].__code__.co_names)
</code></pre>
<p>Your output will be a tuple: </p>
<pre><code>('x', 'y', 'z')
</code></pre>
<p>Ultimately, as you inspect the class <code>Foo</code> to get its members, there are attributes you can further investigate as you iterate each member. Each member has attributes to further <em>inspect</em>, and so on. For this particular example, we focus on <code>__init__</code> and <em>inspect</em> the <code>__code__</code> (per documentation: The <code>__code__</code> object representing the compiled function body) attribute which has an attribute called <code>co_names</code> which provides a tuple of members as indicated above with the output of running the code.</p>
</div>
<div class="post-text" itemprop="text">
<p>As Lærne mentioned, attributes declared inside of functions (like <code>__init__</code>), are dynamic. They effectively <em>don't exist</em> until the <code>__init__</code> function is called.</p>
<p>However, there is a way to do what you want.</p>
<p>You can create <em>class</em> attributes, like so:</p>
<pre><code>class Foo:
    bar = None
    barbar = None

    def __init__(self, bar, barbar):
        self.bar = bar
        self.barbar = barbar
</code></pre>
<p>And you can access those attributes like this:</p>
<pre><code>[var for var in vars(Foo).keys() if not var.startswith('__')]
</code></pre>
<p>Which gives this result:</p>
<pre><code>['bar', 'barbar']
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/30128924/is-there-any-way-to-get-class-instance-attributes-without-creating-class-instanc">Is there any way to get class instance attributes without creating class instance?</a></span>
<span class="comment-copy"><code>Foo.__init__.__code__.co_varnames</code></span>
<span class="comment-copy">@AvihooMamka Won't that only give you the arguments passed to the methods? What if you created a dynamic attribute in the <code>__init__</code> that did not depend on an argument passed to the <code>__init__</code>?</span>
<span class="comment-copy">@idjaw correct, it won't work in your case.</span>
<span class="comment-copy">The attributes of class instances are dynamic and can change through time—so <b>no</b>, you can't.</span>
<span class="comment-copy">You may want to consider that classes with <code>__slots__</code> may be an exception here.</span>
<span class="comment-copy">Your code is checking for <b>class</b> attributes, not <b>instance</b> attributes.</span>
<span class="comment-copy">@martineau That is mentioned in the answer (and the question). This would be a way for the OP to accomplish what they want to do.</span>
<span class="comment-copy">Although the title says "attributes of a class", the OP's code only shows two instance attributes being created in <code>__init__()</code> and then asks if there's a way to determine them without instantiating an object—so I believe you've misunderstood the question.</span>
<span class="comment-copy">@martineau And I clearly state that cannot be done in the first paragraph of my answer. Then, I propose an alternative. There is no misunderstanding in play.</span>
<span class="comment-copy">OK, but your code <b><i>isn't</i></b> doing what they want, it's listing class attributes with names that just happen to coincide with those given to instance attributes created in one of the methods. Sounds like a fragile solution, at best, since the source of the information is wrong.</span>
