<div class="post-text" itemprop="text">
<p>I am writing a database program and personica is my test subject (I would usually have a variable in the place of the file path, but for test and demo purposes I just have a string.). There is a text file at this exact location on my computer (I have changed my username on here, by the way because I am paranoid.), but it says:</p>
<pre><code>Traceback (most recent call last):
File "C:\Users\Admin\Documents\Project 
Documentation\InteractiveExecutable.py", line 46, in &lt;module&gt;
ReadPerson = open("C:/Users/Admin/Documents/Project 
Documentation/personica.txt", 'r')
IOError: [Errno 2] No such file or directory:
'C:/Users/Admin/Documents/Project Documentation/personica.txt'
</code></pre>
<p>This is the line of code:</p>
<pre><code>ReadPerson = open("C:/Users/Admin/Documents/Project Documentation/personica.txt", 'r')
</code></pre>
<p>I am certain that it is there and when I copy that address into Windows Explorer, it takes me right to the text file.</p>
<p>Anyone know why this is not working?</p>
</div>
<div class="post-text" itemprop="text">
<p>The new-ish <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib</code> module</a> (available in Python &gt;= 3.4) is great for working with path-like objects (both Windows and for other OSes). </p>
<h2><a href="https://xkcd.com/1416/" rel="nofollow noreferrer">It's Paths - Paths all the way down</a></h2>
<p>To simplify: you can build up any path (directory and file path objects are treated exactly the same) as an object, which can be an <em>absolute path object</em> or a <em>relative path object</em>. You can use raw strings to make complex paths (i.e., <code>r'string'</code>) and <code>pathlib</code> will be very forgiving. However, note that there are better ways to build up paths than raw strings (see further down). </p>
<p>Here are examples:</p>
<pre><code>from pathlib import Path

Path(r'c:\temp\foo.bar') # absolute path
Path(r'c:/temp/foo.bar') # same absolute path
Path('foo.bar') # different path, RELATIVE to current directory
Path('foo.bar').resolve() # resolve converts to absolute path
Path('foo.bar').exists() # check to see if path exists
</code></pre>
<p>Note that if you're on Windows <code>pathlib</code> forgives you for using the "wrong slash" in the second example. See discussion at the end about why you should probably <em>always</em> use the forward slash. </p>
<p>Simple displaying of some useful paths- such as the current working directory and the user home- works like this: </p>
<pre><code># Current directory (relative):
cwd = Path() # or Path('.')
print(cwd)

# Current directory (absolute):
cwd = Path.cwd()
print(cwd)

# User home directory:
home = Path.home()
print(home)

# Something inside the current directory
file_path = Path('some_file.txt') # relative path; or 
file_path = Path()/'some_file.txt' # also relative path
file_path = Path().resolve()/Path('some_file.txt') # absolute path
print(file_path)
</code></pre>
<p>To navigate down the file tree, you can do things like this. Note that the first object, <code>home</code>, is a <code>Path</code> and the rest are just strings: </p>
<pre><code>some_person = home/'Documents'/'Project Documentation'/'personica.txt' # or
some_person = home.join('Documents','Project Documentation','personica.txt')
</code></pre>
<p>To read a file located at a path, you can use its <code>open</code> method rather than the <code>open</code> function: </p>
<pre><code>with some_person.open() as f:
    dostuff(f)
</code></pre>
<p>But you can also just grab the text directly! </p>
<pre><code>contents = some_person.read_text()
content_lines = contents.split('\n')
</code></pre>
<p>...and WRITE text directly!</p>
<pre><code>data = '\n'.join(content_lines)
some_person.write_text(data) # overwrites existing file
</code></pre>
<p>Check to see if it is a file or a directory (and exists) this way: </p>
<pre><code>some_person.is_dir()
some_person.is_file()
</code></pre>
<p>Make a new, empty file without opening it like this (silently replaces any existing file): </p>
<pre><code>some_person.touch()
</code></pre>
<p>To make the file <em>only if it doesn't exist</em>, use <code>exist_ok=False</code>:</p>
<pre><code>try:
    some_person.touch(exist_ok=False)
except FileExistsError:
    # file exists
</code></pre>
<p>Make a new directory (under the current directory, <code>Path()</code>) like this: </p>
<pre><code>Path().mkdir('new/dir') # get errors if Path()/`new` doesn't exist
Path().mkdir('new/dir', parents=True) # will make Path()/`new` if it doesn't exist
Path().mkdir('new/dir', exist_ok=True) # errors ignored if `dir` already exists
</code></pre>
<p>Get the file extension or filename of a path this way:</p>
<pre><code>some_person.suffix # empty string if no extension
some_person.stem # note: works on directories too
</code></pre>
<p>Use <code>name</code> for the entire last part of the path (stem and extension if they are there):</p>
<pre><code>some_person.name # note: works on directories too
</code></pre>
<p>Rename a file using the <code>with_name</code> method (which returns the same path object but with a new filename):</p>
<pre><code>new_person = some_person.with_name('personica_new.txt')
</code></pre>
<p>You can iterate through all the "stuff' in a directory like so using <code>iterdir</code>: </p>
<pre><code>all_the_things = list(Path().iterdir()) # returns a list of Path objects
</code></pre>
<h2>Sidebar: backslashes (<code>\</code>)</h2>
<p>Be careful when using backslashes in a path string, especially <em>ending</em> a path with a backslash. As with <strong>any</strong> string, Python will read that <em>terminating backslash</em> as an escape character <em>even in raw input mode</em>. Observe:</p>
<pre><code>&gt;&gt;&gt; r'\'
  File "&lt;stdin&gt;", line 1
    r'\'
       ^
SyntaxError: EOL while scanning string literal
</code></pre>
<p>So this will give a pretty cryptic error message if you are not aware of this issue: </p>
<pre><code>&gt;&gt;&gt; Path(r'C:\')
  File "&lt;stdin&gt;", line 1
    Path(r'\')
             ^
SyntaxError: EOL while scanning string literal
</code></pre>
<p>The reason for this error is that <code>\'</code> is assumed to be a single quotation <em>in the string</em>. This works fine: <code>'\''</code> (the second single quotation ends the string).</p>
<p>If you insist on using backslashes, be sure to use raw input mode or you will run into problems. For example, the <code>'\t'</code> character represents a tab. So when you do this (without raw input): </p>
<pre><code>&gt;&gt;&gt; Path('C:\temp')
</code></pre>
<p>You are putting a tab character into your path. This is perfectly legal and Python won't complain until you do something that causes Windows to try turning it into a real Windows path: </p>
<pre><code>&gt;&gt;&gt; Path('C:\temp').resolve()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
OSError: [WinError 123] The filename, directory name, or volume label syntax is incorrect: 'C:\temp'
</code></pre>
<p>This is also a very cryptic error if you do not know what is going on! Best to avoid the backslash characters altogether when messing about with paths. </p>
<h2>Preventing Your Problem</h2>
<p>Your problem occurred when you created your file and erroneously added a double extension. To prevent this issue using <code>pathlib</code>, use the <code>touch</code> method to make the file:</p>
<pre><code>some_person = Path.home()/'Documents'/'Project Documentation'/'personica.txt'
some_person.touch()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>On Windows, I like to use Python's raw string format for file paths:</p>
<pre><code>path = r'C:/Users/Admin/Documents/Project Documentation/personica.txt'
</code></pre>
<p>Note the <code>r</code> at the beginning of the string. Also note that the forward slash can be important as well.</p>
<p>Then I can just do the regular Python <code>open()</code> command:</p>
<pre><code>with open(path) as fobj:
    for line in fobj:
        print line
</code></pre>
<p>See the String Literals section in Python's lexical analysis document:</p>
<ul>
<li><a href="https://docs.python.org/2/reference/lexical_analysis.html#string-literals" rel="nofollow noreferrer">https://docs.python.org/2/reference/lexical_analysis.html#string-literals</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Ok, I fixed it. When I named the file, it was called personica.txt, as well as being a text file. So it's full name was personica.txt.txt. When I changed the name, it worked fine. Thanks to everyone for their help and input, I learnt from it even it it did not contribute to the solution.</p>
</div>
<span class="comment-copy">Shouldn't you be using backslashes <code>\\\\\\\\\\\\\\\\</code>?</span>
<span class="comment-copy">OTOH, since your text file is in the same directory as your script, <code>open('personica.txt')</code> does the trick.</span>
<span class="comment-copy">@MosesKoledoye Windows typically accepts either.</span>
<span class="comment-copy">@RickTeachey <code>pathlib</code> magically corrects typos?</span>
<span class="comment-copy">Are you sure there are no non-English symbols in file's name or <code>Project Documentation</code>? What happens if you try opening a completely different file in a different place? What if you rename the file you already have? What if you move it to a different directory (e.g. one level up)?</span>
<span class="comment-copy">Worth noting that naively using backslashes (as most Windows users will do) and raw strings can still be a recipe for pain, i.e., <code>r'C:\'</code>. The forward slash is important to mention.</span>
<span class="comment-copy">True enough. I rarely have had problems in raw strings with backslashes. If I don't use the raw string though, then I've had some pretty weird issues.</span>
