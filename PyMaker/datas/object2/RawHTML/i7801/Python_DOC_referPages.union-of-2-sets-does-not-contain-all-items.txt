<div class="post-text" itemprop="text">
<p>How come when I change the order of the two sets in the unions below, I get different results?</p>
<pre><code>set1 = {1, 2, 3}
set2 = {True, False}

print(set1 | set2)
# {False, 1, 2, 3}

print(set2 | set1)
#{False, True, 2, 3}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Why the union() doesn't contain all items</h1>
<p>The <code>1</code> and <code>True</code> are equivalent and considered to be duplicates.  Likewise the <code>0</code> and <code>False</code> are equivalent as well:</p>
<pre><code>&gt;&gt;&gt; 1 == True
True
&gt;&gt;&gt; 0 == False
True
</code></pre>
<h1>Which equivalent value is used</h1>
<p>When multiple equivalent values are encountered, sets keep the first one seen:</p>
<pre><code>&gt;&gt;&gt; {0, False}
{0}
&gt;&gt;&gt; {False, 0}
{False}
</code></pre>
<h1>Ways to make the values be distinct</h1>
<p>To get them to be treated as distinct, just store them in a <code>(value, type)</code> pair:</p>
<pre><code>&gt;&gt;&gt; set1 = {(1, int), (2, int), (3, int)}
&gt;&gt;&gt; set2 = {(True, bool), (False, bool)}
&gt;&gt;&gt; set1 | set2
{(3, &lt;class 'int'&gt;), (1, &lt;class 'int'&gt;), (2, &lt;class 'int'&gt;),
 (True, &lt;class 'bool'&gt;), (False, &lt;class 'bool'&gt;)}
&gt;&gt;&gt; set1 &amp; set2
set()
</code></pre>
<p>Another way to make the values distinct is to store them as strings:</p>
<pre><code>&gt;&gt;&gt; set1 = {'1', '2', '3'}
&gt;&gt;&gt; set2 = {'True', 'False'}
&gt;&gt;&gt; set1 | set2
{'2', '3', 'False', 'True', '1'}
&gt;&gt;&gt; set1 &amp; set2
set()
</code></pre>
<p>Hope this clears up the mystery and shows the way forward :-)</p>
<hr/>
<p>Rescued from the comments:</p>
<p>This is the standard technique for breaking cross-type equivalence (i.e. <code>0.0 == 0</code>, <code>True == 1</code>, and <code>Decimal(8.5) == 8.5)</code>. The technique is used in Python 2.7's regular expression module to force unicode regexes to be cached distinctly from otherwise equivalent str regexes. The technique is also used in Python 3 for functools.lru_cache() when the typed parameter is true.</p>
<p>If the OP needs something other than the default equivalence relation, then some new relation needs to be defined. Depending the use case, that could be case-insensitivity for strings, normalization for unicode, visual appearance (things that look different are considered different), identity (no two distinct objects are considered equal), a value/type pair, or some other function that defines an equivalence relation. Given the OPs specific example, it would seem that he/she expected either distinction by type or visual distinction. </p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, <code>False</code> and <code>0</code> are considered equivalent, as are <code>True</code> and <code>1</code>. Because <code>True</code> and <code>1</code> are considered the same value, only one of them can be present in a set a the same time. Which one depends on the order they are added to the set in. In the first line, <code>set1</code> is used as the first set, so we get <code>1</code> in the resulting set. In the second set, <code>True</code> is in the first set, so <code>True</code> is included in the result.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you look at <a href="https://docs.python.org/3/library/stdtypes.html#boolean-values" rel="noreferrer">https://docs.python.org/3/library/stdtypes.html#boolean-values</a> section 4.12.10. Boolean Values:</p>
<blockquote>
<p>Boolean values are the two constant objects <strong>False and True</strong>. They are used to represent truth values (although other values can also be considered false or true). In numeric contexts (for example when used as the argument to an arithmetic operator), they behave like the <strong>integers 0 and 1</strong>, respectively.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The comparison operator (<code>==</code>, <code>!=</code>) is defined for boolean <code>True</code> and <code>False</code> to match 1 and 0.</p>
<p>That's why, in the set union, when it checks whether <code>True</code> is in the new set already, it gets a truthy answer:</p>
<pre><code>&gt;&gt;&gt; True in {1}
True
&gt;&gt;&gt; 1 in {True}
True
</code></pre>
</div>
