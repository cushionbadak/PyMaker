<div class="post-text" itemprop="text">
<p>In Python I can implement a loop with step counter and a stop condition as a classical case of <strong>for loop</strong> :</p>
<pre><code>for i in range(50):
    result = fun(i)
    print(i, result)
    if result == 0: 
        break
</code></pre>
<p>where <code>fun(x)</code> is some arbitrary function from integers to integers. </p>
<p>I always in doubts if that is the best way to code it (<strong>Pythonically</strong>, and in terms of <strong>readability</strong> and <strong>efficiency</strong>) or is it better to run it as a <strong>while loop</strong>:</p>
<pre><code>i = 0
result = 1
while result != 0 and i &lt; 50:
    result = fun(i)
    print(i, result)
    i += 1
</code></pre>
<p>which approach is better? In particular - I'm concerned about the usage of <code>break</code> statement which doesn't feel right.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>for</code> loop is slightly more performant than the <code>while</code> because <a href="https://stackoverflow.com/a/869295/6260170"><code>range()</code> is implemented in C</a>, meanwhile the <code>+=</code> operation is interpreted and requires <a href="https://stackoverflow.com/a/869347/6260170">more operations</a> and object creation/ destruction. You can illustrate the performance difference using the <a href="https://docs.python.org/3/library/timeit.html" rel="noreferrer"><code>timeit</code> module</a>, for example:</p>
<pre><code>from timeit import timeit

def for_func():
    for i in range(10000):
        result = int(i)
        if result == -1: 
            break

def while_func():
    i = 0
    result = 1
    while result != -1 and i &lt; 10000:
        result = int(i)
        i += 1


print(timeit(lambda: for_func(), number = 1000))
# 1.03937101364
print(timeit(lambda: while_func(), number = 1000))
# 1.21670079231 
</code></pre>
<p>The <code>for</code> loop is arguably <a href="https://stackoverflow.com/a/920692/6260170">more Pythonic in the vast majority of cases when you wish to iterate over an iterable object</a>. Furthermore, to quote the <a href="https://wiki.python.org/moin/WhileLoop" rel="noreferrer">Python wiki</a>: "As the for loop in Python is so powerful, while is rarely used except in cases where a user's input is required". There is nothing un-Pythonic about using a <code>break</code> statement <em>per se</em>.</p>
<p>Readability is mostly subjective, I would say the <code>for</code> loop is more readable too, but it probably depends on your previous programming background and experience.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a minute difference in performance. As the while loop performs an extra boolean check at every iteration, it is slightly slower. </p>
<p>However, for most functions you would like to assess, there is an alternative to using a loop in the first place, which is way faster. See example attached below. And I am certain there are more optimal implementations..</p>
<pre><code>import time

def fun(step):
    return step == 50000000

t1 = time.time()
for i in range(500000000):
    result = fun(i)
#    print(i, result)
    if result == 1: 
        break
print("time elapsed", time.time() - t1)

t2 = time.time()
i = 0
result = 0
while result != 1 and i &lt; 50000000:
    result = fun(i)
#    print(i, result)
    i += 1

print("and here", time.time() - t2)

import numpy as np

t3 = time.time()

foo = np.arange(500000000)
i = np.where(foo == 50000000)
print("Alternative", time.time()-t3)
</code></pre>
<blockquote>
<blockquote>
<p>time elapsed 11.082087516784668</p>
<p>and here 14.429940938949585</p>
<p>Alternative 1.4022133350372314</p>
</blockquote>
</blockquote>
<p>If you want to/have to use a loop however, the for-loop is in general the more Pythonic way to go, as is explained <a href="https://stackoverflow.com/a/920692/5212031">in this nice answer to a related question</a></p>
<p>EDIT: Chris Rands's answer below explains it from the C-code point of view, and uses a more accurate (although on such macro-levels as I forced this example to be, that would not really matter) timing module. Do read his answer as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>best way would be not to loop explicitly at all. itertools for the rescue:</p>
<pre><code>from itertools import takewhile
it = ((x, f(x)) for x in range(50)) # first you define the resulting view
it = takewhile(lambda y: y[1] != 0, it) # define when to stop iterating
list(map(print, it)) # if you want to print it
</code></pre>
<p>+ it would be a lot a lot faster than looping</p>
</div>
<div class="post-text" itemprop="text">
<p>Looking purely at the bytecode, While-loop got 30 lines and the for-loop got 26 lines.</p>
<p>In the end, don't really think it matters that much but I personally prefer the for-loop version as it's easier to read.</p>
<p><a href="http://mergely.com/9P1cfnTr/" rel="nofollow noreferrer">http://mergely.com/9P1cfnTr/</a> </p>
<p>Code I used:</p>
<pre><code>def fun(i):
    i = i + 1
    return i

def test1():
    i = 0
    result = 1
    while result != 0 and i &lt; 50:
        result = fun(i)
        print(i, result)
        i += 1

def test2():
    for i in range(50):
        result = fun(i)
        print(i, result)
        if result == 0: 
            break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Taking the functional approach, create a local closure that performs the action and returns the termination predicate's value. Then iterate over the inputs until done.</p>
<pre><code>def action(i):
    result = fun(i)
    print(i, result)
    return result == 0

list(itertools.takewhile(action, range(50)))  # non-pythonic wasted list
</code></pre>
<p>Another way of terminating a sequence of actions is:</p>
<pre><code>terminated = reduce(lambda done, i: done or action(i), range(50), False)  # extra unnecessary iterations
</code></pre>
<p>Looks like we are back to the <code>break</code> statement for pythonicness</p>
<pre><code>for i in range(50):
    if action(i):
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm pretty sure you should not care about performance when you are comparing <strong>while</strong> and <strong>for</strong> loops, so the main question is about readability.</p>
<p>first of all, of course </p>
<pre><code>for i in range(50):
    result = fun(i)
    print(i, result)
    if result == 0: 
        break
</code></pre>
<p>is much better than</p>
<pre><code>i = 0
result = 1
while result != 0 and i &lt; 50:
    result = fun(i)
    print(i, result)
    i += 1
</code></pre>
<p>because you don't need to keep some C-like variables in mind when you are reading simple loop</p>
<p>@quidkid's solution is pretty elegant, but it is a good point that </p>
<pre><code>it = takewhile(lambda y: y[1] != 0, ((x, f(x)) for x in range(50)))
</code></pre>
<p>works only on quite simple examples and will lost readability as you will require to add some additional functionality</p>
<p>As i can see, the main problem in your code is that your function is not pure, so maybe you should do something like this:</p>
<pre><code>def some_generator():
    for i in range(50):
        result = fun(i)
        yield result, i
        if result == 0:
            return 

for x in some_generator():
    print x
    do_something_else_with(x[1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If efficiency is what you are looking for then use generator functions</p>
<pre><code>In [1]: def get_result():                            
    ...:     for i in xrange(50):                            
    ...:         result = fun(i)
    ...:         yield result, i
    ...:         if result == 0:
    ...:             break
    ...:         

In [2]: generator_func = get_result()

In [3]: for result, i in generator_func:
    ...:     print result, i
    ...:   
</code></pre>
<p>The result of %timeit in ipython</p>
<blockquote>
<p>The slowest run took 6.15 times longer than the fastest. This could
  mean that an intermediate result is being cached. 10000 loops, best of
  3: 30.9 µs per loop</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You  do NOT need the break statement at all... for loops will terminate automatically. All you need is:</p>
<pre><code>for i in range(50):
    result = fun(i)
    print(i, result)
</code></pre>
<p>This, will always be more readable imho.</p>
</div>
<span class="comment-copy">In For loop if  you modify the control variable it has no effect but While loop.</span>
<span class="comment-copy">That's right, but I'm not aiming to do so</span>
<span class="comment-copy">They are both fine. The for-loop places emphasis on the items in the iterable and the while-loop places the emphasis on the break condition. It is up to the author of the code to decide which aspect is most essential for communicating the meaning of the code. If neither prevail, use the for-loop because it is more commonly used in Python.</span>
<span class="comment-copy">The <code>for</code> loop should be more efficient (by a small margin) and there's nothing wrong with breaking out of loops if an inner condition is met. Anyhow, this is a matter of personal preference so you won't get the 'right answer' - only opinions.</span>
<span class="comment-copy">It should also be noted that <code>for loops</code> are faster than <code>while loops</code>.  Python for loops are implemented in C. While loops are implemented with Python.   <a href="https://stackoverflow.com/questions/869229/why-is-looping-over-range-in-python-faster-than-using-a-while-loop" title="why is looping over range in python faster than using a while loop">stackoverflow.com/questions/869229/…</a></span>
<span class="comment-copy">While updating my answer, I see that you linked to the same topic. As your answer is more insightful in terms of underlying code; you have my upvote.</span>
<span class="comment-copy">Thanks! Great explanation</span>
<span class="comment-copy">@Dimgold you're welcome, glad I could help!</span>
<span class="comment-copy">Sounds weird, I was sure that <code>for</code> is implemented with <code>while</code>.</span>
<span class="comment-copy">You are right that a for-loop internally uses a while loop. But "while True", is 1 identity check versus a more expensive Boolean  (statement 1 AND statement 2) check.</span>
<span class="comment-copy">@Dimgold if you are thinking that the <code>for</code> loop you have written is internally doing <code>i += 1</code> like a C for loop, it's not. try something like <code>for i in range(10): print(i) i+=1</code>, does the output surprise you?</span>
<span class="comment-copy">@RyanHaining, sure, that not surprising. But let's say it was <code>xrange()</code> - would it be better then?</span>
<span class="comment-copy">@Dimgold it's the same output either way, for the same reason. I was assuming this was python3 based on your original code where <code>range</code> does what <code>xrange</code> did in python2</span>
<span class="comment-copy">Don't you enumerate the whole options at the second row? It is quite simple in this toy example but i'm not sure that it is useful when on each iteration there are numerous actions ( maybe even sequential) to be done</span>
<span class="comment-copy">nope. This 2nd and 3rd line are generators, they are run only on 4th line when list comes in.</span>
<span class="comment-copy">If they want a list, this is fine, but it is not pythonic to use a structure like this for procedural calls like <code>print()</code> because you needlessly create a list of <code>None</code> values, see <a href="https://stackoverflow.com/questions/5753597/is-it-pythonic-to-use-list-comprehensions-for-just-side-effects" title="is it pythonic to use list comprehensions for just side effects">stackoverflow.com/questions/5753597/…</a></span>
<span class="comment-copy">The number of line <i>per se</i> does not matter, it is the line that <b>jump back</b> to the loop that matter at the end. So you cannot make any assumption by only the number of lines.</span>
