<div class="post-text" itemprop="text">
<p>I am trying to implement QM coding for educational purposes. My main resource is chapter 5.11 from Handbook of Data Compression, 5th edition. This is my rough implementation of encoder for now:</p>
<pre class="lang-py prettyprint-override"><code>def _encode_bit(self, bit):
    if bit == self._lps:
        self._code_lps()
    else:
        self._code_mps()

def _code_mps(self):
    self._a = self._a - self._q_e()
    if self._a &lt; 0x8000:
        self._switch_intervals_if_needed()
        self._renormalize()
        self._p_table.next_mps()

def _code_lps(self):
    self._c = self._c + self._a - self._q_e()
    self._a = self._q_e()
    self._switch_intervals_if_needed()
    self._renormalize()
    self._p_table.next_lps()

def _renormalize(self):
    while self._a &lt; 0x8000:
        #C &lt; 0,5 (0xFFFF / 3)
        if self._c &lt; 0x5555:
            b = 0
            d = 0
        else:
            b = 1
            d = 0x5555
        self._write_bit(b)
        logger.debug("Written '%i' to output", b)
        #C = 2 * (C - D)
        self._c = (self._c - d) &lt;&lt; 1
        #A = 2 * A
        self._a &lt;&lt;= 1
</code></pre>
<p>I am mapping the interval to integers, since it should be more efficient as I understand. In the book, there is mentioned, that 16 bit word is used for mapping, but since I am doing this in Python I am not sure whether not enforce the 16 bit length of all variables. The problem is that when I run my encoder, the <code>C</code> (<code>self._c</code> in code), which should point to the bottom of MPS interval if I understand it correctly overflows over 16 bit length very quickly, and its value becomes very large. Because of this, the encoded bits is mostly just a string of LPS symbols. Should I enforce the variable length somehow? Or is there other problem in my code? I have spent several days on it already trying to figure out what went wrong...</p>
</div>
<div class="post-text" itemprop="text">
<p>In any form of arithmetic compression (like QM), one needs to stay within the maximum allowed bits (16 in this case), otherwise you will have all kinds of problems.  These problems include roundoff errors because in theory you may need infinite precision.  The algorithm itself will round off when necessary and perform a renormalization to maximize use of the bit range.  The answer to your question is "Yes".</p>
</div>
<span class="comment-copy">I'm not familiar with the QM-coder, but I suspect there's a problem with your <code>renormalize</code> method. It would help if you could include pseudo-code for the <i>exact</i> algorithm you're using.</span>
<span class="comment-copy">Thanks for the comment! Well, that's a part I didn't understand completely and it comes from my teacher's materials, who used same source. After I read the chapter in Handbook of Data Compression i still didn't understand, how output is formed, so I took over this piece from him. From the book I understood, that renormalization takes place because i want to keep A (<code>self._a</code> in code) close to 1, so I can omit more complex multiplication while encoding. Original code can be seen at slide 63 in <a href="http://outrata.inf.upol.cz/courses/kd/komprese.pdf" rel="nofollow noreferrer">teacher's presentation</a></span>
<span class="comment-copy">to use a 16 bit word, the <code>ctypes</code> module could be used: <a href="https://docs.python.org/3/library/ctypes.html#ctypes.c_int16" rel="nofollow noreferrer">docs.python.org/3/library/ctypes.html#ctypes.c_int16</a></span>
<span class="comment-copy">Thank you very much! This answer, although didn't make my code working, pushed me forward to making it work. Now the output looks more reasonable, but the encoding/decoding process won't return original input, so I have to investigate little bit further, since there is probably another bug.</span>
<span class="comment-copy">Look at chapter 2.16 of <a href="https://books.google.co.in/books?id=ujnQogzx_2EC&amp;pg=PA129&amp;lpg=PA129&amp;dq=arithmetic+compression+qm&amp;source=bl&amp;ots=FpqBpD3wrT&amp;sig=Z81N-n0MTIJV_YNDwcWKWlDds-o&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwirwb3RitTUAhWHNI8KHegkCOUQ6AEIQTAF#v=onepage&amp;q=arithmetic%20compression%20qm&amp;f=false" rel="nofollow noreferrer">books.google.co.in/â€¦</a> .  Nice description of the algorithm.  Funny, JPEG uses QM compression.</span>
<span class="comment-copy">Thanks! Actually, the chapter 2.16 from Data Compression: The Complete Reference, 4th edition is same as the chapter 5.11 from Handbook of Data Compression, 5th edition by the same author -- David Solomon. The principals of algoritm itself are described quite nicely there, but as I said the details are not - I did not understand how output is formed after I read it or how decoder reads bits...</span>
<span class="comment-copy">OK with you if I take a stab at implementing it?  I'll probably go for Java if so.</span>
