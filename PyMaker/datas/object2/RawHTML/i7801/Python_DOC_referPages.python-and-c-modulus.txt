<div class="post-text" itemprop="text">
<p>I am learning c++ and in trying to code a little program i found something strange. It is about modulus :
c++ code </p>
<pre><code>cout &lt;&lt; -325 - (-325 % 100) &lt;&lt; endl;
// -300 
cout &lt;&lt; 325 - (325 % 100);
// 300 
</code></pre>
<p>and python code</p>
<pre><code>print(-325 - (-325 % 100))
# -400 
print(325 - (325 % 100))
# 300
</code></pre>
<p>Can someone explain me that pls ? Thq </p>
</div>
<div class="post-text" itemprop="text">
<p>This is a bit out of my expertise but its likely python follows the <a href="https://en.wikipedia.org/wiki/Modulo_operation" rel="nofollow noreferrer">Donald Knuth</a> remainder calculation which is: <code>a + b*[a/b]</code> being <code>[]</code> the <a href="https://docs.python.org/3.6/library/math.html#math.floor" rel="nofollow noreferrer">floor</a> operation. As so:</p>
<pre><code>a = -325
b = 100
print(a - b*math.floor(a/b))
print(math.floor(-3.25))
print(-325 -(a - b*math.floor(a/b)))
</code></pre>
<p>results in:</p>
<pre><code>75
-4
-400
</code></pre>
<p>I'm a bit surprised C++ does not return the same (but I'm also not knowledgeable enough about the subject). </p>
<p><strong>EDIT:</strong> Made a quick search for this topic and <a href="http://www.learncpp.com/cpp-tutorial/32-arithmetic-operators/" rel="nofollow noreferrer">learncpp</a> mentions the reason why C++, specifically C++ 11, standardized the floor operation always towards 0. I quote:</p>
<blockquote>
<p>Prior to C++11, if either of the operands of integer division are
  negative, the compiler is free to round up or down! For example, -5 /
  2 can evaluate to either -3 or -2, depending on which way the compiler
  rounds. However, most modern compilers truncate towards 0 (so -5 / 2
  would equal -2). The C++11 specification changed this to explicitly
  define that integer division should always truncate towards 0 (or put
  more simply, the fractional component is dropped).</p>
<p>Also prior to C++11, if either operand of the modulus operator is
  negative, the results of the modulus can be either negative or
  positive! For example, -5 % 2 can evaluate to either 1 or -1. <strong>The
  C++11 specification tightens this up so that a % b always resolves to
  the sign of a.</strong></p>
</blockquote>
<p>Regarding Python you can take a look at the documentation for <a href="https://docs.python.org/3.6/library/functions.html#divmod" rel="nofollow noreferrer">divmod</a> which states:</p>
<blockquote>
<p>Take two (non complex) numbers as arguments and return a pair of
  numbers consisting of their quotient and remainder when using integer
  division. With mixed operand types, the rules for binary arithmetic
  operators apply. For integers, the result is the same as (a // b, a %
  b). For floating point numbers the result is (q, a % b), where q is
  usually math.floor(a / b) but may be 1 less than that. In any case q *
  b + a % b is very close to a, <strong>if a % b is non-zero it has the same
  sign as b</strong>, and 0 &lt;= abs(a % b) &lt; abs(b)</p>
</blockquote>
<p><strong>EDIT2:</strong> Even more information on the <a href="https://docs.python.org/3/faq/programming.html#why-does-22-10-return-3" rel="nofollow noreferrer">Python Programming FAQ</a> regarding this subject.</p>
<blockquote>
<p><strong>Why does -22 // 10 return -3?</strong> </p>
<p>It’s primarily driven by the desire that
  <code>i % j</code> have the same sign as <code>j</code>. If you want that, and also want:</p>
<p><code>i == (i // j) * j + (i % j)</code></p>
<p>then integer division has to return the
  floor. C also requires that identity to hold, and then compilers that
  truncate <code>i // j</code> need to make <code>i % j</code> have the same sign as <code>i</code>.</p>
<p>There are few real use cases for <code>i % j</code> when <code>j</code> is negative. When <code>j</code> is
  positive, there are many, and in virtually all of them it’s more
  useful for <code>i % j</code> to be <code>&gt;= 0</code>. If the clock says 10 now, what did it say
  200 hours ago? <code>-190 % 12 == 2</code> is useful; <code>-190 % 12 == -10</code> is a bug
  waiting to bite.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>It looks phyton doesn't accept negative modulus results, so adds 100 to -25.</p>
<blockquote>
<p>print(-325 - (-325 % 100))</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I don't really know much about it, but since you are learning C++,i would like to tell you something from my personal experience, that if you are making a program in C++ and you're using modulus operator, and you want +ve mod always, you should do something like this - </p>
<pre><code>a = b%m;
if(a&lt;0) a += m;
</code></pre>
<p>I am not so sure on when and why, but a can take a negative value for <strong>any</strong> b and m (not only when b is -ve)</p>
</div>
<span class="comment-copy"><a href="http://en.cppreference.com/w/cpp/language/operator_arithmetic#Multiplicative_operators" rel="nofollow noreferrer">This multiplicative operator reference</a> might help you understand what happens in C++. I suggest you try e.g. <code>-325 % 100</code> <i>separately</i> to see what it does. Pay close attention to the notes at the end of the section.</span>
<span class="comment-copy">Different languages interpret the % operator differently. <a href="https://en.wikipedia.org/wiki/Modulo_operation" rel="nofollow noreferrer">en.wikipedia.org/wiki/Modulo_operation</a></span>
<span class="comment-copy">It gives the same result.</span>
<span class="comment-copy">@verbalki Yeah, I found out why. I'll edit the answer.</span>
<span class="comment-copy">In Python, <code>a % b</code> always has the same sign as <code>b</code>.</span>
