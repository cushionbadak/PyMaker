<div class="post-text" itemprop="text">
<p>I'm trying to perform <code>sqlite3_exec</code> from python to extract line by line the contents of a database. According to the <a href="http://www.sqlite.org/c3ref/exec.html" rel="nofollow noreferrer">C API</a>, I need a Callback function which will perform the iteration. I have coded the following with a lot of help from internet:</p>
<p><strong>UPDATED with @eryksun pi√®ces of advice</strong></p>
<pre><code>import ctypes

def extractor(unused, num_columns, pcolumn, pcolumn_name):
    for column in range(0,num_columns):
        if pcolumn[i] != None:
            print pcolumn[i]

sqlite3DLL = ctypes.CDLL("C:\\Python\\PYTHON\\DLLs\\sqlite3.dll")
SQLITE_OPEN_READONLY = 1 
null_ptr = ctypes.c_void_p(None)
p_src_db = ctypes.c_void_p(None)

ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_void_p, ctypes.POINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_char_p))
callback_func = callback_type(extractor)

connect = sqlite3DLL.sqlite3_open_v2(DatabasePath, ctypes.byref(p_src_db), SQLITE_OPEN_READONLY, null_ptr)
connect = sqlite3DLL.sqlite3_exec(DatabasePath, "SELECT * FROM *", callback_func, None, null_ptr)
sqlite3DLL.sqlite3_close(DatabasePath)
</code></pre>
<p>Before moving on to the python callback function I have some doubts:</p>
<ol>
<li>Is <code>"SELECT * FROM *"</code> a possible <strong>SQL statement</strong> to avoid providing the name of a table (because I do not know it)?</li>
<li>Is the first argument of both functions <code>sqlite3_open_v2</code> and <code>sqlite3_exec</code> the path to the database?</li>
</ol>
<p>If all that is ok we can move on to the callback function. According to what I found on the net, the C callback function should be somewhat similar to:</p>
<pre><code>callback(void *NotUsed, int argc, char **argv, char **azColName)
    for (int i = 0; i &lt; argc; i++) {printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL")}
</code></pre>
<p>That is why I coded the <code>CFUNCTYPE</code> you see on my code. How can I code a python function which matches the callback needed to maybe fill a list with the database contents?</p>
<p>I have added the proposed changes on the code, the callback function just prints the value to verify the output. But It wont work I get an error:</p>
<pre><code>con = sqlite3DLL.sqlite3_exec(FastenerLibraryPath, "SELECT * FROM *", callback_func, None, null_ptr)
WindowsError: exception: access violation writing 0x0000000000000009
</code></pre>
<p>Many thanks in advance!</p>
<p><strong>FINAL WORKING EDITION (@eryksun comments and @MarkTolonen solution)</strong></p>
<pre><code>import ctypes

def extractor(unused, num_columns, pcolumn, pcolumn_name):
    print ','.join(["''" if x is None else "'"+x+"'" for x in pcolumn[:num_columns]])
    return 0

sqlite3DLL = ctypes.CDLL("C:\\Python\\PYTHON\\DLLs\\sqlite3.dll")
SQLITE_OPEN_READONLY = 1 
null_ptr = ctypes.c_void_p(None)
p_src_db = ctypes.c_void_p(None)

ctypes.CFUNCTYPE(ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.POINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_char_p))
callback_func = callback_type(extractor)

connect = sqlite3DLL.sqlite3_open_v2(DatabasePath, ctypes.byref(p_src_db), SQLITE_OPEN_READONLY, None)
connect = sqlite3DLL.sqlite3_exec(p_src_db, b"SELECT * FROM Pin", callback_func, None, None)
sqlite3DLL.sqlite3_close(p_src_db)
</code></pre>
<p>This is working, however, I will look into <code>argtypes</code> and the opaque type.</p>
<p>Thank you all!</p>
</div>
<div class="post-text" itemprop="text">
<p>Tested in Python 2.7 and Python 3.6 (if you change the DLL path) using the following database:</p>
<pre><code>create table tbl1(one varchar(10), two smallint);
insert into tbl1 values('hello',10);
insert into tbl1 values('goodbye',20);
</code></pre>
<p>Code:</p>
<pre><code># I know, bad form, but it makes the code easier to read for an example
from ctypes import *

# This was missing the 2nd c_int parameter.
CALLBACK = CFUNCTYPE(c_int, c_void_p, c_int, POINTER(c_char_p), POINTER(c_char_p))

@CALLBACK
def extractor(unused, num_columns, pcolumn, pcolumn_name):
    print(pcolumn[:num_columns])
    return 0 # needs to return 0 from callback or will abort.

sqlite3DLL = CDLL(r"C:\Python27\DLLs\sqlite3.dll")
SQLITE_OPEN_READONLY = 1 
p_src_db = c_void_p()

sqlite3DLL.sqlite3_open_v2(b'test.db', byref(p_src_db), SQLITE_OPEN_READONLY, None)
# pass the handle returned by above as first parameter below
sqlite3DLL.sqlite3_exec(p_src_db, b'SELECT * FROM tbl1', extractor, None, None)
sqlite3DLL.sqlite3_close(p_src_db)
</code></pre>
<p>Output:</p>
<pre><code>['hello', '10']
['goodbye', '20']
</code></pre>
<p>I also recommend setting <code>argtypes</code> because it helps catch type errors and for some parameter types (like c_double) it is required.</p>
<pre><code>sqlite3DLL.sqlite3_open_v2.argtypes = c_char_p, POINTER(c_void_p), c_int,c_char_p
sqlite3DLL.sqlite3_open_v2.restype = c_int

sqlite3DLL.sqlite3_exec.argtypes = c_void_p,c_char_p,CALLBACK,c_void_p,POINTER(c_char_p)
sqlite3DLL.sqlite3_open_v2.restype = c_int
</code></pre>
</div>
<span class="comment-copy">The <code>sqlite3_exec()</code> callback is hard to use even in C. Better use a <a href="http://stackoverflow.com/documentation/sqlite/5456/sqlite3-stmt-prepared-statement-c-api/">cursor</a>.</span>
<span class="comment-copy">The callback type should be <code>ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_void_p, ctypes.POINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_char_p))</code>. You can use it as a decorator for a Python function with the signature <code>(unused, num_columns, pcolumn, pcolumn_name)</code>. Iterate over <code>range(num_columns)</code>. If the ith column is empty, then <code>pcolumn[i]</code> should be <code>None</code>, so the equivalent of the C ternary is <code>pcolumn[i] if pcolumn[i] else b'NULL'</code>. For success, return 0. If the callback returns a non-zero value, <code>sqlite3_exec</code> returns <code>SQLITE_ABORT</code>.</span>
<span class="comment-copy">Or just use the Python-included <a href="https://docs.python.org/3/library/sqlite3.html" rel="nofollow noreferrer">sqlite3</a> library?</span>
<span class="comment-copy">@MarkTolonen, Chang is using sqlite3.dll from Python's installation directory and hopefully knows about the sqlite3 module. I assumed this was needed for something not implemented by the module or for educational purposes.</span>
<span class="comment-copy">Using <code>WinDLL</code> (stdcall) is wrong with sqlite3.dll. It should be <code>CDLL</code> (cdecl). You'll only see a problem in 32-bit Python. The cdecl and stdcall calling conventions are ignored in x64.</span>
<span class="comment-copy">You'll gain more type safety if you define an opaque <code>sqlite3</code> type and a <code>psqlite3</code> pointer type to use in <code>argtypes</code>. Using <code>c_void_p</code> for the connection handle is very permissive -- not that some APIs don't do this (e.g. Windows).</span>
