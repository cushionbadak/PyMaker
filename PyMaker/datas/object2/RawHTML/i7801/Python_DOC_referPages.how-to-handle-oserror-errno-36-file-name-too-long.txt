<div class="post-text" itemprop="text">
<p>When handling the errors that occur when trying to create an existing file or trying to use a file that doesn't exist the <code>OSError</code>s that get thrown have a subclass (<code>FileExistsError</code>, <code>FileNotFoundError</code>). I couldn't find that subclass for the special case when the filename is too long.</p>
<p>The exact error message is:</p>
<pre><code>OSError: [Errno 36] File name too long: 'filename'
</code></pre>
<p>I would like to catch the OSError that occurs when the filename is too long, but <em>only when</em> the filename is too long. I do <em>not</em> want to catch other <code>OSError</code>s that might occur. Is there a way to achieve this?</p>
<p><strong>Edit:</strong> I know that I could check the filename against a length but the maximum filename length varies too much depending on the OS and the filesystem and I don't see a "clean" solution that way.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simply check <code>errno</code> attribute of caught exception.</p>
<pre><code>try:
    do_something()
except OSError as exc:
    if exc.errno == 36:
        handle_filename_too_long()
    else:
        raise  # re-raise previously caught exception
</code></pre>
<p>For readability you may consider using appropriate constant from <a href="https://docs.python.org/3/library/errno.html" rel="nofollow noreferrer"><code>errno</code> built-in module</a> instead of hardcoded constant.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can specify just how you want to catch a specific error such as <a href="https://docs.python.org/2/library/errno.html#errno.ENAMETOOLONG" rel="nofollow noreferrer">errno.ENAMETOOLONG</a>:</p>
<p><strong>Specific to your question...</strong></p>
<pre><code>try:
    # try stuff
except OSError as oserr:
    if oserr.errno != errno.ENAMETOOLONG:
        # ignore
    else:
        # caught...now what?
</code></pre>
<p><strong>Specific to your comments...</strong></p>
<pre><code>try:
    # try stuff
except Exception as err:
    # get the name attribute from the exception class
    errname = type(err).__name__
    # get the errno attribute from the exception class
    errnum = err.errno
    if (errname == 'OSError') and (errnum == errno.ENAMETOOLONG):
        # handle specific to OSError [Errno 36]
    else if (errname == 'ExceptionNameHere' and ...:
        # handle specific to blah blah blah
    .
    .
    .
    else:
        raise # if you want to re-raise; otherwise code your ignore
</code></pre>
<p>This will grab all exceptions caused by errors in the <code>try</code>. Then it checks if the <code>__name__</code> matches any specific exception and any additional conditions you want to specify. </p>
<p>You should know there is no getting around the <code>except</code> if an error is encountered unless you specific a concrete exception.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/4677234/python-ioerror-exception-when-creating-a-long-file">Python IOError exception when creating a long file</a></span>
<span class="comment-copy">@NuclearPeon: No. That's windows specific and the answers there do not answer this question. I specified that in the question.</span>
<span class="comment-copy">You can try to get the max filename path, although there is no sure way to do this. Check this link out: <a href="https://code.activestate.com/lists/python-list/210662/" rel="nofollow noreferrer">code.activestate.com/lists/python-list/210662</a> - check the length of the filename and notify the user if it's too long. Otherwise a try/except is your best bet as already listed.</span>
<span class="comment-copy">I specifically asked how to catch the exact error. I don't want to check the length beforehand because of race conditions and because of inconsistencies of maximum filename lengths (as stated in the question).</span>
<span class="comment-copy">The only other way to narrow down OSError I've seen is to check the 3rd parameter when the exception is thrown. See doc here: <a href="https://docs.python.org/2/library/exceptions.html#exceptions.OSError" rel="nofollow noreferrer">docs.python.org/2/library/exceptions.html#exceptions.OSError</a> - relevant information: <code>For exceptions that involve a file system path (such as chdir() or unlink()), the exception instance will contain a third attribute, filename, which is the file name passed to the function.</code> You might have to come to the conclusion that Python doesn't have a sure way of doing what you want. File a bug.</span>
<span class="comment-copy">Great minds think alike and post together!</span>
<span class="comment-copy">But then I also catch the other <code>OSError</code>s that I <i>specifically</i> don't want to catch!</span>
<span class="comment-copy">@Max: The raise takes care of that. See the edit.</span>
<span class="comment-copy">But then I also catch the other <code>OSError</code>s that I <i>specifically</i> don't want to catch!</span>
<span class="comment-copy">@MaxMatti To "catch" and error you must "handle" it. The <code>if/else</code> sets the conditional that <code>if</code> the exceptions <code>errno</code> attribute is not equal to (<code>!=</code>), you write code to ignore it (however you choose to do so); <code>else</code> you've "caught" the right exception...now "handle" it.</span>
<span class="comment-copy">I do not want to ignore it! I want to <i>not</i> catch it. I stated that in my question: "I do <i>not</i> want to catch other <code>OSError</code>s that might occur. Is there a way to achieve this?"  If there's a way to let the previous error propagate further if <code>errno</code> is not equal to <code>errno.ENAMETOOLONG</code> please add that to your answer. But currently I don't see how you plan to achieve that.</span>
<span class="comment-copy">@MaxMatti Lets say you have two errors: E1 &amp; E2. In your <code>try/except</code> you only want to catch is E2 which is the error you are currently focused with. You know the type (<code>OSError</code>) but that is not how the <code>except</code> statement works. It is a <a href="https://docs.python.org/2/library/exceptions.html#exceptions.OSError" rel="nofollow noreferrer">built-in</a> and as such you have to refer to the <code>errno</code> module for its mapped error code. But what if the first error you got was E1? Because <code>OSError</code> is a built in, there is no <code>OSError.ENAMETOOLONG</code> to specify in the <code>except</code>. In both the answers posted, you can move along if not E2.</span>
<span class="comment-copy">@MaxMatti Just because you check if the <code>OSError</code> is the one you specifically want to deal with doesn't harm the code. Whatever is being executed in the <code>try</code> statement is subject to <code>except</code> if there is an error encountered. There is no <code>except OSError as oserr if oserr.errno == errno.ENAMETOOLONG</code>.</span>
