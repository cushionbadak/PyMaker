<div class="post-text" itemprop="text">
<p>I wanted to have a function that handled a dictionary, addressed like a dictionary or similar with little work, so that when called I could run other code.</p>
<p>I thought it seemed easier to subclass dict, so I have. From reading <code>help(dict)</code> I think I have covered all dictionary editing functions so that a callback is called too. Have I? Also are there any other like pop which return a value of the editing ones?</p>
<pre><code>class BindedDict(dict):
    """Custom dictionary with callback when edited."""

    def __init__(self, callback, *a, **kw):
        self.callback = callback
        super().__init__(*a, *kw)
        return

    def __delitem__(self, *a, **kw):
        super().__delitme__(*a, **kw)
        self.callback()
        return

    def __setitem__(self, *a, **kw):
        super().__setitem__(*a, **kw)
        self.callback()
        return

    def clear(self, *a, **kw):
        super().clear(*a, **kw)
        self.callback()
        return

    def pop(self, *a, **kw):
        r = super().pop(*a, **kw)
        self.callback()
        return r

    def popitem(self, *a, **kw):
        super().popitem(*a, **kw)
        self.callback()
        return

    def setdefault(self, *a, **kw):
        super().setdefault(*a, **kw)
        self.callback()
        return

    def update(self, *a, **kw):
        super().update(*a, **kw)
        self.callback()
        return
</code></pre>
<p>Also a better title and class name would be good.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd use composition rather than inheritance, and implement the <code>MutableMapping</code> from <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer"><code>collections.abc</code></a> so that I get some of the methods implemented for free. Per the documentation, you have to provide implementations of <code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__iter__</code>, and <code>__len__</code>:</p>
<pre><code>from collections.abc import MutableMapping


class BoundDict(MutableMapping):
    """Dict-like class that calls a callback on changes.

    Note that the callback is invoked *after* the 
    underlying dictionary has been mutated.

    """

    def __init__(self, callback, *args, **kwargs):
        self._callback = callback
        self._map = dict(*args, **kwargs)

    def __getitem__(self, key):
        return self._map[key]

    def __setitem__(self, key, value):
        self._map[key] = value
        self._callback()

    def __delitem__(self, key):
        del self._map[key]
        self._callback()

    def __iter__(self):
        return iter(self._map)

    def __len__(self):
        return len(self._map)
</code></pre>
<p>Note that you don't need to put a bare <code>return</code> at the end of a method, and I've added a docstring to explain what the class does. </p>
<p>Thanks to the abstract base class, the following additional methods will now be implemented for you: <code>__contains__</code>, <code>keys</code>, <code>items</code>, <code>values</code>, <code>get</code>, <code>__eq__</code>, and <code>__ne__</code>, <code>pop</code>, <code>popitem</code>, <code>clear</code>, <code>update</code>, and <code>setdefault</code>. Because they all call through to the five fundamental methods defined above, it's guaranteed that any change through the <code>MutableMapping</code> interface (although <em>not</em> changes to <code>_map</code> directly) will invoke the callback, as it will always involve calling either <code>__setitem__</code> or <code>__delitem__</code>.</p>
<p>In use:</p>
<pre><code>&gt;&gt;&gt; bd = BoundDict(lambda: print('changed'), [('foo', 'bar')], hello='world')
&gt;&gt;&gt; bd
&lt;BoundDict object at 0x7f8a4ea61048&gt;
&gt;&gt;&gt; list(bd.items())
[('foo', 'bar'), ('hello', 'world')]
&gt;&gt;&gt; bd['foo']
'bar'
&gt;&gt;&gt; bd['hello']
'world'
&gt;&gt;&gt; bd['foo'] = 'baz'
changed
&gt;&gt;&gt; del bd['hello']
changed
&gt;&gt;&gt; bd['foo']
'baz'
&gt;&gt;&gt; bd['hello']
Traceback (most recent call last):
  File "python", line 1, in &lt;module&gt;
  File "python", line 16, in __getitem__
KeyError: 'hello'
</code></pre>
<p>The only downside to this is that if you have explicit type checking, you might have issues:</p>
<pre><code>&gt;&gt;&gt; isinstance(bd, dict)
False
</code></pre>
<p>However, you should generally be using the ABCs for your type checks, too (or just <a href="https://docs.python.org/3/glossary.html#term-duck-typing" rel="nofollow noreferrer">duck typing</a>):</p>
<pre><code>&gt;&gt;&gt; isinstance(bd, MutableMapping)
True
&gt;&gt;&gt; isinstance(dict(), MutableMapping)
True
</code></pre>
<hr/>
<p>I think when you ask <em>"and that explains why I only see one callback with my example?"</em> <a href="https://stackoverflow.com/questions/44478363/dictionary-subclass-are-all-editing-methods-covered-with-callback/44478584#comment75952727_44478584">below</a> you want to know why the following happens with our different implementations:</p>
<pre><code>&gt;&gt;&gt; BindedDict(lambda: print('changed'), foo='bar', hello='world').clear()
changed
&gt;&gt;&gt; BoundDict(lambda: print('changed'), foo='bar', hello='world').clear()
changed
changed
</code></pre>
<p>This is due to the implementation of <a href="https://github.com/python/cpython/blob/3.6/Lib/_collections_abc.py#L816" rel="nofollow noreferrer"><code>MutableMapping.clear</code></a>; it loops over the keys in the dictionary, calls <code>popitem</code> for each one, which in turn calls <code>__delitem__</code>, which in turns calls the callback. By contrast, your implementation calls the callback only once, because you implement <code>clear</code> directly and call it from there.</p>
<p>Note that the ABC approach <strong>doesn't prevent you from doing this</strong>. It's not clear from your question (and you may not yet <em>know</em>) which is the correct behaviour, but you <em>can</em> still come in and override the default implementations provided by the ABC:</p>
<pre><code>class BoundDict(MutableMapping):
    """..."""

    ...

    def clear(self):
        self._map.clear()  #Â or e.g. self._map = {}
        self._callback()
</code></pre>
<p>The reason I recommend using the ABC rather than subclassing <code>dict</code> is that this gives you sensible default implementations that you can override where you need to, so you only need to worry about where your behaviour <em>differs</em> from the defaults. Fewer methods implemented also means a smaller risk of simple typos like <code>__delitme__</code> (if you don't provide a required <code>@abstractmethod</code> you get an error when you try to instantiate the class) and <code>super().__init__(*a, *kw)</code>.</p>
</div>
<span class="comment-copy"><code>__delitme__</code>? I'd recommend looking into the <code>MutableMapping</code> <a href="https://docs.python.org/3/library/collections.abc.htmlhttps://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer">ABC</a>. If your code works correctly, and you want improvements suggested, see <a href="https://codereview.stackexchange.com">Code Review</a>.</span>
<span class="comment-copy">Thanks @jonrsharpe . I had not tested deleting yet and thats a typo. By the way the ABC link is dead.</span>
<span class="comment-copy">@Peilonrayz managed to paste it twice... <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer">docs.python.org/3/library/collections.abc.html</a></span>
<span class="comment-copy">@jonrsharpe looking at the docs it does not explain much there, I'm going to google it but if you see this: what and how could I use it? Thanks</span>
<span class="comment-copy">Thanks, this is a really good explanation. What I don't get is why people are saying on different questions at when you subclass dict you don't get the methods? As everything is working from what I tested and it does not have downsides to ABC MM. Another thing, with your example above you say that you only need call back on <code>__setitem__</code> and <code>__delitem__</code>. Do the other methods use internal methods then to access them as with my code the callback is only called once as if the main two are not called? I might add a logger to each one to see...</span>
<span class="comment-copy"><i>"why people are saying on different questions at when you subclass dict you don't get the methods?"</i> - I don't understand the question, if you have other information maybe provide links? <i>"Do the other methods use internal methods then to access them"</i> - as I say in the answer, the extra methods that are implemented for you all call through to the five required implementations. Do <code>bd = BoundDict(lambda: print('changed'), [('foo', 'bar')], hello='world')</code> then <code>bd.clear()</code> and you'll see <code>changed</code> twice, for example.</span>
<span class="comment-copy">So when you inherit a class you get all its methods, so what methods would I be missing? In your example: <code>methods implemented for free</code>, <a href="https://stackoverflow.com/questions/3387691/how-to-perfectly-override-a-dict">Another Questions</a> Do you, and they mean I do not have to cover all methods which I want to change as it does not use super() which then called the parents unchanged methods and that explains why I only see one callback with my example?</span>
<span class="comment-copy">@Max sorry, I've no idea what you're trying to ask now. It's not clear why you think you're missing <i>any</i> methods - <b>the ABC provides them for you</b>. This approach doesn't have inheritance or <code>super</code>. It's unclear what your example is.</span>
<span class="comment-copy">@Max I think I figured out what you meant by the last part at least and have edited my answer. It's worth having a look at the source code I link to, in the context of <a href="https://docs.python.org/3/library/abc.html#module-abc" rel="nofollow noreferrer">how ABCs work generally in Python</a>; the <code>MutableMapping</code> and <code>Mapping</code> are pretty straightforward.</span>
