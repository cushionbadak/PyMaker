<div class="post-text" itemprop="text">
<p>I'm experimenting with OOP python and I wasn't sure about the <code>__repr__</code> function inheritance. Since the parent class function looked like this:</p>
<pre><code>def __repr__(self):
    '''Returns representation of the object'''
    return("{}('{}')".format("Class name", self._param))
</code></pre>
<p>I wanted to know if it is better to use a generic approach (which could be suitable for children classes as well) like the following one:</p>
<pre><code>def __repr__(self):
    '''Returns representation of the object'''
    return("{}('{}')".format(self.__class__.__name__, self._param))
</code></pre>
<p>or if it is a good practice to override the function in every class.</p>
<p>Also, please ignore the encoding part, since I'm leaving it behind.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well the <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="noreferrer"><code>__repr__</code></a> has a special meaning in Pythons data model:</p>
<blockquote>
<h2><code>object.__repr__(self)</code></h2>
<p>Called by the <code>repr()</code> built-in function to compute the “official” string representation of an object. <strong>If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment)</strong>. If this is not possible, a string of the form <code>&lt;...some useful description...&gt;</code> should be returned. The return value must be a string object. If a class defines <code>__repr__()</code> but not <code>__str__()</code>, then <code>__repr__()</code> is also used when an “informal” string representation of instances of that class is required.</p>
<p>This is typically used for debugging, so it is important that the representation is information-rich and unambiguous.</p>
</blockquote>
<p>That means the string that is returned by <code>__repr__</code> should be usable to create another object just like it. So <code>__repr__</code> is something that <em>quite often</em> needs overriding, not because of the <code>__class__.__name__</code> but because the "state" has to captured in the representation.</p>
<pre><code>def class A(object):
    def __init__(self, param):
        self._param = param

    def __repr__(self):
        '''Returns representation of the object'''
        return("{}('{}')".format(self.__class__.__name__, self._param))
</code></pre>
<p>Then you absolutely should override the <code>__repr__</code> when you add parameters for <code>__init__</code>:</p>
<pre><code>def class B(A):
    def __init__(self, param1, param2):
        self._param = param1
        self._param2 = param2

    def __repr__(self):
        '''Returns representation of the object'''
        return("{}('{}')".format(self.__class__.__name__, self._param, self._param2))
</code></pre>
<p>But in case the <code>__repr__</code> of the superclass still <strong>accuratly</strong> "describes" the subclass then there's no point overloading the <code>__repr__</code>:</p>
<pre><code>class B(A):
     pass
</code></pre>
<hr/>
<p>However it's always a good choice to use <code>self.__class__.__name__</code> over hard-coding the class name, just in case you or someone else subclasses it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes - - it is not just "ok", but it is what is more practical in almost every project and class hierarchy.</p>
<p>Actually, this is almost a perfect "text book example" of when to use class inheritance, and just let the code in the superclasses be reused. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here, you can have a look, how I inherited the <code>__repr__</code> method from Pesron class in Student class.</p>
<h1>Main():</h1>
<pre><code>def main():
    person_obj = Person("Jay", "26")  #Instance of Person class
    print(person_obj)
    st_obj = Student("Jenny", "24", "12345") #Instance of Student class
    print(st_obj)
</code></pre>
<h1>Base class: Person</h1>
<pre><code>class Person:
    name = ""  
    age = 0  

    def __init__(self, personName, personAge):  
        self.name = personName  
        self.age = personAge  

    def __repr__(self):
        return "Hello.. greeting!! {} {} ".format(self.name, self.age) 
</code></pre>
<h1>Derived class: Student</h1>
<pre><code>class Student(Person):
    studentId = ""  

def __init__(self, studentName, studentAge, studentId):  
    Person.__init__(self, studentName, studentAge)  
    self.studentId = studentId  

def __repr__(self):
    return super().__repr__() + " id is:  {} ".format(self.studentId)


if __name__ == '__main__':
    main()
</code></pre>
</div>
<span class="comment-copy">Generally speaking, it's fine to override the method if you want don't want to extend it.</span>
<span class="comment-copy">If all the child classes have the <code>_param</code> attribute, then it's quite safe for them to inherit that <code>__repr__</code> from the parent class.</span>
<span class="comment-copy">You should take the ability for recreating an object from its repr recomendtion with a grain of salt: it is great for some kindof objects, still it was thought up at  a time when Pyhton's <code>input</code> would call "eval" on the value typed by the user: it was another mindset for interactive use of the Python language. Depending on the kind of object it is not really practical - and sometimes not even desirable - taht repr works this way.</span>
<span class="comment-copy">@jsbueno It's more important for debugging (and when you post on StackOverflow). When the representation contains all necessary informations that define the instance then it's much easier to recreate a particular state or "see" what is going on.</span>
<span class="comment-copy">The behaviour you described is actually what you would do for <code>__str__</code>, not for <code>__repr__</code>!</span>
