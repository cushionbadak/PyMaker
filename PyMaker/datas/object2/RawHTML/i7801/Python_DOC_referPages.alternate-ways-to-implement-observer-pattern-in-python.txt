<div class="post-text" itemprop="text">
<p>i was going through a post <a href="http://www.giantflyingsaucer.com/blog/?p=5117" rel="nofollow noreferrer">post</a> about how observer pattern can be implemented in python . on the same post there are these comments.</p>
<blockquote>
<p>1) In python you may as well just use plain functions, the ‘Observer’
  class isnt really needed.</p>
<p>2) This is great example of what Java programmers are trying to do once
  they switch to Python – they feel like Python is missing all that crap
  and try to “port” it.</p>
</blockquote>
<p>These comments imply that the observer pattern is not really useful in python and there exists other ways to achieve the same effect. is that true and if how can that be done?</p>
<p>Here is the code of observer pattern:</p>
<pre><code>class Observable(object):

    def __init__(self):
        self.observers = []

    def register(self, observer):
        if not observer in self.observers:
            self.observers.append(observer)

    def unregister(self, observer):
        if observer in self.observers:
            self.observers.remove(observer)

    def unregister_all(self):
        if self.observers:
            del self.observers[:]

    def update_observers(self, *args, **kwargs):
        for observer in self.observers:
            observer.update(*args, **kwargs)

from abc import ABCMeta, abstractmethod

class Observer(object):
    __metaclass__ = ABCMeta

    @abstractmethod
    def update(self, *args, **kwargs):
        pass

class AmericanStockMarket(Observer):
    def update(self, *args, **kwargs):
        print("American stock market received: {0}\n{1}".format(args, kwargs))

class EuropeanStockMarket(Observer):
    def update(self, *args, **kwargs):
        print("European stock market received: {0}\n{1}".format(args, kwargs))


if __name__ == "__main__":
    observable = Observable()

    american_observer = AmericanStockMarket()
    observable.register(american_observer)

    european_observer = EuropeanStockMarket()
    observable.register(european_observer)

    observable.update_observers('Market Rally', something='Hello World')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are many different ways you can "observe" something in python. Use property <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>, custom <a href="https://docs.python.org/2/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer"><code>__setattr__</code></a>, <a href="https://wiki.python.org/moin/PythonDecorators" rel="nofollow noreferrer">decorators</a>...</p>
<p>Here is a simple example that uses <a href="https://en.wikipedia.org/wiki/First-class_function" rel="nofollow noreferrer">first class functions</a>:</p>
<pre><code>class Foo(object):
    def __init__(self):
        self.observers = []

    def register(self, fn):
        self.observers.append(fn)
        return fn   # &lt;-- See comments below answer

    def notify_observers(self, *args, **kwargs):
        for fn in self.observers:
            fn(*args, **kwargs)
</code></pre>
<p>You can then register any callable.</p>
<pre><code>class Bar(object):
    def do_something(self, *args, **kwargs):
        pass # do something

foo = Foo()
bar = Bar()
foo.register(bar.do_something)
</code></pre>
<p>This will work properly. The call to <code>do_something</code> will have the correct <code>self</code> value. Because an object's methods are callable objects which carry a reference to the instance they are bound to.</p>
<p>This might help understanding how it works under the hood:</p>
<pre><code>&gt;&gt;&gt; bar
&lt;Bar object at 0x7f3fec4a5a58&gt;
&gt;&gt;&gt; bar.do_something
&lt;bound method Bar.do_something of &lt;Bar object at 0x7f3fec4a5a58&gt;&gt;
&gt;&gt;&gt; type(bar.do_something)
&lt;class 'method'&gt;
&gt;&gt;&gt; bar.do_something.__self__
&lt;Bar object at 0x7f3fec4a5a58&gt;
</code></pre>
<hr/>
<p><strong>[edit: decorator example]</strong></p>
<p>You may also use the <code>register</code> method we defined above as a decorator, like this:</p>
<pre><code>foo = Foo()

@foo.register
def do_something(*args, **kwargs):
    pass # do something
</code></pre>
<p>For this to work, just remember that <code>register</code> needs to return the callable it registered.</p>
</div>
<span class="comment-copy">What problem are you trying to solve? Patterns are mere tools; trying to "implement" them is meaningless outside a specific context to apply them to.</span>
<span class="comment-copy">@spectras i am trying to learn patterns so for that i need to implement it. but according t those comments this pattern is not really useful in python. and there exists alternate wasy to achieve the same idea</span>
<span class="comment-copy">The pattern itself is useful, but the implementation is Java-esque in that you define an "interface" <code>Observer</code> that has a method that implementations must implement, so that the <code>Observable</code> can then call that method (update) of those implementations. In python you might as well just pass plain functions or bound methods as observers without all the boilerplate. This is not to say that you should never do it like this. "Interfaces "do have their uses in Python as well.</span>
<span class="comment-copy">The point made in the comments (which should be taken with a grain of salt, it's true... to a certain extent only) is you would not structure your python code the same way you structure a functionally-equivalent Java code.</span>
<span class="comment-copy">By not enforcing anything, but accepting callables directly instead of "observer objects". You can even pass bound methods in python.</span>
<span class="comment-copy">i got it now.thanks :)</span>
<span class="comment-copy">If <code>register()</code> returned the fn, it'd work as a decorator as well, and so one could <code>@observable.register ...</code> functions. Just a small example of how Python might differ.</span>
<span class="comment-copy">@IljaEverilä&gt; I feared it would be too much for this answer, especially given it's also a change in paradigm (you need the obervable instance to exist before the observer method is defined, which gets even further away from Java). But it is totally true and I would definitely have it return the callable in a real-world example. I added the return with a note.</span>
<span class="comment-copy">I would be interested in that decorater solution. ;) I am not from Java but C++.</span>
<span class="comment-copy">@buhtz here you are.</span>
