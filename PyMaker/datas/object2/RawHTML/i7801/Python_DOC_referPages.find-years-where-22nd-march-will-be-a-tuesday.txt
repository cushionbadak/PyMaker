<div class="post-text" itemprop="text">
<p>I need to find out in which years between 2017 and 2100 (both inclusive) will the 22nd March be a Tuesday.</p>
<p>I tried using the <code>datetime</code> module but I couldn't figure out how...</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <strong><a href="https://docs.python.org/3/library/calendar.html" rel="nofollow noreferrer">calendar</a></strong> module instead:</p>
<pre><code>&gt;&gt;&gt; import calendar
&gt;&gt;&gt; [year for year in range(2017, 2101) if calendar.weekday(year, 3, 22) == calendar.TUESDAY]
[2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/datetime.html#datetime.date.isoweekday" rel="nofollow noreferrer"><code>isoweekday</code></a> from the <code>datetime</code> module:</p>
<pre><code>import datetime

for year in range(2017, 2101):
    if datetime.date(year, 3, 22).isoweekday() == 2:  # 2 is Tuesday
        print(year)
</code></pre>
<p>or <a href="https://docs.python.org/3/library/datetime.html#datetime.date.weekday" rel="nofollow noreferrer"><code>weekday</code></a>:</p>
<pre><code>import datetime

for year in range(2017, 2101):
    if datetime.date(year, 3, 22).weekday() == 1:  # now 1 is Tuesday
        print(year)
</code></pre>
<hr/>
<p>You can also use a comprehension to collect them in a list:</p>
<pre><code>&gt;&gt;&gt; [year for year in range(2017, 2101) if datetime.date(year, 3, 22).isoweekday() == 2]
[2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A bit late to the party, but how about using math instead of building hundreds of <code>datetime.datetime</code> objects just to throw them away?</p>
<pre><code># adjusted Zeller's formula, returns 0 - Sunday, 1 - Monday ... 6 - Saturday
def get_weekday(y, m, d):  
    return (d+(13*((10+m)%12+1)-1)//5+y%100+y%100//4+(y//100)//4-2*(y//100))%7

start_year = 2017
end_year = 2100

target_date = 22
target_month = 2    # 0 - January, 1 - February ... 11 - December
target_weekday = 2  # 0 - Sunday, 1 - Monday ... 6 - Saturday

years = [year for year in range(start_year, end_year + 1) if
         get_weekday(year, target_month, target_date) == target_weekday]
# gives: [2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use the <code>datetime</code> module:</p>
<pre><code>&gt;&gt;&gt; tuesdays = [year for year in range(2017, 2101) if datetime.date(year, 3, 22).weekday() == 1]

&gt;&gt;&gt; tuesdays
[2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095]
</code></pre>
</div>
<span class="comment-copy">It'd be great if you could provide your code so far</span>
<span class="comment-copy">not that it's particular important (because 2100-3-22 isn't a Tuesday) but the range <b>including 2100</b> or <b>excluding 2100</b>? I find <i>in between</i> a bit vague.</span>
<span class="comment-copy">Sorry I had a for loop cricket_007 and inclusive MSeifert</span>
<span class="comment-copy">Wow this module is much better for this than datetime thanks!</span>
<span class="comment-copy">Just a minor comment: If you want 2100 inclusive you need to use <code>range(2017, 2101)</code>. :)</span>
<span class="comment-copy"><code>calendar.weekday</code> is just an alias for <code>datetime.date.weekday</code>. No need to load a separate module just for this purpose.</span>
<span class="comment-copy">@zwer I presume OP was not using the <code>datetime</code> module anywhere else</span>
<span class="comment-copy">@shash678 - <code>calendar</code> provides nice facilities and convenience features for iterating over various calendar ranges, generating HTML calendars, dealing with different locales and calculating based on different week days... if you need to load all that just to get a <code>(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)</code> map, you're doing it wrong... But then we'd be arguing convenience vs effectiveness and that's rarely a fruitful discussion so I won't go there. I was merely suggesting a more effective approach that your answer translates to.</span>
<span class="comment-copy">A good alternative but in general I wouldn't recommend using self-implemented math if there's already a (built-in) library providing the math.</span>
