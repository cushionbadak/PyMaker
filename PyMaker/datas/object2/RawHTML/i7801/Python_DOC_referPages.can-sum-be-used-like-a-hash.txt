<div class="post-text" itemprop="text">
<p>I want to check whether the sum of two list is same or not. </p>
<pre><code>lst1 = [1 2 3 4]
lst2 = [0 3 3 4]
if sum(lst1) == sum(lst2):
    return true
</code></pre>
<p>Here the sum returns true. If I hash the list I get different values but hashing is computationally expensive. <strong>I only want to check whether the elements in the two lists are same (only with the exception of 1 element)</strong>. I am using Binary search technique of dividing the list and then checking the hash. if hashes are different I am checking if its more than once. 
But as I said hashing is computationally expensive. <strong>Also the order does matter here</strong>. Thank you</p>
</div>
<div class="post-text" itemprop="text">
<p>First, <code>is</code> is not the logically correct syntax for your application; use <code>==</code> instead. Refer this post to know more about the difference: <a href="https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python">Is there a difference between `==` and `is` in Python?</a></p>
<pre><code>def checksum(lst1, lst2):
    return sum(lst1) == sum(lst2):

list1 = [1, 2, 3, 4]
list2 = [0, 3, 3, 4]
checksum(list1,list2)
</code></pre>
<p>This <em>is</em> the correct code to compare a <em>checksum</em> (and is obviously true in this example). </p>
<p>If you are looking for something different, like finding whether the items of the list are the same element-wise, then the straight-forward answer would be</p>
<pre><code>return lst1 == lst2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>is</code> checks for object identity, not equality (<a href="https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python">link</a>).</p>
<p><code>sum</code> does not differentiate between the elements that are summed over only the end result. If you need to differentiate between the elements of the containers you can use a <code>set</code></p>
<pre><code>set(lst1) == set(lst2) # ignores counts of elements
</code></pre>
<p>or if you're sensitive to the counts of the elements use <code>collections.Counter</code></p>
<pre><code>collections.Counter(lst2) == collections.Counter(lst1) # False
collections.Counter(lst1) == collections.Counter(lst1) # True
</code></pre>
<p>this requires you to iterate over the list.</p>
<hr/>
<p>Depending on what exactly you're after you could also you </p>
<pre><code>hash(tuple(lst1)) == hash(tuple(lst2))
</code></pre>
<p>This checks both the elements contained and their order (maybe you don't care about order) and is pretty efficient. You have to do the cast to a <code>tuple</code> as <code>list</code> is not immutable and therefore can not be hashed.</p>
<p><code>hash(tuple)</code> seems to be much faster, but it's not clear to me what exactly your end goal is</p>
<pre><code>%timeit hash(tuple(lst1)) == hash(tuple(lst2))
1000000 loops, best of 3: 408 ns per loop

%timeit collections.Counter(lst2) == collections.Counter(lst1)
100000 loops, best of 3: 5.58 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Can sum be used like a hash?</h2>
<p>Yes, the <em>sum()</em> function can be used as a hash for a list or tuple of integers.</p>
<h2>Is hashing is computationally expensive?</h2>
<p>Interestingly, <strong><em>hash()</em> performs better than <em>sum()</em> for a tuple of integers</strong>:</p>
<pre><code>$ python2.7 -m timeit -s "data = (1, 2, 3, 4)" "sum(data)"
10000000 loops, best of 3: 0.113 usec per loop

$ python2.7 -m timeit -s "data = (1, 2, 3, 4)" "hash(data)"
10000000 loops, best of 3: 0.0569 usec per loop
</code></pre>
<h2>How to compare unordered lists</h2>
<p>The stated problem is "how to compare elements in the two lists are same (only with the exception of 1 element)"</p>
<p>A built-in tool for doing this is <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><em>collections.Counter()</em></a>.  Internally, it uses fast hashing to accumulate counts.  In Python 3, it is accelerated by code written in C.   It uses a single O(n) pass rather than an O(log n) binary search.</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; list1 = [1, 2, 3, 4]
&gt;&gt;&gt; list2 = [0, 3, 3, 4]

&gt;&gt;&gt; c1 = Counter(list1)
&gt;&gt;&gt; c2 = Counter(list2)
&gt;&gt;&gt; c1 == c2
False
&gt;&gt;&gt; c1 - c2
Counter({1: 1, 2: 1})
&gt;&gt;&gt; c2 - c1
Counter({0: 1, 3: 1})
</code></pre>
<p>The difference in the various approaches will become more pronounced as the list size grows larger.</p>
</div>
<span class="comment-copy">You don't need the sum then. Enough to check the lists have the same items. You didn't say if the order is important tho.</span>
<span class="comment-copy">You could use <code>hash(tuple(lst))</code> to generate a distinctive number for a list. But it wouldn't be unique. It's impossible to convert a list to a unique number unless there is additional information about (say) the range of the numbers in your lists.</span>
<span class="comment-copy">Your sum <i>is</i> equal. It <i>should</i> return True.</span>
<span class="comment-copy">Re-opened after the OP's edit.  The question is now entirely unrelated to <a href="https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python" title="is there a difference between and is in python">stackoverflow.com/questions/132988/…</a></span>
<span class="comment-copy"><i>but sum should differentiate between the different numbers in the list</i></span>
<span class="comment-copy">This is a good tip but it's really not what the OP was asking.</span>
<span class="comment-copy">Should have been in a comment indeed - or as a side note in a full answer.</span>
<span class="comment-copy">Thanks for the suggestion bruno and @khelwood. I just added a bit more detail for clarity.</span>
<span class="comment-copy">Nice answer (+1), but don't you think it's a bit of an overkill for the OP?</span>
<span class="comment-copy">I try to write my answers for anyone stumbling onto the question later in addition to the OP.  SO is a form of documentation nowadays</span>
