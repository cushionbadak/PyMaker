<div class="post-text" itemprop="text">
<p>I have 2 functions: The first one, <code>def_a</code>, is an asynchronous function and the second one is <code>def_b</code> which is a regular function and called with the result of <code>def_a</code> as a callback with the <code>add_done_callback</code> function.</p>
<p>My code looks like this:</p>
<pre><code>import asyncio

def def_b(result):
    next_number = result.result()
    # some work on the next_number
    print(next_number + 1)

async def def_a(number):
    await some_async_work(number)
    return number + 1

loop = asyncio.get_event_loop()
task = asyncio.ensure_future(def_a(1))
task.add_done_callback(def_b)
response = loop.run_until_complete(task)
loop.close()
</code></pre>
<p>And it's work perfectly.</p>
<p>The problem began when also the second function, <code>def_b</code>, became asynchronous. Now it looks like this:</p>
<pre><code>async def def_b(result):
    next_number = result.result()
    # some asynchronous work on the next_number
    print(next_number + 1)
</code></pre>
<p>But now I can not provide it to the <code>add_done_callback</code> function, because it's not a regular function.</p>
<p>My question is- Is it possible and how can I provide <code>def_b</code> to the <code>add_done_callback</code> function if <code>def_b</code> is asynchronous?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>add_done_callback</code> is considered a "low level" interface.  When working with coroutines, you can <a href="https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines" rel="noreferrer">chain them</a> in many ways, for example:</p>
<pre><code>import asyncio


async def my_callback(result):
    print("my_callback got:", result)
    return "My return value is ignored"


async def coro(number):
    await asyncio.sleep(number)
    return number + 1


async def add_success_callback(fut, callback):
    result = await fut
    await callback(result)
    return result


loop = asyncio.get_event_loop()
task = asyncio.ensure_future(coro(1))
task = add_success_callback(task, my_callback)
response = loop.run_until_complete(task)
print("response:", response)
loop.close()
</code></pre>
<p>Keep in mind <code>add_done_callback</code> will still call the callback if your future raises an exception (but calling <code>result.result()</code> will raise it). </p>
</div>
<div class="post-text" itemprop="text">
<p>This only works for one future job, if you have multiple async jobs, they will blocks each other, a better way is using asyncio.as_comleted() to iterate future list:</p>
<pre><code>import asyncio

async def __after_done_callback(future_result):
    # await for something...
    pass

async def __future_job(number):
    await some_async_work(number)
    return number + 1

loop = asyncio.get_event_loop()
tasks = [asyncio.ensure_future(__future_job(x)) for x in range(100)]  # create 100 future jobs

for f in asyncio.as_completed(tasks):
    result = await f
    await __after_done_callback(result)

loop.close()
</code></pre>
</div>
<span class="comment-copy">thank you for sharing, out of curiousity, what is the benefit of using ensure future over using await my_coro within my_callback</span>
<span class="comment-copy"><code>ensure_future(coro)</code> just queues <code>coro()</code> for later execution and does not immediately start <code>coro()</code>.</span>
<span class="comment-copy">asyncio.create_task() should be used used instead of asyncio.ensure_future() in Python 3.7+ <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-task.html#asyncio.create_task</a></span>
