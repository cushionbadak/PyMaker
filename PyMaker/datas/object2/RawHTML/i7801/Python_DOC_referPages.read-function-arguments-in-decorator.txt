<div class="post-text" itemprop="text">
<p>I have written this decorator that saves intermediate results in a json file</p>
<pre><code>import json
import os

def json_file(fname):
    def decorator(function):
        def wrapper(*args, **kwargs):
            if os.path.isfile(fname):
                with open(fname, 'r') as f:
                    ret = json.load(f)
            else:
                with open(fname,'w') as f:
                    ret = function(*args, **kwargs)
                    json.dump(ret, f)
            return ret
        return wrapper
    return decorator
</code></pre>
<p>And usage is</p>
<pre><code>@json_file("cached.json")
def some_calculation(n):
   return {"result": 2**n}
</code></pre>
<p>And I want to augment in to use the function parameters like this:</p>
<pre><code>@json_file("cached_{n}.json")
def calculation(n):
    return {"result": 2**n}
</code></pre>
<p>Such that <code>{n}</code> is replaced with the value of <code>n</code> when calling the function.</p>
<p>I tried replacing <code>fname</code> with <code>fname.format(**kwargs)</code>, without any success.</p>
<p>How can this be achieved ?</p>
<p>EDIT:</p>
<p>As Per @jonrshape's comment, this is the error I am getting after adding the <code>.format(**kwargs)</code></p>
<pre><code> &lt;ipython-input-4-12b0c894b345&gt; in wrapper(*args, **kwargs)
       5     def decorator(function):
       6         def wrapper(*args, **kwargs):
 ----&gt; 7             fname = fname.format(**kwargs)
       8             if os.path.isfile(fname):
       9                 with open(fname, 'r') as f:

 UnboundLocalError: local variable 'fname' referenced before assignment
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">inspect</a> module.</p>
<p>First we extract the wrapped function's signature:</p>
<pre><code>signature= inspect.signature(function)
</code></pre>
<p>Then we <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature.bind" rel="nofollow noreferrer">bind</a> the *args and **kwargs:</p>
<pre><code>bound_args= signature.bind(*args, **kwargs)
</code></pre>
<p>Now <code>bound_args.parameters</code> is a dict of <code>parameter_name:parameter_value</code> which we can use to format our file name:</p>
<pre><code>file_name= fname.format(**bound_args.arguments)
</code></pre>
<p>Everything put together:</p>
<pre><code>import json
import os
import inspect

def json_file(fname):
    def decorator(function):
        signature= inspect.signature(function)

        def wrapper(*args, **kwargs):
            bound_args= signature.bind(*args, **kwargs)
            file_name= fname.format(**bound_args.arguments)

            #~ print(file_name)
            if os.path.isfile(file_name):
                with open(file_name, 'r') as f:
                    ret = json.load(f)
            else:
                with open(file_name,'w') as f:
                    ret = function(*args, **kwargs)
                    json.dump(ret, f)
            return ret
        return wrapper
    return decorator
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If <code>n</code> will sometimes be a positional and sometimes be a keyword argument, you can first search the keyword arguments <code>kwargs</code>, and if that fails, "fallback" to getting the value from <code>args</code>:</p>
<pre><code>def json_file(fname):
    def decorator(function):
        def wrapper(*args, **kwargs):
            try:
                value = kwargs['n']
            except KeyError:
                value = args[0]
            fname.format(value)
            if os.path.isfile(fname):
                with open(fname, 'r') as f:
                    ret = json.load(f)
            else:
                with open(fname,'w') as f:
                    ret = function(*args, **kwargs)
                    json.dump(ret, f)
            return ret
        return wrapper
    return decorator
</code></pre>
<hr/>
<p>Just for sake of completeness, I'll address your error.</p>
<p>The reason your getting an <code>UnboundLocalError</code> error is because of how Python sees your variable definition.</p>
<p>If a variable is already defined in the current scope, assiging the variable to a new value will simply <em><strong>rebind</strong></em> it to the new value. However, if the variable has not yet been defined, Python treats it as a variable <em><strong>definition</strong></em>, not a rebinding. </p>
<p>That is why your code fails. Python expects <code>fname</code> to have been defined in the <em>current</em> scope, not a parent scope. But since <code>fname</code> was never defined, it raised an error.</p>
<p>You can fix this error by using the <a href="https://docs.python.org/3/reference/simple_stmts.html#grammar-token-nonlocal_stmt" rel="nofollow noreferrer"><code>nonlocal</code></a> statement. From the docs:</p>
<blockquote>
<p>The <a href="https://docs.python.org/3/reference/simple_stmts.html#grammar-token-nonlocal_stmt" rel="nofollow noreferrer">nonlocal</a> statement causes the listed identifiers to refer to previously bound variables in the nearest enclosing scope excluding globals. This is important because the default behavior for binding is to search the local namespace first. The statement allows encapsulated code to rebind variables outside of the local scope besides the global (module) scope.</p>
</blockquote>
<p>Here is an example of the usage:</p>
<pre><code>&gt;&gt;&gt; def foo(arg):
    def bar():
        arg += 1
        return arg
    return bar

&gt;&gt;&gt; 
&gt;&gt;&gt; foo(0)() # this will raise an error
Traceback (most recent call last):
  File "&lt;pyshell#76&gt;", line 1, in &lt;module&gt;
    foo(0)() # this will raise an error
  File "&lt;pyshell#74&gt;", line 3, in bar
    arg += 1
UnboundLocalError: local variable 'arg' referenced before assignment
&gt;&gt;&gt; 
&gt;&gt;&gt; def foo(arg):
    def bar():
        nonlocal arg
        arg += 1
        return arg
    return bar

&gt;&gt;&gt; foo(0)() # this will work
1
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy"><code>n</code> can be passed as a positional argument, why did you expect in in <code>kwargs</code>? If it must always be the first argument, change to <code>def wrapper(n, *args, **kwargs):</code>.</span>
<span class="comment-copy">It also doesn't work when calling the function with <code>calculation(n=5)</code></span>
<span class="comment-copy">Please give a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> with the traceback, then. A simple example works just fine for me.</span>
<span class="comment-copy">Why the vote down?</span>
<span class="comment-copy">Well there are many other questions about <code>UnboundLocalError: local variable 'fname' referenced before assignment </code>, this isn't a unique problem. If you don't try to reuse the same name in <code>wrapper</code> as the parameter from <code>json_file</code> it's based on, what you have will work.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/44376199/read-function-arguments-in-decorator?noredirect=1#comment75753450_44376199"><i>"It also doesn't work when calling the function with <code>calculation(n=5)</code>"</i></a></span>
<span class="comment-copy">@jonrsharpe Ah, I missed that. I'll edit my answer.</span>
