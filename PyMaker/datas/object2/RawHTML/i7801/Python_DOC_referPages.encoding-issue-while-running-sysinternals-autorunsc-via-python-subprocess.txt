<div class="post-text" itemprop="text">
<p>I have a Python 3.6.0 script where I run <code>autorunsc</code> v13.71 (<a href="https://technet.microsoft.com/en-us/sysinternals/bb963902.aspx" rel="nofollow noreferrer">https://technet.microsoft.com/en-us/sysinternals/bb963902.aspx</a>) on the system (x86 or x86_64 version, according to the system bitness using <code>platform.machine()</code>). If I run <code>autorunsc</code> directly from the terminal (CMD or Powershell) I get the output as expected, no issues (snip from the output):</p>
<p><a href="https://i.stack.imgur.com/KlN1f.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/KlN1f.png"/></a></p>
<p>But, if I try to run it using my code I get this messy output:</p>
<p><a href="https://i.stack.imgur.com/YcKkv.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/YcKkv.png"/></a></p>
<p>I'm using Window's default Notepad to open the output text file. People should be able to read it using Notepad, they won't be able to download a code reader like Notepad++, ST3, etc.</p>
<hr/>
<p>My code (removed some parts to keep it short and direct):</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

import platform
import socket
import subprocess
from time import gmtime, strftime
from pathlib import Path

HOSTNAME = socket.gethostname()
SYS_ARCH = platform.machine()  # AMD64 or x86
ROOT_PATH = Path(__file__).parent


def get_current_datetime():
    return strftime("%Y-%m-%d %H:%M:%S UTC%z", gmtime())


def run_command(output_file, command_name, command_args, system_cmd=False):
    output_file.write(f'---------- START [{command_name} {SYS_ARCH}] {get_current_datetime()} ----------\n')
    output_file.flush()

    file_path = command_name if system_cmd else str(ROOT_PATH / 'tools' / SYS_ARCH / (command_name + '.exe'))
    subprocess.call([file_path] + command_args, stdout=output_file, shell=True, universal_newlines=True)

    output_file.write(f'---------- ENDED [{command_name} {SYS_ARCH}] {get_current_datetime()} ----------\n\n')
    output_file.flush()
    print(f'[*] [{command_name} {SYS_ARCH}] done')


def main():
    output_file = ROOT_PATH.parent / (HOSTNAME + '.txt')
    with open(output_file, 'w', encoding='utf-8') as fout:
        run_command(output_file=fout, command_name='autorunsc', command_args=['-h', '-nobanner', '-accepteula'])


if __name__ == '__main__':
    main()
</code></pre>
<hr/>
<p>File structure:</p>
<ul>
<li>folder\

<ul>
<li>app.py (the code shown here)</li>
<li>tools\

<ul>
<li>AMD64\

<ul>
<li>autorunsc.exe</li>
</ul></li>
<li>x86\

<ul>
<li>autorunsc.exe</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<hr/>
<p>I believe it's something to do with the output of <code>autorunsc</code>, I read somewhere it returns the output encoded as UTF-16. The thing is that I run many other Sysinternals EXEs and append the output to the same file (using my <code>run_command</code> function), and all of them work flawlessly, but this one. How can I get this right?</p>
</div>
<div class="post-text" itemprop="text">
<p>To open your file in Microsoft Notepad, you must use Microsoft new lines: <code>\r\n</code> (CR LF). </p>
<p>The <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">open</a> function in Python 3 has a <em>newline</em> parameter for that. </p>
<p>You can fix your code like this:</p>
<pre><code>with open(output_file, 'w', encoding='utf-8', newline='\r\n') as fout:
    run_command(output_file=fout, command_name='autorunsc', command_args=['-h', '-nobanner', '-accepteula'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found the solution. Indeed, the issue was the encoding for the <code>autorunsc</code> tool output. It's in <code>UTF16</code> while the rest is <code>UTF8</code>, this is what I did:</p>
<pre><code># IF-ELSE to handle the 'autorunsc' output, which is UTF16
if command_name == 'autorunsc':
    result = subprocess.Popen([file_path] + command_args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    text = result.stdout.read().decode('UTF16')
    for line in text:
        output_file.write(line)
else:
    subprocess.call([file_path] + command_args, stdout=output_file, stderr=output_file) 
</code></pre>
<p>With this code I can have all the outputs inside my single UTF-8 file.txt.</p>
</div>
<span class="comment-copy">Didn't fix the issue. Got the same messy output. The line break for all the other outputs are fine. <code>autorunsc</code> isn't the only .exe I run with my code, there are others Sysinternals tools that I run and the output is correctly formatted.</span>
<span class="comment-copy">You can use <code>splitlines</code> to split to output of your command and then write them into your file.</span>
<span class="comment-copy">No I can't, take a look at <code>subprocess.call([file_path] + command_args, stdout=output_file, stderr=output_file, shell=True, universal_newlines=True)</code>. It automatically sends to output to the file (<code>output_file</code>). I don't have any control over the lines.</span>
<span class="comment-copy">Your screen copy seems to have a <a href="https://en.m.wikipedia.org/wiki/Byte_order_mark" rel="nofollow noreferrer">BOM</a>. And is probably encoded in UTF16.</span>
<span class="comment-copy">Use <code>check_output</code> instead of <code>call</code> to get the sub process output.</span>
