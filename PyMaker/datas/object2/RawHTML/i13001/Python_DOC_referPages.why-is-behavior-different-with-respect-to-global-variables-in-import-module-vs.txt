<div class="post-text" itemprop="text">
<p>Let's have <strong>a.py</strong> be:</p>
<pre><code>def foo():
    global spam
    spam = 42
    return 'this'
</code></pre>
<p>At a console, if I simply <code>import a</code>, things make sense to me:</p>
<pre><code>&gt;&gt;&gt; import a
&gt;&gt;&gt; a.foo()
'this'
&gt;&gt;&gt; a.spam
42
</code></pre>
<p>However, if I do the less popular thing and...</p>
<pre><code>&gt;&gt;&gt; from a import *
&gt;&gt;&gt; foo()
'this'
&gt;&gt;&gt; spam
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'spam' is not defined
&gt;&gt;&gt; a.spam
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'a' is not defined
</code></pre>
<p>I've read opinions about why people don't like "<code>from module import *</code> " from a namespace perspective, but I can't find anything on this behavior, and frankly I figured out that this was the issue I was having by accident.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you ask for <code>a.spam</code> there happens a namespace search in the module <code>a</code> and <code>spam</code> is found. But when you ask for just <code>spam</code>:</p>
<pre><code>&gt;&gt;&gt; from a import *  # imported foo, spam doesn't exist yet
&gt;&gt;&gt; foo()
</code></pre>
<p><code>spam</code> is created in the <em>namespace</em> a (you cannot access it with such import though), but not in the current module. And it seems like nobody promised us to add newly added globals of <code>a</code> to all the namespaces module <code>a</code> has been imported into via <code>*</code>. That will require storing import links inside the interpreter and probably will degrade performance if one heavily imported module does such tricks all the time.</p>
<p>And imagine you have defined <code>spam</code> in your main module prior to calling <code>foo()</code>. That would be downright name collision.</p>
<p>Just as illustration, you can do <code>from a import *</code> to get fresh updates for the module <code>a</code>:</p>
<pre><code>from a import *
print(foo())
from a import *
print(spam)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's go thorough it step by step:</p>
<p>At the point of importing, <code>a</code> only has the symbol <code>foo</code> which refers to a function.</p>
<p>Only if the function is executed, <code>a</code> gets the additional symbol <code>spam</code>.</p>
<p>In the first case, you do <code>import a</code> and get a "handle" to the module, which allows you to monitor whatever happens later. If you'd do <code>a.spam</code> before calling <code>a.foo()</code>, you'd get an error.</p>
<p>In the second case, <code>from a import *</code> gives you whatever <em>currently</em> is in the module - and that's just <code>spam()</code>. After calling that, you could do <code>from a import *</code> to get <code>spam</code> as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>I generally agree with Vovanrock2002.</p>
<p>As was recently explained to me, the '.' is a scope resolution operator. <code>import a</code> and <code>from a import *</code> give you different syntaxes. <code>from a import *</code> imports each global variable from <code>a</code> separately, and binds them as variables in the local scope. A more practical example might be the difference between <code>import datetime</code> and <code>from datetime import date</code>. With the former, I have to create a date object using <code>datetime.date(2015, 11, 12)</code>, with the latter I get to just use <code>date(2015, 11, 12)</code>.</p>
<p>You can read more on the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-import-statement" rel="nofollow">import statement</a></p>
<p>I would have to differ with you, however, in that I don't believe that spam is the meaning of life, the universe, and everything.</p>
</div>
<span class="comment-copy"><code>globals</code> defined in <code>a.py</code> are going to be global in that module itself, so it is not going to define a global variable where you're importing it. Check <code>foo.__globals__</code>.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/modules.html#more-on-modules" rel="nofollow noreferrer">Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module...</a></span>
<span class="comment-copy">This is clear enough for me to understand, thank you.</span>
<span class="comment-copy">Calling spam <i>or</i> a.spam doesn't work in the second case. And I agree, the world would be a sad place if spam were truely the answer.</span>
