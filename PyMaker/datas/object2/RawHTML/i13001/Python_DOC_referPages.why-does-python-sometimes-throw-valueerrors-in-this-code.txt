<div class="post-text" itemprop="text">
<p>I have some Python 3.5 code that looks approximately like this:</p>
<pre><code>try:
    my_process = Popen(someargs, stdin=None, stdout=PIPE, stderr=PIPE)
    stdout, stderr = my_process.communicate(timeout=10)
    my_process.wait()
except TimeoutExpired:
    my_process.kill()
    stdout, stderr = my_process.communicate()
</code></pre>
<p>I am trying to follow the principle described in <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow">the python subprocess documentation here</a>, namely that in the case of a TimeoutError, I should kill the process manually, then complete the communication.</p>
<p>In principle that sounds fine, but periodically (maybe every 1 in 50 times, very approximately), I get an error like this:</p>
<pre><code>Traceback (most recent call last):
  File "/Users/xyz/myprogram/myprogram", line 125, in &lt;module&gt;
    stdout, stderr = my_process.communicate()
  File "/usr/local/Cellar/python3/3.5.0/Frameworks/Python.framework/Versions/3.5/lib/python3.5/subprocess.py", line 1068, in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
  File "/usr/local/Cellar/python3/3.5.0/Frameworks/Python.framework/Versions/3.5/lib/python3.5/subprocess.py", line 1689, in _communicate
    selector.register(self.stdout, selectors.EVENT_READ)
  File "/usr/local/Cellar/python3/3.5.0/Frameworks/Python.framework/Versions/3.5/lib/python3.5/selectors.py", line 342, in register
    key = super().register(fileobj, events, data)
  File "/usr/local/Cellar/python3/3.5.0/Frameworks/Python.framework/Versions/3.5/lib/python3.5/selectors.py", line 228, in register
    key = SelectorKey(fileobj, self._fileobj_lookup(fileobj), events, data)
  File "/usr/local/Cellar/python3/3.5.0/Frameworks/Python.framework/Versions/3.5/lib/python3.5/selectors.py", line 215, in _fileobj_lookup
    return _fileobj_to_fd(fileobj)
  File "/usr/local/Cellar/python3/3.5.0/Frameworks/Python.framework/Versions/3.5/lib/python3.5/selectors.py", line 39, in _fileobj_to_fd
    "{!r}".format(fileobj)) from None
ValueError: Invalid file object: &lt;_io.BufferedReader name=5&gt;
</code></pre>
<p>Line 125 is the second <code>communicate()</code> line in my case.</p>
<p>It would appear that this is failing because some stream underlying the process object has closed or terminated - perhaps sometimes by chance this happens between the <code>kill()</code> and the <code>communicate()</code>?. But if so, is there a graceful way I should be handling this? The Python docs don't appear to cover this case.</p>
</div>
<div class="post-text" itemprop="text">
<p>To workaround <code>my_process.communicate()</code> raising <code>ValueError</code> in the exception handler, you could read from the streams directly (simpler code path -- don't use it in the general case):</p>
<pre><code>from subprocess import Popen, PIPE, TimeoutExpired

with Popen(cmd, stdout=PIPE, stderr=PIPE) as process:
    try:
        stdout, stderr = process.communicate(timeout=10)
    except TimeoutExpired:
        process.kill()
        stdout = process.stdout.read() # the process is dead, no deadlock
        stderr = process.stderr.read()
</code></pre>
<p>On Python 3.5, you could use <code>subprocess.run()</code>:</p>
<pre><code>import subprocess
from subprocess import PIPE, TimeoutExpired

try:
    result = subprocess.run(cmd, timeout=10, stdout=PIPE, stderr=PIPE)
except TimeoutExpired as e:
    result = e
stdout, stderr = result.stdout, result.stderr
</code></pre>
<p>Though it handles <code>TimeoutExpired</code> the same way as your code and therefore you can get <code>ValueError</code> anyway. If you get <code>ValueError</code> with this code; report the issue at <a href="http://bugs.python.org" rel="nofollow">http://bugs.python.org</a></p>
</div>
<div class="post-text" itemprop="text">
<h2>Improved Answer</h2>
<p>Using an empty bytes object as return values for <code>stdout</code> and <code>stderr</code> could be a solution. <code>my_process.communicate()</code> reads the pipes for you. So better not to use a file objects here:</p>
<pre><code>try:
    my_process = Popen(someargs, stdin=None, stdout=PIPE, stderr=PIPE)
    stdout, stderr = my_process.communicate(timeout=10)
    my_process.wait()
except TimeoutExpired:
    my_process.kill()
    try:
        stdout, stderr = my_process.communicate()
    except ValueError:
        stdout = b''
        stderr = b''
</code></pre>
<h2>Original Answer</h2>
<p>Creating empty file objects for <code>stdout</code> and <code>stderr</code> could be a solution:</p>
<pre><code>import io

try:
    my_process = Popen(someargs, stdin=None, stdout=PIPE, stderr=PIPE)
    stdout, stderr = my_process.communicate(timeout=10)
    my_process.wait()
except TimeoutExpired:
    my_process.kill()
    try:
        stdout, stderr = my_process.communicate()
    except ValueError:
        stdout = io.BytesIO()
        stderr = io.BytesIO()
</code></pre>
</div>
<span class="comment-copy">are you using multiple threads? Otherwise, it looks like a bug. Could you create a dummy <code>child.py</code> to pass in <code>someargs</code>, to reproduce the issue?</span>
<span class="comment-copy">Here's the code to reproduce this issue in 3.6.0:  `    import subprocess     import time          po = subprocess.Popen(['/bin/ls'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)     time.sleep(1)     out, err = po.communicate(timeout=1)     out, err = po.communicate(timeout=1)`</span>
<span class="comment-copy">Very interesting. Did not know about the improvements in Python 3.5.</span>
<span class="comment-copy">Mike, won't that discard any information retrieved into those buffers during the "try" block?</span>
<span class="comment-copy">you should use <code>stdout, stderr = b'', b''</code>, not <code>io.BytesIO()</code>.</span>
<span class="comment-copy">Thanks for the hint. Added an improvement.</span>
