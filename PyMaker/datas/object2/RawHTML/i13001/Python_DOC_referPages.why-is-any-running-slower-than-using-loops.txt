<div class="post-text" itemprop="text">
<p>I've been working in a project that manages big lists of words and pass them trough a lot of tests to validate or not each word of the list. The funny thing is that each time that I've used "faster" tools like the <code>itertools</code> module, they seem to be slower.</p>
<p>Finally I decided to ask the question because it is possible that I be doing something wrong. The following code will try to test the performance of the <code>any()</code> function versus the use of loops.</p>
<pre><code>#!/usr/bin/python3
#

import time
from unicodedata import normalize


file_path='./tests'


start=time.time()
with open(file_path, encoding='utf-8', mode='rt') as f:
    tests_list=f.read()
print('File reading done in {} seconds'.format(time.time() - start))

start=time.time()
tests_list=[line.strip() for line in normalize('NFC',tests_list).splitlines()]
print('String formalization, and list strip done in {} seconds'.format(time.time()-start))
print('{} strings'.format(len(tests_list)))


unallowed_combinations=['ab','ac','ad','ae','af','ag','ah','ai','af','ax',
                        'ae','rt','rz','bt','du','iz','ip','uy','io','ik',
                        'il','iw','ww','wp']


def combination_is_valid(string):
    if any(combination in string for combination in unallowed_combinations):
        return False

    return True


def combination_is_valid2(string):
    for combination in unallowed_combinations:
        if combination in string:
            return False

    return True


print('Testing the performance of any()')

start=time.time()
for string in tests_list:
    combination_is_valid(string)
print('combination_is_valid ended in {} seconds'.format(time.time()-start))


start=time.time()
for string in tests_list:
    combination_is_valid2(string)
print('combination_is_valid2 ended in {} seconds'.format(time.time()-start))  
</code></pre>
<p>The previous code is pretty representative of the kind of tests I do, and if we take a look to the results:</p>
<pre><code>File reading done in 0.22988605499267578 seconds
String formalization, and list strip done in 6.803032875061035 seconds
38709922 strings
Testing the performance of any()
combination_is_valid ended in 80.74802565574646 seconds
combination_is_valid2 ended in 41.69514226913452 seconds


File reading done in 0.24268722534179688 seconds
String formalization, and list strip done in 6.720442771911621 seconds
38709922 strings
Testing the performance of any()
combination_is_valid ended in 79.05265760421753 seconds
combination_is_valid2 ended in 42.24800777435303 seconds
</code></pre>
<p>I find kinda amazing that using loops is half faster than using <code>any()</code>. What would be the explanation for that? Am I doing something wrong?</p>
<p>(I used python3.4 under GNU-Linux)</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually the <a href="https://docs.python.org/3/library/functions.html?highlight=enumerate#any" rel="nofollow"><code>any()</code></a> function is equal to following function :</p>
<pre><code>def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
</code></pre>
<p>which is like your second function, but since the <code>any()</code> returns a boolean value by itself, you don't need to check for the result and then return a new value, So the difference of performance is because of that you are actually use a redundant return and <code>if</code> conditions,also calling the <code>any</code> inside another function.</p>
<p>So the advantage of <code>any</code> here is that you don't need to wrap it with another function because it does all the things for you.</p>
<p>Also as @interjay mentioned in comment it seems that the most important reason which I missed is that you are passing a generator expression to <code>any()</code> which doesn't provide the results at once and since it produce the result on demand it does an extra job.</p>
<p>Based on <a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow">PEP 0289 -- Generator Expressions</a></p>
<blockquote>
<p>The semantics of a generator expression are equivalent to creating an anonymous generator function and calling it. For example:</p>
</blockquote>
<pre><code>g = (x**2 for x in range(10))
print g.next()
</code></pre>
<p>is equivalent to:</p>
<pre><code>def __gen(exp):
    for x in exp:
        yield x**2
g = __gen(iter(range(10)))
print g.next()
</code></pre>
<p>So as you can see each time that python want to access the next item it calls the <code>iter</code> function and the <code>next</code> method of a generator.And finally the result is that it's overkill to use <code>any()</code> in such cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since your true question is answered, I'll take a shot at the implied question:</p>
<p>You can get a free speed boost by just doing <code>unallowed_combinations = sorted(set(unallowed_combinations))</code>, since it contains duplicates.</p>
<p>Given that, the fastest way I know of doing this is</p>
<pre><code>valid3_re = re.compile("|".join(map(re.escape, unallowed_combinations)))

def combination_is_valid3(string):
    return not valid3_re.search(string)
</code></pre>
<p>With CPython 3.5 I get, for some test data with a line length of 60 characters,</p>
<pre><code>combination_is_valid ended in 3.3051061630249023 seconds
combination_is_valid2 ended in 2.216959238052368 seconds
combination_is_valid3 ended in 1.4767844676971436 seconds
</code></pre>
<p>where the third is the regex version, and on PyPy3 I get</p>
<pre><code>combination_is_valid ended in 2.2926249504089355 seconds
combination_is_valid2 ended in 2.0935239791870117 seconds
combination_is_valid3 ended in 0.14300894737243652 seconds
</code></pre>
<p>FWIW, this is competitive with Rust (a low-level language, like C++) and actually noticeably wins out on the regex side. Shorter strings favour PyPy over CPython a lot more (eg. 4x CPython for a line length of 10) since overhead is more important then.</p>
<p>Since only about a third of CPython's regex runtime is loop overhead, we conclude that PyPy's regex implementation is better optimized for this use-case. I'd recommend looking to see if there is a CPython regex implementation that makes this competitive with PyPy.</p>
</div>
<span class="comment-copy">Does your test vector include any strings that would return <code>True</code>?</span>
<span class="comment-copy">It's probably because the generator expression provides a level of indirection over the loop, which slows things down.</span>
<span class="comment-copy">Regarding what you say about the loop exiting early: <code>any</code> also exits early (only iterating until a true value), so that isn't the difference.</span>
<span class="comment-copy">The effects of a single additional <code>if</code> would be negligible compared to the loop. A much bigger difference is that the <code>any</code> version uses a generator expression.</span>
<span class="comment-copy">@interjay It's not because of <code>if</code> as I said it's because of extra function call and the condition. But the generator expression would also be a reason, but not much.</span>
<span class="comment-copy">The loop does a lot of work, looking for multiple substrings. It's very unlikely that an additional function call and <code>if</code> would double the time it takes.</span>
<span class="comment-copy">@interjay Yep. I see. thanks for attention, I just update the answer with your hint.</span>
<span class="comment-copy">@rsm Yes, now you can checkout the edit.</span>
<span class="comment-copy">The duplicated values over the unallowed_combinations list was a mistake I did when typing the test, but thanks so much for your answer!! My benchmark was... <code>22.354313850402832 seconds</code></span>
