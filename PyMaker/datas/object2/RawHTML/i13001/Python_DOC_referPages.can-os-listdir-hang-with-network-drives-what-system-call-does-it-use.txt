<div class="post-text" itemprop="text">
<p>What system call does os.listdir internally perform and is there a possiblity of Python process hanging because of a scenario where <code>os.listdir</code> is over a mounted network drive? </p>
<p>We are suspecting a problem in our app server because of <code>os.listdir</code> which tries to list a samba share mounted on to a linux machine. Apparently DNS of the samba share had changed round about the time we had this issue. We are still trying to replicate this scenario, but can anyone tell me how would it work? And also would commands like <code>ls</code> also hang like this?</p>
<p>Are there any ways we could handle this at user-space?</p>
</div>
<div class="post-text" itemprop="text">
<p>CPython's <a href="https://github.com/python/cpython/blob/0ef0398dcfcbf0ddde13625149ba7065fd1b3833/Modules/posixmodule.c#L2287" rel="nofollow noreferrer">implementation of <code>os.listdir</code></a> uses platform-specific C library calls to read the contents of a directory. On Unix-like platforms those are <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html" rel="nofollow noreferrer"><code>opendir(3)</code></a> and <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir.html" rel="nofollow noreferrer"><code>readdir(3)</code></a>, and on Windows it uses <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85).aspx" rel="nofollow noreferrer"><code>FindFirstFile</code></a> and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85).aspx" rel="nofollow noreferrer"><code>FindNextFile</code></a>.</p>
<p>How these calls behave in the presence of unreachable network file systems will depend on the operating system. When using Linux or Windows, they are certain to hang in those situations in which system commands such as <code>ls</code> hang. To prevent arbitrarily long pauses, one can use specialized frameworks, such as <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a> and <a href="https://twistedmatrix.com/trac/" rel="nofollow noreferrer">twisted</a> which make use of non-blocking IO. The use of these frameworks can be daunting, though, and typically requires using them throughout the application and the whole program to event-driven model.</p>
<p>A simpler and somewhat beginner-friendly way to make sure IO system calls don't block in presence of network file systems is to use threads. As an example, here is a <code>safe_listdir</code> function that returns the directory contents, or <code>None</code> if the call took longer than a specified timeout:</p>
<pre><code>import os, threading

def safe_listdir(directory, timeout):
    contents = []
    t = threading.Thread(target=lambda: contents.extend(os.listdir(directory)))
    t.daemon = True  # don't delay program's exit
    t.start()
    t.join(timeout)
    if t.is_alive():
        return None  # timeout
    return contents
</code></pre>
<p>In Python 3 one could use the excellent <code>concurrent.futures</code> package. It not only simplifies the implementation, it automatically limits the number of created threads if <code>safe_listdir</code> is called many times, and ensures that exceptions raised in <code>os.listdir</code> are correctly propagated to the caller:</p>
<pre><code>import os, concurrent.futures
pool = concurrent.futures.ThreadPoolExecutor()

def safe_listdir(directory, timeout):
    future = pool.submit(os.listdir, directory)
    try:
        return future.result(timeout)
    except concurrent.futures.TimeoutError:
        return None  # timeout
</code></pre>
</div>
<span class="comment-copy">Is there a way we can handle these things without modifying the kernel implementation? Something like a time-out would that not make sense?</span>
<span class="comment-copy">Brilliant, I haven't used threads much. But this is a good example to learn those concepts. Will go through the example. Its someting like seperating the "network connectivity check" from the real Python or something in that essense.</span>
<span class="comment-copy">@Nishant Edited the answer to remove the "dead" management. It turns out that Python threads don't need to be successfully "joined" to clean up after themselves.</span>
