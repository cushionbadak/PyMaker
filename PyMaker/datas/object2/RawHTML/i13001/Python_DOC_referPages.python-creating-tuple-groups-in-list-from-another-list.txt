<div class="post-text" itemprop="text">
<p>Let's say I have this data:</p>
<pre><code>data = [1, 2, 3, -4, -5, 3, 2, 4, -2, 5, 6, -5, -1, 1]
</code></pre>
<p>I need it to be grouped in another list by tuples. One tuple consists of two lists. One for positive numbers, another for negative. And tuples should be created by checking what kind of number it is. Last negative number (I mean in a row that between negative numbers there were no positive ones) means, other numbers must go into another tuple and when it finds another last negative number, it should create another tuple.</p>
<p>So rules are these: All found numbers are being added into first tuple, when it finds negative number, it still adds it to that tuple, till it finds positive number (it means new tuple must be created).</p>
<p>I think it is easier to show, than to explain. After parsing <code>data</code>, the list should look like this:</p>
<pre><code>l = [([1, 2, 3], [-4, -5]), ([3, 2, 4], [-2]), ([5, 6], [-5, -1]), ([1], [])]
</code></pre>
<p>I created a solution, but I wonder if it's quite optimal. Maybe it is possible to write a more elegant one (and I wonder about performance, is there some better way to write such parser with best possible performance:))?</p>
<pre><code>def neighborhood(iterable):
    iterator = iter(iterable)
    prev = None
    item = iterator.next()  # throws StopIteration if empty.
    for next in iterator:
        yield (prev,item,next)
        prev = item
        item = next
    yield (prev,item,None)

l = []    
pos = []
neg = []
for prev, item, next in neighborhood(data):
    if item &gt; 0:
        pos.append(item)
        if not next:
            l.append((pos, neg))
    else:
        neg.append(item)
        if next &gt; 0:
            l.append((pos, neg))
            pos = []
            neg = []
        elif not next:
            l.append((pos, neg))

print l
</code></pre>
<p>P.S. <code>if not next</code> part I think can be used only once after main check.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to make a list of consecutive tuples containing positive/negative lists first, and then group into consecutive pairs. This can still be done in one pass through the list by taking advantage of generators:</p>
<pre><code>from itertools import groupby, zip_longest

x = (list(v) for k,v in groupby(data, lambda x: x &lt; 0))
l = list(zip_longest(x, x, fillvalue=[]))
</code></pre>
<p>This gives <code>l</code> as:</p>
<pre><code>[([1, 2, 3], [-4, -5]), ([3, 2, 4], [-2]), ([5, 6], [-5, -1]), ([1], [])]
</code></pre>
<p>A couple of notes on the code above:</p>
<ul>
<li><p>The initial grouping into positive/negative values is handed to <code>groupby</code> which should be reasonably performant (it's compiled code).</p></li>
<li><p>The zipping-a-generator method for grouping into pairs is a reasonably common idiom in Python. It's guaranteed to work since <code>zip</code> guarantees than an iterable is consumed from left to right.</p></li>
<li><p>In Python 2, use <code>izip_longest</code>.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You could go with <code>O(n)</code> solution which is much less beautiful than @ajcr one but should be more efficient.</p>
<pre><code>def pos_neg(data):
  split = []
  for r in data:
    if len(split) == 0 or (r &gt; 0 and len(split[-1][-1]) &gt; 0):
      split.append(([], []))

    if r &lt; 0:
      split[-1][-1].append(r)
    else:
      split[-1][-2].append(r)

  return split

data = [1, 2, 3, -4, -5, 3, 2, 4, -2, 5, 6, -5, -1, 1]
print pos_neg(data)
#=&gt; [([1, 2, 3], [-4, -5]), ([3, 2, 4], [-2]), ([5, 6], [-5, -1]), ([1], [])]
</code></pre>
</div>
<span class="comment-copy">Lots of magic in there. Very interesting use of a single iterator fed twice to zip.</span>
<span class="comment-copy">Looks interesting. Also I tested performance and this one seems to be faster than mine. Of course this sample data is very small, but still. My solution finishes in: <code>~0.33 milliseconds</code> and yours in <code>~0.03 milliseconds</code></span>
<span class="comment-copy">Perhaps you should add this quote from the <code>zip</code> documentation, that makes the code correct: <i>“The left-to-right evaluation order of the iterables is guaranteed.”</i></span>
<span class="comment-copy">Thanks @spectras, added a few notes.</span>
<span class="comment-copy">@Andrius: I just realised the code could be made even simpler using <code>zip_longest</code>. It should run just as fast as the previous method but now avoids building a temporary list first (so is more memory efficient).</span>
<span class="comment-copy">Hm, I tested time between all solutions. Yours solution seems to take something similar time to mine. So at least on this sample <code>data</code>, @ajcr solution is much faster.</span>
<span class="comment-copy">@Andrius it is pretty strange, because my benchmarks shows that ajcr solution is as twice as slower</span>
<span class="comment-copy">@Andrius timeit showed 7.99484586716 sec vs 16.8815200329 sec</span>
<span class="comment-copy">You are right. I tested with random data and your solution is faster. For some reason my sample data (in question) runs faster on ajcr solution. I guess that one scales worse.</span>
<span class="comment-copy">I tried with sample data from the question as well and it was faster as well :)</span>
