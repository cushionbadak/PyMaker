<div class="post-text" itemprop="text">
<p>Let's say we have <em>list of numbers</em> and we want to multiply all numbers in it as long as product is digit.</p>
<p>For Example:</p>
<pre><code>[2,2,5] =&gt; [4,5]

[3,3,7] =&gt; [9,7]

[5,5,5,5,5] =&gt; [5,5,5,5,5]
</code></pre>
<p>Can I somehow use <code>functools.reduce</code> here? What's pythonic way to solve this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be solved easily by a simple stateful algorithm:</p>
<pre><code>def multiply_digits(lst):
    res = []
    for x in lst:
        if res and res[-1] * x &lt; 10:
            res[-1] *= x
        else:
            res.append(x)
    return res
</code></pre>
<p>While there is an equivalent functional way (with <code>reduce</code>), that will not be as simple since you either need to reassemble the result list in each step, or carry the current number value separately.</p>
</div>
<div class="post-text" itemprop="text">
<p>This might do the trick:</p>
<pre><code>def process(lst):
    lst = sorted(lst)
    last = 1
    result = []
    for el in lst:
        if last * el &gt;= 10:
            result.append(last)
            last = el
            continue
        last *= el
    result.append(last)
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is better I guess:</p>
<pre><code>from numpy import product
reduce(lambda x , y : (x[0:-1]+[y*x[-1]] if product(x+[y])&lt;10 else x+[y]) if len(x)&gt;0 else [y]  ,[21,1,2,3,4,5,6],[])
</code></pre>
</div>
<span class="comment-copy">can you explain how you are getting those outputs</span>
<span class="comment-copy">what if there is a zero?</span>
<span class="comment-copy">I think OP means, as long as product is <b>single</b> digit.</span>
<span class="comment-copy">what is the output of <code>[21,2,2,1]</code>?</span>
<span class="comment-copy">What about <code>[21, 2, 2, 21, 2]</code>, i.e. do the numbers to be multiply have to be adjacent?</span>
<span class="comment-copy">What if I'd have input [3, 2, 2, 2, 2, 2, 2, 2, 2, 2] and expect to get [3,8,8,8] and not [4,6,8,8] (so after join, I'd get smallest possible number, 3888 &lt; 4688)?</span>
<span class="comment-copy">@Adiqq That's far more complex and out of scope for this question. You can try to go from the back (using <a href="https://docs.python.org/3/library/functions.html#reversed" rel="nofollow noreferrer"><code>reversed</code></a> in Python), but you probably need a clever algorithm (or just brute force all possibilities) to find the number which yields the smallest result.</span>
<span class="comment-copy">why sort the list?</span>
<span class="comment-copy">@DanielSanchez I assume that the order of numbers dosn't matter, i.e. we just won't reduce possible combinations. In case of phihag's answer the order matters, e.g. <code>[21, 2, 2, 1]</code> and <code>[2, 21, 2, 1]</code>.</span>
<span class="comment-copy">This code just checks n-1 digits. It returns wrong results wrong for almost all inputs. For instance, I'd expect <code>[9, 2, 2] =&gt; [9, 4]</code>, <code>[8]</code> =&gt; <code>[8]</code>, <code>[2, 2, 3, 3] =&gt; [4,9]</code> .</span>
<span class="comment-copy">Now check it again . Does that work.</span>
<span class="comment-copy">No, it still fails the very first test I gave (<code>[9, 2, 2] =&gt; [9, 4]</code>). Plus, the updated version is horrendously inefficient, given it constantly constructs lists and calls <code>numpy.product</code> for a single multiplication.</span>
