<div class="post-text" itemprop="text">
<p>I have a situation, in which I'm parsing a file and collecting stats. I want to store those stats in nested dict which has a final value as a list. And as I process the file I want to expand the list.</p>
<p>for instance my dict structure is something like this </p>
<pre><code>data_dict 
    { "aa1" :
         { 'aa' : []}
         { 'bb' : [] }
     "aa2" : 
         { 'ab' : []}
         { 'ba' : [] }
    }
</code></pre>
<p>Now as I parse the file I want to append the value to the last list
for instance, in first occurrence of data my dict should look like this.</p>
<pre><code>data_dict 
    { "aa1" :
         { 'aa' : ['a0']}
         { 'bb' : ['a1'] }
     "aa2" : 
         { 'ab' : ['b0']}
         { 'ba' : ['b1'] }
    }
</code></pre>
<p>and in second something like this </p>
<pre><code>data_dict 
    { "aa1" :
         { 'aa' : ['a0', 'a01']}
         { 'bb' : ['a1', 'a11'] }
     "aa2" : 
         { 'ab' : ['b0', 'b01']}
         { 'ba' : ['b1', 'b11'] }
    }
</code></pre>
<p>Also I'm not initializing dict keys to anything and creating keys at the first occurrence of the match. Can anyone suggest how do I achieve this?</p>
<p>Note I'm using autovivification for initializing my data_dict, which at first doesn't contain anything.</p>
<p>This is sample data I'm trying to parse</p>
<pre><code>DATETIME TYPE TAG  COUNT MEAN 1% 10% 20% 30% 40% 50% 60% 70% 80% 90% 99% 
20151109044056 LS_I aa8 57     80,493,122      8,931,000      8,937,000      8,944,000      8,974,000      9,073,000     21,262,000     28,419,000     35,794,000    148,920,000    316,408,000    447,902,000 
    20151109044056 LS_I aa0 6,893      9,008,024      8,862,000      8,913,000      8,941,000      8,964,000      8,984,000      9,006,000      9,028,000      9,049,000      9,071,000      9,102,000      9,170,000 
    20151109044056 LS_I aa1 6,062      9,018,094      8,867,000      8,913,000      8,938,000      8,961,000      8,983,000      9,003,000      9,025,000      9,048,000      9,071,000      9,103,000      9,175,000 
    20151109044056 LS_I aa2 2,776      9,030,621      8,929,000      8,967,000      8,987,000      8,999,000      9,012,000      9,024,000      9,037,000      9,050,000      9,065,000      9,087,000      9,161,000 
    20151109044056 LS_I aa3 1,074      9,028,744      8,925,000      8,970,000      8,988,000      9,002,000      9,016,000      9,026,000      9,039,000      9,051,000      9,067,000      9,089,000      9,138,000 
    20151109044056 LS_I aa4 6,060      9,003,651      8,874,000      8,935,000      8,958,000      8,976,000      8,991,000      9,005,000      9,019,000      9,033,000      9,049,000      9,071,000      9,121,000 
    20151109044056 LS_I aa5 5,453      9,003,993      8,874,000      8,936,000      8,959,000      8,976,000      8,991,000      9,004,000      9,018,000      9,032,000      9,048,000      9,071,000      9,126,000 
    20151109044056 LS_I aa6 16,384            328            111            165            190            208            227            253            301            362            434            551            997 
    20151109044056 LS_I aa7 16,384            316             58             65             70             76             87            137            308            395            512            702          1,562 
</code></pre>
<p>so my dict has first key as Tag column, second key as one of the %column and then the value of this key is all the instances of that value in complete file.</p>
<p>This is my processing code, which is not working.</p>
<pre><code>            while re.match("\d{14}\s.*", curr_line):

                lat_data = curr_line.split()
                tag = lat_data[header.index("TAG")]
                for item in range(len(header)):
                    col = header[item]

                    if '%' in col or\
                       "COUNT" in col or\
                       "MEAN" in col:
                        self.data_dict[tag][col].append(lat_data[item])
                curr_line = lat_file.next()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First off: <code>has_key</code> has been deprecated for ages (gone in Py3); you can use direct <code>in</code> checks. Secondly, what you were trying to do with <code>has_key</code> is nonsensical <code>[tag][col]</code> is not legal syntax without something to index (without indexing/looking up something, it looks like two back to back single element <code>list</code> literals, which isn't legal syntax). The fix for the test is to test for each component individually (after which you can append, since you know the value exists):</p>
<pre><code>if tag in self.data_dict and col in self.data_dict[tag]:
    self.data_dict[tag][col].append(whatever_you_want_to_append)
</code></pre>
<p>Side-note: You almost never want <code>for i in range(len(something)):</code>; that's a symptom of coming from a C-style <code>for</code> loop background. You're not actually using the index for anything besides getting the value, so replace:</p>
<pre><code>for item in range(len(header)):
    col = header[item]
</code></pre>
<p>with:</p>
<pre><code>for col in header:
</code></pre>
<p>Runs faster, more idiomatically, etc. If you need the index too for some reason, that's what <code>enumerate</code> is for:</p>
<pre><code>for i, col in enumerate(header):
</code></pre>
<p><strong>UPDATE</strong>: You updated the question with more info, so it looks like you need to iterate <code>lat_data</code> in parallel. In that case, do:</p>
<pre><code>for col, lat in zip(header, lat_data):
    ...

        if tag in self.data_dict and col in self.data_dict[tag]:
            self.data_dict[tag][col].append(lat)
</code></pre>
</div>
<span class="comment-copy">More information needed. What are 1,2? Are they line numbers? when value will be added to 'a' and when to 'b'?</span>
<span class="comment-copy">no, they are just key. I used as dummy variable. I made changes to make it more clear</span>
<span class="comment-copy">See <a href="http://stackoverflow.com/questions/4143698/create-or-append-to-a-list-in-a-dictionary-can-this-be-shortened" title="create or append to a list in a dictionary can this be shortened">stackoverflow.com/questions/4143698/…</a> or <a href="http://stackoverflow.com/questions/960733/python-creating-a-dictionary-of-lists" title="python creating a dictionary of lists">stackoverflow.com/questions/960733/…</a> on how to either use a defaultdict or the setdefault method</span>
<span class="comment-copy">As it stands, your example is not valid Python. I'm guessing that you meant <code>"aa1"</code>, not <code>aa1</code>, for example, and that each value is a single dictionary, not a list of dictionaries. Right? Could you clarify? That said, you probably want to take a look at <a href="http://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>.</span>
<span class="comment-copy">@TimPietzcker  I'm not sure how a defaultdict will be able to help, as my dict is a nested dict.</span>
