<div class="post-text" itemprop="text">
<h1>EDIT: I added the class and some info, see the new post.</h1>
<p>I have created a class that extends <code>dict</code> and <code>set</code> (more exactly, I extended <code>collections.abc.MutableMapping</code> and <code>MutableSet</code>). Now I want to properly override the method <code>keys()</code>. </p>
<p>This class represents a set of other objects, called <code>Measurand</code>:</p>
<pre><code>class Measurands(MutableSet, MutableMapping):
    @property
    def measurands(self):
        return self._measurands


    @measurands.setter
    def measurands(self, val):
        self._measurands = []

        for el in val:
            self.add(el)


    def __init__(self, arg=None):
        if arg is None:
            self.measurands = []
        else:
            try:
                measurands = arg.measurands
            except AttributeError:
                if isinstance(arg, Iterable):
                    measurands = list(arg)
                else:
                    measurands = [arg]

            self.measurands = measurands


    def __iter__(self):
        return iter(self.measurands)


    def __getitem__(self, key):
        for m in self:
            if m.id == key:
                return m

        raise KeyError(key)


    def __contains__(self, el_x):
        is_in = False

        for el in self:
            if el_x.id == el.id:
                is_in = True
                break

        return is_in


    def add(self, el):
        try:
            self[el.id].session_ids |= el.session_ids
        except KeyError:
            self[el.id] = Measurand(el)


    def _discard(self, key):
        res = False

        for i, m in enumerate(self):
            if m.id == key:
                del self.measurands[i]
                res = True
                break

        return res


    def __delitem__(self, key):
        res = self._discard(self, key)

        if not res:
            raise KeyError(key)

    def discard(self, key):
        self._discard(self, key)


    def remove(self, key):
        self.__delitem__(self, key)


    def __len__(self):
        return len(self.measurands)


    def __setitem__(self, key, value):
        res = False
        value_true = Measurand(value)

        for i, m in enumerate(self):
            if m.id == key:
                res = True

                if value.id == key:
                    self.measurands[i] = value_true
                else:
                    raise KeyError(key)

                break

        if not res:
            self.measurands.append(value_true)


    def __str__(self):
        string = "Measurands({"

        for m in self:
            string += str(m)
            string += ", "

        if string:
            string = string[:-2]

        string += "})"

        return string
</code></pre>
<p>The problem is the default method <code>keys</code> returns a "list" of <code>Measurand</code> objects. This is not what I want. The keys should be the property <code>id</code> of the <code>Measurand</code> objects.</p>
<p>For now I'm returning a simple <code>list</code>, but I would return a <code>dict_keys</code> or a <code>collection.abc.KeysView</code> object. Unluckily, <code>dict_keys</code> is not a global name. </p>
<ol>
<li>Where is <code>dict_keys</code>?</li>
<li>Is this the correct/pythonic way to do it?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>This is already handled for you! <code>collections.abc.MutableMapping</code> includes a reasonable default implementation of <code>keys</code> that provides the same interface as <code>dict.keys</code>.</p>
<p>Simply delete your <code>keys</code> method, and you'll be using the inherited implementation.</p>
</div>
<div class="post-text" itemprop="text">
<p>I haven't been able to find any way to cast something to the <code>dict_keys</code> type, but after reading the PEP that introduced the new way to access keys and values (<a href="https://www.python.org/dev/peps/pep-3106/" rel="nofollow">PEP 3106</a>), it looks like <code>dict_keys</code> was introduced to </p>
<blockquote>
<p>return a set-like or unordered container object whose contents are derived from the underlying dictionary rather than a list which is a copy of the keys, etc.</p>
</blockquote>
<p>Taking this into account, it looks like you could get away with returning a generator object with your <code>keys()</code> method instead of a list. </p>
<p>Here is the pseudo-code from the PEP:</p>
<pre><code>class dict:

    # Omitting all other dict methods for brevity.

    def keys(self):
        return d_keys(self)

class d_keys:

    def __init__(self, d):
        self.__d = d

    def __len__(self):
        return len(self.__d)

    def __contains__(self, key):
        return key in self.__d

    def __iter__(self):
        for key in self.__d:
            yield key
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The Python3 documentation says that <code>dict.keys()</code> return value type (i.e. a view) is "set-like", so your return value should be "set-like" as well.</p>
<blockquote>
<p>The objects returned by dict.keys(), dict.values() and dict.items()
  are view objects. They provide a dynamic view on the dictionaryâ€™s
  entries, which means that when the dictionary changes, the view
  reflects these changes.</p>
<p>Dictionary views can be iterated over to yield their
  respective data, and support membership tests:</p>
<p>....</p>
<p>Keys views are set-like since their entries are unique and hashable.
  If all values are hashable, so that (key, value) pairs are unique and
  hashable, then the items view is also set-like. (Values views are not
  treated as set-like since the entries are generally not unique.) For
  set-like views, all of the operations defined for the abstract base
  class collections.abc.Set are available (for example, ==, &lt;, or ^).</p>
</blockquote>
<p>Full text here:
<a href="https://docs.python.org/3/library/stdtypes.html#dict-views" rel="nofollow">https://docs.python.org/3/library/stdtypes.html#dict-views</a></p>
</div>
<span class="comment-copy"><i>"I want to properly override the method <code>dict()</code>"</i> - what? <code>dict</code> isn't a method. Do you mean you want to be able to do <code>dict(instance_of_your_thing)</code>? Could you give a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> of your implementation and explain the problem with an example?</span>
<span class="comment-copy">Judging from the title, I think he meant he wants to properly override <code>keys()</code> and made a typo in the actual question</span>
<span class="comment-copy">@wilbur ah! That would make more sense. OP?</span>
<span class="comment-copy">Well, I missed to report some useful info. See the updated question.</span>
<span class="comment-copy">@MarcoSulla: It's not returning a list of Measurands. You've screwed up your <code>__iter__</code>; it's iterating over values instead of keys. Fix that, and the inherited <code>keys</code> implementation will work.</span>
<span class="comment-copy"><code>__iter__</code> is correct. If I do <code>for m in mm</code> where <code>mm</code> is a <code>Measurands</code> object, I want that <code>m</code> is the i-th <code>Measurand</code> object, not its id. If you notice, the <code>Measurand</code> class is a mix of <code>set</code> and <code>dict</code> that I created because you can't do a <code>set</code> of unhashable objects.</span>
<span class="comment-copy">@MarcoSulla: That's a violation of the mapping API, and if you're not going to follow the API, you shouldn't bother with <code>keys</code>, <code>values</code>, or <code>items</code>. They'll just cause confusion.</span>
<span class="comment-copy">Not sure that it's a violation. Since I'm extending also <code>set</code>, I'm following the behaviour of <code>__iter__</code> of the <code>set</code> interface.</span>
