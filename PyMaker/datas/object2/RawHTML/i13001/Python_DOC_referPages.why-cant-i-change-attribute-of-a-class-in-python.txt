<div class="post-text" itemprop="text">
<p>We say <code>classes</code> are mutable in Python which means you can using references we can change the values that will be reflected in object. For example,</p>
<pre><code>&gt;&gt;&gt; A = [1, 2, 3]
&gt;&gt;&gt; B = A
&gt;&gt;&gt; B[2] = 5
&gt;&gt;&gt; A
[1, 2, 5]
</code></pre>
<p>Here I can change the values of <code>A</code> object using <code>B</code> because <code>list</code> is a mutable type. My question is why can't I change the attributes of a class below using same concept:</p>
<pre><code>class C:

    apple = 2

    def __init__(self):
        self.dangerous = 2

D = C # D is pointing to same class C

D().dangerous = 5 # changing the value of class attribute D

D().apple = 3 # changing the value of apple here

print D().apple

print D().dangerous

OUTPUT:
2
2
</code></pre>
<p>Could anyone explain why the output is <code>2</code> and <code>2</code> but not <code>3</code> and <code>5</code> since we are saying that the class is a <code>mutable</code> type.</p>
<p>UPDATE : Referring to the answer by @zxq9, if you see the below diagram when do <code>D=C</code>, <code>D</code> is actually pointing to the same class rather a new object as you have described. Could you explain this:</p>
<p><a href="https://i.stack.imgur.com/fzG2z.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/fzG2z.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Each time you place parens after a class, you are constructing a <em>new instance object of the class</em>. So the things you printed were brand-spanking new and did not reflect the short-lived assignments you had made previously.</p>
<p>Here is an example (expanded to cover the underlying reference to class C):</p>
<pre><code>&gt;&gt;&gt; class C:
...   red = 2
...   def __init__(self):
...     self.blue = 2
... 
&gt;&gt;&gt; C.red
2
&gt;&gt;&gt; C.blue
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: type object 'C' has no attribute 'blue'
&gt;&gt;&gt; C().red
2
&gt;&gt;&gt; C().blue
2
&gt;&gt;&gt; #OOOOH!
... 
&gt;&gt;&gt; z = C()
&gt;&gt;&gt; z.red
2
&gt;&gt;&gt; z.blue
2
&gt;&gt;&gt; D = C
&gt;&gt;&gt; D.red
2
&gt;&gt;&gt; D().red
2
&gt;&gt;&gt; D().red = "over 9000!"
&gt;&gt;&gt; D.red
2
&gt;&gt;&gt; D.red = "No, really over 9000!"
&gt;&gt;&gt; D.red
'No, really over 9000!'
&gt;&gt;&gt; C.red
'No, really over 9000!'
&gt;&gt;&gt; #OOOOOOHHHH!
...
</code></pre>
<p>Note that we <em>did</em> change the class directly when I assigned <code>D.red = "No, really over 9000!"</code> -- because that was referencing the <em>class definition itself</em>, not an instantiated object created from it. Note also that assigning an attribute of D (a copy) changed the attribute of C (the original) because in many (but not all) cases Python makes such assignments <em>by reference</em>, meaning that D is really an <em>alias</em> of C, not copy of the underlying structure. Read up on Python's <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">deepcopy()</a> method for more about that particularly startling detail.</p>
<p>Walk through the example code carefully, note the difference between <em>referencing</em> <code>ClassName</code> and <em>calling</em> <code>ClassName()</code>. The first is a <em>reference</em> via a variable name to a class definition -- a blueprint for generating instance objects that carries a constructor function <code>__init__()</code> with it. The second is an <em>invokation</em> of <code>__init__()</code> whose return value is an instance object of the class within which it is defined.</p>
<p>This is also why you can do things like this:</p>
<pre><code>def some_fun(another_fun, value):
    another_fun(value)

def foo(v):
    return v + v

def bar(v):
    return v * v

some_fun(foo, 5)
some_fun(bar, 5)
</code></pre>
<p>This feature lends Python a high degree of flexibility in building functional abstractions. (Now if only it had tail-call elimination...)</p>
</div>
<div class="post-text" itemprop="text">
<p>It is an interesting example. </p>
<ol>
<li>The line <strong>D().dangerous = 5</strong> will change the attribute "dangerous" of the instance <strong>D()</strong>; But the line <strong>print D().dangerous</strong> print out the attribute "dangerous" of <strong>ANOTHER</strong> instance <strong>D()</strong>.</li>
<li>The line <strong>D().apple = 3</strong> will <strong>create</strong> an attribute "apple" in the instance <strong>D()</strong> since this instance does not have the attribute "apple".</li>
<li>The line <strong>print D().apple</strong> will print out the attribute "apple" of the class <strong>D</strong> since the instance <strong>D()</strong> does not have the attribute "apple".</li>
<li>One way to change the attribute "apple" of the class through its instance is by using <strong>D().__class__.apple=3</strong></li>
</ol>
</div>
<span class="comment-copy">What in the world are people downvoting this for? The OP asked a pretty clear question, just didn't realize the syntactic difference between instantiated objects and class definitions.</span>
<span class="comment-copy">@zxq9 Can you see my updated pic?</span>
<span class="comment-copy">Yes, but <i>you are still only ever assigning to a temporary instance of the class</i> not the class itself. I'll toy with this and expand my answer to cover this as well. Its a <i>very</i> good thing to keep in mind with Python.</span>
<span class="comment-copy">You are awesome. Thank you :)</span>
<span class="comment-copy">Concept cleared :) Thank you</span>
