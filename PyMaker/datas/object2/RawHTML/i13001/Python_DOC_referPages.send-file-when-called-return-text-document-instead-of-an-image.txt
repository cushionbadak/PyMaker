<div class="post-text" itemprop="text">
<p>I want to send an image file from server side to client side. I am using flask framework.</p>
<p>But the problem is whenever I call the route in which <code>send_file()</code> is, the response return is an File. When I click this file <code>gedit</code> opens it with nothing in that file. That means it must be text file written.</p>
<p>I referred the flask docs for <a href="http://flask.pocoo.org/docs/0.10/api/#flask.send_file" rel="nofollow"><code>send_file()</code></a>.</p>
<p>Here is what I am doing in the code:</p>
<pre><code>@app.route('/try')
def trial():
    todown = 'https://igcdn-photos-e-a.akamaihd.net//hphotos-ak-xaf1//t51.2885-15//e35//12093691_1082288621781484_1524190206_n.jpg'  
    resp = requests.get(todown)
    return send_file(resp,mimetype="image/jpeg",attachment_filename="img.jpg",as_attachment=True)
</code></pre>
<p>Whenever I load <code>localhost:5000/try</code> a file is downloaded but not the image file that I want to download.</p>
<p>Error I am getting in my terminal is <code>AttributeError: 'Response' object has no attribute 'read' error</code>.</p>
<p>What must be the problem. Is anything missing in this above snippet?</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p><code>resp</code> is a <code>requests.models.Response</code> object, not string nor bytes:</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; todown = 'https://igcdn-photos-e-a.akamaihd.net//hphotos-ak-xaf1//t51.2885-15//e35//12093691_1082288621781484_1524190206_n.jpg'
&gt;&gt;&gt; resp = requests.get(todown)
&gt;&gt;&gt; resp
&lt;Response [200]&gt;
&gt;&gt;&gt; type(resp)
&lt;class 'requests.models.Response'&gt;
</code></pre></li>
<li><p><code>Flask.send_file()</code> <em>sends a file</em>.</p></li>
</ol>
<hr/>
<p>So first at all you need use <code>resp.content</code> to get the content of the object, it'll return bytes object (and by the way, <code>resp.text</code> return string object.
Always use <code>.content</code> if you're downloading an image, video, or other non-text things).</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; todown = 'https://igcdn-photos-e-a.akamaihd.net//hphotos-ak-xaf1//t51.2885-15//e35//12093691_1082288621781484_1524190206_n.jpg'
&gt;&gt;&gt; resp = requests.get(todown)
&gt;&gt;&gt; type(resp.content)
&lt;class 'bytes'&gt;
</code></pre>
<p>Please check <a href="http://docs.python-requests.org/en/latest/" rel="nofollow">the document</a> for more details.</p>
<hr/>
<p>Then, because <code>Flask.send_file()</code> <em>send a file</em>, so you need write the image into a file before you send it.</p>
<p>But since you don't need use this image on your server anyway, I'd suggest use <a href="https://docs.python.org/3/library/io.html#io.BytesIO" rel="nofollow"><code>io.BytesIO</code></a> in this case, then you don't need delete that image after you sent it. And note that use <a href="https://docs.python.org/3/library/io.html#io.StringIO" rel="nofollow"><code>io.StringIO</code></a> if you're sending a text file.</p>
<p>For example:</p>
<pre><code>import requests
from io import BytesIO
from flask import Flask, send_file

app = Flask(__name__)

@app.route('/')
def tria():
    todown = 'https://igcdn-photos-e-a.akamaihd.net//hphotos-ak-xaf1//t51.2885-15//e35//12093691_1082288621781484_1524190206_n.jpg'
    resp = requests.get(todown)
    return send_file(BytesIO(resp.content), mimetype="image/jpeg", attachment_filename="img2.jpg", as_attachment=True)

app.run(port=80, debug=True)
</code></pre>
<hr/>
<p>However, if you want write the image into a file and send it then, sure you can also do it. We can use <a href="https://docs.python.org/3/library/tempfile.html#tempfile.NamedTemporaryFile" rel="nofollow"><code>tempfile.NamedTemporaryFile()</code></a> to create a <em>tempfile</em> instead of just create a file to avoid rewrite your important files. </p>
<p>From the document:</p>
<blockquote>
<p>This function operates exactly as <code>TemporaryFile()</code> does, except that the file is guaranteed to have a visible name in the file system (on Unix, the directory entry is not unlinked). </p>
<p>That name can be retrieved from the <code>name</code> attribute of the file object. Whether the name can be used to open the file a second time, while the named temporary file is still open, varies across platforms (it can be so used on Unix; it cannot on Windows NT or later). If delete is true (the default), the file is deleted as soon as it is closed.</p>
<p>The returned object is always a file-like object whose <code>file</code> attribute is the underlying true file object. This file-like object can be used in a <code>with</code> statement, just like a normal file. </p>
</blockquote>
<p>For example:</p>
<pre><code>import tempfile
import requests
from flask import Flask, send_file

app = Flask(__name__)


@app.route('/')
def tria():
    todown = 'https://igcdn-photos-e-a.akamaihd.net//hphotos-ak-xaf1//t51.2885-15//e35//12093691_1082288621781484_1524190206_n.jpg'

    resp = requests.get(todown)

    with tempfile.NamedTemporaryFile() as f:  
        # create a file-like object use `NamedTemporaryFile()` and `with` 
        # as the basic usage which said in the document     

        f.write(resp.content)
        # write the content of the image into it

        return send_file(f.name, mimetype="image/jpeg",
                         attachment_filename="img2.jpg", as_attachment=True)                             
        # `f.name` is the temp file's filename

app.run(port=80, debug=True)
</code></pre>
</div>
<span class="comment-copy">Didn't you get <code>AttributeError: 'Response' object has no attribute 'read'</code> error?</span>
<span class="comment-copy">Do you need to be using <code>send_file(resp.content...)</code>?</span>
<span class="comment-copy">@SimonMᶜKenzie If I use <code>resp.content</code> same thing happens</span>
<span class="comment-copy">You explained me Like Iam5 . Very Good explanation. Thanks you</span>
<span class="comment-copy">@SurajPalwe: No problem, glad I could help :)</span>
<span class="comment-copy">I'd change the order of the two solutions. Writing the image to a file first (you'd need to delete it at some point too..) is rarely a good idea, and <b>especially</b> not with a hardcoded filename instead of file created by the <code>tempfile</code> module. That's just asking for trouble with more than one request at a time.</span>
<span class="comment-copy">Better, but I'd use this for the file instead of a hash: <a href="https://docs.python.org/2/library/tempfile.html#tempfile.NamedTemporaryFile" rel="nofollow noreferrer">docs.python.org/2/library/…</a></span>
<span class="comment-copy">Yes, avoiding disk IO always makes sense, especially for something as small as the typical image file. If you wanted to serve it many times it would be a different thing, but then you would be using something more persistent anyway...</span>
