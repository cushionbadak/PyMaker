<div class="post-text" itemprop="text">
<p>I am wondering about how Python handles the user-defined objects. So here is the scenario:</p>
<p>I have created my own class called MyClass:</p>
<pre><code>class MyClass():
  def __init__(self):
    # some code here

class MyClassContainer():
  def __init__(self):
    self.container = [] # will store MyClass object instances.
  def Add(self, object):
    self.container.append(object)
  def Remove(self, object):
    self.container.remove(object)

example = MyClassContainer()

myclass1 = MyClass()
example.Add(myclass1)

myclass2 = MyClass()
example.Add(myclass2)

example.Remove(myclass1)
</code></pre>
<p>So the question, is python's remove function able to distinguish different object instances of the same class? Is there any corner case that will not uniquely identify the object instance I wanted to delete?</p>
<p>A possible scenario is this one:</p>
<pre><code>myclass1 = MyClass(5)
example.Add(myclass1)

myclass1 = MyClass(3)
example.Add(myclass1)

example.Remove(myclass1)
</code></pre>
<p>Which object instance will be removed? I guess the one with 3 passed, but is there a rule that says, python uniquely identify object instances of the same class?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>list.remove()</code> removes the first object that tests <em>equal</em>. From the <a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="nofollow">documentation</a>:</p>
<blockquote>
<p><code>s.remove(x)</code><br/>
   remove the first item from <em>s</em> where <code>s[i] == x</code> </p>
</blockquote>
<p>Instances of a custom class by default only test equal if they are the exact same object; if <code>s[i] is x</code> returns true then <code>s[i] == x</code> also returns true.</p>
<p>It is not the variable name that defines the instance; in your second example, it'll be the <code>MyClass(3)</code> instance that is removed from the list, because it is a unique object, distinct from the <code>MyClass(5)</code> instance you created and added before. You can check this with the <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow"><code>id()</code> function</a>, which on CPython basically returns the current memory address:</p>
<pre><code>&gt;&gt;&gt; myclass1 = MyClass(5)
&gt;&gt;&gt; id(myclass1)
4349144816
&gt;&gt;&gt; example.Add(myclass1)
&gt;&gt;&gt; myclass1 = MyClass(3)
&gt;&gt;&gt; id(myclass1)
4349145040
&gt;&gt;&gt; example.Add(myclass1)
&gt;&gt;&gt; example.container
[&lt;__main__.MyClass object at 0x1033aaef0&gt;, &lt;__main__.MyClass object at 0x1033aafd0&gt;]
&gt;&gt;&gt; hex(id(myclass1))
'0x1033aafd0'
&gt;&gt;&gt; myclass1 is example.container[1]
True
&gt;&gt;&gt; example.Remove(myclass1)
&gt;&gt;&gt; example.container
[&lt;__main__.MyClass object at 0x1033aaef0&gt;]
</code></pre>
<p>Note that the default representation of your custom classes include the <code>id()</code> value in hexadecimal!</p>
<p>You can alter this behaviour by overriding the <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow"><code>object.__eq__()</code> method</a>; have it return <code>True</code> or <code>False</code> based on your own criteria, or return the <code>NotImplemented</code> singleton if the other object is not a type your class supports being compared with (so Python can delegate to the other object).</p>
<p>For example, if your instances should be considered equal when their <code>number</code> attribute is equal, you'd implement it like this:</p>
<pre><code>class MyClass():
    def __init__(self, number):
        self.number = number

    def __eq__(self, other):
        if not isinstance(other, MyClass):
            return NotImplemented
        return self.number == other.number
</code></pre>
<p>With that change, you can do this:</p>
<pre><code>example.Add(MyClass(42))
example.Add(MyClass(81))
example.Remove(MyClass(42))
</code></pre>
<p>and that would remove the instance with <code>number</code> set to <code>42</code>.</p>
</div>
<span class="comment-copy">you have to define how they are compared using <code>__eq__</code>. Basically locates the <code>myclass1 == example.container</code> element and removes that.</span>
<span class="comment-copy">And if you were on Python 2, while you're defining <code>__eq__</code>, you'd want to either set <code>__hash__ = None</code> or define a reasonable <code>__hash__</code> method, so dicts and sets don't go crazy.</span>
