<div class="post-text" itemprop="text">
<p>I want to do something like this:</p>
<pre><code>class B():
    def __init__(self,c):
        self.c=c
    def getA(self):
        #this is what I want
class A():
    def __init__(self,d):
        self.b = B(d)

a = A(d)
</code></pre>
<p>what I want is that when I perform </p>
<pre><code>a.b.getA()
</code></pre>
<p>I can get the object a that use this method by its attribute b.
I can't pass any new variable to the function because this in implementation is a class written by other people that changing the input variables means changing a lot of stuff.</p>
<p>Can anyone help?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since it seems that you construct the <code>B</code> instance within the <code>A</code> constructor, then give your <code>B</code> instance a reference to the <code>A</code> instance:</p>
<pre><code>class B():
    def __init__(self, c, a):
        self.c = c
        self.a = a
    def getA(self):
        return self.a

class A():
    def __init__(self, d):
        self.b = B(d, self)

a = A(d)
</code></pre>
<hr/>
<p>It is possible under <strong>certain</strong> Python implementations to sometimes find an instance using the <a href="https://docs.python.org/3/library/gc.html#gc.get_referrers" rel="nofollow"><code>gc.get_referrers</code></a>, but as the documentation says, using it should be avoided <em>"for any purpose other than debugging."</em>:</p>
<pre><code>import gc

class B():
    def __init__(self,c):
        self.c = c

    def getA(self):
        for i in gc.get_referrers(self):
            if not isinstance(i, dict):
                continue

            for j in gc.get_referrers(i):
                if isinstance(j, A) and getattr(j, 'b', None) is self:
                    return j

        return

class A():
    def __init__(self,d):
        self.b = B(d)

a = A(42)
print(a.b.getA() is a)
</code></pre>
<p>The first <code>get_referrers</code> call will find among others, the <code>__dict__</code> of the <code>A</code> instance; this would probably be of type <code>dict</code>; we then go through all the objects of the dictionaries referring to <code>self</code>, and if any of these is of type <code>A</code>, and it has attribute <code>b</code> whose value <code>is self</code>, we return that object.</p>
<p>Thus the clause <code>print(a.b.getA() is a)</code> shall print true.</p>
<p>But seriously, don't use this code.</p>
</div>
<span class="comment-copy">but you already have <code>a</code>, don't you?</span>
<span class="comment-copy">seems that way to me... <code>a.b.getA()</code></span>
<span class="comment-copy">@sobolevn I can only modify the method getA(), so I want to get the object using this method.</span>
<span class="comment-copy">No, you can't do that. References have only one direction. Objects never know what other objects (note: plural!) may reference them. The exception is when you explicitly store a reference in the object (eg modifying class B so it stores a reference to A, which must then be initialized)</span>
<span class="comment-copy">I am not the one using the object a. In other word, I need a function in b that can get the object a.</span>
<span class="comment-copy">Is there a way I don't need to change the initial method of the classes, I'm trying to keep modifications in a single method to minimize the modification of the code. Changing initialization will change a lot of things.</span>
