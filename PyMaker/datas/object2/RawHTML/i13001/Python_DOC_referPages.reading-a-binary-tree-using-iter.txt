<div class="post-text" itemprop="text">
<p>I have a standard Binary Tree that reads like<br/>
    1<br/>
   / \<br/>
2  3<br/>
/ \ / \<br/>
4  5 6  7</p>
<p>I need to read the binary tree by importing my tree class, creating this tree, and then using a for loop to read it like: [4, 2, 5, 1, 6, 3, 7]</p>
<p>I have already made the tree and my program will generate a like tree with any amount of numbers. My problem is in the method.</p>
<p>def <strong>iter</strong>(self):</p>
<p>So far I have:</p>
<pre><code>def __iter__(self):
    if self.left:
        self.left.__iter__()
    yield self
    if self.right:
        self.right.__iter__()
</code></pre>
<p>But when I run a for loop on the tree object like:</p>
<p>for item in tree:
    print("{}: {}").format(item.name, item.height())</p>
<p>It only prints the first node in my try with a correct height.</p>
<p>My question is basically, how to print this binary tree using recursion?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python &gt;= <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow">3.3</a>, one can use the <code>yield from x</code> syntax for recursive iterators:</p>
<pre><code>def __iter__(self):
    if self.left:
        yield from self.left
    yield self
    if self.right:
        yield from self.right
</code></pre>
<p>Edit: Python 3.3 support confirmed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not tried, but probably rather something like:</p>
<pre><code>def __iter__(self):
    if self.left:
        for k in self.left:
            yield k
    yield self
    if self.right:
        for k in self.right:
            yield k
</code></pre>
<p>But check it first.</p>
</div>
<div class="post-text" itemprop="text">
<p>Next element from the collection should be <strong>returned</strong> by <code>__next__()</code>: <a href="https://stackoverflow.com/questions/13094421/what-is-the-interface-for-python-iterators">What is the interface for python iterators?</a> </p>
<p><code>__iter__()</code> should return an iterator, an object that defines <code>__next__()</code> method. <code>yield</code> is used in generator which is quite different concept than iterators, but you can use generator function (because it is an iterator), i.e.:</p>
<pre><code>class A:
    def __init__(self, val, a=None, b=None):
        self.left = a
        self.right = b
        self.val = val

    def __iter__(self):
        def generator():
            if self.left:
                for leaf in self.left:
                    yield leaf
            yield self
            if self.right:
                for leaf in self.right:
                    yield leaf
        return generator()

for i in A(3, A(5, A(2), A(1)), A(4)):
    print(i.val)
</code></pre>
</div>
<span class="comment-copy">Presumably, <code>for k in self.left</code> would never enter the body if <code>self.left</code> were falsy, making the <code>if</code> check redundant.</span>
