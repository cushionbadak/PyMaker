<div class="post-text" itemprop="text">
<p>I am having a really hard time figuring out how to pass a large byte array of data from C to an arbitrary Python3 function. For reference, here are some documentation links on the subject:</p>
<p><a href="https://docs.python.org/3.5/extending/embedding.html" rel="nofollow">https://docs.python.org/3.5/extending/embedding.html</a></p>
<p>Most of the information in the docs seems to assume that I am passing data from Python to C. I need to do the opposite. I found the a reference to the API function <code>PyBuffer_FromContiguous</code> – but it is not documented anywhere (that I can find). The function prototype is here:</p>
<pre><code>PyAPI_FUNC(int) PyBuffer_FromContiguous(Py_buffer *view, void *buf,
                                        Py_ssize_t len, char order);
</code></pre>
<p>Basically I have two questions:</p>
<ol>
<li>Is this the right way to construct a <code>Py_buffer</code> object? Is this even the right approach?</li>
<li>Once the <code>Py_buffer</code> is constructed, how do I associate the <code>Py_buffer</code> with a <code>PyObject</code> that can be set to a input tuple/argument for a call to a python function?</li>
</ol>
<p>Here is a code sample for what I am attempting (updated to include the <code>data_s</code> typedef):</p>
<pre><code>typedef struct
{
  size_t size;
  unsigned char* data;
} data_s;

  // convert the arguments
  PyObject* pArgs;
  PyObject* pRes;
  Py_buffer* pBuf;
  pArgs = PyTuple_New((Py_ssize_t)num_args);
  if (num_args)
  {
    va_start(argp, num_args);
    for (i = 0; i &lt; num_args; i++)
    {
      data_s* arg = va_arg(argp, data_s*);
      result = PyBuffer_FromContiguous(pBuf, arg-&gt;data, (Py_ssize_t)arg-&gt;size, 'C');
      if (result &lt; 0)
      {
        fprintf(stderr, "Error: Unable to copy argument %d into python object\n", i);
        PY_DECREF(pArgs);
        break;
      }

      // set pValue, something like this?
      PyTuple_SetItem(pArgs, i, pBuf-&gt;obj);
    }
  }

  // run the function
  pRes = PyObject_CallObject(func_entry-&gt;pFunc, pArgs);

  // error checking... 
</code></pre>
<p>… I would really appreciate any leads on these issues.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem was that I was not finding the right API call for what I needed. Here is the call (in case anyone cares) that solves this problem: <code>Py_BuildValue</code> and is documented here:</p>
<p><a href="https://docs.python.org/3/extending/extending.html#building-arbitrary-values" rel="nofollow">https://docs.python.org/3/extending/extending.html#building-arbitrary-values</a></p>
</div>
<span class="comment-copy">You're creating a buffer, but not using it. What are you trying to do? Usually, you'd want to use something like <a href="https://docs.python.org/3/c-api/buffer.html#c.PyBuffer_FillInfo" rel="nofollow noreferrer"><code>PyBuffer_FillInfo</code></a>, but it's not clear what the goal here is. Buffers must be associated with a Python object, is <code>data_s</code> as <code>PyObject</code> of some sort?</span>
<span class="comment-copy">@ShadowRanger: You might be right. I was attempting to use the Py_buffer in the <code>PyTuple_SetItem()</code> call. I am trying to call an arbitrary function with arbitrary data. Maybe it isn't valid to set the buffer PyObject to a tuple like that? I did see some documentation on the <code>PyBuffer_FillInfo</code> function, but I was assuming that the <code>PyObject* exporter</code> needed to exist before I could use it to set the value of the Py_buffer. It seemed the opposite direction for what I need.</span>
