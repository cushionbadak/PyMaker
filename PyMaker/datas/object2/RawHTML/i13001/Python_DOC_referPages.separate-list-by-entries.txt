<div class="post-text" itemprop="text">
<p>I have a Python list that I know contains the entries <code>1</code>, <code>2</code>, and <code>7</code>, e.g.,</p>
<pre><code>data = [1, 7, 2, 1, 1, 1, 2, 2, 7, 1, 7, 7, 2]
</code></pre>
<p>I would now like to get all of the indices of each entry, i.e.,</p>
<pre><code>g1 = [0, 3, 4, 5, 9]
g2 = [2, 6, 7, 12]
g7 = [1, 8, 10, 11]
</code></pre>
<p>The <code>data</code> array can be long, so efficiency matters. How do I achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3/library/collections.html#defaultdict-examples" rel="nofollow"><code>defaultdict</code></a> in order to collect indices of elements per group:</p>
<pre><code>In [1]: from collections import defaultdict

In [2]: data = [1, 7, 2, 1, 1, 1, 2, 2, 7, 1, 7, 7, 2]

In [3]: indices = defaultdict(list)

In [4]: for i, d in enumerate(data):
   ...:     indices[d].append(i)
   ...:     

In [5]: indices
Out[5]: defaultdict(&lt;class 'list'&gt;, {1: [0, 3, 4, 5, 9], 2: [2, 6, 7, 12], 7: [1, 8, 10, 11]})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Though <a href="http://werkzeug.pocoo.org/docs/0.10/datastructures/#werkzeug.datastructures.MultiDict" rel="nofollow">werkzeug</a> is not really meant for this job, it will work well:</p>
<pre><code>from werkzeug import MultiDict

data = [1, 7, 2, 1, 1, 1, 2, 2, 7, 1, 7, 7, 2]

g = MultiDict((v, i) for i, v in enumerate(data))
g1 = g.getlist(1)
g2 = g.getlist(2)
g7 = g.getlist(7)

print repr(g7)
# [1, 8, 10, 11]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about something more dynamic like this?</p>
<pre><code>data = [1, 7, 2, 1, 1, 1, 2, 2, 7, 1, 7, 7, 2]
index_dict = {}

for i in range(len(data)):

  # Get or create the entry for the value
  sub_dict = index_dict.setdefault(val, [])

  # Add the index for the value
  sub_dict.append(i)
</code></pre>
<p>This code will create an entry for each value it encounter and store it's index. Then you can lookup the dictionary to know the index of every value.</p>
<p>While this code is less elegant than list comprehension, it has the advantage of iterating through the data only once.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/2/library/itertools.html#itertools.compress" rel="nofollow"><code>itertools.compress</code></a></p>
<pre><code>data = [1, 7, 2, 1, 1, 1, 2, 2, 7, 1, 7, 7, 2]

g1 = itertools.compress(range(len(data)),  map(lambda x: x==1, data))
g2 = itertools.compress(range(len(data)),  map(lambda x: x==2, data))
g7 = itertools.compress(range(len(data)),  map(lambda x: x==7, data))
</code></pre>
</div>
<span class="comment-copy"><code>g = {target: [index for index, val in enumerate(data) if val == target] for target in set(data)}</code>? Then the indices of <code>1</code> would be <code>g[1]</code>.</span>
<span class="comment-copy">This way, I would need to iterate over the list several times, which takes too long in my application.</span>
<span class="comment-copy">So use <code>g = collections.defaultdict(list)</code> and then <code>g[index].append(val)</code>? What have you actually <i>tried</i>, and what is the problem with it?</span>
<span class="comment-copy">I have no idea why this question has four close votes as "unclear what you are asking" ... did they even read the question?</span>
<span class="comment-copy">It isn't clear to me why this question was closed. I have now removed the "best" in "best achieve this" since that didn't add clarity, but other than that, I'm unsure what to change. Describing my failed attempts doesn't contribute to the clarity of the question I believe.</span>
<span class="comment-copy">1. You don't need <code>0</code> in the call to <code>range</code>, that's the default. 2. You should test for <code>None</code> by identity, with <code>is</code> (an empty list is also false-y, but can certainly be appended to). 3. You've just rewritten your own <code>defaultdict</code>, not even using e.g. <code>sub_dict = index_dict.get(val, [])</code>.</span>
<span class="comment-copy">@jonrsharpe Using <code>sub_dict = index_dict.get(val, [])</code> would not create a new entry in index_dict. Testing with <code>is None</code> is not required because the entry will always have a value with this code but I updated it anyway. <code>range(len(data))</code>, you're totally right.</span>
<span class="comment-copy">@Gab you're right, sorry - I meant <code>setdefault</code>, not <code>get</code>.</span>
<span class="comment-copy">@jonrsharpe, I did not know about <code>setdefault</code>, my code is way better now, thanks :)</span>
<span class="comment-copy">Like my first suggestion, this will iterate over <code>data</code> multiple times</span>
<span class="comment-copy">OP didnt's say that in his question...</span>
