<div class="post-text" itemprop="text">
<p>I was trying to create a list comprehension from a function that I had and I came across an unexpected behavior. Just for a better understanding, my function gets an integer and checks which of its digits divides the integer exactly:</p>
<pre><code># Full function
divs = list()
for i in str(number):
    digit = int(i)
    if digit &gt; 0 and number % digit == 0:
        divs.append(digit)
return len(divs)

# List comprehension
return len([x for x in str(number) if x &gt; 0 and number % int(x) == 0])
</code></pre>
<p>The problem is that, if I give a <code>1012</code> as an input, the full function returns <code>3</code>, which is the expected result. The list comprehension returns a <code>ZeroDivisionError: integer division or modulo by zero</code> instead. I understand that it is because of this condition:</p>
<pre><code>if x &gt; 0 and number % int(x) == 0
</code></pre>
<p>In the full function, the multiple condition is handled from the left to the right, so it is fine. In the list comprehension, I do not really know, but I was guessing that it was not handled in the same way.</p>
<p>Until I tried with a simpler function:</p>
<pre><code># Full function
positives = list()
for i in numbers:
    if i &gt; 0 and 20 % i ==0:
        positives.append(i)
return positives

# List comprehension
return [i for i in numbers if i &gt; 0 and 20 % i == 0]
</code></pre>
<p>Both of them worked. So I am thinking that maybe it has something to do with the <code>number % int(x)</code>? This is just curiosity on how this really works? Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>The list comprehension is different, because you compare <code>x &gt; 0</code> without converting <code>x</code> to <code>int</code>. In Py2, mismatched types will compare in an <a href="https://hg.python.org/cpython/file/v2.7.10/Objects/object.c#l762" rel="nofollow">arbitrary and stupid but consistent way</a>, which in this case sees all <code>str</code>s (the type of <code>x</code>) as greater than all <code>int</code> (the type of <code>0</code>) meaning that the <code>x &gt; 0</code> test is always <code>True</code> and the second test always executes (see <strong>Footnote</strong> below for details of this nonsense). Change the list comprehension to:</p>
<pre><code>[x for x in str(number) if int(x) &gt; 0 and number % int(x) == 0]
</code></pre>
<p>and it will work.</p>
<p>Note that you could simplify a bit further (and limit redundant work and memory consumption) by importing a Py3 version of <code>map</code> at the top of your code (<code>from future_builtins import map</code>), and using a generator expression with <code>sum</code>, instead of a list comprehension with <code>len</code>:</p>
<pre><code>return sum(1 for i in map(int, str(number)) if i &gt; 0 and number % i == 0)
</code></pre>
<p>That only calls <code>int</code> once per digit, and constructs no intermediate <code>list</code>.</p>
<hr/>
<p><strong>Footnote</strong>: <code>0</code> is a numeric type, and all numeric types are "smaller" than everything except <code>None</code>, so a <code>str</code> is always greater than <code>0</code>. In non-numeric cases, it would be comparing the string type names, so <code>dict</code> &lt; <code>frozenset</code> &lt; <code>list</code> &lt; <code>set</code> &lt; <code>str</code> &lt; <code>tuple</code>, except oops, <code>frozenset</code> and <code>set</code> compare "naturally" to each other, so you can have non-transitive relationships; <code>frozenset() &lt; []</code> is true, <code>[] &lt; set()</code> is true, but <code>frozenset() &lt; set()</code> is false, because the type specific comparator gets invoked in the final version. Like I said, arbitrary and confusing; it was removed from Python 3 for a reason.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should say int(x) &gt; 0 in the list comprehension</p>
</div>
<span class="comment-copy">i'm surprised that you would get a <code>ZeroDivisionError</code> and not a <code>TypeError</code> for comparing x with 0, ie <code>str &gt; int</code></span>
<span class="comment-copy">@RNar: In Py2, mismatched type comparisons don't raise exceptions (unless custom comparator code gets involved and does so on purpose). They use a fallback comparison that gets "arbitrary but consistent ordering"; the simple version of that fallback is that it's comparing the string names of each type.</span>
<span class="comment-copy">ahhh, i see. py3 has an explicit error raised for it so that's why I could not replicate</span>
<span class="comment-copy">Yeah. They changed it in Py3 precisely because the fallback comparison was non-intuitive and let probable errors pass silently. The main casualty from the change is that it breaks some code that, rather than filtering values added to a <code>list</code>, instead inserted <code>None</code> to indicate "no value". Sorting such a <code>list</code> moved all the <code>None</code>s to the front (which I thought was a coincidence of <code>None</code> being the only thing whose <code>type</code>, <code>NoneType</code> begins with a capital letter, making it sort before everything else; turns out <code>None</code> is actually explicitly special cased to be "smallest" in CPython).</span>
<span class="comment-copy">What is interesting, Python 3 warns explicitely: TypeError: unorderable types: str() &gt; int()</span>
<span class="comment-copy">That gives you a list of strings, not of integers - add another <code>int</code> or simply iterate over <code>map(int, str(number))</code> instead.</span>
<span class="comment-copy">@RomanSusi yes, this behaviour was changed in 3.x; see <a href="https://docs.python.org/3/whatsnew/3.0.html#ordering-comparisons" rel="nofollow noreferrer">docs.python.org/3/whatsnew/3.0.html#ordering-comparisons</a></span>
<span class="comment-copy">@jonrsharpe: Since the OP was just checking the length, not using the <code>list</code>, the type of the values in the resulting <code>list</code> didn't matter. I did just add a better solution that avoids repeated <code>int</code>-ification and the intermediate <code>list</code> when all they wanted was a count of values passing the filter.</span>
<span class="comment-copy">Thank you guys! I feel a bit stupid because I forgot the <code>int(x)</code>, but I found this topic really interesting... so I got that going for me, which is nice :P</span>
