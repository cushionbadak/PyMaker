<div class="post-text" itemprop="text">
<p>I have a list of lists in Python:</p>
<pre><code>k = [[1, 2], [4], [5, 6, 2], [1, 2], [3], [4]]
</code></pre>
<p>And I want to remove duplicate elements from it. Was if it a normal list not of lists I could used <code>set</code>. But unfortunate that list is not hashable and can't make set of lists. Only of tuples. So I can turn all lists to tuples then use set and back to lists. But this isn't fast.</p>
<p>How can this done in the most efficient way?</p>
<p>The result of above list should be:</p>
<pre><code>k = [[5, 6, 2], [1, 2], [3], [4]]
</code></pre>
<p>I don't care about preserve order.</p>
<p>Note: <a href="https://stackoverflow.com/questions/1143379/removing-duplicates-from-list-of-lists-in-python">this question</a> is similar but not quite what I need. Searched SO but didn't find exact duplicate.</p>
<hr/>
<p>Benchmarking:</p>
<pre><code>import itertools, time


class Timer(object):
    def __init__(self, name=None):
        self.name = name

    def __enter__(self):
        self.tstart = time.time()

    def __exit__(self, type, value, traceback):
        if self.name:
            print '[%s]' % self.name,
        print 'Elapsed: %s' % (time.time() - self.tstart)


k = [[1, 2], [4], [5, 6, 2], [1, 2], [3], [5, 2], [6], [8], [9]] * 5
N = 100000

print len(k)

with Timer('set'):
    for i in xrange(N):
        kt = [tuple(i) for i in k]
        skt = set(kt)
        kk = [list(i) for i in skt]


with Timer('sort'):
    for i in xrange(N):
        ks = sorted(k)
        dedup = [ks[i] for i in xrange(len(ks)) if i == 0 or ks[i] != ks[i-1]]


with Timer('groupby'):
    for i in xrange(N):
        k = sorted(k)
        dedup = list(k for k, _ in itertools.groupby(k))

with Timer('loop in'):
    for i in xrange(N):
        new_k = []
        for elem in k:
            if elem not in new_k:
                new_k.append(elem)
</code></pre>
<p>"loop in" (quadratic method) fastest of all for short lists. For long lists it's faster then everyone except groupby method. Does this make sense?</p>
<p>For short list (the one in the code), 100000 iterations:</p>
<pre><code>[set] Elapsed: 1.3900001049
[sort] Elapsed: 0.891000032425
[groupby] Elapsed: 0.780999898911
[loop in] Elapsed: 0.578000068665
</code></pre>
<p>For longer list (the one in the code duplicated 5 times):</p>
<pre><code>[set] Elapsed: 3.68700003624
[sort] Elapsed: 3.43799996376
[groupby] Elapsed: 1.03099989891
[loop in] Elapsed: 1.85900020599
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; k = [[1, 2], [4], [5, 6, 2], [1, 2], [3], [4]]
&gt;&gt;&gt; import itertools
&gt;&gt;&gt; k.sort()
&gt;&gt;&gt; list(k for k,_ in itertools.groupby(k))
[[1, 2], [3], [4], [5, 6, 2]]
</code></pre>
<p><a href="http://docs.python.org/library/itertools.html?highlight=itertools#module-itertools" rel="noreferrer"><code>itertools</code></a> often offers the fastest and most powerful solutions to this kind of problems, and is <strong>well</strong> worth getting intimately familiar with!-)</p>
<p><strong>Edit</strong>: as I mention in a comment, normal optimization efforts are focused on large inputs (the big-O approach) because it's so much easier that it offers good returns on efforts. But sometimes (essentially for "tragically crucial bottlenecks" in deep inner loops of code that's pushing the boundaries of performance limits) one may need to go into much more detail, providing probability distributions, deciding which performance measures to optimize (maybe the upper bound or the 90th centile is more important than an average or median, depending on one's apps), performing possibly-heuristic checks at the start to pick different algorithms depending on input data characteristics, and so forth.</p>
<p>Careful measurements of "point" performance (code A vs code B for a specific input) are a part of this extremely costly process, and standard library module <code>timeit</code> helps here. However, it's easier to use it at a shell prompt.  For example, here's a short module to showcase the general approach for this problem, save it as <code>nodup.py</code>:</p>
<pre><code>import itertools

k = [[1, 2], [4], [5, 6, 2], [1, 2], [3], [4]]

def doset(k, map=map, list=list, set=set, tuple=tuple):
  return map(list, set(map(tuple, k)))

def dosort(k, sorted=sorted, xrange=xrange, len=len):
  ks = sorted(k)
  return [ks[i] for i in xrange(len(ks)) if i == 0 or ks[i] != ks[i-1]]

def dogroupby(k, sorted=sorted, groupby=itertools.groupby, list=list):
  ks = sorted(k)
  return [i for i, _ in itertools.groupby(ks)]

def donewk(k):
  newk = []
  for i in k:
    if i not in newk:
      newk.append(i)
  return newk

# sanity check that all functions compute the same result and don't alter k
if __name__ == '__main__':
  savek = list(k)
  for f in doset, dosort, dogroupby, donewk:
    resk = f(k)
    assert k == savek
    print '%10s %s' % (f.__name__, sorted(resk))
</code></pre>
<p>Note the sanity check (performed when you just do <code>python nodup.py</code>) and the basic hoisting technique (make constant global names local to each function for speed) to put things on equal footing.</p>
<p>Now we can run checks on the tiny example list:</p>
<pre><code>$ python -mtimeit -s'import nodup' 'nodup.doset(nodup.k)'
100000 loops, best of 3: 11.7 usec per loop
$ python -mtimeit -s'import nodup' 'nodup.dosort(nodup.k)'
100000 loops, best of 3: 9.68 usec per loop
$ python -mtimeit -s'import nodup' 'nodup.dogroupby(nodup.k)'
100000 loops, best of 3: 8.74 usec per loop
$ python -mtimeit -s'import nodup' 'nodup.donewk(nodup.k)'
100000 loops, best of 3: 4.44 usec per loop
</code></pre>
<p>confirming that the quadratic approach has small-enough constants to make it attractive for tiny lists with few duplicated values.  With a short list without duplicates:</p>
<pre><code>$ python -mtimeit -s'import nodup' 'nodup.donewk([[i] for i in range(12)])'
10000 loops, best of 3: 25.4 usec per loop
$ python -mtimeit -s'import nodup' 'nodup.dogroupby([[i] for i in range(12)])'
10000 loops, best of 3: 23.7 usec per loop
$ python -mtimeit -s'import nodup' 'nodup.doset([[i] for i in range(12)])'
10000 loops, best of 3: 31.3 usec per loop
$ python -mtimeit -s'import nodup' 'nodup.dosort([[i] for i in range(12)])'
10000 loops, best of 3: 25 usec per loop
</code></pre>
<p>the quadratic approach isn't bad, but the sort and groupby ones are better.  Etc, etc.</p>
<p>If (as the obsession with performance suggests) this operation is at a core inner loop of your pushing-the-boundaries application, it's worth trying the same set of tests on other representative input samples, possibly detecting some simple measure that could heuristically let you pick one or the other approach (but the measure must be fast, of course).</p>
<p>It's also well worth considering keeping a different representation for <code>k</code> -- why does it have to be a list of lists rather than a set of tuples in the first place?  If the duplicate removal task is frequent, and profiling shows it to be the program's performance bottleneck, keeping a set of tuples all the time and getting a list of lists from it only if and where needed, might be faster overall, for example.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; k = [[1, 2], [4], [5, 6, 2], [1, 2], [3], [4]]
&gt;&gt;&gt; k = sorted(k)
&gt;&gt;&gt; k
[[1, 2], [1, 2], [3], [4], [4], [5, 6, 2]]
&gt;&gt;&gt; dedup = [k[i] for i in range(len(k)) if i == 0 or k[i] != k[i-1]]
&gt;&gt;&gt; dedup
[[1, 2], [3], [4], [5, 6, 2]]
</code></pre>
<p>I don't know if it's necessarily faster, but you don't have to use to tuples and sets. </p>
</div>
<div class="post-text" itemprop="text">
<p>Doing it manually, creating a new <code>k</code> list and adding entries not found so far:</p>
<pre><code>k = [[1, 2], [4], [5, 6, 2], [1, 2], [3], [4]]
new_k = []
for elem in k:
    if elem not in new_k:
        new_k.append(elem)
k = new_k
print k
# prints [[1, 2], [4], [5, 6, 2], [3]]
</code></pre>
<p>Simple to comprehend, and you preserve the order of the first occurrence of each element should that be useful, but I guess it's quadratic in complexity as you're searching the whole of <code>new_k</code> for each element.</p>
</div>
<div class="post-text" itemprop="text">
<p>Even your "long" list is pretty short. Also, did you choose them to match the actual data? Performance will vary with what these data actually look like. For example, you have a short list repeated over and over to make a longer list. This means that the quadratic solution is linear in your benchmarks, but not in reality.</p>
<p>For actually-large lists, the set code is your best betâ€”it's linear (although space-hungry). The sort and groupby methods are O(n log n) and the loop in method is obviously quadratic, so you know how these will scale as n gets really big. If this is the real size of the data you are analyzing, then who cares? It's tiny.</p>
<p>Incidentally, I'm seeing a noticeable speedup if I don't form an intermediate list to make the set, that is to say if I replace</p>
<pre><code>kt = [tuple(i) for i in k]
skt = set(kt)
</code></pre>
<p>with</p>
<pre><code>skt = set(tuple(i) for i in k)
</code></pre>
<p>The real solution may depend on more information: Are you sure that a list of lists is really the representation you need?</p>
</div>
<div class="post-text" itemprop="text">
<p>List of tuple and {} can be used to remove duplicates</p>
<pre><code>&gt;&gt;&gt; [list(tupl) for tupl in {tuple(item) for item in k }]
[[1, 2], [5, 6, 2], [3], [4]]
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All the <code>set</code>-related solutions to this problem thus far require creating an entire <code>set</code> before iteration.</p>
<p>It is possible to make this lazy, and at the same time preserve order, by iterating the list of lists and adding to a "seen" <code>set</code>. Then only yield a list if it is not found in this tracker <code>set</code>.</p>
<p>This <code>unique_everseen</code> recipe is available in the <code>itertools</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">docs</a>. It's also available in the 3rd party <a href="https://toolz.readthedocs.io/en/latest/" rel="nofollow noreferrer"><code>toolz</code></a> library:</p>
<pre><code>from toolz import unique

k = [[1, 2], [4], [5, 6, 2], [1, 2], [3], [4]]

# lazy iterator
res = map(list, unique(map(tuple, k)))

print(list(res))

[[1, 2], [4], [5, 6, 2], [3]]
</code></pre>
<p>Note that <code>tuple</code> conversion is necessary because lists are not hashable.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should work.</p>
<pre><code>k = [[1, 2], [4], [5, 6, 2], [1, 2], [3], [4]]

k_cleaned = []
for ele in k:
    if set(ele) not in [set(x) for x in k_cleaned]:
        k_cleaned.append(ele)
print(k_cleaned)

# output: [[1, 2], [4], [5, 6, 2], [3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another probably more generic and simpler solution is to create a dictionary keyed by the string version of the objects and getting the values() at the end:</p>
<pre><code>&gt;&gt;&gt; dict([(unicode(a),a) for a in [["A", "A"], ["A", "A"], ["A", "B"]]]).values()
[['A', 'B'], ['A', 'A']]
</code></pre>
<p>The catch is that this only works for objects whose string representation is a good-enough unique key (which is true for most native objects).</p>
</div>
<div class="post-text" itemprop="text">
<p>Create a dictionary with tuple as the key, and print the keys.</p>
<ul>
<li>create dictionary with tuple as key and index as value</li>
<li>print list of keys of dictionary</li>
</ul>
<hr/>
<pre><code>k = [[1, 2], [4], [5, 6, 2], [1, 2], [3], [4]]

dict_tuple = {tuple(item): index for index, item in enumerate(k)}

print [list(itm) for itm in dict_tuple.keys()]

# prints [[1, 2], [5, 6, 2], [3], [4]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Strangely, the answers above removes the 'duplicates' but what if I want to remove the duplicated value also??
The following should be useful and does not create a new object in memory!</p>
<pre><code>def dictRemoveDuplicates(self):
    a=[[1,'somevalue1'],[1,'somevalue2'],[2,'somevalue1'],[3,'somevalue4'],[5,'somevalue5'],[5,'somevalue1'],[5,'somevalue1'],[5,'somevalue8'],[6,'somevalue9'],[6,'somevalue0'],[6,'somevalue1'],[7,'somevalue7']]


print(a)
temp = 0
position = -1
for pageNo, item in a:
    position+=1
    if pageNo != temp:
        temp = pageNo
        continue
    else:
        a[position] = 0
        a[position - 1] = 0
a = [x for x in a if x != 0]         
print(a)
</code></pre>
<p>and the o/p is:</p>
<pre><code>[[1, 'somevalue1'], [1, 'somevalue2'], [2, 'somevalue1'], [3, 'somevalue4'], [5, 'somevalue5'], [5, 'somevalue1'], [5, 'somevalue1'], [5, 'somevalue8'], [6, 'somevalue9'], [6, 'somevalue0'], [6, 'somevalue1'], [7, 'somevalue7']]
[[2, 'somevalue1'], [3, 'somevalue4'], [7, 'somevalue7']]
</code></pre>
</div>
<span class="comment-copy">By "this isn't fast", do you mean that you have timed it and it is not fast enough for your application, or that you think it is not fast?</span>
<span class="comment-copy">@Torsten, it just seems like too much copying to be smart method. sorry, gut feeling. copy lists to tuples, then into set, then back to list of lists (copy again tuples to lists)</span>
<span class="comment-copy">@zaharpopov: thats not how Python works, nothing will be <i>copied</i>, just new containers for the existing elements ( though for ints, it's pretty much the same )</span>
<span class="comment-copy">1. the timings for the methods using sorting are deflated, because "k" is rebound to the sorted variant.  2. The last method is faster because the way you generate the test data leaves you with at most 4 distinct elements. Try sth. like  K = [[int(u) for u in str(random.randrange(1, 1000))] for _ in range(100)]</span>
<span class="comment-copy">@Torsten: fixed thanks. but still the loop method is fast even when there is only one duplicate in list of 10</span>
<span class="comment-copy">@alex thanks for alternative. this method about same speed as danben's, a few % faster</span>
<span class="comment-copy">@alex: strangely this is slower than a naive quadratic method for shorter lists (see question edit)</span>
<span class="comment-copy">@zaharpopov: it's that way only in your special case, cf. my comment to the question.</span>
<span class="comment-copy">@zaharpopov, if you give a probability distribution of list and sublist lengths and chance of duplicates, it's possible (with huge effort) to compute/measure the runtimes probability distribution for any given code and optimize whatever measure you need (median, mean, 90th centile, whatever). It's hardly ever done because of very low ROI: normally one focuses on the much-easier case of large inputs (the big-O approach), where inferior algorithms would really hurt performance terribly. And I don't see you specify any probability distributions in your Q anyway;-).</span>
<span class="comment-copy">@Alex great answer, thank you</span>
<span class="comment-copy">Thank you danben. this faster than turn to tuples then 'set' then back to lists?</span>
<span class="comment-copy">You could easily test that - write both deduping methods, generate some random lists using <code>random</code>, and time it with <code>time</code>.</span>
<span class="comment-copy">you right, this indeed seem faster</span>
<span class="comment-copy">@paul: very strange - this method is faster than all others</span>
<span class="comment-copy">I suspect this method won't be faster for very long lists.  It'll depend on your application: if you really just have six-element lists with two duplicates then any solution is likely to be fast enough and you should go with the clearest code.</span>
<span class="comment-copy">@zaharpopov, It's not quadratic in your benchmark because you duplicate the same list over and over. You are benchmarking with a linear corner case.</span>
<span class="comment-copy"><code>k = ([[1, 2], [4], [5, 6, 2], [1, 2], [3], [5, 2], [6], [8], [9]] +[[x] for x in range(1000)]) *5</code> will show up the quadratic behaviour nicely</span>
