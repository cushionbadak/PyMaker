<div class="post-text" itemprop="text">
<p>I have a module for configuration, <code>projectConfig</code>, to parse a sample sheet for a project:</p>
<pre><code>class SampleSheetFields():
    FIELD_1 = "field1"
    FIELD_2 = "field2"


class SampleSheetFieldsOld():
    FIELD_1 = "field_1"
    FIELD_2 = "field_2"
</code></pre>
<p>I had been using the first class in other modules like this:</p>
<pre><code>from projectConfig import SampleSheetFields as ssFields

class SomeClass

    def __init__(self):
        ...
        check(someContent, ssFields.FIELD_1)
</code></pre>
<p>The thing is I had developed my software using the reference to <code>ssFields</code> quite a lot. At some point new specifications said that the software should also use sample sheets with different field names. The quickest way I found to achieve that, without messing too much with the code, was to add the class <code>SampleSheetFieldsOld</code> in the <code>projectConfig</code> and to make a conditional import in my modules:</p>
<pre><code>class SomeClass:

    def __init__(self, useOld):
        if useOld:
            from projectConfig import SampleSheetFieldsOld as ssFields
        else:
            from projectConfig import SampleSheetFields as ssFields

        ...
        check(someContent, ssFields.FIELD_1)
</code></pre>
<p>Note that the mandatory fields which are used have the same name so there is no  conflicting or missing field. The program works as expected.</p>
<p>My questions are:</p>
<ol>
<li>How bad is this practice, if it is bad; and </li>
<li>How can I circumvent it to make a better and more sustainable code?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>It's probably not the worst thing, but what I do find kind of problematic is the fact that you're now locked into two configuration options, old and new. What if you need to add a third or fourth etc. set someday? You won't be able to use a simple boolean test anymore.</p>
<p>Besides, it looks like your configuration options are all just simple string values, accessible via string keys. You don't need a class for that.</p>
<p>My suggestion is to forget about doing your configuration with the source code and use a configuration <em>file</em>. In your <code>projectConfig</code> you can have a <code>dict</code> which you initialize from a file, whose path/name can be provided on the command line or in whatever way is convenient. So <code>projectConfig.py</code> might go something like this:</p>
<pre><code>config_options = {}

def load_configuration(filename):
    with open(filename) as f:
        for line in f:
            # get key and value
            config_options[key] = value
</code></pre>
<p>Then everywhere you need to get a field name, just access <code>projectConfig.config_options['field_key']</code>, e.g.</p>
<pre><code>from projectConfig import config_options

class SomeClass

    def __init__(self):
        ...
        check(someContent, config_options['FIELD_1'])
</code></pre>
<p>Or use <code>dict.get(key, default)</code> if there is a reasonable default value. This way, each time you need to switch to a different set of field names, you just create a new configuration file, and you don't have to touch the code.</p>
<p>Python's standard library includes a <a href="https://docs.python.org/3/library/configparser.html" rel="nofollow"><code>configparser</code> module</a> which can handle the loading for you.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you only need the class attributes, you could create a class factory, using <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow"><code>type</code></a> to create new classes, like:</p>
<pre><code>FIELDS = dict(
    new=dict(FIELD_1="field1", FIELD_2="field2"),
    old=dict(FIELD_1="field_1", FIELD_2="field_2"),
}


def sample_sheet_field_factory(field_spec='new'):
    return type("SampleSheetFields", (object,), FIELDS[field_spec])
</code></pre>
<p>This can easily be extended to further sets of field specifications, and doesn't require a conditional import:</p>
<pre><code>from wherever import sample_sheet_field_factory

class SomeClass(object):

    def __init__(self, use_old):
        ss_fields = sample_sheet_field_factory("old" if use_old else "new")
        check(some_content, ss_fields.FIELD_1)
</code></pre>
<p>You could also use a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow"><code>namedtuple</code></a>, rather than a class, which would be a little more lightweight. Note edits for compliance with <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow">the style guide</a>.</p>
</div>
<span class="comment-copy">So you're just using the classes for their attributes? Or do they have actual functionality, too? Have you considered making them instances, or creating a class factory?</span>
<span class="comment-copy">Their purpose is only to get the names, for matching purpose.</span>
<span class="comment-copy">In the likely event that the OP doesn't really need a class, this is even easier than creating them dynamically.</span>
