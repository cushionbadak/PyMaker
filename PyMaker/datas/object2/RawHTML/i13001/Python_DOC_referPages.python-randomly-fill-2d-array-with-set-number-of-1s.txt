<div class="post-text" itemprop="text">
<p>Suppose I have a 2D array (8x8) of 0's. I would like to fill this array with a predetermined number of 1's, but in a random manner. For example, suppose I want to place <em>exactly 16 1's</em> in the grid at random, resulting in something like this:</p>
<pre><code>[[0, 0, 0, 1, 0, 0, 1, 0],
 [1, 0, 0, 0, 0, 0, 0, 1],
 [0, 0, 1, 1, 1, 0, 0, 0],
 [0, 0, 0, 0, 0, 0, 0, 0],
 [0, 1, 0, 0, 0, 0, 0, 0],
 [0, 0, 1, 0, 1, 1, 0, 0],
 [0, 1, 0, 0, 0, 1, 0, 0],
 [0, 1, 1, 0, 0, 0, 0, 1]]
</code></pre>
<p>The resulting placement of the 1's does not matter in the slightest, as long as it is random (or as random as Python will allow).</p>
<p>My code technically works, but I imagine it's horrendously inefficient. All I'm doing is setting the probability of each number becoming a 1 to <code>n/s</code>, where <code>n</code> is the number of desired 1's and <code>s</code> is the size of the grid (i.e. number of elements), and then I check to see if the correct number of 1's was added. Here's the code (Python 2.7):</p>
<pre><code>length = 8
numOnes = 16
while True:
    board = [[(random.random() &lt; float(numOnes)/(length**2))*1 for x in xrange(length)] for x in xrange(length)]
    if sum([subarr.count(1) for subarr in board]) == 16:
        break
print board
</code></pre>
<p>While this <em>works</em>, it seems like a roundabout method. Is there a better (i.e. more efficient) way of doing this? I foresee running this code many times (hundreds of thousands if not millions), so speed is a concern.</p>
</div>
<div class="post-text" itemprop="text">
<p>Either shuffle a list of 16 1s and 48 0s:</p>
<pre><code>board = [1]*16 + 48*[0]
random.shuffle(board)
board = [board[i:i+8] for i in xrange(0, 64, 8)]
</code></pre>
<p>or fill the board with 0s and pick a random sample of 16 positions to put 1s in:</p>
<pre><code>board = [[0]*8 for i in xrange(8)]
for pos in random.sample(xrange(64), 16):
    board[pos//8][pos%8] = 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I made the ones, made the zeros, concatenated them, shuffle them, and reshaped.</p>
<pre><code>import numpy as np
def make_board(shape, ones):
    o = np.ones(ones, dtype=np.int)
    z = np.zeros(np.product(shape) - ones, dtype=np.int)
    board = np.concatenate([o, z])
    np.random.shuffle(board)
    return board.reshape(shape)

make_board((8,8), 16)
</code></pre>
<h3>Edit.</h3>
<p>For what it's worth, <a href="https://stackoverflow.com/users/2357112/user2357112">user2357112</a>'s approach with <code>numpy</code> is fast...</p>
<pre><code>def make_board(shape, ones):
    size = np.product(shape)
    board = np.zeros(size, dtype=np.int)
    i = np.random.choice(np.arange(size), ones)
    board[i] = 1
    return board.reshape(shape)
</code></pre>
</div>
<span class="comment-copy">Do it on a 1-D array first and then change it to 8X8 shape.</span>
<span class="comment-copy">Use a random shuffle.  Populate a vector of length 8x8 with 16 ones, and shuffle them, per <a href="http://stackoverflow.com/a/976918/1653571">stackoverflow.com/a/976918/1653571</a></span>
<span class="comment-copy">I was not aware of the existence of shuffle; thanks for pointing that out. Looking at your second example, that seems pretty obvious now. Thanks for your help!</span>
<span class="comment-copy">For fun, I just tried timing these algorithms, and the second one is quite a bit faster that the first (31 µs vs 53 µs on my machine), and about the same as my <code>numpy</code> method (27 µs). For large boards (1 million squares), it's <i>much</i> faster than either (6 ms, vs 857 ms for method 1, and 142 ms for my method).</span>
<span class="comment-copy">There is a caveat with the second method: if I'm not mistaken it is not guaranteed that 16 <i>different</i> positions are selected. Perhaps that's why it is so fast.</span>
<span class="comment-copy">@Erwin411: It is definitely guaranteed to pick 16 different positions. <code>random.sample</code> will not return duplicates. See the <a href="https://docs.python.org/3/library/random.html#random.sample" rel="nofollow noreferrer">docs</a>. It most likely outperformed the <code>shuffle</code> so drastically on the million-square board because shuffling a million elements is a lot more work than picking 16.</span>
<span class="comment-copy">@user2357112: Thanks for the clarification, I should have read the docs. I was assuming that <code>sample</code> returns independent samples from some (uniform) distribution.</span>
<span class="comment-copy">Thanks for providing another alternative! I always like seeing the various ways people go about solving these things.</span>
<span class="comment-copy">Beware of using <code>np.random.choice</code> for this; with <code>replace=True</code> (the default), it is not guaranteed to pick 16 different cells, and with <code>replace=False</code>, it is really slow due to a poor implementation decision that they're stuck with for backward compatibility (it performs a complete shuffle instead of shuffling just enough to produce the sample).</span>
