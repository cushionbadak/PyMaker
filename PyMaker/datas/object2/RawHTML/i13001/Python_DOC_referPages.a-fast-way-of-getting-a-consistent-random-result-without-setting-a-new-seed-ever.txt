<div class="post-text" itemprop="text">
<p>I'm learning the basics of Pygame and I'm slowly trying to get a mini RPG game built bit by bit. I've done a very basic implementation of getting tiles to display from coordinates and the camera location, however it's just block colours at the moment, so I wanted to vary the colour a bit.</p>
<p>I tried something to the effect of this code below, which works, but it's very slow:</p>
<pre><code>new_rand = random.Random()

#x_range and y_range only draw blocks that are within the bounds of the screen
for x in x_range:
    for y in y_range:
        #get the colour from a dictionary

        new_rand.seed((x, y))
        colour = [min(255, max(0, c + new_rand.uniform(-10, 10))) for c in colour]

        #draw block
</code></pre>
<p>I'm positive there should be a better way to do this, just could do with a pointer in the right direction.</p>
<p>Also, I subtract the camera location from <code>(x, y)</code> to get where the blocks should be on screen. Would there be a faster way to do this? That by itself when very zoomed out is not particularly fast.</p>
</div>
<div class="post-text" itemprop="text">
<p>Fleshing out my comment from above - if you're looking for a consistent value for any given x, y pair, what you need is a hash function. From <a href="https://en.wikipedia.org/wiki/Hash_function" rel="nofollow">Wikipedia</a>:</p>
<blockquote>
<p>A hash function is any function that can be used to map data of arbitrary size to data of fixed size.</p>
</blockquote>
<p>In your case, where you're essentially looking for an offset as a small integer value, something like this should do the trick:</p>
<pre><code>def simplehash(x, y):
    return (x * y) % 20 - 10
</code></pre>
<p>This probably won't give you a very uniform distribution of values, but it
should be sufficient for your needs. You could always tweak it a bit for aesthetics. Maybe add one to x and y before multiplying to avoid a glut of zeroes, that sort of thing.</p>
<p>As a side note, you might be able to improve performance a bit with some <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow">caching</a>:</p>
<pre><code>from functools import lru_cache

@lru_cache(maxsize=100)  # definitely tweak maxsize as needed
def simplecache(y, x):
   ...
</code></pre>
<p>lru_cache is pretty new, I think it was introduced in Python 3.3 but there are backports available for Python 2 if needed.</p>
</div>
<span class="comment-copy">Why do you need to have each (x,y) pair to have their own random seed? Why can't you use the same seed for all x and y?</span>
<span class="comment-copy">It seems like you are misunderstanding seeds. A PRNG only needs to be seeded <b>once</b> at the beginning of program execution. For non-cryptographic applications, it's usually just seeded with the current system time, or something like that.</span>
<span class="comment-copy">@Linuxios: If the goal is the <i>same</i> random result (per the question title), then reseeding would be needed to get the same result each time.</span>
<span class="comment-copy">@Mr.E Then the random colors are generated <i>once</i>, and mapped to the (x, y) pairs. The point here is somewhat pedantic and conceptual, but at the same time crucial: <b>random</b> functions should not (except rarely and by accident) produce the same output twice. If you want something to be "randomly generated the same way twice", you have fundamentally misunderstood randomness.</span>
<span class="comment-copy">Maybe you could use a simple hash function that returns values between -10 and 10? Something like x * y % 20 - 10 ?</span>
<span class="comment-copy">Thanks, nice idea with the <code>%20 - 10</code>, I'm trying to get an even distribution with using the <code>id</code> of each number, it's a bit harder than I thought but I'm getting there aha.</span>
<span class="comment-copy">So, slight problem. This is how your formula looks (zoomed out) - <a href="http://i.imgur.com/lcj8OYC.png" rel="nofollow noreferrer">i.imgur.com/lcj8OYC.png</a>, and this is how the cantor pairing function looks - <a href="http://i.imgur.com/xr7fcLy.png" rel="nofollow noreferrer">i.imgur.com/xr7fcLy.png</a>. Turns out it's actually quite difficult to do :P</span>
<span class="comment-copy">Alright, got it reasonably working. By using the inbuilt python hash on strings (I did <code>x=hash(str(x) + str(y / 2)); y=hash(str(y * x))</code>), it provides good enough values for the cantor pairing function, which I didn't link to before but I saw it here - <a href="http://stackoverflow.com/questions/919612/mapping-two-integers-to-one-in-a-unique-and-deterministic-way" title="mapping two integers to one in a unique and deterministic way">stackoverflow.com/questions/919612/â€¦</a></span>
