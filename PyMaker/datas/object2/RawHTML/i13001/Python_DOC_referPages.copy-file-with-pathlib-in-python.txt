<div class="post-text" itemprop="text">
<p>I try to copy a file with <code>pathlib</code></p>
<pre><code>import pathlib
import shutil

my_file=pathlib.Path('/etc/hosts')
to_file=pathlib.Path('/tmp/foo')
shutil.copy(my_file, to_file)
</code></pre>
<p>I get this exception:</p>
<pre><code>/home/foo_egs_d/bin/python /home/foo_egs_d/src/test-pathlib-copy.py
Traceback (most recent call last):
  File "/home/foo_egs_d/src/test-pathlib-copy.py", line 6, in &lt;module&gt;
    shutil.copy(my_file, to_file)
  File "/usr/lib/python2.7/shutil.py", line 117, in copy
    if os.path.isdir(dst):
  File "/home/foo_egs_d/lib/python2.7/genericpath.py", line 41, in isdir
    st = os.stat(s)
TypeError: coercing to Unicode: need string or buffer, PosixPath found

Process finished with exit code
</code></pre>
<p>... how to copy file with pathlib in Python 2.7?</p>
</div>
<div class="post-text" itemprop="text">
<p>So what about this?</p>
<pre><code>import pathlib
import shutil

my_file = pathlib.Path('/etc/hosts')
to_file = pathlib.Path('/tmp/foo')
shutil.copy(str(my_file), str(to_file))
</code></pre>
<p>The problem is <code>pathlib.Path</code> create a <code>PosixPath</code> object if you're using Unix/Linux, <code>WindowsPath</code> if you're using Microsoft Windows.</p>
<p>But <code>shutil.copy()</code> need string as arguments. So just use <code>str()</code> here, when you use <code>str()</code> function on a <code>Path</code> object it will return the original path.</p>
</div>
<div class="post-text" itemprop="text">
<p>The cause for <code>shutil.copy()</code> not working is that you are not using the latest Python, Python 3.6 <code>shutil.copy()</code> <strong>can</strong> handle <code>Path</code> objects (or subclasses thereof). That for older versions of Python this throws an error is because those implementations of <code>shutil</code> expect string arguments for <code>copy</code>, and not <code>pathlib.Path</code> type arguments. </p>
<p>What you actually want to be able to write is:</p>
<pre><code>my_file.copy(to_file)
</code></pre>
<p>You can subclass Path to include such a method, and adapt the creation of <code>my_file</code>. I find it easier to just graft/monkey-patch/duck-punch it on the existing <code>pathlib.Path</code></p>
<pre><code>from pathlib import Path


def _copy(self, target):
    import shutil
    assert self.is_file()
    shutil.copy(str(self), str(target))  # str() only there for Python &lt; (3, 6)

Path.copy = _copy
</code></pre>
<p>You can put this code anywhere you like, as long as it gets executed before calling the <code>.copy</code> method on any of the <code>Path</code> instances. The argument to <code>.copy()</code> can be a file or a directory.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.5, without importing <code>shutil</code>, you can do:</p>
<pre><code>from pathlib import Path

dest = Path('dest')
src = Path('src')
dest.write_bytes(src.read_bytes()) #for binary files
dest.write_text(src.read_text()) #for text files
</code></pre>
<p>For Python 2.7, <a href="http://pypi.python.org/pypi/pathlib2" rel="noreferrer"><code>pathlib2</code></a> provides the <code>read_bytes</code>, <code>read_text</code>, <code>write_bytes</code> and <code>write_text</code> methods.</p>
<p>The file will be loaded in memory, so this method is not suitable for files larger than the machines available memory.</p>
<p>As per the comments, one can use <code>write_bytes</code> and <code>read_bytes</code> to copy text files, but if you need to deal with the encoding at copy time <code>write_text</code> an <code>read_text</code> present the advantage of two extra parameters:</p>
<ul>
<li><code>encoding</code> is the name of the encoding used to decode or encode the file</li>
<li><code>errors</code> is an optional string that specifies how encoding and decoding errors are to be handled</li>
</ul>
<p>They both have the same meaning as in <a href="https://docs.python.org/3/library/functions.html#open" rel="noreferrer"><code>open()</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.rename" rel="nofollow noreferrer">pathlib</a> rename method instead of shutil.move().</p>
<pre><code>import pathlib

my_file = pathlib.Path('/etc/hosts')
to_file = pathlib.Path('/tmp/foo')
my_file.rename(to_file)
</code></pre>
</div>
<span class="comment-copy">This works without throwing an error on Python 3.6</span>
<span class="comment-copy">@Anthon we use Python 2.7.</span>
<span class="comment-copy">If I understood the problem you talk about correctly, then the code is not portable: <code>as_posix()</code> does not work on window. OK, <code>/etc/hosts</code> does not exist on windows, but the path object could be created from some config which defines a windows path "C:\....". Is there no portable solution?</span>
<span class="comment-copy">@guettli Edited, I forgot we can simply use <code>str()</code> here :P</span>
<span class="comment-copy">@guettli Actually if you're using <code>my_file.as_posix()</code> on Windows, it'll return <code>C:/etc/hosts</code>. So that doesn't matter.</span>
<span class="comment-copy">Don't take this personal: I though pathlib was made to make things easier. I guess I stick with using plain old strings like I used to do.</span>
<span class="comment-copy">I would also have expected Pathlib to be able to copy a file, given that it can move/rename and unlink/delete files.</span>
<span class="comment-copy">AFAIK this is called Monkey-Patching. Why does pathlib not provide this?</span>
<span class="comment-copy">I guess this is the reason why pathlib has no wide acceptance (according to my point of view). Good news is that the situation gets better with Python 3.6</span>
<span class="comment-copy">I'd say pathlib does not provide this functionality because that's not what it's meant for - just as <code>os.path</code> was not meant for file handling itself. The module's functionality is about file handling and file's metadata, but not about file handling, as far as I know.</span>
<span class="comment-copy">@mr.zog I don't think your intended audience will get notified that you wrote a comment when you just put in a name. You should consult the <a href="https://stackoverflow.com/editing-help#comment-formatting">help on formatting of comments</a> where it clearly states to use the <code>@</code> character</span>
<span class="comment-copy">@mr.zog There's indeed a mistake in that comment. What I meant to say was that pathlib is not meant to do file manipulation actions such as copying or moving.</span>
<span class="comment-copy">Is there a way to do this with Python 2.7?</span>
<span class="comment-copy">There is something for Python 2.7, namely <code>pathlib2</code> but I haven't tried it. <a href="https://pypi.python.org/pypi/pathlib2/" rel="nofollow noreferrer">pypi.python.org/pypi/pathlib2</a>. The <code>read_bytes</code> and <code>write_bytes</code> methods are in the source code, so I presume they work.</span>
<span class="comment-copy">@JacquesGaudin <code>pathlib2</code> works perfectly.</span>
<span class="comment-copy">@GeorgeSovetov Thanks I added it to the answer.</span>
<span class="comment-copy">With this method a sufficiently large file would crash Python with a <code>MemoryError</code>.  <code>shutil.copy</code> doesn't have this problem because it uses <code>shutil.copyfileobj</code> which buffers larger files into smaller chunks.</span>
<span class="comment-copy">Using <code>shutil.copy()</code> you will have two copies: the original and the target. If you use <code>Path.rename</code> your original is gone, so this is not related to what the op wants at all.</span>
<span class="comment-copy">path.rename does not work accross unix volumes....</span>
