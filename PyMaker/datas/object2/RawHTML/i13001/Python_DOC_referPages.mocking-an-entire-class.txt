<div class="post-text" itemprop="text">
<p>Long story short, I'm perfectly able to mock class method, when it's just that method that's replaced by mock object, but I'm unable to mock that method when I'm trying to replace the whole class by the mock object</p>
<p>The <code>@mock.patch.object</code> successfully mocks the <code>scan</code> method but <code>@mock.patch</code> fails to do so. I've followed the example at 
<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow">https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch</a>
but apparently I'm doing something wrong. </p>
<p>I'm mocking the lexicon module in the same namespace in both cases (it's imported by <code>import lexicon</code> in the <code>sentence_parser</code>) but the <code>mock_lexicon is lexicon.lexicon</code> check fails</p>
<pre class="lang-py prettyprint-override"><code>#!python
import sys;
sys.path.append('D:\python\lexicon');
import lexicon;

import sentence_parser;
import unittest2 as unittest;
import mock;

class ParserTestCases(unittest.TestCase) :

    def setUp(self) :
        self.Parser = sentence_parser.Parser();

    @mock.patch('lexicon.lexicon')
    def test_categorizedWordsAreAssigned_v1(self, mock_lexicon) :

        print "mock is lexicon:";
        print mock_lexicon is lexicon.lexicon + "\n";

        instance = mock_lexicon.return_value;
        instance.scan.return_value = "anything";    

        self.Parser.categorize_words_in_sentence("sentence");
        instance.scan.assert_called_once_with("sentence");

    @mock.patch.object(lexicon.lexicon, 'scan')
    def test_categorizedWordsAreAssigned_v2(self, mock_scan) :

        mock_scan.return_value = "anything";    

        self.Parser.categorize_words_in_sentence("sentence");
        mock_scan.assert_called_once_with("sentence");

if (__name__ == '__main__') :
    unittest.main()
</code></pre>
<p>Output :</p>
<pre><code>mock is lexicon:
False

======================================================================
FAIL: test_categorizedWordsAreAssigned_v1 (__main__.ParserTestCases)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "D:\python\get_img\getImage_env\lib\site-packages\mock\mock.py", line 1305, in patched
    return func(*args, **keywargs)
  File "./test_sentence_parser.py", line 26, in test_categorizedWordsAreAssigned_v1
    instance.scan.assert_called_once_with("sentence");
  File "D:\python\get_img\getImage_env\lib\site-packages\mock\mock.py", line 947, in assert_called_once_with
    raise AssertionError(msg)
AssertionError: Expected 'scan' to be called once. Called 0 times.

----------------------------------------------------------------------
Ran 2 tests in 0.009s

FAILED (failures=1)
</code></pre>
<p>EDIT :</p>
<p>To clarify, the <code>Parser</code> is defined as follows </p>
<pre><code>#!python

import sys;
sys.path.append('D:\python\lexicon');
import lexicon;

class Parser(object) :

    my_lexicon = lexicon.lexicon()

    def __init__(self) :
        self.categorized_words = ['test'];

    def categorize_words_in_sentence(self, sentence) :
        self.categorized_words = self.my_lexicon.scan(sentence);


if (__name__ == '__main__') :
    instance = Parser();
    instance.categorize_words_in_sentence("bear");
    print instance.categorized_words;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What is real relevant here is how <code>categorize_words_in_sentence</code> <code>Parser</code>'s method use <code>lexicon</code>. But first of all we should remove the noise:</p>
<pre><code>print mock_lexicon is lexicon.lexicon + "\n"
</code></pre>
<p>Is what can lead us to the wrong direction: try to replace it by</p>
<pre><code>self.assertIs(mock_lexicon, lexicon.lexicon)
</code></pre>
<p>and you will understand that you are printing <code>False</code> because <code>mock_lexicon</code> is not <code>lexicon.lexicon + "\n"</code> but just <code>lexicon.lexicon</code>.</p>
<p>Now I cannot tell you why the first test doesn't work because the answer is in <code>categorize_words_in_sentence</code> method or more probably in <code>sentence_parser</code> module where I can guess you can have something like </p>
<pre><code>from lexicon import lexicon
</code></pre>
<p>In both case take a look to <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow">Where to Patch</a> documentation that can enlighten you on what can be the cause and what you really need to patch in your case.</p>
<p>The second version works just because you are patching the object and not the reference (that should be different).</p>
<p>Finally the more concise and general version can be:</p>
<pre><code>@mock.patch('lexicon.lexicon.scan', return_value="anything")
def test_categorizedWordsAreAssigned_v3(self, mock_scan) :
    self.Parser.categorize_words_in_sentence("sentence")
    mock_scan.assert_called_once_with("sentence")
</code></pre>
<p>One more thing: remove <code>unittest2</code> at least you're not using python 2.4 and you are interested on backported unittest features.</p>
<p><strong>[EDIT]</strong></p>
<p>Now I can stop to guess and point to you why the first version doesn't work and will never work:</p>
<pre><code>class Parser(object) :
    my_lexicon = lexicon.lexicon()
</code></pre>
<p><code>Parser.my_lexicon</code> attribute is evaluated at the <em>load time</em>. That means when you import <code>sentence_parser</code> a <code>lexicon</code> is created and the reference associated to <code>Parser.my_lexicon</code>. When you patch <code>lexicon.lexicon</code> you leave this reference untouched and your parser object still use the original reference created when is imported.</p>
<p>What you can do is to patch the reference in <code>Parser</code> class by</p>
<pre><code>@patch("sentence_parser.Parser.my_lexicon")
</code></pre>
<p>You can use <a href="https://docs.python.org/3/library/unittest.mock.html#create-autospec" rel="nofollow"><code>create_autospect</code></a> if you want give to your mock the same <code>lexicon</code>'s signature.</p>
<pre><code>@patch("sentence_parser.Parser.my_lexicon", create_autospec("lexicon.lexicon", instance=True))
</code></pre>
</div>
<span class="comment-copy">Three question: 1) I took a look to <code>lexicon</code> module at <a href="https://github.com/bitprophet/lexicon/tree/master/lexicon" rel="nofollow noreferrer">github.com/bitprophet/lexicon/tree/master/lexicon</a> and seams to me the class is <code>Lexicon</code> instead <code>lexicon</code>; 2) my guess is that you have another <code>lexicon</code> module and not just the one in <code>D:\python\lexicon</code>; 3) why do you need <code>;</code> at the end of the lines ?</span>
<span class="comment-copy">1) <code>lexicon</code> is my own module that just happens to have the same name as the one you linked; 2) I have only two files in <code>D:\python\lexicon</code> one is <code>lexicon.py</code> and second one is <code>test_lexicon.py</code> containing unittests; 3) The <code>;</code> are just something I got used to in other languages, but that's not really relevant here</span>
<span class="comment-copy">I've stated in the original post that the lexicon is imported simply by <code>import lexicon;</code>. I've added the full <code>Parser</code> code to the original post. I've seen the Where to Patch. I know that could mock <code>scan</code> method only, but it annoys me that mocking an entire class doesn't work when theres no reason for it not to</span>
<span class="comment-copy">Updated... <code>Parser</code>'s class code was what is really relevant here.</span>
<span class="comment-copy">Thank you! It finally works. I need to read up on references in python, I hoped that such nuisances would be mentioned in Where to Patch documentation.</span>
<span class="comment-copy">I don't think that Where to Patch can cover these cases: that is how Python works and you should try to understand what happen on import and understand what is execute and what not. Personally I avoid to execute any kind of function/creation in the static part of the module/class.</span>
