<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/21260991/how-to-make-full-use-of-cpu-cores-with-threading-in-python-2">How to make full use of CPU cores with threading in python 2</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I've always struggled with multi-threaded program. My current understanding is when i create the multiple threads, it will run parallel. But it is not happening.</p>
<p>Here is code Ihave came so far.  </p>
<pre><code>#!/usr/bin/python

import threading
import time

class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):
        print "Starting " + self.name
        # Get lock to synchronize threads
        threadLock.acquire()
        print_time(self.name, self.counter, 3)
        # Free lock to release next thread
        threadLock.release()
        print "Exiting " + self.name

def print_time(threadName, delay, counter):
    while counter:
        time.sleep(delay)
        print "%s: %s" % (threadName, time.ctime(time.time()))
        counter -= 1

threadLock = threading.Lock()
threads = []

# Create new threads
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# Start new Threads
thread1.start()
thread2.start()

# Add threads to thread list
threads.append(thread1)
threads.append(thread2)

# Wait for all threads to complete
for t in threads:
    t.join()
print "Exiting Main Thread"
</code></pre>
<p>Output:</p>
<pre><code>Starting Thread-1
Starting Thread-2
Thread-1: Mon Nov 16 23:49:33 2015
Thread-1: Mon Nov 16 23:49:34 2015
Thread-1: Mon Nov 16 23:49:35 2015
Exiting Thread-1
Thread-2: Mon Nov 16 23:49:37 2015
Thread-2: Mon Nov 16 23:49:39 2015
Thread-2: Mon Nov 16 23:49:41 2015
Exiting Thread-2
Exiting Main Thread
</code></pre>
<p>I except both thread should run in parallel. but it is not happening. Please help me understanding the multithread program, Since i am new to multi-thread program in python. Thanks in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>You acquired a shared lock before printing in each thread. So of course they're not interleaving <code>print</code>s, the lock isn't being released while the first thread to acquire it sleeps, so the second thread is stuck waiting for the lock the whole time.</p>
<p>If the goal was to protect only the time prints, not the loop of prints from start to finish, you'd change the code for <code>run</code> and <code>print_time</code> to:</p>
<pre><code>    def run(self):
        print "Starting " + self.name
        # No locking now, letting print_time do it
        print_time(self.name, self.counter, 3)
        print "Exiting " + self.name

def print_time(threadName, delay, counter):
    while counter:
        time.sleep(delay)
        # Use a with statement to avoid problems with lock being held forever
        # if release() call skipped due to an exception (or coding error)
        with threadLock: # Hold lock during time and print, and at no other time
            print "%s: %s" % (threadName, time.ctime(time.time()))
        counter -= 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By the way:</p>
<blockquote>
<p>CPython implementation detail: In CPython, due to the Global Interpreter Lock, only one thread can execute Python code at once (even though certain performance-oriented libraries might overcome this limitation). If you want your application to make better use of the computational resources of multi-core machines, you are advised to use multiprocessing or concurrent.futures.ProcessPoolExecutor. However, threading is still an appropriate model if you want to run multiple I/O-bound tasks simultaneously.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/threading.html" rel="nofollow">Python threading</a></p>
<p>With or without the locks, you can't get true parallelism. You have to use <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow">multiprocessing</a> for that. </p>
</div>
<span class="comment-copy">See also: <a href="http://stackoverflow.com/q/3044580/1461210">stackoverflow.com/q/3044580/1461210</a></span>
<span class="comment-copy">@ShawdowRanger, Thanks for the reply. to make it run in parallel, what would be the best way?</span>
<span class="comment-copy">@Sandy: Was already adding that. Note: CPython's GIL means that, given the lack of access to shared data structures, you probably don't benefit from this lock. Locking to protect output from interleaving <i>might</i> be beneficial (and good practice), but you'd want to add the locking (individually) around the <code>Starting</code> and <code>Ending</code> prints too in that case.</span>
<span class="comment-copy">@Sandy: As an additional note, read up on the <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">CPython GIL</a>. In general, threading doesn't get you a big performance boost in Python (at least, not in CPU bound cases; for I/O bound code it can provide a benefit).</span>
<span class="comment-copy">After adding your code                                                                             Output is only                                                                                           Starting Thread-1 Starting Thread-2 . I really don't know what causing this issue</span>
<span class="comment-copy">@Sandy: Psychic debugging: You added the code to <code>print_time</code>, but didn't remove the <code>acquire</code> and <code>release</code> from <code>run</code>. Thus, one thread acquires the lock in <code>run</code>, then tries to reacquire it in <code>print_time</code>, and <code>Lock</code> is not reentrant; the lock can't be <code>acquire</code>-ed twice, even within the same thread.</span>
<span class="comment-copy">Yar, I commented to that effect; that said, the OP's particular case (at least as written) is I/O, lock acquisition and <code>sleep</code> bound, and all of those actions (being blocking actions implemented at the C layer) release the GIL.</span>
