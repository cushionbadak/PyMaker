<div class="post-text" itemprop="text">
<p>Function <code>foo</code> prints to console. I want to test the console print. How can I achieve this in python?</p>
<p>Need to test this function, has NO return statement : </p>
<pre><code>def foo(inStr):
   print "hi"+inStr
</code></pre>
<p>My test : </p>
<pre><code>def test_foo():
    cmdProcess = subprocess.Popen(foo("test"), stdout=subprocess.PIPE)
    cmdOut = cmdProcess.communicate()[0]
    self.assertEquals("hitest", cmdOut)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can easily capture standard output by just temporarily redirecting <code>sys.stdout</code> to a <code>StringIO</code> object, as follows:</p>
<pre><code>import StringIO
import sys

def foo(inStr):
    print "hi"+inStr

def test_foo():
    capturedOutput = StringIO.StringIO()          # Create StringIO object
    sys.stdout = capturedOutput                   #  and redirect stdout.
    foo('test')                                   # Call unchanged function.
    sys.stdout = sys.__stdout__                   # Reset redirect.
    print 'Captured', capturedOutput.getvalue()   # Now works as before.

test_foo()
</code></pre>
<p>The output of this program is:</p>
<pre><code>Captured hitest
</code></pre>
<p>showing that the redirection successfully captured the output and that you were able to restore the output stream to what it was before you began the capture.</p>
<hr/>
<p>Note that the code above in for Python 2.7, as the question indicates. Python 3 is slightly different:</p>
<pre><code>import io
import sys

def foo(inStr):
    print ("hi"+inStr)

def test_foo():
    capturedOutput = io.StringIO()                  # Create StringIO object
    sys.stdout = capturedOutput                     #  and redirect stdout.
    foo('test')                                     # Call function.
    sys.stdout = sys.__stdout__                     # Reset redirect.
    print ('Captured', capturedOutput.getvalue())   # Now works as before.

test_foo()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This Python 3 answer uses <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>unittest.mock</code></a>. It also uses a reusable helper method <code>assert_stdout</code>, although this helper is specific to the function being tested.</p>
<pre><code>import io
import unittest
import unittest.mock

from .solution import fizzbuzz


class TestFizzBuzz(unittest.TestCase):

    @unittest.mock.patch('sys.stdout', new_callable=io.StringIO)
    def assert_stdout(self, n, expected_output, mock_stdout):
        fizzbuzz(n)
        self.assertEqual(mock_stdout.getvalue(), expected_output)

    def test_only_numbers(self):
        self.assert_stdout(2, '1\n2\n')
</code></pre>
<p>Note that the <code>mock_stdout</code> arg is passed automatically by the <code>unittest.mock.patch</code> decorator to the <code>assert_stdout</code> method.</p>
<p>A general-purpose <code>TestStdout</code> class, possibly a mixin, can in principle be derived from the above.</p>
<p>For those using Python ≥3.4, <a href="https://docs.python.org/3/library/contextlib.html#module-contextlib" rel="nofollow noreferrer"><code>contextlib.redirect_stdout</code></a> also exists, but it seems to serve no benefit over <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer"><code>unittest.mock.patch</code></a>.</p>
</div>
<span class="comment-copy">duplicate <a href="http://stackoverflow.com/questions/12998908/is-it-possible-to-mock-pythons-built-in-print-function" title="is it possible to mock pythons built in print function">stackoverflow.com/questions/12998908/…</a> tl;dr turn print into builtin function using future or assert on replaced stdout file</span>
<span class="comment-copy">I dont want to mock anything. Infact my actual <code>foo</code> takes about 8 arguments, and it returns a json. I want to be also to test this.</span>
