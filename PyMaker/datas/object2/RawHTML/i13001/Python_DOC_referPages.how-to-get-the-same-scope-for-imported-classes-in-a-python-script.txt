<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/15959534/visibility-of-global-variables-in-imported-modules">Visibility of global variables in imported modules</a>
<span class="question-originals-answer-count">
                    7 answers
                </span>
</li>
</ul>
</div>
<p>It appears that a class defined in a script has a different scope to one that is imported into the script. For example:</p>
<p>In a file foo.py:</p>
<pre><code>class foo(object):
    def __init__(self):
        print globals()
</code></pre>
<p>In my main file:</p>
<pre><code>from foo import foo

class bar(object):
    def __init__(self):
        print globals()

classimport = foo()
classinternal = bar()
</code></pre>
<p>The list of globals returned from foo and bar are different - why is this? </p>
<p>It is making life difficult as any class that needs to access the main globals() has to reside in the main file. How do I ensure that the imported class has the same global scope? Some things that I have tried after reading other posts <a href="https://stackoverflow.com/questions/6347588/is-it-possible-to-import-to-the-global-scope-from-inside-a-function-python">here</a> and <a href="https://stackoverflow.com/questions/3106089/python-import-scope">here</a> include:</p>
<pre><code>module = __import__("foo", fromlist="foo")
globals()["foo"] = getattr(module, "foo")
</code></pre>
<p>and</p>
<pre><code>__builtin__.foo = foo
</code></pre>
<p>Any help appreciated!</p>
<p>[EDIT] ---</p>
<p>So per the link above, this is answered in a <a href="https://stackoverflow.com/questions/15959534/python-visibility-of-global-variables-in-imported-modules">duplicate article</a>. It turns out that scope is not shared across modules. It mentions several ways around this, but in my case I need to actually create / read / write global variables. So I created a routine in the main script and pass it as an object when foo and bar are initialized. For example:</p>
<pre><code>def PrintGlobals():
    print globals()

class bar(object):
    def __init__(self, PrintGlobals):
        self.PrintGlobals = PrintGlobals
        self.PrintGlobals()

classinternal = bar(PrintGlobals)
</code></pre>
<p>(Not my choice of how all this should work, its a hack until I get some time with the application devs :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's what the Python 3 <a href="https://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="nofollow noreferrer">FAQ</a> has to say:</p>
<blockquote>
<p>In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a value anywhere within the function’s body, it’s assumed to be a local unless explicitly declared as global.</p>
<p>Though a bit surprising at first, a moment’s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you’d be using global all the time. You’d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.</p>
</blockquote>
<p>To see globals in various scopes, try doing a print(globals()) at various points during your execution. For example: at the top-level module before any code is run, then in <code>__init__.py</code> if you have any code in there (because you import foo), at foo's module level, within each function, and before/after you modify any variables passed to the function.</p>
<p><a href="https://stackoverflow.com/a/15890156/3182836">This answer</a> further explains:</p>
<blockquote>
<p>I think the key thing you're missing here is that each module has its own "global" namespace. This can be a bit confusing at first, because in languages like C, there's a single global namespace shared by all external variables and functions. But once you get past that assumption, the Python way makes perfect sense.</p>
</blockquote>
<p>Note however that all names assigned in a package <code>__init__.py</code> file are available in the package namespace when you import the package or a module in the package.</p>
</div>
<span class="comment-copy">Instead of using globals, you'd be better off passing required information to functions or methods in a data type. If you use a dictionary for example, that works very well with **kwargs. Or consider using a package like PyYAML to read a configuration file if you need that. What specific problem are you trying to solve?</span>
<span class="comment-copy">Globals belong to the module where the function is defined.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/15959534/python-visibility-of-global-variables-in-imported-modules">This post</a> might give you a nice overview on this issue.</span>
