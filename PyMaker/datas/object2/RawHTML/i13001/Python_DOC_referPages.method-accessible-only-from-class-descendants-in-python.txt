<div class="post-text" itemprop="text">
<p>Let's say I have the following two classes</p>
<pre class="lang-py prettyprint-override"><code>class A:
    def own_method(self):
        pass
    def descendant_method(self):
        pass

class B(A):
    pass
</code></pre>
<p>and I want <code>descendant_method</code> to be callable from instances of <code>B</code>, but not of <code>A</code>, and <code>own_method</code> to be callable from everywhere. </p>
<p>I can think of several solutions, all unsatisfactory:</p>
<ol>
<li>Check some field and manually raise <code>NotImplementedError</code>:</li>
</ol>
<pre class="lang-py prettyprint-override"><code>class A:
    def __init__(self):
        self.some_field = None
    def own_method(self):
        pass
    def descendant_method(self):
        if self.some_field is None:
            raise NotImplementedError

class B(A):
    def __init__(self):
        super(B, self).__init__()
        self.some_field = 'B'
    pass
</code></pre>
<p>But this is modifying the method's runtime behaviour, which I don't want to do</p>
<ol start="2">
<li>Use a mixin:</li>
</ol>
<pre class="lang-py prettyprint-override"><code>class A:
    def own_method(self):
        pass

class AA:
    def descendant_method(self):
        pass

class B(AA, A):
    pass
</code></pre>
<p>This is nice as long as <code>descendant_method</code> doesn't use much from <code>A</code>, or else we'll have to inherit <code>AA(A)</code> and this defies the whole point</p>
<ol start="3">
<li>make method private in <code>A</code> and redefine it in a metaclass:</li>
</ol>
<pre class="lang-py prettyprint-override"><code>class A:
    def own_method(self):
        pass
    def __descendant_method(self):
        pass

class AMeta(type):
    def __new__(mcs, name, parents, dct):
        par = parents[0]
        desc_method_private_name = '_{}__descendant_method'.format(par.__name__)
        if desc_method_private_name in par.__dict__:
            dct['descendant_method'] = par.__dict__[desc_method_private_name]

        return super(AMeta, mcs).__new__(mcs, name, parents, dct)

class B(A, metaclass=AMeta):
    def __init__(self):
        super(B, self).__init__()
</code></pre>
<p>This works, but obviously looks dirty, just like writing <code>self.descendant_method = self._A__descendant_method</code> in <code>B</code> itself.</p>
<p>What would be the right "pythonic" way of achieving this behaviour?</p>
<p>UPD: putting the method directly in <code>B</code> would work, of course, but I expect that <code>A</code> will have many descendants that will use this method and do not want to define it in every subclass.</p>
</div>
<div class="post-text" itemprop="text">
<p>What is so bad about making <code>AA</code> inherit from <code>A</code>? It's basically an abstract base class that adds additional functionality that isn't meant to be available in <code>A</code>. If you really don't want <code>AA</code> to ever be instantiated then the pythonic answer is not to worry about it, and just document that the user isn't meant to do that. Though if you're really insistent you can define <code>__new__</code> to throw an error if the user tries to instantiate <code>AA</code>. </p>
<pre><code>class A:
    def f(self):
        pass

class AA(A):
    def g(self):
        pass
    def __new__(cls, *args, **kwargs):
        if cls is AA:
            raise TypeError("AA is not meant to be instansiated")
        return super().__new__(cls)

class B(AA):
    pass
</code></pre>
<p>Another alternative might be to make <code>AA</code> an <a href="https://docs.python.org/3/library/abc.html" rel="nofollow">Abstract Base Class</a>. For this to work you will need to define at least one method as being abstract -- <code>__init__</code> could do if there are no other methods you want to say are abstract.</p>
<pre><code>from abc import ABCMeta, abstractmethod

class A:
    def __init__(self, val):
        self.val = val
    def f(self):
        pass

class AA(A, metaclass=ABCMeta):
    @abstractmethod
    def __init__(self, val):
        super().__init__(val)
    def g(self):
        pass

class B(AA):
    def __init__(self, val):
        super().__init__(val)
</code></pre>
<p>Very finally, what's so bad about having the descendant method available on <code>A</code>, but just not using it. You are writing the code for <code>A</code>, so just don't use the method... You could even document the method that it isn't meant to be used directly by <code>A</code>, but is rather meant to be available to child classes. That way future developers will know your intentions.</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I can tell, this may be the most Pythonic way of accomplishing what you want:</p>
<pre><code>class A:
    def own_method(self):
        pass
    def descendant_method(self):
        raise NotImplementedError

class B(A):
    def descendant_method(self):
        ...
</code></pre>
<p>Another option could be the following:</p>
<pre><code>class A:
    def own_method(self):
        pass
    def _descendant_method(self):
        pass

class B(A):
    def descendant_method(self):
        return self._descendant_method(self)
</code></pre>
<p>They're both Pythonic because it's <em>explicit, readable, clear and concise</em>.</p>
<ul>
<li>It's explicit because it's not doing any unnecessary magic.</li>
<li>It's readable because
one can tell precisely what your doing, and what your intention was
at first glance.</li>
<li>It's clear because the leading single underscore is
a widely used convention in the Python community for private
(non-magic) methodsâ€”any developer that uses it should know to tread
with caution.</li>
</ul>
<p>Choosing between one of these approaches will depend on how you intend on your use case. A more concrete example in your question would be helpful.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try to check the class name using <code>__class__.__name__</code> .</p>
<pre><code>class A(object):

    def descendant_method(self):
        if self.__class__.__name__ == A.__name__:
            raise NotImplementedError
        print 'From descendant'


class B(A):
    pass


b = B()
b.descendant_method()
a = A()
a.descendant_method()
</code></pre>
</div>
<span class="comment-copy">If self._<i>class_</i> == A?  Not isinstance, equality test?  I've done that to avoid registering "abstract" classes when only the concrete ones could be used.</span>
<span class="comment-copy">This is kind of an awkward requirement of a method, which usually indicates you're approaching your problem wrong. Please expalin <i>why</i> you want to do that, and what's the original problem you're trying to solve using this design. There might be a better approach.</span>
<span class="comment-copy">@JLPeyret, yes, this would be better than my number 1, but I still want to avoid any runtime checking</span>
<span class="comment-copy">Wonder if you could use a <i>property</i> that returned descendant only on != A.  That would leave descendant itself alone.   And have you looked at ABC module? Not that familiar with it but it seems it's the kinda stuff it looks after.</span>
<span class="comment-copy">@shx2, updated the question. There will be many subclasses to make use of this method, and I want to only define it once; but calling it in the parent class makes no sense.</span>
<span class="comment-copy">Agree with just not using from A.  But, depending on what the method does, you could also implement a do-nothing behavior when calling from A - return wo changes if the method modifies things, return an empty list if it is meant to return members, etc...   Ultimately, while the not-from-A requirement may have its reason, insisting that descendant_m itself remains blissfully unaware of that in its implementation may be unrealistic.</span>
<span class="comment-copy">Thanks, these are valid points. I would add to this an abstract <code>descendant_method</code> in A to indicate it does not belong there, as in question update.</span>
<span class="comment-copy">One objection may be that the class <code>B</code> now contains two methods that do the same thing</span>
