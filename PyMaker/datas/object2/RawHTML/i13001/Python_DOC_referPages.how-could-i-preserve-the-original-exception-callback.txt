<div class="post-text" itemprop="text">
<p>Currently, if I execute sample.py I can get the exception information on the exported text file.</p>
<p>However, once the exception happens the program won't show the exception and the screen,</p>
<p>and it won't execute the following code. So I didn't see the string <code>"you should check the result on export file"</code> on the terminal</p>
<p>How could I get what i want . thanks~</p>
<h1>exception_hook.py</h1>
<pre><code>def handleException(excType, excValue, trace):
    file = StringIO()
    cgitb.Hook(file=file, display=True, format='text')(excType, excValue, trace)
    ...
sys.excepthook = handleException
</code></pre>
<h1>sample.py</h1>
<pre><code>import excepthook
def test_divide_zero_exception():
    register_exception_sender("Test")
    1/0
    print("you should check the result on export file")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.7, this is the <a href="https://docs.python.org/2/library/sys.html#sys.excepthook" rel="nofollow">documentation of <code>sys.excepthook()</code></a>:</p>
<blockquote>
<p>This function prints out a given traceback and exception to sys.stderr.</p>
<p>When an exception is raised and uncaught, the interpreter calls sys.excepthook with three arguments, the exception class, exception instance, and a traceback object. In an interactive session this happens just before control is returned to the prompt; <strong>in a Python program this happens just before the program exits.</strong> The handling of such top-level exceptions can be customized by assigning another three-argument function to sys.excepthook.</p>
</blockquote>
<p>(The documentation is <a href="https://docs.python.org/3/library/sys.html#sys.excepthook" rel="nofollow">substantially the same in 3.x</a>.)</p>
<p>It is not reasonably possible (without fiddling with bytecode and implementation details, or doing highly complex AST transforms on your code) to resume execution right where the exception happened.  It <em>is</em> possible to get the "standard" behavior of printing a traceback, by calling the original <code>sys.excepthook()</code> function:</p>
<pre><code>import sys
original_excepthook = sys.excepthook

def handleException(excType, excValue, trace):
    file = StringIO()
    cgitb.Hook(file=file, display=True, format='text')(excType, excValue, trace)
    ...
    original_excepthook(excType, excValue, trace)

 sys.excepthook = handleException
</code></pre>
<p>This will print a traceback as normal, in addition to whatever customization you've installed.  It will not allow you to resume where the exception originated, however.  If you want to handle exceptions on a case-by-case basis, you need to use <a href="https://docs.python.org/2/tutorial/errors.html#handling-exceptions" rel="nofollow"><code>try</code>/<code>except</code></a> instead.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>and it won't execute the following code. So I didn't see the string
  "you should check the result on export file" on the terminal</p>
</blockquote>
<p>I think you are trying to do something too complex when you actually need a try-except block.</p>
<pre><code>import traceback
try:
    x = 1/0
    self.some_code_that_depends_on_x(x)

except: # try to catch specific exceptions here 
    traceback.print_exc(file=sys.stderr) # or your exception file

print("you should check the result on export file") # the following code works
</code></pre>
</div>
<span class="comment-copy">I mean... it isn't reasonable but it's doable. You could use the inspect package to find out what method was being called, and then call it again, which sounds like a great way to get a huge loop of identical problems. Try/except is obviously a much better (and accepted) solution, but if you REALLY didn't want your code to stop when unexpected things happen...</span>
<span class="comment-copy">@en_Knight: That's not good enough.  You have to rebuild the whole call stack, which is going to be inordinately complicated if you want it to e.g. work on PyPy.</span>
<span class="comment-copy">The inspect package may be Cython dependent, but it would build the call stack for you. And you may not even need the call stack for something very simple and not context dependent, but for something complex it certainly isn't a robust solution. I agree with your answer (and upvoted it).</span>
<span class="comment-copy">@en_Knight: If you just want to re-run the whole program, you don't need <code>sys.excepthook</code> in the first place.  Just write <code>while True: try: main() except: pass</code> and you're done.  If you want to re-run the specific function that was executing, you (almost certainly) need to handle that function returning, in which case you need the full call stack (or at least the next item on the call stack, but then you have to handle <i>that</i> returning and so on).</span>
<span class="comment-copy">I like that while loop, I think I'm adding it my production code, I'll never see another pesky bug! :) Nah I can think of reasonable applications where that wouldn't be necessary, like a gui with bindings. Maybe I click a button and then input something bazaar and unexpected on the dialog that pops up. Sure, the dialog crashed, but it might be reasonable just to start it up again. In general, if the function is parametrized by class fields or a global state, not arguments, it might be possible to pull off. I don't recommend it, but it's doable</span>
