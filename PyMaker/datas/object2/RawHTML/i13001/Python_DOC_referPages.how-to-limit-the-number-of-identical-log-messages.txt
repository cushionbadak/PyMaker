<div class="post-text" itemprop="text">
<p>I use the <a href="https://docs.python.org/3/library/logging.html" rel="nofollow">logging</a> module to warn about issues with some routines. These routines may be run several times before getting back to normal operations (e.g. repeated queries to an API which fail, but eventually go through). Each failed call triggers a log entry.</p>
<p><strong>Is there a way to limit the number of identical log messages?</strong><br/>
I would like this limit to fire off after <code>n</code> identical messages being output, then possibly inform that <code>n</code> more were generated (so not to clutter the log file) and reset once a recovery log is received.  This is the ideal scenario - I am looking at how to approach the problem to start with.</p>
<p>The closest I found was the <a href="https://docs.python.org/3/howto/logging-cookbook.html#buffering-logging-messages-and-outputting-them-conditionally" rel="nofollow">conditional release of logs</a> but I do not see how this could be adapted to my case.<br/>
 Another possibility would be to put the limit at the syslog level (in <code>rsyslog</code> or <code>syslog-ng</code>) but this is a "per process" setting so I could lose useful logs (the ones which would come in between the loop-generated ones)</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a <code>logging.Filter</code>!</p>
<p>The <code>DuplicateFilter</code> takes two regex patterns or a string (to be compiled into one), one that should match against the string you want to filter out, and one you want to reset the filter at. </p>
<pre><code>import logging
import os
import re
import sys

from sre_parse import Pattern


class DuplicateFilter(logging.Filter):
    def __init__(self, match_against, reset_at_message, hide_at_count=5, name=''):
        super(DuplicateFilter, self).__init__(name)

        if isinstance(match_against, Pattern):
            self.match_against = match_against
        else:
            self.match_against = re.compile(match_against)

        if isinstance(reset_at_message, Pattern):
            self.reset_at_message = reset_at_message
        else:
            self.reset_at_message = re.compile(reset_at_message)

        self.hide_at_count = hide_at_count

        self.count = 0

    def filter(self, record: logging.LogRecord):
        _ = super(DuplicateFilter, self).filter(record)
        if not _:
            return _

        msg = record.getMessage()

        if self.match_against.match(msg):
            self.count += 1

            if self.count &gt;= self.hide_at_count:
                return False

        elif self.reset_at_message.match(msg):
            record.msg = os.linesep.join([
                '{:d} more generated'.format(self.count - self.hide_at_count),
                record.msg
            ])
            self.count = 0

        return True

handler = logging.StreamHandler(sys.stdout)
handler.addFilter(DuplicateFilter('Filter me!', 'Reset at me'))

logging.basicConfig(level='INFO', handlers=[handler, ])

log = logging.getLogger()

for _ in range(10):
    log.info('Filter me!')

log.info('Reset at me')

for _ in range(3):
    log.info('Filter me!')
</code></pre>
<p>This is the resulting log:</p>
<pre><code>INFO:root:Filter me!
INFO:root:Filter me!
INFO:root:Filter me!
INFO:root:Filter me!
INFO:root:5 more generated
Reset at me
INFO:root:Filter me!
INFO:root:Filter me!
INFO:root:Filter me!
</code></pre>
<p>Just pre-pending the "5 more generated" message probably isn't what you want, but hopefully this is a good starting point.</p>
</div>
<span class="comment-copy">I'm not sure how your link <i>doesn't</i> apply to your situation. Maybe I'm dense -- can you explain how your use case differs from the example? If you're expecting failures, how many and in what specific case do you want them to start logging?</span>
<span class="comment-copy">My use case is to limit the number of identical messages after receiving <code>n </code> identical ones, then possibly output a information about the count. I will make that clear in the question, thanks. The linked example is about holding off all messages until a condition is met, then to release them or not. I have mixed messages, out of which I would like to limit the number of identical ones. I am just an amateur in Python and I do not see how I could manipulate the messages held in <code>MemoryHandler</code>.</span>
<span class="comment-copy">One way you could do this: Use some sort of state. When something fails, call a method <code>setState(state, message)</code>; e.g. <code>setState(WARN, "failed to connect")</code>. Inside this method, log the message only if not already in state <code>WARN</code>. Then, when the connection is established, call <code>setState(OKAY, "connection successful")</code>. Or similar, a method <code>logConditional(message)</code> that only logs this message if the (cached) previous message was not the same message. Of course, there are limitations to both, and whether its applicable depends on your exact use case.</span>
<span class="comment-copy">@tobias_k: interesting approach, thanks. This is not a solution native to <code>logging</code> (I was hoping for that) but otherwise makes sense and is flexible.</span>
