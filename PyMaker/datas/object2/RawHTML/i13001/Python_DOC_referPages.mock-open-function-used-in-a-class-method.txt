<div class="post-text" itemprop="text">
<p>I tried to mock the open function used in a method of my class.
I found this thread <a href="https://stackoverflow.com/questions/1289894/how-do-i-mock-an-open-used-in-a-with-statement-using-the-mock-framework-in-pyth">How do I mock an open used in a with statement (using the Mock framework in Python)?</a> but could not solve my issue. Also the unittest documention shows a solution which also didn't mock my open <a href="https://docs.python.org/3/library/unittest.mock-examples.html#patch-decorators" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock-examples.html#patch-decorators</a></p>
<p>This is my class with the method where the open function is used:</p>
<pre><code>#__init.py__

import json

class MyClass:

    def save_data_to_file(self, data):
        with open('/tmp/data.json', 'w') as file:
            json.dump(data, file)
...
mc = MyClass()
</code></pre>
<p>Now I found a little different solution. This is my test:</p>
<pre><code>#save_to_file_test.py

from mymodule import MyClass
from mock import mock_open, patch
import ast

class SaveToFileTest(unittest.TestCase):

    def setUp(self):
        self.mc = MyClass()
        self.data = [
            {'id': 5414470, 'name': 'peter'},
            {'id': 5414472, 'name': 'tom'},
            {'id': 5414232, 'name': 'pit'},
        ]

    def test_save_data_to_file(self):
        m = mock_open()
        with patch('mymodule.open', m, create=True):
            self.mc.save_data_to_file(self.data)
            string = ''
            for call in m.return_value.write.mock_calls:
                string += (call[1][0])
            list = ast.literal_eval(string)
            assertEquals = (list, self.data)
</code></pre>
<p>I'm not sure if this is the best way to test the content which should be written to a file.
When I test the mock_calls (call_args_list is the same) this are the arguments which are passed to the file handle.
Any advice, improvements and suggestions are welcome.</p>
</div>
<div class="post-text" itemprop="text">
<h1>TL;DR</h1>
<p>The heart of your problem is that you <em>should</em> be also mocking <code>json.dump</code> to be able to properly test the data that is going to be written to your file. I actually had a hard time running your code until a few important adjustments were made to your test method. </p>
<ul>
<li>Mock with <code>builtins.open</code> and not <code>mymmodule.open</code></li>
<li>You are in a context manager, so you should be checking <code>m.return_value.__enter__.write</code>, however you are actually calling the write from json.dump which is where the write will be called. (Details below on a suggested solution) </li>
<li>You should also mock <code>json.dump</code> to simply validate it is called with your data</li>
</ul>
<p>In short, with the issues mentioned above, the method can be re-written as: </p>
<p><em>Details about all this below</em></p>
<pre><code>def test_save_data_to_file(self):
    with patch('builtins.open', new_callable=mock_open()) as m:
        with patch('json.dump') as m_json:
            self.mc.save_data_to_file(self.data)

            # simple assertion that your open was called 
            m.assert_called_with('/tmp/data.json', 'w')

            # assert that you called m_json with your data
            m_json.assert_called_with(self.data, m.return_value)
</code></pre>
<h1>Detailed Explanation</h1>
<p>To focus on the problems I see in your code, the first thing I strongly suggest doing, since <code>open</code> is a builtin, is to mock from builtins, furthermore, you can save yourself a line of code by making use of <code>new_callable</code> and <code>as</code>, so you can simply do this:</p>
<pre><code>with patch('builtins.open', new_callable=mock_open()) as m:
</code></pre>
<p>The next problem that I see with your code as I had trouble running this until I actually made the following adjustment when you started looping over your calls:</p>
<pre><code>m.return_value.__enter__.return_value.write.mock_calls
</code></pre>
<p>To dissect that, what you have to keep in mind is that your method is using a context manager. In using a context manager, the work of your write will actually be done inside your <code>__enter__</code> method. So, from the <code>return_value</code> of your <code>m</code>, you want to then get the return_value of <code>__enter__</code>. </p>
<p>However, this brings us to the heart of the problem with what you are trying to test. Because of how the <code>json.dump</code> works when writing to the file, your <code>mock_calls</code> for your write after inspecting the code, will actually look like this: </p>
<pre><code>&lt;MagicMock name='open().write' id='4348414496'&gt;
call('[')
call('{')
call('"name"')
call(': ')
call('"peter"')
call(', ')
call('"id"')
call(': ')
call('5414470')
call('}')
call(', ')
call('{')
call('"name"')
call(': ')
call('"tom"')
call(', ')
call('"id"')
call(': ')
call('5414472')
call('}')
call(', ')
call('{')
call('"name"')
call(': ')
call('"pit"')
call(', ')
call('"id"')
call(': ')
call('5414232')
call('}')
call(']')
call.__str__()
</code></pre>
<p>That is not going to be fun to test. So, this brings us to the next solution you can try out; Mock <code>json.dump</code>. </p>
<p>You shouldn't be testing json.dump, you should be testing calling it with the right parameters. With that being said, you can follow similar fashion with your mocking and do something like this: </p>
<pre><code>with patch('json.dump') as m_json:
</code></pre>
<p>Now, with that, you can significantly simplify your test code, to simply validate that the method gets called with your data that you are testing with. So, with that, when you put it all together, you will have something like this:</p>
<pre><code>def test_save_data_to_file(self):
    with patch('builtins.open', new_callable=mock_open()) as m:
        with patch('json.dump') as m_json:
            self.mc.save_data_to_file(self.data)

            # simple assertion that your open was called 
            m.assert_called_with('/tmp/data.json', 'w')

            # assert that you called m_json with your data
            m_json.assert_called_with(self.data, m.return_value.__enter__.return_value)
</code></pre>
<p>If you're interested in further refactoring to make your test method a bit cleaner, you could also set up your patching as a decorator, leaving your code cleaner inside the method: </p>
<pre><code>@patch('json.dump')
@patch('builtins.open', new_callable=mock_open())
def test_save_data_to_file(self, m, m_json):
    self.mc.save_data_to_file(self.data)

    # simple assertion that your open was called
    m.assert_called_with('/tmp/data.json', 'w')

    # assert that you called m_json with your data
    m_json.assert_called_with(self.data, m.return_value.__enter__.return_value)
</code></pre>
<p>Inspecting is your best friend here, to see what methods are being called at what steps, to further help with the testing. Good luck. </p>
</div>
<span class="comment-copy">Thanks idjaw, i adopted your solution.   But when i change 'mymodule.open' to 'builtins.open' i got a AssertionError: Expected call: mock('/tmp/data.json', 'w') Not called. With 'mymodule.open' it works perfectly. I tried also to 'import <b>builtin</b> as builtins' found this somewhere, because using Python 2.7, the problem resists, and the mock is not called. Btw: Code of mock_calls looked excatly like you described. That's the reason why i was building a string in a loop and used 'ast' to create a list from it. Your solution is really more elegant and and comes with less code.</span>
<span class="comment-copy">@surfi Glad this helped. I didn't realize you were using Python 2. Can you actually try <code>'__builtin__.open'</code>. I just had success with that. There is actually another way to further clean up your code if you're interested. You can do your mock patching as a decorator instead of using the context manager inside the method. I can update to show.</span>
<span class="comment-copy">I am not sure it changes anything in the case of writing, however you should pass a constructor to the <code>new_callable</code> argument. It should look like: <code>@patch('builtins.open', new_callable=mock_open)</code></span>
<span class="comment-copy">I am writing a similar test for a function that uses json.load to open a json file. Is there a way to run an assertion to verify that the json object, when loaded from a file that is mocked, is correct?</span>
<span class="comment-copy">Such a thorough answer.  I wish you could provide one of testing a read file function.</span>
