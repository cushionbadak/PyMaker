<div class="post-text" itemprop="text">
<p>I'n reading through <a href="http://blog.thedigitalcatonline.com/blog/2014/09/01/python-3-oop-part-5-metaclasses/#.Vv1T7zG1XGA" rel="nofollow">http://blog.thedigitalcatonline.com/blog/2014/09/01/python-3-oop-part-5-metaclasses/#.Vv1T7zG1XGA</a> ,  which contains:</p>
<blockquote>
<p>Since in Python everything is an object, everything is the instance of a class, even classes. Well, type is the class that is instanced to get classes. So remember this: object is the base of every object, type is the class of every type. Sounds puzzling? It is not your fault, don't worry. However, just to strike you with the finishing move, this is what Python is built on</p>
</blockquote>
<pre><code>&gt;&gt;&gt; type(object)
&lt;class 'type'&gt;
&gt;&gt;&gt; type.__bases__
(&lt;class 'object'&gt;,)
</code></pre>
<p>I'm having trouble understanding this, Can anyone explain this relationship in a different way to make it clearer? </p>
</div>
<div class="post-text" itemprop="text">
<p>The relationship between <code>type(x)</code> is basically the same as the result of <code>x.__class__</code>:</p>
<pre><code>for obj in (object,type,1,str):
    assert type(obj) is obj.__class__

print("type(obj) and obj.__class__ gave the same results in all test cases")
</code></pre>
<p><code>__bases__</code> represents the bases that a class is derived from:</p>
<pre><code>class parent:
    pass

class child(parent,int):
    pass

print(child.__bases__)
</code></pre>
<p>however if you are asking about the odd relationship between <code>object</code> and <code>type</code>:</p>
<pre><code>&gt;&gt;&gt; isinstance(object, object)
True
&gt;&gt;&gt; isinstance(type, type)
True
&gt;&gt;&gt; isinstance(object, type)
True
&gt;&gt;&gt; isinstance(type, object)
True
</code></pre>
<p>that is more of a chicken vs. egg question: which came first?</p>
<p>The answer is <code>PyObject</code> which is defined in C.</p>
<p>before either <code>object</code> or <code>type</code> is available to the python interpreter their underlying mechanisms are defined in C and the instance checking is overrided after they are defined. (act like abstract classes, see <a href="https://www.python.org/dev/peps/pep-3119/" rel="nofollow">PEP 3119</a>)</p>
<p>you can consider it something like this python implementation:</p>
<pre><code>#this wouldn't be available in python
class superTYPE(type):
    def __instancecheck__(cls,inst):
        if inst ==TYPE:
            return True
        else:
            return NotImplemented #for this demo

class TYPE(type,metaclass=superTYPE):
    def __instancecheck__(cls,inst):
        if inst in (OBJECT,TYPE):
            return True
        else:
            return NotImplemented #for this demo

class OBJECT(metaclass=TYPE):
    pass

print(isinstance(TYPE,OBJECT))
print(isinstance(OBJECT,TYPE))
print(isinstance(TYPE,TYPE))
print(isinstance(OBJECT,OBJECT))
</code></pre>
<p>actually it may be better represented as:</p>
<pre><code>#this isn't available in python
class superTYPE(type):
    def __instancecheck__(cls,inst):
        if inst in (TYPE,OBJECT):
            return True
        else:
            return NotImplemented #for this demo

class OBJECT(metaclass=superTYPE):
    pass


class TYPE(OBJECT):
    pass
</code></pre>
<p>but again if you want to know exactly how it works you would need to look at the source code written in C.</p>
</div>
<div class="post-text" itemprop="text">
<h1>TL;DR - probably not. But I tried.</h1>
<p>This is really weird and feels like turtles all the way down. I've actually not delved into this arena very much before, though it's something that sounded fun and powerful. This explanation was confusing, and so was the rest of the information on that page, but I <em>feel</em> like I have some enlightenment. Whether or not I can explain that clearly, I'm not sure, but I'll have a go.</p>
<p>Let's look at the turtles, first:</p>
<pre><code>&gt;&gt;&gt; isinstance(type, object)
True
&gt;&gt;&gt; isinstance(object, type)
True
</code></pre>
<p>Wait, what?</p>
<p>How is <code>object</code> an instance of <code>type</code>, when <code>type</code> is an instance of <code>object</code>? That feels like saying something like:</p>
<pre><code>class Parrot: pass

ex = Parrot()

isinstance(ex, Parrot)
isinstance(Parrot, ex)
</code></pre>
<p>Should be <code>True</code> both times. But obviously it's not. Even (as Tadhg McDonald-Jensen pointed out)</p>
<pre><code>&gt;&gt;&gt; isinstance(type, type)
True
</code></pre>
<p>This should indicate to you that there is some magic going on behind the scenes. So at this point, let's just completely forget about Python (I know, why would we ever want to do such a horrible thing?)</p>
<p>In general, all computer programs are are 1's and 0's <sub><sup>(and more accurately they're just a bunch of logic gates and electrons at &gt;~2.5v and ~&lt;2.5v, but 0's and 1's are good enough)</sup></sub>. Whether you wrote it in assembly, actual machine code, Python, C#, Java, Perl, whatever - they're all just bits.</p>
<p>If you write a class definition, that class is just bits. An instance of that class is just more bits. And a programming language and a compiler and an interpreter is just even more bits.</p>
<p>In the case of Python, it's the <code>python</code> interpreter that gives meaning to the bits that are our Python programs. As an interesting point, a lot of what we typically consider to be Python is actually written in Python (though most of it is C, for us CPython folks, Java for Jython, etc.).</p>
<p>So now we come to this thing we call <code>type</code> and <code>object</code>. As the article points out, they're kind of special. So, we know that we can create a class, and then that class is an object:</p>
<pre><code>&gt;&gt;&gt; class Confusion: pass
...
&gt;&gt;&gt; isinstance(Confusion, object)
</code></pre>
<p>Which makes sense, if you think about it - you may have created class-level variables:</p>
<pre><code>&gt;&gt;&gt; class Counter:
...  count = 0
...  def __init__(self):
...   Counter.count += 1
...   print(self.count)
...
&gt;&gt;&gt; Counter()
1
&lt;__main__.Counter object at 0x7fa03fca4518&gt;
&gt;&gt;&gt; Counter()
2
&lt;__main__.Counter object at 0x7fa03fca4470&gt;
&gt;&gt;&gt; Counter()
3
&lt;__main__.Counter object at 0x7fa03fca4518&gt;
&gt;&gt;&gt; Counter()
4
&lt;__main__.Counter object at 0x7fa03fca4470&gt;
&gt;&gt;&gt; Counter.count
4
&gt;&gt;&gt; Counter.__repr__(Counter)
'&lt;type object at 0x1199738&gt;'
</code></pre>
<p>But as this last example shows (and is mentioned in the post), a class declaration, what you get with <code>class SomeClass: pass</code>, that declaration of a class is actually an <em>instance</em> of another class. In particular, it's an instance of the <code>type</code> class. And that <em>instance</em> (which we call a class) when called will produce an <em>instance</em> of itself:</p>
<pre><code>&gt;&gt;&gt; Counter.__call__()
5
&lt;__main__.Counter object at 0x7fa03fca4518&gt;
</code></pre>
<p>So what does all this have to do with the relationship between <code>type</code> and <code>object</code>?</p>
<p>Well, <em>somewhere</em>, <code>python</code> creates a series of bits that is <code>object</code>, and a series of bits that is <code>type</code>, and then wires them together in such a way that</p>
<pre><code>&gt;&gt;&gt; type.__bases__
(&lt;class 'object'&gt;,)
&gt;&gt;&gt; object.__bases__
()
</code></pre>
<p>Because I currently don't feel like looking through the source, I'm going to make a guess that <code>type</code> is created first, and <code>object</code> is produced from that type and that <code>type.__bases__</code> is set to <code>(class 'object')</code>. By creating this circular relationships between <code>type</code> and <code>object</code>, it gives the appearance that it's just turtles all the way down, when really the last two turtles are just standing on top of each other.</p>
<p>I don't think there's <em>really</em> a better way to explain what's going on here than how the article describes it - at least in a classical OOP is-a/has-a style of thinking, because it's not actually that sort of thing. Like trying to plot a 3d figure in 2d space, you're going to have problems.</p>
<p>It's just two sets of bits that have some bits inside them that happen to be the address of one another.</p>
</div>
<div class="post-text" itemprop="text">
<p>While my first answer addresses the paradoxical relationship between the python builtin variables <code>type</code> and <code>object</code>, it doesn't necessarily try to clear up the confusion about what exactly <code>type</code> and <code>object</code> mean in the bigger picture.  This answer will explain how <code>object</code> and <code>type</code> affect other python objects in the context that you will likely see in practice.</p>
<blockquote>
<p>In Python everything is an <code>object</code></p>
</blockquote>
<p>This means that the statement <code>isinstance(x, object)</code> will always give <code>True</code> for any possible value <code>x</code>. </p>
<p>This also means that any class that is defined will be considered a subclass of object. So <code>issubclass(x, object)</code> is always true for any class.</p>
<p>Practically this means operations that are standard across all python objects will be defined in <code>object</code>, things like attribute lookup and getting the size of an object in memory.  It also defines behaviours that are commonly overridden like converting to a string or initialization, so if you don't override <code>__str__</code> or <code>__init__</code> in your subclass it will still do something reasonable.</p>
<blockquote>
<p><code>type</code> is the class that is instanced to get classes</p>
</blockquote>
<p>This means that all classes are considered instances of <code>type</code>. So <code>isinstance(x, type)</code> will be true for all classes. When I say classes I mean things like <code>int</code>, <code>str</code>, <code>bool</code> or the variable created by the <code>class</code> keyword.</p>
<blockquote>
<p>everything is an object -  <strong>even classes.</strong></p>
</blockquote>
<p>This means that the standard behaviour that exists for all objects is also applied to class objects.  So writing <code>str.join</code> will lookup the <code>join</code> method and give you <code>&lt;method 'join' of 'str' objects&gt;</code></p>
<blockquote>
<p>type is the class of every type</p>
</blockquote>
<p>so in the same way that <code>int</code> defines what <code>1+3</code> should do or <code>str</code> defines methods for strings, <code>type</code> defines behaviour that is specific to type objects. For example calling a class object (like <code>int("34")</code>) will create a new instance of that class - this behaviour of creating new objects is defined in <code>type.__call__</code> method.</p>
<p>As a more concrete example look at the duality between <code>str.join</code> and <code>type.mro</code></p>
<pre><code>&gt;&gt;&gt; x = "hello"
&gt;&gt;&gt; str.join # unbound method of strings
&lt;method 'join' of 'str' objects&gt;
&gt;&gt;&gt; x.join #bound method of x
&lt;built-in method join of str object at 0x109bf23b0&gt;
&gt;&gt;&gt; hex(id(x)) # the memory address of x as seen above
'0x109bf23b0'

&gt;&gt;&gt; type.mro #unbound method
&lt;method 'mro' of 'type' objects&gt;
&gt;&gt;&gt; int.mro #mro method bound to int
&lt;built-in method mro of type object at 0x106afeca0&gt;
&gt;&gt;&gt; hex(id(int)) # address of int object as seen above
'0x106afeca0'
&gt;&gt;&gt; int.mro() #mro stands for Method Resolution Order, is related to __bases__
[&lt;class 'int'&gt;, &lt;class 'object'&gt;]
</code></pre>
<p>So every class defines methods that act on its instances, behaviours of classes themselves is defined in the <code>type</code> class. </p>
<p>Behaviour that is common to all objects - the kind of things you usually just write off as builtin - are defined by <code>object</code> so all objects share those behaviours (unless a subclass overrides it :)</p>
<p>P.S. In the same way you can make a subclass of <code>str</code> to create special string objects that have different behaviour, you can create a subclass of <code>type</code> to create special classes that have different behaviour.  This is called a <strong>meta-class</strong> (the class of a class object) and the <a href="https://docs.python.org/3/library/abc.html#abc.ABCMeta" rel="nofollow noreferrer">practical applications of using meta-classes are usually abstract</a>. (pun intended)</p>
</div>
<span class="comment-copy">Probably worth reading this question and associated answers:  <a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" title="what is a metaclass in python">stackoverflow.com/questions/100003/â€¦</a></span>
<span class="comment-copy"><code>isinstance(type,type) =&gt; True</code> if you ignore the <code>type</code> object everything makes sense, <code>type</code> is the only weird one.</span>
<span class="comment-copy">Thanks for taking the time to answer this.</span>
<span class="comment-copy">you may want to look at <a href="https://www.python.org/dev/peps/pep-3119/" rel="nofollow noreferrer">PEP 3119</a> before convincing yourself that this is strictly C level magic and bits and bytes.</span>
<span class="comment-copy">Sorry it came across that way - I wasn't claiming it was C-level magic (indeed, I even mentioned <code>a lot of what we typically consider to be Python is actually written in Python</code>), or that bits and bytes are the domain of C. That's just <a href="https://www.youtube.com/watch?v=IqhlQfXUk7w" rel="nofollow noreferrer">silly</a>. Apparently my theory about the chicken/egg ordering was wrong. My educated guess needed more education :-\</span>
<span class="comment-copy">sorry, you didn't come across like that, I was just convinced it was C-magic for a long time before I discovered abstract classes and PEP 3119, at which point I was able to replicate the circular behaviour in python.  It is completely possible that the actual creation is the other way around I haven't looked into the source either. :)</span>
<span class="comment-copy">Wayne, thanks for your explanation.</span>
