<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6098073/creating-a-function-object-from-a-string">creating a function object from a string</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>Consider that we have the following input </p>
<pre><code>formula = "(([foo] + [bar]) - ([baz]/2) )"

function_mapping = {
                   "foo" : FooFunction,
                   "bar" : BarFunction,
                   "baz" : BazFunction,  
                  }
</code></pre>
<p>Is there any python library that lets me parse the formula and convert it into 
a python function representation.</p>
<p>eg.</p>
<pre><code>converted_formula = ((FooFunction() + BarFunction() - (BazFunction()/2))
</code></pre>
<p>I am currently looking into something like</p>
<pre><code>In [11]: ast = compiler.parse(formula)

In [12]: ast
Out[12]: Module(None, Stmt([Discard(Sub((Add((List([Name('foo')]), List([Name('bar')]))), Div((List([Name('baz')]), Const(2))))))]))
</code></pre>
<p>and then process this ast tree further. </p>
<p>Do you know of any cleaner alternate solution? 
Any help or insight is much appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <code>re</code> module to do what you want via regular-expression pattern matching and relatively straight-forward text substitution.</p>
<pre><code>import re

alias_pattern = re.compile(r'''(?:\[(\w+)\])''')

def mapper(mat):
    func_alias = mat.group(1)
    function = function_alias_mapping.get(func_alias)
    if not function:
        raise NameError(func_alias)
    return function.__name__ + '()'

# must be defined before anything can be mapped to them
def FooFunction(): return 15
def BarFunction(): return 30
def BazFunction(): return 6

function_alias_mapping =  dict(foo=FooFunction, bar=BarFunction, baz=BazFunction)
formula = "(([foo] + [bar]) - ([baz]/2))"

converted_formula = re.sub(alias_pattern, mapper, formula)
print('converted_formula = "{}"'.format(converted_formula))

# define contexts and function in which to evalute the formula expression
global_context = dict(FooFunction=FooFunction,
                      BarFunction=BarFunction,
                      BazFunction=BazFunction)
local_context = {'__builtins__': None}

function = lambda: eval(converted_formula, global_context, local_context)
print('answer = {}'.format(function()))  # call function
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>converted_formula = "((FooFunction() + BarFunction()) - (BazFunction()/2))"
answer = 42
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use what's called string formatting to accomplish this.</p>
<pre><code>function_mapping = {
                   "foo" : FooFunction(),
                   "bar" : BarFunction(),
                   "baz" : BazFunction(),  
                  }

formula = "(({foo} + {bar}) - ({baz}/2) )".format( **function_mapping )
</code></pre>
<p>Will give you the result of <code>((FooFunction() + BarFunction() - (BazFunction()/2))</code></p>
<p>But I believe the functions will execute when the module is loaded, so perhaps a better solution would be</p>
<pre><code>function_mapping = {
                   "foo" : "FooFunction",
                   "bar" : "BarFunction",
                   "baz" : "BazFunction",  
                  }

formula = "(({foo}() + {bar}()) - ({baz}()/2) )".format( **function_mapping )
</code></pre>
<p>This will give you the string <code>'((FooFunction() + BarFunction() - (BazFunction()/2))'</code> which you can then execute at any time with the <code>eval</code> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you change the syntax used in the formulas slightly, (another) way to do this — as I mentioned in a <a href="https://stackoverflow.com/questions/36349553/convert-custom-formula-to-python-function#comment60347260_36349553">comment</a> — would be to use <a href="https://docs.python.org/2/library/string.html#template-strings" rel="nofollow noreferrer"><code>string.Template</code></a> substitution.</p>
<p>Out of curiosity I decided to find out if this other approach was viable — and consequently was able to come up with better answer in the sense that not only is it simpler than my <a href="https://stackoverflow.com/a/36354572/355230">other</a> one, it's also a little more flexible in the sense that it would be easy to add arguments to the functions being called as noted in a comment below.</p>
<pre><code>from string import Template

def FooFunction(): return 15
def BarFunction(): return 30
def BazFunction(): return 6

formula = "(($foo + $bar) - ($baz/2))"

function_mapping = dict(foo='FooFunction()',  # note these calls could have args
                        bar='BarFunction()',
                        baz='BazFunction()')

converted_formula = Template(formula).substitute(function_mapping)
print('converted_formula = "{}"'.format(converted_formula))

# define contexts in which to evalute the expression
global_context = dict(FooFunction=FooFunction,
                      BarFunction=BarFunction,
                      BazFunction=BazFunction)
local_context = dict(__builtins__=None)
function = lambda: eval(converted_formula, global_context, local_context)

answer = function()  # call it
print('answer = {}'.format(answer))
</code></pre>
<p>As a final note, notice that <code>string.Template</code> supports different kinds of <em>Advanced usage</em> which would allow you to fine-tune the expression syntax even further — because internally it uses the <code>re</code> module (in a more sophisticated way than I did in my original answer).</p>
<p>For the cases where the mapped functions all return values that can be represented as Python literals  — like numbers — and aren't being called just for the side-effects they produce, you could make the following modification which effectively cache (aka <a href="https://stackoverflow.com/questions/1988804/what-is-memoization-and-how-can-i-use-it-in-python">memoize</a>) the results:</p>
<pre><code>function_cache = dict(foo=FooFunction(),  # calls and caches function results
                      bar=BarFunction(),
                      baz=BazFunction())

def evaluate(formula):
    print('formula = {!r}'.format(formula))
    converted_formula = Template(formula).substitute(function_cache)
    print('converted_formula = "{}"'.format(converted_formula))
    return eval(converted_formula, global_context, local_context)

print('evaluate(formula) = {}'.format(evaluate(formula)))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>formula = '(($foo + $bar) - ($baz/2))'
converted_formula = "((15 + 30) - (6/2))"
evaluate(formula) = 42
</code></pre>
</div>
<span class="comment-copy">One potential problem with using <code>compiler.parse()</code> is that it parses according to Python syntax, which is why it turned the <code>[foo]</code> in the formula into <code>List([Name('foo')])</code>. What is the syntax being used in the formulas?</span>
<span class="comment-copy">@martineau True, there is a problem with the formula structure sicne it collides with the python List type. I define the syntax of the formulas, hence can give something like      <code>In [18]: formula = "((foo + bar) - (baz/2) )"  In [19]: ast = compiler.parse(formula)  In [20]: ast Out[20]: Module(None, Stmt([Discard(Sub((Add((Name('foo'), Name('bar'))), Div((Name('baz'), Const(2))))))]))</code></span>
<span class="comment-copy">You may be able to sidestep the syntax issue with <code>compiler.parse()</code> by "simply" doing text substitution as I've showm in my <a href="http://stackoverflow.com/a/36354572/355230">answer</a> below. That said, it might be better to define the syntax of your formula expressions so it doesn't conflict with existing Python syntax. For example, instead of the <code>re</code> module, it might be possible to do what you want using <a href="https://docs.python.org/2/library/string.html#string.Template.template" rel="nofollow noreferrer"><code>string.Template</code></a> substitution <code>$</code> syntax which might be easier to understand and implement.</span>
<span class="comment-copy">This works pretty well! Thank you! I was steering away from using <code>eval</code> since I was worried about the security implications. As long as I validate the input thoroughly, do you think this would be a valid use case for <code>eval</code> ?</span>
<span class="comment-copy">What do you mean "pretty well"? <code>eval</code> is OK if you take certain precautions — see updated answer.</span>
<span class="comment-copy">I think I wanted to say 'Works Perfectly!' :) Thanks for the update! Will make sure that I take the necessary precautions before using eval.</span>
<span class="comment-copy">The parenthesis of functions are missing in the second example. Other detail: if a function is present multiple times in the formula, it will be called multiple times. <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer">LRU</a>, dirty flag or caching can be useful here.</span>
<span class="comment-copy">@aluriak I did not know there was a built in way to automatically memoize functions for you. That is way cool. And I've updated my answer to include the parenthesis as well. Thanks for pointing that out.</span>
<span class="comment-copy">"This will give you the string '((FooFunction() + BarFunction() - (BazFunction()/2))'", actually no.... this is completely wrong....</span>
<span class="comment-copy">@Mr.Me : Daniel is right, the string you get will be something like  <code>In [10]: formula Out[10]: '((&lt;function FooFunction at 0x109749140&gt;() + &lt;function BarFunction at 0x1097491b8&gt;()) - (&lt;function BazFunction at 0x1097b5a28&gt;()/2) )'</code> . Thank you though!</span>
<span class="comment-copy">I really should fully test my code before posting it. Putting the function name in a string will fix this. If you're not able to hard code this in, there are ways of getting the string name of any function. See <a href="http://stackoverflow.com/questions/251464/how-to-get-a-function-name-as-a-string-in-python" title="how to get a function name as a string in python">stackoverflow.com/questions/251464/…</a> for info on how to do that.</span>
