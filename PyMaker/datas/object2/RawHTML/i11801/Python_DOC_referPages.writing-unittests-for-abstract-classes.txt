<div class="post-text" itemprop="text">
<p>Consider this example:</p>
<pre><code>class A:
    def do_stuff(self):
        # ...
        some_var = self.helper_method()
        # ...

    def helper_method(self):
        # This method must be implemented by subclass
        raise NotImplementedError()

class B(A):
    def helper_method(self):
        # implementation for class B

class C(A):
    def helper_method(self):
        # implementation for class C
</code></pre>
<p>My task is to write unit tests for <code>A</code>, <code>B</code> and <code>C</code> classes (especially for <code>do_stuff</code>).</p>
<p>But how can I test <code>A</code> class if I cannot use some of it methods directly?
Should I just test only <code>B</code> and <code>C</code> classes (which have implementation for <code>helper_method</code>)
or maybe there is common way for testing abstract classes in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't really have an abstract base class, at least as far as the language is concerned. Nothing is stopping you from instantiating it.</p>
<pre><code>a = A()
</code></pre>
<p>If you were using the <code>abc</code> module to define classes that you can't instantiate:</p>
<pre><code>class A(metaclass=abc.ABCMeta):
    ...
</code></pre>
<p>then you can make <code>A</code> instantiable by overriding its set of abstract methods:</p>
<pre><code>A.__abstractmethods__ = frozenset()
a = A()
# test away
</code></pre>
<p>In either case, you can still test that an abstract method either raises <code>NotImplementedError</code></p>
<pre><code>try:
    a.helper_method()
except NotImplementedError:
    print("Test passed")
else:
    print("Test failed")
</code></pre>
<p>or test its default implementation as needed.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>do_stuff</code> exists on <code>A</code>, so test it on <code>A</code>. The helper methods exist on the concrete classes so test them there. You can use the <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow"><code>unittest.mock</code></a> module to temporarily patch the abstract class so it will work with your test, and also patching the abstract method to return a specific value -- so that its logic is not under test. Given all that, this is how I would test an abstract class.</p>
<p>Given some abstract class:</p>
<pre><code>from abc import abstractmethod, ABC

class MyAbstract(ABC):
    def concrete_method(self):
        i = self.abstract_method()
        return i ** 2

    @abstractmethod
    def abstract_method(self):
        """return some int"""
        pass
</code></pre>
<p>This is how I would test it.</p>
<pre><code>from unittest import main, TestCase
from unittest.mock import patch, Mock

from module_under_test import MyAbstract

class TestMyAbstract(TestCase):

    def test_cannot_instantiate(self):
        """showing we normally can't instantiate an abstract class"""
        with self.assertRaises(TypeError):
            MyAbstract()

    @patch.multiple(MyAbstract,
        __abstractmethods__=set(),
        abstract_method=Mock(return_value=3))
    def test_concrete_method(self):
        """patch abstract class  and its abstract methods for duration of the test"""
        # given
        my_abstract = MyAbstract()
        expected = 9

        # when
        actual = my_abstract.concrete_method()

        # then
        self.assertEqual(actual, expected)

if __name__ == "__main__":
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should test logic, not the implementation. A's do_stuff() method has no logic itself, right? What it does depends on whether you are dealing with B or C. Instead it seems to me that it would make more sense to test B's and C's do_stuff() methods - you know what exactly they should do.</p>
</div>
<div class="post-text" itemprop="text">
<p>As @chepner has already answered your question, not to digress, but you should try to avoid using abstract classes in Python. Abstract classes don't or rather shouldn't serve much purpose much purpose in Dynamic DuckTyped languages like Python, Ruby etc. In Duck-typing as long as particular instance responds to a particular behavior, one shouldn't enforce it to be a child of a particular abstract class.</p>
</div>
<span class="comment-copy">Test it using a concrete subclass.</span>
<span class="comment-copy">And check coverage to be sure that abstract class code was covered during tests.</span>
<span class="comment-copy">Thank you for your response! I did't know that there is way to create "true" abstract classes in Python, and yeah, class <code>A</code> in my example is not abstract at all. The test for <code>helper_method</code> is necessary, but there is still one misunderstanding left. Method <code>do_stuff</code> is still not invokable directly from class <code>A</code>. Maybe I just need to use some of the subclasses of 'A' to test 'do_stuff' method (as @engineer noted) or override <code>A</code> directly in test code.</span>
<span class="comment-copy">One you've instantiated <code>A</code>, you can call the method normally with <code>a = A(); a.do_stuff()</code>. If you don't instantiate it, you can't call it without <i>something</i> to act as an instance. You can pass it a mock object: <code>m = unittest.mock.Mock(); A.do_stuff(m)</code>.</span>
