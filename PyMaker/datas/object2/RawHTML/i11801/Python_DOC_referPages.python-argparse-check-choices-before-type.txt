<div class="post-text" itemprop="text">
<p>I'm trying to enable a user to pass in a function name.  For some reason it seems that argparse performs the type check/conversion BEFORE it checks the choices.  Is this a bug?  Best thing to do?</p>
<pre><code>import argparse

def foo():
  return 'foo'

def bar():
  return 'bar'

parser = argparse.ArgumentParser()
functions = {f.__name__:f for f in [foo, bar]}
parser.add_argument("function", type=lambda f: functions.get(f), help="which function", choices=functions)
args = parser.parse_args()
print(args.function())
</code></pre>
<p>This throws:</p>
<pre><code>$ python blah.py foo
usage: blah.py [-h] {foo,bar}
blah.py: error: argument function: invalid choice: &lt;function foo at 0x7f65746dd848&gt; (choose from 'foo', 'bar')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, during parsing the <code>type</code> then <code>choices</code> order is clear and intentional (and not just incidental).  When preparing to assign <code>arg_strings</code> to the <code>namespace</code> it calls <code>_get_values</code>, which does:</p>
<pre><code>  def _get_values(self, action, arg_strings)
        .... (various nargs tests)
        value = self._get_value(action, arg_string)
        self._check_value(action, value)
        return value
</code></pre>
<p>where <code>_get_value</code> applies the <code>action.type</code> function, and <code>_check_value</code> tests </p>
<pre><code>value not in action.choices  
</code></pre>
<p>For parsing <code>choices</code> only has to respond to the <code>in</code> (<code>__contains__</code>) expression.</p>
<p>So <code>choices</code> have to reflect values after conversion.  If <code>type</code> is <code>int</code>, then <code>choices=[1,2,3]</code> is correct, <code>['1','2','3']</code> is not.</p>
<p>There are some (largely unresolved) bug issues over the display of the choices.  Long lists, e.g. <code>range(100)</code> work in parsing, but don't display nicely. And display also requires that <code>choices</code> be iterable (e.g. a list, tuple, dictionary).   This display issue affects the usage, the help and the error messages (each formats <code>choices</code> slightly differently).</p>
<p><code>metavar</code> is your most powerful tool for replacing an undesirable <code>choices</code> list.  I'd have to run a test case to see whether it solves things for all 3 situations.</p>
</div>
<div class="post-text" itemprop="text">
<p>Apparently so, however you can work around this simply by using <code>functions.keys()</code> as your choices, e.g.</p>
<pre><code>import argparse

def foo():
  return 'foo'

def bar():
  return 'bar'

parser = argparse.ArgumentParser()
functions = {f.__name__:f for f in [foo, bar]}
parser.add_argument("function", type=lambda f: functions.get(f), help="which function", choices=functions.values())
args = parser.parse_args()
print(args.function())
</code></pre>
<p>However, if you want to provide this kind of interface (mapping functions to command line arguments) you might want to take a look at <a href="http://click.pocoo.org/5/" rel="nofollow">click</a>.</p>
</div>
<span class="comment-copy">From <a href="https://docs.python.org/3/library/argparse.html#choices" rel="nofollow noreferrer"><code>argparse</code></a> documentation:  <code>Note that inclusion in the choices container is checked after any type conversions have been performed, so the type of the objects in the choices container should match the type specified:</code></span>
<span class="comment-copy">Yeah, there are several obvious workarounds.  I can also just do type=str, then call functions[args.function]().  Mostly, I was grumpy that --help displays the choices BEFORE "type"ing, but the parser checks the choices AFTER "type"ing.  Was hoping there was a generic way to deal with that situation.</span>
<span class="comment-copy">Ha, understood. For what it's worth I would suggest using the <code>str</code> names for commands (<code>type=str, choices=functions.keys()</code>) to make the error message when entering the wrong value nicer than <code>invalid choice: None (choose from &lt;function foo at 0x0000000000927F28&gt;)</code></span>
<span class="comment-copy">Apparently you can suppress the "choices" in the help by supplying a "metavar = 'FUNCTION'", then add the choices back into the help the way you want them with simple string manipulation.  That's what I'm gonna do, I think... along with your .values() suggestion.  Thx.</span>
