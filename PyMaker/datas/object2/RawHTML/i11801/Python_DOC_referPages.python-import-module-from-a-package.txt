<div class="post-text" itemprop="text">
<p><strong>folder structure:</strong></p>
<pre><code>&lt;current dir&gt;
   main.py
   packages &lt;dir&gt;
      __init__.py
      mod.py
</code></pre>
<p><strong>main py:</strong> </p>
<pre><code>import packages
print packages.mod.hello()
</code></pre>
<p><strong>mod.py:</strong></p>
<pre><code>def hello():
    return 'hello'
</code></pre>
<p><strong>__init__.py:</strong></p>
<pre><code>from packages import mod
</code></pre>
<p>If I run <code>main.py</code>, I get no error. But if I edit <code>__init__.py</code> to <code>'from packages import *'</code> , I get this error: <strong>AttributeError: 'module' object has no attribute 'mod'</strong></p>
<p>I'm not asking how to make that <code>'print'</code> command work. I can use other <code>'import'</code> syntax in <code>main.py</code> to make it work. The question is: I'm curious about that <code>'from packages import mod'</code> in the <code>__init__.py</code>. If i can do <code>import mod</code> then when I replace to <code>import *</code>, which means import everything, why do I get an error instead?</p>
<p>So what does the <code>from packages import *</code> really mean inside that <code>__init__.py</code>?</p>
<p>Anyone can help? Thanks</p>
</div>
<div class="post-text" itemprop="text">
<h2>Short answer</h2>
<p><em>So what does the <code>from packages import *</code> really mean inside that <code>__init__.py</code>?</em></p>
<p>The <code>__init__.py</code> imports itself.</p>
<h2>Explanation</h2>
<p>You can only import modules, not packages. Packages are just containers for modules or sub-packages. When you "import" a package you actually import the module <code>__init__.py</code>.</p>
<p>The <code>__init__.py</code> with this content:</p>
<pre><code>from packages import mod
</code></pre>
<p>imports the module <code>mod</code> into <code>__init__.py</code>. Therefore, it will be available
in your <code>main.py</code> via <code>packages.mod</code> (remember <code>packages</code> is represented by <code>__init__.py</code>).</p>
<p>When you change the content of <code>__init__.py</code> to:</p>
<pre><code>from packages import *
</code></pre>
<p>You are importing the module <code>__init__.py</code>, the very same file you are in.
This works (a second import just triggers a lookup in <code>sys.modules</code>) 
but won't give you the content of <code>mod</code>.</p>
<p>This means, you can use:</p>
<pre><code>from module import *
</code></pre>
<p>but you <strong>cannot</strong> sensibly use this with an empty <code>__init__.py</code>:</p>
<pre><code>from package import *
</code></pre>
<p>Because <code>package</code> is actually represented by the <code>__init__.py</code> and there 
is nothing in it yet. You can check this (interactively or in  file):</p>
<pre><code>&gt;&gt;&gt; import packages
&gt;&gt;&gt; print(packages)
&lt;module 'packages' from '/.../packages/__init__.py'&gt;
</code></pre>
<p>In <code>__init__.py</code> you can write:</p>
<pre><code>from packages.mod import *
</code></pre>
<p>and then in <code>main.py</code>:</p>
<pre><code>print packages.hello()
</code></pre>
<p>works. Because the function <code>hello()</code> is now in the global name space of the
file <code>__init__.py</code>.</p>
<p>As mentioned in the answer by mozman, you can use <code>__all__</code> in <code>__init__.py</code> to
list the modules that <a href="https://docs.python.org/3/tutorial/modules.html#importing-from-a-package" rel="noreferrer">should be imported</a> if <code>from packages import *</code> is used. This is designed for this case.</p>
<p>The <code>__init__.py</code> has only this content:</p>
<pre><code>__all__ = ['mod']
</code></pre>
<p>Now you can do this in <code>main.py</code>:</p>
<pre><code>from packages import *

print mod.hello()
</code></pre>
<p>If you extend your <code>__init__.py</code>:</p>
<pre><code>__all__ = ['mod']

from packages import *
</code></pre>
<p>You can do this in <code>main.py</code>:</p>
<pre><code>import packages

print packages.mod.hello()
</code></pre>
<p>But if you remove the <code>from packages import *</code> from <code>__init__.py</code>:</p>
<pre><code>__all__ = ['mod'] 
</code></pre>
<p>You will get an error:</p>
<pre><code>AttributeError: 'module' object has no attribute 'mod'
</code></pre>
<p>because the <code>__all__</code> is only used for the <code>from packages import *</code> case.
Now we are back to the <code>__init__.py</code> imports itself.</p>
</div>
<div class="post-text" itemprop="text">
<p>See also: <a href="https://stackoverflow.com/questions/2360724/in-python-what-exactly-does-import-import">In Python, what exactly does “import *” import?</a></p>
<p>adding __all__ to packages.__init__:</p>
<pre><code>__all__ = ['mod']
from packages import *
</code></pre>
<p>and module 'mod' will be imported, else 'mod' is not in the namespace of 'packages', but I can not explain why 'import *' without __all__ do not import 'mod'.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can load the modules inside the same packages directly. The following code works and it loads all the modules inside mod.py.</p>
<p><strong>Inside __init__.py</strong></p>
<pre><code>from mod import *
print hello()
</code></pre>
<p><strong>Efficient import - loads only hello function</strong> </p>
<pre><code>from mod import hello
print hello()
</code></pre>
<p>In your code,  <code>from packages import *</code> you are telling the interpreter to look for a modules inside <code>packages</code>(in the same directory as <code>__init__.py</code>). But it does not exist there. It exist one directory above the <code>__init__.py</code>. (I suspect my terminologies are wrong)</p>
<p>Here is a <a href="https://stackoverflow.com/questions/436497/python-import-the-containing-package">reference</a> that explains how to load the containing package itself.</p>
<p><strong>FOUND IT</strong></p>
<p>It was very interesting to read about python import mechanisms. <a href="https://docs.python.org/3.3/reference/import.html" rel="nofollow noreferrer">Ref1</a> <a href="https://docs.python.org/3.3/library/sys.html#sys.meta_path" rel="nofollow noreferrer">Ref2</a> <a href="https://www.python.org/dev/peps/pep-0302/#specification-part-1-the-importer-protocol" rel="nofollow noreferrer">Ref3</a></p>
<p>Apparently the parent modules is loaded first. For example, Ref3 states that, the code <code>import mod</code> inside <code>__init__.py</code> is automatically interpreted as <code>packages.mod</code>. Now I have to find out what happens if you write <code>import packages.mod</code>. Ref1 is more up-to-date with python3 conventions. Refer it for more info. Hope this helps you.</p>
</div>
<span class="comment-copy">i <b>can</b> do <code>from package import *</code> since there will be no error when compiled, only if i print then it said no module 'mod'. So that command is valid , only i'm confused about what the code is doing .</span>
<span class="comment-copy">i'll have a look the link and research it. i'll be back when i got something.</span>
<span class="comment-copy">Thanks but something is still missing, here what i got... if <b>all</b> is defined then it should import all the names defined in this sequence, otherwise it will import all names, except these which start with one underscore. so in my case if i didn't define <b>all</b> , it should import all names including my 'mod' , right ?</span>
<span class="comment-copy">Thanks but that's not my question , i can do other import syntax to make that print works. But I'm asking about that import * which should import everything including ** mod **</span>
<span class="comment-copy">also you said the module named packages does not exist, but in fact if i did this : from packages import mod. it works ! try to delete this code and run it, it will give you error. but when i put 'from packages import mod' , it works. So it means it's there. I know what you mean, that the packages is upper level, that why i'm confused . it should be 'illegal' , but the 'from packages import mod' works ! that's why i'm confused.  i may change my question a bit ... why then the 'from packages import mod' work?</span>
<span class="comment-copy">Okay that's fascinating. Can you specify the platform OS and python version, so i can recreate the scenario and test it. I will check it.</span>
<span class="comment-copy">i'm using imac OSX 10.9.2, python 2.7.5 . thanks !</span>
<span class="comment-copy">@andio added some references, I still have to recreate your scenario.</span>
