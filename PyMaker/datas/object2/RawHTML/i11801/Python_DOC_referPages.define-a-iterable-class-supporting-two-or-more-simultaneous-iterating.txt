<div class="post-text" itemprop="text">
<p>I'm not sure if this title is good..Hope someone could help to change it.</p>
<p>I'm trying to define an <code>molecule</code> class, and hope it can iterate over its atoms.
I searched how people define an iterable class, and it may look like this:</p>
<pre><code>class molecule(object):
    def __init__(self,name):
         self.__pointer=0
         # ...something else
    def __iter__(self):
         self.__pointer=0
         return self
    def __next__(self):
         self.__pointer+=1
         if self.__pointer&lt;=self.natoms: # self.natoms is defined somewhere
               return self[self.__pointer]   # suppose __getitem__ is defined to return an atom object
         else:
               raise StopIteration("Exceeded all atoms")
</code></pre>
<p>It works well:</p>
<pre><code> &gt;&gt;&gt; ben=molecule('ben') #defined a molecule
 &gt;&gt;&gt; ben.addatom(...) # and defined some atoms
 &gt;&gt;&gt; ite=iter(ben)
 &gt;&gt;&gt; for atom in ite:
 ...     print(atom)
 ...
 # atom objects are correctly printed here
</code></pre>
<p>However, I found it cannot work in two iterators, if they exist simultaneously.</p>
<pre><code>&gt;&gt;&gt; ite=iter(ben)
&gt;&gt;&gt; next(ite)
# atom1
&gt;&gt;&gt; next(ite)
# atom2
&gt;&gt;&gt; ite2=iter(ben)
&gt;&gt;&gt; next(ite)
# atom1 again, where atom3 is expected
&gt;&gt;&gt; next(ite2)
# atom2, where atom1 is expected
</code></pre>
<p>This is not a surprise because the two iterators share a same <code>self.__pointer</code>, so defining a new iterator will renew the pointer to zero.</p>
<p>I had a look at this page <a href="https://stackoverflow.com/questions/19151/how-to-make-class-iterable">How to make class iterable?</a>, and most of them use a <code>self.__pointer</code> within the class, which raises my question.
I guess if the <code>pointer</code> be an attribute of the iterator(<code>ite</code> or <code>ite2</code>) but not of the iterated object itself (<code>molecule</code>), then this problem could be solved.</p>
<p>Hope someone can give some help:) Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Make <code>__iter__</code> to return new iterator object every time when it's called.</p>
<pre><code>class molecule_iterator(object):
    def __init__(self, obj):
        self.pointer = 0
        self.obj = obj

    def __next__(self):
        self.pointer += 1  # Are you sure to do this here?
        if self.pointer &lt; self.obj.natoms:
            return self.obj[self.pointer]
        raise StopIteration()


class molecule(object):
    ...

    def __iter__(self):
        return molecule_iterator(self)

    ...
</code></pre>
<p>Or, you can use <a href="https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement" rel="nofollow"><code>yield</code> statement</a> which does not require you to define <code>__next__</code>. Because <code>__iter__()</code> will return a new generator iterator:</p>
<pre><code>def __iter__(self):
    for i in range(self.natoms):
        yield self[i + 1]
</code></pre>
<p>DEMO: <a href="https://ideone.com/TK78Ml" rel="nofollow">https://ideone.com/TK78Ml</a></p>
</div>
<span class="comment-copy">&gt; Make <code>__iter__</code> to return new iterator object every time when it's called.  &lt;&lt; How to do this?   while using <code>yield</code> looks good.</span>
<span class="comment-copy">@RuixingWang, I updated the answer to include the code for the first option. (return new iterator instance)</span>
<span class="comment-copy">Cool answer.  For the comment <code>#Are you sure</code>, yes, since I count atoms from 1 but not zero:)   Thanks!</span>
