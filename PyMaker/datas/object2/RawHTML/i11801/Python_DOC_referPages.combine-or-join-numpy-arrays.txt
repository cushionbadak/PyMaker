<div class="post-text" itemprop="text">
<p>How can I join two numpy ndarrays to accomplish the following in a fast way, using optimized numpy, without any looping?</p>
<pre><code>&gt;&gt;&gt; a = np.random.rand(2,2)
&gt;&gt;&gt; a
array([[ 0.09028802,  0.2274419 ],
       [ 0.35402772,  0.87834376]])

&gt;&gt;&gt; b = np.random.rand(2,2)
&gt;&gt;&gt; b
array([[ 0.4776325 ,  0.73690098],
       [ 0.69181444,  0.672248  ]])

&gt;&gt;&gt; c = ???
&gt;&gt;&gt; c
array([[ 0.09028802,  0.2274419, 0.4776325 ,  0.73690098],
       [ 0.09028802,  0.2274419, 0.69181444,  0.672248  ],
       [ 0.35402772,  0.87834376, 0.4776325 ,  0.73690098],
       [ 0.35402772,  0.87834376, 0.69181444,  0.672248  ]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's walk through a prospective solution to handle generic cases involving different shaped arrays with some inlined comments to explain the method involved. </p>
<p>(1) First off, we store shapes of input arrays.</p>
<pre><code>ma,na = a.shape
mb,nb = b.shape
</code></pre>
<p>(2) Next up, initialize a 3D array with number of columns being the sum of number of columns in input arrays<code>a</code> and <code>b</code>. Use <a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.empty.html" rel="nofollow"><code>np.empty</code></a> for this task.</p>
<pre><code>out = np.empty((ma,mb,na+nb),dtype=a.dtype)
</code></pre>
<p>(3) Then, set the first axis of the 3D array for the first "na" columns with the rows from <code>a</code> with <code>a[:,None,:]</code>. So, if we assign it to <code>out[:,:,:na]</code>, that second colon would indicate to NumPy that we need a broadcasted setting, if possible as always happens with singleton dims in NumPy arrays. In effect, this would be same as tiling/repeating, but possibly in an efficient way.</p>
<pre><code>out[:,:,:na] = a[:,None,:]
</code></pre>
<p>(4) Repeat for setting elements from <code>b</code> into output array. This time we would broadcast along the first axis of <code>out</code> with <code>out[:,:,na:]</code>, with that first colon helping us do that broadcasting.</p>
<pre><code>out[:,:,na:] = b
</code></pre>
<p>(5) Final step is to reshape the output to a 2D shape. This could be done with simply changing the shape with the required 2D shape tuple. Reshaping just changes view and is effectively zero cost.</p>
<pre><code>out.shape = (ma*mb,na+nb)
</code></pre>
<hr/>
<p>Condensing everything, the full implementation would look like this -</p>
<pre><code>ma,na = a.shape
mb,nb = b.shape
out = np.empty((ma,mb,na+nb),dtype=a.dtype)
out[:,:,:na] = a[:,None,:]
out[:,:,na:] = b
out.shape = (ma*mb,na+nb)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not the prettiest, but you could combine <code>hstack</code>, <code>repeat</code>, and <code>tile</code>:</p>
<pre><code>&gt;&gt;&gt; a = np.arange(4).reshape(2,2)
&gt;&gt;&gt; b = a+10
&gt;&gt;&gt; a
array([[0, 1],
       [2, 3]])
&gt;&gt;&gt; b
array([[10, 11],
       [12, 13]])
&gt;&gt;&gt; np.hstack([np.repeat(a,len(a),0),np.tile(b,(len(b),1))])
array([[ 0,  1, 10, 11],
       [ 0,  1, 12, 13],
       [ 2,  3, 10, 11],
       [ 2,  3, 12, 13]])
</code></pre>
<p>Or for a 3x3 case:</p>
<pre><code>&gt;&gt;&gt; a = np.arange(9).reshape(3,3)
&gt;&gt;&gt; b = a+10
&gt;&gt;&gt; np.hstack([np.repeat(a,len(a),0),np.tile(b,(len(b),1))])
array([[ 0,  1,  2, 10, 11, 12],
       [ 0,  1,  2, 13, 14, 15],
       [ 0,  1,  2, 16, 17, 18],
       [ 3,  4,  5, 10, 11, 12],
       [ 3,  4,  5, 13, 14, 15],
       [ 3,  4,  5, 16, 17, 18],
       [ 6,  7,  8, 10, 11, 12],
       [ 6,  7,  8, 13, 14, 15],
       [ 6,  7,  8, 16, 17, 18]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you want is, apparently, the cartesian product of <code>a</code> and <code>b</code>, stacked horizontally. You can use the <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a> module to generate the indices for the numpy arrays, then <code>numpy.hstack</code> to stack them:</p>
<pre><code>import numpy as np
from itertools import product

a = np.array([[ 0.09028802,  0.2274419 ],
              [ 0.35402772,  0.87834376]])

b = np.array([[ 0.4776325 ,  0.73690098],
              [ 0.69181444,  0.672248  ],
              [ 0.79941110,  0.52273   ]])

a_inds, b_inds = map(list, zip(*product(range(len(a)), range(len(b)))))

c = np.hstack((a[a_inds], b[b_inds]))
</code></pre>
<p>This results in a <code>c</code> of:</p>
<pre><code>array([[ 0.09028802,  0.2274419 ,  0.4776325 ,  0.73690098],
       [ 0.09028802,  0.2274419 ,  0.69181444,  0.672248  ],
       [ 0.09028802,  0.2274419 ,  0.7994111 ,  0.52273   ],
       [ 0.35402772,  0.87834376,  0.4776325 ,  0.73690098],
       [ 0.35402772,  0.87834376,  0.69181444,  0.672248  ],
       [ 0.35402772,  0.87834376,  0.7994111 ,  0.52273   ]])
</code></pre>
<p>Breaking down the indices thing:</p>
<p><code>product(range(len(a)), range(len(b))</code> will generate something that looks like this if you convert it to a list:</p>
<pre><code>[(0, 0), (0, 1), (1, 0), (1, 1)]
</code></pre>
<p>You want something like this: <code>[0, 0, 1, 1]</code>, <code>[0, 1, 0, 1]</code>, so you need to transpose the generator. The idiomatic way to do this is with <code>zip(*zipped_thing)</code>. However, if you just directly assign these, you'll get <code>tuples</code>, like this:</p>
<pre><code>[(0, 0, 1, 1), (0, 1, 0, 1)]
</code></pre>
<p>But numpy arrays interpret tuples as multi-dimensional indexes, so you want to turn them to lists, which is why I mapped the <code>list</code> constructor onto the result of the <code>product</code> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>dstack()</code> and <code>broadcast_arrays()</code>:</p>
<pre><code>import numpy as np

a = np.random.randint(0, 10, (3, 2))
b = np.random.randint(10, 20, (4, 2))

np.dstack(np.broadcast_arrays(a[:, None], b)).reshape(-1, a.shape[-1] + b.shape[-1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All arrays are indexable, so you can merge the by just calling:</p>
<pre><code>a[:2],b[:2]
</code></pre>
<p>or you can use core numpy stacking functions, should look something like this:</p>
<pre><code>c = np.vstack(a,b)
</code></pre>
</div>
<span class="comment-copy"><code>np.hstack((a[[0, 0, 1, 1]], b[[0, 1, 0, 1]])</code> will do this. Presumably someone can come up with a more general way of doing it though.</span>
<span class="comment-copy">Not a pretty one liner, but faster.</span>
<span class="comment-copy">@hpaulj Sometimes the ugly ones are the fast ones :)</span>
<span class="comment-copy">@Divakar I am kinda surprised that this works. I didn't realize you could just assign a <code>shape</code> tuple. Can you explain exactly what's happening?</span>
<span class="comment-copy">@Paul Check out the edits please. Hope those make sense :)</span>
<span class="comment-copy">@Divakar Thank you for the answer and additional color. I selected this as the answer for 3 reasons: 1) handles generic case, 2) numpy only and 3) performance. Paul's answer is also very good IMO.</span>
<span class="comment-copy">This is great. Thank you very much. I know I did not specify in my question, but if a and b are different dimensions, your solution generates an error. The following edit corrects that case:     <code>np.hstack([np.repeat(a,len(b),0),np.tile(b,(len(a),1))])</code></span>
<span class="comment-copy">Actually, my above suggestion does not work. But try with <code>b = np.random.rand(3,2)</code> I see <code>ValueError: all the input array dimensions except for the concatenation axis must match exactly</code></span>
<span class="comment-copy">@HelloWorld: the above was done under the assumption that <code>a</code> and <code>b</code> were both square and the same shape, like in your example. Do you need to handle the general case?</span>
<span class="comment-copy">I do need to handle the general case, but your answer is correct for the question I asked. I did get this far: <code>np.repeat(a[np.newaxis,:], b.shape[0], axis=1)[0,:]</code></span>
<span class="comment-copy">@HelloWorld Not to toot my own horn, but my answer below works just fine for matrices of two different shapes.</span>
<span class="comment-copy">This use of <code>broadcast_arrays</code> is clever, but slower than the one with <code>repeat</code> and <code>tile</code>.</span>
<span class="comment-copy">The first thing just creates a 2-ple. The second one doesn't work, but even if it did, it would just append b to a. The OP wants a numpy array that is the cartesian product of the two arrays.</span>
