<div class="post-text" itemprop="text">
<p><strong>problem</strong></p>
<p>Doing a while loop to validate file extension. If a file extension is not .exe or .bat, ask user input again. I am looking for a solution without using <code>import</code> <code>endswith</code> <code>break</code> functions.</p>
<p><strong>code</strong></p>
<pre><code>format = " "
while file[:-4] != ".bat" and file[:-4] != ".exe":
    format = input("Enter file you like to open: ")
    if format[:-4] == ".bat" or format[:-4] == ".exe":
        callFunction(format)
    else:
        file = input("Enter file you like to open: ")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need a loop</p>
<pre><code>def ask_exe(prompt='Executable file name? '):
    name = input(prompt)
    if name[-4:] in {'.exe', '.bat'}: return name
    return ask_exe(prompt='The name has to end in ".exe" or ".bat", please retry: ')
</code></pre>
<p>[no breaks, no imports, almost no code...]</p>
<p>As noted by <a href="https://stackoverflow.com/users/364696/shadowranger">ShadowRanger</a> my code, that uses <code>set</code> notation for the membership test, is suboptimal for Python versions prior to 3.2.  For these older versions using a <code>tuple</code> avoids computing the set at runtime, each and every time the function is executed.</p>
<pre><code>...
    # for python &lt; 3.2
    if name[-4:] in ('.exe', '.bat'): return name
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To follow <a href="https://stackoverflow.com/questions/23294658/asking-the-user-for-input-until-they-give-a-valid-response">Asking the user for input until they give a valid response</a> and using <a href="https://docs.python.org/3/library/os.path.html#os.path.splitext" rel="nofollow noreferrer"><code>os.path.splitext()</code></a> to extract the file extension:</p>
<pre><code>import os

ALLOWED_EXTENSTIONS = {".bat", ".exe"}
while True:
    filename = input("Enter file you like to open: ")
    extension = os.path.splitext(filename)[1]
    if extension in ALLOWED_EXTENSTIONS:
        break

with open(filename) as f:
    # do smth with f
</code></pre>
<hr/>
<p>Without <code>break</code>:</p>
<pre><code>import os

ALLOWED_EXTENSTIONS = {".bat", ".exe"}
extension = None
while extension not in ALLOWED_EXTENSTIONS:
    filename = input("Enter file you like to open: ")
    extension = os.path.splitext(filename)[1]

with open(filename) as f:
    # do smth with f
</code></pre>
<hr/>
<p>Without <code>break</code> and without any imports:</p>
<pre><code>ALLOWED_EXTENSTIONS = (".bat", ".exe")
filename = ""
while not filename.endswith(ALLOWED_EXTENSTIONS):
    filename = input("Enter file you like to open: ")

with open(filename) as f:
    # do smth with f
</code></pre>
<hr/>
<p>Without <code>break</code> and without any imports and without <code>endswith()</code>:</p>
<pre><code>ALLOWED_EXTENSTIONS = {"bat", "exe"}
filename = ""
while filename.rsplit(".",1)[-1] not in ALLOWED_EXTENSTIONS:
    filename = input("Enter file you like to open: ")

with open(filename) as f:
    # do smth with f
</code></pre>
</div>
<span class="comment-copy">@ShadowRanger Your edit was a source of inspiration. tx</span>
<span class="comment-copy">Just a heads up, the set literal approach will cost more on older Python; <code>tuple</code>s of literals get cached in the per function constant store in all versions of Python, but <a href="https://docs.python.org/3/whatsnew/3.2.html#optimizations" rel="nofollow noreferrer">membership tests for set literals are only converted to <code>frozenset</code>s and stored in the constant store on Python 3.2+</a>; on 3.1 and earlier (including all 2.x releases), the <code>set</code> has to be built every time, then a membership test is performed; saving on the lookup by rebuilding the <code>set</code> every time is a net loss. For two elements, the <code>tuple</code> is fine even in 3.2+.</span>
<span class="comment-copy">@ShadowRanger Thank you for the interest, the discussion and the link. Now the reason of your edit are really clear. I've edited my answer accordingly (well, I hope so...)</span>
<span class="comment-copy">thanks for the response, but i was looking for a solution without using endswith and break.</span>
<span class="comment-copy">@LearnAndLearn sure, <code>endswith()</code> was extra, fixed.</span>
<span class="comment-copy">is there another way to stop the loop without using break and importing</span>
<span class="comment-copy">@alecxe be aware of the vampires...</span>
<span class="comment-copy">@PadraicCunningham ah yeah, messed things up, thanks for noticing!</span>
