<div class="post-text" itemprop="text">
<p>I have a CSV file with a column that has varying date ranges for a million records. For instance, I have something like this:
2004-2016; 1980-2016; 1991-2006; 2000-2012; 1998 - 2011</p>
<p>If I want to find out the 3, 5 or the 7 year range that is most common in all these records, how will I do this in Python? It doesn't matter if a few records are eliminated but I am trying to find out which 7 year frequency or a 10 year frequency is most common for all the ranges. Can someone help?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a> of <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a> to handle this. The <code>defaultdict</code> is used to group the date ranges by the number of years, and the <code>Counter</code> keeps track of the counts of range strings for that number of years:</p>
<pre><code>from collections import defaultdict, Counter

year_ranges = defaultdict(Counter)

s = '2004-2016; 1980-2016; 1991-2006; 2000-2012; 1998 - 2011; 2004-2016'
for start, end in [r.split('-') for r in s.split('; ')]:
    start, end = int(start), int(end)
    year_ranges[end-start].update(['{}-{}'.format(start, end)])    # update counter for normalised range string

&gt;&gt;&gt; print(year_ranges)
defaultdict(&lt;class 'collections.Counter'&gt;, {36: Counter({'1980-2016': 1}), 12: Counter({'2004-2016': 1, '2000-2012': 1}), 13: Counter({'1998-2011': 1}), 15: Counter({'1991-2006': 1})})
</code></pre>
<p>If you want to know the most common range string with year range 12:</p>
<pre><code>&gt;&gt;&gt; year_ranges[12].most_common(1)
[('2004-2016', 2)]
</code></pre>
<p>Not sure how you want to handle cases where there are multiple range strings representing the same year range with equivalent counts.</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>Parse file; get 2-element tuples: <code>((2004, 2016), (1980-2016), ...)</code>.</li>
<li>Transform it to differences: <code>(12, 36, ...)</code>.</li>
<li>Create <code>Counter</code> object with this sequnce and call <code>most_common</code> method.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Split your sequence into individual ranges. Assuming you call the resulting sequence diff.</p>
<pre><code>from collections import Counter

diff = ["2004-2016", "1980-2016", "1991-2006", "2000-2012", "1998 - 2011"]

diff_frequency = Counter( map( lambda x: abs( eval(x) ), diff) ).most_common()

most_common_diff = diff_frequency[0]
</code></pre>
</div>
<span class="comment-copy">How do you load the data? In a list like <code>['2004-2016', '1980-2016', ...]</code>?</span>
<span class="comment-copy">What exactly do you need help with? What have you tried, and where are you getting stuck? Did you write any code yet?</span>
<span class="comment-copy">@Reti43: because <code>eval</code> is dangerous on untrusted data. Also it's slow and there are 1 million records. The method I show also has the advantage that the date range strings are normalised before being counted, e.g <code>1998 - 2011</code> and <code>1998-2011</code> are considered the same.</span>
<span class="comment-copy">@Reti43:  How is a <code>try</code> statement going to prevent execution of arbitrary code? If the input is malicious, but valid code that <code>eval()</code> can execute, no exception might be raised. What if the data contained <code>os.system('rm -rf /tmp')</code> (or worse)? In general it's a bad idea to use <code>eval()</code>. And it's 4-6 times slower than the direct string manipulation I show. And you still have to normalise the input strings to get sensible tallies.</span>
<span class="comment-copy">I'm not insisting on <code>eval()</code>. You also made a good point that it's faster. However, assuming the possibility of bad input, <code>int()</code> can fail.</span>
<span class="comment-copy">@Reti43: fair enough, <code>int()</code> can also fail on bad input - although it's unlikely to take out your filesystem with it. I take your point though, and really my main point in these comments is that <code>eval()</code> is an unnecessarily risky solution.</span>
<span class="comment-copy">I'm totally with you there. I was just too hasty with naivety.</span>
