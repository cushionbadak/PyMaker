<div class="post-text" itemprop="text">
<p>I have a somewhat bizarre metaclass question. I'm using a meta class to dynamically create a 'sibling' class that inherits from another superclass and assign it as an attribute on the original class. Below is a minimal setup:</p>
<pre><code>class Meta(type):
def __new__(cls, name, parents, dct):
    sdct = dct.copy()
    dct['sibling'] = type(name+'Sibling', (Mom,), sdct)
    return super().__new__(cls, name, (Dad,), dct)

class Mom:
     def __init__(self):
         self.x = 3

class Dad:
     def __init__(self):
         self.x = 4

class Child(metaclass=Meta):
     def __init__(self):
         super().__init__()
         self.y = 1  # &lt;&lt;&lt; added from feedback
print(Child().x) # 4
print(Child().sibling) # &lt;class '__main__.Child'&gt; | should be ChildSibling
print(Child().sibling().x) # should be 3 instead throws:
    # TypeError: super(type, obj): obj must be an instance or subtype of type
print(Child().sibling().y) # should print 4
</code></pre>
<p>Something seems to be going wrong above with the creation of the 'sibling' class but I'm not quite sure what. I know for example that this would work:</p>
<pre><code>class ChildAbstract:
    def __init__(self):
        super().__init__()

ChildSibling = type('ChildSibling', (ChildAbstract, Mom), {})
Child = type('Child', (ChildAbstract, Dad), {'sibling': ChildSibling})
print(Child().sibling().x) # 3
</code></pre>
<p>I can't see the difference between the two cases though.</p>
</div>
<div class="post-text" itemprop="text">
<p>The dictionary <em>sdct</em> passed to <em>type</em> includes <code>__qualname__</code>, which according to this <a href="https://www.python.org/dev/peps/pep-3155/#id6" rel="nofollow">PEP</a> is what <em>repr</em> and <em>str</em> now use.</p>
<p>Try adding</p>
<pre><code>print(Child is Child.sibling)  # False
print(Child.sibling.__name__)  # "ChildSibling"
</code></pre>
<p>and you'll see that it is truly the sibling.</p>
<p>As to why <code>sibling().x</code> throws, the very same <em>sdct</em> also already contains <code>Child.__init__</code>, which ends up as <code>__init__</code> of your dynamically created new type <code>ChildSibling</code>. During a call to <code>sibling()</code> the <code>super()</code> call resolves the class to <code>Child</code> and is given an instance of <code>ChildSibling</code>:</p>
<blockquote>
<p>Also note that, aside from the zero argument form, super() is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, <strong>as the compiler fills in the necessary details to correctly retrieve the class being defined</strong>, as well as accessing the current instance for ordinary methods.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow">https://docs.python.org/3/library/functions.html#super</a></p>
<p>Accessing the current instance is done by passing the first argument to method as instance.</p>
<blockquote>
<p><code>super() -&gt; same as super(__class__, &lt;first argument&gt;)</code></p>
</blockquote>
<p>The error is raised at <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c#L7210" rel="nofollow">line 7210 of Object/typeobject.c</a>.</p>
<p>Try removing the wrong <code>__init__</code> in your <code>__new__</code> with:</p>
<pre><code>del sdct['__init__']
</code></pre>
<p>and now</p>
<pre><code>print(Child().sibling().x)
</code></pre>
<p>will print 3.</p>
<p>A solution to "generic" inheritance and meta programming friendlier <code>__init__</code> is to use the 2 argument form of <code>super()</code>:</p>
<pre><code>def __init__(self):
    super(self.__class__, self).__init__()
</code></pre>
</div>
<span class="comment-copy">Interesting point, deleting <b>init</b> from the dictionary works but only because in my toy example I don't do anything in Child.__init__ so this doesn't quite solve the problem (updated code to illustrate). I'll take a look at <b>qualname</b> though</span>
<span class="comment-copy">Ahh the note on super explains this</span>
<span class="comment-copy">@Buck The reason your second example works is that the bases of those 2 dynamic types include <code>ChildAbstract</code> and so <code>super()</code> is happy.</span>
<span class="comment-copy">so <code>super().__init__() -&gt; super(self.__class__, self).__init__()</code> sovles this, thanks @Ilja</span>
<span class="comment-copy">@Buck included your solution as part of the answer too, so it's easier to find</span>
