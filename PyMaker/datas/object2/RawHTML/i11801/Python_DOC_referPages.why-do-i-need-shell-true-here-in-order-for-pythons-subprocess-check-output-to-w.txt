<div class="post-text" itemprop="text">
<p>I've got a python script that's being run from the <strong>if-up</strong> script that's called by the <strong>ppp</strong> program on Linux when the PPP connection is established. The python script basically calls a command line program, parses the result and returns it:</p>
<pre><code>import subprocess

result = subprocess.check_output(["fw_printenv", "serialnr"])
result = # some operation 
return result
</code></pre>
<p>Although this code works 100% fine when I run the python script manually from the command line (e.g. <code>python script.py</code>), it doesn't work at all when it's run by PPP from if-up. An exception is raised when <code>subprocess.check_output</code> is called: <code>[Errno 2] No such file or directory: 'fw_printenv'</code>.</p>
<p>I can only get it to work if I change the code to:</p>
<pre><code>result = subprocess.check_output("fw_printenv serialnr", shell=True)
</code></pre>
<p>Why?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer">subprocess documentation</a>:</p>
<blockquote>
<p>If shell is True, the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, <strong>environment variable expansion</strong>, and expansion of ~ to a userâ€™s home directory. However, note that Python itself offers implementations of many shell-like features (in particular, glob, fnmatch, os.walk(), os.path.expandvars(), os.path.expanduser(), and shutil).</p>
</blockquote>
<p>Environment variables are necessary in order to get paths to binaries (notabily the <code>PATH</code>, containing possible paths, including <code>/usr/bin/</code> under unix systems).
Else, <code>fw_printenv</code> could be <a href="https://stackoverflow.com/a/36477647/3077939">accessed by absolute path</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use absolute paths:</p>
<pre><code>result = subprocess.check_output(["/full/path/to/fw_printenv", "serialnr"])
</code></pre>
<p>The same goes for stuff you run via cron and web servers.</p>
<p><code>shell=True</code> obviously opens a shell but, less obviously, it also sets all the environment variables (such as <code>PATH</code>) - as if you were running the script manually in your terminal. Removing <code>shell=True</code> and using absolute paths instead is probably the best/safest choice if it works (which I think it will). </p>
</div>
<span class="comment-copy">By using shell, you are using the system's PATH variables. That's most likely why the first version can't find the executable</span>
