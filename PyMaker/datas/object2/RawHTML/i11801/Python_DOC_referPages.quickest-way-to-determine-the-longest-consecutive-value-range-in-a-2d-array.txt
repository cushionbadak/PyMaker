<div class="post-text" itemprop="text">
<p><strong>The problem</strong></p>
<p>let's assume we're working with a large dataset and for the sake of simplicity we use this smaller one in this question:</p>
<pre><code>dataset = [["PLANT", 4,11],
           ["PLANT", 4,12],
           ["PLANT", 34,4],
           ["PLANT", 6,5],
           ["PLANT", 54,45],
           ["ANIMAL", 5,76],
           ["ANIMAL", 7,33],
           ["Animal", 11,1]]
</code></pre>
<p>and we want to find out which column has the longest range of consecutive values, what would be the fastest way to find out, which is the best column? </p>
<p><strong>The naive approach</strong></p>
<p>I found out it quickly can be sorted by each column with</p>
<pre><code>sortedDatasets = []
for i in range(1,len(dataset[0]):
    sortedDatasets.append(sorted(dataset,key=lambda x: x[i]))
</code></pre>
<p>But here comes the laggy part: we could go on from here and do a <code>for loop</code> for each of the sorted datasets, and count the consecutive elements but when it comes to processing <code>for loops</code> python is very slow.</p>
<p><strong>Now my the question</strong>: is there a faster way than this naive approach, is there maybe even an built-in function for these 2D-containers?</p>
<hr/>
<p><strong>Update:</strong></p>
<p>More precisely the meaning of a range can be described by this pseudo algorithm - this includes incrementing if <code>current value == next value</code>: </p>
<pre><code>if nextValue &gt; current Value +1: 
     {reset counter} 
else: 
     {increment counter}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with reasonable efficiency using <code>groupby</code>. I'll do this in stages, so you can see how it works.</p>
<pre><code>from itertools import groupby

dataset = [
    ["PLANT", 4, 11],
    ["PLANT", 4, 12],
    ["PLANT", 34, 4],
    ["PLANT", 6, 5],
    ["PLANT", 54, 45],
    ["ANIMAL", 5, 76],
    ["ANIMAL", 7, 33],
    ["ANIMAL", 11, 1],
]

# Get numeric columns &amp; sort them in-place
sorted_columns = [sorted(col) for col in zip(*dataset)[1:]]
print sorted_columns
print

# Check if tuple `t` consists of consecutive numbers
keyfunc = lambda t: t[1] == t[0] + 1

# Search for runs of consecutive numbers in each column
for col in sorted_columns:
    #Create tuples of adjacent pairs of numbers in this column
    pairs = zip(col, col[1:])
    print pairs
    for k,g in groupby(pairs, key=keyfunc):
        print k, list(g)
    print
</code></pre>
<p><strong>output</strong></p>
<pre><code>[[4, 4, 5, 6, 7, 11, 34, 54], [1, 4, 5, 11, 12, 33, 45, 76]]

[(4, 4), (4, 5), (5, 6), (6, 7), (7, 11), (11, 34), (34, 54)]
False [(4, 4)]
True [(4, 5), (5, 6), (6, 7)]
False [(7, 11), (11, 34), (34, 54)]

[(1, 4), (4, 5), (5, 11), (11, 12), (12, 33), (33, 45), (45, 76)]
False [(1, 4)]
True [(4, 5)]
False [(5, 11)]
True [(11, 12)]
False [(12, 33), (33, 45), (45, 76)]
</code></pre>
<p>Now, to attack your <em>actual</em> question:</p>
<pre><code>from itertools import groupby

dataset = [
    ["PLANT", 4, 11],
    ["PLANT", 4, 12],
    ["PLANT", 34, 4],
    ["PLANT", 6, 5],
    ["PLANT", 54, 45],
    ["ANIMAL", 5, 76],
    ["ANIMAL", 7, 33],
    ["ANIMAL", 11, 1],
]

# Get numeric columns &amp; sort them in-place
sorted_columns = [sorted(col) for col in zip(*dataset)[1:]]

# Check if tuple `t` consists of consecutive numbers
keyfunc = lambda t: t[1] == t[0] + 1

#Search for the longest run of consecutive numbers in each column
runs = []
for i, col in enumerate(sorted_columns, 1):
    pairs = zip(col, col[1:])
    m = max(len(list(g)) for k,g in groupby(pairs, key=keyfunc) if k)
    runs.append((m, i))

print runs
#Print the highest run length found and the column it was found in
print max(runs)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[(3, 1), (1, 2)]
(3, 1)
</code></pre>
<hr/>
<p>FWIW, this can be condensed into a single line. It's a little more efficient since it uses a couple of generator expressions instead of list comprehensions, but it's not particularly readable:</p>
<pre><code>print max((max(len(list(g)) 
    for k,g in groupby(zip(col, col[1:]), key=lambda t: t[1] == t[0] + 1) if k), i)
        for i, col in enumerate((sorted(col) for col in zip(*dataset)[1:]), 1))
</code></pre>
<hr/>
<h3>Update</h3>
<p>We can handle your new consecutive sequence definition by making a few minor changes.</p>
<p>Firstly, we need a key function that returns <code>True</code> if the difference between an adjacent pair of numbers in a sorted column is &lt;= 1.</p>
<pre><code>def keyfunc(t):
    return t[1] - t[0] &lt;= 1
</code></pre>
<p>And instead of taking the length of the sequences which match that key function we now do some simple arithmetic to see the size of the range of values in the sequence.</p>
<pre><code>def runlen(seq):
    return 1 + seq[-1][1] - seq[0][0]
</code></pre>
<p>Putting it all together:</p>
<pre><code>def keyfunc(t):
    return t[1] - t[0] &lt;= 1

def runlen(seq):
    return 1 + seq[-1][1] - seq[0][0]

# Get numeric columns &amp; sort them in-place
sorted_columns = [sorted(col) for col in zip(*dataset)[1:]]

#Search for the longest run of consecutive numbers in each column
runs = []
for i, col in enumerate(sorted_columns, 1):
    pairs = zip(col, col[1:])
    m = max(runlen(list(g)) for k,g in groupby(pairs, key=keyfunc) if k)
    runs.append((m, i))

print runs
#Print the highest run length found and the column it was found in
print max(runs)
</code></pre>
<hr/>
<h3>Update 2</h3>
<p>As noted in the comments, <code>max</code> raises <code>ValueError</code> if its arg is an empty sequence. A simple way to handle that is to wrap the <code>max</code> call in a <code>try..except</code> block. This is quite efficient if the exception happens rarely, <code>try..except</code> is actually faster than equivalent <code>if...else</code> logic when the exception isn't raised. So we <em>could</em> do something like this:</p>
<pre><code>run = (runlen(list(g)) for k,g in groupby(pairs, key=keyfunc) if k)
try:
    m = max(run)
except ValueError:
    m = 0
runs.append((m, i))
</code></pre>
<p>But if that exception happens fairly frequently it's better to use another approach. </p>
<p>Here's a new version that uses a fully-fledged generator function, <code>find_runs</code>, in place of the generator expression. <code>find_runs</code> simply <code>yield</code>s a zero before it starts processing the column data so <code>max</code> will always have at least one value to process. I've inlined the <code>runlen</code> calculation to save on the overhead of an additional function call. This refactoring also makes it easier to build the <code>runs</code> list in a list comprehension.</p>
<pre><code>from itertools import groupby

dataset = [
    ["PLANT", 4, 11, 3],
    ["PLANT", 4, 12, 5],
    ["PLANT", 34, 4, 7],
    ["PLANT", 6, 5, 9],
    ["PLANT", 54, 45, 11],
    ["ANIMAL", 5, 76, 13],
    ["ANIMAL", 7, 33, 15],
    ["ANIMAL", 11, 1, 17],
]

def keyfunc(t):
    return t[1] - t[0] &lt;= 1

def find_runs(col):
    pairs = zip(col, col[1:])
    #This stops `max` from choking if we don't find any runs
    yield 0
    for k, g in groupby(pairs, key=keyfunc):
        if k:
            #Determine run length
            seq = list(g)
            yield 1 + seq[-1][1] - seq[0][0]

# Get numeric columns &amp; sort them in-place
sorted_columns = [sorted(col) for col in zip(*dataset)[1:]]

#Search for the longest run of consecutive numbers in each column
runs = [(max(find_runs(col)), i) for i, col in enumerate(sorted_columns, 1)]
print runs

#Print the highest run length found and the column it was found in
print max(runs)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[(4, 1), (2, 2), (0, 3)]
(4, 1)
</code></pre>
</div>
<span class="comment-copy">From your naive approach I assume you don't want to find the consecutive values in the first column?</span>
<span class="comment-copy">@ChristophTerasa exactly</span>
<span class="comment-copy">@user3085931: Correct. <code>(3,1)</code> means that a run of 3 consecutive values was found in column 1. By default, <code>sort</code>, <code>max</code> &amp; <code>min</code> compare lists or tuples item by item from left to right, so by putting the runlength as item zero we don't need to supply a custom key function.</span>
<span class="comment-copy">Note that if two columns tie for maximum runlength, then <code>max</code> will choose the one with the highest column number, but that can be modified with a suitable key function, if desired.</span>
<span class="comment-copy">@user3085931: BTW, if you're using Python 2 you should get even more speed (and reduce RAM usage) by using <a href="https://docs.python.org/2/library/itertools.html#itertools.izip" rel="nofollow noreferrer"><code>itertools.izip</code></a>; that's not necessary in Python 3, since the Python 3 version of <a href="https://docs.python.org/3.3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> returns an iterator.</span>
<span class="comment-copy">@user3085931: Sorry about that! :oops: I'll see if I can figure out a more efficient way to handle empty sequences and add it to my answer. Your weird typing is excused, SO comments aren't designed to cope with extensive code snippets, and they're especially bad for Python since they kill indentation; it's generally better to add code (and error tracebacks) to your question. You can use the HTML code <code>&lt;HR&gt;</code> to add a horizontal rule as a separator if you like.</span>
<span class="comment-copy">@user3085931: The quick answer is to use Python 3.4 or better, since <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow noreferrer">the latest version of <code>max</code></a> can be given a default value. Another option is to use a list comprehension instead of a generator expression, eg <code>run = [runlen(list(g)) for k,g in groupby(pairs, key=keyfunc) if k]; runs.append((max(run or [0]), i))</code>, but that wastes RAM. However, I <i>think</i> I can do something efficient with a full generator function in place of the generator expression.</span>
