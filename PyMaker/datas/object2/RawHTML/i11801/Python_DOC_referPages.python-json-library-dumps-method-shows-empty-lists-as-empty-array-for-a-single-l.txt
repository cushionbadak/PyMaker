<div class="post-text" itemprop="text">
<p>I am using json.dumps to dump a class I created.  There are two list data members, one is never used but one is used to manage the building of another data member list.  The never used lists are not present in the generated JSON, but the used list is added even when I clear it from every instance of the object in a list of those objects.  I do not want this empty list in the JSON.</p>
<p>Before I return the list to be passed to dumps, I do this</p>
<pre><code> for entry in self.endpointList:
     entry.attributeNameList.clear()
</code></pre>
<p>I tried clearing in my own JSONEncoder too.  The attributeNameList members are cleared when I look at them in the debugger, but they are emitted by dumps as an empty array.  The other untouched, empty lists never show.</p>
<p>The other difference is the empty lists that do not show are declared in the same way, but attributeNameList is initialized in <code>__init__</code> method of my class.</p>
<pre><code>class ProvisioningEndpoint:
    attributeList = []
    attributeNameList = []
    def __init__(self, record):
         self.attributeNameList = list()
</code></pre>
<p>Is there a way to prevent this particular empty list from being converted to </p>
<pre><code>"attributeNameList": []
</code></pre>
<p>attributeList is never added to the JSON output.</p>
<p>The never used lists and the cleared list look exactly the same in the debugger--empty.  Python may have a dirty bit on the list and uses it to decide when to emit as JSON.
Thanks.</p>
<p>Here is the encoder code (as requested)</p>
<pre><code> class ServiceRegistryEncoder(json.JSONEncoder):
        def default(self, obj):
            if isinstance(obj, (ProvisioningEndpoint,endpointAttribute)):
                obj = obj.__dict__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your <em>class</em> has two attributes which are lists - <code>attributeList</code> and <code>AttributeNameList</code>.</p>
<p><em>Instances</em> of the class have <code>attributeNameList</code> as an attribute, because it's initialised in the __ init __ method.  This instance attribute overrides the class attribute.</p>
<p>Your encoder is serialising everything in an instance's __ dict __, which will include <code>attributeNameList</code>.  If you don't want to serialise <code>self.attributeNameList</code> when it's empty then you'll need to add some logic in the encoder to handle this: for example:</p>
<pre><code> class ServiceRegistryEncoder(json.JSONEncoder):
        def default(self, obj):
            if isinstance(obj, (ProvisioningEndpoint,endpointAttribute)):
                obj = obj.__dict__.copy()
                if not obj.get('attributeNameList):
                    try:
                        del obj['attributeNameList']
                    except KeyError:
                        pass
</code></pre>
<p><strong>EDIT</strong>: more on class attributes</p>
<p>When you try to access an attribute <code>foo</code> on an instance Python first looks in the instance's __ dict __.  If the attribute isn't found there, Python will look in the instance's class's __ dict __.  If it finds the attribute there it will return it. This means that class attributes are shared across all instances of the class.  See <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables" rel="nofollow">the tutorial</a> for more on this.</p>
<p>As class attributes are shared across instances, changes to a class attribute will be visible to all instances.  This can result in surprising or undesirable behaviour:</p>
<pre><code>&gt;&gt;&gt; class Emailer(object):
...     recipients = ['default@example']
...     def send_secret_email(self):
...         # send secret email
...         pass
... 
&gt;&gt;&gt; e1 = Emailer()
&gt;&gt;&gt; e2 = Emailer()
&gt;&gt;&gt; e1.recipients.append('alice@example.com')
&gt;&gt;&gt; print(e1.recipients)
['default@example', 'alice@example.com']
&gt;&gt;&gt; e2.recipients.append('bob@example.com')
&gt;&gt;&gt; print(e2.recipients)
['default@example', 'alice@example.com', 'bob@example.com']
&gt;&gt;&gt; print(e1.recipients)
['default@example', 'alice@example.com', 'bob@example.com']
</code></pre>
<p>In cases like the above example you can take a copy of the attribute in your __ init __ method to mitigate this.</p>
<pre><code> &gt;&gt;&gt; class Emailer(object):
...     recipients = ['default@example']
...     def __init__(self):
...         self.recipients = self.recipients.copy()
...     def send_secret_email(self):
...         # send secret email
...         pass
... 
&gt;&gt;&gt; e1 = Emailer()
&gt;&gt;&gt; e2 = Emailer()
&gt;&gt;&gt; e1.recipients.append('alice@example.com')
&gt;&gt;&gt; print(e1.recipients)
['default@example', 'alice@example.com']
&gt;&gt;&gt; e2.recipients.append('bob@example.com')
&gt;&gt;&gt; print(e2.recipients)
['default@example', 'bob@example.com']
&gt;&gt;&gt; print(e1.recipients)
['default@example', 'alice@example.com']
</code></pre>
<p>As @blackjack observed, mutable class attributes are usually a code smell, but they do have some uses: for example, if a class wants to keep track of its instances.</p>
</div>
<span class="comment-copy">Can you show the code in your encoder that handles the instance's attributes?</span>
<span class="comment-copy">Thank you.  So, class attributes, if not set in the __ init __ method, do not exist in an instance?</span>
<span class="comment-copy">@ThomasBentley Class attributes <i>never</i> exist in an instance.  If you set an attribute with the same name within a <code>__init__</code> then you have a class attribute at the class and an instance attribute at the instance with the same name. Class attributes that are not constants are usually a code smell.</span>
<span class="comment-copy">Thanks Blackjack.  They class attribute and the instance attribute will show in the debugger in the same way, correct?  That is what I see in pydev.</span>
