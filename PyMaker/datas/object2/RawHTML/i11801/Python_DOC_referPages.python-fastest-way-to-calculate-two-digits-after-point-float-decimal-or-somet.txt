<div class="post-text" itemprop="text">
<p>As i found out, decimal is is more precise at the cost of processing power.
And i found out that</p>
<pre><code>getcontext().prec = 2
Decimal(number)
</code></pre>
<p>also counts the numbers before the point. In my case i need it only to calculate two numbers after the point no matter how big the number is. Because sometimes i got numbers like 12345.15 and sometimes numbers like 2.53. And what if the numbers are 5 or 298.1?</p>
<p>Im a bit confused with all these differences between float, decimal, rounding and truncate.</p>
<p>My main question is:</p>
<p>How can i calculate with a Number like 254.12 or 15.35 with fewest resource costs? Maybe it is even possible to fake these numbers? The rounding doesn't matter but calculating with floats and 8 digits after the point and then truncating them seems like a waste of resources to me. Please correct me if im wrong.</p>
<p>I also know how to do Benchmarks with</p>
<pre><code>import time

start_time = time.clock()
main()
print time.clock() - start_time, "seconds"
</code></pre>
<p>But im sure there are enough things i dont know about. Since im quite new to programming i would be very happy if someone can give me a few hints with a piece of code to work and learn with. Thank you for taking your time to read this! :)</p>
</div>
<div class="post-text" itemprop="text">
<p>First, please be aware that floating point operations are not necessarily as expensive as you might fear. This will depend on the CPU you are using, but for example, a single floating point operation in a mainly integer program will cost about as much as an integer operation, due to pipelining. It's like going to a bathroom at a night club. There's always a line for the girls bathroom - integer ops - but never a line for the guys - floating point ops.</p>
<p>On the other hand, low-power CPUs may not even include floating point support at all, making any float operation hideously expensive! So before you get all judgy about whether you should use float or integer operations, do some profiling. You mention using <code>time.clock</code> and comparing start with end times. You should have a look at the <code>timeit</code> module shipped with python.</p>
<p>Worse than bad performance, though, is the fact that floats don't always represent the number you want. Regardless of decimal point, if a number is large enough, or if you do the wrong operation to it, you can end up with a float that "approximates" your result without storing it exactly.</p>
<p>If you know that your application requires two digits beyond the decimal, I'd suggest that you write a class to implement that behavior using integer numbers. Python's integers automatically convert to big numbers when they get large, and the precision is exact. So there's a performance penalty (bignum ops are slower than integer or float ops on top-end hardware). But you can guarantee whatever behavior you want.</p>
<p>If your application is financial, please be aware that you are going to have to spend some time dealing with <a href="https://en.wikipedia.org/wiki/Rounding#Tie-breaking" rel="nofollow">rounding</a> issues. Everybody saw Superman 3, and now they think you're stealing their .00001 cents...</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, all floats are all the same size, regardless of precision, because they are all represented in a single 'double' type. This means that either way you will be 'wasting' memory (24 bytes is a <em>tiny</em> amount, really). Using <code>sys.getsizeof</code> shows this:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getsizeof(8.13333333)
24
&gt;&gt;&gt; sys.getsizeof(8.13)
24
</code></pre>
<p>This is also shown in the fact that if an int is too big (ints have no max value) it can't be converted into a float - you get an <code>OverflowError</code>:</p>
<pre><code>&gt;&gt;&gt; 2**1024 + 0.5
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
OverflowError: long int too large to convert to float
</code></pre>
<p>Using <code>Decimal</code> is even less efficient, even when the precision is set up right. This is because class instances take up lots of space on their own, regardless of their content:</p>
<pre><code>&gt;&gt;&gt; import decimal
&gt;&gt;&gt; sys.getsizeof(decimal.Decimal(0))
80
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>prec</code> setting actually affects the total number of digits, not only the ones after the decimal point. Regarding that, the <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow">documentation</a> says</p>
<blockquote>
<p>The significance of a new Decimal is determined solely by the number
  of digits input. Context precision and rounding only come into play
  during arithmetic operations.</p>
</blockquote>
<p>and also</p>
<blockquote>
<p>The quantize() method rounds a number to a fixed exponent. This method
  is useful for monetary applications that often round results to a
  fixed number of places</p>
</blockquote>
<p>So these are a few things you can look for if you need to work with a fixed number of digits after the point.</p>
<p>Regarding <strong>performance</strong>, it seems to me that you are <em>prematurely optimizing</em>. You generally don't need to worry about the <em>fastest</em> way to do a calculation that will take less than a microsecond (unless, of course, you need to do something on the order of millions of such calculations per second). On a quick benchmark, a sum of two numbers takes 48 nanoseconds for <code>float</code>s and 82 nanoseconds for <code>Decimal</code>s. The impact of that difference should be very little for most applications.</p>
</div>
<span class="comment-copy">Why would you even use python for this??</span>
<span class="comment-copy">To save resources you could just as well use <code>unsigned integers</code>. It just depends on what you are trying to achieve. In terms of floats it does not make a difference whether you calculate 3.1 or 3.12. Readup on IEEE 754.</span>
<span class="comment-copy">@PhilippBraun because i actually learn it. In this case i need a code with good performance at the cost of accuracy. Later i want to change the same code for a different project that requires more accuracy and performance isn't that important.</span>
<span class="comment-copy">If you're counting money, you should use integers or decimals with unlimited precision.</span>
<span class="comment-copy">That puts my mind at ease, because i think it will be a typical night club situation. :) Thank you for your detailed answer! I really appreciate this.</span>
<span class="comment-copy">Not millions per second but maybe hundreds of thousands. This is why i ask these questions. Actually i was reading a bit about premature optimisation and that helped a lot too. Thank you! :)</span>
