<div class="post-text" itemprop="text">
<p>How can I implement a manual MTU discovery with Python?</p>
<p>From: <a href="https://networkengineering.stackexchange.com/a/28988/23983">https://networkengineering.stackexchange.com/a/28988/23983</a></p>
<blockquote>
<p>Send a ping to a target, in my example, I'll use Google's DNS server (8.8.8.8). Set your DF bit in your ping to on, to prevent your ping from being fragmented. Set your packet size to some large number, or the standard MTU of 1500. Note that some ping implementations set the size of just the payload, which means you have to account for the 8 byte ICMP header, and 20 byte IP header.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I'd like to add that you could to this with raw sockets as well.<br/>
<a href="http://www.secdev.org/projects/scapy/" rel="nofollow noreferrer">scapy</a> is a nice abstraction layer that does much of the magic for you, but in all fairness if you're going to go low you could go all the way for the learning experience. <em>(Note that raw sockets require elevated permissions in most modern OS'es, and as you go deeper implementations may vary from Windows and Linux.)</em></p>
<pre><code>import socket
s = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))
</code></pre>
<p>This will give you a raw packet based socket that literally delivers all the frames for you. It varies a bit between Windows and Linux but I'll stick to Linux in this answer. Also note that all outgoing packets might not get picked up by this socket, if you need that functionality (sniffing stuff) consider searching for <a href="https://github.com/Torxed/Scripts/blob/master/python/Laboratory/switch.py" rel="nofollow noreferrer">promiscuous mode</a> related hits.</p>
<p>All you need to do now is treat each packet as the segments they come or go in, for instance - unpacking a ethernet and IP frame would look something like this:</p>
<pre><code>frame, meta = s.recvfrom(65565)
print(frame, meta)

ethernet = frame[0:14]
ethernet_segments = struct.unpack("!6s6s2s", ethernet)

mac_source, mac_dest = (binascii.hexlify(mac) for mac in ethernet_segments[:2])

ip = frame[14:34]
ip_segments = struct.unpack("!12s4s4s", ip)

ip_source, ip_dest = (socket.inet_ntoa(section) for section in ip_segments[1:3])

print('MAC Source:', b':'.join(mac_source[i:i+2] for i in range(0, len(mac_source), 2)))
print('MAC Dest:', b':'.join(mac_dest[i:i+2] for i in range(0, len(mac_dest), 2)))
print('IP Source:', ip_source)
print('IP Dest:', ip_dest)
</code></pre>
<p>Payloading would be "easy", considering you're building the packets yourself.<br/>
All be it not the most conventional of ways or the initially fastest way, but you'd be able to implement whatever you wanted.</p>
<p>Sending is just as easy, use <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">struct</a> and have a look at the many ICMP examples out there, including those with checksum calculations:</p>
<ul>
<li><a href="https://www.g-loaded.eu/2009/10/30/python-ping/" rel="nofollow noreferrer">https://www.g-loaded.eu/2009/10/30/python-ping/</a></li>
<li><a href="https://gist.github.com/pklaus/856268" rel="nofollow noreferrer">https://gist.github.com/pklaus/856268</a></li>
</ul>
<p>Regarding MTU, this is logic you'd have to implement yourself because there's no pre-built library that does this that I'm aware of.</p>
<p>But this is my contribution to sending <strong>raw IP traffic with Python</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sending anything raw in python, you are looking at using at using scapy. </p>
<p>For info on how to send ping messages:</p>
<p><a href="http://www.secdev.org/projects/scapy/doc/usage.html#icmp-ping" rel="nofollow noreferrer">http://www.secdev.org/projects/scapy/doc/usage.html#icmp-ping</a></p>
<p>To set the DF Flag:</p>
<pre><code>IP(flags='DF')
</code></pre>
<p>For how to adjust the particular size so that you can simulate fragmentation:</p>
<p><a href="https://stackoverflow.com/questions/6605118/adding-payload-in-packet-scapy">Adding payload in packet (scapy)</a></p>
<p>Putting it all together:</p>
<pre><code>data = "x" * 1473
ans,unans = sr(IP(dst="&lt;target_ip&gt;", flags='DF' )/ICMP() / Raw(load=data))
</code></pre>
<p>If you aren't actually that interested in creating these things raw, this question is a dup of: <a href="https://stackoverflow.com/questions/14010635/how-to-find-mtu-value-of-network-through-codein-python">How to find mtu value of network through code(in python)?</a></p>
</div>
