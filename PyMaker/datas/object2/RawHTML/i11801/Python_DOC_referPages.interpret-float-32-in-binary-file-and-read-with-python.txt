<div class="post-text" itemprop="text">
<p>let me start off by admitting I am not a computer scientist, so if this is a dumb question I apologize in advance. 
I am trying to figure out a binary file format using a hex editor. I am able to read ints and chars fine (using numpy in python) but when I get to the floats I am having issues, they don't appear to be IEEE 754 binary 32 and when I try to use numpy with dtype 'f4' to read this chunk of memory it returns an incorrect value. I have tried switching the endianness to no avail. Any insight to what format these numbers are in would be useful, but more importantly, how would I read them in python (assuming they are in a byte string)? The following is an example with the known value given in decimals on the top, the hex values found in the editor, followed by the binary in the file. </p>
<hr/>
<p>250</p>
<p>00 00 7a 43</p>
<p>00000000 00000000 01111010 01000011</p>
<hr/>
<p>-250</p>
<p>00 00 7a c3</p>
<p>00000000 00000000 01111010 11000011</p>
<hr/>
<p>0</p>
<p>00 00 00 00</p>
<p>00000000 00000000 00000000 00000000</p>
<hr/>
<p>200</p>
<p>00 00 48 43</p>
<p>00000000 00000000 01001000 0011 1111</p>
<hr/>
<p>250.1</p>
<p>9a 19 7a 43 </p>
<p>10011010 00011001 01111010 01000011</p>
<hr/>
</div>
<div class="post-text" itemprop="text">
<p>The values you're showing indicate that your data is being stored little-endian.  The 32-bit IEEE floating point string for 250.0, for example, is <code>437a0000</code> in hex.  The corresponding little-endian byte sequence is:</p>
<pre><code>00 00 7a 43
</code></pre>
<p>This is exactly what you've been seeing.</p>
<p>I think the problem is that Python usually uses double-precision for its <code>float</code> type, i.e. 64-bit floating point values.</p>
<p>One way to correctly unpack these values is with <code>struct</code>:</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.unpack('&gt;f', '\x43\x7a\x00\x00')[0]
250.0
&gt;&gt;&gt;
</code></pre>
<p>The above works for Python 2.  In Python 3, you need a buffer, such as:</p>
<pre><code>&gt;&gt;&gt; struct.unpack('&gt;f', b'\x43\x7a\x00\x00')[0]
250.0
&gt;&gt;&gt;
</code></pre>
<p>or:</p>
<pre><code>&gt;&gt;&gt; struct.unpack('&gt;f', bytes([0x43, 0x7a, 0x00, 0x00]))[0]
250.0
&gt;&gt;&gt;
</code></pre>
<p>For more info, see the struct documentation for <a href="https://docs.python.org/2/library/struct.html" rel="nofollow">Python 2</a> or 
<a href="https://docs.python.org/3/library/struct.html" rel="nofollow">Python 3</a>.  This seems to be exactly what you're looking for.</p>
</div>
<span class="comment-copy">A binary editor is always a good first approach to get a feeling for binary files. Python has excellent binary handling in the <code>struct</code> module. This and other techniques are discussed here: <a href="http://www.devdungeon.com/content/working-binary-data-python#struct" rel="nofollow noreferrer">devdungeon.com/content/working-binary-data-python#struct</a></span>
<span class="comment-copy">"<i>when I try to use numpy with dtype 'f4' to read this chunk of memory it returns an incorrect value</i>"? Can you provide a short, complete program that demonstrates the error you are seeing? Or, at least, show us precisely how you are "trying to use numpy"?</span>
<span class="comment-copy">Turns out I was using numpy always with the big endian "f4" format. When using the little endian the code works fine. Simple mistake I had passed over a hundred times.</span>
