<div class="post-text" itemprop="text">
<p>I'm not very familiar with Python, so when I met this code, there are a few things not quite clear to me. Here is the code:</p>
<pre><code>class TypeVariable(object):
    #A type variable standing for an arbitrary type.
    #All type variables have a unique id, but names are only assigned lazily, 
    #when required.

    next_variable_id = 0

    def __init__(self):
        self.id = TypeVariable.next_variable_id
        TypeVariable.next_variable_id += 1
        self.instance = None
        self.__name = None

    next_variable_name = 'a'

    @property
    def name(self):
        #Names are allocated to TypeVariables lazily, so that only TypeVariables present
        if self.__name is None:
            self.__name = TypeVariable.next_variable_name
            TypeVariable.next_variable_name = chr(ord(TypeVariable.next_variable_name) + 1)
        return self.__name
</code></pre>
<p>Why does <code>def __init__(self):</code> not have <code>name</code> as a parameter but in the above code there is <code>self.__name = None</code>?</p>
<p>Also, what does <code>self.instance</code> mean, because I don't recall that there is an attribute called instance.</p>
<p>Can someone please help me understand what this code does, and if a java version can be provided will be much appreciated since I'm more familiar with Java. Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>The code has no context to say what <code>self.instance</code> might be. As for <code>self.__name</code>, the <code>property</code> definition makes clear that it is lazily assigning sequential names to instances. It sets <code>__name</code> to <code>None</code> so it knows it hasn't been initialized; when <code>self.name</code> is accessed, it will recognize the placeholder, replace it with a new value, and return the new value.</p>
<p>Note that providing some assignment to all instance attributes in <code>__init__</code> is considered good form in Python, since otherwise it can be very hard to figure out what attributes an instance might have. And in modern Python (3.3 and up), doing so gets you a memory savings; as long as all attributes are initialized in <code>__init__</code> and no new attributes are added after <code>__init__</code>, the <code>__dict__</code> for all instances is a <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-412-key-sharing-dictionary" rel="nofollow">key-sharing dictionary</a> which reduces the cost of each instance significantly (by roughly two-thirds, though that's an implementation detail). So if some other method/property would set <code>instance</code> later, it's best to initialize it to something in <code>__init__</code> both for maintainers to know what it's supposed to have, and reduced memory consumption in Py3.3+.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>self.instance = None
self.__name = None
</code></pre>
<p>There are just object attributes with default value. You don't need to put them into <code>__init__()</code> parameters if they are not required for building class instance.</p>
</div>
<span class="comment-copy">Hi, can I consider the <code>def __init__(self)</code> as a constructor in Java, if so then how come it can do add operation in the constructor</span>
<span class="comment-copy">@AndaZhao: Technically, <code>__init__</code> is an initializer; the raw object is created before it is called (that's how you receive <code>self</code>). Python has a <code>__new__</code> that constructs (and can initialize too), but it's typically only used for logically immutable objects (<code>__init__</code> can be called more than once, which would violate immutability) or cached/singleton objects (<code>__new__</code> can return an existing object, not just make new ones). But in any event, Python, unlike Java, doesn't define instance attribute names ahead of time in general; you can define any attribute, any time.</span>
<span class="comment-copy"><code>self.__name</code> is needed at the least since the <code>@property</code> assumes it exists. The implementation of <code>name</code> would have to change if it wasn't guaranteed to be initialized in <code>__init__</code>.</span>
