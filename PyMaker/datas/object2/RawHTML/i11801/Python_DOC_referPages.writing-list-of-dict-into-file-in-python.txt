<div class="post-text" itemprop="text">
<p>I am having trouble in dynamically mapping the dictionary values while writing the db output into a file. 
Scenario:</p>
<pre><code>new_list = [{'Table':'A', 'Column':'C1', 'DataType':'int'},
        {'Table':'A', 'Column':'C2', 'DataType':'varchar'},
        {'Table':'A', 'Column':'C2', 'DataType':'numeric'}
       ]
# I want to write the data into a file.
Table|Column|DataType
A|C1|int
A|C2|varchar
A|C3|numeric
</code></pre>
<p>I am trying to do like below.</p>
<pre><code>header = []
with open('my_log.log', 'w',encoding='utf-8') as log:
   for n in new_list:
      for i in n.keys():
        header.append(i)
   log.write("|".join(set(header)))
   log.write("\n")
   for data in new_list:
      # don't want to hard code the keys like below
      log.write("{Table}|{Column}|{DataType} \n".format(**data))
      # need to do something so that I dont have to hard code the keys as it  is dynamic in nature
      # and also my file output should match with the header generated in the previous line
      log.write("{???}".format(**data))
</code></pre>
<p>Any Suggestion!</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a way to write out the data using a dynamic list of headers:</p>
<pre><code>new_list = [{'Table':'A', 'Column':'C1', 'DataType':'int'},
        {'Table':'A', 'Column':'C2', 'DataType':'varchar'},
        {'Table':'A', 'Column':'C2', 'DataType':'numeric'}
       ]

header = new_list[0].keys()

with open('my_log.log', 'w') as log:
   log.write("|".join(header))
   log.write("\n")
   for data in new_list:
      log.write("|".join(data[h] for h in header))
      log.write("\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're writing delimited text, so you should be using the <code>csv</code> module. It happens to have a <a href="https://docs.python.org/3/library/csv.html#csv.DictWriter" rel="nofollow"><code>DictWriter</code></a> object that is perfect for this.</p>
<pre><code>import csv

new_list = [{'Table':'A', 'Column':'C1', 'DataType':'int'},
    {'Table':'A', 'Column':'C2', 'DataType':'varchar'},
    {'Table':'A', 'Column':'C2', 'DataType':'numeric'}
   ]

with open("my_log.log", "wb") as f:
    writer = csv.DictWriter(f,
                            fieldnames=["Table", "Column", "DataType"],
                            delimiter="|")
    writer.writerows(new_list)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use python pandas.</p>
<pre><code>import pandas as pd
tableA = pd.DataFrame([[1,2,3],[4,5,6]], columns=["C1","C2","C3"])
tableA.to_csv("mytables.csv",sep="|")
</code></pre>
<p>OUTPUT: mytables.csv</p>
<p>|C1|C2|C3</p>
<p>0|1|2|3</p>
<p>1|4|5|6</p>
</div>
<span class="comment-copy">A dictionary can be serialized using pickle. You could look into that</span>
<span class="comment-copy">You could also write the list out using <code>json.dump</code> more information can be found within <a href="https://docs.python.org/2/library/json.html#basic-usage" rel="nofollow noreferrer">Python's JSON documentation</a>.</span>
<span class="comment-copy">I second the approach of dumping to JSON, but if you want to build your own file then seriously consider my approach over the accepted solution. <code>csv.DictWriter</code> is the "one...obvious way to do it"</span>
<span class="comment-copy">Note that this doesn't guarantee the order of the columns, since dictionaries are orderless.</span>
<span class="comment-copy">@AdamSmith True, but if the data is being read back into a dictionary then it doesn't matter.</span>
<span class="comment-copy">Absolutely! Though if the data is being read back into a dictionary, you could just serialize with pickle or JSON :)</span>
<span class="comment-copy">Is there any way we can set the fieldnames dynamically because new_list will vary depending on the query?@Adam Smith</span>
<span class="comment-copy">@Pradeep Sure, any way you could normally manipulate that. The problem you will run into is the same as in Brent Washburne's answer. Dictionary keys are not ordered, so you can't guarantee that <code>{"A": 1, "B": 2, "C": 3}.keys()</code> will give you <code>["A", "B", "C"]</code> and not <code>["B", "C", "A"]</code> (or any other arbitrary ordering.)</span>
<span class="comment-copy">If you need to get a list of arbitrary keys and you care at all about their order, I would define them to be a <code>collections.OrderedDict</code> beforehand, or simple decide "I'm using the alphabetical sort of all these keys." (<code>fieldnames=sorted(new_list[0].keys())</code>)</span>
<span class="comment-copy">cool! it resolves my issue! thanks. @Adam Smith</span>
<span class="comment-copy">@Pradeep glad I could help!</span>
