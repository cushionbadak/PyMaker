<div class="post-text" itemprop="text">
<p>Given a string, lets say "TATA__", I need to find the total number of differences between adjacent characters in that string. i.e. there is a difference between T and A, but not a difference between A and A, or _ and _.</p>
<p>My code more or less tells me this. But when a string such as "TTAA__" is given, it doesn't work as planned. </p>
<p>I need to take a character in that string, and check if the character next to it is not equal to the first character. If it is indeed not equal, I need to add 1 to a running count. If it is equal, nothing is added to the count.</p>
<p>This what I have so far:</p>
<pre><code>def num_diffs(state):
    count = 0            
    for char in state:
        if char != state[char2]:
            count += 1
    char2 += 1
    return count
</code></pre>
<p>When I run it using num_diffs("TATA__") I get 4 as the response. When I run it with num_diffs("TTAA__") I also get 4. Whereas the answer should be 2. </p>
<p>If any of that makes sense at all, could anyone help in fixing it/pointing out where my error lies? I have a feeling is has to do with state[char2]. Sorry if this seems like a trivial problem, it's just that I'm totally new to the Python language.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of ways you might do this.<br/>
First, you could iterate through the string using an index, and compare each character with the character at the previous index.<br/>
Second, you could keep track of the previous character in a separate variable. The second seems closer to your attempt.</p>
<pre><code>def num_diffs(s):
    count = 0
    prev = None
    for ch in s:
        if prev is not None and prev!=ch:
            count += 1
        prev = ch
    return count
</code></pre>
<p><code>prev</code> is the character from the previous loop iteration. You assign it to <code>ch</code> (the current character) at the end of each iteration so it will be available in the next.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import operator

def num_diffs(state):
    return sum(map(operator.ne, state, state[1:]))
</code></pre>
<p>To open this up a bit, it maps <code>!=</code>, <code>operator.ne</code>, over <code>state</code> and <code>state</code> beginning at the 2nd character. The <code>map</code> function accepts multible iterables as arguments and passes elements from those one by one as positional arguments to given function, until one of the iterables is exhausted (<code>state[1:]</code> in this case will stop first).</p>
<p>The <code>map</code> results in an iterable of boolean values, but since <code>bool</code> in python inherits from <code>int</code> you can treat it as such in some contexts. Here we are interested in the <code>True</code> values, because they represent the points where the adjacent characters differed. Calling <code>sum</code> over that mapping is an obvious next step.</p>
<p>Apart from the string slicing the whole thing runs using iterators in python3. It is possible to use iterators over the string <code>state</code> too, if one wants to avoid slicing huge strings:</p>
<pre><code>import operator
from itertools import islice

def num_diffs(state):
    return sum(map(operator.ne,
                   state,
                   islice(state, 1, len(state))))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might want to investigate Python's <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>groupby</code></a> function which helps with this kind of analysis.</p>
<pre><code>from itertools import groupby

def num_diffs(seq):
    return len(list(groupby(seq))) - 1

for test in ["TATA__",  "TTAA__"]:
    print(test, num_diffs(test))
</code></pre>
<p>This would display:</p>
<pre><code>TATA__ 4
TTAA__ 2
</code></pre>
<p>The <code>groupby()</code> function works by grouping identical entries together. It returns a <code>key</code> and a <code>group</code>, the key being the matching single entry, and the group being a list of the matching entries. So each time it returns, it is telling you there is a difference.</p>
</div>
<div class="post-text" itemprop="text">
<p>Trying to make as little modifications to your original code as possible:</p>
<pre><code>def num_diffs(state):
    count = 0            
    for char2 in range(1, len(state)):
        if state[char2 - 1] != state[char2]:
            count += 1      
    return count                    
</code></pre>
<p>One of the problems with your original code was that the <code>char2</code> variable was not initialized within the body of the function, so it was impossible to predict the function's behaviour.</p>
<p>However, working with indices is not the most Pythonic way and it is error prone (see comments for a mistake that I made).  You may want rewrite the function in such a way that it does one loop over a pair of strings, a pair of characters at a time:</p>
<pre><code>def num_diffs(state):
    count = 0
    for char1, char2 in zip(state[:-1], state[1:]):
        if char1 != char2:
            count += 1
    return count
</code></pre>
<p>Finally, that very logic can be written much more succinctly â€” see @Ilja's answer.</p>
</div>
<span class="comment-copy">Your example is not <a href="http://stackoverflow.com/help/mcve">verifiable or complete</a>, since <i>char2</i> is not defined before use. Please fix your code example.</span>
<span class="comment-copy">What is the value of <code>char2</code>?</span>
<span class="comment-copy">But I would expect <code>3</code> for  <code>num_diffs("TTAA__")</code> can you please explain why it should be <code>2</code>?</span>
<span class="comment-copy">The responses from Khelwood and Bolo are pretty much perfect. Thanks so much! Thanks to Ilja too but it was too complex for what I was looking for.</span>
<span class="comment-copy">Thank you so much Ilja! While importing is not exactly what I had in mind, it is a great solution nonetheless.</span>
<span class="comment-copy">While this code would work for those specific examples, I was looking for something that would work in multiple cases. Such as "TATATA__" or "TAATATATAT__". Thank you so much though! (If you included what I just said in your code, please excuse me. I'm really new to this whole Python thing.)</span>
<span class="comment-copy">Should be <code>range(1, len(state))</code>, not <code>range(1, len(state)-1)</code>.</span>
<span class="comment-copy">@khelwood That would raise <code>IndexError</code></span>
<span class="comment-copy">No it wouldn't. Your code is missing off comparing the last two characters in the string.</span>
<span class="comment-copy">@bolo: The second argument to <code>range()</code> is exclusive.</span>
<span class="comment-copy">@zondo Ah, right!</span>
