<div class="post-text" itemprop="text">
<p>Say I already have a method with type annotations:</p>
<pre><code>class Shape:
    def area(self) -&gt; float:
        raise NotImplementedError
</code></pre>
<p>Which I will then subclass multiple times:</p>
<pre><code>class Circle:
    def area(self) -&gt; float:
        return math.pi * self.radius ** 2

class Rectangle:
    def area(self) -&gt; float:
        return self.height * self.width
</code></pre>
<p>As you can see, I'm duplicating the <code>-&gt; float</code> quite a lot. Say I have 10 different shapes, with multiple methods like this, some of which contain parameters too. Is there a way to just "copy" the annotation from the parent class, similar to what <code>functools.wraps()</code> does with docstrings?</p>
</div>
<div class="post-text" itemprop="text">
<p>This might work, though I'm sure to miss the edge cases, like additional arguments:</p>
<pre><code>from functools import partial, update_wrapper


def annotate_from(f):
    return partial(update_wrapper,
                   wrapped=f,
                   assigned=('__annotations__',),
                   updated=())
</code></pre>
<p>which will assign "wrapper" function's <code>__annotations__</code> attribute from <code>f.__annotations__</code> (keep in mind that it is not a copy).</p>
<p>According to documents the <a href="https://docs.python.org/3/library/functools.html#functools.update_wrapper" rel="nofollow"><code>update_wrapper</code></a> function's default for <em>assigned</em> includes <code>__annotations__</code> already, but I can see why you'd not want to have all the other attributes assigned from <em>wrapped</em>.</p>
<p>With this you can then define your <code>Circle</code> and <code>Rectangle</code> as</p>
<pre><code>class Circle:
    @annotate_from(Shape.area)
    def area(self):
        return math.pi * self.radius ** 2

class Rectangle:
    @annotate_from(Shape.area)
    def area(self):
        return self.height * self.width
</code></pre>
<p>and the result</p>
<pre><code>In [82]: Circle.area.__annotations__
Out[82]: {'return': builtins.float}

In [86]: Rectangle.area.__annotations__
Out[86]: {'return': builtins.float}
</code></pre>
<p>As a side effect your methods will have an attribute <code>__wrapped__</code>, which will point to <code>Shape.area</code> in this case.</p>
<hr/>
<p>A less standard (if you can call the above use of <em>update_wrapper</em> standard) way to accomplish handling of overridden methods can be achieved using a class decorator:</p>
<pre><code>from inspect import getmembers, isfunction, signature


def override(f):
    """
    Mark method overrides.
    """
    f.__override__ = True
    return f


def _is_method_override(m):
    return isfunction(m) and getattr(m, '__override__', False)


def annotate_overrides(cls):
    """
    Copy annotations of overridden methods.
    """
    bases = cls.mro()[1:]
    for name, method in getmembers(cls, _is_method_override):
        for base in bases:
            if hasattr(base, name):
                break

        else:
            raise RuntimeError(
                    'method {!r} not found in bases of {!r}'.format(
                            name, cls))

        base_method = getattr(base, name)
        method.__annotations__ = base_method.__annotations__.copy()

    return cls
</code></pre>
<p>and then:</p>
<pre><code>@annotate_overrides
class Rectangle(Shape):
    @override
    def area(self):
        return self.height * self.width
</code></pre>
<p>Again, this will not handle overriding methods with additional arguments.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a class decorator to update your subclass methods annotations. In your decorator you will need to walk through your class definition then update only those methods that are present in your superclass. Of course to access the superclass you need to use the it <a href="https://docs.python.org/3.5/library/stdtypes.html?highlight=mro#class.__mro__" rel="nofollow"><code>__mro__</code></a> which is just the tuple of the class, subclass, till <code>object</code>. Here we are interested in the second element in that tuple which is at index <code>1</code> thus <code>__mro__[1]</code> or using the <a href="https://docs.python.org/3.5/library/stdtypes.html?highlight=mro#class.__mro__" rel="nofollow"><code>cls.mro()[1]</code></a>. Last and not least your decorator must return the class.</p>
<pre><code>def wraps_annotations(cls):
    mro = cls.mro()[1] 
    vars_mro = vars(mro)
    for name, value in vars(cls).items():
        if callable(value) and name in vars_mro:
            value.__annotations__.update(vars(mro).get(name).__annotations__)
    return cls
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class Shape:
...     def area(self) -&gt; float:
...         raise NotImplementedError
...
&gt;&gt;&gt; import math
&gt;&gt;&gt;
&gt;&gt;&gt; @wraps_annotations
... class Circle(Shape):
...     def area(self):
...         return math.pi * self.radius ** 2
...
&gt;&gt;&gt; c = Circle()
&gt;&gt;&gt; c.area.__annotations__
{'return': &lt;class 'float'&gt;}
&gt;&gt;&gt; @wraps_annotations
... class Rectangle(Shape):
...     def area(self):
...         return self.height * self.width
...
&gt;&gt;&gt; r = Rectangle()
&gt;&gt;&gt; r.area.__annotations__
{'return': &lt;class 'float'&gt;}
</code></pre>
</div>
<span class="comment-copy">Awesome, thank you very much! :) I hadn't even thought of decorator.</span>
<span class="comment-copy">Why was this answer downvoted?..I can't see any comments?...</span>
