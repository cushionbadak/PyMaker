<div class="post-text" itemprop="text">
<p>suppose I have a class definition like this</p>
<pre><code>class structure:
    def __init__(self, handle):
        self.handle = handle
</code></pre>
<p>How can I use <code>numpy.unique</code> or another tool of Python3 to find unique elements in a list of instances of this class? The comparison should be done with respect to the value of the <code>'handle'</code> field.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>numpy.unique</code> is not the best tool for custom classes. Make your instances <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow">hashable</a> (implementing <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow"><code>__hash__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow"><code>__eq__</code></a>), then use a set to reduce a list of instances to unique values:</p>
<pre><code>class structure:
    def __init__(self, handle):
        self.handle = handle

    def __hash__(self):
        return hash(self.handle)

    def __eq__(self, other):
        if not isinstance(other, structure):
            # only equality tests to other `structure` instances are supported
            return NotImplemented
        return self.handle == other.handle
</code></pre>
<p>Sets efficiently can detect duplicates via the hash, confirming that the objects with the same hash are also equal first.</p>
<p>To get the unique instances, simply call <code>set()</code> on a sequence of instances:</p>
<pre><code>unique_structures = set(list_of_structures)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class structure:
...     def __init__(self, handle):
...         self.handle = handle
...     def __hash__(self):
...         return hash(self.handle)
...     def __eq__(self, other):
...         if not isinstance(other, structure):
...             # only equality tests to other `structure` instances are supported
...             return NotImplemented
...         return self.handle == other.handle
...     def __repr__(self):
...         return '&lt;structure({!r})&gt;'.format(self.handle)
...
&gt;&gt;&gt; list_of_structures = [structure('foo'), structure('bar'), structure('foo'), structure('spam'), structure('spam')]
&gt;&gt;&gt; set(list_of_structures)
{&lt;structure('bar')&gt;, &lt;structure('foo')&gt;, &lt;structure('spam')&gt;}
</code></pre>
<p>Do take into account that the hash of any <code>structure</code> instance stored in a set or used a dictionary key <em>must not change</em>; not altering the <code>handle</code> attribute during the lifetime of an instance is the easiest way to ensure this.</p>
</div>
<span class="comment-copy">Do you want the values for handle, or the instances?  If you want the instances and two instances have same value for handle, which should be chosen?</span>
<span class="comment-copy">Could I ask you kindly to explaing the reason of insertion of 'if not isinstance'?</span>
<span class="comment-copy">@Macaronnos: comparison methods like <code>__eq__</code> should always return <code>NotImplemented</code> for comparisons they do not support; there is little point in supporting equality tests with anything other than <code>structure</code> instances.</span>
<span class="comment-copy">Oh, exactly. Thank you.</span>
