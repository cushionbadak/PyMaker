<div class="post-text" itemprop="text">
<p>So i made a class and want, that attribute hp stays always between 0 and maxhp
In theory making hp a property should give me the wished result: Somehow it doesnt work though.</p>
<p>Is there way to link attributes for and back? So i have stored the position of the unit class object. At 2 places, once the attribute position which contains a [x,y] array and the other time its stored in 2 attributes x and y and each contains a int. 
Changing self.x or self.y should changes self.position and the other way around too.</p>
<pre><code> class units(object):

    def __init__(self,typus, position, stats):
        self.type = typus

        #they should be linked both directions
        self.position = position
        self.x = self.position[0]
        self.y = self.position[1]

        self.attack = stats[0]
        self.defense = stats[1]
        self.maxhp = stats[2]
        self.hp = self.maxhp

    def __repr__(self):
        text = "This a %s at position [%s,%s].\n  Attack: %s \n Defense: %s \n Hp : %s/%s \n "  \
               % (self.type,self.position[0],self.position[1],  self.attack, self.defense, self.hp, self.maxhp)
        return text


    # hp set to always be in between 0 and maxhp
    @property
    def hp(self):
        return self.__hp

    @hp.setter
    def hp(self, hp):
        if hp &lt; 0:
            self.__hp = 0
        if hp &gt; self.maxhp:
            self.__hp = self.maxhp
        else:
            self.__hp = hp

    def takedmg(self,dmg):
        self.hp -= max(dmg-self.defense, 0)
        if self.hp &lt;= 0:
            self.alive = False
        return self.hp



p = units("peasant", [1,1],  [2,0,30])
p.takedmg(100)
print (p.hp)     # it should be 0!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In your <code>__init__</code>, the line <code>self.hp = self.maxhp</code> should be <code>self.__hp = self.maxhp</code>. That way it's only set/get in the <code>@property</code> methods.</p>
<p>You would handle <code>postion</code>, <code>x</code> and <code>y</code> the same way as you've done for <code>hp</code>. Use <code>_postion</code>, <code>_x</code> and <code>_y</code> internally to correspond to the values in the getters and setters; and set all of the <code>_prop</code> values in the setters of each. Using <code>position</code> as a an example:</p>
<pre><code>@property
def position(self):
    return self._position

@position.setter
def position(self, position):
    self._position = position  # do checking before this if needed
    self._x = position[0]
    self._y = position[1]
</code></pre>
<p>Similarly for <code>x</code> and <code>y</code>, though I think you should only do it via <code>position</code>:</p>
<pre><code>@property
def x(self):
    return self._x

@x.setter
def x(self, x):
    self._x = x
    # self._y remains unchanged
    self._position[0] = x
</code></pre>
<p>Btw, the <code>hp</code> setter can be re-written as follows:</p>
<pre><code>@hp.setter
def hp(self, hp):
    self.__hp = max(0, min(hp, self.maxhp))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another problem is in <code>hp.setter</code>. The second <code>if</code> statement should be replaced with <code>elif</code> because when <code>hp</code> is less than 0, <code>self.__hp</code> is set to 0 in first <code>if</code> and then, without <code>elif</code>, it is set to a negative value in <code>else</code>:</p>
<pre><code>@hp.setter
def hp(self, hp):
    if hp &lt; 0:
        self.__hp = 0
    elif hp &gt; self.maxhp:
        self.__hp = self.maxhp
    else:
        self.__hp = hp
</code></pre>
</div>
<span class="comment-copy">And along with the changes given in my answer, consider using <a href="https://docs.python.org/3/library/string.html#format-string-syntax" rel="nofollow noreferrer"><code>str.format()</code></a> for the long <code>__repr__</code>.</span>
<span class="comment-copy">Thanks that helped a lot. The rewrinting of hp: I really like itsince there actually lots of attributes that need a similiar behaviour.</span>
<span class="comment-copy">Yes, I use a similar approach to implement such behaviour. It's also the <i>pythonic</i> way to do it - so almost everyone does. One thing to add, do you necessarily need the double-underscore name-mangling for <code>self.__hp</code> vs <code>self._hp</code> which is just considered private? That's only really needed if you don't want a sub-class's implementation to interfere with yours.</span>
<span class="comment-copy">Well that was the way showed when i googeled how to use property. So no doesnt make any difference. One small question "do checking before this if needed" what do you mean with that?</span>
<span class="comment-copy">"do checking before this if needed" for <code>position</code> such as not allowing negative values (if appropriate) or not allowing <code>x</code> and <code>y</code> values which are out of bounds of the map/grid.</span>
<span class="comment-copy">That's not really a problem, unless <code>maxhp</code> can be negative. Putting it as an <code>elif</code> <i>is</i> better/clearer/optimised but it's definitely not the problem.</span>
<span class="comment-copy">That's a real problem in the example code. When hp is &lt;0 self.__hp is set to 0 in first if, then, without elif, is it set to negative value in else.</span>
<span class="comment-copy">Good point, missed that. Fortunately, the <code>hp.setter</code> I put in my answer doesn't have that bug. I've edited your answer and added your explanation (and undone my -ve vote). <i>Though</i> that wasn't the OP's question wrt setting dependent values.</span>
