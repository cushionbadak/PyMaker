<div class="post-text" itemprop="text">
<p>In Japanese, there are combining diacritical marks that apply to certain <em>kana</em>, so there is a logical relationship between say "か" (<em>ka</em>) and "が" (<em>ga</em>) - the <em>ga</em> character is voiced.</p>
<p>I'm wondering if there is any natural way (in Python, preferably, though a generalized answer about unicode is fine, too) to do the equivalent of transforming voiced characters to their unvoiced equivalents, and vice-versa - something akin to the <code>lower()</code> method that applies in latin scripts. An example of what I'm looking to do:</p>
<pre><code>&gt;&gt;&gt; devoice('が')
"か"
&gt;&gt;&gt; voice('か')
"が"
&gt;&gt;&gt; devoice('か')
"か"
&gt;&gt;&gt; semivoice('は')
"ぱ"
&gt;&gt;&gt; devoice('ぱ')
"は"
</code></pre>
<p>At the moment, the best approach I seem to be able to come up with is to generate a lookup table indexed by row, column and voicing, then look up the character I have and translate it in the right direction. That said, I'd like to know if there's a more natural way to do it.</p>
<p>One potential pitfall is that it seems to me that the unicode combining characters do not seem to compare equal to their single-codepoint equivalents:</p>
<pre><code>&gt;&gt;&gt; a = chr(0x304B) + chr(0x3099)
&gt;&gt;&gt; b = chr(0x304C)
&gt;&gt;&gt; print(a)
'が'
&gt;&gt;&gt; print(b)
'が'
&gt;&gt;&gt; a == b
False
</code></pre>
<p>I am mainly concerned with the ones that do <em>not</em> involve combining diacriticals, since it seems easy enough to detect and strip off the combining marks.</p>
<p><em>Note:</em> I am not sure I understand Japanese phonology well enough to know what the correct behavior is for <code>う</code> (u) and <code>ゔ</code> (vu - rare / obsolete), which again is why it would be nice if there were a "natural" way to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can de-voice by decomposing the character (moving from the NFC to NFD forms), using the <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize" rel="nofollow"><code>unicodedata.normalize()</code> function</a></p>
<pre><code>&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; print(ascii(unicodedata.normalize('NFD', '\u304c')))
'\u304b\u3099'
</code></pre>
<p>so <code>devoice()</code> can be implemented as:</p>
<pre><code>def devoice(char):
    return unicodedata.normalize('NFD', char)[0]
</code></pre>
<p>If voicing always adds <code>\u3099</code> (which it looks like), you can just add that to the entered kana and return the <code>NFC</code> combined normal form:</p>
<pre><code>def voice(char):
    return unicodedata.normalize('NFC', char + '\u3099')
</code></pre>
<p>It looks like semivoiced means you add <code>\u309a'</code>:</p>
<pre><code>def semivoice(char):
    return unicodedata.normalize('NFC', char + '\u309a')
</code></pre>
<p>You could possibly use <code>unicodedata.decomposition()</code> to test if there is a decomposition:</p>
<pre><code>import unicodedata

def voice(char):
    if not ('\u3041' &lt;= char &lt;= '\u3096') or len(char) &gt; 1 or unicodedata.decomposition(char):
        return char
    return unicodedata.normalize('NFC', char + '\u3099')

def semivoice(char):
    if not ('\u3041' &lt;= char &lt;= '\u3096') or len(char) &gt; 1 or unicodedata.decomposition(char):
        return char
    return unicodedata.normalize('NFC', char + '\u309a')

def devoice(char):
    if not ('\u3041' &lt;= char &lt;= '\u3096') or len(char) &gt; 1 or not unicodedata.decomposition(char):
        return char
    return unicodedata.normalize('NFD', char)[0]
</code></pre>
</div>
<span class="comment-copy">Thanks! What about the other direction? I would prefer that <code>voice('\u304b')</code> return <code>'\u304c'</code>, not <code>'\u304b\u3099'</code>.</span>
<span class="comment-copy">@Paul: I was still working on that part :-)</span>
<span class="comment-copy">Looks good! Thanks. There's still some delay before I can accept an answer.</span>
