<div class="post-text" itemprop="text">
<p>I want to perform a power operation combined with a modulo.  I have trouble performing this <code>pow()</code> function with real numbers.</p>
<p>This works fine for integers: </p>
<pre><code>pow(2,6000,400) = 176
</code></pre>
<p>However, this returns an error with real numbers:</p>
<pre><code>pow(1.4142, 6000, 400)
</code></pre>
<p>I have tried also the <code>math.pow()</code> function but it doesn't
work either... how can I get this to work with real numbers ?</p>
</div>
<div class="post-text" itemprop="text">
<p>The python function <code>pow()</code> accepts 2 or 3 arguments. In your case, <code>pow(x,y,z)</code> does <code>x</code> power <code>y</code> and applies a modulo <code>z</code> to the result.  But the <a href="https://docs.python.org/3/library/functions.html#pow" rel="nofollow">documentation</a> is explicit:  </p>
<blockquote>
<p>If the second argument is negative, the third argument must be
  omitted. If z is present, x and y must be of integer types, and y must
  be non-negative.</p>
</blockquote>
<p>So:  </p>
<ul>
<li><p>Your first call works fine, because the arguments comply with the requirements.  Note that despite <code>pow(2,6000)</code> being a huge number,  the result of the combined modulo operation can be calculated easily without overflow, by using properties on <a href="https://en.wikipedia.org/wiki/Modular_exponentiation" rel="nofollow">modular exponentiation</a> of integers. </p></li>
<li><p>Your second call fails with an error, because the first argument is not an integer. The workaround would be to decompose your operation into <code>pow(1.4142,6000) % 400</code>, because <a href="https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations" rel="nofollow">modulo</a> is defined for real numbers. <br/> Unfortunately, <code>pow(1.4142,6000)</code> is too big and causes an overflow error. This is because contrary to the python integers which are of unlimited range, <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow">real numbers are limited</a> by the range of the C floating point encoding.  </p></li>
</ul>
<p>P.S.: I assumed that it's about python and not VB, because <a href="https://msdn.microsoft.com/en-us/library/system.math.pow%28v=vs.110%29.aspx?cs-save-lang=1&amp;cs-lang=vb#code-snippet-1" rel="nofollow">VB's <code>pow()</code></a> accepts only 2 arguments.  </p>
<p><strong>Edit: hint for a workaround</strong></p>
<p>Here a little workaround that makes use of the fact that technically, a floating point number is not a mathematical real of unlimited precision, but a rational number.  We can then make use of the numerator and denominator and use integer operations to master the huge numbers: </p>
<pre><code>n=pow(14142,6000)         # take the first argument multiplied by a 10 exponent to make it an integer
d=pow(10000,6000)         # keep track of this 10 exponent
i=n//d                    # integer division to compute the integral value
r=n-d*i                   # remainder of the integer division 
precision=6               # precision 
f=r*pow(10,precision)//d  # keep the 6 most significant digits 
result=(i%400)+(f/pow(10,precision)) 
</code></pre>
<p>The result is 271.048181 to the 6th digit.  I let you as an exercise the writing of a function that performs this in a less artisanal way.   </p>
</div>
<span class="comment-copy">What programming language do you use?</span>
<span class="comment-copy">am using only VB and Python</span>
<span class="comment-copy">This helps so much!!!!  Thank you!!!  :)  Will experiment with this.</span>
<span class="comment-copy">Christophe, could you tell me how accurate you feel that returned value of "271.04" would be?  Would it be very precise?</span>
<span class="comment-copy">According to the <a href="http://www.fas.harvard.edu/~scphys/nsta/error_propagation.pdf" rel="nofollow noreferrer">rules of error propagation</a> it's +/- 0.4243 so that the exact value should be btw 270.62 and 271.48</span>
