<div class="post-text" itemprop="text">
<p>What's a Python bytestring? </p>
<p>All I can find are topics on how to encode to bytestring or decode to <code>ascii</code> or <code>utf-8</code>. I'm trying to understand how it works under the hood. In a normal ASCII string, it's an array or list of characters, and each character represents an ASCII value from 0-255, so that's how you know what character is represented by the number. In Unicode, it's the 8- or 16-byte representation for the character that tells you what character it is.</p>
<p>So what is a bytestring? How does Python know which characters to represent as what? How does it work under the hood? Since you can print or even return these strings and it shows you the string representation, I don't quite get it...</p>
<p>Ok, so my point is <em>definitely</em> getting missed here. I've been told that it's an <em>immutable</em> sequence of bytes without any particular <em>interpretation</em>. </p>
<p>A sequence of bytes.. Okay, let's say one byte:<br/>
<code>'a'.encode()</code> returns <code>b'a'</code>.  </p>
<p>Simple enough. Why can I read the <strong>a</strong>? </p>
<p>Say I get the ASCII value for <strong>a</strong>, by doing this:<br/>
<code>printf "%d" "'a"</code></p>
<p>It returns <strong>97</strong>. Okay, good, the integer value for the ASCII character <strong>a</strong>. If we interpret <strong>97</strong> as ASCII, say in a C <code>char</code>, then we get the letter <code>a</code>. Fair enough. If we convert the byte representation to bits, we get this:</p>
<p><code>01100001</code></p>
<p><em>2^0 + 2^5 + 2^6 = 97</em>. Cool.</p>
<p>So why is <code>'a'.encode()</code> returning <code>b'a'</code> instead of <code>01100001</code>??<br/>
If it's <strong>without</strong> a particular <em>interpretation</em>, shouldn't it be returning something like <code>b'01100001'</code>?<br/>
It <strong>seems</strong> like it's interpreting it like ASCII.</p>
<p>Someone mentioned that it's calling <code>__repr__</code> on the bytestring, so it's displayed in human-readable form. However, even if I do something like:</p>
<pre><code>with open('testbytestring.txt', 'wb') as f:
    f.write(b'helloworld')
</code></pre>
<p>It will <em>still</em> insert <code>helloworld</code> as a regular string into the file, not as a sequence of bytes... So is a bytestring in ASCII?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python <em>does not</em> know how to represent a bytestring. That's the point.</p>
<p>When you output a character with value 97 into pretty much any output window, you'll get the character 'a' but that's not part of the implementation; it's just a thing that happens to be locally true. If you want an encoding, you don't use bytestring. If you use bytestring, you don't have an encoding.</p>
<p>Your piece about .txt files shows you have misunderstood what is happening. You see, plain text files too don't have an encoding. They're just a series of bytes. These bytes get translated into letters by the text editor but there is no guarantee <em>at all</em> that someone else opening your file will see the same thing as you if you stray outside the common set of ASCII characters.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is a common misconception that text is ascii or utf8 or cp1252, and therefore bytes are text.  </p>
<p>Text is only text, in the way that images are only images.  The matter of storing text or images to disk is a matter of encoding that data into a sequence of bytes.  There are many ways to encode images into bytes: Jpeg, png, svg, and likewise many ways to encode text, ascii, utf8 or cp1252.</p>
<p>Once encoding has happened, bytes are just bytes.  Bytes are not images anymore, they have forgotten the colors they mean; although an image format decoder can recover that information.  Bytes have similarly forgotten the letters they used to be.  In fact, bytes don't remember wether they were images or text at all.  Only out of band knowledge (filename, media headers, etcetera) can guess what those bytes should mean, and even that can be wrong (in case of data corruption)</p>
<p>so, in python (py3), we have two types for things that might otherwise look similar;  For text, we have <code>str</code>, which knows it's text; it knows which letters it's supposed to mean.   It doesn't know which bytes that might be, since letters are not bytes.  We also have <code>bytestring</code>, which doesn't know if it's text or images or any other kind of data.</p>
<p>The two types are superficially similar, since they are both sequences of things, but the things that they are sequences of is quite different.</p>
<p>Implementationally, <code>str</code> is stored in memory as <code>UCS-?</code> where the ? is implementation defined, it may be UCS4, UCS2 or UCS1, depending on compile time options and which codepoints are present in the represented string.</p>
<hr/>
<p>edit "but why"?</p>
<p>Some things that look like text are actually defined in other terms.  A really good example of this are the many internet protocols of the world.  For instance, HTTP is a "text" protocol that is in fact defined using the ABNF syntax common in RFC's.  These protocols are expressed in terms of octets, not characters, although an informal encoding may also be suggested:</p>
<blockquote>
<p><a href="http://tools.ietf.org/html/rfc5234.html#section-2.3">2.3.  Terminal Values</a></p>
<p>Rules resolve into a string of terminal values, sometimes called<br/>
  characters.  In ABNF, a character is merely a non-negative integer.<br/>
  In certain contexts, a specific mapping (encoding) of values into a<br/>
  character set (such as ASCII) will be specified.</p>
</blockquote>
<p>This distinction is important, because it's not possible to send text over the internet, the only thing you can do is send bytes.  saying "text but in 'foo' encoding" makes the format that much more complex, since clients and servers need to now somehow figure out the encoding business on their own, hopefully in the same way, since they must ultimately pass data around as bytes anyway.  This is doubly useless since these protocols are seldom about text handling anyway, and is only a convenience for implementers.  Neither the server owners nor end users are ever interested in reading the words <code>Transfer-Encoding: chunked</code>, so long as both the server and the browser understand it correctly.</p>
<p>By comparison, when working with text, you don't really care how it's encoded.  You can express the "Heävy Mëtal Ümlaüts" any way you like, except "Heδvy Mλtal άmlaόts"</p>
<hr/>
<p>the distinct types thus give you a way to say "this value 'means' text" or "bytes".</p>
</div>
<div class="post-text" itemprop="text">
<p>As the name implies, a Python3 <code>bytestring</code> (or simply a <code>str</code> in
Python 2.7) is a string of <em>bytes</em>. And, as others have pointed out, it is immutable.</p>
<p>It is distinct from a Python3
<code>str</code> (or, more descriptively, a <code>unicode</code> in Python 2.7) which is a
string of <em>abstract</em> unicode characters (a.k.a. UTF-32, though Python3 adds fancy compression under the hood to reduce the actual memory footprint similar to UTF-8, perhaps even in a more general way).</p>
<p>There are essentially three ways of "interpreting" these bytes. You can look at the numeric value of an element, like this:</p>
<pre><code>&gt;&gt;&gt; ord(b'Hello'[0])  # Python 2.7 str
72
&gt;&gt;&gt; b'Hello'[0]  # Python 3 bytestring
72
</code></pre>
<p>Or you can tell Python to emit one or more elements to the terminal (or a file, device, socket, etc.) <em>as 8-bit characters</em>, like this:</p>
<pre><code>&gt;&gt;&gt; print b'Hello'[0] # Python 2.7 str
H
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.stdout.buffer.write(b'Hello'[0:1]) and None; print() # Python 3 bytestring
H
</code></pre>
<p>As Jack hinted, in this latter case it is <em>your terminal</em> interpreting
the character, not Python.</p>
<p>Finally, as you have seen in your own research, you can also get <em>Python</em> to interpret a <code>bytestring</code>. For example, you can construct an abstract <code>unicode</code> object like this in Python 2.7:</p>
<pre><code>&gt;&gt;&gt; u1234 = unicode(b'\xe1\x88\xb4', 'utf-8')
&gt;&gt;&gt; u1234
u'\u1234'
&gt;&gt;&gt; type(u1234)
&lt;type 'unicode'&gt;
&gt;&gt;&gt; len(u1234)
1
&gt;&gt;&gt; 
</code></pre>
<p>Or like this in Python 3:</p>
<pre><code>&gt;&gt;&gt; u1234 = str(b'\xe1\x88\xb4', 'utf-8')
&gt;&gt;&gt; '\\u%04x' % ord(u1234)
\u1234
&gt;&gt;&gt; type(u1234)
&lt;class 'str'&gt;
&gt;&gt;&gt; len(u1234)
1
</code></pre>
<p>But unicode abstraction does not happen automatically if you don't want it to. The point of a <code>bytestring</code> is that you can directly get at the bytes. Even in the above Python2.7 example:</p>
<pre><code>&gt;&gt;&gt; len(b'\xe1\x88\xb4')
3
&gt;&gt;&gt; b'\xe1\x88\xb4'[0]
'\xe1'
</code></pre>
<p>You can also do other wonderful things with <code>bytestring</code>s, like knowing if they will fit in a reserved space within a file, sending them directly over a socket, calculating the HTTP <code>content-length</code> field correctly, and avoiding <a href="https://bugs.python.org/issue8260" rel="nofollow noreferrer">Python Bug 8260</a>. In short, use <code>bytestring</code>s when your data is processed and stored in bytes.</p>
</div>
<div class="post-text" itemprop="text">
<p>Bytes objects are immutable sequences of single bytes. The <a href="https://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow">docs</a> have a very good explanation of what they are and how to use them.</p>
</div>
<span class="comment-copy">When you say "decode to <code>utf-8</code>" what you really mean is to use the <code>decode("utf-8")</code> method which actually tells Python to interpret your UTF-8 bytes and return a <code>unicode</code>. Besides that example (and various wrappers on it like <a href="https://bugs.python.org/issue8260" rel="nofollow noreferrer">codecs</a>) <i>Python</i> will not interpret your bytes; you can send the characters to the terminal/file/socket/device etc. to have that consumer (not Python) do the interpretation.</span>
<span class="comment-copy">Thanks, this and Russell's answer cleared up the confusion for me.</span>
<span class="comment-copy">TLDR - The basic issue that was cleared up to me was that both text editors, the python interpreter (using <code>__repr__</code>), etc, interpret a bytestring in <code>ASCII</code> (assuming no encoding specified) to potentially represent something meaningful to the user.</span>
<span class="comment-copy">Actually, text editors can be pretty liberal in how they interpret text. Some assume UTF-8 by default (which is a super-set of 7-bit ASCII); many use heuristics to guess.</span>
<span class="comment-copy">It <b>is</b> representing text, since if I type <code>b'Hello World'</code> into the interpreter, it returns <code>b'Hello World'</code>. How does it know that it's a character? From what I read in the docs, it represents ASCII characters 0-127, and everything else has an escape sequence. Why not just call it an ascii string? is it because .encode('ascii') is extended ascii (0-255)? is it so that you can represent many escape sequences?</span>
<span class="comment-copy">only a human may recognize <code>b'Hello World'</code> as text.  On the other hand, <code>b'GIF89a\x01\x00\x01\x00\x80\x01\x00\xff\xff\xff\x00\x00\x00!\xf9\x04\x01\n\x00\x01\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02L\x01\x00;'</code> is not text at all.  Neither can be decoded with the <code>utf16le</code> encoding expected by certain win32 api's.</span>
<span class="comment-copy">Ok, but if you do <code>echo "hello" | od -bc</code> in the terminal, it will show you the integer representation for each index in the array representing the string "hello". In this case <code>150 145 154 154 157 012</code>. So why is <code>b'hello'</code> returning <code>b'hello'</code> instead of something like <code>150 145 154 154 157 012</code>? It seems like it's interpreting anything from 0-255* as ASCII. Am I wrong?</span>
<span class="comment-copy">let me repeat this,  a <code>bytestring</code> <i>represents</i> an immutable sequence of bytes, without implying any particular interpretation, as text or otherwise,  whereas <code>str</code> <i>represents</i> an immutable sequence of unicode codepoints, without implying any particular binary encoding.  the fact that the python literals for each looks similar is only a convenience.</span>
<span class="comment-copy">The interpreter calls the magic <code>__repr__()</code> function to give you a readable representation of the bytestring. <code>__repr__()</code> is defined as returning a string, so it gives a possibly-meaningful-to-humans string by treating the bytestring as ASCII or UTF-8. That doesn't mean the underlying bytestring necessarily represents ASCII or looks like a string. The map is not the territory.</span>
<span class="comment-copy">Ok, so it says "Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence.". So what's the point of having them rather than using ASCII? is it for compatibility purposes where something can't read extended ascii (0-255)?</span>
<span class="comment-copy">@gyeh What exactly is extended ASCII? Especially, what does the character 252 mean in your so-called "extended ASCII"? Is it <code>ü</code>, as in <code>latin1</code>? Or is it <code>³</code> as in <code>cp850</code>? Or <code>ⁿ</code> (<code>cp437</code>)? There are many options. So the mapping from bytes to characters depends on the encoding. And that's why both strings and bytestrings exist: strings hold characters, whose "byte representation" depends on the encoding used, and bytestrings hold bytes, whose "character meaning" depends on the encoding.</span>
<span class="comment-copy">I understand that extended ascii requires an encoding. I think my point is being missed here. If I do <code>echo "hello" | od -bc</code>, it will show the integer value for each index of the array representing hello as a string. In this case: <code>150 145 154 154 157 012</code>. So why is <code>b'hello'</code> human readable instead of those stream of numbers? It seems like it's doing ASCII representation to me.</span>
