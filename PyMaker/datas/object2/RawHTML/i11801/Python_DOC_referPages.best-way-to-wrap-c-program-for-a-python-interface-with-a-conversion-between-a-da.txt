<div class="post-text" itemprop="text">
<p>We have a pre-exisitng large imaging library written in C/C++, with a pre-exising image type. We would like to interface it with Python. We know how to do most things using SWIG for instance, but we would like our interface to use NumPy instead of a home-grown structure type to store our images.</p>
<p>Does anyone have an example how to do this? There are examples on the web that interface NumPy to bare pointers. How do we interface NumPy to an existing C type struct like this one:</p>
<pre><code>typedef struct xvimage {

    int nx, ny, nz, nt ; // dimensions

    enum {PIX_UINT8, PIX_INT16, PIX_UINT16, PIX_INT32, PIX_FLOAT, PIX_DOUBLE} ; // type

    void *data;

} xvimage;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are basically three ways:</p>
<ol>
<li><p>Copy from your image buffer to a NumPy array and vice versa. When given a C/C++ image, create a NumPy array and copy the data, when given a NumPy array, create a C/C++ image and copy the data.</p></li>
<li><p>NumPy array as wrapper around C data pointer. Create a NumPy array but with a given data pointer. Make sure your C/C++ image holding the data pointer lives longer than the NumPy array. The NumPy array can live shorter because in this case it will not attempt to delete the data.</p></li>
<li><p>C/C++ image buffer as wrapper around a NumPy array pointer. Create a NumPy array and extract the data pointer, then use it to manupilate the NumPy array in-place. Make sure the NumPy array lives long enough by holding a Python reference.</p></li>
</ol>
<p>Each of these can be implemented in a SWIG typemap.</p>
<p>In any case you need a type conversion of your types to NumPy types (NPY_UINT8, ..) and storing of image dimensions in a <code>npy_intp *</code>.</p>
<p>To create a NumPy array use <code>PyArray_New</code> or <code>PyArray_SimpleNew</code> or <code>PyArray_SimpleNewFromData</code> (<a href="http://docs.scipy.org/doc/numpy/reference/c-api.array.html#creating-arrays" rel="nofollow">Array API</a>) and specify your desired flags like Fortran-style contiguous or whatever is convenient for you. You can provide your own data pointer with <code>PyArray_New</code> and <code>PyArray_SimpleNewFromData</code>.</p>
<p>The return value is a <code>PyObject*</code> which can safely be cast to <code>PyArrayObject*</code> (or perform a <code>PyArray_Check</code> before) and the data pointer is extracted by <code>PyArray_DATA</code> (<a href="http://docs.scipy.org/doc/numpy/reference/c-api.array.html#array-structure-and-data-access" rel="nofollow">Array API</a>) which returns a <code>void *</code> which you can then cast to your desired type. Then you can either perform the copy or do the in-place modification as desired.</p>
<p>To add a reference to a Python object use <code>Py_INCREF</code> and <code>Py_DECREF</code> (<a href="https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF" rel="nofollow">doc</a>) in case you want to avoid for the NumPy array to prematurely being deleted.</p>
<p>If you want to be notified when the Python object is about to be garbage collected use a weak reference via <code>PyWeakref_NewRef</code> (<a href="https://docs.python.org/3/c-api/weakref.html" rel="nofollow">doc</a>).</p>
</div>
<span class="comment-copy">Welcome to StackOverflow! I would recommend that you'd narrow your question down a bit on what you want to be answered.</span>
