<div class="post-text" itemprop="text">
<p>tldr; see the final line; the rest is just preamble.  </p>
<hr/>
<p>I am developing a test harness, which parses user scripts and generates a Python script which it then runs. The idea is for non-techie folks to be able to write high-level test scripts.</p>
<p>I have introduced the idea of variables, so a user can use the <code>LET</code> keyword in his script. E.g. <code>LET X = 42</code>, which I simply expand to <code>X = 42</code>. They can then use X later in their scripts - <code>RELEASE CONNECTION X</code></p>
<p>But what if someone writes <code>LET 2 = 3</code>? That's going to generate invalid Python. </p>
<p>If I have that <code>X</code> in a variable <code>variableName</code>, then how can I check whether <code>variableName</code> is a valid Python variable?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3 you can use <a href="https://docs.python.org/3/library/stdtypes.html?highlight=identifier#str.isidentifier" rel="noreferrer"><code>str.isidentifier()</code></a> to test whether a given string is a valid Python identifier/name.</p>
<pre><code>&gt;&gt;&gt; 'X'.isidentifier()
True
&gt;&gt;&gt; 'X123'.isidentifier()
True
&gt;&gt;&gt; '2'.isidentifier()
False
&gt;&gt;&gt; 'while'.isidentifier()
True
</code></pre>
<p>The last example shows that you should also check whether the variable name clashes with a Python keyword:</p>
<pre><code>&gt;&gt;&gt; from keyword import iskeyword
&gt;&gt;&gt; iskeyword('X')
False
&gt;&gt;&gt; iskeyword('while')
True
</code></pre>
<p>So you could put that together in a function:</p>
<pre><code>from keyword import iskeyword

def is_valid_variable_name(name):
    return name.isidentifier() and not iskeyword(name)
</code></pre>
<hr/>
<p>Another option, which works in Python 2 and 3, is to use the <code>ast</code> module:</p>
<pre><code>from ast import parse

def is_valid_variable_name(name):
    try:
        parse('{} = None'.format(name))
        return True
    except SyntaxError, ValueError, TypeError:
        return False

&gt;&gt;&gt; is_valid_variable_name('X')
True
&gt;&gt;&gt; is_valid_variable_name('123')
False
&gt;&gt;&gt; is_valid_variable_name('for')
False
&gt;&gt;&gt; is_valid_variable_name('')
False
&gt;&gt;&gt; is_valid_variable_name(42)
False
</code></pre>
<p>This will parse the assignment statement without actually executing it. It will pick up invalid identifiers as well as attempts to assign to a keyword. In the above code <code>None</code> is an arbitrary value to assign to the given name - it could be any valid expression for the RHS.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use exceptions handling and catch actually <code>NameError</code> and <code>SyntaxError</code>. Test it inside <code>try/except</code> block and inform user if there is some invalid input.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try a test assignment and see if it raises a <code>SyntaxError</code>:</p>
<pre><code>&gt;&gt;&gt; 2fg = 5
  File "&lt;stdin&gt;", line 1
    2fg = 5
      ^
SyntaxError: invalid syntax
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, as above, you can simply use <a href="https://docs.python.org/3/library/stdtypes.html#str.isidentifier" rel="nofollow noreferrer"><code>str.isidentifier</code></a>. But in Python 2, this does not exist.</p>
<p>The <a href="https://docs.python.org/2.7/library/tokenize.html#str.isidentifier" rel="nofollow noreferrer"><code>tokenize</code></a> module has a regex for names (identifiers): <a href="https://github.com/python/cpython/blob/2.7/Lib/tokenize.py#L52" rel="nofollow noreferrer"><code>tokenize.Name</code></a>. But I couldn't find any documentation for it, so it may not be available everywhere. It is simply <code>r'[a-zA-Z_]\w*'</code>. A single <code>$</code> after it will let you test strings with <code>re.match</code>.</p>
<p>The <a href="https://docs.python.org/2/reference/lexical_analysis.html#identifiers" rel="nofollow noreferrer">docs</a> say that an identifier is defined by this grammar:</p>
<pre><code>identifier ::=  (letter|"_") (letter | digit | "_")*
letter     ::=  lowercase | uppercase
lowercase  ::=  "a"..."z"
uppercase  ::=  "A"..."Z"
digit      ::=  "0"..."9"
</code></pre>
<p>Which is equivalent to the regex above. But we should still import <code>tokenize.Name</code> in case this ever changes. (Which is very unlikely, but maybe in older versions of Python it was different?)</p>
<p>And to filter out keywords, like <code>pass</code>, <code>def</code> and <code>return</code>, use <code>keyword.iskeyword</code>. There is one caveat: <code>None</code> is not a keyword in Python 2, but still can't be assigned to. (<code>keyword.iskeyword('None')</code> in Python 2 is <code>False</code>).</p>
<p>So:</p>
<pre><code>import keyword

if hasattr(str, 'isidentifier'):
    _isidentifier = str.isidentifier
else:
    import re
    _fallback_pattern = '[a-zA-Z_][a-zA-Z0-9_]*'
    try:
        import tokenize
    except ImportError:
        _isidentifier = re.compile(_fallback_pattern + '$').match
    else:
        _isidentifier = re.compile(
            getattr(tokenize, 'Name', _fallback_pattern) + '$'
        ).match

    del _fallback_pattern


def isname(s):
    return bool(_isidentifier(s)) and not keyword.iskeyword(s) and s != 'None'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just let Python (works on any version in use today, as far as I know) do the check for you they way it normally would internally, and catch the exception:</p>
<pre><code>def _dummy_function_taking_kwargs(**_):
    pass

try:
    _dummy_function_taking_kwargs(**{my_variable: None})
    # if the above line didn't raise and we get here,
    # the keyword/variable name was valid.
    # You could also replace the external dummy function
    # with an inline lambda function.
except TypeError:
    # If we get here, it wasn't.
</code></pre>
<p>Notably, <code>TypeError</code> is consistently raised whenever a <code>dict</code> undergoes keyword argument expansion and has a key which isn't a valid function argument, <strong>and</strong> whenever a <code>dict</code> literal is being constructed with an invalid key.</p>
<p>The advantage over the accepted answer is that it is <strong>both</strong> compatible across both Python 3 and 2, <strong>and</strong> not as fragile as the <code>ast.parse</code>/<code>compile</code> approach (which would count strings like <code>foo = bar; qux</code> as valid).</p>
<p>I haven't thoroughly audited this solution or written Hypothesis tests for it to fuzz it, so there might be some corner case, but it seems to generally work on Python 3.7, 3.6, 2.7, and 2.5 (not that anyone <em>ought</em> to be using 2.5 nowadays, but it's still out in the wild and you might be one of the few poor sods stuck having to write code that works with 2.6/2.5).</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think you need the exact same naming syntax as python itself.
Would rather go for a simple regexp like:</p>
<pre><code>\w+
</code></pre>
<p>to make sure it's something alphanumeric, and then add a prefix to keep away from python's own syntax. So the non-techie user's declaration:</p>
<pre><code>LET return = 12
</code></pre>
<p>should probably become after your parsing:</p>
<pre><code>userspace_return = 12
or
userspace['return'] = 12
</code></pre>
</div>
<span class="comment-copy">On the side: Why do you think "LET X = 42" is easier for "non-techie folks" than "X = 42"?</span>
<span class="comment-copy">One option is to use a regex. See <a href="http://stackoverflow.com/q/5474008/4014959">Regular expression to confirm whether a string is a valid identifier in Python</a></span>
<span class="comment-copy">@PM2Ring - Note that that's for Python 2. It's less simple for <a href="https://docs.python.org/3.5/reference/lexical_analysis.html#identifiers" rel="nofollow noreferrer">Python 3</a> (also see <a href="https://www.python.org/dev/peps/pep-3131/" rel="nofollow noreferrer">here</a> and <a href="http://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">@timgeb the answer to that is quite Basic :-)</span>
<span class="comment-copy"><code>compile('{} = None'.format(name), "&lt;string&gt;", "exec")</code>  and <code>return True</code>  after should be enough</span>
<span class="comment-copy">@PadraicCunningham: Thanks.  Either works and <code>ast.parse()</code>  calls <code>compile()</code> anyway. I think that it's a little cleaner with <code>ast.parse()</code> because there are fewer arguments, although it does require an import.</span>
<span class="comment-copy">For what it's worth, <code>is_valid_variable_name('a = b')</code>, <code>is_valid_variable_name('[]')</code>, <code>is_valid_variable_name('*a')</code> will all return <code>True</code>.</span>
<span class="comment-copy">@vaultah: it's worth a great deal and thanks for finding the flaw in my solution. Worth also noting that this problem only affects the <code>ast.parse()</code> solution. AFAIK the first solution still works as expected.</span>
<span class="comment-copy">@mhawke: yes, the first solution should work fine. Sorry, I should have mentioned that</span>
<span class="comment-copy">The this is that I want to validate when I am generating the code. Now when it is run, which could be much later.</span>
<span class="comment-copy">Aha, I could test it before generating the code! Well done! Thanks.</span>
<span class="comment-copy">A <code>SyntaxError</code> will prevent the script from running. The only way (AFAIK) to actually catch a <code>SyntaxError</code> is if you <code>import</code> a Python file that contains a syntax error.</span>
<span class="comment-copy">@timgeb: Ah, of course. I wasn't thinking about <code>eval</code> or <code>exec</code>, since I tend to avoid using them, especially on arbitrary input from "non-techie folks". :)</span>
