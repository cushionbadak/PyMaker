<div class="post-text" itemprop="text">
<p>I'm performing a simulation of protein-protein interactions. I'm using <strong>Python</strong> to code logic gates as functions to model protein interactions. 
My model is basically a series of groups (<code>g0</code> to <code>g4</code>) containing logic gates (see image). Initially, I set up a <code>list</code> containing my groups, and then for each group a <code>dict</code> that contains proteins (nodes) with their starting values (their so-called <code>seedValues</code>, which are the starting parameters for the network at <code>t=0</code>).</p>
<p>My question is this: is there some way of iterating through my groups (and their logic gate functions), that begins at group 0 (<code>g0</code> in the image) at <code>t</code>, and that at <code>t=t+1</code> executes groups <code>g0</code> and <code>g1</code>, then executes the three groups <code>g0</code>, <code>g1</code> and <code>g2</code> at <code>t=t+2</code>, and so on until <code>t=m</code>, where <code>m</code> is the number of iterations wanted?</p>
<blockquote>
<p><strong>Clarification</strong>: Perhaps I am unclear. My problem is this: say that I write a function that steps through my groups, one at a time. It
  starts at <code>g0</code> at time <code>t=0</code>, and executes, stores and outputs all the
  gates in that group, plus all the gates "ahead" of itself (<code>g1</code> to
  <code>g4</code>). When this is done, the function ticks time one step forward
  (<code>t=t+1</code>) and goes to <code>g1</code> and exeuctes again, including outputting
  groups <code>g2</code> to <code>g4</code>. Now is where an error creeps in: for an accurate
  model, I need to execute <code>g0</code> at time <code>t=t+1</code> too, <em>before</em> the
  program steps to <code>g2</code>. How can I make my program output  such
  sequential "waves" of execution? I imagine I might need to use
  recursion, but I don't know how.</p>
</blockquote>
<p>See example image of what I mean with "groups" <a href="https://i.stack.imgur.com/VdfmA.jpg" rel="nofollow noreferrer">here</a>.
<em>Image notes: <strong>A</strong> and <strong>B</strong> are switches (the program is supposed to change them, as a way of studying perturbations), <strong>C</strong> is a constant (never changed). <strong>J</strong> is the output (mostly for show). <strong>D</strong> and <strong>F</strong> are built that way to oscillate, whenever <strong>A</strong> = 0.</em></p>
<p>I have searched for this on Stack Exchange and Stack Overflow; while I see many questions that tangent my area of interest (<a href="https://stackoverflow.com/questions/19624134/how-to-detect-oscillations-in-gate-logic-simulations">1</a>, <a href="https://stackoverflow.com/questions/16376607/boolean-logic-gate-delays">2</a>), I don't see any that I determine specifically solve my problems. Thank you for your time.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems to me your problem reduces to a couple of nested loops.  If you put all the groups into a list named <code>gx</code>, and you increment time <code>t</code> in steps from 0 to some value <code>tmax</code>, it looks like this in Python...</p>
<pre><code>for t in range(tmax):
    for i in range(t):
        nodeExecute(gx[i])
</code></pre>
<p>Each time you increment <code>t</code>, one more group gets executed in addition to all the previous ones.  Apologies if I still haven't understood.</p>
</div>
<div class="post-text" itemprop="text">
<p>For event-driven digital simulation or <a href="https://en.wikipedia.org/wiki/Discrete_event_simulation" rel="nofollow noreferrer">discrete event simulation</a>, a "time wheel" or "timing wheel" is often used as basic data structure. The wheel is basically an array where every element points to a list or dynamic vector of simulated events which share the same value for "time mod wheelsize". </p>
<p>Timewheel as depicted <a href="http://www.dejazzer.com/ece470/project/TimingWheel.pdf" rel="nofollow noreferrer">here</a>:
<a href="https://i.stack.imgur.com/2WkYv.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/2WkYv.png"/></a></p>
<p>A timewheel is more efficient than a <a href="https://docs.python.org/3/library/queue.html?highlight=priorityqueue#queue.PriorityQueue" rel="nofollow noreferrer">priority queue</a>, which could also be used to process the simulation events in ascending order of their timestamps.</p>
<p><strong>Pseudo-code of event-driven logic simulation:</strong></p>
<pre><code>t = tStart
While (t &lt; tEnd) {
    process all events scheduled for t and schedule follow-up events
    schedule events from signal sources
    t = t + 1
}
</code></pre>
<p>To handle the grouping of gates, you could treat each group as a super-gate with multiple outputs. It might be necessary to model different latency delays within a given group of gates.</p>
<p>Rather than writing your own simulator, you could describe your circuit in a <a href="https://en.wikipedia.org/wiki/Hardware_description_language" rel="nofollow noreferrer">Hardware Description Language</a> like <a href="https://en.wikipedia.org/wiki/Verilog" rel="nofollow noreferrer">Verilog</a> and use a <a href="https://en.wikipedia.org/wiki/List_of_HDL_simulators" rel="nofollow noreferrer">ready-made simulator</a>.</p>
</div>
<span class="comment-copy">Probably I'm missing something here.  The only good reason to create a multithread/multiprocess program Is performance.  If you haven't written the program yet, how do you know it's not fast enough? Just because the circuit components function in parallel doesn't mean the internal structure of your program must do the calculations in parallel.  What matters is that the program produces an accurate model of what the circuit (protein) does.  Why complicate your task by writing a multithreaded program?</span>
<span class="comment-copy">I have updated my question to better reflect what I am looking to do. Please see my clarification in the original question.</span>
<span class="comment-copy">This will do perfectly, thank you very much. I had a very myopic view of my problem versus it's solution.</span>
<span class="comment-copy">This seems like a great approach to my question. Just like your excellent answer suggests, I've chosen to model my gates in a series of groups, where one group is executed per time step. I describe it graphically !<a href="http://i.imgur.com/4dCtTqm.jpg" rel="nofollow noreferrer">like this</a>, which corresponds pretty well with the event-driven data structures you suggested. Thank you for your input!</span>
