<div class="post-text" itemprop="text">
<p>I am having the following pattern in text file</p>
<pre><code>Question1: Quesion XYZ
a. option1
b. option2
c. option3
d. option4

Question2 : Question next
a. option1
b. option2
c. option3
d. option4

so on multiple questions
</code></pre>
<p>This pattern is there in the text file. I am trying to read the text file and segregate each question and respective choices. I want the output as </p>
<pre><code>Block1 :

  Question1: Quesion XYZ
    a. option1
    b. option2
    c. option3
    d. option4

Block 2 :     
    Question2 : Question next
    a. option1
    b. option2
    c. option3
    d. option4
</code></pre>
<p>Motive is to retrieve each question and respective options. I was trying for a <code>list</code> which I will append each question and respective options. I will create multiple lists where I will store each question</p>
<p>I have done coding like</p>
<pre><code>import re
txt = open("questions.txt")
i = 0 ; 
for line in txt:
    key = 'list' + str(i)
    key = []
    # if line == "\n" : continue
    if re.search("^\n", line): continue
    searchObj = re.search("([\d]+)\.\s*(.*)", line)
    if searchObj : 
        i = searchObj.group(1)
        key = searchObj.group(2)
    searchObj2 = re.search("[\w]+\.\s*(.*)", line)
    if searchObj2 : 
        key.append = (searchObj2.group(1))

txt.close()
print alist1
</code></pre>
<p>It is giving error. Moreover it is not solving the above purpose. I heard that we can also use dict for that. Need to know how as there can be <code>n</code> number of questions in the file. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a generic method to solve this case, I said generic because it needs to be modified within the content of your text file and how it is formatted, which means tweaking the <code>re</code> expressions, anyways, what I would do, is a create a list of dictionaries, with each dictionary holding data of each question, as follows:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt;
&gt;&gt;&gt; patQNbBody = re.compile('(?P&lt;QNb&gt;Question\\d+)\\s*:\\s*(?P&lt;QBody&gt;[\\w\\s]+)$', re.IGNORECASE|re.MULTILINE|re.DOTALL)
&gt;&gt;&gt;
&gt;&gt;&gt; patQopt = re.compile('^[a-z]\\.\\s*(?P&lt;Opt&gt;\\w+)$', re.IGNORECASE|re.MULTILINE|re.DOTALL)
&gt;&gt;&gt;
&gt;&gt;&gt; my_questions = []
&gt;&gt;&gt; 
&gt;&gt;&gt; with open('questions.txt', 'r') as f:
        i = -1
        for line in f:
            m1 = patQNbBody.search(line)
            if m1:
                i += 1
                p = m1.group(1)
                my_questions.append({'Number':m1.group(1), 'Body':m1.group(2), 'options':[]})
            else:
                m2 = patQopt.search(line)
                if m2:
                    my_questions[i]['options'].append(m2.group(1))

&gt;&gt;&gt; my_questions
[{'options': ['option1', 'option2', 'option3', 'option4'], 'Number': 'Question1', 'Body': 'Quesion XYZ\n'}, {'options': ['option1', 'option2', 'option3', 'option4'], 'Number': 'Question2', 'Body': 'Question next\n'}]
</code></pre>
<p>If order matters to you, then you can get the advantage of <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>OrderedDict</code></a> to your best:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt;
&gt;&gt;&gt; patQNbBody = re.compile('(?P&lt;QNb&gt;Question\\d+)\\s*:\\s*(?P&lt;QBody&gt;[\\w\\s]+)$', re.IGNORECASE|re.MULTILINE|re.DOTALL)
&gt;&gt;&gt;
&gt;&gt;&gt; patQopt = re.compile('^[a-z]\\.\\s*(?P&lt;Opt&gt;\\w+)$', re.IGNORECASE|re.MULTILINE|re.DOTALL)
&gt;&gt;&gt;
&gt;&gt;&gt; my_questions = []
&gt;&gt;&gt; with open('test1.txt', 'r') as f:
        i = -1
        for line in f:
            d = OrderedDict()
            m1 = patQNbBody.search(line)
            if m1:
                i += 1
                for k,v in zip(('Number','Body','Options'),(m1.group(1), m1.group(2), [])):
                    d[k] = v
                my_questions.append(d)
            else:
                m2 = patQopt.search(line)
                if m2:
                    my_questions[i]['Options'].append(m2.group(1))

&gt;&gt;&gt; my_questions
[OrderedDict([('Number', 'Question1'), ('Body', 'Quesion XYZ\n'), ('Options', ['option1', 'option2', 'option3', 'option4'])]), OrderedDict([('Number', 'Question2'), ('Body', 'Question next\n'), ('Options', ['option1', 'option2', 'option3', 'option4'])])]
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; my_questions[0]['Number']
'Question1'
&gt;&gt;&gt; my_questions[1]['Body']
'Question next\n'
&gt;&gt;&gt; 
&gt;&gt;&gt; my_questions[1]['Options']
['option1', 'option2', 'option3', 'option4']
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">I would not use a regular expression. Just extract it 'manually'. That way it is easier to debug and figure out what is happening.</span>
