<div class="post-text" itemprop="text">
<p>As far as I understand, prepared statements are (mainly) a database feature that allows you to separate parameters from the code that uses such parameters. Example:</p>
<pre><code>PREPARE fooplan (int, text, bool, numeric) AS
    INSERT INTO foo VALUES($1, $2, $3, $4);
EXECUTE fooplan(1, 'Hunter Valley', 't', 200.00);
</code></pre>
<p>A parameterized query substitutes the manual string interpolation, so instead of doing</p>
<pre><code>cursor.execute("SELECT FROM tablename WHERE fieldname = %s" % value)
</code></pre>
<p>we can do</p>
<pre><code>cursor.execute("SELECT FROM tablename WHERE fieldname = %s", [value])
</code></pre>
<p>Now, it seems that prepared statements are, for the most part, used in the database language and parameterized queries are mainly used in the programming language connecting to the database, although I have seen exceptions to this rule.</p>
<p>The problem is that asking about the difference between prepared statement and parameterized query brings a lot of confusion. Their purpose is admittedly the same, but their methodology seems distinct. Yet, there are <a href="http://www.programmerinterview.com/index.php/database-sql/parameterized-queries-vs-prepared-statements/" rel="noreferrer">sources</a> indicating that both are the same. MySQLdb and Psycopg2 seem to support parameterized queries but donâ€™t support prepared statements (e.g. <a href="https://stackoverflow.com/a/17237567/460147">here</a> for MySQLdb and in the <a href="https://wiki.postgresql.org/wiki/Python_PostgreSQL_Driver_TODO" rel="noreferrer">TODO list for postgres drivers</a> or <a href="https://groups.google.com/d/msg/sqlalchemy/LN0evK1hyOM/78nvIwtT7GgJ" rel="noreferrer">this answer</a> in the sqlalchemy group). Actually, there is a <a href="https://gist.github.com/dvarrazzo/3797445" rel="noreferrer">gist</a> implementing a psycopg2 cursor supporting prepared statements and a minimal <a href="https://stackoverflow.com/questions/9866350/prepared-statements-using-psycopg">explanation</a> about it. There is also a <a href="http://initd.org/psycopg/articles/2012/10/01/prepared-statements-psycopg/" rel="noreferrer">suggestion</a> of subclassing the cursor object in psycopg2 to provide the prepared statement manually.</p>
<p>I would like to get an authoritative answer to the following questions:</p>
<ul>
<li><p>Is there a meaningful difference between prepared statement and parameterized query? Does this matter in practice? If you use parameterized queries, do you need to worry about prepared statements?</p></li>
<li><p>If there is a difference, what is the current status of prepared statements in the Python ecosystem? Which database adapters support prepared statements?</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<ul>
<li><p>Prepared statement: A reference to a pre-interpreted query routine on the database, ready to accept parameters</p></li>
<li><p>Parametrized query: A query made by your code in such a way that you are passing values in <em>alongside</em> some SQL that has placeholder values, usually <code>?</code> or <code>%s</code> or something of that flavor.</p></li>
</ul>
<p>The confusion here seems to stem from the (apparent) lack of distinction between the ability to directly get a prepared statement object and the ability to pass values into a 'parametrized query' method that acts very much like one... because it is one, or at least makes one for you.</p>
<p>For example: the C interface of the SQLite3 library has a lot of tools for working with <a href="https://www.sqlite.org/c3ref/stmt.html" rel="nofollow noreferrer">prepared statement objects</a>, but the <a href="https://docs.python.org/3/library/sqlite3.html" rel="nofollow noreferrer">Python api</a> makes almost no mention of them. You can't prepare a statement and use it multiple times whenever you want. Instead, you can use <code>sqlite3.executemany(sql, params)</code> which takes the SQL code, creates a prepared statement <em>internally</em>, then uses that statement in a loop to process each of your parameter tuples in the iterable you gave.</p>
<p>Many other SQL libraries in Python behave the same way. Working with prepared statement objects can be a real pain, and can lead to ambiguity, and in a language like Python which has such a lean towards clarity and ease over raw execution speed they aren't really the greatest option. Essentially, if you find yourself having to make hundreds of thousands or millions of calls to a complex SQL query that gets re-interpreted every time, you should probably be doing things differently. Regardless, sometimes people wish they could have direct access to these objects because if you keep the same prepared statement around the database server won't have to keep interpreting the same SQL code over and over; most of the time this will be approaching the problem from the wrong direction and you will get much greater savings elsewhere or by restructuring your code.*</p>
<p>Perhaps more importantly in general is the way that prepared statements and parametrized queries keep your data sanitary and separate from your SQL code. <strong>This is vastly preferable to string formatting!</strong> You should think of parametrized queries and prepared statements, in one form or another, as <strong>the only way to pass variable data from your application into the database</strong>. If you try to build the SQL statement otherwise, it will not only run significantly slower but you will be vulnerable to <a href="https://xkcd.com/327/" rel="nofollow noreferrer">other problems</a>.</p>
<p><em>*e.g., by producing the data that is to be fed into the DB in a generator function then using <code>executemany()</code> to insert it all at once from the generator, rather than calling <code>execute()</code> each time you loop.</em></p>
<h2>tl;dr</h2>
<p><strong>A parametrized query is a single operation which generates a prepared statement internally, then passes in your parameters and executes.</strong></p>
<p><em>edit:</em> A lot of people see this answer! I want to also clarify that many database engines also have concepts of a prepared statement that can be constructed explicitly with plaintext query syntax, then reused over the lifetime of a client's session (in <a href="https://www.postgresql.org/docs/current/sql-prepare.html" rel="nofollow noreferrer">postgres</a> for example). Sometimes you have control over whether the query plan is cached to save even more time. Some frameworks use these automatically (I've seen rails' ORM do it aggressively), sometimes usefully and sometimes to their detriment when there are permutations of form for the queries being prepared.</p>
<p>Also if you want to nit pick, parametrized queries do not <em>always</em> use a prepared statement under the hood; they should do so if possible, but sometimes it's just formatting in the parameter values. The real difference between 'prepared statement' and 'parametrized query' here is really just the shape of the API you use.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, your questions shows very good preparation - well done.</p>
<p>I am not sure, if I am the person to provide authoritative answer, but I will try to explain my
understanding of the situation.</p>
<p><strong>Prepared statement</strong> is an object, created on side of database server as a result of <code>PREPARE</code>
statement, turning provided SQL statement into sort of temporary procedure with parameters. Prepared
statement has lifetime of current database session and are discarded after the session is over.
SQL statement <code>DEALOCATE</code> allows destroying the prepared statement explicitly.</p>
<p>Database clients can use SQL statement <code>EXECUTE</code> to execute the prepared statement by calling it's
name and parameters.</p>
<p><strong>Parametrized statement</strong> is alias for prepared statement as usually, the prepared statement has
some parameters.</p>
<p><strong>Parametrized query</strong> seems to be less often used alias for the same (24 mil Google hits for
parametrized statement, 14 mil hits for parametrized query). It is possible, that some people use
this term for another purpose.</p>
<p>Advantages of prepared statements are:</p>
<ul>
<li>faster execution of actual prepared statement call (not counting the time for <code>PREPARE</code>)</li>
<li>resistency to SQL injection attack</li>
</ul>
<h2>Players in executing SQL query</h2>
<p>Real application will probably have following participants:</p>
<ul>
<li>application code</li>
<li>ORM package (e.g. sqlalchemy)</li>
<li>database driver</li>
<li>database server</li>
</ul>
<p>From application point of view it is not easy to know, if the code will really use prepared
statement on database server or not as <strong>any of participants may lack support of prepared
statements</strong>.</p>
<h2>Conclusions</h2>
<p><strong>In application code</strong> prevent direct shaping of SQL query as it is prone to SQL injection attack. For
this reason it is recommended using whatever the ORM provides to parametrized query even if it does
not result on using prepared statements on database server side as the ORM code can be optimized to
prevent this sort of attack.</p>
<p><strong>Decide, if prepared statement is worth for performance reasons</strong>. If you have simple SQL query,
which is executed only few times, it will not help, sometime it will even slow down the execution a
bit.</p>
<p>For complex query being executed many times and having relatively short execution time will be
the effect the biggest. In such a case, you may follow these steps:</p>
<ul>
<li>check, that the database you are going to use supports the <code>PREPARE</code> statement. In most cases it
will be present.</li>
<li>check, that the drive you use is supporting prepared statements and if not, try to find another
one supporting it.</li>
<li>Check support of this feature on ORM package level. Sometime it vary driver by driver (e.g.
sqlalchemy states some limitations on prepared statements with MySQL due to how MySQL manages
that). </li>
</ul>
<p>If you are in search for real authoritative answer, I would head to authors of sqlalchemy.</p>
</div>
<div class="post-text" itemprop="text">
<p>An sql statement can't be execute immediately: the DBMS must interpret them before the execution.</p>
<p>Prepared statements are statement already interpreted, the DBMS change parameters and the query starts immediately. This is a feature of certain DBMS and you can achieve fast response (comparable with stored procedures).</p>
<p>Parametrized statement are just a way you compose the query string in your programming languages. Since it doesn't matter how sql string are formed, you have slower response by DBMS.</p>
<p>If you measure time executing 3-4 time the same query (select with different conditions) you will see the same time with parametrized queries, the time is smaller from the second execution of prepared statement (the first time the DBMS has to interpret the script anyway).</p>
</div>
<span class="comment-copy">In Python, I think a "parameterized" query is a feature of cursor objects that is generally implemented using prepared statements.  Sometimes the two are used interchangeably when writing SQL code, depending on which aspect is being emphasized (putting parameters in statements or caching the query plan).</span>
<span class="comment-copy">Thanks. Maybe parameterized  implies prepared statement, but then why so many people arguing about prepared statements not being supported by their database adapters (e.g. <a href="http://stackoverflow.com/questions/1947750/does-python-support-mysql-prepared-statements#comment30763896_1947993">this comment</a> referencing <a href="https://pythonhosted.org/oursql/api.html?highlight=prepared#oursql.Connection.cursor" rel="nofollow noreferrer">this project</a>?</span>
<span class="comment-copy"><i>A parametrized query is a single operation which generates a prepared statement internally, then passes in your parameters and executes.</i>. Only if the database adapter actually implements it like this. The popular MySQL adapters still use string interpolation to create the final query with data to send to the database, for example. They do a good job of sanitising the data first..</span>
<span class="comment-copy">@Widdershins Thank you for your response.</span>
<span class="comment-copy">@MartijnPieters That's pretty much my main concern. Most adapters (including postgreSQL adapters) don't seem to include prepared statements support. If all they do is sanitizing but not prepared statements, I wonder how much risk of SQL injection remains.</span>
<span class="comment-copy">@RobertSmith: There isn't, not with the long-maintained modules. Sanitising isn't <i>that</i> hard, but it is still best left to the driver at the very least. There is no more or less risk than using prepared statements, because the database can't distinguish between an embedded literal in the statement and the programmer having interpolated un-sanitised input.</span>
<span class="comment-copy">@RobertSmith: There isn't, not with the long-maintained modules. Sanitising isn't <i>that</i> hard, but it is still best left to the driver at the very least. There is no more or less risk than using prepared statements, because the database can't distinguish between an embedded literal in the statement and the programmer having interpolated un-sanitised input.</span>
<span class="comment-copy">Thank you! I think you are making the right distinctions here. Prepared statements and parameterized statement/query are the same but applied differently throughout the application. As far as I understand, most database drivers in Python don't support prepared statements on the database (the exception being oursql) and my concerns are primarily focused on security (not so much performance.) I guess that there is some security risk involved in not supporting prepared statements on the database. I would be very interested in knowing to what extent this is true.</span>
<span class="comment-copy">hmmm, actually, the part about parametrized being slow is not totally true.  many databases will automatically cache an execution plan and will use re-use it on subsequent passes, if the only changing thing is the bind parameters.  another reason, besides sql injection concerns, to avoid rolling your own query by injecting variables directly into the query string.</span>
<span class="comment-copy">Thank you for your answer. I guess you're indirectly claiming that prepared statements and parameterized queries are not the same and that speed is a meaningful difference.</span>
