<div class="post-text" itemprop="text">
<p>In the course of implementing the "Variable Elimination" algorithm for a Bayes' Nets program, I encountered an unexpected bug that was the result of an iterative map transformation of a sequence of objects.</p>
<p>For simplicity's sake, I'll use an analogous piece of code here:</p>
<pre><code>&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; for x in [4, 5, 6]:
...     # Uses n if x is odd, uses (n + 10) if x is even
...     nums = map(
...         lambda n: n if x % 2 else n + 10, 
...         nums)
...
&gt;&gt;&gt; list(nums)
[31, 32, 33]
</code></pre>
<p>This is definitely the wrong result.  Since [4, 5, 6] contains two even numbers, <code>10</code> should be added to each element at most twice.  I was getting unexpected behaviour with this in the VE algorithm as well, so I modified it to convert the <code>map</code> iterator to a <code>list</code> after each iteration.</p>
<pre><code>&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; for x in [4, 5, 6]:
...     # Uses n if x is odd, uses (n + 10) if x is even
...     nums = map(
...         lambda n: n if x % 2 else n + 10,
...         nums)
...     nums = list(nums)
...
&gt;&gt;&gt; list(nums)
[21, 22, 23]
</code></pre>
<p>From my understanding of iterables, this modification <em>shouldn't</em> change anything, but it does.  Clearly, the <code>n + 10</code> transform for the <code>not x % 2</code> case is applied one fewer times in the <code>list</code>-ed version.</p>
<p>My Bayes Nets program worked as well after finding this bug, but I'm looking for an explanation as to why it occurred.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer is very simple: <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> is a <a href="https://stackoverflow.com/questions/20535342/lazy-evaluation-python">lazy</a> function in Python 3, it returns an iterable object (in Python 2 it returns a <code>list</code>). Let me add some output to your example:</p>
<pre><code>In [6]: nums = [1, 2, 3]

In [7]: for x in [4, 5, 6]:
   ...:     nums = map(lambda n: n if x % 2 else n + 10, nums)
   ...:     print(x)
   ...:     print(nums)
   ...:     
4
&lt;map object at 0x7ff5e5da6320&gt;
5
&lt;map object at 0x7ff5e5da63c8&gt;
6
&lt;map object at 0x7ff5e5da6400&gt;

In [8]: print(x)
6

In [9]: list(nums)
Out[9]: [31, 32, 33]
</code></pre>
<p>Note the <code>In[8]</code> - the value of <code>x</code> is 6. We could also transform the <code>lambda</code> function, passed to <code>map</code> in order to track the value of <code>x</code>:</p>
<pre><code>In [10]: nums = [1, 2, 3]

In [11]: for x in [4, 5, 6]:
   ....:     nums = map(lambda n: print(x) or (n if x % 2 else n + 10), nums)
   ....:     

In [12]: list(nums)
6
6
6
6
6
6
6
6
6
Out[12]: [31, 32, 33]
</code></pre>
<p>Because <code>map</code> is lazy, it evaluates when <code>list</code> is being called. However, the value of <code>x</code> is <code>6</code> and that is why it produces confusing output. Evaluating <code>nums</code> inside the loop produces <em>expected</em> output.</p>
<pre><code>In [13]: nums = [1, 2, 3]

In [14]: for x in [4, 5, 6]:
   ....:     nums = map(lambda n: print(x) or (n if x % 2 else n + 10), nums)
   ....:     nums = list(nums)
   ....:     
4
4
4
5
5
5
6
6
6

In [15]: nums
Out[15]: [21, 22, 23]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The issue has to do with how the <code>x</code> variable is accessed by the lambda functions you are creating. The way Python's scoping works, the lambda functions will always use the latest version of <code>x</code> from the outside scope when they're called, not the value that it had when they were defined.</p>
<p>Since <code>map</code> is lazy, the lambda functions don't get called until after the loop (when you consume the nested <code>map</code>s by passing them to <code>list</code>) and so, they all use the last <code>x</code> value.</p>
<p>To make each lambda function save the value <code>x</code> has when they are defined, add <code>x=x</code> like this:</p>
<pre><code>lambda n, x=x: n if x % 2 else n + 10
</code></pre>
<p>This specifies an argument and its default value. The default will be evaluated at the time the lambda is defined, so when the lambda gets called later (without a second argument), the <code>x</code> inside the expression will be that saved default value.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use the lazy version, you need to fix <code>x</code> in each loop.
<a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow">functools.partial</a> does exactly that:</p>
<pre><code>from functools import partial

def myfilter(n, x):
    return n if x % 2 else n + 10

nums = [1, 2, 3]
for x in [4, 5, 6]:
    f = partial(myfilter, x=x)
    nums = map(f, nums)

&gt;&gt;&gt; list(nums)
[21, 22, 23]
</code></pre>
</div>
<span class="comment-copy">Please don't write code like that.  It makes my brain hurt.</span>
<span class="comment-copy">Your code doesn't do what you explain it should do. If you want it to keep the numbers if they are odd and add ten if they are even, you must put <code>nums = map(lambda n: n if x % 2 != 0 else n + 10, nums)</code> .... there needs to be something to evaluate for the if function, otherwise it always evaluates as true. BTW. the problem with the code was not newlines, as your edits suggest. I think, what kevin complains about are the dots and arrows to the left.</span>
<span class="comment-copy">Could it be that in Python3 , <code>map</code> is an iterator?</span>
<span class="comment-copy">Oh, and since you iterate on the list [4,5,6], the function overwrites nums for each iteration. Which means that your output is only related to the last element (6) in your list.</span>
<span class="comment-copy">yeah, the lambdas are run at the line <code>list(nums)</code>, all 3 of them see <code>x</code> then bound to 6, and thus add 10. You can verify this by adding <code>del x</code> before <code>list(nums)</code>; you'd get a <code>NameError</code>.</span>
<span class="comment-copy">Ah!  It was the <code>x</code>!  Thank you.  I know iterators in general are "lazy", but I missed that part of the laziness.  Is there any way to set up a lambda expression to immediately evaluate a variable during each iteration of a loop?  (edit: never mind, got it!) This seems to be a danger of mixing functional and imperative programming!</span>
<span class="comment-copy">"it evaluates when the x value has been changed to 6". Rather, it evaluates when <code>list</code> is called on the map object, which happens when <code>x = 6</code>.</span>
<span class="comment-copy">@Evert, yes, I'm fixing that, thank you</span>
<span class="comment-copy">@cosmicFluke, you are always welcome!</span>
<span class="comment-copy">@cosmicFluke besides the <code>map</code>'s laziness, it's also a case of <a href="http://docs.python-guide.org/en/latest/writing/gotchas/#late-binding-closures" rel="nofollow noreferrer">late binding</a>, as pointed out in Blckknght's and Mike's answers.</span>
<span class="comment-copy">That's the answer to my follow-up question (on the first answer).  Thanks!</span>
<span class="comment-copy">How is it lazy if you call <code>list</code> on <code>map(f, nums)</code> in each iteration of the loop?</span>
<span class="comment-copy">There's also that default argument hack: <code>lambda n, x=x: ...</code>, since default arguments are evaluated during function (lambda) creation time.</span>
<span class="comment-copy">@Evert Thanks for the hint <code>list()</code> is not needed. Removed.</span>
