<div class="post-text" itemprop="text">
<p>While fixing one user's <a href="https://askubuntu.com/a/754931/295286">answer on AskUbuntu</a>  , I've discovered a small issue. The code itself is straightforward : os.walk , recursively get sum of all files in the directory.</p>
<p>But it breaks on symlinks :</p>
<pre><code>$ python test_code2.py $HOME                                                                                          
Traceback (most recent call last):
  File "test_code2.py", line 8, in &lt;module&gt;
    space += os.stat(os.path.join(subdir, f)).st_size
OSError: [Errno 2] No such file or directory: '/home/xieerqi/.kde/socket-eagle'
</code></pre>
<p>Question then is, how do I tell python to ignore those files and avoid summing them ?</p>
<p><strong>Solution</strong>:</p>
<p>As suggested in the comments , I've added <code>os.path.isfile()</code> check and now it works perfectly and gives correct size for my home directory</p>
<pre><code>$&gt; cat test_code2.py                                                          
#! /usr/bin/python
import os
import sys

space = 0L  # L means "long" - not necessary in Python 3
for subdir, dirs, files in os.walk(sys.argv[1]):
    for f in files:
        file_path = os.path.join(subdir, f)
        if os.path.isfile(file_path):
           space += os.stat(file_path).st_size

sys.stdout.write("Total: {:d}\n".format(space))
$&gt; python test_code2.py  $HOME                                                
Total: 76763501905
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As already mentioned by Antti Haapala in a comment, The script does not break on symlinks, but on <em>broken symlinks</em>. One way to avoid that, taking the existing script as a starting point, is using <code>try/except</code>:</p>
<pre class="lang-py prettyprint-override"><code>#! /usr/bin/python2
import os
import sys

space = 0L  # L means "long" - not necessary in Python 3
for root, dirs, files in os.walk(sys.argv[1]):
    for f in files:
        fpath = os.path.join(root, f)
        try:
            space += os.stat(fpath).st_size
        except OSError:
            print("could not read "+fpath)

sys.stdout.write("Total: {:d}\n".format(space))
</code></pre>
<p>As a side effect, it gives you information on possible broken links.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, <code>os.path.isfile</code> is the way to go. However the following version <em>may be</em> more memory efficient.</p>
<pre><code>for subdir, dirs, files in os.walk(sys.argv[1]):
    paths = (os.path.join(subdir, f) for f in files)
    space = sum(os.stat(path).st_size for path in paths if os.path.isfile(path))
</code></pre>
</div>
<span class="comment-copy">it does not break on symlinks. it breaks on <i>broken</i> symlinks. In any case you can test with <a href="https://docs.python.org/3/library/os.path.html#os.path.isfile" rel="nofollow noreferrer"><code>os.path.isfile</code></a> that the filename points to an actual file, before summing its size.</span>
<span class="comment-copy">AHA, sharp, that's why the code works in my test :)</span>
<span class="comment-copy">@AnttiHaapala so what should the solution be ? Delete the broken symlinks ? Is there a way to get around that in the code itself ?</span>
<span class="comment-copy">Just test if the file exists and skip if not.</span>
<span class="comment-copy">@AnttiHaapala post the answer :)</span>
<span class="comment-copy">Interesting, why exactly sum() is more memory efficient ?</span>
<span class="comment-copy">@Serg It's not <code>sum</code>, it is the use of iterators that result in space efficiency. You can see that <code>paths</code> is a genexp. So this declarative style ensures that you are dealing with <b>one</b> object at a time while essentially talking about <b>all</b> at the same time. There are no intermediate container data structures. But in this example I used "<i>may be</i>", as you can see, because there aren't intermediate lists anyway. But has a side effect, <code>space</code> is changing.</span>
