<div class="post-text" itemprop="text">
<p>I have a login method that I have written a unittest for it and it works great. But login method calls external classes to verify username and password. As I want to make the procedure faster and do the test in isolation I want to mock those classes.</p>
<pre><code>def test_login(self):
    with self.app.test_client() as client:
        response = client.post('/login',
                               data=json.dumps(dict({'username': 'username',
                                                     'password': 'password'})),
                               content_type='application/json',
                               headers={'x-header':'custom headers'})
        self.assertEqual(response.status_code, 200, response.data)
</code></pre>
<p>Inside of <code>login</code> there is a class that connects to DB. How should I mock the part conneting to DB? Lets say the DB class is called <code>externalService()</code>. Any thoughts?</p>
<hr/>
<p><strong>EDIT1:</strong></p>
<pre><code>with patch('__main__.externalService') as MockClass:
    instance = MockClass.return_value
    instance.method.return_value = 'success'
</code></pre>
<p>This gives the error of:</p>
<pre><code>AttributeError: &lt;module '__main__' from 'test_login.py'&gt; does not have the attribute 'externalService'
</code></pre>
<p>The error makes sense as it is not present in <code>test_login</code>, it is a working class in a different place in project that login function uses! How to mock it?</p>
</div>
<div class="post-text" itemprop="text">
<p>A basic approach to <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow">patching</a> with mock objects would be something like:</p>
<pre><code>from unittest import TestCase
from unittest.mock import patch


class TestSomething(TestCase):

    # Presuming you have a login_service instance singleton
    @patch('my.package.login_service')
    def test_login(self, login_service):
        # Clients verify credentials with a call to
        # login_service.verify(uname, passwd). During this test,
        # login never fails.
        login_service.verify.return_value = True
        # Call the DUT
        with self.app.test_client() as client:
            response = client.post('/login',
                                   data=json.dumps(dict({'username': 'username',
                                                         'password': 'password'})),
                                   content_type='application/json',
                                   headers={'x-header':'custom headers'})

        self.assertEqual(response.status_code, 200, response.data)
        login_service.verify.assert_called_once_with('username', 'password')
</code></pre>
<p>The actual solution depends on how your project is set up.</p>
<p>Note that depending on how you import your <code>externalService</code> patching may not replace the correct reference during testing:</p>
<pre><code>from urllib.request import urlopen
import urllib.request
from unittest.mock import patch

try:
    with patch('urllib.request.urlopen'):
        urlopen('this will fail')

except Exception as e:
    print('fail:', e)

with patch('urllib.request.urlopen') as mock_urlopen:
    urllib.request.urlopen('this will succeed')

mock_urlopen.assert_called_once_with('this will succeed')
print('great success')
</code></pre>
<p>outputs:
</p>
<pre><code> % python3 patchtest.py
fail: unknown url type: 'this will fail'
great success
</code></pre>
<p>So if you have imported <code>externalService</code> in to the namespace of your view module, you can try and patch it there instead:</p>
<pre><code>@patch('myproject.myview.externalService')
...
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a>?</span>
<span class="comment-copy">@Ilja should I use decorator on <code>test_login</code> function or the main login function?</span>
<span class="comment-copy">I've used it to decorate test functions, which then setup the passed mock object to suit the needs of the test.</span>
<span class="comment-copy">@Ilja please see the <code>EDIT1</code> part of the question.</span>
<span class="comment-copy">You have to provide the fully qualified name of externalService, like <code>my.project.externalService</code></span>
<span class="comment-copy">It works and test ran but test login calls the external method. <code>with patch('myProject.externalService') as MockClass:                 instance = MockClass.return_value                 instance.method.return_value = 'success'</code>.  My method is <code>call</code> in externalService. Should I do something about it?</span>
<span class="comment-copy">Without details like what calls what, how and what do you want to replace with mock versions it's neigh impossible to give an exact answer. Do you mean that your login view in "/login" calls <code>myProject.externalService</code> instance's <code>call</code> method? Then why would you do <code>instance.method.return_value = 'success'</code> instead of <code>instance.call.return_value = 'success'</code>?</span>
<span class="comment-copy">The answer to the first part of the question is yes, and the second is that I'm not completely familiar with mock.  I turned it into <code>instance.call.return_value = 'success' </code> but it goes to the external service.</span>
<span class="comment-copy">@AlirezaHos please see the additions, have you perhaps imported <code>externalService</code> in to the namespace of your login view?</span>
<span class="comment-copy">@AlirezaHos didn't mean that literally, could not even know you had a call to that, but as an example of how <code>patch</code> might not produce the desired results, e.g. replace the correct reference during testing.</span>
