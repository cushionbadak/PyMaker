<div class="post-text" itemprop="text">
<p>I have some ids as follows:</p>
<pre><code>req_ids=['964','123','534','645','876','222']
</code></pre>
<p>and I get a response from another server like this not in any particular order:</p>
<pre><code>res_result = [{'id':'123', 'name':'Sachin'},
              {'id':'534', 'name':'Vipin'},
              {'id':'222', 'name':'Ram'},
              {'id':'645', 'name':'Anoop'},
              {'id':'964', 'name':'Sani'},
              {'id':'876', 'name':'John'}]
</code></pre>
<p>I need to get <code>res_result</code> in the same request order as req_ids,</p>
<pre><code>    [{'id':'964', 'name':'Sani'},
     {'id':'123', 'name':'Sachin'},
     {'id':'534', 'name':'Vipin'},
     {'id':'645', 'name':'Anoop'},
     {'id':'876', 'name':'John'},
     {'id':'222', 'name':'Ram'}]
</code></pre>
<p>How do I do this if possible using an inbuilt python function instead writing our own loop to do this logic?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you <em>must</em> sort, map the keys to integers, then use that map to sort:</p>
<pre><code>id_to_pos = {key: i for i, key in enumerate(req_ids)}
sorted(res_result, key=lambda d: id_to_pos[d['id']])
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; req_ids = ['964', '123', '534', '645', '876', '222']
&gt;&gt;&gt; res_result = [{'id':'123', 'name':'Sachin'},
...               {'id':'534', 'name':'Vipin'},
...               {'id':'222', 'name':'Ram'},
...               {'id':'645', 'name':'Anoop'},
...               {'id':'964', 'name':'Sani'},
...               {'id':'876', 'name':'John'}]
&gt;&gt;&gt; id_to_pos = {key: i for i, key in enumerate(req_ids)}
&gt;&gt;&gt; sorted(res_result, key=lambda d: id_to_pos[d['id']])
[{'id': '964', 'name': 'Sani'}, {'id': '123', 'name': 'Sachin'}, {'id': '534', 'name': 'Vipin'}, {'id': '645', 'name': 'Anoop'}, {'id': '876', 'name': 'John'}, {'id': '222', 'name': 'Ram'}]
&gt;&gt;&gt; pprint(_)
[{'id': '964', 'name': 'Sani'},
 {'id': '123', 'name': 'Sachin'},
 {'id': '534', 'name': 'Vipin'},
 {'id': '645', 'name': 'Anoop'},
 {'id': '876', 'name': 'John'},
 {'id': '222', 'name': 'Ram'}]
</code></pre>
<p>However, you can avoid sorting altogether, you <em>already</em> have the right order, you only need to map from <code>id</code> keys to dictionaries (O(N)), then pull out the dictionaries in the right order (still O(N)):</p>
<pre><code>id_to_dict = {d['id']: d for d in res_result}
[id_to_dict[id] for id in req_ids]
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; id_to_dict = {d['id']: d for d in res_result}
&gt;&gt;&gt; [id_to_dict[id] for id in req_ids]
[{'id': '964', 'name': 'Sani'}, {'id': '123', 'name': 'Sachin'}, {'id': '534', 'name': 'Vipin'}, {'id': '645', 'name': 'Anoop'}, {'id': '876', 'name': 'John'}, {'id': '222', 'name': 'Ram'}]
&gt;&gt;&gt; pprint(_)
[{'id': '964', 'name': 'Sani'},
 {'id': '123', 'name': 'Sachin'},
 {'id': '534', 'name': 'Vipin'},
 {'id': '645', 'name': 'Anoop'},
 {'id': '876', 'name': 'John'},
 {'id': '222', 'name': 'Ram'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; map({d['id']: d for d in res_result}.__getitem__, req_ids)
[{'id': '964', 'name': 'Sani'}, {'id': '123', 'name': 'Sachin'}, {'id': '534', 'name': 'Vipin'}, {'id': '645', 'name': 'Anoop'}, {'id': '876', 'name': 'John'}, {'id': '222', 'name': 'Ram'}]
</code></pre>
</div>
<span class="comment-copy">It the complexity O(n^2)?</span>
<span class="comment-copy">@FazalSap: no, O(NlogN), simply straight-up sort; the <code>id_to_pos</code> map makes looking up the sort key a O(1) operation, per sorted item. The map is created in O(N) time, <i>before</i> the sort. So the overall algorithm is still dominated by the O(NlogN) sorting time.</span>
<span class="comment-copy">@FazalSap: but now that you made me think properly, I added a O(N) solution instead. No need to sort when you already have a fixed order, all you need is to produce a map from id to dictionary.</span>
<span class="comment-copy">@MartijnPieters - dict lookup <code>id_to_dict[id]</code> can be O(n) if there is a collision right? So the worst case is O(n^2) no? Please correct me if I am wrong.</span>
<span class="comment-copy">@Nishant: chances of a collision are <i>way too small</i> to matter here. Yes, in theory you can <a href="http://www.ocert.org/advisories/ocert-2011-003.html" rel="nofollow noreferrer">craft all-colliding keys</a>, but with <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED" rel="nofollow noreferrer">hash randomisation</a> the chances of running into <i>N</i> hash collisions is virtually zero.</span>
