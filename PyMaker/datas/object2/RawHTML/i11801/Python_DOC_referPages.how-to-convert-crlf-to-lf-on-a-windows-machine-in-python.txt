<div class="post-text" itemprop="text">
<p>So I got those template, they are all ending in LF and I can fill some terms inside with format and still get LF files by opening with "wb"</p>
<p>Those templates are used in a deployment script on a windows machine to deploy on a unix server.</p>
<p>Problem is, a lot of people are going to mess with those template, and I'm 100% sure that some of them will put some CRLF inside.</p>
<p>How could I, using python convert all the crlf to lf?</p>
<p>Thanks.</p>
<h1>EDIT</h1>
<p>Well, my bad, I had a bug in my code, opening in "wb" always put lf at the end of the lines even if the file was using crlf before.</p>
<p>Here is the code I'm using if you are wondering :</p>
<pre><code>#!/usr/bin/env python
# --*-- encoding: iso-8859-1 --*--

import string

def formatFile(templatePath, filledFilePath, params, target):
    openingMode = 'w'
    if target == 'linux':
        openingMode += 'b'

    with open(templatePath, 'r') as infile, open(filledFilePath, openingMode) as outfile:
        for line in infile:
            template = string.Template(line.decode('UTF-8'))
            outfile.write(template.substitute(**params).encode('UTF-8'))
</code></pre>
<p>So no problem, everything is working fine :x</p>
</div>
<div class="post-text" itemprop="text">
<h1>Convert Line Endings in-place (with Python 3)</h1>
<h3>Windows to Linux/Unix</h3>
<p>Here is a short script for directly converting <strong>Windows line endings</strong> (<code>\r\n</code> also called <code>CRLF</code>) to <strong>Linux/Unix line endings</strong> (<code>\n</code> also called <code>LF</code>) in-place (without creating an extra output file):</p>
<pre><code># replacement strings
WINDOWS_LINE_ENDING = b'\r\n'
UNIX_LINE_ENDING = b'\n'

# relative or absolute file path, e.g.:
file_path = r"c:\Users\Username\Desktop\file.txt"

with open(file_path, 'rb') as open_file:
    content = open_file.read()

content = content.replace(WINDOWS_LINE_ENDING, UNIX_LINE_ENDING)

with open(file_path, 'wb') as open_file:
    open_file.write(content)
</code></pre>
<h3>Linux/Unix to Windows</h3>
<p>Just swap the constants for the line endings in the <code>str.replace()</code> call like so: <code>content.replace(UNIX_LINE_ENDING, WINDOWS_LINE_ENDING)</code>.</p>
<hr/>
<h3>Code Explanation</h3>
<ul>
<li><p><strong>Important: Binary Mode</strong> We need to make sure that we open the file both times in binary mode (<code>mode='rb'</code> and <code>mode='wb'</code>) for the conversion to work.</p>
<p>When opening files in text mode (<code>mode='r'</code> or <code>mode='w'</code> without <code>b</code>), the platform's native line endings (<code>\r\n</code> on Windows and <code>\r</code> on old Mac OS versions) are automatically converted to Python's Unix-style line endings: <code>\n</code>. So the call to <code>content.replace()</code> couldn't find any <code>\r\n</code> line endings to replace.</p>
<p>In binary mode, no such conversion is done. Therefore the call to <code>str.replace()</code> can do its work.</p></li>
<li><p><strong>Binary Strings</strong> In Python 3, if not declared otherwise, strings are stored as Unicode (<code>UTF-8</code>). But we open our files in binary mode - therefore we need to add <code>b</code> in front of our replacement strings to tell Python to handle those strings as binary, too.</p></li>
<li><p><strong>Raw Strings</strong> On Windows the path separator is a backslash <code>\</code> which we would need to escape in a normal Python string with <code>\\</code>. By adding <code>r</code> in front of the string we create a so called "raw string" which doesn't need any escaping. So you can directly copy/paste the path from Windows Explorer into your script.</p>
<p>(<em>Hint:</em> Inside Windows Explorer press <kbd>CTRL</kbd>+<kbd>L</kbd> to automatically select the path from the address bar.)</p></li>
<li><p><strong>Alternative</strong> We open the file twice to avoid the need of repositioning the file pointer. We also could have opened the file once with <code>mode='rb+'</code> but then we would have needed to move the pointer back to start after reading its content (<code>open_file.seek(0)</code>) and truncate its original content before writing the new one (<code>open_file.truncate(0)</code>).</p>
<p>Simply opening the file again in write mode does that automatically for us.</p></li>
</ul>
<p>Cheers and happy programming,<br/>
winklerrr</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's <a href="https://docs.python.org/2.7/library/functions.html#open" rel="noreferrer">open</a> function supports the <code>'rU'</code> mode for <a href="https://docs.python.org/2.7/glossary.html#term-universal-newlines" rel="noreferrer">universal newlines</a>, in which case it doesn't mind which sort of newline each line has. In Python 3 you can also request a specific form of newline with the <a href="https://docs.python.org/3/library/functions.html#open" rel="noreferrer">newline argument for open</a>. </p>
<p>Translating from one form to the other is thus rather simple in Python:</p>
<pre><code>with open('filename.in', 'rU') as infile,                 \
   open('filename.out', 'w', newline='\n') as outfile:
       outfile.writelines(infile.readlines())
</code></pre>
<p>(Due to the newline argument, the U is actually deprecated in Python 3; the equivalent form is <code>newline=None</code>.)</p>
</div>
<div class="post-text" itemprop="text">
<p>why don't you try below::
str.replace('\r\n','\n');</p>
<p>CRLF =&gt; \r\n
LF =&gt; \n</p>
<p>it's history of typewriter =)</p>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to fix existing templates with messed-up ending with this code:</p>
<pre><code>with open('file.tpl') as template:
   lines = [line.replace('\r\n', '\n') for line in template]
with open('file.tpl', 'w') as template:
   template.writelines(lines)
</code></pre>
</div>
