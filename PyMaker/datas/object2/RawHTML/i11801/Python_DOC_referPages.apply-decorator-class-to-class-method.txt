<div class="post-text" itemprop="text">
<p>Consider following decorator:</p>
<pre><code>class connector(object):
    def __init__(self, signal):
        self.signal = signal
    def __call__(self, slot_func):
        def wrapper(*args, **kwargs):
            slot_func(*args, **kwargs)
        self.signal.connect(wrapper)
</code></pre>
<p>And following signal, and class with method I need to decorate:</p>
<pre><code>from signalslot import Signal

update = Signal()

class manager(object):
    # SOME CODE CUT
    @connector(update)
    def update(self):
        print("I'm updating, yay!!!!")
</code></pre>
<p>As you can see I need to pass decorator some additional arguments, and in that case - signal I need to connect to.
How to pass self as well?</p>
<p>The reason I ask that, because it fails with following error if I try to apply this decorator to method, not a function:</p>
<blockquote>
<p>TypeError: update() missing 1 required positional argument: 'self'</p>
</blockquote>
<p>More specifically, if I try to emit the signal:</p>
<pre><code>update.emit()
</code></pre>
<p>And yes, I use <a href="http://signalslot.readthedocs.org/en/latest/" rel="nofollow">"signalslot"</a> in that project.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>self</code> must be a <em>positional</em> argument, not a keyword argument:</p>
<pre><code>def wrapper(self, *args, **kwargs):
    #       ^^^^ You can't use "self=None" here.
    slot_func(self, *args, **kwargs)
</code></pre>
<p>If you need to differentiate between functions and methods, implement a <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow">descriptor</a> instead.</p>
<p>However, if you are trying to connect a signal, you'll need to do so to <em>a bound method on each instance</em>. You'd be better of connecting your signals <em>at instance creation time</em>:</p>
<pre><code>class manager(object):
    def __init__(self):
        update.connect(self.update)

    def update(self):
        print("I'm updating, yay!!!!")
</code></pre>
<p>When <code>manager.__init__</code> is called, you have have a new instance and it is then you can create <em>one</em> <code>self.update</code> bound method to receive the signal.</p>
<p>You can still use decorator for this, but you can, at best register <em>at class level</em> what functions can act as signal handlers; you'd have to enumerate all functions on your class at instance-creation time and bind all those signals then:</p>
<pre><code>class connector(object):
    def __init__(self, signal):
        self.signal = signal
    def __call__(self, slot_func):
        slot_func._signal_handler = self.signal
        return slot_func
</code></pre>
<p>and a separate class decorator to wrap the <code>class.__init__</code> method:</p>
<pre><code>from inspect import getmembers, isfunction

def connectsignals(cls):
    signal_handlers = getmembers(
        cls, lambda m: isfunction(m) and hasattr(m, '_signal_handler'))
    init = getattr(cls, '__init__', lambda self: None)
    def wrapper(self, *args, **kwargs):
        init(self, *args, **kwargs)
        for name, handler in signal_handlers:
            handler._signal_handler.connect(handler.__get__(self))
    cls.__init__ = wrapper
    return cls
</code></pre>
<p>Decorate the class as well as the signal handlers:</p>
<pre><code>@connectsignals
class manager(object):
    @connector(update)
    def update(self):
        print("I'm updating, yay!!!!")
</code></pre>
<p>The decorator then connects all handlers each time a new instance is created:</p>
<pre><code>&gt;&gt;&gt; class Signal(object):
...     def connect(self, handler):
...         print('connecting {!r}'.format(handler))
...
&gt;&gt;&gt; update = Signal()
&gt;&gt;&gt; @connectsignals
... class manager(object):
...     @connector(update)
...     def update(self):
...         print("I'm updating, yay!!!!")
...
&gt;&gt;&gt; manager()
connecting &lt;bound method manager.update of &lt;__main__.manager object at 0x105439ac8&gt;&gt;
&lt;__main__.manager object at 0x105439ac8&gt;
</code></pre>
<p>You may want to check if the <code>signalslot</code> project uses weak references to track signal handlers however, as you'll either have a problem of circular references to any instances you create (where a <code>manager</code> instance is kept alive because a signal is still referencing a bound method to that instance), or where your signal handlers are cleaned up too early because your bound methods are stored in weak references, and thus won't have any <em>other</em> references to keep them alive.</p>
<p>Looking at the <a href="https://github.com/Numergy/signalslot/blob/master/signalslot/signal.py#L69" rel="nofollow"><code>signalslot</code> source code</a>, I see that the current iteration of the project uses hard references, so your <code>manager</code> instances are never going to be cleared unless you do so explicitly. For this reason alone I'd avoid using methods as signal handlers. Take a look at <a href="https://stackoverflow.com/questions/21826700/using-python-weakset-to-enable-a-callback-functionality">using python WeakSet to enable a callback functionality</a> if you want to use weak references instead.</p>
</div>
