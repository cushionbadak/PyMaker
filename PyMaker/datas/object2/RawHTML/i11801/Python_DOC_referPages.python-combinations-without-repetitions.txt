<div class="post-text" itemprop="text">
<p>I have a list of numbers and I want to make combinations from it. If I have list:</p>
<pre><code>t = [2,2,2,2,4]
c = list(itertools.combinations(t, 4))
</code></pre>
<p>The result is:</p>
<pre><code>(2, 2, 2, 2)
(2, 2, 2, 4)
(2, 2, 2, 4)
(2, 2, 2, 4)
(2, 2, 2, 4)
</code></pre>
<p>but I want to get:</p>
<pre><code>(2, 2, 2, 2)
(2, 2, 2, 4)
</code></pre>
<p>Is it possible to eliminate duplicates except making new list and going through first list?</p>
</div>
<div class="post-text" itemprop="text">
<p>As Donkey Kong points to set, You can get the unique values in a list by converting the list to a set :</p>
<pre><code>t = [2,2,2,2,4]
c = list(itertools.combinations(t, 4))
unq = set(c)
print(unq)
</code></pre>
<p>And the result will be:</p>
<pre><code>{(2, 2, 2, 4), (2, 2, 2, 2)}
</code></pre>
<p>If you want to use it as a list, you can convert it back by doing :</p>
<pre><code>result = list(unq)
</code></pre>
<p>Alternative and more clean,comprehensive way will be :</p>
<pre><code>t = [2,2,2,2,4]
c = set(itertools.combinations(t, 4))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I know this is late but I want to add a point.</p>
<p><code>set(itertools.combinations(t, 4))</code> would do a fine job for most cases, but it still iterates all repetitive combinations internally and so it can be computationally heavy. This is especially the case if there aren't many actual unique combinations.</p>
<p>This one iterates only unique combinations:</p>
<pre><code>from itertools import chain,repeat,islice,count
from collections import Counter

def combinations_without_repetition(r, iterable=None, values=None, counts=None):
  if iterable:
    values, counts = zip(*Counter(iterable).items())

  f = lambda i,c: chain.from_iterable(map(repeat, i, c))
  n = len(counts)
  indices = list(islice(f(count(),counts), r))
  if len(indices) &lt; r:
    return
  while True:
    yield tuple(values[i] for i in indices)
    for i,j in zip(reversed(range(r)), f(reversed(range(n)), reversed(counts))):
      if indices[i] != j:
        break
    else:
      return
    j = indices[i]+1
    for i,j in zip(range(i,r), f(count(j), counts[j:])):
      indices[i] = j
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; t = [2,2,2,2,4]
# elements in t must be hashable
&gt;&gt;&gt; list(combinations_without_repetition(4, iterable=t)) 
[(2, 2, 2, 2), (2, 2, 2, 4)]

# You can pass values and counts separately. For this usage, values don't need to be hashable
# Say you have ['a','b','b','c','c','c'], then since there is 1 of 'a', 2 of 'b', and 3 of 'c', you can do as follows:
&gt;&gt;&gt; list(combinations_without_repetition(3, values=['a','b','c'], counts=[1,2,3]))
[('a', 'b', 'b'), ('a', 'b', 'c'), ('a', 'c', 'c'), ('b', 'b', 'c'), ('b', 'c', 'c'), ('c', 'c', 'c')]

# combinations_without_repetition() is a generator (and thus an iterator)
# so you can iterate it
&gt;&gt;&gt; for comb in combinations_without_repetition(4, t):
...   print(sum(comb))
...
8   # 2+2+2+2
10  # 2+2+2+4
</code></pre>
<p>Note that <code>itertools.combinations()</code> is implemented in C, which means it is much faster than my python script for most cases. This code works better than <code>set(itertools.combinations())</code> method only when there are A LOT MORE repetitive combinations than unique combinations.</p>
</div>
<div class="post-text" itemprop="text">
<p>Technically, what you get are not actually duplicates, it's simply how <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow"><code>itertools.combinations</code></a> works, if you read the description in the linked page:</p>
<blockquote>
<p><code>itertools.combinations(iterable, r)</code></p>
<p>Return r length subsequences of elements from the input iterable.</p>
<p>Combinations are emitted in lexicographic sort order. So, if the input iterable is sorted, the combination tuples will be produced in
  sorted order.</p>
<p><strong>Elements are treated as unique based on their position, not on their value</strong>. So if the input elements are unique, there will be no
  repeat values in each combination.</p>
</blockquote>
<p>DEMO:</p>
<pre><code>&gt;&gt;&gt; import itertools as it
&gt;&gt;&gt; list(it.combinations([1,2,3,4,5], 4))
[(1, 2, 3, 4), (1, 2, 3, 5), (1, 2, 4, 5), (1, 3, 4, 5), (2, 3, 4, 5)]
</code></pre>
<p>So, just as posted on the previous answer, <code>set()</code> will give you the unique values you want:</p>
<pre><code>&gt;&gt;&gt; set(it.combinations(t, 4))
{(2, 2, 2, 4), (2, 2, 2, 2)}
</code></pre>
</div>
<span class="comment-copy">Use a <code>set</code>?...</span>
<span class="comment-copy">Just <code>set(itertools.combinations(t, 4))</code></span>
<span class="comment-copy">It was his code he is using list, i am just continuing his code ...</span>
<span class="comment-copy">Yes , that will be the clean way.</span>
<span class="comment-copy">Don't do that.  Why would he cast to a list and then to a set and then back to a list?</span>
<span class="comment-copy">@Randhawa..your answer should provide a <i>clean</i> <i>fix</i> code as well...:)</span>
<span class="comment-copy">I'm still trying to understand all your passages but it works very good!</span>
<span class="comment-copy">I'm just trying to understand the usage. Can you explain it a bit more?</span>
<span class="comment-copy">@decadenza Can you spot the part where you get confused? Or maybe you can tell me what you are trying to do.</span>
<span class="comment-copy">I do not understand the purpose of <code>values</code> and <code>counts</code> fields. Your example gives the same result. Can you explain it? Thanks.</span>
<span class="comment-copy">@decadenza I added more explanation on my post. Does it help?</span>
<span class="comment-copy">I was about to force myself to write an answer because of the other answer but you saved me the trouble, thank you, +1.</span>
<span class="comment-copy">@DonkeyKong ... hahahahah ... no pblm .. =-D .. I wanted in my answer to explain to OP why he actually got those values whom thinks they are duplicates..;)</span>
