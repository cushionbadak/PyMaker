<div class="post-text" itemprop="text">
<p>I would like to split a Python multiline string at its commas, except when the commas are inside a bracketed expression. E.g., the string</p>
<pre><code>{J. Doe, R. Starr}, {Lorem
{i}psum dolor }, Dol. sit., am. et.
</code></pre>
<p>Should be split into</p>
<pre><code>['{J. Doe, R. Starr}', '{Lorem\n{i}psum dolor }', 'Dol. sit.', 'am. et.']
</code></pre>
<p>This involves bracket matching, so probably regexes are not helping out here. <a href="http://pyparsing.wikispaces.com/">PyParsing</a> has <a href="http://pyparsing.wikispaces.com/file/view/commasep.py/30112823/commasep.py"><code>commaSeparatedList</code></a> which <em>almost</em> does what I need except that <em>quoted</em> (<code>"</code>) environments are protected instead of <code>{}</code>-delimited ones.</p>
<p>Any hints?</p>
</div>
<div class="post-text" itemprop="text">
<p>Write your own custom split-function:</p>
<pre><code> input_string = """{J. Doe, R. Starr}, {Lorem
 {i}psum dolor }, Dol. sit., am. et."""


 expected = ['{J. Doe, R. Starr}', '{Lorem\n{i}psum dolor }', 'Dol. sit.', 'am. et.']

 def split(s):
     parts = []
     bracket_level = 0
     current = []
     # trick to remove special-case of trailing chars
     for c in (s + ","):
         if c == "," and bracket_level == 0:
             parts.append("".join(current))
             current = []
         else:
             if c == "{":
                 bracket_level += 1
             elif c == "}":
                 bracket_level -= 1
             current.append(c)
     return parts

 assert split(input_string), expected
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow"><code>re.split</code></a> in this case:</p>
<pre><code>&gt;&gt;&gt; from re import split
&gt;&gt;&gt; data = '''\
... {J. Doe, R. Starr}, {Lorem
... {i}psum dolor }, Dol. sit., am. et.'''
&gt;&gt;&gt; split(',\s*(?![^{}]*\})', data)
['{J. Doe, R. Starr}', '{Lorem\n{i}psum dolor }', 'Dol. sit.', 'am. et.']
&gt;&gt;&gt;
</code></pre>
<p>Below is an explanation of what the Regex pattern matches:</p>
<pre><code>,       # Matches ,
\s*     # Matches zero or more whitespace characters
(?!     # Starts a negative look-ahead assertion
[^{}]*  # Matches zero or more characters that are not { or }
\}      # Matches }
)       # Closes the look-ahead assertion
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/26808913/split-string-at-commas-except-when-in-bracket-environment#comment42190637_26808913">Lucas Trzesniewski's comment</a> can actually be used in Python with <a href="https://pypi.python.org/pypi/regex" rel="nofollow noreferrer">PyPi regex module</a> (I just replaced named group with a numbered one to make it shorter):</p>
<pre><code>&gt;&gt;&gt; import regex
&gt;&gt;&gt; r = regex.compile(r'({(?:[^{}]++|\g&lt;1&gt;)*})(*SKIP)(*FAIL)|\s*,\s*')
&gt;&gt;&gt; s = """{J. Doe, R. Starr}, {Lorem
{i}psum dolor }, Dol. sit., am. et."""
&gt;&gt;&gt; print(r.split(s))
['{J. Doe, R. Starr}', None, '{Lorem\n{i}psum dolor }', None, 'Dol. sit.', None, 'am. et.']
</code></pre>
<p>The pattern - <code>({(?:[^{}]++|\g&lt;1&gt;)*})(*SKIP)(*FAIL)</code> - matches <code>{...{...{}...}...}</code> like structures (as <code>{</code> matches <code>{</code>, <code>(?:[^{}]++|\g&lt;1&gt;)*</code> matches 0+ occurrences of 2 alternatives: 1) any 1+ characters other than <code>{</code> and <code>}</code> (the <code>[^{}]++</code>), 2) text matching the whole <code>({(?:[^{}]++|\g&lt;1&gt;)*})</code> subpattern). The <code>(*SKIP)(*FAIL)</code> verbs make the engine omit the whole matched value from the match buffer, thus, moving the index to the end of the match and holding nothing to return (we "skip" what we matched).</p>
<p>The <code>\s*,\s*</code> matches a comma enclosed with 0+ whitespaces.</p>
<p>The <code>None</code> values appear because there is a capture group in the first branch that is empty when the second branch matches. We need to use a capture group in the first alternative branch for recursion. To remove the empty elements, use comprehension:</p>
<pre><code>&gt;&gt;&gt; print([x for x in r.split(s) if x])
['{J. Doe, R. Starr}', '{Lorem\n{i}psum dolor }', 'Dol. sit.', 'am. et.']
</code></pre>
</div>
<span class="comment-copy">AFAIK Python doesn't support recursion in regexes. Just for reference, this would <a href="http://regex101.com/r/qD4zV8/1" rel="nofollow noreferrer">do the job</a> with PCRE: <code>(?'braces'\{(?:[^{}]++|\g&lt;braces&gt;)*\})(*SKIP)(*FAIL)|,</code></span>
<span class="comment-copy">this is no trivial thing you ask ... ... regexes are not helpfull because you require a state machine with memory in order to match enclosing items ..(brakcets,quotes,etc)</span>
<span class="comment-copy">It can't be done without recursive regex (ones that do recursion). I thought Python has a newer version that does this now. Funny how Perl comes from Python, Perl leaves it in the dust.</span>
<span class="comment-copy">@sln: What does "Perl comes from Python" mean? Perl was already around when Guido started thinking about Python, was in widespread use long before most people even heard of Python, and was an influence in Python's development through the 1.x/early-2.x days. Python's <code>re</code> engine, in particular, is directly based on Perl's. And I'm not sure that being able to spend exponential time on a regexp without warning counts as "leaves it in the dust"â€¦</span>
<span class="comment-copy">@abarnert - I think Perl may have been around but Perl adopted much functionality, which was first I don't know. I briefly thought I read some details on Python re beta site, seems quite a few new things are coming about using the available syntax constructs.</span>
<span class="comment-copy">nice work ... :) this is the only current correct answer afaik</span>
<span class="comment-copy">Good, but the assumption with this implementation is there are no "{" or "}" characters in the string which may not be part of a grouping.  i.e.  ":-}"  If that possibility ever exists, there would need to be some consideration made for how to deal with it.</span>
<span class="comment-copy">Won't this fail for more slightly more complicated examples of nested brackets? E.g. <code>"{J. Doe, R. Starr {x,{y}}}, {Lorem {i}psum dolor }, Dol. sit., am. et."</code>?</span>
<span class="comment-copy">@ajcr - Yes, it will fail.  But that's why I said "in this case".  The pattern I gave isn't bulletproof and can only handle simple strings.  Specifically, it is meant for strings where there are no nested curly braces with commas, as in the OP's example.  However, if the OP is working with strings as complex as that, it would be better to ditch Regex and build a parser instead.</span>
<span class="comment-copy">I don't think you can generalize this to be a solution on any level.</span>
<span class="comment-copy">If you're willing to accept a quick hack that doesn't work on more complex cases, why not go for the simplest? You don't really need to handle matched pairs of open and closed braces; just treat both open braces and closed braces as equivalent alternative "quote" characters, and skip any commas inside "quotes" the same way that PyParsing or <code>csv</code> or whatever does?</span>
