<div class="post-text" itemprop="text">
<p>Is there a way to give a comparator to <code>set()</code> so when adding items it checks an attribute of that item for likeness rather than if the item is the same? For example, I want to use objects in a set that can contain the same value for one attribute.</p>
<pre><code>class TestObj(object):
    def __init__(self, value, *args, **kwargs):
        self.value = value 
        super().__init__(*args, **kwargs)

values = set()
a = TestObj('a')
b = TestObj('b')
a2 = TestObj('a')
values.add(a) # Ok
values.add(b) # Ok
values.add(a2) # Not ok but still gets added

# Hypothetical code
values = set(lambda x, y: x.value != y.value)
values.add(a) # Ok
values.add(b) # Ok
values.add(a2) # Not added
</code></pre>
<p>I have implemented my own sorta thing that does similar functionality but wanted to know if there was a builtin way.</p>
<pre><code>from Queue import Queue
class UniqueByAttrQueue(Queue):
    def __init__(self, attr, *args, **kwargs):
        Queue.__init__(self, *args, **kwargs)
        self.attr = attr

    def _init(self, maxsize):
        self.queue = set()

    def _put(self, item):
        # Potential race condition, worst case message gets put in twice
        if hasattr(item, self.attr) and item not in self:
            self.queue.add(item)

    def __contains__(self, item):
        item_attr = getattr(item, self.attr)
        for x in self.queue:
            x_attr = getattr(x, self.attr)
            if x_attr == item_attr:
                return True
        return False

    def _get(self):
        return self.queue.pop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just define <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow"><code>__hash__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow"><code>__eq__</code></a> on the object in terms of the attribute in question and it will work with <code>set</code>s. For example:</p>
<pre><code>class TestObj(object):
    def __init__(self, value, *args, **kwargs):
        self.value = value 
        super().__init__(*args, **kwargs)

    def __eq__(self, other):
        return self.value == other.value

    def __hash__(self):
        return hash(self.value)
</code></pre>
<p>If you can't change the object (or don't want to, say, because other things are important to equality), then use a <code>dict</code> instead. You can either do:</p>
<pre><code>mydict[obj.value] = obj
</code></pre>
<p>so new objects replace old, or</p>
<pre><code>mydict.setdefault(obj.value, obj)
</code></pre>
<p>so old objects are maintained if the <code>value</code> in question is already in the keys. Just make sure to iterate using <code>.viewvalues()</code> (Python 2) or <code>.values()</code> (Python 3) instead of iterating directly (which would get the keys, not the values). You could actually use this approach to make a custom <code>set</code>-like object with a key as you describe (though you'd need to implement many more methods than I show to make it efficient, the default methods are usually fairly slow):</p>
<pre><code>from collections.abc import MutableSet  # On Py2, collections without .abc

class keyedset(MutableSet):
    def __init__(self, it=(), key=lambda x: x):
        self.key = key
        self.contents = {}
        for x in it:
            self.add(x)

    def __contains__(self, x):
        # Use anonymous object() as default so all arguments handled properly
        sentinel = object()
        getval = self.contents.get(self.key(x), sentinel)
        return getval is not sentinel and getval == x

    def __iter__(self):
        return iter(self.contents.values())  # itervalues or viewvalues on Py2

    def __len__(self):
        return len(self.contents)

    def add(self, x):
        self.contents.setdefault(self.key(x), x)

    def discard(self, x):
        self.contents.pop(self.key(x), None)
</code></pre>
</div>
<span class="comment-copy">Set and dict equality is determined by the object hash, so you could override the <code>__hash__</code> method to be based on the <code>value</code> attribute.</span>
<span class="comment-copy">I'd think that set would take care of that for you. It will only reject identical objects, not objects that are partially different.</span>
<span class="comment-copy">Well that is the problem exactly @roadrunner66. I want it to reject partially the same hence why I want to give it a comparison key.</span>
<span class="comment-copy">@tzaman: Object hash <i>and</i> normal equality, so you also have to implement <code>__eq__</code>.</span>
<span class="comment-copy">Kinda curious why I got the downvote, but whatever.</span>
<span class="comment-copy">That's a weird downvote. The only problem I see here is that you assume <code>other</code> is a <code>TestObj</code> instance in <code>__eq__</code> instead of checking and returning <code>NotImplemented</code>. Other than that, this is a great answer.</span>
<span class="comment-copy">@user2357112 As an aside, I think that <code>NotImplemented</code> is used for abstract-style classes (where the idea is to subclass them and define your own method). Generally you use <code>TypeError</code> or one of its subclasses if an operation isn't defined for a given type.</span>
<span class="comment-copy">@Paul: You'd use <code>NotImplemented</code> in this case actually, because it tells Python that you don't know how to handle the comparison, but allows it to try using the <code>__eq__</code> of the other object to see if it supports it. If the right side object knows how to compare to the left, the left <i>must</i> return <code>NotImplemented</code> so Python will know to try the right.</span>
<span class="comment-copy">@Paul: No, <code>NotImplemented</code> is there to let the other guy define an equality operation. For example, NumPy arrays can be <code>==</code>ed with just about anything.</span>
