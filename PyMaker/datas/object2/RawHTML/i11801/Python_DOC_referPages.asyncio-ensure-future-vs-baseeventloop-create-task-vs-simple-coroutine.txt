<div class="post-text" itemprop="text">
<p>I've seen several basic Python 3.5 tutorials on asyncio doing the same operation in various flavours.
In this code:</p>
<pre><code>import asyncio  

async def doit(i):
    print("Start %d" % i)
    await asyncio.sleep(3)
    print("End %d" % i)
    return i

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    #futures = [asyncio.ensure_future(doit(i), loop=loop) for i in range(10)]
    #futures = [loop.create_task(doit(i)) for i in range(10)]
    futures = [doit(i) for i in range(10)]
    result = loop.run_until_complete(asyncio.gather(*futures))
    print(result)
</code></pre>
<p>All the three variants above that define the <code>futures</code> variable achieve the same result; the only difference I can see is  that with the third variant the execution is out of order (which should not matter in most cases). Is there any other difference? Are there cases where I can't just use the simplest variant (plain list of coroutines)?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Actual info:</h2>
<p>Starting from Python 3.7 <code>asyncio.create_task(coro)</code> high-level function <a href="https://docs.python.org/3/library/asyncio-task.html#creating-tasks" rel="noreferrer">was added</a> for this purpose. </p>
<p>You should use it instead other ways of creating tasks from coroutimes. However if you need to create task from arbitrary awaitable, you should use <code>asyncio.ensure_future(obj)</code>.</p>
<hr/>
<h2>Old info:</h2>
<h2><code>ensure_future</code> vs <code>create_task</code></h2>
<p><code>ensure_future</code> is a method to create <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task" rel="noreferrer"><code>Task</code></a> from <a href="https://docs.python.org/3/library/asyncio-task.html#coroutines" rel="noreferrer"><code>coroutine</code></a>. It creates tasks in different ways based on argument (including using of <code>create_task</code> for coroutines and future-like objects).</p>
<p><code>create_task</code> is an abstract method of <code>AbstractEventLoop</code>. Different event loops can implement this function different ways.</p>
<p>You should use <code>ensure_future</code> to create tasks. You'll need <code>create_task</code> only if you're going to implement your own event loop type.</p>
<p><strong>Upd:</strong></p>
<p>@bj0 pointed at <a href="https://github.com/python/asyncio/issues/477" rel="noreferrer">Guido's answer</a> on this topic:</p>
<blockquote>
<p>The point of <code>ensure_future()</code> is if you have something that could
  either be a coroutine or a <code>Future</code> (the latter includes a <code>Task</code> because
  that's a subclass of <code>Future</code>), and you want to be able to call a method
  on it that is only defined on <code>Future</code> (probably about the only useful
  example being <code>cancel()</code>). When it is already a <code>Future</code> (or <code>Task</code>) this
  does nothing; when it is a coroutine it <em>wraps</em> it in a <code>Task</code>.</p>
<p>If you know that you have a coroutine and you want it to be scheduled,
  the correct API to use is <code>create_task()</code>. The only time when you should
  be calling <code>ensure_future()</code> is when you are providing an API (like most
  of asyncio's own APIs) that accepts either a coroutine or a <code>Future</code> and
  you need to do something to it that requires you to have a <code>Future</code>.</p>
</blockquote>
<p>and later:</p>
<blockquote>
<p>In the end I still believe that <code>ensure_future()</code> is an appropriately
  obscure name for a rarely-needed piece of functionality. When creating
  a task from a coroutine you should use the appropriately-named
  <code>loop.create_task()</code>. Maybe there should be an alias for that
  <code>asyncio.create_task()</code>?</p>
</blockquote>
<p>It's surprising to me. My main motivation to use <code>ensure_future</code> all along was that it's higher-level function comparing to loop's member <code>create_task</code> (discussion <a href="https://github.com/python/asyncio/issues/477#issuecomment-269042731" rel="noreferrer">contains</a> some ideas like adding <code>asyncio.spawn</code> or <code>asyncio.create_task</code>).</p>
<p>I can also point that in my opinion it's pretty convenient to use universal function that can handle any <code>Awaitable</code> rather than coroutines only.</p>
<p>However, Guido's answer is clear: <strong>"When creating a task from a coroutine you should use the appropriately-named <code>loop.create_task()</code>"</strong></p>
<h2>When coroutines should be wrapped in tasks?</h2>
<p>Wrap coroutine in a Task - is a way to start this coroutine "in background". Here's example:</p>
<pre><code>import asyncio


async def msg(text):
    await asyncio.sleep(0.1)
    print(text)


async def long_operation():
    print('long_operation started')
    await asyncio.sleep(3)
    print('long_operation finished')


async def main():
    await msg('first')

    # Now you want to start long_operation, but you don't want to wait it finised:
    # long_operation should be started, but second msg should be printed immediately.
    # Create task to do so:
    task = asyncio.ensure_future(long_operation())

    await msg('second')

    # Now, when you want, you can await task finised:
    await task


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
</code></pre>
<p>Output:</p>
<pre><code>first
long_operation started
second
long_operation finished
</code></pre>
<p>You can replace <code>asyncio.ensure_future(long_operation())</code> with just <code>await long_operation()</code> to feel the difference.</p>
</div>
<div class="post-text" itemprop="text">
<h3><code>create_task()</code></h3>
<ul>
<li>accepts coroutines, </li>
<li>returns Task, </li>
<li>it is invoked in context of the loop.</li>
</ul>
<hr/>
<h3><code>ensure_future()</code></h3>
<ul>
<li>accepts Futures, coroutines, awaitable objects,</li>
<li>returns Task (or Future if Future passed). </li>
<li>if the given arg is a coroutine it uses <code>create_task</code>,</li>
<li>loop object can be passed. </li>
</ul>
<p>As you can see the create_task is more specific.</p>
<hr/>
<h3><code>async</code> function without create_task or ensure_future</h3>
<p>Simple invoking <code>async</code> function returns coroutine</p>
<pre><code>&gt;&gt;&gt; async def doit(i):
...     await asyncio.sleep(3)
...     return i
&gt;&gt;&gt; doit(4)   
&lt;coroutine object doit at 0x7f91e8e80ba0&gt;
</code></pre>
<p>And since the <a href="https://hg.python.org/cpython/file/tip/Lib/asyncio/tasks.py#l614" rel="noreferrer"><code>gather</code></a> under the hood ensures (<code>ensure_future</code>) that args are futures, explicitly <code>ensure_future</code> is redundant.</p>
<p>Similar question <a href="https://stackoverflow.com/questions/33980086/whats-the-difference-between-loop-create-task-asyncio-async-ensure-future-and">What's the difference between loop.create_task, asyncio.async/ensure_future and Task?</a></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Note: Only valid for <strong>Python 3.7</strong> (for Python 3.5 refer to the <a href="https://stackoverflow.com/a/36415477/764592">earlier answer</a>).</p>
</blockquote>
<p>From the official docs:</p>
<blockquote>
<p><a href="https://docs.python.org/3.7/library/asyncio-task.html#asyncio.create_task" rel="noreferrer"><code>asyncio.create_task</code></a> (added in Python 3.7) is the preferable way for spawning new tasks instead of <a href="https://docs.python.org/3.7/library/asyncio-future.html#asyncio.ensure_future" rel="noreferrer"><code>ensure_future()</code></a>. </p>
</blockquote>
<hr/>
<h1>Detail:</h1>
<p>So now, in Python 3.7 onwards, there are 2 top-level wrapper function (similar but different):</p>
<ul>
<li><a href="https://docs.python.org/3.7/library/asyncio-task.html#asyncio.create_task" rel="noreferrer"><code>asyncio.create_task</code></a>: which simply call <a href="https://docs.python.org/3.7/library/asyncio-eventloop.html#asyncio.loop.create_task" rel="noreferrer"><code>event_loop.create_task(coro)</code></a> directly. (<a href="https://github.com/python/cpython/blob/v3.7.1/Lib/asyncio/tasks.py#L319-L325" rel="noreferrer">see source code</a>)</li>
<li><a href="https://docs.python.org/3.7/library/asyncio-future.html#asyncio.ensure_future" rel="noreferrer"><code>ensure_future</code></a> which also call <a href="https://docs.python.org/3.7/library/asyncio-eventloop.html#asyncio.loop.create_task" rel="noreferrer"><code>event_loop.create_task(coro)</code></a> if it is coroutine or else it is simply to ensure the return type to be a <a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future" rel="noreferrer">asyncio.Future</a>. (<a href="https://github.com/python/cpython/blob/v3.7.1/Lib/asyncio/tasks.py#L573-L593" rel="noreferrer">see source code</a>). Anyway, <code>Task</code> is still a <code>Future</code> due to its class inheritance (<a href="https://github.com/python/cpython/blob/v3.7.1/Lib/asyncio/tasks.py#L55-L56" rel="noreferrer">ref</a>). </li>
</ul>
<p>Well, utlimately both of these wrapper functions will help you call <a href="https://github.com/python/cpython/blob/v3.7.1/Lib/asyncio/base_events.py#L387-L399" rel="noreferrer"><code>BaseEventLoop.create_task</code></a>. The only difference is <code>ensure_future</code> accept any <a href="https://docs.python.org/3.7/reference/datamodel.html#object.__await__" rel="noreferrer"><code>awaitable</code></a> object and help you convert it into a Future. And also you can provide your own <code>event_loop</code> parameter in <code>ensure_future</code>. And depending if you need those capability or not, you can simply choose which wrapper to use.</p>
</div>
<div class="post-text" itemprop="text">
<p>for your example, all the three types execute asynchronously. the only difference is that, in the third example, you pre-generated all 10 coroutines, and submitted to the loop together. so only the last one gives output randomly.</p>
</div>
<span class="comment-copy">According to Guido, you should use <code>create_task</code> if you really need a a task object, which you normally shouldn't need: <a href="https://github.com/python/asyncio/issues/477#issuecomment-268709555" rel="nofollow noreferrer">github.com/python/asyncio/issues/477#issuecomment-268709555</a></span>
<span class="comment-copy">@bj0 thank you for this link. I updated answer adding information from this discussion.</span>
<span class="comment-copy">does <code>ensure_future</code> automatically adds the created <code>Task</code> to the main event loop?</span>
<span class="comment-copy">@AlQuemist every coroutine, future or task you create is automatically binded to some event loop, where it'll be executed later. By default it is <a href="https://docs.python.org/3/library/asyncio-eventloops.html#asyncio.AbstractEventLoopPolicy.get_event_loop" rel="nofollow noreferrer">current</a> event loop for current thread, but you can specify other event loop using <code>loop</code> keyword argument (<a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future" rel="nofollow noreferrer">see ensure_future signature</a>).</span>
<span class="comment-copy">@laycat we need <code>await</code> within <code>msg()</code> to return control to event loop on second call. Event loop once receive control will be able to start <code>long_operation()</code>. It made to demonstrate how <code>ensure_future</code> starts coroutine to execute concurrently with current execution flow.</span>
<span class="comment-copy">I think there is another difference that is not documented: if you try to call asyncio.create_task before running the loop, you will have a problem since asyncio.create_task is expecting a running loop. You can use asyncio.ensure_future in this case, however, since a running loop is not a requirement.</span>
