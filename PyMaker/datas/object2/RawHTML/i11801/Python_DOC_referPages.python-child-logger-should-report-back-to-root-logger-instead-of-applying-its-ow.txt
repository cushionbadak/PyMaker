<div class="post-text" itemprop="text">
<p>As mentioned here <a href="https://stackoverflow.com/a/4150322/1526342">https://stackoverflow.com/a/4150322/1526342</a>. When logging to child logger, it will pass on the message to its parent, and its parent will pass the message to the root logger.
Now considering the following example</p>
<pre><code>import logging
import logging.handlers
child_logger = logging.getLogger(__name__)
f = logging.Formatter(
        fmt='%(asctime)s; %(name)s; % (filename)s:%(lineno)d:%(message)s',
        datefmt="%Y-%m-%d %H:%M:%S")
handler = logging.handlers.RotatingFileHandler('/tmp/info.log',
                                               encoding='utf8',
                                               maxBytes=500000000,
                                               backupCount=5)
handler.setFormatter(f)
child_logger.setLevel(logging.INFO)
child_logger.addHandler(handler)
child_logger.info('1 + 1 is %d', 1+1)
</code></pre>
<p><code>child_logger</code> should have reported back to the root logger instead of printing the output to the child_logger's log file.</p>
<p>I'm confused.</p>
</div>
<div class="post-text" itemprop="text">
<p>As shown in <a href="https://docs.python.org/3/howto/logging.html#logging-flow" rel="nofollow">this logging flow chart</a>, loggers pass log records both to own handlers <em>and</em> to parent logger objects. Try adding a handler to the parent logger, you'll see the log record is being processed there as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>In this case, your 'child_logger' is your root logger. If you had initialized it like so:</p>
<pre><code>logger = getLogger('root')
child_logger = getLogger('root.child')
</code></pre>
<p><code>child_logger</code> is a child of <code>logger</code> as defined by:</p>
<blockquote>
<p>The name is potentially a period-separated hierarchical value, like foo.bar.baz (though it could also be just plain foo, for example). Loggers that are further down in the hierarchical list are children of loggers higher up in the list. For example, given a logger with a name of foo, loggers with names of foo.bar, foo.bar.baz, and foo.bam are all descendants of foo. The logger name hierarchy is analogous to the Python package hierarchy, and identical to it if you organise your loggers on a per-module basis using the recommended construction logging.getLogger(<code>__name__</code>). That’s because in a module, <code>__name__</code> is the module’s name in the Python package namespace.</p>
</blockquote>
<p>If you do not want a child to propogate, you can set <a href="https://docs.python.org/2/library/logging.html#logging.Logger.propagate" rel="nofollow"><code>logger.propagate</code></a> = <code>False</code>.</p>
<p>Furthermore, if you would like only certain levels written to your child logger file (i.e. only debug) but you want higher level to still propagate, you could create a subclass of a handler, as in mine here:</p>
<pre><code>from logging import DEBUG, INFO, WARN, ERROR, CRITICAL, handlers

class DebugRotatingFileHandler(handlers.RotatingFileHandler):
    def __init__(self, filename, mode, maxBytes, backupCount, encoding, delay):
        super(DebugRotatingFileHandler, self).__init__(
                  self, filename, mode, maxBytes, backupCount, encoding, delay)

    def emit(self, record):
        if record.levelno != DEBUG:
            return
        super(DebugRotatingFileHandler, self).emit(self, record)
</code></pre>
<p>(Yes, I know there are some improvements that can be made, this is old code.)</p>
<p>For example, executing <code>debug_logger.info("Info Message")</code> would print nothing to the debug_logger's specified file, however, if <code>root_logger</code>'s level was set to info, or debug, it would print it out in it's file. I use this for debug logging, whilst still retaining the ability to have the logger make error message calls and print those to the root log.</p>
</div>
