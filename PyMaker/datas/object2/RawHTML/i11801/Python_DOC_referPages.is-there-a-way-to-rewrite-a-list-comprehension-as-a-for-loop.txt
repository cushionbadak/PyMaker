<div class="post-text" itemprop="text">
<p>I have a line of code like this:</p>
<pre><code>list1=[string1[i:i+int1] for i in range(0, len(string1), int1)]
</code></pre>
<p>I remember my teacher saying that we should start new lines when there is 'for'
so, is there a way to write this code that looks like:</p>
<pre><code>for i in range(0, len(string1), int1):
    #something here
</code></pre>
<p>or something else?</p>
</div>
<div class="post-text" itemprop="text">
<p>You mean to extract a boring old regular <a href="https://wiki.python.org/moin/ForLoop" rel="nofollow"><code>for loop</code></a> from a <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow"><code>list-comprehension</code></a>?</p>
<pre><code>list1=[string1[i:i+int1] for i in range(0, len(string1), int1)]
</code></pre>
<p>Becomes:</p>
<pre><code>list1 = list()
for i in range(0, len(string1), int1):
    list1.append(string1[i:i+int1])
</code></pre>
<p>This would be useful if you wanted to add exception handling, logging, or more complex functions or behaviors while you iterate over your data.</p>
<p>For instance:</p>
<pre><code>list1 = list()
for i in range(0, len(string1), int1):
    log.info('in loop: i={}'.format(i))
    try:
        data = string1[i:i+int1]
    except:
        log.error('oh no!')
        # maybe do something complex here to get some data anyway?
        data = complex_function(i)
    log.debug('appending to list: data={}'.format(data))
    list1.append(data)
</code></pre>
<p>But generally speaking the list-comprehension is a totally legitimate way to write that.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to create the empty list first, and then append for each iteration.</p>
<pre><code>list1 = []
for i in range(0, len(string1), int1):
    list1.append(string1[i:i+int1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That list comprehension would translate to:</p>
<pre><code>l = []
for i in range(0, len(string1), int1):
    l.append(string1[i:i+int1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Little bit dirty, but a good alternative for splitting collection to subcollections of a fixed size.</p>
<pre><code>from itertools import zip_longest

l = []
for chunk in zip_longest(*([iter(string1)]*int1), fillvalue=''):
    l.append(''.join(chunk))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>g = (string[i:i+int1] for i,char in enumerate(string) if i % int1 == 0)
l = list(g)
</code></pre>
<p><strong>Do not</strong> use <code>len(iterable)</code> in the while dealing with indices. Use <code>enumerate()</code> for that. It yields <code>(index, item)</code>. This is efficient and pythonic. </p>
<p>The idea that you should make a newline while using <code>for</code> loop is probably idiomatic to some other language, C, C++ e.g. But not in python. List comprehensions come fro the Haskell world of FP. So that's elegant as they come.</p>
</div>
<span class="comment-copy">Please read about <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehensions</a>.</span>
<span class="comment-copy">Your teacher's advice is an oversimplification. You should start a new line when there is a for <i>statement</i>, but a <code>for</code> inside of an expression isn't part of a for statement; it's part of a list comprehension.</span>
<span class="comment-copy">I'm almost certain your teacher didn't mean you should forgo all <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehensions</a> in favor of explicitly <code>for</code> loops that build a <code>list</code> piecemeal. If they did, they aren't really teaching you Python.</span>
<span class="comment-copy">No doubt your teacher was trying to simplify things. I'll update your title to the question that you're actually asking here.</span>
<span class="comment-copy">alternatively, one could write a function and do <code>[somefunction(val) for val in values]</code>. Assuming that was appropriate for the case, of course. As another potentially appropriate alternative, rather than returning a list, one could <code>yield data</code> and get a generator out of the deal.</span>
<span class="comment-copy"><code>[]</code> is more efficient than <code>list()</code>.  See <a href="https://stackoverflow.com/questions/30216000/why-is-faster-than-list/30216156#30216156">why</a></span>
<span class="comment-copy">@zondo: Also conveniently avoids the problem of people name-shadowing <code>list</code>, though ideally, they wouldn't do that in the first place. :-) That said, the incremental cost of <code>list()</code> over <code>[]</code> is pretty small, about 60-70 extra ns on my machine (admittedly an increase of 2-3.5x over the base cost of <code>[]</code> of ~20-30 ns, but unlikely to matter in all but the hottest of loops).</span>
<span class="comment-copy">I'd add readability to that. <code>something = []</code> is more immediately recognisable than <code>something = list()</code> to me.</span>
