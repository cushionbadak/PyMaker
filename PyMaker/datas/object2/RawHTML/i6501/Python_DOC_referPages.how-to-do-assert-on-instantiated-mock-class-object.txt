<div class="post-text" itemprop="text">
<p>In the constructor of my class under test a socket object is instantiated and assigned to a class member. I mocked the socket class and set a mocked socket object as return value to the socket constructor call. I then want to assert that connect() and sendall() is called on that object. I always get the assert error that the functions are not called when I assert on the original mocked class object or the one that I set to return on constructor call.</p>
<p>I know I canâ€™t mock the class that is under test (and its members) because that would defeat the purpose here. </p>
<p>Pseudo code:</p>
<pre><code>import socket

Class socketHandler():
    def __init__(...):
    self.mySocket = socket(...)
    ...
    self.mySocket.connect(...)

    def write(message):
        self.mySocket.sendall(message)
</code></pre>
<p>Test:</p>
<pre><code>from unittest import mock
from unittest.mock import MagicMock #not sure if i need this
import pytest
import socketHandler

@mock.patch(socketHandler.socket)
def test_socket_handler(mockSocket):
    ...
    new_sock = mock_socket()
    mock_socket.return_value = new_sock

    mySocketHandler = SocketHandler(...)

    mock_socket.socket.assert_called_with(...)
    new_sock.connect.assert_called_with(...) #fails (never called)
    mock_socket.connect.assert_called_with(...) #fails (never called)
    #likewise for the sendall() method call when mysocketHandler.write(..)
    #is called
</code></pre>
<p>The purpose of this test is:</p>
<ol>
<li><p>ensure the constructor of socket library is called with the right arguments.</p></li>
<li><p>ensure that connect() is called with right arguments.</p></li>
<li><p>ensure that sendall() is called with exactly what I want it to be called, when I pass message into mySocketHandler.write() method.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The complete answer derived from hints given by @ryanh119 and this post <a href="https://stackoverflow.com/questions/31864168/mocking-a-socket-connection-in-python" title="link">link</a></p>
<p>I will fix the example given above by ryanh119 and refrain from editing original question which i messed up, so for completeness:</p>
<pre><code>from unittest import mock
import pytest
import socketHandler

@mock.patch("app_directory.socketHandler.socket")
def test_socket_handler(mockSocketClass):

# mockSocketClass is already a mock, so we can call production right away.
mySocketHandler = SocketHandler(...)

# Constructor of mockSocketClass was called, since the class was imported
#like: import socket we need to:
mockSocketClass.socket.assert_called_with(...)

# Production called connect on the class instance variable
# which is a mock so we can check it directly.
# so lets just access the instance variable sock
mySocketHandler.mySocket.connect.assert_called_with(...)

# The same goes for the sendall call:
mySocketHandler.mySocket.sendall.assert_called_with(expectedMessage)
</code></pre>
<p>I also did some research and there would have been two more solutions that I want to mention. They are not as pythonicaly correct like the above ones but here it is:</p>
<ol>
<li>Make use of dependency injection by changing the <code>__init__</code> of socketHandler to take in a socket object and only instantiate it if not supplied in the args. That way i could have passed in a mock or MagicMock object and used that to do the asserts on.</li>
<li>Make use of a extremely powerful mocking/patching tool called <a href="https://docs.pytest.org/en/latest/monkeypatch.html" rel="nofollow noreferrer">MonkeyPatch</a> which actually can patch/mock instance variables of classes. This approach would have been like trying to kill a fly with a rocket launcher.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You're on the right track, but there are a couple things that need to change for this test to work.</p>
<p>Part of your problem right off the bat is that the mock that <code>patch</code> passes into your test method is called <code>mockSocket</code>, but your test code is referring to something called <code>mock_socket</code>.</p>
<p>Also, <code>patch</code>'s first argument, the thing you want to patch, should be a <em>string representation</em> of the path to the module where you want to patch something. If your file structure looks like this:</p>
<pre><code>|-- root_directory
|   |
|   |-- app_directory
|   |   |-- socketHandler.py
|   |   `-- somethingElse.py
|   |
|   `-- test_directory
|       |-- testSocketHandler.py
|       `-- testSomethingElse.py
</code></pre>
<p>and you run your tests from the root directory, you'd want to call patch like this: <code>@mock.patch("app_directory.socketHandler.socket")</code></p>
<ol>
<li><p>Constructor is called - The most important thing to realize is that <code>mockSocket</code> is a <code>Mock</code> object representing the socket <em>class</em>. So to test that the constructor was called, you need to check <code>mockSocket.assert_called_with(...)</code>. That will pass if your production calls <code>socket(...)</code>.</p>
<p>You may also want to assert that <code>mySocketHandler.socket</code> is the same object as <code>mockSocket.return_value</code>, to test that mySocketHandler not only calls the constructor, but assigns it to the right attribute.</p></li>
<li><p>and 3. <code>connect</code> and <code>sendall</code> are called properly - You should never call your mock in a test, because it can lead to falsely-passing assertions. In other words, you want your production code to be the only thing calling mocks. This means you shouldn't use the line <code>new_sock = mock_socket()</code>, because then your previous assertion about the constructor will pass no matter what your production code does, and I think it's causing your other assertions to fail.</p>
<p><code>mockSocket</code>is already an instance of <code>Mock</code>, so it's return value will automatically be another, different <code>Mock</code> instance. Therefore, you don't need the first 2 lines of your test code above, and you only need one of the assertions on <code>connect</code>. The same ideas apply to <code>sendall</code>.</p></li>
</ol>
<p>That's a lot to take in, here's what your test would look like if I wrote it:</p>
<pre><code>from unittest import mock
import pytest
import socketHandler

@mock.patch("app_directory.socketHandler.socket")
def test_socket_handler(mockSocketClass): # renamed this variable to clarify that it's a mock of a class.

    # mockSocketClass is already a mock, so we can call production right away.
    mySocketHandler = SocketHandler(...)

    # Constructor of mockSocketClass was called
    mockSocketClass.assert_called_with(...)

    # Instance of mockSocketClass was assigned to correct attribute on SocketHandler
    self.assertIs(mockSocketClass.return_value, mySocketHandler.socket)

    # Production called connect on the return_value of the mock module, i.e. the instance of socket.
    mockSocketClass.return_value.connect.assert_called_with(...)

    # If SocketHandler's constructor calls sendall:
    mockSocketClass.return_value.sendall.assert_called_with(expectedMessage)
</code></pre>
<p>Bonus Round! <code>MagicMock</code>s behave like <code>Mock</code>s, except that they implement some default values for <a href="https://docs.python.org/3/library/unittest.mock.html?highlight=magicmock#unittest.mock.MagicMock" rel="nofollow noreferrer">some magic methods</a>. I don't use them unless I absolutely need them. Here's an example:</p>
<pre><code>from mock import Mock, MagicMock

mock = Mock()
magic_mock = MagicMock()

int(mock)
&gt;&gt;&gt;Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: int() argument must be a string or a number, not 'Mock'

len(mock)
&gt;&gt;&gt;Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: object of type 'Mock' has no len()

int(magic_mock)
&gt;&gt;&gt; 1

len(magic_mock)
&gt;&gt;&gt; 0
</code></pre>
</div>
<span class="comment-copy">Thanks for your answer. It was not entirely correct but it helped me in finding the right answer. Sorry for my syntax mistakes, however:</span>
<span class="comment-copy">1. You defined a method so you cant use references to self, assertIs is a method from the unittest.TestCase class! 2. mockSocketClass.return_value.connect.assert_called_with(...) was never called when I tried your code.   Why not use MagicMock? Their autospec or spec ability make them very useful.</span>
<span class="comment-copy">Sorry, I assumed you were using unittest.TestCase and had omitted it from your code.  You can use spec with <code>Mock</code> as well. I avoid them because I rarely need any magic methods defined for me, and I don't want my tests to pass when they shouldn't because I forgot to override a magic method on a <code>MagicMock</code></span>
