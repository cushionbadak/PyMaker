<div class="post-text" itemprop="text">
<p>I am trying to create a dictionary with two strings as a key and I want the keys to be in whatever order.</p>
<pre><code>myDict[('A', 'B')] = 'something'
myDict[('B', 'A')] = 'something else'
print(myDict[('A', 'B')])
</code></pre>
<p>I want this piece of code to print 'something else'. Unfortunately, it seems that the ordering matters with tuples. What would be the best data structure to use as the key?</p>
</div>
<div class="post-text" itemprop="text">
<h1>Use a <a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow noreferrer"><code>frozenset</code></a></h1>
<p>Instead of a <code>tuple</code>, which is ordered, you can use a <code>frozenset</code>, which is <em>unordered</em>, while still <em>hashable</em> as <code>frozenset</code> is <em>immutable</em>.</p>
<pre><code>myDict = {}
myDict[frozenset(('A', 'B'))] = 'something'
myDict[frozenset(('B', 'A'))] = 'something else'
print(myDict[frozenset(('A', 'B'))])
</code></pre>
<p>Which will print:</p>
<pre><code>something else
</code></pre>
<hr/>
<hr/>
<p>Unfortunately, this simplicity comes with a disadvantage, since <code>frozenset</code> is basically a “frozen” set. There will be no duplicate values in the <code>frozenset</code>, for example, </p>
<pre><code>frozenset((1, 2)) == frozenset((1,2,2,1,1))
</code></pre>
<p>If the trimming down of values doesn’t bother you, feel free to use <code>frozenset</code></p>
<p>But if you’re 100% sure that you don’t want what was mentioned above to happen, there are however two alternates:</p>
<hr/>
<p><em>First</em> method is to use a <code>Counter</code>, and make it <code>hashable</code> by using <code>frozenset</code> again: (<strong>Note: everything in the tuple must be <em>hashable</em></strong>)</p>
<pre><code>from collections import Counter

myDict = {}
myDict[frozenset(Counter(('A', 'B')).items())] = 'something'
myDict[frozenset(Counter(('B', 'A')).items())] = 'something else'
print(myDict[frozenset(Counter(('A', 'B')).items())])

# something else
</code></pre>
<hr/>
<p><em>Second</em> method is to use the built-in function <code>sorted</code>, and make it <em>hashable</em> by making it a <code>tuple</code>. This will sort the values before being used as a key: (<strong>Note: everything in the tuple must be <em>sortable</em> and <em>hashable</em></strong>)</p>
<pre><code>myDict = {}
myDict[tuple(sorted(('A', 'B')))] = 'something'
myDict[tuple(sorted(('B', 'A')))] = 'something else'
print(myDict[tuple(sorted(('A', 'B')))])

# something else
</code></pre>
<p>But if the tuple elements are neither all <em>hashable</em>, nor are they all <em>sortable</em>, unfortunately, you might be out of luck and need to create your own dict structure... D:</p>
</div>
<div class="post-text" itemprop="text">
<p>You can build your own structure:</p>
<pre><code>class ReverseDict:
   def __init__(self):
      self.d = {}
   def __setitem__(self, k, v):
      self.d[k] = v

   def __getitem__(self, tup):
      return self.d[tup[::-1]]

myDict = ReverseDict()
myDict[('A', 'B')] = 'something'
myDict[('B', 'A')] = 'something else'
print(myDict[('A', 'B')])
</code></pre>
<p>Output:</p>
<pre><code>something else
</code></pre>
</div>
<span class="comment-copy">Why would you expect it to print that? <code>('A', 'B')</code> is mapped to <code>something</code></span>
<span class="comment-copy">If you want it to print <code>something else</code> then try <code>print(myDict[('B','A')])</code></span>
<span class="comment-copy">Well yeah, I do not expect it, but I want to use a data structure other than tuple which enables me to do that.</span>
<span class="comment-copy">How would it know whether to choose <code>something</code> or <code>something else</code> then? Keys must be unique</span>
<span class="comment-copy">In other words - there is no way in Python to have the data structure omit the element ordering?</span>
<span class="comment-copy">Your <code>frozenset(Counter(…))</code> code is wrong: <code>frozenset(Counter('abc'))</code>, <code>frozenset(Counter('abbccc'))</code>, and <code>frozenset(('a', 'b', 'c'))</code> are all equal. You want <code>frozenset(Counter(xs).iteritems())</code> (<code>.items()</code> in Python 3).</span>
<span class="comment-copy">Also, if the elements aren't hashable, then <code>tuple(sorted(xs))</code> will still not be a valid key, because it won't itself be hashable: if <code>xs == [[1], [2]]</code>, for example, then <code>tuple(sorted(xs)) == ([1], [2])</code>, which also yields an error when you use it as a key. It kind of sounds like what you're trying to say is <code>json.dumps(xs, sort_keys=True)</code>, but honestly I can't imagine a situation where marshalling live objects to keys every time that you want to look them up in a dictionary is a good idea.</span>
