<div class="post-text" itemprop="text">
<p>I have a big <code>poems.csv</code> file with entries like this:</p>
<pre><code>"
this is a good poem. 
",1

"  
this is a bad poem.    
",0

"
this is a good poem. 
",1

"  
this is a bad poem.    
",0
</code></pre>
<p>and I would like to remove duplicates from it:</p>
<p>If the file did not have the binary classifier I could just remove duplicate lines, like this:</p>
<pre><code>with open(data_in,'r') as in_file, open(data_out,'w') as out_file:
    seen = set() # set for fast O(1) amortized lookup
    for line in in_file:
        if line in seen: continue # skip duplicate
        seen.add(line)
        out_file.write(line)
</code></pre>
<p>But this would remove all classification as well. How do I remove duplicate entries  keeping <code>0s</code> and <code>1s</code>?</p>
<p>expected output:</p>
<pre><code>"
this is a good poem. 
",1

"  
this is a bad poem.    
",0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can easily add both portions of the line to the set. Assuming your "line" consists of a string and an integer (or two strings), a <a href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="nofollow noreferrer"><code>tuple</code></a> of both elements can be a valid <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer"><code>set</code></a> element. <code>tuple</code> is immutable, and therefore hashable, and can be added to a <code>set</code>.</p>
<p>Splitting the line would be much easier using the <a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow noreferrer"><code>csv.reader</code></a> class, since it would allow you to read multiline poems as a single line, etc.</p>
<pre>
<b>import csv</b>

with open(data_in, 'r'<b>, newline=''</b>) as in_file, open(data_out, 'w'<b>, newline=''</b>) as out_file:
    <b>reader = csv.reader(in_file)
    writer = csv.writer(out_file)</b>
    seen = set() # set for fast O(1) amortized lookup
    for <b>row in reader</b>:
        <b>row = tuple(row)</b>
        if <b>row</b> in seen: continue # skip duplicate
        seen.add(<b>row</b>)
        <b>writer</b>.write<b>row</b>(<b>row</b>)
</pre>
<p>Since you definitely have a bunch of multiline values in your file, using <code>newline=''</code> is crucial for both input and output because it delegates line splitting to the <code>csv</code> classes.</p>
<p>The advantage of doing it this way over using pandas or another library that preloads the entire file is that it avoids loading more than one duplicate poem into memory at one time. One copy of each poem will be retained in the <code>set</code>, but for a very large file with a lot of duplicates, this solution is much closer to optimal.</p>
<p>We can test with the following file:</p>
<pre><code>"Error 404:
Your Haiku could not be found.
Try again later.", 0
"Error 404:
Your Haiku could not be found.
Try again later.", 1
"Error 404:
Your Haiku could not be found.
Try again later.", 0
"Error 404:
Your Haiku could not be found.
Try again later.", 1
</code></pre>
<p>The output is as follows:</p>
<pre><code>"Error 404:
Your Haiku could not be found.
Try again later.", 0
"Error 404:
Your Haiku could not be found.
Try again later.", 1
</code></pre>
<p><strong>Note about Python 2</strong></p>
<p>The argument <code>newline</code> does not exist in the Python 2 version of <a href="https://docs.python.org/2/library/functions.html#open" rel="nofollow noreferrer"><code>open</code></a>. This is not going to be a problem on most operating systems since line endings will be internally consistent between the input and output files. Rather than specifying <code>newline=''</code>, the Python 2 version of <a href="https://docs.python.org/2/library/csv.html" rel="nofollow noreferrer"><code>csv</code></a> requests that files be opened with binary mode.</p>
<p><strong>UPDATE</strong></p>
<p>You have indicated that the behavior of your own answer is not 100% correct. It appears that your data makes it a perfectly valid approach, so I am retaining the previous portion of my answer.</p>
<p>To be able to filter only by poem, ignoring (but preserving) the binary classifier of the first occurrence, you don't need to change much in your code:</p>
<pre><code>import csv

with open(data_in, 'r', newline='') as in_file, open(data_out, 'w', newline='') as out_file:
    reader = csv.reader(in_file)
    writer = csv.writer(out_file)
    seen = set() # set for fast O(1) amortized lookup
    for row in reader:
        if row[0] in seen: continue # skip duplicate
        seen.add(row[0])
        writer.writerow(row)
</code></pre>
<p>Since the zero classifier appears first in the file, the output for the test case above would be:</p>
<pre><code>"Error 404:
Your Haiku could not be found.
Try again later.", 0
</code></pre>
<p>I mentioned in the comments that you can also retain either the last seen classifier or always a one if it is found. For both of these options, I would recommend using a <a href="https://docs.python.org/3/library/stdtypes.html#typesmapping" rel="nofollow noreferrer"><code>dict</code></a> (or and <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a> if you want to preserve the original order of the poems) keyed by the poem, with the value being the classifier. A dictionary's keys are basically a <code>set</code>. You would also end up writing the output file after you load the entire input file.</p>
<p>To retain the last classifier seen:</p>
<pre><code>import csv
from collections import OrderedDict

with open(data_in, 'r', newline='') as in_file:
    reader = csv.reader(in_file)
    writer = csv.writer(out_file)
    seen = OrderedDict() # map for fast O(1) amortized lookup
    for poem, classifier in reader:
        seen[poem] = classifier # Always update to get the latest classifier

with open(data_out, 'w', newline='') as out_file:
    for row in seen.items():
        writer.writerow(row)
</code></pre>
<p><code>seen.items()</code> iterates over tuples containing the key (poem) and value (classifier), which happens to be exactly what you want to write to the file.</p>
<p>The output from this version will have a one classifier since that appears last in the test input above:</p>
<pre><code>"Error 404:
Your Haiku could not be found.
Try again later.", 1
</code></pre>
<p>A similar approach will work to retain a 1 classifier if it exists:</p>
<pre><code>import csv
from collections import OrderedDict

with open(data_in, 'r', newline='') as in_file:
    reader = csv.reader(in_file)
    writer = csv.writer(out_file)
    seen = OrderedDict() # map for fast O(1) amortized lookup
    for poem, classifier in reader:
        if poem not in seen or classifier == '1'
            seen[poem] = classifier

with open(data_out, 'w', newline='') as out_file:
    for row in seen.items():
        writer.writerow(row)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>pandas as pd</code> solved it:</p>
<pre><code>raw_data = pd.read_csv(data_in)
clean_data = raw_data.drop_duplicates()
clean_data.to_csv(data_out)
</code></pre>
</div>
<span class="comment-copy">Also, just to clarify, are two identical poems with different binary classifiers considered to be different? Your own answer seems to support this, but I would like to confirm.</span>
<span class="comment-copy">no, identical entries have always the same classifier here</span>
<span class="comment-copy">Could you give an example of expected input and output? It's hard to know exactly what you want to discard when you only show one row and no expected output.</span>
<span class="comment-copy">I've provided an example input you can use if you wish.</span>
<span class="comment-copy">thank you, your example is perfect. my data is structured the same way.</span>
<span class="comment-copy">The <a href="https://docs.python.org/2/library/csv.html#module-contents" rel="nofollow noreferrer">docs</a> don't mention this at all. I think you'll be fine without <code>newline=''</code> if you are on an OS that has single-character line endings.</span>
<span class="comment-copy">Note that's an empty string, not a space.</span>
<span class="comment-copy">Also , an upvote would be nice</span>
<span class="comment-copy">you got it, thanks</span>
<span class="comment-copy">very broad and complete answer. I would upvote it twice if I could.</span>
<span class="comment-copy">Python should remove the csv library and refer to pandas (my opinion!) :)</span>
<span class="comment-copy">@Anton. That comment makes no sense. The two libraries serve very different purposes. That's like telling a carpenter to get rid of his saw because he has a drill.</span>
