<div class="post-text" itemprop="text">
<p>The Python standard library's <a href="https://docs.python.org/3/library/socket.html#socket.create_connection" rel="nofollow noreferrer"><code>socket</code><strong><code>.create_connection()</code></strong></a>method has a source address option, for controlling which source IP a connection uses.  </p>
<p>How do I do the same thing with a Python ZeroMQ socket, given a machine that has multiple addresses?</p>
<p>In this case, I've been using Linux's iproute2 <code>ip addr add</code> to create the addresses and the ZeroMQ <code>PUB/SUB</code> socket-archetypes.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Well, ZeroMQ is a bit tricky to read as a <code>socket</code>-"counterparty"<sup> ( it's not )</sup></h2>
<p>Why?</p>
<p>Classical <code>socket</code> is a free-to-harness resource.</p>
<p>ZeroMQ is a rather complex hierarchy of ideas and principles of behaviours ( better - distributed behaviours ), that help design smart distributed computing systems, without touching the low-level ( ZeroMQ well abstracted ) details, that control the actual flow of events in the storms of harsh conditions all distributed computing systems are open to face ( and have to handle at low level accordingly, if the high-level abstractions "promised" by ZeroMQ to keep are to be fulfilled and ease the designers' minds to focus rather on his/her core application part, not re-designing wheels ( with all trials and errors ) on pulling strings on O/S resources and shaking systems services for collecting just a few low-hanging types of fruits ).</p>
<hr/>
<p>For these reasons <strong>better straight forget ZeroMQ to be "<em>something-like-</em><code>socket</code>"</strong></p>
<hr/>
<h2>ZeroMQ hierarchy in less than a five seconds</h2>
<p><strong>1:</strong><br/>
ZeroMQ promises an easy re-use of a few trivial Scalable Formal Communication Pattern <strong>archetypes</strong> offering a particular distributed behaviour <code>{ PUB/SUB | PUSH/PULL | PAIR/PAIR | XPUB/XSUB | ... | REQ/REP }</code>.</p>
<p><strong>2:</strong><br/>
Except a case of exclusively using just a <em>device-less</em> <strong><code>inproc://</code></strong> transport-class, in all other cases, ZeroMQ needs one or more instances of a tunable "<strong>engine</strong>" - a <strong><code>Context( nIOthreads = N )</code></strong>, <code>N &gt;= 1</code>.</p>
<p><strong>3:</strong><br/>
Having this, any ( future <em>socket</em> ) <strong>Access Point</strong> could get instantiated, bearing a behavioural archetype since the very moment of birth:</p>
<pre><code>aSubscribeCHANNEL = aLocalCONTEXT.socket( zmq.SUB )      # this is NOT a &lt;SOCKET&gt;
#                                 ^^^^^^__________________ even it was typed in
</code></pre>
<p><strong>4:</strong><br/>
Having an "<em>Access Point</em>" instance ready "inside" the local "<em>engine</em>", one can lock-in its materialisation in the external-reality, using one or more ( yes, more ... WOW! Meaning more incoming pulling-strings into / whistles blowing out from a single Access Point "behaviour-node" ) calls to either of these methods:<br/>
<strong><code>.bind(</code></strong> <code>&lt;transport-class&gt;://&lt;a-class-specific-address&gt;</code> <strong><code>)</code></strong><br/>
or<br/>
<strong><code>.connect(</code></strong> <code>&lt;transport-class&gt;://&lt;a-class-specific-address&gt;</code> <strong><code>)</code></strong> </p>
<p><strong>5:</strong><br/>
If and only if a <code>.bind()</code>-RTO-ready Access Point A "<strong>gets visited</strong>" by a first live <code>.connect()</code>-RTO-ready Access Point B, having any matching behaviour pairing, the ZeroMQ-messaging/signalling archetype gets live ( naming it also a <em>socket</em> was probably used for historical reasons, to ease an explanation in times )</p>
<p><sub> ( <code>PUB/PUB</code> will never fit, for obvious reasons, whereas <code>PUB/SUB</code> and many other behaviour-archetype pairs will and do lovely match and form the mutually-"compatible"-behaviours that will finally go live and stay so ) </sub></p>
<hr/>
<h2>So,<br/>how do I do the same thing with a Python ZeroMQ socket,<br/>given a machine that has multiple addresses?</h2>
<p>Simply use the fully qualified specification in a call to<br/>
<strong><code>.bind(</code></strong> <code>"{ tcp | pgm | epgm }://&lt;ip&gt;:&lt;port#&gt;"</code> <strong><code>)</code></strong> method and you are done.</p>
<p>That easy.</p>
<p>Cool, isn't it?</p>
<p><sub>Many further pleasant surprises under the hood of performance tuning, latency shaving and security tweaking.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>When trying to <strong><code>.connect()</code></strong> to a remote, I found the answer in the <a href="http://api.zeromq.org/4-1:zmq-tcp" rel="nofollow noreferrer">protocol documentation</a>, put the source ip before a semicolon in the connect string:</p>
<pre><code>rc = zmq_connect( socket, "tcp://192.168.1.17:5555;192.168.1.1:5555" )
</code></pre>
<p>In Python, this looks like:</p>
<pre><code>socket = zmq.Context().socket( zmq.SUB )
socket.connect( 'tcp://192.168.1.17:5555;192.168.1.1:5555' )
</code></pre>
</div>
<span class="comment-copy">I don't think I fully understand the problem you're trying to solve ... it the interfaces have specific subnets on them the routing should decide where to egress, and if they don't does it really matter which one gets picked?</span>
<span class="comment-copy">I'm testing layer 3 load balancing, so the source IP address determines where traffic ends up.</span>
<span class="comment-copy">This answer is very helpful, but it turns out my question was not quite clear: I need to bind the source ip for the other end of the connection, in the connect method.  I've added an answer to that effect and upvoted this.</span>
<span class="comment-copy">Glad you have found it helpful. The <code>.connect()</code> works the same way as <code>.bind()</code>-method does. The important and cool thing is, that one [<b>Access Point</b>] can <code>.connect( "tcp://&lt;address&gt;:&lt;port&gt;" )</code> and also <code>.connect( "vmci://@:&lt;port&gt;" )</code> and also <code>.connect( "ipc://&lt;address_identifier&gt;" )</code> and operate all these established connections under the same [<b>Access Point</b>]'s model of a Formal Communication Behaviour. <b>That was the reason to elaborate all details above</b>, to start to realise how different the ZeroMQ-sockets are and what immense powers they bring for advanced distributed systems.</span>
<span class="comment-copy">A semicolon-separated list expansion is rather a side-effect of the "hidden" API feature of the ZeroMQ core. It functionally creates the same thing as a sequence of calls to the <code>.connect()</code>-method, irrespective whether the first was using a <code>tcp://</code> <i>transport-class</i> and the other an <code>epgm://</code> one, as explained above.</span>
