<div class="post-text" itemprop="text">
<p>By implementing the line </p>
<pre><code>start_time = time.time()
</code></pre>
<p>at the start of my code and </p>
<pre><code>print("%f seconds" % (time.time() - start_time))
</code></pre>
<p>at the end of my code I have been measuring the performance of my script (which can take hours to run). I have heard that this may not be the best method due to it being inaccurate. How accurate is it and is there a better alternative?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this, timeit from the standard library:</p>
<pre><code>from timeit import default_timer as timer
start_time = timer()
end_time = timer()    
print(end_time - start_time)                                                                                                                                           
logger.info("Duration was {}".format(end_time - start_time)) 
</code></pre>
<p>The documentation for default_timer is of interest, and should really be quoted in the answer: "Define a default timer, in a platform-specific manner. On Windows, time.clock() has microsecond granularity, but time.time()’s granularity is 1/60th of a second. On Unix, time.clock() has 1/100th of a second granularity, and time.time() is much more precise. On either platform, default_timer() measures wall clock time, not the CPU time. This means that other processes running on the same computer may interfere with the timing." </p>
</div>
<div class="post-text" itemprop="text">
<p>Try usng datetime</p>
<pre><code>from datetime import datetime
startTime = datetime.now()
#CODE
print("Time taken:",datetime.now() - startTime)
</code></pre>
</div>
<span class="comment-copy">On a time-scale of hours, any subsecond accuracy seems irrelevant. How accurate do you want your timings to be?</span>
<span class="comment-copy">Disregard that figure. I came for recommendations of the best method. Cheers</span>
<span class="comment-copy">The "best method" is somewhat subjective. The best method may cost $200K, and may thus not be the best method for your wallet. Also, do you want to measure wall-clock time, CPU time? Please make your question more practical.</span>
<span class="comment-copy">Good point. Sorry for my vagueness.</span>
<span class="comment-copy"><code>datetime.datetime</code> instances have a <code>microsecond</code> attribute that will be used if you use <code>datetime.datetime.now()</code>. So do <code>timedelta</code> instances.The accuracy of <code>time.time()</code> is OS dependent—on some it's less than 1 second.</span>
<span class="comment-copy">Could you specify why this is a better option regarding accuracy? Thanks</span>
<span class="comment-copy">The documentation for <code>default_timer</code> is of interest, and should really be quoted in the answer: "Define a default timer, in a platform-specific manner. On Windows, time.clock() has microsecond granularity, but time.time()’s granularity is 1/60th of a second. On Unix, time.clock() has 1/100th of a second granularity, and time.time() is much more precise. On either platform, default_timer() measures wall clock time, not the CPU time. This means that other processes running on the same computer may interfere with the timing."</span>
<span class="comment-copy">Awesome thanks for that. I will edit your answer and accept it.</span>
<span class="comment-copy">Could you specify why this is a better option regarding accuracy? Thanks</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/datetime.html" rel="nofollow noreferrer">docs.python.org/3/library/datetime.html</a></span>
