<div class="post-text" itemprop="text">
<p>As we know in Python 3 <code>print()</code> is a function, is it possible to create a decorated version of it wrapped under <code>json.dumps(indent=4)</code></p>
<p>for ex.</p>
<p>Calling <code>print(mydict)</code> should produce the same result as <code>print(json.dumps(mydict, indent=4))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need a decorator per se to do that.  Just define a new function and call it <code>print</code>:</p>
<pre><code>import builtins

def print(*args, **kwargs):
    builtins.print(json.dumps(*args, **kwargs, indent=4))
</code></pre>
<p>You can use the <code>builtins</code> module as shown to access the original print function.</p>
<p>The thing is that doing this doesn't really gain anything over calling your new function something besides <code>print</code>, except it will confuse people.</p>
<p>If you want to <em>really</em> confuse people you could store <code>old_print = builtins.print</code>, define your new function as <code>my_print</code> (accessing the original as <code>old_print</code>) and then do <code>builtins.print = my_print</code>.  Then your modified <code>print</code> will actually replace the regular <code>print</code>, even in other modules that know nothing about your shenanigans.  But that is an even worse idea.</p>
</div>
<div class="post-text" itemprop="text">
<p>Alternatively, take a look at pprint.
<a href="https://docs.python.org/3/library/pprint.html" rel="nofollow noreferrer">https://docs.python.org/3/library/pprint.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to @Adam Smith for this <a href="https://gist.github.com/anonymous/c6ee1be4befc1c38d34cd02553b31945" rel="nofollow noreferrer">gist</a>, posting it here for a reference. </p>
<pre><code>import builtins
import functools
import json

orig_print = builtins.print

def indent4(f):
    @functools.wraps(f)
    def wrapped(*args, **kwargs):
        return f(json.dumps(*args, **kwargs, indent=4))
    return wrapped

@indent4
def print(*args, **kwargs):
    return orig_print(*args, **kwargs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, it's not possible since <code>print</code> is a builtin function and it's not even a builtin C-level class. <a href="https://stackoverflow.com/questions/12476402/is-it-possible-to-apply-my-own-decorators-to-builtin-methods-in-python">This answer</a> provides a way to subclass a builtin object like a <code>str</code> and apply a decorator to one of it's methods.</p>
</div>
<span class="comment-copy">Why does this have to be a decorator?</span>
<span class="comment-copy">Thanks for the elegant use of <code>builtins</code> module, It's very handy and clever solution indeed.</span>
<span class="comment-copy">@BrenBarn's answer shows how it <i>is</i> possible.</span>
<span class="comment-copy">@AdamSmith Barn's answer isn't using a decorator. That's what the question originally asked.</span>
<span class="comment-copy">Done with a decorator here: <a href="https://gist.github.com/anonymous/c6ee1be4befc1c38d34cd02553b31945" rel="nofollow noreferrer">gist.github.com/anonymous/c6ee1be4befc1c38d34cd02553b31945</a></span>
