<div class="post-text" itemprop="text">
<p>Python's peewee orm library allows me to query database using the <code>get</code> method like this:</p>
<pre><code>grandma = Person.get(Person.name == 'Grandma L.')
</code></pre>
<p>This query will filter the resultset based on Person's name doing a sql <code>where</code> behind the scenes.</p>
<p>I know the expression <code>Person.name == 'Grandma L.'</code> is evaluated first and the <code>get</code> method receives just a boolean value.</p>
<p>How does the <code>get</code> method inspect it's arguments to detect that the filter needs to be applyed to the 'name' field ?</p>
<p>PS: I read peewee's source but couldn't have any clue how it does that.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I know the expression <code>Person.name == 'Grandma L.'</code> is evaluated first and the <code>get</code> method receives just a boolean value.</p>
</blockquote>
<p>I don't know Peewee specifically but I do know how this sort of thing is done.</p>
<p>Basically, the second part of your sentence isn't true. <code>name</code> is of a custom type. Its <code>__eq__</code> method doesn't return just a Boolean value, but rather an object that contains information on what comparison was actually done. (This class might even derived from <code>bool</code> so it works like a Boolean in other contexts.) Its other rich comparison methods are similar.</p>
<p>But how does <code>Person.name</code> know that its name is <code>name</code>? The answer to <em>that</em> is that <code>Person</code> probably doesn't actually have a <code>name</code> attribute. Instead, it has a <code>__getattr__()</code> method that returns the <code>name</code> object, which is the custom class that has the <code>__eq__</code> method I just described.</p>
<p>Since <code>Person.__getattr__()</code> receives the name of the attribute, it can bake that name into the value it returns for <code>name</code>. Then the custom <code>__eq__</code> method on <code>name</code> returns a Boolean-like object that contains some representation of <code>name == 'Grandma L.'</code> inside it. And <code>Person.get()</code> uses this representation to put together the query.</p>
</div>
<span class="comment-copy">Awesome. That gives me some clues where to read peewee's source. Thanks.</span>
<span class="comment-copy">If Peewee is anything like the other ORMs (and <a href="http://docs.peewee-orm.com/en/latest/peewee/quickstart.html#model-definition" rel="nofollow noreferrer">it is</a>), then <code>__getattr__</code> is not at play, but column/field objects as class attributes, defined in the model class. And those get the name from the attribute with some metaclass handling. In recent enough Python a metaclass will not be necessary for that anymore, as descriptors may define <a href="https://docs.python.org/3/reference/datamodel.html#object.__set_name__" rel="nofollow noreferrer"><code>__set_name__()</code></a> for that.</span>
<span class="comment-copy">Sweet, that's a much better way to do it. But the main point is that field objects need to know their own name somehow.</span>
<span class="comment-copy">Aye, that's handled during class construction by the metaclass. In case of peewee, <a href="https://github.com/coleifer/peewee/blob/master/peewee.py#L4822" rel="nofollow noreferrer"><code>BaseModel</code></a>.</span>
