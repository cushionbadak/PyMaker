<div class="post-text" itemprop="text">
<p>Given a custom class that needs to support addition, are there any reasons not to delegate the <code>__add__</code> method to <code>__iadd__</code> such that:</p>
<pre><code>def __add__(self, other): 
    if not self.comparable(other):
        raise ValueError("Objects cannot be added!")

    temp = copy.deepcopy(self)
    temp += other
    return temp

def __iadd__(self, other):
    if not self.comparable(other):
        raise ValueError("Objects cannot be added!")

    self.x += other.x
    self.y += other.y
    # ... whatever else addition voodoo 
</code></pre>
<p>I cannot come up with anything besides the fact that <code>copy.deepcopy</code> might be an issue for memory but since addition is <strong>supposed to</strong> return a new object and leave <code>self</code> unchanged, I am not sure it can be avoided. An alternative would be to instantiate a new object with the constructor, which isn't really a neat option if the class has many mutable variables. In my case here it's a stochastic model that's generated from a whole chunk of training data, so it was easier to get a copy.</p>
<p>All in all the above definitions do comply with the requirements, but I have not seen this type of dependency between the two methods in any tutorial which makes me a bit suspicious. </p>
<p>Is this in any way dangerous or bad practice?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is certainly very much the natural and recommended way of doing things in C++.  </p>
<p>On the other hand, if you have immutable objects (like the basic integer or string types) you won't have an <code>__iadd__</code> and will have to implement <code>__add__</code> directly.</p>
<p>From <a href="https://docs.python.org/3/reference/datamodel.html#object.__iadd__" rel="nofollow noreferrer">the docs</a> if you don't have an <code>__iadd__</code>, <code>x += y</code> will invoke either <code>x.__add__(y)</code> or <code>y.__radd__(x)</code> and then assign the result to x.</p>
</div>
