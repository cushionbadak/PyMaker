<div class="post-text" itemprop="text">
<p>In the paragraph "Descriptor Protocol" of <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">“Descriptor HowTo Guide"</a> of the Python 3.6 documentation there is written</p>
<blockquote>
<p>If an instance’s dictionary has an entry with the same name as a
  non-data descriptor, the dictionary entry takes precedence</p>
</blockquote>
<p>Maybe I understand something wrong but why does the non-data descriptor has precedence over the instance entry in this example</p>
<pre><code>class Descriptor:
    def __get__( self, instance, owner ):
        print( "__get__ is called" )
        return self.__dict__[self.name]


    def __set_name__( self, owner, name ):
        print( "__set_name__ is called" )
        self.name = name
        self.__dict__[name] = "Hello World"

d = Descriptor()

class MyClass:
    data = d

instance_of = MyClass()
instance_of.d = "Goodbye"

print()
print( instance_of.data )
</code></pre>
<p>I expected that <code>Goodbye</code> will be outputted. However there was outputted <code>Hello World</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>That is not is what is meant by "name". Here the "name" refers to the name in the class <code>__dict__</code> and in the instance <code>__dict__</code>, and <em>not</em> any name attribute the descriptor may have. See the following example for when the class descriptor gets overridden.</p>
<pre><code>from pprint import pprint

class Descriptor:
    def __get__( self, instance, owner ):
        return "class"

class MyClass:
    data = Descriptor()

obj = MyClass()
# get the data descriptor's value
print(obj.data) # prints "class"

# set an instance attribute with the same name
obj.data = "instance"
print(obj.data) # prints "instance"

# print the variables of both class and instance
# -- both contain the name "data"
pprint(vars(MyClass)) # prints
# mappingproxy({'__dict__': &lt;attribute '__dict__' of 'MyClass' objects&gt;,
#               '__doc__': None,
#               '__module__': '__main__',
#               '__weakref__': &lt;attribute '__weakref__' of 'MyClass' objects&gt;,
#               'data': &lt;__main__.Descriptor object at 0x034BF1B0&gt;})
print(vars(obj)) # prints
# {'data': 'instance'}

# delete the instance attribute and the descriptor becomes visible again
del obj.data
print(obj.data) # prints "class" again
</code></pre>
</div>
<span class="comment-copy">1. It’s helpful to <i>show</i> the output. 2. Did you mean <code>instance_of.data = “Goodbye”</code>? 3. And also <code>print(instance_of.data)</code>?</span>
<span class="comment-copy">You haven’t fixed every typo. See 2. Once you do so you will get Goodbye and your question will therefore be redundant.</span>
<span class="comment-copy">You've mixed up <code>data</code> and <code>d</code>. You're not assigning to the attribute you're trying to read. Voting to close as typo.</span>
<span class="comment-copy">This is more than a typo. This is a misunderstanding of what the is meant by the "name" of a descriptor in the documentation. See the use of the new <a href="https://www.python.org/dev/peps/pep-0487/" rel="nofollow noreferrer"><code>__set_name__</code></a> method in the example.</span>
<span class="comment-copy">@Dunes I’m not sure it is. Neither name set in the descriptor instance is the same as either attribute name on the other instance.</span>
<span class="comment-copy">In this section there is written "If an object defines both <b>get__() and __set__(), it is considered a data descriptor" So your interpretation does not make sense. data is not a descriptor because it does not define at least __get</b>.</span>
<span class="comment-copy">It is a descriptor as it <i>does</i> define <code>__get__</code>. But it is a non-data descriptor rather than a data descriptor. Data descriptors also define <code>__set__</code>. You also seem to mixed up over precedences. Non-data descriptors (without <code>__set__</code>) are overruled by the instance's <code>__dict__</code>. Whereas data descriptors (with <code>__set__</code>) overrule the instance's <code>__dict__</code>.</span>
<span class="comment-copy">The most common non-data descriptors are functions. This allows them to return bound functions when getting them off of an instance, but allows you to monkey-patch an object by setting a value to the same name.</span>
<span class="comment-copy">I am sorry but using the general terms of programming data nothing defines. It is the class Descriptor or at least the object d that defines this method.</span>
