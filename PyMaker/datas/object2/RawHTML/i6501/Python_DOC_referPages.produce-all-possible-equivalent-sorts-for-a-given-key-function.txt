<div class="post-text" itemprop="text">
<p>Say I have points: </p>
<pre><code>points = [(1., 1.), (3., 0.), (-1., -1.), (9., 2.), (-4., 2.) ]
</code></pre>
<p>If I sort them by y axis:</p>
<pre><code> points = sorted(points , key=lambda k: [k[1], k[0]])
</code></pre>
<p>I get</p>
<pre><code> points = [(-1., -1.),  (3., 0.), (1.,1.) , (-4.,2.), (9., 2.)]
</code></pre>
<p>However I want to sort it completely independent from the x axis.  <strong>Further, I want the output to be the 2 lists which show both possible sorts (i.e. all permutations of the x-values where the y-values are equal</strong>):</p>
<pre><code>[(-1., -1.),  (3., 0.), (1.,1.) , (-4.,2.),(9., 2.)]
[(-1., -1.),  (3., 0.), (1.,1.) , (9.,2.), (-4.,2.)]
</code></pre>
<p>Is there a way I can do this?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Problem statement:</h2>
<p>Create multiple lists of all possible permutations of sorts given an equivalence relation (such as comparing y-coodinates and ignoring the x-coordinates):</p>
<h2>Solution:</h2>
<p>Here is some working code to solve the problem:</p>
<pre><code>from operator import itemgetter
from itertools import groupby, product, permutations, chain

points = [(1., 1.),  (3., 0.),(-1., -1.) , (9., 2.), (-4., 2.) ]
points.sort(key=itemgetter(1))
groups = [list(permutations(g)) for k, g in groupby(points, itemgetter(1))]
for t in product(*groups):
    print(list(chain.from_iterable(t)))
</code></pre>
<h2>Final Result:</h2>
<pre><code>[(-1.0, -1.0), (3.0, 0.0), (1.0, 1.0), (9.0, 2.0), (-4.0, 2.0)]
[(-1.0, -1.0), (3.0, 0.0), (1.0, 1.0), (-4.0, 2.0), (9.0, 2.0)]
</code></pre>
<h2>Explanation:</h2>
<ul>
<li><p>The initial sort orders the points by the y-axis only.  This uses <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><em>itemgetter()</em></a> to extract field 1.</p></li>
<li><p>The <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><em>groupby()</em></a> step makes groups of points that have the same y-coordinate.</p></li>
<li><p>The <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><em>permutations()</em></a> step generates all possible orderings of each group.</p></li>
<li><p>The <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><em>product()</em></a> step generates the cartesian product of each of the permutation groups (so that each output has one element from each of the permutation groups).</p></li>
<li><p>The <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><em>chain.from_iterable()</em></a> step links consecutive tuples in the product into a single iterable which can be fed into <a href="https://docs.python.org/3/library/functions.html#func-list" rel="nofollow noreferrer"><em>list()</em></a> to make the desired result.</p></li>
</ul>
<h2>Step-by-step:</h2>
<p>1) Sort the points by the y-coordinate, ignoring the x-coordinate:</p>
<pre><code>&gt;&gt;&gt; points = [(1., 1.),  (3., 0.),(-1., -1.) , (9., 2.), (-4., 2.)]
&gt;&gt;&gt; points.sort(key=itemgetter(1))
&gt;&gt;&gt; points
[(-1.0, -1.0), (3.0, 0.0), (1.0, 1.0), (9.0, 2.0), (-4.0, 2.0)]
&gt;&gt;&gt;       ^-----------^-----------^-----------^-------------^ ascending y-values
</code></pre>
<p>2) Create groups of points that have the same y-coordinate:</p>
<pre><code>&gt;&gt;&gt; pprint([list(g) for k, g in groupby(points, itemgetter(1))], width=40)
[[(-1.0, -1.0)],                                            # y = -1.0  
 [(3.0, 0.0)],                                              # y =  0.0
 [(1.0, 1.0)],                                              # y =  1.0 
 [(9.0, 2.0), (-4.0, 2.0)]]                                 # y =  2.0 
</code></pre>
<p>3) Generate all permutations of points that have the same y-coordinate:</p>
<pre><code>&gt;&gt;&gt; groups = [list(permutations(g)) for k, g in groupby(points, itemgetter(1))]
&gt;&gt;&gt; pprint(groups)
[[((-1.0, -1.0),)],                                         # y = -1.0
 [((3.0, 0.0),)],                                           # y =  0.0 
 [((1.0, 1.0),)],                                           # y =  1.0 
 [((9.0, 2.0), (-4.0, 2.0)), ((-4.0, 2.0), (9.0, 2.0))]]    # y =  2.0
</code></pre>
<p>4) Create all possible sequences with one element from each permutation group:</p>
<pre><code>&gt;&gt;&gt; for t in product(*groups):
        print(t)

(((-1.0, -1.0),), ((3.0, 0.0),), ((1.0, 1.0),), ((9.0, 2.0), (-4.0, 2.0)))
(((-1.0, -1.0),), ((3.0, 0.0),), ((1.0, 1.0),), ((-4.0, 2.0), (9.0, 2.0)))
</code></pre>
<p>5) Combine each subsequence into a single list:</p>
<pre><code>&gt;&gt;&gt; for t in product(*groups):
        list(chain.from_iterable(t))

[(-1.0, -1.0), (3.0, 0.0), (1.0, 1.0), (9.0, 2.0), (-4.0, 2.0)]
[(-1.0, -1.0), (3.0, 0.0), (1.0, 1.0), (-4.0, 2.0), (9.0, 2.0)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To sort on the x values only:</p>
<pre><code>    points = sorted(points , key=lambda k: k[1])
    points

    [(-1.0, -1.0), (3.0, 0.0), (1.0, 1.0), (9.0, 2.0), (-4.0, 2.0)]
</code></pre>
</div>
<span class="comment-copy">Please do not use the names of the builtins for your variables; replace <code>list</code>, with <code>points</code> for instance; this will save you a lot of grief (and others too)!</span>
<span class="comment-copy">So this will give me the list you just proved and sorted(list , key=lambda k: [k[1], k[0]]) will give me the one i mentioned but imagine that there is (2,2) also these solutions won't work</span>
<span class="comment-copy">It is not entirely clear what is your desired ordering for the second one; can you clarify?</span>
<span class="comment-copy">What I want is something that gives me all possible sorting order for y's regarding the x values so what you wrote and what I have will solve this problem if there is only 2 numbers repeated however the problem will not be solve if we have a 3rd number with y-axis 2</span>
<span class="comment-copy">ok, thanks. See Raymond Hettinger's answer.</span>
