<div class="post-text" itemprop="text">
<p>This code rounds 1.5 (value = 15) to 2 but also rounds 144.5 (value = 1445) to 144.  I dont understand why.</p>
<pre><code>def rounders(value):
    count = 0
    while value &gt;= 10:
        value = round(value / 10, 0)
        count += 1
    return value * (10 ** count)
</code></pre>
<p>This is my attempt to solve the codefights challenge "rounders".  Below is an explanation of whats being attempted.</p>
<p>Example</p>
<p>For value = 15, the output should be
rounders(value) = 20;</p>
<p>For value = 1234, the output should be
rounders(value) = 1000.</p>
<p>1234 -&gt; 1230 -&gt; 1200 -&gt; 1000.</p>
<p>For value = 1445, the output should be
rounders(value) = 2000.</p>
<p>1445 -&gt; 1450 -&gt; 1500 -&gt; 2000.</p>
</div>
<div class="post-text" itemprop="text">
<p>This question is very similar to <a href="https://stackoverflow.com/questions/45021268/strange-behavior-of-numpy-round">Strange behavior of numpy.round</a>. What is written there about <code>np.round</code> is directly applicable to the builtin <code>round</code> method of python 3. Note that the behaviour of python 2 is different (as described in the post above. Thanks to ShadowRanger for pointing that out.)</p>
<p>Have a look at the <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer">documentation</a> of the <code>round</code> method: </p>
<blockquote>
<p>If two multiples are equally close, rounding is done toward the <em>even</em> choice.</p>
</blockquote>
<p>That is,</p>
<pre><code>round(2.5) == 2
round(3.5) == 4
</code></pre>
<p>You can write a rounding method with the intuitive behaviour with a simple if-statement:</p>
<pre><code>def myRound(x):
    r = x % 1
    if r &lt; 0.5:
        return x-r
    else: 
        return x-r+1
</code></pre>
</div>
<span class="comment-copy">Is this python 2 or 3?</span>
<span class="comment-copy">Side-note: This rounding mode is often referred to as "round half even" mode, and it's useful for unbiased rounding in financial contexts (you don't want your bank always rounding off in its favor), and for avoiding cascading errors (repeatedly rounding in the same direction in a long computation magnifies errors; rounding towards even tends to balance out). If you need more control, you can use <code>decimal.Decimal</code> values, which allow you to tweak the context to <i>choose</i> your <a href="https://docs.python.org/3/library/decimal.html#rounding-modes" rel="nofollow noreferrer">preferred rounding mode</a> to match your desired behavior.</span>
<span class="comment-copy">Also note, <code>round</code> uses round-half-even mode only on Py3; <a href="https://docs.python.org/2/library/functions.html#round" rel="nofollow noreferrer">on Py2, the <code>round</code> mode is round-half-up</a> (halves are rounded away from 0, so <code>-0.5</code> -&gt; <code>-1.0</code> and <code>0.5</code> -&gt; <code>1.0</code>), and it always returns <code>float</code> (where Py3 returns <code>int</code> when the second argument isn't provided).</span>
