<div class="post-text" itemprop="text">
<p>From <a href="https://stackoverflow.com/a/44880260/156458">https://stackoverflow.com/a/44880260/156458</a></p>
<blockquote>
<p>Note that the <code>__dict__</code> attribute of custom Python class instances is
  a <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer"><em>descriptor</em></a>; the
  instance itself doesn't have the attribute, it is the class that
  provides it (so
  <code>type(instance).__dict__['__dict__'].__get__(instance)</code> is returned).
  <code>object.__dict__</code> may exist, but <code>object.__dict__['__dict__']</code> does
  not.</p>
</blockquote>
<p>Why is <code>__dict__</code> attribute of a custom Python class instance   a descriptor of the class, instead of an actual attribute of the instance?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's tempting to say that <code>__dict__</code> has to be a descriptor because implementing it as a <code>__dict__</code> entry would require you to find the <code>__dict__</code> before you can find the <code>__dict__</code>, but Python already bypasses normal attribute lookup to find <code>__dict__</code> when looking up other attributes, so that's not quite as compelling as it initially sounds. If the descriptors were replaced with a <code>'__dict__'</code> key in every <code>__dict__</code>, <code>__dict__</code> would still be findable.</p>
<p>There's some space savings by not having a key for <code>'__dict__'</code> in every <code>__dict__</code>, but that's not the big reason. There's also time saved by not having to set a <code>'__dict__'</code> key, and time and space saved by not creating a circular reference, and these benefits are all really nice, but they're still probably smaller than the next thing.</p>
<p>The big thing requiring <code>__dict__</code> to be a descriptor is handling attempts to reassign or delete an object's <code>__dict__</code>. If attribute lookup for <code>__dict__</code> went through a <code>__dict__</code> key, then reassigning <code>someobj.__dict__</code> would reassign the dict key without changing what dict Python actually looks in to find <code>someobj</code>'s attributes. <code>__dict__</code> needs to be a descriptor so it stays in sync with the actual C-level struct slot Python looks in to find an object's dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because it's the attribute that allows instances to have custom attributes.  It's where new custom attributes of an instance are typically be stored.  Some magic is required to avoid circular references (you wouldn't want to look up <code>__dict__</code> on an instance to find <code>__dict__</code> on that instance).  Class descriptors are one of two  Python mechanisms to have this sort of magic for instance attribute lookup.</p>
</div>
<span class="comment-copy">All instances of a class have the same descriptor, so there's no need to duplicate it in every instance.</span>
<span class="comment-copy">@Barmar but different instances of a class have different instance attributes, so need their own <code>__dict__</code>'s to store their different instance attributes. correct?</span>
<span class="comment-copy">Thanks. What do you mean by "Python already bypasses normal attribute lookup to find <code>__dict__</code>"?</span>
<span class="comment-copy">@Tim: When looking up <code>someobj.foo</code>, Python <a href="https://github.com/python/cpython/blob/v3.6.3/Objects/object.c#L1067" rel="nofollow noreferrer">finds the instance dict</a> using the type's C-level <code>tp_dictoffset</code> rather than by looking up <code>someobj.__dict__</code> through normal attribute lookup.</span>
<span class="comment-copy">Thanks. (1)  Does the lookup process for <code>__dict__</code> also apply to other special attributes whose names both begin and end with two underscores, such as <code>__name__, __class__, __new__, __init__, __str__, __repr__</code>?  (2) <a href="https://stackoverflow.com/q/46594480">will the lookup for self-defined attributes whose names both begin and end with two underscores (e.g. <code>__madeupAttribute__</code>)   be the same as the lookup for those special attributes?</a></span>
