<div class="post-text" itemprop="text">
<p>Here is the code I currently have.</p>
<pre><code>def fibonacci(n):

    if n == 1:
        return 1
    elif n == 2:
        return 1
    else:
        value = fibonacci(n - 1) + fibonacci(n - 2)
        return value
</code></pre>
<p>This currently takes quite some time to calculate values greater than n = 30. Is there a more computationally efficient method to accomplish this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Adding a value cache to trade some memory for a reduced processing time can be a useful method. A purely recursive program will attempt to calculate values over and over again, however this takes time for larger values. If the values do not change, then storing them can be helpful. It is important to note, however, that should values be volatile you might need a different approach. </p>
<pre><code>fibonacci_value_cache = {}


def fibonacci(n):

    if n == 1:
        return 1
    elif n == 2:
        return 1
    elif n in fibonacci_value_cache:
        return fibonacci_value_cache[n]
    else:
        fibonacci_value_cache[n] = fibonacci(n - 1) + fibonacci(n - 2)
        return fibonacci_value_cache[n]

n = 100

print("Fib " + str(n) + ": " + str(fibonacci(n)))
</code></pre>
<p>Here, we check if the value is in the dictionary and return it if it is, otherwise we calculate it and add it to the dictionary. This means that we are make better use of the processor by not calculating the same value multiple times.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's a recipe for  a decorator that uses as an example exactly what you want. It's named <a href="https://wiki.python.org/moin/PythonDecoratorLibrary#Memoize" rel="nofollow noreferrer">Memoize</a> in the <a href="https://wiki.python.org/moin/PythonDecoratorLibrary" rel="nofollow noreferrer">PythonDecoratorLibrary</a>. </p>
<p>It may seem like overkill, but having the <code>memoized</code> decorator around could be useful for other future tasks. That said, here it is in its entirety (although I changed the <code>print</code> at the end):</p>
<pre><code>import collections
import functools

class memoized(object):
   '''Decorator. Caches a function's return value each time it is called.
   If called later with the same arguments, the cached value is returned
   (not reevaluated).
   '''
   def __init__(self, func):
      self.func = func
      self.cache = {}
   def __call__(self, *args):
      if not isinstance(args, collections.Hashable):
         # uncacheable. a list, for instance.
         # better to not cache than blow up.
         return self.func(*args)
      if args in self.cache:
         return self.cache[args]
      else:
         value = self.func(*args)
         self.cache[args] = value
         return value
   def __repr__(self):
      '''Return the function's docstring.'''
      return self.func.__doc__
   def __get__(self, obj, objtype):
      '''Support instance methods.'''
      return functools.partial(self.__call__, obj)

@memoized
def fibonacci(n):
   "Return the nth fibonacci number."
   if n in (0, 1):
      return n
   return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(12))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using idea of Dynamic Programming, and store the intermediate results to save computational cost, it could be very efficient. The code below cost less than <strong><code>0.02s</code></strong> for <strong><code>n=10000</code></strong> on my laptop. </p>
<pre><code>def fib(n):  # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    for i in range(n):
        result.append(b)
        a, b = b, a + b
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No need for caching/memoization.  Here's a Python 3 implementation that expresses the <a href="https://en.wikipedia.org/wiki/Fibonacci_number#Matrix_form" rel="nofollow noreferrer">Fibonacci sequence as powers of a matrix</a>, then does efficient exponentiation via halving and squaring.  The result is O(log n) in both time and storage.</p>
<pre><code>def matrix_fib(n):
    if n == 1:
        return [0,1]
    else:
        f = matrix_fib(n // 2)
        c = f[0] * f[0] + f[1] * f[1]
        d = f[1] * (f[1] + 2 * f[0])
        return [c,d] if (n &amp; 1) == 0 else [d,c+d]

def fib(n):
  return n if n == 0 else matrix_fib(n)[1]

print(fib(1000000))
</code></pre>
<p>On my laptop this coughs up the value of the millionth Fibonacci number in a little over half a second, and the bulk of that is probably in the big integer arithmetic and formatting of the outputâ€”the result is ridiculously large. You don't need to worry about stack overflow, though.  The call stack depth for this is only log2(1000000) = 20.</p>
</div>
<span class="comment-copy">Yes. Don't use recursion.</span>
<span class="comment-copy">Bonus tip: For Python 3 users, the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>lru_cache</code></a> decorator conveniently does all the work of caching your values, without you having to manually write dict management conditionals yourself.</span>
<span class="comment-copy">FWIW, if you want a fast way to calculate Fibonacci numbers please see <code>fast_fib</code> near the end of my answer <a href="https://stackoverflow.com/a/40683466/4014959">here</a></span>
<span class="comment-copy">BTW, it's better to let <code>print</code> (or <code>format</code>) handle the string conversion &amp; concatenation for you, rather than doing it manually. Eg, <code>print("Fib", n, fibonacci(n))</code> or <code>print('Fib {} {}'.format(n, fibonacci(n)))</code>. The code tends to be more compact as well as more efficient.</span>
<span class="comment-copy">You also have two if-branches that do the same thing with conditions that can easily be covered by a single condition.</span>
<span class="comment-copy">And I guess it ought to be mentioned that while doing Fibonacci calculations may be a good exercise in learning recursion it's generally best to avoid recursion in Python, unless you're doing something that actually needs recursion, eg processing recursive data structures like trees. Python cannot optimize <a href="https://en.wikipedia.org/wiki/Tail_call" rel="nofollow noreferrer">tail calls</a>, and it has a limit to its recursion depth (although you can change that limit if you need to).</span>
<span class="comment-copy">You code isn't recursively calculating the Fibonacci sequence, which the question specifically asks about, not doing it some other different way.</span>
<span class="comment-copy">Ops, didn't see that, recursion is costive though.</span>
<span class="comment-copy">You should use a for-loop here.</span>
<span class="comment-copy">You're right, could look more elegant with for-loop. I'm modifying it.</span>
<span class="comment-copy">@juanpa: Maybe not a for-loop here. It's not necessary to check every <code>i</code> value up to <code>n</code> incrementing it by <code>1</code> each time. It can be increased to at least <code>b</code> each iteration. Should make it even faster...</span>
