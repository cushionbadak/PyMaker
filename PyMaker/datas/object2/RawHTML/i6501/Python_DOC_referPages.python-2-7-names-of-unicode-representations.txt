<div class="post-text" itemprop="text">
<p>What are the names for these different kinds of ascii representations of unicode?</p>
<ul>
<li><code>\xF0\x9F\x98\xA2</code></li>
<li><code>\U0001f622</code></li>
</ul>
<p>And is there a term for the set that they belong to that's more specific than "representation"? And in the context of these, how would I describe the non-ascii representation (ðŸ˜¢)?</p>
<p>Since I don't know what to call them it is very hard to search for how to work with them.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>As Tom Blodget already warned you, this is a somewhat python specific answer.</p>
<hr/>
<p>The leading <code>\</code> shows that it's an escape sequence.</p>
<p><code>\x</code> means that the next two characters will be interpreted as a hex digit.</p>
<p><code>\U</code> means that the next eight characters will be interpreted as a 32-bit hex value.</p>
<p>You can read more about that here:</p>
<blockquote>
<p><a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow noreferrer">https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals</a></p>
</blockquote>
<p>To fully answer your question:</p>
<ul>
<li><code>\xF0\x9F\x98\xA2</code> are simply four ASCII characters and you have their hex values</li>
<li><code>\U0001f622</code> is a UNICODE codepoint encoded with a 32-bit hex value</li>
<li><code>ðŸ˜¢</code> is a glyph or simply a special character.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><strong>For Python 3</strong></p>
<p>First there seems to be a misunderstanding about the hex escapes:</p>
<pre><code>print("\xF0\x9F\x98\xA2" == "\u00F0\u009F\u0098\u00A2")
print("\xF0\x9F\x98\xA2" == "\U000000F0\U0000009F\U00000098\U000000A2")
print("\xF0\x9F\x98\xA2" == "\U000000F0\U0000009F\U00000098\U000000A2")
print("\xF0\x9F\x98\xA2" == "\N{LATIN SMALL LETTER ETH}\N{APPLICATION PROGRAM COMMAND}\N{START OF STRING}\N{CENT SIGN}")
</code></pre>
<p>and for completeness (I recall using octal effectively in machine code where some instructions had 3-bit, aligned arguments but I don't see the point in real programming):</p>
<pre><code>print("\xF0\x9F\x98\xA2" == "\360\237\230\242")
</code></pre>
<p>It appears they are all Unicode <strong>codepoint</strong> escapes in 2-digit hexadecimal, 4-digit hexadecimal, and 8-digit hexadecimal, with ranges from U+0000 to U+00FF, U+FFFF, and U+10FFFF, respectively. </p>
<p>We can confirm that, unlike other languages where the \u for is for a UTF-16 code unit, in Python 3, it is really a codepoint. </p>
<pre><code>print("\ud83d\ude22" == "\U0000d83d\U0000de22")
</code></pre>
<p>and for completeness:</p>
<pre><code>print("\U0001f622" == "ðŸ˜¢")
print("\N{CRYING FACE}" == "ðŸ˜¢")
</code></pre>
<p>In other languages (where they would be two UTF-16 code units), <code>"\ud83d\ude22"</code> would equal <code>"ðŸ˜¢"</code>.</p>
<p>Now, U+D8ED and U+DE22 are Unicode codepoints designated as surrogates. In other words, not <em>characters.</em> They reserve the codepoint codespace for the UTF-16 code units with corresponding values. This is the way the USC-2 encoding of Unicode was transparently extended to UTF-16 when Unicode was expanded from 2^16 codepoints to 2^21 codepoints. For more information see the <a href="http://www.unicode.org/faq/utf_bom.html" rel="nofollow noreferrer">Unicode FAQ</a>.</p>
<hr/>
<p>As <a href="https://stackoverflow.com/users/8747/rob%e1%b5%a9">@Robáµ©</a> points out, you can have a bytestring literal, too:</p>
<pre><code>print("\U0001f622".encode("utf-8") == b"\xF0\x9F\x98\xA2")
</code></pre>
</div>
<span class="comment-copy">This seems like a language-specific question or at least would have language-specific answers. Also, where the hex byte format is allowed, it's not a given that the bytes are interpreted as Unicode. For example, not allowed in C#. In JavaScript, it represents bytes from ISO 8859-1 that are then put into the string as Unicode characters.</span>
<span class="comment-copy">The first is also the UTF-8 encoding of the second.</span>
<span class="comment-copy">Hex values outside the range <code>\x00</code> to <code>\x7f</code> aren't ASCII. That's not a 16-bit hex value, it's 32 bits. And the technical term is "codepoint", not "character".</span>
<span class="comment-copy">Yup, I confused hex values with hex digits. 8 Hex digits means 32-bits, you're right, I edited the answer.</span>
<span class="comment-copy">@MarkRansom Do you mean for the second bullet point in this answer it should read <i>"<code>\U0001f622</code> is a UNICODE codepoint"</i> ?</span>
<span class="comment-copy">@NathanHinchey exactly.</span>
<span class="comment-copy">The treatment of <code>\u</code> may depend on the version and build of Python you're using. For me, <code>u"\ud83d\ude22" == u'\U0001f622'</code> yields <code>True</code> on 2.7 but <code>False</code> on 3.6.</span>
