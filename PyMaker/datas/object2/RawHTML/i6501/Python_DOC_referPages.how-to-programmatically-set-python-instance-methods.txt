<div class="post-text" itemprop="text">
<p>I have a class for making an anonymous class:</p>
<pre><code>class Anonyclass(object):
    def __init__(self, **kwargs):
        for kwarg in kwargs:
            self.__setattr__(kwarg, kwargs[kwarg])
</code></pre>
<p>It works great for setting properties dynamically, however I cannot set instance methods this way because they don't have access to <code>self</code>.  e.g. <code>Anonyclass(foo = lambda x: x**2).foo(5) == 25</code>, but I can't seem to shove a <code>self</code> in there...</p>
<p>Anybody know how to make this happen?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is not creating new "classes" just instances of <code>Anonyclass</code>. 
Just as you can set instance attributes, you can set callable attributes that know to which instance they are bound.</p>
<p>So, assuming any callable passed as an argument will take <code>self</code> as the first argument, you can change your code to:</p>
<pre><code>from functools import partial

class Anonyclass(object):
    def __init__(self, **kwargs):
        for kwarg, attr in kwargs.items():
            if callable(attr):
                  attr = partial(attr, self)
            setattr(self, kwarg, attr)
</code></pre>
<p>This is needed because a callable being set in the instance bypass the <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">mechanism Python uses to bind a method to an instance</a> auto-adding the "self" argument to all calls. So we use <code>functools.partial</code> to do the same. (It could be done with lambdas, but we'd need two levels of lambda's so that the "attr" variable would keep itself bound to the correct method, and not point to the last element assigned in the <code>for</code> loop)</p>
<p>Also, if you want to actually create <em>classes</em>  and not instances with attributes bound, you could just make a call to <code>type</code>, passing the same arguments you get as <code>kwargs</code> on your code:</p>
<pre><code>def anon_class_factory(**kwargs):
   return type("Anonyclass", (object,), kwargs)
</code></pre>
<p>This will make any function passed in <code>kwargs</code> behave as a "real" method.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do it like the following. You may have to modify the <code>for kwarg, value in kwargs.items():</code> loop to check what kind of value is being assigned and handle data- and/or property-types of attributes differently. I didn't try it with anything else since there weren't any example in your question.</p>
<pre><code>class _Callable(object):
    def __init__(self, instance, name, value):
        self.name = name
        self.instance = instance
        self.__setattr__(name, value)

    def __call__(self, *args):
        return self.__dict__[self.name](self.instance, *args)

class AnonyClass(object):
    def __init__(self, **kwargs):
        for kwarg, value in kwargs.items():
            setattr(self, kwarg, _Callable(self, kwarg, value))

value = 6.480740698407860230965967436088
print( AnonyClass(foo=lambda self, x: x**2).foo(value) )  # -&gt; 42.0
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/972/adding-a-method-to-an-existing-object-instance">Adding a Method to an Existing Object Instance</a></span>
<span class="comment-copy">for this to work you have to pass the <code>self</code> argument inside <code>Anonyclass.__init__</code> to the <code>_Callable</code> instance as well.</span>
<span class="comment-copy">@jsbueno: True and fixed. Thanks for pointing that out. Didn't notice since the testcase function/method doesn't access its <code>self</code> argument.</span>
