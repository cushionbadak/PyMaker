<div class="post-text" itemprop="text">
<p>I'm a beginner at programming (and also an older person), so I don't really know how to express what I want correctly. I've tried to describe my question as thoroughly as possible, so really appreciate your patience! </p>
<p>I would like to store the winning scores associated with each user.</p>
<ul>
<li>Each user would have different number of winning scores.</li>
<li>I do not need to seperate users first name and last name, they can all be one string.</li>
<li>I do not need the scores to be ordered in any way, and I don't need to be able to change them. </li>
<li>I only need to be able to add the scores whenever the user wins and sort users by amount of wins.</li>
<li>I will extract all the winning scores for statistics, but the statistics will not be concerned with what score belongs to what user.   </li>
<li>Once the program stops, it can all be erased from memory.</li>
</ul>
<p>From what I've researched so far it seems my best options are to either create a user class, where I store a list and add to the list each time. Or to create a dictionary with a key for each user. But since each user may have a different amount of winning scores, I don't know if I can use dictionaries with that (unless each key is associated with a list maybe?). I don't think I need something like a numpy array, since I want to create very simple statistics without worrying about what score belongs to what user. 
I need to think about not using an unnecessary amount of memory etc., especially because there may be a hundred winning scores for each user. But I can't really find clear information on what the benefits of dictionaries vs classes are. The programming community is amazingly helpful and full of answers, but unfortunately I often don't understand the answers. </p>
<p>Greatful for any help I can get! And don't be afraid to tell me my ideas are dumb, I want to learn how to think like a programmer.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a good question because it discusses two possible solutions. The class based solution and the dictionary based solution. The class based solution is more elegant and versatile so I will describe that one.</p>
<pre><code>class User(object):
    def __init__(self, scores, name): #Where scores is a list of their scores
        self.scores = scores
        self.name = name

    def get_scores(self):
        return self.scores

    def get_sum(self):
        return sum(self.scores)

    def get_name(self):
        return self.name
</code></pre>
<p>Then you could do something like</p>
<pre><code>user_a = User([1,2,3], "Jerry Stewart")
user_b = User([1,3,12,13,110], "Godric Gryffindor")
user_c = User([8,10,11], "Jackie")
users = [user_a, user_b, user_c]

for user in users:
    print "{} : {}".format(user.get_name(), user.get_sum())
</code></pre>
<p>Hopefully this covers the basics of what you need!</p>
</div>
<div class="post-text" itemprop="text">
<p>Welcome to SO!</p>
<p>Building on Hallsville3's answer, I think you could achieve a similar outcome by simply subclassing list like so:</p>
<pre><code>class User(list):
    def __init__(self, name, scores):
        super().__init__(scores)
        #Where scores is a list of their scores. This assumes you are using Python 3. Super calls in python 2 need a couple more arguments.
        self.name = name
</code></pre>
<p>Then you can create a list of users and add to it easily:</p>
<pre><code>user_base = []
user_base.append(User('Stuart', [1, 2, 3]))
user_base.append(User('Jane', [4, 5, 6]))
</code></pre>
<p>This data model has only two layers Userlist =&gt; Scorelist/User Object, as opposed to having Userlist =&gt; User Object =&gt; Scorelist, which should make accessing it slightly simpler.</p>
<p>You can also expand your object to return statistics per user:</p>
<pre><code>class User(list):
    def __init__(self, name, scores):
        super().__init__(scores)
        self.name = name
    @property
    def average(self):
        return sum(self)/len(self)
</code></pre>
<p>And use this to return all the users averages:</p>
<pre><code>[user.average for user in user_base]
</code></pre>
<p>There are literally thousands of ways to structure your data, from simple implementations like this, up to SQL databases if you are doing this on a big scale. I think it makes sense to start with a simple model then buiild up complexity as you build up your skills.</p>
<p>Good Luck!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>Dictionary</code> as values in dicts can be <code>mutable</code> like a <code>list</code> where you can keep all the scores/winning scores for each user.</p>
<p><code>{'player1' : [22,33,44,55],
'player2' : [23,34,45],
.....
}
</code></p>
<p>If this is not an exercise that you will repeat dicts make sense but if it is an exercise that might need to be done again in future <code>Classes</code> are better alternative as explained in other answers by Stuart and Hallsville3.</p>
<p>Hope it helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>Since there is already an answer covering the class option, I give the simplest dictionary base solution I could come up with.
I personally would prefer to use a plain dictionary approach first and maybe switch to a more flexible class implementation later if it is needed.</p>
<p>A basic scores dictionary and its usage could look like this:</p>
<pre><code>scores = {}

scores["user1"] = []  # empty scores list
scores["user2"] = [14, 32, 67]
scores["user3"] = [1, 94]

scores["user1"].append(45)  # add a single score
scores["user3"].extend([13, 22])  # add multiple scores

for user, user_scores in scores.items():
    print(user, user_scores, min(user_scores), max(user_scores), sum(user_scores))
</code></pre>
<p>Output for this would look like this:</p>
<pre><code>user1 [45] 45 45 45
user2 [14, 32, 67] 14 67 113
user3 [1, 94, 13, 22] 1 94 130
</code></pre>
<p>Maybe you could experiment with this approach and see if it fits your needs.</p>
</div>
<div class="post-text" itemprop="text">
<p>class is used when there is both state and behavior . dict is used when there's only state. since you have both  use class.  </p>
</div>
<div class="post-text" itemprop="text">
<p>From your description, all you need is a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> with a <code>list</code> as default.</p>
<pre><code>from collections import defaultdict

scores = defaultdict(list)
scores['User1'].append(3)
scores['User1'].append(5)
scores['User2'].append(6)
scores['User2'].append(1)

print(scores)
# defaultdict(&lt;class 'list'&gt;, {'User1': [3, 5], 'User2': [6, 1]})

print(sorted(scores, key= lambda k: sum(scores[k]), reverse=True))
# ['User1', 'User2']

print(sorted(scores, key= lambda k: sum(scores[k])/len(scores[k]), reverse=True))
# ['User1', 'User2']
</code></pre>
<p>If each user has only one score, you could use a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a>.</p>
</div>
<span class="comment-copy">There is no problem with using a dictionary with list values. dictionaries are actually very efficient in python and used everywhere "under the hod" (also in classes). My first approach would be using a plain dictionary with score lists as values. If you need more flexibility later you could then switch to a custom class with additional functionality. Maybe you find this <a href="https://www.youtube.com/watch?v=npw4s1QTmPg" rel="nofollow noreferrer">video</a> about the topic interesting.</span>
<span class="comment-copy">Thank you that is very helpful! I did not know of this format function, so I've learned even more than I asked for!</span>
<span class="comment-copy">I'm really glad that helped! The format method of Strings is incredibly useful! If you haven't already you can find the full documentation <a href="https://docs.python.org/2/library/string.html#format-examples" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">Yes this addition is very helpful, thank you! You made me realize something; I've only imagined a scenario of a handful users at best. But there should be no such restrictions. If I may trouble you with another question: what is the best practice if you were to have a list of one hundred users? Is it better to create a dictionary then? In my mind, I imagine creating a class instance for each user will take a lot of memory, but perhaps that is just because the code of the class <i>looks</i> less efficient compared to a dictionary.</span>
<span class="comment-copy">I think you have to try and measure like always when you try to optimise something. One hundred users should not be a problem. A dictionary is perfectly fine even for millions of users with thousands of scores. There is also a way to implement more memory efficient classes using <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><b>slots</b></a> but i have no idea how it would compare to the plain dictionary approach in memory usage. I would strive for the simplest solution first and optimise only if I had a real memory problem.</span>
