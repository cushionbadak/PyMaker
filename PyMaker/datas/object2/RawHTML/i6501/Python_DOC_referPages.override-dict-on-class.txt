<div class="post-text" itemprop="text">
<p>I'm trying to make a <code>dict</code>-like class in Python.</p>
<p>When you make a class, you have certain methods that tell Python how to make a built-in class. For example, overriding the <code>__int__</code> method tells Python what to return if the user uses <code>int()</code> on an instance of the class. Same for <code>__float__</code>. You can even control how Python would make an iterable object of the class by overriding the <code>__iter__</code> method (which can help Python make <code>list</code>s and <code>tuple</code>s of your class). My question is how would you tell Python how to make a <code>dict</code> of your custom class? There is no special <code>__dict__</code> method, so how would you go about doing it? I want something like the following:</p>
<pre><code>class Foo():
    def __dict__(self):
        return {
            'this': 'is',
            'a': 'dict'
        }

foo = Foo()
dict(foo) # would return {'this': 'is', 'a': 'dict'}
</code></pre>
<p>I've tried making the class inherit from <code>dict</code>, but it raises an error later in the code because of subclasses trying to inherit from <code>dict</code> and <code>type</code>, so inheriting from <code>dict</code> isn't a possibility. Is there any other way to do it?</p>
<p>Also, I've overridden the <code>__iter__</code> method already so that it would return a <code>dict_keyiterator</code> object (what gets returned when you use <code>iter()</code> on a <code>dict</code>), but it still doesn't seem to work how it should.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="nofollow noreferrer"><code>dict</code></a> can be called with an iterable of pairs, so if you design your <code>__iter__</code> to return an iterable of tuples, your example works as you'd like:</p>
<pre><code>class Foo:
    def __iter__(self):
        yield from {
            'this': 'is',
            'a': 'dict'
        }.items()

dict(Foo())
{'a': 'dict', 'this': 'is'}
</code></pre>
<hr/>
<p>If you want your class to behave like a python dictionary, in that iterating over an instance iterates over its keys, you can implement the interface defined by <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer"><code>abc.Mapping</code></a>. </p>
<p>You can do this either by implementing <code>__getitem__</code>, <code>__iter__</code>, and <code>__len__</code>, and inheriting from <code>abc.Mapping</code>, or by implementing all of <code>__getitem__</code>, <code>__iter__</code>, <code>__len__</code> <code>__contains__</code>, <code>keys</code>, <code>items</code>, <code>values</code>, <code>get</code>, <code>__eq__</code>, and <code>__ne__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Although the approach in the <a href="https://stackoverflow.com/a/46627087/355230">answer</a> from @ForeverWintr is fairly clever and works, I think it's a little obscure since it takes advantage of some of the arcane details about the attributes of the argument passed to the <code>dict</code> class constructor. </p>
<p>For that reason a better approach might be what I was saying in my comments about just adding a method that does what you want (plus shows how simply giving it a name indicating exactly what's going on).</p>
<p>Example code:</p>
<pre><code>class Foo:
    def to_dict(self):
        return {'this': 'is', 'more': 'clear'}

print( Foo().to_dict() )  # -&gt; {'this': 'is', 'more': 'clear'}
</code></pre>
</div>
<span class="comment-copy">Have you tried inheriting from <code>collections.abc.*Mapping</code> yet?</span>
<span class="comment-copy">Using your analogy, I think it might be clearer to think "You can even control how Python would make an <i>iterable object</i> from the class by overriding the <code>__iter__</code> method." <code>dict</code>s are iterables, and like lists and tuples you can create them by passing in iterators.</span>
<span class="comment-copy">@martineau, I don't think you'd want to use <code>@staticmethod</code> in this case, would you? Presumably your <code>to_dict</code> would need access to an instance in order to convert its attributes to a dictionary.</span>
<span class="comment-copy">I <i>kind of</i> found an answer though by making a <code>keys</code> method on my class. If you use <code>dict</code> on a class, it'll try to get create a mapping first with the <code>keys()</code> method. I got it from here: <a href="https://stackoverflow.com/a/8601389/6212261">stackoverflow.com/a/8601389/6212261</a> It doesn't use the <code>__iter__</code> method, so I can implement my own <code>__iter__</code> method <i>and still</i> be able to make a <code>dict</code> with the same class.</span>
<span class="comment-copy">ForeverWintr: Sorry...when I wrote that comment I meant a <code>@classmethod</code> which would have meant the function would need to be passed the object to operate upon, so calls to it would look like <code>result = Foo.to_dict(foo_obj)</code>—however you're right, it would be better to just make it a regular method, so calls could simply be something like <code>result = foo_obj.to_dict()</code>.</span>
<span class="comment-copy">That does work correctly for creating a <code>dict</code> on the <code>Foo</code> object, but then you can't iterate through the keys of the items. Something like <code>for i in Foo()</code> wouldn't iterate through the <i>keys</i> of the object, it would iterate through a <i>tuple</i> of <code>(key, value)</code> tuples.</span>
<span class="comment-copy">@Christian: Good point...however class <code>Foo</code> isn't a formal subclass of <code>dict</code>, so assuming it will behave exactly like one when it's iterated isn't completely reasonable.</span>
<span class="comment-copy">ForeverWintr: FWIW, giving your class (just) a <code>__getitem__()</code> method would also allow built-in <code>dict</code> class objects to be created from instances of them. I still think it would be better to be more explicit and give the class a <code>to_dict()</code> method instead of relying on the somewhat obscure construction argument details of another class..</span>
<span class="comment-copy">ForeverWintr: As proof try replacing your <code>__iter__()</code> method with <code>def __getitem__(self, key):</code>, followed by <code>return [('this', 'is'), ('a', 'dict')][key]</code>—this makes it behave a little like a <code>list</code> of (key, value) pairs.</span>
<span class="comment-copy">@martineau: Ah, of course! That's probably a better answer. Care to add it?</span>
