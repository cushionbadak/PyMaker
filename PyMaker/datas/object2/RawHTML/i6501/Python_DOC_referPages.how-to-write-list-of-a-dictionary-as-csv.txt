<div class="post-text" itemprop="text">
<p>I have a dictionary, in which for each key exists lists of (possible empty) lists.
Now I want to write them in a csv file.</p>
<p>Dictionary:</p>
<pre><code>d = {'A' : [['a', 'b'], ['a', 't', 'c']],[[],['a','b']]
     'B' : [['c', 'd'], ['e']],[['f', 'g'], ['c', 'd', 'e']]}
</code></pre>
<p>Furthermore I know that the first list of 'A' is related to the first list of 'B', the second of 'A' to the  second of 'B' and so on.
Wished Output:
csv file looking like:</p>
<pre><code>A , B 
a , c
b , d

a , e
t ,
c , 

  , f
  , g

a , c
b , d
  , e
</code></pre>
<p>All I tried so far was super "inconvenient" and didn't work in the end.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have modified you Dic variable to look like this so that it is valid:</p>
<pre><code>d = {'A' : [['a', 'b'], ['a', 't', 'c'],[],['a','b']],
     'B' : [['c', 'd'], ['e'],['f', 'g'], ['c', 'd', 'e']]}
</code></pre>
<p>The following code will do the pair wise matching you want over the elements of the list in each dict entry.</p>
<pre><code>import itertools

with open('file.csv', 'w') as fid:            
    fid.write("{} , {}\n".format(*d.keys()))
    # first let's iterate over the element in the lists in d['a'] and d['b']
    # A and B will be matched sublists
    for A, B in itertools.zip_longest(d['A'],d['B'], fillvalue=''):
        # next iterate over the elements in the sub lists.  
        # Each pair will be an entry you want to write to your file
        for pair in itertools.zip_longest(A, B, fillvalue=''):                        
            fid.write("{} , {}\n".format(*pair))
        fid.write('\n')
</code></pre>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">zip_longest</a> is the magic sauce here.  It does the pair wise matching that you want.  It will terminate when the end of the longest list is reached (as opposed to just <code>zip</code> which will terminates when the end of the shortest list is reached.</p>
<p>Content of file.csv:</p>
<pre><code>A , B
a , c
b , d

a , e
t , 
c , 

 , f
 , g

a , c
b , d
 , e
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A hand made solution, with pure python tools :</p>
<pre><code>Dic = {'A' : [['a', 'b'], ['a', 't', 'c'],[],['a','b']],
       'B' : [['c', 'd'], ['e'],['f', 'g'], ['c', 'd', 'e']]}


with open('out.csv','w') as f:
    print(*Dic,sep=',',file=f) # keys
    for A,B in zip(*Dic.values()):
        for i in range(max(len(A),len(B))):
            print(A[i] if i&lt;len(A) else ' ',end=',',file=f) 
            print(B[i] if i&lt;len(B) else ' ',        file=f) 
        print(file=f) # blank line
</code></pre>
<p>For </p>
<pre><code>A,B
a,c
b,d

a,e
t, 
c, 

 ,f
 ,g

a,c
b,d
 ,e
</code></pre>
</div>
<span class="comment-copy">Is it possible to use another, better suited, format for your output file? Like JSON</span>
<span class="comment-copy">Please correct your <code>Dic</code> variable, it's not a valid python dict.</span>
<span class="comment-copy">I edited the dictionary variable. @CHURLZ Unfortunaly I need a csv for now...</span>
<span class="comment-copy">Thank you, I didn't know the zip_longest so far. Also appreciate the comments in the code!</span>
