<div class="post-text" itemprop="text">
<p>I've following code that I need to convert to <code>list-comprehension</code> (one liner). However, I am unable to do so.
The code calculates prime numbers up-to input range of  <code>A</code>.</p>
<pre><code>def sieve(A):    
    l = []
    f = lambda x : int(x**0.5)
    for p in range(2,A+1):        
        for i in range(2, f(p) + 1):
            if p % i == 0:
                break
        else:
            l.append(p)
    return l
</code></pre>
<p>So far I've following which does not work. Especially the <code>break</code> within <code>for-loop</code> is throwing me off.</p>
<pre><code>list(set([val for sublist in [[p  for i in range(2, f(p) + 1) if p %i != 0 ] for p in range(2,A) ] for val in sublist]))
</code></pre>
<p><strong>EDIT</strong><br/>
Adding constraints for the problem.
The code can only be one statement, without <code>eval</code> or <code>exec</code>. The code must be at most 160 character long.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>[p for p in range(2,A+1) if next((i for i in range(2, int(p**0.5) + 1) if (p % i) == 0),None)==None]
</code></pre>
<p>Code is 100 chars long.<br/>
We use <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer">next()</a> to break out of the iteration.<br/>
<strong>Explanation</strong><br/></p>
<pre><code>def sieve(A):
  [p for p in range(2,A+1) if getFirstDiv(p)==None]

def getFirstDiv(p):
  next(divIter(p),None)

def divIter(p):
  return (i for i in range(2, int(p**0.5) + 1) if (p % i) == 0)
</code></pre>
<hr/>
<p><strong>OUTPUT</strong></p>
<pre><code>15 --&gt; [2, 3, 5, 7, 11, 13]
10 --&gt; [2, 3, 5, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This one liner will do it:</p>
<pre><code>[r for r in [i*all([i if i%j!=0 else 0 for j in range(2,i)]) for i in range(2,x)] if r&gt;0]
</code></pre>
<p>You just need to set <code>x</code> (the maximum value).</p>
<p>Note: it is not particularly efficient, although I'm guessing efficiency isn't the aim of this question.</p>
<p>Explanation (expanded code):</p>
<pre><code>filtered = []
primes = []

for i in range(2,x):
    # Check that all numbers up to i do not divide i
    # I realise we only need to check up to int(sqrt(i))
    condition = all([i if i%j!=0 else 0 for j in range(2,i)])

    # Exploit Python's treatment of bool: number*True = number and number*False=0
    filtered.append( i*condition )


for r in filtered:
    # Take out all the zeros
    if r&gt;0:
        primes.append(r)
</code></pre>
</div>
<span class="comment-copy">Why? I pity the person who has to try and decipher this list comprehension.</span>
<span class="comment-copy">Why in the first place do you want it to be converted to list comprehension?</span>
<span class="comment-copy">I know, It's part of a online problem that accepts only one liner solution. Unless there is some other way to provide one liners.</span>
<span class="comment-copy">Regarding adding a break condition to a list comprehension - <a href="https://stackoverflow.com/questions/9572833/break-list-comprehension" title="break list comprehension">stackoverflow.com/questions/9572833/break-list-comprehension</a></span>
<span class="comment-copy">I mean, not recommended but there is always the <a href="http://onelinepy.herokuapp.com/" rel="nofollow noreferrer">Oneliner-izer</a></span>
<span class="comment-copy">Ah, so I was missing out on next(), good to know. It works perfectly even for A=10000+ within given time constraints. thx.</span>
