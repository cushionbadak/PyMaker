<div class="post-text" itemprop="text">
<p>Please excuse the vagueness of my question, I don't have any formal training in CS. I'm pretty sure a solution already exists, but I can't find an answer because I don't know what question to ask.</p>
<p>Essentially, I'm looking for the name of an algorithm, or group of algorithms, to find all combinations of several lists where each list contains the possibilities for a single position. That is, some function that can perform the mapping:</p>
<pre><code>((a,b,c), (1,2), (z,g,h), (7)) -&gt;
    ((a,1,z,7), (a,1,g,7), (a,1,h,7), (a,2,z,7), ... (c,2,h,7))
</code></pre>
<p>such that the result can be used to iterate over all possible combinations of the per-position lists in order.</p>
<p>The number of lists is variable, and the size of each list is variable and independent of the other lists. All the example solutions are missing at least one of those criteria.</p>
<p>It would also be awesome if anyone knew of pseudocode or example implementations for any of those algorithms, or a Python package that can handle this.</p>
<p>I can and have solved the problem previously, but I would like to know if there are better solutions out there before I implement my design again.</p>
<p>Thanks for your time.</p>
<p>For those curious, my previous solution looked something like what is described in <a href="https://watermark.silverchair.com/25-1-48.pdf" rel="nofollow noreferrer">this paper</a>, which is the only example solution I've found. However, it doesn't name the problem, nor does it give me a jumping off point for further research. Here is an (untested) Python listing of my general solution:</p>
<pre><code>def nloop(*args):
  lists = args
  n = len(lists) # Number of lists

  # Exit if no lists were passed
  if n &lt;= 0:
    raise StopIteration

  i = [0] * n # Current index of each list
  l = [len(L) for L in lists] # Length of each list

  # Exit if any list is zero-length
  if min(l) &lt;= 0:
    raise StopIteration

  while True:
    # Create and yield a list using the current indices
    yield tuple( lists[x][ i[x] ] for x in range(n) )

    # Increment the indices for the next loop
    # Move to the next item in the last list
    i[-1] += 1
    # Check the lists in reverse order to carry any
    # indices that have wrapped
    for x in reverse(list(range(n))):
      if i[x] &gt;= l[x]:
        i[x] = 0
        if x &gt; 0:
          i[x-1] += 1

    # If the first list has wrapped, we're done
    if i[0] &gt;= l[0]:
      break

  raise StopIteration
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are looking for <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a>. It is equivalent to the nested <code>for</code> loop of arbitrary depth that you describe.</p>
<p>For your particular example (with appropriate syntactic modifications):</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; list(product(('a', 'b', 'c'), (1, 2), ('z', 'g', 'h'), (7,)))
[('a', 1, 'z', 7),
 ('a', 1, 'g', 7),
 ('a', 1, 'h', 7),
 ('a', 2, 'z', 7),
 ('a', 2, 'g', 7),
 ('a', 2, 'h', 7),
 ('b', 1, 'z', 7),
 ('b', 1, 'g', 7),
 ('b', 1, 'h', 7),
 ('b', 2, 'z', 7),
 ('b', 2, 'g', 7),
 ('b', 2, 'h', 7),
 ('c', 1, 'z', 7),
 ('c', 1, 'g', 7),
 ('c', 1, 'h', 7),
 ('c', 2, 'z', 7),
 ('c', 2, 'g', 7),
 ('c', 2, 'h', 7)]
</code></pre>
</div>
<span class="comment-copy">I actually looked at itertools, but whatever documentation I found only listed the /other/ usage <code>product(range(2), repeat=3)</code>. Never fails, no matter how much effort you put into a solution, posting on the Internet will guarantee it's a simple solution you've overlooked. Thanks.</span>
<span class="comment-copy">No worries, the link I posted is to the official documentation that you should be looking at. Everything else feels watered down.</span>
<span class="comment-copy">Yeah, the troubling part is that I <i>know</i> that. Thanks again.</span>
<span class="comment-copy">@MattW. No worries, you clearly put a lot of effort into this, so glad to help. You should select this answer if it works for you.</span>
<span class="comment-copy">Waiting for the 6 minute timer to run out :)</span>
