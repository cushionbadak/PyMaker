<div class="post-text" itemprop="text">
<p>When we define a class in Python, i.e. we are the authors of the class,</p>
<ul>
<li><p>are we allowed to create attributes of a class, whose names both begin and end with double underscores, and don't conflict with special attributes e.g. <code>__base__, __class__, __name__, __dict__</code>, and special methods such as <code>__new__, __init__, __str__, __repr__, __hash__, __call__, __get__</code>?</p></li>
<li><p>If yes, will the lookup for such attributes (e.g. <code>__madeupAttribute__</code>) that we define be the same as the lookup for those special attributes? Note that the  lookup process for those special attributes is different from the lookup process for regular attributes (e.g. <code>attribute1</code>, <code>attribute2</code>), as mentioned in Python in a Nutshell</p>
<blockquote>
<p>A few attribute dunder-names are special,  <code>C.__name__</code>, <code>C.__bases__</code>, <code>x.__class__</code>. When you refer to an attribute with one of
  these special names, the attribute reference looks directly into a dedicated slot in the
  class or instance object and fetches the value it finds there. You cannot unbind these
  attributes. </p>
</blockquote></li>
<li><p>are we allowed to create attributes of a class, whose names begin with a single underscore?</p></li>
<li><p>are we allowed to create attributes of a class, whose names begin with two underscores?</p></li>
</ul>
<p>Note that I have read <a href="https://stackoverflow.com/q/1301346">What is the meaning of a single- and a double-underscore before an object name?</a>. My questions in this post are: what kinds of attributes the author of a Python class can create and what not.</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>are we allowed to create attributes of a class, whose names both
  begin and end with double underscores, and don't conflict with special
  attributes? If yes, will the lookup for such attributes (e.g. <code>__madeupAttribute__</code>) that we define be the same as the lookup for those special attributes? </p>
</blockquote>
<p>If you create an attribute which name has double underscores on both sides, it gets no special treatment whatsoever. Only the attribute names reserved by the language have a special look-up treatment. Some of those may or may not be directly created by the class author. Most names intended for methods that are responsible to implement operations with the objects of that class, such as <code>__add__</code>, <code>__mul__</code> can be freely writable. Others, will be overwritten on class creation, but are free to be changed afterwards, such as <code>__name__</code>, while still others are created along with the class and are imutable, such as <code>__mro__</code>. Names not listed on the documentation are just like ordinary names, but may get in conflict with future special names added to the language object model.You will be able to locate most special attribute and method names in the <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">language data model</a>, although some attributes can be used by specific stdlib modules and not be listed there. (They have no special meaning for the language as well, just for that module. One example is <code>__reduce__</code>, used by <code>pickle</code>)</p>
<blockquote>
<p>are we allowed to create attributes of a class, whose names begin with a single underscore?</p>
</blockquote>
<p>Yes - single underscore has no special meaning for Python at all, it is just a convention that code outside the class/package that created anything starting with an underscore should not change that directly or rely on its value or on its existence. This convention is what replaces "private" attributes and names in use in other languages</p>
<blockquote>
<p>are we allowed to create attributes of a class, whose names begin with two underscores?</p>
</blockquote>
<p>For attributes of a class prefixed by two underscores, there is a special treatment at <em>compile</em> time that mangles those names, baking the class's name into the attribute name itself. All code written inside a class body (including inside methods, and inside nested functions into those methods) is changed in the same way. This name modification makes it so that classes that inherit from that one, if they use the same attribute name in their code, that attribute will not clash and be independent from the attribute on the parent class. This feature may be used to provide encapsulation for attributes you don't intend derived class to read or write, but again that is more due to convention and convenience, since the name mangling rules are well known. Early Python documentation often implied that this should be used for "private attributes". That is somewhat incorrect: "private" in Python is by convention only, and for readability purposes, often relies on a single prefixed underscore. </p>
</div>
<span class="comment-copy">You can use <code>__author__</code> at the beginning of your module</span>
<span class="comment-copy">These are just naming conventions, they don't have any special meaning to Python.</span>
<span class="comment-copy"><code>__author__</code> is a <a href="https://www.python.org/dev/peps/pep-0008/#module-level-dunder-names" rel="nofollow noreferrer">module-level name</a>. For classes, stick with what it says in the <a href="https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles" rel="nofollow noreferrer">Descriptive: Naming Styles</a> section. See specifically the "special forms" <b><code>__double_leading_underscore</code></b>, <b><code>_single_leading_underscore</code></b> and <b><code>__double_leading_and_trailing_underscore</code></b> â€”you should avoid ever creating any of your own attribute names that follow those patterns.</span>
<span class="comment-copy">You can make whatever attributes you want. <a href="https://ideone.com/akMCko" rel="nofollow noreferrer">With a metaclass, you can even override most of the "special" attributes.</a></span>
<span class="comment-copy">@martineau Specific names have special meaning, but the underscores themselves are not special. The rules require the special names to follow the underscore conventions.</span>
<span class="comment-copy">Thanks. Does the lookup process for special data attributes <code>__dict__ __name__, __class__</code>,  also apply to special method attributes <code>__new__, __init__, __str__, __repr__</code>?</span>
<span class="comment-copy">@Tim: Only when it makes sense to do so. <code>__dict__</code> and <code>__class__</code> are instance attributes, so looking them up on the type wouldn't work. <code>__new__</code> is a <i>static</i> hook method that applies specifically to classes to create new instances. Specifically, the rule applies only to special <b>methods</b>, so yes, <code>__init__</code>,<code>__str__</code> and <code>__repr__</code> are all subject to the rule.</span>
<span class="comment-copy">@MartijnPieters Thanks for pointing out the differences between the attributes. Does what Python in a Nutshell says in the following apply to <code>__dict__, __class__, __name__, __new__, __init__, _-str__, __repr__</code>?  "When you refer to an attribute with one of these special names, the attribute reference looks directly into a dedicated slot in <b>the class or instance object</b> and fetches the value it finds there. "</span>
<span class="comment-copy">@Tim: That snippet applies to the specific names listed in the text.  For example, see the <a href="https://github.com/python/cpython/blob/v3.6.3/Objects/typeobject.c#L369-L388" rel="nofollow noreferrer"><code>type_name</code> function</a> which is the descriptor for <code>classobj.__name__</code>. Note that it is <i>still a descriptor object</i>, so <code>classobj.__name__</code> still uses the metatype <code>__getattribute__</code> hook to find that descriptor and bind it.</span>
