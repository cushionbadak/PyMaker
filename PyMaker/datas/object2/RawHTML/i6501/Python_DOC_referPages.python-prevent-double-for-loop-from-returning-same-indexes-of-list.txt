<div class="post-text" itemprop="text">
<p>I am currently working on problem 1 in Leetcode, named "Two Sum."</p>
<blockquote>
<p>Given an array of integers, return indices of the two numbers such
  that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and
  you may not use the same element twice.</p>
<p>Example: Given <code>nums = [2, 7, 11, 15], target = 9</code>,</p>
<p>Because <code>nums[0] + nums[1] = 2 + 7 = 9</code>, return <code>[0, 1]</code>.</p>
</blockquote>
<p>My current code is:</p>
<pre><code>def twosum_indices(nums, target):
    for i in nums:
        for v in nums[i + 1:]:
            if i + v == target:
                return nums.index(i), nums.index(v)
</code></pre>
<p>In this, nums is a list of integers, and the program must return two different indexes in a list, such that their true values add up to a given target. Although this works fine on most test cases, it fails on a list like [3,3] where both values are the same, and returns the same index twice, like [0,0] instead of returning the actual answer of [0,1]. Why is this happening?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are multiple bugs in your code, not the least of which is a failure to use <code>enumerate</code> instead of <code>list.index</code>. For example, <code>[3, 3].index(3)</code> is of course always 0.</p>
<p>The focus of this answer is not to arrive at the most efficient solution, but to improve upon your specific approach. You can alternatively see the the <a href="https://stackoverflow.com/a/46627284/832230"><strong>O(n) solution</strong></a> instead.</p>
<h3>Understanding list comprehensions</h3>
<p>As a prerequisite, first understand how <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">multiple <code>for</code> loops can exist in a list comprehension</a>.</p>
<pre><code>def sums(nums):
    return [x + y for x in nums for y in nums[:x]]
</code></pre>
<p>The above is equivalent to:</p>
<pre><code>def sums(nums):
    output = []
    for x in nums:
       for y in nums[:x]:
           output.append(x + y)
    return output
</code></pre>
<h2>Solution using chained generator expression</h2>
<pre><code>def twosum_indices(nums, target):
    return next((i, j) for i in range(len(nums)) for j in range(len(nums[:i])) if (nums[i] + nums[j] == target))
</code></pre>
<p>Examples:</p>
<pre><code>print(sorted(twosum_indices([2, 7, 11, 15], 9)))
[0, 1]

print(sorted(twosum_indices([3, 3], 6)))
[0, 1]
</code></pre>
<h2>Solution using generator expression with itertools</h2>
<p>It's a tad simpler with <code>itertools</code>:</p>
<pre><code>import itertools

def twosum_indices_it(nums, target):
    return next((i, j) for (i, x), (j, y) in itertools.combinations(enumerate(nums), 2) if (x + y == target))
</code></pre>
<p>Examples:</p>
<pre><code>print(sorted(twosum_indices_it([2, 7, 11, 15], 9)))
[0, 1]

print(sorted(twosum_indices_it([3, 3], 6)))
[0, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>#! /usr/bin/env python3


def two_sum_indices(nums, target):

    def dup(i, j):
        return i == j

    d = {num: i
         for i, num in enumerate(nums)}

    for i, num in enumerate(nums):
        if target - num in d:
            if not dup(i, d[target - num]):
                return i, d[target - num]
    return -1, -1


if __name__ == '__main__':

    print(two_sum_indices([2, 7, 11, 15], target=9))
    print(two_sum_indices([3], target=6))
    print(two_sum_indices([3, 3], target=6))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def twosum_indices(nums, target):
    for i in range(len(nums)):
        for v in range(len(nums)):
            if nums[i] + nums[v] == target and i != v:
                return i, v
</code></pre>
</div>
<span class="comment-copy">You are attempting the naive brute force approach, which is O(n**2) and therefore wrong (because it will take too long when they hit you with the real data). The correct answer is O(n). However, your attempt fails to do what you think because i is a number, but you are using it as an index.</span>
<span class="comment-copy">@COLDSPEED I am sorry. I was going to, but by mistake, I clicked enter. It will not let me edit now.</span>
<span class="comment-copy">@KennyOstrom O(n) only if the array is sorted, I think.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ nah, use a <code>dict</code>, traverse the sequence adding the index to the <code>dict</code>, for each element in seq, check if the complement is in the <code>dict</code>.</span>
<span class="comment-copy">Even when you fix your index, it will be for naught when you call nums.index which always returns the first index. Try this -- for i in range(len(nums): for j in range(i, len(nums): if nums[i] == nums[j]: return i,j  (Also this works on small inputs, but is too slow ... they eventually want you to come up with a way to make two passes and NOT compare every item to every other item, but I have tried not to spoil it for you and say what that is)</span>
<span class="comment-copy">If you run this, you will find that it still has the same erroneous output.</span>
<span class="comment-copy">@KennyOstrom This code works for me, what result are you getting?</span>
<span class="comment-copy">nums = [3,3], target = 6, result = [0, 0], expected result [0, 1] because you rely on nums.index which will return the first occurance.</span>
<span class="comment-copy">@Fibo36 It now works and that's good but the computational complexity is still higher than necessary. Basically, if you've to check <code>i != v</code>, your complexity is higher than what it needs to be. You're looping through the number pairs twice, and this may be avoidable.</span>
<span class="comment-copy">@A-B-B Can you show me a more effective way of doing this?</span>
