<div class="post-text" itemprop="text">
<p>Given the following:</p>
<p>ParentModule.py</p>
<pre><code>class ParentClass():
    def __init__(self):
        pass
</code></pre>
<p>ChildModule.py</p>
<pre><code>class ChildClass(ParentClass):
    def __init__(self):
        pass
</code></pre>
<p>If, in <code>ChildModule</code>, I mistakenly import the parent <strong>module</strong> and not the parent class, i.e.:</p>
<pre><code>import ParentModule
</code></pre>
<p>instead of the correct</p>
<pre><code>from ParentModule import ParentClass
</code></pre>
<p>I will get the following error:</p>
<pre><code>TypeError: module.__init__() takes at most 2 arguments (3 given)
</code></pre>
<p>So just what are these 3 implicit arguments passed to <code>ParentModule's __init__()</code>?  What are the 2 arguments <code>ParentModule.__init__()</code> is expecting?</p>
<p>How does one take advantage of this functionality?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, the error message is a bit misleading, because it's ignoring the implicit <code>self</code> argument. It should probably say <code>takes at most 3 arguments (4 given)</code>, accounting for <code>self</code>.</p>
<p>If you take a look at the <code>help</code> output for the module type:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; help(type(sys))
</code></pre>
<p>you'll see the following:</p>
<pre><code>Help on class module in module builtins:

class module(object)
 |  module(name[, doc])
 |  
 |  Create a module object.
 |  ...
</code></pre>
<p>So the module type's <code>__init__</code> is supposed to take up to 3 arguments: <code>self</code> (not listed), <code>name</code> (the module name), and optionally <code>doc</code> (the docstring).</p>
<hr/>
<p>That's not what you're passing it. When you mistakenly do</p>
<pre><code>import ParentModule

class ChildClass(ParentModule)
</code></pre>
<p>Python assumes that <code>ParentModule</code> is a class with a weird metaclass and uses <code>type(ParentModule)</code> to find what should be the metaclass. It finds the module type, and calls it with 3 arguments: the name (<code>'ChildClass'</code>), the bases (<code>(ParentModule,)</code>), and the dict of the new class you're trying to create:</p>
<pre><code>type(ParentModule)('ChildClass', (ParentModule,), {'__init__': ..., ...})
</code></pre>
<p>This results in a call to the module type's <code>__init__</code> with 4 arguments (inserting <code>self</code> at the front), and the module type's <code>__init__</code> doesn't like that, so it throws an error.</p>
<hr/>
<p>For more reading on the details of class creation, see the <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow noreferrer">Python data model documentation on metaclasses</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you import module, the code will load <code>__init__.py</code> file in module. 
if you want to utilize init, for example preload modules, you could add code into <code>__init__.py</code></p>
<pre><code>model/
    __init__.py
    func1.py
    func2.py
</code></pre>
</div>
<span class="comment-copy">I can't reproduce. Are both modules in the same directory? The only error I get is: <code>NameError: name 'ParentClass' is not defined</code>.</span>
<span class="comment-copy">Yeah, the <code>ParentClass</code> and <code>ParentModule</code> most likely had the same name in the real code, or the real code had <code>class ChildClass(ParentModule)</code> instead of <code>class ChildClass(ParentClass)</code>.</span>
<span class="comment-copy">@ChristianDean:  Yes, the real module/class names would be Parent.Parent and Child.Child, but I felt using that terminology didn't clarify the problem.  Feel free to edit the question if you think it would be clearer that way.</span>
<span class="comment-copy">Excellent work!  I should have thought to run help() on the module object.</span>
