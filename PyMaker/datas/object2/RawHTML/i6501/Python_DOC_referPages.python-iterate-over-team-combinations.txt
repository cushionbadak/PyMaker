<div class="post-text" itemprop="text">
<p>I have a list of 10 players, each with a respective skill score. I'm trying to organise them into 2 teams of 5, where the total skill score of each team is as close as possible.</p>
<p>Iterating over every combination is obviously not very efficient as identical teams will occur.</p>
<p>Is there a python library or function that can either efficiently solve this problem or at least just iterate over the correct combinations?</p>
<p>Iterating over 10! combinations isn't so bad if that is the easiest answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>While not a perfect solution, could you take the average player skill and rank the n players based on this average.</p>
<p>Then based on these values, use some heuristic to try and "balance" out these players across the two teams. 
Simple example would be to assign teams like so (highest ranked = 10, lowest ranked = 1)</p>
<p>Team 1 = 10 7 6 3 1 </p>
<p>Team 2 = 9 8 5 4 2 </p>
<p>Again, not perfect, but much less expensive than 10! search. </p>
</div>
<div class="post-text" itemprop="text">
<p>As you said finding the perfect solution is very complex for this problem set, but you can try using greedy approach. </p>
<p>Say each player 'P' has these skills score bowling(bw) batting(b) &amp; fielding(f) now you can come up with an equation for aggregated skill(K) with sample equation <code>K = 2*bw+2*b+f</code></p>
<p>Now all you have to do is split the 10 players into 2 teams with each <code>k/2+k/2</code> approximately, which is straightforward if you use greedy approach. </p>
<h1>Greedy algorithm:</h1>
<ol>
<li>Sort all the player in descending order by their aggregated skill score(K). </li>
<li>Maintain two sides A &amp; B</li>
<li>Add the highest scorer to team A</li>
<li>Add the second highest scorer to team B</li>
<li>Keep adding the next scorer to the lowest total's team</li>
</ol>
<p>You can find the implementation here in <a href="https://en.wikipedia.org/wiki/Partition_problem#The_greedy_algorithm" rel="nofollow noreferrer">Wikipedia</a></p>
<pre><code>def find_partition(int_list):
    "returns: An attempt at a partition of `int_list` into two sets of equal sum"
    A = set()
    B = set()
    for n in sorted(int_list, reverse=True):
        if sum(A) &lt; sum(B):
           A.add(n)
        else:
           B.add(n)
    return (A, B)
</code></pre>
<p><strong>Update</strong>:
The above code doesn't consider the quality of team size, Regarding that here might be useful discussion</p>
<p><a href="https://cs.stackexchange.com/questions/33697/partition-partition-with-constraint-of-equal-size">https://cs.stackexchange.com/questions/33697/partition-partition-with-constraint-of-equal-size</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I solved this problem with <code>itertools.combinations</code> and sets, by going through each combination of the first team and using the remaining players as the second team, the search space was reduced to only 252 combinations.</p>
<pre><code>from itertools import combinations

# random dictionary of players and scores
players = {
    'abc': 1234,
    'bcd': 2345,
    'cde': 3456,
    'def': 4567,
    'efg': 5678,
    'fgh': 6789,
    'ghi': 7891,
    'hij': 8912,
    'ijk': 9123,
    'jkl': 7410
}

closest_difference = None
all_players_set = set(players.keys())

for team_a in combinations(players.keys(), 5):
    team_a_set = set(team_a)
    team_b_set = all_players_set - team_a_set

    team_a_total = sum([players[x] for x in team_a_set])
    team_b_total = sum([players[x] for x in team_b_set])

    score_difference = abs(team_a_total - team_b_total)

    if not closest_difference or score_difference &lt; closest_difference:
        closest_difference = score_difference
        best_team_a = team_a_set     
        best_team_b = team_b_set  

print("\nTeam a:")

for player in best_team_a:
    print(player)
print("with a score of " + str(sum([players[x] for x in best_team_a])))

print("\nTeam b:")

for player in best_team_b:
    print(player)
print("with a score of " + str(sum([players[x] for x in best_team_b])))
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> will give you the combinations.  We can't really help beyond that without seeing some of your code</span>
<span class="comment-copy">@PatrickHaugh Cool thanks, did you want to reply with an answer demonstrating how you would use this with say a dictionary of player to score?</span>
<span class="comment-copy">Thanks for the answer - I have been running with this exact pattern as a starting point for getting them even, but you can usually almost immediately improve the teams just by scanning over by eye</span>
<span class="comment-copy">If one player has a score much larger than everyone elses (say a score of 100 when everyone else has &lt; 10) then you would get a team of one and a team of nine, instead of two teams of five.</span>
<span class="comment-copy">Interesting approach, and good point @PatrickHaugh</span>
