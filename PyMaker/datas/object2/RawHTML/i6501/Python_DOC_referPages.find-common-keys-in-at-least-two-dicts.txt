<div class="post-text" itemprop="text">
<p>I'd like to obtain a dict of the following form (not strict):</p>
<pre><code>{65: ['Fresh', 'Frozen'],
 66: ['Fresh', 'Delicatessen'],
 75: ['Grocery', 'Detergents_Paper'],
 128: ['Fresh', 'Delicatessen'],
 154: ['Milk', 'Grocery', 'Delicatessen']}
</code></pre>
<p>when I have an input which is list of dicts. Their keys may be intersected and values - not. For example in our case we have the same key <code>65</code> in two dicts with value <code>Fresh</code> and <code>Frozen</code>.</p>
<p>This is my solution and I'd like to improve it:</p>
<pre><code>outliers = [
    {65: 'Fresh', 66: 'Fresh', 81: 'Fresh', 95: 'Fresh', 96: 'Fresh',
     128: 'Fresh', 171: 'Fresh', 193: 'Fresh', 218: 'Fresh', 304: 'Fresh',
     305: 'Fresh', 338: 'Fresh', 353: 'Fresh', 355: 'Fresh', 357: 'Fresh',
     412: 'Fresh'},

    {86: 'Milk', 98: 'Milk', 154: 'Milk', 356: 'Milk'},

    {75: 'Grocery', 154: 'Grocery'},

    {38: 'Frozen', 57: 'Frozen', 65: 'Frozen', 145: 'Frozen', 175: 'Frozen',

     264: 'Frozen', 325: 'Frozen', 420: 'Frozen', 429: 'Frozen', 439: 'Frozen'},

    {75: 'Detergents_Paper', 161: 'Detergents_Paper'},

    {66: 'Delicatessen', 109: 'Delicatessen', 128: 'Delicatessen',
     137: 'Delicatessen', 142: 'Delicatessen', 154: 'Delicatessen',
     183: 'Delicatessen', 184: 'Delicatessen', 187: 'Delicatessen',
     203: 'Delicatessen', 233: 'Delicatessen', 285: 'Delicatessen',
     289: 'Delicatessen', 343: 'Delicatessen'}
]

common_outliers = {}
for outlier in outliers:
    for idx, feature in outlier.items():
        if idx not in common_outliers:
            common_outliers[idx] = [feature]
        else:
            common_outliers[idx].append(feature)
common_outliers = {idx: features for idx, features in common_outliers.items()
                   if len(features) &gt; 1}
print(common_outliers)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import chain
from collections import defaultdict

d_dict = defaultdict(list)
for k, v in chain.from_iterable([ i.items() for i in outliers ]):
    d_dict[k].append(v)

dict(filter( lambda x:len(x[1])&gt;1, d_dict.items() ))
</code></pre>
<p>Output:</p>
<pre><code>{65: ['Fresh', 'Frozen'],
 66: ['Fresh', 'Delicatessen'],
 75: ['Grocery', 'Detergents_Paper'],
 128: ['Fresh', 'Delicatessen'],
 154: ['Milk', 'Grocery', 'Delicatessen']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> to make it easier, it allows to get rid of the key checking step:</p>
<pre><code>from collections import defaultdict

common_outliers = defaultdict(list)
for outlier in outliers:
    for idx, feature in outlier.items():
        common_outliers[idx].append(feature)

common_outliers = {idx: features for idx, features in common_outliers.items()
                    if len(features) &gt; 1}
</code></pre>
</div>
<span class="comment-copy">I think I misread it before, are you trying to filter out all entries that have only one feature in the list?</span>
<span class="comment-copy">@TomKarzes I'd like to show only those items which occurred more than 1 time.</span>
<span class="comment-copy">use a <code>defaultdict</code> or the <code>.setdefault</code> method of a normal <code>dict</code></span>
<span class="comment-copy">This kind of question seems better suited for <a href="https://codereview.stackexchange.com/">codereview.stackexchange.com</a></span>
<span class="comment-copy">You just do <code>d.setdefault(k, []).append(v)</code></span>
