<div class="post-text" itemprop="text">
<p>So I have been trying to think of how this would be possible, but nothing comes to mind. </p>
<p>I have 2 csv files with dates and data in them. The dates, however, are mismatched. I want to be able to write a code that allows me to loop through all the data, find the matching dates, and then create a text document with the date in common and the 2 data values from the separate sheets. The other alternative is matching them myself in excel. </p>
<p>Any suggestions?</p>
<p>Ex. of what I am trying to accomplish:</p>
<p>Say I have this file1: </p>
<pre><code>01/01/01 | 1 
01/02/01 | 2 
01/03/01 | 3 
01/04/01 | 4 
01/05/01 | 5 
01/06/01 | 6 
01/07/01 | 7 
01/08/01 | 8 
</code></pre>
<p>and this file2: </p>
<pre><code>01/05/01 | 9  
01/06/01 | 22 
01/07/01 | 33 
01/08/01 | 44
01/09/01 | 55
01/10/01 | 66
01/11/01 | 77
01/12/01 | 88
</code></pre>
<p>What I would hope to have returned is (after running a loop):</p>
<pre><code>01/05/01 | 5 | 9
01/06/01 | 6 | 22
01/07/01 | 7 | 33
01/08/01 | 8 | 44
</code></pre>
<p>Any help would be appreciated, thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> of lists to store the data from the CSV files, then find those items in the dict that have more than one value in the list.</p>
<pre><code>import csv
from collections import defaultdict

merged = defaultdict(list)

for filename in 'f1.csv', 'f2.csv':
    with open(filename) as f:
        for date, value in csv.reader(f, delimiter='|'):
            merged[date].append(value)

with open('out.csv', 'w') as f:
    w = csv.writer(f, delimiter='|')
    for date in sorted(merged):
        if len(merged[date]) &gt; 1:
            w.writerow([date] + merged[date])
</code></pre>
<p>This will (almost) produce the file that you require, the only difference being that the delimiter is a single <code>|</code> instead of <code>|</code> (with surrounding spaces). I also assumed that the input files are similarly delimited.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think pandas join logic is well suited for this task since you are effectively asking for an inner join as keyed by date.</p>
<p>First define a parsing function for your dates (which I added in case you needed to treat these as actual dates for further processing in python). Then load each csv file into a separate dataframe. Finally join and drop <code>NaN</code> values to get the inner join you seek (or just explicitly inner join by setting <code>how</code> parameter in <code>join</code> function). You can also easily drop the outptut dataframe into a csv file with the <code>to_csv</code> function.</p>
<p>If you are looking to get a little more creative with aggregating or joining then pandas is the way to go.</p>
<pre><code>import pandas
parser = lambda date: pandas.datetime.strptime(date.strip(), '%y/%m/%d')
dt = pandas.read_csv('H:\\one.csv', parse_dates = [0], date_parser = parser, index_col=0, delimiter="|", names = ["date", "val"])
dt2 = pandas.read_csv('H:\\two.csv', parse_dates = [0], date_parser = parser, index_col=0, delimiter="|", names = ["date", "val2"])
dt.join(dt2).dropna().to_csv("H:\\output.csv")
</code></pre>
<p>This would also work but you lose all of the date-specific functionality within python:</p>
<pre><code>import pandas
dt = pandas.read_csv('H:\\one.csv', index_col=0, delimiter="|", names = ["date", "val"])
dt2 = pandas.read_csv('H:\\two.csv', index_col=0, delimiter="|", names = ["date", "val2"])
dt.join(dt2, how='inner').to_csv("H:\\output.csv")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>Read the first record from each file, <strong>r1</strong> and <strong>r2</strong></li>
<li>Extract dates <strong>d1</strong> and <strong>d2</strong></li>
<li>while there's remaining data in both files:

<ul>
<li>if d1 == d2:

<ul>
<li>merge records and print</li>
<li>get next line of each file (new <strong>r1</strong> and <strong>r2</strong>)</li>
</ul></li>
<li>else if d1 &lt; d2

<ul>
<li>get next <strong>r1</strong></li>
</ul></li>
<li>else

<ul>
<li>get next <strong>r2</strong></li>
</ul></li>
</ul></li>
</ul>
<p>Briefly, you're stepping through both files, keeping a "bookmark" in each.  If the records match, merge them and print; advance both files.  Otherwise, advance the bookmark that's "behind" in the date.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using CSV module to read out both files, convert them to a dictionary which maps <code>date</code> =&gt; <code>list[values]</code>, then prints them.</p>
<pre><code>import csv

# Extract CSV
csv1 = []
with open('first.csv', 'r') as f1:
    csv_reader = csv.reader(f1)
    for row in csv_reader:
        csv1.append(row)

csv2 = []
with open('second.csv', 'r') as f2:
    csv_reader = csv.reader(f2)
    for row in csv_reader:
        csv2.append(row)

# Initialize dict which will map dates to values
d = {}

# Map dates to values by getting a default array and appending the values
for row in csv1:
    v = d.get(row[0], [])
    v.append(row[1])
    d[row[0]] = v

for row in csv2:
    v = d.get(row[0], [])
    v.append(row[1])
    d[row[0]] = v

# Print results
for k, v in d.items():
    values = ' | '.join(list(map(str, v)))
    print(f'{k} | {values}')
</code></pre>
</div>
<span class="comment-copy">Thanks so much, this worked perfectly!</span>
