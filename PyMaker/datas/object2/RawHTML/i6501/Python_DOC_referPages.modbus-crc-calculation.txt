<div class="post-text" itemprop="text">
<pre><code>def calcString( st, crc):
    """Given a binary string and starting CRC, Calc a final CRC-16 """
    for ch in st:
        crc = (crc &gt;&gt; 8) ^ table[(crc ^ ord(ch)) &amp; 0xFF]
    return crc
</code></pre>
<p>I am getting different CRC values for the following string values:</p>
<pre><code>051075F9000C1800000000000000000000000000002D0A0C00000000000014
</code></pre>
<p>and</p>
<pre><code>\x05\x10\x75\xF9\x00\x0C\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x2D\x0A\x0C\x00\x00\x00\x00\x00\x00\x14
</code></pre>
<p>please help me on this.</p>
<p>If i want to convert this </p>
<pre><code>051075F9000C1800000000000000000000000000002D0A0C00000000000014 
</code></pre>
<p>to</p>
<pre><code> \x05\x10\x75\xF9\x00\x0C\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x2D\x0A\x0C\x00\x00\x00\x00\x00\x00\x14
</code></pre>
<p>what should i do?.</p>
</div>
<div class="post-text" itemprop="text">
<h1>With binascii</h1>
<p>You could use <a href="https://docs.python.org/3/library/binascii.html#binascii.unhexlify" rel="nofollow noreferrer"><code>binascii.unhexlify</code></a> (thanks @JonClements):</p>
<pre><code>&gt;&gt;&gt; import binascii
&gt;&gt;&gt; binascii.unhexlify(b"051075F9000C1800000000000000000000000000002D0A0C00000000000014")b'\x05\x10u\xf9\x00\x0c\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00-\n\x0c\x00\x00\x00\x00\x00\x00\x14'
</code></pre>
<h1>With chr and int</h1>
<p>If you want to do it yourself, you could simply split your hex string in a list of 2 characters, convert it to an int and get the corresponding character with <code>chr</code>:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; crc = "051075F9000C1800000000000000000000000000002D0A0C00000000000014"
&gt;&gt;&gt; if len(crc) % 2: raise ValueError('Incorrect string. Length should be even')
&gt;&gt;&gt; xxs = re.findall('[0-9a-f]{2}', crc, re.I)
&gt;&gt;&gt; xxs
['05', '10', '75', 'F9', '00', '0C', '18', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '2D', '0A', '0C', '00', '00', '00', '00', '00', '00', '14']
&gt;&gt;&gt; ''.join(chr(int(xx, 16)) for xx in xxs)
'\x05\x10u√π\x00\x0c\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00-\n\x0c\x00\x00\x00\x00\x00\x00\x14'
</code></pre>
<p>Note that <code>"\x75"</code> is displayed as <code>"u"</code>:</p>
<pre><code>&gt;&gt;&gt; chr(int('75', 16))
'u'
</code></pre>
<p>The strings are equal, though:</p>
<pre><code>&gt;&gt;&gt; chr(int('75', 16)) == "\x75"
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is a great <a href="https://docs.python.org/2/library/binascii.html" rel="nofollow noreferrer">library</a> for binary and ASCII conversions: <code>binascii</code></p>
<p>The specific methods you need for converting an ASCII string to a HEX string are <code>binascii.unhexlify(hexstr)</code> or <code>binascii.a2b_hex(hexstr)</code> (these two are actually the same method). From the docs:</p>
<blockquote>
<p>Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of b2a_hex(). hexstr must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise a TypeError is raised.</p>
</blockquote>
<p>Example:</p>
<pre><code>plain = "051075F9000C1800000000000000000000000000002D0A0C00000000000014"
binary = binascii.unhexlify(plain)
</code></pre>
<p>Just for completeness, the opposite operations is:</p>
<pre><code>ascii = binascii.hexlify(binary) # Note: Returns lowercase hex chars
</code></pre>
</div>
<span class="comment-copy">If you <code>binascii.unhexlify</code> the first (which is the text hex representation of the second) - you'll end up with the second...</span>
<span class="comment-copy">Or just <code>binascii.unhexlify</code> which does it for you :)</span>
<span class="comment-copy">You also need to be careful with that regex - it'll silently return results (which most likely isn't desired) for strings that don't contain complete pairs... eg "F" will silently return nothing and "FAF" will ignore the last "F"... the unhexlify approach checks there's an even number and raises an error if not.</span>
<span class="comment-copy">You could, however, I'd go for <code>if len(text) % 2: raise ValueError('some warning here')</code>... That way it can be handled in the normal control flow of the program if necessary</span>
<span class="comment-copy">(might just want to change the name from <code>hex</code> - it being a builtin function...)</span>
<span class="comment-copy">Ugh... wondering whether I should point out the missing <code>)</code> on the length check... Given that you're ensured a list from <code>re.findall</code> - be it empty or of pairs, then you can check it's not empty first before converting to avoid the <code>int</code> failing for an empty string although it may still raise on invalid hexchars.... eg: <code>if not xxs: return b'' else return ..</code>...</span>
