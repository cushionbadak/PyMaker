<div class="post-text" itemprop="text">
<p>I want to convert each branch of a JSON tree structure into a list of items in that branch. I want to do it using loops but I can't access the objects using indices. </p>
<pre><code>Example JSON:
{
    "Root": { "child1": "abc",
              "child2": "def",
              "child3": { "grandchild1": "nick",
                           "grandchild2": "Sam"
                        }
             }
 }
</code></pre>
<p>I want to traverse them and store them as following: </p>
<pre><code>list1 = ['Root', "child1", "abc"]
list2 = ['Root', "child2", "def"]
list3 = ['Root', "child3", "grandchild1", "nick",]
list4 = ['Root', "child3", "grandchild2", "sam",]
</code></pre>
<p>I read the JSON as follows: </p>
<pre><code>import json

with open('sample.json') as f:
    tree = json.load(f)
</code></pre>
<p><strong>Problem:</strong> 
I wanted to loop through these items and append it to various lists but I can only access them through their keys like <code>tree['Root']</code> would give Child1, 2, 3 and then <code>tree['Root']['child3']</code> should give me the other two members. However, this method is not scalable in my use case where I have 1400 branches (pretty deep nested) in the JSON file and I want to create 1400 lists for them. </p>
<p>Any ideas how to do this efficiently? </p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow noreferrer"><code>yield from</code></a> statement from Python 3.3+ and a recursive function:</p>
<pre><code>tree = {
"Root": { "Child1": "abc",
          "Child2": "def",
          "Child3": { "grandchild1": "nick",
                      "grandchild2": "Sam"
                    }
         }
}

def walk_json(tree, path=[]):
    try:
        for root, child in tree.items():
            yield from walk_json(child, path + [root])
    except AttributeError: # in case .items() is not possible (on leaves)
        yield path + [tree]

list(walk_json(tree))
</code></pre>
<p>will output:</p>
<pre><code>[['Root', 'Child1', 'abc'],
['Root', 'Child2', 'def'],
['Root', 'Child3', 'grandchild1', 'nick'],
['Root', 'Child3', 'grandchild2', 'Sam']]
</code></pre>
</div>
<span class="comment-copy">Are all values in the structure going to be either strings or objects (dicts)?</span>
<span class="comment-copy">@glibdud all elements are dict but some of the values for a specific key within dict could be lists.</span>
<span class="comment-copy">Good answer, but a bare <code>except:</code> can make troubleshooting difficult. Probably better to use <code>except AttributeError:</code>.</span>
<span class="comment-copy">@glibdud: very True, fixed</span>
<span class="comment-copy">@Guillaume works fine. I accepted the answer but it would be great for others if you can add a basic explanation of the yield from statement.</span>
<span class="comment-copy">yield is a keyword, similar to return, the difference is that yield is a return to the generator</span>
<span class="comment-copy">@engr_s: added link to the official doc, you can also see <a href="https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3" title="in practice what are the main uses for the new yield from syntax in python 3">stackoverflow.com/questions/9708902/â€¦</a></span>
