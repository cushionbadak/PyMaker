<div class="post-text" itemprop="text">
<h2>Summary</h2>
<p>I've recently become aware of the <a href="https://docs.python.org/3/library/types.html#additional-utility-classes-and-functions" rel="nofollow noreferrer"><code>types.SimpleNamespace</code> class</a>, which is <a href="https://github.com/topper-123/Articles/blob/master/New-interesting-data-types-in-Python3.rst" rel="nofollow noreferrer">nifty as heck</a>.</p>
<p>It would be useful to create types using this class, but allow them to utilize a signature defining positional arguments instead of keyword only arguments. Allowing positional arguments would give some additional flexibility for instance creation.</p>
<p><s> My attempts at doing this are not working so I'm looking for suggestions. </s> </p>
<h2>Details</h2>
<p>If you subclass <code>types.SimpleNamespace</code> utilizing positional arguments, you'll get an error:</p>
<pre><code>&gt;&gt;&gt; class Test1(SimpleNamespace):
...  def __init__(self, a, b):
...   super().__init__(a, b)
...
&gt;&gt;&gt; Test1(1,2)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in __init__
TypeError: no positional arguments expected
</code></pre>
<p>However, you can fix this problem by simply assigning a name to the arguments when calling <code>super</code>:</p>
<pre><code>&gt;&gt;&gt; class Test2(SimpleNamespace):
...  def __init__(self, a, b):
...   super().__init__(a=a, b=b)
...
&gt;&gt;&gt; Test2(1,2)
Test2(a=1, b=2)
</code></pre>
<p>Great. But now let's say I want a method to create types like the one above without having to repeat the named arguments in the call to <code>super().__init__</code>, using the exact same code as shown to fail above. How can I do it?</p>
<p>EDIT: It turns out my problem was being caused by a simple typo. Everything works with the code shown in the answer below.</p>
<p>Since using <code>SimpleNamespace</code>with positional arguments is something others might be interested in understanding how to do, I think it would be a good idea to keep this question instead of closing it.</p>
</div>
<div class="post-text" itemprop="text">
<p>To more easily create a positional class signature for a child class when the parent class is utilizing a named argument signature, we will create a base class that takes the positional arguments and feeds them into the constructor methods as named arguments.</p>
<p>In order to do this we will need to use <code>inspect.getargspec</code>. This will allow us to match up the signature names for <code>__init__</code> with the positional values that have been pass into it.</p>
<pre><code>from types import SimpleNamespace
import inspect

class PositionalSimpleNamespaceBase(SimpleNamespace):
    def __init__(self, *args, **kwargs):
        args_name = inspect.getargspec(type(self).__init__)[0][1:]
        print('__init__ args: ', args_name)
        super().__init__(**dict(zip(args_name, args), **kwargs))

class ChildClass(PositionalSimpleNamespaceBase):
    def __init__(self, a, b):
        super().__init__(a, b)
</code></pre>
<p>Now:</p>
<pre><code>&gt;&gt;&gt; obj=ChildClass(1,2)
__init__ args:  ['a', 'b']
&gt;&gt;&gt; obj
ChildClass(a=1, b=2)
</code></pre>
<p>It works!</p>
<p>If one wishes to <em>dynamically</em> create types like this, one way to do that would be using methods similar to those used in the builtin <code>collections</code> module for <code>namedtuple</code>. One would create a template that subclasses from <code>PositionalSimpleNamespaceBase</code>, and then execute the template using the <code>exec</code> function.</p>
<p>A simplified version is below (the provided field names are not being sanitized here, so this is not safe to use as shown!):</p>
<pre><code>def positional_simple_namespace(name, fields):
    field_names = fields.replace(',',' ').split() if isinstance(fields, str) else tuple(map(str, fields))
    field_text = ', '.join(field_names)
    super_sigs = (f'{n!s} = {n!s}' for n in field_names)
    super_text = ', '.join(super_sigs)
    code = f'''class {name!s}(PositionalSimpleNamespaceBase):
        def __init__(self, {field_text}):
            super().__init__({super_text})
    '''
    namespace = {}
    exec(code, dict(PositionalSimpleNamespaceBase = PositionalSimpleNamespaceBase), namespace)
    cls = namespace[name]
    return cls
</code></pre>
<p>Use like so:</p>
<pre><code>&gt;&gt;&gt; X=positional_simple_namespace('Test', 'a b c')
&gt;&gt;&gt; X(1,2,3)
__init__ args:  ['a', 'b', 'c']
Test(a=1, b=2, c=3)
</code></pre>
</div>
<span class="comment-copy">Just to make sure I understood the problem correctly - by "dynamically create types" you mean you want to do something like <code>new_type = make_type('C3', ['a', 'b'])</code>? Something like that is very rarely a good idea.</span>
<span class="comment-copy">@Rawing I believe it is a great idea in my use case... but I'm also inexperienced. yes that's essentially correct.</span>
<span class="comment-copy">@Rawing I have a list of 30-or-so types that are very inconvenient to define and maintain using standard python syntax. It is much much easier to dynamically create them using some other data structure I have created (a <code>tuple</code> of <code>namedtuples</code>), and feeding that data structure into the dynamic type creation factory function (i.e., <code>make_type(name, my_data_structure)</code>).</span>
<span class="comment-copy">@Rawing Turns out the error was caused by a typo. Didn't see it until this morning. Everything works now.</span>
