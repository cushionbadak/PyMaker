<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; def f():
...        def __call__(x):
...             return x
... 
&gt;&gt;&gt; f(1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: f() takes 0 positional arguments but 1 was given
&gt;&gt;&gt; f.__call__(1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: f() takes 0 positional arguments but 1 was given
</code></pre>
<p>The problem is that upon defining <code>f</code> and its private subfunction <code>__call__</code>- and thence after attempting to call the function (with the thought that it'd call the <code>__call__</code> override instead) it throws an error that states the function doesn't take any arguments, yet one was passed.</p>
<p>And (obviously- in hindsight) trying to call the <code>__call__</code> method, it gives the exact same error.</p>
<p>On this, I'm confused as I thought that firstmostly, <code>f</code> would be defined, then it'll have its basic private methods created (like <code>__str__</code>, <code>__name__</code>, <code>__repr__</code> etc.) and then the definition of the explicit <code>__call__</code> method would replace the implicitly generated <code>__call__</code> method.</p>
<p>Can somebody explain either what the order of function definition is and what gets declared first and last, or explain how you would manage to override the hidden <code>__call__</code> (preferably, if possible, without using a class to mask a function).</p>
</div>
<div class="post-text" itemprop="text">
<p>The namespace in a function does not produce attributes. <code>__call__</code> is a <em>local variable</em> inside <code>f()</code>, nothing more.</p>
<p><code>def &lt;identifier&gt;(...):</code> binds the name <code>identifier</code> in the <em>current namespace</em>, and in a function that means it assigns a local name, just like <code>some_name = ...</code> would do.</p>
<p>At most, you can return that object:</p>
<pre><code>&gt;&gt;&gt; def f():
...     def __call__(x):
...         return x
...     return __call__  # return the local variable
...
&gt;&gt;&gt; f()
&lt;function f.&lt;locals&gt;.__call__ at 0x10e946400&gt;
&gt;&gt;&gt; f()(1)
1
</code></pre>
<p>It would be really surprising if all local variables in a function became attributes instead, even before you had actually executed the function!</p>
<p>However, even if you gave a function object a <code>__call__</code> attribute, <em>it still would not be used</em>. You can only use a <em>class</em> to create an object with a <code>__call__</code> method:</p>
<pre><code>class Foo:
    def __call__(self, x):
        return x

foo = Foo()
foo()  # returns 1
</code></pre>
<p>That's because <code>__call__</code> is a <em>special method</em>, and thus subject to the <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer"><em>Special method lookup</em> rules</a>, which dictate that Python would look for the method on the type of the object, not the object itself.</p>
<p>When Python evaluates <code>foo(...)</code>, if <code>foo</code> is not a function object Python will execute <code>type(foo).__call__(foo, ...)</code>. Python does this to make sure that the <code>Foo.__call__</code> method is not used when you create your instance with <code>Foo()</code>; classes are callables too but defining <code>Foo.__call__</code> should not clash with that.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you're asking to avoid is what <code>__call__</code> is for. It allows an <em>object</em> with the method to masquerade as an function. When you're defining a function, you're not creating an object with properties - there simply is no method named <code>__call__</code> defined (.. that you've defined yourself, at least) on the object representing the function <code>f</code>.</p>
<p>However, it turns out you already have a function that handles your call, namely <code>f</code>. You can also use decorators to wrap that function if necessary, or as you've suggested, create a class and instanciate an object instead.</p>
</div>
