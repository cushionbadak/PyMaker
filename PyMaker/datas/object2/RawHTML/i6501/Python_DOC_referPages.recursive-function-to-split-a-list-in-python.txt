<div class="post-text" itemprop="text">
<p>I have a function I've written to take a list of arbitrary values and to split it at certain values into sublists. Basically, I want to take a list and split it at all occurrences of a specific value, returning a list of sublists. I figured the easiest way to do this would be via a recursive function as below.</p>
<pre><code>def recsplit(L, val):
    if L.count(val)==0: # If there are no occurrences, return the whole list
        return L
    elif L.index(val)==0: # If the value is the first element, return everything else
        return recsplit(L[1:],val)
    else: # Otherwise, split at the first instance of value
        return L[:L.index(val)], recsplit(L[L.index(val)+1:],val)
</code></pre>
<p>The function <strong>should</strong> work like this:</p>
<pre><code>&gt;&gt;&gt; P = [1,2,3,4,5,None,None,6,7,8,None,9,10,11,None]
&gt;&gt;&gt; recsplit(P,None) 
[[1,2,3,4,5],[6,7,8],[9,10,11]]
</code></pre>
<p>Unfortunately I get the following output:</p>
<pre><code>([1, 2, 3, 4, 5, 6, 7], ([8, 9, 10, 11], ([12, 13, 14, 15], [])))
</code></pre>
<p>I'm sure there's a way to handle this, but I have tried as many combinations I can think of and none seem to work for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think recursion is the easiest way to do this, when you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>from itertools import groupby

lst = [list(g) for k, g in groupby(P, lambda x: x is not None) if k]
print(lst)
# [[1, 2, 3, 4, 5], [6, 7, 8], [9, 10, 11]]
</code></pre>
<p><sub>Also keep in mind that recursion is not cheap</sub>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As someone already pointed out, recursive function might not be the best way (at least in python) for this specific task. But since you asked, here is the code with recursive call to generate the exact output you expected.</p>
<pre><code>def recsplit(L, val, out=[[]]):
    if L == []:
        return out
    elif L[0] == val and out[-1] != [] and L[1:].count(val) != len(L[1:]):
        return recsplit(L[1:], val, out + [[]])
    elif L[0] != val and L[0] is not None:
        return recsplit(L[1:], val, out[:-1] + [out[-1] + [L[0]]])
    else:
        return recsplit(L[1:], val, out)

P = [1,2,3,4,5,None,None,6,7,8,None,9,10,11,None]
P1 = [1,2,None,3,4,5,None,"x","x",None,6,7,8,"x",9,10,11,None,"x","x"]  
print("Subs of P by None =", recsplit(P,None))
print("Subs of P1 by x =", recsplit(P1,"x"))
print("Subs of P1 by None =", recsplit(P1,None))
</code></pre>
<p>==&gt;</p>
<pre><code>Subs of P by None = [[1, 2, 3, 4, 5], [6, 7, 8], [9, 10, 11]]
Subs of P1 by x = [[1, 2, 3, 4, 5], [6, 7, 8], [9, 10, 11]]
Subs of P1 by None = [[1, 2], [3, 4, 5], ['x', 'x'], [6, 7, 8, 'x', 9, 10, 11], ['x', 'x']]
</code></pre>
</div>
<span class="comment-copy">do you <i>have</i> to use recursion for this?</span>
