<div class="post-text" itemprop="text">
<p>I have a flat list of coordinates:</p>
<pre><code>points=[x1,y1,x2,y2,...,xN,yN]
</code></pre>
<p>and I need to add an offset pair (dx,dy) to all of them:</p>
<pre><code>points=[x1+dx,y1+dy,x2+dx,y2+dy,...,xN+dx,yN+dy]
</code></pre>
<p>Since this is done quite often, efficiency is important. Is there a better method than</p>
<pre><code>for i in range(0,len(points),2):
    points[i]+=dx
    points[i+1]+=dy
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can add more elegance to the code by using <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle</code></a>, and adding elements from the cycle object in turns:</p>
<pre><code>from itertools import cycle

cyc = cycle([dx, dy])
for i in range(len(points)):
    points[i] += next(cyc)
</code></pre>
<p>You could easily extend this into a list comprehension if you need to create a new list:</p>
<pre><code>from itertools import cycle

cyc = cycle([dx, dy])
lst = [x + next(cyc) for x in points]
</code></pre>
<p>OTOH, if you want to go super efficient you can perform the addition using numpy (requires installation of numpy):</p>
<pre><code>import numpy as np

points = np.array(...)
points[::2] += dx
points[1::2] += dy
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is <code>numpy</code> allowed. I would use <code>numpy</code> for this kind of thing:</p>
<pre><code>points = points.reshape(-1, 2)
points += np.array([dx, dy])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So, using the suggestions above, a quick performance test. Since I need a copy of the input list, I do an explicit copy if the code is not doing one:</p>
<pre><code>import timeit
from itertools import cycle


def plainLoop(pointsIn,dx,dy):
    pointsOut=pointsIn[:]
    for i in range(0,len(pointsOut),2):
        pointsOut[i]+=dx
        pointsOut[i+1]+=dy
    return pointsOut

def cycleAndLoop(pointsIn,dx,dy):
    offsets = cycle([dx, dy])
    pointsOut=pointsIn[:]
    for i in range(len(pointsOut)):
        pointsOut[i] += next(offsets)
    return pointsOut

def cycleAndComprehension(pointsIn,dx,dy):
    offsets = cycle([dx, dy])
    pointsOut=[c+next(offsets) for c in pointsIn]
    return pointsOut

points=[float(i) for i in range(50*6)]

number=1000
repeat=1000

print 'plainLoop:',             min(timeit.repeat('plainLoop(points,.1,.2)',setup='from __main__ import plainLoop,points',number=number,repeat=repeat))
print 'cycleAndLoop:',          min(timeit.repeat('cycleAndLoop(points,.1,.2)',setup='from __main__ import cycleAndLoop,points',number=number,repeat=repeat))
print 'cycleAndComprehension:', min(timeit.repeat('cycleAndComprehension(points,.1,.2)',setup='from __main__ import cycleAndComprehension,points',number=number,repeat=repeat))
</code></pre>
<p>The size of the input array (50*6) is representative of the number of triplets that describe a character in many fonts. The results:</p>
<pre><code>             cycleAndLoop:: min: 3.718e-01, avg: 3.926e-01, max: 4.301e-01
    cycleAndComprehension:: min: 2.999e-01, avg: 3.144e-01, max: 3.388e-01
                plainLoop:: min: 1.908e-01, avg: 2.034e-01, max: 2.364e-01
</code></pre>
<p>So yes, the plain loop is the fastest of the lot, but the 50% performance penalty of the cycle() solution in a comprehension is compensated by the terseness of the code.</p>
</div>
<span class="comment-copy">Why are your coordinates in a flat list rather than a list of tuples?</span>
<span class="comment-copy">Your code looks as good as possible for this data.</span>
<span class="comment-copy">@Barmar Bezier splines in Gimp's Python API.</span>
<span class="comment-copy">These may be more elegant, but is it really possible that they're more efficient than the simple loop in his original code?</span>
