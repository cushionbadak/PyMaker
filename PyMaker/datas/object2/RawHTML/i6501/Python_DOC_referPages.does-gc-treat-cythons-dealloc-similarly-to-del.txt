<div class="post-text" itemprop="text">
<p>Python's optional garbage collector <a href="https://docs.python.org/3/library/gc.html" rel="nofollow noreferrer"><code>gc</code></a> ignores cycles that <a href="https://docs.python.org/3/library/gc.html#gc.garbage" rel="nofollow noreferrer">contain any object with a <code>__del__</code> method</a>:</p>
<blockquote>
<p>Changed in version 3.4: Following PEP 442, objects with a <code>__del__()</code> method donâ€™t end up in <code>gc.garbage</code> anymore.</p>
</blockquote>
<p>Cython extension types can have a <code>__dealloc__</code> method, but <a href="http://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#finalization-method-dealloc" rel="nofollow noreferrer">no <code>__del__</code> method</a>:</p>
<blockquote>
<p>Note: There is no <code>__del__()</code> method for extension types.</p>
</blockquote>
<p>For the purpose of collecting cycles, is the presence of <code>__dealloc__</code> treated by the garbage collector as if a <code>__del__</code> method is present? Or is <code>__dealloc__</code> invisible to the garbage collector?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you look at the generated C code you can see that Cython generates the destructor in the <code>tp_dealloc</code> slot, rather than the <code>tp_del</code> slot</p>
<pre><code>cdef class B:
    def __dealloc__(self):
        pass
</code></pre>
<p>generates:</p>
<pre><code>static PyTypeObject __pyx_type_5cy_gc_B = {
  PyVarObject_HEAD_INIT(0, 0)
  "cy_gc.B", /*tp_name*/
  sizeof(struct __pyx_obj_5cy_gc_B), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5cy_gc_B, /*tp_dealloc*/

  /* lines omitted */

  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX &gt;= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
</code></pre>
<p>You can easily verify that this is the case for other examples too (e.g. classes with automatically generated <code>__dealloc__</code>).</p>
<p><a href="https://docs.python.org/3/library/gc.html#gc.garbage" rel="nofollow noreferrer">Therefore, for Python 3.4+</a>:</p>
<blockquote>
<p>Starting with Python 3.4, this list should be empty most of the time, except when using instances of C extension types with a non-NULL tp_del slot.</p>
</blockquote>
<p>Cython classes should not end up in this list of uncollectable stuff since they don't have <code>tp_del</code> defined.</p>
<hr/>
<p>For earlier versions of Python I think you're also fine. Mostly because  you still don't have a <code>__del__</code> method, but also because <a href="http://cython.readthedocs.io/en/latest/src/userguide/extension_types.html#controlling-cyclic-garbage-collection-in-cpython" rel="nofollow noreferrer">cython automatically generates <code>tp_traverse</code> and <code>tp_clear</code> functions</a> that should allow Python to break reference cycles involve Cython classes.</p>
<p>You can disable the generation of these <code>tp_traverse</code> and <code>tp_clear</code> functions. I'm a little unclear on what happens to objects that are in a reference cycle but don't have methods to detect it, or to break it. It's quite likely that they just continue to exist somewhere, but are inaccessible.</p>
<hr/>
<p>I think the concern (before Python 3.4) was that <code>__del__</code> methods could make an object accessible again:</p>
<pre><code>class C:
   def __del__(self):
      global x
      x = self
</code></pre>
<p><code>__dealloc__</code> is called after the point of no return, and so this isn't allowed (you just get a segmentation fault if you access <code>x</code>). Therefore they don't have to be stuck in <code>gc.garbage</code> in their indeterminate state.</p>
</div>
