<div class="post-text" itemprop="text">
<p>I have a list <code>a</code> with a few elements. I have another list <code>b</code> with more elements. I need to extend <code>a</code> to match <code>b</code> in size, using zeros to fill. In the new list that will come out, the original <code>a</code> sits in a position determined by <code>b</code>, as explained by example in the following.<br/>
Small example of my situation:</p>
<pre><code>a = [3, 4, 5]

b = [1.2, 2.5, 3.7, 4.3, 5.1, 6.3, 7.3, 8.9]
</code></pre>
<p>I need </p>
<pre><code>[0, 0, 3, 4, 5, 0, 0, 0]
</code></pre>
<p>The first non-zero element is in third position here, to match where <code>b</code> becomes equal or greater than 3, and similarly the last non-zero element is in fifth position as a result of the comparison with <code>b</code>.</p>
<p>The final output is always <code>len(b)</code>; if there are too many zeros at the start to fit all of <code>a</code>, then elements from <code>a</code> are dropped.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = [3, 4, 5]
b = [1.2,2.5,3.7,4.3,5.1,6.3,7.3,8.9]

b.sort()  # Ensure they are sorted

start_zero_till = len(b) - len(a)
for i in range(len(b)):
    if a[0] &lt; b[i]:
        start_zero_till = i
        break

revised_a = [0] * start_zero_till
revised_a.extend(a)
revised_a.extend([0] * (len(b) - len(revised_a)))

print(revised_a)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use bisection to find the first position in <code>b</code> greater or equal to <code>a[0]</code>, with the <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code> module</a></p>
<pre><code>import bisect

def zero_pad(a, b):
    pos = bisect.bisect(b, a[0])
    remainder = len(b) - len(a) - pos
    return ([0] * pos + a + [0] * remainder)[:len(b)]
</code></pre>
<p>Bisection lets you find the point in O(logN) time.</p>
<p>An alternative is to use a generator function; loop over <code>b</code> and yield <code>0</code>s until an equal or larger value to <code>a[0]</code> is found, then yield <code>a</code> until exhausted and go back to zeros:</p>
<pre><code>def zero_pad_gen(a, b, _sentinel=object()):
    a = iter(a)
    nexta = next(a, _sentinel)
    for bval in b:
        if nexta is _sentinel or bval &lt; nexta:
            yield 0
        else:
            yield nexta
            nexta = next(a, _sentinel)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; a = [3, 4, 5]
&gt;&gt;&gt; b = [1.2, 2.5, 3.7, 4.3, 5.1, 6.3, 7.3, 8.9]
&gt;&gt;&gt; zero_pad(a, b)
[0, 0, 3, 4, 5, 0, 0, 0]
&gt;&gt;&gt; list(zero_pad_gen(a, b))
[0, 0, 3, 4, 5, 0, 0, 0]
</code></pre>
<p>and for edge cases; <code>b</code> too short, dropping values from <code>a</code>:</p>
<pre><code>&gt;&gt;&gt; zero_pad(a, b[:-4])
[0, 0, 3, 4]
&gt;&gt;&gt; list(zero_pad_gen(a, b[:-4]))
[0, 0, 3, 4]
</code></pre>
<p>First value of <code>b</code> matching:</p>
<pre><code>&gt;&gt;&gt; zero_pad([1, 2] + a, b)
[1, 2, 3, 4, 5, 0, 0, 0]
&gt;&gt;&gt; list(zero_pad_gen([1, 2] + a, b))
[1, 2, 3, 4, 5, 0, 0, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this</p>
<pre><code>for i in b:
    if int(i) not in a:
        a.insert(b.index(i),0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try this with list comprehensions</p>
<pre><code>a = [3, 4, 5]
b = [1.2, 2.5, 3.7, 4.3, 5.1, 6.3, 7.3, 8.9]
num=[c for c,e in enumerate(b) if e&gt;=a[0]][0]
c=[0 for e in range(num)]+a+[0 for e in range(len(b)-num-len(a))]
print(c)
</code></pre>
</div>
<span class="comment-copy">So your input lists are sorted?</span>
<span class="comment-copy">@MartijnPieters yes</span>
<span class="comment-copy">What happens if <code>a[pos] == b[pos]</code>, so there is a <code>3.0</code> in <code>b</code>?</span>
<span class="comment-copy">@MartijnPieters then 'pos' will be the position of the first non zero element</span>
<span class="comment-copy">And what happens if <code>b</code> has more than 3 elements outside the 'range' of <code>a</code>? Say <code>b = [0.1, 2.1, 3.0, 3.5, 4.1, 5.8, 6.6, 7]</code>? Or are you basically aligning your <code>a[0]</code> with a value in <code>b</code> only, then matching the length?</span>
<span class="comment-copy">just tried this and I got [0, 3, 4, 5, 0, 0, 0]</span>
<span class="comment-copy">@johnhenry: ah, yes, off by one error on my part, because <code>bisect_left</code> returns the insertion position <i>before</i>.</span>
<span class="comment-copy">now I got [0, 0, 3, 4, 5, 0, 0]</span>
<span class="comment-copy">@johnhenry: All fixed.</span>
