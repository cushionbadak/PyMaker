<div class="post-text" itemprop="text">
<p>For each occurrence of a certain word, I need to display the context by showing about 5 words preceding and following the occurrence of the word. </p>
<p>Example output for the word 'stranger' in a text file of content when you enter <code>occurs('stranger', 'movie.txt')</code>:</p>
<p>My code so far:</p>
<pre><code>def occurs(word, filename):

    infile = open(filename,'r')
    lines = infile.read().splitlines()
    infile.close()

    wordsString = ''.join(lines)
    words = wordsString.split()
    print(words)

    for i in range(len(words)):
        if words[i].find(word):
            #stuck here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd suggest slicing <code>words</code> depending on <code>i</code>:</p>
<pre><code>print(words[i-5:i+6])
</code></pre>
<p>(This would go where your comment is)</p>
<p>Alternatively, to print as shown in your example:</p>
<pre><code>print("...", " ".join(words[i-5:i+6]), "...")
</code></pre>
<p>To account for the word being in the first 5:</p>
<pre><code>if i &gt; 5:
    print("...", " ".join(words[i-5:i+6]), "...")
else:
    print("...", " ".join(words[0:i+6]), "...")
</code></pre>
<p>Additionally, <code>find</code> is not doing what you think it is. If <code>find()</code> doesn't find the string, it returns <code>-1</code> which evaluates to <code>True</code> when used in a if statement. Try:</p>
<pre><code>if word in words[i].lower():
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This retrieves the index of every occurrence of the word in <code>words</code>, which is a list of all words in the file. Then slicing is used to get a list of the matched word and the 5 words before and after.</p>
<pre><code>def occurs(word, filename):
    infile = open(filename,'r')
    lines = infile.read().splitlines()
    infile.close()

    wordsString = ''.join(lines)
    words = wordsString.split()

    matches = [i for i, w in enumerate(words) if w.lower().find(word) != -1]

    for m in matches:
        l = " ".join(words[m-5:m+6])
        print(f"... {l} ...")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Consider the <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.adjacent" rel="nofollow noreferrer"><code>more_itertools.adajacent</code></a> tool.</p>
<p><strong>Given</strong></p>
<pre><code>import more_itertools as mit


s = """\
But we did not answer him, for he was a stranger and we were not used to, strangers and were shy of them.
We were simple folk, in our village, and when a stranger was a pleasant person we were soon friends.
"""

word, distance = "stranger", 5
words = s.splitlines()[0].split()
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>neighbors = list(mit.adjacent(lambda x: x == word, words, distance))

" ".join(word for bool_, word in neighbors if bool_)
# 'him, for he was a stranger and we were not used'
</code></pre>
<hr/>
<p><strong>Details</strong></p>
<p><code>more_itertools.adjacent</code> returns an iterable of tuples, e.g. (<code>bool</code>, item) pairs.  A <code>True</code> boolean is returned for words in the string that satisfy the predicate.  Example:</p>
<pre><code>&gt;&gt;&gt; neighbors
[(False, 'But'),
 ...
 (True, 'a'),
 (True, 'stranger'),
 (True, 'and'),
 ...
 (False, 'to,')]
</code></pre>
<p>Neighboring words are filtered from the results given a <code>distance</code> from the target word.</p>
<p><em>Note:  <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> is a third-party library. Install by <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>pip install more_itertools</code></a>.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>Whenever I see rolling views of files, I think <a href="https://docs.python.org/3/library/collections.html?highlight=deque#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a></p>
<pre><code>import collections

def occurs(needle, fname):
    with open(fname) as f:
        lines = f.readlines()

    words = iter(''.join(lines).split())

    view = collections.deque(maxlen=11)
    # prime the deque
    for _ in range(10):  # leaves an 11-length deque with 10 elements
        view.append(next(words, ""))
    for w in words:
        view.append(w)
        if view[5] == needle:
            yield list(view.copy())
</code></pre>
<p>Note that this approach intentionally does not handle any edge cases for <code>needle</code> names in the first 5 words or the last 5 words of the file. The question is ambiguous as to whether matching the third word should give the first through ninth words, or something different.</p>
</div>
<span class="comment-copy">Print the preceeding words. If the current word is position <code>i</code> then the word before it is at position <code>i - ...</code> ?</span>
<span class="comment-copy">Please show the expected results for a given input</span>
<span class="comment-copy">I tried that however this is the output and text file: <a href="https://imgur.com/a/5qdmK" rel="nofollow noreferrer">imgur.com/a/5qdmK</a>.</span>
<span class="comment-copy">I believe I have fixed the issue @sam44</span>
<span class="comment-copy">Maybe <code>if word in w.lower()</code>? To account for punctuation and capitalization.</span>
<span class="comment-copy">@ElliotRoberts Good point. Should have used <code>find()</code> instead of checking equality as well.</span>
