<div class="post-text" itemprop="text">
<pre><code>my_dict = {'a': 1}
</code></pre>
<p>I wish for <code>my_dict['a']</code> to behave the same as <code>my_dict.get('a')</code>
That way, if I do <code>my_dict['b']</code>, I will not raise an error but get the default <code>None</code> value, the same way you would get it from <code>my_dict.get('b')</code></p>
<p>In the case of <code>my_dict = {'a': {'b': 2}}</code> I could do <code>my_dict['a']['b']</code> and it would act as <code>my_dict.get('a').get('b')</code></p>
<p>When doing <code>my_dict['b'] = 2</code> it will act same as <code>my_dict.update({'b': 2})</code></p>
<p>Is it possible to do so that I will not have to inherit from dict?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict()</code> object</a> to <em>add</em> a new value to the dictionary each time you try to access a non-existing key:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(lambda: None)
&gt;&gt;&gt; d['a'] is None
True
&gt;&gt;&gt; d
defaultdict(&lt;function &lt;lambda&gt; at 0x10f463e18&gt;, {'a': None})
</code></pre>
<p>If you don't want the key added, create a subclass of <code>dict</code> that implements the <a href="https://docs.python.org/3/reference/datamodel.html#object.__missing__" rel="nofollow noreferrer"><code>__missing__</code> method</a>:</p>
<pre><code>class DefaultNoneDict(dict):
    def __missing__(self, key):
        return None
</code></pre>
<p>This explicitly won't add new keys:</p>
<pre><code>&gt;&gt;&gt; d = DefaultNoneDict()
&gt;&gt;&gt; d['a'] is None
True
&gt;&gt;&gt; d
{}
</code></pre>
<p>If you wanted to <em>chain</em> <code>.get()</code> calls, you'll have to return an empty dictionary instead, otherwise <code>dict.get(keyA).get(keyB)</code> will fail with an attribute error (the first <code>None</code> returned won't have a <code>.get()</code> method).</p>
<p>Generally speaking, it is better to stick to the default type and be explicit. There is nothing wrong with:</p>
<pre><code>value = some_d.get(outer, {}).get(inner)
</code></pre>
<p>Using a <code>defaultdict</code> or a <code>dict</code> subclass with custom <code>__missing__</code> hook have a downside: they will <em>always</em> produce a default when the key is missing, even when you accidentally produced incorrect keys somewhere else in your code. I often opt for an explicit <code>dict.get()</code> or <code>dict.setdefault()</code> codepath over <code>defaultdict</code> precisely because I want a non-existing key to produce an error in other parts of my project.</p>
</div>
<span class="comment-copy">Why don't you want to use <code>dict.get()</code>?</span>
<span class="comment-copy"><code>my_dict.get('a').get('b')</code> will raise <code>AttributeError: 'NoneType' object has no attribute 'get'</code>.</span>
