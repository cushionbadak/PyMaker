<div class="post-text" itemprop="text">
<p>I understand that <code>__dict__</code>  in <code>obj.__dict__</code> is a descriptor attribute of <code>type(obj)</code>, so the lookup for <code>obj.__dict__</code> is <code>type(obj).__dict__['__dict__'].__get__(obj)</code>.</p>
<p>From <a href="https://stackoverflow.com/a/46576009">https://stackoverflow.com/a/46576009</a></p>
<blockquote>
<p>It's tempting to say that <code>__dict__</code> has to be a descriptor because
  implementing it as a <code>__dict__</code> entry would require you to find the
  <code>__dict__</code> before you can find the <code>__dict__</code>, but <strong>Python already
  bypasses normal attribute lookup to find <code>__dict__</code> when looking up
  other attributes</strong>, so that's not quite as compelling as it initially
  sounds. If the descriptors were replaced with a <code>'__dict__'</code> key in
  every <code>__dict__</code>, <code>__dict__</code> would still be findable.</p>
</blockquote>
<p>How does "Python already bypasses normal attribute lookup to find <code>__dict__</code>"? What does "normal attribute lookup" mean? </p>
<p>According to the context of the quote in the link, I don't think when the author wrote that, he referred to   that the lookup for <code>obj.__dict__</code> is <code>type(obj).__dict__['__dict__'].__get__(obj)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Normal attribute lookup is done by calling the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code> hook</a>, or more precisely, the <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_getattro" rel="nofollow noreferrer">C-API <code>tp_getattro</code> slot</a>. The default implementation for this is in the <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_GenericGetAttr" rel="nofollow noreferrer"><code>PyObject_GenericGetAttr</code> C-API function</a>.</p>
<p>It is the job of <code>PyObject_GenericGetAttr</code> to invoke descriptors if they exist, and to look at the instance <code>__dict__</code>. And indeed, there <em>is</em> a <code>__dict__</code> descriptor, but it is faster for <code>__getattribute__</code> to just access the <code>__dict__</code> slot in the instance memory structure directly, and that is what <a href="https://github.com/python/cpython/blob/v3.6.3/Objects/object.c#L1065-L1086" rel="nofollow noreferrer">the actual implementation</a> does:</p>
<pre class="lang-c prettyprint-override"><code>if (dict == NULL) {
    /* Inline _PyObject_GetDictPtr */
    dictoffset = tp-&gt;tp_dictoffset;
    if (dictoffset != 0) {
        if (dictoffset &lt; 0) {
            Py_ssize_t tsize;
            size_t size;

            tsize = ((PyVarObject *)obj)-&gt;ob_size;
            if (tsize &lt; 0)
                tsize = -tsize;
            size = _PyObject_VAR_SIZE(tp, tsize);
            assert(size &lt;= PY_SSIZE_T_MAX);

            dictoffset += (Py_ssize_t)size;
            assert(dictoffset &gt; 0);
            assert(dictoffset % SIZEOF_VOID_P == 0);
        }
        dictptr = (PyObject **) ((char *)obj + dictoffset);
        dict = *dictptr;
    }
}
</code></pre>
<p>Note the <em>Inline <code>_PyObject_GetDictPtr</code></em> comment; this is a performance optimisation, as instance attribute lookups are frequent.</p>
<p>If you try to access <code>instance.__dict__</code> fromPython code, then the descriptor is invoked; it is a data descriptor object so is invoked before instance attributes are even looked at. </p>
</div>
<span class="comment-copy">I've noticed @Tim that that you often add a salutatory remark to your question. While this is certainly consider polite when speaking with someone face to face, it only adds noise to posts on Stack Overflow. Please see <a href="https://meta.stackoverflow.com/questions/328379/why-are-fellow-users-removing-thank-yous-from-my-questions"><i>Why are fellow users removing thank-you's from my questions?</i></a> for further details</span>
<span class="comment-copy">You may find this of interest: <a href="https://stackoverflow.com/questions/39379351/changing-getattr-during-instantiation" title="changing getattr during instantiation">stackoverflow.com/questions/39379351/â€¦</a></span>
<span class="comment-copy">Thanks. Does the lookup process for <code>__dict__</code> also apply to other attributes whose names both begin and end with two underscores, such as <code>__name__</code>, <code>__class__</code>, <code>__new__</code>, <code>__init__</code>, <code>__str__</code>, <code>__repr__</code>?</span>
<span class="comment-copy"><a href="https://stackoverflow.com/q/46594480">will the lookup for self-defined attributes whose names both begin and end with two underscores (e.g. <code>__madeupAttribute__</code>)   be the same as the lookup for those special attributes?</a></span>
<span class="comment-copy">@Tim: no, this isn't about special names, that <code>__dict__</code> is a special name has nothing to do with it. The attribute lookup process needs access to that specific object <i>every time you look up an attribute that is not a data descriptor</i>, so the access path is optimised.</span>
<span class="comment-copy">@Tim: Special names are subject to <a href="https://docs.python.org/3/reference/datamodel.html#special-lookuphttps://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">different lookup rules</a>, but that happens in the code trying to access them. For example, the <code>hash()</code> function will explicitly use <code>type(obj).__hash__(obj)</code> rather than <code>obj.__hash__()</code>. It is the responsibility of the code accessing special attributes to treat them special.</span>
<span class="comment-copy">@Tim: double-underscore names are "reserved", by convention only, see the <a href="https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers" rel="nofollow noreferrer"><i>Reserved classes of identifiers</i> section</a> of the lexical analysis documentation. You are free to make up your own, but you can't count on forward compatibility. If you want to use <code>__madeupAttribute__</code> and a future Python version wants to assign special meaning to that name, then your code could break on that Python version.</span>
