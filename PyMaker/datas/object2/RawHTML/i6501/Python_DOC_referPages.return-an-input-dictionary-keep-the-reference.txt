<div class="post-text" itemprop="text">
<p>I have a program where a dictionary of some properties must be copied for each year in my simulation, and some few keys have to be updated. But, when I sent a dictionary to a function, change it inside the function and than return it, the returned dictionary keep as a reference to the original one. Let me show a simple example with the code below.</p>
<pre><code>def change(dict_in):
    dict_in['value'] = 50
    return dict_in

props = [{'value':12}]
props.append(change(props[-1]))
props
[{'value': 50}, {'value': 50}]
</code></pre>
<p>However as one can see above, the property 'value' was changed in the first dict too.</p>
<p>When I use the copy.deepcopy function than it works as expected:</p>
<pre><code>import copy
props = [{'value':12}]
props.append( change( copy.deepcopy(props[-1]) ) )
props
[{'value': 12}, {'value': 50}]
</code></pre>
<p>But is this the only way to make it work!?</p>
</div>
<div class="post-text" itemprop="text">
<h1><code>dict.update()</code> approach</h1>
<pre><code>def change(dict_in):
    new_dict = {}
    new_dict.update(dict_in)
    new_dict['value'] = 50
    return new_dict

props = [{'value':12}]
props.append(change(props[-1]))
props
[{'value': 50}, {'value': 50}]
</code></pre>
<p><code>d1.update(d2)</code> does not return the result, it modifies <code>d1</code> in order to include <code>d2</code> values. That's why I first create a new empty <code>dict</code> and copy the input values into it.</p>
<h1><code>dict()</code> approach</h1>
<pre><code>def change(dict_in):
    new_dict = dict(dict_in)
    new_dict['value'] = 50
    return new_dict

props = [{'value':12}]
props.append(change(props[-1]))
props
[{'value': 50}, {'value': 50}]
</code></pre>
<p>Similar to the previous version but using the <code>dict</code> constructor</p>
<h1><code>dict</code> comprehension approach</h1>
<pre><code>def change(dict_in):
    new_dict = {k: v for k, v in dict_in.items()}
    new_dict['value'] = 50
    return new_dict

props = [{'value':12}]
props.append(change(props[-1]))
props
[{'value': 50}, {'value': 50}]
</code></pre>
<p>And another copy method using <code>dict</code> comprehensions.</p>
<h1><code>**kwargs</code> approach</h1>
<pre><code>def change(**kwargs):
    kwargs['value'] = 50
    return kwargs

props = [{'value':12}]
props.append(change(**props[-1]))
props
[{'value': 50}, {'value': 50}]
</code></pre>
<p>The <code>**</code> notation before a function formal parameter (in the <code>def</code> line) means that the keyword arguments that are not explicitely specified will be stored as a <code>dict</code>. <code>kwargs</code> is a common name for this variable. A single <code>*</code> works similar for positional arguments storing them in a <code>list</code>.</p>
<p>The <code>**</code> notation when calling a function means the opposite, extract the <code>dict</code> values into keyword arguments. Same with <code>*</code> and lists.</p>
<p>This way we are extracting <code>props[-1]</code> which is the original <code>dict</code> into a set of keyword arguments and creating a new <code>dict</code> with <code>**kwargs</code>. I actually like this approach as you let Python handle the new <code>dict</code> creation but you have to remember to use the <code>**</code> when calling change.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the problem you see with <code>deepcopy</code> and <code>update</code> is that a copy of the dictionary will be created after each iteration of your simulation, you could consider using an immutable dictionary type. Unfortunately, immutable dicts are not supplied by the python standard library. However, the data structure is available in libraries such as <a href="https://github.com/tobgu/pyrsistent" rel="nofollow noreferrer">pyrsistent</a>. From the pyristent docs of <a href="https://github.com/tobgu/pyrsistent#pmap" rel="nofollow noreferrer">pmap</a>:</p>
<pre><code>&gt;&gt;&gt; from pyrsistent import m, pmap, v

# No mutation of maps once created, instead they are
# "evolved" leaving the original untouched
&gt;&gt;&gt; m1 = m(a=1, b=2)
&gt;&gt;&gt; m2 = m1.set('c', 3)
&gt;&gt;&gt; m3 = m2.set('a', 5)
&gt;&gt;&gt; m1
pmap({'a': 1, 'b': 2})
&gt;&gt;&gt; m2
pmap({'a': 1, 'c': 3, 'b': 2})
&gt;&gt;&gt; m3
pmap({'a': 5, 'c': 3, 'b': 2})
&gt;&gt;&gt; m3['a']
5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If it fits into your program, you can divide the data into two parts: the constant base which remains the same (and which you are now copying from one simulation round to the next) and the rest, i.e. the changes or updates. You can join the two parts using the <a href="https://docs.python.org/3/library/collections.html#chainmap-objects" rel="nofollow noreferrer">ChainMap</a>. It is available on Python 3, but it might be worth to backport it if you are using Python 2.</p>
<p>Here is an example.</p>
<pre><code>from collections import ChainMap

base = dict(a=1, b=2, c=3, d=4)

updates = [ 
    dict(a=99),
    dict(b=99),
    dict(a=0, b=0, c=0),
    ]   

for i, update in enumerate(updates, 1): 
    combined = ChainMap(update, base)
    print("#{}: a={}, b={} c={} d={}".format(
        i, combined['a'], combined['b'], combined['c'], combined['d']))

#1: a=99, b=2 c=3 d=4
#2: a=1, b=99 c=3 d=4
#3: a=0, b=0 c=0 d=4
</code></pre>
</div>
<span class="comment-copy">you can use update method of dict</span>
<span class="comment-copy"><code>update()</code> would be useful to replace the <code>change()</code> function, but changes the original dictionary too.</span>
<span class="comment-copy">This approach also creates a new <code>dict</code>-like object every iteration. You just leave an external library do the trick. I would not include an external library just for this feature when there are simpler solutions.</span>
<span class="comment-copy">@Adirio No, immutable data structures don't work that way. The result of <code>.set()</code> will not create a copy of all the values in the dict. <code>m2</code> is just a different view on the original dict <code>m1</code> with the key <code>c</code> changed. This is the only thing <code>m2</code> tracks.</span>
<span class="comment-copy">From <a href="https://github.com/tobgu/pyrsistent" rel="nofollow noreferrer">Pyrsistent Github</a>: "<i>All methods on a data structure that would normally mutate it instead return a new copy of the structure containing the requested updates. The original structure is left untouched.</i>"</span>
<span class="comment-copy">@Adirio I invite you to check the <a href="https://github.com/tobgu/pyrsistent/blob/master/pyrsistent/_pmap.py#L146" rel="nofollow noreferrer">implementation of pmap</a> if you're still not convinced. Untouched data is shared between the different data structures.</span>
<span class="comment-copy">Check the <code>Pmap.evolver()</code> method documentation or the <code>_Evolver.persistent()</code>, method.</span>
