<div class="post-text" itemprop="text">
<p>I have a CSV file of 1 GB with around 1 million records, each row is 171 columns, I did some research and came up with this code. I have reduced the size of file to 5 MB for testing purposes, but there are still 171 columns. The code works fine as long as the sorting column index is below 50. Even on 49 it works fine, but I have columns with index 151, 153. I want to sort the file with those columns.</p>
<p><strong>Error:</strong></p>
<p>When I give it index 50 or above it throws the error:</p>
<pre class="lang-none prettyprint-override"><code>  data.sort(key=operator.itemgetter(*sort_key_columns))
IndexError: list index out of range
</code></pre>
<p><strong>My Code:</strong></p>
<pre><code>def sort_csv(csv_filename, sort_key_columns):
    data = []
    with open(csv_filename, 'r') as f:
        for row in csv.reader(f):
            data.append(row)
    data.sort(key=operator.itemgetter(*sort_key_columns))
    with open(csv_filename, 'w', newline='') as f:
        csv.writer(f).writerows(data)

sort_csv('Huge_Complete_B2B_file_1_1.csv', [49])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can handle the short row by writing your own version of <code>operator.itemgetter</code> which you can base on the code equivalent to it which is shown in its <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer">online documentation</a>.</p>
<p>The custom version below simply supplies a specified value for any that are missing. This will cause the row to be sorted as though it had that value in it at that indexed position.</p>
<p><strong>Note:</strong> That this assumes all the missing items should use the same default <code>MISSING</code> value. If that's not the case, it could be enhanced to allow a different one to be specified for each index in the sequence of them passed to it. This would likely require an additional argument.</p>
<pre><code>import csv
import operator

def my_itemgetter(*indexes, MISSING=''):
    if len(indexes) == 1:
        index = indexes[0]
        def getter(obj):
            try:
                return obj[index]
            except IndexError:
                return MISSING
    else:
        def getter(obj):
            try:
                return tuple(obj[index] for index in indexes)
            except IndexError:
                return tuple(obj[index] if index &lt; len(obj) else MISSING
                                for index in indexes)
    return getter

def sort_csv(csv_filename, sort_key_columns):
    with open(csv_filename, 'r', newline='') as f:
        data = [row for row in csv.reader(f)]

    data.sort(key=my_itemgetter(*sort_key_columns))

    with open(csv_filename, 'w', newline='') as f:
        csv.writer(f).writerows(data)

sort_csv('Huge_Complete_B2B_file_1_1.csv', [0, 171])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems that one of your files contains a truncated row below 51 columns.</p>
<p>If you don't care about your input being corrupt, you could filter it out while reading the input &amp; sort it, in one line:</p>
<pre><code>def sort_csv(csv_filename, sort_key_columns):
    with open(csv_filename, 'r') as f:
        data = sorted([row for row in csv.reader(f) if len(row)&gt;=171],key=operator.itemgetter(*sort_key_columns))
    # then write the file
</code></pre>
</div>
<span class="comment-copy">that's probably because there are some rows with less than 51 columns. Could you check that for instance by computing the minimum number of columns?</span>
<span class="comment-copy">well the column obviously there but the data is missing in alot of columns for sure</span>
<span class="comment-copy">obviously some columns are missing... Can you do <code>print(min(len(row) for row in csv.reader(f)))</code> just after opening the file (instead of the for loop)</span>
<span class="comment-copy">note: your loop would be much better like: <code>data = list(csv.reader(f))</code></span>
<span class="comment-copy">the printed result is 50</span>
<span class="comment-copy">Working great !!! Its sorting with both columns index now. Is there any way i can avoid reading the first row within this same code ?</span>
<span class="comment-copy">To skip the first row, just put a <code>next(f)</code> immediately <i>before</i> the <code>data = [row for...</code> line. <b>Note</b> this will also effectively remove the header in the output file. Also see <a href="https://stackoverflow.com/questions/11349333/when-processing-csv-data-how-do-i-ignore-the-first-line-of-data"><i>When processing CSV data, how do I ignore the first line of data?</i></a>.</span>
<span class="comment-copy">P.S. You can preserve the first header row by using <code>header = next(f)</code> and then output it manually when overwriting the file at the end with a <code>f.write(header)</code> before the <code>writerows()</code> call.</span>
<span class="comment-copy">Amazing!!! Thankyou so very much for all your help</span>
<span class="comment-copy">Thankyou so very much!!! It worked 2 questions: (1) when i give it two columns why does it only sort with the first one. (2) how can i avoid first line from sorting</span>
<span class="comment-copy">I don't see your questions...</span>
<span class="comment-copy">like [155, 156] it only does the 155 part</span>
