<div class="post-text" itemprop="text">
<p>I have a code looping on a generator. I have to break that loop after the second iteration if it reaches it. To do so I use <code>break</code>, which raises a <code>GeneratorExit</code> when it calls the <code>Generator.close()</code> method.</p>
<pre><code>for page in limit_handled(tweepy.Cursor(..., ..., ...):
    while len(the_list) &lt; 400:
        for status in page:

            def process_status(tweet):
                ...
                ...

            the_list.append(process_status(status))

    break
</code></pre>
<p>Would there be a more elegant way which would avoid such an error?</p>
<pre><code>Exception ignored in: &lt;generator object limit_handled at 0x000000003AB300A0&gt;
RuntimeError: generator ignored GeneratorExit
</code></pre>
<p>I have seen answers to these two questions : <a href="https://stackoverflow.com/questions/5234090/how-to-take-the-first-n-items-from-a-generator-or-list-in-python">How to take the first N...</a> <a href="https://stackoverflow.com/questions/4152376/how-to-get-the-n-next-values-of-a-generator-in-a-list-python">How to get the n next...</a> but this is not the same issue. In my case, the <code>Generator</code> uses a <code>Cursor</code>. Hence, at each iteration it processes a query. I want to stop it querying once at least 400 statuses have been reached, which can happen after the second or the third iteration (a query generally return 200 rows, but it can also be less). Slicing the generator is not an option here. Avoiding to process all the queries (16 total, for approximately 16*200=3200 statuses) is exactly what I want to avoid by Breaking the code after 400 statuses are returned.</p>
<p>Edit: For a better understanding, here is the code for my generator:</p>
<pre><code>def limit_handled(cursor):
    global user_timeline_remaining
    while True:
        if user_timeline_remaining&gt;1:
            try:
                yield cursor.next()
            except BaseException as e:
                print('failed_on_CURSOR_NEXT', str(e))
        else:
            time.sleep(5*60)
                try:
                    data = api.rate_limit_status()
                except BaseException as f:
                    print('failed_on_LIMIT_STATUS', str(f))
                user_timeline_remaining = data['remaining_queries']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your generator <strong>ignores</strong> the <code>GeneratorExit</code> exception that <a href="https://docs.python.org/3/reference/expressions.html#generator.close" rel="nofollow noreferrer"><code>generator.close()</code></a> raises. By catching <code>BaseException</code>, you effectively made closing impossible, so your generator will instead <em>yield another value</em> (as the code continues after the exception handler back to the top of the loop until <code>yield</code> is reached again). This is why you see your exception:</p>
<blockquote>
<p>If the generator yields a value, a <code>RuntimeError</code> is raised.</p>
</blockquote>
<p>You really should not catch <code>BaseException</code> in your code. Catch <em>specific exceptions</em> or, at best, <code>Exception</code>:</p>
<pre><code>except Exception a e:
    # ...
</code></pre>
<p>That way you don't catch <code>GeneratorExit</code> (a subclass of <code>BaseException</code>), <code>SystemExit</code> or <code>KeyboardInterrupt</code>.</p>
<p>If you feel your code must catch <code>SystemExit</code> and <code>KeyboardInterrupt</code> at this point, at least add a <code>except GeneratorExit: return</code> before your <code>except BaseException as e:</code> handler.</p>
</div>
<span class="comment-copy">Why not just handle the exception in the generator then? <code>try: ... except GeneratorExit: pass</code>.</span>
<span class="comment-copy">And the <code>close()</code> is not (directly) called by the <code>for</code> loop, it is called when there are no more references left to the generator object (given that the <code>for</code> loop is the only reference, when the loop ends the reference is dropped and the generator is deleted).</span>
<span class="comment-copy">Sorry I thought that was clear that it was raised when the break was called (implying that there was generator iterations left)</span>
<span class="comment-copy">Yes, the <code>break</code> ends the <code>for</code> loop. The <code>for</code> loop ending decrements the reference count to the result of <code>limit_handled(...)</code>. Because that was the only reference, the generator <code>__del__</code> method is called to clean it up, which calls <code>generator.close()</code>.</span>
<span class="comment-copy">Gotcha. Anyways, I am not sure what you mean by your first answer (using <code>try:... except GeneratorExit : pass </code>), could you explain it a bit more please?</span>
