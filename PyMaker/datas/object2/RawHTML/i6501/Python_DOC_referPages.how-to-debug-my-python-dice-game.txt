<div class="post-text" itemprop="text">
<p>So I recently posted my code for a simple dice program I'm having trouble with. It is supposed to randomly generate 5 numbers in an array, then check if there are any matching values, if there are, it adds to MATCH, so once it's done checking, MATCH+1 is how many 'of a kind' there are(match=1 means two of a kind, match=2 means three of a kind etc.)</p>
<p>It randomly generates and then displays the numbers correctly, and the program seems to check without errors except when the last two playerDice elements match, then it throws an out of bounds error, Why is it doing that? Also it never actually displays the last print line with how many of a kind there are, even when it runs error free, Why is that?</p>
<p>Here is the code:</p>
<pre><code>import random
playerDice = [random.randint(1,6),random.randint(1,6),random.randint(1,6),random.randint(1,6),random.randint(1,6)]
compDice = [random.randint(1,6),random.randint(1,6),random.randint(1,6),random.randint(1,6),random.randint(1,6)]
match = 0
compmatch = 0

#print player dice
print("You rolled: ",end=" ")
a = 0
while a &lt; len(playerDice):
        print(str(playerDice[a]) + ", ",end=" ")
        a = a + 1

#player check matches
i = 0
while i &lt; len(playerDice):

        j = i + 1
        if playerDice[i] == playerDice[j]:
                match = match + 1

        while playerDice[i] != playerDice[j]:
                j = j + 1
                if playerDice[i] == playerDice[j]:
                        match = match + 1

i = i + 1

print("Player has: " + str(match + 1) + " of a kind.")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's a much easier way to look for matches: sort the dice, and then look for runs of repeated dice. You could look for those runs manually, but the standard library has a function for that: <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>. Here's a short demo.</p>
<pre><code>import random
from itertools import groupby

# Seed the randomizer while testing so that the results are repeatable.
random.seed(7)

def roll_dice(num):
    return [random.randint(1,6) for _ in range(num)]

def find_matches(dice):
    matches = []
    for k, g in groupby(sorted(dice)):
        matchlen = len(list(g))
        if matchlen &gt; 1:
            matches.append('{} of a kind: {}'.format(matchlen, k))
    return matches

for i in range(1, 6):
    print('Round', i)

    player_dice = roll_dice(5)
    #comp_dice = roll_dice(5)

    print('You rolled: ', end='')
    print(*player_dice, sep=', ')

    matches = find_matches(player_dice)
    if not matches:
        print('No matches')
    else:
        for row in matches:
            print(row)
    print()
</code></pre>
<p><strong>output</strong></p>
<pre><code>Round 1
You rolled: 3, 2, 4, 6, 1
No matches

Round 2
You rolled: 1, 5, 1, 3, 5
2 of a kind: 1
2 of a kind: 5

Round 3
You rolled: 1, 5, 2, 1, 1
3 of a kind: 1

Round 4
You rolled: 4, 4, 1, 2, 1
2 of a kind: 1
2 of a kind: 4

Round 5
You rolled: 5, 4, 1, 5, 1
2 of a kind: 1
2 of a kind: 5
</code></pre>
<hr/>
<p>Here's an alternative version of <code>find_matches</code> that doesn't use <code>groupby</code>. It's probably a good idea to run through this algorithm on paper to see exactly how it works.</p>
<pre><code>def find_matches(dice):
    matches = []
    dice = sorted(dice)

    prev = dice[0]
    matchlen = 1
    # Add a "dummy" entry so we can detect a group at the end of the list
    for d in dice[1:] + [0]:
        # Compare this die to the previous one
        if d == prev:
            # We're inside a run of matching dice
            matchlen += 1
        else:
            # The previous run has ended, so see if it's
            # long enough to add to the matches list
            if matchlen &gt; 1:
                matches.append('{} of a kind: {}'.format(matchlen, prev))
            # Reset the match length counter
            matchlen = 1
        # This die will be the previous die on the next loop iteration
        prev = d

    return matches
</code></pre>
</div>
<span class="comment-copy">I don't think you have adequate bounds checking on <code>j</code>.</span>
<span class="comment-copy">What do you want the program to do if the player rolls something like <code>[1,1,2,2,2]</code>, two of a kind and 3 of a kind at the same time? BTW, there are better ways to organize &amp; write this code...</span>
<span class="comment-copy">The line <code>j = i + 1</code> will always result in an index error on the last iteration of the loop. Also, the <code>i = i + 1</code> needs to be inside the loop. Without this, the loop will spin forever, which is why the last line is never executed.</span>
<span class="comment-copy">This is way higher than my current level of python knowledge but thank you for taking the time to write that and show me!  I'm going to copy this code and go over it so I know all of the different commands you used.</span>
<span class="comment-copy">@JGoss Fair enough. I've just added an alternative version of <code>find_matches</code> that doesn't use <code>groupby</code>. Hopefully the comments will help you to understand how it works.</span>
<span class="comment-copy">thanks again this helps quite a bit.</span>
