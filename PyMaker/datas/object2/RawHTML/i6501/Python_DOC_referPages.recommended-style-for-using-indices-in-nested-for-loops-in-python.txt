<div class="post-text" itemprop="text">
<p>Consider a C style nested for loop like so:</p>
<pre><code>for i = 0; i &lt; n; i++ {
    for j = i; j &lt; n; j++ {
        do_something();
    }
}
</code></pre>
<p>What is the recommended python translation for that?</p>
<p>Following <a href="http://www.effectivepython.com" rel="nofollow noreferrer">Effective Python</a>, which dictates that <code>range(len(something))</code> should be avoided and <code>enumerate</code> should be used wherever possible, I'm thinking of:</p>
<pre><code>for i, _ in enumerate(some_iter):
    for j in range(i, len(some_iter)):
        do_something()
</code></pre>
<p>but mix of <code>enumerate</code> and <code>range</code> appears inconsistent.</p>
<p>Whereas,</p>
<pre><code>for i in range(len(some_iter)):
    for j in range(i, len(some_iter)):
        do_something()
</code></pre>
<p>looks consistent but uses <code>range(len(some_iter))</code>.</p>
<p>What is the recommended Python style for this?</p>
</div>
<div class="post-text" itemprop="text">
<p>As written, you're not actually using <code>i</code> or <code>j</code> for anything, so the nested loop is nonsense; you could just loop a calculated number of times as a single top-level loop.</p>
<p>That said, it follows the pattern commonly seen for processing all unique pairings from a given input sequence, and that <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" rel="nofollow noreferrer">is a solved problem in Python</a>:</p>
<pre><code>import itertools

for x, y in itertools.combinations_with_replacement(some_iter, 2):
    do_something(x, y)
</code></pre>
<p>is the Pythonic equivalent, without unnecessary indexing, of:</p>
<pre><code>for i in range(len(some_iter)):
    for j in range(i, len(some_iter)):
        do_something(some_iter[i], some_iter[j])
</code></pre>
<p>If you also needed the index, just pair it with <code>enumerate</code>:</p>
<pre><code>for (ix, x), (iy, y) in itertools.combinations_with_replacement(enumerate(some_iter), 2):
    do_something(ix, x, iy, y)
</code></pre>
<p>Using <code>itertools.combinations_with_replacement</code> (with or without <code>enumerate</code>) is going to be more efficient, and more general: If you're relying on indexing, you limit your inputs to <em>sequences</em>, so arbitrary iterables (<code>set</code>, <code>dict</code>, generator expressions, etc.) won't work without converting them to a sequence first. Using the Pythonic approach means you can accept and work with any finite iterable without needing to perform manual type conversions and indexing.</p>
</div>
<div class="post-text" itemprop="text">
<p>I try to use for <code>item in itemList:</code> whenever I can, instead of using <code>i</code> as a variable, and <code>i</code> as an iterator.</p>
<pre><code>for i in some_iter:
    for j in some_iter[some_iter.index(i):-1]
        doSomething()
</code></pre>
<p>so the second <code>for</code> loop slices the list from the index of the current item to the end.</p>
</div>
<span class="comment-copy">just use <code>range</code>, you aren't using the actual value of the iterable in enumerate, or at least, that is what you imply with <code>for i, _ in enumerate(some_iter)</code>, in which case you should <i>prefer <code>range</code></i>.</span>
<span class="comment-copy">IOW: "enumerate should be used wherever possible" is not true. It should be used when you want to <i>enumerate</i> something, whether that be to give you an index along with the value, or just for counting iterations while you get your value, e.g. <code>page_no, val in enumerate(pages, 1)</code></span>
<span class="comment-copy">I completely agree with @juanpa.arrivillaga here. <code>enumerate</code> should not <i>always</i> strived to be used, especially at the cost of readability and clarity. There are perfect valid use cases for <code>range(len(...)</code>. <code>enumerate</code> is only meant to replace the common pattern of need an element and index while iterating over an iterable.</span>
<span class="comment-copy">I haven't read the book, but I'm guessing that "<i>range(len(something)) should be avoided and enumerate should be used wherever possible</i>" is there to stop people writing C-in-Python by writing <code>for i in range(len(some_iter)): item = some_iter[i]</code> instead of <code>for i, item in enumerate(some_iter):</code> but range and enumerate are different and if you need a range but not an item, there's no need for enumerate.</span>
<span class="comment-copy">Definitely <code>for i, _ in enumerate(some_iter):</code> is not the way to do anything.</span>
<span class="comment-copy">Side-note: As a rule, most of the time when people think they need <code>range(len(someseq))</code>, and half the time they think they need <code>enumerate</code>, claiming it's because their use case is too complicated, they really just don't know the <code>zip</code> function and the <code>itertools</code> module very well; between the two of them and list comprehensions, they cover almost everything you'd ever need. In many of those <code>enumerate</code> cases, the problem can be solved by a simple list comprehension to generate a new <code>list</code>, rather than index assigning to the old one for instance (a common use for <code>enumerate</code>).</span>
<span class="comment-copy">Using <code>index</code> is adding a wasteful (and inaccurate for non-unique inputs) linear scan before each inner loop; <code>enumerate</code>-ing the outer loop would give you the index for free. Also, it's a bad idea to use <code>i</code> (or <code>j</code>) as a name for anything but an index variable, since programming traditions use it exclusively for that purpose, so it's misleading to use it for the actual value.</span>
<span class="comment-copy">thanks for the feedback, I personally don't usually use i and j as names, I was just following the format of the poster. I would normally give it a meaningful name.</span>
