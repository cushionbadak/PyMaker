<div class="post-text" itemprop="text">
<p>I have a list of items: <code>list = [a, b, c, d]</code>
I'd like to modify each item and then <code>time.sleep(10)</code> before moving on to the next iteration. On the final iteration, I'd like to modify the item, but avoid sleeping.  </p>
<pre><code>for item in list:  
    # modify item  
    time.sleep(10) # avoid this line on the final iteration  
</code></pre>
<p>Doesn't have to be this structure--looking for any method that gets the job done.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yet another solution using <code>enumerate</code>:</p>
<pre><code>lst = ['a', 'b', 'c', 'd']
for i, v in enumerate(lst, 1 - len(lst)):
    print(v)
    if i:
        print('sleeping')
</code></pre>
<p><strong>output</strong></p>
<pre><code>a
sleeping
b
sleeping
c
sleeping
d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could sleep first, but skip sleep the first iteration sleep, instead:</p>
<pre><code>for idx, item in enumerate(list):
    if idx != 0:   
        time.sleep(10) # avoid this line on the final iteration 
    # modify item 
</code></pre>
<p>It falls off at the last item, without sleeping.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you inverse the problem and add a boolean to signal the first element you can do this:</p>
<pre><code>do_sleep = False
for item in list:  
    if do_sleep:
        time.sleep(10) # avoid this line on the first iteration.
    else:
        do_sleep = True
    # modify item  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>enumerate</code> to track index :</p>
<pre><code>for index, data in enumerate(list, 1 - len(list)):
    if index: 
        time.sleep(10)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to avoid testing for the last element at each iteration.</p>
<pre><code>for element in elements[:-1]:
    process_element(element)
    time.sleep(10)

process_element(element)
</code></pre>
<p>In case the changes needs to be applied to the elements within the list (without creating a new one).</p>
<pre><code>for index, _ in enumerate(elements[:-1]):
    process_element(elements, index)
    time.sleep(10)

process_element(elements, -1)

def process_element(elements, index):
    elements[index] += 1
</code></pre>
<p>If you want to avoid copying the list you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer">islice</a>. Note that len([]) has O(1) cost.</p>
<pre><code>for element in islice(elements, len(elements) - 1):
    ...

for index, _ in enumerate(islice(elements, len(elements) - 1)):
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>for i,item in enumerate(list):
    # modify item
    if i &lt; len(list) - 1:
        time.sleep(10)
</code></pre>
</div>
<span class="comment-copy">If I'm understanding correctly, you're passing -3 as the starting index for enumerate, to iterate: -3, -2, -1, 0, and using 0 as False for the <code>if</code> statement?</span>
<span class="comment-copy">@Simonsays Yes, that's correct. Zero is False-ish, and non-zero numbers are True-ish, in Python.</span>
<span class="comment-copy">Well spotted!Thanks, fixed.</span>
<span class="comment-copy"><b>1</b> You can pass <code>enumerate</code> a starting value. <b>2</b> Why compute the list length on each loop iteration? It's not going to change (at least, I assume it's not going to change since it's generally not wise to change the length of a list that you're iterating over, unless you're very careful). Sure, getting the list length is a very fast operation, but still...</span>
<span class="comment-copy">@PM2Ring Ahh, thanks for pointing out, I should use <code>enumerate(list, 1 - len(list))</code></span>
<span class="comment-copy">But this is exactly what you wrote @PM2Ring. By the way, thanks for mentioning out 2 points ( they are really helpful ) a learning for me</span>
<span class="comment-copy">Wouldn't this altogether skip modifying the last item as well?</span>
<span class="comment-copy">The <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer">islice</a> method can deal with the reference copy.</span>
<span class="comment-copy">@Simonsays The last item is processed outside the loop.</span>
<span class="comment-copy">Modifiying the answer to support @Simonsays use case.</span>
<span class="comment-copy">Answer completed with both in place modification and iteration instead of slicing (copying).</span>
