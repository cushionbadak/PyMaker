<div class="post-text" itemprop="text">
<p>I have some code that I am running from my own package and the program is using a lot more memory (60GB) than it should be. How can I print the size of all objects (in bytes) in the current namespace in order to attempt to work out where this memory is being used?</p>
<p>I attempted something like </p>
<pre><code>from pympler import asizeof

for objname in dir():
    print(asizeof.asizeof(thing)/1024) # print size in kb
</code></pre>
<p>But it doesn't work as it just prints the size of the string containing the name of the object in the namespace. Is there a way to get an object reference to everything in the namespace in order to use this method or is there a better method for working out what is using the memory?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>dir()</code> returns only the names present in the local scope. Use the <a href="https://docs.python.org/3/library/functions.html#locals" rel="noreferrer"><code>locals()</code> function</a> to get the local scope as a dictionary:</p>
<pre><code>for obj in locals().values():
        print(asizeof.asizeof(obj) / 1024)
</code></pre>
<p>Note that outside of functions, <code>locals()</code> is the same mapping as <a href="https://docs.python.org/3/library/functions.html#globals" rel="noreferrer"><code>globals()</code></a>.</p>
<p>If <code>asizeof()</code> is in the dictionary, you want to filter it out:</p>
<pre><code>for name, obj in locals().items():
    if name != 'asizeof':
        print(asizeof.asizeof(obj) / 1024)
</code></pre>
<p><code>dir()</code> without arguments is functionally equivalent to <code>sorted(locals())</code> (a sorted list of the keys of the local namespace).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>gc.get_objects()</code> to just fetch all objects tracked by the collector, not just those in a specific namespace. I'd start by using it to count the number of instances of each type as that might give you some clues in itself.</p>
<pre><code>from collections import Counter
c = Counter(type(o) for o in gc.get_objects())
print(c.most_common(20))
</code></pre>
<p>Then you might drill down to find the size of any likely suspects.</p>
</div>
<span class="comment-copy">Yes, <code>dir()</code> produces <i>just the names</i> as strings. Use <code>globals()</code> and <code>locals()</code> to get the namespace as a dictionary so you can access the objects themselves, not the names.</span>
<span class="comment-copy">I appear to get a recursion issue when I run this. I imagine due to asizeof running on itself, is there a simple way to remove this from the dict created by locals()?</span>
<span class="comment-copy">@SomeRandomPhysicist: iterate over the <code>dict.items()</code> name-value pairs so you can filter it out. Alternatively, use <code>if obj is not asizeof:</code>.</span>
<span class="comment-copy">I had a number of temporary variables referencing asizeof so a more general method to filter these out was simply a try except statement.</span>
<span class="comment-copy">@SomeRandomPhysicist: or the <code>if obj is not asizeof:</code>, as that tests the identity of the object, not the name.</span>
<span class="comment-copy">The largest objects in locals() is only 1.27MB so I think whatever is using the memory doesn't have a reference to it in the namespace. I'm running the code from a jupyter notebook and the memory usage clears when the kernel is restarted.</span>
<span class="comment-copy">true. I've updated it. You still have to be careful to avoid infinite loops but I've found <code>get_objects()</code> a useful starting point for memory leaks in the past.</span>
