<div class="post-text" itemprop="text">
<pre><code>class A:
    def __init__(self, text):
        self.text = text

    def __repr__(self):
        return self.text

    def __str__(self):
        return self.text

    def __add__(self, other):
        return str(self) + other

    def __radd__(self, other):
        return other + str(self)
</code></pre>
<p>I want that list of <code>A</code> objects to be "joinable" with <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer">str.join()</a>.
Which <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">special method</a> should I implement to achieve this?</p>
<p>Of course, I can extract first a list of text then join it, but it's not what I want.</p>
<pre><code>b = A('Hello')
c = A('World')
l = [b, c]

print b, c
print l
print b + ' ' + c
print ' '.join(l) # &lt;- Error here

Hello World
[Hello, World]
Hello World
Traceback (most recent call last):
  File "sandbox.py", line 24, in &lt;module&gt;
    print ' '.join(l)
TypeError: sequence item 0: expected string, instance found
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>__str__</code> is only used if the user of your object <em>wants</em> to turn it into a string, and <code>str.join</code> doesn't. You have to explicitly convert your objects to <code>str</code> values before <code>str.join</code> will use them.</p>
<p>(<em>Could</em> <code>str.join</code> have been defined to implicitly call <code>str</code> on each element in the iterable it receives as an argument? Sure. But it wasn't.)</p>
<p>One of the tenets of Python is "Explicit is better than implicit". If you want to <code>str.join</code> to join the string representations of your objects, <em>pass <code>str</code> objects to <code>join</code></em>.</p>
<pre><code>print(' '.join(str(x) for x in l))
</code></pre>
<p>The only way <code>join</code> will treat them as <code>str</code> objects implicitly is if they <em>are</em> <code>str</code> objects, which is to say if <code>A</code> is a subclass of <code>str</code>.</p>
<pre><code>class A(str):
    def __new__(cls, text):
        obj = super().__new__(cls, text)
        # Do whatever else you need to add to obj
        return obj

l = [A('hello'), A('world')]
print(' '.join(l))
</code></pre>
<p>Beware of using inheritance where it isn't warranted, though.</p>
</div>
<span class="comment-copy">"I can extract first a list of text then join it, but it's not what I want." - Too bad.</span>
<span class="comment-copy">You've already implemented <code>__str__</code>, so you can use <code>' '.join(str(x) for x in l)</code>.</span>
<span class="comment-copy"><i>List comprehension</i> could be one way to reach your goal: <code>print ' '.join([str(item) for item in l])</code>.</span>
<span class="comment-copy">Why not <code>A(' ').join(l)</code> and return a new instance of <code>A</code> containing the joined strings or a string instance?</span>
<span class="comment-copy">Subclassing <code>str</code> just for that tiny detail is pretty much overkill, and could cause confusion in other parts where the class may come to be used. See <a href="http://www.catb.org/jargon/html/S/spaghetti-inheritance.html" rel="nofollow noreferrer">spaghetti inheritance</a></span>
<span class="comment-copy">but OP <i>wants</i> to be able to use <code>join</code>. That's pretty much the only way to do it.</span>
<span class="comment-copy">He could use join along with list comprehensions. Much cleaner.</span>
<span class="comment-copy">the technical explanation is spot on. "The only way to make ' '.join(l) work is if A is a subclass of str." doesn't mean that answered thinks that it's a good idea.</span>
<span class="comment-copy">@chepner you could add the alternative with <code>str</code> explicit conversion (which doesn't cost a dime if object is already a string). You'd have less enemies :)</span>
