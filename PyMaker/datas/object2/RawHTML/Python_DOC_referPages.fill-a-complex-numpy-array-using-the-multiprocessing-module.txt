<div class="post-text" itemprop="text">
<p>I have come across this demo <a href="https://jonasteuwen.github.io/numpy/python/multiprocessing/2017/01/07/multiprocessing-numpy-array.html" rel="nofollow noreferrer">https://jonasteuwen.github.io/numpy/python/multiprocessing/2017/01/07/multiprocessing-numpy-array.html</a> on how to populate a numpy array using the multiprocessing module. I want to do a similar thing in my code but the array I'm populating i.e. my <code>X</code> is a complex array. The ctypes module gives me an error along the lines of <code>NotImplementedError: Converting dtype('complex128') to a ctypes type</code>.</p>
<p>So in the linked example what I want to is effectively replacing in the non-parallel version:</p>
<pre><code>X = np.random.random((100, 100))
</code></pre>
<p>with</p>
<pre><code>X = np.random.random((100, 100)) + 1j * np.random.random((100, 100))
</code></pre>
<p>and</p>
<pre><code>tmp = np.zeros((100, 100))
</code></pre>
<p>with</p>
<pre><code>tmp = np.zeros((100, 100)) + 1j * np.random.random((100, 100))
</code></pre>
<p>I am unsure how to do this using the numpy.ctypes module but am open to other ideas to achieve a similar thing. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Solved this by splitting the array into real and imaginary parts, dealing with them separately and then combine to form the complex variable.</p>
<pre><code>import numpy as np
import itertools
from multiprocessing import Pool #  Process pool
from multiprocessing import sharedctypes

size = 100
block_size = 4

X = np.random.random((size, size)) + 1j * np.random.random((size, size))
X_r = X.real 
X_i = X.imag
result_r = np.ctypeslib.as_ctypes(np.zeros((size, size)))
result_i = np.ctypeslib.as_ctypes(np.zeros((size, size)))
shared_array_r = sharedctypes.RawArray(result_r._type_, result_r)
shared_array_i = sharedctypes.RawArray(result_i._type_, result_i)

def fill_per_window(args):
    window_x, window_y = args
    tmp_r = np.ctypeslib.as_array(shared_array_r)
    tmp_i = np.ctypeslib.as_array(shared_array_i)

    for idx_x in range(window_x, window_x + block_size):
        for idx_y in range(window_y, window_y + block_size):
            tmp_r[idx_x, idx_y] = X_r[idx_x, idx_y]
            tmp_i[idx_x, idx_y] = X_i[idx_x, idx_y]

window_idxs = [(i, j) for i, j in
           itertools.product(range(0, size, block_size),
                             range(0, size, block_size))]

p = Pool()
res = p.map(fill_per_window, window_idxs)
result_r = np.ctypeslib.as_array(shared_array_r)
result_i = np.ctypeslib.as_array(shared_array_i)
result = result_r + 1j * result_i
print(np.array_equal(X, result))
</code></pre>
</div>
