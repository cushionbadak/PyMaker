<div class="post-text" itemprop="text">
<p>I have been working on this project for a couple months right now. The ultimate goal of this project is to evaluate an entire digital logic circuit similar to functional testing; just to give a scope of the problem. The topic I created here deals with the issue I'm having with performance of analyzing a boolean expression. For any gate inside a digital circuit, it has an output expression in terms of the global inputs. EX: <code>((A&amp;B)|(C&amp;D)^E)</code>. What I want to do with this expression is then calculate all possible outcomes and determine how much influence each input has on the outcome.</p>
<p>The fastest way that I have found was by building a truth table as a matrix and looking at certain rows (won't go into specifics of that algorithm as it's offtopic), the problem with that is once the number of unique inputs goes above 26-27 (something around that) the memory usage is well beyond 16GB (Max my computer has). You might say "Buy more RAM", but as every increase in inputs by 1, memory usage doubles. Some of the expressions I analyze are well over 200 unique inputs...</p>
<p>The method I use right now uses the compile method to take the expression as the string. Then I create an array with all of the inputs found from the compile method. Then I generate a list row by row of "True" and "False" randomly chosen from a sample of possible values (that way it will be equivalent to rows in a truth table if the sample size is the same size as the range and it will allow me to limit the sample size when things get too long to calculate). These values are then zipped with the input names and used to evaluate the expression. This will give the initial result, after that I go column by column in the random boolean list and flip the boolean then zip it with the inputs again and evaluate it again to determine if the result changed.</p>
<p>So my question is this: Is there a faster way? I have included the code that performs the work. I have tried regular expressions to find and replace but it is always slower (from what I've seen). Take into account that the inner for loop will run <em>N</em> times where <em>N</em> is the number of unique inputs. The outside for loop I limit to run 2^15 if <em>N</em> &gt; 15. So this turns into eval being executed <code>Min(2^N, 2^15) * (1 + N)</code>...</p>
<p>As an update to clarify what I am asking exactly (Sorry for any confusion). The algorithm/logic for calculating what I need is not the issue. I am asking for an alternative to the python built-in 'eval' that will perform the same thing faster. (take a string in the format of a boolean expression, replace the variables in the string with the values in the dictionary and then evaluate the string).</p>
<pre><code>#value is expression as string
comp = compile(value.strip(), '-', 'eval')
inputs = comp.co_names
control = [0]*len(inputs)

#Sequences of random boolean values to be used
random_list = gen_rand_bits(len(inputs))


for row in random_list:
    valuedict = dict(zip(inputs, row))
    answer = eval(comp, valuedict)

    for column in range(len(row)):
        row[column] = ~row[column]

        newvaluedict = dict(zip(inputs, row))
        newanswer = eval(comp, newvaluedict)

        row[column] = ~row[column]

        if answer != newanswer:
            control[column] = control[column] + 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My question:</p>
<blockquote>
<p>Just to make sure that I understand this correctly: Your actual problem is to determine the relative influence of each variable within a boolean expression on the outcome of said expression?</p>
</blockquote>
<p>OP answered:</p>
<blockquote>
<p>That is what I am calculating but my problem is not with how I calculate it logically but with my use of the python <code>eval</code> built-in to perform evaluating.</p>
</blockquote>
<hr/>
<p>So, this seems to be a classic <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a>. You have an actual problem which is to determine the relative influence of each variable within the a boolean expression. You have attempted to solve this in a rather ineffective way, and now that you actually “feel” the inefficiency (in both memory usage and run time), you look for ways to improve your solution instead of looking for better ways to solve your original problem.</p>
<p>In any way, let’s first look at how you are trying to solve this. I’m not exactly sure what <code>gen_rand_bits</code> is supposed to do, so I can’t really take that into account. But still, you are essentially trying out every possible combination of variable assignments and see if flipping the value for a single variable changes the outcome of the formula result. <em>“Luckily”</em>, these are just boolean variables, so you are <em>“only”</em> looking at <code>2^N</code> possible combinations. This means you have exponential run time. Now, <code>O(2^N)</code> algorithms are in theory very very bad, while in practice it’s often somewhat okay to use them (because most have an acceptable average case and execute fast enough). However, being an exhaustive algorithm, you actually have to look at <em>every single</em> combination and can’t shortcut. Plus the compilation and value evaluation using Python’s <code>eval</code> is apparently not so fast to make the inefficient algorithm acceptable.</p>
<p>So, we should look for a different solution. When looking at your solution, one might say that more efficient is not really possible, but when looking at the original problem, we can argue otherwise.</p>
<p>You essentially want to do things similar to what compilers do as <a href="http://en.wikipedia.org/wiki/Static_program_analysis" rel="nofollow noreferrer">static analysis</a>. You want to look at the source code and analyze it just from there without having to actually evaluate that. As the language you are analyzing is highly restricted (being only a boolean expression with very few operators), this isn’t really that hard.</p>
<p>Code analysis usually works on the <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="nofollow noreferrer">abstract syntax tree</a> (or an augmented version of that). Python offers code analysis and abstract syntax tree generation with its <a href="http://docs.python.org/3/library/ast.html" rel="nofollow noreferrer">ast</a> module. We can use this to parse the expression and get the AST. Then based on the tree, we can analyze how relevant each part of an expression is for the whole.</p>
<p>Now, evaluating the relevance of each variable can get quite complicated, but you can do it all by analyzing the syntax tree. I will show you a simple evaluation that supports all boolean operators but will not further check the semantic influence of expressions:</p>
<pre><code>import ast

class ExpressionEvaluator:
    def __init__ (self, rawExpression):
        self.raw = rawExpression
        self.ast = ast.parse(rawExpression)

    def run (self):
        return self.evaluate(self.ast.body[0])

    def evaluate (self, expr):
        if isinstance(expr, ast.Expr):
            return self.evaluate(expr.value)
        elif isinstance(expr, ast.Name):
            return self.evaluateName(expr)
        elif isinstance(expr, ast.UnaryOp):
            if isinstance(expr.op, ast.Invert):
                return self.evaluateInvert(expr)
            else:
                raise Exception('Unknown unary operation {}'.format(expr.op))
        elif isinstance(expr, ast.BinOp):
            if isinstance(expr.op, ast.BitOr):
                return self.evaluateBitOr(expr.left, expr.right)
            elif isinstance(expr.op, ast.BitAnd):
                return self.evaluateBitAnd(expr.left, expr.right)
            elif isinstance(expr.op, ast.BitXor):
                return self.evaluateBitXor(expr.left, expr.right)
            else:
                raise Exception('Unknown binary operation {}'.format(expr.op))
        else:
            raise Exception('Unknown expression {}'.format(expr))

    def evaluateName (self, expr):
        return { expr.id: 1 }

    def evaluateInvert (self, expr):
        return self.evaluate(expr.operand)

    def evaluateBitOr (self, left, right):
        return self.join(self.evaluate(left), .5, self.evaluate(right), .5)

    def evaluateBitAnd (self, left, right):
        return self.join(self.evaluate(left), .5, self.evaluate(right), .5)

    def evaluateBitXor (self, left, right):
        return self.join(self.evaluate(left), .5, self.evaluate(right), .5)

    def join (self, a, ratioA, b, ratioB):
        d = { k: v * ratioA for k, v in a.items() }
        for k, v in b.items():
            if k in d:
                d[k] += v * ratioB
            else:
                d[k] = v * ratioB
        return d

expr = '((A&amp;B)|(C&amp;D)^~E)'
ee = ExpressionEvaluator(expr)
print(ee.run())
# &gt; {'A': 0.25, 'C': 0.125, 'B': 0.25, 'E': 0.25, 'D': 0.125}
</code></pre>
<p>This implementation will essentially generate a plain AST for the given expression and the recursively walk through the tree and evaluate the different operators. The big <code>evaluate</code> method just delegates the work to the type specific methods below; it’s similar to what <a href="http://docs.python.org/3/library/ast.html#ast.NodeVisitor" rel="nofollow noreferrer">ast.NodeVisitor</a> does except that we return the analyzation results from each node here. One could augment the nodes instead of returning it instead though.</p>
<p>In this case, the evaluation is just based on ocurrence in the expression. I don’t explicitely check for semantic effects. So for an expression <code>A | (A &amp; B)</code>, I get <code>{'A': 0.75, 'B': 0.25}</code>, although one could argue that semantically <code>B</code> has no relevance at all to the result (making it <code>{'A': 1}</code> instead). This is however something I’ll leave for you. As of now, every binary operation is handled identically (each operand getting a relevance of 50%), but that can be of course adjusted to introduce some semantic rules.</p>
<p>In any way, it will not be necessary to actually test variable assignments.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of reinventing the wheel and getting into risk like performance and security which you are already in, it is better to search for industry ready well accepted libraries.</p>
<p><a href="http://docs.sympy.org/dev/modules/logic.html" rel="nofollow">Logic Module</a> of <code>sympy</code> would do the exact thing that you want to achieve without resorting to <code>evil</code> ohh I meant <code>eval</code>. More importantly, as the boolean expression is <strong>not a string</strong> you don;t have to care about parsing the expression which generally turns out to be the bottleneck. </p>
</div>
<div class="post-text" itemprop="text">
<p>You don't have to prepare a static table for computing this. Python is a dynamic language, thus it's able to interpret and run a code by itself during runtime.</p>
<p>In you case, I would suggest a soluation that:</p>
<pre><code>import random, re, time

#Step 1: Input your expression as a string
logic_exp = "A|B&amp;(C|D)&amp;E|(F|G|H&amp;(I&amp;J|K|(L&amp;M|N&amp;O|P|Q&amp;R|S)&amp;T)|U&amp;V|W&amp;X&amp;Y)"

#Step 2: Retrieve all the variable names.
#        You can design a rule for naming, and use regex to retrieve them.
#        Here for example, I consider all the single-cap-lettler are variables.
name_regex = re.compile(r"[A-Z]")

#Step 3: Replace each variable with its value. 
#        You could get the value with reading files or keyboard input.
#        Here for example I just use random 0 or 1.
for name in name_regex.findall(logic_exp):
    logic_exp = logic_exp.replace(name, str(random.randrange(2)))

#Step 4: Replace the operators. Python use 'and', 'or' instead of '&amp;', '|' 
logic_exp = logic_exp.replace("&amp;", " and ")
logic_exp = logic_exp.replace("|", " or " )    


#Step 5: interpret the expression with eval(exp) and output its value.
print "exporession =", logic_exp  
print "expression output =",eval(logic_exp)
</code></pre>
<hr/>
<p>This would be very fast and take very little memory. For a test, I run the example above with 25 input variables:</p>
<pre><code>exporession = 1 or 1 and (1 or 1) and 0 or (0 or 0 or 1 and (1 and 0 or 0 or (0 and 0 or 0 and 0 or 1 or 0 and 0 or 0) and 1) or 0 and 1 or 0 and 1 and 0)
expression output= 1
computing time: 0.000158071517944 seconds     
</code></pre>
<hr/>
<p>According to your comment, I see that you are computing <em>all the possible combinations</em> instead of the output at a given input values. If so, it would become a typical <strong>NP-complete</strong> <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem" rel="nofollow">Boolean satisfiability problem</a>. I don't think there's any algorithm that could make it by a complexity lower than <code>O(2^N)</code>. I suggest you to search with the keywords <code>fast algorithm to solve SAT problem</code>, you would find a lot of interesting things.</p>
</div>
<span class="comment-copy">I recommend not to use <code>eval()</code> you can read about it <a href="http://stackoverflow.com/a/1087625/1982962">here</a>.</span>
<span class="comment-copy">"how much influence each input has on the outcome" - could you clarify what you mean by this part? Depending on what you want, your problem may be <a href="http://en.wikipedia.org/wiki/NP-hard" rel="nofollow noreferrer">NP-hard</a>, but it may still be feasible.</span>
<span class="comment-copy">@KobiK that is sort of a security risk you know...</span>
<span class="comment-copy">I really hope you are not falling for the old <a href="http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">X Y Problem</a>. Please read that and make sure this is really what you want help with, and not instead figuring out a better way to implement your idea from the get-go, not just how to implement the solution you thought of.</span>
<span class="comment-copy">@K DawG I know and since he is trying to use it for now at a harmless script he should be aware of the risks so when he'll create another script he will know if he can use it or not, I just recommended it :)</span>
<span class="comment-copy">I had thought of other ways of solving this problem but it always a lead to a dead end (non-functional code); hence the reason I stuck with the expression analysis. Your response is very insightful though, I will definitely try to modify and implement it to give 'correct' values - EX: expressions such as <code>A | (A &amp; B)</code> and <code>A &amp; (A | B)</code> etc. like you mention. From those expressions it isn't hard to see <code>{'A': 1}</code>, but an expression such as <code>(A &amp; B) | (A &amp; D)</code> would be a little more difficult to arrive at <code>{'A': 0.75, 'B': 0.25, 'D': 0.25}</code>. I'm not sure how I could program that in though.</span>
<span class="comment-copy">One solution I had thought of previously was actually similar to your answer. I would start at a base expression and build up; to find the new value of A, for example, I would take A from the previous expression and multiply it by the probability the other input side is non-affecting. Take <code>(A|B)&amp;(C|D)</code> I would multiply <code>A * prob( (C|D) == 1)</code> since <code>(C|D)</code> has to be 1 for A to be able to change the output. To handle A appearing on the other side <code>(A|B) &amp; (A|C)</code> I came up with <code>left(A) * prob( (A|D) == 1) + right(A) * prob( (A|B) == 1)</code>. This does not work for all cases, ie <code>(A|B|C) &amp; (A|C)</code></span>
<span class="comment-copy">Sorry I forgot to mention I have already tried sympy and it was much slower. My boolean expression is stored as a string in the format of 'A&amp;B|(C|D)' etc. where I then plug in 'True'/'False' combinations for unique inputs (A,B,C,D etc) and evaluate it. If I remember correctly, sympy did not handle xor '^' as well.</span>
<span class="comment-copy">I wish you solution was faster than mine. You are evaluating 1 expression for only 1 possible combination of input values. For my purposes I would evaluate that expression for all possible combinations which is 2^25 (although my algorithm limits to 2^15). Then for each combination evaluated I check all inputs by inverting their value individually and re-evaluating. a resulting code with similar runs would be 	 	<code>for i in range(2**15): 		for j in range(25): 			for name in name_regex.findall(exp): 			    exp = exp.replace(name, str(random.randrange(2))) 			eval(exp) 			exp = value</code></span>
<span class="comment-copy">I see. If you want to calculate all the possible combinations, then it would become a NP-complete problem. I don't think there's any algorithm that could make the complexity lower than <code>O(2^N)</code>:(</span>
<span class="comment-copy"><code>eval(exp)</code> and <code>exp = value</code> happen every iteration of the second <code>for</code> loop: <code>for j in range(25)</code>. as it stands my program can run through your expression and determine influence of the inputs in approx. 6.7 seconds not including the time it takes to generate a sample of size 2^15 containing random non repeating sequences 25 bits in length. (which would bump runtime up to 7.7 seconds - not very efficient but that is not something I'm currently working on to improve atm)</span>
<span class="comment-copy">Yes, it is NP-Complete for the most part, until it hits 15 inputs in my algorithm; then it becomes ((2**15) * N) I know there is no faster way to calculate what I am calculating in terms of the complexity, but I was hoping there was a faster alternative to using 'eval'</span>
<span class="comment-copy">So far the only things I can think of to improve speed is make this massively parallel. It would not improve the runtime of 1 expression but when dealing with 20,000 expressions having 20,000 cores (each core assigned to an expression) would make things very fast (obviously lol) but very expensive. I have it implemented with multiprocessing but 4 cores is not much better than 1 core with that many expressions.</span>
