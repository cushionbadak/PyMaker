<div class="post-text" itemprop="text">
<p>I was trying to understand and figure out if I should use <code>os.urandom()</code> or <code>Crypto.Random.new()</code> for cryptographically secure pseudo-random numbers. </p>
<p>The following website seems to suggest to use <code>os.urandom()</code>:</p>
<p><a href="https://github.com/mozilla/PyHawk/pull/13">https://github.com/mozilla/PyHawk/pull/13</a></p>
<p>but I don't really see why and the other websites I found online don't really explain which one to use.</p>
<p>If anyone knows which one is secure for cryptographic use, I would appreciate the advice!</p>
<p>One of the things that specifically worry me is that, I plan to use it to generate random numbers but I am worried that one day I generate some random numbers and the next day the state of the generator is the same and it starts to generate the same "random" numbers.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the link you gave, the <em>only</em> reason given to prefer <code>urandom()</code> is that it pulled less code in (the OS implements "most of it", and <code>os.urandom()</code> is built in to Python).</p>
<p>If you're going to distribute a Python package, you can simplify users' lives by minimizing external dependencies.  That's the entire point of the link you found.</p>
<p>In terms of quality, either way should work fine.  I prefer <code>urandom()</code> because I understand what it does; I never dug into the guts of <code>PyCrypto</code>.  But <code>urandom()</code> has been criticized for use in <em>some</em> environments.  <a href="http://en.wikipedia.org/wiki//dev/random" rel="noreferrer">Click this</a> and scroll down to the part that starts</p>
<blockquote>
<p>Gutterman, Pinkas, &amp; Reinman in March 2006 published a detailed
  cryptographic analysis of the Linux random number generator ...</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I go for <code>os.urandom</code>. On all (recent) Python implementations I checked, it does the correct thing by simply opening an <em>unbuffered</em> connection to <code>/dev/urandom</code> or the equivalent device on other non-Linux platforms.</p>
<p>On the other hand, PyCrypto's <code>Crypto.Random</code> is a very complex wrapper based on Fortuna. Such complex construction was probably done in the hope of mitigating some flaws of the underlying OS. Unfortunately:</p>
<ul>
<li>It still pulls entropy from <code>/dev/urandom</code> (on Linux), so if the OS is broken, PyCrypto's <code>Crypto.Random</code> will be broken too (defeating its purpose)</li>
<li>That choice has backfired, since it is very hard to deal with forking and cases where the same entropy gets reused by different processes (see <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-1445" rel="noreferrer">CVE-2013-1445</a>).</li>
<li>The Fortuna code is not covered at all by unit tests and Fortuna algorithm itself does not come with test vectors. That alone forces you to make a (big) leap of faith.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><code>urandom</code> <em>does</em> return cryptographically secure numbers, with a caveat. If it runs out of entropy (real random data generated by mouse movement, CPU temperature fluctuations on Ivy Bridge+ chips, etc), it will start producing less secure pseudo-random numbers. These are generated by a strong generator, but depending on your application they may not be random enough. On Unix systems, <code>/dev/random</code> will block while waiting for more entropy, while <code>/dev/urandom</code> will start generating pseudo-random numbers.</p>
<p>I'm not knowledgeable on PyCrypto, however on reading the source, it seems the <code>Crypto/Random/OSRNG/posix.py</code> simply reads from <code>/dev/urandom</code> - so I wouldn't worry too much about the choice.</p>
</div>
<span class="comment-copy">Either one works.</span>
<span class="comment-copy">@U2EF1 For something as important and hard-to-verify as correctness of a CSPRNG, you'll have to provide a bit more than an offhand assertion.</span>
<span class="comment-copy"><a href="http://docs.python.org/3.4/library/ssl.html#ssl.RAND_bytes" rel="nofollow noreferrer"><code>ssl.RAND_bytes()</code> docs</a> recommend to read <a href="http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" rel="nofollow noreferrer">Wikipedia</a> to get the requirements of a CSPRNG.</span>
<span class="comment-copy">my specific worry is that, I plan to use these to generate random numbers but I am worried that one day I generate some and the next day the state of the generator is the same or something and it generates the same "random" (not really) numbers.</span>
<span class="comment-copy">You may want to have a look: <a href="https://docs.python.org/3/library/secrets.html#module-secrets" rel="nofollow noreferrer">docs.python.org/3/library/secrets.html#module-secrets</a></span>
