<div class="post-text" itemprop="text">
<p>Python's <code>map</code> can take multiple iterables, for use when the callable can accept the same number of input arguments. If the input iterables are the same length, thats behaving like the list comprehension passing in zipped arguments, e.g.:</p>
<pre><code>&gt;&gt;&gt; iterables = 'spam', 'eggs'
&gt;&gt;&gt; map(max, *iterables)
['s', 'p', 'g', 's']
&gt;&gt;&gt; [max(*a) for a in zip(*iterables)]
['s', 'p', 'g', 's']
</code></pre>
<p>When the input arguments are different length, it gets weird - Python 2 (<a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow noreferrer">docs</a>) pads with <code>None</code>, but Python 3 (<a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer">docs</a>) truncates to shortest iterable.</p>
<pre><code>&gt;&gt;&gt; map(max, 'spam', 'potato')  # 2.x
['s', 'p', 't', 'm', 't', 'o']
&gt;&gt;&gt; list(map(max, 'spam', 'potato'))  # 3.x
['s', 'p', 't', 'm']
</code></pre>
<p>Why is this feature existing, what's an example of a typical case where that's needed or useful? I don't know a lot about functional styles, could I be missing out on some great strengths of <code>map</code> that are related to the multiple arguments? And what's the rationale for the API change in 3.x?</p>
</div>
<div class="post-text" itemprop="text">
<p>Regarding <em>why</em> <code>map</code> truncates in python3, this is simply because python3's <code>map</code> is actually <a href="http://docs.python.org/2/library/itertools.html#itertools.imap" rel="nofollow"><code>itertools.imap</code></a>. And the documentation says:</p>
<blockquote>
<p>Like <code>map()</code> but stops when the shortest iterable is exhausted
  instead of filling in <code>None</code> for shorter iterables. <strong>The reason for
  the difference is that infinite iterator arguments are typically an
  error for <code>map()</code> (because the output is fully evaluated) but
  represent a common and useful way of supplying arguments to
  <code>imap()</code></strong>.</p>
</blockquote>
<p>The truncation allows you to do things like <code>map(func, itertools.repeat(5), [1,2,3])</code> and iterate over the result without worries. With the old <code>map</code> that would be an infinite loop.</p>
<p>One of the most significant changes in python3 is that a lot of built-in functions now return generators instead of <code>list</code>s, including <code>map</code> and <code>zip</code>. This "increased lazyness" changed the way these functions should be used and thus the modified behaviour.</p>
<p>As to why one would ever use python2's multiple-iterables to <code>map</code> I don't know. Sure, it's a shortcut for something like (in python3):</p>
<pre><code>list(itertools.starmap(function, itertools.zip_longest(*iterables)))
</code></pre>
<p>This might have some corner case usage, but I've never seen it used.
Probably most people don't even know that <code>map</code> accepts a sequence of iterables.
So, AFAIK there isn't any super-power deriving from the use of multiple arguments.</p>
<p>As to why <code>map</code> is in the language, that's because <code>map</code> was there long before list-comprehensions. Before list-comprehensions it was quite useful for building lists.
It wasn't remove for backward compatibility and because many people actually like it,
although Guido <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow"><em>did</em> want to remove it</a>.</p>
<p>To learn more about the history of <code>map</code>, <code>filter</code> and <code>reduce</code> and other functional aspects, read: <a href="http://python-history.blogspot.it/2009/04/origins-of-pythons-functional-features.html" rel="nofollow">The History of Python: Origins of Python's "Functional" Features</a></p>
</div>
<span class="comment-copy">Guido actually has a strong dislike of <code>map</code> and did in fact plan to remove it from python 3. Due to popular opinion however, he did not. <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow noreferrer">artima.com/weblogs/viewpost.jsp?thread=98196</a></span>
<span class="comment-copy">It's Python's fault that <code>lambda</code>s are too restrictive and too slow. Otherwise <code>map</code> would be useful in some cases where the list comprehension would turn harder to read.</span>
<span class="comment-copy"><code>map</code> predates comprehensions.</span>
<span class="comment-copy">@MihaiMaruseac <code>lambda</code>s are <b>useless</b>. If you want to use more than one expression just use a <code>def</code> and define a real function. Having bigger <code>lambda</code>s would be completely unreadable. Other languages need <code>lambda</code> expressions because they cannot define inner functions, but python <i>does</i> have them, so <code>lambda</code>s are useful <i>only</i> when you need a thorw-away one-expr function to put as parameter.</span>
<span class="comment-copy">Wow, I guess I'm a relative newbie to python because I can't even imagine the language without comprehensions.  They seem such a strong and integral part of the language that python &lt; v2.0 must look like something quite different.</span>
<span class="comment-copy">@wim Yes, they are one of the "killer features" of newer python versions. Python &lt;2.0 was really a <i>completely</i> different language. Especially python &lt; 1.6 where strings didn't have methods (that's why in python2 the <code>string</code> module is full of functions like <code>split</code>, <code>strip</code> etc.). The language has <i>improved</i> a lot in the last 10-15 years.</span>
