<div class="post-text" itemprop="text">
<p>I have some C code running on an embedded processor, which outputs integers (16 bits) over a serial port (stdout) using <code>printf("%d", my_int);</code>. I have some python code running on a PC that reads the serial stream using pyserial and writes it to a file, which I can just achieve using <code>ser.readline()</code>. This works quite happily, although it isn't very efficient.</p>
<p>As the embedded C is sending quite a lot of numbers and I want to cut down on the transfer time, I would like to send the data formatted as binary rather than ascii (i.e. two bytes/chars rather than several bytes/chars.) I tried to do this with:</p>
<pre><code>char msbs = my_int&gt;&gt;8;
char lsbs = my_int;
printf("%c%c\n", msbs, lsbs)
</code></pre>
<p>And then in my python code:</p>
<pre><code>chars = ser.readline()
value = ord(chars[0])&lt;&lt;8 + ord(chars[1])
</code></pre>
<p>But value seems to be gibberish. Could anyone point out the thing(s) I'm doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try with this:</p>
<pre><code>import struct
chars = ser.readline()[:-1]
value = struct.unpack('&gt;h', chars)
</code></pre>
<p>I've assumed that your integer is signed short and please note the presence of '&gt;' for endianness (bytes order).</p>
<p>However the error with you code was because of operator precedence:
<code>value = (ord(chars[0])&lt;&lt;8) + ord(chars[1])</code> this should work. But it is better to use struct anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>struct</code> idea is great, but your protocol is faulty.</p>
<p>If you write binary data, it is not useful to have line endings in-between: one of the "value bytes" could have that value - 10 - as well.</p>
<p>So better refrain from using these line ends and <code>readline()</code>.</p>
<p>But there could arise the problem that you could get out of sync. So you either should define a kind of package boundaries, or you could encode your data in more than 2 bytes.</p>
<p>Example: Each 16bit value is encoded in 3 bytes, in the following way:</p>
<pre><code>AADDDDDD BBBDDDDD CCCDDDDD
</code></pre>
<p><code>AA</code> is <code>10</code>, <code>BBB</code> is <code>110</code>, <code>CCC</code> is <code>111</code>.</p>
<p>The value 57723 - 0xE17B, 0b1110000101111011, is encoded as</p>
<pre><code>10111000 11001011 11111011
</code></pre>
<p>or</p>
<pre><code>B8 CB FB
</code></pre>
<p>by means of</p>
<pre><code>byte1 = 0x80 + ((value &gt;&gt; 10) &amp; 0x3F) # bits 10..15
byte2 = 0xC0 + ((value &gt;&gt; 5)  &amp; 0x1F) # bits 5..9
byte3 = 0xE0 + ((value)       &amp; 0x1F) # bits 0..4
</code></pre>
<p>Upon reception of these bytes, you immediately can detect</p>
<p>a) which byte it is (the 1st, the 2nd or the 3rd) and
b) its contents.</p>
<p>So even if one byte gets missing, you can detect that and can resume reception of the stream immediately.</p>
<p>Plus, this implementation is endianness-agnostic - it will work on every machine regardless of its endianness, a way every protocol should be designed.</p>
<p>How to implement that I'll leave to you.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>As the embedded C is sending quite a lot of numbers and I want to cut down on the transfer time,</p>
</blockquote>
<p>To improve time performance you could send and/or receive more than one number at a time. In my tests, <code>array.fromfile()</code> is 10 - 100 times faster than <code>struct.unpack()</code>. It comes at the cost of calling <code>array.byteswap()</code> sometimes to take into account endianness explicitly. </p>
<hr/>
<p>If the C program and Python script were running on the same machine (same size, same endianess); then you could use <code>fwrite</code> to write short ints as platform values on C side and <a href="http://docs.python.org/3/library/array#array.array.fromfile" rel="nofollow"><code>array.fromfile()</code> on Python side</a> to read them back in a native format.</p>
<p>For example, print short ints as binary:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
  short a[] = {31415, 9265, 3589, 793};
  size_t n = sizeof a / sizeof *a;
  if (fwrite(&amp;n, sizeof n, 1, stdout) != 1) exit(EXIT_FAILURE); /* send size */
  return (fwrite(a, sizeof *a, n, stdout) &lt; n) ? EXIT_FAILURE : EXIT_SUCCESS;
}
</code></pre>
<p>Read it in Python:</p>
<pre><code>#!/usr/bin/env python3
import sys
import array
import struct

# make stdin binary
file = sys.stdin.detach()

# read size
size_format = 'N' # size_t
n, = struct.unpack(size_format, file.read(struct.calcsize(size_format)))
print(n)

a = array.array('h') # native short int
a.fromfile(file, n)
print(a.tolist()) # -&gt; [31415, 9265, 3589, 793]
</code></pre>
<p><code>array.fromfile</code> should be efficient both time and memory-wise. If you don't know the size then call <code>a.fromfile</code> until <code>EOFError</code> is raised.</p>
<hr/>
<p>If C program and Python script are on different machines then you could send integers in the network byte order:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;netinet/in.h&gt; /* htons() */

int main(void) {
  short a[] = {31415, 9265, 3589, 793};
  /* print one integer at a time */
  short *p = a, *end = &amp;a[sizeof a / sizeof *a];
  for ( ; p != end; ++p) {
    uint16_t s = htons(*p); /* convert from native to network byte order */
    if (fwrite(&amp;s, sizeof s, 1, stdout) != 1)  exit(EXIT_FAILURE);
  }
  return 0;
}
</code></pre>
<p>And swap byte order if necessary on the Python side:</p>
<pre><code>#!/usr/bin/env python
import array
import sys

a = array.array('h') # short int in native byte order, byte swap might be needed
for i in range(15, 128): 
    try: # double size to avoid O(n**2) behaviour
        a.fromfile(sys.stdin, 2 &lt;&lt; i)
    except EOFError:
        break
if sys.byteorder != 'big': # if not network order
    a.byteswap()  # swap byte order
print(a.tolist()) # -&gt; [31415, 9265, 3589, 793]
</code></pre>
<p>To avoid converting to network order, you could send a magic number instead. It allows to send numbers in a native byte order on C side (as in the 1st code example) and check it in Python to swap bytes if necessary:</p>
<pre><code>MAGIC = 1
if a[0] != MAGIC:
   a.byteswap()
   if a[0] != MAGIC:
      raise ValueError("Unexpected %d" % a[0])
</code></pre>
</div>
