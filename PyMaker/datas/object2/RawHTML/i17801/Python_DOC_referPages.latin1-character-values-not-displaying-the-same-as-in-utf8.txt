<div class="post-text" itemprop="text">
<p>FOR PYTHON 2.7 (I took a shot of using encode in 3 and am all confused now...would love some advice how to replicate this test in python 3....)</p>
<p>For the Euro character (€) I looked up what its utf8 Hex code point was using <a href="http://www.ltg.ed.ac.uk/~richard/utf-8.cgi?input=%E2%82%AC&amp;mode=char" rel="nofollow">this tool</a>. It said it was  0x20AC. </p>
<p>For Latin1 (again using Python2 2.7), I used decode to get its Hex code point:</p>
<pre><code>&gt;&gt;import unicodedata
&gt;&gt;p='€'
## notably x80 seems to correspond to [Windows CP1252 according to the link][2]
&gt;&gt;p.decode('latin-1') 
&gt;&gt;u'\x80'
</code></pre>
<p>Then I used this print statement for both of them, and this is what I got:</p>
<p>for utf8:</p>
<pre><code>&gt;&gt;&gt; print unichr(0x20AC).encode('utf-8')
â‚¬
</code></pre>
<p>for latin-1:</p>
<pre><code>&gt;&gt;&gt; print unichr(0x80).encode('latin-1')
€
</code></pre>
<p>What in the heck happened? Why did encode return 'â‚¬' for utf-8? Also...it seems that Latin1 hex code points CAN be different then their utf8 counterparts (I have a colleague who believes different -- says that Latin1 is just like ASCII in this respect). But the presence of different code points seems to suggest otherwise to me...HOWEVER the reason why python 2.7 is reading the <a href="http://www.stanford.edu/~laurik/fsmbook/faq/utf8.html" rel="nofollow">Windows CP1252 'x80'</a> is a real mystery to me....is this the standard for latin-1 in python 2.7??</p>
</div>
<div class="post-text" itemprop="text">
<p>You've got some serious misunderstandings here. If you haven't read the Unicode HOWTOs for <a href="http://docs.python.org/2/howto/unicode.html" rel="nofollow">Python 2</a> and <a href="http://docs.python.org/3/howto/unicode.html" rel="nofollow">Python 3</a>, you should start there.</p>
<p>First, UTF-8 is an encoding of Unicode to 8-bit bytes. There is no such thing as UTF-8 code point <code>0x20AC</code>. There is a <em>Unicode</em> code point U+20AC, but in UTF-8, that's three bytes: <code>0xE2</code>, <code>0x82</code>, <code>0xAC</code>.</p>
<hr/>
<p>And that explains your confusion here:</p>
<blockquote>
<p>Why did encode return 'â‚¬' for utf-8?</p>
</blockquote>
<p>It didn't. It returned the byte string <code>'\xE2\x82\xAC'</code>. You then <code>print</code>ed  that out to your console. Your console is presumably in CP-1252, so it interpreted those bytes as if they were CP-1252, which gave you <code>â‚¬</code>.</p>
<hr/>
<p>Meanwhile, when you write this:</p>
<pre><code>p='€'
</code></pre>
<p>The console isn't giving Python Unicode, it's giving Python bytes in CP-1252, which Python just stores as bytes. The CP-1252 for the Euro sign is <code>\x80</code>. So, this is the same as typing:</p>
<pre><code>p='\x80'
</code></pre>
<p>But in Latin-1, <code>\x80</code> isn't the Euro sign, it's an invisible control character, equivalent to Unicode U+0080. So, when you call <code>p.decode('latin-1')</code>, you get back <code>u'\x80'</code>. Which is exactly what you're seeing.</p>
<hr/>
<p>The reason you can't reproduce this in Python 3 is that in Python 3, <code>str</code>, and plain string literals, are Unicode strings, not byte strings. So, when you write this:</p>
<pre><code>p='€'
</code></pre>
<p>… the console gives Python some bytes, which Python then automatically decodes with the character set it guessed for the console (CP-1252) into Unicode. So, it's equivalent to writing this:</p>
<pre><code>p='\u20ac'
</code></pre>
<p>… or this:</p>
<pre><code>p=b'\x80'.decode(sys.stdin.encoding)
</code></pre>
<hr/>
<p>Also, you keep saying "hex code points" to mean a variety of different things, none of which make any sense.</p>
<p>A code point is a Unicode concept. A <code>unicode</code> string in Python is a sequence of code points. A <code>str</code> is a sequence of <em>bytes</em>, not code points. Hex is just a way of representing a number—the hex number <code>20AC</code>, or <code>0x20AC</code>, is the same thing as the decimal number <code>8364</code>, and the hex number <code>0x80</code> is the same thing as the decimal number <code>128</code>.</p>
<p>That sequence of bytes doesn't have any inherent meaning as text on its own; it needs to be combined with an encoding to have a meaning. Depending on the encoding, some code points may not be representable at all, and others may take 2 or more bytes to represent.</p>
<hr/>
<p>Finally:</p>
<blockquote>
<p>Also...it seems that Latin1 hex code points CAN be different then their utf8 counterparts (I have a colleague who believes different -- says that Latin1 is just like ASCII in this respect).</p>
</blockquote>
<p>Latin-1 is a superset of ASCII. Unicode is also a superset of the printable subset of Latin-1; some of the Unicode characters up to U+FF (and all printable characters up to U+7F) are encoded in UTF-8 as the byte with the same value as the code point, but not all. CP-1252 is a <em>different</em> superset of the printable subset of Latin-1. Since there <em>is</em> no Euro sign in either ASCII or Latin-1, it's perfectly reasonable for CP-1252 and UTF-8 to represent it differently.</p>
</div>
<span class="comment-copy">First, the UTF-8 for the Euro character is <code>'\xE2\x82\xAC'</code>. In UTF-8, <code>'\x20\xAC'</code> is a space followed by an illegal character.</span>
<span class="comment-copy">Are you saying I need to enter '\xe2\x82\xac' ?? that doesn't make sense to me.... or python. I get "SyntaxError: invalid syntax" when I put in: &gt;&gt;&gt; print unichr('\xe2\x82\xac').encode('utf-8')</span>
<span class="comment-copy">First, you didn't put the quotes in. Second, <code>unichr</code> takes a number, not a string, so that isn't going to work anyway. To convert a string of bytes into a <code>unicode</code>, you need to use the <code>decode</code> method—and specify the encoding you want to convert from. So, <code>print '\xe2\x82\xac'.decode('utf-8').encode('utf-8')</code> will give you… exactly what you started with, as you'd expect.</span>
<span class="comment-copy">Sorry edit. It says: SyntaxError: invalid syntax</span>
<span class="comment-copy">Then you copied and pasted wrong. If I paste that exact code into my Python 2.7 interpreter, or an online interpreter like <a href="http://ideone.com/8tckH2" rel="nofollow noreferrer">this one</a>, there is no <code>SyntaxError</code>; it prints out <code>€</code> on a machine with a UTF-8 console, <code>â‚¬</code> on a machine with a CP-1252 console, etc.</span>
<span class="comment-copy">There's a mistake in your last paragraph: Unicode, not UTF-8, is a superset of the printable parts of Latin-1.</span>
<span class="comment-copy">What are 'all the printable parts of Latin-1'? I've read the python 2 How-To a dozen of times (i.e. esp "...Latin-1, also known as ISO-8859-1, is a similar encoding. Unicode code points 0-255 are identical to the Latin-1 values.."). I'm sorry for using 'hex code points' incorrectly (yes, I am referring to the Unicode code point) and that is what I am confused by -- how can the code point for Latin-1 Euro character be different then the utf-8 character if utf8 is a 'superset' of  Latin-1??</span>
<span class="comment-copy">@jwodder: Thanks; I rewrote it to be clearer, I hope.</span>
<span class="comment-copy">@user14696: See <a href="http://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">the Wikipedia article</a>. Latin-1 actually doesn't define 0x80-0x9F, so it's not really true that Unicode code point U+80 is identical to Latin-1 0x80, because there <i>is</i> no Latin-1 0x80. But Unicode defines 0x80-09F to be reserved control characters, so that's not a big deal.</span>
<span class="comment-copy">@user14696: Meanwhile, even the original version of the last paragraph explained that there is no Euro sign in Latin-1. You're not using Latin-1, you're using CP-1252, a Latin-1 extension that defines (parts of) 0x80-0x9F for characters that don't exist in Latin-1, and which map all over the place in Unicode. The CP-1252 0x80 is U+20AC, <code>€</code>; the Latin-1 0x80 is U+0080, a reserved control character.</span>
