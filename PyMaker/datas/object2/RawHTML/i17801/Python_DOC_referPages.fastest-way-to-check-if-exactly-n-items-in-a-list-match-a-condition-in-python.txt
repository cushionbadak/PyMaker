<div class="post-text" itemprop="text">
<p>If I have <em>m</em> items in a list, what is the fastest way to check if exactly <em>n</em> of those items in the list meet a certain condition? For example:</p>
<pre><code>l = [1,2,3,4,5]
</code></pre>
<p>How would I check if any two items in the list match the condition <code>x%2 == 0</code>?</p>
<p>The naive approach would be to use nested for loops:</p>
<pre><code>for i in l:
    for j in l:
        if not i%2 and not j%2:
            return True
</code></pre>
<p>But that is an incredibly inefficient way of checking, and would become especially ugly if I wanted to check for any 50,000 items in a list of 2-10 million items.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works:</p>
<pre><code>&gt;&gt;&gt; l = [1,2,3,4,5]
&gt;&gt;&gt; n = 2
&gt;&gt;&gt; a = 0  # Number of items that meet the condition
&gt;&gt;&gt; for x in l:
...     if x % 2 == 0:
...         a += 1
...         if a &gt; n:
...             break
...
&gt;&gt;&gt; a == n
True
&gt;&gt;&gt;
</code></pre>
<p>It has the advantage of running trough the list only once.</p>
</div>
<div class="post-text" itemprop="text">
<p>[Edited to reflect exact matching, which we can still accomplish with short-circuiting!]</p>
<p>I think you'd want this to short-circuit (stop when determined, not only at the end):</p>
<pre><code>matched = 0
for i in l:
    if i%2 == 0:
        matched += 1
        if matched &gt; 2: # we now have too many matches, stop checking
            break
if matched == 2:
    print("congratulations")
</code></pre>
<p>If you wanted to do the query much faster on the same input data several times, you should use NumPy instead (with no short-circuiting):</p>
<pre><code>l = np.array([1,2,3,4,5])

if np.count_nonzero(l%2 == 0) == 2:
    print "congratulations"
</code></pre>
<p>This doesn't short-circuit, but it will be super-fast once the input array is constructed, so if you have a large input list and lots of queries to do on it, and the queries can't short-circuit very early, this will likely be faster.  Potentially by an order of magnitude.</p>
</div>
<div class="post-text" itemprop="text">
<p>A <code>sum</code> solution adding up <code>True</code> valuesis correct, probably more efficient than an explicit loop, and definitely the most concise:</p>
<pre><code>if sum(i % 2 == 0 for i in lst) == n:
</code></pre>
<p>However, it relies on understanding that in an integer context like addition, <code>True</code> counts as <code>1</code> and <code>False</code> as <code>0</code>. You may not want to count on that. In which case you can rewrite it (squiguy's answer):</p>
<pre><code>if sum(1 for i in lst if i % 2 == 0) == n:
</code></pre>
<p>But you might want to factor this out into a function:</p>
<pre><code>def count_matches(predicate, iterable):
    return sum(predicate(i) for i in iterable)
</code></pre>
<p>And at that point, it might arguably be more readable to <a href="http://docs.python.org/3/library/functions.html#filter" rel="nofollow"><code>filter</code></a> the list and count the length of the resulting filtered iterable instead:</p>
<pre><code>def ilen(iterable):
    return sum(1 for _ in iterable)

def count_matches(predicate, iterable):
    return ilen(filter(predicate, iterable))
</code></pre>
<p>However, the down side of all of these variations—as with any use of <code>map</code> or <code>filter</code> is that your predicate has to be a <em>function</em>, not just an expression. That's fine when you just wanted to check that <code>some_function(x)</code> returns True, but when you want to check <code>x % 2 == 0</code>, you have to go to the extra step of wrapping it in a function, like this:</p>
<pre><code>if count_matches(lambda x: x %2 == 0, lst) == n
</code></pre>
<p>… at which point I think you lose more readability than you gain.</p>
<hr/>
<p>Since you asked for the fastest—even though that's probably misguided, since I'm sure any of these solutions are more than fast enough for almost any app, and this is unlikely to be a hotspot anyway—here are some tests with 64-bit CPython 3.3.2 on my computer with a length of 250:</p>
<pre><code>32.9 µs: sum(not x % 2 for x in lst)
33.1 µs: i=0\nfor x in lst: if not x % 2: i += 1\n
34.1 µs: sum(1 for x in lst if not x % 2)
34.7 µs: i=0\nfor x in lst: if x % 2 == 0: i += 1\n
35.3 µs: sum(x % 2 == 0 for x in lst)
37.3 µs: sum(1 for x in lst if x % 2 == 0)
52.5 µs: ilen(filter(lambda x: not x % 2, lst))
56.7 µs: ilen(filter(lambda x: x % 2 == 0, lst))
</code></pre>
<p>So, as it turns out, at least in 64-bit CPython 3.3.2 whether you use an explicit loop, sum up False and True, or sum up 1s if True makes very little difference; using <code>not</code> instead of <code>== 0</code> makes a bigger difference in some cases than the others; but even the worst of these is only 12% worse than the best.</p>
<p>So I would use whichever one you find most readable. And, if the slowest one isn't fast enough, the fastest one probably isn't either, which means you will probably need to rearrange your app to use NumPy, run your app in PyPy instead of CPython, write custom Cython or C code, or do something else a lot more drastic than just reorganizing this trivial algorithm.</p>
<p>For comparison, here's some NumPy implementations (assuming <code>lst</code> is a <code>np.ndarray</code> rather than a <code>list</code>):</p>
<pre><code> 6.4 µs: len(lst) - np.count_nonzero(lst % 2)
 8.5 µs: np.count_nonzero(lst % 2 == 0)
17.5 µs: np.sum(lst % 2 == 0)
</code></pre>
<p>Even the most obvious translation to NumPy is almost twice as fast; with a bit of work you can get it 3x faster still.</p>
<p>And here's the result of running the exact same code in PyPy (3.2.3/2.1b1) instead of CPython:</p>
<pre><code>14.6 µs: sum(not x % 2 for x in lst)
</code></pre>
<p>More than twice as fast with no change in the code at all.</p>
</div>
<div class="post-text" itemprop="text">
<p>You might want to look into <code>numpy</code></p>
<p>For example:</p>
<pre><code>In [16]: import numpy as np 
In [17]: a = np.arange(5)

In [18]: a
Out[18]: array([0, 1, 2, 3, 4])

In [19]: np.sum(a % 2 == 0)
Out[19]: 3
</code></pre>
<p>Timings:</p>
<pre><code>In [14]: %timeit np.sum(np.arange(100000) % 2 == 0)
100 loops, best of 3: 3.03 ms per loop

In [15]: %timeit sum(ele % 2 == 0 for ele in range(100000))
10 loops, best of 3: 17.8 ms per loop
</code></pre>
<p>However, if you account for conversion from <code>list</code> to <code>numpy.array</code>, <code>numpy</code> is not faster:</p>
<pre><code>In [20]: %timeit np.sum(np.array(range(100000)) % 2 == 0)
10 loops, best of 3: 23.5 ms per loop
</code></pre>
<p><strong>Edit:</strong></p>
<p>@abarnert's solution is the fastest:</p>
<pre><code>In [36]: %timeit(len(np.arange(100000)) - np.count_nonzero(a % 2))
10000 loops, best of 3: 80.4 us per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <code>sum</code> built in with your condition and check that it equals your <code>n</code> value.</p>
<pre><code>l = [1, 2, 3, 4, 5]
n = 2
if n == sum(1 for i in l if i % 2 == 0):
    print(True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you just use filter() ?</p>
<p>Ex.: Checking number of even integers in a list:</p>
<pre><code>&gt;&gt;&gt; a_list = [1, 2, 3, 4, 5]
&gt;&gt;&gt; matches = list(filter(lambda x: x%2 == 0, a_list))
&gt;&gt;&gt; matches
[2, 4]
</code></pre>
<p>then if you want the number of matches:</p>
<pre><code>&gt;&gt;&gt; len(matches)
2
</code></pre>
<p>And finally your answer:</p>
<pre><code>&gt;&gt;&gt; if len(matches) == 2:
        do_something()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use a while loop:</p>
<pre><code>l=[1,2,3,4,5]

mods, tgt=0,2
while mods&lt;tgt and l:
    if l.pop(0)%2==0:
        mods+=1

print(l,mods)  
</code></pre>
<p>If you are concerned about 'fastest' replace the list with a <a href="http://docs.python.org/2/library/collections.html#collections.deque" rel="nofollow">deque</a>:</p>
<pre><code>from collections import deque

l=[1,2,3,4,5]
d=deque(l)
mods, tgt=0,2
while mods&lt;tgt and d:
    if d.popleft()%2==0: mods+=1

print(d,mods)     
</code></pre>
<p>In either case, it is easy to read and will short circuit when the condition is met. </p>
<p>This <strong>does</strong> do exact matching as written with short-circuiting:</p>
<pre><code>from collections import deque

l=[1,2,3,4,5,6,7,8,9]
d=deque(l)
mods, tgt=0,2
while mods&lt;tgt and d:
    if d.popleft()%2==0: mods+=1

print(d,mods,mods==tgt)
# deque([5, 6, 7, 8, 9]) 2 True
# answer found after 4 loops


from collections import deque

l=[1,2,3,4,5,6,7,8,9]
d=deque(l)
mods, tgt=0,2
while mods&lt;tgt and d:
    if d.popleft()%9==0: mods+=1

print(d,mods,mods==tgt)
# deque([]) 1 False
# deque exhausted and less than 2 matches found...
</code></pre>
<p>You can also use an iterator over your list:</p>
<pre><code>l=[1,2,3,4,5,6,7,8,9]
it=iter(l)
mods, tgt=0,2
while mods&lt;tgt:
    try:
        if next(it)%2==0: mods+=1
    except StopIteration:
        break

print(mods==tgt)   
# True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Build a generator that returns <code>1</code> for each item that matches the criteria and limit that generator to at most <code>n</code> + 1 items, and check that the sum of the ones is equal to the number you're after, eg:</p>
<pre><code>from itertools import islice

data = [1,2,3,4,5]
N = 2
items = islice((1 for el in data if el % 2 == 0), N + 1)
has_N = sum(items) == N
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Itertools is a useful shortcut for list trolling tasks</p>
<pre><code>import itertools

#where expr is a lambda, such as 'lambda a: a % 2 ==0'
def exact_match_count ( expr, limit,  *values):
    passes = itertools.ifilter(expr, values)
    counter = 0
    while counter &lt;= limit + 1:
        try:
            passes.next()
            counter +=1
        except:
            break
    return counter == limit
</code></pre>
<p>if you're concerned about memory limit, tweak the signature so that *values is a generator rather than a tuple</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple way to do it:</p>
<pre><code>def length_is(iter, size):
    for _ in xrange(size - 1):
        next(iter, None)

    try:
        next(iter)
    except StopIteration:
        return False  # too few

    try:
        next(iter)
        return False  # too many
    except StopIteration:
        return True
</code></pre>
<pre><code>length_is((i for i in data if x % 2 == 0), 2)
</code></pre>
<p>Here's a slightly sillier way to write it:</p>
<pre><code>class count(object):
    def __init__(self, iter):
        self.iter = iter

    __eq__ = lambda self, n: length_is(self.iter, n)
</code></pre>
<p>Giving:</p>
<pre><code>count(i for i in data if x % 2 == 0) == 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Any candidate for "the fastest solution" needs to have a single pass over the input and an early-out.</p>
<p>Here is a good base-line starting point for a solution:</p>
<pre><code>&gt;&gt;&gt; s = [1, 2, 3, 4, 5]
&gt;&gt;&gt; matched = 0
&gt;&gt;&gt; for x in s:
        if x % 2 == 0:
            matched += 1
            if matched &gt; 2:
                print 'More than two matched'
else:
    if matched == 2:
        print 'Exactly two matched'
    else:
        print 'Fewer than two matched'


Exactly two matched
</code></pre>
<p>Here are some ideas for improving on the the algorithmicially correct baseline solution:</p>
<ol>
<li><p>Optimize the computation of the condition.  For example, replace <code>x % 2 == 0</code> with <code>not x &amp; 1</code>.  This is called <a href="https://en.wikipedia.org/wiki/Strength_reduction" rel="nofollow">reduction in strength</a>.</p></li>
<li><p>Localize the variables.  Since global lookups and assignments are more expensive than local variable assignments, the exact match test will run faster if it is inside a function.</p>
<p>For example:</p>
<pre><code>def two_evens(iterable):
    'Return true if exactly two values are even'
    matched = 0
    for x in s:
            if x % 2 == 0:
                matched += 1
                if matched &gt; 2:
                    return False
    return matched == 2
</code></pre></li>
<li><p>Remove the interpreter overhead by using <a href="http://docs.python.org/2.7/library/itertools.html#module-itertools" rel="nofollow">itertools</a> to drive the looping logic.</p>
<p>For example, <a href="http://docs.python.org/2.7/library/itertools.html#itertools.ifilter" rel="nofollow">itertools.ifilter()</a> can isolate the matches at C-speed:</p>
<pre><code>&gt;&gt;&gt; list(ifilter(None, [False, True, True, False, True]))
[True, True, True]
</code></pre>
<p>Likewise, <a href="http://docs.python.org/2.7/library/itertools.html#itertools.islice" rel="nofollow">itertools.islice()</a> can implement the early-out logic at C speed:</p>
<pre><code>&gt;&gt;&gt; list(islice(range(10), 0, 3))
[0, 1, 2]
</code></pre>
<p>The built-in <a href="http://docs.python.org/2.7/library/functions.html#sum" rel="nofollow">sum()</a> function can tally the matches at C speed.</p>
<pre><code>&gt;&gt;&gt; sum([True, True, True])
3
</code></pre>
<p>Put these together to check for an exact number of matches:</p>
<pre><code>&gt;&gt;&gt; s = [False, True, False, True, False, False, False]
&gt;&gt;&gt; sum(islice(ifilter(None, s), 0, 3)) == 2
True
</code></pre></li>
<li><p>These optimizations are only worth doing if it is an actual bottleneck in a real program.  That would typically only occur if you're going to make many such exact-match-count tests.  If so, then there may be additional savings by caching some of the intermediate results on the first pass and then reusing them on subsequent tests.</p>
<p>For example, if there is a complex condition, the sub-condition results can potentially be cached and reused.</p>
<p>Instead of:</p>
<pre><code>check_exact(lambda x: x%2==0 and x&lt;10 and f(x)==3, dataset, matches=2)
check_exact(lambda x: x&lt;10 and f(x)==3, dataset, matches=4)
check_exact(lambda x: x%2==0 and f(x)==3, dataset, matches=6)
</code></pre>
<p>Pre-compute all the conditions (only once per data value):</p>
<pre><code>evens = map(lambda x: x%2==0, dataset)
under_tens = map(lambda x: x&lt;10, dataset)
f_threes = map(lambda x: x%2==0 and f(x)==3, dataset)
</code></pre></li>
</ol>
</div>
<span class="comment-copy">@arshajii You should undelete your answer. It's correct now that he clarified the question.</span>
<span class="comment-copy">@Barmar Oh, I see. Thanks -- I've undeleted it.</span>
<span class="comment-copy">The 'naive approach' in the question will not work. It will return True even if only one value meets the condition, and also if more than two meet the condition.</span>
<span class="comment-copy">The benchmarks here are flawed by using a trivial (almost the most trivial possible) condition. This makes it harder to see the difference between shortcircuiting answers and those that don't. You also need a good sample of test cases - in the best case the shortcircuiting answer only needs to test the condition 3 times for n=2.</span>
<span class="comment-copy">The short-circuit isn't correct now that he's clarified the question.</span>
<span class="comment-copy">The OP asked for "fastest" but this answer fails to short-circuit now, and is therefore not the fastest.  I demand a recount!  :)</span>
<span class="comment-copy">@iCodez: please read my answer.  I do short-circuiting, and I claim it is correct.  I just do short-circuiting in a specific way, stopping when we reach 3, because that means we cannot end with 2.</span>
<span class="comment-copy">@JohnZwinck - Oh my, I didn't see that.  Goodness, I don't know why he accepted my answer then.  Yours is a lot better. Have a +1 for 2/3 compensation. :)</span>
<span class="comment-copy">You can still short circuit if there are more than n+1 matches, so this is not optimal</span>
<span class="comment-copy">Version using the <a href="http://docs.python.org/2/library/itertools.html#recipes" rel="nofollow noreferrer"><code>take</code> and <code>consume</code> recipes from the <code>itertools</code> docs</a>, which might be faster in some cases: <code>it = ifilter(condition, l); consume(it, n-1); return len(take(2, it)) == 1</code>. I probably wouldn't use this unless I timed it and found a speed improvement I really needed, or I was just playing around.</span>
<span class="comment-copy">If the condition can be implemented in C (for example, by using <code>2 .__rmod__</code>), <code>sum</code> can get a nice speed boost. If doing so is awkward, though (for example, by using <code>2 .__rmod__</code>), it's probably not worth it.</span>
<span class="comment-copy">If they are already using numpy this is definitely the best.</span>
<span class="comment-copy">Using <code>np.count_nonzero</code> instead of <code>np.sum</code> will probably make it a little faster. And I'm guessing negating the array instead of using <code>== 0</code> might as well. Or, for that matter, not negating or comparing to 0, and instead subtracting the result from the array size.</span>
<span class="comment-copy">Actually, it's not just "a little faster". See my answer. (And the results hold up with larger lists, and on 2.x vs. 3.x; I just didn't show all the timings because it's already too long.)</span>
<span class="comment-copy">@abarnert, It is almost 4 times faster! Thanks a lot for pointing that out.</span>
<span class="comment-copy">@SethMMorton: Even if they're <i>not</i> already using NumPy, switching to NumPy to use this may still be best. After all, if this is their hotspot, the next-slowest parts of their code are probably also doing trivial arithmetic over a big array, and NumPy will similarly give 4-10x speedups for all of those as well, not to mention cutting memory use by 75%… It may not be worth the dev time in many use cases, but if optimizing this loop is important enough to do, numpy-fying probably is.</span>
<span class="comment-copy">If the length is potentially more than a handful, building a list just to take its length and throw it away is more than a little wasteful.</span>
<span class="comment-copy">Why would you use <code>pop(0)</code> when <code>pop()</code> works just fine? (Of course, modifying the list is probably a bad idea, so why not use a <code>for</code> loop or an iterator?)</span>
<span class="comment-copy">Use <code>pop(0)</code> because it may be true that the user wants to check the list left to right which, arithmetically, the correct convention. With a <code>deque</code> there is no spped advantage to <code>pop</code> vs <code>popleft</code> so it does not matter. There is not enough information in the question to state if pop left or pop right is 'correct' with a short circuit.</span>
<span class="comment-copy">It's matching a condition. There's no requirement on what order you check in; if you could exploit some structure of the data to produce a speedup with a more efficient computation order (for example, binary search if the true values were guaranteed to be contiguous), that'd be a win.</span>
<span class="comment-copy">OK -- pop right to left then. Once again -- if you use a <code>deque</code> it does not matter which side you pop from. With a Python list it does have a performance advantage to pop right to left true.</span>
<span class="comment-copy">You should really be catching <code>StopIteration</code> here</span>
<span class="comment-copy">for the contrived example it's almost the only thing that could go wrong :) but you're right, that's better rpactice</span>
