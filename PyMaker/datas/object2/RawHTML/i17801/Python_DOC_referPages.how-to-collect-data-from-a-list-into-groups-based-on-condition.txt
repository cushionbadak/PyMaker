<div class="post-text" itemprop="text">
<p>Not sure how to title this question. I've run into a few situations where I have a list of data, maybe annotated with some property, and I want to collect them into groups. </p>
<p>For example, maybe I have a file like this:</p>
<pre><code>some event
reading: 25.4
reading: 23.4
reading: 25.1
different event
reading: 22.3
reading: 21.1
reading: 26.0
reading: 25.2
another event
reading: 25.5
reading: 25.1
</code></pre>
<p>and I want to group each set of readings, splitting them on a condition (in this case, an event happening) so that I end up with a structure like </p>
<pre><code>[['some event',
  'reading: 25.4',
  'reading: 23.4',
  'reading: 25.1'],
 ['different event',
  'reading: 22.3',
  'reading: 21.1',
  'reading: 26.0',
  'reading: 25.2'],
 ['another event',
  'reading: 25.5',
  'reading: 25.1']]
</code></pre>
<p>In it's generic form, it is:
  Look for a condition, collect the data until that condition is true again, repeat</p>
<p>Right now, I'd do something like </p>
<pre><code>events = []
current_event = []

for line in lines:
    if is_event(line):
        if current_event:
            events.append(current_event)
        current_event = [line]

    else:
        current_event.append(line)
else:
    if current_event:
        events.append(current_event)


def is_event(line):
    return 'event' in line
</code></pre>
<p>which produces what I want, but it's ugly and hard to understand. I'm fairly certain there has to be a better way</p>
<p>My guess is that it involves some itertools wizardry, but I'm new to itertools and can't quite wrap my head around all of it. </p>
<p>Thanks!</p>
<h1>Update</h1>
<p>I've actually gone with Steve Jessop's answer with a Grouper class. Here's what I'm doing:</p>
<pre><code>class Grouper(object):
    def __init__(self, condition_function):
        self.count = 0
        self.condition_function = condition_function

    def __call__(self, line):
        if self.condition_function(line):
            self.count += 1
        return self.count
</code></pre>
<p>and then using it like </p>
<pre><code>event_grouper = Grouper(is_event)
result_as_iterators = (x[1] for x in itertools.groupby(lines, event_grouper))
</code></pre>
<p>and then to turn it into a dictionary I do</p>
<pre><code>event_dictionary = [{event: readings} for event, *readings in result_as_iterators]
</code></pre>
<p>which gives</p>
<pre><code>[
 {'some event': ['reading: 25.4', 'reading: 23.4', 'reading: 25.1']},
 {'different event': ['reading: 22.3','reading: 21.1','reading: 26.0','reading: 25.2']},
 {'another event': ['reading: 25.5', 'reading: 25.1']}
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the fact that functions in Python have state. This grouper function serves the same purpose as DSM's <code>accumulate(fn(line) for line in s1)</code>:</p>
<pre><code>def grouper(line):
    if is_event(line):
        grouper.count += 1
    return grouper.count
grouper.count = 0

result_as_iterators = (x[1] for x in itertools.groupby(lines, grouper))
</code></pre>
<p>Then if you need it:</p>
<pre><code>result_as_lists = [list(x) for x in result_as_iterators]
</code></pre>
<p>To allow for concurrent use you need a new grouper function object each time you use it (so that it has its own count). You might find it simpler to make it a class:</p>
<pre><code>class Grouper(object):
    def __init__(self):
        self.count = 0
    def __call__(self, line):
        if is_event(line):
            self.count += 1
        return self.count

results_as_iterators = itertools.groupby(lines, Grouper())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I doubt itertools (or collections) can make it clearer than this, unless the exact pattern is implemented in there somewhere.</p>
<p>Two things I notice:</p>
<ul>
<li>You <em>always</em> have a current event (since the first line is an event)</li>
<li>You <em>always</em> append the line to the current event (so the event itself is always <code>current_event[0]</code></li>
</ul>
<p>So you can skip the checking for if you have a current event, and you don't have to special-case creating it either.  Additionally, since the "current" event is always the last one, we can just use a negative index to jump straight to it:</p>
<pre><code>events = []

for line in lines:
    if is_event(line):
        events.append([])
    events[-1].append(line)

def is_event(line):
    return 'event' in line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With <a href="http://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a>, you can easily group things based on a key, like <code>'event' in line</code>. So, as a first step:</p>
<pre><code>&gt;&gt;&gt; for k, g in itertools.groupby(lines, lambda line: 'event' in line):
...     print(k, list(g))
</code></pre>
<p>Of course this doesn't put the events together with their values. I suspect you really don't <em>want</em> the events together with their values, but would actually prefer to have a dict of <code>event: [values]</code> or a list of <code>(event, [values])</code>. In which case you're nearly done. For example, to get that dict, just use the grouper recipe (or <code>zip(*[iter(groups)]*2)</code>) to group into pairs, then use a dict comprehension to map either <code>k, v</code> in those pairs to <code>next(k): list(v)</code>.</p>
<p>On the other hand, if you really <em>do</em> want them together, it's the same steps, but with a list of <code>[next(k)] + list(v)]</code> at the end.</p>
<p>However, if you don't actually understand <code>groupby</code> well enough to turn that description into code, you should probably write something you <em>do</em> understand. And that's not too hard:</p>
<pre><code>def groupify(lines):
    event = []
    for line in lines:
        if 'event' in line:
            if event: yield event
            event = [line]
        else:
            event.append(line)
    if event: yield event
</code></pre>
<p>Yes, it's 7 lines (condensable to 4 with some tricks) instead of 3 (condensable to 1 by nesting comprehensions in an ugly way), but 7 lines you understand and can debug are more useful than 3 lines of magic.</p>
<p>When you iterate the generator created by this function, it gives you lists of lines, like this:</p>
<pre><code>&gt;&gt;&gt; for event in groupify(lines):
...     print(event)
</code></pre>
<p>This will print:</p>
<pre><code>['some event', 'reading: 25.4', 'reading: 23.4', 'reading: 25.1']
['different event', 'reading: 22.3', 'reading: 21.1', 'reading: 26.0', 'reading: 25.2']
['another event', 'reading: 25.5', 'reading: 25.1']
</code></pre>
<p>If you want a list instead of an generator (so you can index it, or iterate over it twice), you can do the same thing you do to turn any other iterable into a list:</p>
<pre><code>events = list(groupify(lines))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wish <code>itertools</code> had a function which did what you wanted.  For entertainment value, in modern Python you could do something like</p>
<pre><code>from itertools import groupby, accumulate, tee
def splitter(source, fn):
    s0, s1 = tee(source)
    tick = accumulate(fn(line) for line in s1)
    grouped = groupby(s0, lambda x: next(tick))
    return (list(g) for k,g in grouped)
</code></pre>
<p>which gives</p>
<pre><code>&gt;&gt;&gt; with open("event.dat") as fp:
...     s = list(splitter(fp, lambda x: x.strip().endswith("event")))
...     
&gt;&gt;&gt; s
[['some event\n', 'reading: 25.4\n', 'reading: 23.4\n', 'reading: 25.1\n'], 
['different event\n', 'reading: 22.3\n', 'reading: 21.1\n', 'reading: 26.0\n', 'reading: 25.2\n'], 
['another event\n', 'reading: 25.5\n', 'reading: 25.1']]
</code></pre>
<p>but to be honest I'd probably do what @abarnert did.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make your code more concise using list comprehensions:</p>
<pre><code># Load the file
lines  = [l.rstrip() for l in open("test.txt") ]

# Record the line indices where events start/stop
events = [ i for i in range(len(lines)) if "event" in lines[i] ]
events.append( len(lines) ) # required to get the last event

# Group the lines into their respective events
groups = [ lines[events[i]:events[i+1]] for i in range(len(events)-1) ]
print groups
</code></pre>
<p>Output:</p>
<pre><code>[['some event', 'reading: 25.4', 'reading: 23.4', 'reading: 25.1'],
 ['different event', 'reading: 22.3', 'reading: 21.1', 'reading: 26.0', 'reading: 25.2'],
 ['another event', 'reading: 25.5', 'reading: 25.1']]
</code></pre>
<p>I'm not sure how much you gain in raw readability, but it's pretty straightforward to understand with the comments.</p>
</div>
<span class="comment-copy">Up-vote my answer <i>if it is correct</i> :)</span>
<span class="comment-copy">This is really cool, and actually helps me understand DSM's answer a lot better. So it basically tags each line with a number and groups by that number?</span>
<span class="comment-copy">@JoePinsonault: yes. The number isn't attached to the line or anything, it's just that because we know the grouper function will be called for each line in order, we can rig it to identify each line with the number of the group we want it to be in. This is halfway between "use itertools wherever possible" and "do everything for yourself" :-)</span>
<span class="comment-copy">Oh that's great, it's so obvious now that I've seen it</span>
<span class="comment-copy">@JoePinsonault And in a few years you'll show a similar example to someone else and they'll say the same thing.  'Tis the best way to learn!  =)</span>
<span class="comment-copy">Great answer. Can you add a line about using the groupify generator?</span>
<span class="comment-copy">Ah! I didn't realize creating a generator was so straight forward, that's very clean. Yeah I think after seeing some of the alternatives itertools might be a little crazy for my use case</span>
<span class="comment-copy">@crennie: Does the edited version do what you want?</span>
<span class="comment-copy">@JoePinsonault: Also, if you haven't read the <a href="http://docs.python.org/3/tutorial/classes.html#iterators" rel="nofollow noreferrer">Iterators</a> and following two sections in the Python tutorial, they're pretty handy. Although a lot of people don't grasp the fundamental idea that <code>yield</code> is a way to return a value but keep running, which many novices ask for but most intermediate developers don't bother to because they think it's just not possible.</span>
<span class="comment-copy">@abarnert And that's a good observation about novice/intermediate developers. For most of my ~1 year of writing python I haven't cared about list operations taking up memory because I've dealt with small datasets, but recently the value of generators has become obvious. Started doing operations on ~100MB files, and I can't be a memory cowboy anymore. Plus they're a really interesting concept. They're like little buddies that just hand off data to you only when you need it and no earlier</span>
<span class="comment-copy">I'm going to have to study this a bit, it's exotic and intriguing. I think I've got my next python related reading topics</span>
<span class="comment-copy">I'm pretty sure I submitted something similar to <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more-itertools</code></a>, which didn't require <code>tee</code>ing to iterate twice, but was more complicated and had a bug in some edge case that Erik found and I never bothered to fixâ€¦ if you want to take a stab at doing it right, you should submit it, and the next time this question comes up we can just say "use DSM's splitter, available in more-itertools" and be done with it. :)</span>
<span class="comment-copy">I thought about going for the index based approach at first, but my implementation got too messy. Thanks for showing me how I should have done it if I hadn't given up</span>
