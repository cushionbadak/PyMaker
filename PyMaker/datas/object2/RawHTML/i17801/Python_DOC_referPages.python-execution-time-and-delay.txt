<div class="post-text" itemprop="text">
<p>in that code part, im trying to collect 100 data(in the for loop) and i want if the for loop execution last less then 1 second, wait for (1-execution time) sec. how can i do that ? </p>
<p>thanks</p>
<pre><code>while(1):               
        temparray=array('i')
        fileName = 'interval' + str(initialfreq) + '.txt'
        temp_file = open(fileName, 'wb')
    for z in range(100):
            readoff = ser.readline()                
            temp_file.write(readoff)
            readoff=int(readoff)
            temparray.append(readoff)
    print('biten aralik: '+str(initialfreq))
    general_list.write('interval'+str(initialfreq)+":    "+str(mean(temparray))+'\n')
    initialfreq= initialfreq + 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Before the <code>for</code> loop, get the current time, as <code>t0</code>.</p>
<p>After the <code>for</code> loop, get the current time again, as <code>t1</code>.</p>
<p>Then, if <code>t1 - t0 &lt; 1</code>, <a href="http://docs.python.org/3/library/time.html#time.sleep" rel="nofollow"><code>time.sleep(1 - (t1 - t0))</code></a>.</p>
<p>There are a few different choices of time objects you can use. <a href="http://docs.python.org/3/library/datetime.html#datetime.datetime.now" rel="nofollow"><code>datetime.datetime</code></a> is the simplest (especially if you need to debug this later—print out a <code>datetime</code> and it's immediately readable to a human), if you don't need the highest precision. When you subtract two <code>datetime</code> objects, you get a <code>timedelta</code> object. So:</p>
<pre><code>t0 = datetime.datetime.now()
for …
t1 = datetime.datetime.now()
td = (t1 - t0).total_seconds()
if td &lt; 1:
    time.sleep(1 - td)
</code></pre>
<p>If you need better precision, there are functions in the <code>time</code> module that let you use better clocks that your platform supports, especially if you're on 3.3+. See the <a href="http://docs.python.org/3/library/time.html#time.clock_gettime" rel="nofollow"><code>clock_gettime</code></a> function in 3.3+:</p>
<pre><code>t0 = time.clock_gettime(time.CLOCK_MONOTONIC)
for …
t1 = time.clock_gettime(time.CLOCK_MONOTONIC)
td = (t1 - t0) / time.clock_getres(time.CLOCK_MONOTONIC)
# same code as above
</code></pre>
<p><code>CLOCK_MONOTONIC</code> may not be the best clock for your platform—e.g., if you have <code>CLOCK_HIGHRES</code> or <code>CLOCK_MONOTONIC_RAW</code> they will almost always be better. So, read the docs and then check what you have.</p>
<p>In earlier versions (including all 2.x versions), you will have to choose between <code>clock</code>, <code>perf_counter</code>, <code>process_time</code>, or <code>time</code>, which all have different tradeoffs, and the tradeoffs are even different on different platforms (and <code>datetime.datetime</code> will already be at least as good as <code>time</code>), so no one can tell you "always use this one".</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import time

now = time.time()
future = now + 1
for z in range(100):
  readoff = ser.readline()                
  temp_file.write(readoff)
  readoff=int(readoff)
  temparray.append(readoff)
time_span = future - time.time()
if time_span &gt; 0:
  print 'sleeping for %g' %(1-time_span)
  time.sleep(1-time_span)
</code></pre>
</div>
<span class="comment-copy">As a side note, you appear to be mixing tabs and spaces in your code, which is almost guaranteed to give you <code>IndentationError</code>s or incorrect behavior in cases where nothing looks wrong. Don't do that. Use a text editor that consistently uses spaces even when you hit tab, and run Python with the <code>-t</code> or <code>-tt</code> flag to verify it.</span>
<span class="comment-copy">im totally noob for stackoverflow and when im making code quote there and it looks like there is indentation error :) its correct normally. but thanks for your solution :)</span>
<span class="comment-copy">can i ask that as i said the every period will be 1 sec. so do you think that it can precise enough for 1 sec periods ?  and it doesnt needs to be multiplatform. i will only use win7 and my python version is 2.7.6.  thanks</span>
<span class="comment-copy">@cihangir: IIRC, on Windows, <code>time</code> and <code>datetime.datetime</code> are usually based on a 20ms clock tick, so you'll end up with anywhere from 0.98 sec to 1.02 sec. And <code>sleep</code> is based on processor time slices, which are anywhere from 20-200ms, so that's as good as you can get anyway, without getting fancy.</span>
<span class="comment-copy">ok, thanks a lot for your help :)</span>
<span class="comment-copy">@cihangir: However, one thing to keep in mind: <code>sleep</code> isn't actually guaranteed to sleep for as long as you ask it to. If that's a problem, you may want to loop around the whole bit from <code>t1 =</code> until td &gt;= 1. However, in most apps where that's a problem, you don't really want to wait until a whole second since the last loop, you want to wait until an integral number of seconds since start, or something more complicated. (For example, audio apps often do this kind of thing.)</span>
