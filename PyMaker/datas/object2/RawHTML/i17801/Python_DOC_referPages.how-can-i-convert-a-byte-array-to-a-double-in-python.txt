<div class="post-text" itemprop="text">
<p>I am using Java to convert a double into a byte array. Like this:</p>
<pre><code>public static byte[] toByteArray(double value) {
    byte[] bytes = new byte[8];
    ByteBuffer.wrap(bytes).putDouble(value);
    return bytes;
}
</code></pre>
<p>Now, I would like to convert this byte array back into a double. In Java I would do it like this:</p>
<pre><code>public static double toDouble(byte[] bytes) {
    return ByteBuffer.wrap(bytes).getDouble();
}
</code></pre>
<p>Now, how can I write the <code>toDouble()</code> method in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has the <a href="http://docs.python.org/2/library/struct.html" rel="nofollow"><code>struct</code> module</a> to convert bytes back to <code>float</code> values:</p>
<pre><code>import struct

value = struct.unpack('d', bytes)[0]
</code></pre>
<p>Here <code>'d'</code> signifies that a double value is expected (in native endianess, as 8 bytes). See the module documentation for more options, including specifying endianess.</p>
<p>Another option is to turn your <code>bytes</code> value into an <a href="http://docs.python.org/2/library/array.html" rel="nofollow"><code>array</code> object</a>; you'd use this is if you had a homogenous sequence of doubles:</p>
<pre><code>import array

doubles_sequence = array.array('d', bytes)
</code></pre>
<p>where every 8 bytes is interpreted as a double value, making <code>doubles_sequence</code> a sequence of doubles, addressable by index. To support a different endianess, you can swap the byte order with <code>doubles_sequence.byteswap()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You want the <a href="http://docs.python.org/3/library/struct.html" rel="nofollow"><code>struct</code></a> module:</p>
<pre><code>&gt;&gt;&gt; d = 1.234
&gt;&gt;&gt; b = struct.pack('d', d)
&gt;&gt;&gt; b
b'X9\xb4\xc8v\xbe\xf3?'
&gt;&gt;&gt; d2, = struct.unpack('d', b)
&gt;&gt;&gt; d2
1.234
</code></pre>
<p>The <code>pack</code> method gives you a <code>bytes</code> in Python 3.x, or a <code>str</code> in Python 2.x. This type isn't mutable like a Java <code>byte[]</code>, and in 2.x it also acts like a sequence of single-character strings, not a sequence of numbers from 0-255. If you need to fix either of those, just convert it to <code>bytearray</code>.</p>
<p>Also, note that—in both Java and Python—you probably want to specify an explicit endianness more often than not, especially if you're planning to save the bytes to a file or send them over the network. See <a href="http://docs.python.org/3/library/struct.html#format-strings" rel="nofollow">Format Strings</a> for details.</p>
<p>So:</p>
<pre><code>&gt;&gt;&gt; b = bytearray(struct.pack('!d', d))
&gt;&gt;&gt; b
bytearray(b'?\xf3\xbev\xc8\xb49X')
&gt;&gt;&gt; b[0]
63
</code></pre>
</div>
<span class="comment-copy">How would you go about to extract doubles from the <code>doubles_sequence</code>. Say the first double.</span>
<span class="comment-copy">@user2426316: <code>doubles_sequence[0]</code> gives you the first value, just like in a list.</span>
