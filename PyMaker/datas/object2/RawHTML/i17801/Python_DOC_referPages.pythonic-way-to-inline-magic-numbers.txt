<div class="post-text" itemprop="text">
<p>My code has several magic numbers like specific error codes from "outside" that I need only once. So I could code</p>
<pre><code>do_something(x, y, 161)
</code></pre>
<p>or </p>
<pre><code>magic_code = 161
do_something(x, y, magic_code)
</code></pre>
<p>The second one is of course better readable as it encodes the meaning of 161 into "magic_code". Thus the code becomes more readable. However it puts the semantical link outside of the statement. Would there be an easy to type way to put this inline? Ideally something in the direction of</p>
<pre><code>do_something(x, y, magic_code = 161)
do_something(x, y, other_magic = 162)
</code></pre>
<p>which of course does not work.</p>
<p>Of course I could collect the constants into some specific enumeration. However the constants are "only good for one call".</p>
<p>Some answers suggest to collect the magic constants into an enumeration. I do not want to do that. The issue is that do_something calls some external system and I collect the constants through reverse engineering. Once I have all the calls in place I might decide to do so. But at this time it is more convenient to NOT YET do so. So I am asking for a way to speed up my typing while still maintaining some readability.</p>
<p>The closest thing that I found so far is</p>
<pre><code>do_something(x, y, 161 if "magic" else nil)
do_something(x, y, {"magic":161}["magic"])

def inline_constant(name, value): return value
do_something(x, y, inline_constant("magic", 161))
do_something(x, y, inline_constant("other_magic", 162))
</code></pre>
<p>It puts the semantics close to the number but it looks awkward to me.</p>
<p>I do not want to set a module level constant. I only want an one time named constant. The closest thing I have found so far is</p>
<pre><code>do something(x, y, "magic" and 161)
do something(x, y, "other magic" and 162)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The probably least ugly option would be something like this:</p>
<pre><code>def const(**kwargs):
    return kwargs.values()[0]


do_something(x, y, const(magic_code=161))
do_something(x, y, const(other_magic=162))
</code></pre>
<p>For python3 (where <code>values()</code> returns a <a href="http://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow">view</a> which you cannot index directly):</p>
<pre><code>def const(**kwargs):
    for x in kwargs.values():
        return x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In python, you can't<sup>1</sup> do an assignment in an expression ... and honestly, I don't really see why you would want to<sup>2</sup>.  Ultimately, wherever the <code>do_something</code> function is defined, there should also be the constants that it accepts as magical:</p>
<pre><code># Magic values
EARTH = 1
FIRE = 2
WATER = 4
AIR = 8
HEART = 16

def do_something(a, b, magic):
   ...
</code></pre>
<p>Now, you can call it like:</p>
<pre><code>do_something("Captain", "Planet", EARTH)
</code></pre>
<p>Or, if it's imported from a module:</p>
<pre><code>import my_module
my_module.do_something("Captain", "Planet", my_module.EARTH)
</code></pre>
<p>if you're outside the function looking in, you don't care what value <code>EARTH</code> has, only that it means something special to the function.</p>
<p>Note that python3.4(?) has made this even a little more formalized with <a href="http://docs.python.org/3.4/library/enum.html" rel="nofollow">enumerated types</a>.</p>
<hr/>
<p><sup><sup>1</sup><em>can't</em> is too strong of a word here.  <code>globals().update(foo=bar) or bar</code> is technically an expression which has the effect of an assignment in the global namespace and still returns <code>bar</code> ... But that's just dirty...</sup></p>
<p><sup><sup>2</sup>I'm sure a ruby programmer could let me know why I would want to do that, but I've never felt the need ... ;-)</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>So, Ideally you'd like to call:</p>
<pre><code>do_something(x, y, magic_code=1234)
</code></pre>
<p>In order to do that, in the function definition, do this:</p>
<pre><code>def do_something(x, y, magic_code=int)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; def do_something(x, y, magic_code=int):
    print x, y, magic_code


&gt;&gt;&gt; do_something(1, 2, 123)
1 2 123
&gt;&gt;&gt; do_something(1, 2, magic_code=123)
1 2 123
</code></pre>
</div>
<span class="comment-copy">ummm... that works, just remove the spaces, i.e. do_something(x, y, magic_code=161)</span>
<span class="comment-copy">@ColeMaclean: only if the argument is also named <code>magic_code</code>.  If he had <code>def do_something(x, y, code_number): pass</code>, it wouldn't.</span>
<span class="comment-copy">Why not have a module that defines all these constants and import it when required? Or am I missing something?</span>
<span class="comment-copy">Right, so why not do that?</span>
<span class="comment-copy"><code>"magic" or 161</code> won't work; you'd need <code>"magic" and 161</code>.</span>
<span class="comment-copy">Yes, this looks like what I was searching for.</span>
<span class="comment-copy">I can't decide if that's inspired or awful. Full marks for creativity, anyway, and a decent implementation of what the OP asked for. But does it have anything to recommend it over module-level constants or even <code>do_something(x, y, 161) # 161 is magic_code</code>? It seems like an obfuscatory way to add semantically meaningless information to the code, which is normally something I think of as belonging in variable names or comments.</span>
<span class="comment-copy">@PeterDeGlopper: I definitely wouldn't tolerate something like this in the production code, but as a temporary hack to save some typing during debugging - why not?</span>
<span class="comment-copy">python3 compatibility:  <code>return next(iter(kwargs.values()))</code></span>
<span class="comment-copy">@mgilson: thanks, updated!</span>
<span class="comment-copy">Captain Planet Fan, eh?</span>
<span class="comment-copy">@GamesBrainiac -- who isn't?  Captain Planet, he's our hero ...</span>
<span class="comment-copy"><a href="http://www.python.org/dev/peps/pep-0008/#constants" rel="nofollow noreferrer">python.org/dev/peps/pep-0008/#constants</a> if you want an external source recommending the same thing. Or am I skipping over too much of the obvious-to-me logic that dictates that magical numbers should be module-level constants?</span>
<span class="comment-copy">I like importing constants from a dedicated module (or class) best. Qualifying with the module or class name also gives you a clear indication what group a particular constant belongs to. +1</span>
<span class="comment-copy">This is a keyword argument here.</span>
<span class="comment-copy">umm <code>magic_code=int</code>?</span>
<span class="comment-copy">I think <code>OP</code> wants <code>magic_code</code> to magically set a module level name "magic_code" ...</span>
<span class="comment-copy">@mgilson That sounds like a <i>really</i> bad idea.</span>
<span class="comment-copy"><code>int</code> is a type, so making it the default value of the <code>magic_code</code> argument would cause the call <code>do_something(1, 2)</code> to result in <code>1 2 &lt;type 'int'&gt;</code> being printed -- which doesn't really make any sense IMHO.</span>
