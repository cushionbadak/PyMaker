<div class="post-text" itemprop="text">
<p>I'm running many web servers on the same machine for test purposes. Instead of dealing with server port conflicts, I'd like to have the servers simply ask the OS for an available port, and then tell me what they got.</p>
<p>I may communicate the port back to the invoker by logging to console, or writing to a specified temp file (not sure yet), but knowing the port number is the tricky part.</p>
<p>Currently, the WSGI based server is being launched with:</p>
<pre><code>  cherrypy.quickstart(dev_server, config=_GetConfig(options))
</code></pre>
<p>The config will contain the following:</p>
<pre><code>{ 'global':
                  { &lt;snip&gt;
                    'server.socket_host': '0.0.0.0',
                    'server.socket_port': int(options.port)
                  },
   &lt;snip&gt;
}
</code></pre>
<p>Is there any way to do this with CherryPy?</p>
<p>I assume I can set the port to '0' to have it auto-selected, but that doesn't give me a way to report it.</p>
</div>
<div class="post-text" itemprop="text">
<p>The basic idea is:</p>
<ul>
<li>Bind to port 0.</li>
<li>Ask the socket which port you ended up with.</li>
<li>Report that port somehow.</li>
</ul>
<p>The first part depends radically on how you're building, starting, and configuring your servers. CherryPy is hugely flexible, and the details will be different depending on how you're using it.</p>
<p>The second part requires that you be using some mechanism where you're writing the top-level code that starts the servers, and <em>not</em> one of the mechanisms that starts them automatically without any of your code. That's because, before starting the server, you will need to manually <a href="http://docs.cherrypy.org/dev/refman/wsgiserver/init.html#cherrypy.wsgiserver.HTTPServer.bind" rel="nofollow"><code>bind</code></a> the server to get its socket. Once you have a created and bound socket, <a href="http://docs.python.org/3/library/socket.html#socket.socket.getsockname" rel="nofollow"><code>getsockname</code></a> will give you the address and port it ended up bound to.</p>
<p>The third part can obviously be as easy or as hard as you want.</p>
<hr/>
<p>Here's a trivial example, which you can even do from the interactive interpreter:</p>
<pre><code>def app(env, start):
    start('200 OK', [('Content-type', 'text/plain')])
    return ['Hello, world!']
server = cherrypy.wsgiserver.CherryPyWSGIServer(('0.0.0.0', 0), app,
                                                server_name='localhost')
server.bind(socket.AF_INET, socket.SOCK_STREAM)
addr, port = server.socket.getsockname()
print(port)
server.start()
</code></pre>
<hr/>
<p>You may also want to take a look at <a href="https://cherrypy.readthedocs.org/en/latest/pkg/cherrypy.process.html?highlight=serveradapter#cherrypy.process.servers.ServerAdapter" rel="nofollow"><code>cherrypy.process.servers</code></a> and its <code>ServerAdapter</code>, which lets you manage multiple servers from a single place, instead of having a bunch of independent servers that you have to manually coordinate.</p>
</div>
<span class="comment-copy">How do you want them to tell you what they got? Print to the console? Log to syslog? Write it to a runfile? Connect to some master server and send it via some API?</span>
<span class="comment-copy">Are there that many web servers competing for a port? A loop that tries port at random would find one after a few rounds. But don't think of that loop before you have an answer to @abarnert comment.</span>
<span class="comment-copy">Also, please tell us how you're starting your server(s) and how you're configuring them, because CherryPy has a lot of flexibility.</span>
<span class="comment-copy">Right now, each test instance is it's own Python process started independently from other instances. CherryPy is actually launched with: cherrypy.quickstart(dev_server, config=_GetConfig(options))</span>
<span class="comment-copy">Sometimes I feel like we just "give away" solutions to problems "too easily". Good Answer however :)</span>
<span class="comment-copy">@JamesMills: This only gives away the solution if he happens to be using a flat <code>CherryPyWSGIServer</code> with all configuration hard-coded in the source, which I really doubt he's using. My hope is that it's enough for him to figure out how to adapt to whatever he actually <i>is</i> doing, and/or find the relevant information in the docs, and/or at least ask a better questionâ€¦</span>
<span class="comment-copy"><i>sigh</i> :) I do admit it though, you're answer was/is better phrased and oragnized than mine was :)</span>
<span class="comment-copy">Your answer is exactly what I needed. These scripts are something I inherited, but haven't gone through in depth. In particular, I hadn't realized that CherryPy was that flexible, or could be used in so many different ways.</span>
