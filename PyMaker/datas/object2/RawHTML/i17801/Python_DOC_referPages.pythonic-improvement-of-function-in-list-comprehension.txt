<div class="post-text" itemprop="text">
<p>Is there a more pythonic way to do the following code?  I would like to do it in one line</p>
<p>parsed_rows is a function that can return a tuple of size 3, or None.</p>
<pre><code>parsed_rows = [ parse_row(tr) for tr in tr_els ]        
data        = [ x for x in parsed_rows if x is not None ] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Doing this in one line won't make it more Pythonic; it will make it less readable. If you really want to, you can always translate it directly by substitution like this:</p>
<pre><code>data = [x for x in [parse_row(tr) for tr in tr_els] if x is not None] 
</code></pre>
<p>… which can obviously be flattened as Doorknob of Snow shows, but it's still hard to understand. However, he didn't get it quite right: clauses nest from left to right, and you want <code>x</code> to be each <code>parse_row</code> result, not each element of each <code>parse_row</code> result (as Volatility points out), so the flattened version would be:</p>
<pre><code>data = [x for tr in tr_els for x in (parse_row(tr),) if x is not None]
</code></pre>
<p>I think the fact that a good developer got it backward and 6 people upvoted it before anyone realized the problem, and then I missed a second problem and 7 more people upvoted that before anyone caught it, is pretty solid proof that this is not more pythonic or more readable, just as Doorknob said. :)</p>
<p>In general, when faced with either a nested comp or a comp with multiple <code>for</code> clauses, if it's not immediately obvious what it does, you should translate it into nested <code>for</code> and <code>if</code> statements with an innermost <code>append</code> expression statement, as shown in <a href="http://docs.python.org/3.3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">the tutorial</a>. But if you need to do that with a comprehension you're trying to write, it's a pretty good sign you shouldn't be trying to write it…</p>
<hr/>
<p>However, there <em>is</em> a way to make this more Pythonic, and also more efficient: change the first list comprehension to a generator expression, like this:</p>
<pre><code>parsed_rows = (parse_row(tr) for tr in tr_els)
data = [x for x in parsed_rows if x is not None]
</code></pre>
<p>All I did is change the square brackets to parentheses, and that's enough to compute the first one <em>lazily</em>, calling <code>parse_row</code> on each <code>tr</code> as needed, instead of calling it on all of the rows, and building up a list in memory that you don't actually need, before you even get started on the real work.</p>
<p>In fact, if the only reason you need <code>data</code> is to iterate over it once (or to convert it into some other form, like a CSV file or a NumPy array), you can make that a generator expression as well.</p>
<hr/>
<p>Or, even better, replace the list comprehension with a <a href="http://docs.python.org/3.3/library/functions.html#map" rel="nofollow"><code>map</code></a> call. When your expression is just "call this function on each element", <code>map</code> is generally more readable (whereas when you have to write a new function, especially with <code>lambda</code>, just to wrap up some more complex expression, it's usually not). So:</p>
<pre><code>parsed_rows = map(parse_row, tr_els)
data = [x for x in parsed_rows if x is not None]
</code></pre>
<p>And now it actually <em>is</em> readable to sub in:</p>
<pre><code>data = [x for x in map(parse_row, tr_els) if x is not None]
</code></pre>
<hr/>
<p>You could similarly turn the second comprehension into a <a href="http://docs.python.org/3/library/functions.html#filter" rel="nofollow"><code>filter</code></a> call. However, just as with <code>map</code>, if the predicate isn't just "call this function and see if it returns something truthy", it usually ends up being less readable. In this case:</p>
<pre><code>data = filter(lambda x: x is not None, map(parse_row, tr_els))
</code></pre>
<p>But notice that you really don't need to check <code>is not None</code> in the first place. The only non-<code>None</code> values you have are 3-tuples, which are always truthy. So, you can replace the <code>if x is not None</code> with <code>if x</code>, which can simplifies your comprehension:</p>
<pre><code>data = [x for x in map(parse_row, tr_else) if x]
</code></pre>
<p>… and which can be written in two different ways with <code>filter</code>:</p>
<pre><code>data = filter(bool, map(parse_row, tr_els))
data = filter(None, map(parse_row, tr_els))
</code></pre>
<p>Asking which of those two is better will start a religious war on any of the Python lists, so I'll just present them both and let you decide.</p>
<hr/>
<p>Note that if you're using Python 2.x, <code>map</code> is not lazy; it will generate the whole intermediate list. So, if you want to get the best of both worlds, and can't use Python 3, use <code>itertools.imap</code> instead of <code>map</code>. An in the same way, in 3.x, <code>filter</code> <em>is</em> lazy, so if you want a list, use <code>list(filter(…))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can nest one in the other:</p>
<pre><code>data = [x for tr in tr_els for x in parse_row(tr) if x is not None]
</code></pre>
<p>(Also, @Volatility points out that this will give an error if <code>parse_row(tr)</code> is <code>None</code>, which can be solved like this:</p>
<pre><code>data = [x for tr in tr_els for x in (parse_row(tr),) if x is not None]
</code></pre>
<p>)</p>
<p>However, in my opinion this is much less readable. Shorter is not always better.</p>
</div>
<span class="comment-copy">You can make <code>parsed_rows</code> a generator so you don't have to materialize an intermediate list.</span>
<span class="comment-copy">+1 for <code>map</code>. I didn't think of that.</span>
<span class="comment-copy">+1, but I think the second code should be <code>data = [x for tr in tr_els for x in (parse_row(tr),) if x is not None]</code> (I'm nitpicking though)</span>
<span class="comment-copy"><code>data = filter(None,parsed_rows)</code> is also pretty readable</span>
<span class="comment-copy">@JoranBeasley: But that's the same as <code>if x</code>, not <code>if x is not None</code>, which will filter out zeros, empty strings, etc.</span>
<span class="comment-copy">@abarnert: to be fair, the OP said the only two options were tuple-of-three and None.</span>
<span class="comment-copy">+1, shorter is not always better. Giving a name to the intermediate data puts explicit intent in the code</span>
<span class="comment-copy">With nested comprehensions I usually format it so that each <code>for</code> is on a different line, but I guess that defeats the purpose of the question!</span>
<span class="comment-copy">Isn't this an array comprehension with a generator expression though (rather than nested array comprehensions), just to nit-pick? Not sure about it myself, so this is a serious question :)</span>
<span class="comment-copy">@roe Heh, I'm actually not sure about that myself, since I don't usually use Python. I'll just edit it out</span>
<span class="comment-copy">Shouldn't there be square brackets around the <code>parsed(tr) for tr in tr_els</code>? Because otherwise it would give a <code>NameError</code></span>
