<div class="post-text" itemprop="text">
<p>Suppose I have the following code which takes in a distance function and two points, and spits out the distance:</p>
<pre><code>def distance(dist_fun, p1, p2):
    ## SOME ASSERTION HERE on dist_fun ##

    ## Suppose, just for this post, we've already checked p1 and p2 are 
    ## n-tuples of integers.

    assert (len(p1) == len(p2)), "Coordinates are different dimensions."
    dist = dist_fun(p1, p2)
    assert (dist&gt;=0), "Negative distance is not possible."
    return dist

def euclid(p1, p2):  #as an example dist function.
    return pow(reduce(lambda x,y: x+y, [pow((p1[i] - p2[i]), 2) for i in range(len(p1))]),0.5)
</code></pre>
<p>I'd like to be able to check that if a user uses a particular distance function that it is, first and foremost, actually a function.  After this, I can check other things, but my main question is: <strong>how do I assert that dist_fun is actually a function?</strong></p>
<p>If there is no easy way to do this, or if there's an alternative way to do this kind of thing, let me know.  I've done a bit of testing before in Python, but never ran across this problem until now.  I've seen that the "type" of a function is "function", but Python does not allow me to use this as a type?  Would it be easier just to go back to try-except here?</p>
</div>
<div class="post-text" itemprop="text">
<p>The motto for Python is, of course, that it's better to ask forgiveness than permission. So, you'd be perfectly fine counting on the user to pass you valid input, or <code>except</code>ing the <code>TypeError</code> that gets thrown if you try to call something that can't be called. </p>
<p><strong>That being said</strong>, if you really want to assert that something is a function, I suppose you could always check the type...</p>
<pre><code>assert (callable(dist_fun))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>how do I assert that dist_fun is actually a function?</p>
</blockquote>
<p>This is normally done via:</p>
<pre><code>if callable(f):
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to assert that it's actually a function, that's easy:</p>
<pre><code>assert ininstance(dist_fun, types.FunctionType)
</code></pre>
<p>… or:</p>
<pre><code>assert inspect.isfunction(dist_fun)
</code></pre>
<p>In general, when you have this problem:</p>
<blockquote>
<p>I've seen that the "type" of a function is "function", but Python does not allow me to use this as a type?</p>
</blockquote>
<p>… for a built-in type, the type you want is available in <a href="http://docs.python.org/2/library/types.html" rel="nofollow"><code>types</code></a> and/or a function that checks more simply can be found in <a href="http://docs.python.org/3/library/types.html" rel="nofollow"><code>inspect</code></a>.</p>
<hr/>
<p>However, you probably don't want to do that; rather, you want to assert that it's <em>something callable</em>. After all, a bound method, a <code>functools.partial</code>, an object with a custom <code>__call__</code> method, a custom function-like object implemented in a C extension, etc. would all be just as useful here, right? So use <a href="http://docs.python.org/2/library/functions.html#callable" rel="nofollow"><code>callable</code></a>:</p>
<pre><code>assert callable(dist_fun)
</code></pre>
<p>(Unless you need to support Python 3.0-3.1, or really ancient 1.x versions. <code>callable</code> was added somewhere around 1.4, removed in 3.0, then added back in 3.2.)</p>
<hr/>
<p>Or, maybe even better (with Python 3.3+ only):</p>
<pre><code>assert inspect.signature(dist_fun).bind(p1, p2)
</code></pre>
<p>This checks that it's not just callable, but callable with the arguments you want to pass it. (Not such a big deal when it's just two positional arguments… but when you're passing keyword arguments, or forwarding args with <em>/</em>*, etc., it can be.)</p>
</div>
<div class="post-text" itemprop="text">
<p>well, instead of trying to test if the parammeter is a valid function, you can test is it's callable, because with python any user can user a callable instead of a function, this is one way to do it:</p>
<pre><code>if callable(dist_fun):
    # do whatever you wanna do
</code></pre>
<p>or</p>
<pre><code>assert callable(dist_func)
</code></pre>
</div>
<span class="comment-copy">I'm also trying to get better at "when to and when to not use assertions" but I didn't want to make that part of the main question.  Feel free to comment on my assertion usage here in the comments.</span>
<span class="comment-copy">Why are you assertions here at all?</span>
<span class="comment-copy">@james: Many Python developers would say you should <i>never</i> use assertions like this, because Design By Contract and dynamic languages are a bad fit. Others argue that DBC is either completely independent of static type checking, or strictly a superset of it, so it makes as much sense in Python as in Java or Eiffel. It's either a style question or a religious question, and either way, SO isn't going to answer it for you…</span>
<span class="comment-copy">Is there any damage done to do the latter?  This is <i>exactly</i> what I wanted, also.  Thank you!</span>
<span class="comment-copy">In general, yes, EAFP. But not when you're trying to use assert design-by-contract as the OP is. Whether he should be trying to do that is a different question… but so long as he is, EAFP isn't the way to do it.</span>
<span class="comment-copy">Yeah - that's why I talked about the latter solution. The main reason I advocated for the first solution is that it would perhaps provide more informative error messages (<code>TypeError</code> vs <code>AssertionError</code>) to the caller of the function.</span>
<span class="comment-copy">@AVP: But a <code>TypeError</code> is <i>less</i> informative, not <i>more</i>. For example, it could just as easily mean that you called it with the wrong arguments, or had a <code>TypeError</code> in evaluating the arguments in the first place, or… An <code>AssertionError</code> has exactly the text you want it to have, and tells you exactly which part of the statement failed (the <code>assert</code> part itself, of course). They wouldn't be in the language otherwise.</span>
<span class="comment-copy">@james: What do you mean by "damage"? There's obviously a CPU cost to doing an extra function call, and to <code>assert</code>ing, which you wouldn't have to pay if you just tried to call the function and let it fail. And of course there's an extra line of code to read, write, and maintain. And there could be some rare edge cases where it's not clear what <code>callable</code> should return and therefore what it returns isn't what you wanted. That's all "damage" in a way. But it doesn't mutate the function you pass it or speculatively execute its code or anything, if that's what you're asking.</span>
<span class="comment-copy">I didn't know about "types" at all --- this is pretty neat.  I also didn't know about <b>call</b>, but I'm sure there's some pretty cool stuff that I can do with that when I start doing a bit more under-the-hood work.  Neat.</span>
<span class="comment-copy">@james: Take a look at <code>inspect</code> while you're at it. Especially if you are (or are considering) using 3.3+, where you can use <code>inspect.signature(dist_fun)</code> and assert that it will take the arguments you want to pass it.</span>
