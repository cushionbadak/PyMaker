<div class="post-text" itemprop="text">
<p>What is the purpose of checking <code>self.__class__</code> ? I've found some code that creates an abstract interface class and then checks whether its <code>self.__class__</code> is itself, e.g.</p>
<pre><code>class abstract1 (object):
  def __init__(self):
    if self.__class__ == abstract1: 
      raise NotImplementedError("Interfaces can't be instantiated")
</code></pre>
<p><strong>What is the purpose of that?
Is it to check whether the class is a type of itself?</strong></p>
<p>The code is from NLTK's <a href="http://nltk.googlecode.com/svn/trunk/doc/api/nltk.probability-pysrc.html#ProbDistI" rel="noreferrer">http://nltk.googlecode.com/svn/trunk/doc/api/nltk.probability-pysrc.html#ProbDistI</a></p>
</div>
<div class="post-text" itemprop="text">
<p><code>self.__class__</code> is a reference to the <em>type</em> of the current instance.</p>
<p>For instances of <code>abstract1</code>, that'd be the <code>abstract1</code> class <em>itself</em>, which is what you don't want with an abstract class. Abstract classes are only meant to be subclassed, not to create instances directly:</p>
<pre><code>&gt;&gt;&gt; abstract1()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 4, in __init__
NotImplementedError: Interfaces can't be instantiated
</code></pre>
<p>For an instance of a <em>subclass</em> of <code>abstract1</code>, <code>self.__class__</code> would be a reference to the specific subclass:</p>
<pre><code>&gt;&gt;&gt; class Foo(abstract1): pass
... 
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.__class__
&lt;class '__main__.Foo'&gt;
&gt;&gt;&gt; f.__class__ is Foo
True
</code></pre>
<p>Throwing an exception here is like using an <code>assert</code> statement elsewhere in your code, it protects you from making silly mistakes.</p>
<p>Note that the <em>pythonic</em> way to test for the type of an instance is to use the <a href="http://docs.python.org/2/library/functions.html#type" rel="nofollow noreferrer"><code>type()</code> function</a> instead, together with an <em>identity</em> test with the <code>is</code> operator:</p>
<pre><code>class abstract1(object):
    def __init__(self):
        if type(self) is abstract1: 
            raise NotImplementedError("Interfaces can't be instantiated")
</code></pre>
<p><code>type()</code> should be preferred over <code>self.__class__</code> because the latter <a href="https://stackoverflow.com/a/10633356/100297">can be shadowed by a class attribute</a>.</p>
<p>There is little point in using an equality test here as for custom classes, <code>__eq__</code> is basically implemented as an identity test anyway.</p>
<p>Python also includes a standard library to define abstract base classes, called <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer"><code>abc</code></a>. It lets you mark methods and properties as abstract and will refuse to create instances of any subclass that has not yet re-defined those names.</p>
</div>
<div class="post-text" itemprop="text">
<p>The code that you posted there is a no-op; <code>self.__class__ == c1</code> is not part of a conditional so the boolean is evaluated but nothing is done with the result.</p>
<p>You could try to make an abstract base class that checks to see if <code>self.__class__</code> is equal to the abstract class as opposed to a hypothetical child (via an if statement), in order to prevent the instantiation of the abstract base class itself due to developer mistake.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd say that some would do:</p>
<pre><code>class Foo(AbstractBase):
    def __init__(self):
        super(Foo, self).__init__()
        # ...
</code></pre>
<p>Even when the base is abstract, you wouldn't want the base's <code>__init__</code> to throw <code>NotImplementedError</code>. Hey, maybe it even does something useful?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>What is the purpose of that? Is it to check whether the class is a type of itself?</p>
</blockquote>
<p>Yes, if you try to construct an object of type <code>Abstract1</code> it'll throw that exception telling you that you're not allowed to do so.</p>
</div>
<div class="post-text" itemprop="text">
<p>The clues are in the name of the class, "abstract1", and in the error. This is intended to be an abstract class, meaning one that is intended to be subclassed. Each subclass will provide its own behaviour. The abstract class itself serves to document the interface, i.e. the methods and arguments that classes implementing the interface are expected to have. It is not meant to be instantiated itself, and the test is used to tell whether we are in the class itself or a subclass.</p>
<p>See the section on Abstract Classes in this <a href="http://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods" rel="nofollow">article</a> by Julien Danjou.</p>
</div>
<span class="comment-copy">I think this requires more context.  Where did you "find" this code?  It's basically broken.</span>
<span class="comment-copy">@Iguananaut: Why is it broken? It works <i>fine</i> when used as intended; as an abstract base class.</span>
<span class="comment-copy">I'm pretty sure earlier it was something different?  I don't know--I agree, what's on there now is not broken.</span>
<span class="comment-copy">Although for more recent versions of Python one should just use an abstract base class using <code>abc.ABCMeta</code>.</span>
<span class="comment-copy">An ABC can still be instantiated directly.</span>
<span class="comment-copy">Are you saying that <code>super(Foo, self).__init__()</code> would not work? Because that is not correct; it'll work <i>just fine</i>. The base's <code>__init__</code> will <i>only</i> throw the exception when self is an instance of <code>AbstractBase</code>, and not when it instance of a subclass like <code>Foo</code>.</span>
