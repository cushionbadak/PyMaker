<div class="post-text" itemprop="text">
<p>I have the following code</p>
<pre><code>from __future__ import print_function
import subprocess

p = subprocess.Popen(['cat'], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
p.kill()
p.wait()
print(p.stdin.write(b'some'))
</code></pre>
<p>and I ran it with python 2.7 and python 3.3. With python 2.7 an exception is thrown when I try to write to stdin. With python 3.3 this code prints 4. What is the difference between python 2.7 subprocess module and python 3.3?</p>
</div>
<div class="post-text" itemprop="text">
<p>The difference is in the default value for <code>bufsize</code>. It is <code>0</code> (unbuffered) in Python 2.7 therefore <code>write</code> causes <code>EPIPE</code> error. Pipes are fully buffered in Python 3.2+ i.e., until you flush the buffer, no error is detected. From <a href="http://docs.python.org/3/library/subprocess#popen-constructor" rel="noreferrer"><code>subprocess</code>' docs</a>:</p>
<blockquote>
<p>Changed in version 3.3.1: <code>bufsize</code> now defaults to <code>-1</code> to enable
  buffering by default to match the behavior that most code expects. In
  versions prior to Python 3.2.4 and 3.3.1 it incorrectly defaulted to <code>0</code>
  which was unbuffered and allowed short reads. This was unintentional
  and did not match the behavior of Python 2 as most code expected.</p>
</blockquote>
</div>
<span class="comment-copy">Docs for both <a href="http://docs.python.org/2.7/library/subprocess.html#popen-objects" rel="nofollow noreferrer">2.7</a> and <a href="http://docs.python.org/3.3/library/subprocess.html#popen-objects" rel="nofollow noreferrer">3.3</a> warn to use <code>communicate</code> rather than <code>.stdin.write</code> - does that make any difference?</span>
<span class="comment-copy">It would be nice to know which expression is thrown in Python 2.7 :-)</span>
<span class="comment-copy">The exception is <code>IOError: [Errno 32] Broken pipe</code>. When I use <code>communicate</code> exception is not thrown, but I need to use <code>stdin.write</code>.</span>
<span class="comment-copy">Why are you trying to first kill the process and then write to it's stdin? To me it seems that this is just undefined behaviour.</span>
<span class="comment-copy">What are you really trying to do? To handle gracefully a situation where the child process died? On which platform? Do you get an exception on 3.3 if you add <code>p.stdin.flush()</code> in the end?</span>
