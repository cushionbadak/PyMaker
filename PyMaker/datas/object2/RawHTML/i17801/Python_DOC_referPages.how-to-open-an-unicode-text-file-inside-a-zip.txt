<div class="post-text" itemprop="text">
<p>I tried</p>
<pre><code>with zipfile.ZipFile("5.csv.zip", "r") as zfile:
    for name in zfile.namelist():
        with zfile.open(name, 'rU') as readFile:
                line = readFile.readline()
                print(line)
                split = line.split('\t')
</code></pre>
<p>it answers:</p>
<pre><code>b'$0.0\t1822\t1\t1\t1\n'
Traceback (most recent call last)
File "zip.py", line 6
    split = line.split('\t')
TypeError: Type str doesn't support the buffer API
</code></pre>
<p>How to open the text file as unicode instead of as <code>b</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><em>edit</em> For Python 3, using <code>io.TextIOWrapper</code> as J. F. Sebastian describes is the best choice. The answer below could still be helpful for 2.x. I don't think anything below is actually incorrect even for 3.x, but <code>io.TestIOWrapper</code> is still better.</p>
<p>If the file is utf-8, this will work:</p>
<pre><code># the rest of the code as above, then:
with zfile.open(name, 'rU') as readFile:
    line = readFile.readline().decode('utf8')
    # etc
</code></pre>
<p>If you're going to be iterating over the file you can use <code>codecs.iterdecode</code>, but that won't work with <code>readline()</code>.</p>
<pre><code>with zfile.open(name, 'rU') as readFile:
    for line in codecs.iterdecode(readFile, 'utf8'):
        print line
        # etc
</code></pre>
<p>Note that neither approach is necessarily safe for multibyte encodings. For example, little-endian UTF-16 represents the newline character with the bytes <code>b'\x0A\x00'</code>. A non-unicode aware tool looking for newlines will split that incorrectly, leaving the null bytes on the following line. In such a case you'd have to use something that doesn't try to split the input by newlines, such as <code>ZipFile.read</code>, and then decode the whole byte string at once. This is not a concern for utf-8.</p>
</div>
<div class="post-text" itemprop="text">
<p>To convert a byte stream into Unicode stream, you could use <a href="http://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="noreferrer"><code>io.TextIOWrapper()</code></a>:</p>
<pre><code>encoding = 'utf-8'
with zipfile.ZipFile("5.csv.zip") as zfile:
    for name in zfile.namelist():
        with zfile.open(name) as readfile:
            for line in io.TextIOWrapper(readfile, encoding):
                print(repr(line))
</code></pre>
<p>Note: <code>TextIOWrapper()</code> uses universal newline mode by default. <code>rU</code> mode in <code>zfile.open()</code> is deprecated since version 3.4.</p>
<p>It avoids issues with multibyte encodings described in <a href="https://stackoverflow.com/a/20602013/4279">@Peter DeGlopper's answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason why you're seeing that error is because you are trying to mix bytes with unicode. The argument to <code>split</code> must also be byte-string:</p>
<pre><code>&gt;&gt;&gt; line = b'$0.0\t1822\t1\t1\t1\n'
&gt;&gt;&gt; line.split(b'\t')
[b'$0.0', b'1822', b'1', b'1', b'1\n']
</code></pre>
<p>To get a unicode string, use <a href="http://docs.python.org/3/library/stdtypes.html#bytes.decode" rel="nofollow">decode</a>:</p>
<pre><code>&gt;&gt;&gt; line.decode('utf-8')
'$0.0\t1822\t1\t1\t1\n'
</code></pre>
</div>
<span class="comment-copy">It looks to me like the zip library doesn't support encoding parameters for <code>open</code>. If that's correct I think you'll have to use the <code>codecs.EncodedFile</code> wrapper or manually decode each line.</span>
<span class="comment-copy">how can I do that?</span>
<span class="comment-copy">Do you know the correct encoding for the file? It looks like utf-8 to me but it's a bad idea to guess if you can avoid it.</span>
<span class="comment-copy">I know it's utf-8</span>
<span class="comment-copy">I've checked and indeed <code>.readline().decode('utf-16')</code> fails with an exception. Worse, <code>codecs.iterdecode()</code> produces wrong output silently (newlines are shifted to the next line). <a href="http://stackoverflow.com/a/20603185/4279"><code>io.TextIOWrapper()</code></a> avoids such problems.</span>
<span class="comment-copy">I was told that Python 3 solved Unicode errors once and for all. What am I missing?</span>
<span class="comment-copy">@oneloop - well, I don't know what you're missing, you haven't given any context. Python 3 makes it harder to accidentally mix encoded bytes and Unicode objects, which is a common cause of confusing errors in Python 2 because it apparently works until you hit data that actually causes implicit decoding/encoding with the default character encoding. But it's not magic, you still need to decode to turn binary data into characters or encode to do the reverse.</span>
<span class="comment-copy">Yeah, if that works over filelike objects that's probably the safest answer in cases where you can't provide an encoding when opening the file (or use the <code>codecs.open</code> method.) I had seen the recommendation to use it in place of <code>rU</code> mode, but since 3.4 isn't out yet the deprecation warning didn't seem applicable. Proper handling of multibyte newlines is a compelling reason even without that, though - I wonder how much that had to do with the decision to deprecate?</span>
<span class="comment-copy">It does work. It is <i>the way</i> to do it in Python 3. (sys.stdin, sys.stdout, (text) pipes in <code>subprocess</code> module are created using <code>TextIOWrapper</code>). <code>codecs.open</code> expect a filename (I don't see how it helps with the zipfile). <code>codecs.getreader(encoding)(file_obj)</code> might be useful on Python 2.</span>
<span class="comment-copy">Yeah, I was thinking in the general case - I don't see a better option for zipfiles. Perhaps my comment would be better worded "given that that works over filelike objects..."</span>
