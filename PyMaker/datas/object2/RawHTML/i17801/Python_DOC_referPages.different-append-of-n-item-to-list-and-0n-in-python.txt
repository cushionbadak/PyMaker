<div class="post-text" itemprop="text">
<p>I have two Code that is same<br/>
<code>Code1</code></p>
<pre><code>&gt;&gt;&gt; a=[0]*60000000
</code></pre>
<p><code>Code2</code> </p>
<pre><code>&gt;&gt;&gt; a=[]
&gt;&gt;&gt; for i in range(0,60000000):
        a.append(0)
</code></pre>
<p>in My pc Time needed for <code>Code1</code> is 1s But for <code>Code2</code> is 480s !!<br/>
Why ? Waht is Different?</p>
</div>
<div class="post-text" itemprop="text">
<p>(In what follows I'm assuming you're using Python 3; in Python 2 the story would be similar but we'd have to discuss the cost of memory allocation due to <code>range</code>.)</p>
<p>Your second program spends its time running <em>in Python bytecode</em>. Let's disassemble it using the <a href="http://docs.python.org/3/library/dis.html" rel="nofollow"><code>dis</code></a> module:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis('a=[]\nfor i in range(0,60000000):\n a.append(0)')
  1           0 BUILD_LIST               0 
              3 STORE_NAME               0 (a) 

  2           6 SETUP_LOOP              36 (to 45) 
              9 LOAD_NAME                1 (range) 
             12 LOAD_CONST               0 (0) 
             15 LOAD_CONST               1 (60000000) 
             18 CALL_FUNCTION            2 (2 positional, 0 keyword pair) 
             21 GET_ITER             
        &gt;&gt;   22 FOR_ITER                19 (to 44) 
             25 STORE_NAME               2 (i) 

  3          28 LOAD_NAME                0 (a) 
             31 LOAD_ATTR                3 (append) 
             34 LOAD_CONST               0 (0) 
             37 CALL_FUNCTION            1 (1 positional, 0 keyword pair) 
             40 POP_TOP              
             41 JUMP_ABSOLUTE           22 
        &gt;&gt;   44 POP_BLOCK            
        &gt;&gt;   45 LOAD_CONST               2 (None) 
             48 RETURN_VALUE         
</code></pre>
<p>The loop runs from bytes 22 to 41, and each time round the loop, Python has to decode and execute seven byte code instructions, and call a function too (the function being <code>a.append</code>). That's 420 million byte code instructions and 60 million function calls.</p>
<p>Whereas your first program spends its time running <em>in native code</em>:</p>
<pre><code>&gt;&gt;&gt; dis.dis('a = [0] * 60000000')
  1           0 LOAD_CONST               0 (0) 
              3 BUILD_LIST               1 
              6 LOAD_CONST               1 (60000000) 
              9 BINARY_MULTIPLY      
             10 STORE_NAME               0 (a) 
             13 LOAD_CONST               2 (None) 
             16 RETURN_VALUE         
</code></pre>
<p>You can see that not only is there no loop, there are no function calls. All the work happens "under the hood" inside the <code>BINARY_MULTIPLY</code> instruction, which dispatches to <a href="http://hg.python.org/cpython/file/ae9b74c2b357/Objects/listobject.c#l509" rel="nofollow"><code>list_multiply</code> in <code>listobject.c</code></a>, and since the list <code>[0]</code> contains just one element, the result is constructed in this tight loop at lines 529–536:</p>
<pre class="lang-c prettyprint-override"><code>if (Py_SIZE(a) == 1) {
    elem = a-&gt;ob_item[0];
    for (i = 0; i &lt; n; i++) {
        items[i] = elem;
        Py_INCREF(elem);
    }
    return (PyObject *) np;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>range</code> in Python 2.7 creates a list itself, and not an iterator. Therefore, you do double the work in <code>Code2</code>. That means, you first create a list of 6000000 items, and then iterate over it. <code>Code1</code> does not need that intermediate step.</p>
<blockquote>
<p>This [range] is a versatile function to create lists containing arithmetic
  progressions</p>
</blockquote>
<p>Soure: <a href="http://docs.python.org/2/library/functions.html#range" rel="nofollow">Range Python 2.x</a></p>
<p>Compare that to Python 3.x: </p>
<blockquote>
<p>Rather than being a function, range is actually an immutable sequence
  type, as documented in Ranges and Sequence Types — list, tuple, range.</p>
</blockquote>
<p>Source: <a href="http://docs.python.org/3/library/functions.html#func-range" rel="nofollow">Range Python 3.x</a></p>
<p>Try to use <code>xrange</code> instead of <code>range</code>, and test it again.</p>
</div>
<div class="post-text" itemprop="text">
<p>Ignoring the fact that you used <code>range</code> instead of <code>xrange</code>, there are two things that are going on:</p>
<p>1) The functions don't do the same thing, though they arrive at the same output.  Your <code>code1</code> means "60 million copies of <code>[0]</code> concatenated together".  That is not what <code>Code2</code> is doing, obviously- it has to call the <code>append</code> method of lists 60 million times.</p>
<p>2) Explicit loops in python are slow.  There is a loop in <code>Code1</code>, somewhere, but it occurs "at C speed" as opposed to, well, python speed.</p>
<pre><code>def f():
    a = [0]*6000000

def g():
    a = []
    for i in xrange(6000000):
        a.append(0)

%timeit f()
10 loops, best of 3: 31 ms per loop

%timeit g()
1 loops, best of 3: 358 ms per loop
</code></pre>
<p>In a tight loop like this, the majority of the overhead is in the <em>loop itself</em> rather than the operations contained therein.  So a popular method to optimize tight loops is to drop them into a comprehension:</p>
<pre><code>def h():
    [0 for _ in xrange(6000000)]

%timeit h()
10 loops, best of 3: 151 ms per loop
</code></pre>
<p>Note that again the two functions are not doing the same thing, which is why there is discrepancy between <code>f</code> and <code>h</code>.</p>
</div>
<span class="comment-copy">code1: is pure memy initialization; where as code2 bears 2 overhead list - courtesy <b>range()</b> and not to forget the <b>for</b> loop</span>
<span class="comment-copy">+1 for finding that C code :)</span>
<span class="comment-copy">OK Thank you. But Why Time for Code2 != 2*Code1?!</span>
<span class="comment-copy">Creating the list and using the <b>for</b> is much more expensive than the stuff you do in Code1, especially when you count in issues related to memory handling of your operating system.</span>
<span class="comment-copy">@downvoter let me know how I can improve my answer.</span>
