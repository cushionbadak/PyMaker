<div class="post-text" itemprop="text">
<p>I wrote a code that gets n functions and composites them together. If the function doesnt recieve any input it returns the "x" which we called the lambda functions with.(example- compose()(3) # will return 3)
this is my code, i simply cant seem to see the problem:</p>
<pre><code>def compose(*funcs):
    if len(funcs)==0:
        return lambda x: x
    else:
        for i in funcs[-1:0:-1]:

            return lambda x: funcs[0](funcs[i](x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's say you have three functions:</p>
<pre><code>def f1(x):
    return 'f1 %s' % x

def f2(x):
    return 'f2 %s' % x

def f3(x):
    return 'f3 %s' % x
</code></pre>
<p>Then we have a function compose:</p>
<pre><code>def compose(*funcs):
    def f(x):
        ret = x
        for func in funcs[::-1]:
            ret = func(ret)
        return ret
    return f
</code></pre>
<p>We can use it like this:</p>
<pre><code>F = compose(f1, f2, f3)
print F('x')
</code></pre>
<p>It will print out:</p>
<pre><code>f1 f2 f3 x
</code></pre>
<p>Hope this is what you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>The usual way to implement functional composition is this:</p>
<pre><code>def compose(*funcs):
    def _inner(x):
        functools.reduce(lambda acc, f: f(acc), funcs, x)
    return _inner
</code></pre>
<p>However, in order to fix your code, you might do this:</p>
<pre><code>def compose(*funcs):
    if not funcs:    # preferred to checking if len is 0
        return lambda x: x
    else:
        return lambda x: funcs[0](compose(*funcs[1:])(x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>i think you are talking about </p>
<pre><code>def fn1(x):
    return x+1
def fn2(x):
    return x**2
def fn3(x):
    return math.sin(x)**0.5

def apply(my_list_of_stuff):
    if len(my_list_of_stuff) == 1:
         return my_list_of_stuff[0]
    return my_list_of_stuff[0](apply(my_list_of_stuff[1:]))

apply([fn1,fn2,fn3,7]) # -&gt; fn1(fn2(fn3(7)))
</code></pre>
<p>assuming I understood what you are asking</p>
</div>
<div class="post-text" itemprop="text">
<p>Function composition can be elegantly achieved using <a href="http://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow">reduce</a>. You can use the <em>initializer</em> argument to achieve your no-input condition too:</p>
<pre><code>import functools

def compose(*funcs):
    return functools.reduce(lambda f, g: lambda x: f(g(x)), funcs, lambda x: x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think a better way to implement this is:</p>
<pre><code>def compose(*funcs):
    chain = lambda f, g: lambda *a, **kw: f(g(*a, **kw))
    return reduce(chain, funcs, lambda x: x)
</code></pre>
<p>Which will return a new function that is the composition of the list of functions passed to it. If you don't care about kwargs, you can do:</p>
<pre><code>def compose(*funcs):
    chain = lambda f, g: lambda *a: f(g(*a))
    return reduce(chain, funcs, lambda x: x)
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; def compose(*funcs):
...     chain = lambda f, g: lambda *a: f(g(*a))
...     return reduce(chain, funcs, lambda x: x)
...
&gt;&gt;&gt; remove_newlines = compose(lambda l: "".join(l), lambda s: s.split("\n"))
&gt;&gt;&gt; remove_newlines("hello\n world")
'hello world'
</code></pre>
<p>Note: In python3, reduce has been moved out of the stdlib into functools, so you will need to do <code>from functools import reduce</code></p>
</div>
<span class="comment-copy">what is i?  A number or a function?</span>
<span class="comment-copy">its an index that runs on all the function from the end to the start. cause what i want to do is f1(f2(f3(......fn(x)))</span>
<span class="comment-copy">Why do you always return from the for loop after the first iteration?</span>
<span class="comment-copy">And <code>funcs[-1:0:-1]</code> is better written <code>reversed(funcs[1:])</code> IMHO</span>
<span class="comment-copy">Pretty sure you don't want the <code>reversed</code> there</span>
<span class="comment-copy">@Eric Fixed, I thought that it didn't work without the reversal, but then realised that it does.</span>
<span class="comment-copy">@Eric Precisely</span>
<span class="comment-copy">You could equally write it <code>lambda x: compose(*funcs[:-1])(funcs[-1](x))</code></span>
<span class="comment-copy">Composition is <code>combined_f = compose([fn1,fn2,fn3])</code> <code>combined_f(7)</code></span>
