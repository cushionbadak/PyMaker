<div class="post-text" itemprop="text">
<p>I want to append a crc that I calculate to an existing binary file.</p>
<p>For example, the crc is 0x55667788.</p>
<p>I want to append 0x55, 0x66, 0x77 and 0x88 to the end of the file.</p>
<p>For example, if I open the file in HexEdit, the last four bytes of the file
will show 0x55667788.</p>
<p>Here is my code so far:</p>
<pre><code>fileopen = askopenfilename()
filename = open(fileopen, 'rb+')
filedata = filename.read()
filecrc32 = hex(binascii.crc32(filedata))
filename.seek(0,2)
filename.write(filecrc32)
filename.close()
</code></pre>
<p>I get the following error:</p>
<pre><code>File "C:\Users\cjackel\openfile.py", line 9, in &lt;module&gt;
filename.write(filecrc32)
TypeError: 'str' does not support the buffer interface
</code></pre>
<p>Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/3/library/functions.html#hex" rel="nofollow"><code>hex</code></a> function returns a <em>string</em>. In this case, you've got a string of 10 hex characters representing your 4-byte number, like this:</p>
<pre><code>'0x55667788'
</code></pre>
<p>In Python 2.x, you would be allowed to write this incorrect data to a binary file (it would show up as the 10 bytes <code>30 78 35 35 36 36 37 37 38 38</code> rather than the four bytes you want, <code>55 66 77 88</code>). Python 3.x is smarter, and only allows you to write <code>bytes</code> (or <code>bytearray</code> or similar) to a binary file, not <code>str</code>.</p>
<hr/>
<p>What you want here is not the hex string, but the actual bytes. </p>
<p>The way you described the bytes you want is called <a href="http://en.wikipedia.org/wiki/Endianness" rel="nofollow">big-endian order</a>. On most computers, the "native" order is the opposite, little-endian, which would give you <code>0x88776655</code> instead of <code>0x55667788</code>.</p>
<p>In Python 3.2+, the simplest way to get that is the <a href="http://docs.python.org/3.2/library/stdtypes.html#int.to_bytes" rel="nofollow"><code>int.to_bytes</code></a> method:</p>
<pre><code>filecrc = binascii.crc32(filedata).to_bytes(4, byteorder='big', signed=False)
</code></pre>
<p>(The <code>signed=False</code> isn't really necessary, because it's the default, but it's a good way of making it explicit that you're definitely dealing with an unsigned 32-bit integer.)</p>
<p>If you're stuck with earlier versions, you can use the <a href="http://docs.python.org/3/library/struct.html" rel="nofollow"><code>struct</code></a> module:</p>
<pre><code>filecrc = struct.pack('&gt;I', binascii.crc32(filedata))
</code></pre>
<p>The <code>&gt;</code> means big-endian, and the <code>I</code> means unsigned 4-byte integer. So, this returns the same thing. In either case, what you get is <code>b'\x55\x66\x77\x88'</code> (or, as Python would <code>repr</code> it, <code>b'\Ufw\x88'</code>).</p>
<hr/>
<p>The error is a bit cryptic, because no novice is going to have any idea what "the buffer interface" is (especially since the 3.x documentation calls it the <a href="http://docs.python.org/3/library/io.html" rel="nofollow">Buffer Protocol</a>, and it's only documented as part of CPython's C extension APIâ€¦), but effectively it means that you need a <a href="http://docs.python.org/3/glossary.html#term-bytes-like-object" rel="nofollow">bytes-like object</a>. Usually, this error will mean that you just forgot to encode your string to UTF-8 or some other encoding. But when you were trying to write actual binary data rather than encoded text, it's the same error.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to serialize the data. Serialization is the process of getting
the relevant bytes from the whole number. In your case, your CRC is a 
4-byte number. The individual 4 bytes can be retrieved to a list as below:</p>
<pre><code>serialized_crc = [(filecrc32 &gt;&gt; 24) &amp; 0xFF,(filecrc32 &gt;&gt; 16) &amp; 0xFF,
                 (filecrc32 &gt;&gt; 8) &amp; 0xFF,filecrc32 &amp; 0xFF]
</code></pre>
<p>The CRC can be then written to the file by converting to a bytearray as below:</p>
<pre><code>filename.write(bytearray(serialized_crc))
</code></pre>
</div>
<span class="comment-copy">You're opening the file in <i>binary</i> mode, but are trying to write a <i>text</i> string. You need to pick an encoding for the string first, or write some other binary data.</span>
<span class="comment-copy">you could use <code>binascii.crc32(filedata).to_bytes(4, byteorder='big')</code> in Python 3.2+</span>
<span class="comment-copy">@J.F.Sebastian: Well, I'd probably use an explicit <code>signed=False</code> as well, but otherwise, yeah, that's a lot simpler. And I forgot that 3.2 already and it. Thanks!</span>
<span class="comment-copy">I agree. Despite <code>binascii.crc32()</code> being documented to return unsigned integers and <code>signed=False</code> being default, the explicit <code>signed=False</code> makes it easier to read in 6 months then you forgot all about it.</span>
