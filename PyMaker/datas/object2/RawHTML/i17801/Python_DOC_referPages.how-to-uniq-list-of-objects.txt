<div class="post-text" itemprop="text">
<p>How to uniq list of objects in Python, saving order  ?</p>
<pre><code>def Test(object):
    def __init__(self,p1,p2):
        self.p1 = p1
        self.p2 = p2
lst = [Test(1,2), Test(2,3), Test(1,2)]
</code></pre>
<p>Two object uniq, if </p>
<pre><code>Test1.p1 == Test2.p1 and Test1.p1 == Test2.p2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Test(object):
    def __init__(self,p1,p2):
        self.p1 = p1
        self.p2 = p2

    def __eq__(self, other):
        return (other.p1 == self.p1) and (other.p2 == self.p2)

    def __hash__(self):
        return (self.p1 &lt;&lt; 64) | self.p2

lst = [Test(1,2), Test(2,3), Test(1,2)]
from collections import OrderedDict
uniq = list(OrderedDict.fromkeys(lst, 0))
print [[item.p1, item.p2] for item in uniq]
</code></pre>
<ol>
<li><p>If we use the objects in <a href="http://docs.python.org/2/glossary.html#term-hashable" rel="nofollow"><code>hashable</code></a> collections, we should define <a href="http://docs.python.org/2/reference/datamodel.html#object.__hash__" rel="nofollow"><code>__hash__</code></a> and <a href="http://docs.python.org/2/reference/datamodel.html#object.__eq__" rel="nofollow"><code>__eq__</code></a> functions.</p></li>
<li><p>I have used <code>(self.p1 &lt;&lt; 64) | self.p2</code> as hash, with the assumption that the numbers <code>p1</code> and <code>p2</code> will not exceed 2^64 (18446744073709551616).</p></li>
<li><p>This works but <strong>don't do this</strong>. The class which you have created is mutable, which means the state of the object can be changed (basically you ll be changing <code>p1</code> and <code>p2</code>). If the state of the object can change, the hash value will also change. As you see, we rely on <code>__hash__</code> to store the object in <code>OrderedDict</code>.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>I'm changing my answer to preserve order. You can define just equality (by adding an <code>__eq__</code> method) and append your items one by one into a new list, while checking if they are already present:</p>
<pre><code>class Test(object):
    def __init__(self,p1,p2):
        self.p1 = p1
        self.p2 = p2

    def __eq__(self, ot):
        return self.p1 == ot.p1 and self.p2 == ot.p2


lst = [Test(1,2), Test(2,3), Test(1,2)]
new_lst = []
for x in lst:
    if x not in new_lst:
        new_lst.append(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="http://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>collections.OrderedDict</code></a>:</p>
<pre><code>class Test(object):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2

lst = [Test(1,2), Test(2,3), Test(1,2)]


import collections
d = collections.OrderedDict()
for x in lst:
    key = x.p1, x.p2
    if key not in d:
        d[key] = x

for test_item in d.values():
    print(test_item.p1, test_item.p2)
</code></pre>
<p>prints</p>
<pre><code>1 2
2 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Alternatively, with a generator that keeps track of the keys it's already seen using a set:</p>
<pre><code>def unique_values(iterable):
    seen = set()
    for value in iterator:
        key = (value.p1, value.p2)
        if key not in seen:
            yield value
            seen.add(key)

lst = list(unique_values(lst))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do something that feels hacky, but should work for you:</p>
<pre><code>tmpset = set(lst)
uniqsorted = list(tmpset).sort()
</code></pre>
</div>
<span class="comment-copy">Define uniqueness? is it <code>p1</code> same in both or <code>p2</code>?</span>
<span class="comment-copy">@AamirAdnan based on the context I assume he wants an ordered list that only contains unique elements.</span>
<span class="comment-copy">cast both as sets  <code>p1 = set(p1)</code> then <code>p1 = p1.union(p2)</code> would give a set containing all unique. then sort it. <a href="http://docs.python.org/2/library/sets.html" rel="nofollow noreferrer">set</a></span>
<span class="comment-copy">I just thought about the same solution and wasn't sure how to build the hash value. Shifting the value of p1 might work, depending on the expected values.</span>
<span class="comment-copy">I'd use <code>hash((self.p1, self.p2))</code> as hash value. If Test were immutable...</span>
<span class="comment-copy">Wait, this does not save order</span>
<span class="comment-copy">Copied from <a href="http://stackoverflow.com/questions/4169252/remove-duplicates-in-list-of-object-with-python">dublicate question answer</a>.</span>
<span class="comment-copy">Now it does, and no, I didn't copy :)</span>
<span class="comment-copy">Would not work if the original order is not sorted.</span>
<span class="comment-copy">No it won't. But before he edited the question what exactly he was asking for was unclear.</span>
