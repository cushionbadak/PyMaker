<div class="post-text" itemprop="text">
<p>Python 3.2 introduced <a href="http://docs.python.org/3/library/concurrent.futures.html" rel="noreferrer">Concurrent Futures</a>, which appear to be some advanced combination of the older threading and <a href="http://docs.python.org/2/library/multiprocessing.html" rel="noreferrer">multiprocessing</a> modules.</p>
<p>What are the advantages and disadvantages of using this for CPU bound tasks over the older multiprocessing module?</p>
<p><a href="http://eli.thegreenplace.net/2013/01/16/python-paralellizing-cpu-bound-tasks-with-concurrent-futures/" rel="noreferrer">This article</a> suggests they're much easier to work with - is that the case?</p>
</div>
<div class="post-text" itemprop="text">
<p>I wouldn't call <code>concurrent.futures</code> more "advanced" - it's a <em>simpler</em> interface that works very much the same regardless of whether you use multiple threads or multiple processes as the underlying parallelization gimmick.</p>
<p>So, like virtually all instances of "simpler interface", much the same tradeoffs are involved:  it has a shallower learning curve, in large part just because there's so much less available <em>to</em> be learned; but, because it offers fewer options, it may eventually frustrate you in ways the richer interfaces won't.</p>
<p>So far as CPU-bound tasks go, that's waaaay too under-specified to say much meaningful.  For CPU-bound tasks under CPython, you need multiple processes rather than multiple threads to have any chance of getting a speedup.  But how much (if any) of a speedup you get depends on the details of your hardware, your OS, and especially on how much inter-process communication your specific tasks require.  Under the covers, all inter-process parallelization gimmicks rely on the same OS primitives - the high-level API you use to get at those isn't a primary factor in bottom-line speed.</p>
<p><strong>Edit: example</strong></p>
<p>Here's the final code shown in the article you referenced, but I'm adding an import statement needed to make it work:</p>
<pre><code>from concurrent.futures import ProcessPoolExecutor
def pool_factorizer_map(nums, nprocs):
    # Let the executor divide the work among processes by using 'map'.
    with ProcessPoolExecutor(max_workers=nprocs) as executor:
        return {num:factors for num, factors in
                                zip(nums,
                                    executor.map(factorize_naive, nums))}
</code></pre>
<p>Here's exactly the same thing using <code>multiprocessing</code> instead:</p>
<pre><code>import multiprocessing as mp
def mp_factorizer_map(nums, nprocs):
    with mp.Pool(nprocs) as pool:
        return {num:factors for num, factors in
                                zip(nums,
                                    pool.map(factorize_naive, nums))}
</code></pre>
<p>Note that the ability to use <code>multiprocessing.Pool</code> objects as context managers was added in Python 3.3.</p>
<p>Which one is easier to work with?  LOL ;-)  They're essentially identical.</p>
<p>One difference is that <code>Pool</code> supports so many different ways of doing things that you may not realize how easy it <em>can</em> be until you've climbed quite a way up the learning curve.</p>
<p>Again, all those different ways are both a strength and a weakness.  They're a strength because the flexibility may be required in some situations.  They're a weakness because of "preferably only one obvious way to do it".  A project sticking exclusively (if possible) to <code>concurrent.futures</code> will probably be easier to maintain over the long run, due to the lack of gratuitous novelty in how its minimalistic API can be used.</p>
</div>
<div class="post-text" itemprop="text">
<p>@TimPeters answer looks great to me but I just wanted to add an experience that I had which may be relevant.</p>
<p>I once wanted child processes to create child processes when communicating between clusters. I could not get multiprocessing to do this however concurrent.futures did it easily. I believe this is because multiprocessing does not have this functionality but I'm not 100% sure. At the very least it was much easier in concurrent.futures and at most is a feature available to concurrent.futures but not multiprocessing. If anyone can confirm or deny this then that would be great?</p>
</div>
<span class="comment-copy"><i>"you need multiple processes rather than multiple threads to have any chance of getting a speedup"</i> is too harsh. If speed is important; the code might already use a C library  and therefore it can release GIL e.g., regex, lxml, numpy.</span>
<span class="comment-copy">@J.F.Sebastian, thanks for adding that - perhaps I should have said "under <i>pure</i> CPython", but I'm afraid there's no short way to explain the truth here without discussing the GIL.</span>
<span class="comment-copy">And it worth mentioning that threads might be especially useful and enough when having operation with long IO.</span>
<span class="comment-copy">@TimPeters In some ways <code>ProcessPoolExecutor</code> actually has more options than <code>Pool</code> because <code>ProcessPoolExecutor.submit</code> returns <code>Future</code> instances that allow cancellation (<code>cancel</code>), checking <i>which</i> exception was raised (<code>exception</code>), and dynamically adding a callback to be called upon completion (<code>add_done_callback</code>).  None of these features are available with <code>AsyncResult</code> instances returned by <code>Pool.apply_async</code>. In other ways <code>Pool</code> has more options due to <code>initializer</code> / <code>initargs</code>, <code>maxtasksperchild</code>, and <code>context</code> in <code>Pool.__init__</code>, and more methods exposed by <code>Pool</code> instance.</span>
<span class="comment-copy">@max, sure, but note that the question wasn't about <code>Pool</code>, it was about the modules.  <code>Pool</code> is a small part of what's in <code>multiprocessing</code>, and is so far down in the docs it takes a while for people to realize it even exists in <code>multiprocessing</code>.  This particular answer focused on <code>Pool</code> because that's all the article the OP linked to used, and that <code>cf</code> is "much easier to work with" simply isn't true about what the article discussed.  Beyond that, <code>cf</code>'s <code>as_completed()</code> can also be very handy.</span>
