<div class="post-text" itemprop="text">
<p>I need to build up an array, but I receive my data out-of-order (and I don't know what the highest index of the array will be) so I need a way of doing <code>array[index]=item</code> when the index is frequently out of bounds.</p>
<p>I quickly threw together this function that does what I want, but I feel there might be an easier way.</p>
<pre><code>def oob_assign(array,index,item,default):
  "set array[index] to item. if index is out of bounds, array is extended as necessary using default"
  array.extend([default]*(index-len(array)+1))
  array[index]=(item)
</code></pre>
<p>So, for example:</p>
<pre><code>In [4]: a=[]

In [5]: oob_assign(a,5,"five",0)

In [6]: a
Out[6]: [0, 0, 0, 0, 0, 'five']

In [7]: a[5]
Out[7]: 'five'
</code></pre>
<p>Edit: While my end goal is a bit too much to ask in a stackoverflow question, the operations I need to do (relatively quickly) on the resulting data are:</p>
<ul>
<li>iterate over values in index order (non-default-only is fine)</li>
<li>look up values by index</li>
</ul>
<p>The data-set is small enough (~1000 elements) that the memory usage of an array are not an issue.</p>
<p>Edit: Thanks for all of the great answers! I &lt;3 Stackoverflow :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Can you store both the <code>(index, data_value)</code> in a list via <code>append</code>? Then you can sort the list by index value:</p>
<pre><code>data_items = []
for index, data_value in generate_out_of_order_data():
    data_items.append((index, data_value))
data_items.sort()
indices, data = zip(*data_items)
</code></pre>
<p>For example:</p>
<pre><code>In [1]: random_data = [(4, 'd'), (1, 'a'), (3, 'c'), (2, 'b')]
In [2]: data_items = []
In [3]: for index, data_value in random_data:
   ...:     data_items.append((index, data_value))
   ...: 
In [4]: data_items.sort()
In [5]: indices, data = zip(*data_items)
In [6]: indices
Out[6]: (1, 2, 3, 4)
In [7]: data
Out[7]: ('a', 'b', 'c', 'd')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a self-extending list for you:</p>
<pre><code>class OOBList(list):
    def __init__(self, default, *args, **kwargs):
        super(OOBList, self).__init__(*args, **kwargs)
        self.default = default

    def __setitem__(self, index, value):
        max_index = len(self) - 1
        if index &gt; max_index:
            self.extend([self.default] * (index - max_index))
        super(OOBList, self).__setitem__(index, value)
</code></pre>
<p>When assigning to an index beyond the end of the list, it extends the list to be long enough to hold it.</p>
<p>Since it subclasses <code>list</code>, there's no sorting required for display (but repeatedly extending the list a little at a time might be expensive).</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to keep this sparse (that is, if you set index 50 when the previous highest index was 25, you only want to create 1 new element instead of 25), the obvious answer here is a dict, plus a "largest index seen" int.</p>
<p>There is a tradeoff here. Obviously a real <code>list</code> will be faster for some operations, and use less storage when the list is actually dense rather than sparse, and will help us more with implementing things like complex slices, and so on.</p>
<p>But if you were thinking of using a <code>defaultdict</code>, this is the direction you're looking. A <a href="http://docs.python.org/3/library/collections.html#defaultdict-objects" rel="nofollow"><code>defaultdict</code></a> does a lot of the extra stuff you need, but it won't let you iterate over the values, or give the right <code>len</code>, and it will create and store new values whiner you ask for them instead of leaving them sparse. You could add those things… but really, if you can't use <code>defaultdict</code> directly, it's not helping much; we already <em>know</em> where we want to defaultify and where we don't, and it's already inside a wrapper, so…</p>
<p>To build a custom <code>list</code>-like object, you can just define a handful of methods and let <a href="http://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow"><code>collections.abc.MutableSequence</code></a> define the rest for you.</p>
<pre><code>class ExpandoList(collections.abc.MutableSequence):
    def __init__(self):
        self.d = {}
        self.maxidx = -1
    def __setitem__(self, idx, value):
        self.maxidx = max(idx, self.maxidx)
        self.d[idx] = value
    def __getitem__(self, idx):
        self.maxidx = max(idx, self.maxidx)
        return self.d.get(idx, 0)
    def __delitem__(self, idx):
        for i in range(i, self.maxidx):
            self.d[i] = self.d[i-1]
        self.maxidx -= 1
    def insert(self, idx, value):
        for i in reversed(range(i, self.maxidx)):
            self.d[i] = self.d[i-1]
        self.d[idx] = value
        self.maxidx += 1
    def __iter__(self):
        yield from (self[i] for i in range(self.maxidx))
    def __len__(self):
        return self.maxidx
</code></pre>
<p>Note that this doesn't do slicing. You <em>can</em> handle that manually, but it gets more complicated than I'd want to put into an answer. If you want to take this further, I've got a <code>lazylist</code> class I can upload somewhere that shows how to solve the same problems you'd need to solve.</p>
</div>
<span class="comment-copy">what you need is a dynmic array in python a dynamic array is a 'list'</span>
<span class="comment-copy">You should briefly consider <code>collections.defaultdict</code>. Two reasons it probably doesn't help: (1) you can't iterate over non-existent keys, just look them up with <code>[]</code>, (2) in your code callers to <code>oob_assign</code> can specify a different default value each call, but <code>defaultdict</code> has no such facility. But you never know, examples in questions aren't always representative.</span>
<span class="comment-copy">@stevejessop I think defaultdict might be the right answer for my situation, but unfortunately it's a comment not an answer ;)</span>
<span class="comment-copy">@pix, What do you want to do with your data?  Are you just storing it then writing it to a database? Going to convert to a <code>numpy.array</code> and plot it with <code>matplotlib</code>?  Depending on what you want to do after you have the data in a structure will dictate which structure you should choose.</span>
<span class="comment-copy">@pix: I'll claim a moral victory then, for brazenly ignoring the parts of the question that don't suit my answer ;-) Kirk's answer is a variant on the same theme as <code>defaultdict</code>, and abarnert's also answers point (1).</span>
<span class="comment-copy">This doesn't let you assign to slices. Which I think is OK, as long as you point that out.</span>
<span class="comment-copy">@abarnert Interesting point. I don't do that often and didn't think about it.</span>
<span class="comment-copy">I think this is a much more beautiful re-invention of the same wheel ;)</span>
<span class="comment-copy">"should we reduce self.maxidx here" -- opens a can of worms. <code>foo = ExpandoList(); foo[0]; foo[2]; del foo[2];</code>. <code>len(foo)</code> could plausibly be 3, 2 or 1, although I don't think making it 1 can be fast.</span>
<span class="comment-copy">@SteveJessop: On reflection, if this is supposed to work like a <code>list</code>, it <i>has to</i> slide everyone else up; otherwise it's a completely different data structure. And yes, that's O(N) rather than O(1), but the same is true for <code>list</code>, so that isn't a problem.</span>
<span class="comment-copy">@SteveJessop: Of course the OP doesn't necessarily really want a list, but just something that works like a list in certain ways and may work differently in other ways. So, there might be a reasonable design that's more of a list-dict hybrid (<code>blist</code> has something like that under the covers, as one of two layers you can put on top of its trees, but doesn't expose it…).</span>
<span class="comment-copy">still I think the interaction between "sparseness" and "deleting" isn't necessarily obvious. Maybe deleting the highest "real" value should also remove the "unreal" region immediately below it, maybe not. Since the questioner in a comment said that <code>defaultdict</code> would do the job for them, it might not matter which you do :-)</span>
<span class="comment-copy">@SteveJessop: I was assuming he wanted sparseness in the implementation but not in the interface (so it would <i>act</i> as if all those 0's existed even though they don't). But you're right, if you wanted it to be part of the interface as well, it's ambiguous what deleting the top value should do. Anyway I suspect that the comment just means that he hasn't thought through some of these issues, not that he's checked it against a mental spec and it fits.</span>
