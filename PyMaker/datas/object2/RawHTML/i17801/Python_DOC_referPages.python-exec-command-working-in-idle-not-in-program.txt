<div class="post-text" itemprop="text">
<p>I want to re-assign the value of a variable chosen by the user. The idea is that, if the user chooses this variable, the value of that variable is set to zero.</p>
<p>The code looks like this:</p>
<pre><code>v1 = 8.4
v2 = 12.1
v3 = 36.2

list = ['', 'v1=', 'v2=', 'v3=']

print("What v do you want to be zero?")
print("    1 = v1")
print("    2 = v2")
print("    3 = v3")
a = eval(input("Enter your choice: "))
</code></pre>
<p>(the user enters 1)</p>
<pre><code>b = list[a] + '0'
exec(b)
print(v1, v2, v3)
</code></pre>
<p>When I enter this code in IDLE, line by line, I get:</p>
<pre><code>0 12.1 36.2
</code></pre>
<p>But, when I run the identical code within a function (*so the exec() and print(v1,v2,v3) statements are inside the same function), I get:</p>
<pre><code>8.4 12.1 36.2
</code></pre>
<p>Can anyone explain this? I think it's probably a terrible way to do what I'm doing (I'm new to coding), and I welcome your suggestions on how to do it better, maybe a loop or a series of 'if/elif' statements? However, what I'd really like to know is why this code works when it's entered line-by-line, but not as a function.</p>
<p>(* = edit)</p>
<p>This is a program that does not re-assign any variable:</p>
<pre><code># delete me.py

def main():

    v1 = 8.4
    v2 = 12.1
    v3 = 36.2

    list = ['', 'v1=', 'v2=', 'v3=']

    print("What v do you want to be zero?")
    print("    1 = v1")
    print("    2 = v2")
    print("    3 = v3")
    a = eval(input("Enter your choice: "))

    b = list[a] + '0'
    exec(b)

    print(v1, v2, v3)

main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way to understand this is that you aren't allowed to modify variables through exec. It will sometimes work, but its not really allowed, and its never a good idea.</p>
<p>For this piece of code, you should write:</p>
<pre><code>v = [8.4, 12.1, 36.2]
print("What v do you want to be zero?")
print("    1 = v1")
print("    2 = v2")
print("    3 = v3")
a = int(input("Enter your choice: "))
v[a - 1] = 0
print(v)
</code></pre>
<p>Basically, if you need to lookup a variable by user input, it should be in a list or dictionary. You should never need to do this for local variables.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is because you are updating the local scope of the function inside which you <code>exec</code> is run.</p>
<p>Compare this:</p>
<pre><code>v = 42
def f(): v = 43 #which is inside you exec
f()
print(v)
</code></pre>
</div>
<span class="comment-copy">You <b>really</b> want to avoid <code>exec</code> and <code>eval</code>. Your program could be rewritten to use a <code>dict</code> (<code>values = {'v1': 8.4, 'v2': 12.1, 'v3': 36.2}</code>), <code>int()</code> to take user input, and <code>lst = list(values)</code>, then <code>values[lst[a - 1]] = 0</code> and <code>print(values['v1'], values['v2'], values['v3'])</code>.</span>
<span class="comment-copy">What about showing us the complete, non-working program? Then we can see how things really are...</span>
<span class="comment-copy">Yeah I'm learning that eval and exec should be used carefully and sparingly. I suppose the user could enter and run any code he or she wants via that input, even if it has nothing to do with the purpose of my program. I hadn't thought of using dict keys stored in a list to re-assign dict values. That's way better than what I had. Thanks.</span>
<span class="comment-copy">OK, I understand now. Yeah, I thought I might be admonished for using exec() and eval() like I did, but I still wanted to know what was happening. Thanks for your explanation and suggestion. I will use a dict and int() instead of exec and eval.</span>
<span class="comment-copy">Useful note from the <a href="http://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer">documentation</a>: "Note: The default locals act as described for function locals() below: modifications to the default locals dictionary should not be attempted. Pass an explicit locals dictionary if you need to see effects of the code on locals after function exec() returns."</span>
<span class="comment-copy">It used to be the case that <code>exec</code> would cause variable lookup within the same scope to use a different opcode (<code>LOAD_NAME</code> rather than <code>LOAD_FAST</code> or <code>LOAD_GLOBAL</code>), so you actually could change the locals and even create new local variables, but now that <code>exec</code> is a function, the compiler can't do that.</span>
<span class="comment-copy">user2357112, thanks for pointing me to that. I need to figure out what default, function and explicit locals are. I've been programming for &lt;6 months, so the documentation is still a tough read for me. I read the documentation about exec before posting this question and I figured something in there pertained to my problem, but I had no idea what a lot of it meant.</span>
<span class="comment-copy">My print statement is inside the function that contains the exec(). If, in your example, you put the print(v) into the f(), calling f() returns v = 43.</span>
<span class="comment-copy">@user3103237 f doesn't return anything.</span>
<span class="comment-copy">Sorry, I meant that if you put the print statement into f, the f() <i>prints</i> 43, and not 42. In the code for my function above (I added it after you answered my question), the print statement is inside the function that also contains exec.</span>
