<div class="post-text" itemprop="text">
<p>I'm doing some things in python (Using python 3.3.3), and I came across something that is confusing me since to my understanding class's get a new id each time they are called.</p>
<p>Lets say you have this in some .py file:</p>
<pre><code> class someClass: pass

 print(someClass())
 print(someClass())
</code></pre>
<p>The above returns the same id which is confusing me since I'm calling on it so it shouldn't be the same, right? Is this how python works when the same class is called twice in a row or not? It gives a different id when I wait a few seconds but if I do it at the same like the example above it doesn't seem to work that way, which is confusing me.</p>
<pre><code> &gt;&gt;&gt; print(someClass());print(someClass())
 &lt;__main__.someClass object at 0x0000000002D96F98&gt;
 &lt;__main__.someClass object at 0x0000000002D96F98&gt;
</code></pre>
<p>It returns the same thing, but why? I also notice it with ranges for example</p>
<pre><code>for i in range(10):
    print(someClass())
</code></pre>
<p>Is there any particular reason for python doing this when the class is called quickly? I didn't even know python did this, or is it possibly a bug? If it is not a bug can someone explain to me how to fix it or a method so it generates a different id each time the method/class is called? I'm pretty puzzled on how that is doing it because if I wait, it does change but not if I try to call the same class two or more times.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>id</code> of an object is only guaranteed to be unique <em>during that object's lifetime</em>, not over the entire lifetime of a program. The two <code>someClass</code> objects you create only exist for the duration of the call to <code>print</code> - after that, they are available for garbage collection (and, in CPython, deallocated immediately). Since their lifetimes don't overlap, it is valid for them to share an id. </p>
<p>It is also unsuprising in this case, because of a combination of two CPython implementation details: first, it does garbage collection by reference counting (with some extra magic to avoid problems with circular references), and second, the <code>id</code> of an object is related to the value of the underlying pointer for the variable (ie, its memory location). So, the first object, which was the most recent object allocated, is immediately freed - it isn't too surprising that the <em>next</em> object allocated will end up in the same spot (although this potentially also depends on details of how the interpreter was compiled). </p>
<p>If you are relying on several objects having distinct <code>id</code>s, you might keep them around - say, in a list, so that their lifetimes overlap. Otherwise, you might implement a class-specific id that has different guarantees - eg:</p>
<pre><code>class SomeClass:
    next_id = 0

    def __init__(self):
         self.id = SomeClass.nextid
         SomeClass.nextid += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you read the documentation for <a href="http://docs.python.org/3/library/functions.html#id" rel="noreferrer"><code>id</code></a>, it says:</p>
<blockquote>
<p>Return the “identity” of an object. <strong>This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same <code>id()</code> value.</strong></p>
</blockquote>
<p>And that's exactly what's happening: you have two objects with non-overlapping lifetimes, because the first one is already out of scope before the second one is ever created.</p>
<hr/>
<p>But don't trust that this will <em>always</em> happen, either. Especially if you need to deal with other Python implementations, or with more complicated classes. All that the language says is that these two objects <em>may</em> have the same <code>id()</code> value, not that they <em>will</em>. And the fact that they <em>do</em> depends on two implementation details:</p>
<ul>
<li><p>The garbage collector has to clean up the first object before your code even starts to allocate the second object—which is guaranteed to happen with CPython or any other ref-counting implementation (when there are no circular references), but pretty unlikely with a generational garbage collector as in Jython or IronPython.</p></li>
<li><p>The allocator under the covers have to have a very strong preference for reusing recently-freed objects of the same type. This is true in CPython, which has multiple layers of fancy allocators on top of basic C <code>malloc</code>, but most of the other implementations leave a lot more to the underlying virtual machine.</p></li>
</ul>
<hr/>
<p>One last thing: The fact that the <code>object.__repr__</code> happens to contain a substring that happens to be the same as the <code>id</code> as a hexadecimal number is just an implementation artifact of CPython that isn't guaranteed anywhere. According to <a href="http://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="noreferrer">the docs</a>:</p>
<blockquote>
<p>If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment). If this is not possible, a string of the form <code>&lt;...some useful description…&gt;</code> should be returned.</p>
</blockquote>
<p>The fact that CPython's <code>object</code> happens to put <code>hex(id(self))</code> (actually, I believe it's doing the equivalent of <code>sprintf</code>-ing its pointer through <code>%p</code>, but since CPython's <code>id</code> just returns the same pointer cast to a <code>long</code> that ends up being the same) isn't guaranteed anywhere. Even if it has been true since… before <code>object</code> even existed in the early 2.x days. You're safe to rely on it for this kind of simple "what's going on here" debugging at the interactive prompt, but don't try to use it beyond that.</p>
</div>
<div class="post-text" itemprop="text">
<p>I sense a deeper problem here. You should not be relying on <code>id</code> to track unique instances over the lifetime of your program. You should simply see it as a non-guaranteed memory location indicator for the duration of each object instance. If you immediately create and release instances then you may very well create consecutive instances in the same memory location.</p>
<p>Perhaps what you need to do is track a class static counter that assigns each new instance with a unique id, and increments the class static counter for the next instance.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's releasing the first instance since it wasn't retained, then since nothing has happened to the memory in the meantime, it instantiates a second time to the same location.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this, try calling the following:</p>
<pre><code>a = someClass()
for i in range(0,44):
    print(someClass())
print(a)
</code></pre>
<p>You'll see something different. Why? Cause the memory that was released by the first object in the "foo" loop was reused. On the other hand <code>a</code> is not reused since it's retained.</p>
</div>
<div class="post-text" itemprop="text">
<p>A example where the memory location (and id) is not released is:</p>
<pre><code>print([someClass() for i in range(10)])
</code></pre>
<p>Now the ids are all unique.</p>
</div>
<span class="comment-copy">Nice explanation, but one minor quibble. The way it's written implies that the memory is actually getting <code>free</code>d and then <code>malloc</code>d (or some equivalent), when really it's not even getting outside of Python's PyObject free-list, and <i>that's</i> why it happens so consistently (subject to your well-explained caveats), even across platforms or with debug mallocs and so on.</span>
<span class="comment-copy">Base <code>object</code> <code>tp_dealloc</code> calls the <a href="http://hg.python.org/cpython/file/c3896275c0f6/Objects/typeobject.c#l2370" rel="nofollow noreferrer">heap type's <code>tp_free</code></a>, which is <a href="http://hg.python.org/cpython/file/c3896275c0f6/Modules/gcmodule.c#l1621" rel="nofollow noreferrer"><code>PyObject_GC_Del</code></a>. That in turn uses the macro <code>PyObject_FREE</code>. The caveat, regarding how CPython is compiled, is that <a href="http://hg.python.org/cpython/file/c3896275c0f6/Include/objimpl.h#l133" rel="nofollow noreferrer">without pymalloc</a> the macro <code>PyObject_FREE</code> is defined as <code>PyMem_FREE</code>, which for a non-debug build is just <code>free</code>. So at that point address reuse depends on the platform <code>malloc</code>.</span>
<span class="comment-copy">Well said about mentioning Garbage Collection :).</span>
<span class="comment-copy">I don't think the OP is trying to use <code>id</code> here (or, actually, the equivalent number that appears in the <code>repr</code>) for any purpose other than debugging object lifetimes… which is the one thing it's good for.</span>
<span class="comment-copy">@abarnert if you see OP's comment in mhlester's answer, it seems to indicate that OP is actually looking for such an equivalent behaviour.</span>
<span class="comment-copy">Although from his followup comment on the same answer, it looks like he <i>isn't</i> really looking for that, he just got confused while debugging…</span>
<span class="comment-copy">Oh, I see, is there any way to tell python the memory changed so it instantiates differently? I'm not sure how I would change the memory that fast so it assigns a different id each time.</span>
<span class="comment-copy">I wouldn't use the id as your identifier. Either pass in and store a counter variable, or if you want to use id, add the instance to a list or other object in order to keep it from being reused.</span>
<span class="comment-copy">I don't know why you need to have different ids, but, whatever is your reason, it is probably wrong. Also you have to take into account that due to internal "caching" it could happen (with immutable types) for two different and apparently unrelated variables to share the same object (and id).</span>
<span class="comment-copy">@user3130555: Why is this a problem for you in the first place? If the first variable is still around, the <code>id</code>s are guaranteed not to conflict. And if it's <i>not</i> around, then there's nothing to conflict <i>with</i>.</span>
<span class="comment-copy">@Faust: Good point. For a trivial example, <code>int(1)</code> will probably just return the same object no matter how many times you call it, in almost any reasonable Python implementation…</span>
