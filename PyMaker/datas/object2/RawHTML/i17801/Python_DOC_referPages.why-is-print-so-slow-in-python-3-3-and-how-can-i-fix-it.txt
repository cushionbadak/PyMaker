<div class="post-text" itemprop="text">
<p>I just tried to run this script with Python 3.3.
Unfortunately it's about twice as slow than with Python 2.7.</p>
<pre><code>#!/usr/bin/env python

from sys import stdin

def main():
    for line in stdin:
        try:
            fields = line.split('"', 6)
            print(fields[5])
        except:
            pass

if __name__ == '__main__':
    main()
</code></pre>
<p>Here are the results:</p>
<pre><code>$ time zcat access.log.gz | python3 -m cProfile ./ua.py &gt; /dev/null

real    0m13.276s
user    0m18.977s
sys     0m0.484s

$ time zcat access.log.gz | python2 -m cProfile ./ua.py &gt; /dev/null

real    0m6.139s
user    0m11.693s
sys     0m0.408s
</code></pre>
<p>Profiling shows that the additional time is spend in print:</p>
<pre><code>$ zcat access.log.gz | python3 -m cProfile ./ua.py | tail -15
   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap&gt;:1594(_handle_fromlist)
   196806    0.234    0.000    0.545    0.000 codecs.py:298(decode)
        1    0.000    0.000   13.598   13.598 ua.py:3(&lt;module&gt;)
        1    4.838    4.838   13.598   13.598 ua.py:6(main)
        1    0.000    0.000   13.598   13.598 {built-in method exec}
        1    0.000    0.000    0.000    0.000 {built-in method hasattr}
  4300456    4.726    0.000    4.726    0.000 {built-in method print}
   196806    0.312    0.000    0.312    0.000 {built-in method utf_8_decode}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
  4300456    3.489    0.000    3.489    0.000 {method 'split' of 'str' objects}

$ zcat access.log.gz | python2 -m cProfile ./ua.py | tail -10
   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    6.573    6.573 ua.py:3(&lt;module&gt;)
        1    3.894    3.894    6.573    6.573 ua.py:6(main)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
  4300456    2.680    0.000    2.680    0.000 {method 'split' of 'str' objects}
</code></pre>
<p>How can I avoid this overhead? Has it something to do with UTF-8?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 decodes data read from <code>stdin</code> and encodes again to <code>stdout</code>; it is not so much the <code>print()</code> function that is slower here as the unicode-to-bytes conversion and vice-versa.</p>
<p>In your case you probably want to bypass this and deal with bytes only; you can access the underlying <code>BufferedIOBase</code> implementation through the <a href="http://docs.python.org/3/library/io.html#io.TextIOBase.buffer"><code>.buffer</code> attribute</a>:</p>
<pre><code>from sys import stdin, stdout

try:
    bytes_stdin, bytes_stdout = stdin.buffer, stdout.buffer
except AttributeError:
    bytes_stdin, bytes_stdout = stdin, stdout

def main():
    for line in bytes_stdin:
        try:
            fields = line.split(b'"', 6)
            bytes_stdout.write(fields[5] + b'\n')
        except IndexError:
            pass

if __name__ == '__main__':
    main()
</code></pre>
<p>You'll now <em>have</em> to use <code>stdout.write()</code> as <code>print()</code> insists on writing to the <code>stdout</code> <code>TextIOBase</code> implementation.</p>
<p>Note that the <code>.split()</code> now uses a <em>bytes</em> literal <code>b'"'</code> and we write a bytes-literal <code>b'\n'</code> as well (which normally would be taken care of by <code>print()</code>).</p>
<p>The above is compatible with Python 2.6 and up. Python 2.5 doesn't support the <code>b</code> prefix.</p>
</div>
<span class="comment-copy">Well, <code>print</code> isn't a statement anymore in python3 so some overhead is expected. This could probably be lessened by using <code>sys.stdout.write</code> instead - or even better, by first creating a list of your strings and then using <code>sys.stdout.writelines</code>, assuming memory is not an issue. In both cases, you would need to add the newlines created by <code>print</code> yourself.</span>
