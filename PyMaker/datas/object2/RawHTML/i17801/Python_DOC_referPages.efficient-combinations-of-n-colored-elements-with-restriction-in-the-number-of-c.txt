<div class="post-text" itemprop="text">
<p>Given a set of N elements colored with C colors, how can I find every possible combination of length L that contains no more than a maximum of M colors?</p>
<p>I tried this algorithm that uses itertools.combinations to generate all the possible combinations, and then filter out those that do not hold the maximum colors condiction.</p>
<pre><code>from itertools import combinations as cb

def allowed_combinations(elements, combination_size=4, max_colors=3):

    colors = set([c for k, c in elements.items()])
    combinations = cb(elements, combination_size)
    for combination in combinations:
        colors = set([elements[element] for element in combination])
        if len(colors) &gt; max_colors:
            continue
        yield combination


elements = dict()
elements['A'] = 'red'
elements['B'] = 'red'
elements['C'] = 'blue'
elements['D'] = 'blue'
elements['E'] = 'green'
elements['F'] = 'green'
elements['G'] = 'green'
elements['H'] = 'yellow'
elements['I'] = 'white'
elements['J'] = 'white'
elements['K'] = 'black'

combinations = allowed_combinations(elements)

for c in combinations:
    for element in c:
        print("%s-%s" % (element, elements[element]))
    print "\n"
</code></pre>
<p>the output is like:</p>
<pre><code>A-red
C-blue
B-red
E-green


A-red
C-blue
B-red
D-blue


A-red
C-blue
B-red
G-green


A-red
C-blue
B-red
F-green

...
</code></pre>
<p>The problem is that generating all possible combinations can be computationally very expensive. In my case, for instance, L is often 6 and  the number of elements N is around 50, so it gives us Bin(50,6) = 15890700 possible combinations. If maximum number of colors allowed in a comination is small, most of combinations are "useless" and so they are discarded in the filter step. My intuition is that I should put the filtering step inside/before the combinatory step, to avoid the explotion of combinations, but I don't see how.</p>
</div>
<div class="post-text" itemprop="text">
<p>Combinatorial problems are notorious for being easy to state but possibly difficult to solve.  For this one, I wouldn't use <code>itertools</code> at all, but instead write a custom generator.  For example,</p>
<pre><code>def combs(elt2color, combination_size=4, max_colors=3):

    def inner(needed, index):
        if needed == 0:
            yield result
            return
        if n - index &lt; needed:
            # not enough elements remain to reach
            # combination_size
            return
        # first all results that don't contain elts[index]
        for _ in inner(needed, index + 1):
            yield result
        # and then all results that do contain elts[index]
        needed -= 1
        elt = elts[index]
        color = elt2color[elt]
        color_added = color not in colors_seen
        colors_seen.add(color)
        if len(colors_seen) &lt;= max_colors:
            result[needed] = elt
            for _ in inner(needed, index + 1):
                yield result
        if color_added:
            colors_seen.remove(color)

    elts = tuple(elt2color)
    n = len(elts)
    colors_seen = set()
    result = [None] * combination_size
    for _ in inner(combination_size, 0):
        yield tuple(result)
</code></pre>
<p>Then:</p>
<pre><code>elt2color = dict([('A', 'red'), ('B', 'red'), ('C', 'blue'),
                  ('D', 'blue'), ('E', 'green'), ('F', 'green'),
                  ('G', 'green'), ('H', 'yellow'), ('I', 'white'),
                  ('J', 'white'), ('K', 'black')])
for c in combs(elt2color):
    for element in c:
        print("%s-%s" % (element, elements[element]))
    print "\n"
</code></pre>
<p>produces the same 188 combinations as your post-processing code, but internally abandons a partial combination as soon as it would span more than <code>max_colors</code> colors.  There's no way to change what <code>itertools</code> functions do internally, so when you <em>want</em> control over that, you need to roll your own.</p>
<p><strong>Using itertools</strong></p>
<p>Here's another approach, generating first all solutions with exactly 1 color, then exactly 2 colors, and so on.  <code>itertools</code> can be used directly for much of this, but at the lowest level still needs a custom generator.  I find this harder to understand than a fully custom generator, but it may be clearer to you:</p>
<pre><code>def combs2(elt2color, combination_size=4, max_colors=3):
    from collections import defaultdict
    from itertools import combinations
    color2elts = defaultdict(list)
    for elt, color in elt2color.items():
        color2elts[color].append(elt)

    def at_least_one_from_each(iterables, n):
        if n &lt; len(iterables):
            return # impossible
        if not n or not iterables:
            if not n and not iterables:
                yield ()
            return
        # Must have n - num_from_first &gt;= len(iterables) - 1,
        # so num_from_first &lt;= n - len(iterables) + 1
        for num_from_first in range(1, min(len(iterables[0]) + 1,
                                           n - len(iterables) + 2)):
            for from_first in combinations(iterables[0],
                                           num_from_first):
                for rest in at_least_one_from_each(iterables[1:],
                                             n - num_from_first):
                    yield from_first + rest

    for numcolors in range(1, max_colors + 1):
        for colors in combinations(color2elts, numcolors):
            # Now this gets tricky.  We need to pick
            # combination_size elements across all the colors, but
            # must pick at least one from each color.
            for elements in at_least_one_from_each(
                    [color2elts[color] for color in colors],
                    combination_size):
                yield elements
</code></pre>
<p>I haven't timed these, because I don't care ;-)  The fully custom generator's single <code>result</code> list is reused for building each output, which slashes the rate of dynamic memory turnover.  The second way creates a lot of memory churn by pasting together multiple levels of <code>from_first</code> and <code>rest</code> tuples - and that's mostly unavoidable because it uses <code>itertools</code> to generate the <code>from_first</code> tuples at each level.</p>
<p>Internally, <code>itertools</code> functions almost always work in a way more similar to the first code sample, and for the same reasons, reusing an internal buffer as much as possible.</p>
<p><strong>AND ONE MORE</strong></p>
<p>This is more to illustrate some subtleties.  I thought about what I'd do if I were to implement this functionality in C as an <code>itertools</code> function.  All the <code>itertools</code> functions were first prototyped in Python, but in a semi-low-level way, reduced to working with vectors of little integers (no "inner loop" usage of sets, dicts, sequence slicing, or pasting together partial result sequences - sticking as far as possible to <code>O(1)</code> worst-case time operations on dirt simple native C types after initialization).</p>
<p>At a higher level, an <code>itertools</code> function for this would accept any iterable as its primary argument, and almost certainly guarantee to return combinations from that in lexicographic index order.  So here's code that does all that.  In addition to the <code>iterable</code> argument, it also requires an <code>elt2ec</code> mapping, which maps each element from the iterable to its equivalence class (for you, those are strings naming colors, but any objects usable as dict keys <em>could</em> be used as equivalence classes):</p>
<pre><code>def combs3(iterable, elt2ec, k, maxec):
    # Generate all k-combinations from `iterable` spanning no
    # more than `maxec` equivalence classes.
    elts = tuple(iterable)
    n = len(elts)
    ec = [None] * n  # ec[i] is equiv class ordinal of elts[i]
    ec2j = {} # map equiv class to its ordinal
    for i, elt in enumerate(elts):
        thisec = elt2ec[elt]
        j = ec2j.get(thisec)
        if j is None:
            j = len(ec2j)
            ec2j[thisec] = j
        ec[i] = j
    countec = [0] * len(ec2j)
    del ec2j

    def inner(i, j, totalec):
        if i == k:
            yield result
            return
        for j in range(j, jbound[i]):
            thisec = ec[j]
            thiscount = countec[thisec]
            newtotalec = totalec + (thiscount == 0)
            if newtotalec &lt;= maxec:
                countec[thisec] = thiscount + 1
                result[i] = j
                yield from inner(i+1, j+1, newtotalec)
                countec[thisec] = thiscount

    jbound = list(range(n-k+1, n+1))
    result = [None] * k
    for _ in inner(0, 0, 0):
         yield (elts[i] for i in result)
</code></pre>
<p>(Note that this is Python 3 code.)  As advertised, nothing in <code>inner()</code> is fancier than indexing a vector with a little integer.  The only thing remaining to make it directly translatable to C is removing the recursive generation.  That's tedious, and since it wouldn't illustrate anything particularly interesting here I'm going to ignore that.</p>
<p>Anyway, the interesting thing is timing it.  As noted in a comment, timing results are strongly influenced by the test cases you use.  <code>combs3()</code> here is sometimes fastest, but not often!  It's almost always faster than my original <code>combs()</code>, but usually slower than my <code>combs2()</code> or @GarethRees's lovely <code>constrained_combinations()</code>.</p>
<p>So how can that be when <code>combs3()</code> has been optimized "almost all the way down to mindless ;-) C-level operations"?  Easy!  It's still written in Python.  <code>combs2()</code> and <code>constrained_combinations()</code> use the C-coded <code>itertools.combinations()</code> to do much of their work, and that makes a world of difference.  <code>combs3()</code> would run circles around them <em>if</em> it were coded in C.</p>
<p>Of course any of these can run unboundedly faster than the <code>allowed_combinations()</code> in the original post - but that one can be fastest too (for example, pick just about any inputs where <code>max_colors</code> is so large that no combinations are excluded - then <code>allowed_combinations()</code> wastes little effort, while all these others add extra substantial extra overheads to "optimize" pruning that never occurs).</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an implementation that's a bit simpler than the other answers posted so far. The basic approach is to:</p>
<ol>
<li>Pick a value ("colour" in your terminology) that has not been picked so far;</li>
<li>Loop over <code>i</code>, the number of keys ("elements") associated with that value that will be included in the output;</li>
<li>  Loop over <code>c</code>, the combinations of those keys of length <code>i</code>;</li>
<li>    Recurse to pick the next value.</li>
</ol>
<pre class="lang-py prettyprint-override"><code>from collections import defaultdict, deque
from itertools import combinations

def constrained_combinations(elements, r, s):
    """Generate distinct combinations of 'r' keys from the dictionary
    'elements' using at most 's' different values. The values must be
    hashable.

        &gt;&gt;&gt; from collections import OrderedDict
        &gt;&gt;&gt; elements = OrderedDict(enumerate('aabbc'))
        &gt;&gt;&gt; cc = constrained_combinations
        &gt;&gt;&gt; list(cc(elements, 2, 1))
        [(0, 1), (2, 3)]
        &gt;&gt;&gt; list(cc(elements, 3, 2))
        [(0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (1, 2, 3), (2, 3, 4)]
        &gt;&gt;&gt; list(cc(elements, 3, 3)) == list(combinations(range(5), 3))
        True
        &gt;&gt;&gt; sum(1 for _ in cc(OrderedDict(enumerate('aabbcccdeef')), 4, 3))
        188

    """
    # 'value_keys' is a map from value to a list of keys associated
    # with that value; 'values' is a list of values in reverse order of
    # first appearance.
    value_keys = defaultdict(list)
    values = deque()
    for k, v in elements.items():
        if v not in value_keys:
            values.appendleft(v)
        value_keys[v].append(k)

    def helper(current, r, s):
        if r == 0:
            yield current
            return
        if s == 0 or not values:
            return
        value = values.pop()
        keys = value_keys[value]
        for i in range(min(r, len(keys)), -1, -1):
            for c in combinations(keys, i):
                for result in helper(current + c, r - i, s - min(i, 1)):
                    yield result
        values.append(value)

    return helper((), r, s)
</code></pre>
<h3>Notes</h3>
<ol>
<li><p>In Python 3.3 or later, you could use the <code>yield from</code> statement to simplify the recursive call:</p>
<pre><code>yield from helper(current + c, r - i, s - min(i, 1))
</code></pre></li>
<li><p>If you're wondering why the <a href="http://docs.python.org/3/library/doctest.html" rel="nofollow noreferrer">doctests</a> use <a href="http://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a>, it's so that the combinations can be returned in a predictable order, which is necessary for the tests to work.</p></li>
<li><p>The code reverses the list <code>values</code>, and iterates downwards over <code>i</code> so that if the caller passes in an <code>OrderedDict</code>, the combinations are returned in a sensible order (with values that appear early in the input also appearing early in the output).</p></li>
<li><p>Given the slight awkwardness in getting predictable output from this function, it would, I think, be worth considering changing the interface so that instead of taking a dictionary mapping keys to values, it would take an iterable of (key, value) pairs.</p></li>
</ol>
<h3>Performance</h3>
<p>This is broadly similar in speed to <a href="https://stackoverflow.com/a/20551581/68063">Tim Peter's <code>combs2</code></a>:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; elements = dict(enumerate('abcde' * 10))
&gt;&gt;&gt; test = lambda f:timeit(lambda:sum(1 for _ in f(elements, 6, 3)), number=1)
&gt;&gt;&gt; test(combs2)
11.403807007009163
&gt;&gt;&gt; test(constrained_combinations)
11.38378801709041
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rough outline.</p>
<p>You have in total C different colors. For each <code>k, 1 &lt;= k &lt;= M</code>, choose <code>k</code> colors
in <code>Bin(C,k)</code> ways. (I'm using your notation here assuming Bin mean binomial coefficient).</p>
<p>For each of the above choices, collect all the elements with the chosen colors. Let's say it gives <code>P</code> distinct elements. Then choose <code>L</code> from these <code>P</code> elements in <code>Bin(P, L)</code> different ways.</p>
<p>All of the above subject to obvious checks, <code>M &lt;= C</code>, <code>L &lt;= P</code>, etc.</p>
<p>The advantage of this approach is that it will generate only valid combinations and every valid combination will be generated exactly once. (edit: and as pointed out in a comment, this is not true duplicate, combination can be generated).</p>
<p>PS. And here's an implementation of the above algorithm, with the fix for duplicated combinations:</p>
<pre><code>from itertools import combinations


elts  = { 'A' : 'red', 'B' : 'red', 'C' : 'blue', 'D' : 'blue',
          'E': 'green', 'F' : 'green', 'G' : 'green', 'H' : 'yellow',
          'I' : 'white', 'J' : 'white', 'K' : 'black' }

def combs (elts, size = 4, max_colors = 3):
    # Count different colors
    colors = {}
    for e in elts.values():
        colors [e] = 1
    ncolors = len(colors)

    # for each different number of colors between 1 and 'max_colors' 
    for k in range (1, max_colors + 1):
        # Choose 'k' different colors
        for selected_colors in combinations (colors, k):
            # Select ell the elements with these colors
            selected_elts = []
            for e, c in elts.items():
                if c in selected_colors:
                    selected_elts.append (e)
            # Choose 'size' of these elements
            for chosen_elts in combinations (selected_elts, size):
                # Check the chosen elements are of exactly 'k' different colors
                t = {}
                for e in chosen_elts:
                    t[elts[e]] = 1
                if len(t) == k:
                    yield chosen_elts


#for e in combs (elts):
#    print (e)

print (len (list (combs (elts))))
</code></pre>
<p>PS. I also timed Tim's <code>comb2</code>, my own <code>comb</code> and Gareth's <code>constrained_combinations</code> with the program <a href="https://drive.google.com/file/d/0B58VNpK9sKadZ1QwWExOWl9NQkE/edit?usp=sharing" rel="nofollow">here</a> with these results:</p>
<pre><code>combs2 =  5.214529
constr combs = 5.290079
combs = 4.952063
combs2 = 5165700
constr combs = 5165700
combs = 5165700
</code></pre>
</div>
<span class="comment-copy">Thanks @Tim! I timed it: combs = 791 ns; combs2 = 632 ns; On the other hand, the solution of @Gareth takes around 14 µs. So I will sacrify clarity for the sake of speed :)</span>
<span class="comment-copy">@AlbertoLumbreras: can you say where these timings come from? In my timing tests Tim Peters' <code>combs2</code> and my <code>constrained_combinations</code> take similar amounts of time. (See the "Performance" section of <a href="http://stackoverflow.com/a/20555616/68063">my answer</a>.)</span>
<span class="comment-copy">I used the magic %%timeit working on a ipython notebook and executed <code>constrained_combinations(nodes, 4, 3)</code> in that cell.  However, if I run your test (even still in notebook) then you are right, <code>combs</code> and <code>constrained_combinations</code> are quite similar.</span>
<span class="comment-copy">Timing is tricky, because different parts of the algorithms will tend to dominate depending on the inputs. For example, the bigger <code>combination_size</code>, the more expensive "pasting together" result tuples gets:  overall, that takes time essentially <i>quadratic</i> in <code>combination_size</code>.  For tiny 3, 4, 5, 6 that probably doesn't matter. <code>combs</code> doesn't suffer from that (it reuses a single <code>result</code> list of length <code>combination_size</code>) - but <code>combs</code> doesn't work as hard (as the others) at cutting off doomed partial tuples early.  So, use all 3, and pick the fastest for the current input - LOL ;-)</span>
<span class="comment-copy">Alas, it's harder than that.  For example, when k=2, in the OP's example <code>{'white', 'black'}</code> is one set of 2 colors.  That corresponds to the set of elements <code>{'I', 'J', 'K'}</code>.  If <code>L==2</code>, only 2 of the 3 2-combinations of that set actually spans two distinct colors.  The other combination - <code>('I', 'J')</code> - has both elements with color <code>'white'</code>.  So it duplicates one of the results delivered for <code>k=1</code>.</span>
<span class="comment-copy">@TimPeters, indeed. This can be corrected by accepting a combination iff it has exactly <code>k</code> different colors in it, which is unfortunate, my goal was to avoid "filtering".</span>
<span class="comment-copy">yup, and my first stab at code for this had the same problem ;-)  "Custom all the way down" seems like the best approach to this one.</span>
