<div class="post-text" itemprop="text">
<p>If I had the line in perl</p>
<pre><code>$cds_score{$score}{$id} = 1;
</code></pre>
<p>where cds score is a hash, would the best python equivalent be</p>
<pre><code>cds_score = {}
cds_score[score] = id
</code></pre>
<p>And in a more general sense, I am confused why I often see the =1 at the end of hashes in perl. In python, it seems more sense to make these list appending instead of a dict like in the case of <code>{NC} -&gt; {$id} =1</code> where in python I would write <code>NC.append(id)</code>. Is the idea just that in perl storing long lists as a hash is better than as an array, if you are trying to look up arbitrary members?</p>
</div>
<div class="post-text" itemprop="text">
<p>A dict/hash where all of the values are <code>1</code> (or some other truthy constant) is a standard way to simulate sets in a language that doesn't have them, like perl. (Of course this being perl, it's only one of many standard ways to do it.)</p>
<p>Python <em>does</em> have <a href="http://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="noreferrer">sets</a>, so you can just use them. For example:</p>
<pre><code>cds_score[score].add(id)
</code></pre>
<hr/>
<p>However, Python <em>doesn't</em> have automatic multilevel/recursive dicts, so if you want that, you need to do it explicitly with <a href="http://docs.python.org/3/library/collections.html#collections.defaultdict" rel="noreferrer"><code>defaultdict</code></a> or <a href="http://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="noreferrer"><code>dict.setdefault</code></a>:</p>
<pre><code>cds_score.setdefault(score, set()).add(id)
</code></pre>
<hr/>
<p>This structure—a dict of sets (or a hash of hashes whose values are always 1)—is sometimes known as a "multidict", because it's a value of representing a dictionary mapping a single key to 0 or more values, instead of to 0 or 1 value. Both languages have third-party modules that implement multidicts more directly, but neither language really needs them, because it's so simple to do on your own.</p>
<hr/>
<p>What you're doing here:</p>
<pre><code>cds_score[score] = id
</code></pre>
<p>… is not an equivalent to the perl code; you're storing just the last <code>id</code> for each <code>score</code>, instead of storing all of them.</p>
<hr/>
<p>Finally:</p>
<blockquote>
<p>In python, it seems more sense to make these list appending instead of a dict </p>
</blockquote>
<p>No. A list <em>is</em> a way to simulate a set, but it has some significant tradeoffs. In particular, lists allow duplicate entries, and take O(N) instead of O(1) time to search. Those tradeoffs are nearly identical in perl and in python, so if it's not appropriate in perl, it's not appropriate in python either.</p>
<p>If you're just keeping a few values and will never have duplicates, go ahead and use a list, in either language. If you're potentially going to have large sets, or may have the same values showing up many times, you need a real set, in either language (which, in perl, you have to fake with a hash).</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is the idea just that in perl storing long lists as a hash is better than as an array, if you are trying to look up arbitrary members?</p>
</blockquote>
<p>Yes, that's exactly it. Searching an array by value is O(N). Searching an hash by key is O(1).</p>
<p>The code for searching is also much more concise when using a HoH instead of an HoA. Where as you can use the following with an HoH:</p>
<pre><code>if ($h{$k1}{$k2})
</code></pre>
<p>An HoA would require the following:</p>
<pre><code>if (grep $_ eq $key2, @{ $h{$k1} })
</code></pre>
<hr/>
<blockquote>
<p>Why equal 1 always?</p>
</blockquote>
<p>Personally, I use</p>
<pre><code>++$h{$k1}{$k2};
</code></pre>
<p>But many people actually use the following to conserve memory: (16 bytes per entry on a 32-bit build)</p>
<pre><code>undef $h{$k1}{$k2};
</code></pre>
<p>The check becomes</p>
<pre><code>if (exists($h{$k1}{$k2}))
</code></pre>
</div>
<span class="comment-copy">Thanks. So in the case of <code>$self -&gt; {A} -&gt; {$x} -&gt; {$y}=1</code> I would want to do <code>self.A = collections.defaultdict(set); self.A[x] = y</code>?</span>
<span class="comment-copy">@IanFiddes: I don't know what you're trying to do there, but I sincerely doubt the Python code you wrote is anything like what you want. Again, <code>A[x] = y</code> is just replacing whatever used to be in <code>A[x]</code> (whether a previous value, or the default empty set) with <code>y</code>. The same mistake as in your original question, which I already explained in the answer. If you want to add <code>y</code> to the set in <code>A[x]</code>, then you want <code>A[x].add(y)</code>, and the <code>defaultdict</code> is useful because it means you automatically start with an empty set.</span>
<span class="comment-copy">@IanFiddes: Also, choosing between <code>defaultdict</code> and <code>setdefault</code> is all about how you're planning to <i>use</i> the dictionary after constructing it, not about how to construct it. The construction part is almost exactly the same amount of reading, typing, and thinking either way. See <a href="http://stupidpythonideas.blogspot.com/2013/08/defaultdict-vs-setdefault.html" rel="nofollow noreferrer">here</a> for details.</span>
