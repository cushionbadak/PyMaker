<div class="post-text" itemprop="text">
<p>just doing a reveiw of my python class and noticed that I forgot how to do this. I know it's super simple and I'm overlooking something but I'd appreciate some help!</p>
<pre><code>def outsideIn2(lst):

'''(list)-&gt;list

Returns a new list where the middle two elements have been
removed and placed at the beginning of the result. Assume all lists are an even
length

&gt;&gt;&gt; outsideIn2(['C','a','r','t','o','n']) 
['r','t','C','a','o','n'] # rt moves to front
&gt;&gt;&gt; outsideIn2(['H','i']) 
['H','i'] # Hi moves to front so output remains the same.
&gt;&gt;&gt; outsideIn2(['B','a','r','b','a','r','a',' ','A','n','n','e']) 
['r','a','B','a','r','b,','a',' ','A','n','n','e'] # ra moves to front.
'''
length = len(lst)
middle1 = lst.pop((len(lst) / 2) - 1)
middle2 = lst.pop((len(lst) / 2) + 1)

lst.insert([0], middle1)
lst.insert([1], middle2)                  

return lst
</code></pre>
<p>I'm getting this error:</p>
<blockquote>
<p>middle1 = lst.pop((len(lst) / 2) - 1)</p>
<p>TypeError: integer argument expected, got float</p>
</blockquote>
<p>What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you upgraded to Python 3, the '<code>/</code>' operator changed from giving you integer division to real division.  Switch to '<code>//</code>' operator.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>//</code> operator:</p>
<pre><code>middle1 = lst.pop((len(lst) // 2) - 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The other answers explained why you are getting the error.  You need to use <code>//</code> instead of <code>/</code> (also, just for the record, you need to give <code>list.insert</code> integers, not lists).</p>
<hr/>
<p>However, I'd like to suggest a different approach that uses <a href="https://stackoverflow.com/questions/509211/pythons-slice-notation">Explain Python's slice notation</a>:</p>
<pre><code>def outsideIn2(lst):
    x = len(lst)//2
    return lst[x-1:x+1]+lst[:x-1]+lst[x+1:]
</code></pre>
<p>This method should be significantly faster than using<code>list.pop</code> and <code>list.insert</code>.</p>
<p>As proof, I made the below script to compare the two methods with <a href="http://docs.python.org/3/library/timeit.html#timeit.timeit" rel="nofollow noreferrer"><code>timeit.timeit</code></a>:</p>
<pre><code>from timeit import timeit

def outsideIn2(lst):

    length = len(lst)
    middle1 = lst.pop((len(lst) // 2) - 1)
    middle2 = lst.pop((len(lst) // 2) + 1)

    lst.insert(0, middle1)
    lst.insert(1, middle2)

    return lst

print(timeit("outsideIn2(['B','a','r','b','a','r','a',' ','A','n','n','e'])", "from __main__ import outsideIn2"))

def outsideIn2(lst):
     x = len(lst)//2
     return lst[x-1:x+1]+lst[:x-1]+lst[x+1:]

print(timeit("outsideIn2(['B','a','r','b','a','r','a',' ','A','n','n','e'])", "from __main__ import outsideIn2"))
</code></pre>
<p>The results were as follows:</p>
<pre><code>6.255111473664949
4.465956427423038
</code></pre>
<p>As you can see, my proposed method was ~2 seconds faster.  However, you can run more tests if you would like to validate mine.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>pop</code> and <code>insert</code> (especially inserting at positions 0 and 1) can be fairly slow with Python lists.  Since the underlying storage for the list is an array, inserting at position 0 means that the element at position <code>n-1</code> has to be moved to position <code>n</code>, then the element at <code>n-2</code> has to be moved to <code>n-1</code> and so on. <code>pop</code> has to do the same in reverse. So imagine in your little method how many element moves must be done. Roughly:</p>
<pre><code>pop #1 - move n/2 elements
pop #2 - move n/2 elements
insert 0 - move n elements
insert 1 - move n elements
</code></pre>
<p>So approximately <code>3n</code> moves are done in this code.</p>
<p>Breaking the list into 3 slices and reassembling a new list may be more optimal:</p>
<pre><code>def outsideIn2(lst):
    midstart = len(lst)//2-1
    left,mid,right = lst[0:midstart], lst[midstart:midstart+2], lst[midstart+2:]
    return mid+left+right
</code></pre>
<p>Plus you won't run into any weird issues by <code>pop</code> changing the length of the list between the first and second call to <code>pop</code>. And the slices implicitly guard against index errors when you get a list that is shorter than 2 characters.</p>
</div>
<span class="comment-copy">Is this python 3.x?</span>
<span class="comment-copy">As a side note, after you pop <code>len(lst)/2-1</code>, everything else shifts up one slot. It makes your math a lot easier if you pop the higher one first. Or, alternatively, if you pop and reinsert one before popping and reinserting the other (because popping <code>len(lst)/2-1</code> and inserting <code>0</code> leaves the other one in its original place).</span>
<span class="comment-copy">One very minor quibble: Python explicitly calls its type <code>float</code> rather than <code>real</code> to hammer home the fact that it's not <i>really</i> a real number, but a floating-point base-2 rational, and it calls <code>/</code> "true division" rather than "real" or "float" division.</span>
<span class="comment-copy">You took the words right out of my brain! I thought this would be faster, but timeit proves it, nice!</span>
<span class="comment-copy">@PaulMcGuire - Thank you.  Unfortunately for you however, my method is faster than yours for some reason.  ^_^  You can see for yourself by copying the test script I made and replacing the OP's function with yours.  I bet you you could fix this though by putting the last two lines of yours into one so that you don't make a tuple.</span>
<span class="comment-copy">@PaulMcGuire - Yup, that worked.  Putting those two lines into one makes our solutions neck and neck for speed.</span>
