<div class="post-text" itemprop="text">
<p>I have several file names that I am trying to compare. Here are some examples:</p>
<pre><code>files = ['FilePrefix10.jpg', 'FilePrefix11.jpg', 'FilePrefix21.jpg', 'FilePrefixOoufhgonstdobgfohj#lwghkoph[]**^.jpg']
</code></pre>
<p>What I need to do is extract "FilePrefix" from each file name, which changes depending on the directory. I have several folders containing many jpg's. Within each folder, each jpg has a FilePrefix in common with every other jpg in that directory. I need the variable portion of the jpg file name. I am unable to predict what FilePrefix is going to be ahead of time.</p>
<p>I had the idea to just compare two file names using difflib (in Python) and extract FilePrefix (and subsequently the variable portion) that way. I've run into the following issue:</p>
<pre><code>&gt;&gt;&gt;&gt; comp1 = SequenceMatcher(None, files[0], files[1])
&gt;&gt;&gt;&gt; comp1.get_matching_blocks()
[Match(a=0, b=0, size=11), Match(a=12, b=12, size=4), Match(a=16, b=16, size=0)]

&gt;&gt;&gt;&gt; comp1 = SequenceMatcher(None, files[1], files[2])
&gt;&gt;&gt;&gt; comp1.get_matching_blocks()
[Match(a=0, b=0, size=10), Match(a=11, b=11, size=5), Match(a=16, b=16, size=0)]
</code></pre>
<p>As you can see, the first <code>size</code> does not match up. It's confusing the ten's and digit's place, making it hard for me to match a difference between more than two files. Is there a correct way to find a minimum <code>size</code> among all files within the directory? Or alternatively, is there a better way to extract FilePrefix?</p>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not that it's "confusing the ten's and digit's place", it's that in the first matchup the ten's place isn't different, so it's considered part of the matching prefix.</p>
<p>For your use case, there seems to be a pretty easy solution to this ambiguity: just match all adjacent pairs, and take the minimum. Like this:</p>
<pre><code>def prefix(x, y):
    comp = SequenceMatcher(None, x, y)
    matches = comp.get_matching_blocks()
    prefix_match = matches[0]
    prefix_size = prefix_match[2]
    return prefix_size

pairs = zip(files, files[1:])
matches = (prefix(x, y) for x, y in pairs)
prefixlen = min(matches)
prefix = files[0][:prefixlen]
</code></pre>
<p>The <code>prefix</code> function is pretty straightforward, except for one thing: I made it take a single tuple of two values instead of two arguments, just to make it easier to call with <code>map</code>. And I used the <code>[2]</code> instead of <code>.size</code> because there's an annoying bug in 2.7 <code>difflib</code> where the second call to <code>get_matching_blocks</code> may return a <code>tuple</code> instead of a <code>namedtuple</code>. This won't affect the code as-is, but if you add some debugging <code>print</code>s it will break.</p>
<p>Now, <code>pairs</code> is a list of all adjacent pairs of names, created by <a href="http://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code>ping</a> together <code>names</code> and <code>names[1:]</code>. (If this isn't clear, <code>print(zip(names, names[1:])</code>. If you're using Python 3.x, you'll need to <code>print(list(zip(names, names[1:]))</code> instead, because <code>zip</code> returns a lazy iterator instead of a printable list.)</p>
<p>Now we just want to call <code>prefix</code> on each of the pairs, and take the smallest value we get back. That's what <a href="http://docs.python.org/3/library/functions.html#min" rel="nofollow"><code>min</code></a> is for. (I'm passing it a <a href="http://docs.python.org/3/tutorial/classes.html#generator-expressions" rel="nofollow">generator expression</a>, which can be a tricky concept at first—but if you just think of it as a <a href="http://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a> that doesn't build the list, it's pretty simple.)</p>
<p>You could obviously compact this into two or three lines while still leaving it readable:</p>
<pre><code>prefixlen = min(SequenceMatcher(None, x, y).get_matching_blocks()[0][2] 
                for x, y in zip(files, files[1:]))
prefix = files[0][:prefixlen]
</code></pre>
<hr/>
<p>However, it's worth considering that <code>SequenceMatcher</code> is probably overkill here. It's looking for the longest matches <em>anywhere</em>, not just the longest prefix matches, which means it's essentially O(N^3) on the length of the strings, when it only needs to be O(NM) where M is the length of the result. Plus, it's not inconceivable that there could be, say, a suffix that's longer than the longest prefix, so it would return the wrong result.</p>
<p>So, why not just do it manually?</p>
<pre><code>def prefixes(name):
    while name:
        yield name
        name = name[:-1]

def maxprefix(names):
    first, names = names[0], names[1:]
    for prefix in prefixes(first):
        if all(name.startswith(prefix) for name in names):
            return prefix
</code></pre>
<p><code>prefixes(first)</code> just gives you <code>'FilePrefix10.jpg'</code>, <code>'FilePrefix10.jp',</code>'FilePrefix10.j<code>, etc. down to</code>'F'`. So we just loop over those, checking whether each one is also a prefix of all of the other names, and return the first one that is.</p>
<hr/>
<p>And you can do this even faster by thinking character by character instead of prefix by prefix:</p>
<pre><code>def maxprefix(names):
    for i, letters in enumerate(zip(*names)):
        if len(set(letters)) &gt; 1:
            return names[0][:i]
</code></pre>
<p>Here, we're just checking whether the first character is the same in all names, then whether the second character is the same in all names, and so on. Once we find one where that fails, the prefix is all characters up to that (from any of the names).</p>
<p>The <code>zip</code> reorganizes the list of names into a list of tuples, where the first one is the first character of each name, the second is the second character of each name, and so on. That is, <code>[('F', 'F', 'F', 'F'), ('i', 'i', 'i', 'i'), …]</code>. </p>
<p>The <code>enumerate</code> just gives us the index along with the value. So, instead of getting <code>('F', 'F', 'F', 'F')</code> you get <code>0, ('F, 'F', F', 'F')</code>. We need that index for the last step.</p>
<p>Now, to check that <code>('F', 'F', 'F', 'F')</code> are all the same, I just put them in a <code>set</code>. If they're all the same, the set will have just one element—<code>{'F'}</code>, then <code>{'i'}</code>, etc. If they're not, it'll have multiple elements—<code>{'1', '2'}</code>—and that's how we know we've gone past the prefix.</p>
</div>
<div class="post-text" itemprop="text">
<p>The only way to be certain is to check ALL the filenames.  So just iterate through them all, checking against the kept maximum matching string as you go.</p>
<p>You might try something like this:</p>
<pre><code>files = ['FilePrefix10.jpg',
         'FilePrefix11.jpg',
         'FilePrefix21.jpg',
         'FilePrefixOoufhgonstdobgfohj#lwghkoph[]**^.jpg',
         'FileProtector354.jpg
         ]
prefix=files[0]
max = 0
for f in files:
    for c in range(0, len(prefix)):
        if prefix[:c] != f[:c]:
            prefix = f[:c-1]
            max = c - 1
print prefix, max
</code></pre>
<p>Please pardon the 'un-Pythonicness' of the solution, but I wanted the algorithm to be obvious to any level programmer.</p>
</div>
<span class="comment-copy">@mh00h: Which one are you trying to understand first? And do you know how <code>map</code>, comprehensions, generators, and <code>all</code> work?</span>
<span class="comment-copy">I'm digesting it all now. You've got me going to documentation a lot (I'd rather do that than first than post here); bear with me while I digest all of it!! Awesome answer. A lot to learn here.</span>
<span class="comment-copy">@mh00h: OK, cool. I'll try to add some explanations in to the answer—some future searcher coming along looking for the same problem might not be as diligent as you. If you find anything that isn't clear, let me know so we can improve it. (Also, if any of them don't actually work, let me know; I edited them a few times after initially writing and testing them…)</span>
<span class="comment-copy">It looks like <code>matches = map(prefix, pairs)</code> is throwing an error at the beginning, since prefix needs two variables. Not a completely plug and chug block of code, but it gets the point across.</span>
<span class="comment-copy">@mh00h: I think you may be mixing code from two different edits. When I used <code>map</code> I switched it to take <code>prefix(xy)</code> and then do <code>x, y = xy</code>. Then I decided that was clumsy, so I replaced the <code>map</code> call with a comprehension, so we can just do <code>prefix(x, y) for x, y in pairs</code>, which is more readable. Apologies for repeatedly editing while you're reading…</span>
<span class="comment-copy">@abarnert Your solution is at least 3 times faster than mine.  Thanks for the great and efficient example code.  Very elegant!</span>
