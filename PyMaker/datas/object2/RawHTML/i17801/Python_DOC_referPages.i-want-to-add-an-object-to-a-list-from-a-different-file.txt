<div class="post-text" itemprop="text">
<p>I have 3 files. The first is a Runners file which is abstract. The other two are CharityRunner and ProfessionalRunners. In these I can create runners. </p>
<p>Runners:</p>
<pre><code>class Runner(object):
def __init__ (self, runnerid, name):
    self._runnerid = runnerid
    self._name = name

@property
def runnerid(self):
    return self._runnerid

@property
def name(self):
    return self._name

@name.setter
def name(self, name):
    self._name = name

def get_fee(self, basicfee, moneyraised):
    raise NotImplementedError("AbstractMethod")        
</code></pre>
<p>CharityRunners:</p>
<pre><code>from Runner import *

class CharityRunner(Runner):
def __init__ (self, runnerid, name, charityname):
    super().__init__(runnerid, name)
    self._charityname = charityname

@property
def charityname(self):
    return self._charityname

@charityname.setter
def charityname(self, charityname):
    self._charityname = charityname

def get_fee(self, basicfee, moneyraised):
    if moneyraised &gt;= 100:
        basicfee = basicfee * 0.25
    elif moneyraised &gt;= 50 and moneyraised &lt; 100:
        basicfee = basicfee * 0.5
    else:
        basicfee = basicfee
    return basicfee
</code></pre>
<p>ProfessionalRunners:</p>
<pre><code>from Runner import *

class ProfessionalRunner(Runner):
def __init__ (self, runnerid, name, sponsor):
    super().__init__(runnerid, name)
    self._sponsor = sponsor

@property
def sponsor(self):
    return self._sponsor

@sponsor.setter
def sponsor(self, sponsor):
    self._sponsor = sponsor

def get_fee(self, basicfee):
    basicfee = basicfee * 2
    return basicfee
</code></pre>
<p>Now I have also created a club object that has a club id and club name. There is also a list called <code>self._runners = []</code>. I'm trying to get a add function that will add the runners created in the list. But it must make sure that the runner is not already in the list. </p>
<p>The object printing method should be in the format of:</p>
<p><code>Club: &lt;club id&gt; &lt;club name&gt;</code></p>
<p><code>Runner: &lt;runner id 1&gt; &lt;runner name 1&gt;</code></p>
<p><code>Runner: &lt;runner id 2&gt; &lt;runner name 2&gt;</code></p>
<p>At the moment I only have this for the club object:</p>
<pre><code>from Runner import *

class Club (object):
def __init__(self, clubid, name):
    self._clubid = clubid
    self._name = name
    self._runners = []

@property
def clubid(self):
    return self._clubid

@property
def name(self):
    return self._name

@name.setter
def name(self, name):
    self._name = name

def add_runner(self):
    self._runner.append(Runner)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm guessing the part you're missing is:</p>
<blockquote>
<p>im trying to get a add function that will add the runners created in the list.</p>
</blockquote>
<p>Your existing code does this:</p>
<pre><code>def add_runner(self):
    self._runner.append(Runner)
</code></pre>
<p>This has multiple problems.</p>
<p>First, you're trying to modify <code>self._runner</code>, which doesn't exist, instead of <code>self._runners</code>.</p>
<p>Next, you're appending the <code>Runner</code> <em>class</em>, when you almost certainly want an <em>instance</em> of it, not the class itself.</p>
<p>In fact, you almost certainly want an instance of one of its subclasses.</p>
<p>And I'm willing to bet you want a <em>specific</em> instance, that someone will pass to the <code>add_runner</code> function, not just some random instance.</p>
<p>So, what you want is probably:</p>
<pre><code>def add_runner(self, runner):
    self._runners.append(runner)
</code></pre>
<hr/>
<p>And now that you posted the UML diagram, it says that explicitly: <code>add_runner(Runner: runner)</code>. In Python, you write that as:</p>
<pre><code>def add_runner(self, runner):
</code></pre>
<p>Or, if you really want:</p>
<pre><code>def add_runner(self, runner: Runner):
</code></pre>
<p>… but that will probably mislead you into thinking that this is a Java-style definition that requires an instance of <code>Runner</code> or some subclass thereof and checks it statically, and that it can be overloaded with different parameter types, etc., none of which is true.</p>
<hr/>
<p>To use it, just do this:</p>
<pre><code>doe_club = Club(42, "Doe Family Club")
john_doe = CharityRunner(23, "John Doe", "Toys for John Doe")
doe_club.add_runner(john_doe)
</code></pre>
<hr/>
<p>Next:</p>
<blockquote>
<p>But it must make sure that the runner is not already in the list.</p>
</blockquote>
<p>You can translate that almost directly from English to Python:</p>
<pre><code>def add_runner(self, runner):
    if runner not in self._runners:
        self._runners.append(runner)
</code></pre>
<hr/>
<p>However, this does a linear search through the list for each new runner. If you used an appropriate data structure, like a <code>set</code>, this wouldn't be a problem. You <em>could</em> use the same code (but with <code>add</code> instead of <code>append</code>)… but you don't even need to do the checking with a <code>set</code>, because it already takes care of duplicates for you. So, if you set <code>self._runners = {}</code>, you just need:</p>
<pre><code>def add_runner(self, runner):
    self._runners.add(runner)
</code></pre>
</div>
<span class="comment-copy">You usually don't need abstract classes like this in Python; duck typing will usually get you errors that are just as good as what you would have gotten if you did everything perfectly, and better than what you get when you miss something. But if you <i>do</i> need abstract classes, use the <a href="http://docs.python.org/2/library/abc.html" rel="nofollow noreferrer"><code>abc</code></a> module instead of trying to do it yourself. Meanwhile, you also almost never want getters and setters in Python—all that code has the same effect as just letting people access <code>foo.name</code>, etc., directly, but slower, a lot more verbose, and easy to get wrong.</span>
<span class="comment-copy">Meanwhile, if you want to make sure the runners are unique, why not use a set instead of a list? (If you also need to preserve ordering, you can use an <code>OrderedSet</code>—there's a nice <a href="http://code.activestate.com/recipes/576694/" rel="nofollow noreferrer">recipe</a> linked from the <a href="http://docs.python.org/2/library/collections.html" rel="nofollow noreferrer"><code>collections</code></a> docs, or you can build one trivially on top of an <code>OrderedDict</code> with dont-care values).</span>
<span class="comment-copy">Most importantly, however, what is the question here? What part do you not know how to do? I can take some guesses, but how can I know whether they've solved your problem if I don't know what your problem is?</span>
<span class="comment-copy">unfortunately i need to do it this way. i can show you the UML diagram of it. <a href="http://imgur.com/Esxb238" rel="nofollow noreferrer">link</a> and then the task for this specific part is "The add_runner method must only add the runner to the club that runner object does not already exist in the list of runners"</span>
<span class="comment-copy"><a href="http://pastebin.com/2Hevp7Cf" rel="nofollow noreferrer">Here</a> is the same code with all the Java-isms stripped out, and your problem solved, all in only 41 lines. <a href="http://pastebin.com/pdLpiXTW" rel="nofollow noreferrer">Here</a> is an even simpler version, with all the unnecessary "abstract class" stuff stripped out as well, now only 35 lines. It can be used exactly the same way as what you were trying to build, without all the overhead.</span>
<span class="comment-copy">so if i create a runner using the CharityRunner class. how would i go about testing that it has gone into the list.</span>
<span class="comment-copy">@Ross: The same way I just showed you: the <code>in</code> operator. <code>if new_runner in club.runners</code>.</span>
<span class="comment-copy">ok so i added the code. no how would i get the list to print out so i can see if the runner was added to the list. i tried "print ('[%s]' % ', '.join(map(str, self._runners)))" but it says that self is not defined</span>
<span class="comment-copy">@Ross: Where did you try that? Inside a method of <code>Club</code>, that should work (although I'm not sure why you want that instead of just <code>print(self._runners)</code>. Outside a method of <code>Club</code>, there obviously is no club named <code>self</code>; you have to use some <code>Club</code> instance that you created and stored somewhere. If you don't understand even this basic stuff, you need to read <a href="http://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">Classes</a> in the tutorial before trying to write complicated classes yourself.</span>
<span class="comment-copy">@Ross: And that gives me even less confidence in your teacher. If they're trying to show you how to write <code>@property</code> getters and setters before they've even taught you the basics of what <code>self</code> means, you are going to come out of this class as a much worse Python programmer than someone who's just spent a few hours picking it up himself. Drop the class, or learn Python on your own from proper instructions and then go back and ace the class if you prefer.</span>
