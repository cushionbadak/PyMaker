<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3942820/how-to-do-unit-testing-of-functions-writing-files-using-python-unittest">How to do unit testing of functions writing files using python unittest</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>I have a Python function that takes a list as an argument and writes it to a file:</p>
<pre><code>def write_file(a):
    try:
        f = open('testfile', 'w')
        for i in a:
            f.write(str(i))

    finally:
        f.close()
</code></pre>
<p>How do I test this function ?</p>
<pre><code>def test_write_file(self):
    a = [1,2,3]
    #what next ?
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Call the <code>write_file</code> function and check whether <code>testfile</code> is created with expected content.</p>
<pre><code>def test_write_file(self):
    a = [1,2,3]
    write_file(a)
    with open('testfile') as f:
        assert f.read() == '123' # Replace this line with the method
                                 #   provided by your testing framework.
</code></pre>
<p>If you don't want test case write to actual filesystem, use something like <a href="http://docs.python.org/3/library/unittest.mock.html#unittest.mock.mock_open" rel="noreferrer"><code>mock.mock_open</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>First solution: rewrite you function to accept a writable file-like object. You can then pass a StringIO instead and test the StringIO's value after the call.</p>
<p>Second solution: use some mock library that let you patch builtins.</p>
</div>
