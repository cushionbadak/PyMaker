<div class="post-text" itemprop="text">
<p>I having been trying to offset inside a for statement so i can evaluate changes in the data sequence. Wondering what i am doing wrong here. maybe to for statement isn't the best method, so tried using next inside an if statement as well. this will be used large data sets.</p>
<pre><code>n = 1
data = [10,9,8,7,6,5,6,7,8,7,6]

def test(data,n):
    highs = []
    for d in data:
        if d &gt; d[-n]:
            highs.extend([d])
    return highs


def test1(data,n):
    highs = []
    if data[n+1] &gt; data[n]:
        highs.extend([data[n]])
        next
    else:
        next
    return highs
</code></pre>
<p>can anyone help with what is missing in this? thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not entirely clear as to what you mean by <code>d[-n]</code> or <code>data[n]</code>.  But I'm guessing you mean the previous value in the list (or the current position - n back).</p>
<p>Here's a simple solution to the problem of finding elements that are larger than the previous one.  Just save that previous value in a variable.</p>
<pre><code>prev = data[0] 
highs = [prev] # should the 1st one be one the list?
for d in data:
    if d &gt; prev:
        highs.append(d) # simpler than extend([d])
    prev = d  # update prev       
highs
# [10, 6, 7, 8]
</code></pre>
<p>Another approach is to step the index</p>
<pre><code>for i in range(n, len(data)):
    if data[i]&gt;data[i-n]
        ...
</code></pre>
<p>Or use <code>enumerate</code> to get the index</p>
<pre><code>for i, d in enumerate(data):
    j = i - n
    if j&gt;=0:
        if d &gt; data[j]:
           ....
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you want a sliding window that moves over your data, so you can compare each element to one n before it?</p>
<p>You can use a collections.deque (<a href="http://docs.python.org/2/library/collections.html#deque-objects" rel="nofollow">http://docs.python.org/2/library/collections.html#deque-objects</a>) for this:</p>
<pre><code>from itertools import islice
from collections import deque
def windowed(items, size):
    items = iter(items)
    window = deque(islice(items, size), maxlen=size)
    while True:
        yield window
        window.append(items.next())
</code></pre>
<p>(Using maxlen means that the append pushes the leftmost element out of the fixed-size deque.)</p>
<p>Then you can use it to look at the first and last items in the window with:</p>
<pre><code>for window in windowed(data, n):
    # do something with window[0] and window[-1]
</code></pre>
<p>Access to each end of the deque is quick - O(1).</p>
</div>
<span class="comment-copy">what do you think <code>next</code> does?</span>
<span class="comment-copy"><code>if d &gt; d[-n]:</code> should this be <code>if d &gt; data[n]:</code>? on <code>test()</code></span>
<span class="comment-copy">As a followup to shx2's point, the docs will <i>tell</i> you what <a href="http://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next</code></a> does.</span>
<span class="comment-copy">And as a side note, <code>highs.extend([d])</code> is the same as <code>highs.append(d)</code>. No need to over-complicated things.</span>
<span class="comment-copy">Can you explain better what you want?</span>
