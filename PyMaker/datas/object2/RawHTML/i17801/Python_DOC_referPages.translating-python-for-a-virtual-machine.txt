<div class="post-text" itemprop="text">
<p>I am currently working on a project involving a new faster execution environment/VM for Python on Linux. The python source is parsed into an intermediate AST, analyzed and the code for the target VM is generated JIT and cached. Due to the JIT nature of the proposed machine, speed is essential and I am writing it as native as possible. Currently its completely implemented in C apart a single python interface to the compiler module. Currently I am able to build the AST using the Python compiler module and have it in memory.</p>
<p>For example the code:</p>
<pre><code>class Test:
    def testFunc(arg1):
        print 'Arg is ' + arg1
</code></pre>
<p>generates the AST</p>
<pre><code>Module(None, Stmt([Class('Test', [], None, Stmt([Function(None, 'testFunc', ['arg1'], [], 0, None, Stmt([Printnl([Add((Const('Arg is '), Name('arg1')))], None)]))]), None)]))
</code></pre>
<p>What I want to know is a efficient method to parse this AST into a manipulable data structure like a tree, which can be traversed and the target code emitted. I am confused as to whether to go for a parser generator like Bison or Lemon or manually tokenize and parse it. Since the AST is obtained after extensive error checks, so no point of further error checks, hence I believe a parser generator is overkill. Python itself provides AST walkers but it slows it down. But then I am really not too sure how to go about manually deciphering it. I would really appreciate any algorithm or suggestion or if possible a native language implementation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python already has a fast parser (see <a href="http://hg.python.org/cpython/file/c3bbb5597f11/Parser/parser.c" rel="nofollow"><code>Parser/parser.c</code></a> in the Python sources). You create a parser by calling <a href="http://hg.python.org/cpython/file/c3bbb5597f11/Parser/parser.c#l71" rel="nofollow"><code>PyParser_New</code></a> and send it tokens by calling <a href="http://hg.python.org/cpython/file/c3bbb5597f11/Parser/parser.c#l227" rel="nofollow"><code>PyParser_AddToken</code></a>. It builds a tree of <code>node</code> objects (see <a href="http://hg.python.org/cpython/file/c3bbb5597f11/Include/node.h" rel="nofollow"><code>Parser/node.h</code></a>):</p>
<pre class="lang-c prettyprint-override"><code>typedef struct _node {
    short        n_type;
    char         *n_str;
    int          n_lineno;
    int          n_col_offset;
    int          n_nchildren;
    struct _node *n_child;
} node;
</code></pre>
<p>So if the <a href="http://docs.python.org/3/library/ast.html" rel="nofollow"><code>ast</code></a> module is too slow, use the C interface and process the parse tree directly.</p>
</div>
<span class="comment-copy">You might want to move this question to <a href="http://cs.stackexchange.com/">cs.stackexchange.com</a></span>
<span class="comment-copy">the <code>T</code> in <code>ast</code> stands for <code>tree</code>. It already a tree that you can traverse e.g., <a href="http://stackoverflow.com/q/1515357/4279">Simple example of how to use <code>ast.NodeVisitor</code>?</a> or another simple example: <a href="http://stackoverflow.com/q/9782793/4279">Extracting “extra” docstrings from Python code?</a></span>
<span class="comment-copy">I mean I obtained this as a text string from the Python compiler module and want to parse this into a tree in memory preferably in a native language. I tried the python AST walker but its somewhat slow for really huge codes. What I need is a simple system which parses this and gives me the node name and values.</span>
<span class="comment-copy">And letting Python generate its AST and dumping it into a string representation isn't slow? Then you should probably first try doing the traversal yourself (possibly using C code, but Python will be easier to prototype and may do the trick) instead of using the visitor interface. And as an aside: Perhaps you should tackle the hard and innovative part <i>first</i>, namely creating a faster VM + JIT compiler. Since that's independent from how exactly you turn Python source code into VM instructions, it'll be easy to optimize that part later/concurrently.</span>
<span class="comment-copy">Exactly the thing. And Thanks to you the entire thing is in C with no Python dependencies! Thanks!</span>
