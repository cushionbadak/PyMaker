<div class="post-text" itemprop="text">
<pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed

def main():
    with ThreadPoolExecutor(max_workers=16) as producersPool:
        for i in [1,2,3,4,5,6,7,8,9,0]:
            producersPool.submit((lambda i : print(i))(i))


if __name__ == "__main__":
    main()
</code></pre>
<p>Running with python3:</p>
<pre><code>1
2
3
4
5
6
7
8
9
0
</code></pre>
<p>Always the same.</p>
<p>Now I'd like you to get me right - I don't necessarily wish for those tasks to be reordered, but I'm just wondering why does the ordering <em>happen at all</em>? I mean, one could expect to get things done in deterministic way inside one thread, but the strict queueing of the threads seems a bit odd to me.</p>
<p>Anyway, how do I get the real concurrency in Python 3? (Jython and IronPython support only 2.x, as far as I know).</p>
</div>
<div class="post-text" itemprop="text">
<p>All jobs are executed <em>before</em> they are submitted, and none of them do more than write to an output stream. You submit the <em>result</em> of calling each <code>lambda</code>.</p>
<p>Even if you used:</p>
<pre><code>producersPool.submit(lambda i: print(i), (i,))
</code></pre>
<p>there is not <em>enough</em> in each thread to be preempted by another thread, so they all complete before any other thread can but in.</p>
</div>
<div class="post-text" itemprop="text">
<p>to answer the second part of your question:</p>
<blockquote>
<p>"how do I get the real concurrency in Python 3?"</p>
</blockquote>
<p>you can use the <a href="http://docs.python.org/3/library/multiprocessing.html" rel="nofollow">multiprocessing</a> module:</p>
<blockquote>
<p>"multiprocessing is a package that supports spawning processes using
  an API similar to the threading module. The multiprocessing package
  offers both local and remote concurrency, effectively side-stepping
  the Global Interpreter Lock by using subprocesses instead of threads."</p>
</blockquote>
<p>Since your example used <code>ThreadPoolExecutor</code> from <code>concurrent.futures</code>, have a look at <a href="http://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor" rel="nofollow"><code>ProcessPoolExecutor</code></a> in the same package.  It is similar to <code>ThreadPoolExecutor</code>, but uses processes (instead of threads), so it is not hampered by the GIL.</p>
</div>
<span class="comment-copy">Your example contains an important error: you're actually <i>calling</i> the lambda and only passing the <i>result</i> (which is always None) to <code>submit</code>. The observed behaviour has nothing to do with the ThreadPool. You probably wanted to write <code>(lambda i: (lambda: print(i)))(i)</code> instead.</span>
<span class="comment-copy">@l4mpi, yes, I already noticed it and already hit myself in the face. I edited the code to <code>producersPool.submit(sleepy, i)</code> and it runs as expected, i.e. is a rather unpredicted fashion. Thank you.</span>
<span class="comment-copy">Ah, I see. Well, I added <code>sleep(5)</code> and it seems to print the list in a truly random way now. Thank you.</span>
<span class="comment-copy">The actual problem in the example is that the printing happens in the main thread, and OP never submits anything other than <code>None</code> to the thread pool...</span>
<span class="comment-copy">See my comment for @l4mpi (lambdas look a little raggedy here IMO, so I made a function).</span>
<span class="comment-copy">Yeah, I saw it, but just didn't think about the possibility. That's great, I'm sorry I can't accept two answers at once (I shouldn't have asked two at once first of all:) )</span>
