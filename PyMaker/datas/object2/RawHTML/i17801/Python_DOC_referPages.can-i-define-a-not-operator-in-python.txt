<div class="post-text" itemprop="text">
<p>I am trying to interface a C++ library that implements logical operators &amp;&amp;, ||, ! (unary operator not) to operate on custom selection classes. </p>
<p>I'm a bit stuck because I can't find an unary 'not' operator in Python. 
Is it possible to override the built in '<strong>not</strong>' operator which works on boolean in Python ? </p>
<p>Is there another suitable operator, or do I need to define a function 'Not()' to implement this behavior?</p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot override the <strong>boolean</strong> operators (<code>and</code>, <code>or</code>, and <code>not</code>) with special method hooks, because <code>and</code> and <code>or</code> operate lazily and a special method would require that you evaluate operands early instead.</p>
<p>You can only influence how the object is evaluated to a boolean (using the <a href="http://docs.python.org/2/reference/datamodel.html#object.__nonzero__" rel="nofollow"><code>__nonzero__</code></a> or <a href="http://docs.python.org/2/reference/datamodel.html#object.__len__" rel="nofollow"><code>__len__</code></a> methods, depending on whether you are implementing a numeric or container type; Python 3 renamed <code>__nonzero__</code> to <a href="http://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="nofollow"><code>__bool__</code></a>).</p>
<p>You <em>can</em> hook into bitwise operators (<code>&amp;</code>, <code>|</code> and <code>~</code>), with the <a href="http://docs.python.org/2/reference/datamodel.html#object.__and__" rel="nofollow"><code>__and__</code></a>, <a href="http://docs.python.org/2/reference/datamodel.html#object.__or__" rel="nofollow"><code>__or__</code></a>, and <a href="http://docs.python.org/2/reference/datamodel.html#object.__invert__" rel="nofollow"><code>__invert__</code></a> methods, however. This is probably what you are looking for instead. For <code>&amp;</code> and <code>|</code> there are also inverse and in-place hooks available (<a href="http://docs.python.org/2/reference/datamodel.html#object.__rand__" rel="nofollow"><code>__rand__</code></a>, <a href="http://docs.python.org/2/reference/datamodel.html#object.__ror__" rel="nofollow"><code>__ror__</code></a>, <a href="http://docs.python.org/2/reference/datamodel.html#object.__iand__" rel="nofollow"><code>__iand__</code></a> and <a href="http://docs.python.org/2/reference/datamodel.html#object.__ior__" rel="nofollow"><code>__ior__</code></a>).</p>
<p>The result of the boolean hooks (<code>__nonzero__</code>, etc.) are cast to a boolean (<code>True</code> or <code>False</code>), but the bitwise operator hooks can return anything you like. <code>~custom_obj</code> will evaluate to whatever <code>type(custom_obj).__invert__(custom_obj)</code> returns; <code>custom_obj1 &amp; custom_obj2</code> will return the result of <code>type(custom_obj1).__and__(custom_obj1, custom_obj2)</code>, unless that method doesn't exist or returns <code>NotImplemented</code>, in which case <code>type(custom_obj2).__rand__(custom_obj2, custom_obj1)</code> is called instead.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>not</code> just acts on boolean values in python. If that is sufficient in your use case you can override the <a href="http://docs.python.org/reference/datamodel.html#object.__nonzero__" rel="nofollow"><code>__nonzero__</code> method</a>. Otherwise your stuck to implement your own <code>obj.inverted()</code> method.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; hex(~0xaa &amp; 0xff)
'0x55'
</code></pre>
<p>Just have to use the matching Python operator.</p>
</div>
<span class="comment-copy">you can't overwrite the <code>not</code> operator.... cause their implemented in C</span>
<span class="comment-copy">not is unary and will operate on other data types other than boolean in python, what is the motivation behind changing it?</span>
<span class="comment-copy">Totally nit-picking but I doubt <code>not</code> is lazy.</span>
<span class="comment-copy">@MarkRansom: It is indeed not lazy. I was simplifying.</span>
<span class="comment-copy">@Guy: <code>not</code>'s behavior is perfectly overridable for a custom object, provided you want to influence if it returns <code>False</code> or <code>True</code>. That's the full extend of your influence.</span>
<span class="comment-copy">how is <code>not</code> really different than C <code>!</code> anyway? while this is all interesting, does he really have to do that?</span>
<span class="comment-copy">@Guy: Depends on your project. <a href="http://docs.sqlalchemy.org/en/rel_0_8/core/sqlelement.html?highlight=#sqlalchemy.sql.expression.not_" rel="nofollow noreferrer">SQLAlchemy does it</a>, to great effect. Same for using <a href="http://docs.sqlalchemy.org/en/rel_0_8/core/sqlelement.html?highlight=#sqlalchemy.sql.expression.or_" rel="nofollow noreferrer"><code>|</code> for <code>or</code></a> and <a href="http://docs.sqlalchemy.org/en/rel_0_8/core/sqlelement.html?highlight=#sqlalchemy.sql.expression.and_" rel="nofollow noreferrer"><code>&amp;</code> for <code>and</code></a>.</span>
