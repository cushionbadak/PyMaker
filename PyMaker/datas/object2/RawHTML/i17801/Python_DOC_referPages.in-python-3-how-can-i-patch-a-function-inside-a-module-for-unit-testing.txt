<div class="post-text" itemprop="text">
<p>I have decorated methods that send timings to a hosted graphite instance they look like what is below</p>
<p><strong>views.py</strong></p>
<pre><code>from util import send_timing

@send_timing('login')
def login_user():

    if is_user_ok():
        return True
    return False

@send_timing('get_user_info')
def get_user_info():

    return get_that_info()
</code></pre>
<p>I have a util file that defines the decorator</p>
<p><strong>util.py</strong></p>
<pre><code>def send_timing(f):
  def decorated(*args):
     make_network_connection()
     ret = f(*args)
  return decorated
</code></pre>
<p>I have some unit tests</p>
<p><strong>test.py</strong></p>
<pre><code>from views import *
import unittest

class TestCase(unittest.TestCase):

   def test_login(self):         
      self.assertTrue(login_user())
</code></pre>
<p>Now the problem is that call to <code>login_user</code>. It invokes the send_timing decorator which in turn makes a network connection. This makes my tests volatile and non-deterministic. Is there an easy way (python 3.3) to patch <code>send_timing</code> with a dummy or mock globally for all my tests?</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to use <a href="http://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow"><code>@functools.wraps()</code> decorator factory</a> in your decorator:</p>
<pre><code>from functools import wraps

def send_timing(f):
    @wraps(f)
    def wrapper(*args, **kw):
        # probably do a little more than just proxy
        return f(*args, **kw)
    return wrapper
</code></pre>
<p>This adds an attribute <em>on the returned wrapper function</em>, letting you access the original unwrapped function:</p>
<pre><code>unwrapped = login_user.__wrapped__
</code></pre>
<p>You can use the <code>unwrapped</code> value here to mock <code>login_user</code>, or use it directly in your unit tests.</p>
</div>
