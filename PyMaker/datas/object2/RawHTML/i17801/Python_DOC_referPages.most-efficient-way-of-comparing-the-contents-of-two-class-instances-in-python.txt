<div class="post-text" itemprop="text">
<p>I'm looking for the most efficient way of comparing the contents of two class instances. I have a list containing these class instances, and before appending to the list I want to determine if their property values are the same. This may seem trivial to most, but after perusing these forums I wasn't able specific to what I'm trying to do. Also note that I don't have an programming background.</p>
<p>This is what I have so far:</p>
<pre><code>class BaseObject(object):
    def __init__(self, name=''):
        self._name = name


    def __repr__(self):
        return '&lt;{0}: \'{1}\'&gt;'.format(self.__class__.__name__, self.name)

    def _compare(self, other, *attributes):
        count = 0
        if isinstance(other, self.__class__):
            if len(attributes):
                for attrib in attributes:
                    if (attrib in self.__dict__.keys()) and (attrib in other.__dict__.keys()):
                        if self.__dict__[attrib] == other.__dict__[attrib]:
                            count += 1
                return (count == len(attributes))
            else:
                for attrib in self.__dict__.keys():
                    if (attrib in self.__dict__.keys()) and (attrib in other.__dict__.keys()):
                        if self.__dict__[attrib] == other.__dict__[attrib]:
                            count += 1
                return (count == len(self.__dict__.keys()))
    def _copy(self):
        return (copy.deepcopy(self))
</code></pre>
<p>Before adding to my list, I'd do something like:</p>
<pre><code>found = False
for instance in myList:
    if instance._compare(newInstance): 
        found = True
        Break

if not found: myList.append(newInstance)
</code></pre>
<p>However I'm unclear whether this is the most efficient or python-ic way of comparing the contents of instances of the same class.</p>
</div>
<div class="post-text" itemprop="text">
<p>Implement a <a href="http://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow"><code>__eq__</code> special method</a> instead:</p>
<pre><code>def __eq__(self, other, *attributes):
    if not isinstance(other, type(self)):
        return NotImplemented

    if attributes:
        d = float('NaN')  # default that won't compare equal, even with itself
        return all(self.__dict__.get(a, d) == other.__dict__.get(a, d) for a in attributes)

    return self.__dict__ == other.__dict__
</code></pre>
<p>Now you can just use:</p>
<pre><code>if newInstance in myList:
</code></pre>
<p>and Python will automatically use the <code>__eq__</code> special method to test for equality.</p>
<p>In my version I retained the ability to pass in a limited set of attributes:</p>
<pre><code>instance1.__eq__(instance2, 'attribute1', 'attribute2')
</code></pre>
<p>but using <code>all()</code> to make sure we only test as much as is needed.</p>
<p>Note that we return <code>NotImplemented</code>, a special singleton object to signal that the comparison is not supported; Python will ask the <em>other</em> object if it perhaps supports equality testing instead for that case.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can implement the <a href="http://www.rafekettler.com/magicmethods.html#comparisons" rel="noreferrer">comparison magic method</a> <code>__eq__(self, other)</code> for your class, then simply do</p>
<pre><code>if instance == newInstance:
</code></pre>
<p>As you apparently don't know what attributes your instance will have, you could do:</p>
<pre><code>def __eq__(self, other):
    return isinstance(other, type(self)) and self.__dict__ == other.__dict__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your method has one major flaw: if you have reference cycles with classes that both derive from <code>BaseObject</code>, your comparison will never finish and die with a stack overflow.</p>
<p>In addition, two objects of different classes but with the same attribute values compare as equal. Trivial example: any instance of <code>BaseObject</code> with no attributes will compare as equal to any instance of a <code>BaseObject</code> subclass with no attributes (because if <code>issubclass(C, B)</code> and <code>a</code> is an instance of <code>C</code>, then <code>isinstance(a, B)</code> returns <code>True</code>).</p>
<p>Finally, rather than writing a custom <code>_compare</code> method, just call it <code>__eq__</code> and reap all the benefits of now being able to use the <code>==</code> operator (including contain testing in lists, container comparisons, etc.).</p>
<p>As a matter of personal preference, though, I'd stay away from that sort-of automatically-generated comparison, and explicitly compare explicit attributes.</p>
</div>
<span class="comment-copy">You should put them in a set and implement <code>__hash__</code> and <code>__eq__</code> in your class.</span>
<span class="comment-copy"><i>two objects of different classes but with the same attribute values compare as equal</i>: This is absolutely, patently <i>not true</i>. Instances of different classes never equal. Even the OP version does a <code>isinstance()</code> test first, and <code>object()</code> won't pass that test.</span>
<span class="comment-copy">Whoops, my bad, I missed the <code>isinstance</code> check. Shouldn't comment on these things before the coffee has had the time to kick in. However, instances of different classes return <code>None</code> instead of 0, which may or may not be what you want.</span>
<span class="comment-copy">What you want, really, is to return <code>NotImplemented</code> for those cases so that Python will look for <code>second.__eq__(first)</code>.</span>
<span class="comment-copy">Wait, actually, instances of different classes can compare as equal, if and only if one is a subclass of the other (and both derive from <code>BaseObject</code>).</span>
<span class="comment-copy">Yes, and that is probably intended, provided they have the same attributes.</span>
