<div class="post-text" itemprop="text">
<p>I'm trying to use python to control cuda, through ctypes.  Here, to illustrate my problem, I use python to pass pointers along to c functions which allocate cuda memory, copy numpy array to cuda mempory, and copy cuda memory back to a new numpy array. But it doesnt seem to work, despite my basic ctypes setup working.  I think the issue is with what's being returned from cudaMalloc function to python.  </p>
<p>here's the python code </p>
<pre><code>  pycu_alloc = dll.alloc_gpu_mem
  pycu_alloc.argtypes = [c_size_t]
  pycu_alloc.restypes = [c_void_p]   

  host2gpu = dll.host2gpu
  host2gpu.argtypes = [c_void_p, c_void_p, c_size_t]

  gpu2host = dll.gpu2host
  gpu2host.argtypes = [c_void_p, c_void_p, c_size_t]

  a = np.random.randn(1024).astype('float32')
  c = np.zeros(1024).astype('float32')

  c_a = c_void_p(a.ctypes.data)
  c_c = c_void_p(c.ctypes.data)

  da = pycu_alloc(1024)
  c_da = c_void_p(da)

  host2gpu(c_a, c_da, 1024)
  gpu2host(c_c, c_da, 1024)

  print a
  print c
</code></pre>
<p>and the C:</p>
<pre><code>extern "C" {
float *  alloc_gpu_mem( size_t N)
{
  float *d;
  int size = N *sizeof(float);
  int err;

  err = cudaMalloc(&amp;d, size);

  printf("cuda malloc: %d\n", err);
  return d;
 }}

 extern "C" {
 void host2gpu(float * a, void * da, size_t N)
 {
  int size = N * sizeof(float);
  int err;
  err = cudaMemcpy(da, a, size, cudaMemcpyHostToDevice);
  printf("load mem: %d\n", err);
  }}

  extern "C"{
 void gpu2host(float *c, void *d_c, size_t N)
 {
  int  err;
  int size = N*sizeof(float);
  err = cudaMemcpy(c, d_c, size, cudaMemcpyDeviceToHost);
  printf("cpy mem back %d\n", err);
 }}
</code></pre>
<p>The code should copy a random vector <code>a</code> to cuda memory, and then copy that cuda memory back to an empty vector <code>c</code>.  When I print <code>c</code>, thought, it is just <code>0</code>s.</p>
<p>I've wrestled with different possibilities of the <code>float*</code> and <code>void*</code>, particularly in the way <code>alloc_gpu_mem</code> works.  But I don't know what to do.</p>
<p>As for the <code>err</code> return values, the <code>cudaMalloc</code> returns <code>0</code> but both <code>cudaMemcpy</code> return 11.</p>
<p>What's python doing wrong with the pointer? Help? </p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is here:</p>
<pre><code>pycu_alloc.restypes = [c_void_p]   
</code></pre>
<p>This doesn't do anything. What you wanted was:</p>
<pre><code>pycu_alloc.restype = c_void_p
</code></pre>
<p>See <a href="http://docs.python.org/3/library/ctypes.html#return-types" rel="noreferrer">Return types</a> in the <code>ctypes</code> docs.</p>
<p>And without that, <code>ctypes</code> assumes that your function returns a C <code>int</code>. On a 32-bit platform, you might get away with it, because you end up constructing a <code>c_void_p</code> whose value is that <code>int</code>… but on a 64-bit platform, that pointer is going to end up with the upper 32 bits missing.</p>
<p>So, when you pass that into CUDA, it recognizes that the pointer isn't in any range it knows about, and gives you back a <code>cudaErrorInvalidValue</code> (11).</p>
<p>Also, if you get everything right, this line should be unnecessary:</p>
<pre><code>c_da = c_void_p(da)
</code></pre>
<p>You're calling a function whose <code>argtypes</code> specifies <code>c_void_p</code>, so you can pass it an <code>int</code> that you got from a <code>c_void_p</code>-returning function just fine.</p>
<hr/>
<p>You can see the same behavior with plain old <code>malloc</code> and <code>free</code>, except that you'll probably get a segfault at <code>free</code> instead of a nice error:</p>
<pre><code>malloc = libc.malloc
malloc.argtypes = [c_size_t]
malloc.restype = c_void_p # comment this line to crash on most 64-bit platforms

free = libc.free
free.argtypes = [c_void_p]
free.restype = None

a = malloc(1024)
free(a) # commenting this line and uncommenting the next two has no effect
#c_a = c_void_p(a)
#free(ca)
</code></pre>
</div>
<span class="comment-copy">This doesn't directly answer your question, but… have you tried the existing Python CUDA bindings from <a href="http://mathema.tician.de/software/pycuda/" rel="nofollow noreferrer">Andreas Klöckner</a> (which I think are the same ones Nvidia links to from their website, but I haven't checked)?</span>
<span class="comment-copy">No I was looking at that and I probably should have used them but I wanted to dive in and control the cuda myself to make sure I knew what was going on.  then i got caught up giving myself python handles because it would be really nice for me.  but alas.</span>
<span class="comment-copy">WOOOOHOOOOOOOO!!!! thank you so much dear friend.  merry, merry blessings to you</span>
<span class="comment-copy">@Ethan: Remember to be careful with types that have data descriptors yet still give a <code>__dict__</code> to instances. ctypes data types allow this because they're designed to be subclassed to support additional state and interfaces. Unfortunately it's easy to mistakenly create a new attribute like <code>restypes</code>. If you tried to assign <code>[c_void_p]</code> to the correct <code>restype</code> attribute you would at least get a <code>TypeError</code>. The REPL, <code>dir</code> and <code>help</code> are your friends.</span>
