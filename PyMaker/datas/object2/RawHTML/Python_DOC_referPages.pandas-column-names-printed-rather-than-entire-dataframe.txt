<div class="post-text" itemprop="text">
<p>I have some code that creates a generator with <code>read_sql()</code> and loops through the generator to print each chunk:</p>
<p><strong>execute.py</strong></p>
<pre><code>import pandas as pd
from sqlalchemy import event, create_engine

engine = create_engine('path-to-driver')

def getDistance(chunk):
    print(chunk)
    print(type(chunk))

df_chunks = pd.read_sql("select top 2 * from SCHEMA.table_name", engine, chunksize=1)

for chunk in df_chunks:
    result = getDistance(chunk)
</code></pre>
<p>It works, and each chunk is printed as as DataFrame. When I attempt to do the same thing with multiprocessing like this...</p>
<p><strong>outside_function.py</strong></p>
<pre><code>def getDistance(chunk):
    print(chunk)
    print(type(chunk))
    df = chunk
    return df
</code></pre>
<p><strong>execute.py</strong></p>
<pre><code>import pandas as pd
from sqlalchemy import event, create_engine

engine = create_engine('path-to-driver')

df_chunks = pd.read_sql("select top 2 * from SCHEMA.table_name", engine, chunksize=1)

if __name__ == '__main__':
    global result
    p = Pool(20)
    for chunk in df_chunks:
        print(chunk)
        result = p.map(getDistance, chunk)
    p.terminate()
    p.join()
</code></pre>
<p>...the chunks print as column names in the console with the type 'str'. Printing out <code>result</code> reveals this <code>['column_name']</code>. </p>
<p>Why are the chunks turning into strings that are just the column names when multiprocessing is applied?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is because <code>p.map</code> expects a function and an iterable. Iterating over a dataframe (in this case your <code>chunk</code>) will yield the column names. </p>
<p>You need to pass in a collection of dataframes to the map method. I.e.:</p>
<pre><code>    global result
    p = Pool(20)
    result = p.map(getDistance, df_chunks)
    p.terminate()
    p.join()
</code></pre>
</div>
<span class="comment-copy">You are not properly looping over the data_frame. The chunk will be a string regardless of using multiprocessing or not. If you want to loop over the values or rows you should use <code>df.itertuples()</code> or <code>df.iterrows()</code>. What exactly are you trying to do?</span>
<span class="comment-copy">I guess I'm saying you should not be surprised here. If all you did was <code>for a in df:</code> that is a string. So no matter what you do with it after that, <code>a</code> is a string. Doesn't matter if you're using multiprocessing or not.</span>
<span class="comment-copy">In my experience with multiprocessing, you want to avoid terminating processes how you are doing. Check <a href="https://stackoverflow.com/questions/32053618/how-to-to-terminate-process-using-pythons-multiprocessing">this answer</a> for a pretty in-depth explanation on "gracefully" exiting processes.</span>
