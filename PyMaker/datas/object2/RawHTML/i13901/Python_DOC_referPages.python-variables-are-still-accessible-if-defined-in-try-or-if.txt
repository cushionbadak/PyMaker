<div class="post-text" itemprop="text">
<p>I'm a Python beginner and I am from C/C++ background. I'm using Python 2.7.</p>
<p>I read this article: <a href="http://spartanideas.msu.edu/2014/05/12/a-beginners-guide-to-pythons-namespaces-scope-resolution-and-the-legb-rule/">A Beginner’s Guide to Python’s Namespaces, Scope Resolution, and the LEGB Rule</a>, and I think I have some understanding of Python's these technologies.</p>
<p>Today I realized that I can write Python code like this:</p>
<pre><code>if condition_1:
    var_x = some_value
else:
    var_x = another_value
print var_x
</code></pre>
<p>That is, var_x is still accessible even it is <strong>not</strong> define <strong>before</strong> the if. Because I am from C/C++ background, this is something new to me, as in C/C++, <code>var_x</code> are defined in the scope enclosed by if and else, therefore you cannot access it any more unless you define <code>var_x</code> before <code>if</code>.</p>
<p>I've tried to search the answers on Google but because I'm still new to Python, I don't even know where to start and what keywords I should use. </p>
<p>My guess is that, in Python, <code>if</code> does not create new scope. All the variables that are newly defined in <code>if</code> are just in the scope that <code>if</code> resides in and this is why the variable is still accessible after the <code>if</code>. However, if <code>var_x</code>, in the example above, is only defined in <code>if</code> but not in <code>else</code>, a warning will be issued to say that the <code>print var_x</code> may reference to a variable that may not be defined.</p>
<p>I have some confidence in my own understanding. However, <strong>could somebody help correct me if I'm wrong somewhere, or give me a link of the document that discusses about this??</strong></p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>My guess is that, in Python, <code>if</code> does not create new scope. All the variables that are newly defined in <code>if</code> are just in the scope that if resides in and this is why the variable is still accessible after the <code>if</code>.</p>
</blockquote>
<p>That is correct. In Python, <a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow noreferrer">namespaces</a>, that essentially decide about the variable scopes, are only created for modules, and functions (including methods; basically any <code>def</code>). So everything that happens within a function (and not in a sub-function) is placed in the same namespace.</p>
<p>It’s important to know however that the mere existance of an assignment within a function will reserve a name in the local namespace. This makes for some interesting situations:</p>
<pre><code>def outer ():
    x = 5
    def inner ():
        print(x)
        # x = 10
    inner()
outer()
</code></pre>
<p>In the code above, with that line commented out, the code will print <code>5</code> as you may expect. That’s because <code>inner</code> will look in the outer scope for the name <code>x</code>. If you add the line <code>x = 10</code> though, the name <code>x</code> will be <em>local</em> to <code>inner</code>, so the <em>earlier</em> look up to <code>x</code> will look in the local namespace of <code>inner</code>. But since it hasn’t been assigned yet, you will receive an <code>UnboundLocalError</code> (<em>“local variable 'x' referenced before assignment”</em>). The <a href="https://stackoverflow.com/questions/1261875/python-nonlocal-statement"><code>nonlocal</code></a> statement was added in Python 3 to overcome one issue from this: The situation where you want to actually modify the <code>x</code> of the outer scope within the inner function.</p>
<p>For more information on name lookup, see <a href="https://stackoverflow.com/questions/291978/short-description-of-python-scoping-rules">this related question</a>.</p>
</div>
<span class="comment-copy">You are correct. Variables defined in <code>if</code>/<code>elif</code>/<code>else</code> blocks are visible in the scope containing the block.</span>
<span class="comment-copy">This also applies to <code>for</code> and <code>while</code> loops, as well as the <code>with</code> statement. Basically everything but functions and classes (you can still access variables through the class's name: <code>Cls.var</code>).</span>
<span class="comment-copy">you can mess around looking at what is and isn't in scope with <code>locals()</code> and <code>globals()</code></span>
<span class="comment-copy">@MarkusMeskanen you are correct. However, there are other enclosed scopes, such as comprehensions, where variables created in them are not visible to the surrounding code.</span>
<span class="comment-copy">@MattDMo: true only for Python 3.x. With 2.x comprehension variables are defined in the surrounding scope.</span>
<span class="comment-copy">Thanks, and it's interesting to know the situation you mentioned here.. I've never known about this!</span>
