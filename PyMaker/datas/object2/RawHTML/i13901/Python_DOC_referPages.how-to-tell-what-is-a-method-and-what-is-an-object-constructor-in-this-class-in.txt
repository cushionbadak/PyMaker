<div class="post-text" itemprop="text">
<p>I'm a beginner in Python and PySide. Can someone explain me how to recognize what is an object constructor and what is a method in this class (e.g. QLCDNumber(self) vs addWidget(argv)) and therefore why not calling self.vbox instead of vbox? </p>
<pre><code>import sys 
from PySide import QtGui, QtCore

class App(QtGui.QWidget):

    def __init__(self):
        super(Example, self).__init__()
        self.init_ui()

    def init_ui(self):
        lcd = QtGui.QLCDNumber(self)
        sld = QtGui.QSlider(QtCore.Qt.Horizontal, self)

        vbox = QtGui.QVBoxLayout()
        vbox.addWidget(lcd)
        vbox.addWidget(sld)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The difference between "methods" and "object constructors" in Python is very thin. You must be getting thoroughly confused with Java here.</p>
<p>Consider this:</p>
<pre><code>class A():
  def __init__(self, bar):
    baz = bar + bar
    self.egg = baz + baz

def B(tuna):
  return A(tuna)
</code></pre>
<p>What happens is <code>baz</code> is a mere variable and only <code>egg</code> hangs around after <code>A.__init__()</code> ends.</p>
<pre><code>&gt;&gt;&gt; A("foo").egg
"foofoofoofoo"
&gt;&gt;&gt; A("foo").baz # exception
</code></pre>
<p>Also, the return values of <code>A()</code> and <code>B()</code> are indistinguishable.</p>
<p>In Python, way moreso than Java, <em>everything</em> is an object and with a few corner cases there is no distinction between functions and methods. If you <em>really really really</em> did need to check, this is the way to go:</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; type(A) == types.ClassType and type(B) != types.ClassType
True
&gt;&gt;&gt; type(A) != types.FunctionType and type(B) == types.FunctionType
True
&gt;&gt;&gt; type(A.__init__) == types.MethodType and type(B) != types.MethodType
True
</code></pre>
<p>...but the need to do such introspection is quite rare.</p>
</div>
<div class="post-text" itemprop="text">
<p>Class constructors are defined by the method <code>__init__</code>. All non-static class methods (including the constructor) take a reference to the object itself in the form the <code>self</code> parameter, which is the first parameter passed. </p>
<p>You'd create a new instance of the <code>App</code> class by doing the following:</p>
<pre><code>app = App()
</code></pre>
<p>Then to call the method <code>init_ui</code> you'd do the following:</p>
<pre><code>app.init_ui()
</code></pre>
<p>If <code>lcd</code>, <code>sld</code> and <code>vbox</code> are all member variables of the <code>App</code> class then you'll need to access them as <code>self.vbox</code> within the methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>Constructor <code>__init__()</code> is called when you initialise the class</p>
<pre><code>class example:
    def __init__(self):
        print("example")
    def init(self):
        print("example No. 2")
</code></pre>
<p>So:</p>
<pre><code>&gt;&gt;&gt;a = example
... "example"
&gt;&gt;&gt;a.init()
... "example No. 2"
</code></pre>
<p>The  <code>self</code> is something that class have stored inside itself, not globaly but it will not 'disaper'</p>
<pre><code>class Human:
    def __init__(self, gender, name):
        self.age = 0
        self.gender = gender
        self.name = name
    def aging(self):
        self.age += 1

humans = []
humans.append(Human("male", "Jack")) # his age is 0 and gender is male
humans.append(Human("female", "Jesica"))
for human in humans:
    human.aging() # age is increasing
</code></pre>
</div>
<span class="comment-copy">As I understand it __init__() is the object constructor because it is a special class method for this functionality as documented at <a href="https://docs.python.org/2/tutorial/classes.html" rel="nofollow noreferrer">docs.python.org/2/tutorial/classes.html</a> and <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">docs.python.org/3/tutorial/classes.html</a>. init_ui() is a non-special class method.</span>
<span class="comment-copy">If you want to access instance attributes you must <i>always</i> go for the dotted notation. <code>lcd</code>, <code>sld</code> and <code>vbox</code> are simple variables of <code>init_ui</code> and,  since they all seem to go out of scope at the end of the function without any further references to them, they will get garbage collected. IOW, <code>init_ui</code> probably does nothing.</span>
<span class="comment-copy">In addition to the other answers, keep in mind that _<i>xyz_</i> double underscore methods are often called <i>magic methods</i> and provide special services.   For example _<i>str_</i> is roughly equivalent to a Java <i>toString</i>.</span>
<span class="comment-copy">Are <code>lcd</code>, <code>sld</code> and <code>vbox</code>  in this example, now member variables? If not, does <code>self.vbox = QtGui.QVBoxLayout()</code> makes it a member variable?</span>
<span class="comment-copy">In your example they are just local variables, if you want to access the object's variables, you have to use <code>self</code>.</span>
<span class="comment-copy">I have read that <code>__init__</code>  in Python is not a constructor because instance is already created when <code>__init__</code> is called. However, my question is not about that. I don't know to recognize is <code>QGridLayout()</code> a method or a class/object? My english is bad, that is why my question is unclear</span>
<span class="comment-copy">From what I understand /class Human/ is a class /myhuman = human/ is an object and /aging(self)/ is a method</span>
<span class="comment-copy">@HrvojeT unless you are dealing with immutable objects, the difference between <code>__init__</code> and constructors is mostly immaterial. You can't tell whether <code>QGridLayout</code> is a function or a class based on syntax alone. Consider what happens when I write <code>import QGridLayout as _QGridLayout; def QGridLayout(): return _QGridLayout()</code></span>
