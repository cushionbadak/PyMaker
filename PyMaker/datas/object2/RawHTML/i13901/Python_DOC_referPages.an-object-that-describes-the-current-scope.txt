<div class="post-text" itemprop="text">
<p>An API I use defines a method like this:</p>
<pre><code>def show_prop(object, propname): #...
</code></pre>
<p>What it's supposed to do is display the property on screen by calling <code>getattr(object, propname)</code> and allow the user to change the attribute, resulting in <code>setattr(object, propname)</code>.</p>
<p>There is no way I can change that behaviour but I want to use the API to show a local variable to the user and receive the normal feedback from the user?</p>
<p>I thought of a builting variable describing the current scope and the variables available, kind of like a local <code>__dict__</code> but I haven't found such thing.</p>
<pre><code>userinput = "Default input"
show_prop(__mysterious_unknown__, 'userinput')
# Do something exciting with the changed userinput
</code></pre>
<p>Is this possible to achieve?</p>
</div>
<div class="post-text" itemprop="text">
<p>No. Local write access can be done only directly in the scope or in nested scopes using <code>nonlocal</code> (Python3 only).</p>
<p>Python doesn't have the concept of "pointer" and the only way to specify a writable place is passing a reference to the container and the "name" of the member (or the index of the array, the key of the dict).</p>
<p>What you can do is however create a small object on the fly just for this:</p>
<pre><code>class Bunch:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

def foo():
    my_local = 42
    ...
    myobj = Bunch(my_local=my_local) # create the dummy instance
    show_prop(myobj, "my_local")     # call the original code
    my_local = myobj.my_local        # get modified value back
    ...
</code></pre>
<p>In Python3 would be possible to create a magic object instance that when written to the member will mutate the local on the fly (using the new Python3 <code>nonlocal</code> keyword and either a property or a <code>__getattr__</code>/<code>__setattr__</code> catch-all). I wouldn't go for this kind of strange magic unless it's really needed however...</p>
<p>For example:</p>
<pre><code>def foo(obj, name):
    # the fixed API
    setattr(obj, name, 1 + getattr(obj, name))

def bar():
    myloc = 11

    # magic class...
    class MyClass:
        def __getattr__(self, name):
            # accessing any member returns the current value of the local
            return myloc
        def __setattr__(self, name, value):
            # writing any member will mutate the local (requires Python3)
            nonlocal myloc
            myloc = value

    foo(MyClass(), "myloc")
    print(myloc) # here myloc will have been incremented

bar()
</code></pre>
</div>
<span class="comment-copy">There's the <a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer"><code>locals()</code></a> dictionary, but you can't use <code>getattr</code> on a dictionary.</span>
<span class="comment-copy">@MorganThrapp: also what is returned by <code>locals()</code> is read-only</span>
<span class="comment-copy">Also a good point.</span>
<span class="comment-copy">This kind of "strange magic" would be much appreciated though but I guess the "class Bunch" would be good enough</span>
<span class="comment-copy">@WorldSEnder: I've added an example, but don't tell anyone I told you this ;-)</span>
