<div class="post-text" itemprop="text">
<p>I want to run this git command through a Python script and get the output of it:</p>
<pre><code>git diff --name-only mybranch `git merge-base mybranch develop`
</code></pre>
<p>The purpose of the command is to see what changes have been made on <code>mybranch</code> since the last merge with develop.</p>
<p>To achieve this I'm using <code>subprocess.Popen</code>:</p>
<pre><code>output = subprocess.Popen(["git", "diff", "--name-only", "mybranch", "`git merge-base mybranch develop`"], stdout=subprocess.PIPE, shell=True)
</code></pre>
<p>However, this does not work. The variable <code>output.communicate()[0]</code> simply gives me a printout of git usage -- essentially telling me the input command is wrong.</p>
<p>I saw that a similar question <a href="https://stackoverflow.com/questions/30328207/git-command-doesnt-work-in-subprocess-in-python">exists here</a>, but it only told me to use <code>shell=True</code> which didn't solve my problem.</p>
<p>I also attempted to run the two commands in succession, but that gave me the same output as before. It is possible that I am missing something in this step, though.</p>
<p>Any help or tips are appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Backticks and subprocess</h2>
<p>The backtick being a <strong>shell feature</strong>, you may not have a choice but to use <code>shell=True</code>, however pass in <strong>a shell command string</strong>, not a list of args</p>
<p>So for your particular command (assuming it works in the first place)</p>
<pre><code>process = subprocess.Popen("git diff --name-only mybranch `git merge-base mybranch develop`", stdout=subprocess.PIPE, shell=True)
</code></pre>
<p>Notice when you call <code>Popen()</code> you get a process, shouldn't be called <code>output</code> IMO</p>
<p><strong>Here's a simple example that works with backticks</strong></p>
<pre><code>&gt;&gt;&gt; process = subprocess.Popen('echo `pwd`', stdout=subprocess.PIPE, shell=True)
&gt;&gt;&gt; out, err = process.communicate()
&gt;&gt;&gt; out
'/Users/bakkal\n'
</code></pre>
<p><strong>Or you can use the $(cmd) syntax</strong></p>
<pre><code>&gt;&gt;&gt; process = subprocess.Popen('echo $(pwd)', stdout=subprocess.PIPE, shell=True)
&gt;&gt;&gt; out, err = process.communicate()
&gt;&gt;&gt; out
'/Users/bakkal\n'
</code></pre>
<p><strong>Here's what did NOT work (for backticks)</strong></p>
<pre><code>&gt;&gt;&gt; process = subprocess.Popen(['echo', '`pwd`'], stdout=subprocess.PIPE, shell=True)
&gt;&gt;&gt; out, err = process.communicate()
&gt;&gt;&gt; out
'\n'
&gt;&gt;&gt; process = subprocess.Popen(['echo', '`pwd`'], stdout=subprocess.PIPE, shell=False)
&gt;&gt;&gt; out, err = process.communicate()
&gt;&gt;&gt; out
'`pwd`\n'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>On POSIX, the argument list is passed to <code>/bin/sh -c</code> i.e., only the first argument is recognized as a shell command i.e., the shell runs <code>git</code> without any arguments that is why you see the usage info. You should pass the command as a string if you want to use <code>shell=True</code>. From <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="nofollow">the <code>subprocess</code> docs</a>:</p>
<blockquote>
<p>On POSIX with <code>shell=True</code>, the shell defaults to <code>/bin/sh</code>. If <code>args</code> is a
  string, the string specifies the command to execute through the shell.
  This means that the string must be formatted exactly as it would be
  when typed at the shell prompt. This includes, for example, quoting or
  backslash escaping filenames with spaces in them. If <code>args</code> is a
  sequence, the first item specifies the command string, and any
  additional items will be treated as additional arguments to the shell
  itself. That is to say, <code>Popen</code> does the equivalent of:</p>
<pre><code>Popen(['/bin/sh', '-c', args[0], args[1], ...])
</code></pre>
</blockquote>
<p>You don't need <code>shell=True</code> in this case.</p>
<pre><code>#!/usr/bin/env python
from subprocess import check_output

merge_base_output = check_output('git merge-base mybranch develop'.split(), 
                                 universal_newlines=True).strip()
diff_output = check_output('git diff --name-only mybranch'.split() +
                           [merge_base_output])
</code></pre>
</div>
<span class="comment-copy">why are you trying to use shell=True and passing a list of args? Also why is git in a separate list?`</span>
<span class="comment-copy">The answer in the linked question said that using back-ticks would only work with shell=True. They are in separate lists for no particular reason, I'll edit to avoid confusion.</span>
<span class="comment-copy">You should either use a string with shell=True or remove shell=True and pass a list of individual args</span>
<span class="comment-copy">Thank you, this was the answer. I must have missed this in the docs.</span>
<span class="comment-copy">Note that backticks are deprecated in Bash: the <code>$(cmd)</code> syntax is less prone to being mis-read, and you can nest it if necessary. See <a href="http://mywiki.wooledge.org/BashFAQ/082" rel="nofollow noreferrer">BashFAQ/082</a> "Why is $(...) preferred over (backticks)?" in the BashGuide for further details. Also, backticks are a pain to write in SO comments. :)</span>
<span class="comment-copy">@PM2Ring Added a sample using <code>$(cmd)</code> with <code>subprocess</code></span>
<span class="comment-copy">Thanks. I decided to move my comment to the question, since it's probably more appropriate there.</span>
<span class="comment-copy">you <i>have</i> a choice, you can <a href="http://stackoverflow.com/a/31521714/4279">drop <code>shell=True</code></a></span>
<span class="comment-copy">You'd have to do the backtick expansion manually, because from my trials it doesn't seem you can expand backticks or <code>$(cmd)</code> without <code>shell=True</code>, backticks being the crux of the question</span>
