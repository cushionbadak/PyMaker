<div class="post-text" itemprop="text">
<p>I am writing a Java collection class that is meant to be used with Jython. I want end users to be able to manipulate the collection this way:</p>
<pre class="lang-java prettyprint-override"><code>myCollection = MyJavaCollection()
myCollection[0] += 10.;
a = myCollection[0]; //a = 10
myCollection[0] += 20.;
b = myCollection[0]; //b = 20
</code></pre>
<p>What I find in the Python documentation is the following methods:</p>
<ul>
<li><p><code>__getitem__</code> and <code>__setitem__</code> methods should do the job for bracket operator overloading.</p></li>
<li><p><code>__iadd__</code> method is the good candidate for the <code>+=</code>.</p></li>
</ul>
<p>How can I mix both to do want I want ? </p>
</div>
<div class="post-text" itemprop="text">
<p>Note that <code>myCollection[0] += 10.;</code> will really be interpreted something like:</p>
<pre><code>myCollection.__setitem__(0,  myCollection.__getitem__(0).__iadd__(10.))
</code></pre>
<p>Therefore, to make this work you need to implement:</p>
<ul>
<li><code>__getitem__</code> and <code>__setitem__</code> on <code>MyJavaCollection</code>; and</li>
<li><code>__iadd__</code> (or <code>__add__</code>, which Python will fall back to if <code>__iadd__</code> isn't implemented) on <em>whatever <code>.__getitem__</code> is going to return</em>, not <code>MyJavaCollection</code> itself - if it will return something that already implements addition, like the <code>float</code>s in your example, you're fine.</li>
</ul>
<hr/>
<p>A quick demonstration:</p>
<pre><code>&gt;&gt;&gt; class Container(object):

    def __init__(self, contained):
        self.contained = contained

    def __getitem__(self, key):
        print "Container.__getitem__"
        return self.contained

    def __setitem__(self, key, val):
        print "Container.__setitem__"
        self.contained = val


&gt;&gt;&gt; class Contained(object):

    def __add__(self, other):
        print "Contained.__add__"
        return "foo"


&gt;&gt;&gt; test = Container(Contained())
&gt;&gt;&gt; test[0] += 1
Container.__getitem__
Contained.__add__
Container.__setitem__
&gt;&gt;&gt; test.contained
'foo'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your original question had a list passed as the index, so I wrote this assuming that you wanted to access the <code>(i, j)</code>th element of a 2D list. You can do that by defining your class with something like:</p>
<pre><code>class MyJavaCollection:
    def __init__(self, values):
        self.values = values

    def __getitem__(self, indices):
        """
        Returns the item at index (i, j) given an index list [i, j].
        """
        return self.values[indices[0]][indices[1]]

    def __setitem__(self, indices, value):
        """
        Sets the (i, j)th item to the input value given an input
        index list [i, j].
        """
        self.values[indices[0]][indices[1]] = value
</code></pre>
<p>Here you are overloading the <code>__getitem__</code> and <code>__setitem__</code> methods to retrieve or set the <code>(i, j)</code>th element in your <code>values</code> list when you pass a list of indices <code>[i, j]</code>. If your values are just numbers, then the syntax <code>myCollection([1, 1]) += 10</code> will add <code>10</code> to <code>values[1][1]</code>.</p>
<p>As stated in another answer, if you are not simply storing numbers in your object, then you may need to overwrite the <code>__add__</code> or <code>__iadd__</code> method on whatever class your data comprises to get the behavior that you want.</p>
<p>Testing my example class:</p>
<pre><code>&gt;&gt; my_list = [[1, 2, 3], [4, 5, 6]]
&gt;&gt; my_list[1][1]
   5
&gt;&gt; my_collect = MyJavaCollection(my_list)
&gt;&gt; my_collect[[1, 1]]
   5
&gt;&gt; my_collect[[1, 1]] += 5
&gt;&gt; my_collect[[1, 1]]
   10
</code></pre>
<p>The <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow">documentation on special method names</a> gives you everything you could want to know about special methods like this. It can be a good place to search if you are not sure what method you may need to overload.</p>
</div>
<span class="comment-copy">What is this code supposed to do? Sets are unhashable and cannot be used this way, and even if you mean <code>myCollection</code> is a list containing only a 2-element set, I cannot understand how you mean it to look after this operation is complete.</span>
<span class="comment-copy">edited the example to explain results I expect. Removed the index as list and replaced it by a simple int.</span>
<span class="comment-copy">Thanks, editors. This is a nice-looking question now!</span>
<span class="comment-copy">Wait, do you want a list index, or just a single index? With a single index a simple list already does what you are asking for, except that you seem to want the value at <code>myCollection[0]</code> to reset to zero once it's been read? Otherwise <code>b = 30</code> no?</span>
<span class="comment-copy">Small addendum, python will still try to invoke <code>Contained.__iadd__</code>, only resorting to <code>Contained.__add__</code> if <code>__iadd__</code> was not present. In this way if a <code>Container</code> had a list then the list would be mutated inplace rather than a new list being created.</span>
<span class="comment-copy">@Dunes good point; editing, thank you</span>
<span class="comment-copy">really nice trick ! Thank you !</span>
