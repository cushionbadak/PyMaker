<div class="post-text" itemprop="text">
<p>Let us assume we have three lists:</p>
<pre><code>foo = [1, 2, 3]
bar = [4, 5, 6]
baz = [7, 8, 9]
</code></pre>
<p>If I do <code>list(zip(foo, bar, baz))</code> I get a list that looks like this (and this is what I actually want as an end result):</p>
<pre><code>[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
</code></pre>
<p>What I however couldn't get easily get to work was applying <code>zip</code> "iteratively", i.e. applying it to <code>foo</code> and <code>bar</code> and then at a later stage applying <code>zip</code> to <code>baz</code> again. Something like this:</p>
<pre><code>list(zip(list(zip(foo, bar)), baz))
</code></pre>
<p>gives me the following result:</p>
<pre><code>[((1, 4), 7), ((2, 5), 8), ((3, 6), 9)]
</code></pre>
<p>and is not quite what I want. When I played around with it I discovered that:</p>
<pre><code> ls = list(zip(*list(zip(foo, bar))))
 ls.append(baz)
 list(zip(*ls))
</code></pre>
<p>does exactly what I want and gives me:</p>
<pre><code>[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
</code></pre>
<p>Does anyone know of a better way of doing this? I feel that my solution is overly complicated for what should be quite simple.</p>
</div>
<div class="post-text" itemprop="text">
<p>To demystify the code you've written so far, do this:</p>
<pre><code>def transpose(rows):
    return list(zip(*rows))
</code></pre>
<p>Now it's easier to see why after doing <code>m = transpose([foo,bar])</code>, the way to add an extra <em>column</em> to your matrix is to do:</p>
<pre><code>t = transpose(m)
t.append(baz)
transpose(t)
</code></pre>
<p>Or:</p>
<pre><code>transpose(transpose(m) + [baz])
</code></pre>
<p>But you can also see from this that the code in johnrsharpe's answer is likely to be more efficient for larger examples, since it creates fewer intermediate objects that you don't keep. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you make the result a list of <em>lists</em>, rather than of <em>tuples</em>, you can <code>append</code> to them:</p>
<pre><code>&gt;&gt;&gt; out = list(map(list, zip(foo, bar)))
&gt;&gt;&gt; out
[[1, 1], [2, 2], [3, 3]]
&gt;&gt;&gt; for old, new in zip(out, baz):
    old.append(new)


&gt;&gt;&gt; out
[[1, 1, 1], [2, 2, 2], [3, 3, 3]]
</code></pre>
<p>If you stick with tuples you can use tuple addition to add the <code>new</code> element, e.g. within a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a>:</p>
<pre><code>&gt;&gt;&gt; out = list(zip(foo, bar))
&gt;&gt;&gt; out[:] = [old + (new,) for old, new in zip(out, baz)]
&gt;&gt;&gt; out
[(1, 1, 1), (2, 2, 2), (3, 3, 3)]
</code></pre>
<p>Otherwise, I think what you have is as neat as it's going to get.</p>
</div>
<span class="comment-copy">you want to get it without using the zip?</span>
<span class="comment-copy">No, I don't want to get away with zip. I want to apply zip to foo and bar first, store the intermediate result and then at a later stage apply zip the to the intermediate result and baz</span>
<span class="comment-copy">This makes so much sense. Thanks a lot.</span>
