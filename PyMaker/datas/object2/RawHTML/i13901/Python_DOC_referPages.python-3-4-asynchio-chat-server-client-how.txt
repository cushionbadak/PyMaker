<div class="post-text" itemprop="text">
<p>I am working on a Python 3.4 chat asynchio server and client but I have having a little trouble porting the client to asynchio.</p>
<p>Here's the link for your reference.</p>
<p><a href="https://docs.python.org/3/library/asyncio-protocol.html#tcp-echo-client-protocol" rel="nofollow">18.5.4.3.1. TCP echo client protocol</a></p>
<p>My working asynchio working chat server code below:</p>
<pre><code>import asyncio

clients = []

class SimpleChatClientProtocol(asyncio.Protocol):
    def connection_made(self, transport):
        self.transport = transport
        peername = transport.get_extra_info("peername")
        self.username = "{:s}:{:d}".format(*peername)
        print("connection_made: {}".format(self.username))

        for client in clients:
            client.send("{:s} connected".format(self.username))

        clients.append(self)

    def send(self, text):
        self.transport.write("{:s}\n".format(text).encode())

    def data_received(self, data):
        print("data_received: {}".format(data.decode()))

        incoming = data.decode()

        if len(incoming) == 0:
            return

        if incoming.find("/") == 0:
            parts = incoming.split()

            command = parts[0]

            print("found command block: {:s}".format(command))

            if command == "/username":
                if len(parts) != 2:
                    self.send("&lt; command: invalid payload! Usage: /username &lt;username&gt;")
                    return

                print("{:s} changing username to {:s}".format(self.username, parts[1]))

                for client in clients:
                    if client != self:
                        client.send("{:s} changed username to {:s}".format(self.username, parts[1]))

                self.username = parts[1]
                self.send("&lt; username changed")

                return

            elif command == "/whisper":
                if len(parts) &lt; 3:
                    self.send("&lt; command: invalid payload! Usage: /w &lt;username&gt; &lt;message&gt;")
                    return

                for client in clients:
                    if client.username == parts[1]:
                        client.send("{:s} whispered: {:s}".format(self.username, " ".join(parts[2:])))
                        return

                self.send("&lt; command: whisper target username not found!")
                return

            elif command == "/exit":
                self.send("&lt; command: disconnecting, bye!")
                print("client_disconnect: {:s}".format(self.username))
                self.transport.close()
                return

        for client in clients:
            if client is not self:
                client.send("{:s} wrote: {:s}".format(self.username, incoming))

    def connection_lost(self, ex):
        print("connection_lost: {}".format(self.username))
        clients.remove(self)

        for client in clients:
            client.send("{:s} disconnected".format(self.username))

if __name__ == '__main__':
    print("starting up..")

    loop = asyncio.get_event_loop()
    coro = loop.create_server(SimpleChatClientProtocol, '127.0.0.1', 8888)
    server = loop.run_until_complete(coro)

    for socket in server.sockets:
        print("serving on {}".format(socket.getsockname()))

    loop.run_forever()
</code></pre>
<p>My Old working Threaded chat client code below:</p>
<pre><code>from socket import *
from threading import Thread

host = '127.0.0.1'
port = 8888
s = socket(AF_INET, SOCK_STREAM)
s.connect((host, port))

def Listener():
    try:
        while True:
            data = s.recv(1024).decode('utf-8')
            print('&gt;', data)
    except ConnectionAbortedError:
        pass

t = Thread(target=Listener)
t.start()

try:
    while True:
        message = input('&gt;')
        s.send(message.encode('utf-8'))
except EOFError:
    pass
finally:
    s.close()
</code></pre>
<p>Using the link below as reference, can anyone help me modify it so that it sends messages via shell input like my old client code?</p>
<p>Thank you so much for any help.</p>
<p><a href="https://docs.python.org/3/library/asyncio-protocol.html#tcp-echo-client-protocol" rel="nofollow">18.5.4.3.1. TCP echo client protocol</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If I'm understanding your question correctly, you want to broadcast messages from <code>STDIN</code> to every connected client, is that right?</p>
<p>Here try this:</p>
<pre><code>import asyncio

clients = []

class SimpleChatClientProtocol(asyncio.Protocol):
    def connection_made(self, transport):
        self.transport = transport
        peername = transport.get_extra_info("peername")
        self.username = "{:s}:{:d}".format(*peername)
        print("connection_made: {}".format(self.username))

        for client in clients:
            client.send("{:s} connected".format(self.username))

        clients.append(self)

    def send(self, text):
        self.transport.write("{:s}\n".format(text).encode())

    def data_received(self, data):
        print("data_received: {}".format(data.decode()))

        incoming = data.decode()

        if len(incoming) == 0:
            return

        if incoming.find("/") == 0:
            parts = incoming.split()

            command = parts[0]

            print("found command block: {:s}".format(command))

            if command == "/username":
                if len(parts) != 2:
                    self.send("&lt; command: invalid payload! Usage: /username &lt;username&gt;")
                    return

                print("{:s} changing username to {:s}".format(self.username, parts[1]))

                for client in clients:
                    if client != self:
                        client.send("{:s} changed username to {:s}".format(self.username, parts[1]))

                self.username = parts[1]
                self.send("&lt; username changed")

                return

            elif command == "/whisper":
                if len(parts) &lt; 3:
                    self.send("&lt; command: invalid payload! Usage: /w &lt;username&gt; &lt;message&gt;")
                    return

                for client in clients:
                    if client.username == parts[1]:
                        client.send("{:s} whispered: {:s}".format(self.username, " ".join(parts[2:])))
                        return

                self.send("&lt; command: whisper target username not found!")
                return

            elif command == "/exit":
                self.send("&lt; command: disconnecting, bye!")
                print("client_disconnect: {:s}".format(self.username))
                self.transport.close()
                return

        for client in clients:
            if client is not self:
                client.send("{:s} wrote: {:s}".format(self.username, incoming))

    def connection_lost(self, ex):
        print("connection_lost: {}".format(self.username))
        clients.remove(self)

        for client in clients:
            client.send("{:s} disconnected".format(self.username))

@asyncio.coroutine
def send_from_stdin(loop):
  while True:
    message = yield from loop.run_in_executor(None, input, "&gt;")
    for client in clients:
      client.send(message)

if __name__ == '__main__':
    print("starting up..")

    loop = asyncio.get_event_loop()
    coro = loop.create_server(SimpleChatClientProtocol, '127.0.0.1', 8888)
    server = loop.run_until_complete(coro)

    # Start a task which reads from STDIN and pushes to clients.
    asyncio.async(send_from_stdin(loop))

    for socket in server.sockets:
        print("serving on {}".format(socket.getsockname()))

    loop.run_forever()
</code></pre>
<p>The trick is to async-ize the <code>input</code> function by running it in a thread (this is what <code>run_in_executor</code> does). This way when you are waiting for data from <code>STDIN</code> you don't block the entire loop.</p>
</div>
