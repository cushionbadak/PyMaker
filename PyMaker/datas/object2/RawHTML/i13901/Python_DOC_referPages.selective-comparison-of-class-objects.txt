<div class="post-text" itemprop="text">
<p>I need to make multiple comparisons of class objects. However, only values of selected fields are subject to comparison, i.e.:</p>
<pre><code>class Class:
    def __init__(self, value1, value2, value3, dummy_value):
        self.field1 = value1
        self.field2 = value2
        self.field3 = value3
        self.irrelevant_field = dummy_value

obj1 = Class(1, 2, 3, 'a')
obj2 = Class(1, 2, 3, 'b') #compare(obj1, obj2) = True
obj3 = Class(1, 2, 4, 'a') #compare(obj1, obj3) = False
</code></pre>
<p>Currently I do it this way:</p>
<pre><code>def dumm_compare(obj1, obj2):
    if obj1.field1 != obj2.field1:
        return False
    if obj1.field2 != obj2.field2:
        return False
    if obj1.field3 != obj2.field3:
        return False
    return True
</code></pre>
<p>As my actual number of relevant fields is greater than 10, this approach leads to quite bulky code. That's why I tried something like this:</p>
<pre><code>def cute_compare(obj1, obj2):
    for field in filter(lambda x: x.startswith('field'), dir(obj1)):
        if getattr(obj1, field) != getattr(obj2, field):
            return False
    return True
</code></pre>
<p>The code is compact; however, the performance suffers significantly:</p>
<pre><code>import time

starttime = time.time()
for i in range(100000):
    dumm_compare(obj1, obj2)
print('Dumm compare runtime: {:.3f} s'.format(time.time() - starttime))

starttime = time.time()
for i in range(100000):
    cute_compare(obj1, obj2)
print('Cute compare runtime: {:.3f} s'.format(time.time() - start time))

#Dumm compare runtime: 0.046 s
#Cute compare runtime: 1.603 s
</code></pre>
<p>Is there a way to implement selective object comparison more efficiently?</p>
<p><strong>EDIT:</strong> 
In fact I need several such functions (which compare objects by different, sometimes overlapping, sets of fields). That's why I do not want to overwrite built-in class methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the fields exist for all instances in one particular comparison set, 
try saving the list to compare to the class.</p>
<pre><code>def prepped_compare(obj1, obj2):
    li_field = getattr(obj1, "li_field", None)
    if li_field  is None:
        #grab the list from the compare object, but this assumes a 
        #fixed fieldlist per run.
        #mind you getattr(obj,non-existentfield) blows up anyway
        #so y'all making that assumption already
        li_field = [f for f in vars(obj1) if f.startswith('field')]
        obj1.__class__.li_field = li_field

    for field in li_field:
        if getattr(obj1, field) != getattr(obj2, field):
            return False
    return True    
</code></pre>
<p>or pre-compute outside, better</p>
<pre><code>def prepped_compare2(obj1, obj2, li_field):

    for field in li_field:
        if getattr(obj1, field) != getattr(obj2, field):
            return False
    return True    


starttime = time.time()
li_field = [f for f in vars(obj1) if f.startswith('field')]
for i in range(100000):
    prepped_compare2(obj1, obj2, li_field)
print('prepped2 compare runtime: {:.3f} s'.format(time.time() - starttime))
</code></pre>
<p>output:</p>
<pre><code>Dumm compare runtime: 0.051 s
Cute compare runtime: 0.762 s
prepped compare runtime: 0.122 s
prepped2 compare runtime: 0.093 s
</code></pre>
<p>re. overriding <em>eq</em>, I am pretty sure you could have something like.</p>
<pre><code>def mycomp01(self, obj2) #possibly with a saved field list01 on the class
def mycomp02(self, obj2) #possibly with a saved field list02 on the class

#let's do comp01.
Class.__eq__ = mycomp01
run comp01 tests
Class.__eq__ = mycomp02
run comp02 tests
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>dir()</code> not only includes instance attributes, but it'll traverse the class hierarchy as well. As such it does much more work than is needed here; <code>dir()</code> is really only suitable for debugging tasks.</p>
<p>Stick to using <a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow"><code>vars()</code></a> instead, perhaps combined with <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow"><code>any()</code></a>:</p>
<pre><code>def faster_compare(obj1, obj2):
    obj2_vars = vars(obj2)
    return all(value == obj2_vars[field]
               for field, value in vars(obj1).items() if field.startswith('field'))
</code></pre>
<p><code>vars()</code> returns a dictionary containing the attributes of the instance only; in the above generator expression I access both the attribute name and its value in one step by using the <code>dict.items()</code> method.</p>
<p>I replaced the <code>getattr()</code> method call for <code>obj2</code> to use the same dictionary approach, this saves a framestack push and pop each time as the key lookup can be handled in bytecode (C code) entirely. Note that this does assume you are not using properties; only actual instance attributes are going to be listed.</p>
<p>This method still has to do more work than hardcoding the <code>if</code> branches, but it is at least not performing all that bad:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; timeit('compare(obj1, obj2)', 'from __main__ import obj1, obj2, dumm_compare as compare')
0.349234500026796
&gt;&gt;&gt; timeit('compare(obj1, obj2)', 'from __main__ import obj1, obj2, cute_compare as compare')
16.48695448896615
&gt;&gt;&gt; timeit('compare(obj1, obj2)', 'from __main__ import obj1, obj2, faster_compare as compare')
1.9555692840367556
</code></pre>
</div>
<span class="comment-copy">Do you know in advance how many fields there are?</span>
<span class="comment-copy">It would be quicker to be explicit about the fields that <i>should</i> be compared, e.g. with a class attribute <code>COMPARE_FIELDS = ['field1', 'field2', ...]</code>, then iterate over that.</span>
<span class="comment-copy">shouldn't that be <code>return not any(value != obj2_vars[field]...</code> ?</span>
<span class="comment-copy">@overactor: oops, inversion trip-up there. No, it should be using <code>all()</code> instead.</span>
