<div class="post-text" itemprop="text">
<p>I have a question understanding the queue in the <code>multiprocessing</code> module in python 3</p>
<p>This is what they say in the <a href="https://docs.python.org/3/library/multiprocessing.html#all-start-methods" rel="noreferrer">programming guidelines</a>:</p>
<blockquote>
<p>Bear in mind that a process that has put items in a queue will wait before
terminating until all the buffered items are fed by the “feeder” thread to
the underlying pipe.  (The child process can call the
Queue.cancel_join_thread
method of the queue to avoid this behaviour.)</p>
<p>This means that whenever you use a queue you need to make sure that all
items which have been put on the queue will eventually be removed before the
process is joined.  Otherwise you cannot be sure that processes which have
put items on the queue will terminate.  Remember also that non-daemonic
processes will be joined automatically.</p>
<p>An example which will deadlock is the following:</p>
<pre>from multiprocessing import Process, Queue

def f(q):
    q.put('X' * 1000000)

if __name__ == '__main__':
    queue = Queue()
    p = Process(target=f, args=(queue,))
    p.start()
    p.join()                    # this deadlocks
    obj = queue.get()
</pre>
<p>A fix here would be to swap the last two lines (or simply remove the
p.join() line).</p>
</blockquote>
<p>So apparently, <code>queue.get()</code> should not be called after a <code>join()</code>.</p>
<p>However there are examples of using queues where <code>get</code> is called after a <code>join</code> like:</p>
<pre><code>import multiprocessing as mp
import random
import string

# define a example function
def rand_string(length, output):
    """ Generates a random string of numbers, lower- and uppercase chars. """
    rand_str = ''.join(random.choice(
                string.ascii_lowercase
                + string.ascii_uppercase
                + string.digits)
    for i in range(length))
        output.put(rand_str)

 if __name__ == "__main__":
     # Define an output queue
     output = mp.Queue()

     # Setup a list of processes that we want to run
     processes = [mp.Process(target=rand_string, args=(5, output))
                    for x in range(2)]

     # Run processes
    for p in processes:
        p.start()

    # Exit the completed processes
    for p in processes:
        p.join()

    # Get process results from the output queue
    results = [output.get() for p in processes]

    print(results)
</code></pre>
<p>I've run this program and it works (also posted as a solution to the StackOverFlow question <a href="https://stackoverflow.com/questions/29904010/python-3-multiprocessing-queue-get-does-not-respond">Python 3 - Multiprocessing - Queue.get() does not respond</a>).</p>
<p>Could someone help me understand what the rule for the deadlock is here?</p>
</div>
<div class="post-text" itemprop="text">
<p>The queue implementation in multiprocessing that allows data to be transferred between processes relies on standard OS pipes.</p>
<p>OS pipes are not infinitely long, so the process which queues data could be blocked in the OS during the <code>put()</code> operation until some other process uses <code>get()</code> to retrieve data from the queue.</p>
<p>For small amounts of data, such as the one in your example,  the main process can <code>join()</code> all the spawned subprocesses and then pick up the data.  This often works well, but does not scale, and it is not clear when it will break.</p>
<p>But it will certainly break with large amounts of data.  The subprocess will be blocked in <code>put()</code> waiting for the main process to remove some data from the queue with <code>get()</code>, but the main process is blocked in <code>join()</code> waiting for the subprocess to finish.  This results in a deadlock.</p>
<p>Here is an example where a user had <a href="https://stackoverflow.com/questions/31708646/process-join-and-queue-dont-work-with-large-numbers">this exact issue</a>.  I posted some code in an answer there that helped him solve his problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't call <code>join()</code> on a process object before you got all messages from the shared queue.</p>
<p>I used following workaround to allow processes to exit before processing all its results:</p>
<pre><code>results = []
while True:
    try:
        result = resultQueue.get(False, 0.01)
        results.append(result)
    except queue.Empty:
        pass
    allExited = True
    for t in processes:
        if t.exitcode is None:
            allExited = False
            break
    if allExited &amp; resultQueue.empty():
        break
</code></pre>
<p>It can be shortened but I left it longer to be more clear for newbies.</p>
<p>Here <code>resultQueue</code> is the <code>multiprocess.Queue</code> that was shared with <code>multiprocess.Process</code> objects. After this block of code you will get the <code>result</code> array with all the messages from the queue.</p>
<p>The problem is that input buffer of the queue pipe that receive messages may become full causing writer(s) infinite block until there will be enough space to receive next message. So you have three ways to avoid blocking:</p>
<ul>
<li>Increase the <code>multiprocessing.connection.BUFFER</code> size (not so good)</li>
<li>Decrease message size or its amount (not so good)</li>
<li>Fetch messages from the queue immediately as they come (good way)</li>
</ul>
</div>
<span class="comment-copy">I understand your OS pipe explanation but I have a question here: If I call q.get() before the process has finished execution, say its an HTTP Longpoll Get request, will the q.get() wait for the response/timeout ? Is there a possibility that the process returns at mp.join() which is after my q.get() and I miss that return value?</span>
<span class="comment-copy">It depends on how you set the q.get() block and timeout parameters.</span>
