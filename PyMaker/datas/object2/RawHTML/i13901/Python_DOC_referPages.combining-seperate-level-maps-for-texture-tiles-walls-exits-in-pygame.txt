<div class="post-text" itemprop="text">
<p>I am trying to have 2 separate lists that turn into one tile map.</p>
<ol>
<li>is for placement of the color block or textures </li>
<li>is to hold the placement of walls** and a exit point.</li>
</ol>
<p><strong>I am using two different method of creating a tile using characters to represent the tiles. I can get both methods to work separately but would like to combine or use them both?</strong></p>
<p>I would ideally like <strong>to know how to combine the two the results from the 2 lists</strong>, </p>
<pre><code>#map of the colors or textured tiles
level1tile = ["------",
              "-$$---",
              "-$^^$-",
              "------"
    ]
#level1tile is a simple mapping: char -&gt; colour
colors = {'X': pygame.color.THECOLORS['blue'],
          '-': pygame.color.THECOLORS['grey'],
          '^': pygame.color.THECOLORS['brown'] ]        
          }

#map of the walls and level exits
level1wall = ["WWWWWW",
              "W    E",
              "W WW W",
              "WWWWWW"
    ]
#level1wall is collision detection W = wall, E = exit, P = Player
</code></pre>
<ol>
<li>is for placement of the color block or textures </li>
<li>is to hold the placement of walls** and a exit point.</li>
</ol>
<p>I will be adding invisible items down the line so I want keep two separate maps so some titles can have the same texture as a wall or not.</p>
<p><strong>some examples of possible uses:</strong> 
1. you can walk trough some water tiles but not others
2. quicksand, invisible item or trap </p>
<p>So in the 1st map represent the <strong>water tile with X blue color</strong> </p>
<pre><code> colors = {'X': pygame.color.THECOLORS['blue']}
</code></pre>
<p>In the 2nd I represent the the <strong>water with W for the wall</strong> collision detection.</p>
<p>I am blocking off area by using a W for a wall for collision detection in this example the blue color or water and the grey color or rock tiles are areas the player can not walk.</p>
<p><img alt="Background titles" src="https://i.stack.imgur.com/9ytYw.png"/></p>
<p>I am blocking off area by using a W for a wall for collision detection in this example the blue color or water and the grey color or rock tiles are areas the player can not walk. But I want retain two maps in case I want to add invisible areas or maybe some water you can walk on, etc.</p>
<p><img alt="Method 1" src="https://i.stack.imgur.com/LN2x4.png"/></p>
<pre><code>level = ["WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
         "W           WWWWWWWWW WW          EW",
         "W            WWWWWWW               W",
         "W           WW             WWW     W",
         "W          WW             WWWWW    W",
         "W                        WWWWWWW   W",
         "W                        WWWWWW    W",
         "W                        WWWWWWW   W",
         "W                         WWWWWW   W",
         "W                            WW    W",
         "W                                  W",
         "W                W                 W",
         "W               WWW                W",
         "W              WWWWW               W",
         "W              WWWWW               W",
         "W             WWWWW                W",
         "W              WWWWWW              W",
         "W                 WWW              W",
         "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW"]


# W = wall, E = exit, P = Player
x = y = 0
for row in level:
    for col in row:
        if col == "W":
            Wall((x, y))
        if col == "E":
            end_rect = pygame.Rect(x, y, 32, 32)
        x += 32
    y += 32
    x = 0
</code></pre>
<p>I am creating the color or texture tile map using a technique I learn off reading a member Sloth posts here. </p>
<pre><code>levelB = ["------------------------------------",
         "-  $$$$$$$$$--------- --   $ $ $ $E-",
         "- $  $$$$$$$$-------^^^^         $$-",
         "-$ $$$$$$$$ --     ^^^^    XXX    $-",
         "-  $$$$$$$ --  $  ^^^^    XXXXX    -",
         "-    $$$$$$$      ^^^^   XXXXXXX   -",
         "- $$$$$$$$$$      ^^^^   XXXXXX    -",
         "-    $$$$$$$$     ^^^^   XXXXXXX   -",
         "-$$$$$$$$$$$$$$  ^^^^     XXXXXX   -",
         "-     $$$$$$$   ^^^^         XX    -",
         "-  $ $$$       ^^^^        $ $ $ $ -",
         "- $$$$$$     ^^^^-         $$$$$$$$-",
         "-  $$$$$$   ^^^^---      $$$$$ $ $ -",
         "- $$$$$    ^^^^-----        $$$$$$$-",
         "- $$$$$$$  ^^^^-----       $ $ $ $ -",
         "- $$$$$$$ ^^^^-----       $$$$$$ $$-",
         "-  $$$$$$ ^^^^ ------      $ $ $ $ -",
         "- $$$$$$$$  ^^^^  ---            $$-",
         "------------------------------------"]
#a simple mapping: char -&gt; colour
colors = {'X': pygame.color.THECOLORS['blue'],
          '-': pygame.color.THECOLORS['grey'],
          '$': pygame.color.THECOLORS['green'],
          '^': pygame.color.THECOLORS['brown'], 
          'E': pygame.color.THECOLORS['black']        
          }

blocksize = 32
</code></pre>
<p>I will be swapping out the colors with a texture map</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/GiH3c.png"/></p>
<p><strong>#######################################</strong></p>
<p><a href="https://i.stack.imgur.com/y99CC.jpg" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/y99CC.jpg"/></a></p>
<p>below is my attempt following the answer provided still I have only got it to preform half the check.</p>
<p><strong>Full Source</strong></p>
<pre><code>import os
import random
import pygame

#map of the colors or textured tiles
level1tile = ["------------------------------------",
         "-  $$$$$$$$$--------- --   $ $ $ $E-",
         "- $  $$$$$$$$-------^^^^         $$-",
         "-$ $$$$$$$$ --     ^^^^    XXX    $-",
         "-  $$$$$$$ --  $  ^^^^    XXXXX    -",
         "-    $$$$$$$      ^^^^   XXXXXXX   -",
         "- $$$$$$$$$$      ^^^^   XXXXXX    -",
         "-    $$$$$$$$     ^^^^   XXXXXXX   -",
         "-$$$$$$$$$$$$$$  ^^^^     XXXXXX   -",
         "-     $$$$$$$   ^^^^         XX    -",
         "-  $ $$$       ^^^^        $ $ $ $ -",
         "- $$$$$$     ^^^^-         $$$$$$$$-",
         "-  $$$$$$   ^^^^---      $$$$$ $ $ -",
         "- $$$$$    ^^^^-----        $$$$$$$-",
         "- $$$$$$$  ^^^^-----       $ $ $ $ -",
         "- $$$$$$$ ^^^^-----       $$$$$$ $$-",
         "-  $$$$$$ ^^^^ ------      $ $ $ $ -",
         "- $$$$$$$$  ^^^^  ---            $$-",
         "------------------------------------"]
#a simple mapping: char -&gt; color
colors = {'X': pygame.color.THECOLORS['blue'],
          '-': pygame.color.THECOLORS['grey'],
          '$': pygame.color.THECOLORS['green'],
          '^': pygame.color.THECOLORS['brown'], 
          'E': pygame.color.THECOLORS['black']        
          }

blocksize = 32
#map of the walls and level exits
level1wall = ["WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
         "W           WWWWWWWWW WW          EW",
         "W            WWWWWWW               W",
         "W           WW             WWW     W",
         "W          WW             WWWWW    W",
         "W                        WWWWWWW   W",
         "W                        WWWWWW    W",
         "W                        WWWWWWW   W",
         "W                         WWWWWW   W",
         "W                            WW    W",
         "W                                  W",
         "W                W                 W",
         "W               WWW                W",
         "W              WWWWW               W",
         "W              WWWWW               W",
         "W             WWWWW                W",
         "W              WWWWWW              W",
         "W                 WWW              W",
         "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW"]


# Class for the Player object
class Player(object):

    def __init__(self):
        self.rect = pygame.Rect(32, 32, 16, 16)

    def move(self, dx, dy):

        # Move each axis separately. Note that this checks for collisions both times.
        if dx != 0:
            self.move_single_axis(dx, 0)
        if dy != 0:
            self.move_single_axis(0, dy)

    def move_single_axis(self, dx, dy):

        # Move the rect
        self.rect.x += dx
        self.rect.y += dy

        # If you collide with a wall, move out based on velocity
        for wall in walls:
            if self.rect.colliderect(wall.rect):
                if dx &gt; 0: # collide right
                    self.rect.right = wall.rect.left
                if dx &lt; 0: # collide left
                    self.rect.left = wall.rect.right
                if dy &gt; 0: # collide top
                    self.rect.bottom = wall.rect.top
                if dy &lt; 0: # collide bottom
                    self.rect.top = wall.rect.bottom

# Nice class to hold a wall rect
class Wall(object):

    def __init__(self, pos):
        walls.append(self)
        self.rect = pygame.Rect(pos[0], pos[1], 32, 32)
#level1wall is collision detection W = wall, E = exit, P = Player

#Block
class Block(pygame.sprite.Sprite):
    # Constructor. Pass in the color of the block, and its x and y position
    def __init__(self, color, width, height, x, y):
       # Call the parent class (Sprite) constructor
       pygame.sprite.Sprite.__init__(self)

       # Create an image of the block, and fill it with a color.
       # This could also be an image loaded from the disk.
       self.image = pygame.Surface([width, height])
       self.image.fill(color)

       # Fetch the rectangle object that has the dimensions of the image
       # Update the position of this object by setting the values of rect.x and rect.y
       self.rect = self.image.get_rect(top=y, left=x)

pygame.init()


# Set up the display
pygame.display.set_caption("Tiles and Walls!")
screen = pygame.display.set_mode((len(level[0])* blocksize, len(level*blocksize)))
#screen = pygame.display.set_mode((1150, 600))

clock = pygame.time.Clock()
walls = [] # List to hold the walls
player = Player() # Create the player


combined_list = []  # initialize a blank list
for i in range(len(level1tile)):  # build your new list
  combined_list.append(zip(level1tile[i], level1wall[i]))

    # Parse the level string above. W = wall, E = exit
x = y = 0
for row in level1wall:
    for col in row:
        if col == "W":
            Wall((x, y))
        if col == "E":
            end_rect = pygame.Rect(x, y, 32, 32)
        x += 32
    y += 32
    x = 0

running = True
while running:

    clock.tick(60)

    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            running = False
        if e.type == pygame.KEYDOWN and e.key == pygame.K_ESCAPE:
            running = False

    # Move the player if an arrow key is pressed
    key = pygame.key.get_pressed()
    if key[pygame.K_LEFT]:
        player.move(-2, 0)
    if key[pygame.K_RIGHT]:
        player.move(2, 0)
    if key[pygame.K_UP]:
        player.move(0, -2)
    if key[pygame.K_DOWN]:
        player.move(0, 2)

    # Just added this to make it slightly fun ;)
    if player.rect.colliderect(end_rect):
        raise SystemExit("Next Level!")

    # Draw the scene
    screen.fill((0, 0, 0))
    for wall in walls:
        pygame.draw.rect(screen, (255, 255, 255), wall.rect)
    pygame.draw.rect(screen, (255, 0, 0), end_rect)
    pygame.draw.rect(screen, (255, 200, 0), player.rect)
    pygame.display.flip()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Without Itertools</h3>
<p>I might recommend using the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip()</code></a> function in Python. Basically it takes two (or more) lists as arguments and returns a single list where each element is a tuple of the values of your original two lists at that location. For example, you could create a new list where at each location in your map you have a tuple <code>(tile, wall)</code>:</p>
<pre><code>combined_list = []  # initialize a blank list
for i in range(len(level1tile)):  # build your new list
  combined_list.append(zip(level1tile[i], level1wall[i]))
</code></pre>
<p>which, using your first example in your question, returns:</p>
<pre><code>combined_list = 
[[('-', 'W'), ('-', 'W'), ('-', 'W'), ('-', 'W'), ('-', 'W'), ('-', 'W')],
 [('-', 'W'), ('$', ' '), ('$', ' '), ('-', ' '), ('-', ' '), ('-', 'E')],
 [('-', 'W'), ('$', ' '), ('^', 'W'), ('^', 'W'), ('$', ' '), ('-', 'W')],
 [('-', 'W'), ('-', 'W'), ('-', 'W'), ('-', 'W'), ('-', 'W'), ('-', 'W')]]
</code></pre>
<p>You can then get the tile and wall status of any given location in the map, <code>(x, y)</code>, with something like:</p>
<pre><code>(tile, wall) = combined_list[x][y]
</code></pre>
<p>Then you can access <code>tile</code> and <code>wall</code> each individually:</p>
<pre><code>&gt;&gt; (tile, wall) = combined_list[1][0]
&gt;&gt; tile
    '-'
&gt;&gt; wall
    'W'
</code></pre>
<p>Is that along the lines of what you were looking for?</p>
<p>There is probably a really clever way to combine these two lists of strings with list comprehensions, but I could not quite get it to work for me.</p>
<h3>Edit: With Itertools</h3>
<p>There <em>is</em> a clever way to do this with <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow"><code>itertools</code></a>! Well, sort of. I could not quite retain your 2D layout, but instead managed to get all of the <code>(tile, wall)</code> tuples put into a single <code>1 x n*m</code>-length list (as opposed to an <code>n x m</code> 2D list) with this:</p>
<pre><code>import itertools as it
combined = list(it.izip(it.chain.from_iterable(level1tile), it.chain.from_iterable(level2tile)))
</code></pre>
<p>Now you can access the <code>(tile, wall)</code> values at position <code>(x, y)</code> with:</p>
<pre><code>(tile, wall) = combined[x + y*n]  # where "n" is how many columns you have in your map
</code></pre>
<p>There is probably <em>still</em> a more elegant way to do this with <code>itertools</code> (or without), but hopefully this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you're using characters to represent the tiles and the walls, you can concatenate them into a single string to combine the two list. The combined list will require less memory a provide faster access this way than would be required if they were put into lists or tuples of characters.</p>
<p>Afterwards, you can access the tile and wall character for a specific position directly with <code>combined[row][col][0]</code> and <code>combined[row][col][1]</code> respectively.</p>
<p>Using <code>itertools.izip()</code> instead of <code>zip()</code> reduces memory consumption because it eliminates the need to create temporary intermediate lists. Same goes for using <code>xrange()</code> instead of <code>range()</code>.</p>
<pre><code>try:
    from itertools import izip
except ImportError:  # Python3
    izip = zip
    xrange = range

combined = [tuple(tile+wall for tile, wall in zip(level1tile[i], level1wall[i]))
                for i in xrange(len(level1tile))]

from pprint import pprint
print('level1tile and level1wall combined:')
pprint(combined)
print('')

print('combined[1][5] -&gt; {!r}'.format(combined[1][5]))
tile, wall = combined[1][5]
print('after "tile, wall = combined[1][5]:"')
print('  tile, wall -&gt; {!r},{!r}'.format(tile, wall))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>level1tile and level1wall combined:
[('-W', '-W', '-W', '-W', '-W', '-W'),
 ('-W', '$ ', '$ ', '- ', '- ', '-E'),
 ('-W', '$ ', '^W', '^W', '$ ', '-W'),
 ('-W', '-W', '-W', '-W', '-W', '-W')]

combined[1][5] -&gt; '-E'
after "tile, wall = combined[1][5]:"
  tile, wall -&gt; '-','E'
</code></pre>
</div>
<span class="comment-copy">Not sure what you're asking. In general, if you have two dictionaries with a duplicate key, you could combine the values associated with it by putting both of them into a list and associating that with the key. That way no information is lost.</span>
<span class="comment-copy">Sorry about that I tried to reword it better, I was not using dictionaries that was bad wording on my part. I am trying combine two lists or sift through two list to render one result but hold both sets of values one of cosmetic tile look and another of walls and collisions.</span>
<span class="comment-copy">It helps a lot I understand the concept. I have both lists then combine using zip() then I have to step through each line and character and create a block &amp; wall at the right position till end. then process then next set. I will give the top method a try due to my own skill level or lack of one yet. but I will start wrapping my head around using itertools and due some reading to learn what I need to to it.</span>
<span class="comment-copy">I got the layout to work but when I combined them I only got one the walls to display. I added the full source of my attempt and a picture of the output to the above part</span>
<span class="comment-copy">In the code that you added, I can't tell that you are ever drawing anything other than the walls. You initialize the whole board to black with <code>screen.fill(0, 0, 0)</code>, and then draw the walls with your <code>for wall in walls: ...</code> loop after that. Are you concerned that your other textures are not showing up? You need to draw them first. Also, you are never using your <code>combined_list</code>, but maybe you have plans for that later?</span>
<span class="comment-copy">Yes, I was trying to render both both the walls and the tiles with or w/o them combined. I thought I used both I just assume I made mistake where the walls layer rendered over the tiles. Do i use for x in combined_list:   while True:   screen.fill((255, 204, 102))     for wall in walls:       pygame.draw.rect(screen, (255, 255, 255), wall.rect)   pygame.draw.rect(screen, (255, 0, 0), end_rect)   pygame.draw.rect(screen, (255, 200, 0), player.rect)    if pygame.event.get(pygame.QUIT):     break   pygame.event.poll()   level_blocks.draw(screen)   screen.blit(player,(x,y))   pygame.display.flip()</span>
