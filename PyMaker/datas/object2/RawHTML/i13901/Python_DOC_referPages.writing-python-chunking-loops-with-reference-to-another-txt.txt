<div class="post-text" itemprop="text">
<p>I've been working on this for a while and I'm getting pretty frustrated with it. Basically, I have two text documents that both have important information. The first document contains some information I want to extract (chromatin name, start point, and end point), and I want to use this information to search for information in the second text (I want to count the atgc for each chunk defined by the start and end point). So I am trying to extract the start-end sequence numbers, and then use those to chunk and count the frequencies of atcg for each of the frequencies. I feel like I am getting close, but my biggest problem is how can I use the start and end points I extracted from the first text, and use them as start and end points in making chunks in the second? </p>
<p>Here is what I have so far:</p>
<pre><code>from __future__ import division
import nltk, re, pprint, subprocess

f = open('first_text.txt') #this text has chromatin name, start/end points
raw = f.read()
raw = read.lower ()
l = raw.splitlines() #these next few lines are just for formatting
l = [re.sub(r'\t', '', l) for l in l] #and getting rid of stuff I don't want

datas = []
for elem in l:
    datas.append(elem.strip().split(' '))

wanted_stuff = []
for datas in datas:
    wanted_stuff.append(datas[0:3]) #extracting chromatin name, start, end
    # and making a list of [name, start, end]'s.
    # for example: ['chr1', '10000', '106000'] is on one line, etc. 
    # next line is another ['chrx', 'start number', 'end number'], and so on

chroms = []
starts = []
ends = []
for wanted_stuff in wanted_stuff:
    chroms.append(wanted_stuff[0])
    starts.append(wanted_stuff[1])
    ends.append(wanted_stuff[2])    

start_stop = [slice(int(starts), int(stops)) for chroms, starts, stops in wanted_stuff]

print start_stop # ValueError: too many values to unpack

f.close()

f = open('dna.txt')
fdna = f.read()
fdna = fdna.lower()
format1 = re.sub(r'chr, '', fdna) #getting rid of stuff I don't want
my_format = re.sub(r'[^atcg]', '', format1)

# SOME KIND OF CHUNKING MAGIC HERE?!?!?!

total = len(my_format)
n_bits =  my_format.count('n')
a_bits =  my_format.count('a')
t_bits =  my_format.count('t')
g_bits =  my_format.count('g')
c_bits =  my_format.count('c')

def percentage(count, total):
    return 100 * count / total
f.close() 
</code></pre>
<p>Right now this just prints a long list of numbers, counting how many a's there are in every chunk of 600 characters. However, I want to figure out how to define these chunks by what I have as the results of my first_text. (I.e. for the result "chrom1, 10000, 10600", in the second part of my code I want 10000 to the the start, 10600 to be the end, and then loop through all of the starts and ends, to count "a" in every trunk. If I could return a result like, "Chrom1, chunk 10000 - 10600 has 175 a's", I would be so happy!</p>
<p>Can anyone help me out? I'm not a very good programmer... I know some of my code is redundant. Anyway, any input is much appreciated!! </p>
<p>EDIT to clear up some things:
The extraction of the start and end points is working. If I</p>
<pre><code>print wanted_data
</code></pre>
<p>My results are</p>
<pre><code>"['Chrom1', '10000', '10600'], ['Chrom1', '10600', '12300'], ['Chrom1', '12300', '17000'], ['Chrom1', '17000', '21000]', ...."
</code></pre>
<p>many more. The first number in each one is the start point (e.g. 10000). The second point is the end point in each set (e.g. 10600)</p>
<p>Edit - the start and end points should be the start and end points of the chunks. So I want to use 10000 and 106000 to find format2[10000:106000] and count the a's in this chunk, and then do this for all of the starts and ends I get. </p>
</div>
<div class="post-text" itemprop="text">
<p>A bit of cleanup; you can remove all the tabs from <code>raw</code> before you split it.</p>
<pre><code>raw = read.lower ()
raw = re.sub(r'\t', '', raw)
l = raw.splitlines() #these next few lines are just for formatting
</code></pre>
<p>You want to save all of the extracted data instead - here is one way with a list.</p>
<pre><code>wanted_stuff = []
for datas in datas:
    wanted_stuff.append(data[0:3]) #extracting chromatin name, start, end
# or as a list comprehension
#wanted_stuff = [data[:3] for data in datas]
</code></pre>
<p>If your data looks like this:</p>
<pre><code>a = [['Chrom1', '10000', '10600'], ['Chrom1', '10600', '12300'],
     ['Chrom1', '12300', '17000'], ['Chrom1', '17000', '21000']]
</code></pre>
<p>You can create a list of <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow"><code>slice</code></a> objects:</p>
<pre><code>start_stop = [slice(int(start), int(stop)) for c, start, stop in a]
#if you need to conserve resources or time, use a generator expression
#start_stop = (slice(int(start), int(stop)) for c, start, stop in a)
</code></pre>
<p>That used a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a> to create <code>start_stop</code>.  Written as a traditional <code>for</code> loop it looks like this:</p>
<pre><code>start_stop = []
for c, start, stop in a:
    start_stop.append(slice(start, stop))
</code></pre>
<p>This uses unpacking to separate the items:</p>
<pre><code>&gt;&gt;&gt; thing = ['Chrom1', '10000', '10600']
&gt;&gt;&gt; c, start, stop = thing
&gt;&gt;&gt; c
'Chrom1'
&gt;&gt;&gt; start, stop
('10000', '10600')
&gt;&gt;&gt;
</code></pre>
<p><a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow">slice</a> objects can be used to index into a sequence:</p>
<pre><code>&gt;&gt;&gt; s = 'abcdefg'
&gt;&gt;&gt; items_123 = slice(1, 4)
&gt;&gt;&gt; s[items_123]
'bcd'
&gt;&gt;&gt; s[1:4]
'bcd'
&gt;&gt;&gt; 
</code></pre>
<p><code>start_stop</code> is a list that contains <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow">slice objects</a> which can be used extract the desired text from <code>format2</code></p>
<pre><code>chunks = [format2[chunk] for chunk in start_stop]
</code></pre>
<p><em>Expanded</em> as a <code>for</code> loop:</p>
<pre><code>chunks = []
for chunk in start_stop:
    chunks.append(format2[chunk])
</code></pre>
<hr/>
<p>You seem to have forgotten to close the second file.  You can avoid that mistake by using files in a context manager using the <code>with</code> keyword:</p>
<pre><code>with open('dna.txt') as f:
    fdna = f.read()

fdna = fdna.lower()
...
</code></pre>
</div>
<span class="comment-copy">The <i>extraction</i> of the start and end points is working?  Please provide an brief example of the extracted data.</span>
<span class="comment-copy">In the loop, <code>for datas in datas:</code> you overwrite <code>wanted_stuff</code> each iteration - it will only contain the last <i>item</i> when the iteration completes.</span>
<span class="comment-copy">What are the "starts and ends"?  Character offsets into the second file? Line offsets? Something else? Can you point us towards an example of the data you're working with?</span>
<span class="comment-copy">I edited and clarified things at the bottom. Meanwhile, wwii, if I need to keep all of them, should I append the results onto an empty list perhaps?</span>
<span class="comment-copy">@wwii, thank you for noticing this. I appended it to an empty list and will edit my original post for this.</span>
<span class="comment-copy">Thanks for this! I've cleaned up the parts you suggested (I'll update the original post after this) but I've still got some questions.  First, when I "print list wanted_stuff" I get the right format, but when I just "print wanted_stuff" I get what you have shown. Is there a specific reason for that?  I'm also still learning how to use generator expressions, so that is something I will try!  I don't exactly understand the line of code for defining start_stop. How does it take the numbers and make them starts/stops? also, what is "c" and "a". since I'm looking for dna, i don't want to use atcg</span>
<span class="comment-copy">Also when I run it with this addition, I get an error. Edit: line 23 in &lt;module&gt;      start_stop = [slice(int(start), int(stop)) for c, start, stop in a]     NameError: name 'a' is not defined.</span>
<span class="comment-copy">@SnarkShark,  <code>name 'a' is not defined.</code> in my answer, the example data is assigned to <code>a</code> so that is what I used in the code - you need to adjust for the name of your data. <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow noreferrer"><code>slice</code></a> .. <a href="https://docs.python.org/3/glossary.html#term-slice" rel="nofollow noreferrer">slice object</a>.  you may also be interested in <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a></span>
<span class="comment-copy">Unfortunantly, I still don't really understand that line of code and how, for example, I can map 10000 on to start and 106000 onto end. I read that line of code as, "the thing named start_stop is a pair of some integer named started and another integer named stop, and... ". I don't understand the "for c, start, stop in a". For my purposes would it be something like, "for chunk, start in start, stop in end"...but then I need to figure out how to loop it as well.</span>
<span class="comment-copy">@SnarkShark, see edit.</span>
