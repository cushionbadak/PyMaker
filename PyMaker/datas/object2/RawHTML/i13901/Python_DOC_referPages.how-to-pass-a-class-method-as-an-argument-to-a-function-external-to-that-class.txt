<div class="post-text" itemprop="text">
<p>This is how it works for me:</p>
<pre><code>class SomeName:
  def __init__(self):
    self.value = "something"
  def some_method(self):
    print self.value

def external_func(instance, method):
  method(instance)

external_func(SomeName(), SomeName.some_method)
</code></pre>
<p>This appears to work correctly. Is this the right way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code is "technically correct" (it does what you ask for) but - at least in your example - pretty useless: </p>
<pre><code>def external_func(instance, method):
  method(instance)

external_func(SomeName(), SomeName.some_method)
</code></pre>
<p>is the same as:</p>
<pre><code>def external_func(method):
  method()

external_func(SomeName().some_method)
</code></pre>
<p>which FWIW is the same as:</p>
<pre><code>SomeName().some_method()
</code></pre>
<p>but I assume you understood this already .</p>
<p>Now you probably have a reason to try to pass both the method AND instance to <code>external_func()</code>, or there might be a better way to solve your real problem... </p>
</div>
<div class="post-text" itemprop="text">
<p>Depending on what you're doing. Because functions are also objects in Python it is possible to do so.</p>
<p>But is it a <strong>good</strong> solution? It seems though that you're trying to handle a problem which maybe could be better solved with more of an object oriented approach:</p>
<pre><code>class A:
    def __init__(self):
        self.value = "class A"
    def some_method(self):
        print self.value

class B:
    def __init__(self):
        self.value = "class B"
    def some_method(self):
        print self.value

some_class = A()
some_class.some_method()

some_class = B()
some_class.some_method()
</code></pre>
<p>Output: </p>
<pre><code>"class A"
"class B"
</code></pre>
<p>In my view this would be a better approach (if this is possible/reasonable in your case): You just call <code>some_method()</code> on your class, maybe without even knowing what exact type of object you're dealing with (regarding inheritance). The class itself knows what to do and reacts accordingly when its method has been called.</p>
<p>This of course doesn't work when you work with external libraries which you have no influence on.</p>
</div>
<div class="post-text" itemprop="text">
<p>I of course don't know what you're doing exactly, but it sounds to me like you're trying to do too much inside of one function. Your problem might be better solved by simply splitting up the contents of <code>external_func</code>.</p>
<p>The goals here, as I understand them, are you don't know ahead of time what the object/method pair will be, and want to reduce code repetition.  </p>
<p>Perhaps something like this would be better: </p>
<pre><code>def main():
    obj = SomeName()
    # do the setting up portion 
    complex_object = external_func_set_up(obj)
    # presumably at some point you have to designate the method to be used:
    method = get_method_name(obj) 
    # run the method:
    getattr(obj, method)()
    # finish up the external operation: 
    external_func_complete(***args***) 
</code></pre>
<p>I understand this is more code, but I think in the end it's a lot clearer what is happening, and also might force you to think through your problem a bit more (and potentially come up with an even better solution). </p>
</div>
<div class="post-text" itemprop="text">
<p>You could pass <code>SomeName().some_method</code> or make <code>some_metod</code> <code>staticmethod</code> or <code>classmethod</code> if there is no instance data used in your method.</p>
<p>Check documentation to know more about <code>staticmethod</code> and <code>classmethod</code>:</p>
<ul>
<li><a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow">https://docs.python.org/3/library/functions.html#staticmethod</a></li>
<li><a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow">https://docs.python.org/3/library/functions.html#classmethod</a></li>
</ul>
</div>
<span class="comment-copy">You could just pass <code>SomeName().some_method</code> then call <code>method()</code>, it is also not really a class method as you are calling it with an instance</span>
<span class="comment-copy">@PadraicCunningham I think OP probably just means "a class's method", not a classmethod.</span>
<span class="comment-copy">But it needs to be able to call it with data that will be computed later. There is some function foo(), were all the steps are the same except the method used to do (for instance) some tax computation which depends on the region or something (my goal is to prevent code duplication).</span>
<span class="comment-copy">@zehelvion, not sure what the difference is, you can call the method and pass whatever you like, maybe  add more context to your question if there is something you feel might be an issue</span>
<span class="comment-copy">oh, in the real case, the function needs to construct and preform some lengthy computation with the class instance, using one of it's specific method.</span>
<span class="comment-copy">In my case the class itself is the same and familiar with two (or more) behaviors but the situation changes. Imagine this, a <code>Dog</code> class that can <code>bite</code>, <code>bark</code> or <code>growl</code> depending on what the owner decides. We need to pass the behavior the owner desires to some dog which isn't born yet. The dog allocation / computation process is always the same but the behavior is an argument. The dog is computed based on some data provided.</span>
<span class="comment-copy">As we try to model classes accordingly to real world objects, it would be kind of odd to ask an unborn dog to <code>bark</code>, isn't it? Is there no way to wait until the dog has been created before you decide to tell it what to do?</span>
<span class="comment-copy">I'm starting to think this is right. There is a model (instance) and a context, was the model needs to behave. Imagine a person in a formal business and the same person in a rock concert. The function / script, gets the input to generate the person instance and the situation (appropriate behavior). It is used to determine the result of the derived instance with the specified behavior.</span>
<span class="comment-copy">@wolfdawn wery late comment but anyway: what you describe above looks like the strategy pattern.</span>
<span class="comment-copy">It is not a static method, it has a <code>self</code> argument and depends on the <code>value</code> attribute of the example class. It is therefore <i>not</i> static by definition.</span>
<span class="comment-copy">You're correct, but as I see the <code>value</code> is constant, hence it's possible to define it as a class property, hence it's possible to use <code>classmethod</code>.</span>
