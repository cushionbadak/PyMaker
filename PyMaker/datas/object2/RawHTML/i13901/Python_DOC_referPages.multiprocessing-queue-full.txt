<div class="post-text" itemprop="text">
<p>I'm using concurrent.futures to implement multiprocessing. I am getting a queue.Full error, which is odd because I am only assigning 10 jobs.</p>
<pre><code>A_list = [np.random.rand(2000, 2000) for i in range(10)]

with ProcessPoolExecutor() as pool:
    pool.map(np.linalg.svd, A_list)
</code></pre>
<p>error: </p>
<pre><code>Exception in thread Thread-9:
Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/threading.py", line 921, in _bootstrap_inner
    self.run()
  File "/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/threading.py", line 869, in run
    self._target(*self._args, **self._kwargs)
  File "/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/concurrent/futures/process.py", line 251, in _queue_management_worker
    shutdown_worker()
  File "/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/concurrent/futures/process.py", line 209, in shutdown_worker
    call_queue.put_nowait(None)
  File "/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/multiprocessing/queues.py", line 131, in put_nowait
    return self.put(obj, False)
  File "/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/multiprocessing/queues.py", line 82, in put
    raise Full
queue.Full
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Short Answer</strong><br/>
I believe pipe size limits are the underlying cause. There isn't much you can do about this except break up your data into smaller chunks and deal with them iteratively. This means you may need to find a new algorithm that can work on small portions of your 2000x2000 array at a time to find the Singular Value Composition.</p>
<p><strong>Details</strong><br/>
Let's get one thing straight right away: you're dealing with a lot of information. Just because you're working with only ten items doesn't mean it's trivial. Each of those items is a 2000x2000 array full of 4,000,000 floats, which are usually 64 bits each, so you're looking at around 244MB per array, plus the other data that tags along in <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html" rel="noreferrer">Numpy's ndarrays</a>. </p>
<p>The <a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-example" rel="noreferrer">ProcessPoolExecutor</a> works by launching a separate thread to manage the worker processes. The management thread uses a <a href="https://docs.python.org/3.4/library/multiprocessing.html#multiprocessing.Queue" rel="noreferrer">multiprocesing.Queue</a> to pass jobs to the workers, called <code>_call_queue</code>. These <code>multiprocessing.Queue</code>s are actually just fancy wrappers around <a href="https://www.cs.rutgers.edu/~pxk/416/notes/c-tutorials/pipe.html" rel="noreferrer">pipes</a>, and the ndarrays you're trying to pass to the workers are likely too large for the pipes to handle properly.</p>
<p>Reading over <a href="https://bugs.python.org/issue8426" rel="noreferrer">Python Issue 8426</a> shows that figuring out exactly how big your pipes can be difficult, even when you can look up some nominal pipe size limit for your OS. There are too many variables to make it simple. Even the order that things are pulled off of the queue can induce race conditions in the underlying pipe that trigger odd errors. </p>
<p>I suspect that one of your workers is getting an getting an incomplete or corrupted object off of its <code>_call_queue</code>, because that queue's pipe is full of your giant objects. That worker dies in an unclean way, and the work queue manager detects this failure, so it gives up on the work and tells the remaining workers to exit. But it does this by passing them <a href="http://www.captaindebug.com/2013/03/producers-and-consumers-part-3-poison.html#.Vl5-2Zf9TVM" rel="noreferrer">poison pills</a> over <code>_call_queue</code>, which is <em>still full of your giant ndarrays</em>. This is why you got the full queue exception - your data filled up the queue, then the management thread tried to use the same queue to pass control messages to the other workers.</p>
<p>I think this is a classic example of the potential dangers of mixing data and control flows between different entities in a program. Your large data not only blocked more data from being received by the workers, it also blocked the manager's control communications with the workers because they use the same path.</p>
<p>I haven't been able to recreate your failure, so I can't be <em>sure</em> that all of this is correct. But the fact that you can make this code work with a 200x200 array (~2.5MB) seems to support this theory. Nominal pipe size limits seem to be measured in KB or a few MB at most, depending on the OS and architecture. The fact that this amount of data can get through the pipes isn't surprising, especially when you consider that not all of the 2.5MB needs to actually fit in the pipe at once if a consumer is continuously receiving the data. It suggests a reasonable upper bound on the amount of data that you could get serially through a pipe.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've recently stumbled upon this, while debugging a python3.6 program which sends  various GBs of data over the pipes. This is what I found (hoping it could save someone else's time!).</p>
<p>Like <a href="https://stackoverflow.com/users/2615940/skrrgwasme">skrrgwasme</a> said, if the queue manager is unable to acquire a semaphore while sending a poison pill, it <a href="https://github.com/python/cpython/blob/e2f33add635df4fde81be9960bab367e010c19bf/Lib/multiprocessing/queues.py#L83" rel="noreferrer">raises</a> a queue Full error. 
The <a href="https://github.com/python/cpython/blob/1023dbbcb7f05e76053486ae7ef7f73b4cdc5398/Lib/threading.py#L133" rel="noreferrer">acquire call</a> to the semaphore is non-blocking and it causes the manager to fail (it's unable to send a 'control' command due to data and control flow sharing the same <em>Queue</em>). Note that the links above refer to python 3.6.0</p>
<p>Now I was wondering why my queue manager would send the poison pill. There must have been some other failure!
Apparently some exception had happened (in some other subprocess? in the parent?), and the queue manager was trying to clean up and shut down all the subprocesses. At this point I was interested in finding this root cause.</p>
<p><strong>Debugging the root cause</strong></p>
<p>I initially tried logging all exceptions in the subprocesses but apparently no explicit error happened there.
From <a href="https://github.com/python/cpython/pull/3895" rel="noreferrer">issue 3895</a>:</p>
<blockquote>
<p>Note that multiprocessing.Pool is also broken when a result fails at unpickle.</p>
</blockquote>
<p>it seems that the multiprocessing module is broken in py36, in that it won't catch and treat a serialization error correctly. </p>
<p>Unfortunately, due to time constraints I didn't manage to replicate and verify the problem myself, preferring to jump to the action points and better programming practices (don't send all that data through pipes :). Here's a couple of ideas:</p>
<ol>
<li>Try to pickle the data supposed to run through the pipes. Due to the huge nature of my data (hundreds of GBs) and time constraints, I didn't manage to find which records were unserializable. </li>
<li>Put a debugger into python3.6 and print the original exception.</li>
</ol>
<p><strong>Action points</strong></p>
<ol>
<li><p>Remodel your program to send less data through the pipes if possible.</p></li>
<li><p>After reading <a href="https://github.com/python/cpython/pull/3895" rel="noreferrer">issue 3895</a> it appears the problem arises with pickling errors. An alternative (and good programming practice) could be to transfer the data using different means. For example one could have the subprocesses write to files and return the paths to the parent process (this would be just a small string, probably a few bytes).</p></li>
<li><p>Wait for future python versions. Apparently this was fixed on python version tag v3.7.0b3 in the context of <a href="https://github.com/python/cpython/pull/3895" rel="noreferrer">issue 3895</a>. The <em>Full</em> exception will be <a href="https://github.com/python/cpython/commit/94459fd7dc25ce19096f2080eb7339497d319eb0#diff-d24fedf7a1cf058e9e4166d89f2bb378R326" rel="noreferrer">handled</a> inside <em>shutdown_worker</em>. The current maintenance version of Python at the time of writing is 3.6.5 </p></li>
</ol>
</div>
<span class="comment-copy">Do you get the same error if you use a much smaller array?</span>
<span class="comment-copy">I do not get the error on smaller arrays. The largest I can go is ~200x200.</span>
<span class="comment-copy">The call to <code>shutdown_worker</code> that's failing only runs if the <code>Pool</code> has become broken due to a worker process crashing - so the real problem you need to track down is why that's happening.</span>
