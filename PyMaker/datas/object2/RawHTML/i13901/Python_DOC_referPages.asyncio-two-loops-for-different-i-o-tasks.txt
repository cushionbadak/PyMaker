<div class="post-text" itemprop="text">
<p>I am using Python3 Asyncio module to create a load balancing application. I have two heavy IO tasks:</p>
<ul>
<li>A SNMP polling module, which determines the best possible server</li>
<li>A "proxy-like" module, which balances the petitions to the selected server.</li>
</ul>
<p>Both processes are going to run forever, are independent from eachother and should not be blocked by the other one.</p>
<p>I cant use 1 event loop because they would block eachother, is there any way to have 2 event loops or do I have to use multithreading/processing? </p>
<p>I tried using asyncio.new_event_loop() but havent managed to make it work.</p>
</div>
<div class="post-text" itemprop="text">
<p>Answering my own question to post my solution:</p>
<p>What I ended up doing was creating a thread and a new event loop inside the thread for the polling module, so now every module runs in a different loop. It is not a perfect solution, but it is the only one that made sense to me(I wanted to avoid threads, but since it is only one...). Example:</p>
<pre><code>import asyncio
import threading


def worker():
    second_loop = asyncio.new_event_loop()
    execute_polling_coroutines_forever(second_loop)
    return

threads = []
t = threading.Thread(target=worker)
threads.append(t)
t.start()

loop = asyncio.get_event_loop()
execute_proxy_coroutines_forever(loop)
</code></pre>
<p>Asyncio requires that every loop runs its coroutines in the same thread. Using this method you have one event loop foreach thread, and they are totally independent: every loop will execute its coroutines on its own thread, so that is not a problem.
As I said, its probably not the best solution, but it worked for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>The whole point of <code>asyncio</code> is that you can run multiple thousands of I/O-heavy tasks concurrently, so you don't need <code>Thread</code>s at all, this is exactly what <code>asyncio</code> is made for. Just run the two coroutines (SNMP and proxy) in the same loop and that's it. 
You have to make both of them available to the event loop BEFORE calling <code>loop.run_forever()</code>. Something like this:</p>
<pre><code>import asyncio

async def snmp():
    print("Doing the snmp thing")
    await asyncio.sleep(1)

async def proxy():
    print("Doing the proxy thing")
    await asyncio.sleep(2)

async def main():
    while True:
        await snmp()
        await proxy()

loop = asyncio.get_event_loop()
loop.create_task(main())
loop.run_forever()
</code></pre>
<p>I don't know the structure of your code, so the different modules might have their own infinite loop or something, in this case you can run something like this:</p>
<pre><code>import asyncio

async def snmp():
    while True:
        print("Doing the snmp thing")
        await asyncio.sleep(1)

async def proxy():
    while True:
        print("Doing the proxy thing")
        await asyncio.sleep(2)

loop = asyncio.get_event_loop()
loop.create_task(snmp())
loop.create_task(proxy())
loop.run_forever()
</code></pre>
<p>Remember, both <code>snmp</code> and <code>proxy</code> needs to be coroutines (<code>async def</code>) written in an asyncio-aware manner. <code>asyncio</code> will not make simple blocking Python functions suddenly "async".</p>
<p>In your specific case, I suspect that you are confused a little bit (no offense!), because well-written async modules will never block each other in the same loop. If this is the case, you don't need <code>asyncio</code> at all and just simply run one of them in a separate <code>Thread</code> without dealing with any <code>asyncio</code> stuff.</p>
</div>
<div class="post-text" itemprop="text">
<p>Asyncio event loop is a single thread running and it will not run anything in parallel, it is how it is designed. The closest thing which I can think of is using <code>asyncio.wait</code>.</p>
<pre><code>from asyncio import coroutine
import asyncio

@coroutine
def some_work(x, y):
    print("Going to do some heavy work")
    yield from asyncio.sleep(1.0)
    print(x + y)

@coroutine
def some_other_work(x, y):
    print("Going to do some other heavy work")
    yield from asyncio.sleep(3.0)
    print(x * y)



if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(asyncio.wait([asyncio.async(some_work(3, 4)), 
                            asyncio.async(some_other_work(3, 4))]))
    loop.close()
</code></pre>
<p>an alternate way is to use <code>asyncio.gather()</code> - it returns a future results from the given list of futures.</p>
<pre><code>tasks = [asyncio.Task(some_work(3, 4)), asyncio.Task(some_other_work(3, 4))]
loop.run_until_complete(asyncio.gather(*tasks))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>But I used that like this, but still its synchronous no async:</p>
<pre><code>def main(*args):    
    loop = get_event_loop()
    coro = asyncio.start_server(handle_echo, '127.0.0.1', 50008,loop=loop)
    srv = loop.run_until_complete(coro)        
    loop.run_forever()    

@asyncio.coroutine
def handle_echo(reader, writer):
    data = yield from reader.read(500)
    message = data.decode(encoding='utf-8')            

    nameindex=('name="calculator2"' in message)
    if nameindex:
        time.sleep(5)
        writer.write("Content-Length: 1\r\n\r\n2".encode())
        yield from writer.drain()
    else:
        writer.write("Content-Length: 1\r\n\r\n1".encode())
        yield from writer.drain()



    print("Close the client socket")
    writer.close()
</code></pre>
<p>if received value contains (name="calculator2") I wait for 5 seconds 
if not, just answer and write data immediately.
But when test it, first send data to server with containing (name="calculator2") and next data without (name="calculator2"), but next data handles after 5 seconds of first is done and after that 2th data will be handled.</p>
<p>its sequential. what it wrong with it?
and the other way, how should I get client connected ip and port?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>If the proxy server is running all the time it cannot switch back and forth. The proxy listens for client requests and makes them asynchronous, but the other task cannot execute, because this one is serving forever. </p>
</blockquote>
<p>If the proxy is a coroutine and is starving the SNMP-poller (never awaits), isn't the client requests being starved aswell?</p>
<blockquote>
<p>every coroutine will run forever, they will not end</p>
</blockquote>
<p>This should be fine, as long as they do <code>await/yield from</code>. The <a href="https://docs.python.org/3/library/asyncio-protocol.html#tcp-echo-server-protocol" rel="nofollow">echo server</a> will also run forever, it doesn't mean you can't run several servers (on differents ports though) in the same loop.</p>
</div>
<span class="comment-copy">If designed the right way, Asyncio coroutines won't block each other even though they run on the same loop. Asyncio effectively switches back and forth between multiple coroutines / tasks to give the effect of concurrency, even if using a single thread.</span>
<span class="comment-copy">@shongololo but if I have one loop running with "loop.run_forever()" it blocks the loop and I cant do anything else unless i stop it. Or am I undertanding wrong? Thats the behaviour I am seeing...</span>
<span class="comment-copy">not sure I fully understand the dilemma. Is there anything stopping you from running both in the same loop? asyncio will automatically switch back and forth (within the same loop) when encountering 'yield from' points inside your code. This is basically the point of asyncio, it lets you run multiple and potentially blocking coroutines inside the same loop without one blocking the other.</span>
<span class="comment-copy">If the proxy server is running all the time it cannot switch back and forth. The proxy listens for client requests and makes them asynchronous, but the other task cannot execute, because this one is serving forever.</span>
<span class="comment-copy">The whole point of asyncio is that you can run multiple thousands of I/O-heavy tasks concurrently, so you don't need Threads at all, this is exactly what asyncio is made for. Just run the two coroutines (SNMP and proxy) in the same loop and that's it.  On the technical side: You have to make both of them available to the event loop BEFORE calling <code>loop.run_forever()</code></span>
<span class="comment-copy">I know that event loops are single-threaded, thats why I was asking if there would be any way to implement it using 2 different loops. I cannot use that method because as I said, every coroutine will run forever, they will not end. Will try to post my solution when I figure it out, Thanks.</span>
<span class="comment-copy">@brunoop You can still use this approach - it doesn't matter that your tasks don't end. Just schedule the coroutines you need using <code>asyncio.async(your_coroutine())</code>, and then call <code>loop.run_forever()</code> once they've all been scheduled. There's no need to use two threads.</span>
