<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/6442050/python-equivalence-to-inline-functions-or-macros">This</a> is a similar question but my goal is not performance but readability. </p>
<p>Let's say I have different <code>Behaviours</code>, and they share a repeated function <code>f1()</code>. </p>
<pre><code>from abc import ABCMeta, abstractmethod

class Behavior:
    __metaclass__ = ABCMeta
    @abstractmethod 
    def run(self):
        pass

class Behavior1(Behavior):
    def __init__(self, data):
        self.data = data

    def run(self):
        def f1():
            print(self.data*localVar)

        localVar = 1.
        f1()

class Behavior2(Behavior):
    def __init__(self, data):
        self.data = data

    def run(self):
        def f1():
            print(self.data*localVar)

        localVar = 2.
        f1()

class Behavior3(Behavior):
    def __init__(self, data):
        self.data = data

    def run(self):
        def f1():
            print(self.data*localVar)

        localVar = 3            
        f1()
</code></pre>
<p>I want <code>f1()</code> to have access to instance attributes and local variables inside <code>run()</code> without passing them as arguments. </p>
<p>Probably I can implement that inside <code>Behavior</code> but I don't have access to <code>localVar</code>.</p>
<pre><code>from abc import ABCMeta, abstractmethod

class Behavior:
    __metaclass__ = ABCMeta
    @abstractmethod 
    def run(self):
        pass

    def f(self):
        print(self.data*localVar)

class Behavior1(Behavior):
    def __init__(self, data):
        self.data = data

    def run(self):
        def f1():
            print(self.data*localVar)

        localVar = 1.
        f1()
        self.f()

class Behavior2(Behavior):
    def __init__(self, data):
        self.data = data

    def run(self):
        def f1():
            print(self.data*localVar)

        localVar = 2.
        f1()
        self.f()

class Behavior3(Behavior):
    def __init__(self, data):
        self.data = data

    def run(self):
        def f1():
            print(self.data*localVar)

        localVar = 3            
        f1()
        self.f()
</code></pre>
<p>Is there any pythonic or OOP way of writting a C-Style macro for <code>f1()</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Macros are not an inherent construct in python since there's no preprocessor like in C++ to use.</p>
<p>As such, anything you do to allow you to only write the code once will have to be done...</p>
<ul>
<li><p>Outside of python (i.e. you manually use gcc's preprocessor); or</p></li>
<li><p>By using debugging information in python (i.e. you deconstruct the callstack)</p></li>
</ul>
<p>The former is a pain in the butt, but is doable.</p>
<p>The latter is also a pain in the butt, but is also doable.</p>
<p>However, since your goal is to increase readability, neither of these options are good because anybody accustomed to python will have absolutely no idea what you're doing. Be very careful when porting language constructs from other languages into python.</p>
<p>If your function needs to <em>modify</em> local variables, then you'll have to write the same lines of code in every place.</p>
<p>If it just needs to use them, I strongly recommend just passing arguments - or rethinking your design and need for many derived classes all doing roughly the same thing in one function (i.e. what if you broke that "function" into several pieces of the function and let derived classes only override the ones they want?).</p>
</div>
<div class="post-text" itemprop="text">
<p>What you actually want sounds like "access to outer scope variables" which is not global.</p>
<p>If you use python3.x, you should look up the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement" rel="nofollow noreferrer">nonlocal keyword</a>.</p>
<p>If you use python2.x, try using a mutable object as a wrapper to your object.</p>
<p>Actually my answer is based on <a href="https://stackoverflow.com/a/8448011/3181777">this</a> one.</p>
</div>
<span class="comment-copy">Why not define it in the abstract class <code>Behavior</code> ?</span>
<span class="comment-copy"><i>"I want <code>f1()</code> to have access to objects and data inside run() without passing them as arguments."</i> - why? Just instance attributes, or other local variables? Could you provide a less abstract example that demonstrates what you're actually trying to achieve?</span>
<span class="comment-copy">It took me a long time to figure out what you meant. I'd recommend explicitly pointing out that you want f1() to be a C-style macro, not a function.</span>
<span class="comment-copy">@iAdjunct Sure, actually <code>f1()</code>, <code>f2()</code>, ... are steps of a simulation. Data is partitioned and distributed using mpi and the method <code>run()</code> is implemented differently for each <code>Behavior</code> class. Finally steps f1(), f2(), ... need to access local variables produced by <code>run()</code></span>
<span class="comment-copy">No, I mean edit your post and explicitly mention that you want that function to be a macro. That is, of course, assuming that's what you actually mean.</span>
