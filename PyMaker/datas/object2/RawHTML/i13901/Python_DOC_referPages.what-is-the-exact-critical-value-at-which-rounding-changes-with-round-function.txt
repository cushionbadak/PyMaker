<div class="post-text" itemprop="text">
<p>In py2, criticality is found to round .50 where it is round .51 in py3</p>
<p>In python2,  </p>
<pre><code>round(0.5) =&gt; 1.0   
round(0.49) =&gt; 0.0  
round(0.51) =&gt; 1.0  
round(1.5) =&gt; 2.0  
round(0.4999999999999999999999999) =&gt; 1.0  
round(0.4899999999999999999999999) =&gt; 0.0  
round(0.4989999999999999999999999) =&gt; 0.0 
</code></pre>
<p>In python 3,  </p>
<pre><code>round(0.49) =&gt; 0  
round(0.50) =&gt; 0  
round(0.51) =&gt; 1  
round(0.500000000000000000001) =&gt; 0  
round(0.50999999999999999999999) =&gt; 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The change from <code>round(0.5)==1</code> to <code>round(0.5)==0</code> was intended.
Compare the documentation between round in <a href="https://docs.python.org/2/library/functions.html#round" rel="nofollow">Python 2</a> and <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow">Python 3.</a>. It was changed to round always round toward the EVEN value, instead of rounding away from zero (if both values are equally close).</p>
<p>If you always wish to round up, instead use:</p>
<pre><code>import math
print math.ceil(0.5)
</code></pre>
<p>This will give 1.0 no matter version of python.</p>
<p><a href="https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues" rel="nofollow">Here is an article</a> explaining the strangeness of floats and why the rounding error occurs. The difference in the rounding errors between 2.x and 3.x are because of the change in how rounding works in the two versions.</p>
<p>Due to how floating point values work, it is impossible to accurately represent many decimal numbers. If you need an exact number you'll need to use a <a href="https://docs.python.org/2/library/decimal.html" rel="nofollow">decimal</a> datatype instead. </p>
<p>Edit: This change was to conform to the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" rel="nofollow">IEEE 754 standard</a>, aka the IEEE Floating Point standard. This is so that the rounded values will not be biased towards high values, and instead bias towards even numbers.</p>
</div>
<span class="comment-copy">This is because of the innaccuracies of using floating point arithmatic. Because computers use binary, they can't represent 0.5 in binary (Think 1/3 = 0.3333) If you want exact rounding, use a decimal type</span>
<span class="comment-copy">@muddyfish, I agree in general that floats can be surprisingly inaccurate, but 0.5 happens to be one possible value that <i>can</i> be exactly represented.</span>
<span class="comment-copy">@Kevin However some of the cases can only be explained by the phenomenon muddyfish points out. 0.5000....1 and 0.499...9 can't be exactly represented so they will be represented as 1/2 (1*2^-1) and so rounded as if they were 1/2.</span>
<span class="comment-copy">There was a change between 2.x and 3.x in how numbers are rounded. Use math.ceil and math.floor instead for consistency between versions.</span>
<span class="comment-copy">@stiffo even if i use math module, i got the same result.</span>
<span class="comment-copy">Would be nice if they stated this explicitly in the docs as "Changed in 3.0: ...".</span>
<span class="comment-copy">Perhaps you might want to point out the fact that literals that are too near 0.5 will round as if they were 0.5 (due to the fact that they can't be represented exactly). The question actually has such examples.</span>
<span class="comment-copy">It's explained in the linked article, but I changed my answer to state that it's explained there.</span>
