<div class="post-text" itemprop="text">
<p>I'm looking to do something like this:</p>
<pre><code>parser = argparse.ArgumentParser()

group1 = parser.add_argument_group('group1')
group1.add_argument('--test1', help="test1")

group2 = parser.add_argument_group('group2')
group2.add_argument('--test2', help="test2")

group1_args = group1.parse_args()
group2_args = group2.parse_args()
</code></pre>
<p>However, I'm getting the following error:</p>
<pre><code>Traceback (most recent call last):
  File "test.py", line 19, in &lt;module&gt;
    group1_args = group1.parse_args()
AttributeError: '_ArgumentGroup' object has no attribute 'parse_args'
</code></pre>
<p>Is there a way to only get the arguments for one argument group?</p>
</div>
<div class="post-text" itemprop="text">
<p>As your error message indicates, an ArgumentGroup is not a parser, specifically it doesn't have the <code>parse_args</code> method.</p>
<p>ArgumentParser objects and ArgumentGroup objects share a base ArgumentContainer class that gives them methods like <code>add_argument</code>.  But an ArgumentParser has a lot of additional code.  An ArgumentGroup is really just an aid in formatting the <code>help</code>.  It does not affect parsing in any way.</p>
<p>To add confusion, a <code>mutually_exclusive_group</code> subclasses <code>ArgumentGroup</code>, but affects only the <code>usage</code> part of the <code>help</code>, and affects parsing by raising an error message.</p>
<p>If you elaborate on why you want to do this, we could come up with some alternatives that might work.  For example there is a <code>parents</code> mechanism, that lets you <code>insert</code> one <code>parser</code> into another.  Or <code>subparsers</code> that pass parsing control to a subparsers via 'command' arguments.</p>
<hr/>
<p><a href="https://docs.python.org/3/library/argparse.html#parents" rel="nofollow">https://docs.python.org/3/library/argparse.html#parents</a></p>
<p>Defining each group in its own <code>parent</code> parser, would let you control both the help display, and parsing.  Only problem with parents is that you have to use <code>help=False</code> at some level to prevent the duplication of the <code>-h</code> option.</p>
<p>You may also need to use <code>parse_known_args</code> so the 'group' parser does not complain about arguments that it does not recognize.</p>
<hr/>
<p>Here's a way of displaying all the <code>args</code> entries, grouped by argument group.  I'm including the 2 default groups, optionals and positionals.  It does make use of 'private' attributes of the parser.  There's a bit of risk in doing so, but this isn't the kind of thing that is likely to be changed in future patches.</p>
<pre><code>import argparse
parser = argparse.ArgumentParser()

group1 = parser.add_argument_group('group1')
group1.add_argument('--test1', help="test1")

group2 = parser.add_argument_group('group2')
group2.add_argument('--test2', help="test2")

args = parser.parse_args('--test1 one --test2 two'.split())

print([g.title for g in parser._action_groups])  # all group titles
print(group1._group_actions)  # arguments/actions of `group1`
print([a.dest for a in group2._group_actions]) # actions for group2

for group in parser._action_groups:
    group_dict={a.dest:getattr(args,a.dest,None) for a in group._group_actions}
    print(group.title, argparse.Namespace(**group_dict))
</code></pre>
<p>producing</p>
<pre><code>1513:~/mypy$ python stack31519997.py 
['positional arguments', 'optional arguments', 'group1', 'group2']
[_StoreAction(option_strings=['--test1'], dest='test1', nargs=None, const=None, default=None, type=None, choices=None, help='test1', metavar=None)]
['test2']
('positional arguments', Namespace())
('optional arguments', Namespace(help=None))
('group1', Namespace(test1='one'))
('group2', Namespace(test2='two'))
</code></pre>
<p>If could be more convenient to work with <code>vars(args)</code>, the dictionary version.  <code>argparse.Namespace(**adict)</code> recreates a namespace from a dictionary.</p>
<p>Of coarse you make your own <code>dest</code> lists, <code>['test1']</code> and <code>['test2']</code>.</p>
</div>
<span class="comment-copy">How would you know which group's arguments were present before parsing all of them?</span>
<span class="comment-copy">Maybe just create separate ArgumentParser instances?</span>
<span class="comment-copy">@larsks could you elaborate more? Would it be leveraging <code>parse_known_args()</code>?</span>
<span class="comment-copy">This is purely for readability. I have two category of parameters, and would like to represent that clearly when using them.</span>
<span class="comment-copy">Look at the docs regarding <code>parents</code>.</span>
<span class="comment-copy">I also called <code>parser.parse_args()</code> before <code>group1.parse_args()</code> and <code>group2.parse_args()</code> so that <code>-h</code> will show the help for both sets of parameters.</span>
<span class="comment-copy">Sounds like you might be more interested in a way dividing <code>args=parser.parse_args()</code> into 2 or more subsets, without parsing afresh.</span>
<span class="comment-copy">Yes! I just realized a while ago. Is there a way to do that?</span>
