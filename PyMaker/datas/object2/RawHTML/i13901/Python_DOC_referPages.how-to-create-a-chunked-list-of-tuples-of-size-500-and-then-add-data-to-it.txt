<div class="post-text" itemprop="text">
<p>This is my code, using Python 2.7</p>
<pre><code>list1 = [1,2,3,4,5,6,9,10.....1000]
</code></pre>
<p>I'm trying to create chunks of 500 list data like this</p>
<pre><code>chunk_data = [(1,2,3,4,5,...500),(501,502....1000)]
</code></pre>
<p>and then I'm going to add a "data" at the end of each chunk</p>
<p>so it will look like this</p>
<pre><code>[(1,2...500,'data'),(501,502...1000,'data')]
</code></pre>
<p>I tried to use zip for this</p>
<pre><code>it = iter(list1)    
chunked_data = zip(*[it]*500) 
</code></pre>
<p>but I'm unable to append the "data" now</p>
<pre><code>from itertools import repeat
chunked_data = zip(*[it]*500,repeat("data")) #Gives Error about adding arguments after unpacking function values !!
</code></pre>
<p>It's not possible for me to write this code below even though it would work</p>
<pre><code>chunked_data = zip(it,it,it...(500 times),repeat("data")]
</code></pre>
<p>So how should I attempt this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could create a list of positional arguments and then unpack it:</p>
<pre><code>args = [it] * 500 + [repeat('data')]
chunked_data = zip(*args)
</code></pre>
<p>This is essentially a modified <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>grouper</code> recipe</a> from the <code>itertools</code> documentation.</p>
<p>It works nicely:</p>
<pre><code>In [17]: it = iter('0123456789')

In [18]: args = [it] * 5 + [repeat('data')]

In [19]: list(zip(*args))
Out[19]: [('0', '1', '2', '3', '4', 'data'), ('5', '6', '7', '8', '9', 'data')]
</code></pre>
<hr/>
<p>Alternative solution:</p>
<pre><code>[tuple(list1[i:i+500]) + ('data',) for i in range(0, len(list1), 500)]
</code></pre>
<p>You can find more at <a href="https://stackoverflow.com/q/312443/2301450">this</a> page.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>[tuple(list1[i:i+500]+['data']) for i in xrange(0, len(list1), 500)]
</code></pre>
<p>You can change 500 and extend it for any chunk size</p>
</div>
<div class="post-text" itemprop="text">
<p>Function which provides your output</p>
<pre><code>def chunks_with_data(l, n):
    return [tuple(l[i:i + n])+("data",) for i in range(0, len(l), n)]

&gt;&gt;&gt;chunks_with_data(range(1000), 500)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>But it might be very very long!!</p>
<pre><code>base_lst = [x for x in range(1, 1001)]
lst = [tuple(base_lst[x:x+500]+['Data']) for x in range(500)]
print(lst)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my take on this problem. It returns 500 element chunks from a list (<code>[(1...500),(501...1000)]</code>) and appends <code>data</code>:</p>
<pre><code>l = [x for x in range(1, 1001)]
out_l = [tuple(l[i:i+500] + ['data']) for i in xrange(0, len(l), 500)]
</code></pre>
</div>
<span class="comment-copy">Tuples are immutable, and can't be appended to.  So, even if this code worked, it would need to copy and be very inefficient.  If your goal is to re-use the list1 somehow, consider using a better data structure.  If you don't intend to re-use it, consider using a loop that does something special when ((i+1) % 500 == 0) (or, more advanced, list comprehensions or generators).</span>
<span class="comment-copy">@PadraicCunningham segregate the input array into chunks of 500 elements</span>
<span class="comment-copy">what if the array is not evenly divisible by 500?</span>
<span class="comment-copy">@PadraicCunningham That would'nt happen in the case of the input</span>
<span class="comment-copy">This is a follow-on question to <a href="http://stackoverflow.com/q/31637486/4014959">Adding and creating chunks of a list in python</a></span>
<span class="comment-copy">Hmm, I really want to know why this is downvoted.</span>
<span class="comment-copy">@AnandSKumar because this is a bad answer?</span>
<span class="comment-copy">I mean the reason why this is a bad answer.</span>
<span class="comment-copy">OP needs tuple inside :p</span>
<span class="comment-copy">Thanks @itzmeontv. Fixed it.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/31637605/3881403">Oddly familiar</a> :) OP should note that for very large <code>k</code> (<code>500</code> is probably not yet <i>very</i> large) the overhead can become significant compared to an iterator-based way.</span>
<span class="comment-copy">This solution has come up an inordinate number of times, but +1 for being the first to parametrize <code>n</code>, which at this point seems a good idea.</span>
<span class="comment-copy">Your response have one problem though. It would iterate over every element in the list and add the next 500 elements. What OP clearly wanted was getting tuples like (1...500), (501...1000), not (1...500), (2...501).</span>
<span class="comment-copy">@wswld: Wellâ€¦ He said "chunks of 500 list data like this" So, for me it's 500 <code>tuple</code> in a <code>list</code>. No?</span>
<span class="comment-copy">It seems that he himself illustrated it like that: chunk_data = [(1,2,3,4,5,...500),(501,502....1000)].</span>
<span class="comment-copy">Yes, but it seems to that is easier to forget a comma: '[(),,()]' than to make an error like confounding "500 list" with "2 lists". No?</span>
<span class="comment-copy">Sorry, didn't get your point here.</span>
