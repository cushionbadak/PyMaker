<div class="post-text" itemprop="text">
<p>I am using python logging module (python 3.4.3). 
Let's say my logging level is set to INFO and I would like to use a function as an argument of my logging message.</p>
<p>Now I would expect when log level is decreased (e.g. WARNING) that the argument functions are not executed.</p>
<p>Is this true?</p>
<p>Example (console):</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.basicConfig(level=logging.INFO)
&gt;&gt;&gt; logging.debug('Factorial of 100000=',math.factorial(100000))
&gt;&gt;&gt; */empty output but slightly delayed, small CPU peak/*
&gt;&gt;&gt; logging.debug('Factorial of 10=',math.factorial(10))
&gt;&gt;&gt; */empty output but instant, no noticeable CPU usage/*
</code></pre>
<p>The function is probably not executed, but still there is noticable delay. Could someone explain me please the possible cause?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Function arguments evaluations before call</h2>
<p>Well you see the arguments you pass to <code>logging.debug('Factorial of 100000=', math.factorial(100000))</code> need to be <strong><em>evaluated</em></strong> before <code>logging.debug()</code> gets <em>called</em>, and evaluating <code>math.factorial(100000)</code> takes time</p>
<p>It doesn't matter if ultimately the function does nothing in its call, the arguments will still get evaluated</p>
<p>Conceptually you can think of it as doing</p>
<pre><code>value = math.factorial(100000)           # This gets evaluated
logging.debug('Factorial is %d', value)  # Even if this is a "no op" call, 
                                         # the arg evaluation still takes place
</code></pre>
<h2>Workaround</h2>
<pre><code>import math
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()

if logger.getEffectiveLevel() &lt;= logging.DEBUG:    # Or use == if you want DEBUG only
    logger.debug('Factorial is %d', math.factorial(100000))
</code></pre>
<p>Using Python 3's <a href="https://docs.python.org/3/library/logging.html#logging.Logger.getEffectiveLevel" rel="nofollow">logger.getEffectiveLevel()</a></p>
<p>Given that the levels are ordered as</p>
<pre><code>CRITICAL    50
ERROR       40
WARNING     30
INFO        20
DEBUG       10
NOTSET      0
</code></pre>
<p>You can see that our if block (with <code>&lt;= logging.DEBUG</code>) will only run on <code>DEBUG</code> and below (so <code>DEBUG</code> and <code>NOTSET</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you evaluate the function before you call. One way of dealing with this is using <code>logger.getEffectiveLevel()</code> as described by bakkal. This can be a bit verbose though. Another way to get around this is to create an intermediary object to pass to the logger that does the work in it's <code>__str__</code> function. This delays the function call until the logging module is sure the message will be emitted.</p>
<p>For example:</p>
<pre><code>import logging
import math

class CallableMsg:
    def __init__(self, func, *args, **kwargs):
        self.func = func
        self.args = args
        self.kwargs = kwargs

    def __str__(self):
        return str(self.func(*self.args, **self.kwargs))

logging.basicConfig(level=logging.INFO)

# single arg log
logging.info(CallableMsg(math.factorial, 10)) 
# using the CallableMsg in a format string
logging.info("10! = %s", CallableMsg(math.factorial, 10))
# factorial function never gets evaluated for the debug call
logging.debug(CallableMsg(math.factorial, 1000000))
</code></pre>
<p>The logging module is also kind enough to preserve the line on which the log call was actually made if there is ever an error.</p>
<pre><code>logging.info(CallableMsg(math.factorial, -1))
</code></pre>
<p>Outputs:</p>
<pre><code>--- Logging error ---
Traceback (most recent call last):
  File "C:\Python34\lib\logging\__init__.py", line 971, in emit
    msg = self.format(record)
  File "C:\Python34\lib\logging\__init__.py", line 821, in format
    return fmt.format(record)
  File "C:\Python34\lib\logging\__init__.py", line 558, in format
    record.message = record.getMessage()
  File "C:\Python34\lib\logging\__init__.py", line 319, in getMessage
    msg = str(self.msg)
  File "C:python\run.py", line 12, in __str__
    return str(self.func(*self.args, **self.kwargs))
ValueError: factorial() not defined for negative values
Call stack:
  File "&lt;string&gt;", line 1, in &lt;module&gt;
  File "C:\Python34\lib\idlelib\run.py", line 126, in main
    ret = method(*args, **kwargs)
  File "C:\Python34\lib\idlelib\run.py", line 353, in runcode
    exec(code, self.locals)
  File "C:\python\run.py", line 18, in &lt;module&gt;
    logging.info(CallableMsg(math.factorial, -1))
Message: &lt;__main__.CallableMsg object at 0x02ECF970&gt;
Arguments: ()
</code></pre>
</div>
<span class="comment-copy">Excellent answer, thanks a lot</span>
<span class="comment-copy">Both very valuable insights, thanks a lot Dunes.</span>
