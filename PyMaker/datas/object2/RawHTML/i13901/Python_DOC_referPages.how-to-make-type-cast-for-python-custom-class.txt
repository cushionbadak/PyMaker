<div class="post-text" itemprop="text">
<p>Consider a class;</p>
<pre><code>class temp:
    def __init__(self):
        pass
</code></pre>
<p>I make an object of it;</p>
<pre><code>obj = temp()
</code></pre>
<p>Convert it to string;</p>
<pre><code>strObj = str(obj)
</code></pre>
<p>Now, how can i convert strObj to an object of temp class??</p>
<pre><code>org = temp(strObj)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As noted by Anand in comments, what you're looking for is object serialization and deserialization. One way to achieve this is through the pickle (or cPickle) module:</p>
<pre><code>&gt;&gt;&gt; import pickle

&gt;&gt;&gt; class Example():
...     def __init__(self, x):
...             self.x = x
...
&gt;&gt;&gt; a = Example('foo')
&gt;&gt;&gt; astr = pickle.dumps(a) # (i__main__\nExample\np0\n(dp1\nS'x'\np2\nS'foo'\np3\nsb.
&gt;&gt;&gt; b = pickle.loads(astr)
&gt;&gt;&gt; b
&lt;__main__.Example instance at 0x101c89ea8&gt;
&gt;&gt;&gt; b.x
'foo'
</code></pre>
<p>Note, however, that one gotcha in using the pickle module is dealing with implementation versions. As suggested in the Python docs, if you want an unpickled instance to automatically handle implementation versioning, you may want to add a version instance attribute and add a custom __setstate__ implementation: <a href="https://docs.python.org/2/library/pickle.html#object.__setstate__" rel="nofollow">https://docs.python.org/2/library/pickle.html#object.<strong>setstate</strong></a>. Otherwise, the version of the object at serialization time will be exactly what you get at deserialization time, regardless of code changes made to the object itself.</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer the question, one way of doing this is by "abusing" <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer"><code>__repr__</code></a> in combination with <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer"><code>eval()</code></a>. Let's first have a look at the <code>__repr__</code> docs (emphasis: mine):</p>
<blockquote>
<p>Called by the repr() built-in function to compute the “official”
  string representation of an object. <strong>If at all possible, this should
  look like a valid Python expression that could be used to recreate an
  object with the same value (given an appropriate environment).</strong> If this
  is not possible, a string of the form &lt;...some useful description...&gt;
  should be returned. The return value must be a string object. If a
  class defines <code>__repr__()</code> but not <code>__str__()</code>, then <code>__repr__()</code> is also
  used when an “informal” string representation of instances of that
  class is required.</p>
<p>This is typically used for debugging, so it is important that the
  representation is information-rich and unambiguous.</p>
</blockquote>
<p>With this in mind, we know that it is recommended to return a string from <code>__repr__</code> which can be used with <code>eval()</code>. This is implied by the statement that the value "should look like a valid Python expression".</p>
<h2>Example</h2>
<p>Here is an example which uses this. The example also overrides <code>__eq__</code>, but only for convenience for the print-outs. And for completeness we also add a value to the instance.</p>
<p>The example creates a new instance. Then the value is converted to a string using <code>__repr__</code> (by using the <a href="https://docs.python.org/3/library/functions.html#repr" rel="nofollow noreferrer"><code>repr()</code></a> function. Next that string value is passed to <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer"><code>eval()</code></a> which will evaluate the string and return the result. The result will be a new instance of the same class and is stored in <code>second_instance</code>. We also print out the <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer"><code>id()</code></a> to visualise that we have indeed two different instances. Finally we show that <code>first_instance == second_instance</code> is indeed <code>True</code>:</p>
<pre><code>class MyClass:

    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        return isinstance(self, MyClass) and self.value == other.value

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.value)


first_instance = MyClass(123)
print('First instance: repr=%r, id=%d' % (first_instance, id(first_instance)))

stringified = repr(first_instance)
print('Stringified: %r' % stringified)

second_instance = eval(stringified)  # !!! DANGEROUS (see below) !!!
print('Second instance: repr=%r, id=%d' % (second_instance, id(second_instance)))

print('First == Second: %r' % (first_instance == second_instance))
</code></pre>
<h2>When is it OK to do this?</h2>
<p>This is <em>100%</em> acceptable if <strong>absolutely everything going into <code>eval()</code></strong> is under your control! This means:</p>
<ul>
<li>The scope in which <code>eval()</code> is called is under your control</li>
<li><em>No place</em> in the evaluated string should contain data coming from outside sources. Outside sources include:

<ul>
<li>Database values</li>
<li>User-Input</li>
<li>Data read from disk</li>
<li>... basically any I/O</li>
</ul></li>
</ul>
<p>Keeping all this in mind and guaranteeing that at no point in the future of the project I/O will end up in an <code>eval()</code> call is almost impossible. As such I strongly recommend avoiding this in important production code as it opens up nasty security holes.</p>
<p>For code not running in production, this is absolutely acceptable. For example unit-tests, personal utility scripts, e.t.c. But the risk should always be taken into consideration.</p>
<h2>Why is this Dangerous?</h2>
<ul>
<li>The code passed into <code>eval()</code> is executed inside the Python process calling it, with the same privileges. Example: You read a value from a DB where multiple users have access and you <code>eval()</code> it. In that case, another user may inject code via the database and that code will run <em>as your user</em>!</li>
<li>Using <code>eval()</code> when the values come from outside sources opens up the possibility of code-injections.</li>
<li>It is not guaranteed that <code>repr()</code> will return a valid Python expression. This is only a <em>recommendation</em> by the docs. Hence the call to <code>eval</code> with <code>__repr__</code> is prone to run-time errors.</li>
<li>In the example above, the scope calling <code>eval()</code> needs to "know" about the class <code>MyClass</code> (it must be imported). It only looks for the name. So if by pure chance that same name exists in the scope, but pointing to another object, you will call something else unintentionally and may run into weird bugs. Granted, this is an edge-case.</li>
</ul>
<h2>Safer Alternative</h2>
<p>Use one of the many available serialisation options. The most popular, and simplest one to use is to convert the object to/from JSON strings. The above example could be made safe like this:</p>
<pre><code>import json


class MyClass:

    @staticmethod
    def from_json(document):
        data = json.loads(document)
        instance = MyClass(data['value'])
        return instance

    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        return isinstance(self, MyClass) and self.value == other.value

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.value)

    def to_json(self):
        data = {
            'value': self.value
        }
        return json.dumps(data)


first_instance = MyClass(123)
print('First instance: repr=%r, id=%d' % (first_instance, id(first_instance)))

stringified = first_instance.to_json()
print('Stringified: %r' % stringified)

second_instance = MyClass.from_json(stringified)
print('Second instance: repr=%r, id=%d' % (second_instance, id(second_instance)))

print('First == Second: %r' % (first_instance == second_instance))
</code></pre>
<p>This is only marginally more difficult but much safer.</p>
<p>The same approach can be used with other serialisation methods. Popular formats are:</p>
<ul>
<li><a href="https://docs.python.org/3/library/xml.dom.minidom.html" rel="nofollow noreferrer">XML</a></li>
<li><a href="https://pyyaml.org" rel="nofollow noreferrer">YAML</a></li>
<li><a href="https://docs.python.org/3/library/configparser.html" rel="nofollow noreferrer">ini/cfg files</a></li>
<li><a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer">pickle</a> (note that this uses bytes instead of text as serialisation medium).</li>
<li><a href="https://msgpack.org/" rel="nofollow noreferrer">MessagePack</a> (note that this uses bytes instead of text as serialisation medium).</li>
<li>Custom Implementation</li>
<li>...</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>For those who are looking for overriding conversion builtins such as <code>int(obj)</code>, <code>float(obj)</code>, and <code>str(obj)</code>, see <a href="https://stackoverflow.com/questions/11575393/overload-int-in-python">Overload int() in Python</a>. You need to implement <code>__int__</code>, <code>__float__</code>, or <code>__str__</code> on the object.</p>
</div>
<span class="comment-copy">I do not think you can do something like that, why do you need this?</span>
<span class="comment-copy">You need a constructor that can create the object from a string. <code>def __init__(self, x=""):</code>, if you want to use more than one constructor look at <a href="http://stackoverflow.com/questions/682504/what-is-a-clean-pythonic-way-to-have-multiple-constructors-in-python" title="what is a clean pythonic way to have multiple constructors in python">stackoverflow.com/questions/682504/…</a></span>
<span class="comment-copy">This is an experiment. I want to insert a class instance to MongoDB. But can't do it directly, so i had to convert it to a string.. Now, i need to convert it back.</span>
<span class="comment-copy">You are looking at the wrong conversion, what you want is <code>object serialization</code> , do not use <code>str(..)</code> for that.</span>
<span class="comment-copy">@markiz the link was really good!.. understood the approach of multiple constructors.. But can you explain how to convert a string to object?</span>
<span class="comment-copy">Thank you for simplifying things!</span>
