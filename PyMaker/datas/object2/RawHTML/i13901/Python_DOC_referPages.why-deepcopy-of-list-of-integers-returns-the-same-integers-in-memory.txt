<div class="post-text" itemprop="text">
<p>I understand the differences between shallow copy and deep copy as I have learnt in class. However the following doesn't make sense</p>
<pre><code>import copy

a = [1, 2, 3, 4, 5] 

b = copy.deepcopy(a)

print(a is b)
print(a[0] is b[0])
----------------------------
~Output~
&gt;False
&gt;True
----------------------------
</code></pre>
<p>Shouldn't <code>print(a[0] is b[0])</code> evaluate to False as the objects and their constituent elements are being recreated at a different memory location in a deep copy? I was just testing this out as we had discussed this in class yet it doesn't seem to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason of this behavior is that Python optimize small integers so they are not actually in different memory location. Check out the <code>id</code> of <code>1</code>, they are always the same:</p>
<pre><code>&gt;&gt;&gt; x = 1
&gt;&gt;&gt; y = 1
&gt;&gt;&gt; id(x)
1353557072
&gt;&gt;&gt; id(y)
1353557072

&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; id(a[0])
1353557072

&gt;&gt;&gt; import copy
&gt;&gt;&gt; b = copy.deepcopy(a)
&gt;&gt;&gt; id(b[0])
1353557072
</code></pre>
<hr/>
<p>Reference from <a href="https://docs.python.org/3/c-api/long.html">Integer Objects</a>:</p>
<blockquote>
<p>The current implementation keeps an array of integer objects for all integers between <code>-5</code> and <code>256</code>, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of <code>1</code>. I suspect the behaviour of Python in this case is undefined. :-)</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The answer by Yu Hao is actually not correct. While it is true that Python has interned objects for small integers, it is not what causes that behaviour.</p>
<p>Let's have a look at what happens when we use bigger integers.</p>
<pre><code>&gt; from copy import deepcopy
&gt; x = 1000
&gt; x is deepcopy(x)
True
</code></pre>
<p>If we dig down in the <code>copy</code> module we find out that calling <code>deepcopy</code> with an atomic value defers the call to the function <a href="https://github.com/python/cpython/blob/master/Lib/copy.py#L182" rel="nofollow noreferrer"><code>_deepcopy_atomic</code></a>.</p>
<pre><code>def _deepcopy_atomic(x, memo):
    return x
</code></pre>
<p>So what is actually happening is that <code>deepcopy</code> will not copy an immutable value, but only return it.</p>
<p>By example this is the case for <code>int</code>, <code>float</code>, <code>str</code>, <code>function</code> and more.</p>
</div>
<span class="comment-copy">Isnt what youre describing the principal of "shallow copies" i.e copy.copy(a), when using copy.deepcopy(a), shouldnt the elements all be in different memory locations, i.e that id(a[0]) != id(b[0])</span>
<span class="comment-copy">@GeraldLee: This is a special case, in that the 'small' integers (<code>&lt; 257</code>) will be fixed to memory location to speed up common operations. Try the following: <code>a, b = (list(range(258)), list(range(258)));[id(a[i]) == id(b[i]) for i in range(258)]</code> in a python REPL</span>
<span class="comment-copy">Small ints are examples of Python singletons. Others are <code>None</code>, <code>True</code>, and <code>False</code></span>
<span class="comment-copy">I am sorry, but this is not the reason why. Try with <code>x = 1000</code>. See my answer below.</span>
