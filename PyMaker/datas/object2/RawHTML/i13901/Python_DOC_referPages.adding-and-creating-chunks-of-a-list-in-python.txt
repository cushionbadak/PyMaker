<div class="post-text" itemprop="text">
<p>This is my list</p>
<pre><code>list1 = [1,2,3,4,5,6,7,8,9,10,11,12]
</code></pre>
<p>i tried to do this</p>
<pre><code>it = iter(list1)

chunked_lists =  zip(it,it,it)

chunked_lists is now = [(1,2,3),(4,5,6),(7,8,9),(10,11,12)]
</code></pre>
<p>Now i'd like to add a 'data' to every chunk so that it would look like</p>
<pre><code>[(1,2,3,'data'),(4,5,6,'data')....etc]
</code></pre>
<p>but tuples are immutable and i'd have to destroy them, append and create them again.</p>
<p>is there a better way to accomplish this in python?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>it = iter(list1)
from itertools import repeat
chunked_lists =  zip(it,it,it,repeat("data"))
[(1, 2, 3, 'data'), (4, 5, 6, 'data'), (7, 8, 9, 'data'), (10, 11, 12, 'data')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer"><code>itertools.repeat</code></a> to create a new iterator contain the <code>data</code> and then apply the <code>zip</code> function on your prior iterators and new repeated iterator :</p>
<pre><code>&gt;&gt;&gt; it = iter(list1)
&gt;&gt;&gt; it2=repeat('data',len(list1))
&gt;&gt;&gt; chunked_lists =  zip(it,it,it,it2)
&gt;&gt;&gt; chunked_lists
[(1, 2, 3, 'data'), (4, 5, 6, 'data'), (7, 8, 9, 'data'), (10, 11, 12, 'data')]
&gt;&gt;&gt; 
</code></pre>
<p>Note that as @Padraic Cunningham mentioned on <a href="https://stackoverflow.com/a/31637688/2867928">his answer</a> there is no need to call the <code>len</code> function in <code>itertools.repeat</code>.So you can simply use <code>repeat('data')</code></p>
<p>If you want to modify the list of tuples after creation you can use a list comprehension to modify your tuples by adding the new elements to the tuples.</p>
<p>Example :</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; l2=np.random.randint(0,100,len(list1)/3)
&gt;&gt;&gt; it = iter(list1)
&gt;&gt;&gt; chunked_lists =  zip(it,it,it)
&gt;&gt;&gt; chunked_lists = [i+(j,) for i,j in zip(chunked_lists,l2)]
&gt;&gt;&gt; l2
array([35, 22, 35, 95])
&gt;&gt;&gt; chunked_lists
[(1, 2, 3, 35), (4, 5, 6, 22), (7, 8, 9, 35), (10, 11, 12, 95)]
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should be a linear time way to do it:</p>
<pre><code>list1 = [1,2,3,4,5,6,7,8,9,10,11,12]
result = [tuple(list1[x:x+3]+["data"]) for x in range(0, len(list1), 3)]
</code></pre>
<p>If I am not ignoring some Python intricacy, <a href="https://stackoverflow.com/questions/18726969/time-complexity-of-casting-lists-to-tuples-in-python-and-vice-versa">since tuple() has complexity O(n)</a>, <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">the slice accessor has complexity O(k)</a> and the overhead caused by the <code>+["data"]</code> isn't greater than simply appending a node at the end of a list (which is <code>O(1)</code>), it should be <code>O((len(list1) / k) * k ^ 2)</code> aka <code>O(n k)</code>, where <code>k</code> is fixed to 3 in your case.</p>
<pre><code>result = [tuple(list1[x:x+3]+["data"]) for x in range(0, len(list1), 3)]
</code></pre>
<p>means:</p>
<p><code>[list1[x:x+3]+["data"] for x in (0, 3, ... 12)]</code></p>
<p>aka:</p>
<pre><code>[
 tuple(list1[0:3]+["data"]),
 tuple(list1[4:6]+["data"]),
 ...
 tuple(list1[9:12]+["data"])
]
</code></pre>
<p>It is also well behaved with odd lists:</p>
<pre><code>&gt;&gt;&gt; list1 = [1,2,3,4,5,6,7,8,9,10,11]
&gt;&gt;&gt; print [tuple(list1[x:x+3]+["data"]) for x in range(0, len(list1), 3)]
[(1, 2, 3, 'data'), (4, 5, 6, 'data'), (7, 8, 9, 'data'), (10, 11, 'data')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since tuples are immutable, if you're adding and deleting from them often, you're perhaps better off using lists of lists:</p>
<pre><code>list1 = [1,2,3,4,5,6,7,8,9,10,11,12]
it = iter(list1)
chunked_lists = [list(a) for a in zip(it,it,it)]  
# =&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]

for l in chunked_lists:
    l.append('data')
# =&gt; [[1, 2, 3, 'data'], [4, 5, 6, 'data'], [7, 8, 9, 'data'], [10, 11, 12, 'data']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about adding them to the <code>zip</code> function when you are creating the <code>chunked_lists</code> itself -</p>
<pre><code>&gt;&gt;&gt; list1 = [1,2,3,4,5,6,7,8,9,10,11,12]
&gt;&gt;&gt; it = iter(list1)
&gt;&gt;&gt; chunked_lists =  zip(it,it,it,['data']*(len(list1)/3))
&gt;&gt;&gt; chunked_lists
[(1, 2, 3, 'data'), (4, 5, 6, 'data'), (7, 8, 9, 'data'), (10, 11, 12, 'data')]
</code></pre>
<hr/>
<p>For Python 3.x , you would need to divide the <code>len(list1)</code> using <code>//</code> operator (for it to return int) . (And most probably wrap <code>zip</code> in <code>list()</code> , since <code>zip</code> in Python 3.x , returns an iterator.)</p>
</div>
<span class="comment-copy">Why do you need that exactly ? If your plan to add a lot more data to each chunk, maybe you could converter them to list after the zip.</span>
<span class="comment-copy">Tobia Tesan's solution is more robust than the zip-based methods, since it handles the <code>len(list1)%3!=0</code> situation. FWIW, if I can <i>*guarantee</i> that the list length is ok I'd probably just do <code>[u+('data',)for u in zip(*[iter(list1)]*3)]</code>. OTOH, I guess you could do something with <code>[i]zip_longest</code>...</span>
<span class="comment-copy">Excellent, there is no need to specify the number of repeat!</span>
<span class="comment-copy">@Kasramvd, yep, it will just repeat as necessary</span>
<span class="comment-copy">@PadraicCunningham why does <code>print repeat('data')</code> give the output as <code>repeat('data')</code> ???</span>
<span class="comment-copy">@wolfgang, it is just how python represents the object.</span>
<span class="comment-copy">@wolfgang, the formatting is here <a href="https://github.com/python/cpython/blob/master/Modules/itertoolsmodule.c#L4168" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Modules/â€¦</a></span>
<span class="comment-copy">I am not sure he plans to just add a 'data' to each of his chunk, my guess is it's a placeholder for something he's going to add later. (He might be doing it lot, as he seems concerned by computational cost of tuple creation)</span>
<span class="comment-copy">@Yann Yeah I guess so! I'll update the answer!</span>
