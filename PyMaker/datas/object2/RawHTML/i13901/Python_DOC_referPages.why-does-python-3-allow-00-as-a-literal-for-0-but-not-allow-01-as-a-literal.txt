<div class="post-text" itemprop="text">
<p>Why does Python 3 allow "00" as a literal for 0 but not allow "01" as a literal for 1? Is there a good reason? This inconsistency baffles me. (And we're talking about Python 3, which purposely broke backward compatibility in order to achieve goals like consistency.)</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; from datetime import time
&gt;&gt;&gt; time(16, 00)
datetime.time(16, 0)
&gt;&gt;&gt; time(16, 01)
  File "&lt;stdin&gt;", line 1
    time(16, 01)
              ^
SyntaxError: invalid token
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Per <a href="https://docs.python.org/3/reference/lexical_analysis.html#integer-literals" rel="noreferrer">https://docs.python.org/3/reference/lexical_analysis.html#integer-literals</a>:</p>
<blockquote>
<p>Integer literals are described by the following lexical definitions:</p>
<pre><code>integer        ::=  decimalinteger | octinteger | hexinteger | bininteger
decimalinteger ::=  nonzerodigit digit* | "0"+
nonzerodigit   ::=  "1"..."9"
digit          ::=  "0"..."9"
octinteger     ::=  "0" ("o" | "O") octdigit+
hexinteger     ::=  "0" ("x" | "X") hexdigit+
bininteger     ::=  "0" ("b" | "B") bindigit+
octdigit       ::=  "0"..."7"
hexdigit       ::=  digit | "a"..."f" | "A"..."F"
bindigit       ::=  "0" | "1"
</code></pre>
<p>There is no limit for the length of integer literals apart from what
  can be stored in available memory.</p>
<p>Note that leading zeros in a non-zero decimal number are not allowed.
  This is for disambiguation with C-style octal literals, which Python
  used before version 3.0.</p>
</blockquote>
<p>As noted here, leading zeros in a <em>non-zero</em> decimal number are not allowed. <code>"0"+</code> is legal as a very special case, which <a href="https://docs.python.org/2/reference/lexical_analysis.html#integer-and-long-integer-literals" rel="noreferrer">wasn't present in Python 2</a>:</p>
<pre><code>integer        ::=  decimalinteger | octinteger | hexinteger | bininteger
decimalinteger ::=  nonzerodigit digit* | "0"
octinteger     ::=  "0" ("o" | "O") octdigit+ | "0" octdigit+
</code></pre>
<hr/>
<p><a href="https://mail.python.org/pipermail//python-3000-checkins/2007-June/000874.html" rel="noreferrer">SVN commit r55866</a> implemented PEP 3127 in the tokenizer, which forbids the old <code>0&lt;octal&gt;</code> numbers. However, curiously, it also adds this note:</p>
<pre><code>/* in any case, allow '0' as a literal */
</code></pre>
<p>with a special <code>nonzero</code> flag that only throws a <code>SyntaxError</code> if the following sequence of digits contains a nonzero digit.</p>
<p>This is odd because <a href="https://www.python.org/dev/peps/pep-3127/" rel="noreferrer">PEP 3127</a> does not allow this case:</p>
<blockquote>
<p>This PEP proposes that the ability to specify an octal number by using a leading zero will be removed from the language in Python 3.0 (and the Python 3.0 preview mode of 2.6), and that <strong>a SyntaxError will be raised whenever a leading "0" is immediately followed by another digit</strong>. </p>
</blockquote>
<p>(emphasis mine)</p>
<p>So, the fact that multiple zeros are allowed is <em>technically</em> violating the PEP, and was basically implemented as a special case by Georg Brandl. He made the corresponding documentation change to note that <code>"0"+</code> was a valid case for <code>decimalinteger</code> (previously that had been covered under <code>octinteger</code>).</p>
<p>We'll probably never know <em>exactly</em> why Georg chose to make <code>"0"+</code> valid - it may forever remain an odd corner case in Python.</p>
<hr/>
<p><strong>UPDATE</strong> [28 Jul 2015]: This question led to a <a href="https://mail.python.org/pipermail/python-ideas/2015-July/034631.html" rel="noreferrer">lively discussion thread</a> on python-ideas in which <a href="https://mail.python.org/pipermail/python-ideas/2015-July/034650.html" rel="noreferrer">Georg chimed in</a>:</p>
<blockquote>
<p>Steven D'Aprano wrote: </p>
<blockquote>
<p>Why was it defined that way? [...] Why would we write 0000 to get zero?</p>
</blockquote>
<p>I could tell you, but then I'd have to kill you.</p>
<p>Georg</p>
</blockquote>
<p>Later on, the thread spawned <a href="https://bugs.python.org/issue24668" rel="noreferrer">this bug report</a> aiming to get rid of this special case. Here, <a href="https://bugs.python.org/msg246945" rel="noreferrer">Georg says</a>:</p>
<blockquote>
<p>I don't recall the reason for this deliberate change (as seen from the docs change). </p>
<p>I'm unable to come up with a good reason for this change now [...]</p>
</blockquote>
<p>and thus we have it: the precise reason behind this inconsistency is lost to time.</p>
<p>Finally, note that the bug report was rejected: leading zeros will continue to be accepted only on zero integers for the rest of Python 3.x.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a special case (<code>"0"+</code>)</p>
<h1><a href="https://docs.python.org/3/reference/lexical_analysis.html#integer-literals" rel="noreferrer">2.4.4. Integer literals</a></h1>
<pre>
Integer literals are described by the following lexical definitions:

integer        ::=  decimalinteger | octinteger | hexinteger | bininteger
decimalinteger ::=  nonzerodigit digit* | "0"+
nonzerodigit   ::=  "1"..."9"
digit          ::=  "0"..."9"
octinteger     ::=  "0" ("o" | "O") octdigit+
hexinteger     ::=  "0" ("x" | "X") hexdigit+
bininteger     ::=  "0" ("b" | "B") bindigit+
octdigit       ::=  "0"..."7"
hexdigit       ::=  digit | "a"..."f" | "A"..."F"
bindigit       ::=  "0" | "1"
</pre>
<p>If you look at the grammar, it's easy to see that <code>0</code> need a special case. I'm not sure why the '<code>+</code>' is considered necessary there though. Time to dig through the dev mailing list...</p>
<hr/>
<p>Interesting to note that in Python2, more than one <code>0</code> was parsed as an <code>octinteger</code> (the end result is still <code>0</code> though)</p>
<pre>
decimalinteger ::=  nonzerodigit digit* | "0"
octinteger     ::=  "0" ("o" | "O") octdigit+ | "0" octdigit+
</pre>
</div>
<div class="post-text" itemprop="text">
<p>Python2 used the leading zero to specify octal numbers:</p>
<pre><code>&gt;&gt;&gt; 010
8
</code></pre>
<p>To avoid this (misleading?) behaviour, Python3 requires explicit prefixes <code>0b</code>, <code>0o</code>, <code>0x</code>:</p>
<pre><code>&gt;&gt;&gt; 0o10
8
</code></pre>
</div>
<span class="comment-copy">It can't be removed now, or it will break backward compatibility with this question!</span>
<span class="comment-copy">Why do you say "We'll probably never know exactly why Georg chose to..."? If someone that knows him sees this thread and informs him about it, then he might come give his answer! (unless you know he's forevermore refusing to discuss his past Python work, or some similar circumstance)</span>
<span class="comment-copy">I don't understand why they didn't just make the second Python 2 <code>octinteger</code> case <code>"0" octdigit*</code>. <code>0</code> is an octal literal in C/C++.</span>
<span class="comment-copy">Actually English is a bit ambiguous in this regard.  The word "another" can mean "one more" or it can mean "a different one."  One valid English interpretation of the bolded quote from PEP 3127 is to mean "a SyntaxError will be raised whenever a leading '0' is immediately followed by a digit other than '0'"  I'm not sure if that's what was actually intended (although that interpretation does appear to be supported by the actual code), but in any case I don't think it's accurate to say that the PEP is technically violated without additional clarification of that sentence.</span>
<span class="comment-copy">@GrandOpener: Note that <code>001</code> is illegal, whereas your interpretation would render that legal (since the meaning of "immediately" should be quite unambiguous).</span>
<span class="comment-copy">Good point. So the PEP is definitely violated; what is ambiguous is the exact nature in which it is violated. :)</span>
<span class="comment-copy">And any idea why there is <code>"0"+</code> and not <code>"0"</code> ?</span>
<span class="comment-copy">@lejlot, not yet - but I am intrigued. It's definitely part of the spec though</span>
<span class="comment-copy">The question remains: why is <code>00</code> allowed? (And <code>000</code>, <code>0000</code>, etc.)</span>
<span class="comment-copy">@MichaelGeary: possibly because it can't be ambiguous (00000000 is 0 regardless of the base) and removing it would needlessly break code? Still strange.</span>
<span class="comment-copy">@RemcoGerlich If I'm not wrong, <code>01</code> is also <code>1</code> regardless of the base.</span>
<span class="comment-copy">@Holt: but allowing "0"+"1"? as a special case would probably be even more confusing.</span>
<span class="comment-copy">@RemcoGerlich Never said it wouldn't ;) I was just saying that the <code>can't be ambiguous</code> is not an argument since <code>01</code> can't be ambiguous either. IMO, the <code>00</code> case is just a special case because it is <code>0</code> which should not be.</span>
