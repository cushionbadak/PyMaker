<div class="post-text" itemprop="text">
<p>I would like to automatically set default argument as class attributes.
For example, I have (with more arguments, like a dozen or two) :</p>
<pre><code>class Foo:
    def __init__(self,a=1,b=2,c=3,...):
        self.a = a
        self.b = b
        self.c = c
        ...
</code></pre>
<p>And I want define the attributes automatically, without having to rewrite <code>self.x = x</code> all the time in <code>__init__</code> body.</p>
<p>I could use something like :</p>
<pre><code>class Foo:
    def __init__(self, **kwargs):
        for attr, value in kwargs.items():
            setattr(self,attr,value)
</code></pre>
<p>But now I cannot give them default values.
What I would like is some function that gives me a dictionary of the arguments with default values :</p>
<pre><code>class Foo:
    def __init__(self,a=1,b=2,c=3,...,**kwargs):
        defargs = somefunction()
</code></pre>
<p>With <code>defargs</code> being <code>{'a':1,'b':2,'c':3,...}</code> (but not containing kwargs).</p>
<p>Closest thing I managed to do is :</p>
<pre><code>class Foo:
    def __init__(self,a=1,b=2,c=3,...,**kwargs):
        defargs=locals()
        defargs.pop('self')
        defargs.pop('kwargs')
        for attr, value in defargs.items():
            setattr(self,attr,value)
</code></pre>
<p>But I don't know if there is not some potentially unsafe behavior in this code.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.3+ this can be done easily using <a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow"><code>inspect.signature</code></a>:</p>
<pre><code>import inspect


def auto_assign(func):
    signature = inspect.signature(func)

    def wrapper(*args, **kwargs):
        instance = args[0]
        bind = signature.bind(*args, **kwargs)
        for param in signature.parameters.values():
            if param.name != 'self':
                if param.name in bind.arguments:
                    setattr(instance, param.name, bind.arguments[param.name])
                if param.name not in bind.arguments and param.default is not param.empty:
                    setattr(instance, param.name, param.default)
        return func(*args, **kwargs)

    wrapper.__signature__ = signature # Restore the signature

    return wrapper


class Foo:
    @auto_assign
    def __init__(self, foo, bar, a=1, b=2, c=3):
        pass

f = Foo(10, 20)
g = Foo(100, 200, a=999)

print(f.__dict__)
print(g.__dict__)
print(inspect.getargspec(Foo.__init__))
</code></pre>
<p>Output:</p>
<pre><code>{'bar': 20, 'b': 2, 'foo': 10, 'c': 3, 'a': 1}
{'bar': 200, 'b': 2, 'foo': 100, 'c': 3, 'a': 999}
ArgSpec(args=['self', 'foo', 'bar', 'a', 'b', 'c'], varargs=None, keywords=None, defaults=(1, 2, 3))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could define the defaults manually as a dict:</p>
<pre><code>def __init__(self, **kwargs):
    defaults = {'a':1,'b':2,'c':3,...}
    defaults.update(kwargs)
    for attr, value in defaults.items():
        setattr(self,attr,value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could always set actual <em>class attributes</em> (you're referring to <em>instance attributes</em>) to hold the default values, and either get them explicitly:</p>
<pre><code>class Foo:

    # default attribute values
    a = 1 
    ...

    def __init__(self, **kwargs):
        setattr(self, 'a', kwargs.get('a', getattr(self, 'a')))
        ...
</code></pre>
<p>Or just leave them to be accessed normally (<strong>not recommended</strong> for mutable attributes):</p>
<pre><code>class Foo:

    # default attribute values
    a = 1 
    ...

    def __init__(self, **kwargs):
        if 'a' in kwargs:
            setattr(self, 'a', kwargs['a'])
        ...
</code></pre>
<p>Either way, <code>Foo().a</code> will get you <code>1</code> and <code>Foo(a=2).a</code> will get you <code>2</code>, and you can now easily refactor to a loop over <code>('a', ...)</code> for the names of relevant attributes.</p>
</div>
<span class="comment-copy"><i>A dozen or two</i>? That's really a lot, don't think form groups in some natural way that you could split off into another class?</span>
<span class="comment-copy">Possibly, it's a bunch of parameters for some solver. I could group them in like four/five groups (space_param, time_param, power_param, sampling_param, ...), but I like to keep in the signature what each parameter is for.</span>
<span class="comment-copy">...for a given value of <i>"easily"</i>!</span>
<span class="comment-copy">For now, this seems the closest to what I wanted. I tried something based on your solution (cf edit in OP), does it seems correct to you ?</span>
<span class="comment-copy">@Nihl don't edit answers into the question</span>
<span class="comment-copy">@jonrsharpe : Sorry, I did not know. Where should I put it ?</span>
<span class="comment-copy">@Nihl you don't need to put it anywhere. If you think there's something you can add to the existing answers, write your own. If you have a new question, ask it separately. If you just want to know if what you've written is correct, <b>test it</b>.</span>
<span class="comment-copy">Better the defaults be a class attribute and not declared each init.</span>
<span class="comment-copy">@InbarRose I don't think that would make any difference at all; you'd need to copy the defaults each time anyway, to prevent them from being mutated by the <code>update</code>.</span>
<span class="comment-copy">This solution seems good, but it does not keep the signature, no ? (I might sound a bit picky, but I liked the fact that when I start typing the function, my IDE display the signature and default arguments). Still thanks.</span>
<span class="comment-copy">@Nihl no, you can't keep the signature if you want to use arbitrary <code>**kwargs</code>.</span>
