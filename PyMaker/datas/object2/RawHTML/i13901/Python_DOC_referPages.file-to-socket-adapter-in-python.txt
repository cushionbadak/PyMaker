<div class="post-text" itemprop="text">
<p>I want to use the <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a> library on Windows to read file-like objects (such as <code>sys.stdin</code> and <a href="https://pypi.python.org/pypi/pyserial" rel="nofollow noreferrer">serial ports</a>).</p>
<p>However, <code>asyncio</code> on Windows <a href="https://stackoverflow.com/questions/31510190/aysncio-cannot-read-stdin-on-windows">expects readable objects to be sockets</a>.</p>
<p>Is it possible to write an adapter class to wrap a file-like object with the API of a socket so that I could use <code>stdin</code> and serial ports with <code>asyncio</code>?</p>
<p>If so, please could you give an example because I've never used sockets before?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Short answer</h2>
<p>No and maybe yes.</p>
<h2>Long answer</h2>
<p>You can't just wrap a file-like object as a socket, or vice-versa, and expect it to work. <code>asyncio</code> is using system calls under the hood to do its async magic and <code>stdin</code> is <code>stdin</code> from the system's point of view no mater how much you wrap it. When using the default <code>SelectorEventLoop</code> it uses one of the <a href="https://docs.python.org/3/library/select.html" rel="nofollow">select</a>-like system calls. On Windows it uses the <a href="https://docs.python.org/3/library/select.html#select.select" rel="nofollow"><code>select</code></a> system call, which does <strong>not</strong> support anything but sockets.</p>
<p>So, <code>select</code> sucks on windows. Is there another option? Yes. On Windows, and only Windows, there is another API for doing async operations called <code>IOCP (I/O Completion Ports)</code>. It's a <code>"notify-on-completion"</code> type multiplexer as opposed to the <code>select</code> based <code>"notify-when-ready"</code> type multiplexers. The API is much more complicated than doing a simple <code>select</code> call on a file, but fortunately <code>asyncio</code> has <em>some</em> support for it already. </p>
<p>The <code>ProactorEventLoop</code> uses IOCP on Windows and it should theoretically supports reading from <code>stdin</code>. I don't have access to a Windows machine so I can't test this, but give this a go:</p>
<pre><code># vim: filetype=python3 tabstop=2 expandtab

import asyncio as aio
import os
import sys

if os.name == "nt":
  proactor_loop = aio.ProactorEventLoop()
  aio.set_event_loop(proactor_loop)

@aio.coroutine
def main(loop):
  stdin_reader = aio.StreamReader()
  stdin_transport, stdin_protocol = yield from loop.connect_read_pipe(
    lambda: aio.StreamReaderProtocol(stdin_reader),
    sys.stdin
  )

  line = yield from stdin_reader.read()
  print(line.strip().decode("utf-8"))

  stdin_transport.close()

loop = aio.get_event_loop()
loop.run_until_complete(main(loop))
loop.close()
</code></pre>
<p>And run the equivalent of this on Windows:</p>
<pre><code>$ echo blha blha blha | python test.py
blha blha blha
</code></pre>
<p>If this works, then at least you can do async <code>stdin</code> on Windows. And then you could try something similar for <code>stdout/stderr</code> or perhaps even serial ports.</p>
<p>If all else fails, you could always simulate async behaviour by wrapping blocking calls in threads using the <code>loop.run_in_executor</code> coroutine:</p>
<pre><code>yield from loop.run_in_executor(None, sys.stdin.readline)
</code></pre>
</div>
<span class="comment-copy">Example doesn't work unfortunatelly :( Fails at "yield from stdin_reader.read()" part with "OSError: [WinError 6] The handle is invalid" error</span>
<span class="comment-copy">Ahh, I was afraid it wouldn't work. --- Using a thread pool (i.e. <code>run_in_executor</code>) should work though and should be sufficient for most use cases.</span>
<span class="comment-copy">Rather than use <code>sys.stdin</code>, would <code>os.fdopen(sys.stdin.fileno(), 'rb')</code> work? Pass in a new binary file object for the file handle, not the textiowrapper.</span>
