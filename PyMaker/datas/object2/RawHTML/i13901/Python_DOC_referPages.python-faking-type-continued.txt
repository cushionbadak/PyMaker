<div class="post-text" itemprop="text">
<p>I'm trying to implement this: <a href="https://stackoverflow.com/questions/6803597/how-to-fake-type-with-python">How to fake type with Python</a>. I'm wrapping some .NET objects I don't control, so don't want <code>__new__</code> to be called on them by the instantiation of the class in the wrapper. I've taken the code from the question above and built a simple example:</p>
<pre><code>class WrappableInt(object):
    def __new__(cls,*args,**kwargs):
        print("Making a new wrapint")
        return super().__new__(cls)
    def __init__(self,x):
        self.x=x


def wrap_user(wrapee):
    class wrapped_user(type(wrapee)):
        def __new__(cls,*args,**kwargs):
            return object.__new__(cls)
        def __init__(self):
            pass
        def gimmieFive(self):
            return 5
        def __getattribute__(self, attr):
            self_dict = object.__getattribute__(type(self), '__dict__')
            if attr in self_dict:
                return self_dict[attr]
            return getattr(wrapee, attr)
    return wrapped_user()
</code></pre>
<p>When I run the following tests, everything is as expected:</p>
<pre><code>&gt;&gt;&gt; z=WrappableInt(3)
Making a new wrapint
&gt;&gt;&gt; p=wrap_user(z)
&gt;&gt;&gt; print(p.x)
3
</code></pre>
<p>However, when I run gimmieFive, I get the following:</p>
<pre><code>&gt;&gt;&gt; p.gimmieFive()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: gimmieFive() missing 1 required positional argument: 'self'
</code></pre>
<p>Why does python think <code>gimmieFive</code> is a static method, when it seems to know <code>__getattribute__</code> is not? It will happily run e.g.:</p>
<pre><code>&gt;&gt;&gt; p.gimmieFive(1)
5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are bypassing the normal <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow">descriptor protocol</a> here. <code>__getattribute__</code> does more than just look up names on the class, it also <em>binds</em> them if the object retrieved supports binding.</p>
<p>Python function objects are descriptors, binding them to an instance produces a method object that, when called, passes in the bound instance as the first function argument. You are returning the original unbound function object.</p>
<p>Re-implementing binding behaviour is.. complex. In case of a conflict between a instance attribute and a descriptor object retrieved from the class, you'll need to check for local attributes, determine if the descriptor is a data descriptor or regural descriptor, and decide which one to return.</p>
<p>A simple and basic implementation would at the very least need to support <code>__get__</code> binding:</p>
<pre><code>if attr in self_dict:
    obj = self_dict[attr]
    if hasattr(obj, '__get__'):
        obj = obj.__get__(self, type(self))
    return obj
</code></pre>
<p>This may be enough for your usecase since your <code>wrapped_user</code> class doesn't have any data descriptors right now.</p>
<p>With the above change, your specific example works as expected:</p>
<pre><code>&gt;&gt;&gt; z=WrappableInt(3)
Making a new wrapint
&gt;&gt;&gt; p=wrap_user(z)
&gt;&gt;&gt; print(p.x)
3
&gt;&gt;&gt; p.gimmieFive()
5
</code></pre>
</div>
<span class="comment-copy">Are there any things about Python you don't know?</span>
