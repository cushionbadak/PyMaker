<div class="post-text" itemprop="text">
<p>I have several billion strings in the format word0.word1.word2, and I wish to perform modulo n on those strings so that I can feed each to a database writer for storage. I know I can perform a form a modulo 10 on the first character of the strings like this:</p>
<pre><code>for i in ["a.b","c.d"]: 
    print ord(i[0]) % 10
</code></pre>
<p>This won't divide my strings evenly, though, as word0, word1, and word2 are sorted into alphabetical order, and the first character of the string is very often "a". I could take the last letter of the string, but am not sure if those are normally distributed or not. </p>
<p><strong>My question</strong>: Is there a fast way to perform something like "ord" on the entire string? I ultimately plan to run modulo 48 on the integer representations of the strings, and wish for that modular output to be uniformly distributed across all 48 cores. I would be grateful for any help others can offer.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>s = "whatever"  # have a string
h = hash(s)     # obtain its hash
bin = h % 48    # find the bin
</code></pre>
<p>Update: The Python's built-in <code>hash</code> function provides deterministic values only for a single process. If you want to keep this information (directly or indirectly ) in a database you have to use an explicit hash function that doesn't include any random data. (Credit goes to @Alik)</p>
</div>
<span class="comment-copy">So basically you are looking for a good <a href="https://en.wikipedia.org/wiki/Hash_function" rel="nofollow noreferrer">hash function</a> I think your best bet would be to take an existing implementation</span>
<span class="comment-copy">What should <code>something_like_ord(whole_string)</code> return?</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/5297448/how-to-get-md5-sum-of-a-string" title="how to get md5 sum of a string">stackoverflow.com/questions/5297448/â€¦</a></span>
<span class="comment-copy">@boardrider md5 is a cryptographic hash function, not the one you want to use in hashmap-like structures.</span>
<span class="comment-copy">Thanks @dlask. I realized halfway through typing out the question that I am indeed after a good hash function. I'll accept this answer and fish around for the optimal implementation of <code>hash()</code></span>
<span class="comment-copy">This is not a template, it's a working code. The <code>hash</code> function is provided directly by Python. However, you can use another hash function, of course.</span>
<span class="comment-copy">@duhaime please, read carefully documentation on <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__</code></a> function. The most important part here is the last note. Also even if you use old Python3 versions or Python 2.7 <code>__hash__</code> is not guaranteed to be a <a href="https://en.wikipedia.org/wiki/Hash_function#Determinism" rel="nofollow noreferrer">deterministic function</a>.</span>
<span class="comment-copy">Thank you @Alik, this is essential. Do you know of a fast deterministic hash function that would help create a fairly uniform distribution appropriate for my %48 situation? Non-deterministic hashes are out of the question.</span>
<span class="comment-copy">@duhaime all hashes must be deterministic functions. Cryptographic hash function is a <i>hash</i> function which is very hard to revert (i.e. get original input given hash value only). Usually they are slower compared to non-cryptographic hashes (see comparison table on xxHash's homepage - MD5, SHA1 are cryptographic hashes)</span>
