<div class="post-text" itemprop="text">
<p>I'm having trouble working with an Enum where some attributes have the same value. I think Enums are so new to python that I can't find any other reference to this issue. In any case, let's say I have the following</p>
<pre><code>class CardNumber(Enum):
    ACE      = 11
    TWO      = 2
    THREE    = 3
    FOUR     = 4
    FIVE     = 5
    SIX      = 6
    SEVEN    = 7
    EIGHT    = 8
    NINE     = 9
    TEN      = 10
    JACK     = 10
    QUEEN    = 10
    KING     = 10
</code></pre>
<p>Clearly these are the card numbers and their corresponding values in black jack. The ten through king have the same value. But if I do something like <code>print(CardNumber.QUEEN)</code>, I get back <code>&lt;CardNumber.TEN: 10&gt;</code>. What's more, if I iterate over these, it simply iterates over unique values.</p>
<pre><code>&gt;&gt;&gt; for elem in CardNumber:
...     print(elem)
CardNumber.ACE
CardNumber.TWO
CardNumber.THREE
CardNumber.FOUR
CardNumber.FIVE
CardNumber.SIX
CardNumber.SEVEN
CardNumber.EIGHT
CardNumber.NINE
CardNumber.TEN
</code></pre>
<p>How can I get around this issue? I want CardNumber.QUEEN and CardNumber.TEN to be unique, and both appear in any iteration. The only thing I could think of was to give each attribute a second value which would act as a distinct id, but that seems unpythonic.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, labels with duplicate values are turned into aliases for the first such label.</p>
<p>You can enumerate over the <code>__members__</code> attribute, it is an ordered dictionary with the aliases included:</p>
<pre><code>&gt;&gt;&gt; for name, value in CardNumber.__members__.items():
...     print(name, value)
... 
ACE CardNumber.ACE
TWO CardNumber.TWO
THREE CardNumber.THREE
FOUR CardNumber.FOUR
FIVE CardNumber.FIVE
SIX CardNumber.SIX
SEVEN CardNumber.SEVEN
EIGHT CardNumber.EIGHT
NINE CardNumber.NINE
TEN CardNumber.TEN
JACK CardNumber.TEN
QUEEN CardNumber.TEN
KING CardNumber.TEN
</code></pre>
<p>However, if you must have label-and-value pairs that are unique (and not aliases), then <code>enum.Enum</code> is the wrong approach here; it doesn't match the usecases for a card game.</p>
<p>In that case it'll be better to use a dictionary (consider using <code>collections.OrderedDict()</code> if order is important too).</p>
</div>
<div class="post-text" itemprop="text">
<p><em>Update</em></p>
<p>Using (<code>aenum</code>)](<a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer">https://pypi.python.org/pypi/aenum</a>)<sup>1</sup> you have a couple choices:</p>
<ul>
<li><p>use <code>NamedConstant</code> instead: does not provide any of the <code>Enum</code> extras (iterating, lookups, etc.) [see: original answer below]</p></li>
<li><p>use <code>NoAlias</code>: has all the normal <code>Enum</code> behavior except every member is unique and by-value lookups are not available</p></li>
</ul>
<p>An example of <code>NoAlias</code>:</p>
<pre><code>from aenum import Enum, NoAlias

class CardNumber(Enum):

    _order_ = 'EIGHT NINE TEN JACK QUEEN KING ACE'  # only needed for Python 2.x
    _settings_ = NoAlias

    EIGHT    = 8
    NINE     = 9
    TEN      = 10
    JACK     = 10
    QUEEN    = 10
    KING     = 10
    ACE      = 11
</code></pre>
<p>and in use:</p>
<pre><code>&gt;&gt;&gt; list(CardNumber)
[&lt;CardNumber.EIGHT: 8&gt;, &lt;CardNumber.NINE: 9&gt;, &lt;CardNumber.TEN: 10&gt;, &lt;CardNumber.JACK: 10&gt;, &lt;CardNumber.QUEEN: 10&gt;, &lt;CardNumber.KING: 10&gt;, &lt;CardNumber.ACE: 11&gt;]

&gt;&gt;&gt; CardNumber.QUEEN == CardNumber.KING
False

&gt;&gt;&gt; CardNumber.QUEEN is CardNumber.KING
False

&gt;&gt;&gt; CardNumber.QUEEN.value == CardNumber.KING.value
True

&gt;&gt;&gt; CardNumber(8)
Traceback (most recent call last):
  ...
TypeError: NoAlias enumerations cannot be looked up by value
</code></pre>
<hr/>
<p><em>Original Answer</em></p>
<p>If you want named constants and don't care about the other features of <code>Enum</code>s, you can use the <code>NamedConstant</code> class from the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer">aenum library</a>:</p>
<pre><code>from aenum import NamedConstant

class CardNumber(NamedConstant):
    ACE      = 11
    TWO      = 2
    THREE    = 3
    FOUR     = 4
    FIVE     = 5
    SIX      = 6
    SEVEN    = 7
    EIGHT    = 8
    NINE     = 9
    TEN      = 10
    JACK     = 10
    QUEEN    = 10
    KING     = 10
</code></pre>
<p>Duplicate values are still distinct:</p>
<pre><code>&gt;&gt;&gt; CardNumber.TEN is CardNumber.JACK
False

&gt;&gt;&gt; CardNumber.TEN == CardNumber.JACK
True

&gt;&gt;&gt; CardNumber.TEN == 10
True
</code></pre>
<hr/>
<p><sup>1</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="nofollow noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="nofollow noreferrer">Advanced Enumeration (<code>aenum</code>)</a>  library.</p>
</div>
<span class="comment-copy"><code>Enum</code> is clearly not the right choice for this. Why not e.g. an <code>OrderedDict</code> instead?</span>
<span class="comment-copy">Both you and jonrsharpe are correct about the fact that I should be using Dicts for this case. I was merely using this as an example, but you have helped me solve my issue, in any case.</span>
