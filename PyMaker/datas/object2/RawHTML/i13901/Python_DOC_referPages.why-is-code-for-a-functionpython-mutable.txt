<div class="post-text" itemprop="text">
<p>In a previous question yesterday, in comments, I came to know that in python <code>__code__</code> atrribute of a function is mutable. Hence I can write code as following</p>
<pre><code>def foo():
    print "Hello"

def foo2():
    print "Hello 2"

foo()
foo.__code__ = foo2.__code__
foo()
</code></pre>
<p>Output</p>
<pre><code>Hello
Hello 2
</code></pre>
<p>I tried googling, but either because there is no information(I highly doubt this), or the keyword (<code>__code__</code>) is not easily searchable, I couldn't find a use case for this.</p>
<p>It doesn't seem like "because most things in Python are mutable" is a reasonable answer either, because other attributes of functions — <code>__closure__</code> and <code>__globals__</code> — are explicitly read-only (from <a href="https://github.com/python/cpython/blob/master/Objects/funcobject.c#L236">Objects/funcobject.c</a>):</p>
<pre><code>static PyMemberDef func_memberlist[] = {
    {"__closure__",   T_OBJECT,     OFF(func_closure),
     RESTRICTED|READONLY},
    {"__doc__",       T_OBJECT,     OFF(func_doc), PY_WRITE_RESTRICTED},
    {"__globals__",   T_OBJECT,     OFF(func_globals),
     RESTRICTED|READONLY},
    {"__module__",    T_OBJECT,     OFF(func_module), PY_WRITE_RESTRICTED},
    {NULL}  /* Sentinel */
};
</code></pre>
<p>Why would <code>__code__</code> be writable while other attributes are read-only?</p>
</div>
<div class="post-text" itemprop="text">
<p>The fact is, most things in Python <em>are</em> mutable.  So the real question is, why are <code>__closure__</code> and <code>__globals__</code> <em>not</em>?</p>
<p>The answer initially appears simple.  Both of these things are containers for variables which the function might need.  The code object itself does not carry its closed-over and global variables around with it; it merely knows how to get them from the function.  It grabs the actual values out of these two attributes when the function is called.</p>
<p>But the scopes themselves are mutable, so this answer is unsatisfying.  We need to explain why modifying these things in particular would break stuff.</p>
<p>For <code>__closure__</code>, we can look to its structure.  It is not a mapping, but a tuple of cells.  It <em>doesn't know the names of the closed-over variables</em>.  When the code object looks up a closed-over variable, it needs to know its position in the tuple; they match up one-to-one with <code>co_freevars</code> which is also read-only.  And if the tuple is of the wrong size or not a tuple at all, this mechanism breaks down, probably violently (read: segfaults) if the underlying C code isn't expecting such a situation.  Forcing the C code to check the type and size of the tuple is needless busy-work which can be eliminated by making the attribute read-only.  If you try to replace <code>__code__</code> with something taking a different number of free variables, <a href="https://github.com/python/cpython/blob/master/Objects/funcobject.c#L269" rel="nofollow">you get an error</a>, so the size is always right.</p>
<p>For <code>__globals__</code>, the explanation is less immediately obvious, but I'll speculate.  The scope lookup mechanism expects to have access to the global namespace at all times.  Indeed, the bytecode may be <a href="https://docs.python.org/2/library/dis.html#opcode-LOAD_GLOBAL" rel="nofollow">hard-coded</a> to go straight to the global namespace, if the compiler can prove no other namespace will have a variable with a particular name.  If the global namespace was suddenly <code>None</code> or some other non-mapping object, the C code could, once again, violently misbehave.  Again, making the code perform needless type checks would be a waste of CPU cycles.</p>
<p>Another possibility is that (normally-declared) functions <a href="https://docs.python.org/3/c-api/intro.html#reference-count-details" rel="nofollow">borrow a reference</a> to the module's global namespace, and making the attribute writable would cause the reference count to get messed up.  I could imagine this design, but I'm not really sure it's a great idea since functions can be constructed explicitly with objects whose lifetimes might be shorter than that of the owning module, and these would need to be special-cased.</p>
</div>
<span class="comment-copy">You can't prevent any sort of this 'nefariousness' in Python, <code>__code__</code> or not. Either trust the modules used, or don't use them.</span>
<span class="comment-copy">Yes. I have found that to be usually the case. But still thought to ask.</span>
<span class="comment-copy">Practice safe stacks instead of hooking into strange APIs.</span>
<span class="comment-copy">It's a peculiar design choice I'll give you that. Everything on a function aside from <code>__globals__</code> and <code>__closure__</code> is writeable. Why only those two are read-only is anyone's guess.</span>
<span class="comment-copy">@AkshatHarit Whoops, it looks like my answer ("most things in Python") is not helpful. I hope you'll forgive me for editing your question a bit to clarify why this is actually an interesting and not straight forward question.</span>
<span class="comment-copy">I don't buy the <code>__closure__</code> explanation: adding a setter that does some type checking would be easy (see, ex, the setter for <code>__code__</code>, which does exactly that: <a href="https://github.com/python/cpython/blob/master/Objects/funcobject.c#L254" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Objects/funcobject.c#L254</a>)</span>
<span class="comment-copy">@DavidWolever: It's still one of the <i>least</i> user-friendly interfaces out there.  You have to get the variable order right, and it's not a tuple of normal objects but a tuple of "cells."  Perhaps the type checking code is simply more trouble than it's worth, in the minds of the core developers.</span>
<span class="comment-copy">I definitely don't buy the <code>__globals__</code> argument, considering that <code>g = {k:v for k,v in func.__globals__.items() if k in allowed}; new_func = types.FunctionType(func.__code__, g, func.__name__, func.__defaults__, func.__closure__)</code> is valid python</span>
<span class="comment-copy">@NightShadeQueen: Have you tried it with <code>None</code>?  I imagine that throws.</span>
<span class="comment-copy">Yep, TypeError. It did let me make a function with an defaultdict for globals, though</span>
