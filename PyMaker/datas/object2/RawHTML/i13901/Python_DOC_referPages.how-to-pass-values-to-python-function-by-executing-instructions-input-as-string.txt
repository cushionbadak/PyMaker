<div class="post-text" itemprop="text">
<p>I have a function:  </p>
<pre><code>def foo(a=0, b=0, c=0, val=0, someotherval=0):  
    print val + someotherval  
</code></pre>
<p>This function is called inside a file <code>bar.py</code>. When I run <code>bar.py</code> from the console, I want to pass the arguments to the function as a string:  </p>
<pre><code>&gt;&gt;python bar.py "val=3"  
</code></pre>
<p>So the function <code>foo</code> interprets it as:  </p>
<pre><code>foo(val=3)  
</code></pre>
<p>I have attempted to use the <code>exec</code> command. In my <code>bar.py</code> file:  </p>
<pre><code>import sys
cmdlinearg = sys.argv[1]    # capturing commandline argument
foo(exec(cmdlinearg))  
</code></pre>
<p>But I get a syntax error.<br/>
I understand that I can just pass the argument values themselves, but with a function with many arguments, I do not want the end user to enter 0s for unneeded arguments:  </p>
<pre><code>&gt;&gt;python bar.py "0" "0" "0" "3"  
</code></pre>
<p>Is there a way to accomplish this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have no concern for safety, you can just do</p>
<pre><code>exec('foo(%s)' % sys.argv[1])
</code></pre>
<p>Or this:</p>
<pre><code>def getdict(**vals):
    return vals
kwargs = exec('getdict(%s)' % sys.argv[1])
foo(**kwargs)
</code></pre>
<p>However, if your concern is the user's ease of use, maybe you should take a look at <a href="https://docs.python.org/2.7/library/argparse.html" rel="nofollow">argparse</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would rather do this the proper way and use argparse.</p>
<p>Your command line interface would look such as:</p>
<pre><code>bar.py --a 0 --b 0 --c 0 --val 0 --someotherval 0
</code></pre>
<p>And the code something along:</p>
<pre><code>import argparse

def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('a', type=int, default=0)
  ...
  args = parser.parse_args()
  foo(a=args.a, b=args.b, c=args.c, var=args.val, someotherval=args.someotherval)

if __name__ == '__main__':
  main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about using the <a href="https://docs.python.org/2/library/argparse.html" rel="nofollow">argparse</a> for parsing the command line arguments?</p>
<p>Example -</p>
<pre><code>import argparse

def foo(a=0, b=0, c=0, val=0, someotherval=0):  
    print(val + someotherval)

parser = argparse.ArgumentParser(description='Some Parser')
parser.add_argument('-a','--a',default=0,type=int,help="value for a")
parser.add_argument('-b','--b',default=0,type=int,help="value for a")
parser.add_argument('-c','--c',default=0,type=int,help="value for a")
parser.add_argument('-v','--val',default=0,type=int,help="value for a")
parser.add_argument('-s','--someotherval',default=0,type=int,help="value for a")
args = parser.parse_args()
foo(a=args.a,b=args.b,c=args.c,val=args.val,someotherval=args.someotherval)
</code></pre>
<p>Then you can call and get results like -</p>
<pre><code>&gt;python a.py
0

&gt;python a.py --val 10
10

&gt;python a.py --val 10 --someotherval 100
110
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Take a look at this library:
<a href="http://click.pocoo.org" rel="nofollow">http://click.pocoo.org</a></p>
<p>It may be useful in your case.</p>
<pre><code>import click

@click.command()
@click.option('-a', default=0)
@click.option('-b', default=0)
@click.option('-c', default=0)
@click.option('--val', default=0)
@click.option('--someotherval', default=0)
def foo(a, b, c, val, someotherval):  
    print val + someotherval

if __name__ == '__main__':
    foo()
</code></pre>
<p>However, you have to add use options as arguments, not strings:</p>
<pre><code>&gt;&gt; python bar.py --val=3  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could just default the values for the other parameters if you know that they are never going to enter them. </p>
<pre><code>foo(0,0,exec(cmdlinearg),0)
</code></pre>
</div>
<span class="comment-copy">Just use <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer">argparse</a></span>
<span class="comment-copy">The argparse-based solutions are probably what you are looking for, but you could do <code>eval("foo(" + sys.argv[1] +")")</code>. Bear in mind that <a href="http://stackoverflow.com/questions/1832940/is-using-eval-in-python-a-bad-practice">the use of eval() is questionable</a>.</span>
<span class="comment-copy">From <a href="http://stackoverflow.com/questions/2428117/casting-raw-strings-python">here</a> <code>cmdlinearg.encode('string-escape')</code> for pre Py3 <code>cmdlinearg.encode('unicode-escape')</code> for Py3.x</span>
<span class="comment-copy">you can also do <code>foo(**vars(args))</code> if all the arguments pertain to <code>foo</code>. (<code>vars</code> converts to a dictionary, <code>**</code> unpacks it)</span>
<span class="comment-copy">@NightShadeQueen You could do that if the cmd line args match the function parameters. It's just that as the python zen mentions "explicit is better than implicit". I wouldn't like the idea of the code failing when adding a new cmd line argument (say --debug or whatever)</span>
<span class="comment-copy">That won't work. One user might want to call foo(a=4), another might want to call foo(b=3, somotherval=10).</span>
