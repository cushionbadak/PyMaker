<div class="post-text" itemprop="text">
<p>Is there a better way to do this?</p>
<pre><code>$ python
Python 2.7.9 (default, Jul 16 2015, 14:54:10)
[GCC 4.1.2 20080704 (Red Hat 4.1.2-55)] on linux2

Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.sub(u'[\U0001d300-\U0001d356]', "", "")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/fast/services/lib/python2.7/re.py", line 155, in sub
    return _compile(pattern, flags).sub(repl, string, count)
  File "/home/fast/services/lib/python2.7/re.py", line 251, in _compile
    raise error, v # invalid expression
sre_constants.error: bad character range
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Python narrow and wide build (Python versions below 3.3)</h2>
<p>The error suggests that you are using "narrow" (UCS-2) build, which only supports Unicode code points up to 65535 as one "Unicode character"<sup>1</sup>. Characters whose code points are above 65536 are represented as surrogate pairs, which means that the Unicode string <code>u'\U0001d300'</code> consists of two "Unicode character" in narrow build.</p>
<pre><code>Python 2.7.8 (default, Jul 25 2014, 14:04:36)
[GCC 4.8.3] on cygwin
&gt;&gt;&gt; import sys; sys.maxunicode
65535
&gt;&gt;&gt; len(u'\U0001d300')
2
&gt;&gt;&gt; [hex(ord(i)) for i in u'\U0001d300']
['0xd834', '0xdf00']
</code></pre>
<p>In "wide" (UCS-4) build, all 1114111 code points are recognized as Unicode character, so the Unicode string <code>u'\U0001d300'</code> consists of exactly one "Unicode character"/Unicode code point.</p>
<pre><code>Python 2.6.6 (r266:84292, May  1 2012, 13:52:17)
[GCC 4.4.6 20110731 (Red Hat 4.4.6-3)] on linux2
&gt;&gt;&gt; import sys; sys.maxunicode
1114111
&gt;&gt;&gt; len(u'\U0001d300')
1
&gt;&gt;&gt; [hex(ord(i)) for i in u'\U0001d300']
['0x1d300']
</code></pre>
<p><sup><sup>1</sup> I use "Unicode character" (in quotes) to refer to one character in Python Unicode string, not one Unicode code point. The number of "Unicode characters" in a string is the <code>len()</code> of the string. In "narrow" build, one "Unicode character" is a 16-bit code unit of UTF-16, so one astral character will appear as two "Unicode character". In "wide" build, one "Unicode character" always corresponds to one Unicode code point.</sup></p>
<h2>Matching astral plane characters with regex</h2>
<h3>Wide build</h3>
<p>The regex in the question compiles correctly in "wide" build:</p>
<pre><code>Python 2.6.6 (r266:84292, May  1 2012, 13:52:17)
[GCC 4.4.6 20110731 (Red Hat 4.4.6-3)] on linux2
&gt;&gt;&gt; import re; re.compile(u'[\U0001d300-\U0001d356]', re.DEBUG)
in
  range (119552, 119638)
&lt;_sre.SRE_Pattern object at 0x7f9f110386b8&gt;
</code></pre>
<h3>Narrow build</h3>
<p>However, the same regex won't work in "narrow" build, since the engine does not recognize surrogate pairs. It just treats <code>\ud834</code> as one character, then tries to create a character range from <code>\udf00</code> to <code>\ud834</code> and fails.</p>
<pre><code>Python 2.7.8 (default, Jul 25 2014, 14:04:36)
[GCC 4.8.3] on cygwin
&gt;&gt;&gt; [hex(ord(i)) for i in u'[\U0001d300-\U0001d356]']
['0x5b', '0xd834', '0xdf00', '0x2d', '0xd834', '0xdf56', '0x5d']
</code></pre>
<p>The workaround is to use the <a href="https://stackoverflow.com/questions/28896329/regex-to-match-egyptian-hieroglyphics/28918460#28918460">same method as done in ECMAScript</a>, where we will construct the regex to match the surrogates representing the code point.</p>
<pre><code>Python 2.7.8 (default, Jul 25 2014, 14:04:36)
[GCC 4.8.3] on cygwin
&gt;&gt;&gt; import re; re.compile(u'\ud834[\udf00-\udf56]', re.DEBUG)
literal 55348
in
  range (57088, 57174)
&lt;_sre.SRE_Pattern object at 0x6ffffe52210&gt;
&gt;&gt;&gt; input =  u'Sample \U0001d340. Another \U0001d305. Leave alone \U00011000'
&gt;&gt;&gt; input
u'Sample \U0001d340. Another \U0001d305. Leave alone \U00011000'
&gt;&gt;&gt; re.sub(u'\ud834[\udf00-\udf56]', '', input)
u'Sample . Another . Leave alone \U00011000'
</code></pre>
<h3>Using <a href="https://mothereff.in/regexpu" rel="noreferrer">regexpu</a> to derive astral plane regex for Python narrow build</h3>
<p>Since the construction to match astral plane characters in Python narrow build is the same as ES5, you can use regexpu, a tool to convert RegExp literal in ES6 to ES5, to do the conversion for you.</p>
<p>Just paste the <em>equivalent</em> regex in ES6 (note the <code>u</code> flag and <code>\u{hh...h}</code> syntax):</p>
<pre><code>/[\u{1d300}-\u{1d356}]/u
</code></pre>
<p>and you get back the regex which can be used in both Python narrow build and ES5</p>
<pre><code>/(?:\uD834[\uDF00-\uDF56])/
</code></pre>
<p>Do take note to remove the delimiter <code>/</code> in JavaScript RegExp literal when you want to use the regex in Python.</p>
<p>The tool is extremely useful when the range spread across multiple high surrogates (U+D800 to U+DBFF). For example, if we have to match the character range</p>
<pre><code>/[\u{105c0}-\u{1cb40}]/u
</code></pre>
<p>The equivalent regex in Python narrow build and ES5 is</p>
<pre><code>/(?:\uD801[\uDDC0-\uDFFF]|[\uD802-\uD831][\uDC00-\uDFFF]|\uD832[\uDC00-\uDF40])/
</code></pre>
<p>which is rather complex and error-prone to derive.</p>
<h2>Python version 3.3 and above</h2>
<p><a href="https://docs.python.org/3/whatsnew/3.3.html#functionality" rel="noreferrer">Python 3.3</a> implements <a href="http://www.python.org/dev/peps/pep-0393" rel="noreferrer">PEP 393</a>, which eliminates the distinction between narrow build and wide build, and Python from now behaves like a wide build. This eliminates the problem in the question altogether.</p>
<h2>Compatibility issues</h2>
<p>While it's possible to workaround and match astral plane characters in Python narrow builds, going forward, it's best to change the execution environment by using Python wide builds, or port the code to use with Python 3.3 and above.</p>
<p>The regex code for narrow build is hard to read and maintain for average programmers, and it has to be completely rewritten when porting to Python 3.</p>
<h3>Reference</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/1446347/how-to-find-out-if-python-is-compiled-with-ucs-2-or-ucs-4">How to find out if Python is compiled with UCS-2 or UCS-4?</a></li>
</ul>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/393843/python-and-regular-expression-with-unicode">This question</a> seems similar but neither answer seems to work for this.</span>
<span class="comment-copy">You need to install wide build for that to work (probably). In narrow build, you have to write the regex like how you would do in JS (match 16-bit code units)</span>
<span class="comment-copy">The code works fine for me as is.  I am also using Python 2.7.9 but mine is compiled for Debian (Stable/Jessie) with GCC 4.9.2, as opposed to the OP's RedHat with GCC 4.1.2.</span>
<span class="comment-copy">wow, I wish I could give more than one upvote for this incredibly thorough answer. This is <i>very</i> helpful! Thank you</span>
<span class="comment-copy">After considering the excellent work-arounds suggested, I ended up re-installing python with wide builds. For reference, this is what that looked like:  <code>$ ./configure --enable-unicode=ucs4 --prefix=/my/path --exec-prefix=/my/path</code> <code>$ make &amp;&amp; make install</code>  I am going to include something that checks for the wide build version and warns the user, using your suggestion to check sys.maxunicode.  Much appreciated!</span>
<span class="comment-copy">Thank you for this great answer. I had a similar issue and ended up adding some code inside the function that does the regex substitution to check <code>sys.maxunicode</code> and in case of narrow builds replace all surrogate pairs (regex <code>[\uD800-\uDBFF][\uDC00-\uDFFF]</code>) with whatever I wanted the replacement for the "actual" unicode character to be.</span>
