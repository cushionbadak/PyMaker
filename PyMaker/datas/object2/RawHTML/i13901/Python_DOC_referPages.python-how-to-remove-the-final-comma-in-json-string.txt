<div class="post-text" itemprop="text">
<p>Hi I have just started experimenting with python and tornado along with mongodb(I am a newbie). I have written a simple get function to get all the values from my mongodb and return it in JSON format. The problem is when I try to write the output as a JSON string I get a trailing comma(,) after the last record from the collection.</p>
<pre><code>class TypeList(APIHandler):
@gen.coroutine
def get(self):
    cursor = db.vtype.find()
    self.write("{"'"success"'": 1, "'"data"'":[")
    while (yield cursor.fetch_next):
        document = cursor.next_object()
        self.write(format(JSONEncoder().encode(document)))
        self.write(",")
    self.write("]}")

class JSONEncoder(json.JSONEncoder):
def default(self, o):
    if isinstance(o,ObjectId):
        return str(o)
    return json.JSONEncoder.default(self, o)
</code></pre>
<p>And my output is like</p>
<pre><code>{"success": 1, "data":[{"_id": "55a5e988545779f35d3ecdf4", "name": "fgkd", "city": "fghj"},{"_id": 12345.0, "name": "adfs", "city": "asd"},]}
</code></pre>
<p>Can anyone tell me how can I get rid of that trailing comma(,) after my last record, because of that comma I am getting an error malformed JSON string</p>
<p>I have tried using json dumps</p>
<pre><code>@gen.coroutine
def get(self):
    cursor = db.vtype.find({"brand": "Tata"})
    while (yield cursor.fetch_next):
        document = cursor.next_object()
        self.write(json.dumps(document,default=json_util.default))
</code></pre>
<p>got the output as </p>
<p><code>{"Reg": "11ts", "_id": {"$oid": "55a5e988545779f35d3ecdf4"}, "Name": "Alex"}{"Reg": "12ts", "_id": {"$oid": "55a5eac6545779f35d3ecdf5"}, "Name": "asdf"}</code></p>
<p>When using <code>dumps[{ "data": document }]</code></p>
<p>I am getting the output as</p>
<pre><code>[{"data": {"Name": "asdf", "Reg": "asdfs", "_id": {"$oid": "55a5e988545779f35d3ecdf4"}}}]

[{"data": {"Name": "qwer", "Reg": "asdff", "_id": {"$oid": "55a5eac6545779f35d3ecdf5"}}}]
</code></pre>
<p>but I want the output like this</p>
<pre><code>{"data": [{"Name": "asdf", "Reg": "asdfs", "_id": {"$oid": "55a5e988545779f35d3ecdf4"}},{"Name": "qwer", "Reg": "asdff", "_id": {"$oid": "55a5eac6545779f35d3ecdf5"}}]}
</code></pre>
<p>If I am doing something wrong please tell me I dont know how to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no reason you should be building up JSON documents via text concatenation.</p>
<p>Python has a perfectly good <code>json</code> module in the standard library which you should be using. Build up your document as a Python list of dicts, then use <code>json.dumps()</code> to convert the whole thing to valid JSON.</p>
</div>
<div class="post-text" itemprop="text">
<p>So your problem is with MongoDB <code>ObjectId</code>? Then maybe you should have been using <a href="http://api.mongodb.org/python/current/api/bson/json_util.html" rel="nofollow"><code>bson.json_util</code></a>. It's probably already installed as part of your MongoDB driver dependecies ( which all use pymongo ), but if not then install it.</p>
<pre><code>import bson
import bson.json_util
from bson.json_util import dumps
from bson import ObjectId

dumps({ "a": ObjectId() })

'{"a": {"$oid": "55a782261d41c80b0432b811"}}'
</code></pre>
<p>Or:</p>
<pre><code>dumps([{ "a": ObjectId(), "b": 1 },{ "a": ObjectId(), "b": 2 }])
'[{"a": {"$oid": "55a79543268e150463d51799"}, "b": 1}, {"a": {"$oid": "55a79543268e150463d5179a"}, "b": 2}]'
</code></pre>
<p>And it works just like "dumps" except all the BSON type handling is built it.</p>
<p>Again, no need to re-invent the wheel here and "roll your own", because people already use this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your implementation of the JSONEncoder works well. Just use it the way it was intended to be used:</p>
<pre><code>&gt;&gt;&gt; JSONEncoder().encode({'data': [ObjectId(), ObjectId()]})
'{"data": ["&lt;objId&gt;", "&lt;objId&gt;"]}'
</code></pre>
<p>The encoder will take care of serializing dicts, objects, lists, tuples, strings (including unicode), ints, longs, floats, booleans and None. Your implementation makes it aware of <code>ObjectId</code>s as well. Perfect!</p>
<p>Just lose the string concatenation and use <code>encode</code>.</p>
</div>
<span class="comment-copy">You might want to <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">look at this</a></span>
<span class="comment-copy">Actually while using JSON dumps (json.dumps) I get an error "ObjectId(addsfsfsf)" is not JSON serializable. The ObjectId is from my mongodb</span>
<span class="comment-copy">Maybe your question should have asked about that instead.</span>
<span class="comment-copy">I have written the <code>class JSONEncoder</code> to overcome that serializer issue.</span>
<span class="comment-copy">Why re-invent the wheel though; if you figured out the issue with <code>json.dumps()</code> you might not have needed to bother with this now.</span>
<span class="comment-copy">when using <code>self.write(json.dumps(document))</code> getting error  <code>TypeError: ObjectId('55a5e988545779f35d3ecdf4') is not JSON serializable</code>.  Am I using json.dumps the right way pls guide me</span>
<span class="comment-copy">@TonyRoczz The sentiment here is correct. But there is a custom version of "dumps" with your mongodb library.</span>
<span class="comment-copy">to overcome the JSON serializable error i have <a href="http://stackoverflow.com/a/16586277/5039470">referred to</a></span>
<span class="comment-copy">Use bson.json_util, from PyMongo, which you've already installed along with Motor.</span>
<span class="comment-copy">can you just post the particular string? I have imported dumps from bson.json_util but it gives me the JSON not serializable error</span>
<span class="comment-copy">@TonyRoczz coded example right there. The output is supported <a href="http://docs.mongodb.org/manual/reference/mongodb-extended-json/" rel="nofollow noreferrer">"extended json"</a> which correctly identifies the "type" of the field. All in the documentation anyway.</span>
<span class="comment-copy">the dumps works fine when I use print instead of self.write</span>
<span class="comment-copy">@TonyRoczz Great. So use it. What the message was here is build your own dicts, use the natural dict responses and let something else handle the serialization. Just like CSV, it's nothing new, so it's all been done before.</span>
<span class="comment-copy">Thanks. the above example works but the issue is the above example does not differentiate the different records of the table the output is like this <code>{"type": "adfs", "_id": 12345.0, "brand": "asd"}{"type": "adfs", "_id": 12345.0, "brand": "asd"}</code> there should be a comma inbetween the different records otherwise its not a proper json string. Shouldnt there be a comma after to separate the two records?</span>
<span class="comment-copy">can you kindly guide me on how my code should be formed for this. How do you suggest my <code>JSONEncoder().encode(document)</code> statement should be. Thank you in advance</span>
<span class="comment-copy">I think Blake's answer is better, but if you want to keep <code>JSONEncoder</code> you can try something like <code>JSONEncoder().encode({'success': 1, 'data': items})</code> where <code>items</code> is a list of the documents returned by your query. You can probably get them all at once, or use your existing loop to fill an initially empty array.</span>
