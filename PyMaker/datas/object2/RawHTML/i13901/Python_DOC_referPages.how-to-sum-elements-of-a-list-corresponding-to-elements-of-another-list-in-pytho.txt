<div class="post-text" itemprop="text">
<p>I have two lists:</p>
<pre><code>a=[25,23,18,28]
</code></pre>
<p>and </p>
<pre><code>b=[1,2,2,3]
</code></pre>
<p>I want to sum the corresponding values in <code>a</code> to similar values in <code>b</code>, so it would look like this:</p>
<pre><code>return_a=(25,41,28)
return_b=(1,2,3)
</code></pre>
<p>Sorry for the confusion. Stealing JPeroutek's clarification: It looks to me like he wants only unique values to exist in <code>return_b</code>. The values in <code>a</code> correspond to those in <code>b</code>. Wherever you have a duplicate in <code>b</code>, you sum the corresponding <code>a</code> values.</p>
<p>Nathan Bartley's answer worked for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>A good way to do this would be to use a dictionary. The logic is very much like JPeroutek describes. You go through list b, store the corresponding number in list a, and if you encounter a value in b you've already seen, then you add the new number in a it. You might try something like this to generate it:</p>
<pre><code>res = {}
for ix in xrange(len(b)):
    cur_b = b[ix] # grab the next number in b
    cur_a = a[ix] # grab the corresponding number in a
    try: # if we've seen cur_b before then we can add cur_a to it
        res[cur_b] += cur_a 
    except KeyError: # otherwise we've never seen cur_b before so we set it to cur_a
        res[cur_b] = cur_a
</code></pre>
<p>In case the try &amp; except doesn't make sense you can rewrite those four lines to look like this</p>
<pre><code>if cur_b in res:  # this asks if cur_b is in the set of keys of res
    res[cur_b] += cur_a
else:
    res[cur_b] = cur_a
</code></pre>
<p>This will result in a dictionary that looks like the following:</p>
<pre><code>{(1, 25), (2, 41), (3, 28)}
</code></pre>
<p>It's important to note that the dictionary may not preserve the order that you want. For example:</p>
<pre><code>b = [3, 3, 2, 1]
a = [12, 4, 6, 6]
</code></pre>
<p>would result in</p>
<pre><code>{(1, 6), (2, 6), (3, 15)}
</code></pre>
<p>If ordering is important, this would pose a problem with the next step.</p>
<hr/>
<p>You can split the dictionary into ret_a and ret_b by messing with the result of     </p>
<pre><code>res.items()
</code></pre>
<p>for instance:</p>
<pre><code>ret_a = [t[1] for t in res.items()]
ret_b = [t[0] for t in res.items()]
</code></pre>
</div>
<span class="comment-copy">I'm not quite sure i understood your intention</span>
<span class="comment-copy">This is not clear at all</span>
<span class="comment-copy">@omri_saadon The intention is to combine all elements in list b with the same value and then to sum the corresponding elements in list a.</span>
<span class="comment-copy">It looks to me like he wants only unique values to exist in <code>return_b</code>.  The values in <code>a</code> correspond to those in <code>b</code>.  Wherever you have a duplicate in <code>b</code>, you sum the corresponding <code>a</code> values.   Seems to me like a dictionary would be a better approach for your data.</span>
<span class="comment-copy">Mind <a href="https://stackoverflow.com/posts/31479820/edit">edit</a>ing the question to make it clearer?</span>
<span class="comment-copy">I tried to clarify some code, in case you haven't seen some of this before.</span>
<span class="comment-copy">The try and except worked. Thank you for your help and explanation.</span>
<span class="comment-copy">1) Your <code>res</code> is a dict, not a set. 2) You should mention that the dict may not preserve the original order. 3) Instead of your <code>try...except</code> stuff or <code>if</code> blocks you can do <code>res[cur_b] = res.get(cur_b, 0) + cur_a</code>. Or use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a> from the <code>collections</code> module, but that might be a bit too fancy for the OP. 4) You can use the <code>dict.keys()</code> and <code>dict.values()</code> methods instead of your list comprehensions.</span>
<span class="comment-copy">1) You're right I was using set colloquially. I will change that 2) Yup. 3) Yeah that would simplify the solution -- arguably more pythonic. I agree that using defaultdict would be overengineering.</span>
