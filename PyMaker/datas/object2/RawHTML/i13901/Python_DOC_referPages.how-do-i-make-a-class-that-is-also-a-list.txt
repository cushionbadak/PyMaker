<div class="post-text" itemprop="text">
<p>I want to create a class in Python with various attributes and methods, but for it to inherit the functionality of a list, so that I can append objects to the object itself, not any of its attributes. I want to be able to say '<code>graph[3]</code>', rather than '<code>graph.node_list[3]</code>'. Is there a way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>All you really need to do is provide a <a href="https://docs.python.org/2/reference/datamodel.html#object.__getitem__"><code>__getitem__</code></a></p>
<pre><code>In [1]: class Foo:
   ...:     def __init__(self, *args):
   ...:         self.args = args
   ...:     def __getitem__(self, i):
   ...:         return self.args[i]
   ...:     

In [2]: c = Foo(3,4,5)

In [3]: c[2]
Out[3]: 5

In [4]: c[3]
IndexError: tuple index out of range #traceback removed for brevity

In [5]: for i in c: print(i) #look, ma, I can even use a for-loop!
3
4
5
</code></pre>
<p>Addendum: There are other methods you probably want to provide, too. <code>__len__</code> is definitely one of them. There's a rather long list of magic methods, I'd recommend going through them and picking the ones that make sense. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can just inherit from <code>list</code>:</p>
<pre><code>class Foo(list):
    def __init__(self):
        pass
</code></pre>
<p>But subclassing builtin types isn't necessarily a good idea.</p>
<hr/>
<p><code>collections.abc.Sequence</code> (or since 3.5, <code>typing.Sequence[T]</code>) is the way I would do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to add some special methods, such as <code>__getitem__</code> in the case of lists.  Take a look at:</p>
<p><a href="https://docs.python.org/2/reference/datamodel.html#emulating-container-types" rel="nofollow">https://docs.python.org/2/reference/datamodel.html#emulating-container-types</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python uses <a href="https://en.wikipedia.org/wiki/Duck_typing" rel="nofollow">duck typing</a>, the primary difference between a list and any other object is the set of methods it exposes.  You can easily see the primary attribues (methods and fields) of an object with the <a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow"><code>dir()</code></a> function.</p>
<pre><code>&gt;&gt;&gt; [a for a in dir([]) if callable(getattr([], a))]
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__',
'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__',
'__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__',
'__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__',
'__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index',
'insert', 'pop', 'remove', 'reverse', 'sort']
</code></pre>
<p>Obviously there's a lot of methods here, and you probably don't care about most of them.  But if your goal was to really replicate the behavior of a list, you'd probably want to implement them.  Most of the <code>__...__</code> methods are defined in Python's <a href="https://docs.python.org/3/reference/datamodel.html#emulating-container-types" rel="nofollow">data model</a>, if you want to look them up.</p>
<p>From that page:</p>
<blockquote>
<p>Mutable sequences should provide methods <code>append()</code>, <code>count()</code>, <code>index()</code>, <code>extend()</code>, <code>insert()</code>, <code>pop()</code>, <code>remove()</code>, <code>reverse()</code> and <code>sort()</code>, like Python standard list objects. Finally, sequence types should implement addition (meaning concatenation) and multiplication (meaning repetition) by defining the methods <code>__add__()</code>, <code>__radd__()</code>, <code>__iadd__()</code>, <code>__mul__()</code>, <code>__rmul__()</code> and <code>__imul__()</code> described below; they should not define other numerical operators. It is recommended that both mappings and sequences implement the <code>__contains__()</code> method to allow efficient use of the in operator; for mappings, in should search the mappingâ€™s keys; for sequences, it should search through the values. It is further recommended that both mappings and sequences implement the <code>__iter__()</code> method to allow efficient iteration through the container; for mappings, <code>__iter__()</code> should be the same as keys(); for sequences, it should iterate through the values.</p>
</blockquote>
<p>The feature you're asking about in particular, index lookups, is provided by <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow"><code>__getitem__</code></a>.  I would suggest also implementing <code>__contains__()</code> and <code>__iter__()</code> (and maybe <code>__len__()</code>), at a minimum.</p>
</div>
<span class="comment-copy">Provide a <a href="https://docs.python.org/2/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>__getitem__</code></a></span>
<span class="comment-copy">One can also derive from <code>abc.Sequence</code> to appease type checks. Or at least implement <code>__len__</code>...</span>
<span class="comment-copy">@kirbyfan64sos, Thanks to virtual subclassing, you don't need to inherit from any of the <code>collections</code> <code>abc</code>s, unless you want to inherit their methods.</span>
<span class="comment-copy">@Navith I was referring to type checkers like Mypy. :)</span>
<span class="comment-copy">'This isn't necessarily a good idea.' - are you referring to the first approach or to the second? Also, why isn't it a good idea?</span>
<span class="comment-copy">@alfasin subclassing builtin types is usually not a good idea.</span>
<span class="comment-copy">why isn't it a good idea?</span>
