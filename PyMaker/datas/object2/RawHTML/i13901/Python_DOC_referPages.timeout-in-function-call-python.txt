<div class="post-text" itemprop="text">
<p>I've got this code</p>
<pre><code>    r = x.run("prog", ["-4"], ['\tab \t cd\n', ' \t ab cd \n', '\ta\b\b\b\tb\n'])
</code></pre>
<p>Where <code>"prog"</code> is the name of an executable c file,<code>"-4"</code> is a command line argument used by <code>"prog"</code> and <code>'\tab \t cd\n', ' \t ab cd \n', '\ta\b\b\b\tb\n'</code> is the input text for the file <code>"prog"</code></p>
<p>My <code>run</code> function is...</p>
<pre><code>    def run(self, prog, args, input):
    global debug
    result = None
    prog = os.path.join(".",prog)
    command = [prog] + args
    self.createFile(CompileAndExecute.stdinName, input)
    cwd = os.getcwd()
    os.chdir(self.tmpdir)
    stream0 = open(CompileAndExecute.stdinName, "r")
    stream1 = open(CompileAndExecute.stdoutName, "w")
    stream2 = open(CompileAndExecute.stderrName, "w")
    p = None

    try:
        p = subprocess.call(command,
            stdin=stream0, stdout=stream1, stderr=stream2)
    except:
        result = sys.exc_info()
        if p != None:
            p.kill()
    finally:
        stream0.close()
        stream1.close()
        stream2.close()
        os.remove(CompileAndExecute.stdinName)
    os.chdir(cwd)
    return result
</code></pre>
<p>I want to add another parameter inside my <code>run</code> function, called <code>timeout</code>.
Basically, I want it so that if my <code>run</code> function is taking longer than 5 seconds, i'll call <code>Sys.exit(1)</code> and end it there.</p>
<p>The proper call of my <code>run</code> function, with the added <code>timeout</code> parameter, would be </p>
<p><code>r = x.run("prog", ["-4"], ['\tab \t cd\n', ' \t ab cd \n', '\ta\b\b\b\tb\n'], 5)</code> </p>
<p>The general idea of my complete code, all of it is not here, is to compile and  execute a C file and check if its output is what it should be.</p>
<p>I was recommended to See section 17.5.1 of the Python3 library documentation for information on how to implement a timeout, but was not able to understand how to. And I tried some solutions to similar questions, but it didn't work out.</p>
<p>Any help?</p>
<p>EDIT:
More info on the <code>run</code> function..</p>
<p><code>run(self, prog,args=[],input=[])</code></p>
<p>The prog argument is a string which specified the name of the executable file in the temporary directory. The args argument contains a list of strings which are to be used as command line arguments for the program named by prog. The run method executes the program, supplying the command line arguments. If the program, while running, reads from its standard input then that standard input is taken from the argument named input. The input argument is a list of strings; each string represents one line of text input to be read by the program.
When the run method returns, the result is either None (for an apparently successful completion) or a string (which specifies a reason for the pro- gram not executing or not completing successfully). Whatever is returned by the function call, both the standard output stream and the standard error output stream should be checked.</p>
<p><code>CompileAndExecute</code> is the class name that <code>run</code> is found in..</p>
<pre><code>class CompileAndExecute:
"""The class provides methods for compiling and testing
a program in a temporary directory."""
stdoutName = ".stdout.txt"
stderrName = ".stderr.txt"
stdinName  = ".stdin.txt"

# constructor, creates temporary directory
def __init__(self, compiler):
    self.compiler = compiler
    self.tmpdir = tempfile.mkdtemp()
</code></pre>
<p>UPDATE:
After some help, I'm getting syntax error </p>
<pre><code>    def run(self, prog, args, input):
    global debug
    result = None
    prog = os.path.join(".",prog)
    command = [prog] + args
    self.createFile(CompileAndExecute.stdinName, input)
    cwd = os.getcwd()
    os.chdir(self.tmpdir)
    stream0 = open(CompileAndExecute.stdinName, "r")
    stream1 = open(CompileAndExecute.stdoutName, "w")
    stream2 = open(CompileAndExecute.stderrName, "w")
    p = None

    try:
        p = subprocess.call(command,
        stdin=stream0, stdout=stream1, stderr=stream2, timeout = 5)
        except subprocess.TimeoutExpired:
            sys.exit(1)
        except:
            result = sys.exc_info()
        if p != None:
            p.kill()
     finally:
        stream0.close()
        stream1.close()
        stream2.close()
        os.remove(CompileAndExecute.stdinName)
    os.chdir(cwd)
    return result
</code></pre>
<p>For the line of code in the above chunk, <code>except subprocess.TimeoutExpired:</code></p>
</div>
<div class="post-text" itemprop="text">
<p>For Python 3+ , you can use the <code>timeout</code> argument for <a href="https://docs.python.org/3/library/subprocess.html#subprocess.call" rel="nofollow"><code>subprocess.call</code></a> , passing in the timeout you want to specify , and then if the timeout expires before the child process got terminated, subprocess would terminate the child process and raise <code>subprocess.TimeoutExpired</code> exception, which you can catch, and then call <code>sys.exit(1)</code> .</p>
<p>So in your code, you would do -</p>
<pre><code>try:
    p = subprocess.call(command,
        stdin=stream0, stdout=stream1, stderr=stream2, timeout=5)
except subprocess.TimeoutExpired:
    import sys #don't need this here, if you have imported anywhere above.
    sys.exit(1)
except:
    result = sys.exc_info()
    if p != None:
        p.kill()
</code></pre>
<p>Also, the <code>subprocess.call</code> function returns the returncode, not the process itself, so trying to do <code>p.kill()</code> inside the <code>except:</code> does not do anything.</p>
<p>Demo - </p>
<pre><code>import sys
try:
    subprocess.call(['python','a.py'],timeout=1)
except subprocess.TimeoutExpired:
    sys.exit(1)
</code></pre>
<p>Where <code>a.py</code> is a python script, that loops 100000 time.</p>
</div>
<span class="comment-copy">Are you using Python 3?</span>
<span class="comment-copy">Yes, I am using Python 3</span>
<span class="comment-copy">Ok, So I used the code you have in the first part of your answer, put it in word for word, but it still doesn't exit the function. The C file being run has an infinite loop inside of it. So I looked at the other part of your code, the demo, added <code>timeout = 5</code> to my <code>p= = subprocess.call(command,             stdin=stream0, stdout=stream1, stderr=stream2)</code>, leaving me with <code>p=  subprocess.call(command,             stdin=stream0, stdout=stream1, stderr=stream2, timeout = 5)</code>, and added the <code>except subprocess.TimeoutExpired:     sys.exit(1)</code> but it still won't exit</span>
<span class="comment-copy">Hmm, if you remove the try:except: block, is there any exception that is occurring? Can you please check.</span>
<span class="comment-copy">SCRATCH THAT lol, I actually get an invalid syntax error on <code>except subprocess.TimoutExpired:</code></span>
<span class="comment-copy">You except is indented at the wrong position, indent it with <code>try</code></span>
<span class="comment-copy">HEY, Noob mistakes, I had bad indentation basically on my except.. haha it works now! Thank you!</span>
