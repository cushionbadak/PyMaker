<div class="post-text" itemprop="text">
<p>I am making a Python script which will allow, among other things, downloading files from an S3 filestore.  I'm using the <code>boto</code> module to do this.  As a first step, I get a list of files in a user-specified bucket.  I'm storing that list in a temporary text file.  Although S3 doesn't <em>really</em> have directories, we fake it the same way as everyone else by prepending a fake path to the filename.  So, suppose I have the following in my bucket:</p>
<pre><code>2015-04-12/logs/east/01.gz
2015-04-12/logs/east/02.gz
2015-04-12/logs/west/01.gz
2015-04-12/logs/west/02.gz
2015-04-12/summary
2015-04-13/logs/east/01.gz
2015-04-13/logs/east/02.gz
2015-04-13/logs/west/01.gz
2015-04-13/logs/west/02.gz
2015-04-13/summary
README
</code></pre>
<p>This is a very, very short version of the file.  The real one is about 35,000 lines, so it needs to be presented to the user in a manageable way.  I'm looking for suggestions on how to go about this.  The way I've attempted has worked well, except that it assumed that everything would share a common directory path length.  As you can see, that's no longer true.  I'm assured that more variations will be coming, so I'd like to accommodate essentially arbitrary directory/file structures.</p>
<p>My method was, in effect, to extract the leftmost part of each path (that is, the top-level directory), create a uniq'd list of those, and present that to the user to choose.  Then, when they choose, take everything starting with their choice and extract the second part of the path (if it existed), uniq those and present them to the user.  When they choose, concatenate their first selection, a <code>/</code>, and their second selection, and repeat until there's no more path left. This is unwieldy and it's hard to say, for example, "this directory contains both files and directories."</p>
<p>How would you go about this?  I'm having a hard time wrapping my head around this without creating an awkward presentation and spaghettified code.  Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand your question correctly, you want to be able to "drill down" into a list of path-like strings, correct?</p>
<p>If so, I'd suggest the newer <code>pathlib</code> module in the standard library. The code I'll show allows you to do something like this:</p>
<pre><code>Current path: 
1: 2015-04-12/
2: 2015-04-13/
3: README
? 2

Current path: 2015-04-13
1: logs/
2: summary
? 1

Current path: 2015-04-13/logs
1: east/
2: west/
? 2

Current path: 2015-04-13/logs/west
1: 01.gz
2: 02.gz
? 1

You have selected:  2015-04-13/logs/west/01.gz
</code></pre>
<p>Now for the code... First, we import <code>pathlib</code> and convert our list of strings to a list of <code>pathlib.Path</code> objects:</p>
<pre><code>import pathlib
paths = (
"""
2015-04-12/logs/east/01.gz
2015-04-12/logs/east/02.gz
2015-04-12/logs/west/01.gz
2015-04-12/logs/west/02.gz
2015-04-12/summary
2015-04-13/logs/east/01.gz
2015-04-13/logs/east/02.gz
2015-04-13/logs/west/01.gz
2015-04-13/logs/west/02.gz
2015-04-13/summary
README""").split()

paths = [pathlib.Path(p) for p in paths]
</code></pre>
<p>Now I'll want to make some helper functions. First is a menu function that asks the user to select an entry from a list of choices. This will return an element of the list:</p>
<pre><code>def menu(choices):
    for i, choice in enumerate(choices, start=1):
        message = '{}: {}'.format(i, choice)
        print(message)

    while True:
        try:
            selection = choices[int(input('? ')) - 1]
        except (ValueError, IndexError):
            message = 'Invalid selection: must be between 1 and {}.'
            print(message.format(len(choices)))
        else:
            return selection
</code></pre>
<p>We'll need a list of choices to give to that function, so we'll make a <code>path_choices</code> function which does as much. We give this function a container of full paths and the current path the the user has selected. It then returns the "next steps" that the user can take. For example, if we have a list of possibilities: <code>['foo/apple', 'foo/banana/one.txt', 'foo/orange/pear/summary.txt']</code>, and <code>curpath</code> is <code>foo</code>, then this function will return <code>{'apple', 'banana/', 'orange/'}</code>. Note that the directories have trailing slashes, which is nice.</p>
<pre><code>def path_choices(possibilities, curpath):
    choices = set()
    for path in possibilities:
        parts = path.relative_to(curpath).parts
        root = parts[0]
        if len(parts) &gt; 1:
            root += '/'
        choices.add(root)
    return choices
</code></pre>
<p>Lastly, we'll have a simple function to filter a container of paths, only returning paths which start with <code>curpath</code>, and which aren't in fact equal to <code>curpath</code>:</p>
<pre><code>def filter_paths(possibilities, curpath):
    for path in possibilities:
        if path != curpath and str(path).startswith(str(curpath)):
            yield path
</code></pre>
<p>After this, it's just a matter of gluing these functions together:</p>
<pre><code>curpath = ''
possibilities = paths

while possibilities:
    print('Current path: {}'.format(curpath))
    choices = sorted(path_choices(possibilities, curpath))
    selection = menu(choices)

    if curpath:
        curpath /= selection
    else:
        curpath = pathlib.Path(selection)

    possibilities = list(filter_paths(possibilities, curpath))
    print()

print('You have selected: ', curpath)
</code></pre>
</div>
<span class="comment-copy">did you try with <code>os.path</code>? <a href="https://docs.python.org/3/library/os.path.html?highlight=os.path#module-os.path" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">Nope, I didn't.  Maybe I'm not seeing it, but I thought that could only traverse a real filesystem.  What I have is a listing of files in a text file, produced by an S3 <code>boto</code> api call.  Are you suggesting having it read the file, or read the S3 store somehow?  Update:  I see what I was, in fact, mistaken.  I'm looking more in this direction now.  Thank you.</span>
<span class="comment-copy">I think you have understood it perfectly, and stated it better than I did.  It will take me a little time to see how this works... as you can see, I'm pretty new with Python.  But, it looks quite compact and much, much more readable than my code.  Thank you.  Update:  Uggh... tried to +1... still not enough reputation.  Off to fix that.</span>
<span class="comment-copy">Great! Glad I could help.</span>
