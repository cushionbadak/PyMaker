<div class="post-text" itemprop="text">
<p>I have a very large number in base <code>n</code> (<code>n</code> is specified by user), stored as an array with each element representing a digit. <code>u[0]</code> is the highest digit, <code>u[1]</code> is the second highest, <code>u[-1]</code> is the lowest digit and so on. Leading zeros are understood to be meaningless: For instance, if <code>n</code> is 8, <code>[0, 0, 0, 4, 7, 3]</code> is equivalent to <code>[4, 7, 3]</code> and both equal (473) in base 8, or 315 in base 10, or <code>13B</code> in hex, or <code>[1, 59]</code> as a byte array.</p>
<p>I want to convert this into an array of bytes which correspond to base-256 representation of the same number, with minimal leading zeros. I have the following code to do so:</p>
<pre><code>def base_n_to_byte_array(digits, from_base):
    """ Converts a base n number to a byte array.

    :param digits: Digits of the number, starting from highest.
    :param from_base: Base in which the number is given.
    """

    x = 0
    n = len(digits)
    for i in range(0, len(digits)):
        x += digits[i] * int(math.pow(from_base, n - i - 1))

    min_length = max(math.ceil(math.log(x, 256)), 1)
    byte_array = x.to_bytes(min_length, byteorder='big')
    return byte_array
</code></pre>
<p>This works for smaller numbers (a few hundred digits). However, it turns out that <code>math.pow</code> is pretty limited, for instance if we use base 8, <code>math.pow(8, 341)</code> is the highest power I can get, and <code>math.pow(8,342)</code> fails with <code>OverflowError: math range error</code>.</p>
<p>I know that the common way of dealing with large numbers is to represent them as floating points - but in this case I am using this code to encode/decode binary files into alternative representations (eg. trytes). Therefore, if due to loss of precision the less significant bytes are altered, a lot of the data will be corrupted, so I can't use an approximate power calculation - I need the result to be exact.</p>
<p>How can I solve this problem? Is there a version of <code>math.pow</code> that doesn't overflow? Is there a more efficient base conversion algorithm that I'm overlooking?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a version of <code>math.pow</code> that doesn't overflow?</p>
</blockquote>
<p>Try using the built-in exponentiation operator, <code>**</code>. AFAIK it doesn't have the same limitations that <code>math.pow</code> does.</p>
<pre><code>&gt;&gt;&gt; math.pow(8,342)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
OverflowError: math range error

&gt;&gt;&gt; 8**342
719077253944926363091722076315609893447190791576922629093720324630930703222003852530833909289630144084480455519485573430635159075257666489971389722557896497511071573699461941105208878404984376477812331808340023075352602729369851525895652442163308948653402042738345192959788983753918865219341425318496896548864L
</code></pre>
</div>
<span class="comment-copy">What you need is <a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic" rel="nofollow noreferrer">Arbitrary-precision arithmetic</a>.</span>
<span class="comment-copy">@WhatsUp Python does this automatically, as long as you avoid floats.</span>
<span class="comment-copy">@WhatsUp I know that is one of my options, I am asking how to do it in Python3.</span>
<span class="comment-copy">If you read the number backwards, then you can iteratively build up the multiplier: <code>value_of_place *= from_base</code> instead of <code>int(math.pow)</code>.</span>
<span class="comment-copy">Or, even if you read the numbers forwards, you can use another number <code>y</code> to store the power of <code>from_base</code>. Just multiply it by <code>from_base</code> at each step.</span>
<span class="comment-copy">The documentation for <a href="https://docs.python.org/3/library/math.html#math.pow" rel="nofollow noreferrer"><code>math.pow</code></a> specifically says that <code>pow</code> (aka <code>**</code>) doesn't have the same limitations.</span>
<span class="comment-copy">Great! In that case I rescind my "AFAIK" and heartily endorse both <code>pow</code> and <code>**</code>.</span>
