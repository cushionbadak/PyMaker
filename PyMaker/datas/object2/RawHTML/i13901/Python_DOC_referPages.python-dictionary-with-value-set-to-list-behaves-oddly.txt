<div class="post-text" itemprop="text">
<p>I know <code>list</code> object can be changed in place, but <code>list()</code> should returns me an independent <code>list</code> object each time when it is called. Now I'm confused about the output:</p>
<pre><code>L = [1, 2, 3, 4]
# list() should 
D = dict.fromkeys(L, list())
print(D) # {1: [], 2: [], 3: [], 4: []}
D[1].append(1989)
print(D) # {1: [1989], 2: [1989], 3: [1989], 4: [1989]}
</code></pre>
<p>the required output should be:</p>
<pre><code>{1: [1989], 2: [], 3: [], 4: []}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your code is that the <code>fromkeys</code> constructor reuses the same value for each key. Thus <code>list()</code> is evaluated only once.</p>
<p>You can use either a dict-comprehension:</p>
<pre><code>D = {x:list() for x in L}
</code></pre>
<p>or, if you know that you will always be using lists in your dictionary, use the <a href="https://docs.python.org/3.5/library/collections.html#collections.defaultdict" rel="nofollow"><code>defaultdict</code></a> factory:</p>
<pre><code>from collections import defaultdict

D = defaultdict(list)
D[1].append(1989)
D[2].append(2001)

print(D) # {1: [1989], 2: [2001]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>list()</code> is called once, and that same <code>list</code> is used as the value for all keys.</p>
<p>Console transcript (you can see the same <code>id</code> for all values):</p>
<pre><code>&gt;&gt;&gt; dict.fromkeys(['a', 'b', 'c'])
{'a': None, 'c': None, 'b': None}
&gt;&gt;&gt; dict.fromkeys(['a', 'b', 'c'], 5)
{'a': 5, 'c': 5, 'b': 5}
&gt;&gt;&gt; dict.fromkeys(['a', 'b', 'c'], [1, 2])
{'a': [1, 2], 'c': [1, 2], 'b': [1, 2]}
&gt;&gt;&gt; dict.fromkeys(['a', 'b', 'c'], [1, 2, 3])
{'a': [1, 2, 3], 'c': [1, 2, 3], 'b': [1, 2, 3]}
&gt;&gt;&gt; d = dict.fromkeys(['a', 'b', 'c'], list())
{'a': [], 'c': [], 'b': []}
&gt;&gt;&gt; for key in d: print id(d[key])
... 
4325657272
4325657272
4325657272
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could consider using a <code>defaultdict</code> from <code>collections</code>, it might be more suitable, and at the least it is worth learning about.</p>
<pre><code>import collections
D = collections.defaultdict(list)

D[1].append(1989)
D[1].append(1990)

print D[1]
print D
print D[2]
print D
</code></pre>
<p>This would print the following:</p>
<pre><code>[1989, 1990]
defaultdict(&lt;type 'list'&gt;, {1: [1989, 1990]})
[]
defaultdict(&lt;type 'list'&gt;, {1: [1989, 1990], 2: []})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>list()</code> is only called once. For older version of Python you can use the fact that you can initialise a dict from a list of key/value pairs:</p>
<pre><code>D = dict([(x, list()) for x in L]
</code></pre>
<p>Starting with Python 2.5 you can use generators and leave out the list construction from the previous example:</p>
<pre><code>D = dict((x, list()) for x in L)
</code></pre>
<p>Starting with python 2.7 and 3.0 you can use the, initially rejected for python 2.3, dict comprehension from <a href="https://www.python.org/dev/peps/pep-0274/" rel="nofollow">PEP 274</a>:</p>
<pre><code>D = {x: list() for x in L}
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/stdtypes.html#dict.fromkeys" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#dict.fromkeys</a></span>
<span class="comment-copy">Using python 3: <code>D = {x:[] for x in L}</code></span>
<span class="comment-copy"><code>list()</code> creates <i>one</i> list object which is referenced by all keys.</span>
<span class="comment-copy">You are using the same object/list  for all the keys</span>
<span class="comment-copy">@vaultah, why is the downvote? your link doesn't solve my issue. it doesn't explain my concern</span>
<span class="comment-copy">How does <code>D = dict.fromkeys(L, list())</code> work?</span>
<span class="comment-copy">I had inadvertently copied in that line from my test code instead of the dict comprehension.</span>
