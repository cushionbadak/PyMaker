<div class="post-text" itemprop="text">
<p>Assume we have the type <code>Noddy</code> as defined in the <a href="http://docs.python.org/extending/newtypes.html#adding-data-and-methods-to-the-basic-example" rel="noreferrer">tutorial on writing C extension modules for Python</a>.  Now we want to create a derived type, overwriting only the <code>__new__()</code> method of <code>Noddy</code>.</p>
<p>Currently I use the following approach (error checking stripped for readability):</p>
<pre><code>PyTypeObject *BrownNoddyType =
    (PyTypeObject *)PyType_Type.tp_alloc(&amp;PyType_Type, 0);
BrownNoddyType-&gt;tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;
BrownNoddyType-&gt;tp_name = "noddy.BrownNoddy";
BrownNoddyType-&gt;tp_doc = "BrownNoddy objects";
BrownNoddyType-&gt;tp_base = &amp;NoddyType;
BrownNoddyType-&gt;tp_new = BrownNoddy_new;
PyType_Ready(BrownNoddyType);
</code></pre>
<p>This works, but I'm not sure if it is The Right Way To Do It.  I would have expected that I have to set the <a href="http://docs.python.org/c-api/typeobj.html#Py_TPFLAGS_HEAPTYPE" rel="noreferrer"><code>Py_TPFLAGS_HEAPTYPE</code></a> flag, too, because I dynamically allocate the type object on the heap, but doing so leads to a segfault in the interpreter.</p>
<p>I also thought about explicitly calling <code>type()</code> using <code>PyObject_Call()</code> or similar, but I discarded the idea.  I would need to wrap the function <code>BrownNoddy_new()</code> in a Python function object and create a dictionary mapping <code>__new__</code> to this function object, which seems silly.</p>
<p>What is the best way to go about this?  Is my approach correct? Is there an interface function I missed?</p>
<h2>Update</h2>
<p>There are two threads on a related topic on the python-dev mailing list <a href="http://mail.python.org/pipermail/python-dev/2009-July/090875.html" rel="noreferrer">(1)</a> <a href="http://mail.python.org/pipermail/python-dev/2009-August/091192.html" rel="noreferrer">(2)</a>.  From these threads and a few experiments I deduce that I shouldn't set <code>Py_TPFLAGS_HEAPTYPE</code> unless the type is allocated by a call to <code>type()</code>.  There are different recommendations in these threads whether it is better to allocate the type manually or to call <code>type()</code>.  I'd be happy with the latter if only I knew what the recommended way to wrap the C function that is supposed to go in the <code>tp_new</code> slot is.  For regular methods this step would be easy -- I could just use <a href="http://docs.python.org/c-api/descriptor.html#PyDescr_NewMethod" rel="noreferrer"><code>PyDescr_NewMethod()</code></a> to get a suitable wrapper object. I don't know how to create such a wrapper object for my <code>__new__()</code> method, though -- maybe I need the undocumented function <code>PyCFunction_New()</code> to create such a wrapper object.</p>
</div>
<div class="post-text" itemprop="text">
<p>I encountered the same problem when I was modifying an extension to be compatible with Python 3, and found this page when I was trying to solve it.</p>
<p>I did eventually solve it by reading the source code for the Python interpreter, <a href="https://www.python.org/dev/peps/pep-0384/" rel="nofollow">PEP 0384</a> and the documentation for the <a href="https://docs.python.org/3/c-api/type.html?highlight=pytype_fromspec" rel="nofollow">C-API</a>.</p>
<p>Setting the <code>Py_TPFLAGS_HEAPTYPE</code> flag tells the interpreter to recast your <code>PyTypeObject</code> as <code>PyHeapTypeObject</code>, which contains additional members that must also be allocated. At some point the interpreter attempts to refer to these extra members and, if you leave them unallocated, it will cause a segfault.</p>
<p>Python 3.2 introduced the C structures <code>PyType_Slot</code> and <code>PyType_Spec</code> and the C function <code>PyType_FromSpec</code> that simplify the creation of dynamic types. In a nutshell, you use <code>PyType_Slot</code> and <code>PyType_Spec</code> to specify the <code>tp_*</code> members of the <code>PyTypeObject</code> and then call <code>PyType_FromSpec</code> to do the dirty work of allocating and initialising the memory.</p>
<p>From PEP 0384, we have:</p>
<pre><code>typedef struct{
  int slot;    /* slot id, see below */
  void *pfunc; /* function pointer */
} PyType_Slot;

typedef struct{
  const char* name;
  int basicsize;
  int itemsize;
  int flags;
  PyType_Slot *slots; /* terminated by slot==0. */
} PyType_Spec;

PyObject* PyType_FromSpec(PyType_Spec*);
</code></pre>
<p>(The above isn't a literal copy from PEP 0384, which also includes <code>const char *doc</code> as a member of <code>PyType_Spec</code>. But that member doesn't appear in the source code.)</p>
<p>To use these in the original example, assume we have a C structure, <code>BrownNoddy</code>, that extends the C structure for the base class <code>Noddy</code>. Then we would have:</p>
<pre><code>PyType_Slot slots[] = {
    { Py_tp_doc, "BrownNoddy objects" },
    { Py_tp_base, &amp;NoddyType },
    { Py_tp_new, BrownNoddy_new },
    { 0 },
};
PyType_Spec spec = { "noddy.BrownNoddy", sizeof(BrownNoddy), 0,
                      Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, slots };
PyTypeObject *BrownNoddyType = (PyTypeObject *)PyType_FromSpec(&amp;spec);
</code></pre>
<p>This should do everything in the original code, including calling <code>PyType_Ready</code>, plus what is necessary for creating a dynamic type, including setting <code>Py_TPFLAGS_HEAPTYPE</code>, and allocating and initialising the extra memory for a <code>PyHeapTypeObject</code>.</p>
<p>I hope that's helpful.</p>
</div>
<div class="post-text" itemprop="text">
<p>I apologize up front if this answer is terrible, but you can find an implementation of this idea in <a href="http://pythonqt.sourceforge.net/" rel="nofollow">PythonQt</a>, in particular I think the following files might be useful references:</p>
<ul>
<li><a href="http://pythonqt.svn.sourceforge.net/viewvc/pythonqt/trunk/src/PythonQtClassInfo.cpp?revision=207&amp;view=markup" rel="nofollow">PythonQtClassInfo.cpp</a></li>
<li><a href="http://pythonqt.svn.sourceforge.net/viewvc/pythonqt/trunk/src/PythonQtClassInfo.h?revision=207&amp;view=markup" rel="nofollow">PythonQtClassInfo.h</a></li>
<li><a href="http://pythonqt.svn.sourceforge.net/viewvc/pythonqt/trunk/src/PythonQtClassWrapper.cpp?revision=207&amp;view=markup" rel="nofollow">PythonQtClassWrapper.cpp</a></li>
<li><a href="http://pythonqt.svn.sourceforge.net/viewvc/pythonqt/trunk/src/PythonQtClassWrapper.h?revision=207&amp;view=markup" rel="nofollow">PythonQtClassWrapper.h</a></li>
</ul>
<p>This fragment from PythonQtClassWrapper_init jumps out at me as being somewhat interesting:</p>
<pre><code>static int PythonQtClassWrapper_init(PythonQtClassWrapper* self, PyObject* args, PyObject* kwds)
{
  // call the default type init
  if (PyType_Type.tp_init((PyObject *)self, args, kwds) &lt; 0) {
    return -1;
  }

  // if we have no CPP class information, try our base class
  if (!self-&gt;classInfo()) {
    PyTypeObject*  superType = ((PyTypeObject *)self)-&gt;tp_base;

    if (!superType || (superType-&gt;ob_type != &amp;PythonQtClassWrapper_Type)) {
      PyErr_Format(PyExc_TypeError, "type %s is not derived from PythonQtClassWrapper", ((PyTypeObject*)self)-&gt;tp_name);
      return -1;
    }

    // take the class info from the superType
    self-&gt;_classInfo = ((PythonQtClassWrapper*)superType)-&gt;classInfo();
  }

  return 0;
}
</code></pre>
<p>It's worth noting that PythonQt does use a wrapper generator, so it's not exactly in line with what you're asking for, but personally I think trying to outsmart the vtable isn't the most optimal design. Basically, there are many different C++ wrapper generators for Python and people use them for a good reason - they're documented, there are examples floating around in search results and on stack overflow. If you hand roll a solution for this that nobody's seen before, it'll be that much harder for them to debug if they run into problems. Even if it's closed-source, the next guy who has to maintain it will be scratching his head and you'll have to explain it to every new person who comes along.</p>
<p>Once you get a code generator working, all you need to do is maintain the underlying C++ code, you don't have to update or modify your extension code by hand. (Which is probably not too far away from the tempting solution you went with)</p>
<p>The proposed solution is an example of breaking the type-safety that the newly introduced <a href="http://docs.python.org/release/2.7.2/c-api/capsule.html" rel="nofollow">PyCapsule</a> provides <a href="http://bugs.python.org/issue5630" rel="nofollow">a bit more protection</a> against (when used as directed).</p>
<p>So, while its possible it might not be the best long term choice to implement derived/subclasses this way, but rather wrap the code and let the vtable do what it does best and when the new guy has questions you can just point him at the documentation for <a href="http://www.boost.org/doc/libs/1_48_0/libs/python/doc/" rel="nofollow">whatever</a> <a href="http://www.swig.org/" rel="nofollow">solution</a> <a href="http://www.pyside.org/docs/shiboken/" rel="nofollow">fits</a> <a href="http://riverbankcomputing.co.uk/software/sip/download" rel="nofollow">best</a>.</p>
<p>This is just my opinion though. :D</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to try and understand how to do this is to create a version of it using SWIG.  See what it produces and see if it matches or is done a different way.  From what I can tell the people who have been writing SWIG have an in depth understanding of extending Python.  Can't hurt to see how they do things at any rate. It may help you understand this problem.</p>
</div>
<span class="comment-copy">As I know, that is the way to do it:( But I'm not sure.  I think so because the requirement, to overwrite the <b>new</b> method, is kind of peculiar..</span>
<span class="comment-copy">@CHENZhao: In my use case, the base type is wrapping a C++ class with virtual member functions.  The derived types only need to overwrite <code>__new__()</code> to allocate a different C++ class.  Methods do not need do be overwritten since they call the virtual member function.  Note that I solved this problem meanwhile by a completely different design using template techniques.  The original question still remains, though.</span>
<span class="comment-copy">If you find no answer here maybe you can ask python-dev mailing list and come back here with the answer</span>
<span class="comment-copy">@XavierCombelle: The python-dev mailing list is meant to coordinate the development of Python itself.  It's not meant for users asking questions.</span>
<span class="comment-copy">@SvenMarnach other possibility python-list@python.org</span>
<span class="comment-copy">Sorry for taking so much time to comment on your answer.  I did not yet find the time to carefully look through all the linked QT source files.  Unfortunately I fail to see how the example code you provided deals with the specific problems I had -- how do I allocate memory for the type correctly?  Is it possible to have a dynamically allocated type garbage collected? etc.</span>
<span class="comment-copy">I did evaluate a few of the C++ wrapper generators -- in particular SWIG, boost.python and PyCXX.  While the least versatile of these, PyCXX came closest to what I needed, but I figured that writing this myself from scratch would be the best option in my specific situation.  (I won't explain my reasons in detail here.)</span>
<span class="comment-copy">Thanks for your answer.  As far as I am aware, SWIG does not generate types dynamically, but rather uses the static approach described in the tutorial (see the link at the beginning of my post).  boost.python does, in a way, create types dynamically, but it uses a rather complex technique that is not applicable in my case for various reasons, one of them being that I'd like to avoid static variables since my library is a header-only.</span>
<span class="comment-copy">Ahh, yes, I totally missed the dynamic part of the title.</span>
