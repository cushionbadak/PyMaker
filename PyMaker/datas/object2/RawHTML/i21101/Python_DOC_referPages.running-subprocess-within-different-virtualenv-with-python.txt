<div class="post-text" itemprop="text">
<p>Let's say I have 2 different versions of my app installed in 2 different virtualenvironments. myapp v1.0 and myapp v2.0.</p>
<p>Now I would like to compare those. The comparison is written in python itself. What would be the best way to do that? Let's assume I can run them separately and both write an output file, which I can compare later.</p>
<p>One way to do that would be to write a bash script (that's what I have currently). I activate one virtualenv, run myapp v1.0, activate another virtualenv, run myapp v2.0. Later run a comparison module on those files. But I would like to add some more dynamics there (take some optional arguments etc) which would be easier with python.</p>
<p>Edit:</p>
<p>Currently I have something like that (a bash script):</p>
<pre><code>source virtualenv1/bin/activate
python my_script.py
deactivate

source virtualenv2/bin/activate
python my_other_script.py
deactivate

python my_comparison_script.py
</code></pre>
<p>instead, I'd like to do only:</p>
<pre><code>python my_comparison_script.py
</code></pre>
<p>and my scripts would be run inside this.</p>
</div>
<div class="post-text" itemprop="text">
<p>what exactly is the question?  how to use subprocess to execute shell commands?  if that's the case, some simplistic pseudo code might look like:</p>
<pre><code>import subprocess

myProcess = subprocess.Popen(   ['these', 'are', 'for', 'the', 'shell'],
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE )

[outStream, errStream] = myProcess.communicate()
</code></pre>
<p>then you can do whatever you'd like with standard out (<code>outStream</code>) and do different things if <code>errStream</code> exists (standard error).  this includes writing the standard out or standard error to a file.  then i presume you would diff those files?</p>
<p>an actual code example (assuming you have python 2.6+ on a linux system) might look like:</p>
<pre><code>import subprocess

with open('dateHelp.log', 'w') as dateLog:
    with open('dateHelp.err', 'w') as errLog:
        dateHelp = subprocess.Popen([ 'date', '-h'], stdout=dateLog, 
                                                     stderr=errLog)
        dateHelp.communicate()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The accepted answer does not address the problem of 'activating' a virtualenv in a subprocess.</p>
<p>If you start your application with a call to the python executable, like in your example it is actually very simple: you only have to explicitly point to the executable in the virtualenv.</p>
<pre class="lang-py prettyprint-override"><code>import subprocess

subprocess.Popen(["virtualenv1/bin/python", "my_script.py"])
subprocess.Popen(["virtualenv2/bin/python", "my_other_script.py"])
</code></pre>
<p>will start the processes in the respective virtualenvs.</p>
<p><strong>Important</strong></p>
<p>To address the concerns voiced in the comments:</p>
<p>If you want to run a subprocess and be sure to use <strong>the same interpreter</strong> that the current process is running in you have to use <a href="https://docs.python.org/3.6/library/sys.html#sys.executable" rel="noreferrer">sys.executable</a>. Also available: <a href="https://docs.python.org/3.6/library/sys.html#sys.exec_prefix" rel="noreferrer">sys.exec_prefix</a> to access the site-specific directory prefix where the platform-dependent Python files are installed.</p>
<p>If you want a much more in depth discussion of this topic, have a look at this <a href="https://github.com/pypa/virtualenv/pull/1080" rel="noreferrer">pull request</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple option would be to run a series of commands with subprocess as follows.</p>
<pre><code>import subprocess

subprocess.call('source activate my_virtualenv; python my_script.py', shell=True)
</code></pre>
<p>And repeat as needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think <strong>virtualenv</strong> documentation explains it nicely.</p>
<p><strong>TL;DR</strong></p>
<p>Runnig python venv binary directly is <strong>NOT</strong> the same as activating venv.
You also have to change <em>PATH</em> and <em>VIRTUAL_ENV</em> variables accordingly (look at <a href="https://docs.python.org/3/library/os.html#os.environ" rel="nofollow noreferrer">os.environ</a>)</p>
<p><a href="https://virtualenv.pypa.io/en/latest/userguide/" rel="nofollow noreferrer">Source</a></p>
<blockquote>
<p>$ source /path/to/ENV/bin/activate</p>
<p>This will change your $PATH so its first entry is the virtualenv’s
  bin/ directory. (You have to use source because it changes your shell
  environment in-place.) This is all it does; it’s purely a convenience.</p>
<p>If you directly run a script or the python interpreter from the
  virtualenv’s bin/ directory (e.g. path/to/ENV/bin/pip or
  /path/to/ENV/bin/python-script.py) then sys.path will automatically be
  set to use the Python libraries associated with the virtualenv. But,
  unlike the activation scripts, the environment variables PATH and
  VIRTUAL_ENV will not be modified. This means that if your Python
  script uses e.g. subprocess to run another Python script (e.g. via a
  !/usr/bin/env python shebang line) the second script may not be executed with the same Python binary as the first nor have the same
  libraries available to it. To avoid this happening your first script
  will need to modify the environment variables in the same manner as
  the activation scripts, before the second script is executed.</p>
</blockquote>
</div>
<span class="comment-copy">Can I activate my virtualenv that way also? My question was, how can I run processes in different <b>virtualenvs</b>. But I guess I can just activate virtualenv with one process and then execute my script which depends on that virtualenv? Thanks for the example though.</span>
<span class="comment-copy">well i'm not sure how you're activating your virtualenv normally, but i'd imagine you could do it with subprocess.  even better, if you already have bash scripts written, why don't you use python to wrap those scripts?  subprocess can call those scripts and process their output in the same way.  you can set up the python script with argparse or optparse (depending on your version) if you want it to have different modes.</span>
<span class="comment-copy">You can do a <code>. /venv1/bin/activate &amp;&amp; python your_app.py</code> and run it using <code>shell = TRUE</code> to run <code>your_app.py</code> using <code>venv1</code> in a subprocess.</span>
<span class="comment-copy">Thanks Noafal for the hint, that worked out well!</span>
<span class="comment-copy">@AndyHayden Launching a command through the shell is only unsafe if the command is constructed from untrusted input.</span>
<span class="comment-copy">Actually, this is not enough. Activating a virtualenv also changes some environment variables, calling specific virutalenv's python doesn't do that. As a result, wrong libraries will be loaded.</span>
<span class="comment-copy">@qarma: I disagree - this approach works and I am using it in my own production code. I am <a href="http://stackoverflow.com/a/14792407/2626627">not the only one recommending it</a>, either. I would be helpful if you concretize the environment variables you are referring to and provide a test case that shows under wich circumstances wrong libraries would be loaded.</span>
<span class="comment-copy">Yes I've seen that recommendation on virtualenv's site too. There are at least two cases where running with virtualenv linked python interpreter directly is different from using activate: when <code>PYTHONHOME</code> is set and when target program uses <code>command</code> or <code>Popen</code> to run another Python program. The latter if arguably murky.</span>
<span class="comment-copy">I just tried the second scenario and that's true: calling subprocess from inside my_script.py would be exectuted with the system Python again. Awkward.</span>
<span class="comment-copy">On windows. I need to "set PYTHONPATH= &amp; workon virtualenv1" before calling python or the script.  Otherwise, the python interpreter  PYTHONPATH still points back to the system libraries.</span>
