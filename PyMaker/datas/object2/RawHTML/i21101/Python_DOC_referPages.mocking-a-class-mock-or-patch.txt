<div class="post-text" itemprop="text">
<p>I am using <a href="http://www.voidspace.org.uk/python/mock/index.html">mock</a> with Python and was wondering which of those two approaches is better (read: more pythonic). </p>
<p><strong>Method one</strong>:  Just create a mock object and use that. The code looks like:</p>
<pre><code>def test_one (self):
    mock = Mock()
    mock.method.return_value = True 
    self.sut.something(mock) # This should called mock.method and checks the result. 
    self.assertTrue(mock.method.called)
</code></pre>
<p><strong>Method two</strong>:  Use patch to create a mock.  The code looks like:</p>
<pre><code>@patch("MyClass")
def test_two (self, mock):
    instance = mock.return_value
    instance.method.return_value = True
    self.sut.something(instance) # This should called mock.method and checks the result. 
    self.assertTrue(instance.method.called)
</code></pre>
<p>Both methods do the same thing.  I am unsure of the differences. </p>
<p>Could anyone enlighten me?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://www.voidspace.org.uk/python/mock/patch.html" rel="noreferrer"><code>mock.patch</code></a> is a very very different critter than <code>mock.Mock</code>.  <code>patch</code> <strong>replaces</strong> the class with a mock object and lets you work with the mock instance.  Take a look at this snippet:</p>
<pre><code>&gt;&gt;&gt; class MyClass(object):
...   def __init__(self):
...     print 'Created MyClass@{0}'.format(id(self))
... 
&gt;&gt;&gt; def create_instance():
...   return MyClass()
... 
&gt;&gt;&gt; x = create_instance()
Created MyClass@4299548304
&gt;&gt;&gt; 
&gt;&gt;&gt; @mock.patch('__main__.MyClass')
... def create_instance2(MyClass):
...   MyClass.return_value = 'foo'
...   return create_instance()
... 
&gt;&gt;&gt; i = create_instance2()
&gt;&gt;&gt; i
'foo'
&gt;&gt;&gt; def create_instance():
...   print MyClass
...   return MyClass()
...
&gt;&gt;&gt; create_instance2()
&lt;mock.Mock object at 0x100505d90&gt;
'foo'
&gt;&gt;&gt; create_instance()
&lt;class '__main__.MyClass'&gt;
Created MyClass@4300234128
&lt;__main__.MyClass object at 0x100505d90&gt;
</code></pre>
<p><code>patch</code> replaces <code>MyClass</code> in a way that allows you to control the usage of the class in functions that you call.  Once you patch a class, references to the class are completely replaced by the mock instance.</p>
<p><code>mock.patch</code> is usually used when you are testing something that creates a new instance of a class inside of the test.  <code>mock.Mock</code> instances are clearer and are preferred.  If your <code>self.sut.something</code> method created an instance of <code>MyClass</code> instead of receiving an instance as a parameter, then <code>mock.patch</code> would be appropriate here.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've got a <a href="https://www.youtube.com/watch?v=smPbDqGjFAI" rel="noreferrer">YouTube video</a> on this.</p>
<p>Short answer: Use <code>mock</code> when you're passing in the thing that you want mocked, and <code>patch</code> if you're not.  Of the two, mock is strongly preferred because it means you're writing code with proper dependency injection.</p>
<p>Silly example:</p>
<pre><code># Use a mock to test this.
my_custom_tweeter(twitter_api, sentence):
    sentence.replace('cks','x')   # We're cool and hip.
    twitter_api.send(sentence)

# Use a patch to mock out twitter_api. You have to patch the Twitter() module/class 
# and have it return a mock. Much uglier, but sometimes necessary.
my_badly_written_tweeter(sentence):
    twitter_api = Twitter(user="XXX", password="YYY")
    sentence.replace('cks','x') 
    twitter_api.send(sentence)
</code></pre>
</div>
<span class="comment-copy">As a person who have never tried either Mock() or patch, I feel that the first version is clearer and shows what you want to do, even though I have no understanding of the actual difference. I don't know if this is of any help or not but I thought it might be useful to convey what an uninitiated programmer might feel.</span>
<span class="comment-copy">@MichaelBrennan: Thank you for your comment. It is useful indeed.</span>
<span class="comment-copy">@D.Shawley how do we patch to a class instantiated inside another class which needs to be under testing.</span>
<span class="comment-copy">@ravz - give the <a href="https://mock.readthedocs.org/en/latest/patch.html#where-to-patch" rel="nofollow noreferrer">"Where to Patch"</a> a read.  This is one of the more difficult things to get to work properly.</span>
<span class="comment-copy">My mock test is similar to <b>Method two</b>. I want MyClass instance to raise an exception. I have tried both mock.side_effect and mock.return_value.side_effect and those didn't work. What do I do?</span>
<span class="comment-copy">@D.Shawley The link is broken, it can be found here now: <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">"Where to Patch"</a></span>
<span class="comment-copy">To patch a <b>class object</b> see <a href="http://stackoverflow.com/questions/8469680/using-mock-patch-to-mock-a-class-method/34534635#34534635" title="using mock patch to mock a class method">stackoverflow.com/questions/8469680/â€¦</a></span>
