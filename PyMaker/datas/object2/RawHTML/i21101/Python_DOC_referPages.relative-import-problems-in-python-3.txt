<div class="post-text" itemprop="text">
<p>Python imports drive me crazy (my experience with python imports sometime doesn't correspond at all to idiom 'Explicit is better than implicit' :( ):</p>
<pre><code>[app]
    start.py
        from package1 import module1
    [package1]
        __init__.py
            print('Init package1')
        module1.py
            print('Init package1.module1')
            from . import module2
        module2.py
            print('Init package1.module2')
            import sys, pprint
            pprint.pprint(sys.modules)
            from . import module1
</code></pre>
<p>I get:</p>
<pre><code>vic@ubuntu:~/Desktop/app2$ python3 start.py 
Init package1
Init package1.module1
Init package1.module2
{'__main__': &lt;module '__main__' from 'start.py'&gt;,
 ...
 'package1': &lt;module 'package1' from '/home/vic/Desktop/app2/package1/__init__.py'&gt;,
 'package1.module1': &lt;module 'package1.module1' from '/home/vic/Desktop/app2/package1/module1.py'&gt;,
 'package1.module2': &lt;module 'package1.module2' from '/home/vic/Desktop/app2/package1/module2.py'&gt;,
 ...
Traceback (most recent call last):
  File "start.py", line 3, in &lt;module&gt;
    from package1 import module1
  File "/home/vic/Desktop/app2/package1/module1.py", line 3, in &lt;module&gt;
    from . import module2
  File "/home/vic/Desktop/app2/package1/module2.py", line 5, in &lt;module&gt;
    from . import module1
ImportError: cannot import name module1
vic@ubuntu:~/Desktop/app2$ 
</code></pre>
<p><code>import package1.module1</code> works, but i want to use <code>from . import module1</code> because i want to make <code>package1</code> portable for my other applications, that's why i want to use relative paths.</p>
<p>I am using python 3.</p>
<p>I need circular imports. A function in module1 asserts that one of its parameter is instance of a class defined in module2 and viceversa.</p>
<p><strong>In other words:</strong></p>
<p><code>sys.modules</code> contains <code>'package1.module1': &lt;module 'package1.module1' from '/home/vic/Desktop/app2/package1/module1.py'&gt;</code>. I want to get a reference to it in form <code>from . import module1</code>, but it tries to get a name, not a package like in case <code>import package1.module1</code> (which works fine). I tried <code>import .module1 as m1</code> - but that's a syntax error.</p>
<p>Also, <code>from . import module2</code> in <code>module1</code> works fine, but <code>from . import module1</code> in <code>module2</code> doesn't work...</p>
<p><strong>UPDATE:</strong></p>
<p>This hack works (but i am looking for the 'official' way):</p>
<pre><code>print('Init package1.module2')

import sys, pprint
pprint.pprint(sys.modules)

#from . import module1
parent_module_name = __name__.rpartition('.')[0]
module1 = sys.modules[parent_module_name + '.module1']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A better solution for your problem is to put package1 in it's own separate package. Of course then it can't import package2, but then again if it is reusable, why would it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Circular imports should be generally avoided, see also <a href="https://stackoverflow.com/questions/1556387/circular-import-dependency-in-python/1556444#1556444">this answer to a related question</a>, or <a href="http://effbot.org/zone/import-confusion.htm#circular-imports" rel="nofollow noreferrer">this article on effbot.org</a>.</p>
<p>In this case the problem is that you import <code>from .</code> where <code>.</code> is the current package. So all your <code>from . import X</code> imports go through the package’s <code>__init__.py</code>.</p>
<p>You can make your problem a bit more visible, if you explicitely import your modules in the <code>__init__.py</code> and give them another name (and adjust the other imports to use those names of course):</p>
<pre><code>print('Init package1')
from . import module1 as m1
from . import module2 as m2
</code></pre>
<p>Now when you are importing <code>m1</code> in <code>start.py</code>, the package first initializes <code>m1</code> and comes to the <code>from . import m2</code> line. At that point, there is no <code>m2</code> known in <code>__init__.py</code> so you get an import error. If you switch the import statements in <code>__init__.py</code> around (so you load <code>m2</code> first), then in <code>m2</code> it finds the <code>from . import m1</code> line, which fails for the same reason as before.</p>
<p>If you don’t explicitely import the modules in <code>__init__.py</code> something similar still happens in the background. The difference is that you get a less flat structure (as the imports are no longer started from the package only). As such both <code>module1</code> and <code>module2</code> get “started” and you get the respective initialization prints.</p>
<p>To make it work, you could do an absolute import in <code>module2</code>. That way you could avoid that the package needs to resolve everything first, and make it reuse the import from <code>start.py</code> (as it has the same import path).</p>
<p>Or even better, you get rid of the circular import at all. It’s generally a sign that your application structure is not so good, if you have circular references.</p>
<p>(I hope my explanation makes any sense, I already had difficulties writing it, but the general idea should be clear, I hope…)</p>
<h3>edit</h3>
<p>In response to your update; what you are doing there is that you use the full package name to get the reference to the module. This is equivalent (but much more complicated) to the first possible option to make it work; you use an absolute import using the same import path as in <code>start.py</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your update emulates what the absolute import does: <code>import package1.module1</code> if you do it while <code>module1</code> being imported. If you'd like to use a dynamic parent package name then to import <code>module1</code> in the <code>module2.py</code>:</p>
<pre><code>import importlib
module1 = importlib.import_module('.module1', __package__)
</code></pre>
<hr/>
<blockquote>
<p>I need circular imports. A function in module1 asserts that one of its
  parameter is instance of a class defined in module2 and viceversa.</p>
</blockquote>
<p>You could move one the classes to a separate module to resolve the circular dependency or make the import at a function level if you don't want to use absolute imports.</p>
<pre><code>.
├── start.py
#       from package1 import module1
└── package1
    ├── __init__.py
#           print("Init package1")
#           from . import module1, module2
    ├── c1.py
#           print("Init package1.c1")
#           class C1:
#               pass
    ├── module1.py
#           print("Init package1.module1")
#           from .c1 import C1
#           from .module2 import C2
    └── module2.py
#           print("Init package1.module2")
#           from .c1 import C1
#           class C2:
#               pass
#           def f():
#               from .module1 import C1
</code></pre>
<h3>Output</h3>
<pre><code>Init package1
Init package1.module1
Init package1.c1
Init package1.module2
</code></pre>
<p>Another option that might be simpler than refactoring out <code>c1.py</code> is to merge <code>module{1,2}.py</code> into a single <code>common.py</code>. <code>module{1,2}.py</code> make the imports from <code>common</code> in this case.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>module2.py
          import module1
</code></pre>
<p>Works too.</p>
</div>
<div class="post-text" itemprop="text">
<p>The accepted answer to <a href="https://stackoverflow.com/questions/1556387/circular-import-dependency-in-python">Circular import dependency in Python</a> makes a good point:</p>
<blockquote>
<p>If a depends on c and c depends on a, aren't they actually the same unit then?</p>
<p>You should really examine why you have split a and c into two packages, because either you have some code you should split off into another package (to make them both depend on that new package, but not each other), or you should merge them into one package.<br/>
  — Lasse V. Karlsen♦</p>
</blockquote>
<p>Maybe you should consider placing them in the same module. :)</p>
</div>
<div class="post-text" itemprop="text">
<p>I ran into this same issue today, and it seems this is indeed broken in python3.4, but works in python3.5.</p>
<p>The <a href="https://docs.python.org/3/whatsnew/3.5.html" rel="nofollow noreferrer">changelog</a> has an entry:</p>
<blockquote>
<p>Circular imports involving relative imports are now supported. (Contributed by Brett Cannon and Antoine Pitrou in <a href="https://bugs.python.org/issue17636" rel="nofollow noreferrer">bpo-17636</a>).</p>
</blockquote>
<p>Looking through the bugreport, it seems that this not so much a buf fixed, as well as a new feature in the way imports work. Referring to <a href="https://stackoverflow.com/a/8030886/740048">poke's answer above</a>, he shows that <code>from . import foo</code> means to load <code>__init__.py</code> and get <code>foo</code> from it (possibly from the implicitly loaded list of submodules). Since python3.5, <code>from . import foo</code> will do the same, but if <code>foo</code> is not available as an attribute, it will fall back to looking through the lists of loaded modules (<code>sys.modules</code>) to see if it is already present there, which fixes this particular case. I'm not 100% sure I properly presented how this works, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>Make sure your <code>package1</code> is a folder. Create a class in <code>__init__.py</code> -- say <code>class1</code>. Include your logic in a method under <code>class1</code> -- say <code>method1</code>. </p>
<p>Now, write the following code - </p>
<pre><code>from .package1 import class1
class1.method1()
</code></pre>
<p>This was my way of resolving it. To summarize, your root directory is <code>.</code> so write your <code>import</code> statement using <code>.</code> notations, e.g. <code>from .package</code> or <code>from app.package</code>.</p>
</div>
<span class="comment-copy">circular import?</span>
<span class="comment-copy">Yes - circular import. A function in module1 asserts that one of its parameter is instance of a class defined in module2 and viceversa.</span>
<span class="comment-copy">relative import must always be <code>from .[optional] import name</code>.</span>
<span class="comment-copy">@J.F.Sebastian In Python2 imports using <code>import X</code> actually can be relative too, unless you import <code>absolute_imports</code> from <code>__future__</code>.</span>
<span class="comment-copy">" i want to make package1 portable for my other applications, that's why i want to use relative paths."  - A better solution for that is to put package1 in it's own separate. Of course then it can't import package2, but then again if it is reusable, why would it?</span>
<span class="comment-copy">I need circular imports. A function in <code>module1</code> asserts that one of its parameter is instance of a class defined in <code>module2</code> and viceversa.</span>
<span class="comment-copy">@warvariuc But one of the includes inside a function definition, instead of the global dictionary.</span>
<span class="comment-copy">Yes, i can do the import at 'runtime' inside the function, but don't like this way.</span>
<span class="comment-copy">It is interesting, that <code>from . import module2</code> in module1 works fine, but <code>from . import module1</code> in module2 fails.</span>
<span class="comment-copy">It’s because module1 is loaded first, and then references module2. If you change <code>start.py</code> to import module2 first, you’ll get the error switched around. And no, you probably don’t need circular imports. Refactor your package design, so those classes are inside a single module, or extract them to some base module.</span>
<span class="comment-copy">modules inside package1 are quite complex, refactoring is difficult for me, that's why i am looking for a way to solve it like this. also see the update.</span>
<span class="comment-copy">@warvariuc: I've updated the answer with the <code>importlib</code> example.</span>
<span class="comment-copy">Not when the main script is called from outside of the <code>package1</code> package. You would need an absolute import path then.</span>
<span class="comment-copy">@poke -- Worked for me, exactly as the OP laid it out. Python2.7, if that matters</span>
<span class="comment-copy">Yeah, it does matter. In Python3 you can only do relative imports using the <code>from..import..</code> syntax, so this does not work.</span>
<span class="comment-copy">i find such (<a href="http://code.google.com/p/web2py/source/browse/gluon/dal.py" rel="nofollow noreferrer">code.google.com/p/web2py/source/browse/gluon/dal.py</a>) not very nice</span>
<span class="comment-copy">@warvariuc Yeah, that's pretty intimidating. But as the quoted answer suggests, you could place some of the contents in another module (if it makes sense to do so), and have the inter-dependent stuff in a single file.</span>
<span class="comment-copy">i don't like that i have to fiddle with refactoring code because language doesn't allow me to make it nicer (see the hack update in the question which does what i want)</span>
<span class="comment-copy">There are always things that can't be done with any language you choose to use. At least, I don't see how to avoid limiting the user <i>in some way</i> during language design. :-)</span>
