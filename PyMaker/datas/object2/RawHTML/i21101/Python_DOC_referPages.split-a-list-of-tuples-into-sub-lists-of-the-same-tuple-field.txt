<div class="post-text" itemprop="text">
<p>I have a huge list of tuples in this format. The second field of the each tuple is the category field.</p>
<pre><code>    [(1, 'A', 'foo'),
    (2, 'A', 'bar'),
    (100, 'A', 'foo-bar'),

    ('xx', 'B', 'foobar'),
    ('yy', 'B', 'foo'),

    (1000, 'C', 'py'),
    (200, 'C', 'foo'),
    ..]
</code></pre>
<p>What is the most efficient way to break it down into sub-lists of the same category ( A, B, C .,etc)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/library/itertools.html#itertools.groupby" rel="noreferrer">itertools.groupby</a>:</p>
<pre><code>import itertools
import operator

data=[(1, 'A', 'foo'),
    (2, 'A', 'bar'),
    (100, 'A', 'foo-bar'),

    ('xx', 'B', 'foobar'),
    ('yy', 'B', 'foo'),

    (1000, 'C', 'py'),
    (200, 'C', 'foo'),
    ]

for key,group in itertools.groupby(data,operator.itemgetter(1)):
    print(list(group))
</code></pre>
<p>yields</p>
<pre><code>[(1, 'A', 'foo'), (2, 'A', 'bar'), (100, 'A', 'foo-bar')]
[('xx', 'B', 'foobar'), ('yy', 'B', 'foo')]
[(1000, 'C', 'py'), (200, 'C', 'foo')]
</code></pre>
<p>Or, to create one list with each group as a sublist, you could use a list comprehension:</p>
<pre><code>[list(group) for key,group in itertools.groupby(data,operator.itemgetter(1))]
</code></pre>
<hr/>
<p>The second argument to <code>itertools.groupby</code> is a function which <code>itertools.groupby</code> applies to each item in <code>data</code> (the first argument). It is expected to return a <code>key</code>. <code>itertools.groupby</code> then groups together all contiguous items with the same <code>key</code>.</p>
<p><a href="http://docs.python.org/library/operator.html#operator.itemgetter" rel="noreferrer">operator.itemgetter(1)</a> picks off the second item in a sequence.</p>
<p>For example, if</p>
<pre><code>row=(1, 'A', 'foo')
</code></pre>
<p>then</p>
<pre><code>operator.itemgetter(1)(row)
</code></pre>
<p>equals <code>'A'</code>.</p>
<hr/>
<p>As @eryksun points out in the comments, if the categories of the tuples appear in some random order, then you must sort <code>data</code> first before applying <code>itertools.groupby</code>. This is because <code>itertools.groupy</code> only collects <strong>contiguous</strong> items with the same key into groups.</p>
<p>To sort the tuples by category, use:</p>
<pre><code>data2=sorted(data,key=operator.itemgetter(1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3><a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a></h3>
<p><code>itertools.groupby</code> requires the input to be sorted by the key field, otherwise you will have to sort <em>first</em>, incurring O(<em>n</em> log <em>n</em>) cost. For guaranteed O(<em>n</em>) time complexity, you can use a <code>defaultdict</code> of lists:</p>
<pre><code>from collections import defaultdict

dd = defaultdict(list)
for item in data:
    dd[item[1]].append(item)

res = list(dd.values())

print(res)

[[(1, 'A', 'foo'), (2, 'A', 'bar'), (100, 'A', 'foo-bar')],
 [('xx', 'B', 'foobar'), ('yy', 'B', 'foo')],
 [(1000, 'C', 'py'), (200, 'C', 'foo')]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To get multiple lists of singletons from a list of tuples:</p>
<pre><code>foo = ((1,2), (3, 4), (5, 6), (7,8) , (9, 10))
[[z[i] for z in foo] for i in (0,1)]
</code></pre>
<p>If you prefer to get multiple tuples of singletons:</p>
<pre><code>zip(*[(1,4),(2,5),(3,6)])
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/7114038/sorting-sub-lists-into-new-sub-lists">Sorting sub-lists into new sub-lists?</a></span>
<span class="comment-copy">Don't forget that the data first has to be sorted: <code>data2 = sorted(data, key=operator.itemgetter(1))</code>.</span>
<span class="comment-copy">Thanks for a very definitive answer.</span>
<span class="comment-copy">Great answer, don't forget that you can use a lambda instead of the operator, for folks who are used to lambdas.</span>
