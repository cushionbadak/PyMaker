<div class="post-text" itemprop="text">
<p>I want to use redis' pubsub to transmit some messages, but don't want be blocked using <code>listen</code>, like the code below:</p>
<pre><code>import redis
rc = redis.Redis()

ps = rc.pubsub()
ps.subscribe(['foo', 'bar'])

rc.publish('foo', 'hello world')

for item in ps.listen():
    if item['type'] == 'message':
        print item['channel']
        print item['data']
</code></pre>
<p>The last <code>for</code> section will block. I just want to check if a given channel has data, how can I accomplish this? Is there a <code>check</code> like method?</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think that would be possible. A Channel doesn't have any "current data", you subscribe to a channel and start receiving messages that are being pushed by other clients on the channel, hence it is a blocking API. Also if you look at the Redis <a href="http://redis.io/commands/subscribe" rel="noreferrer">Commands documentation</a> for pub/sub it would make it more clear.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're thinking of non-blocking, asynchronous processing, you're probably using (or should use) asynchronous framework/server.</p>
<ul>
<li><p>if you're using <a href="http://www.tornadoweb.org/" rel="nofollow noreferrer">Tornado</a>, there is <a href="https://github.com/leporo/tornado-redis" rel="nofollow noreferrer"><strong>Tornado-Redis</strong></a>. It's using native Tornado generator calls. Its <a href="https://github.com/leporo/tornado-redis/tree/master/demos/websockets" rel="nofollow noreferrer">Websocket demo</a> provides example on how to use it in combination with pub/sub.</p></li>
<li><p>if you're using <a href="http://twistedmatrix.com/trac/" rel="nofollow noreferrer">Twisted</a>, there is <a href="https://github.com/deldotdr/txRedis" rel="nofollow noreferrer"><strong>txRedis</strong></a>. There you also have <a href="https://github.com/deldotdr/txRedis/blob/master/examples/pubsub.py" rel="nofollow noreferrer">pub/sub example</a>.</p></li>
<li><p>it also seems that you can use Redis-py combined with <a href="http://www.gevent.org/" rel="nofollow noreferrer">Gevent</a> with no problems using <a href="http://www.gevent.org/gevent.monkey.html" rel="nofollow noreferrer">Gevent's monkey patching </a>(<code>gevent.monkey.patch_all()</code>). </p></li>
</ul>
<p>UPDATE:
It's been 5 years since the original answer, in the mean time Python got <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">native async IO support</a>. There now is <a href="http://aioredis.readthedocs.io" rel="nofollow noreferrer">AIORedis, an async IO Redis client</a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>The new version of redis-py has support for asynchronous pubsub, check <a href="https://github.com/andymccurdy/redis-py" rel="nofollow noreferrer">https://github.com/andymccurdy/redis-py</a> for more details.
Here's an example from the documentation itself:</p>
<pre><code>while True:
    message = p.get_message()
    if message:
        # do something with the message
    time.sleep(0.001)  # be nice to the system :)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Accepted answer is obsolete as redis-py recommends you to use the non-blocking <code>get_message()</code>. But it also provides a way to easily use threads. </p>
<p><a href="https://pypi.python.org/pypi/redis" rel="noreferrer">https://pypi.python.org/pypi/redis</a></p>
<p>There are three different strategies for reading messages.</p>
<p>Behind the scenes, get_message() uses the system’s ‘select’ module to quickly poll the connection’s socket. If there’s data available to be read, get_message() will read it, format the message and return it or pass it to a message handler. If there’s no data to be read, get_message() will immediately return None. This makes it trivial to integrate into an existing event loop inside your application.</p>
<pre><code> while True:
     message = p.get_message()
     if message:
         # do something with the message
     time.sleep(0.001)  # be nice to the system :)
</code></pre>
<p>Older versions of redis-py only read messages with pubsub.listen(). listen() is a generator that blocks until a message is available. If your application doesn’t need to do anything else but receive and act on messages received from redis, listen() is an easy way to get up an running.</p>
<pre><code> for message in p.listen():
     # do something with the message
</code></pre>
<p>The third option runs an event loop in a separate thread. pubsub.run_in_thread() creates a new thread and starts the event loop. The thread object is returned to the caller of run_in_thread(). The caller can use the thread.stop() method to shut down the event loop and thread. Behind the scenes, this is simply a wrapper around get_message() that runs in a separate thread, essentially creating a tiny non-blocking event loop for you. run_in_thread() takes an optional sleep_time argument. If specified, the event loop will call time.sleep() with the value in each iteration of the loop.</p>
<p>Note: Since we’re running in a separate thread, there’s no way to handle messages that aren’t automatically handled with registered message handlers. Therefore, redis-py prevents you from calling run_in_thread() if you’re subscribed to patterns or channels that don’t have message handlers attached.</p>
<pre><code>p.subscribe(**{'my-channel': my_handler})
thread = p.run_in_thread(sleep_time=0.001)
# the event loop is now running in the background processing messages
# when it's time to shut it down...
thread.stop()
</code></pre>
<p>So to answer you question, just check get_message when you want to know if a message has arrived.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a working example to thread the blocking listener.</p>
<pre><code>import sys
import cmd
import redis
import threading


def monitor():
    r = redis.Redis(YOURHOST, YOURPORT, YOURPASSWORD, db=0)

    channel = sys.argv[1]
    p = r.pubsub()
    p.subscribe(channel)

    print 'monitoring channel', channel
    for m in p.listen():
        print m['data']


class my_cmd(cmd.Cmd):
    """Simple command processor example."""

    def do_start(self, line):
        my_thread.start()

    def do_EOF(self, line):
        return True


if __name__ == '__main__':
    if len(sys.argv) == 1:
        print "missing argument! please provide the channel name."
    else:
        my_thread = threading.Thread(target=monitor)
        my_thread.setDaemon(True)

        my_cmd().cmdloop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a nonblocking solution without threads:</p>
<pre><code>fd = ps.connection._sock.fileno();
rlist,, = select.select([fd], [], [], 0) # or replace 0 with None to block
if rlist:
    for rfd in rlist:
        if fd == rfd:
            message = ps.get_message()
</code></pre>
<p><code>ps.get_message()</code> is enough on its own, but I use this method so that I can wait on multiple fds instead of just the redis connection.</p>
</div>
<div class="post-text" itemprop="text">
<p>To reach a none blocking code you must do another kind of paradigm code. It's not hard, using a new thread to listen all changes and leaving main thread to do another things. </p>
<p>Also, you will need some mechanism to interchange data between main thread and redis subscriber thread.</p>
</div>
<div class="post-text" itemprop="text">
<p>The most efficient approach would be greenlet-based rather than thread-based. As a greenlet-based concurrency framework, gevent is already quite established in the Python world. A gevent integration with redis-py would be therefore be wonderful. That is exactly what's being discussed in this issue on github:</p>
<p><a href="https://github.com/andymccurdy/redis-py/issues/310" rel="nofollow">https://github.com/andymccurdy/redis-py/issues/310</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use gevent, gevent monkey patching to build a non-blocking redis pubsub app.</p>
</div>
<div class="post-text" itemprop="text">
<p>Redis' pub/sub sends messages to clients subscribed (listening) on a channel. If you are not listening, you will miss the message (hence the blocking call). If you want to have it non-blocking, I recommend using a queue instead (redis is pretty good at that too). If you have to use pub/sub you can use as suggested gevent to have a asynchronous, blocking listener, push messages to a queue and use a separate consumer to process messages from that queue in a non-blocking way.</p>
</div>
<span class="comment-copy">Is there a reason you don't want to be blocked using listen? Redis connections are pretty cheap and it's generally typical to spawn several of them.</span>
<span class="comment-copy">Asynchronous PubSub in Python using Redis, ZMQ, Tornado - <a href="https://github.com/abhinavsingh/async_pubsub" rel="nofollow noreferrer">github.com/abhinavsingh/async_pubsub</a></span>
<span class="comment-copy">use the pubsub object's .get_message() method instead of .listen() (there's an example below).  [That method may not have been supported in the Python Redis driver when this question was posted].</span>
<span class="comment-copy">I think this answer combined with the other one is pretty complete. He could put this into a thread. If he didnt want instant action taken when a chanel has activity then he could store it maybe in a dict and have his own check method that looks into the dict with a lock mutex</span>
<span class="comment-copy">This is the right answer that should be checked-marked. I'm not sure why people would reinvent the wheel, there is an already existing async-client for redis, spawning a new thread is not really needed in the existance of such a client.</span>
<span class="comment-copy">@securecurve: to be fair, I've added that answer more than a year after the one marked. However, both txRedis and brükva (from which Tornado-Redis forked) are both 3 years old, so it's not really an excuse.</span>
<span class="comment-copy">This answer has nothing to do with the question. As pointed out in the accepted answer, redis pushes messages to clients who are listening. Hence there is no way to ask for messages.</span>
<span class="comment-copy">@Glaslos: There is way to <i>not block</i> on listening for new messages. Which is <i>exactly</i> the question asked.</span>
<span class="comment-copy">I disagree, the listen call on the redis pub/sub channel will always block, also in the case where you run it in a thread/greenlet and switch the context while blocking.</span>
<span class="comment-copy">Doesn't the GIL come into picture now? We could perhaps use multiprocessing (<a href="http://docs.python.org/2/library/multiprocessing.html" rel="nofollow noreferrer">docs.python.org/2/library/multiprocessing.html</a>) instead? But that methods incurs the overhead of creating a process</span>
<span class="comment-copy">GIL won't come to ruin the party because you are not operating in the CPU zone but network listen instead.</span>
<span class="comment-copy">you should not be using listen() if the connection drops, listen() will never complete and your code will hang indefinitely <a href="https://stackoverflow.com/questions/20484920/terminate-a-hung-redis-pubsub-listen-thread" title="terminate a hung redis pubsub listen thread">stackoverflow.com/questions/20484920/…</a></span>
