<div class="post-text" itemprop="text">
<p>I have an OO hierarchy with docstrings that take as much maintenance as the code itself. E.g.,</p>
<pre><code>class Swallow(object):
    def airspeed(self):
        """Returns the airspeed (unladen)"""
        raise NotImplementedError

class AfricanSwallow(Swallow):
    def airspeed(self):
        # whatever
</code></pre>
<p>Now, the problem is that <code>AfricanSwallow.airspeed</code> does not inherit the superclass method's docstring. I know I can keep the docstring using the template method pattern, i.e.</p>
<pre><code>class Swallow(object):
    def airspeed(self):
        """Returns the airspeed (unladen)"""
        return self._ask_arthur()
</code></pre>
<p>and implementing <code>_ask_arthur</code> in each subclass. However, I was wondering whether there's another way to have docstrings be inherited, perhaps some decorator that I hadn't discovered yet?</p>
</div>
<div class="post-text" itemprop="text">
<p>Write a function in a class-decorator style to do the copying for you.  In Python2.5, you can apply it directly after the class is created.  In later versions, you can apply with the <a href="https://docs.python.org/2.7/glossary.html#term-decorator" rel="nofollow noreferrer">@decorator</a> notation.</p>
<p>Here's a first cut at how to do it:</p>
<pre><code>import types

def fix_docs(cls):
    for name, func in vars(cls).items():
        if isinstance(func, types.FunctionType) and not func.__doc__:
            print func, 'needs doc'
            for parent in cls.__bases__:
                parfunc = getattr(parent, name, None)
                if parfunc and getattr(parfunc, '__doc__', None):
                    func.__doc__ = parfunc.__doc__
                    break
    return cls


class Animal(object):
    def walk(self):
        'Walk like a duck'

class Dog(Animal):
    def walk(self):
        pass

Dog = fix_docs(Dog)
print Dog.walk.__doc__
</code></pre>
<p>In newer Python versions, the last part is even more simple and beautiful:</p>
<pre><code>@fix_docs
class Dog(Animal):
    def walk(self):
        pass
</code></pre>
<p>This is a Pythonic technique that exactly matches the design of existing tools in the standard library.  For example, the <a href="https://docs.python.org/2.7/library/functools.html#functools.total_ordering" rel="nofollow noreferrer"><em>functools.total_ordering</em></a> class decorator add missing rich comparison methods to classes.  And for another example,  the <a href="https://docs.python.org/2.7/library/functools.html#functools.wraps" rel="nofollow noreferrer"><em>functools.wraps</em></a> decorator copies metadata from one function to another.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a variation on <a href="http://groups.google.com/group/comp.lang.python/msg/26f7b4fcb4d66c95" rel="nofollow noreferrer">Paul McGuire's DocStringInheritor metaclass</a>.</p>
<ol>
<li>It inherits a parent member's docstring if the child member's
docstring is empty.</li>
<li>It inherits a parent class docstring if the child class docstring is
empty. </li>
<li>It can inherit the docstring from any class in
any of the base classes's MROs, just like regular attribute inheritance. </li>
<li>Unlike with a class decorator, the metaclass is inherited, so you only need to set the metaclass once in some top-level base class, and docstring inheritance will  occur throughout your OOP hierarchy.</li>
</ol>
<hr/>
<pre><code>import unittest
import sys

class DocStringInheritor(type):
    """
    A variation on
    http://groups.google.com/group/comp.lang.python/msg/26f7b4fcb4d66c95
    by Paul McGuire
    """
    def __new__(meta, name, bases, clsdict):
        if not('__doc__' in clsdict and clsdict['__doc__']):
            for mro_cls in (mro_cls for base in bases for mro_cls in base.mro()):
                doc=mro_cls.__doc__
                if doc:
                    clsdict['__doc__']=doc
                    break
        for attr, attribute in clsdict.items():
            if not attribute.__doc__:
                for mro_cls in (mro_cls for base in bases for mro_cls in base.mro()
                                if hasattr(mro_cls, attr)):
                    doc=getattr(getattr(mro_cls,attr),'__doc__')
                    if doc:
                        if isinstance(attribute, property):
                            clsdict[attr] = property(attribute.fget, attribute.fset, 
                                                     attribute.fdel, doc)
                        else:
                            attribute.__doc__ = doc
                        break
        return type.__new__(meta, name, bases, clsdict)



class Test(unittest.TestCase):

    def test_null(self):
        class Foo(object):

            def frobnicate(self): pass

        class Bar(Foo, metaclass=DocStringInheritor):
            pass

        self.assertEqual(Bar.__doc__, object.__doc__)
        self.assertEqual(Bar().__doc__, object.__doc__)
        self.assertEqual(Bar.frobnicate.__doc__, None)

    def test_inherit_from_parent(self):
        class Foo(object):
            'Foo'

            def frobnicate(self):
                'Frobnicate this gonk.'
        class Bar(Foo, metaclass=DocStringInheritor):
            pass
        self.assertEqual(Foo.__doc__, 'Foo')
        self.assertEqual(Foo().__doc__, 'Foo')
        self.assertEqual(Bar.__doc__, 'Foo')
        self.assertEqual(Bar().__doc__, 'Foo')
        self.assertEqual(Bar.frobnicate.__doc__, 'Frobnicate this gonk.')

    def test_inherit_from_mro(self):
        class Foo(object):
            'Foo'

            def frobnicate(self):
                'Frobnicate this gonk.'
        class Bar(Foo):
            pass

        class Baz(Bar, metaclass=DocStringInheritor):
            pass

        self.assertEqual(Baz.__doc__, 'Foo')
        self.assertEqual(Baz().__doc__, 'Foo')
        self.assertEqual(Baz.frobnicate.__doc__, 'Frobnicate this gonk.')

    def test_inherit_metaclass_(self):
        class Foo(object):
            'Foo'

            def frobnicate(self):
                'Frobnicate this gonk.'
        class Bar(Foo, metaclass=DocStringInheritor):
            pass

        class Baz(Bar):
            pass
        self.assertEqual(Baz.__doc__, 'Foo')
        self.assertEqual(Baz().__doc__, 'Foo')
        self.assertEqual(Baz.frobnicate.__doc__, 'Frobnicate this gonk.')

    def test_property(self):
        class Foo(object):
            @property
            def frobnicate(self): 
                'Frobnicate this gonk.'
        class Bar(Foo, metaclass=DocStringInheritor):
            @property
            def frobnicate(self): pass

        self.assertEqual(Bar.frobnicate.__doc__, 'Frobnicate this gonk.')


if __name__ == '__main__':
    sys.argv.insert(1, '--verbose')
    unittest.main(argv=sys.argv)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>F.Y.I for people just now stumbling on this topic: As of Python 3.5, <a href="https://docs.python.org/3/library/inspect.html#inspect.getdoc" rel="noreferrer">inspect.getdoc</a> automatically retrieves docstrings from the inheritance hierarchy.</p>
<p>The responses above are thus useful for Python 2, or if you want to be more creative with merging the docstrings of parents and children.  </p>
<p>I've also created some <a href="https://github.com/meowklaski/custom_inherit" rel="noreferrer">lightweight tools for docstring inheritance</a>. These support some nice default docstring styles (numpy, google, reST) out of the box. You can easily use your own docstring style as well </p>
</div>
<div class="post-text" itemprop="text">
<p>The following adaptation also handles properties and mixin classes. I also came across a situation where I had to use <code>func.__func__</code> (for "instancemethod"s), but I'm not completely sure why the other solutions didn't encouter that problem.</p>
<pre><code>def inherit_docs(cls):
    for name in dir(cls):
        func = getattr(cls, name)
        if func.__doc__: 
            continue
        for parent in cls.mro()[1:]:
            if not hasattr(parent, name):
                continue
            doc = getattr(parent, name).__doc__
            if not doc: 
                continue
            try:
                # __doc__'s of properties are read-only.
                # The work-around below wraps the property into a new property.
                if isinstance(func, property):
                    # We don't want to introduce new properties, therefore check
                    # if cls owns it or search where it's coming from.
                    # With that approach (using dir(cls) instead of var(cls))
                    # we also handle the mix-in class case.
                    wrapped = property(func.fget, func.fset, func.fdel, doc)
                    clss = filter(lambda c: name in vars(c).keys() and not getattr(c, name).__doc__, cls.mro())
                    setattr(clss[0], name, wrapped)
                else:
                    try:
                        func = func.__func__ # for instancemethod's
                    except:
                        pass
                    func.__doc__ = doc
            except: # some __doc__'s are not writable
                pass
            break
    return cls
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def fix_docs(cls):
    """ copies docstrings of derived attributes (methods, properties, attrs) from parent classes."""
    public_undocumented_members = {name: func for name, func in vars(cls).items()
                                   if not name.startswith('_') and not func.__doc__}

    for name, func in public_undocumented_members.iteritems():
        for parent in cls.mro()[1:]:
            parfunc = getattr(parent, name, None)
            if parfunc and getattr(parfunc, '__doc__', None):
                if isinstance(func, property):
                    # copy property, since its doc attribute is read-only
                    new_prop = property(fget=func.fget, fset=func.fset,
                                        fdel=func.fdel, doc=parfunc.__doc__)
                    cls.func = new_prop
                else:
                    func.__doc__ = parfunc.__doc__
                break
    return cls
</code></pre>
</div>
<span class="comment-copy">The example alone would be worth +1 (you see far too few Python references outside the official documentation). Luckily, the remaining question also justifies an upvote ;)</span>
<span class="comment-copy">Have a look at <a href="http://www.google.com/search?q=python+inherit+docstring" rel="nofollow noreferrer">google.com/search?q=python+inherit+docstring</a> -- there are lots of solutions.</span>
<span class="comment-copy">It should be possible to write a class decorator that goes through all the methods to see if their <code>__doc__</code> is <code>None</code> and if so borrows the super <code>__doc__</code>.  Don't have time to try it right now...  See also <a href="http://stackoverflow.com/questions/2025562/inherit-docstrings-in-python-class-inheritance" title="inherit docstrings in python class inheritance">stackoverflow.com/questions/2025562/â€¦</a></span>
<span class="comment-copy">@wberry: class decorators aren't an option, as I'm targeting Python 2.5. Sorry, I should have said that earlier.</span>
<span class="comment-copy">This answer contains an error. <code>vars(cls)</code> contains the pair <code>'__doc__': None</code> from the class, which raises an <code>AttributeError</code> in <code>if func.__doc__</code>. That item should be either skipped or special cased.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/38601305/551045">Here</a> is a version that will also inherit the description of properties.</span>
<span class="comment-copy">And for Python 3?</span>
<span class="comment-copy">@NeilG: I updated the code to be compatible with Python3. The only change necessary (now) is to define <code>Baz</code> with <code>class Baz(Bar,metaclass=DocStringInheritor)</code> instead of <code>__metaclass__ = DocStringInheritor</code> in the class body.</span>
<span class="comment-copy">A metaclass is a bit of overkill for this :-)</span>
<span class="comment-copy">It's only overkill in case there is a simpler solution which has no drawbacks.</span>
<span class="comment-copy">This crashes if the derived classes have properties (Python 2.7.9). See: <a href="http://stackoverflow.com/q/38600186/551045">stackoverflow.com/q/38600186/551045</a></span>
