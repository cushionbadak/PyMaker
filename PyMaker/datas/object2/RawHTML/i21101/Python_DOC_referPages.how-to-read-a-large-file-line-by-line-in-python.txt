<div class="post-text" itemprop="text">
<p>I want to iterate over each line of an entire file. One way to do this is by reading the entire file, saving it to a list, then going over the line of interest. This method uses a lot of memory, so I am looking for an alternative.</p>
<p>My code so far:</p>
<pre><code>for each_line in fileinput.input(input_file):
    do_something(each_line)

    for each_line_again in fileinput.input(input_file):
        do_something(each_line_again)
</code></pre>
<p>Executing this code gives an error message: <code>device active</code>.</p>
<p>Any suggestions?</p>
<p>The purpose is to calculate pair-wise string similarity, meaning for each line in file, I want to calculate the Levenshtein distance with every other line.</p>
</div>
<div class="post-text" itemprop="text">
<p>The correct, fully Pythonic way to read a file is the following:</p>
<pre><code>with open(...) as f:
    for line in f:
        # Do something with 'line'
</code></pre>
<p>The <code>with</code> statement handles opening and closing the file, including if an exception is raised in the inner block. The <code>for line in f</code> treats the file object <code>f</code> as an iterable, which automatically uses buffered I/O and memory management so you don't have to worry about large files.</p>
<blockquote>
<p>There should be one -- and preferably only one -- obvious way to do it.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Two memory efficient ways in ranked order (first is best) -</p>
<ol>
<li>use of <code>with</code> - supported from python 2.5 and above</li>
<li>use of <code>yield</code> if you really want to have control over how much to read</li>
</ol>
<h2>1. use of <code>with</code></h2>
<p><code>with</code> is the nice and efficient pythonic way to read large files. advantages - 1) file object is automatically closed after exiting from <code>with</code> execution block. 2) exception handling inside the <code>with</code> block. 3) memory <code>for</code> loop iterates through the <code>f</code> file object line by line. internally it does buffered IO (to optimized on costly IO operations) and memory management. </p>
<pre><code>with open("x.txt") as f:
    for line in f:
        do something with data
</code></pre>
<h2>2. use of <code>yield</code></h2>
<p>Sometimes one might want more fine-grained control over how much to read in each iteration. In that case use <a href="http://docs.python.org/library/functions.html#iter" rel="noreferrer">iter</a> &amp; <a href="http://docs.python.org/tutorial/classes.html#generators" rel="noreferrer">yield</a>. Note with this method one explicitly needs close the file at the end.</p>
<pre><code>def readInChunks(fileObj, chunkSize=2048):
    """
    Lazy function to read a file piece by piece.
    Default chunk size: 2kB.
    """
    while True:
        data = fileObj.read(chunkSize)
        if not data:
            break
        yield data

f = open('bigFile')
for chuck in readInChunks(f):
    do_something(chunk)
f.close()
</code></pre>
<hr/>
<p><strong>Pitfalls and for the sake of completeness</strong> - below methods are not as good or not as elegant for reading large files but please read to get rounded understanding.</p>
<p>In Python, the most common way to read lines from a file is to do the following: </p>
<pre><code>for line in open('myfile','r').readlines():
    do_something(line)
</code></pre>
<p>When this is done, however, the <code>readlines()</code> function (same applies for <code>read()</code> function) loads the entire file into memory, then iterates over it. A slightly better approach (the first mentioned two methods are the best) for large files is to use the <code>fileinput</code> module, as follows:</p>
<pre><code>import fileinput

for line in fileinput.input(['myfile']):
    do_something(line)
</code></pre>
<p>the <code>fileinput.input()</code> call reads lines sequentially, but doesn't keep them in memory after they've been read or even simply so this, since <code>file</code> in python is iterable. </p>
<h2>References</h2>
<ol>
<li><a href="http://effbot.org/zone/python-with-statement.htm" rel="noreferrer">Python with statement</a></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<h2>To strip newlines:</h2>
<pre><code>with open(file_path, 'rU') as f:
    for line_terminated in f:
        line = line_terminated.rstrip('\n')
        ...
</code></pre>
<p>With <a href="https://docs.python.org/2/library/functions.html#open" rel="noreferrer">universal newline support</a> all text file lines will seem to be terminated with <code>'\n'</code>, whatever the terminators in the file, <code>'\r'</code>, <code>'\n'</code>, or <code>'\r\n'</code>. </p>
<p><strong>EDIT -</strong> To specify universal newline support:</p>
<ul>
<li>Python 2 on Unix - <code>open(file_path, mode='rU')</code> - required <sup>[thanks <a href="https://stackoverflow.com/a/32589529/673991#comment82243835_32589529">@Dave</a>]</sup></li>
<li>Python 2 on Windows - <code>open(file_path, mode='rU')</code> - optional</li>
<li>Python 3 - <code>open(file_path, newline=None)</code> - optional</li>
</ul>
<p>The <code>newline</code> parameter is only supported in Python 3 and defaults to <code>None</code>. The <code>mode</code> parameter defaults to <code>'r'</code> in all cases. The <code>U</code> is deprecated in Python 3. In Python 2 on Windows some other mechanism appears to translate <code>\r\n</code> to <code>\n</code>.</p>
<p>Docs:</p>
<ul>
<li><a href="https://docs.python.org/2/library/functions.html#open" rel="noreferrer">open() for Python 2</a></li>
<li><a href="https://docs.python.org/3/library/functions.html#open" rel="noreferrer">open() for Python 3</a></li>
</ul>
<h2>To preserve native line terminators:</h2>
<pre><code>with open(file_path, 'rb') as f:
    with line_native_terminated in f:
        ...
</code></pre>
<p>Binary mode can still parse the file into lines with <code>in</code>.  Each line will have whatever terminators it has in the file.</p>
<p><em>Thanks to <a href="https://stackoverflow.com/users/398968/katrielalex">@katrielalex</a>'s <a href="https://stackoverflow.com/a/8010133/673991">answer</a>, Python's <a href="https://docs.python.org/2/library/functions.html#open" rel="noreferrer">open()</a> doc, and <a href="http://ipython.org/" rel="noreferrer">iPython</a> experiments.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>this is a possible way of reading a file in python:</p>
<pre><code>f = open(input_file)
for line in f:
    do_stuff(line)
f.close()
</code></pre>
<p>it does not allocate a full list. It iterates over the lines.</p>
</div>
<div class="post-text" itemprop="text">
<p>Some context up front as to where I am coming from. Code snippets are at the end.</p>
<p>When I can, I prefer to use an open source tool like H2O to do super high performance parallel CSV file reads, but this tool is limited in feature set. I end up writing a lot of code to create data science pipelines before feeding to H2O cluster for the supervised learning proper.</p>
<p>I have been reading files like 8GB HIGGS dataset from UCI repo and even 40GB CSV files for data science purposes significantly faster by adding lots of parallelism with the multiprocessing library's pool object and map function. For example clustering with nearest neighbor searches and also DBSCAN and Markov clustering algorithms requires some parallel programming finesse to bypass some seriously challenging memory and wall clock time problems. </p>
<p>I usually like to break the file row-wise into parts using gnu tools first and then glob-filemask them all to find and read them in parallel in the python program. I use something like 1000+ partial files commonly. Doing these tricks helps immensely with processing speed and memory limits.  </p>
<p>The pandas dataframe.read_csv is single threaded so you can do these tricks to make pandas quite faster by running a map() for parallel execution.  You can use htop to see that with plain old sequential pandas dataframe.read_csv, 100% cpu on just one core is the actual bottleneck in pd.read_csv, not the disk at all.</p>
<p>I should add I'm using an SSD on fast video card bus, not a spinning HD on SATA6 bus, plus 16 CPU cores.</p>
<p>Also, another technique that I discovered works great in some applications is parallel CSV file reads all within one giant file, starting each worker at different offset into the file, rather than pre-splitting one big file into many part files. Use python's file seek() and tell() in each parallel worker to read the big text file in strips, at different byte offset start-byte and end-byte locations in the big file, all at the same time concurrently. You can do a regex findall on the bytes, and return the count of linefeeds. This is a partial sum.  Finally sum up the partial sums to get the global sum when the map function returns after the workers finished.</p>
<p>Following is some example benchmarks using the parallel byte offset trick:</p>
<p>I use 2 files: HIGGS.csv is 8 GB. It is from the UCI machine learning repository.  all_bin .csv is 40.4 GB and is from my current project.
I use 2 programs: GNU wc program which comes with Linux, and the pure python fastread.py program which I developed.</p>
<pre><code>HP-Z820:/mnt/fastssd/fast_file_reader$ ls -l /mnt/fastssd/nzv/HIGGS.csv
-rw-rw-r-- 1 8035497980 Jan 24 16:00 /mnt/fastssd/nzv/HIGGS.csv

HP-Z820:/mnt/fastssd$ ls -l all_bin.csv
-rw-rw-r-- 1 40412077758 Feb  2 09:00 all_bin.csv

ga@ga-HP-Z820:/mnt/fastssd$ time python fastread.py --fileName="all_bin.csv" --numProcesses=32 --balanceFactor=2
2367496

real    0m8.920s
user    1m30.056s
sys 2m38.744s

In [1]: 40412077758. / 8.92
Out[1]: 4530501990.807175
</code></pre>
<p>That’s some 4.5 GB/s, or 45 Gb/s, file slurping speed.  That ain’t no spinning hard disk, my friend. That’s actually a Samsung Pro 950 SSD. </p>
<p>Below is the speed benchmark for the same file being line-counted by gnu wc, a pure C compiled program.</p>
<p>What is cool is you can see my pure python program essentially matched the speed of the gnu wc compiled C program in this case.  Python is interpreted but C is compiled, so this is a pretty interesting feat of speed, I think you would agree.  Of course, wc really needs to be changed to a parallel program, and then it would really beat the socks off my python program. But as it stands today, gnu wc is just a sequential program.  You do what you can, and python can do parallel today. Cython compiling might be able to help me (for some other time). Also memory mapped files was not explored yet.</p>
<pre><code>HP-Z820:/mnt/fastssd$ time wc -l all_bin.csv
2367496 all_bin.csv

real    0m8.807s
user    0m1.168s
sys 0m7.636s


HP-Z820:/mnt/fastssd/fast_file_reader$ time python fastread.py --fileName="HIGGS.csv" --numProcesses=16 --balanceFactor=2
11000000

real    0m2.257s
user    0m12.088s
sys 0m20.512s

HP-Z820:/mnt/fastssd/fast_file_reader$ time wc -l HIGGS.csv
11000000 HIGGS.csv

real    0m1.820s
user    0m0.364s
sys 0m1.456s
</code></pre>
<p>Conclusion: The speed is good for a pure python program compared to a C program. However, it’s not good enough to use the pure python program over the C program, at least for linecounting purpose. Generally the technique can be used for other file processing, so this python code is still good.</p>
<p>Question: Does compiling the regex just one time and passing it to all workers will improve speed? Answer: Regex pre-compiling does NOT help in this application. I suppose the reason is that the overhead of process serialization and creation for all the workers is dominating.</p>
<p>One more thing. 
Does parallel CSV file reading even help?  Is the disk the bottleneck, or is it the CPU?  Many so-called top-rated answers on stackoverflow contain the common dev wisdom that you only need one thread to read a file, best you can do, they say. Are they sure, though?</p>
<p>Let’s find out:</p>
<pre><code>HP-Z820:/mnt/fastssd/fast_file_reader$ time python fastread.py --fileName="HIGGS.csv" --numProcesses=16 --balanceFactor=2
11000000

real    0m2.256s
user    0m10.696s
sys 0m19.952s

HP-Z820:/mnt/fastssd/fast_file_reader$ time python fastread.py --fileName="HIGGS.csv" --numProcesses=1 --balanceFactor=1
11000000

real    0m17.380s
user    0m11.124s
sys 0m6.272s
</code></pre>
<p>Oh yes, yes it does. Parallel file reading works quite well.  Well there you go!</p>
<p>Ps. In case some of you wanted to know, what if the balanceFactor was 2 when using a single worker process? Well, it’s horrible:</p>
<pre><code>HP-Z820:/mnt/fastssd/fast_file_reader$ time python fastread.py --fileName="HIGGS.csv" --numProcesses=1 --balanceFactor=2
11000000

real    1m37.077s
user    0m12.432s
sys 1m24.700s
</code></pre>
<p>Key parts of the fastread.py python program:</p>
<pre><code>fileBytes = stat(fileName).st_size  # Read quickly from OS how many bytes are in a text file
startByte, endByte = PartitionDataToWorkers(workers=numProcesses, items=fileBytes, balanceFactor=balanceFactor)
p = Pool(numProcesses)
partialSum = p.starmap(ReadFileSegment, zip(startByte, endByte, repeat(fileName))) # startByte is already a list. fileName is made into a same-length list of duplicates values.
globalSum = sum(partialSum)
print(globalSum)


def ReadFileSegment(startByte, endByte, fileName, searchChar='\n'):  # counts number of searchChar appearing in the byte range
    with open(fileName, 'r') as f:
        f.seek(startByte-1)  # seek is initially at byte 0 and then moves forward the specified amount, so seek(5) points at the 6th byte.
        bytes = f.read(endByte - startByte + 1)
        cnt = len(re.findall(searchChar, bytes)) # findall with implicit compiling runs just as fast here as re.compile once + re.finditer many times.
    return cnt
</code></pre>
<p>The def for PartitionDataToWorkers is just ordinary sequential code. I left it out in case someone else wants to get some practice on what parallel programming is like. I gave away for free the harder parts: the tested and working parallel code, for your learning benefit.</p>
<p>Thanks to:  The open-source H2O project, by Arno and Cliff and the H2O staff for their great software and instructional videos, which have provided me the inspiration for this pure python high performance parallel byte offset reader as shown above.  H2O does parallel file reading using java, is callable by python and R programs, and is crazy fast, faster than anything on the planet at reading big CSV files.</p>
</div>
<div class="post-text" itemprop="text">
<p>Katrielalex provided the way to open &amp; read one file.</p>
<p>However the way your algorithm goes it reads the whole file for each line of the file. That means the overall amount of reading a file - and computing the <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Levenshtein_distance" rel="nofollow">Levenshtein distance</a> - will be done N*N if N is the amount of lines in the file. Since you're concerned about file size and don't want to keep it in memory, I am concerned about the resulting <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Big_O_notation#Orders_of_common_functions" rel="nofollow">quadratic runtime</a>. Your algorithm is in the O(n^2) class of algorithms which often can be improved with specialization.</p>
<p>I suspect that you already know the tradeoff of memory versus runtime here, but maybe you would want to investigate if there's an efficient way to compute multiple Levenshtein distances in parallel. If so it would be interesting to share your solution here.</p>
<p>How many lines do your files have, and on what kind of machine (mem &amp; cpu power) does your algorithm have to run, and what's the tolerated runtime?</p>
<p>Code would look like:</p>
<pre><code>with f_outer as open(input_file, 'r'):
    for line_outer in f_outer:
        with f_inner as open(input_file, 'r'):
            for line_inner in f_inner:
                compute_distance(line_outer, line_inner)
</code></pre>
<p>But the questions are how do you store the distances (matrix?) and can you gain an advantage of preparing e.g. the outer_line for processing, or caching some intermediate results for reuse.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>#Using a text file for the example
with open("yourFile.txt","r") as f:
    text = f.readlines()
for line in text:
    print line
</code></pre>
<ul>
<li>Open your file for reading (r)</li>
<li>Read the whole file and save each line into a <strong>list</strong> (text)</li>
<li>Loop through the list printing each line.</li>
</ul>
<p><em>If you want, for example, to check a specific line for a length greater than 10, work with what you already have available.</em></p>
<pre><code>for line in text:
    if len(line) &gt; 10:
        print line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the python documentation for <a href="http://docs.python.org/library/fileinput.html" rel="nofollow">fileinput</a>.input():</p>
<blockquote>
<p>This iterates over the lines of all files listed in <code>sys.argv[1:]</code>, defaulting to <code>sys.stdin</code> if the list is empty</p>
</blockquote>
<p>further, the definition of the function is:</p>
<pre><code>fileinput.FileInput([files[, inplace[, backup[, mode[, openhook]]]]])
</code></pre>
<p>reading between the lines, this tells me that <code>files</code> can be a list so you could have something like:</p>
<pre><code>for each_line in fileinput.input([input_file, input_file]):
  do_something(each_line)
</code></pre>
<p>See <a href="http://docs.python.org/library/fileinput.html" rel="nofollow">here</a> for more information</p>
</div>
<div class="post-text" itemprop="text">
<p>I would strongly recommend not using the default file loading as it is horrendously slow. You should look into the numpy functions and the IOpro functions (e.g. numpy.loadtxt()).</p>
<p><a href="http://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html" rel="nofollow">http://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html</a></p>
<p><a href="https://store.continuum.io/cshop/iopro/" rel="nofollow">https://store.continuum.io/cshop/iopro/</a></p>
<p>Then you can break your pairwise operation into chunks:</p>
<pre><code>import numpy as np
import math

lines_total = n    
similarity = np.zeros(n,n)
lines_per_chunk = m
n_chunks = math.ceil(float(n)/m)
for i in xrange(n_chunks):
    for j in xrange(n_chunks):
        chunk_i = (function of your choice to read lines i*lines_per_chunk to (i+1)*lines_per_chunk)
        chunk_j = (function of your choice to read lines j*lines_per_chunk to (j+1)*lines_per_chunk)
        similarity[i*lines_per_chunk:(i+1)*lines_per_chunk,
                   j*lines_per_chunk:(j+1)*lines_per_chunk] = fast_operation(chunk_i, chunk_j) 
</code></pre>
<p>It's almost always much faster to load data in chunks and then do matrix operations on it than to do it element by element!!</p>
</div>
<div class="post-text" itemprop="text">
<p>Best way to read large file, line by line is to use python <strong>enumerate</strong> function</p>
<pre><code>with open(file_name, "rU") as read_file:
    for i, row in enumerate(read_file, 1):
        #do something
        #i in line of that line
        #row containts all data of that line
</code></pre>
</div>
<span class="comment-copy">Is that your real code indenting? The second <code>for</code> loop runs within the first one? Use four spaces for indentation, please.</span>
<span class="comment-copy">Why do you need to read the entire file again for each line? Maybe if you told what you're trying to accomplish someone might be able to suggest a better approach.</span>
<span class="comment-copy">yep, this is the best version with python 2.6 and above</span>
<span class="comment-copy">I personally prefer generators &amp; coroutines for dealing with data pipelines.</span>
<span class="comment-copy">what would be the best strategy if a file is a huge text file but with one line and the idea is to process words?</span>
<span class="comment-copy">Could someone explain how <code>for line in f:</code> is working? I mean, how iterating over file object is possible?</span>
<span class="comment-copy">If you iterate over an object, Python looks up in the list of object methods a special one called <code>__iter__</code>, which tells it what to do. File objects define this special method to return an iterator over the lines. (Roughly.)</span>
<span class="comment-copy">-1 It's basically never a good idea to do <code>for line in open(...).readlines(): &lt;do stuff&gt;</code>. Why would you?! You've just lost all the benefit of Python's clever buffered iterator IO for no benefit.</span>
<span class="comment-copy">dude! that's what i go about saying in my answer.No need to downvote. I wanted my answer to be comprehensive to have all the good &amp; bad of reading file in python. read the answer fully before downvoting.</span>
<span class="comment-copy">it is best to avoid giving bad exemples even if you state clearly that this is bad. Especially if your answer is long and OP is a beginner. Still +1 for completness</span>
<span class="comment-copy">@Srikar: there is a time and a place for giving all the possible solutions to a problem; teaching a beginner how to do file input is not it. Having the correct answer buried at the bottom of a long post full of wrong answers does not good teaching make.</span>
<span class="comment-copy">@Srikar: You could make your post significantly better by putting the right way at the top, then mentioning <code>readlines</code> and explaining why it's not a good thing to do (because it reads the file into memory), then explaining what the <code>fileinput</code> module does and why you might want to use it over the other methods, then explaining how chunking the file makes the IO better and giving an example of the chunking function (but mentioning that Python does this already for you so you don't need to). But just giving five ways to solve a simple problem, four of which are wrong in this case, is not good.</span>
<span class="comment-copy">On Python 2.7 I had to <code>open(file_path, 'rU')</code> to enable universal newlines.</span>
<span class="comment-copy">While this works, it's definitely not the canonical way. The canonical way is to use a context wrapper, like <code>with open(input_file) as f:</code>. This saves you the <code>f.close()</code> and makes sure you don't accidentally forget to close it. Prevents memory leaks and all, quite important when reading files.</span>
<span class="comment-copy">As @Mast said, that is not the canonical way, so downvote for that.</span>
<span class="comment-copy">Parallel chunks is what this is, basically.  Also, I expect SSD and Flash are the only compatible storage devices with this technique. Spinning HD is unlikely to be compatible.</span>
<span class="comment-copy">@katriealex: What is your point? Please be constructive.</span>
<span class="comment-copy">My point is that this post does not contain an answer to the question, just some more questions! IMO it would be better suited as a comment.</span>
<span class="comment-copy">@katriealex: Err. Strange. You did see the nested loops, expanding your own answer to fit the actual question? I can remove my questions here from my answer, and there's yet enough content to warrant providing this as a - albeit partial - answer. I could also accept if you'd edit your own answer to include the nested loop example - which was explicitly asked by the question - and then I can remove my own answer happily. But a downvote is something I don't get at all.</span>
<span class="comment-copy">Fair enough; I don't really see demonstrating the nested for loops as an answer to the question but I guess it's pretty strongly targeted at beginners. Downvote removed.</span>
<span class="comment-copy">Not best for this question, but this code is mainly useful in case what you are looking for.is "slurping" (reading the whole file at once). That was my case and google got me here. +1. Also, for atomicity, or if you do time consuming processing in the loop might endup faster to read whole file</span>
<span class="comment-copy">Also, improved the code a bit: 1. close is not needed after with: (<a href="https://docs.python.org/2/tutorial/inputoutput.html" rel="nofollow noreferrer">docs.python.org/2/tutorial/inputoutput.html</a>, search for "It is good practice to use the with keyword...") 2. text can be processed after file is read (ouside of with loop....)</span>
<span class="comment-copy">Why is using enumerate any better? The only benefit over the accepted answer is that you get an index, which OP doesn't need and you are making the code less readable.</span>
