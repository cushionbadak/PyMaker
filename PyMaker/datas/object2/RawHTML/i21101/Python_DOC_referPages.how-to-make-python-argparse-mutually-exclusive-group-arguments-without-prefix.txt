<div class="post-text" itemprop="text">
<p>Python2.7 argparse only accepts optional arguments (prefixed) in mutually exclusive groups:</p>
<pre><code>parser = argparse.ArgumentParser(prog='mydaemon')
action = parser.add_mutually_exclusive_group(required=True)
action.add_argument('--start', action='store_true', help='Starts %(prog)s daemon')
action.add_argument('--stop', action='store_true', help='Stops %(prog)s daemon')
action.add_argument('--restart', action='store_true', help='Restarts %(prog)s daemon')
</code></pre>
<p>$ mydaemon -h</p>
<pre><code>usage: mydaemon [-h] (--start | --stop | --restart)

optional arguments:
  -h, --help  show this help message and exit
  --start     Starts mydaemon daemon
  --stop      Stops mydaemon daemon
  --restart   Restarts mydaemon daemon
</code></pre>
<p>Is there a way to make argparse arguments behaves like traditional unix daemon control:</p>
<pre><code>(start | stop | restart) and not (--start | --stop | --restart) ?
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For all the abilities and options in <code>argparse</code> I don't think you'll ever get a "canned" usage string that looks like what you want.</p>
<p>That said, have you looked at sub-parsers since your original post?</p>
<p>Here's a barebones implementation:</p>
<pre><code>import argparse

parser = argparse.ArgumentParser(prog='mydaemon')
sp = parser.add_subparsers()
sp_start = sp.add_parser('start', help='Starts %(prog)s daemon')
sp_stop = sp.add_parser('stop', help='Stops %(prog)s daemon')
sp_restart = sp.add_parser('restart', help='Restarts %(prog)s daemon')

parser.parse_args()
</code></pre>
<p>Running this with the <code>-h</code> option yields:</p>
<pre><code>usage: mydaemon [-h] {start,stop,restart} ...

positional arguments:
  {start,stop,restart}
    start               Starts mydaemon daemon
    stop                Stops mydaemon daemon
    restart             Restarts mydaemon daemon
</code></pre>
<p>One of the benefits of this approach is being able to use <code>set_defaults</code> for each sub-parser to hook up a function directly to the argument.  I've also added a "graceful" option for <code>stop</code> and <code>restart</code>:</p>
<pre><code>import argparse

def my_stop(args):
    if args.gracefully:
        print "Let's try to stop..."
    else:
        print 'Stop, now!'

parser = argparse.ArgumentParser(prog='mydaemon')

graceful = argparse.ArgumentParser(add_help=False)
graceful.add_argument('-g', '--gracefully', action='store_true', help='tries to terminate the process gracefully')
sp = parser.add_subparsers()
sp_start = sp.add_parser('start', help='Starts %(prog)s daemon')
sp_stop = sp.add_parser('stop', parents=[graceful],
                    description='Stops the daemon if it is currently running.',
                    help='Stops %(prog)s daemon')
sp_restart = sp.add_parser('restart', parents=[graceful], help='Restarts %(prog)s daemon')

# Hook subparsers up to functions
sp_stop.set_defaults(func=my_stop)

# Uncomment when my_start() and 
# my_restart() are implemented
#
# sp_start.set_defaults(func=my_start)
# sp_restart.set_defaults(func=my_restart)

args = parser.parse_args()
args.func(args)
</code></pre>
<p>Showing the "help" message for <code>stop</code>:</p>
<pre><code>$ python mydaemon.py stop -h
usage: mydaemon stop [-h] [-g]

Stops the daemon if it is currently running.

optional arguments:
  -h, --help        show this help message and exit
  -g, --gracefully  tries to terminate the process gracefully
</code></pre>
<p>Stopping "gracefully":</p>
<pre><code>$ python mydaemon.py stop -g
Let's try to stop...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>from <a href="http://pymotw.com/2/argparse/index.html#module-argparse" rel="noreferrer">pymotw</a> </p>
<pre><code>import argparse

parser = argparse.ArgumentParser()

group = parser.add_mutually_exclusive_group()
group.add_argument('-a', action='store_true')
group.add_argument('-b', action='store_true')

print parser.parse_args()
</code></pre>
<p><strong>output:</strong></p>
<pre><code>$ python argparse_mutually_exclusive.py -h  
usage: argparse_mutually_exclusive.py [-h] [-a | -b]

optional arguments:  
  -h, --help  show this help message and exit  
  -a  
  -b  

$ python argparse_mutually_exclusive.py -a  
Namespace(a=True, b=False)

$ python argparse_mutually_exclusive.py -b  
Namespace(a=False, b=True)

$ python argparse_mutually_exclusive.py -a -b  
usage: argparse_mutually_exclusive.py [-h] [-a | -b]  
argparse_mutually_exclusive.py: error: argument -b: not allowed with argument -a
</code></pre>
<p><strong>version2</strong></p>
<pre><code>import argparse

parser = argparse.ArgumentParser()

subparsers = parser.add_subparsers(help='commands')

# A list command
list_parser = subparsers.add_parser('list', help='List contents')
list_parser.add_argument('dirname', action='store', help='Directory to list')

# A create command
create_parser = subparsers.add_parser('create', help='Create a directory')
create_parser.add_argument('dirname', action='store', help='New directory to create')
create_parser.add_argument('--read-only', default=False, action='store_true',
                       help='Set permissions to prevent writing to the directory',
                       )

# A delete command
delete_parser = subparsers.add_parser('delete', help='Remove a directory')
delete_parser.add_argument('dirname', action='store', help='The directory to remove')
delete_parser.add_argument('--recursive', '-r', default=False, action='store_true',
                       help='Remove the contents of the directory, too',
                       )

print parser.parse_args(['list', 'a s d', ])
&gt;&gt;&gt; Namespace(dirname='a s d')
print parser.parse_args(['list', 'a s d', 'create' ])
&gt;&gt;&gt; error: unrecognized arguments: create
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you want a positional argument instead of mutually exclusive options.  You can use 'choices' to restrict the possible acceptable options.</p>
<pre><code>parser = ArgumentParser()
parser.add_argument('action', choices=('start', 'stop', 'restart'))
</code></pre>
<p>This produces a usage line that looks like this:</p>
<pre><code>usage: foo.py [-h] {start,stop,restart}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Building on Adam's answer... if you wanted to specify a default you could always do the following so they can effectively leave it blank.</p>
<pre><code>import argparse

ActionHelp = """
    Start = Starts the daemon (default)
    Stop = Stops the daemon
    Restart = Restarts the daemon
    """
parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument('action', nargs = '?', choices=('start', 'stop', 'restart'),
    default = 'start', help = ActionHelp)

print parser.parse_args(''.split())
print
print parser.parse_args('-h'.split())
</code></pre>
<p>which will print:</p>
<pre><code>Namespace(action='start')

usage: program.py [-h] [{start,stop,restart}]

postional arguments:
    {start,stop,restart}
                      Start = Starts the daemon (default)
                      Stop = Stops the daemon
                      Restart = Restarts the daemon

optional arguments:
    -h, --help        show this help message and exit
</code></pre>
</div>
<span class="comment-copy">But you don't show how to determine which of the start stop or restart options were selected. When I try to view the repr of the arguments, none of the sub-parsers arguments are shown.</span>
<span class="comment-copy">@RonaldoNascimento I think your question is answered here <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_subparsers" rel="nofollow noreferrer">docs.python.org/3/library/…</a> just scroll down a little and there is an example of how to solve this using <code>set_defaults</code></span>
<span class="comment-copy">@RonaldoNascimento late, but I think my edit answers your question. set_defaults() for my_stop() was always there, but was easily overlooked (even by me). It took Ronaldo’s comment to clue me in to your question. And I’m not sure what you’re doing with repr() that didn’t show what you expected.</span>
<span class="comment-copy">Yeah, I saw that, but choices limits expresivity of usage. I'm just looking for some way to get rid of prefixes.</span>
<span class="comment-copy">What do you mean "limits expresivity of usage"?  Can the user run the script without supplying one of these?</span>
<span class="comment-copy">When the user issue "mydaemon -h" the help (usage) is not so clear like using a help string for each argument.</span>
<span class="comment-copy">@AdamWagner What if user passes more than one argument? e.g. <code>foo.py start stop</code></span>
<span class="comment-copy">@SantoshKumar in your example, 'stop' is not the first positional argument, so if only one argument is defined in my example above, it'll cause an error saying it does not recognize 'stop' (in the example you give).  If you had defined a second positional argument, then 'start' would be the value for the first, and 'stop' would be the value for the second (whatever that happened to be).</span>
