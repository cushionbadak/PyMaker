<div class="post-text" itemprop="text">
<p>I want to use a .py file like a config file.
So using the <code>{...}</code> notation I can create a dictionary using strings as keys but the definition order is lost in a standard python dictionary.</p>
<p>My question: is it possible to override the <code>{...}</code> notation so that I get an <code>OrderedDict()</code> instead of a <code>dict()</code>?</p>
<p>I was hoping that simply overriding dict constructor with OrderedDict (<code>dict = OrderedDict</code>) would work, but it doesn't.</p>
<p>Eg:</p>
<pre><code>dict = OrderedDict
dictname = {
   'B key': 'value1',
   'A key': 'value2',
   'C key': 'value3'
   }

print dictname.items()
</code></pre>
<p>Output:</p>
<pre><code>[('B key', 'value1'), ('A key', 'value2'), ('C key', 'value3')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a hack that almost gives you the syntax you want:</p>
<pre><code>class _OrderedDictMaker(object):
    def __getitem__(self, keys):
        if not isinstance(keys, tuple):
            keys = (keys,)
        assert all(isinstance(key, slice) for key in keys)

        return OrderedDict([(k.start, k.stop) for k in keys])

ordereddict = _OrderedDictMaker()
</code></pre>
<pre><code>from nastyhacks import ordereddict

menu = ordereddict[
   "about" : "about",
   "login" : "login",
   'signup': "signup"
]
</code></pre>
<p><strong>Edit:</strong> Someone else discovered this independently, and has published the <a href="https://pypi.python.org/pypi/odictliteral/" rel="nofollow noreferrer"><code>odictliteral</code></a> package on PyPI that provides a slightly more thorough implementation - <strong>use this instead</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>To literally get what you are asking for, you have to fiddle with the syntax tree of your file.  I don't think it is advisable to do so, but I couldn't resist the temptation to try.  So here we go.</p>
<p>First, we create a module with a function <code>my_execfile()</code> that works like the built-in <code>execfile()</code>, except that all occurrences of dictionary displays, e.g. <code>{3: 4, "a": 2}</code> are replaced by explicit calls to the <code>dict()</code> constructor, e.g. <code>dict([(3, 4), ('a', 2)])</code>.  (Of course we could directly replace them by calls to <code>collections.OrderedDict()</code>, but we don't want to be too intrusive.)  Here's the code:</p>
<pre><code>import ast

class DictDisplayTransformer(ast.NodeTransformer):
    def visit_Dict(self, node):
        self.generic_visit(node)
        list_node = ast.List(
            [ast.copy_location(ast.Tuple(list(x), ast.Load()), x[0])
             for x in zip(node.keys, node.values)],
            ast.Load())
        name_node = ast.Name("dict", ast.Load())
        new_node = ast.Call(ast.copy_location(name_node, node),
                            [ast.copy_location(list_node, node)],
                            [], None, None)
        return ast.copy_location(new_node, node)

def my_execfile(filename, globals=None, locals=None):
    if globals is None:
        globals = {}
    if locals is None:
        locals = globals
    node = ast.parse(open(filename).read())
    transformed = DictDisplayTransformer().visit(node)
    exec compile(transformed, filename, "exec") in globals, locals
</code></pre>
<p>With this modification in place, we <em>can</em> modify the behaviour of dictionary displays by overwriting <code>dict</code>.  Here is an example:</p>
<pre><code># test.py
from collections import OrderedDict
print {3: 4, "a": 2}
dict = OrderedDict
print {3: 4, "a": 2}
</code></pre>
<p>Now we can run this file using <code>my_execfile("test.py")</code>, yielding the output</p>
<pre><code>{'a': 2, 3: 4}
OrderedDict([(3, 4), ('a', 2)])
</code></pre>
<p>Note that for simplicity, the above code doesn't touch dictionary comprehensions, which should be transformed to generator expressions passed to the <code>dict()</code> constructor.  You'd need to add a <code>visit_DictComp()</code> method to the <code>DictDisplayTransformer</code> class.  Given the above example code, this should be straight-forward.</p>
<p>Again, I don't recommend this kind of messing around with the language semantics.  Did you have a look into the <code>ConfigParser</code> module?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>OrderedDict</code> is not "standard python syntax", however, an ordered set of key-value pairs (in standard python syntax) is simply:</p>
<pre><code>[('key1 name', 'value1'), ('key2 name', 'value2'), ('key3 name', 'value3')]
</code></pre>
<p>To explicitly get an <code>OrderedDict</code>:</p>
<pre><code>OrderedDict([('key1 name', 'value1'), ('key2 name', 'value2'), ('key3 name', 'value3')])
</code></pre>
<p>Another alternative, is to sort <code>dictname.items()</code>, if that's all you need:</p>
<pre><code>sorted(dictname.items())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you are asking for is impossible, but if a config file in <a href="http://json.org/example.html" rel="nofollow noreferrer">JSON</a> syntax is sufficient you can do something similar with the <a href="http://docs.python.org/library/json.html#encoders-and-decoders" rel="nofollow noreferrer"><code>json</code> module</a>:</p>
<pre><code>&gt;&gt;&gt; import json, collections
&gt;&gt;&gt; d = json.JSONDecoder(object_pairs_hook = collections.OrderedDict)
&gt;&gt;&gt; d.decode('{"a":5,"b":6}')
OrderedDict([(u'a', 5), (u'b', 6)])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The one solution I found is to patch python itself, making the <code>dict</code> object remember the order of insertion.</p>
<p>This then works for all kind of syntaxes:</p>
<pre><code>x = {'a': 1, 'b':2, 'c':3 }
y = dict(a=1, b=2, c=3)
</code></pre>
<p>etc.</p>
<p>I have taken the <code>ordereddict</code> C implementation from <a href="https://pypi.python.org/pypi/ruamel.ordereddict/" rel="nofollow">https://pypi.python.org/pypi/ruamel.ordereddict/</a> and merged back into the main python code.</p>
<p>If you do not mind re-building the python interpreter, here is a patch for Python 2.7.8:
<a href="https://github.com/fwyzard/cpython/compare/2.7.8...ordereddict-2.7.8.diff" rel="nofollow">https://github.com/fwyzard/cpython/compare/2.7.8...ordereddict-2.7.8.diff</a>
.A</p>
</div>
<div class="post-text" itemprop="text">
<p>As of python 3.6, <a href="https://stackoverflow.com/questions/39980323/dictionaries-are-ordered-in-cpython-3-6">all dictionaries will be <em>ordered</em> by default</a>.  For now, this is an implementation detail of <code>dict</code> and should not be relied upon, but it will likely become standard after v3.6.</p>
<p>Insertion order is always preserved in the new <code>dict</code> implementation:</p>
<pre><code>&gt;&gt;&gt;x = {'a': 1, 'b':2, 'c':3 }
&gt;&gt;&gt;list(x.keys())
['a', 'b', 'c']
</code></pre>
<p>As of python 3.6 <code>**kwargs</code> order <a href="https://docs.python.org/3.6/whatsnew/3.6.html#whatsnew36-pep468" rel="nofollow noreferrer">[PEP468]</a> and class attribute order [<a href="https://docs.python.org/3.6/whatsnew/3.6.html#whatsnew36-pep520" rel="nofollow noreferrer">PEP520</a>] are preserved.  The new <a href="https://morepypy.blogspot.ca/2015/01/faster-more-memory-efficient-and-more.html" rel="nofollow noreferrer">compact, ordered dictionary implementation</a> is used to implement the ordering for both of these.</p>
</div>
<div class="post-text" itemprop="text">
<p>If what you are looking for is a way to get easy-to-use initialization syntax  - consider creating a subclass of OrderedDict and adding operators to it that update the dict, for example:</p>
<pre><code>from collections import OrderedDict

class OrderedMap(OrderedDict):
    def __add__(self,other):
        self.update(other)
        return self

d = OrderedMap()+{1:2}+{4:3}+{"key":"value"}
</code></pre>
<p>d will be- OrderedMap([(1, 2), (4, 3), ('key','value')])</p>
<hr/>
<p>Another possible syntactic-sugar example using the slicing syntax:</p>
<pre><code>class OrderedMap(OrderedDict):
    def __getitem__(self, index):
        if isinstance(index, slice):
            self[index.start] = index.stop 
            return self
        else:
            return OrderedDict.__getitem__(self, index)

d = OrderedMap()[1:2][6:4][4:7]["a":"H"]
</code></pre>
</div>
<span class="comment-copy">I assume that the Output mentioned here is what you would like - not what happens ?</span>
<span class="comment-copy">FYI to people stumbling on this 5 year old question in 2016: as of python 3.6 all <code>dict</code>s retain insertion order, so going forward none of these hacks will be needed.</span>
<span class="comment-copy">@NickSweeting <a href="https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation" rel="nofollow noreferrer">docs.python.org/3/whatsnew/3.6.html#new-dict-implementation</a> says "The order-preserving aspect of this new implementation is considered an implementation detail and should not be relied upon".</span>
<span class="comment-copy">@Samuel Santana the way I read the rest of the sentence that you quoted the start of suggests that this new ordering-preservation is the long term desired semantics for the language, without committing to it, right now.</span>
<span class="comment-copy">As of 3.7, those semantics <i>can</i> be relied upon</span>
<span class="comment-copy">This is genius. Evil genius.</span>
<span class="comment-copy">@Eric <a href="https://twitter.com/nedbat/status/765619098852220928" rel="nofollow noreferrer">twitter.com/nedbat/status/765619098852220928</a></span>
<span class="comment-copy">@Eric I came here from reddit <a href="https://www.reddit.com/r/Python/comments/4xyfh7/one_of_the_neatest_python_tricks_ive_ever_seen/?st=irxxcanz&amp;sh=a6b172af" rel="nofollow noreferrer">reddit.com/r/Python/comments/4xyfh7/â€¦</a></span>
<span class="comment-copy">To help decipher how this works, see <a href="http://stackoverflow.com/questions/2936863/python-implementing-slicing-in-getitem" title="python implementing slicing in getitem">stackoverflow.com/questions/2936863/â€¦</a></span>
<span class="comment-copy">@Eric it doesn't work if one key: menu = ordereddict["about" : "about"]; but it seems easy to fix it.</span>
<span class="comment-copy">Yes I will use ConfigParser...but your solution is illuminating. Thank you very much.</span>
<span class="comment-copy">@fdb - before you think of changing the language semantics - think about the principle 'Explicit is better than implicit' - if you try to override '{}' or hide to avoid having to type 'OrderedDict' - you will end up making your code far more difficult to read for others - of for yourself 6 months down the line. Just type 'OrderedDict' - it is understood, and does what you want - more typing, but improved readability.</span>
<span class="comment-copy">my question isn't if OrderedDict is "standard python syntax" but if is possible to override the {...} notation</span>
<span class="comment-copy">@fdb: In Python <code>{}</code> creates a <code>dict</code> object, which is unordered by definition.  You can of course define your own language with <code>{}</code> denoting an orderd dictionary.  You can even write a small wrapper that translates your new language to Python.  Is this what you actually want?</span>
<span class="comment-copy">@SvenMarnach: yes! but was hoping that simply overriding dict constructor with OrderedDict (dict = OrderedDict) would work.</span>
<span class="comment-copy">@fdb: That only works if you make your dictionary by calling <code>dict()</code></span>
<span class="comment-copy">before you think of changing the language semantics - think about the principle 'Explicit is better than implicit' - if you try to override '{}' or hide to avoid having to type 'OrderedDict' - you will end up making your code far more difficult to read for others - of for yourself 6 months down the line. Just type 'OrderedDict' - it is understood, and does what you want - more typing, but improved readability.</span>
<span class="comment-copy">"Impossible" might be a bit too strong a word -- see my answer.</span>
<span class="comment-copy">@Sven: Yes, I totally enjoyed your answer! :) I think I will let my wording stand, though. Please adjust your understanding of "impossible" in this context to match reality ;)</span>
<span class="comment-copy"><b>json.loads</b> and <b>json.load</b> have been also updated since Python 3.1 with support for object_pairs_hook <a href="https://docs.python.org/3.4/library/json.html#json.load" rel="nofollow noreferrer">docs.python.org/3.4/library/json.html#json.load</a></span>
<span class="comment-copy">As of 2016/12, the Pypy implementation will become the standard python <code>dict</code> implementation, nice job predicting this 2 years in advance!</span>
<span class="comment-copy">Why the downvotes? Comments would be appreciated...</span>
<span class="comment-copy">Maybe it has to do with what <a href="https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation" rel="nofollow noreferrer">docs.python.org/3/whatsnew/3.6.html#new-dict-implementation</a> says: "The order-preserving aspect of this new implementation is considered an implementation detail and should not be relied upon". Still, I found the information interesting, so here's an upvote!</span>
<span class="comment-copy">Update: Insert order being preserved is now standard in 3.7 and can be relied upon.</span>
<span class="comment-copy">Note: Both of these violate the expectations of their operators in extreme ways. Both <code>__add__</code> and <code>__getitem__</code> are intended to be non-mutating, and slicing support is expected to be an aggregate form of indexing support, not a completely unrelated behavior. Violating those expectations is <i>asking</i> for maintainability nightmare. The <code>slice</code> hack is much better used to achieve the result given in <a href="https://stackoverflow.com/a/37259917/364696">the accepted answer</a>, where it's a factory object that makes a normal <code>OrderedDict</code>, not an <code>OrderedDict</code> replacement with ongoing weird behaviors.</span>
