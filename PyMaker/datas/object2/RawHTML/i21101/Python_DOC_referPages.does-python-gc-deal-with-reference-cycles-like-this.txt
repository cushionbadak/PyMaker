<div class="post-text" itemprop="text">
<p>Using <a href="http://mg.pov.lt/objgraph/" rel="noreferrer">objgraph</a>, I found a bunch of objects like this:</p>
<p><img alt="InstanceState loop" src="https://i.stack.imgur.com/0Pokr.png"/></p>
<p>Will Python's garbage collector deal with cycles like this, or will it leak?</p>
<p>A slightly wider view of the loop:</p>
<p><img alt="Wider view of InstanceState loop" src="https://i.stack.imgur.com/GI1nu.png"/></p>
</div>
<div class="post-text" itemprop="text">
<p>Python's standard reference counting mechanism cannot free cycles, so the structure in your example would leak.</p>
<p>The <a href="http://docs.python.org/library/gc.html" rel="nofollow noreferrer">supplemental garbage collection facility</a>, however, is enabled by default and should be able to free that structure, if none of its components are reachable from the outside anymore <em>and they do not have <code>__del__()</code> methods</em>.</p>
<p>If they do, the garbage collector <a href="https://docs.python.org/3/library/gc.html#gc.garbage" rel="nofollow noreferrer">will <strong>not</strong> free them</a> because it cannot determine a safe order to run these <code>__del__()</code> methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>To extend on Frédéric's answer a bit, <a href="http://docs.python.org/extending/extending.html#reference-counts" rel="noreferrer">the "reference counts" section</a> of the docs explains the supplementary cycle detection nicely.</p>
<p>Since I find explaining things a good way to confirm I understand it, here are some examples... With these two classes:</p>
<pre><code>class WithDel(object):
    def __del__(self):
        print "deleting %s object at %s" % (self.__class__.__name__, id(self))


class NoDel(object):
    pass
</code></pre>
<p>Creating an object and losing the reference from <code>a</code> triggers the <code>__del__</code> method, thanks to the ref-counting:</p>
<pre><code>&gt;&gt;&gt; a = WithDel()
&gt;&gt;&gt; a = None  # leaving the WithDel object with no references 
deleting WithDel object at 4299615184
</code></pre>
<p>If we make a reference loop between two objects <strong>with no</strong> <code>__del__</code> method, all is still leak-free, this time thanks to the cycle detection. First, enable the garbage-collection debug output:</p>
<pre><code>&gt;&gt;&gt; import gc
&gt;&gt;&gt; gc.set_debug(gc.DEBUG_COLLECTABLE | gc.DEBUG_UNCOLLECTABLE | gc.DEBUG_OBJECTS)
</code></pre>
<p>Then make a reference loop between the two objects:</p>
<pre><code>&gt;&gt;&gt; a = NoDel(); b = NoDel()
&gt;&gt;&gt; a.other = b; b.other = a  # cyclical reference
&gt;&gt;&gt; a = None; b = None # Leave only the reference-cycle
&gt;&gt;&gt; gc.collect()
gc: collectable &lt;NoDel 0x10046ed50&gt;
gc: collectable &lt;NoDel 0x10046ed90&gt;
gc: collectable &lt;dict 0x100376c20&gt;
gc: collectable &lt;dict 0x100376b00&gt;
4
&gt;&gt;&gt; gc.garbage
[]
</code></pre>
<p>(the <code>dict</code> is from the objects internal <code>__dict__</code> attribute)</p>
<p>All is fine, <em>until</em> even one of the objects in the cycle contains a <code>__del__</code> method:</p>
<pre><code>&gt;&gt;&gt; a = NoDel(); b = WithDel()
&gt;&gt;&gt; a.other = b; b.other = a
&gt;&gt;&gt; a = None; b = None
&gt;&gt;&gt; gc.collect()
gc: uncollectable &lt;WithDel 0x10046edd0&gt;
gc: uncollectable &lt;dict 0x100376b00&gt;
gc: uncollectable &lt;NoDel 0x10046ed90&gt;
gc: uncollectable &lt;dict 0x100376c20&gt;
4
&gt;&gt;&gt; gc.garbage
[&lt;__main__.WithDel object at 0x10046edd0&gt;]
</code></pre>
<p>As Paul mentioned, the loop can be broken with a <a href="http://docs.python.org/library/weakref.html" rel="noreferrer"><code>weakref</code></a>:</p>
<pre><code>&gt;&gt;&gt; import weakref
&gt;&gt;&gt; a = NoDel(); b = WithDel()
&gt;&gt;&gt; a.other = weakref.ref(b)
&gt;&gt;&gt; b.other = a # could also be a weakref
</code></pre>
<p>Then when the <code>b</code> reference to the <code>WithDel</code> object is lost, it gets deleted, despite the cycle:</p>
<pre><code>&gt;&gt;&gt; b = None
deleting WithDel object at 4299656848
&gt;&gt;&gt; a.other
&lt;weakref at 0x10045b9f0; dead&gt;
</code></pre>
<p>Oh, <a href="http://mg.pov.lt/objgraph/" rel="noreferrer">objgraph</a> would have helpfully <a href="https://i.stack.imgur.com/2jjj7.png" rel="noreferrer">indicated the problematic <code>__del__</code> method like this</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Python's GC is designed to traverse all live objects to locate and eliminate reference cycles with no external references.</p>
<p>You can validate that is what is happening by running <code>gc.collect()</code> and then printing <code>gc.garbage</code> and <a href="http://docs.python.org/library/gc.html#gc.get_objects" rel="nofollow noreferrer">gc.get_objects</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you use weakrefs for your parent pointers, then GC will happen normally.</p>
</div>
<span class="comment-copy">Relevant: <a href="https://stackoverflow.com/q/15974561/1959808">stackoverflow.com/q/15974561/1959808</a></span>
<span class="comment-copy">It should be stated explicitly that the GC you call "supplemental" is enabled by default in Python</span>
<span class="comment-copy">@Eli, you're right, answer updated accordingly.</span>
<span class="comment-copy">Hurrah ! At least, peoples (you and Raymond Hettinger) who don't make confusion about GC and refs counter and who don't use "garbage collector" as synonym of "reference counting mechanism" ! I had been perplexed for a long time about the fact that I had understood things like that but I was constantly reading texts in which peoples expressed their ideas as if the GC was the responsible of the the killing of no-more-referenced objects. In your answer, the difference is perfectly expressed and clear. Thank you. Hence +1</span>
<span class="comment-copy">This works for me in python2, however, in python3 I'm unable to reproduce the leak... Has something changed?</span>
<span class="comment-copy">@kralyk I guess this pep is responsible: <a href="https://www.python.org/dev/peps/pep-0442/" rel="nofollow noreferrer">python.org/dev/peps/pep-0442</a></span>
