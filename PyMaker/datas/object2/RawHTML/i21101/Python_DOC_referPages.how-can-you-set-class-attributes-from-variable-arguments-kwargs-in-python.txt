<div class="post-text" itemprop="text">
<p>Suppose I have a class with a constructor (or other function) that takes a variable number of arguments and then sets them as class attributes conditionally.</p>
<p>I could set them manually, but it seems that variable parameters are common enough in python that there should be a common idiom for doing this.  But I'm not sure how to do this dynamically.</p>
<p>I have an example using eval, but that's hardly safe.  I want to know the proper way to do this -- maybe with lambda?</p>
<pre><code>class Foo:
    def setAllManually(self, a=None, b=None, c=None):
        if a!=None: 
            self.a = a
        if b!=None:
            self.b = b
        if c!=None:
            self.c = c
    def setAllWithEval(self, **kwargs):
        for key in **kwargs:
            if kwargs[param] != None
                eval("self." + key + "=" + kwargs[param])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could update the <code>__dict__</code> attribute (which represents the class attributes in the form of a dictionary) with the keyword arguments:</p>
<pre><code>class Bar(object):
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)
</code></pre>
<p>then you can:</p>
<pre><code>&gt;&gt;&gt; bar = Bar(a=1, b=2)
&gt;&gt;&gt; bar.a
1
</code></pre>
<p>and with something like:</p>
<pre><code>allowed_keys = ['a', 'b', 'c']
self.__dict__.update((k, v) for k, v in kwargs.items() if k in allowed_keys)
</code></pre>
<p>you could filter the keys beforehand (use <code>iteritems</code> instead of <code>items</code> if you’re still using Python 2.x).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/functions.html#setattr" rel="noreferrer"><code>setattr()</code></a> method:</p>
<pre><code>class Foo:
  def setAllWithKwArgs(self, **kwargs):
    for key, value in kwargs.items():
      setattr(self, key, value)
</code></pre>
<p>There is an analogous <a href="https://docs.python.org/3/library/functions.html#getattr" rel="noreferrer"><code>getattr()</code></a> method for retrieving attributes.</p>
</div>
<div class="post-text" itemprop="text">
<p>Most answers here do not cover a good way to initialize all allowed attributes to just one default value.
So, to add to the answers given by <a href="https://stackoverflow.com/a/8187408/3357935">@fqxp</a> and <a href="https://stackoverflow.com/a/32019483/3357935">@mmj</a>:</p>
<pre><code>class Myclass:

    def __init__(self, **kwargs):
        # all those keys will be initialized as class attributes
        allowed_keys = set(['attr1','attr2','attr3'])
        # initialize all allowed keys to false
        self.__dict__.update((key, False) for key in allowed_keys)
        # and update the given keys by their given values
        self.__dict__.update((key, value) for key, value in kwargs.items() if key in allowed_keys)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I propose a variation of <a href="https://stackoverflow.com/a/8187408/3357935">fqxp's answer</a>, which, in addition to <strong><em>allowed attributes</em></strong>, lets you set <strong><em>default values</em></strong> for attributes:</p>
<pre><code>class Foo():
    def __init__(self, **kwargs):
        # define default attributes
        default_attr = dict(a=0, b=None, c=True)
        # define (additional) allowed attributes with no default value
        more_allowed_attr = ['d','e','f']
        allowed_attr = list(default_attr.keys()) + more_allowed_attr
        default_attr.update(kwargs)
        self.__dict__.update((k,v) for k,v in default_attr.items() if k in allowed_attr)
</code></pre>
<p>This is Python 3.x code, for Python 2.x you need at least one adjustment, <code>iteritems()</code> in place of <code>items()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class SymbolDict(object):
  def __init__(self, **kwargs):
    for key in kwargs:
      setattr(self, key, kwargs[key])

x = SymbolDict(foo=1, bar='3')
assert x.foo == 1
</code></pre>
<p>I called the class <code>SymbolDict</code> because it essentially is a dictionary that operates using symbols instead of strings.  In other words, you do <code>x.foo</code> instead of <code>x['foo']</code> but under the covers it's really the same thing going on.</p>
</div>
<div class="post-text" itemprop="text">
<p>The following solutions <code>vars(self).update(kwargs)</code> or <code>self.__dict__.update(**kwargs)</code> are not robust, because the user can enter any dictionary with no error messages. If I need to check that the user insert the following signature ('a1', 'a2', 'a3', 'a4', 'a5') the solution does not work. Moreover, the user should be able to use the object by passing the "positional parameters" or the "kay-value pairs parameters".</p>
<p>So I suggest the following solution by using a metaclass.</p>
<pre><code>from inspect import Parameter, Signature

class StructMeta(type):
    def __new__(cls, name, bases, dict):
        clsobj = super().__new__(cls, name, bases, dict)
        sig = cls.make_signature(clsobj._fields)
        setattr(clsobj, '__signature__', sig)
        return clsobj

def make_signature(names):
    return Signature(
        Parameter(v, Parameter.POSITIONAL_OR_KEYWORD) for v in names
    )

class Structure(metaclass = StructMeta):
    _fields = []
    def __init__(self, *args, **kwargs):
        bond = self.__signature__.bind(*args, **kwargs)
        for name, val in bond.arguments.items():
            setattr(self, name, val)

if __name__ == 'main':

   class A(Structure):
      _fields = ['a1', 'a2']

   if __name__ == '__main__':
      a = A(a1 = 1, a2 = 2)
      print(vars(a))

      a = A(**{a1: 1, a2: 2})
      print(vars(a))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this one is the easiest via <a href="https://stackoverflow.com/users/147356/larsks">larsks</a></p>
<pre><code>class Foo:
    def setAllWithKwArgs(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)
</code></pre>
<p>my example:</p>
<pre><code>class Foo:
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)

door = Foo(size='180x70', color='red chestnut', material='oak')
print(door.size) #180x70
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Their might be a better solution but what comes to mind for me is:</p>
<pre><code>class Test:
    def __init__(self, *args, **kwargs):
        self.args=dict(**kwargs)

    def getkwargs(self):
        print(self.args)

t=Test(a=1, b=2, c="cats")
t.getkwargs()


python Test.py 
{'a': 1, 'c': 'cats', 'b': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yet another variant based on the excellent answers by <a href="https://stackoverflow.com/a/32019483/7382307">mmj</a> and <a href="https://stackoverflow.com/a/8187408/7382307">fqxp</a>. What if we want to</p>
<ol>
<li>Avoid hardcoding a list of allowed attributes</li>
<li><em>Directly</em> and explicitly set default values for each attributes in the constructor</li>
<li>Restrict kwargs to predefined attributes by either

<ul>
<li>silently rejecting invalid arguments <em>or</em>, alternatively, </li>
<li>raising an error.</li>
</ul></li>
</ol>
<p>By "directly", I mean avoiding an extraneous <code>default_attributes</code> dictionary.</p>
<pre><code>class Bar(object):
    def __init__(self, **kwargs):

        # Predefine attributes with default values
        self.a = 0
        self.b = 0
        self.A = True
        self.B = True

        # get a list of all predefined values directly from __dict__
        allowed_keys = list(self.__dict__.keys())

        # Update __dict__ but only for keys that have been predefined 
        # (silently ignore others)
        self.__dict__.update((key, value) for key, value in kwargs.items() 
                             if key in allowed_keys)

        # To NOT silently ignore rejected keys
        rejected_keys = set(kwargs.keys()) - set(allowed_keys)
        if rejected_keys:
            raise ValueError("Invalid arguments in constructor:{}".format(rejected_keys))
</code></pre>
<p>Not a major breakthrough, but maybe useful to someone...</p>
<p><strong>EDIT:</strong>
If our class uses <code>@property</code> decorators to encapsulate "protected" attributes with getters and setters, and if we want to be able to set these properties with our constructor, we may want to expand the <code>allowed_keys</code> list with values from <code>dir(self)</code>, as follows:</p>
<pre><code>allowed_keys = [i for i in dir(self) if "__" not in i and any([j.endswith(i) for j in self.__dict__.keys()])]
</code></pre>
<p>The above code excludes</p>
<ul>
<li>any hidden variable from <code>dir()</code> (exclusion based on presence of "__"), and</li>
<li>any method from <code>dir()</code> whose name is not found in the end of an attribute name (protected or otherwise) from <code>__dict__.keys()</code>, thereby likely keeping only @property decorated methods. </li>
</ul>
<p>This edit is likely only valid for Python 3 and above.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suspect it might be better in most instances to use named args (for better self documenting code) so it might look something like this:</p>
<pre><code>class Foo:
    def setAll(a=None, b=None, c=None):
        for key, value in (a, b, c):
            if (value != None):
                settattr(self, key, value)
</code></pre>
</div>
<span class="comment-copy">It looks like these questions are similar: <a href="http://stackoverflow.com/questions/3884612/automatically-setting-class-member-variables-in-python" title="automatically setting class member variables in python">stackoverflow.com/questions/3884612/…</a> <a href="http://stackoverflow.com/questions/356718/how-to-handle-constructors-or-methods-with-a-different-set-or-type-of-argument" title="how to handle constructors or methods with a different set or type of argument">stackoverflow.com/questions/356718/…</a> <a href="http://stackoverflow.com/questions/1446555/python-decorator-to-ensure-that-kwargs-are-correct" title="python decorator to ensure that kwargs are correct">stackoverflow.com/questions/1446555/…</a> so it looks like what I want is maybe this-- self.__dict__[key] = kwargs[key]</span>
<span class="comment-copy">Not really relevant to your question, but you might want to check <a href="http://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP8</a> for a few hints on conventional Python styling.</span>
<span class="comment-copy">There is a fantastic library for this called attrs.  simply <code>pip install attrs</code>, decorate your class with <code>@attr.s</code>, and set the args as <code>a = attr.ib(); b = attr.ib()</code> etc.  Read more <a href="https://glyph.twistedmatrix.com/2016/08/attrs.html" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">Am I missing something here? You still need to do self.x =kwargs.get'x']  You open yourself up to typos from caller You have to create client with extra chars instance=Class(**{}) If you don't jump thru hoops with the self.x =kwargs.get'x'] mundaneness, isn't it going to bite you later anyway? i.e. Instead of self.x, you 'll end up with self.__dict__['x'] down the line right? Or getattr() Either more typing than self.</span>
<span class="comment-copy">Even better to make the allowed_keys a set :)</span>
<span class="comment-copy">Even better if you use <code>self.__dict__.update(locals())</code> to copy also positional arguments.</span>
<span class="comment-copy">I think you'll need this nowadays..  kwargs[0].items() instead of kwargs.iteritems() - (I'm using Python 3.6.5 at time of writing)</span>
<span class="comment-copy">@JGFMK: thanks, I updated the answer accordingly.</span>
<span class="comment-copy">@larsks thanks but any idea how we could unpack only a dictionary key? <a href="http://stackoverflow.com/questions/41792761/calling-and-using-an-attribute-stored-in-variable-using-beautifulsoup-4" title="calling and using an attribute stored in variable using beautifulsoup 4">stackoverflow.com/questions/41792761/…</a></span>
<span class="comment-copy">Do you need to use <code>.getattr()</code>? Or can you access the attributes with <code>Foo.key</code>?</span>
<span class="comment-copy">@StevenVascellaro you can of course just use <code>Foo.attrname</code>.  I think I was just pointing out the fact that the <code>getattr</code> method exists.  It's also useful if you want to provide a default value for when the named attribute isn't available.</span>
<span class="comment-copy">I think this is the most complete answer due to the inizialization to <code>False</code>. Good point!</span>
<span class="comment-copy">could smb explain what is kwargs.items()?</span>
<span class="comment-copy"><code>kwargs</code> is a dictionary of keyword arguments, and <code>items()</code> is a method that returns a copy of the dictionary's list of <code>(key, value)</code> pairs.</span>
<span class="comment-copy">What I'm looking for is to conditionally set attributes based on validation.  I realized that the problem with using kwargs is that it doesn't validate (or document) which attributes are acceptable</span>
<span class="comment-copy">Yeah I realize @larsks answer is better. Learn something new everyday at SO!</span>
<span class="comment-copy">This iteration does not work: <code>for key, value in (a, b, c)</code></span>
