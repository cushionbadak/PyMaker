<div class="post-text" itemprop="text">
<p>I have a table (curves.csv) organized like this (not organized would be a better description)</p>
<pre><code>CL,D,PD,CL,D,PD,CL,D,PD,CL,D,PD,CL,D,PD
A,1,a,B,1,b,C,1,c,D,1,d,E,1,e
A,2,f,B,3,g,C,2,h,D,4,i,E,2,j
A,5,k,B,6,l,C,5,m,D,8,n,E,5,o
</code></pre>
<p>I would like to convert this table to</p>
<pre><code>,A,B,C,D,E
1,a,b,c,d,e
2,f,,h,,j
3,,g,,,
4,,,,i,
5,k,,m,,o
6,,l,,,
8,,,,n,
</code></pre>
<p>I currently have this:</p>
<pre><code>celllines=["A","B","C","D","E"]
sorted_days=["1","2","3","4","5","8"]
for d in sorted_days:
    curves=open("curves.csv","rU")
    for line in curves:
        line=line.rstrip().rsplit(",")
        if line[0]!="CL":#removes header
            for x in range(0,len(line),3):
                if line[x] in celllines:
                    if line[x+1] == d:
                        print d,line[x],line[x+2]
                    else:
                        print d, line[x],""



    curves.close()
</code></pre>
<p>I just feel like I am getting further form the answer, not closer!
Any pointers would be,as always, much appreciated</p>
</div>
<div class="post-text" itemprop="text">
<p>How about something like this, using the <code>csv</code> module:</p>
<pre><code>import csv

# make a dictionary to store the data
data = {}

# first, read it in
with open("curves.csv", "rb") as fp:

    # make a csv reader object
    reader = csv.reader(fp)

    # skip initial line
    next(reader)

    for row in reader:
        # for each triplet, store it in the dictionary
        for i in range(len(row)//3):
            CL, D, PD = row[3*i:3*i+3]
            data[D, CL] = PD

# see what we've got
print data

with open("newcurves.csv", "wb") as fp:
    # get the labels in order
    row_labels = sorted(set(k[0] for k in data), key=int)
    col_labels = sorted(set(k[1] for k in data))

    writer = csv.writer(fp)
    # write header
    writer.writerow([''] + col_labels)

    # write data rows
    for row_label in row_labels:
        # start with the label
        row = [row_label]

        # then extend a list of the data in order, using the empty string '' if
        # there's no such value
        row.extend([data.get((row_label, col_label), '') for col_label in col_labels])

        # dump it out
        writer.writerow(row)
</code></pre>
<p>which gives us a dictionary looking like</p>
<pre><code>{('1', 'D'): 'd', ('1', 'E'): 'e', ('5', 'C'): 'm', ('1', 'B'): 'b', ('2', 'E'): 'j', ('1', 'C'): 'c', ('5', 'A'): 'k', ('6', 'B'): 'l', ('2', 'C'): 'h', ('1', 'A'): 'a', ('4', 'D'): 'i', ('8', 'D'): 'n', ('2', 'A'): 'f', ('3', 'B'): 'g', ('5', 'E'): 'o'}
</code></pre>
<p>and an output file like</p>
<pre><code>~/coding$ cat newcurves.csv 
,A,B,C,D,E
1,a,b,c,d,e
2,f,,h,,j
3,,g,,,
4,,,,i,
5,k,,m,,o
6,,l,,,
8,,,,n,
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best way to approach a problem like this, I find, is to separate the breaking down of the old format, and the building up of the new. Instead, break down the old format into a sane data structure that makes it easy to play with the data in Python, then build the new format using that nice, malleable structure.</p>
<p>Wherever we are working with comma separated values, we can simplify it all by using <a href="http://docs.python.org/3.3/library/csv.html" rel="nofollow">the <code>csv</code> module</a>, which is in the standard library, and greatly simplifies this kind of job.</p>
<p>This solution also makes pretty heavy use of <a href="http://www.youtube.com/watch?v=pShL9DCSIUw" rel="nofollow">the list comprehension (and it's various cousins)</a>, so if you are not familiar with them, I recommend reading up a little (linked previously is my short video explaining them).</p>
<pre><code>import csv
import itertools

def grouper(n, iterable, fillvalue=None):
    args = [iter(iterable)] * n
    return itertools.zip_longest(fillvalue=fillvalue, *args)

with open("curves.csv") as file:
    data = csv.reader(file)
    next(data) #Ignore header row.
    parsed = {(column, row): value for line in data
              for column, row, value in grouper(3, line)}

rows = sorted({row for (_, row) in parsed})
columns = sorted({column for (column, _) in parsed})

with open("output.csv", "w") as file:
    writer = csv.writer(file)
    writer.writerow([None] + columns)
    writer.writerows([[row]+[parsed.get((column, row))
                             for column in columns]
                      for row in rows])
</code></pre>
<p>We begin by opening the file using the <code>with</code> statement (a best practice that ensures the file is closed), then we skip the line of headers, and parse the data. To do this, we take each line in the data, then group the line into chunks of length 3 (using the <code>grouper()</code> function, which is <a href="http://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">an <code>itertools</code> recipie</a>). This gives us our column, row and value, which we then use as the key and value of a dictionary.</p>
<p>This gives us a dictionary of <code>{("A", 1): "a", ...}</code>. That's a good format to work from, so now we construct the file back up into the wanted format.</p>
<p>First we need to know what rows and columns we need, we do this by taking only the rows from the parsed data, and making a set (as sets can't contain duplicates), and finally sorting them back into a list so we have the right order.</p>
<p>We then open our output file, and write the columns to it (remembering to add a <code>None</code> for the row headers column), and then write out our data. For each row, we write the row number, then get the value for each column from our parsed data, using <a href="http://docs.python.org/2/library/stdtypes.html#dict.get" rel="nofollow"><code>dict.get()</code></a> so we get <code>None</code> if there isn't a value. This gives the output that was wanted.</p>
<p>As a note: it appears you are using Python 2.x in the question, my answer was written in 3.x. The only difference should be that <code>itertools.zip_longest()</code> is <code>itertools.izip_longest()</code> in 3.x.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just to show (a bit late) that it can also be done in R:</p>
<pre><code>curves &lt;- read.csv("curves.csv", as.is = TRUE)
stack  &lt;- data.frame(CL = unlist(curves[, c(TRUE, FALSE, FALSE)]),
                     D  = unlist(curves[, c(FALSE, TRUE, FALSE)]),
                     PD = unlist(curves[, c(FALSE, FALSE, TRUE)]),
                     stringsAsFactors = FALSE)
library(reshape2)
output &lt;- acast(stack, D ~ CL, value.var = "PD", fill = "")
write.csv(output, "new_curves.csv", quote = FALSE)
</code></pre>
<hr/>
<p>If you don't like to use a third party package, then you can do it all with base:</p>
<pre><code>curves   &lt;- read.csv("curves.csv", as.is = TRUE)
rownames &lt;- sort(unique(unlist(curves[, c(FALSE, TRUE, FALSE)])))
colnames &lt;- sort(unique(unlist(curves[, c(TRUE, FALSE, FALSE)])))
output   &lt;- matrix("", nrow = length(rownames), ncol = length(colnames),
                       dimnames = list(rownames, colnames))
fill.i   &lt;- match(unlist(curves[, c(FALSE, TRUE, FALSE)]), rownames)
fill.j   &lt;- match(unlist(curves[, c(TRUE, FALSE, FALSE)]), colnames)
fill.x   &lt;- unlist(curves[, c(FALSE, FALSE, TRUE)])
output[cbind(fill.i, fill.j)] &lt;- fill.x
write.csv(output, "new_curves.csv", quote = FALSE)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without using the <code>csv</code> module:</p>
<pre><code>celllines=["","A","B","C","D","E"]
days=["1","2","3","4","5","6","7","8"]

curves = sum([line.split(',') for line in open("curves.csv","rU").read().split()[1:]], [])

group = {(d,cl): pd for (cl,d,pd) in [curves[i:i+3] for i in range(0,len(curves),3)]}
table = [[d if not x else '' for x in celllines] for d in days]

for (d,cl),pd in group.items():
    table[days.index(d)][celllines.index(cl)] = pd

with open("curves2.csv", "w") as f:
    f.write('\n'.join(','.join(line) for line in [celllines]+table))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>R solution with <code>tapply</code>-ing the concatenation function, c.</p>
<pre><code>cvrs &lt;- read.table(text="CL,D,PD,CL,D,PD,CL,D,PD,CL,D,PD,CL,D,PD
 A,1,a,B,1,b,C,1,c,D,1,d,E,1,e
 A,2,f,B,3,g,C,2,h,D,4,i,E,2,j
 A,5,k,B,6,l,C,5,m,D,8,n,E,5,o", header=TRUE, sep=",", check.names=FALSE)

long &lt;- rbind(crvs[, 1:3], crvs[, 4:6], crvs[, 7:9], crvs[, 10:12])
out &lt;- with( long, tapply(PD, list(D, CL), FUN=c) )
#-----------------
 write.table(out, quote=FALSE, sep=",", na="")
A,B,C,D
1,a,b,c,d
2,f,,h,
3,,g,,
4,,,,i
5,k,,m,
6,,l,,
8,,,,n
</code></pre>
</div>
<span class="comment-copy">I'm looking at this and I honestly cannot tell how you are getting from the first table to the second table. Can you explain that a little better?</span>
<span class="comment-copy">Groups of three columns need to be stacked and then cross-tabulated by "CL" and "D".</span>
<span class="comment-copy">Why would you not want to use the module designed to do the exact thing you are trying to do?</span>
