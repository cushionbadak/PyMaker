<div class="post-text" itemprop="text">
<p>I accidentally found that in python, an operation of the form</p>
<pre><code>string1.join(string2)
</code></pre>
<p>Can be equivalently expressed as</p>
<pre><code>string2.replace('', string1)[len(string1):-len(string1)]
</code></pre>
<p>Furthermore, after trying <code>timeit</code> with a few different sized inputs, this weird way to join seems to be more than twice as fast.  </p>
<ol>
<li>Why should the join method be slower?  </li>
<li>Is replacing the empty string like this a safe/well-defined thing to do?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>So first of all, let's break down why this works.</p>
<pre><code>&gt;&gt;&gt; string1 = "foo"
&gt;&gt;&gt; string2 = "bar"
&gt;&gt;&gt; string1.join(string2)
'bfooafoor'
</code></pre>
<p>This is the operation of putting <code>string1</code> between every item (character) of <code>string2</code>.</p>
<p>So replacing the empty string does something kind of interesting, it counts the gap between empty characters as the empty string and therefore does essentially the same task, except with an extra separator at the start and end:</p>
<pre><code>&gt;&gt;&gt; string2.replace('', string1)
'foobfooafoorfoo'
</code></pre>
<p>So slicing out these produces the same result as <code>str.join()</code>:</p>
<pre><code>&gt;&gt;&gt; string2.replace('', string1)[len(string1):-len(string1)]
'bfooafoor'
</code></pre>
<p>Obviously, this solution is much, much less readable than <code>str.join()</code>, and so I'd always recommend against it. <code>str.join()</code> has also been developed to be efficient on all platforms. Replacing the empty string might be far less efficient on some versions of Python (I don't know if that's the case, but it's a possibility - just as repeated concatenation is reasonably fast in CPython, but that's not necessarily the case elsewhere.)</p>
<p>I can't even find anything in the documentation that suggests that this behaviour of replacing the empty string should function this way, <a href="http://docs.python.org/3/library/stdtypes.html#str.replace" rel="nofollow">the docs for <code>str.replace()</code></a> simply say:</p>
<blockquote>
<p>Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced.</p>
</blockquote>
<p>I see no reason why we should presume that the gaps in between letters should count as an occurrence of the empty string (arguably, you could fit infinite empty strings anywhere in the string), and as such, relying on this behaviour might be a bad idea.</p>
<p>This operation is also pretty rare - it's more common to have a sequence of strings to join together - joining individual characters of a string isn't something I have personally had to do often.</p>
<p>Interestingly, this <code>x.replace("", y)</code> appears to be special cased in <a href="http://hg.python.org/cpython/file/96721e364870/Objects/stringobject.c#l2347" rel="nofollow">the Python source</a>:</p>
<pre><code>2347 /* Algorithms for different cases of string replacement */
2348
2349 /* len(self)&gt;=1, from="", len(to)&gt;=1, maxcount&gt;=1 */
2350 Py_LOCAL(PyStringObject *)
2351 replace_interleave(PyStringObject *self,
2352 const char *to_s, Py_ssize_t to_len,
2353 Py_ssize_t maxcount)
2354 {
...
</code></pre>
<p>It may well be this special casing causes it to perform well. Again, as it's not mentioned in the documentation, this is an <em>implementation detail</em>, and assuming it will work as quickly (or at all) in other Python versions would be a mistake.</p>
</div>
<div class="post-text" itemprop="text">
<p>As Lattyware mentioned, for empty string replacement, its a special case, <code>replace_interleave</code>, its a straight forward loop where, alternate character from source and from string are copied to the resultant string. The Loop is coded to be <strong>as fast as possible</strong>.</p>
<pre><code>count = self_len+1;

count -= 1;
Py_MEMCPY(result_s, to_s, to_len);
result_s += to_len;
for (i=0; i&lt;count; i++) {
    *result_s++ = *self_s++;
    Py_MEMCPY(result_s, to_s, to_len);
    result_s += to_len;
}

/* Copy the rest of the original string */
Py_MEMCPY(result_s, self_s, self_len-i);
</code></pre>
<p>The Join method has also a Loop, but there are areas of improvements (through I have not found all aspects for the reason to have been coded the following way) and reasons for the bottleneck.</p>
<pre><code>char *sep = PyString_AS_STRING(self);
seq = PySequence_Fast(orig, "");
/* Catenate everything. */
p = PyString_AS_STRING(res);
for (i = 0; i &lt; seqlen; ++i) {
    size_t n;
    item = PySequence_Fast_GET_ITEM(seq, i);
    n = PyString_GET_SIZE(item);
    Py_MEMCPY(p, PyString_AS_STRING(item), n);
    p += n;
    if (i &lt; seqlen - 1) {
        Py_MEMCPY(p, sep, seplen);
        p += seplen;
    }
}
</code></pre>
<p>As You may see here,  Inside a Loop</p>
<ul>
<li>Each Item of the String is Indexed</li>
<li>Size of the Item is determined</li>
<li>Indexed Item is Converted to String</li>
</ul>
<p>The above three operations, even though it may be in-lined have considerable overhead. <strong><em>Note</em></strong> This Also explains, why using a List have different result compared to using a STring, as observed by Blended</p></div>
<span class="comment-copy">Passing a string into <code>join</code> seems to be the bottleneck. Converting <code>string2</code> into a <code>list</code> drops the time from <code>697</code> to <code>148</code> ns.</span>
<span class="comment-copy">The fact that you are skipping a very common use of <code>x.join(y)</code> doesn't count ? For instance, what about <code>' '.join(['1', '2', '3'])</code> ?</span>
<span class="comment-copy">There are a few issues with this, first and foremost - readability. This is horrific for people to read. Secondly, performance for your method might vary wildly depending on Python implementation used (CPython isn't the only thing out there), and as mmgp points out, using <code>join()</code> with a string as the first argument is actually a very rare operation.</span>
<span class="comment-copy">And for large inputs the weird method is indeed slow.<a href="http://www.diigo.com/item/image/3bswf/yjp5?size=o" rel="nofollow noreferrer">diigo.com/item/image/3bswf/yjp5?size=o</a></span>
<span class="comment-copy">This is a great insight, but just to be clear, this is a pure analysis of CPython, not Python in general, so it would not be a good idea to rely heavily on this.</span>
<span class="comment-copy">@Lattyware: Its quite a task to verify all the implementations but I think my **Final Note ** can be a generalist conclusion</span>
<span class="comment-copy">It is a conclusion on the issue of performance, but there are other issues at play here too. It's useful information, but I would advise against looking at it in exclusivity.</span>
<span class="comment-copy">@Lattyware: Off course, and am not denying on that fact, which your answer have rightly addressed. This answer complements yours and its not a supplement.</span>
