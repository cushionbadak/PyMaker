<div class="post-text" itemprop="text">
<p>I'm sorting a text file from Python using a custom unix command that takes a filename as input (or reads from stdin) and writes to stdout. I'd like to sort <code>myfile</code> and keep the sorted version in its place. Is the best way to do this from Python to make a temporary file? My current solution is:</p>
<pre><code>inputfile = "myfile"
# inputfile: filename to be sorted
tmpfile = "%s.tmp_file" %(inputfile)
cmd = "mysort %s &gt; %s" %(inputfile, tmpfile)
# rename sorted file to be originally sorted filename
os.rename(tmpfile, inputfile)
</code></pre>
<p>Is this the best solution? thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to create temporary files, you can use <code>subprocess</code> as in:</p>
<pre><code>import sys
import subprocess

fname = sys.argv[1]
proc = subprocess.Popen(['sort', fname], stdout=subprocess.PIPE)
stdout, _ = proc.communicate()
with open(fname, 'w') as f:
    f.write(stdout)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You either create a temporary file, or you'll have to read the whole file into memory and pipe it to your command.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best solution is to use <a href="http://docs.python.org/3/library/os.html#os.replace" rel="nofollow">os.replace</a> because it would work on Windows too.</p>
<p>This is not really what I regards as "in-place sorting" though. Usually, in-place sorting means that you actually exchange single elements in the lists without doing copies. You are making a copy since the sorted list has to get completely built before you can overwrite the original. If your files get very large, this obviously won't work anymore. You'd probably need to choose between atomicity and in-place-ity at that point.</p>
<p>If your Python is too old to have os.replace, there are lots of resources in <a href="http://bugs.python.org/issue8828" rel="nofollow">the bug adding os.replace</a>.</p>
<p>For other uses of temporary files, you can consider using <a href="http://docs.python.org/3/library/tempfile.html" rel="nofollow">the tempfile module</a>, but I don't think it would gain you much in this case.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try a truncate-write pattern:</p>
<pre><code>with open(filename, 'r') as f:
   model.read(f)
model.process()
with open(filename, 'w') as f:
   model.write(f)
</code></pre>
<p>Note this is non-atomic</p>
<p>This entry describes some pros/cons of updating files in Python:
<a href="http://blog.gocept.com/2013/07/15/reliable-file-updates-with-python/" rel="nofollow">http://blog.gocept.com/2013/07/15/reliable-file-updates-with-python/</a></p>
</div>
<span class="comment-copy">it's a good solution because <a href="http://en.wikipedia.org/wiki/Rename_%28computing%29" rel="nofollow noreferrer">rename is atomic</a>.</span>
<span class="comment-copy">Your <code>mysort</code> custom command is not reading from stdin with that command line; it is taking the filename from it's arguments instead.</span>
<span class="comment-copy">You can use the <code>subprocess</code> module to redirect the output from your command, so you use this output to override the contents of your initial file. No need to create temporary files then.</span>
<span class="comment-copy">is <code>rename</code> portable?</span>
<span class="comment-copy">@mmgp: but can you really redirect the output to the file as you're reading it?</span>
<span class="comment-copy">Well, the in-place sorting should be done by his command. Since it doesn't, I took that part of the question as meaningless.</span>
