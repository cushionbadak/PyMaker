<div class="post-text" itemprop="text">
<p>I create a FIFO, and periodically open it in read-only and non-blockingly mode from a.py:</p>
<pre><code>os.mkfifo(cs_cmd_fifo_file, 0777)
io = os.open(fifo, os.O_RDONLY | os.O_NONBLOCK)
buffer = os.read(io, BUFFER_SIZE)
</code></pre>
<p>From b.py, open the fifo for writing:</p>
<pre><code>out = open(fifo, 'w')
out.write('sth')
</code></pre>
<p>Then a.py will raise an error:</p>
<pre><code>buffer = os.read(io, BUFFER_SIZE)

OSError: [Errno 11] Resource temporarily unavailable
</code></pre>
<p>Anyone know what's wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the manpage of <code>read(2)</code>:</p>
<blockquote>
<pre><code>   EAGAIN or EWOULDBLOCK
          The  file  descriptor  fd refers to a socket and has been marked
          nonblocking   (O_NONBLOCK),   and   the   read   would    block.
          POSIX.1-2001  allows  either error to be returned for this case,
          and does not require these constants to have the same value,  so
          a portable application should check for both possibilities.
</code></pre>
</blockquote>
<p>So what you're getting is that there is no data available for reading. It is safe to handle the error like this:</p>
<pre><code>try:
    buffer = os.read(io, BUFFER_SIZE)
except OSError as err:
    if err.errno == errno.EAGAIN or err.errno == errno.EWOULDBLOCK:
        buffer = None
    else:
        raise  # something else has happened -- better reraise

if buffer is None: 
    # nothing was received -- do something else
else:
    # buffer contains some received data -- do something with it
</code></pre>
<p>Make sure you have the errno module imported: <code>import errno</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>out = open(fifo, 'w')
</code></pre>
<p>Who will close it for you?
Replace your open+write by this:</p>
<pre><code>with open(fifo, 'w') as fp:
    fp.write('sth')
</code></pre>
<p><strong>UPD:</strong>
Ok, than just make this:</p>
<pre><code>out = os.open(fifo, os.O_NONBLOCK | os.O_WRONLY)
os.write(out, 'tetet')
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/10021759/what-conditions-result-in-an-opened-nonblocking-named-pipe-fifo-being-unavai">What conditions result in an opened, nonblocking named pipe (fifo) being "unavailable" for reads?</a> However, this question is definitely still useful, since it's unique phrasing meant it was the first one I found on Google.</span>
<span class="comment-copy"><code>NameError: name 'fifo' is not defined</code> could you please fix the example?</span>
<span class="comment-copy">after try it out, a.py raise:  UnboundLocalError: local variable 'buffer' referenced before assignment</span>
<span class="comment-copy">@chaonin I tried to guess what the reason is (I did not use buffer before), and updated my example. Hopefully it is more clear now.</span>
<span class="comment-copy">io = os.open(fifo, os.O_RDONLY | os.O_NONBLOCK)  try:  	buffer = os.read(io, BUFFER_SIZE)  except OSError as err:      if err.errno == errno.EAGAIN or err.errno == errno.EWOULDBLOCK:          pass      else:          raise err  jobs_infile = shlex.split(buffer)  os.close(io)</span>
<span class="comment-copy">Sove it, thanks Jonas!</span>
<span class="comment-copy">@lxs In fact, you have to if you want to be portable, as the read(2) manpage suggests. It's inconvenient and in python3.3, we would catch <a href="http://docs.python.org/3/library/exceptions.html#BlockingIOError" rel="nofollow noreferrer"><code>BlockingIOError</code></a> instead (which also tells us how many characters were written).</span>
<span class="comment-copy">I have not push the dummy code out...</span>
<span class="comment-copy">This does not answer the question, nor is it relevant considering that the code given is obviously snippetly. (-1)</span>
<span class="comment-copy">If your edit was intended to address my complaint, it didn't.</span>
