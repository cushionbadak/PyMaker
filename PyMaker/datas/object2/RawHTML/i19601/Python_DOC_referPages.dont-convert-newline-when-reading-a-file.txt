<div class="post-text" itemprop="text">
<p>I'm reading a text file:</p>
<pre><code>f = open('data.txt')
data = f.read()
</code></pre>
<p>However newline in <code>data</code> variable is normalized to LF ('\n') while the file contains CRLF ('\r\n').</p>
<p>How can I instruct Python to read the file as is?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.x:</p>
<pre><code>f = open('data.txt', 'rb')
</code></pre>
<p>As <a href="http://docs.python.org/2/library/functions.html#open">the docs</a> say:</p>
<blockquote>
<p>The default is to use text mode, which may convert '\n' characters to a platform-specific representation on writing and back on reading. Thus, when opening a binary file, you should append <code>'b'</code> to the mode value to open the file in binary mode, which will improve portability. (Appending <code>'b'</code> is useful even on systems that don’t treat binary and text files differently, where it serves as documentation.)</p>
</blockquote>
<p>In Python 3.x, there are three alternatives:</p>
<pre><code>f1 = open('data.txt', 'rb')
</code></pre>
<p>This will leave newlines untransformed, but will also return <code>bytes</code> instead of <code>str</code>, which you will have to explicitly <code>decode</code> to Unicode yourself. (Of course the 2.x version also returned bytes that had to be decoded manually if you wanted Unicode, but in 2.x that's what a <code>str</code> object is; in 3.x <code>str</code> is Unicode.)</p>
<pre><code>f2 = open('data.txt', 'r', newline='')
</code></pre>
<p>This will return <code>str</code>, and leave newlines untranslated. Unlike the 2.x equivalent, however, <code>readline</code> and friends will treat <code>'\r\n'</code> as a newline, instead of a regular character followed by a newline. Usually this won't matter, but if it does, keep it in mind.</p>
<pre><code>f3 = open('data.txt', 'rb', encoding=locale.getpreferredencoding(False))
</code></pre>
<p>This treats newlines exactly the same way as the 2.x code, and returns <code>str</code> using the same encoding you'd get if you just used all of the defaults… but it's no longer valid in current 3.x.</p>
<blockquote>
<p>When reading input from the stream, if newline is None, universal newlines mode is enabled. Lines in the input can end in '\n', '\r', or '\r\n', and these are translated into '\n' before being returned to the caller. If it is '', universal newlines mode is enabled, but line endings are returned to the caller untranslated.</p>
</blockquote>
<p>The reason you need to specify an explicit encoding for <code>f3</code> is that opening a file in binary mode means the default changes from "decode with <code>locale.getpreferredencoding(False)</code>" to "don't decode, and return raw <code>bytes</code> instead of <code>str</code>". Again, from <a href="http://docs.python.org/3/library/functions.html#open">the docs</a>:</p>
<blockquote>
<p>In text mode, if encoding is not specified the encoding used is platform dependent: locale.getpreferredencoding(False) is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.)</p>
</blockquote>
<p>However:</p>
<blockquote>
<p>'encoding' … should only be used in text mode.</p>
</blockquote>
<p>And, at least as of 3.3, this is enforced; if you try it with binary mode, you get <code>ValueError: binary mode doesn't take an encoding argument</code>.</p>
<p>So, if you want to write code that works on both 2.x and 3.x, what do you use? If you want to deal in <code>bytes</code>, obviously <code>f</code> and f1<code>are the same. But if you want to deal in</code>str<code>, as appropriate for each version, the simplest answer is to write different code for each, probably</code>f<code>and</code>f2`, respectively. If this comes up a lot, consider writing either wrapper function:</p>
<pre><code>if sys.version_info &gt;= (3, 0):
    def crlf_open(path, mode):
        return open(path, mode, newline='')
else:
    def crlf_open(path, mode):
        return open(path, mode+'b')
</code></pre>
<p>Another thing to watch out for in writing multi-version code is that, if you're not writing locale-aware code, <code>locale.getpreferredencoding(False)</code> almost always returns something reasonable in 3.x, but it will usually just return <code>'US-ASCII'</code> in 2.x. Using <code>locale.getpreferredencoding(True)</code> is technically incorrect, but may be more likely to be what you actually want if you don't want to think about encodings. (Try calling it both ways in your 2.x and 3.x interpreters to see why—or read the docs.) </p>
<p>Of course if you actually know the file's encoding, that's always better than guessing anyway.</p>
<p>In either case, the <code>'r'</code> means "read-only". If you don't specify a mode, the default is <code>'r'</code>, so the binary-mode equivalent to the default is <code>'rb'</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to open the file in the binary mode:</p>
<pre><code>f = open('data.txt', 'rb')
data = f.read()
</code></pre>
<p>(<code>'r'</code> for "read", <code>'b'</code> for "binary")</p>
<p>Then everything is returned as is, nothing is normalized</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/codecs.html?highlight=codecs#codecs.open" rel="nofollow">codecs module</a> to write 'version-agnostic' code:</p>
<blockquote>
<p>Underlying encoded files are always opened in binary mode. No automatic conversion of <code>'\n'</code> is done on reading and writing. The mode argument may be any binary mode acceptable to the built-in <code>open()</code> function; the <code>'b'</code> is automatically added.</p>
</blockquote>
<pre><code>import codecs
with codecs.open('foo', mode='r', encoding='utf8') as f:
    # python2: u'foo\r\n'
    # python3: 'foo\r\n'
    f.readline()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just request "read binary" in the <code>open</code>:</p>
<pre><code>f = open('data.txt', 'rb')
data = f.read()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Open the file using <code>open('data.txt', 'rb')</code>. See the <a href="http://docs.python.org/2/library/functions.html#open" rel="nofollow">doc</a>.</p>
</div>
<span class="comment-copy">Are you using Python 2 or 3 here?</span>
<span class="comment-copy">It's a Python 2</span>
<span class="comment-copy">From the quote you have for Python 3 -- "(For reading and writing raw bytes use binary mode and leave encoding unspecified.)" it sounds to me like you should have left the <code>encoding=locale.getpreferredencoding(False)</code> off of the example for it when using <code>'rb'</code> mode.</span>
<span class="comment-copy">@martineau: I think your comment may have stemmed from a misunderstanding on your part (probably caused by unclear writing on my part). The idea is to read and write <code>str</code> but leave newlines untouched; reading and writing raw <code>bytes</code> obviously means you're not using <code>str</code>. But it pointed me to a major problem with my answer that needed to be fixed. So thanks!</span>
<span class="comment-copy">Yes, that was it. Your current version is much better, IMHO. Thanks.</span>
<span class="comment-copy">Right, I forgot that.</span>
