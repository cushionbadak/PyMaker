<div class="post-text" itemprop="text">
<p>I have a very large 2D array which looks something like this:</p>
<pre><code>a=
[[a1, b1, c1],
 [a2, b2, c2],
 ...,
 [an, bn, cn]]
</code></pre>
<p>Using numpy, is there an easy way to get a new 2D array with e.g. 2 random rows from the initial array a (without replacement)?</p>
<p>e.g.</p>
<pre><code>b=
[[a4,  b4,  c4],
 [a99, b99, c99]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; A = np.random.randint(5, size=(10,3))
&gt;&gt;&gt; A
array([[1, 3, 0],
       [3, 2, 0],
       [0, 2, 1],
       [1, 1, 4],
       [3, 2, 2],
       [0, 1, 0],
       [1, 3, 1],
       [0, 4, 1],
       [2, 4, 2],
       [3, 3, 1]])
&gt;&gt;&gt; idx = np.random.randint(10, size=2)
&gt;&gt;&gt; idx
array([7, 6])
&gt;&gt;&gt; A[idx,:]
array([[0, 4, 1],
       [1, 3, 1]])
</code></pre>
<p>Putting it together for a general case:</p>
<pre><code>A[np.random.randint(A.shape[0], size=2), :]
</code></pre>
<p>For non replacement (numpy 1.7.0+):</p>
<pre><code>A[np.random.choice(A.shape[0], 2, replace=False), :]
</code></pre>
<p>I do not believe there is a good way to generate random list without replacement before 1.7. Perhaps you can setup a small definition that ensures the two values are not the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is an old post, but this is what works best for me:</p>
<pre><code>A[np.random.choice(A.shape[0], num_rows_2_sample, replace=False)]
</code></pre>
<p>change the replace=False to True to get the same thing, but with replacement. </p>
</div>
<div class="post-text" itemprop="text">
<p>Another option is to create a random mask if you just want to down-sample your data by a certain factor. Say I want to down-sample to 25% of my original data set, which is currently held in the array <code>data_arr</code>:</p>
<pre><code># generate random boolean mask the length of data
# use p 0.75 for False and 0.25 for True
mask = numpy.random.choice([False, True], len(data_arr), p=[0.75, 0.25])
</code></pre>
<p>Now you can call <code>data_arr[mask]</code> and return ~25% of the rows, randomly sampled.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need the same rows but just a random sample then,</p>
<pre><code>import random
new_array = random.sample(old_array,x)
</code></pre>
<p>Here x, has to be an 'int' defining the number of rows you want to randomly pick.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a similar answer to the one Hezi Rasheff provided, but simplified so newer python users understand what's going on (I noticed many new datascience students fetch random samples in the weirdest ways because they don't know what they are doing in python).</p>
<p>You can get a number of random indices from your array by using:</p>
<pre><code>indices = np.random.choice(A.shape[0], amount_of_samples, replace=False)
</code></pre>
<p>You can then use slicing with your numpy array to get the samples at those indices:</p>
<pre><code>A[indices]
</code></pre>
<p>This will get you the specified number of random samples from your data.</p>
</div>
<div class="post-text" itemprop="text">
<p>I see permutation has been suggested. In fact it can be made into one line:</p>
<pre><code>&gt;&gt;&gt; A = np.random.randint(5, size=(10,3))
&gt;&gt;&gt; np.random.permutation(A)[:2]

array([[0, 3, 0],
       [3, 1, 2]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to generate multiple random subsets of rows, for example if your doing RANSAC.</p>
<pre><code>num_pop = 10
num_samples = 2
pop_in_sample = 3
rows_to_sample = np.random.random([num_pop, 5])
random_numbers = np.random.random([num_samples, num_pop])
samples = np.argsort(random_numbers, axis=1)[:, :pop_in_sample]
# will be shape [num_samples, pop_in_sample, 5]
row_subsets = rows_to_sample[samples, :]
</code></pre>
</div>
<span class="comment-copy">its silly to have a question one for replacement and one without, you should just allow both answers and in fact encourage both answers.</span>
<span class="comment-copy">There is maybe not a good way, but a way that is just as good as <code>np.random.choice</code>, and that is <code>np.random.permutation(A.shape[0])[:2]</code>, actually its not great, but that is what <code>np.random.choice</code> at this time... or if you don't care to change your array in-place, <code>np.random.shuffle</code></span>
<span class="comment-copy">Before numpy 1.7, use <a href="http://docs.python.org/2.7/library/random.html" rel="nofollow noreferrer">random</a>.sample( xrange(10), 2 )</span>
<span class="comment-copy">why are you naming your variables A and B and stuff? it makes it harder to read.</span>
<span class="comment-copy">there may be some repeated indexs...</span>
<span class="comment-copy">@SalvadorDali I've edited Hezi's post to not choose with replacement. Once the edit is peer-reviewed, you'll see the added <code>replace=False</code> param to <code>choice</code>.</span>
<span class="comment-copy">@0x24a537r9 you should not do this. This is his answer and you change it. If you want - add your answer an do not change answers of other people that significantly alters the answer</span>
<span class="comment-copy">@0x24a537r9 Can you post the answer without replacement?</span>
<span class="comment-copy">This only works if  <code>old_array</code> is a sequence or a set, not a numpy array [link] (<a href="https://docs.python.org/3/library/random.html#functions-for-sequences" rel="nofollow noreferrer">docs.python.org/3/library/random.html#functions-for-sequences</a>)</span>
