<div class="post-text" itemprop="text">
<p>I enjoy playing <a href="http://www.daysofwonder.com/tickettoride/en/" rel="nofollow">Ticket to Ride</a>, so I decided to play around with implementing parts of the game logic in Python as a side programming project.  The game board is essentially a weighted multigraph, so replicating the basic structure of the game with <a href="http://networkx.lanl.gov/" rel="nofollow">NetworkX</a> was a cinch.</p>
<p>The one part I'm having trouble with is analyzing whether a particular path through the board is possible given an inventory of train cards the player possesses.  I <em>think</em> it's more of a math problem than a programming problem per se, and I can probably piece together a brute force method for figuring things out, but thought there must be a more efficient way.</p>
<p>For those who don't know the game: at any given time, each player has a number of train cards in one of eight colors, plus a special "locomotive" category that serves as a wild card.  These colors correspond to the color of train lines on the game board (<a href="http://cdn0.daysofwonder.com/tickettoride/en/img/te_board.jpg" rel="nofollow">shown here</a>) except for the gray lines, where you can use any color, as long as all cars in the segment are the same color.  (There are edge cases involving tunnels and ferries, but we'll leave those aside for now.)</p>
<p>With the code as it stands now, I can find all paths between two given cities and get back how many train cards of each color are needed to take that particular path, unless the paths involve gray segments.  I do the non-gray segments first since they're more straightforward -- either you have enough red/green/blue cards for each red/green/blue segment in the path or you don't.  With gray, because you can pick any color to use for each segment, it gets a bit more involved.</p>
<p>For paths with just one gray segment, it's still easy -- either you have enough cards of any one color to fill it in or not.  With multiple gray segments, however, one can run into situations where the color chosen for the first segment makes completing the second or third segment impossible.</p>
<p>As an example, suppose a player's card inventory is 4 red, 2 green, 3 blue, and we're trying to figure out if he can get from Paris to Vienna.  Looking at the board, it's pretty easy to see that the only possible route for this card combination involves going Paris --(3 gray)--&gt; Zurich --(2 green)--&gt; Venice --(2 gray)--&gt; Zagrad --(2 gray)--&gt; Vienna.  My algorithm for figuring this out starts with the green segment, and allocates the two green cards there.  Then it needs to decide how to use the remaining 4 red and 3 blue cards to cover the gray segments of lengths 3, 2, and 2.</p>
<p>The answer, of course, is to use the 3 blue cards between Paris and Zurich, and 2 red cards each for Venice to Zagrad and Zagrad to Vienna.  But how does one write a generalized algorithm that solves this problem for less obvious cases involving more colors and more segments?</p>
<p>My code for this right now looks like this:</p>
<pre><code>def can_afford(path, cards):
    grays = list()
    for segment in path:
        if segment.color == 'Gray':
            grays.append(segment)
        else:
            if cards.get(segment.color, 0) &gt;= segment.weight:
                cards[segment.color] -= segment.weight
            else:
                return False
    for gray in grays:
        # Halp!
        pass
    return True
</code></pre>
<p>("weight" is the length of the segment in train cars.)</p>
<p>I feel like there's a really trivial solution lurking in here that I just can't put my finger on.  Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>As Daniel Br√ºckner says, the problem of finding a way to assign colors of cards to gray segments corresponds to the <a href="https://en.wikipedia.org/wiki/Bin_packing_problem" rel="nofollow noreferrer">bin packing problem</a>, with the sets of colored cards corresponding to the bins, and the gray segments corresponding to the objects to be packed.</p>
<p>Now, the bin packing problem is <a href="https://en.wikipedia.org/wiki/NP-hard" rel="nofollow noreferrer">NP-hard</a>, but that's not a disaster in this case, because the problem can be solved in <a href="https://en.wikipedia.org/wiki/Pseudo-polynomial_time" rel="nofollow noreferrer">pseudo-polynomial time</a> (that is, in time that's polynomial in the size of the bins) using <a href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="nofollow noreferrer">dynamic programming</a>, and that should be good enough for your application, where the size of the bins is limited by the number of cards in the game. Here's an example implementation of bin packing, using the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>@functools.lru_cache</code> decorator</a> to memoize it:</p>
<p>from functools import lru_cache</p>
<pre><code>@lru_cache(maxsize=None)
def packing(bins, objects):
    """Return a packing of objects into bins, or None if impossible. Both
    arguments are tuples of numbers, and the packing is returned in
    the form of a list giving the bin number for each object.

    &gt;&gt;&gt; packing((4,5,6), (6,5,4))
    [2, 1, 0]
    &gt;&gt;&gt; packing((4,5,6), (1,1,2,4,5))
    [0, 0, 0, 1, 2]

    """
    if not objects:
        return []
    o = objects[0]
    rest = objects[1:]
    for i, b in enumerate(bins):
        if o &lt;= b:
            p = packing(bins[:i] + (b - o,) + bins[i+1:], rest)
            if p is not None:
                return [i] + p
    return None
</code></pre>
<p>And this can be used to determine if a path can be followed in Ticket to Ride:</p>
<pre class="lang-py prettyprint-override"><code>def can_afford(path, cards):
    """Return True if path can be followed using cards, False if not.
    cards might be updated, so pass a copy if you don't want that to
    happen.

    """
    grays = []
    for segment in path:
        c, w = segment.color, segment.weight
        if c == 'Gray':
            grays.append(w)
        elif cards.get(c, 0) &gt;= w:
            cards[c] -= w
        else:
            return False
    return packing(tuple(cards.values()), tuple(grays)) is not None
</code></pre>
<p>Note that if you made <code>cards</code> a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collection.Counter</code></a>, then you could just write <code>cards[c]</code> instead of <code>cards.get(c, 0)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This problem bears some similarities with problems like <a href="http://en.wikipedia.org/wiki/Bin_packing" rel="nofollow">bin packing</a>, <a href="http://en.wikipedia.org/wiki/Subset_sum_problem" rel="nofollow">subset sum</a> and other similar problems. The mentioned and many related problems are NP-complete and therefore it may turn out that there is no (known) efficient algorithm for this problem but I can not prove this at the moment - it is just an intuition. I will think about it some more and then update this answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way of approaching this is to build a search tree as follows:</p>
<ul>
<li><p>Each node is labelled with a city name, a set of cards, and a number of trains. This corresponds to the starting city of a particular route and the cards and train pieces you have available.</p></li>
<li><p>Each child of a node corresponds to a city you can reach from the parent, along with the cards and train pieces that remain in your hand after completing the route from the parent to the node.</p></li>
</ul>
<p>For example, the root of the tree could correspond to Montreal with 4 blue, 1 white, and 1 wild card, and 45 train pieces. The children of the root would be:</p>
<ul>
<li>Toronto, (1 blue, 1 white, 1 wild), 42   # Use 3 blue cards</li>
<li>Toronto, (2 blue, 1 white), 42           # Use 2 blue and a wild card</li>
<li>New York, ( 1 blue, 1 white, 1 wild), 42 # Use 3 blue cards</li>
<li>New York, ( 2 blue, 1 white ), 43        # Use 2 blue and a wild card</li>
<li>Boston, ( 3 blue, 1 white ), 43          # Use 1 blue and a wild card</li>
<li>Boston, ( 2 blue, 1 white, 1 wild ), 43  # Use 2 blue cards</li>
<li>Boston, ( 4 blue ), 43                   # Use 1 white and a wild card</li>
</ul>
<p>Now, you just need to perform a depth-first search in this tree to see if you can reach the destination city. The edges you add to the search tree are limited by the cards in your hand (i.e., you can't go directly from Montreal to Sault St. Marie because you don't have a total of 6 black/wild cards in your hand) and the number of trains remaining (you couldn't go from Calgary to Seattle if you only had 3 cards remaining).</p>
</div>
<span class="comment-copy"><a href="https://cs.stackexchange.com">Computer Science</a> might like this.</span>
<span class="comment-copy">Are you intentionally ignoring locamotives (wild cards)?</span>
<span class="comment-copy">Yeah, for now I am because I wanted to get the gray routes figured out first to keep the problem simpler for now.</span>
<span class="comment-copy">+1 I totally missed that possibility - I thought about the segments being the bins and the card sets being the objects but did not consider swapping them. Suddenly it is so obvious that the problem is equivalent to bin packing.</span>
<span class="comment-copy">Excellent!  I made the same mistake not thinking of the card sets as bins.I tweaked this a bit to give me back a list of the cards remaining after following the entire path and used the collection.Counter as you suggested.</span>
<span class="comment-copy">Yeah, I actually thought about bin packing, but it seemed just different enough that I thought it might have a simpler solution.</span>
