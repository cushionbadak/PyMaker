<div class="post-text" itemprop="text">
<p>So i have this problem, i want to get the name of a python class in this way:</p>
<pre><code>class TestClass():
    myName = (get class name here automatically)
    saveDirectory = os.path.join(saveDir, myName) # so i can save it in unique location
    def __init__(self):
        pass # do something
</code></pre>
<p>However, it seems that <code>__class__.__name__</code> doesn't actually exist as of yet at the time when <code>myName</code> is created. So i have been forced to put that into the <code>__init__()</code> function, like this:</p>
<pre><code>class TestClass():
    def __init__(self):
        self.myName = self.__class__.__name__
        saveDirectory = os.path.join(saveDir, self.myName) # so i can save it in unique location
        pass # do something
</code></pre>
<p>But this has a big problem, because I cannot get the name of the class until I instantiate the class, I instend to create a few gigabytes of data for each instance of the class to be saved in the saveDirectory, so it can be re-used later. So I don't actually want to do go ahead with my current solution.</p>
<p>Is there anyway to get the class name as I have intended? Or am I just dreaming?</p>
<p>EDIT:</p>
<p>Thanks guys for your great suggestions. I am going to spend a little bit of time taking a look at Metaclasses. Otherwise, I will probably create a dictionary globally, and have references to these instantiated classes instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>The only way to actually do what you are trying to during the class definition is to use a <a href="https://stackoverflow.com/a/6581949/505154">metaclass</a>:</p>
<pre><code>def saveDirMeta(name, bases, dct):
    dct['saveDirectory'] = os.path.join(saveDir, name)
    return type(name, bases, dct)

class TestClass(object):
    __metaclass__ = saveDirMeta  # this adds the 'saveDirectory' attribute
    def __init__(self):
        pass # do something
</code></pre>
<p>Or on Python 3.x:</p>
<pre><code>class TestClass(metaclass=saveDirMeta):
    def __init__(self):
        pass # do something
</code></pre>
<p>This is definitely less clear than just using the following:</p>
<pre><code>class TestClass():
    saveDirectory = os.path.join(saveDir, 'TestClass')
    def __init__(self):
        pass # do something
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just use a method?</p>
<pre><code>class TestClass(object):
    @classmethod
    def get_save_directory(cls):
        return os.path.join(save_dir, cls.__name__)
</code></pre>
<p>Or you could just have a class attribute indicating the save directory; less magic is usually a good thing.  Plus you could change the name of the class later without breaking your storage.</p>
<p>Also, what?  Gigabytes?!</p>
</div>
<div class="post-text" itemprop="text">
<p>I guess what you're doing is not possible, because the class doesn't even exist when you do:</p>
<p><code>myName = (get class name here automatically)</code></p>
<p>But soon after the class has been interpreted you can pass the class object to some other function 
to do the job for you.</p>
<pre><code>In [1]: def save_class(cl):
    myName = cl.__name__
    print myName        #or do whatever you wanna do here
   ...:     

In [2]: class A:pass

In [3]: save_class(A)
A
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>During class interpretation, there is no "there" there yet.  So, yes, what your initial example shows is not possible.  But please explain why this would need to be known before the class even technically exists?</p>
<p>Barring a good answer to that outstanding question, one is left with trying to get the class' name from:</p>
<pre><code>1. outside the interpreted class definition, uninstantiated

    class demo(object):
        pass

    print demo.__name__ # 'demo'


2. from within the class definition, uninstantiated (or instantiated ;-)

    class demo2(object):
        @classmethod
        def myName(cls):
            return cls.__name__

    print demo2.myName() # 'demo2'
    print demo2().myName() # 'demo2'


or

3. within an actual instance of the class

    class demo3(object):
        def myClassName(self):
            return self.__class__.__name__

    print demo3().myClassName() # 'demo3'
</code></pre>
<p>Beyond that, please edit the question and add some details that explain why your initial attempt needs to work the way you want, before instantiation and yet internal to the class definition, while your 2nd example is problematic.  Also, how does saveDir get passed/come from?  (A global outside of the class?)  Please show some code showing how you intend to use what you'd like to work.  There may be a way to redesign to get there from here, in effect if not literally.</p>
</div>
<div class="post-text" itemprop="text">
<p>Other than the metaclass in F J's <a href="https://stackoverflow.com/a/14513189/65696">answer</a>, I can think of <em>two</em> other ways.  I'll start with the nicer looking one.  You don't need to use a metaclass; sometimes a descriptor is perfectly adequate.</p>
<pre><code>class ClassNameDescriptor(object):
    def __get__(self, instance, owner):
        return owner.__name__

class BaseClass(object):
    name = ClassNameDescriptor()

class Foo(BaseClass):
    pass
</code></pre>
<p>The other way, if you really <em>need</em> the class name from <em>inside</em> the class body (unlikely), you can snoop on the call stack.  The class name, as it appears in source, is on the code object being executed by the class definition:</p>
<pre><code>import sys

def get_class_name_from_inside_class():
    return sys._getframe().f_back.f_code.co_name

class Foo(object):
    name = get_class_name_from_inside_class()
    print name
</code></pre>
<p>Of the ones presented so far, <em>only</em> this last one allws you to use the name, as a string, from inside the class body, Unfortunately, this doesn't work in all versions of python, notably IronPython does not implementent the call stack introspection as it's not available in the DLR.  </p>
<p>There's a way to get it without introspecting the stack, portably.  It's similar to the answer provided by F J, using a metaclass, but instead uses the <code>__prepare__</code> feature available in Python 3:</p>
<pre><code>class namedMeta(type):
    def __prepare__(mcls, name, bases, **kwargs):
        return {'name': name}

class Foo(metaclass=named):
    print name
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>try this. you can refer to your current class by <code>_class</code>. (I'm using python 2.7)</p>
<pre><code>class Meta(type):
    def __init__(self, *args):
        super(Meta, self).__init__(*args)
        self._class = self
        self.saveDir = str(self._class)

class Wow(object):
     __metaclass__ = Meta

&gt;&gt;&gt; Wow.saveDir
&gt;&gt;&gt; Wow().saveDir
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since python 3.3, you can use the <a href="https://docs.python.org/3/library/stdtypes.html#definition.__qualname__" rel="nofollow noreferrer"><code>__qualname__</code></a> variable:</p>
<pre><code>class TestClass():
    myName = __qualname__
</code></pre>
</div>
<span class="comment-copy">If you're trying to get the name of the class just after defining it, isn't a constant string attribute sufficient? You can change it in subclasses, if needed</span>
<span class="comment-copy">If you are always using the class name, why not just use a string? The class name is static so there should be no reason to continuously ask for it.</span>
<span class="comment-copy">Itâ€™s not possible to get the type name from within the class definition as at the time it is interpreted, the class is not created yet.</span>
<span class="comment-copy">you could do it in a metaclass or decorator.  but that's insane.  implementation left as an exercise to the reader.</span>
<span class="comment-copy">There's no reason to set <code>self.MyName</code> to <code>self.__class__.__name__</code> in <code>__init__()</code>. Just use <code>self.__class__.__name__</code>!</span>
<span class="comment-copy">That linked answer is awesome!</span>
<span class="comment-copy">I think this does the trick =)  Thank you!</span>
<span class="comment-copy">yes.. well.. potentially..</span>
