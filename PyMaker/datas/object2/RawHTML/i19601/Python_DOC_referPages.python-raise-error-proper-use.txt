<div class="post-text" itemprop="text">
<p><strong>Description</strong>:</p>
<p>I've read a lot opinions about checking value type in python and most said that you shouldn't check type, but instead use try and except.
I want to make clear few things.</p>
<p><strong>Questions</strong>:</p>
<p>When I have method like this:</p>
<pre><code>def set_age(self, age):
    self._age = age
</code></pre>
<p>I can't let user pass any types other then int because later in code it can cause some harder to debug bugs.
And according to Python methodology I can't check type.
So how should I do it with try in the proper way?</p>
<pre><code>def set_age(self, age):
    try:
        age = int(age)
    except TypeError:
        raise TypeError('First parameter must be of int type.')
    self._age = age
</code></pre>
<p>Or just</p>
<pre><code>def set_age(self, age):
    self._age = int(age)
</code></pre>
<p>and let Python raise errors on it's own.</p>
<p>I know it might be silly questions, I just want to make sure.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python will raise an appropriate error if it's not an integer, so there is no need to put your own over the top of it.</p>
<p>Let's step back a bit though, as there are other problems here. getters and setters are really unpythonic - either just use an attribute, or use <a href="http://docs.python.org/3/library/functions.html#property" rel="nofollow">properties</a>.</p>
<p>In this case, I think you are still thinking in the wrong way. The reason we don't type check in Python is because we shouldn't care what type something is, just if it will work in the given situation. Making everything the type you think it should be as soon as you get it is essentially type checking.</p>
<p>You say it will make it harder to debug, but that's not really the experience most people have. Duck typing is designed to allow anything that can do the job do the job. Converting everything to an <code>int</code> limits your program. The problem isn't here, the problem is with your code that is passing something that doesn't make sense to your class. In my experience, this is actually a really rare thing to do - you don't tend to throw random stuff at classes and see what sticks.</p>
<p>So, my suggestion here is that you use an attribute - just do <code>x.age = ...</code> instead of using <code>set_age()</code> or anything like that. If you <em>really</em> need to have an <code>int</code> (as in, only whole numbers make sense), then use a property and call <code>int()</code> in the setter, leaving the error to propagate to the caller if it happens.</p>
</div>
<div class="post-text" itemprop="text">
<p>One tenet of python is that "its better to ask forgiveness than permission". Many times the exceptions generated by the functions your function calls are sufficient to tell the caller of your function what went wrong.</p>
<p>That being said, in some cases I'll throw a more specific exception where the semantics to the caller don't entirely line up. one example I can think of is where I am examining a json response and I get a "key error" on one element of the dictionary. This typically means whatever request I sent out failed, and I therefore can't find the data I need. I'll in turn throw something more semantically in line with my function like "Query Failed".</p>
<p>Most times though exceptions thrown by called functions "type error" or "io error" should make perfect sense to the caller of my function so I don't bother catching and rethrowing.</p>
</div>
<span class="comment-copy">"later in code it can cause some harder to debug bugs" -- you gotta fix <i>that</i> code then. At present, you're trying to solve the problem in the wrong place.</span>
<span class="comment-copy">it's not solving yet, just finding place where to start looking. In my app I have a lot of parameters that are later packed to binary format. And when packing function raises error that can't pack something, then it doesn't show me from where data to pack comes, because it's a big array of values that are appended to array somewhere else in code. When I find exception of type error before packing I know what value won't pack. When I think about it right now, I should just validate values before setting it to object. But again validator is somehow type checking so I dunno what to think about it</span>
<span class="comment-copy">There is a huge difference between checking if something is suitable for use and type checking. In some languages they are the same thing, but in Python they are completely disparate. Note that type checking isn't <i>always</i> bad - it's pretty much the only way to differentiate between a string and an arbitrary sequence. In most cases, however, it is not needed and does more harm than good.</span>
<span class="comment-copy">Thanks for answer. I forgot to mention that I use python 2.7, but fortunately it supports properties too. I use setters and getters because maybe I'll need later some additional checks on value and then finding all my x.age = ... in code would be painfull. Altough I don't know if it's really an issue tbh. My first language was C++ and I have to change my thinking.</span>
<span class="comment-copy">@RafałŁużyński Properties solve that issue. If you have an attribute and you decide you need functionality with it, make a property. The property then acts exactly the same to a caller, so the interface doesn't change. Just use an attribute unless you <i>need</i> to do otherwise.</span>
