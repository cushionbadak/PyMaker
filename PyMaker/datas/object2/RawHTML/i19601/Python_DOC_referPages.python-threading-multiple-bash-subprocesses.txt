<div class="post-text" itemprop="text">
<p>How does one use the threading and subprocess modules to spawn parallel bash processes? When I start threads ala the first answer here: <a href="https://stackoverflow.com/questions/2846653/python-multithreading-for-dummies">How to use threading in Python?</a>, the bash processes run sequentially instead of in parallel.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need threads to run subprocesses in parallel:</p>
<pre><code>from subprocess import Popen

commands = [
    'date; ls -l; sleep 1; date',
    'date; sleep 5; date',
    'date; df -h; sleep 3; date',
    'date; hostname; sleep 2; date',
    'date; uname -a; date',
]
# run in parallel
processes = [Popen(cmd, shell=True) for cmd in commands]
# do other things here..
# wait for completion
for p in processes: p.wait()
</code></pre>
<hr/>
<p>To limit number of concurrent commands you could use <code>multiprocessing.dummy.Pool</code> that uses threads and provides the same interface as <a href="http://docs.python.org/2/library/multiprocessing.html#using-a-pool-of-workers" rel="noreferrer"><code>multiprocessing.Pool</code></a> that uses processes:</p>
<pre><code>from functools import partial
from multiprocessing.dummy import Pool
from subprocess import call

pool = Pool(2) # two concurrent commands at a time
for i, returncode in enumerate(pool.imap(partial(call, shell=True), commands)):
    if returncode != 0:
       print("%d command failed: %d" % (i, returncode))
</code></pre>
<p><a href="https://stackoverflow.com/a/9874484/4279">This answer demonstrates various techniques to limit number of concurrent subprocesses</a>: it shows multiprocessing.Pool, concurrent.futures, threading + Queue -based solutions.</p>
<hr/>
<p>You could limit the number of concurrent child processes without using a thread/process pool:</p>
<pre><code>from subprocess import Popen
from itertools import islice

max_workers = 2  # no more than 2 concurrent processes
processes = (Popen(cmd, shell=True) for cmd in commands)
running_processes = list(islice(processes, max_workers))  # start new processes
while running_processes:
    for i, process in enumerate(running_processes):
        if process.poll() is not None:  # the process has finished
            running_processes[i] = next(processes, None)  # start new process
            if running_processes[i] is None: # no new processes
                del running_processes[i]
                break
</code></pre>
<p>On Unix, you could avoid the busy loop and <a href="https://docs.python.org/3/library/os.html#os.waitpid" rel="noreferrer">block on <code>os.waitpid(-1, 0)</code>, to wait for any child process to exit</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple threading example:</p>
<pre><code>import threading
import Queue
import commands
import time

# thread class to run a command
class ExampleThread(threading.Thread):
    def __init__(self, cmd, queue):
        threading.Thread.__init__(self)
        self.cmd = cmd
        self.queue = queue

    def run(self):
        # execute the command, queue the result
        (status, output) = commands.getstatusoutput(self.cmd)
        self.queue.put((self.cmd, output, status))

# queue where results are placed
result_queue = Queue.Queue()

# define the commands to be run in parallel, run them
cmds = ['date; ls -l; sleep 1; date',
        'date; sleep 5; date',
        'date; df -h; sleep 3; date',
        'date; hostname; sleep 2; date',
        'date; uname -a; date',
       ]
for cmd in cmds:
    thread = ExampleThread(cmd, result_queue)
    thread.start()

# print results as we get them
while threading.active_count() &gt; 1 or not result_queue.empty():
    while not result_queue.empty():
        (cmd, output, status) = result_queue.get()
        print('%s:' % cmd)
        print(output)
        print('='*60)
    time.sleep(1)
</code></pre>
<p>Note that there are better ways to do some of this, but this is not too complicated.  The example uses one thread for each command.  Complexity starts to creep in when you want to do things like use a limited number of threads to handle an unknown number of commands.  Those more advanced techniques don't seem too complicated once you have a grasp of threading basics.  And multiprocessing gets easier once you have a handle on those techniques.</p>
</div>
<div class="post-text" itemprop="text">
<p>this is because it is supposed to do, the thing you want to do is not multithreadind but multiprocessing see this <a href="https://stackoverflow.com/questions/18114285/python-what-are-the-differences-between-the-threading-and-multiprocessing-modul/18114475">stack page</a></p>
</div>
<span class="comment-copy">Perhaps you could show some code?</span>
<span class="comment-copy">Why are you using threads with subprocesses given the scope of the question ?</span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/a/23616229/4279">Python: execute cat subprocess in parallel</a></span>
<span class="comment-copy">@j-f-sebastian With Popen, I can use communicate() and process the output, so it is more convenient. But I found that pool.map(Popen, cmds) does not really restrict the number of processes spawned. Am I doing something wrong?   On the other hand, I was able to get pool.map(call, cmds) working fine but am not able to capture its output (other than the return code). Is there a way to capture the output of call()?</span>
<span class="comment-copy">Sorry, looks like output from call() cannot be captured. :-/</span>
<span class="comment-copy">@SaheelGodhane create a function that <i>waits for a subprocess to exit</i> e.g., call <code>.communicate()</code> in it. Pass <i>that</i> function to <code>pool.map</code> instead of <code>Popen</code>. <code>Popen</code> returns <i>immediately</i> It is pointless to pass <code>Popen</code> along to <code>pool.map</code>. If something is unclear; ask a separate question</span>
<span class="comment-copy">Dear Sebastian, I'm trying to do something similar, namely: run first a subprocess p, once p running, I then call a second subprocess p2, I attempt to run p2 in a new terminal window, but I can't make it work with <code>subprocess.CREATE_NEW_CONSOLE</code> as that seems to be only for windows machines. Maybe you can help me out :( here's <a href="http://stackoverflow.com/questions/36624056/running-a-secondary-script-in-a-new-terminal#36624378">the post</a> by the way</span>
