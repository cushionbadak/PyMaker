<div class="post-text" itemprop="text">
<p>there's heapq in python, for general usage.
i want recording topN(0~20) for 10e7 records.</p>
<p>if use heapq, should use '-' to translate max to min; and recording a min number of bottom, to call heapq.heappushpop()  </p>
<p>should i use heapq or self implement a heap(maybe buggy or less efficient)?</p>
<pre><code>#update

import heapq
class TopN(object):
    """
    v format: (num, value)

    after looking into http://hg.python.org/cpython/file/2.7/Lib/heapq.py, 
    i find heappushpop already optimize, no need bottom value

    feed() can be optimize further, if needed:
        using func object instead of compare len(self.h) each time
    """
    def __init__(self, N):
        self.N = N
        self.h = []        

    def feed(self, v):  
        if len(self.h) &lt; self.N:
            heapq.heappush(self.h, v)
        else:
            heapq.heappushpop(self.h, v)

    def result(self):
        self.h.sort(reverse=True)
        return self.h

def t_topn():
    topn = TopN(10)
    for i in xrange(5):
        topn.feed((i, str(i)))
    res = topn.result()    
    assert sorted(res, reverse=True) == res 

def t_topn_random():
    import random
    topn = TopN(10)
    for i in xrange(100):
        x = random.randint(0, 1e4)
        topn.feed((x, str(x)))
    res = topn.result()    
    assert sorted(res, reverse=True) == res 

if __name__ == '__main__':
    t_topn()
    t_topn_random()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The only problem with <code>heapq</code> is that it doesn't provide a <code>key</code> function like everything else in the stdlib does. (If you're curious why, Raymond Hettinger explains in <a href="http://code.activestate.com/lists/python-list/162387/" rel="noreferrer">this email</a>. He's right that <code>heapq</code> couldn't provide the same interface as other sort functions—but the reasons don't affect your use case, where <code>key</code> would just be <code>lambda x: -x</code>.)</p>
<p>The usual workaround is to decorate-heap-undecorate. That is, put a modified version of your values into the heap that sorts by <code>key</code>. Normally, this means one of the following:</p>
<ul>
<li>Storing <code>key(x)</code> instead of <code>x</code>, and then accessing <code>unkey(value)</code> instead of <code>value</code> (assuming <code>key</code> is reversible).</li>
<li>Storing <code>(key(x), x)</code> instead of <code>x</code>, and then accessing <code>value[1]</code>. (This can break stability, but <code>heapq</code> doesn't promise stability anyway.)</li>
<li>Writing a wrapper class that implements a custom <code>__le__</code> method, then storing <code>Wrapper(x)</code> instead of <code>x</code> and accessing <code>value.value</code> instead of <code>value</code>.</li>
</ul>
<p>In your case, the key function is reversible. So, just store <code>-x</code>, and access <code>-value</code>. That's about as trivial as decoration gets.</p>
<p>Still, regardless of how simple it is, you should probably write a wrapper, or you will screw it up at some point. For example, you could write a <code>maxheap</code> that wraps the minheap in <code>heapq</code> like this:</p>
<pre><code>import heapq
def heapify(x):
    for i in range(len(x)):
        x[i] = -x[i]
    heapq.heapify(x)
def heappush(heap, item):
    heapq.heappush(heap, -item)
def heappop(heap):
    return -heapq.heappop(heap)
</code></pre>
<p>… and so on for any other functions you need. It may be a bit of a pain, but it's a lot less work than implementing the whole thing from scratch.</p>
<p>While you're at it, you may want to wrap the heap in an object-oriented API so you can do <code>heap.push(x)</code> instead of <code>heapq.heappush(heap, x)</code>, etc.</p>
<pre><code>import heapq
class MaxHeap(object):
    def __init__(self, x):
        self.heap = [-e for e in x]
        heapq.heapify(self.heap)
    def push(self, value):
        heapq.heappush(self.heap, -value)
    def pop(self):
        return -heapq.heappop(self.heap)
</code></pre>
<p>…</p>
<p>If you take a quick look around the recipes at ActiveState or the modules on PyPI, you should find that others have already done most of the work for you.</p>
<p>Alternatively, you could copy and paste the <code>heapq</code> source (it's pure Python) as <code>maxheapq.py</code> and just replace the <code>cmp_lt</code> function with its opposite. (Of course if you're doing that, it's probably just as easy, and certainly a lot clearer, to modify <code>cmp_lt</code> to take a <code>key</code> argument in the first place, and modify all the other functions to pass the <code>key</code> through—bearing in mind that it won't be as generally applicable anymore, because it can't make the usual guarantee that <code>key</code> is only called once.)</p>
<p>If you really want to live dangerously (you shouldn't), you could even monkeypatch it:</p>
<pre><code>import heapq
def cmp_gt(x, y):
    return y &lt; x if hasattr(y, '__lt__') else not (x &lt;= y)
heapq.cmp_lt = cmp_gt
</code></pre>
<p>But you don't want to do that in real code.</p>
</div>
<span class="comment-copy">Well, what makes you think you <i>shouldn't</i> use <code>heapq</code>? If it can do what you want, and it doesn't have any problems, and it's already built and tested, why is there even a question?</span>
<span class="comment-copy">If you want the top 20, then you can use <code>heapq.heappushpop(heap, x)</code> as it is, since it will push <code>x</code> onto the heap, then pop the <i>smallest</i> item from the heap.</span>
<span class="comment-copy">@unutbu: It sounds like he wants the opposite. Maybe these are golf scores?</span>
<span class="comment-copy">@abarnert: Well, his code seems to indicate he really is only interested in the largest values.</span>
<span class="comment-copy">@whi: Why are you pushing <code>(i, str(i))</code> to the heap? Pushing <code>i</code> would suffice. Then, at the end, you can convert your top N values to <code>str</code>s if you like. This will save you about 10**7 calls to <code>str</code> assuming <code>N &lt;&lt; 10**7</code>.</span>
<span class="comment-copy">Where can I find the source code for heapq?</span>
<span class="comment-copy">@ScottDavidTesler: If you look at <a href="http://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer">the documentation for the module</a>, there's a link to the source code right there at the top. Just follow it.</span>
<span class="comment-copy">@ScottDavidTesler: Or just <code>import heapq; print(heapq.__file__)</code> and you'll usually get the path to a local copy on your system. (This won't work if your Python installation puts the whole stdlib into a zipfile, or keeps .pyc files only, or various other tricks that are common on embedded systems.)</span>
<span class="comment-copy">@ScottDavidTesler: Finally, if you go to the Python website and click "Source" under "Download", or go to the first Google hit for "Python source", or just about any way of looking for it, you will either get <a href="http://www.python.org/getit/source/" rel="nofollow noreferrer">this page</a> with a link to the repo, or <a href="http://hg.python.org/cpython/file/" rel="nofollow noreferrer">the repo itself</a>. From there, all Python modules (like <code>heapq.py</code>) are under Lib, and all C extension modules (like heapq's hidden accelerator code in <code>_heapmodule.c</code>) are under Modules.</span>
<span class="comment-copy">Awesome. Thank you.</span>
