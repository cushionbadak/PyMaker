<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Possible Duplicate:</strong><br/>
<a href="https://stackoverflow.com/questions/9110593/asynchronous-requests-with-python-requests">Asynchronous Requests with Python requests</a> </p>
</blockquote>
<p>Is the python module <a href="http://docs.python-requests.org/en/latest/" rel="nofollow noreferrer">Requests</a> non-blocking?  I don't see anything in the docs about blocking or non-blocking. </p>
<p>If it is blocking, which module would you suggest?</p>
</div>
<div class="post-text" itemprop="text">
<p>Like <code>urllib2</code>, <code>requests</code> is blocking.</p>
<p>But I wouldn't suggest using another library, either.</p>
<p>The simplest answer is to run each request in a separate thread. Unless you have hundreds of them, this should be fine. (How many hundreds is too many depends on your platform. On Windows, the limit is probably how much memory you have for thread stacks; on most other platforms the cutoff comes earlier.)</p>
<p>If you <em>do</em> have hundreds, you can put them in a threadpool. The <a href="http://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-example" rel="noreferrer"><code>ThreadPoolExecutor</code> Example</a> in the <code>concurrent.futures</code> page is almost exactly what you need; just change  the <code>urllib</code> calls to <code>requests</code> calls. (If you're on 2.x, use <a href="http://pypi.python.org/pypi/futures" rel="noreferrer"><code>futures</code></a>, the backport of the same packages on PyPI.) The downside is that you don't actually kick off all 1000 requests at once, just the first, say, 8.</p>
<p>If you have hundreds, and they all need to be in parallel, this sounds like a job for <a href="http://pypi.python.org/pypi/gevent" rel="noreferrer"><code>gevent</code></a>. Have it monkeypatch everything, then write the exact same code you'd write with threads, but spawning <code>greenlet</code>s instead of <code>Thread</code>s.</p>
<p><a href="https://github.com/kennethreitz/grequests" rel="noreferrer"><code>grequests</code></a>, which evolved out of the old async support directly in <code>requests</code>, effectively does the <code>gevent</code> + <code>requests</code> wrapping for you. And for the simplest cases, it's great. But for anything non-trivial, I find it easier to read explicit <code>gevent</code> code. Your mileage may vary.</p>
<p>Of course if you need to do something <em>really</em> fancy, you probably want to go to <code>twisted</code>, <code>tornado</code>, or <code>tulip</code> (or wait a few months for <code>tulip</code> to be part of the stdlib).</p>
</div>
<div class="post-text" itemprop="text">
<p>It is blocking, but this reminded me of a kind of a neat little wrapper I guy I know put around gevent, which fell back to eventlet, and then threads if neither of those two were present. You can add functions to data structures that resemble either dicts or lists and as soon as the functions are added they are executed in the background and have the values returned from the functions be available in place of the functions as soon as they're done executing. It's <a href="https://github.com/lateefj/codap" rel="nofollow">here</a>.</p>
</div>
<span class="comment-copy">+1 excellent answer! This helps a lot.</span>
<span class="comment-copy">Answer Hall of Fame here.</span>
<span class="comment-copy">The most complete answer ever!</span>
