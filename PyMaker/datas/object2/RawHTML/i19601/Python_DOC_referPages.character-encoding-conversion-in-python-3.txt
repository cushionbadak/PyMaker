<div class="post-text" itemprop="text">
<p>In python 2.x, I have used</p>
<pre><code>"shift-jis".decode('shift-jis').encode('utf-8')
</code></pre>
<p>but there is no more str.decode() in python 3.x. what is the equivalent code in python 3.x? </p>
<p>Update :</p>
<p>More specific:</p>
<p>The python2 function is</p>
<pre><code>def unzip(file, dir):
    zips = zipfile.ZipFile(file)
    for info in zips.infolist():
        info.filename = info.filename.decode('shift-jis').encode('utf-8')
        zips.extract(info,dir)

        print(info, filename)
</code></pre>
<p>What is the equivalent python3 code for this function?  </p>
</div>
<div class="post-text" itemprop="text">
<p>To your updated question:</p>
<pre><code>def unzip(file, directory): # dir is a keyword
    with zipfile.ZipFile(file, mode='r') as zips:
        zips.printdir()
        zips.extractall(directory)
</code></pre>
<p>.</p>
<pre><code>&gt;&gt;&gt; b'\x82\xb3'.decode('shiftjis')
'さ'
&gt;&gt;&gt; b'\x82\xb3'.decode('shift-jis')
'さ'
&gt;&gt;&gt; b'\x82\xb3'.decode('shift_jis')
'さ'
&gt;&gt;&gt; '日本語'.encode('shiftjis')
b'\x93\xfa\x96{\x8c\xea'
&gt;&gt;&gt; b'\x93\xfa\x96{\x8c\xea'.decode('shiftjis')
'日本語'
</code></pre>
<p>and when reading files:</p>
<pre><code>with open('shiftjis.txt', 'r', encoding='shiftjis') as file:
    # do something with it
</code></pre>
<p>Read more: <a href="http://docs.python.org/3.3/library/io.html#i-o-base-classes" rel="nofollow">http://docs.python.org/3.3/library/io.html#i-o-base-classes</a> </p>
<p>a less saner version:</p>
<pre><code>with open('shiftjis.txt', 'rb') as file:
    string = file.read().decode('shift-jis')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had the need to do this myself, and the naïve way of doing it is:</p>
<pre><code>def unzip(file, dir):
    zips = zipfile.ZipFile(file)
    for info in zips.infolist():
        info.filename = info.filename.encode("cp437").decode("shift-jis")
    print("Extracting: " + info.filename.encode(sys.stdout.encoding,errors='replace').decode(sys.stdout.encoding))
    zips.extract(info,dir)
    print("")
</code></pre>
<p><code>ZipFile</code> seems to treat all file names internally as DOS (code page 437). Unlike Python 2, Python 3 stores all strings internally as UTF of some kind. So we convert the file name into a byte array, and decode the raw byte string as shift-JIS to get out final file name.</p>
<p>The <code>print</code> line does a similar thing, but to the default encoding of <code>stdout</code> and back. This prevents an error that happens on Windows because its terminal is almost never Unicode-capable. (If it is, however, the name should be shown correctly.)</p>
<p>This worked well for a couple of zip files, until bam... </p>
<pre><code>Traceback (most recent call last):
  File "jp\j-unzip.py", line 73, in &lt;module&gt;
    unzip(archname,archpath)
  File "jp\j-unzip.py", line 68, in unzip
    info.filename = info.filename.encode("cp437").decode("shift-jis")
UnicodeDecodeError: 'shift_jis' codec can't decode byte 0x8f in position 28: illegal multibyte sequence
</code></pre>
<p>Bonus content! It took some head-scratching to figure this one out, but the problem was that some valid shift-JIS characters contain backslashes, which ZipFile converts into forward slashes! For examle, 十 is encoded in shift-JIS as <code>8F 5C</code>. This is converted to <code>8F 2F</code> which is an illegal sequence. The following (perhaps overly complex) code check for this condition if an error occurs, and tried to fix it. But maybe there are other characters where this happens, and the sequence is valid, so you get the wrong character instead of an error. :(</p>
<pre><code>def convert_filename(inname):
    err_ctr=0
    keep_going = True

    trans_filename = bytearray(inname.encode("cp437"))

    while keep_going:
        keep_going = False

        try:
            outname = trans_filename.decode("shift-jis")
        except UnicodeDecodeError as e:
            keep_going = True

            if e.args[4]=="illegal multibyte sequence":
                p0, p1 = e.args[2], e.args[3]
                print("Trying to fix encoding error at positions " + str(p0) +", "+ str(p1) + " caused by shift-jis sequence " + hex(trans_filename[p0]) +", "+  hex(trans_filename[p1]) )

                if (trans_filename[p0]&gt;127 and trans_filename[p1] == 0x2f):
                    trans_filename[p1] = 0x5c
                else:
                    print("Don't know how to fix this error. Quitting. :(")
                    raise e

                err_ctr = err_ctr + 1
                print("This is error #" + str(err_ctr) + " for this filename.")
            else:
                raise e

        if err_ctr&gt;50:
            print("More than 50 iterations. Are we stuck in an endless loop? Quitting...")
            sys.exit(1)

    return outname

def unzip(file, dir):
    zips = zipfile.ZipFile(file)
    for info in zips.infolist():
        info.filename = convert_filename(info.filename)
    print("Extracting: " + info.filename.encode(sys.stdout.encoding,errors='replace').decode(sys.stdout.encoding))
    zips.extract(info,dir)
    print("")
</code></pre>
</div>
<span class="comment-copy">Strings are Unicode by default on python 3, that's why you have to add the 'b' before the string to indicate it's a binary string, as mflatishler pointed out in his examples.</span>
<span class="comment-copy">Please don't do that last example, it's unnecessary. <code>with open('shiftjis.txt', 'r', encoding='shiftjis')</code> is a much more sane option. See <a href="http://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">this page</a> for more information.</span>
<span class="comment-copy">You dont need to call .close() method when you use the <code>with</code> keyword. (response edited)</span>
<span class="comment-copy">Thanks, but the shift-jis filename isn't converted at all. The purpose of the function is not only just extracting zipfile, but also converting each shift-jis filename to utf-8.</span>
<span class="comment-copy">It's trying to decode the filename for you, either as utf-8 or cp437, depending on the zip file. If it has got it wrong, you'll need to first encode it to get original bytes from the file, then decode it correctly. E.g. <code>info.filename.encode('cp437').decode('shift-jis')</code>.</span>
<span class="comment-copy">It's weird. I tested with some zip files, but <code>info.filename.encode('shift-jis').decode('utf-8')</code> doesn't work and produce UnicodeEncodeError. In python2, the code in the question works perfectly.</span>
