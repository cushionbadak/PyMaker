<div class="post-text" itemprop="text">
<p>I'm trying to use super() for a simple class hierarchy in this manner: </p>
<pre><code>class Employee(object):
    def __init__(self, name):
        self.name = name

class FullTime(Employee):
    def __init__(self, name, satOff, freeDays=[], alDays=[], programDays=[]):
        global satsOffDict
        global dayDict
        super(Employee, self).__init__(name)
</code></pre>
<p>However, I'm getting this error: </p>
<pre><code>TypeError: object.__init__() takes no parameters
</code></pre>
<p>I've read that you need to make the parent object type object (new style classes) in order for super to work. If I change class Employee(object) to class Employee(), I get this error: </p>
<pre><code>TypeError: must be type, not classobj
</code></pre>
<p>What's going on? </p>
</div>
<div class="post-text" itemprop="text">
<p>You use the <em>current</em> class in <code>super()</code>:</p>
<pre><code>super(FullTime, self).__init__(name)
</code></pre>
<p><code>super()</code> looks for requested methods relative to the first argument; you started the search from <code>Employee</code> instead, looking for the parent classes; <code>object.__init__()</code> is the next parent method that matches in that case.</p>
<p>You need to use the current class, because Python needs to search the base classes in <a href="http://www.python.org/download/releases/2.3/mro/" rel="nofollow">Method Resolution Order</a>; that ordering depends on how your current class is derived from it's base classes (especially if there is multiple inheritence or a base class ends up being referenced multiple times).</p>
<p>On Python 3.x, you can use <code>super()</code> without any arguments, and the <a href="http://docs.python.org/3/reference/datamodel.html#creating-the-class-object" rel="nofollow">compiler will add an extra hint to your method</a> so that it can determine the correct class to start from.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you use <code>super</code> in Python, you should be specifying the <em>derived</em> type (that is, the class in which you're writing the call) as the first parameter.</p>
<pre><code>super(FullTime, self).__init__(name)
</code></pre>
</div>
<span class="comment-copy">You might want to be careful passing lists as the defaults the <code>__init__</code> like that.  That's just begging for interesting behavior ... <a href="http://stackoverflow.com/questions/1132941/least-astonishment-in-python-the-mutable-default-argument" title="least astonishment in python the mutable default argument">stackoverflow.com/questions/1132941/â€¦</a></span>
<span class="comment-copy">Could you comment on why this is?  I've always wondered.  It seems as though the derived class should be trivially easy to identify automatically by the interpreter.  Is there a use case for using something different as the first parameter?</span>
<span class="comment-copy">Note that in 3.x, <code>super()</code> can take no arguments and work fine.</span>
<span class="comment-copy">@acjohnson55: The MRO of the base classes depend on the inheriting class. Imagine a class that inherits from <i>two</i> super classes.</span>
<span class="comment-copy">So, you're saying that you can use a base class in <code>super</code>, but then a compatible method better be in <i>the base class's</i> superclass lineage someplace?</span>
<span class="comment-copy">@acjohnson55: Exactly. And it might be the wrong one, if there was a different MRO path to follow based on your current class.</span>
