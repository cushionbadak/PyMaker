<div class="post-text" itemprop="text">
<p>What I want is to be able to handle sets of data that have a fixed set of keys. All keys are strings. The data will never be edited. I know this can be done with normal dicts like so:</p>
<pre><code>data_a = {'key1': 'data1a', 'key2': 'data2a', 'key3': 'data3a'}
data_b = {'key1': 'data1b', 'key2': 'data2b', 'key3': 'data3b'}
data_c = {'key1': 'data1c', 'key2': 'data2c', 'key3': 'data3c'}
</code></pre>
<p>They must be able to be called like so:</p>
<pre><code>data_a['key1'] # Returns 'data1a'
</code></pre>
<p>However, this looks to be a waste of memory (since dictionaries apparently keep themselves 1/3 empty or something like that, along with also storing the keys multiple times) and also tedious to create as well since I need to keep entering the same keys over and over again in my code. I also risk accidentally changing something in the datasets.</p>
<p>My current solution is to have a set of keys stored in a tuple first, then store the data as tuples too. It looks like this:</p>
<pre><code>keys = ('key1', 'key2', 'key3')
data_a = ('data1a', 'data2a', 'data3a')
data_b = ('data1b', 'data2b', 'data3b')
data_c = ('data1b', 'data2c', 'data3c')
</code></pre>
<p>To retrieve data, I would do this:</p>
<pre><code>data_a[keys.index('key1')] # Returns 'data1a'
</code></pre>
<p>Then, I learned about this thing called namedtuples which seem to be able to do what I needed:</p>
<pre><code>import collections
Data = collections.namedtuple('Data', ('key1', 'key2', 'key3'))
data_a = Data('data1a', 'data2a', 'data3a')
data_b = Data('data1b', 'data2b', 'data3b')
data_c = Data('data1b', 'data2c', 'data3c')
</code></pre>
<p>However, it appears I can't simply call the value by the key. Instead, to retrieve the data by the key, I have to use getattr, which doesn't seem very intuitive: </p>
<pre><code>getattr(data_a,'key1') # Returns 'data1a'
</code></pre>
<p>My criteria is for memory efficiency first, then performance efficiency. Of these 3 methods, which would be the best way to do things? Or am I missing something and there's a more pythonic idiom to get what I want?</p>
<p>EDIT: I've now recently also learned about the existence of <code>__slots__</code>, which apparently runs more efficiently for key:value pairs while pretty much consuming the same(?) amount of memory. Would an implementation acting similar to <a href="https://stackoverflow.com/a/2648186/272515">this</a> be a suitable alternative to namedtuples?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, <code>__slots__</code> should do.</p>
<pre><code>class Data:
    __slots__ = ["key1", "key2"]

    def __init__(self, k1, k2):
        self.key1, self.key2 = k1, k2

    def __getitem__(self, key):
        if key not in self.__slots__:
            raise KeyError("%r not found" % key)
        return getattr(self, key)
</code></pre>
<p>Let's try that out:</p>
<pre><code>&gt;&gt;&gt; Data(1, 2)["key1"]
1
</code></pre>
<p>The conditional on <code>key not in self.__slots__</code> is a sanity check; <code>getattr</code> would happily fetch <code>__init__</code> for us if it weren't present.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow"><code>namedtuple</code></a> seems the right thing to use. If your "keys" are fixed, you don't need <code>getattr</code> and can use the normal syntax for retrieving objects' attributes:</p>
<pre><code>In [1]: %paste
import collections
Data = collections.namedtuple('Data', ('key1', 'key2', 'key3'))
data_a = Data('data1a', 'data2a', 'data3a')
data_b = Data('data1b', 'data2b', 'data3b')
data_c = Data('data1b', 'data2c', 'data3c')

## -- End pasted text --

In [2]: data_a.key1
Out[2]: 'data1a'
</code></pre>
<p>This usage is also demonstrated in the docs:</p>
<pre><code>&gt;&gt;&gt; # Basic example
&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])
&gt;&gt;&gt; p = Point(11, y=22)     # instantiate with positional or keyword arguments
&gt;&gt;&gt; p[0] + p[1]             # indexable like the plain tuple (11, 22)
33
&gt;&gt;&gt; x, y = p                # unpack like a regular tuple
&gt;&gt;&gt; x, y
(11, 22)
&gt;&gt;&gt; p.x + p.y               # fields also accessible by name
33
&gt;&gt;&gt; p                       # readable __repr__ with a name=value style
Point(x=11, y=22)
</code></pre>
<p>You don't usually use <code>getattr</code> if the second argument (attribute name) is constant. It's only needed if it may change:</p>
<pre><code>In [3]: attr = input('Attribute: ')
Attribute: key3

In [4]: getattr(data_b, attr)
Out[4]: 'data3b'
</code></pre>
</div>
<span class="comment-copy">An orthogonal suggestion, have you looked at <a href="http://pandas.pydata.org/" rel="nofollow noreferrer">pandas</a> ?</span>
<span class="comment-copy">Wouldn't some k/v store like memcache be better?</span>
<span class="comment-copy">Well, the problem is that the values to be retrieved may vary, so rather than actually entering 'key1', its a variable that stores a key (which is a string). So getattr() is necessary. Probably my mistake to not show that in the example. Unless if it's possible to edit the <code>__getitem__</code> method of the namedtuple?</span>
<span class="comment-copy">@Eric <code>__getitem__</code> already does a sane thing for <code>namedtuple</code>, behaving as in the regular tuple (see the example from the docs). But you can subclass it and make it call <code>getattr</code> instead. Saving you typing a couple of characters later is a quite arguable reason for doing that, though.</span>
<span class="comment-copy">What's the memory footprint of a namedtuple compared to a dict?</span>
<span class="comment-copy">From documentation, namedtuples have the same memory overhead as normal tuples. dicts are basically huge, since they only try to keep themselves 2/3 filled from what I've read, while tuples are fixed memory once defined so should be much more efficient.</span>
<span class="comment-copy">If you want to know how much memory an object is consuming use the <code>__sizeof__()</code> method. For example a <code>nametuple</code> of 3 elements uses 48 bytes while a <code>dict</code> containing three elements uses 248 bytes(plus the memory used by the keys and the values, in both of them). Anyway I'd suggest to first <a href="http://stackoverflow.com/questions/110259/python-memory-profiler">profile</a> the memory usage.</span>
