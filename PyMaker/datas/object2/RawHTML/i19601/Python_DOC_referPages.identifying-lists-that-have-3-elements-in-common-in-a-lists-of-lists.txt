<div class="post-text" itemprop="text">
<p>I have a list of lists. If there are subslists that have the first three elements in common , merge them into one list and add all the fourth elements.</p>
<p>The problem is best explained in code and the required output.</p>
<pre><code>a_list = [['apple', 50, 60, 7],
          ['orange', 70, 50, 8],
          ['apple', 50, 60, 12]]

# output:
# [['apple', 50, 60, 19], ['orange', 70, 50, 8]]
</code></pre>
<p>I already have code for a similar problem (given to me by another user in Stack Overflow some time ago), but i don't understand it completely so I'm unable to modify it accordingly. What this code does is it checks if the 0th and 2nd elements are the same, if they are, it merges the sublists, adding the 1st and 3th element:</p>
<pre><code>import defaultdict
data = [['42x120x1800', 50, '50x90x800', 60],
        ['42x120x1800', 8, '50x90x800', 10],
        ['2x10x800', 5, '5x9x80', 6]]

d = defaultdict(lambda :[0, 0])
for sub_list in data:
    key = (sub_list[0], sub_list[2])
    d[key][0] += sub_list[1]
    d[key][1] += sub_list[3]

new_data = [[key[0], val[0], key[1], val[1]] for key, val in d.iteritems()]
# [['2x10x800', 5, '5x9x80', 6], ['42x120x1800', 58, '50x90x800', 70]]
</code></pre>
<p>How should the code be modified to fit to my new problem? I'd really appreciate if you could also take the time and explain the code thoroughly, too.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the same principle, by using the first three elements as a key, and using <code>int</code> as the default value factory for the <code>defaultdict</code> (so you get <code>0</code> as the initial value):</p>
<pre><code>from collections import defaultdict

a_list = [['apple', 50, 60, 7],
          ['orange', 70, 50, 8],
          ['apple', 50, 60, 12]]

d = defaultdict(int)
for sub_list in a_list:
    key = tuple(sub_list[:3])
    d[key] += sub_list[-1]

new_data = [list(k) + [v] for k, v in d.iteritems()]
</code></pre>
<p>If you are using Python 3, you can simplify this to:</p>
<pre><code>d = defaultdict(int)
for *key, v in a_list:
    d[tuple(key)] += v

new_data = [list(k) + [v] for k, v in d.items()]
</code></pre>
<p>because you can use a <a href="http://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow">starred target</a> to take all 'remaining' values from a list, so each sublist is assigned mostly to <code>key</code> and the last value is assigned to <code>v</code>, making the loop just that little simpler (and there is no <code>.iteritems()</code> method on a dict in Python 3, because <code>.items()</code> is an iterator already).</p>
<p>So, we use a <code>defaultdict</code> that uses <code>0</code> as the default value, then for each key generated from the first 3 values (as a tuple so you can use it as a dictionary key) sum the last value.</p>
<ul>
<li><p>So for the first item <code>['apple', 50, 60, 7]</code> we create a key <code>('apple', 50, 60)</code>, look that up in <code>d</code> (where it doesn't exist, but <code>defaultdict</code> will then use <code>int()</code> to create a new value of <code>0</code>), and add the <code>7</code> from that first item.</p></li>
<li><p>Do the same for the <code>('orange', 70, 50)</code> key and value <code>8</code>.</p></li>
<li><p>for the 3rd item we get the <code>('apple', 50, 60)</code> key again and add <code>12</code> to the pre-existing <code>7</code> in <code>d[('apple', 50, 60)]</code>. for a total of 19.</p></li>
</ul>
<p>Then we turn the (key, value) pairs back into lists and you are done. This results in:</p>
<pre><code>&gt;&gt;&gt; new_data
[['apple', 50, 60, 19], ['orange', 70, 50, 8]]
</code></pre>
<p>An alternative implementation that requires sorting the data uses <code>itertools.groupby</code>:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

a_list = [['apple', 50, 60, 7],
          ['orange', 70, 50, 8],
          ['apple', 50, 60, 12]]

newlist = [list(key) + [sum(i[-1] for i in sublists)] 
    for key, sublists in groupby(sorted(a_list), key=itemgetter(0, 1, 2))]
</code></pre>
<p>for the same output. This is going to be slower if your data isn't sorted, but it's good to know of different approaches.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd do something like this:</p>
<pre><code>&gt;&gt;&gt; a_list = [['apple', 50, 60, 7],
...           ['orange', 70, 50, 8],
...           ['apple', 50, 60, 12]]
&gt;&gt;&gt; 
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; getter = itemgetter(0,1,2)
&gt;&gt;&gt; for lst in a_list:
...     d[getter(lst)].extend(lst[3:])
... 
&gt;&gt;&gt; d
defaultdict(&lt;type 'list'&gt;, {('apple', 50, 60): [7, 12], ('orange', 70, 50): [8]})
&gt;&gt;&gt; print [list(k)+v for k,v in d.items()]
[['apple', 50, 60, 7, 12], ['orange', 70, 50, 8]]
</code></pre>
<p>This doesn't give the sum however.  It could be easily be fixed by doing:</p>
<pre><code>print [list(k)+[sum(v)] for k,v in d.items()]
</code></pre>
<p>There isn't much of a reason to prefer this over the slightly more elegant solution by Martijn, other than it will allow the user to have an input list with more than 4 items (with the latter elements being summed as expected).  In other words, this would pass the list:</p>
<pre><code>a_list = [['apple', 50, 60, 7, 12],
          ['orange', 70, 50, 8]]
</code></pre>
<p>as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Form the key from <code>[:3]</code> so that you get the first 3 elements.</p>
</div>
<span class="comment-copy">Does the order of the output list matter?</span>
<span class="comment-copy">The elements in the sublists should be ordered the same way they are in the input. The order of the sublists in the list is not important.</span>
<span class="comment-copy">Nearly the same answer ... Nice.</span>
<span class="comment-copy">As a side note, my loop disappeared because the first time I typed it into the interpretter, I accidentally had a <code>NameError</code> which I removed when copy-pasting -- apparently I removed a little too much :)</span>
<span class="comment-copy">btw, on Python 3 you could use: <a href="http://ideone.com/ULl4oW" rel="nofollow noreferrer"><code>for *key, v in a_list:</code> syntax</a>.</span>
<span class="comment-copy">@J.F.Sebastian -- That's just a little to far out there.  Nicely done though.  Can you unpack a generator expression like that as well?</span>
<span class="comment-copy">@mgilson: Yup, it'll unroll any iterator using that syntax.</span>
<span class="comment-copy">I was wondering where your loop had gone.. :-) Why not just use <code>int</code> as the default value factory and sum right there in the loop?</span>
<span class="comment-copy">@MartijnPieters -- Because I missed the part where OP said he wanted the sum :).  I think I'll delete my answer now. . .</span>
<span class="comment-copy">Decided to un-delete as there is a small use-case where this answer is more generally applicable than Martijn's.  I still prefer his answer however and would use it if the input list is regularly structured.</span>
<span class="comment-copy">Thank you alot for your answer, it's good to learn about new ideas.  I'm going to go with Martijn Pieters solution however, because the input is always 4 elements long.</span>
<span class="comment-copy">@geekkid -- No problem.  I'd go with his as well :)</span>
