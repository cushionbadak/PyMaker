<div class="post-text" itemprop="text">
<p>I currently have a global <code>Lock = threading.Lock()</code>, and make the following call:</p>
<pre><code>Parallel(n_jobs=2)(delayed(serialRemove)(dir,c,b,l,f) for f in os.listdir(dir))
</code></pre>
<p>using jobLib. In <code>serialRemove</code>, I have</p>
<pre><code>Lock.acquire()
print(f+' begin')
if h in hashes:
    try:
        os.remove(path)
        if l: print('Removing ' + path)
        removed += 1
    except os.error:
        print('Encountered error removing file') 
else:
    hashes.add(h)
print(f+' end')
Lock.release()
</code></pre>
<p>Part of the call results in:<br/>
10.txt begin<br/>
11.txt begin<br/>
20.txt begin<br/>
I don't understand how there could be two begin prints if I surround the code in a Lock. Is there any easy way to protect the code block so ideally I get:<br/>
10.txt begin<br/>
10.txt end<br/>
11.txt begin<br/>
11.txt end<br/>
20.txt begin<br/>
20.txt end<br/></p>
</div>
<div class="post-text" itemprop="text">
<p><code>threading.Lock</code> only works between threads of the same process.</p>
<p>Without actually knowing what library you're using for parallelism here, it's hard to be sure, but it's almost certainly executing the tasks in separate processes. (Anything that starts threads in the same process, at least with CPython, isn't going to get any effective parallelism for CPU-bound code, because of the GIL. Therefore, none of them do that.)</p>
<p>So, if you try to use a global <code>threading.Lock</code> object from other processes, you're going to get a completely independent lock in each process. So, locking it doesn't do any good. (With some parallel libraries—possibly different on each platform—you'll get an error instead. But there's no way it could possibly do what you want.)</p>
<p>Most parallelization libraries have their own lock types that work with their style of multiprocessing. If yours does, use the one that comes with your library.</p>
<p>If not, depending on how your library works, <a href="http://docs.python.org/3/library/multiprocessing.html#synchronization-between-processes" rel="nofollow"><code>multiprocessing.Lock</code></a> may do the trick.</p>
<p>If not, you'll have to implement something explicitly using, e.g., a lock file (possibly together with <a href="http://docs.python.org/3/library/fcntl.html#fcntl.flock" rel="nofollow"><code>flock</code></a>/<code>lockf</code>, or relying on Windows exclusive open, or whatever).</p>
<p>Also, note that at least one of the multiple libraries that has an API that could make sense of your example line of code, [<code>joblib</code>], is explicitly designed for tasks that do not have any sharing, and therefore isn't supposed to work with locks at all. (It probably will work with <code>multiprocessing.Lock</code> anyway, but you really shouldn't count on that.)</p>
</div>
<span class="comment-copy">As a side note, you really shouldn't call your lock <code>Lock</code>. It makes things confusing, since that's also the name of the type (even though the type name is qualified here). (If you follow the PEP 8 style of lowercase names for variables and functions, this never even comes up, except for built-in types.)</span>
<span class="comment-copy">What library are you using <code>Parallel</code> from. It doesn't look like <a href="http://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer"><code>multiprocessing</code></a> or <a href="http://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" rel="nofollow noreferrer"><code>concurrent</code></a> from the stdlib, or <a href="http://www.parallelpython.com" rel="nofollow noreferrer">Parallel Python</a>. I can think of a few less-common libraries that have a class named <code>Parallel</code> that might also have a function named <code>delayed</code>, but there's no way to guess which one you mean.</span>
<span class="comment-copy">Appreciate the insight, thanks!</span>
