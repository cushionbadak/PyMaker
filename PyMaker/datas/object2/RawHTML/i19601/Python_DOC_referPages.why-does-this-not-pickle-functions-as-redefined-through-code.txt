<div class="post-text" itemprop="text">
<p>I'm trying to transfer a function across a network connection (using asyncore). Is there an easy way to serialize a python function (one that, in this case at least, will have no side affects) for transfer like this?</p>
<p>I would ideally like to have a pair of functions similar to these:</p>
<pre><code>def transmit(func):
    obj = pickle.dumps(func)
    [send obj across the network]

def receive():
    [receive obj from the network]
    func = pickle.loads(s)
    func()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could serialise the function bytecode and then reconstruct it on the caller.  The <a href="https://docs.python.org/3/library/marshal.html" rel="noreferrer">marshal</a> module can be used to serialise code objects, which can then be reassembled into a function.  ie:</p>
<pre><code>import marshal
def foo(x): return x*x
code_string = marshal.dumps(foo.func_code)
</code></pre>
<p>Then in the remote process (after transferring code_string):</p>
<pre><code>import marshal, types

code = marshal.loads(code_string)
func = types.FunctionType(code, globals(), "some_func_name")

func(10)  # gives 100
</code></pre>
<p>A few caveats:</p>
<ul>
<li><p>marshal's format (any python bytecode for that matter) may not be compatable between major python versions.</p></li>
<li><p>Will only work for cpython implementation.</p></li>
<li><p>If the function references globals (including imported modules, other functions etc) that you need to pick up, you'll need to serialise these too, or recreate them on the remote side.  My example just gives it the remote process's global namespace.</p></li>
<li><p>You'll probably need to do a bit more to support more complex cases, like closures or generator functions.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Check out <a href="https://pypi.python.org/pypi/dill" rel="noreferrer">Dill</a>, which extends Python's pickle library to support a greater variety of types, including functions:</p>
<pre><code>&gt;&gt;&gt; import dill as pickle
&gt;&gt;&gt; def f(x): return x + 1
...
&gt;&gt;&gt; g = pickle.dumps(f)
&gt;&gt;&gt; f(1)
2
&gt;&gt;&gt; pickle.loads(g)(1)
2
</code></pre>
<p>It also supports references to objects in the function's closure:</p>
<pre><code>&gt;&gt;&gt; def plusTwo(x): return f(f(x))
...
&gt;&gt;&gt; pickle.loads(pickle.dumps(plusTwo))(1)
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://pythonhosted.org/Pyro4/" rel="noreferrer">Pyro</a> is able to <a href="http://packages.python.org/Pyro/7-features.html#mobile" rel="noreferrer">do this for you</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The most simple way is probably <code>inspect.getsource(object)</code> (see the <a href="http://docs.python.org/library/inspect.html#retrieving-source-code" rel="noreferrer">inspect module</a>) which returns a String with the source code for a function or a method.</p>
</div>
<div class="post-text" itemprop="text">
<p>It all depends on whether you generate the function at runtime or not:</p>
<p>If you do - <code>inspect.getsource(object)</code> won't work for dynamically generated functions as it gets object's source from <code>.py</code> file, so only functions defined before execution can be retrieved as source.</p>
<p>And if your functions are placed in files anyway, why not give receiver access to them and only pass around module and function names.</p>
<p>The only solution for dynamically created functions that I can think of is to construct function as a string before transmission, transmit source, and then <code>eval()</code> it on the receiver side.</p>
<p>Edit: the <code>marshal</code> solution looks also pretty smart, didn't know you can serialize something other thatn built-ins</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>cloud</code> package (pip install cloud) can pickle arbitrary code, including dependencies.  See <a href="https://stackoverflow.com/a/16891169/1264797">https://stackoverflow.com/a/16891169/1264797</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The basic functions used for this module covers your query, plus you get the best compression over the wire; see the instructive source code:</p>
<p>y_serial.py module :: warehouse Python objects with SQLite</p>
<p>"Serialization + persistance :: in a few lines of code, compress and annotate Python objects into SQLite; then later retrieve them chronologically by keywords without any SQL. Most useful "standard" module for a database to store schema-less data."</p>
<p><a href="http://yserial.sourceforge.net" rel="nofollow noreferrer">http://yserial.sourceforge.net</a></p>
</div>
<div class="post-text" itemprop="text">
<pre>code_string = '''
def foo(x):
    return x * 2
def bar(x):
    return x ** 2
'''

obj = pickle.dumps(code_string)

</pre>
<p>Now</p>
<pre>
exec(pickle.loads(obj))

foo(1)
&gt; 2
bar(3)
&gt; 9
</pre>
</div>
<span class="comment-copy">Have you tried your code?</span>
<span class="comment-copy">In Python 2.5, the "new" module is deprecated.  'new.function' should be replaced by 'types.FunctionType', after an "import types", I believe.</span>
<span class="comment-copy">@EOL: Good point - I've updated the code to use the types module instead.</span>
<span class="comment-copy">Thanks. This is exactly what I was looking for. Based on some cursory testing, it works as is for generators.</span>
<span class="comment-copy">If you read the first couple of paragraphs on the marshal module you see it strongly suggests using pickle instead? Same for the pickle page. <a href="http://docs.python.org/2/library/marshal.html" rel="nofollow noreferrer">docs.python.org/2/library/marshal.html</a></span>
<span class="comment-copy">I am trying to apply the <code>marshal</code> module to serialize a dictionary of dictionaries initialized as <code>defaultdict(lambda : defaultdict(int))</code>. But it returns the error <code>ValueError: unmarshallable object</code>. Note I'am usin python2.7. Any idea? Thanks</span>
<span class="comment-copy">dill also does a pretty good job of getting the source code from functions and lambdas and saving those to disk, if you'd prefer that over object pickling.</span>
<span class="comment-copy">I'd need to stick with the standard library for this particular project.</span>
<span class="comment-copy">But that doesn't mean you can't <i>look</i> at the code of Pyro to see how it is done :)</span>
<span class="comment-copy">Link broken - here is the Pyro Documentation - <a href="http://packages.python.org/Pyro4/" rel="nofollow noreferrer">packages.python.org/Pyro4</a></span>
<span class="comment-copy">@Functional Qyrus: Thanks - I've updated the link.</span>
<span class="comment-copy">@AaronDigulla- true, but it's worth mentioning that before reading a single line of someone else's published code, you should always check the software's license. Reading someone else's code and reusing the ideas without citing the source or adhering to license/copying constraints could be considered plagiarism and/or copyright violation in many cases.</span>
<span class="comment-copy">This looks good, except that the function name is explicitly defined in the code, which is slightly problematic. I could strip the first line of the code off, but that's breakable by doing something like 'def \/n func():'. I could pickle the name of the function with the function itself, but I'd have no guarantees that the name wouldn't collide, or I'd have to put the function in a wrapper, which is still not the cleanest solution, but it might have to do.</span>
<span class="comment-copy">Note that the inspect module is actually just asking the function where it was defined, and then reading in those lines from the source code file - hardly sophisticated.</span>
<span class="comment-copy">You can find out the function's name using its .__name__ attribute. You could do a regex replace on ^def\s*{name}\s*( and give it whatever name you like. It's not foolproof, but it will work for most things.</span>
