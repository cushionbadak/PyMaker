<div class="post-text" itemprop="text">
<p>In this piece of code, why does using 'for' result in no 'StopIteration'
or is the 'for' loop trapping all exceptions and then silently exiting?
In which case, why do we have the extraneous 'return'?? Or is the
<code>raise StopIteration</code> caused by: <code>return None</code>?</p>
<pre><code>#!/usr/bin/python3.1
def countdown(n):
    print("counting down")
    while n &gt;= 9:
        yield n
        n -= 1
    return

for x in countdown(10):
    print(x)

c = countdown(10)
next(c)
next(c)
next(c)
</code></pre>
<p>Assuming <code>StopIteration</code> is being triggered by: <code>return None</code>.
When is GeneratorExit generated?</p>
<pre><code>def countdown(n):
    print("Counting down from %d" % n)
    try:
        while n &gt; 0:
            yield n
            n = n - 1
    except GeneratorExit:
        print("Only made it to %d" % n)
</code></pre>
<p>If i manually do a:</p>
<pre><code>c = countdown(10)
c.close() #generates GeneratorExit??
</code></pre>
<p>In which case why don't I see a traceback?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>for</code> loop listens for <code>StopIteration</code> explicitly.</p>
<p>The purpose of the <code>for</code> statement is to loop over the sequence provided by an iterator and the exception is used to signal that the iterator is now done; <code>for</code> doesn't catch other exceptions raised by the object being iterated over, just that one.</p>
<p>That's because <code>StopIteration</code> is the normal, expected signal to tell whomever is iterating that there is nothing more to be produced.</p>
<p>A generator function is a special kind of iterator; it indeed raises <code>StopIteration</code> when the function is done (i.e. when it returns, so yes, <code>return None</code> raises <code>StopIteration</code>). It is a requirement of iterators; they <em>must</em> raise <code>StopIteration</code> when they are done; in fact, once a <code>StopIteration</code> has been raised, attempting to get another element from them (through <code>next()</code>, or calling the <code>.next()</code> (py 2) or <code>.__next__()</code> (py 3) method on the iterator) <em>must</em> always raise <code>StopIteration</code> again.</p>
<p><code>GeneratorExit</code> is an exception to communicate in the <em>other</em> direction. You are explicitly <em>closing</em> a generator with a <code>yield</code> expression, and the way Python communicates that closure to the generator is by raising <code>GeneratorExit</code> inside of that function. You explicitly catch that exception inside of <code>countdown</code>, its purpose is to let a generator clean up resources as needed when closing.</p>
<p>A <code>GeneratorExit</code> is not propagated to the caller; see the <a href="https://docs.python.org/3/reference/expressions.html#generator.close" rel="noreferrer"><code>generator.close()</code> documentation</a>.</p>
</div>
<span class="comment-copy">Also note, for will only catch the exception while evaluating the iterator. It won't catch it if it's raised within the body of the for loop.</span>
<span class="comment-copy">@JonasWielicki: expanded the sentence a little to remove that interpretation. :-)</span>
