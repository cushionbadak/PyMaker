<div class="post-text" itemprop="text">
<p>I have a binary file with a known format/structure.</p>
<p>How do I read all the binary data in to an array of the structure?</p>
<p>Something like (in pseudo code)</p>
<pre><code>bytes = read_file(filename)
struct = {'int','int','float','byte[255]'}
data = read_as_struct(bytes, struct)
data[1]
&gt;&gt;&gt; 10,11,10.1,Arr[255]
</code></pre>
<p><strong>EDIT:</strong></p>
<p>Solution so far:</p>
<pre><code>data = []

fmt   = '=iiiii256i'
fmt_s = '=iiiii'
fmt_spec = '256i'

struct_size = struct.calcsize(fmt)

for i in range(struct_size, len(bytes)-struct_size, struct_size):
    dat1= list(struct.unpack(fmt_s, bytes[i-struct_size:i-1024]))
    dat2= list(struct.unpack(fmt_spec, bytes[i-1024:i]))
    dat1.append(dat2)
    data.append(dat1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/2/library/struct.html" rel="nofollow noreferrer"><code>struct</code> module</a>; you need to define the types in a string format documented with that library:</p>
<pre><code>struct.unpack('=HHf255s', bytes)
</code></pre>
<p>The above example expects native byte-order, two unsigned shorts, a float and a string of 255 characters.</p>
<p>To loop over an already fully read <code>bytes</code> string, I'd use <code>itertools</code>; there is a handy <a href="https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks">grouper recipe</a> that I've adapter here:</p>
<pre><code>from itertools import izip_longest, imap
from struct import unpack, calcsize

fmt_s = '=5i'
fmt_spec = '=256i'
size_s = calcsize(fmt_s)
size = size_s + calcsize(fmt_spec)

def chunked(iterable, n, fillvalue=''):
    args = [iter(iterable)] * n
    return imap(''.join, izip_longest(*args, fillvalue=fillvalue))

data = [unpack(fmt_s, section[:size_s]) + (unpack(fmt_spec, section[size_s:]),)
    for section in chunked(bytes, size)]
</code></pre>
<p>This produces tuples rather than lists, but it's easy enough to adjust if you have to:</p>
<pre><code>data = [list(unpack(fmt_s, section[:size_s])) + [list(unpack(fmt_spec, section[size_s:]))]
    for section in chunked(bytes, size)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually it looks like you're trying to read a list (or array) of structures from the file. The idiomatic way to do this in Python is use the <code>struct</code> module and call <a href="https://docs.python.org/3/library/struct.html#struct.unpack" rel="noreferrer"><code>struct.unpack()</code></a> in a loop—either a fixed number of times if you know the number of them in advance, or until end-of-file is reached—and store the results in a <code>list</code>. Here's an example of the latter:</p>
<pre><code>import struct

struct_fmt = '=5if255s' # int[5], float, byte[255]
struct_len = struct.calcsize(struct_fmt)
struct_unpack = struct.Struct(struct_fmt).unpack_from

results = []
with open(filename, "rb") as f:
    while True:
        data = f.read(struct_len)
        if not data: break
        s = struct_unpack(data)
        results.append(s)
</code></pre>
<p>The same results can be also obtained slightly more concisely using a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a> along with a short <a href="https://docs.python.org/3/glossary.html#term-generator" rel="noreferrer">generator function</a> helper (i.e. <code>read_chunks()</code> below):</p>
<pre><code>def read_chunks(f, length):
    while True:
        data = f.read(length)
        if not data: break
        yield data

with open(filename, "rb") as f:
    results = [struct_unpack(chunk) for chunk in read_chunks(f, struct_len)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Add comments</p>
<pre><code>import struct 
</code></pre>
<p>First just read the binary into an array</p>
<pre><code>mbr = file('mbrcontent', 'rb').read() 
</code></pre>
<p>So you can just fetch some piece of the the array</p>
<pre><code>partition_table = mbr[446:510] 
</code></pre>
<p>and then unpack it as an integer</p>
<pre><code>signature = struct.unpack('&lt;H', mbr[510:512])[0] 
</code></pre>
<p>a more complex example</p>
<pre><code>little_endian = (signature == 0xaa55) # should be True 
print "Little endian:", little_endian 
PART_FMT = (little_endian and '&lt;' or '&gt;') + ( 
"B" # status (0x80 = bootable (active), 0x00 = non-bootable) 
# CHS of first block 
"B" # Head 
"B" # Sector is in bits 5; bits 9 of cylinder are in bits 7-6 
"B" # bits 7-0 of cylinder 
"B" # partition type 
# CHS of last block 
"B" # Head 
"B" # Sector is in bits 5; bits 9 of cylinder are in bits 7-6 
"B" # bits 7-0 of cylinder 
"L" # LBA of first sector in the partition 
"L" # number of blocks in partition, in little-endian format 
) 

PART_SIZE = 16 
fmt_size = struct.calcsize(PART_FMT) 
# sanity check expectations 
assert fmt_size == PART_SIZE, "Partition format string is %i bytes, not %i" % (fmt_size, PART_SIZE) 

def cyl_sector(sector_cyl, cylinder7_0): 
    sector = sector_cyl &amp; 0x1F # bits 5-0 

    # bits 7-6 of sector_cyl contain bits 9-8 of the cylinder 
    cyl_high = (sector_cyl &gt;&gt; 5) &amp; 0x03 
    cyl = (cyl_high &lt;&lt; 8) | cylinder7_0 
    return sector, cyl 

#I have corrected the indentation, but the change is refused because less than 6 characters, so I am adding this useful comment.
for partition in range(4): 
    print "Partition #%i" % partition, 
    offset = PART_SIZE * partition 
    (status, start_head, start_sector_cyl, start_cyl7_0, part_type, end_head, end_sector_cyl, end_cyl7_0, 
    lba, blocks ) = struct.unpack( PART_FMT,partition_table[offset:offset + PART_SIZE]) 
    if status == 0x80: 
        print "Bootable", 
    elif status: 
        print "Unknown status [%s]" % hex(status), 
        print "Type=0x%x" % part_type 
        start = (start_head,) + cyl_sector(start_sector_cyl, start_cyl7_0) 
        end = (end_head,) + cyl_sector(end_sector_cyl, end_cyl7_0) 
        print " (Start: Heads:%i\tCyl:%i\tSect:%i)" % start 
        print " (End: Heads:%i\tCyl:%i\tSect:%i)" % end 
        print " LBA:", lba 
        print " Blocks:", blocks 
</code></pre>
</div>
<span class="comment-copy">What is <code>spectrum</code> in your update? Did you mean <code>dat2</code>?</span>
<span class="comment-copy">Yes. Edited to reflect that.</span>
<span class="comment-copy">Note that your code actually skips the last <code>struct_size</code> bytes`.</span>
<span class="comment-copy">I like using <a href="http://construct.readthedocs.io/en/latest/" rel="nofollow noreferrer">Construct</a> for things like this. It allows you to easily define and read complex structures in Python.</span>
<span class="comment-copy">It seems this does not work on data larger than the struct size. My binary data repeats itself.</span>
<span class="comment-copy">@lejon: it doesn't remove read data from <code>bytes</code> magically. Either slice <code>buffer</code> or use <code>unpack_from()</code> and an offset.</span>
<span class="comment-copy">so I will have to iterate through the <code>bytes</code> and assign the each <code>unpack</code> to a tuple? Also. Is there a way of putting the last 255 into an actual array, such that the output is in the form of what I put in my original post?</span>
<span class="comment-copy">@lejon: What type is <code>Arr</code>? You'll have to pass the resulting string to that type manually, <code>struct</code> cannot do that for you.</span>
<span class="comment-copy">It's byte array. I've edited the answer to show my solution. However, is there a list comprehension to accomplish the same?</span>
<span class="comment-copy">Some readers may also be interested in reading the answers to the question <a href="https://stackoverflow.com/questions/44933639/fastest-way-to-read-a-binary-file-with-a-defined-format"><b><i>Fastest way to read a binary file with a defined format?</i></b></a></span>
<span class="comment-copy">I get the following error when I try to use your suggestion: struct.error: unpack_from requires a buffer of at least 209 bytes What am I doing wrong? Sorry I am new to python.</span>
<span class="comment-copy">@xMutzelx: That can happen when your binary file's length isn't an exact  multiple of the struct's size because there's no check being made after the <code>f.read()</code> call to ensure that the requested number of bytes is being returned. This can be because the file has some sort of header or trailer, in it as well as the data that comprises the array of structures (or it's corrupt).</span>
<span class="comment-copy">@xMutzelx: I just test the code in the answer and got exactly the error you describe when I added a small (10 byte) header to the binary input file I used for testing.</span>
<span class="comment-copy">@xMutzelx: Hmm...yes, have the wrong structure layout could also cause the problem. That's why it might be a good idea to at least manually verify that the computed <code>struct_len</code> value is what it ought to be. Also note that changing the structure format string prefix from <code>'='</code> to <code>'@'</code> (and leaving the <code>'B'</code> at the end in) might also have worked because it enables "native" alignment instead of suppressing it.</span>
<span class="comment-copy">-1: please fix the indentation and explain what this code is demonstrating.</span>
