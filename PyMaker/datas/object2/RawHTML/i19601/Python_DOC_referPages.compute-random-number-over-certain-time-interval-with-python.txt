<div class="post-text" itemprop="text">
<p>I did some research before posting but seem to be at a lost (not too experienced in coding).</p>
<p>I am attempting to generate or compute a random number for certain time interval with Python. I'm not looking for full code, I want help using the time library if that is the correct one to use.</p>
<p><strong>Pseudo-code:</strong> <p>
Allow python [PC] to compute a random number for 3 seconds 
 <p>           ------&gt; Store the computed generation in a value <em>(i can handle this)</em></p>
<p><p>
<p>
<p>
<p>
I would then use the random generated value to link access a python list (which would be automatically generated via a random number generation as well but i can figure that out).</p>
</p></p></p></p></p></p></div>
<div class="post-text" itemprop="text">
<p>I'm not sure why you want to do this, but here's how to compute many random numbers, throwing most of them away, and then using the last one after 3 seconds have elapsed.</p>
<pre><code>import random
import time

start = time.clock()
while time.clock() - start &lt; 3:
    random_number = random.randint(0,100)

print random_number
</code></pre>
<p>This pointlessly throws away about 2 million perfectly good random numbers on my machine.</p>
<p>(And, as <a href="https://stackoverflow.com/users/908494/abarnert">abarnert</a> points out, this also maxes out one CPU core for the whole 3 seconds in a busy loop, which is very, very wasteful, but I thinks it's what you were asking for?)</p>
<p><strong>EDIT:</strong> Updated to use <a href="http://docs.python.org/2/library/time.html#time.clock" rel="nofollow noreferrer">time.clock</a> instead of <a href="http://docs.python.org/2/library/time.html#time.time" rel="nofollow noreferrer">time.time</a>, as suggested by abarnert again (thanks), because this seems to give better resolution across platforms and doesn't suffer from problems when the system time is altered in the middle of the program running.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you didn't say what kind of random number you want to generate, but given that your example is <code>10</code>, I assume it's an integer in some range—let's say you're calling <a href="http://docs.python.org/3/library/random.html#random.randrange" rel="nofollow"><code>random.randrange(30)</code></a>.</p>
<p>Now, you want to compute a number every second for 3 seconds, then keep the last one. I don't know why you'd even want to do this, but you can do it like this:</p>
<pre><code>for i in range(3):
    number = random.randrange(30)
    time.sleep(1.0)
</code></pre>
<p>At the end of 3 seconds, <code>number</code> will be the third random number generated.</p>
<p>The key here is that, to do something once per second (in a synchronous program—don't do this in a GUI or server!)—you just call <a href="http://docs.python.org/3/library/time.html#time.sleep" rel="nofollow"><code>time.sleep</code></a>.</p>
<p>If the operation you were doing took a significant chunk of a second (or longer), this wouldn't be appropriate. Instead, you'd want to compute the start time, and sleep until a second after that:</p>
<pre><code>t0 = time.monotonic()
for i in range(3):
    number = random.randrange(30)
    t0 += 1
    time.sleep(t0 - time.monotonic())
</code></pre>
<p>Note that I've used <a href="http://docs.python.org/3/library/time.html#time.monotonic" rel="nofollow"><code>time.monotonic</code></a> here. This function is specifically designed for this kind of use case. It returns as much precision as can be gotten with reasonable efficiency (in particular, unlike <code>time.time</code>, it doesn't give you 1s precision on some platforms), and it guarantees that you'll never go backward even if, e.g., you change the system clock in the middle of the program. If you're using 3.2 or earlier, either look through the docs for the best alternative (possibly using <code>time.clock()</code>), or look into using <code>ctypes</code> to call the appropriate platform native function.</p>
<p>But in this case, <code>random.randrange</code> is going to take somewhere on the order of a microsecond, which is so much less time than the minimum resolution of most systems' simple timers that there's no reason to do such a thing.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to take 3 seconds to get a random number, because you're concerned about the quality of the random number, you can use os.urandom() to generate the value.   If all you really want to do is to select an item from your list at random, you can use random.choice()</p>
</div>
<span class="comment-copy">What does step 1 mean? Let's say it averages, e.g., 1us to compute a random number. So, what do you want to do for 3 seconds? Compute about 3,000,000 random numbers and store them all? Compute about 3,000,000 random numbers and store the last one? Compute 1 random number, wait about 2.999999 seconds, and store it? Or…?</span>
<span class="comment-copy">Or are you just trying to compute a random float between 0 and 3?</span>
<span class="comment-copy">I want to compute a random number for 3 seconds of real time. Allow computer to just lets say 1st sec it generates the # 10.... Then there is still 2 secs left of generation it would then change 10 to another number and so forth to arrive at a stop cycle / time of 3 secs and give a generated result of ______.</span>
<span class="comment-copy">Why would you do this? If it only takes 1us to compute a random number, why make it spend 3 seconds doing it?</span>
<span class="comment-copy">It wouldn't be the same, no… but it wouldn't be different in any meaningful way. The whole point of random numbers is that they're random, so it doesn't matter which one you pick.</span>
<span class="comment-copy">And it also pointlessly wastes nearly 100% of one core for 3 seconds on my machine. (But that's not a fault with this program; it seems like that's what the OP may be asking for.)</span>
<span class="comment-copy">I know. I thought that was what the OP wanted. Your solution uses much less CPU, but (pointlessly) throws away only 2 random numbers. I can (pointlessly) throw away a million times as many as that with my busy solution :)</span>
<span class="comment-copy">Wow this is even better than the first one. Thank you @Day.</span>
<span class="comment-copy">@Bain: What do you mean by "flow randomly"? The CPU is in fact doing a very simple set of steps deterministically (e.g., computing the next Yarrow or Mersenne-Twister value) over and over again, which is very nearly the exact opposite of random.</span>
<span class="comment-copy">@Day: One last thing: I think you want <code>time.monotonic</code> here, not <code>time.time</code>. Or, if the OP is using 3.2 or earlier, something more complicated using, e.g., <code>time.clock</code>. Because on some platforms, <code>time.time</code> only has a 1-second resolution and/or only updates every scheduler tick, meaning this could easily finish after, say, 2.07s instead of 3s.</span>
<span class="comment-copy">Thank you! And the generation of integers would be in randrange(x) .. I could put say 100 and it would generate a number between 1 and 100?</span>
<span class="comment-copy">@Bain: Yes. Click the link in my answer to see the docs, or just type <code>help(random)</code> into your interpreter.</span>
<span class="comment-copy">+1 as this is more environmentally friendly and better for the planet than my solution, which burns through CPU for no reason.</span>
<span class="comment-copy">@Day: Yeah, when the universe runs out of random numbers and quantum physics stops working, I'm blaming you. :)</span>
<span class="comment-copy">thank you. random.choice() helps. :)</span>
