<div class="post-text" itemprop="text">
<p>I am trying to run shell commands from Python on the CGI script below. Can someone explain to me why <code>exit_status</code> is <code>0</code> when I execute the script on the shell, while <code>exit_status</code> is <code>127</code> when I run it from a web browser? Thanks in advance. Also, if I try subprocesses like <code>echo something</code> (e.g. <code>exit_status = subprocess.call('echo something', shell=True)</code>), the exit status will be zero when run in the terminal but there will be a <code>500 Internal Server Error</code> when done in the browser. I'm really puzzled... </p>
<pre><code>#!/usr/bin/env python

import subprocess

print 'Content-type: text/html\n\n'  
print '&lt;html&gt;&lt;head&gt;'
print '&lt;/head&gt;&lt;body&gt;'

exit_status = subprocess.call('ls', shell=True)

print exit_status

print '&lt;/body&gt;&lt;/html&gt;'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As @abarnert mentioned in a comment, using <code>shell=True</code> is generally to be avoided unless you don't have any choice (e.g. you absolutely require the system shell's expansion functionality). As <a href="http://docs.python.org/2/library/subprocess.html?highlight=subprocess#frequently-used-arguments" rel="nofollow">this section of the subprocess documentation</a> explains, use of the shell introduces various serious security issues where any of the command (including arguments) is obtained from an external source (e.g. a form submission). In addition to these issues, you're also trusting that the shell is correctly configured on the host system, which is not always a safe assumption for special users such as those used for web services. In addition to the security holes, it's also wasteful to fork an extra shell process just to execute a command which can be executed directly. Also, you're probably hurting your portability by relying on a system shell, since different platforms will apply different expansions and rules to the command string.</p>
<p>When using <code>subprocess</code> it's best to pass commands as a list of arguments rather than a single string, and this becomes particularly important when using <code>shell=False</code>. It may not be required on all platforms, but it certainly is on Linux and hence keeps your code more portable. In additional, splitting the arguments yourself avoids possible mishaps forgetting to escape or quote arguments to the shell.</p>
<p>Also, @abarbert has correctly explained that you won't necessarily have the <code>PATH</code> correctly set up in a CGI environment so it's best practice to reference everything via absolute path names. Again, this is generally good practice for portability to different platforms and environments (though of course hard-coding the path to a binary already gets in the way of portability, but at least you can <em>minimise</em> the issue - who knows when you or someone else will need to port this code).</p>
<p>Taking this into account, your <code>ls</code> and <code>echo</code> examples would look like this:</p>
<pre><code>exit_status = subprocess.call(['/bin/ls'])
exit_status = subprocess.call(['/bin/echo', 'something'])
</code></pre>
<p>It's also somewhat confused by the fact that many shells treat <code>echo</code> as a builtin, which overrides the actual <code>echo</code> command - referencing it by absolute path (i.e. <code>/bin/echo</code>) forces it to use the actual command rather than the builtin.</p>
<p>When running as a CGI script the internal server error typically means you've had an uncaught Python exception. If you look in the log files for your webserver (assuming you have access to them) then you should find the full text of the exception, but this does vary from server to server. When running without <code>shell=True</code>, I suspect you're getting an <code>OSError</code> exception when it fails to find the executable to run. When you run with the shell, you won't get an exception - you'll just get output on standard error with the shell's error message. Again, this should be duplicated in the logs. If you do get an exception, I suspect it's due to the user you're running as not having a valid login shell specified - some configurations run scripts as a user with something like <code>/bin/false</code> as their login shell to avoid the account being abused. I'd expect a return code of <code>1</code> rather than <code>127</code> if this were the case.</p>
<p>In short, see what information has gone to your webserver's error logs and best practice is to avoid <code>shell=True</code> and make sure you specify all commands as lists of arguments rather than whitespace-delimited strings. If you can get some more information from the logs and post it here, we can update our answers to provide more specific help.</p>
<p>Finally, if at all possible I would avoid any code which uses <code>fork()</code> in a webserver, and this includes <code>subprocess</code>. Sometimes there's no way to avoid it, but certainly for simple things like <code>ls</code> you can use Python functions instead (<code>os.listdir()</code>). You're probably fine while you're running as a standard CGI script, but if you ever plan to port your code to a more efficient hosting environment (e.g. mod-wsgi, fastcgi) then you have to be quite careful spawning external processes because of the duplication of file descriptors and other resources which occurs. I'm not saying it can't be done safely, but it's a potential source of confusing bugs in the future so I really would avoid it if you possibly can. This is all not to mention the relative inefficiency of spawning an external process to handle a web request, which may matter if you plan your code to scale.</p>
</div>
<span class="comment-copy">First, why are you using <code>shell=True</code> in the first place? This is never a good idea on Unix if you don't need it, and that's especially true for a CGI.</span>
<span class="comment-copy">Second, exit status 127 usually means a "command not found" from the shell. The two most likely reasons this could happen are that the <code>httpd</code> or equivalent user can't run <code>ls</code> in its default shell, or that the CGI host configures things equivalently (has no <code>PATH</code>/a <code>PATH</code> without <code>/bin</code>, runs in a chroot jail that has the absolute minimum needed to run a web server, runs a special restricted shell that returns 127 for any command you try to subshell it with…). If you can <code>login</code>, <code>sudo</code>, etc. as that user, you can try out the shell (and run your script) and see what the problem is.</span>
<span class="comment-copy">Also see if <code>/bin/ls</code> (or <code>/usr/bin/ls</code> or whatever's appropriate on your system) works instead of <code>ls</code>, which would definitely narrow it down to a <code>PATH</code> problem.</span>
<span class="comment-copy">Thanks for your responses @abarnert! I removed the <code>shell=True</code> argument and now I get exit status <code>0</code> when I run it on the shell (just like before) and a white background (i.e. nothing printed) when I run it from a browser. The behaviour is exactly the same with <code>/bin/ls</code>. I'm still very confused.</span>
<span class="comment-copy">Have you tried the tests that I suggested? Can you <code>login foo</code>, <code>sudo -Ufoo /bin/ls</code> (you may have to su before that's allowed), etc.? Have you checked the webserver error logs (you may have to change the logging settings for your server) as suggested by Cartroo? Unless you do these things, we really can't help beyond throwing out different things that <i>could</i> go wrong one by one until we get lucky, which isn't a good way to debug a problem.</span>
<span class="comment-copy">This is mostly true, but one bit is misleading. The list-vs.-string thing is much more complex, and "never use a string" is really only true if on Unix and not using <code>shell=True</code>. But the details are complex and mostly irrelevant. I think it's simpler if you just reverse the order—explain why <code>shell=True</code> is bad, and then say "and now that you're using <code>shell=False</code> on Unix, you have to use a list of arguments", or hopefully something a bit better than that…</span>
<span class="comment-copy">Anyway, +1 for the explanation of the likely cause(s) of the second problem, now that he's solved the <code>PATH</code> thing by using an absolute path, and how to debug it using webserver logs.</span>
<span class="comment-copy">Yes, I was implicitly assuming a Unix-like OS because of the commands executed, but I should have made that clear. I think it's good practice to always recommend use of a list of arguments because I'm not aware of it <i>breaking</i> on any systems and hence it improves average portability with no detriment (except the trivial overhead of constructing a list instead of a string, which is negligable compared to the cost of spawning a process). I've updated my answer in an effort to explain the issues more clearly.</span>
<span class="comment-copy">When you've got a Windows command line that deals with the insanely broken Windows quoting rules, trying to figure out how to split it into a list that will cause <code>subprocess</code> to re-generate the same string you already had can be difficult (note that <a href="http://docs.python.org/3/library/subprocess.html#converting-an-argument-sequence-to-a-string-on-windows" rel="nofollow noreferrer">docs.python.org/3/library/…</a> is not the inverse of <code>shlex.split</code>), so… why do it? When you're writing cross-platform code to, e.g. run <code>./myhelper ./myinput.dat</code> and read its <code>stdout</code>, definitely always use a list… but for platform-specific code, maybe not.</span>
<span class="comment-copy">@abernert: I suppose it depends on your use-case. If you're accepting a complete command-line as input and the user expects the native platform quoting rules to hold, then I take your point. I would have imagined the most common case is that the programmer has a particular command they want to execute and already know the arguments they wish to supply, so quoting isn't an issue, however - they just want the command executed consistently on all their platforms (of which there may one or many). Using the list avoids all need for quoting, unless there are Windows quirks of which I'm unaware?</span>
