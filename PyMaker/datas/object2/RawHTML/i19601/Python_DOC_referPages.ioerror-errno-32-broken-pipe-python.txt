<div class="post-text" itemprop="text">
<p>I have a very simple Python 3 script:</p>
<pre><code>f1 = open('a.txt', 'r')
print(f1.readlines())
f2 = open('b.txt', 'r')
print(f2.readlines())
f3 = open('c.txt', 'r')
print(f3.readlines())
f4 = open('d.txt', 'r')
print(f4.readlines())
f1.close()
f2.close()
f3.close()
f4.close()
</code></pre>
<p>But it always says:</p>
<pre><code>IOError: [Errno 32] Broken pipe
</code></pre>
<p>I saw on the internet all the complicated ways to fix this, but I copied this code directly, so I think that there is something wrong with the code and not Python's SIGPIPE.</p>
<p>I am redirecting the output, so if the above script was named "open.py", then my command to run would be:</p>
<pre><code>open.py | othercommand
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I haven't reproduced the issue, but perhaps this method would solve it: (writing line by line to <code>stdout</code> rather than using <code>print</code>)</p>
<pre><code>import sys
with open('a.txt', 'r') as f1:
    for line in f1:
        sys.stdout.write(line)
</code></pre>
<hr/>
<p>You could catch the broken pipe? This writes the file to <code>stdout</code> line by line until the pipe is closed. </p>
<pre><code>import sys, errno
try:
    with open('a.txt', 'r') as f1:
        for line in f1:
            sys.stdout.write(line)
except IOError as e:
    if e.errno == errno.EPIPE:
        # Handle error
</code></pre>
<p>You also need to make sure that <code>othercommand</code> is reading from the pipe before it gets too big - <a href="https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer">https://unix.stackexchange.com/questions/11946/how-big-is-the-pipe-buffer</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is due to SIGPIPE handling. You can solve this problem using the following code:</p>
<pre><code>from signal import signal, SIGPIPE, SIG_DFL
signal(SIGPIPE,SIG_DFL) 
</code></pre>
<p><a href="http://newbebweb.blogspot.com/2012/02/python-head-ioerror-errno-32-broken.html" rel="noreferrer">See here</a> for background on this solution. Better answer <a href="https://stackoverflow.com/questions/34718208/catch-broken-pipe-in-python-2-and-python-3">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To bring <a href="https://stackoverflow.com/a/14208261/45375">Alex L.'s helpful answer</a>,  <a href="https://stackoverflow.com/a/16865106/45375">akhan's helpful answer</a>, and <a href="https://stackoverflow.com/a/14213673/45375">Blckknght's helpful answer</a> together with some additional information:</p>
<ul>
<li><p><strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Error-Codes" rel="noreferrer">Standard Unix signal <code>SIGPIPE</code></a> is sent to a process <em>writing</em> to a <a href="https://en.wikipedia.org/wiki/Anonymous_pipe" rel="noreferrer">pipe</a> when there's no process <em>reading</em> from the pipe (anymore).</strong></p>
<ul>
<li>This is not necessarily an <em>error</em> condition; some Unix utilities such as <code>head</code> <em>by design</em> stop reading prematurely from a pipe, once they've received enough data.</li>
</ul></li>
<li><p><strong>By default</strong> - i.e., <strong>if the writing process does not explicitly <em>trap</em> <code>SIGPIPE</code> - the writing process is simply <em>terminated</em>, and its exit code is set to <code>141</code></strong>, which is calculated as <code>128</code> (to signal termination by signal in general) + <code>13</code> (<code>SIGPIPE</code>'s specific signal <em>number</em>).</p></li>
<li><p>By design, however, <strong>Python <em>itself</em> traps <code>SIGPIPE</code></strong> and <strong>translates it into a Python <code>IOError</code></strong> instance with <code>errno</code> value <code>errno.EPIPE</code>, so that a Python script can catch it, if it so chooses - see <a href="https://stackoverflow.com/a/14208261/45375">Alex L.'s answer</a> for how to do that.</p></li>
<li><p><strong>If a Python <em>script</em> does <em>not</em> catch it</strong>, Python <strong>outputs error message <code>IOError: [Errno 32] Broken pipe</code></strong> and <strong>terminates the script with exit code <code>1</code></strong> - this is the symptom the OP saw.</p></li>
<li><p><strong>In many cases</strong> this is <strong>more disruptive than helpful</strong>, so <strong>reverting to the default behavior is desirable</strong>:</p>
<ul>
<li><p>Using the <strong><code>signal</code> module</strong> allows just that, as stated in <a href="https://stackoverflow.com/a/16865106/45375">akhan's answer</a>; <a href="https://docs.python.org/2/library/signal.html#signal.signal" rel="noreferrer"><code>signal.signal()</code></a> takes a signal to handle as the 1st argument and a handler as the 2nd; special handler value <code>SIG_DFL</code> represents the system's <em>default</em> behavior:</p>
<pre><code>from signal import signal, SIGPIPE, SIG_DFL
signal(SIGPIPE, SIG_DFL) 
</code></pre></li>
</ul></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>A "Broken Pipe" error occurs when you try to write to a pipe that has been closed on the other end. Since the code you've shown doesn't involve any pipes directly, I suspect you're doing something outside of Python to redirect the standard output of the Python interpreter to somewhere else. This could happen if you're running a script like this:</p>
<pre><code>python foo.py | someothercommand
</code></pre>
<p>The issue you have is that <code>someothercommand</code> is exiting without reading everything available on its standard input. This causes your write (via <code>print</code>) to fail at some point.</p>
<p>I was able to reproduce the error with the following command on a Linux system:</p>
<pre><code>python -c 'for i in range(1000): print i' | less
</code></pre>
<p>If I close the <code>less</code> pager without scrolling through all of its input (1000 lines), Python exits with the same <code>IOError</code> you have reported.</p>
</div>
<div class="post-text" itemprop="text">
<p>I feel obliged to point out that the method using</p>
<pre><code>signal(SIGPIPE, SIG_DFL) 
</code></pre>
<p>is indeed <strong>dangerous</strong> (as already suggested by David Bennet in the comments) and in my case led to platform-dependent funny business when combined with <code>multiprocessing.Manager</code> (because the standard library relies on BrokenPipeError being raised in several places). To make a long and painful story short, this is how I fixed it:</p>
<p>First, you need to catch the <code>IOError</code> (Python 2) or <code>BrokenPipeError</code> (Python 3). Depending on your program you can try to exit early at that point or just ignore the exception:</p>
<pre><code>from errno import EPIPE

try:
    broken_pipe_exception = BrokenPipeError
except NameError:  # Python 2
    broken_pipe_exception = IOError

try:
    YOUR CODE GOES HERE
except broken_pipe_exception as exc:
    if broken_pipe_exception == IOError:
        if exc.errno != EPIPE:
            raise
</code></pre>
<p>However, this isn't enough. Python 3 may still print a message like this:</p>
<pre><code>Exception ignored in: &lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;
BrokenPipeError: [Errno 32] Broken pipe
</code></pre>
<p>Unfortunately getting rid of that message is not straightforward, but I finally found <a href="http://bugs.python.org/issue11380">http://bugs.python.org/issue11380</a> where Robert Collins suggests this workaround that I turned into a decorator you can wrap your main function with (yes, that's some crazy indentation):</p>
<pre><code>from functools import wraps
from sys import exit, stderr, stdout
from traceback import print_exc


def suppress_broken_pipe_msg(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except SystemExit:
            raise
        except:
            print_exc()
            exit(1)
        finally:
            try:
                stdout.flush()
            finally:
                try:
                    stdout.close()
                finally:
                    try:
                        stderr.flush()
                    finally:
                        stderr.close()
    return wrapper


@suppress_broken_pipe_msg
def main():
    YOUR CODE GOES HERE
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can also occur if the read end of the output from your script dies prematurely</p>
<p>ie   open.py | otherCommand</p>
<p>if otherCommand exits   and open.py tries to write to stdout  </p>
<p>I had a bad gawk script that did this lovely to me.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this is not the "proper" way to do it, but if you are simply interested in getting rid of the error message, you could try this workaround:</p>
<pre><code>python your_python_code.py 2&gt; /dev/null | other_command
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Closes should be done in reverse order of the opens.</p>
</div>
<span class="comment-copy">For what line number?</span>
<span class="comment-copy">@squiguy line 2: <code>print(f1.readlines())</code></span>
<span class="comment-copy">You've got two IO operations occurring on line 2: a read from <code>a.txt</code> and a write to <code>stdout</code>.  Perhaps try splitting those onto separate lines so you can see which operation triggers the exception.  If <code>stdout</code> is a pipe and the read end has been closed, then that could account for the <code>EPIPE</code> error.</span>
<span class="comment-copy">I can reproduce this error on output (given the right conditions), so I suspect the <code>print</code> call is the culprit. @JOHANNES_NYÃ…TT, can you clarify how you're launching your Python script? Are you redirecting standard output somewhere?</span>
<span class="comment-copy">This is a possible duplicate of the following question: <a href="http://stackoverflow.com/questions/11423225/why-does-my-python3-script-balk-at-piping-its-output-to-head-or-tail-sys-module" title="why does my python3 script balk at piping its output to head or tail sys module">stackoverflow.com/questions/11423225/â€¦</a></span>
<span class="comment-copy">While this is good programming practice, I don't think it has anything to do with the broken pipe error the questioner is getting (which probably has to do with the <code>print</code> call, not with reading the files).</span>
<span class="comment-copy">@Blckknght I added a few questions and alternative methods and was hoping for some feedback from the author. If the problem is sending a large quantity of data from an open file directly to the print statement then perhaps one of the alternatives above would fix it.</span>
<span class="comment-copy">(The simplest solutions are often the best - unless there's a particular reason to load a whole file then print it, do it a different way)</span>
<span class="comment-copy">Awesome work in troubleshooting this! While I could take this answer for granted, I could appreciate this only after seeing how the other answers (and my own approach) paled in comparison to your answer.</span>
<span class="comment-copy">This is very dangerous, as I just discovered, because if you ever get a SIGPIPE on a socket (httplib or whatever), your program will just exit without warning or error.</span>
<span class="comment-copy">@DavidBennett, I am sure its application dependent and for your purposes the accepted answer is the right one. There is a much thorough Q&amp;A <a href="https://stackoverflow.com/questions/108183/how-to-prevent-sigpipes-or-handle-them-properly">here</a> for people to go through and make an informed decision. IMO, for command line tools, its probably best to ignore the pipe signal in most cases.</span>
<span class="comment-copy">Any way to do this only temporarily?</span>
<span class="comment-copy">@NateGlenn You can save the <a href="https://docs.python.org/2/library/signal.html#signal.getsignal" rel="nofollow noreferrer">existing handler</a> and restore it later.</span>
<span class="comment-copy">Could someone answer me why people are considering a blogspot article as a better source of truth than <a href="https://docs.python.org/3/library/signal.html#note-on-sigpipe" rel="nofollow noreferrer">official documentation</a> (hint: open the link to see how to fix the broken pipe error properly)? :)</span>
<span class="comment-copy">Yes, this is true, but how do I fix it?</span>
<span class="comment-copy">please let me know how to fix it.</span>
<span class="comment-copy">@JOHANNES_NYÃ…TT: It may work for small files because of the buffering provided by pipes on most Unix-like systems. If you can write the whole contents of the files into the buffer, it doesn't raise an error if the other program never reads that data. However, if the write blocks (because the buffer is full), then it will fail when the other program quits. To say again: What is the other command? We can't help you any more with only the Python code (since it's not the part that's doing the wrong thing).</span>
<span class="comment-copy">"That's because your pipe is probably only around 64kB - if you try to write too much to it and other process isn't reading it then it'll throw an error." Ref that comment I don't think it's true - the next write will simply block until the reader empties out [some of] the buffer by reading it.</span>
<span class="comment-copy">@Blckknght: Good info in general, but re "<i>fix</i> that: and "the part that's doing the <i>wrong</i> thing": a <code>SIGPIPE</code> signal does not necessarily indicate an <i>error</i> condition; some Unix utilities, notably <code>head</code>, <i>by design, during normal operation</i> close the pipe early, once they've read as much data as <i>they</i> needed.</span>
<span class="comment-copy">This didn't seem to fix it for me.</span>
<span class="comment-copy">It worked for me after I added except BrokenPipeError: pass in the supress_broken_pipe_msg function</span>
<span class="comment-copy">It's not about the process reading from the pipe <i>dying</i>, necessarily: some Unix utilities, notably <code>head</code>, <i>by design, during normal operation</i> close the pipe early, once they've read as much data as <i>they</i> needed. Most CLIs simply defer to the system for its default behavior: quietly terminating the reading process and reporting exit code <code>141</code> (which, in a shell, isn't readily apparent, because a pipeline's <i>last</i> command determines the overall exit code). <i>Python</i>'s default behavior, unfortunately, is to die <i>noisily</i>.</span>
<span class="comment-copy">While that is good practice in general, not doing is not a problem in itself and doesn't explain the OP's symptoms.</span>
