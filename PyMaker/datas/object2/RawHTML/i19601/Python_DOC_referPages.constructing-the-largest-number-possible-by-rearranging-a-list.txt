<div class="post-text" itemprop="text">
<p>Say I have an array of positive whole integers; I'd like to manipulate the order so that the concatenation of the resultant array is the largest number possible. For example <code>[97, 9, 13]</code> results in <code>99713</code>; <code>[9,1,95,17,5]</code> results in <code>9955171</code>. I'm not sure of an answer.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>sorted(x, cmp=lambda a, b: -1 if str(b)+str(a) &lt; str(a)+str(b) else 1)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Intuitively, we can see that a reverse sort of single digit numbers would lead to the higest number:</p>
<pre><code>&gt;&gt;&gt; ''.join(sorted(['1', '5', '2', '9'], reverse=True))
'9521'
</code></pre>
<p>so reverse sorting should work. The problem arises when there are multi-digit snippets in the input. Here, intuition again lets us order <code>9</code> before <code>95</code> and <code>17</code> before <code>1</code>, but why does that work? Again, if they had been the same length, it would have been clear how to sort them:</p>
<pre><code>95 &lt; 99
96 &lt; 97
14 &lt; 17
</code></pre>
<p>The trick then, is to 'extend' shorter numbers so they can be compared with the longer ones and can be sorted automatically, lexicographically. All you need to do, really, is to <em>repeat the snippet</em> to beyond the maximum length:</p>
<ul>
<li>comparing <code>9</code> and <code>95</code>: compare <code>999</code> and <code>9595</code> instead and thus <code>999</code> comes first.</li>
<li>comparing <code>1</code> and <code>17</code>: compare <code>111</code> and <code>1717</code> instead and thus <code>1717</code> comes first.</li>
<li>comparing <code>132</code> and <code>13</code>: compare <code>132132</code> and <code>1313</code> instead and thus <code>132132</code> comes first.</li>
<li>comparing <code>23</code> and <code>2341</code>: compare <code>232323</code> and <code>23412341</code> instead and thus <code>2341</code> comes first.</li>
</ul>
<p>This works because python only needs to compare the two snippets until they differ somewhere; and it's (repeating) matching prefixes that we need to skip when comparing two snippets to determine which order they need to be in to form a largest number.</p>
<p>You only need to repeat a snippet until it is longer than the longest snippet * 2 in the input to guarantee that you can find the first non-matching digit when comparing two snippets. </p>
<p>You can do this with a <code>key</code> argument to <code>sorted()</code>, but you need to determine the maximum length of the snippets first. Using that length, you can 'pad' all snippets in the sort key until they are longer than that maximum length:</p>
<pre><code>def largestpossible(snippets):
    snippets = [str(s) for s in snippets]
    mlen = max(len(s) for s in snippets) * 2  # double the length of the longest snippet
    return ''.join(sorted(snippets, reverse=True, key=lambda s: s*(mlen//len(s)+1)))
</code></pre>
<p>where <code>s*(mlen//len(s)+1)</code> pads the snippet with itself to be more than <code>mlen</code> in length.</p>
<p>This gives:</p>
<pre><code>&gt;&gt;&gt; combos = {
...     '12012011': [1201, 120, 1],
...     '87887': [87, 878],
...     '99713': [97, 9, 13],
...     '9955171': [9, 1, 95, 17, 5],
...     '99799713': [97, 9, 13, 979],
...     '10100': [100, 10],
...     '13213': [13, 132],
...     '8788717': [87, 17, 878],
...     '93621221': [936, 21, 212],
...     '11101110': [1, 1101, 110],
... }
&gt;&gt;&gt; def test(f):
...     for k,v in combos.items():
...         print '{} -&gt; {} ({})'.format(v, f(v), 'correct' if f(v) == k else 'incorrect, should be {}'.format(k))
... 
&gt;&gt;&gt; test(largestpossible)
[97, 9, 13] -&gt; 99713 (correct)
[1, 1101, 110] -&gt; 11101110 (correct)
[936, 21, 212] -&gt; 93621221 (correct)
[13, 132] -&gt; 13213 (correct)
[97, 9, 13, 979] -&gt; 99799713 (correct)
[87, 878] -&gt; 87887 (correct)
[1201, 120, 1] -&gt; 12012011 (correct)
[100, 10] -&gt; 10100 (correct)
[9, 1, 95, 17, 5] -&gt; 9955171 (correct)
[87, 17, 878] -&gt; 8788717 (correct)
</code></pre>
<p>Note that this solution is a) 3 lines short and b) works on Python 3 as well without having to resort to <code>functools.cmp_to_key()</code> and c) does not bruteforce the solution (which is what the <code>itertools.permutations</code> option does).</p>
</div>
<div class="post-text" itemprop="text">
<p>Hint one: you concatenate strings, not integers. 
Hint two: <code>itertools.permutations()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools
nums =  ["9", "97", "13"]
m = max(("".join(p) for p in itertools.permutations(nums)), key = int)
</code></pre>
<p>You can use itertools.permutations as hinted and use the key argument of the max function (which tells which function to apply to each element in order to decide the maximum) after you concat them with the join function.</p>
<p>It's easier to work with strings to begin with.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't like the brute force approach to this. It requires a massive amount of computation for large sets.</p>
<p>You can write your own comparison function for the <a href="http://docs.python.org/2/library/functions.html#sorted" rel="nofollow">sorted</a> builtin method, which will return a sorting parameter for any pair, based on any logic you put in the function.</p>
<p>Sample code:</p>
<pre><code>def compareInts(a,b):
    # create string representations
    sa = str(a)
    sb = str(b)

    # compare character by character, left to right
    # up to first inequality
    # if you hit the end of one str before the other, 
    # and all is equal up til then, continue to next step
    for i in xrange(min(len(sa), len(sb))):
        if sa[i] &gt; sb[i]:
            return 1
        elif sa[i] &lt; sb[i]:
            return -1

    # if we got here, they are both identical up to the length of the shorter
    # one.
    # this means we need to compare the shorter number again to the 
    # remainder of the longer
    # at this point we need to know which is shorter
    if len(sa) &gt; len(sb): # sa is longer, so slice it
        return compareInts(sa[len(sb):], sb)
    elif len(sa) &lt; len(sb): # sb is longer, slice it
        return compareInts(sa, sb[len(sa):])
    else:
        # both are the same length, and therefore equal, return 0
        return 0



def NumberFromList(numlist):
    return int(''.join('{}'.format(n) for n in numlist))

nums = [97, 9, 13, 979]
sortednums = sorted(nums, cmp = compareInts, reverse = True)
print nums # [97, 9, 13, 979]
print sortednums # [9, 979, 97, 13]
print NumberFromList(sortednums) # 99799713
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, there's always the brute force approach...</p>
<pre><code>from itertools import permutations
lst = [9, 1, 95, 17, 5]

max(int(''.join(str(x) for x in y)) for y in permutations(lst))
=&gt; 9955171
</code></pre>
<p>Or this, an adaptation of @Zah's answer that receives a list of integers and returns an integer, as specified in the question:</p>
<pre><code>int(max((''.join(y) for y in permutations(str(x) for x in lst)), key=int))
=&gt; 9955171
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with some clever sorting.</p>
<p>If two strings are the same length, choose the larger of the two to come first. Easy.</p>
<p>If they're not the same length, figure out what would be the result if the best possible combination were appended to the shorter one. Since everything that follows the shorter one must be equal to or less than it, you can determine this by appending the short one to itself until it's the same size as the longer one. Once they're the same length you do a direct comparison as before.</p>
<p>If the second comparison is equal, you've proven that the shorter string can't possibly be better than the longer one. Depending on what it's paired with it could still come out worse, so the longer one should come first.</p>
<pre><code>def compare(s1, s2):
    if len(s1) == len(s2):
        return -1 if s1 &gt; s2 else int(s2 &gt; s1)
    s1x, s2x = s1, s2
    m = max(len(s1), len(s2))
    while len(s1x) &lt; m:
        s1x = s1x + s1
    s1x = s1x[:m]
    while len(s2x) &lt; m:
        s2x = s2x + s2
    s2x = s2x[:m]
    return -1 if s1x &gt; s2x or (s1x == s2x and len(s1) &gt; len(s2)) else 1

def solve_puzzle(seq):
    return ''.join(sorted([str(x) for x in seq], cmp=compare))

&gt;&gt;&gt; solve_puzzle([9, 1, 95, 17, 5])
'9955171'
&gt;&gt;&gt; solve_puzzle([97, 9, 13])
'99713'
&gt;&gt;&gt; solve_puzzle([936, 21, 212])
'93621221'
&gt;&gt;&gt; solve_puzzle([87, 17, 878])
'8788717'
&gt;&gt;&gt; solve_puzzle([97, 9, 13, 979])
'99799713'
</code></pre>
<p>This should be much more efficient than running through all the permutations.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools
def largestInt(a):
    b = list(itertools.permutations(a))
    c = []
    x = ""
    for i in xrange(len(b)):
        c.append(x.join(map(str, b[i])))
    return max(c)
</code></pre>
</div>
<span class="comment-copy">This appears to work, and is going to be much faster than exhaustive permutations for large lists.</span>
<span class="comment-copy">Yup, this works, but like other <code>cmp</code> solutions, won't work on Python 3.</span>
<span class="comment-copy">(unless you use <a href="http://docs.python.org/3/library/functools.html#functools.cmp_to_key" rel="nofollow noreferrer"><code>functools.cmp_to_key()</code></a> of course, which cheats).</span>
<span class="comment-copy">This answer is so simple yet so effective. Can you give some insight into how you arrived at it?</span>
<span class="comment-copy">@MarkRansom first of all we have to clarify that this problem is about finding the lexicographically largest string; I take that the mention of integers is purely because the question has been used in interviews in some famous companies and maybe they thought it would be nice to not give a hint so fast. The dual problem, lexic. minimal string, is an exact instance of what is known as Lyndon words, which deals with the total ordering over the closure of a given alphabet. More interesting and detailed information about this can be found in the first part of "Combinatorics of words", J. Karhumäki</span>
<span class="comment-copy"><code>[101, 10110]</code>.  I don't get the "pads the snippet with itself" idea -- if the padding introduced by itself is greater than that of another term with the same prefix, ISTM the comparison will be led astray.</span>
<span class="comment-copy">@DSM: It's all about matching prefixes; <code>101</code> is a matching prefix, and when you repeat these patterns far enough, you'll find where they diverge. For your counter example, you found a way to defeat my limitation to repeating past <code>mlen</code>, as <code>101101</code> is still a prefix to <code>1011010110</code> while repeating the shorter pattern 3 times would show the difference: <code>101101101</code> is sortable against <code>1011010110</code>. So my analysis on how far I need to repeat the elements needs rethinking. I suspect I need to <i>double</i> mlen here, then use that as an upper bound.</span>
<span class="comment-copy">@DSM: Doubling <code>mlen</code> indeed can take care of this; you do need to repeat the longest pattern to find how it starts to repeat; joining <code>787</code> and <code>78</code> either forms <code>778</code> or <code>787</code> somewhere when concatenating and by repeating <i>both</i> patterns to a minimum length you can generating both forms for the <code>key</code> method and pick the larger one.</span>
<span class="comment-copy">@DSM: And it doesn't matter that the key is longer now; it's the prefix match that counts; the <i>next non-matching digit</i> determines the sort. If you are matching patterns that are exact repeats (<code>234</code> and <code>234324</code>) the order no longer matters, the result is the same for <code>[234, 234234]</code> and <code>[234234, 234]</code>.</span>
<span class="comment-copy">FWIW I can't seem to break the current version with any test in my suite, which tries five or six different approaches to find counterexamples..</span>
<span class="comment-copy">But don't sort them as numbers.</span>
<span class="comment-copy">All it needs is a lexicographic ordering where <code>9 &lt; 8 &lt; 7 ... &lt; 1 &lt; 0</code></span>
<span class="comment-copy">Please show a sorting solution that gives the same answer as <code>max( int(''.join(x)) for x in itertools.permutations( str(x) for x in seq ) )</code>.</span>
<span class="comment-copy">@ypercube: Unfortunately, it's not so simple. Not with the variable length of the parts. <code>9</code> should come before <code>95</code>, but <code>17</code> should come before <code>1</code>. I believe that a sorting order on the first digit, then a scoring for the following digits (higher, missing, lower) would work, but not 100% certain.</span>
<span class="comment-copy">@MartijnPieters Oh, you are right. It's more complicated.</span>
<span class="comment-copy">Appears to work.</span>
<span class="comment-copy">Fails for e.g. [936, 21, 212].</span>
<span class="comment-copy">And for <code>[87, 17, 878]</code> and <code>[97, 9, 13, 979]</code>.</span>
<span class="comment-copy">@RussellBorogove and MartijnPieters, as I said I didn't have the ties worked out and both of your examples have that case. I have a fix in mind, just have to test it now.</span>
<span class="comment-copy">That covers all the test cases I have so far.</span>
<span class="comment-copy">New one: <code>[1201, 120, 1]</code>, yours and mine both fail that one.</span>
