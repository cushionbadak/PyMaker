<div class="post-text" itemprop="text">
<p>I am working on a graph library in Python and I am defining my vetex this way:</p>
<pre><code>class Vertex:
def __init__(self,key,value):
    self._key = key
    self._value = value

@property
def key(self):
    return self._key

@key.setter
def key(self,newKey):
    self._key = newKey

@property
def value(self):
    return self._value

@value.setter
def value(self,newValue):
    self.value = newValue

def _testConsistency(self,other):
    if type(self) != type(other):
        raise Exception("Need two vertexes here!")

def __lt__(self,other):
    _testConsistency(other)
    if self.index &lt;= other.index:
        return True
    return False
......
</code></pre>
<p>Do I really have to define __lt__,__eq__,__ne__....all by my self? It is so verbose. Is there simpler way I can get around this?
Cheers.
Please dont use __cmp__ since it will be away in python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/functools.html#functools.total_ordering" rel="nofollow">functools.total_ordering</a> can help you out here.  It's meant to be a class decorator.  You define one of <code>__lt__()</code>, <code>__le__()</code>, <code>__gt__()</code>, or <code>__ge__()</code> <strong>AND</strong> <code>__eq__</code> and it fills in the rest.</p>
<p>As a side note:</p>
<p>Instead of writing this</p>
<pre><code>if self.index &lt;= other.index:
    return True
return False
</code></pre>
<p>write this:</p>
<pre><code>return self.index &lt;= other.index
</code></pre>
<p>It's cleaner that way. :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="http://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow"><code>functools.total_ordering</code></a>, you only need to define one of the equality operators and one of the ordering operators. In Python &lt; 3.2, you're out of luck, <em>something</em> has to define these operators as individual methods. Though you may be able to save some code by writing a simpler version of <code>total_ordering</code> yourself, if you need it in several places.</p>
</div>
<span class="comment-copy">Why the properties? Why not just use regular attributes?</span>
<span class="comment-copy">Umm @delnan <a href="http://stackoverflow.com/questions/6618002/python-property-versus-getters-and-setters" title="python property versus getters and setters">stackoverflow.com/questions/6618002/â€¦</a> this thread may help you</span>
<span class="comment-copy">I know perfectly well how <code>property</code> works and why it's good. But it's still at least six lines more than just using an attribute (<code>self.key = ...</code> in <code>__init__</code>).</span>
<span class="comment-copy">I think that delnan's point is that you can define <code>key</code> and <code>value</code> as regular attributes (no need for the <code>_</code>) and then you don't need the properties.  If you ever decide you <i>need</i> a property, then you can adjust the code and it will still be backward compatable.</span>
<span class="comment-copy">+1 to delnan and mgilson's points, it's very bad form to define getters and setters, even with the property decorator, until you actually need them.</span>
<span class="comment-copy">Do I have to import anything to use this? I got error using @total_ordering. Thanks for your answer.</span>
<span class="comment-copy">Nevermind I figured it out myself.</span>
