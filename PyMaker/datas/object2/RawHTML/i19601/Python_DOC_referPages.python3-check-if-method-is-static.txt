<div class="post-text" itemprop="text">
<p>Simmilar question (related with Python2: <a href="https://stackoverflow.com/questions/8727059/python-check-if-method-is-static">Python: check if method is static</a>)</p>
<p>Lets concider following class definition:</p>
<pre><code>class A:
  def f(self):
    return 'this is f'

  @staticmethod
  def g():
    return 'this is g'
</code></pre>
<p>In Python 3 there is no <code>instancemethod</code> anymore, everything is function, so the answer related to Python 2 will not work anymore.</p>
<p>As I told, everything is function, so we can call <code>A.f(0)</code>, but of course we cannot call <code>A.f()</code> (argument missmatch). But if we make an instance <code>a=A()</code> and we call <code>a.f()</code> Python passes to the function <code>A.f</code> the <code>self</code> as first argument. Calling <code>a.g()</code> prevents from sending it or captures the <code>self</code> - so there have to be a way to test if this is staticmethod or not.</p>
<p>So can we check in Python3 if a method was declared as <code>static</code> or not?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class A:
  def f(self):
    return 'this is f'

  @staticmethod
  def g():
    return 'this is g'
print(type(A.__dict__['g']))
print(type(A.g))

&lt;class 'staticmethod'&gt;
&lt;class 'function'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I needed this solution and wrote the following based on the answer from @root</p>
<pre><code>def is_method_static(cls, method_name):
    # http://stackoverflow.com/questions/14187973/python3-check-if-method-is-static
    for c in cls.mro():
        if method_name in c.__dict__:
            return isinstance(c.__dict__[method_name], staticmethod)
    raise RuntimeError("Unable to find %s in %s" % (method_name, cls.__name__))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For Python 3.2 or newer, use <a href="https://docs.python.org/3/library/inspect.html#inspect.getattr_static" rel="nofollow noreferrer"><code>inspect.getattr_static()</code></a> to retrieve the attribute without invoking the descriptor protocol:</p>
<blockquote>
<p>Retrieve attributes without triggering dynamic lookup via the descriptor protocol, <code>__getattr__()</code> or <code>__getattribute__()</code>.</p>
</blockquote>
<p>Use <code>isinstance(..., staticmethod)</code> on the result:</p>
<pre><code>&gt;&gt;&gt; from inspect import getattr_static
&gt;&gt;&gt; isinstance(getattr_static(A, 'g'), staticmethod)
True
</code></pre>
<p>The function can handle both instances and classes, and will scan the full class hierarchy for you:</p>
<pre><code>&gt;&gt;&gt; class B(A): pass
...
&gt;&gt;&gt; isinstance(getattr_static(B, 'g'), staticmethod)  # inherited
True
&gt;&gt;&gt; isinstance(getattr_static(B(), 'g'), staticmethod)  # instance, inherited
True
</code></pre>
</div>
<span class="comment-copy">Can I ask why you're trying to do this?</span>
<span class="comment-copy">of course, I'm making my own plugin framework and I want to inspect some interface declarations and I would love to know if something was declared as staticmethod or not :)</span>
<span class="comment-copy">great! Could you please explain also why <code>A.__dict__['g']</code> gives something else than <code>A.g</code>?</span>
<span class="comment-copy"><code>A.__dict__['g']</code> is different from <code>A.g</code> because functions are <a href="http://docs.python.org/2/reference/datamodel.html#descriptors" rel="nofollow noreferrer">descriptors</a>. Function objects are descriptors because they define a <code>__get__</code> method, which is invoked by magic when the object is accessed using dot notation (like <code>A.f</code>). The descriptor protocol is how (for example) a <i>function</i> gets transformed into a <i>bound method</i> when called on an instance. Going through the <code>__dict__</code>, rather than using dot notation, bypasses the descriptor protocol.</span>
<span class="comment-copy">This will only work for static methods that aren't inherited. You can use <code>inspect.getattr_static</code> instead of directly accessing <code>__dict__</code> if you want to support inherited static methods.</span>
<span class="comment-copy">Thanks, getattr_static is new in 3.2.  My code runs in both Python2 and Python3</span>
