<div class="post-text" itemprop="text">
<p>I don't understand how <code>__reduce__</code> function exactly works in case of <code>pickle</code> module in Python.</p>
<p>Suppose that I have the following class:</p>
<pre><code>class Foo(object):
  def __init__(self, file_name = 'file.txt'):
    self.file_name = file_name
    self.f = open(self.file_name, 'w')
</code></pre>
<p>It can't be pickled because <code>pickle</code> module doesn't know how to encode file handle:</p>
<pre><code>foo = Foo()
print(pickle.dumps(foo))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>TypeError: can't pickle file objects
</code></pre>
<p>But if I add the <code>__reduce__</code> function it successfully encodes:</p>
<pre><code>import pickle

class Foo(object):
  def __init__(self, file_name = 'file.txt'):
    self.file_name = file_name
    self.f = open(self.file_name, 'w')

  def __reduce__(self):
    return (self.__class__, (self.file_name, ))

foo = Foo()
print(pickle.dumps(foo))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>c__main__
Foo
p0
(S'file.txt'
p1
tp2
Rp3
.
</code></pre>
<p>Am I right that the <code>__reduce__</code> function simply returns "instructions" for the deconstructor to re-create the original object if the <code>pickle.dumps</code> call failed?</p>
<p>It is unclear for me from the documentation.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're right. The <code>__reduce__</code> method should return hints how to reconstruct (unpickle) the object in case it cannot be pickled automatically. It may contain an object reference and parameters with which it will be called to create an initial version of the object, object's state, etc.</p>
<p>From the <a href="https://docs.python.org/3/library/pickle.html#object.__reduce__" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>If a string is returned, the string should be interpreted as the name of a global variable. It should be the object’s local name relative to its module; the pickle module searches the module namespace to determine the object’s module. This behaviour is typically useful for singletons.</p>
<p>When a tuple is returned, it must be between two and five items long. Optional items can either be omitted, or None can be provided as their value. The semantics of each item are in order:</p>
<ul>
<li>A callable object that will be called to create the initial version of the object.</li>
<li>A tuple of arguments for the callable object. An empty tuple must be given if the callable does not accept any argument.</li>
<li>Optionally, the object’s state, which will be passed to the object’s <code>__setstate__()</code> method as previously described. If the object has no such method then, the value must be a dictionary and it will be added to the object’s <code>__dict__</code> attribute.</li>
<li>Optionally, an iterator (and not a sequence) yielding successive items. These items will be appended to the object either using <code>obj.append(item)</code> or, in batch, using <code>obj.extend(list_of_items)</code>. This is primarily used for list subclasses, but may be used by other classes as long as they have <code>append()</code> and <code>extend()</code> methods with the appropriate signature. (Whether <code>append()</code> or <code>extend()</code> is used depends on which pickle protocol version is used as well as the number of items to append, so both must be supported.)</li>
<li>Optionally, an iterator (not a sequence) yielding successive key-value pairs. These items will be stored to the object using <code>obj[key] = value</code>. This is primarily used for dictionary subclasses, but may be used by other classes as long as they implement <code>__setitem__()</code>.</li>
</ul>
</blockquote>
</div>
