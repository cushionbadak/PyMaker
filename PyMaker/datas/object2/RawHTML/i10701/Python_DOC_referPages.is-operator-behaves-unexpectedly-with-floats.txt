<div class="post-text" itemprop="text">
<p>I came across a confusing problem when unit testing a module. The module is actually casting values and I want to compare this values.</p>
<p>There is a difference in comparison with <code>==</code> and <code>is</code> (partly, I'm beware of the difference)</p>
<pre><code>&gt;&gt;&gt; 0.0 is 0.0
True   # as expected
&gt;&gt;&gt; float(0.0) is 0.0
True   # as expected
</code></pre>
<p>As expected till now, but here is my "problem":</p>
<pre><code>&gt;&gt;&gt; float(0) is 0.0
False
&gt;&gt;&gt; float(0) is float(0)
False
</code></pre>
<p>Why? At least the last one is really confusing to me. The internal representation of <code>float(0)</code> and <code>float(0.0)</code> should be equal. Comparison with <code>==</code> is working as expected.</p>
</div>
<div class="post-text" itemprop="text">
<p>This has to do with how <code>is</code> works. It checks for references instead of value. It returns <code>True</code> if either argument is assigned to the same object.</p>
<p>In this case, they are different instances; <code>float(0)</code> and <code>float(0)</code> have the same value <code>==</code>, but are distinct entities as far as Python is concerned. CPython implementation also caches integers as singleton objects in this range -&gt; <strong>[x | x ∈ ℤ ∧ -5 ≤ x ≤ 256 ]</strong>:</p>
<pre><code>&gt;&gt;&gt; 0.0 is 0.0
True
&gt;&gt;&gt; float(0) is float(0)  # Not the same reference, unique instances.
False
</code></pre>
<p>In this example we can demonstrate the integer <em>caching principle</em>:</p>
<pre><code>&gt;&gt;&gt; a = 256
&gt;&gt;&gt; b = 256
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; a = 257
&gt;&gt;&gt; b = 257
&gt;&gt;&gt; a is b
False
</code></pre>
<p>Now, if floats are passed to <code>float()</code>, the float literal is simply returned (<em>short-circuited</em>), as in the same reference is used, as there's no need to instantiate a new float from an existing float:</p>
<pre><code>&gt;&gt;&gt; 0.0 is 0.0
True
&gt;&gt;&gt; float(0.0) is float(0.0)
True
</code></pre>
<p>This can be demonstrated further by using <code>int()</code> also:</p>
<pre><code>&gt;&gt;&gt; int(256.0) is int(256.0)  # Same reference, cached.
True
&gt;&gt;&gt; int(257.0) is int(257.0)  # Different references are returned, not cached.
False
&gt;&gt;&gt; 257 is 257  # Same reference.
True
&gt;&gt;&gt; 257.0 is 257.0  # Same reference. As @Martijn Pieters pointed out.
True
</code></pre>
<p>However, the results of <code>is</code> are also dependant on the scope it is being executed in (<em>beyond the span of this question/explanation</em>), please refer to user: <strong>@<a href="https://stackoverflow.com/users/4952130/jim">Jim</a></strong>'s fantastic explanation on <a href="https://stackoverflow.com/questions/34147515/is-operator-returns-different-results-on-integers/34147516#34147516">code objects</a>. Even python's doc includes a section on this behavior:</p>
<ul>
<li><a href="https://docs.python.org/2/reference/expressions.html#id16" rel="nofollow noreferrer">5.9 Comparisons</a></li>
</ul>
<blockquote>
<p><strong>[7]</strong> 
  Due to automatic garbage-collection, free lists, and the dynamic nature of descriptors, you may notice seemingly unusual behaviour in certain uses of the <code>is</code> operator, like those involving comparisons between instance methods, or constants. Check their documentation for more info.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>If a <code>float</code> object is supplied to <code>float()</code>, <em>CPython</em>* just returns it without making a new object. </p>
<p>This can be seen in <a href="https://github.com/python/cpython/blob/954b23e8571dfe4ea94a03fde134f289f9845f2c/Objects/abstract.c#L1348" rel="nofollow noreferrer"><code>PyNumber_Float</code></a> (which is eventually called from <a href="https://github.com/python/cpython/blob/master/Objects/floatobject.c#L1550" rel="nofollow noreferrer"><code>float_new</code></a>) where the object <code>o</code> passed in is checked with <a href="https://docs.python.org/3/c-api/float.html#c.PyFloat_CheckExact" rel="nofollow noreferrer"><code>PyFloat_CheckExact</code></a>; if <code>True</code>, it just increases its reference count and returns it:</p>
<pre><code>if (PyFloat_CheckExact(o)) {
    Py_INCREF(o);
    return o;
}
</code></pre>
<p>As a result, the <code>id</code> of the object stays the same. So the expression </p>
<pre><code>&gt;&gt;&gt; float(0.0) is float(0.0) 
</code></pre>
<p>reduces to:</p>
<pre><code>&gt;&gt;&gt; 0.0 is 0.0
</code></pre>
<p>But why does that equal <code>True</code>? Well, <code>CPython</code> has some <em>small</em> optimizations. </p>
<p>In this case, it uses the same object for the two occurrences of <code>0.0</code> in your command because they are part of <a href="https://stackoverflow.com/a/34147516/4952130"><em>the same <code>code</code> object</em></a> (short disclaimer: they're on the same logical line); so the <code>is</code> test will succeed.</p>
<p>This can be further corroborated if you execute <code>float(0.0)</code> in separate lines (or, delimited by <code>;</code>) and <em>then</em> check for identity:</p>
<pre><code>a = float(0.0); b = float(0.0) # Python compiles these separately
a is b # False 
</code></pre>
<p>On the other hand, if an <code>int</code> (or a <code>str</code>) is supplied, CPython will create a <em>new</em> <code>float</code> object from it and return that. For this, it uses <a href="https://docs.python.org/3/c-api/float.html#c.PyFloat_FromDouble" rel="nofollow noreferrer"><code>PyFloat_FromDouble</code></a> and <a href="https://docs.python.org/3/c-api/float.html#c.PyFloat_FromString" rel="nofollow noreferrer"><code>PyFloat_FromString</code></a> respectively. </p>
<p>The effect is that the returned objects differ in <code>id</code>s (which used to check identities with <code>is</code>):</p>
<pre><code># Python uses the same object representing 0 to the calls to float
# but float returns new float objects when supplied with ints
# Thereby, the result will be False
float(0) is float(0) 
</code></pre>
<hr/>
<p><sup><strong>*Note:</strong> All previous mentioned behavior applies for the implementation of python in <code>C</code> i.e <code>CPython</code>. Other implementations might exhibit different behavior. In short, <em>don't depend on it</em>.</sup></p>
</div>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python" title="is there a difference between and is in python">stackoverflow.com/questions/132988/…</a></span>
<span class="comment-copy">Your question deserves an answer, but if you came across this problem in real code, the code is probably erroneous and should be fixed. There is (almost) no reason to test reference identity between floats in such a way.</span>
<span class="comment-copy">The strange thing is, that although I can reproduce this, all of <code>id(0.0)</code>, <code>id(float(0.0))</code> and <code>id(float(0))</code> return the same value. ... That is, the value is the same if I execute those one after the other in the interactive shell, but if I do <code>id(float(0.0)), id(float(0))</code> (as a tuple) then the ids differ. Any explanation?</span>
<span class="comment-copy">@Elazar: Thx for adding cpython tag as it seems very cpython related and nothing you should depend on (as you already mentioned)</span>
<span class="comment-copy">@tobias_k: two reasons: immutable literals in code are stored as constants with the code object (so <code>0.0 is 0.0</code> produces just one object that is reused), Python reuses memory (so <code>id(0.0)</code> followed by another <code>id(someobject)</code> could easily produce the same id, since the previous one has been garbage collected) and producing a tuple can't re-use memory locations since you still need <i>all</i> objects to be part of that tuple.</span>
<span class="comment-copy"><code>float(17.0) is float(17.0)</code> returns <code>True</code> but <code>float(17.0) is float('17.0')</code> returns <code>False</code> -&gt; is <code>float( some_value )</code> just returning the original float so no new instance is made (in case some_value is a float...)?</span>
<span class="comment-copy">@Jim answered this</span>
<span class="comment-copy">CPython doesn't cache floats. You're seeing a combination of constant folding and the <code>float</code> constructor passing floats through directly for the cases where <code>is</code> gives <code>True</code>.</span>
<span class="comment-copy"><i>CPython implementation also caches integers/floats as singleton objects in this range -&gt; [x &gt;= -5 | x &lt;= 256 ]</i>. No, only <code>int</code> objects are interned. What is happening here is that the <i>literals</i> are stored as constants with the code object, and there is no point in storing two <code>0.0</code> values in the same code object constants array.</span>
<span class="comment-copy">Try out <code>compile('0.0 is 0.0', '', 'exec').co_consts</code>; you'll find <i>one</i> <code>0.0</code> object, and <code>None</code>.</span>
<span class="comment-copy">Thx for your answer with your details altough I will accept mrdomoboto's answer as correct (I hate this hard decisions...)</span>
<span class="comment-copy">I added your part on code objects as a footnote (great explanation btw!).</span>
