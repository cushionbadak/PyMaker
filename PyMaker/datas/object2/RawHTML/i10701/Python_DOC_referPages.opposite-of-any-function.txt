<div class="post-text" itemprop="text">
<p>The Python built-in function <code>any(iterable)</code> can help to quickly check if any <code>bool(element)</code> is <code>True</code> in a iterable type.</p>
<pre><code>&gt;&gt;&gt; l = [None, False, 0]
&gt;&gt;&gt; any(l)
False
&gt;&gt;&gt; l = [None, 1, 0]
&gt;&gt;&gt; any(l)
True
</code></pre>
<p>But is there an elegant way or function in Python that could achieve the opposite effect of <code>any(iterable)</code>? That is, if any <code>bool(element) is False</code> then return <code>True</code>, like the following example:</p>
<pre><code>&gt;&gt;&gt; l = [True, False, True]
&gt;&gt;&gt; any_false(l)
&gt;&gt;&gt; True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is also the <code>all</code> function which does the opposite of what you want, it returns <code>True</code> if all are <code>True</code> and <code>False</code> if any are <code>False</code>. Therefore you can just do:</p>
<pre><code>not all(l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Write a generator expression which tests your custom condition. You're not bound to only the default <em>truthiness</em> test:</p>
<pre><code>any(not i for i in l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, the implementation of <code>any</code> is <a href="https://docs.python.org/3/library/functions.html#any"><em>equivalent</em></a> to:</p>
<pre><code>def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
</code></pre>
<p>So, just switch the condition from <code>if element</code> to <code>if not element</code>:</p>
<pre><code>def reverse_any(iterable):
    for element in iterable:
        if not element:
            return True
    return False
</code></pre>
<p>Yes, <em>of course</em> this doesn't leverage the speed of the built-ins <code>any</code> or <code>all</code> like the other answers do, but it's a nice readable alternative.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do:</p>
<pre><code>&gt;&gt;&gt; l = [True, False, True]
&gt;&gt;&gt; False in map(bool, l)
True
</code></pre>
<p>Recall that <code>map</code> in Python 3 is a generator. For Python 2, you probably want to use <code>imap</code> </p>
<hr/>
<p>Mea Culpa: After timing these, the method I offered is hands down <strong>the slowest</strong></p>
<p>The fastest is <code>not all(l)</code> or <code>not next(filterfalse(bool, it), True)</code> which is just a silly itertools variant. Use Jack Aidleys <a href="https://stackoverflow.com/a/38869246/298607">solution</a>.</p>
<p>Timing code:</p>
<pre><code>from itertools import filterfalse

def af1(it):
    return not all(it)

def af2(it):
    return any(not i for i in it)   

def af3(iterable):
    for element in iterable:
        if not element:
            return True
    return False    

def af4(it):
    return False in map(bool, it)   

def af5(it):
    return not next(filterfalse(bool, it), True)    

if __name__=='__main__':
    import timeit   
    for i, l in enumerate([[True]*1000+[False]+[True]*999, # False in the middle
                           [False]*2000, # all False
                            [True]*2000], # all True
                            start=1): 
        print("case:", i)
        for f in (af1, af2, af3, af4, af5):
            print("   ",f.__name__, timeit.timeit("f(l)", setup="from __main__ import f, l", number=100000), f(l) )
</code></pre>
<p>Results:</p>
<pre><code>case: 1
    af1 0.45357259700540453 True
    af2 4.538436588976765 True
    af3 1.2491040650056675 True
    af4 8.935278153978288 True
    af5 0.4685744970047381 True
case: 2
    af1 0.016299808979965746 True
    af2 0.04787631600629538 True
    af3 0.015038023004308343 True
    af4 0.03326922300038859 True
    af5 0.029870904982089996 True
case: 3
    af1 0.8545824179891497 False
    af2 8.786235476000002 False
    af3 2.448748088994762 False
    af4 17.90895140200155 False
    af5 0.9152941330103204 False
</code></pre>
</div>
<span class="comment-copy">Your question was correctly answered already by jack Aidley. You may want to check <a href="https://en.wikipedia.org/wiki/De_Morgan's_laws" rel="nofollow noreferrer">en.wikipedia.org/wiki/De_Morgan's_laws</a> for the theory behind it.</span>
<span class="comment-copy">Both JackAidley's and deceze's answer can be helpful depending on your problem. Note that "any element is falsy" isn't the same as "no element is truthy" - they have different answers for the empty array.</span>
<span class="comment-copy">"<i>notice that <code>all</code> returns <code>True</code> on empty iterable</i>" - <a href="https://en.wikipedia.org/wiki/Vacuous_truth" rel="nofollow noreferrer">of course it does</a>. Did you expect otherwise?</span>
<span class="comment-copy">@Bergi Nope, I just want to notice some flash people this interesting feature. Anything wrong with my word?</span>
<span class="comment-copy">@EkeymeMo there's no need for a "conclusion" section, this is why I rolled-back your edits. What you found best is indicated by the accepted answer. What the community found best is indicated by the vote count. (And the community highlighted that Jack Aidley's and Deceze's answers are indeed best).</span>
<span class="comment-copy">Not sure what OP wants if iterable is empty but it's worth noting, <code>all</code> returns True on empty iterable.</span>
<span class="comment-copy">@Lafexlos Good point, it's always worth considering the end points. I would guess that <code>False</code> for <code>[]</code> is the correct answer; which this code give but the OP would have to specify.</span>
<span class="comment-copy">For <code>all(...)</code> you can always add <code>True</code> to the argument list without changing the output. <code>True</code> is a "neutral element" (just like 0 for addition, 1 for multiplication are neutral elements). That's why empty <code>all()</code> returns <code>True</code>. For <code>any()</code> the neutral element is <code>False</code>.</span>
<span class="comment-copy">+1 A little knowledge of mathematical logic can save a lot of time in the long run: <code>∃x: ¬x</code> is equivalent to <code>¬(∀x: x)</code>.  See <a href="https://en.wikipedia.org/wiki/Existential_quantification#Negation" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">Also <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" rel="nofollow noreferrer">en.wikipedia.org/wiki/De_Morgan%27s_laws</a></span>
<span class="comment-copy">Yeah, might be <code>any(bool(i) == False for i in l)</code> is better. Right? <code>None == False</code> is <code>False</code>, but I don't want that. <code>bool(None) == False</code> is <code>True</code></span>
<span class="comment-copy">In that case <code>not i for i in l</code> would probably be best.</span>
<span class="comment-copy">@EkeymeMo Avoid using <code>==</code> to compare against booleans. Just use the bare value eg. <code>if value: ...</code>. However, if you absolutely must check if an object is a boolean rather than a truthful value, use <code>is</code>. Otherwise you can get unexpected results -- eg. <code>1 == True</code> is true, but <code>2 == True</code> is false.</span>
<span class="comment-copy">I think this is a better approach than mine, as it is more generally applicable.</span>
<span class="comment-copy">This is significantly slower than <code>not all(l)</code></span>
<span class="comment-copy">@JackAidley <i>Of course it is</i>, I never made any assertions otherwise. I just added an alternative. Remember, <code>any</code> and <code>all</code> are generally mystifying to new users, looking at their rough implementation generally helps.</span>
