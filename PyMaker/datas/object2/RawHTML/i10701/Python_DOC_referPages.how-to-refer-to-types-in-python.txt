<div class="post-text" itemprop="text">
<p>I know how to refer to some types, i.e. <code>str</code> for <code>type('')</code>, <code>int</code> for <code>type(1)</code> etc. But what about other types, such as <code>type(lambda: None)</code>?</p>
<p>I know to refer to it as <code>type(f) == type(lambda: None)</code> for comparison, but, is there any other way, except that? (No silly answer such as code-golf, use another return value for the lambda, etc.)</p>
<p><strong>Edit</strong>: I just found out how to utilize the accepted answer!</p>
<pre><code>import types

function                   = types.FunctionType
builtin_function_or_method = types.BuiltinFunctionType
classobj                   = types.ClassType
generator                  = types.GeneratorType
object                     = type

del types
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to test if a certain value is <em>a lambda</em>:</p>
<pre><code>import types

foo = lambda: None
print(isinstance(foo, types.LambdaType))
</code></pre>
<p>See <a href="https://docs.python.org/3/library/types.html" rel="nofollow">https://docs.python.org/3/library/types.html</a>.</p>
<p>You usually use <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow"><code>isinstance</code></a> for testing <em>if something is something</em>, <code>type() == type()</code> is very frowned upon.</p>
</div>
<div class="post-text" itemprop="text">
<p>To get the type of various builtin types in Python 2, you can use the <code>types</code> module.</p>
<pre><code>import types
l = lambda: 0
function_type = types.FunctionType
if isinstance(l, function_type):
    do_stuff()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Checking if something is a function is different to checking if it is a callable.
Most likely you want to check if the object is callable (can I use this object like a function?). </p>
<p>A function is one of several types of callable. They are:</p>
<ol>
<li>Pure python functions</li>
<li>Methods</li>
<li>Classes / instances with <code>__call__</code> methods</li>
<li>Builtin (C) functions</li>
</ol>
<p>A pure python function is one that is either a <code>lambda</code>, or defined using a <code>def</code> statement. A method is a function that exists on a class, and has been access via an instance -- basically a function with it's first argument bound as an instance). Classes and objects can be called if their class implements a <code>__call__</code> method (all classes are callable by default, but not all objects are). Builtin functions are just functions written in C, rather than Python.</p>
<p>If you want to check if something is callable, then use the <code>callable</code> function. eg.</p>
<pre><code>&gt;&gt;&gt; callable(lambda: None)
True
&gt;&gt;&gt; class X:
    def f(self):
        pass

&gt;&gt;&gt; callable(X().f)
True
&gt;&gt;&gt; callable(object)
True
&gt;&gt;&gt; callable(len)
True
</code></pre>
<p>If you want to check if a an object is one of the specific subtypes of callable then use the <code>types</code> module.</p>
<pre><code>&gt;&gt;&gt; from types import FunctionType, BuiltinFunctionType, MethodType
&gt;&gt;&gt; isinstance((lambda: None), FunctionType)
True
&gt;&gt;&gt; class X:
    def f(self):
        pass

&gt;&gt;&gt; isinstance(X().f, FunctionType)
False
&gt;&gt;&gt; isinstance(X.f, FunctionType) # False in Python 2.x
True
&gt;&gt;&gt; isinstance(object, FunctionType)
False
&gt;&gt;&gt; isinstance(len, FunctionType)
False
</code></pre>
<p>For other types, you may wish to use the <code>collections.abc</code> module. The classes defined here are abstract base classes that check instances of subclasses confirm to the specification, or can be used to check if an object can act as an instance of the type). eg.</p>
<pre><code>from collections.abc import Generator
def my_generator():
    yield
assert isinstance(my_generator(), Generator)
assert type(my_generator()) is not Generator
</code></pre>
</div>
<span class="comment-copy">For what purpose exactly? You want to test if a certain variable holds <i>a lambda</i>? You usually use <code>isinstance</code> for testing <i>if something is something</i>.</span>
<span class="comment-copy"><code>import types</code> then <code>types.FunctionType</code></span>
<span class="comment-copy">"Remember to add the best answer to Documentation." Why?</span>
<span class="comment-copy">@Evert Sorry, that was removed</span>
<span class="comment-copy">@muddyfish Can you add that as an answer, please?</span>
<span class="comment-copy">Why <i>lambda</i> and not <i>function</i>?</span>
<span class="comment-copy">Because that's what you explicitly want to test...!? You can also test against <code>types.FunctionType</code>, which includes lambdas, if that's what you want.</span>
<span class="comment-copy">Yet <code>type(lambda: None)</code> is a function, not specifically a lambda. <code>types.LambdaType</code> is non-"standard" AFAIK.</span>
<span class="comment-copy">Yes, they're actually equivalent as far as I'm aware; they probably just both exist for completeness.</span>
<span class="comment-copy">FWIW, it shouldn't matter to anyone whether a function was defined via <code>def</code> or <code>lambda</code>; for all functional intents and purposes they both define the same thing simply using different syntax, which is purely an implementation detail on the caller's side, not on the side of the code receiving and inspecting that function.</span>
<span class="comment-copy">I want to check what <i>type</i> is it, not <i>if it is callable</i>. Functions, builtins methods and classes are all callable. But what if I want to have a function work with code? Will I use a class .__init__ to store the code? Functions and builtin functions do the job here. In a class, methods also do the job (which, I have convinced myself they don't exist, it's just a different name for <i>a function in a class</i>.)</span>
<span class="comment-copy">The point is, you shouldn't care if you have a function versus any other callable. So long as it takes the right arguments and returns the right result then it doesn't matter. This is why <code>callable</code> is preferable. Secondly, a method <b>is</b> different to function. A method is simply a function with its first argument already filled in. eg. <code>str.count('abda', 'a')</code> versus <code>'abra'.count('a')</code>. Try <code>type(MyClass().func)</code> to see the type of a method. Methods can be saved and called later without having to supply the <code>self</code> argument. eg. <code>caps = 'abra'.capitalize; assert caps() == 'ABRA'</code>.</span>
<span class="comment-copy">But I want to know the <i>type</i>, not if it is callable...</span>
<span class="comment-copy">Why? You haven't explained why you need the object's type. And since Python is a duck-typed language, you shouldn't really need to know it's type, just that it implements a particular method/interface.</span>
<span class="comment-copy">A function can do different things depending on the type(s) of the argument(s). What if you overloaded a function, such as reverse the digits of an <code>int</code>eger or <code>float</code>ing-point number or reverse the contents of a <code>str</code>ing? And that with returning the same type? Sure, I <i>can</i> do that, but what if I also supported <code>long</code>s and <code>complex</code>es? That gets more difficult without <i>knowing</i> its type.</span>
