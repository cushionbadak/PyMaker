<div class="post-text" itemprop="text">
<p>I have an array of 10-bytes (80-bits) Little Endian float values (or <code>float80</code>). How can i read this values in python 3?</p>
<p>The package <code>struct</code> does not support <code>float80</code> (may be I read the docs carelessly).</p>
<p>The package <code>array</code> as same as package "struct" does not support <code>float80</code>.</p>
<p>The package <code>numpy</code> supports <code>float128</code> or <code>float96</code> types. It's very good, but appending <code>\x00</code> in a tail of <code>float80</code> to extend it to <code>float96</code> or <code>float128</code> is ugly, importing of this package takes a lot of time.</p>
<p>The package <code>ctypes</code> supports <code>c_longdouble</code>. It's many times faster then numpy, but <code>sizeof(c_longdouble)</code> is machine-dependent and can be less then 80 bits, appending <code>\x00</code> in a tail of <code>float80</code> to extend it to <code>c_longdouble</code> is ugly too.</p>
<p><strong>UPDATE 1</strong>: test code at my <a href="https://gist.github.com/kai3341/27e158bb0a9163f1603902abaeb9e940" rel="nofollow">gist.github</a>.
The function <code>decode_str64</code> is ugly, but it works. Now I'm looking for right way</p>
</div>
<div class="post-text" itemprop="text">
<p>Let me rewrite my answer in a more logical way:</p>
<p><code>ctypes c_longdouble</code> is machine dependent because the longdouble float type is not set in stone by the C standard and is dependent on the compiler :( but it is still your best you can have right now for high precision floats...</p>
<p>If you plan to use numpy, numpy.longdouble is what your are looking for, numpy.float96 or numpy.float128 are highly misleading names. They do not indicate a 96- or 128-bit IEEE floating point format. Instead, they indicate the number of bits of alignment used by the underlying long double type. So e.g. on x86-32, long double is 80 bits, but gets padded up to 96 bits to maintain 32-bit alignment, and numpy calls this <code>float96</code>. On x86-64, long double is again the identical 80 bit type, but now it gets padded up to 128 bits to maintain 64-bit alignment, and numpy calls this <code>float128</code>. There's no extra precision, just extra padding. </p>
<p>Appending <code>\x00</code> at the end of a <code>float80</code> to make a <code>Float96</code> is ugly, but in the end it is just that as <code>float96</code> is just a padded <code>float80</code> and <code>numpy.longdouble</code> is a <code>float96</code> or <code>float128</code> depending of the architecture of the machine you use.</p>
<p><a href="https://stackoverflow.com/questions/9062562/what-is-the-internal-precision-of-numpy-float128">What is the internal precision of numpy.float128?</a></p>
</div>
<div class="post-text" itemprop="text">
<p><code>numpy</code> <a href="http://docs.scipy.org/doc/numpy-dev/user/basics.types.html#extended-precision" rel="nofollow">can use 80-bit float if the compiler and platform support them</a>:</p>
<blockquote>
<p>Whether [supporting higher precision] is possible in numpy depends on
  the hardware and on the development environment: specifically, x86
  machines provide hardware floating-point with 80-bit precision, and
  while most C compilers provide this as their <code>long double</code> type, MSVC
  (standard for Windows builds) makes <code>long double</code> identical to double
  (64 bits). Numpy makes the compilerâ€™s long double available as
  <code>np.longdouble</code> (and np.clongdouble for the complex numbers). You can
  find out what your numpy provides with<code>np.finfo(np.longdouble)</code>.</p>
</blockquote>
<p>I checked that <code>np.longdouble</code> is <code>float64</code> in stock <code>numpy-1.11.1-win32.whl</code> at PyPI as well as in <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy" rel="nofollow">Gohlke's build</a> and <code>float96</code> in <code>numpy-1.4.1-9.el6.i686</code> in CentOS 6.</p>
</div>
<div class="post-text" itemprop="text">
<p>The padding, or rather, memory alignment of extended-precision floats on a 4 (x32) or 16 (x64) byte boundary, is added - <a href="https://software.intel.com/en-us/articles/coding-for-performance-data-alignment-and-structures" rel="nofollow noreferrer">by recommendatation from Intel no less</a> - to avoid a performance hit associated with handling non-aligned data on x86 CPUs. To give you an idea of the hit's magnitude, <a href="https://msdn.microsoft.com/en-us/library/aa290049%28v=vs.71%29.aspx#code-snippet-9" rel="nofollow noreferrer">some figures from Microsoft show ~2 times difference for DWORDs.</a></p>
<p><a href="https://stackoverflow.com/questions/17382879/sizeof-long-double-and-precision-not-matching">This layout is ingrained into the underlying C's <code>long double</code></a> rather than being <code>numpy</code>'s invention, so <code>numpy</code> doesn't attempt to provide any way around it to extract/insert only the "significant" part.</p>
<p>So, adding padding by hand if you have raw data without padding looks like the way to go. You can speed up the process by writing directly to the underlying buffer:</p>
<pre><code>fi=np.finfo(np.longdouble)
assert fi.nmant==63 and fi.nexp==15, "80-bit float support is required"
del fi

len_float80=10    #no way to extract this from dtype/finfo
len_padded=np.dtype(np.longdouble).itemsize

f=open('float80.bin','rb')
f_items=os.stat(f.name).st_size//len_float80

n = np.empty(f_items,dtype=np.longdouble)

for i in xrange(f_items):
    raw=f.read(len_float80)
    n.data[i*len_padded:i*len_padded+len_float80]=raw

del f,i,raw,f_items
</code></pre>
<p>Or even attain much more speedup by <a href="http://cython.readthedocs.io/en/latest/src/tutorial/numpy.html" rel="nofollow noreferrer">porting the code to Cython</a> (<a href="https://stackoverflow.com/questions/40209520/daily-data-resample-every-3-days-calculate-over-trailing-5-days-efficiently/40329730#40329730">if using raw buffers, the speedup compared to regular array indexing can be as much as 100x!</a> This would hurt the code's maintainability though so beware of premature optimization here).</p>
<p>Alternatively, for an "interchange" format, you might consider using one that is not bound to internal representation, like <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html" rel="nofollow noreferrer"><code>savetxt</code></a>.</p>
</div>
<span class="comment-copy">You should probably change the format of the producer to either produce <code>float64</code> or <code>float96</code>/<code>float128</code>...</span>
<span class="comment-copy">@Bakuriu, I would have done it if I could :(</span>
<span class="comment-copy">possibly loading as struct "&lt;HQ" and processing accordingly to <a href="https://en.wikipedia.org/wiki/Extended_precision#x86_Extended_Precision_Format" rel="nofollow noreferrer">x86_Extended_Precision_Format</a> possibly using <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer">decimal</a> to not lose precision</span>
<span class="comment-copy">What do you want the output to be? Regular Python <code>float</code>s? How should values that are out of range for a regular <code>double</code> but within the range of an 80-bit <code>long double</code> be handled by the conversion?</span>
<span class="comment-copy">AFAIK either you do that by hand as mentioned by janbrohl, which will be a lot cumbersome, or you just pad the floats to become <code>float96</code>/<code>float128</code> and use numpy. There is no built-in way to handle float80s.</span>
<span class="comment-copy">The trouble is that on some OSs (notably Windows), <code>np.longdouble</code> is simply <code>np.float64</code> again, so using <code>np.longdouble</code> doesn't give a cross-platform solution.</span>
<span class="comment-copy">@Mark Dickinson, As same as <code>ctypes.c_longdouble</code>: on Windows i read a garbage (it may be because <code>ctypes.sizeof(ctypes.c_longdouble)</code> less then 10, this check i added a long time after tests on Windows). But for me it is not critical problem now</span>
<span class="comment-copy">Yes, <code>numpy</code> provides <code>float64</code>, <code>float96</code>, <code>float128</code> data types.</span>
<span class="comment-copy">So it's good, data can be read by appending \x00 in a tail byte array. First I done this task using <code>numpy</code>. By the reason of long time importing <code>numpy</code> I changed <code>numpy</code> to <code>ctypes</code>. There is no difference: I appending \x00 in a tail of byte array.</span>
