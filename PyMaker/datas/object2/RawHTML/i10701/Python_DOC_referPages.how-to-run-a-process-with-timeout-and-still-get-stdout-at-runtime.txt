<div class="post-text" itemprop="text">
<p>The need:</p>
<ol>
<li>Timeout after X seconds, and kill the process (and all the processes it opened) if timeout reached before the process ends gracefully.</li>
<li>Read ongoing output at runtime.</li>
<li>Work with processes that produce output, ones that don't, and ones that produce output, and then stop producing it (e.g. get
stuck).</li>
<li>Run on Windows.</li>
<li>Run on Python 3.5.2.</li>
</ol>
<p>Python 3 subprocess module has <a href="https://docs.python.org/3/library/subprocess.html#subprocess.TimeoutExpired.timeout">timeout</a> built in, and I've also tried and implemented timeout myself using timer and using threads, but it doesn't work with the output. <code>readline()</code> is blocking or not? <code>readlines()</code> is definitely waiting for the process to end before spitting out all the output, which is not what I need (I need ongoing).</p>
<p>I am close to switching to node.js :-(</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use asyncio for this kind of task.</p>
<p>Read IO from the process like in this accepted anwser:
<a href="https://stackoverflow.com/questions/24435987/how-to-stream-stdout-stderr-from-a-child-process-using-asyncio-and-obtain-its-e">How to stream stdout/stderr from a child process using asyncio, and obtain its exit code after?</a></p>
<p>(I don't want to fully copy it here)</p>
<p>Wrap it in a timeout:</p>
<pre><code>async def killer(trans, timeout):
    await asyncio.sleep(timeout)
    trans.kill()
    print ('killed!!')

trans, *other_stuff = loop.run_until_complete(
                           loop.subprocess_exec(
                                SubprocessProtocol, 'py', '-3', '-c', 'import time; time.sleep(6); print("Yay!")' ,
                                        ) 
                       )

asyncio.ensure_future(killer(trans, 5)) # 5 seconds timeout for the kill
loop.run_forever()
</code></pre>
<p>Have fun ...</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the 2 python script below.</p>
<ul>
<li><p>The <em>Master.py</em> will use <code>Popen</code> to start a new process and will start a watcher thread that will kill the process after <code>3.0</code> seconds.</p></li>
<li><p>The slave must call the flush method if no newline in the data written to the <code>stdout</code>, (on windows the <code>'\n'</code> also cause a flush).</p></li>
</ul>
<blockquote>
<p>Be careful the <code>time</code> module is not a high precision timer.</p>
<p>The load time of the process can be longer than 3.0 seconds in extreme cases (reading an executable from a flash drive having USB 1.0)</p>
</blockquote>
<p><strong>Master.py</strong></p>
<pre><code>import subprocess, threading, time

def watcher(proc, delay):
    time.sleep(delay)
    proc.kill()

proc = subprocess.Popen('python Slave.py', stdout = subprocess.PIPE)
threading.Thread(target = watcher, args = (proc, 3.0)).start()

data = bytearray()

while proc:
    chunk = proc.stdout.read(1)
    if not chunk:
        break
    data.extend(chunk)
    print(data)
</code></pre>
<p><strong>Slave.py</strong></p>
<pre><code>import time, sys

while True:
    time.sleep(0.1)
    sys.stdout.write('aaaa')
    sys.stdout.flush()
</code></pre>
</div>
<span class="comment-copy">The problem with stdout might be in the child process.  If the stdout buffer is not flushed then python will never receive the contents (and that would be the same whatever language you used).  One possible solution (untested) would be in <code>subprocess.Popen</code> to assign the child's stdout to stderr.  Usually stderr is unbuffered.</span>
<span class="comment-copy">Yes, <code>readline</code> will block, waiting to receive the next line, as will anything else that reads <code>sys.stdin</code>. You can tell Python to make <code>sys.stdout</code> unbuffered by specifying the <code>-u</code> option on the command line.</span>
<span class="comment-copy">No one cares if you switch to node.js...</span>
<span class="comment-copy">Unfortunately, I wasn't able to make the process time out after the 5 seconds you've mentioned.</span>
<span class="comment-copy">@NaphtaliGilead - The process does not timeout, But your call will return and then you can kill it</span>
<span class="comment-copy">Updated to kill the process after 5 seconds</span>
<span class="comment-copy">Your example works, but I am not able to run my process and get the output.</span>
<span class="comment-copy">use full path to your executable. example: <code>c:\windows\system32\py.exe</code> <code>d:\Slave.py</code></span>
