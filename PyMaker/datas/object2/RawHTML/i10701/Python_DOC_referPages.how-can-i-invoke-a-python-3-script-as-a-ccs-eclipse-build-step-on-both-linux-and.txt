<div class="post-text" itemprop="text">
<p>I have a Python 3.5 script that I would like to invoke as a pre-build step in my Code Composer build. To be clear, it should be run as one of the entries in <em>(my project) &gt; Properties &gt; CCS Build &gt; Steps &gt; Pre-build steps</em>.</p>
<p>The script currently begins with the hashbang <code>#!/usr/bin/env python3</code>, but I can change this.</p>
<p>On Linux, I can invoke the script as <code>../prebuild.py ../output_file</code>. This fails on Windows 10 with:</p>
<pre><code>"C:\\ti\\ccsv6\\utils\\bin\\gmake" -k all 
../prebuild.py ../output_file
makefile:217: recipe for target 'pre-build' failed
process_begin: CreateProcess(NULL, env python3 C:\path\to\prebuild.py ../output_file, ...) failed.
make (e=2): The system cannot find the file specified.
</code></pre>
<p>The path separator does not affect this at all.</p>
<p>I also tried <code>python3 ../prebuild.py ../output_file</code>. This does not work on Windows 10 because there is no <code>python3</code> executable. Python 3 is installed as <code>python.exe</code>. Using <code>python</code> fails on Linux because of course Python 3 is installed as <code>python3</code>, and <code>python</code> refers to Python 2.</p>
<p>I also tried <code>py ../prebuild.py ../output_file</code>. This fails on Linux because there is no <code>py</code> executable.</p>
<p>Is there a cross-platform way to invoke a Python 3 script that can be used for an Eclipse pre-build step? I would like to avoid requiring that developers modify their distribution/Python installation.</p>
<p>I am using Code Composer Studio 6, which is based on Eclipse. I expect any answer to this would apply to either.</p>
<h2>Context</h2>
<p>One of the things I am trying to achieve is to insert the SHA1 of the current Git commit into a file. The <a href="https://stackoverflow.com/a/3443485/188535">accepted answer</a> for doing this is to generate the file as part of the build process by parsing Git output. I have a Python script that can do this on both Windows and Linux, so I need a way to invoke it as part of Eclipse's build process.</p>
</div>
<div class="post-text" itemprop="text">
<p>Have a wrapper script that works under both Python 2 and 3 to detect and run the script with the correct Python version. The Eclipse/CCS pre build step can then be <code>python ../wrapper.py</code> (possibly with extra arguments like <code>../prebuild.py args</code>).</p>
<p>You could just check if it is running on Windows or Linux and what version of Python it is running. If it is running on Linux and running the wrong Python version, run <code>subprocess.call(['python3','prebuild.py'])</code>. To check the Python version and OS use:</p>
<pre><code>import os, sys, subprocess

if sys.version_info[0] &lt; 3 and os.name == 'posix':
     subprocess.call(['python3','../prebuild.py'])
     sys.exit()
else:
    subprocess.call(['python','../prebuild.py'])
    sys.exit()
</code></pre>
<p>A more generic script might <a href="https://stackoverflow.com/questions/9079036/detect-python-version-at-runtime">check if the interpreter</a> is already the right one and try to pass through arguments if it is:</p>
<pre><code>import sys

if sys.version_info[0] &gt;= 3 and sys.version_info[1] &gt;= 3:
    subprocess.call([sys.executable] + sys.argv[1:]
</code></pre>
<p>Otherwise the wrapper could iterate over a list of possible interpreters until it succeeds, like:</p>
<pre><code>interpreters = [["py", "-3"], ["python3"]]

for interp in interpreters:
     # Try a subprocess.call(...) as above. Detect bad return codes (eg. py failed) or OSErrors (ie. command wasn't found).
     success = False
     try:
        success = subprocess.call(...) == 0
     except OSError:
         pass

     if success:
         break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Somewhere between CCStudio 6.1.2 and 6.2.0 they switched from GNU make 3.81 to 4.1. It seems that this introduced <a href="http://git.savannah.gnu.org/cgit/make.git/tree/w32/subproc/sub_proc.c?id=9d58570c77240fed53d1f88217877f8e778f4bb2#n621" rel="nofollow noreferrer">a feature that attempts to interpret the shebang</a> rather than just passing the file on to Windows to handle via the <code>.py</code>-&gt;<code>py.exe</code> assocation.</p>
<p>I didn't want to update various projects and branches just because GNU make was being naughty so I decided to solve this in a little different direction by creating <code>env</code> for Windows.  Well, a minimal version of it that works for my present need (<code>python3</code>).  Since GNU make doesn't bother to us the <code>$PATHEXT</code> variable when searching for matches I couldn't use <code>env.py</code> and beyond that it doesn't even seem to successfully search it's own specified list for anything other than <code>.exe</code>.  So, C++ it is.  If I need to do much more I will likely make <code>env.exe</code> just call <code>py env.py</code> and do the rest in Python.</p>
<p>Here's a copy of my simple first pass <a href="https://gist.github.com/altendky/0a84fe3b9f047a1d7e260d9cf82192ac" rel="nofollow noreferrer">from my gist</a>.</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main (int argc, char* argv[])
{
    string command = string("py");

    cout &lt;&lt; " - - - - - - - \\/  \\/ - - - - - " &lt;&lt; std::endl;
    for (int i = 2; i &lt; argc; i++)
    {
        cout &lt;&lt; argv[i] &lt;&lt; endl;
        command += " ";
        command += '"';
        command += argv[i];
        command += '"';
    }
    cout &lt;&lt; " - - - - - - - /\\  /\\ - - - - - " &lt;&lt; std::endl;
    cout &lt;&lt; command &lt;&lt; endl;
    cout &lt;&lt; " - - - - - - - /\\  /\\ - - - - - " &lt;&lt; std::endl;

    system( command.c_str() );

    return 0;
}
</code></pre>
</div>
<span class="comment-copy">I am not above writing a weird polyglot line, which can be documented, if I can make the development workflow easier in the long run.</span>
<span class="comment-copy">Is the <a href="https://docs.python.org/3/using/windows.html#python-launcher-for-windows" rel="nofollow noreferrer">Launcher for Windows</a> any use for you here?</span>
<span class="comment-copy">@PeterBrittain Nope, it doesn't exist on Linux, so the build step will just fail there. I realise we could symlink <code>py -&gt; python3</code> on Linux, but my preference is for a complex build step that just works over requiring installation or symlinking stuff on the development machine (because the build step is part of the project, which is just checked in to version control, whereas dependencies can't be).</span>
<span class="comment-copy">Obviously a simple build step is better than either, but hey, we can't have everything <code>:)</code></span>
<span class="comment-copy">Somewhere between CCStudio 6.1.2 and 6.2.0 they switched from GNU make 3.81 to 4.1.  It seems that this introduced a feature that attempts to interpret the shebang rather than just passing the file on to Windows to handle via the .py-&gt;py.exe assocation.  <a href="http://git.savannah.gnu.org/cgit/make.git/tree/w32/subproc/sub_proc.c?id=9d58570c77240fed53d1f88217877f8e778f4bb2#n621" rel="nofollow noreferrer">git.savannah.gnu.org/cgit/make.git/tree/w32/subproc/â€¦</a></span>
<span class="comment-copy">How does the detection script get run?</span>
<span class="comment-copy">The detection script would be in the same folder or in the example I gave in a sub folder where the prebuild.py script would be.  Then you would just run it as python detection.py which would run the prebuild.py with the correct version of python. Again it seems hacky but that is what first came to mind. That was just for the detection you also most likely want to pass the output_file but I left that part out just to focus on the switch to the correct python version.</span>
<span class="comment-copy">Ah, and the command I put into Eclipse's build step is <code>python ../switch_prebuild.py</code> I suppose. Implies a dependency on Python 2 in Linux, but I think most distributions rely on that now.</span>
<span class="comment-copy">Sorry, crossed edits there. I'll give this a shot.</span>
<span class="comment-copy">It implies a version python 2 or greater is installed. Because some version of linux has 'python' default to 3.5 others have it default to 2.7. But most will have something that points to something called python.   So if only python 3 is installed the script will still work and call the correct version of python. Also this script works in both python 2.7 and 3.5 without any issue that I have see.   Again you still need to add something to pass in the output_file path/name.</span>
