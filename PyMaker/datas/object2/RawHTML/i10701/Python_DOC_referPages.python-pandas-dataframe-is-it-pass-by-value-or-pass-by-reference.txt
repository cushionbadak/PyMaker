<div class="post-text" itemprop="text">
<p>If I pass a dataframe to a function and modify it inside the function, is it pass-by-value or pass-by-reference?</p>
<p>I run the following code</p>
<pre><code>a = pd.DataFrame({'a':[1,2], 'b':[3,4]})
def letgo(df):
    df = df.drop('b',axis=1)
letgo(a)
</code></pre>
<p>the value of <code>a</code> does not change after the function call. Does it mean it is pass-by-value?</p>
<p>I also tried the following</p>
<pre><code>xx = np.array([[1,2], [3,4]])
def letgo2(x):
    x[1,1] = 100
def letgo3(x):
    x = np.array([[3,3],[3,3]])
</code></pre>
<p>It turns out <code>letgo2()</code> does change <code>xx</code> and <code>letgo3()</code> does not. Why is it like this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The short answer is, Python always does pass-by-value, but every Python variable is actually a pointer to some object, so sometimes it looks like pass-by-reference.</p>
<p>In Python every object is either mutable or non-mutable. e.g., lists, dicts, modules and Pandas data frames are mutable, and ints, strings and tuples are non-mutable. Mutable objects can be changed internally (e.g., add an element to a list), but non-mutable objects cannot. </p>
<p>As I said at the start, you can think of every Python variable as a pointer to an object. When you pass a variable to a function, the variable (pointer) within the function is always a copy of the variable (pointer) that was passed in. So if you assign something new to the internal variable, all you are doing is changing the local variable to point to a different object. This doesn't alter (mutate) the original object that the variable pointed to, nor does it make the external variable point to the new object. At this point, the external variable still points to the original object, but the internal variable points to a new object. </p>
<p>If you want to alter the original object (only possible with mutable data types), you have to do something that alters the object <em>without</em> assigning a completely new value to the local variable. This is why <code>letgo()</code> and <code>letgo3()</code> leave the external item unaltered, but <code>letgo2()</code> alters it. </p>
<p>As @ursan pointed out, if <code>letgo()</code> used something like this instead, then it would alter (mutate) the original object that <code>df</code> points to, which would change the value seen via the global <code>a</code> variable:</p>
<pre><code>def letgo(df):
    df.drop('b', axis=1, inplace=True)

a = pd.DataFrame({'a':[1,2], 'b':[3,4]})
letgo(a)  # will alter a
</code></pre>
<p>In some cases, you can completely hollow out the original variable and refill it with new data, without actually doing a direct assignment, e.g. this will alter the original object that <code>v</code> points to, which will change the data seen when you use <code>v</code> later:</p>
<pre><code>def letgo3(x):
    x[:] = np.array([[3,3],[3,3]])

v = np.empty((2, 2))
letgo3(v)   # will alter v
</code></pre>
<p>Notice that I'm not assigning something directly to <code>x</code>; I'm assigning something to the entire internal range of <code>x</code>.</p>
<p>If you absolutely must create a completely new object and make it visible externally (which is sometimes the case with pandas), you have two options. The 'clean' option would be just to return the new object, e.g., </p>
<pre><code>def letgo(df):
    df = df.drop('b',axis=1)
    return df

a = pd.DataFrame({'a':[1,2], 'b':[3,4]})
a = letgo(a)
</code></pre>
<p>Another option would be to reach outside your function and directly alter a global variable. This changes <code>a</code> to point to a new object, and any function that refers to <code>a</code> afterward will see that new object:</p>
<pre><code>def letgo():
    global a
    a = a.drop('b',axis=1)

a = pd.DataFrame({'a':[1,2], 'b':[3,4]})
letgo()   # will alter a!
</code></pre>
<p>Directly altering global variables is usually a bad idea, because anyone who reads your code will have a hard time figuring out how <code>a</code> got changed. (I generally use global variables for shared parameters used by many functions in a script, but I don't let them alter those global variables.)</p>
</div>
<div class="post-text" itemprop="text">
<p>The question isn't PBV vs. PBR. These names only cause confusion in a language like Python; they were invented for languages that work like C or like Fortran (as the quintessential PBV and PBR languages). It is true, but not enlightening, that Python always passes by value. The question here is whether the value itself is mutated or whether you get a new value. Pandas usually errs on the side of the latter.</p>
<p><a href="http://nedbatchelder.com/text/names.html" rel="noreferrer">http://nedbatchelder.com/text/names.html</a> explains very well what Python's system of names is.</p>
</div>
<div class="post-text" itemprop="text">
<p>To add to @Mike Graham's answer, who pointed to a very good read:</p>
<p>In your case, what is important to remember is the difference between <em>names</em> and <em>values</em>. <code>a</code>, <code>df</code>, <code>xx</code>, <code>x</code>, are all <em>names</em>, but they refer to the same or different <em>values</em> at different points of your examples:</p>
<ul>
<li><p>In the first example, <code>letgo</code> <strong>rebinds</strong> <code>df</code> to another value, because <code>df.drop</code> returns a new <code>DataFrame</code> unless you set the argument <code>inplace = True</code> (<a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.drop.html" rel="nofollow">see doc</a>). That means that the name <code>df</code> (local to the <code>letgo</code> function), which was referring to the value of <code>a</code>, is now referring to a new value, here the <code>df.drop</code> return value. The value <code>a</code> is referring to still exists and hasn't changed.</p></li>
<li><p>In the second example, <code>letgo2</code> <strong>mutates</strong> <code>x</code>, without rebinding it, which is why <code>xx</code> is modified by <code>letgo2</code>. Unlike the previous example, here the local name <code>x</code> always refers to the value the name <code>xx</code> is referring to, and changes that value <em>in place</em>, which is why the value <code>xx</code> is referring to has changed.</p></li>
<li><p>In the third example, <code>letgo3</code> <strong>rebinds</strong> <code>x</code> to a new <code>np.array</code>. That causes the name <code>x</code>, local to <code>letgo3</code> and previously referring to the value of <code>xx</code>, to now refer to another value, the new <code>np.array</code>. The value <code>xx</code> is referring to hasn't changed.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Python is neither pass by value nor pass by reference.  It is pass by assignment.</p>
<p>Supporting reference, the Python FAQ:
<a href="https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="nofollow noreferrer">https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference</a></p>
<p>IOW:</p>
<ol>
<li>If you pass an immutable value, changes to it do not change its
value    in the caller - because you are rebinding the name to a new
object.</li>
<li>If you pass a mutable value, changes made in the called function,
also change the value in the caller, so long as you do not rebind
that name to a new object.  If you reassign the variable,
creating a new object, that change and subsequent changes to the
name are not seen in the caller.</li>
</ol>
<p>So if you pass a list, and change its 0th value, that change is seen in both the called and the caller.  But if you reassign the list with a new list, this change is lost.  But if you slice the list and replace <em>that</em> with a new list, that change is seen in both the called and the caller.</p>
<p>EG:</p>
<pre><code>def change_it(list_):
    # This change would be seen in the caller if we left it alone
    list_[0] = 28

    # This change is also seen in the caller, and replaces the above
    # change
    list_[:] = [1, 2]

    # This change is not seen in the caller.
    # If this were pass by reference, this change too would be seen in
    # caller.
    list_ = [3, 4]

thing = [10, 20]
change_it(thing)
# here, thing is [1, 2]
</code></pre>
<p>If you're a C fan, you can think of this as passing a pointer by value - not a pointer to a pointer to a value, just a pointer to a value.</p>
<p>HTH.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is the doc for drop:</p>
<blockquote>
<p>Return new object with labels in requested axis removed.</p>
</blockquote>
<p>So a new dataframe is created. The original has not changed.</p>
<p>But as for all objects in python, the data frame is passed to the function by reference.</p>
</div>
<div class="post-text" itemprop="text">
<p>you need to make 'a' global at the start of the function otherwise it is a local variable and does not change the 'a' in the main code.</p>
</div>
<span class="comment-copy">For explanations of Python's pass by assignment model, read <a href="http://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Facts and Myths about Pythons names and values</a>, <a href="https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="nofollow noreferrer">FAQ: How do I write a function with output parameters (call by reference)?</a>, <a href="http://stackoverflow.com/q/986006/190597">SO: How do I pass a variable by reference?</a>.</span>
<span class="comment-copy">The semantics of passing and assigning in Python are exactly the same as in Java, and the same things you say can be equally applied to Java. Yet on StackOverflow and elsewhere on the Internet people apparently find it "enlightening" to impress upon you that Java is always pass by value whenever this issue comes up.</span>
<span class="comment-copy">but I assigned it to <code>df</code> inside the function, doesn't it mean the referenced value has been changed to the new object?</span>
<span class="comment-copy">Assigning to a local name will never change what object a name is bound to in another scope.</span>
