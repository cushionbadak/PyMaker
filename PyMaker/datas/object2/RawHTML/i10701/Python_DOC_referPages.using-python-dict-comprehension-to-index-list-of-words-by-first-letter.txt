<div class="post-text" itemprop="text">
<p>Conceptually, this is pretty easy, but I can't seem to figure it out. </p>
<p>I want to turn a list of strings into a dict with each key being the first letter of the list of words associated with it.</p>
<pre><code># My list of sounds
sounds = ['sniff', 'bark', 'bork', 'blork', 'heck', 'borf', 'bjork', 'boo', 'bre', 'bore']

# My dict comprehension which isn't working
indexed = {s[0]: [s] for s in sounds}
</code></pre>
<p>My output look like this:</p>
<pre><code>{'h': ['heck'], 's': ['sniff'], 'b': ['bore']}
</code></pre>
<p>I'm missing an append function here, but each time I try to implement it fails to give me the correct output, or it throws a SyntaxError. What am I missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>this can be done in one go with just the standard library</p>
<pre><code>&gt;&gt;&gt; sounds = ['sniff', 'bark', 'bork', 'blork', 'heck', 'borf', 'bjork', 'boo', 'bre', 'bore']
&gt;&gt;&gt; result=dict()
&gt;&gt;&gt; for s in sounds:
        result.setdefault(s[0],[]).append(s)

&gt;&gt;&gt; result
{'b': ['bark', 'bork', 'blork', 'borf', 'bjork', 'boo', 'bre', 'bore'], 's': ['sniff'], 'h': ['heck']}
&gt;&gt;&gt; 
</code></pre>
<p>the solution with itertools is fine, but it require the extra step of sorting the list, making it O(n log n), while this do the same in just one go so is O(n)</p>
<p>the <a href="https://docs.python.org/3/library/collections.html" rel="nofollow">collections</a> module offer <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow">defaultdict</a> which have a build in <code>setdeafult</code></p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; result=defaultdict(list)
&gt;&gt;&gt; for s in sounds:
        result[s[0]].append(s)

&gt;&gt;&gt; result
defaultdict(&lt;class 'list'&gt;, {'b': ['bark', 'bork', 'blork', 'borf', 'bjork', 'boo', 'bre', 'bore'], 's': ['sniff'], 'h': ['heck']})
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No problem, <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow">itertools to the rescue</a>. You can group the elements by their first letter, then create a dict out of them.</p>
<pre><code>sounds = ['sniff', 'bark', 'bork', 'blork', 'heck', 'borf', 'bjork', 'boo', 'bre', 'bore']
import itertools

grouped = itertools.groupby(sorted(sounds), key=lambda x: x[0])
d = {k: list(v) for k,v in grouped}
print(d)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is this what you are trying to achieve?</p>
<pre><code>firsts = {s[0] for s in sounds}
indexed = {first: [s for s in sounds if s[0]==first] for first in firsts}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is not a good use for a dict comprehension - you will end up with more loops than you need. If you write it directly then you only scan the input list once:</p>
<pre><code>dict1 = {}
for s in ['sniff', 'bark', 'bork', 'blork', 'heck', 'borf', 'bjork', 'boo', 'bre', 'bore']:
  if not s[0] in dict1.keys():
    dict1[ s[0] ] = []
  dict1[ s[0] ].append(s)     
print dict1
</code></pre>
</div>
<span class="comment-copy">2 different values cannot have the same key. So you just keep over writing the previous value every time a new "b..." or "h..." or "s..." comes in since they give the same keys "b", "h" and "s".  You should probably read about dicts...</span>
<span class="comment-copy">Don't use comprehension for this stuff</span>
<span class="comment-copy">This kind of grouping task isn't a good fit for a comprehension. A normal loop works much better.</span>
<span class="comment-copy">Beautiful! I'll pick this apart; thanks for the help!</span>
<span class="comment-copy">@Drew Do have a deeper look into itertools, it can work wonders (and it works on iterators, so for some cases, you can cover infinite sequences and stuff).</span>
<span class="comment-copy">This is how to make it work with comprehensions, but unfortunately it's still O(n^2) in the worst case of everything having its own key.</span>
