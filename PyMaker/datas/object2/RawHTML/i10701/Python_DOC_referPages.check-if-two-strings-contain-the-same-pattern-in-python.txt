<div class="post-text" itemprop="text">
<p>I have the following list:</p>
<pre><code>names = ['s06_215','s06_235b','s06_235','s08_014','18:s08_014','s08_056','s08_169']
</code></pre>
<p><code>s06_235b</code> and <code>s06_235</code>, <code>s08_014</code> and <code>18:s08_014</code> are duplicated. However, as shown in the example, there is no specific pattern in the naming. I need to do a pairwise comparison of the element of the list:</p>
<pre><code>for i in range(0, len(names)-1):
    for index, value in enumerate(names):
        print names[i], names[index]
</code></pre>
<p>I need then to check for each pair, if the two, contain the same string but with length more than <code>4</code>. That is <code>s06_235b</code> and <code>s06_235</code>, and <code>s08_014</code> and <code>18:s08_014</code> would pass this criterion but <code>s08_056</code> and <code>s08_169</code> would not. </p>
<p>How can I achieve this in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use an 'in' operator to see if on variable contains another</p>
<pre><code>if "example" in "this is an example":
</code></pre>
<p>Try this:</p>
<pre><code>for i in range(0, len(names)-1):
    for index, value in enumerate(names):
       if names[i] in names[index] and len(names[i]) &gt; 4:
          print names[i], names[index]
</code></pre>
<p>Edit:
As tobias_k mention: Note that this only works if the entire string is contained in the other string</p>
</div>
<div class="post-text" itemprop="text">
<p>You could iterate all the <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow"><code>combinations</code></a>, <code>join</code> them with some special character that can not be part of those strings, and use a <a href="https://docs.python.org/3/library/re.html" rel="nofollow">regular expression</a> like <code>(\w{5,}).*#.*\1</code> to find a repeated group in that pair. Other than just testing with <code>s1 in s2</code>, this will also work if just a part of the first string is contained in the second, or vice versa.</p>
<p>Here, <code>(\w{5,})</code> is the shared substring of at least 5 characters (from the <code>\w</code> class in this case, but feel free to adapt), followed by more characters <code>.*</code> the separator (<code>#</code> in this case), more filler <code>.*</code> and then another instance of the first group <code>\1</code>.</p>
<pre><code>p = re.compile(r"(\w{5,}).*#.*\1")
for pair in itertools.combinations(names, 2):
    m = p.search("#".join(pair))
    if m:
        print("%r shares %r" % (pair, m.group(1)))
</code></pre>
<p>Output:    </p>
<pre><code>('s06_215', 's06_235b') shares 's06_2'
('s06_215', 's06_235') shares 's06_2'
('s06_235b', 's06_235') shares 's06_235'
('s08_014', '18:s08_014') shares 's08_014'
('s08_014', 's08_056') shares 's08_0'
('18:s08_014', 's08_056') shares 's08_0'
</code></pre>
<p>Of course, you can tweak the regex to fit your needs. E.g., if you do not want the repeated region to be bounded by <code>_</code>, you could use a regex like <code>p = r"([a-z0-9]\w{3,}[a-z0-9]).*#.*\1"</code>.</p>
</div>
<span class="comment-copy">maybe just parse it by regular expression, so it's all in the same pattern something like <code>s\d\d_\d{2,3}</code>? Afterwards you just take uniq elements from your list</span>
<span class="comment-copy">You wrote your example strings wrong: <code>s08_214</code> and <code>18:s08_014</code> are not containing each other.</span>
<span class="comment-copy">sorry, corrected it</span>
<span class="comment-copy">Note that this only works if the <i>entire</i> string is contained in the other string, not if they share some common substring. Also, why are you mixing <code>range</code> and <code>enumerate</code> like this?</span>
<span class="comment-copy">@tobias_k. Thanks, I'll edit the answear. I just inserted the if-statement in OPs code to show where it goes.</span>
