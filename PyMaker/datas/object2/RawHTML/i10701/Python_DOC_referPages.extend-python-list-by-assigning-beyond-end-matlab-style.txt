<div class="post-text" itemprop="text">
<p>I want to use Python to create a file that looks like</p>
<pre><code># empty in the first line
this is the second line
this is the third line
</code></pre>
<p>I tried to write this script</p>
<pre><code>myParagraph = []
myParagraph[0] = ''
myParagraph[1] = 'this is the second line'
myParagraph[2] = 'this is the third line'
</code></pre>
<p>An error is thrown: <code>IndexError: list index out of range</code>. There are many answers on similar questions that recommend using <code>myParagraph.append('something')</code>, which I know works. But I want to better understand the initialization of Python lists. How to manipulate a specific elements in a list that's not populated yet?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do a limited form of this by assigning to a range of indexes starting at the end of the list, instead of a single index beyond the end of the list:</p>
<pre><code>myParagraph = []
myParagraph[0:] = ['']
myParagraph[1:] = ['this is the second line']
myParagraph[2:] = ['this is the third line']
</code></pre>
<p>Note: In Matlab, you can assign to arbitrary positions beyond the end of the array, and Matlab will fill in values up to that point. In Python, any assignment beyond the end of the array (using this syntax or <code>list.insert()</code>) will just append the value(s) into the first position beyond the end of the array, which may not be the same as the index you assigned.</p>
</div>
<div class="post-text" itemprop="text">
<p>A list doesn't have an unkown size - len(myParagraph) will give you its length</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you want to associate an index (whether it exists or not) with an element of data, just use a <code>dict</code> with integer indexes:</p>
<pre><code>&gt;&gt;&gt; myParagraph={}
&gt;&gt;&gt; myParagraph[0] = ''
&gt;&gt;&gt; myParagraph[1] = 'this is the second line'
&gt;&gt;&gt; myParagraph[2] = 'this is the third line'
&gt;&gt;&gt; myParagraph[99] = 'this is the 100th line'
&gt;&gt;&gt; myParagraph
{0: '', 1: 'this is the second line', 2: 'this is the third line', 99: 'this is the 100th line'}
</code></pre>
<p>Just know that you will need to sort the dict to reassemble in integer order.</p>
<p>You can reassemble into a string (and skip missing lines) like so:</p>
<pre><code>&gt;&gt;&gt; '\n'.join(myParagraph.get(i, '') for i in range(max(myParagraph)+1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>myParagraph = []
myParagraph.append('')
myParagraph.append('this is the second line')
myParagraph.append('this is the third line')

for i,item in enumerate(myParagraph):
    print "i:"+str(i)+": item:"+item
</code></pre>
<p>result:</p>
<pre><code>i:0: item:
i:1: item:this is the second line
i:2: item:this is the third line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>append</code> is the easiest way to get around this, but if it makes you more comfortable having those indices then you should consider using <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow"><code>insert</code></a>:</p>
<blockquote>
<p>Insert an item at a given position. The first argument is the index of
  the element before which to insert, so <code>a.insert(0, x)</code> inserts at the
  front of the list, and <code>a.insert(len(a), x)</code> is equivalent to
  <code>a.append(x)</code>.</p>
</blockquote>
<pre><code>myParagraph = []
myParagraph.insert(0, '\n')
myParagraph.insert(1, 'this is the second line\n')
myParagraph.insert(2, 'this is the third line\n')
</code></pre>
<p>And don't forget the new line character <code>'\n'</code> when writing to a file.</p>
</div>
<span class="comment-copy">Use <code>myParagraph.append(line_add)</code></span>
<span class="comment-copy">@dawg please see the last part in my question. My question is how (or if it's possible) to directly access a specific element of a list.</span>
<span class="comment-copy">A list must be completely populated -- if <code>my_list[6]</code> exists, then <code>my_list[0]</code> - <code>my_list[5]</code> must also exist. In your case, if you assigned something to <code>myParagraph[5]</code>, what would you expect to be placed in the earlier positions? If you know how many lines you'll end up with, you could start with <code>myParagraph = [''] * num_lines</code>. Or if you want to store values for arbitrary indexes, and only those indexes, you could use a dictionary: <code>myParagraph = {}</code>.</span>
<span class="comment-copy">@mfripp thank you for the clarification. Coming from a Matlab background (which allows this action), there are many different rules in Python that I'm trying to get used to.</span>
<span class="comment-copy">@Chris I thought I remembered that syntax from somewhere! By the way, if you're working with Matlab-style vectors and matrices, you should check out the numpy package. But for ad hoc data types, Python's lists are great (and easier syntax than a Matlab cell array, at least for me).</span>
<span class="comment-copy">Ok, that's fair. I'll rephrase the question.</span>
<span class="comment-copy">Also, if you start with <code>myParagraph = collections.defaultdict(str)</code>, you could automatically return an empty string for any unassigned rows. (e.g., via <code>[myParagraph[i] for i in range(99)]</code> or <code>[myParagraph[i] for i in range(max(myParagraph.keys()))]</code>). Or with a standard dictionary you could use <code>[myParagraph.get(i, '') for i in range(max(myParagraph.keys()))]</code>.</span>
<span class="comment-copy">@mfripp: Exactly!</span>
<span class="comment-copy">Gotcha. Yeah I can see it doesn't make much sense to use these tricks instead of just .append(). It's totally fine to write a=[]; a(2)=2; in Matlab. That's essentially where I got confused in Python.</span>
<span class="comment-copy">simpler comment, too late to edit: If you use the above solution and you know how many lines there will be (and you fill them all in), then you can retrieve the lines in order with something like <code>[myParagraph[i] for i in range(99)]</code>. If you don't know how long the paragraph will be, and you want to use blanks for any unassigned lines, you could retrieve the lines via <code>[myParagraph.get(i, '') for i in range(max(myParagraph.keys()))]</code>.</span>
<span class="comment-copy">please see the last part in my question. My question is that if it's possible to avoid using .append(). Say, directly defining the third line.</span>
<span class="comment-copy">yes, but before initializing myParagraph = [None]*3</span>
<span class="comment-copy">cool! I knew there must be a function to do the job. thanks for pointing it out for me</span>
<span class="comment-copy">Note that if you use <i>any</i> index beyond the end of your list, the value will just get appended to the end, not necessarily at the index number you expect. By the way you can also get the same effect with <code>myParagraph[1:1] = ['this is the second line']</code>.</span>
<span class="comment-copy"><code>.insert()</code> only works to the extent the previous elements exist. If you do <code>li=[]; li.insert(2, 'line')</code> the first two missing list elements are not created...</span>
<span class="comment-copy">@dawg shoot...you are right</span>
