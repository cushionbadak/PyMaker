<div class="post-text" itemprop="text">
<p>I've been trying to write an interactive wrapper (for use in ipython) for a library that controls some hardware.  Some calls are heavy on the IO so it makes sense to carry out the tasks in parallel. Using a ThreadPool (almost) works nicely:</p>
<pre><code>from multiprocessing.pool import ThreadPool

class hardware():
    def __init__(IPaddress):
        connect_to_hardware(IPaddress)

    def some_long_task_to_hardware(wtime):
        wait(wtime)
        result = 'blah'
        return result

pool = ThreadPool(processes=4)
Threads=[]
h=[hardware(IP1),hardware(IP2),hardware(IP3),hardware(IP4)]
for tt in range(4):
    task=pool.apply_async(h[tt].some_long_task_to_hardware,(1000))
    threads.append(task)
alive = [True]*4
Try:
    while any(alive) :
        for tt in range(4): alive[tt] = not threads[tt].ready()
        do_other_stuff_for_a_bit()
except:
    #some command I cannot find that will stop the threads...
    raise
for tt in range(4): print(threads[tt].get())
</code></pre>
<p>The problem comes if the user wants to stop the process or there is an IO error in <code>do_other_stuff_for_a_bit()</code>. Pressing <kbd>Ctrl</kbd>+<kbd>C</kbd> stops the main process but the worker threads carry on running until their current task is complete.<br/>
Is there some way to stop these threads without having to rewrite the library or have the user exit python?  <code>pool.terminate()</code> and <code>pool.join()</code> that I have seen used in other examples do not seem to do the job.</p>
<p>The actual routine (instead of the simplified version above) uses logging and although all the worker threads are shut down at some point, I can see the processes that they started running carry on until complete (and being hardware I can see their effect by looking across the room).</p>
<p>This is in python 2.7. </p>
<p><strong>UPDATE:</strong></p>
<p>The solution seems to be to switch to using multiprocessing.Process instead of a thread pool.  The test code I tried is to run foo_pulse:</p>
<pre><code>class foo(object):
    def foo_pulse(self,nPulse,name): #just one method of *many*
        print('starting pulse for '+name)
        result=[]
        for ii in range(nPulse):
            print('on for '+name)
            time.sleep(2)
            print('off for '+name)
            time.sleep(2)
            result.append(ii)
        return result,name
</code></pre>
<p>If you try running this using ThreadPool then ctrl-C does not stop foo_pulse from running (even though it does kill the threads right away, the print statements keep on coming:</p>
<pre><code>from multiprocessing.pool import ThreadPool
import time
def test(nPulse):
    a=foo()
    pool=ThreadPool(processes=4)
    threads=[]
    for rn in range(4) :
        r=pool.apply_async(a.foo_pulse,(nPulse,'loop '+str(rn)))
        threads.append(r)
    alive=[True]*4
    try:
        while any(alive) : #wait until all threads complete
            for rn in range(4):
                alive[rn] = not threads[rn].ready() 
                time.sleep(1)
    except : #stop threads if user presses ctrl-c
        print('trying to stop threads')
        pool.terminate()
        print('stopped threads') # this line prints but output from foo_pulse carried on.
        raise
    else : 
        for t in threads : print(t.get())
</code></pre>
<p>However a version using multiprocessing.Process works as expected:</p>
<pre><code>import multiprocessing as mp
import time
def test_pro(nPulse):
    pros=[]
    ans=[]
    a=foo()
    for rn in range(4) :
        q=mp.Queue()
        ans.append(q)
        r=mp.Process(target=wrapper,args=(a,"foo_pulse",q),kwargs={'args':(nPulse,'loop '+str(rn))})
        r.start()
        pros.append(r)
    try:
        for p in pros : p.join()
        print('all done')
    except : #stop threads if user stops findRes
        print('trying to stop threads')
        for p in pros : p.terminate()
        print('stopped threads')
    else : 
        print('output here')
        for q in ans :
            print(q.get())
    print('exit time')
</code></pre>
<p>Where I have defined a wrapper for the library foo (so that it did not need to be re-written).  If the return value is not needed the neither is this wrapper :</p>
<pre><code>def wrapper(a,target,q,args=(),kwargs={}):
    '''Used when return value is wanted'''
    q.put(getattr(a,target)(*args,**kwargs))
</code></pre>
<p>From the documentation I see no reason why a pool would not work (other than a bug).</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a very interesting use of parallelism. </p>
<p>However, if you are using <code>multiprocessing</code>, the goal is to have many processes running in parallel, as opposed to one process running many threads. </p>
<p>Consider these few changes to implement it using <code>multiprocessing</code>:</p>
<p>You have these functions that will run in parallel:</p>
<pre><code>import time
import multiprocessing as mp


def some_long_task_from_library(wtime):
    time.sleep(wtime)


class MyException(Exception): pass

def do_other_stuff_for_a_bit():
    time.sleep(5)
    raise MyException("Something Happened...")
</code></pre>
<p>Let's create and start the processes, say 4:</p>
<pre><code>procs = []  # this is not a Pool, it is just a way to handle the
            # processes instead of calling them p1, p2, p3, p4...
for _ in range(4):
    p = mp.Process(target=some_long_task_from_library, args=(1000,))
    p.start()
    procs.append(p)
mp.active_children()   # this joins all the started processes, and runs them.
</code></pre>
<p>The processes are running in parallel, presumably in a separate cpu core, but that is to the OS to decide. You can check in your system monitor.</p>
<p>In the meantime you run a process that will break, and you want to stop the running processes, not leaving them orphan:</p>
<pre><code>try:
    do_other_stuff_for_a_bit()
except MyException as exc:
    print(exc)
    print("Now stopping all processes...")
    for p in procs:
        p.terminate()
print("The rest of the process will continue")
</code></pre>
<p>If it doesn't make sense to continue with the main process when one or all of the subprocesses have terminated, you should handle the exit of the main program.</p>
<p>Hope it helps, and you can adapt bits of this for your library.</p>
</div>
<div class="post-text" itemprop="text">
<p>In answer to the question of why pool did not work then this is due to (as quoted in the <a href="https://docs.python.org/3.1/library/multiprocessing.html" rel="nofollow noreferrer">Documentation</a>) then <strong>main</strong> needs to be importable by the child processes and due to the nature of this project interactive python is being used.  </p>
<p>At the same time it was not clear why ThreadPool would - although the clue is right there in the name.  ThreadPool creates its pool of worker processes using multiprocessing.dummy which as noted <a href="https://stackoverflow.com/questions/26432411/multiprocessing-dummy-in-python">here</a> is just a wrapper around the Threading module.  Pool uses the multiprocessing.Process.  This can be seen by this test:</p>
<pre><code>p=ThreadPool(processes=3)
p._pool[0]
&lt;DummyProcess(Thread23, started daemon 12345)&gt; #no terminate() method

p=Pool(processes=3)
p._pool[0]
&lt;Process(PoolWorker-1, started daemon)&gt; #has handy terminate() method if needed
</code></pre>
<p>As threads do not have a terminate method the worker threads carry on running until they have completed their current task.  Killing threads is messy (which is why I tried to use the multiprocessing module) but solutions are <a href="https://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread-in-python">here</a>.</p>
<p>The one warning about the solution using the above:</p>
<pre><code>def wrapper(a,target,q,args=(),kwargs={}):
    '''Used when return value is wanted'''
    q.put(getattr(a,target)(*args,**kwargs))
</code></pre>
<p>is that changes to attributes inside the instance of the object are not passed back up to the main program.  As an example the class foo above can also have methods such as: 
def addIP(newIP):
self.hardwareIP=newIP
A call to <code>r=mp.Process(target=a.addIP,args=(127.0.0.1))</code> does not update <code>a</code>.</p>
<p>The only way round this for a complex object seems to be shared memory using a custom <code>manager</code> which can give access to both the methods and attributes of object <code>a</code> For a very large complex object based on a library this may be best done using <code>dir(foo)</code> to populate the manager.  If I can figure out how I'll update this answer with an example (for my future self as much as others).</p>
</div>
<span class="comment-copy">Do you have any reason to use undocumented classes? You'd probably have better luck with <code>concurrent.futures</code> module.</span>
<span class="comment-copy">No real reason to use the undocumented classes - other than this is what was used in the example code I came across when researching how to do it.</span>
<span class="comment-copy">@SuperSaiyan: It's documented under a different name; <code>ThreadPool</code> there is exposed in a documented fashion under <code>multiprocessing.dummy.Pool</code>, where <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.dummy" rel="nofollow noreferrer"><code>multiprocessing.dummy</code> is a close copy of the <code>multiprocessing</code> API backed by threads instead of processes</a>.</span>
<span class="comment-copy">In my case it did not matter if everything runs on the same CPU, the reason for running in parallel is that there are massive waits on IO.  However this method works with the one downside that it is hard to return values from the calls.  For now I solved this with a wrapper function - see my updated post.</span>
<span class="comment-copy">Depending of which kind of values you need to return from the calls, you can use <code>Queue</code>, <code>Pipe</code>, shared memory <code>Value</code> or <code>Array</code>, or even a disk file. In some of these cases you may need to use <code>Lock</code>s.</span>
