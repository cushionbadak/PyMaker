<div class="post-text" itemprop="text">
<p>I have a dictionary filled with key-object pairs. I want to make the dictionary immutable and I thought the best/easiest way is to cast it to a frozenset but <code>frozenset(dict)</code> and also <code>tuple(dict)</code> only stores the keys.</p>
<p>Using <code>frozenset(dict.items())</code> I seem to get a frozenset with the key-object pairs but I don't know how to retrieve the values/keys.</p>
<p>I have the following code which works, as long as "__obfuscators" is a dictionary</p>
<pre><code>def obfuscate_value(self, key, value):
    obfuscator = self.__obfuscators.get(key)
    if obfuscator is not None:
        return obfuscator.obfuscate_value(value)
    else:
        return value
</code></pre>
<p>I tried this in an attempt to get it working with the frozen set:</p>
<pre><code>def obfuscate_value(self, key, value):
    try:
        obfuscator = self.__obfuscators[key]
    except:
        return value
    return obfuscator.obfuscate_value(value)
</code></pre>
<p>but this gives that <code>frozenset does not have \__getitem__</code>
and <code>self.__obfuscators.__getattribute__(key)</code> always says it does not have the attribute (because I assume this searches for a function named key)
Is there a better way to make the dictionary immutable or how can I retrieve the object depending on the key?</p>
<p>Edit:
I ended up casting the dict to a tuple using <code>tuple(obfuscator.items())</code>
and then wrote my own find value function:</p>
<pre><code>def find_obfuscator(self, key):
    for item in self.__obfuscators:
        x, y = item
        if self.case_insensitive:
            if x.lower() == key.lower():
                return y
        else:
            if x == key:
                return y
</code></pre>
<p>I would like to thank everyone for their efforts and input.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create an immutable view of a dictionary using <a href="https://docs.python.org/3/library/types.html#types.MappingProxyType" rel="nofollow"><code>types.MappingProxyType</code></a>:</p>
<pre><code>from types import MappingProxyType
d = { 'a': 1 }
fd = MappingProxyType(d)
fd['a']
#output:
1

fd['a'] = 2
#output:
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'mappingproxy' object does not support item assignment
</code></pre>
<p>notice that you can still change the vaule object, so:</p>
<pre><code>d = { 'a': [1] }
fd = MappingProxyType(d)
fd['a'].append(2)
fd['a']
#output:
[1,2]
</code></pre>
<p>will work.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could make a wrapper class that takes a dictionary and has a get item function but no set item.  You'd need to add a few things for thread safety and hashing maybe but the basic class wouldn't be too difficult.</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest way I could think of to achieve what you want was to subclass the standard <code>dict</code> type and overwrite its <code>__setitem__</code> method:</p>
<pre><code>class MyDict(dict):
    def __setitem__(self, key, value):
        raise NotImplementedError("This is a frozen dictionary")
</code></pre>
<p>This allows you to create dictionaries that cannot thereafter be changed by item assignment:</p>
<pre><code>d = MyDict({1: 2, 3: 4})
</code></pre>
<p>or, equivalently:</p>
<pre><code>d = MyDict([(1, 2), (3, 4)])
</code></pre>
<p>The dict then prints out just like a standard dict:</p>
<pre><code>{1: 2, 3: 4}
</code></pre>
<p>But when you try to change a value (or add a new one):</p>
<pre><code>d[1] = 15
---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
&lt;ipython-input-21-a22420992053&gt; in &lt;module&gt;()
----&gt; 1 d[1] = 34

&lt;ipython-input-18-03f266502231&gt; in __setitem__(self, key, value)
      1 class MyDict(dict):
      2     def __setitem__(self, key, value):
----&gt; 3         raise NotImplementedError("This is a frozen dictionary")

NotImplementedError: This is a frozen dictionary
</code></pre>
<p>Note that this isn't fully immutable, however:</p>
<pre><code>d.update({1:17})
</code></pre>
<p>for example, will update it, but this solution might be good enough - it depends on the broader requirements.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you mention <code>tuple(dict)</code> in your original post, probably the simplest solution to achieve what you want might simply be:</p>
<pre><code>tuple(dict.items())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need a <code>dict</code> that is capable of freezing? You can simply make one:</p>
<pre><code>class FrozenDict(dict):
    def __init__(self, *args, **kwargs):
        self._frozen = False
        dict.__init__(self, *args, **kwargs)
    def freeze(self):
        self._frozen = True
    def __setitem__(self, key, value):
        if (self._frozen):
            raise TypeError("Attempted assignment to a frozen dict")
        else:
            return dict.__setitem__(self, key, value)

a = FrozenDict({7:8})
a[5] = 6
print(a)
a.freeze()
a[3] = 2 # raises TypeError
</code></pre>
<p>It will behave exactly like usual <code>dict</code> until you call <code>.freeze()</code>. Then it's frozen.</p>
</div>
<span class="comment-copy">what about subclassing<code>collections.Mapping</code> or using a <code>Mappingproxy</code>. As far as I know both are immutable (for a given value of immutable).</span>
<span class="comment-copy">I did think about this but I hoped there would be an easier/faster solution than making an own custom dictionary class. Especially since I seemed like I was so close now because I have a frozenset with key-object pairs, but I just cannot access them or at least I don't know how</span>
<span class="comment-copy">with this option I still face the same problem as in the <code>frozenset(dict.items())</code>. How can I access the value, based on the key?</span>
<span class="comment-copy">when thinking about this option again I realized it would probably be the easiers solution, if I made my own search function since all the other options are not more simple</span>
