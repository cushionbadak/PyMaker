<div class="post-text" itemprop="text">
<p>I coding a script in python to read a .INI file. I know there is a library called configparser, but my .INI is a little different from the "standard".</p>
<p>In general, the files should be like:</p>
<pre><code>[HEADER]
username = john
fruits = oranges, apples
</code></pre>
<p>but in my case, I have to read something like that:</p>
<pre><code>[HEADER]
username john
fruits oranges apples
</code></pre>
<p>Is there any easy way to do that or I have to make my own parser?</p>
<p>-- Edited --</p>
<p>Guys, thanks for the answers. I forgot to mention something very important. In the INI file (It is generated by a proprietary and painfull software), It also can have multiple lines with the same key. I will give you an example. </p>
<pre><code>[HEADER]
day1 bananas oranges
day1 apples avocado
day2 bananas apples
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This seems like the kind of thing you'll have to write your own parser to handle. I'd still drop it into a <code>ConfigParser</code> object, but only so it can be more easily used in the future. <code>configparser.ConfigParser</code> can do <em>almost</em> everything you need to do. I'm not aware of any way to tell it to treat</p>
<pre><code>[SomeHeader]
foo = bar
foo = baz
</code></pre>
<p>as <code>config["SomeHeader"]["foo"] == ["bar", "baz"]</code> as you mention near the end of your question.</p>
<p>You could try something like:</p>
<pre><code>def is_section_header(text):
    # what makes a section header? To me it's a word enclosed by
    # square brackets.
    match = re.match(r"\[([^\]]+)\]", text)
    if match:
        return match.group(1)

def get_option_value_tuple(line):
    """Returns a tuple of (option, comma-separated values as a string)"""
    option, *values = line.split(" ")
    return (option, ", ".join(values))

def parse(filename):
    config = configparser.ConfigParser()
    cursection = None
    with open(filename) as inifile:
        for line in inifile:
            sectionheader = is_section_header(line)
            if sectionheader:
                cursection = sectionheader
                try:
                    config.add_section(sectionheader)
                except configparser.DuplicateSectionError:
                    # This section already exists!
                    # how should you handle this?
                    continue  # ignore for now
            else:
                option, values = get_option_value_tuple(line.strip())
                if config.has_option(cursection, option):
                    config[cursection][option] += (", " + values)
                else:
                    config[cursection][option] = values
    return config
</code></pre>
<p>This will make:</p>
<pre><code>[SomeHeader]
foo bar baz
foo spam eggs
bar baz
</code></pre>
<p>parse the same as a standard parse of</p>
<pre><code>[SomeHeader]
foo = bar, baz, spam, eggs
bar = baz
</code></pre>
</div>
<span class="comment-copy">Parsing this manually isn't even too hard - as long as none of your parameter names are meant to contain a space, you can get away with something like <code>line.split(' ')</code>.</span>
<span class="comment-copy">Just convert from your ini to regular ini before parsing: <code>newline = line.split(' ')[0] + "=" + ", ".join( line.split(' ')[1:]</code></span>
<span class="comment-copy">Your example looks simple but there may be complications lurking in its format. If the same header appears twice, does it add or overwrite? Does it allow substitution variables? Can it have comments and what does it use to demark them? Can options have multiple values and how are they represented? Confiig parsing is a dark art!</span>
<span class="comment-copy">See <a href="https://docs.python.org/3/library/configparser.html#customizing-parser-behaviour" rel="nofollow noreferrer">the documentation on customizing the parser behavior</a>. It looks like at minimum you're looking at <code>configparser.ConfigParser(delimiters=(" ",), strict=False)</code> however you don't define what your last example should do!</span>
<span class="comment-copy">Hi guys, when there are two lines with same key, the software just concatenate the values. I don't know why they choose do that.  In my example, a guy ate four fruits in day1 (bananas, oragens, apples and avocado). And I'm sorry, I'm not a english native speaking, so I'm not sure if I've been clearly enough.</span>
<span class="comment-copy">Thank you everybody for all the answers. Thank you Adam. I wasn't expecting for a working code, but it will really help me since I'm a beginner in programming.</span>
