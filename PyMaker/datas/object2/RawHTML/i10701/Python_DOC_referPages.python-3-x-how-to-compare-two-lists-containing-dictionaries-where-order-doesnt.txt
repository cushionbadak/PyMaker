<div class="post-text" itemprop="text">
<p>I have nested dictionaries that may contain other dictionaries or lists. I need to be able to compare a list (or set, really) of these dictionaries to show that they are equal. </p>
<p>The order of the list is not uniform. Typically, I would turn the list into a set, but it is not possible since there are values that are also dictionaries. </p>
<pre><code>a = {'color': 'red'}
b = {'shape': 'triangle'}
c = {'children': [{'color': 'red'}, {'age': 8},]}

test_a = [a, b, c] 
test_b = [b, c, a]

print(test_a == test_b)  # False
print(set(test_a) == set(test_b))  # TypeError: unhashable type: 'dict'
</code></pre>
<p>Is there a good way to approach this to show that <code>test_a</code> has the same contents as <code>test_b</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a simple loop to check if each of one list is in the other:</p>
<pre><code>def areEqual(a, b):
    if len(a) != len(b):
        return False

    for d in a:
        if d not in b:
            return False
    return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suggest writing a function that turns any Python object into something orderable, with its contents, if it has any, in sorted order. If we call it <code>canonicalize</code>, we can compare nested objects with:</p>
<pre><code>canonicalize(test_a) == canonicalize(test_b)
</code></pre>
<p>Here's my attempt at writing a <code>canonicalize</code> function:</p>
<pre><code>def canonicalize(x):
    if isinstance(x, dict):
        x = sorted((canonicalize(k), canonicalize(v)) for k, v in x.items())
    elif isinstance(x, collections.abc.Iterable) and not isinstance(x, str):
        x = sorted(map(canonicalize, x))
    else:
        try:
            bool(x &lt; x) # test for unorderable types like complex
        except TypeError:
            x = repr(x) # replace with something orderable
    return x
</code></pre>
<p>This should work for most Python objects. It won't work for lists of heterogeneous items, containers that contain themselves (which will cause the function to hit the recursion limit), nor <code>float('nan')</code> (which has bizarre comparison behavior, and so may mess up the sorting of any container it's in).</p>
<p>It's possible that this code will do the wrong thing for non-iterable, unorderable objects, if they don't have a <code>repr</code> function that describes all the data that makes up their value (e.g. what is tested by <code>==</code>). I picked <code>repr</code> as it will work on any kind of object and <em>might</em> get it right (it works for <code>complex</code>, for example). It should also work as desired for classes that have a <code>repr</code> that looks like a constructor call. For classes that have inherited <code>object.__repr__</code> and so have <code>repr</code> output like <code>&lt;Foo object at 0xXXXXXXXX&gt;</code> it at least won't crash, though the objects will be compared by identity rather than value. I don't think there's any truly universal solution, and you can add some special cases for classes you expect to find in your data if they don't work with <code>repr</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the elements in both lists are shallow, the idea of sorting them, and then comparing with equality can work. The problem with @Alex's solution is that he is only using "id" - but if instead of id, one uses a function that will sort dictionaries properly, things shuld just work:</p>
<pre><code>def sortkey(element):
   if isinstance(element, dict):
         element = sorted(element.items())
   return repr(element)

sorted(test_a, key=sortkey) == sorted(test_b, key=sotrkey) 
</code></pre>
<p>(I use an <code>repr</code> to wrap the key because it will cast all elements to string before comparison, which will avoid typerror if different elements are of unorderable types - which would almost certainly happen if you are using Python 3.x)</p>
<p>Just to be clear, if your dictionaries and lists have nested dictionaries themselves, you should use the answer by @m_callens. If your inner lists are also unorderd, you can fix this to work, jsut sorting them inside the key function as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>In this case they are the same dicts so you can compare ids (<a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow">docs</a>). Note that if you introduced a new <code>dict</code> whose values were identical it would still be treated differently. I.e. <code>d = {'color': 'red'}</code> would be treated as not equal to <code>a</code>. </p>
<pre><code>sorted(map(id, test_a)) == sorted(map(id, test_b))
</code></pre>
<p>As @jsbueno points out, you can do this with the kwarg <code>key</code>.</p>
<pre><code>sorted(test_a, key=id) == sorted(test_b, key=id)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An elegant and relatively fast solution:</p>
<pre><code>class QuasiUnorderedList(list):
    def __eq__(self, other):
        """This method isn't as ineffiecient as you think! It runs in O(1 + 2 + 3 + ... + n) time, 
        possibly better than recursively freezing/checking all the elements."""
        for item in self:
            for otheritem in other:
                if otheritem == item:
                    break
            else:
                # no break was reached, item not found.
                return False
        return True
</code></pre>
<p>This runs in <code>O(1 + 2 + 3 + ... + n)</code> flat. While slow for dictionaries of low depth, this is faster for dictionaries of high depth. </p>
<p>Here's a considerably longer snippet which is faster for dictionaries where depth is low and length is high.</p>
<pre><code>class FrozenDict(collections.Mapping, collections.Hashable):  # collections.Hashable = portability
    """Adapated from http://stackoverflow.com/a/2704866/1459669"""

    def __init__(self, *args, **kwargs):
        self._d = dict(*args, **kwargs)
        self._hash = None

    def __iter__(self):
        return iter(self._d)

    def __len__(self):
        return len(self._d)

    def __getitem__(self, key):
        return self._d[key]

    def __hash__(self):
        # It would have been simpler and maybe more obvious to
        # use hash(tuple(sorted(self._d.iteritems()))) from this discussion
        # so far, but this solution is O(n). I don't know what kind of
        # n we are going to run into, but sometimes it's hard to resist the
        # urge to optimize when it will gain improved algorithmic performance.
        # Now thread safe by CrazyPython
        if self._hash is None:
            _hash = 0
            for pair in self.iteritems():
                _hash ^= hash(pair)
        self._hash = _hash
        return _hash


def freeze(obj):
    if type(obj) in (str, int, ...):  # other immutable atoms you store in your data structure
        return obj
    elif issubclass(type(obj), list):  # ugly but needed
        return set(freeze(item) for item in obj)
    elif issubclass(type(obj), dict):  # for defaultdict, etc.
        return FrozenDict({key: freeze(value) for key, value in obj.items()})
    else:
        raise NotImplementedError("freeze() doesn't know how to freeze " + type(obj).__name__ + " objects!")


class FreezableList(list, collections.Hashable):
    _stored_freeze = None
    _hashed_self = None

    def __eq__(self, other):
        if self._stored_freeze and (self._hashed_self == self):
            frozen = self._stored_freeze
        else:
            frozen = freeze(self)
        if frozen is not self._stored_freeze:
            self._stored_hash = frozen
        return frozen == freeze(other)

    def __hash__(self):
        if self._stored_freeze and (self._hashed_self == self):
            frozen = self._stored_freeze
        else:
            frozen = freeze(self)
        if frozen is not self._stored_freeze:
            self._stored_hash = frozen
        return hash(frozen)


class UncachedFreezableList(list, collections.Hashable):
    def __eq__(self, other):
        """No caching version of __eq__. May be faster.
        Don't forget to get rid of the declarations at the top of the class!
        Considerably more elegant."""
        return freeze(self) == freeze(other)

    def __hash__(self):
        """No caching version of __hash__. See the notes in the docstring of __eq__2"""
        return hash(freeze(self))
</code></pre>
<p>Test all three (<code>QuasiUnorderedList</code>, <code>FreezableList</code>, and <code>UncachedFreezableList</code>) and see which one is faster in your situation. I'll betcha it's faster than the other solutions.</p>
</div>
<span class="comment-copy">You're going to need to write a custom function to traverse your data structures and determine equality. There is no built-in capability for this.</span>
<span class="comment-copy">are the inner lists uniform? Or do their elements can be in arbitrary order as well? Do they nest mora than two levels (i.e., the conatined elements and lists can contain other lists and dictionaries themselves) - or are all elements on the lists you are comparing shallow?</span>
<span class="comment-copy">@uoɥʇʎPʎzɐɹC: Less trivial than you might think, if you want it to be efficient and not fragile.</span>
<span class="comment-copy">How did you end up with such different formats?</span>
<span class="comment-copy">@jsbueno yes, elements can be in arbitrary order, yes they can contain other lists or dictionaries</span>
<span class="comment-copy">You should check the other direction too</span>
<span class="comment-copy">comsider <code>a=[1]</code> and <code>b=[1,2]</code>, your function return <code>True</code></span>
<span class="comment-copy">test it with [a, b, c] and [a, b, c, d] you will see :)</span>
<span class="comment-copy">@OhadEytan ahh yes, I see what you mean...good point</span>
<span class="comment-copy">Thank you, this does make sense for the example I provided. In my actual scenario, there may be additional nested arrays deeper that would keep this from working (since order matters)</span>
<span class="comment-copy">thank you. Unfortunately in the real case I am not comparing the same dicts, but rather two dicts with the same contents</span>
<span class="comment-copy">Besides not resolving the problem, this usage of "sorted" is incorrect unless one really wants the IDs - you should be using the <code>key</code> argument to sorted, instead of using <code>map</code> on the source lists.</span>
<span class="comment-copy"><code>O(1+2+3+...+n)</code> time is <code>O(n**2)</code> time. You also have <code>QuasiUnorderedList([1, 2]) == [1, 2, 3]</code>, and your implementation is generally slower than the one m_callens posted earlier.</span>
<span class="comment-copy">@user2357112 Yes, worst case <code>O(n**2)</code> time. But in practice, is <code>1+2+3</code> equal to <code>3**2</code>?</span>
<span class="comment-copy"><code>1+2+3&gt;(3**2)/2</code>, and in general, <code>1+2+3+...+n==(n**2+n)/2</code>. If you want to argue constant factors, you still have a worse constant factor than what m_callens posted.</span>
