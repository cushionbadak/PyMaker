<div class="post-text" itemprop="text">
<p>I am trying to understand the new <a href="https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines" rel="nofollow noreferrer">async</a> coroutines (introduced in Python 3.5). </p>
<p>In 1997 I attended a course at university which roughly covered the content of the book <a href="https://en.wikipedia.org/wiki/Modern_Operating_Systems" rel="nofollow noreferrer">Modern Operating Systems</a> by Andrew Tanenbaum.</p>
<p>Somehow the <code>await</code> in Python3 reminds me at <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking" rel="nofollow noreferrer">Cooperative Multitasking</a>.</p>
<p>From Wikipedia:</p>
<blockquote>
<p>Cooperative multitasking, also known as non-preemptive multitasking, is a style of computer multitasking in which the operating system never initiates a context switch from a running process to another process. Instead, processes voluntarily yield control periodically or when idle in order to enable multiple applications to be run simultaneously. This type of multitasking is called "cooperative" because all programs must cooperate for the entire scheduling scheme to work. </p>
</blockquote>
<p>If you look at the Python interpreter like an operating system, does the term "Cooperative Multitasking" apply to <code>await</code>?</p>
<p>But may be I am missing something. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Inside a coroutine function, the await expression can be used to
  suspend coroutine execution until the result is available. Any object
  can be awaited, as long as it implements the awaitable protocol by
  defining the <strong>await</strong>() method.</p>
</blockquote>
<p>A coroutine can pause execution using the await keyword with another coroutine. While it is paused, the coroutineâ€™s state is maintained, allowing it to resume where it left off the next time it is awakened. <em>That sounds quite like Cooperative multitasking to me</em>. See this <a href="https://pymotw.com/3/asyncio/coroutines.html" rel="noreferrer">example</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It is cooperative multitasking indeed.</p>
<p>What about a small program to prove it. Let's first sleep with cooperative <code>asyncio.sleep</code> for a second and then let's sleep with blocking <code>time.sleep</code> for a second. Let's print a thread id, time spent in the coroutine and id of a task.</p>
<pre><code>import threading
import asyncio
import time

async def async_function(i):
    started = time.time()
    print("Id:", i, "ThreadId:", threading.get_ident())
    await asyncio.sleep(1)
    time.sleep(1)
    print("Id:", i, "ThreadId:", threading.get_ident(), "Time:", time.time() - started)

async def async_main():
    await asyncio.gather(
        async_function(1),
        async_function(2),
        async_function(3)
    )

loop = asyncio.get_event_loop()
loop.run_until_complete(async_main())
</code></pre>
<p>Now let's try and see:</p>
<pre><code>Id: 3 ThreadId: 140027884312320
Id: 2 ThreadId: 140027884312320
Id: 1 ThreadId: 140027884312320
Id: 3 ThreadId: 140027884312320 Time: 2.002575397491455
Id: 2 ThreadId: 140027884312320 Time: 3.0038201808929443
Id: 1 ThreadId: 140027884312320 Time: 4.00504469871521
</code></pre>
<p>As expected. Execution was only in one thread. <code>asyncio.sleep(1)</code> is nonblocking, so it took 1 second to process all of them concurrently. <code>time.sleep(1)</code> is blocking (it does not cooperate), so it blocks the rest. Id <code>1</code> waits for id <code>2</code> to finish while id <code>2</code> waits for id <code>3</code> to finish.</p>
<h1>C# has async/await too, does it have cooperative multitasking as well?</h1>
<p>Let's try the same thing in C#:</p>
<pre><code>using System;
using System.Threading;
using System.Threading.Tasks;

namespace AsyncTest
{
    class MainClass {
        private static async Task AsyncMethod(int id) {
            var started = DateTime.Now;
            Console.WriteLine("Id: {0} ThreadId: {1}", id, Thread.CurrentThread.ManagedThreadId);
            await Task.Delay(1000);
            Thread.Sleep(1000);
            Console.WriteLine("Id: {0} ThreadId: {1} Time: {2}", id, Thread.CurrentThread.ManagedThreadId, DateTime.Now - started);
        }

        private static async Task MainAsync()
        {
            await Task.WhenAll(AsyncMethod(1), AsyncMethod(2), AsyncMethod(3));
        }

        public static void Main (string[] args) {
            MainAsync().Wait();
        }
    }
}
</code></pre>
<p>Run it and...</p>
<pre><code>Id: 1 ThreadId: 1
Id: 2 ThreadId: 1
Id: 3 ThreadId: 1
Id: 2 ThreadId: 7 Time: 00:00:02.0147000
Id: 3 ThreadId: 8 Time: 00:00:02.0144560
Id: 1 ThreadId: 6 Time: 00:00:02.0878160
</code></pre>
<p>Damn. The threads are different after await. And it tooks just 2 seconds for each of the coroutine! What's wrong?</p>
<p>Nothing is wrong. <strong>Unlike Python, async/await in C# has a combination of cooperative multitasking and multithreading.</strong> <code>Task.Delay(1000)</code> is indeed nonblocking but when a coroutine resumes, it can resume in a totally different thread as it did in the example. Since the coroutines continued in three different threads, <code>Thread.Sleep(1000)</code> blocked them in parallel.</p>
<p>Note there are more things in C# which can influence this behavior (like SynchronizationContext), but this is a different topic.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes. According to <a href="https://en.wikipedia.org/wiki/Coroutine" rel="nofollow">Wikipedia</a>: </p>
<blockquote>
<p>Coroutines are computer program components that generalize subroutines for <strong>nonpreemptive multitasking</strong>, by allowing multiple entry points for suspending and resuming execution at certain locations.</p>
</blockquote>
</div>
<span class="comment-copy">"await coroutines" is a somewhat nonsense term. Can I suggest you change your question to refer to "asyncio coroutines" where asyncio refers to the stdlib module, to distinguish it from other coroutines systems (such as gevent, twisted.)  You can use "await" to describe a type of expression.</span>
<span class="comment-copy">@GaryvanderMerwe I changed to "async coroutines". Is it ok now?</span>
<span class="comment-copy">I think the fact that we can relinquish the control to the event-loop by using <code>await asyncio.sleep(0)</code>  (inside long running function for example, see <a href="https://github.com/python/asyncio/issues/284" rel="nofollow noreferrer">this discussion on github</a> for example) is also something that makes it sounds like cooperative multitasking.</span>
<span class="comment-copy">Why is it that in your python output, the first 3 lines show ids in decreasing order, instead of in increasing order?</span>
<span class="comment-copy">@AjaxLeung that's a good question. It's definitely up to the scheduler to schedule coroutines. On macos with Python 3.7.0 I get always 1, 2, 3; on Linux with Python 3.6.1 (from repl.it) I always get 2, 3, 1. Don't remember what exact combination of OS and version was used for the execution in the answer.</span>
