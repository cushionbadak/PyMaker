<div class="post-text" itemprop="text">
<p>I'm digging through some old binaries that contain (among other things) text. Their text frequently uses custom character encodings for Reasons, and I want to be able to read and rewrite them.</p>
<p>It seems to me that the appropriate way to do this is to create a custom codec using the <a href="https://docs.python.org/3.5/library/codecs.html" rel="noreferrer">standard codecs library</a>. Unfortunately its documentation is both colossal and entirely bereft of examples. Google turns up a few, but only for python2, and I'm using 3.</p>
<p>I'm looking for a minimal example of how to use the codecs library to implement a custom character encoding.</p>
</div>
<div class="post-text" itemprop="text">
<p>You asked for minimal!</p>
<ul>
<li>Write a encode function and a decode function.</li>
<li>Write a "search function" that returns a <code>CodecInfo</code> object constructed from the above encoder and decoder.</li>
<li>Use <a href="https://docs.python.org/3/library/codecs.html#codecs.register" rel="noreferrer">codec.register</a> to register a function that returns the above <code>CodecInfo</code> object.</li>
</ul>
<p>Here is an example that converts the lowercase letters a-z to 0-25 in order.</p>
<pre><code>import codecs
import string

# prepare map from numbers to letters
_encode_table = {str(number): bytes(letter, 'ascii') for number, letter in enumerate(string.ascii_lowercase)}

# prepare inverse map
_decode_table = {ord(v): k for k, v in _encode_table.items()}


def custom_encode(text: str) -&gt; bytes:
    # example encoder that converts ints to letters
    # see https://docs.python.org/3/library/codecs.html#codecs.Codec.encode
    return b''.join(_encode_table[x] for x in text), len(text)


def custom_decode(binary: bytes) -&gt; str:
    # example decoder that converts letters to ints
    # see https://docs.python.org/3/library/codecs.html#codecs.Codec.decode
    return ''.join(_decode_table[x] for x in binary), len(binary)


def custom_search_function(encoding_name):
    return codecs.CodecInfo(custom_encode, custom_decode, name='Reasons')


def main():

    # register your custom codec
    # note that CodecInfo.name is used later
    codecs.register(custom_search_function)

    binary = b'abcdefg'
    # decode letters to numbers
    text = codecs.decode(binary, encoding='Reasons')
    print(text)
    # encode numbers to letters
    binary2 = codecs.encode(text, encoding='Reasons')
    print(binary2)
    # encode(decode(...)) should be an identity function
    assert binary == binary2

if __name__ == '__main__':
    main()
</code></pre>
<p>Running this prints</p>
<pre><code>$ python codec_example.py
0123456
b'abcdefg'
</code></pre>
<p>See <a href="https://docs.python.org/3/library/codecs.html#codec-objects" rel="noreferrer">https://docs.python.org/3/library/codecs.html#codec-objects</a> for details on the <code>Codec</code> interface. In particular, the decode function</p>
<blockquote>
<p>... decodes the object <em>input</em> and returns a tuple (output object, length
  consumed).</p>
</blockquote>
<p>whereas the encode function</p>
<blockquote>
<p>... encodes the object <em>input</em> and returns a tuple (output object, length consumed).</p>
</blockquote>
<p>Note that you should also worry about handling streams, incremental encoding/decoding, as well as error handling. For a more complete example, refer to the <a href="https://github.com/pyserial/pyserial/blob/master/serial/tools/hexlify_codec.py" rel="noreferrer">hexlify codec</a> that @krs013 mentioned.</p>
<hr/>
<p>P.S. instead of of <code>codec.decode</code>, you can also use <code>codec.open(..., encoding='Reasons')</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>While the online documentation is certainly sparse, you can get a lot more information by looking at <a href="https://hg.python.org/releasing/3.5.2/file/tip/Lib/codecs.py" rel="nofollow noreferrer" title="codecs.py">the source code</a>. The docstrings and comments are quite clear, and the definitions for the parent classes (Codec, IncrementalEncoder, etc.) are ready to be copy/pasted for a start to your codec (be sure to replace the <code>object</code> in each class definition with the name of the class you're inheriting from). It's also worth looking at the <a href="https://github.com/pyserial/pyserial/blob/master/serial/tools/hexlify_codec.py" rel="nofollow noreferrer" title="hexlify_codec.py">example</a> I linked to in the comments for how to assemble/register it.</p>
<p>I've been stuck at the same point as you for a while looking through this, so good luck! If I have time in a few days, I'll see about actually making that implementation and pasting/linking to it here.</p>
</div>
<span class="comment-copy">Not minimal, but this might be a good place to start: <a href="https://github.com/pyserial/pyserial/blob/master/serial/tools/hexlify_codec.py" rel="nofollow noreferrer">github.com/pyserial/pyserial/blob/master/serial/tools/â€¦</a></span>
<span class="comment-copy">I'm interested in this one also:  <a href="https://github.com/asottile/future-fstrings" rel="nofollow noreferrer">github.com/asottile/future-fstrings</a></span>
<span class="comment-copy">Hey @Andrew - if my answer helped you, don't forget to accept it :)</span>
<span class="comment-copy">@JamesLim: Accepted. I wasn't really expecting an answer after so long.</span>
<span class="comment-copy">Nice work, believe I could follow this. :)  You might want to modify your links from '<i>/3.5/</i>' to '3' so they follow newer versions.</span>
<span class="comment-copy">Hrm, wait a sec. This gets the point across, but I don't think those def lines are valid python...? Unless there's a different function def syntax that I've somehow managed to never see. [edit: never mind, it's type hinting. I learned something today.]</span>
