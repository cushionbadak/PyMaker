<div class="post-text" itemprop="text">
<pre><code>class Person:
    def __init__(self, name):
        """Make a new person with the given name."""
        self.myname = name

    def introduction(myname):
        """Returns an introduction for this person."""
        return "Hi, my name is {}.".format(myname)

# Use the class to introduce Mark and Steve
mark = Person("Mark")
steve = Person("Steve")

print(mark.introduction())
print(steve.introduction())
</code></pre>
<p>its suppose to produce 
"Hi, my name is Mark." or "Hi, my name is Steve."</p>
<p>but instead it produces 
"Hi, my name is undefined."</p>
</div>
<div class="post-text" itemprop="text">
<p>It should be printing the object's representation in memory (something along the lines of <code>Hi, my name is &lt;__main__.Person object at 0x005CEA10&gt;</code>).</p>
<p>The reason is that the first argument of a method is expected to be the object that the method is called upon.</p>
<p>Just like you have <code>def __init__(self, name):</code> you should have <code>def introduction(self, myname):</code>.</p>
<p>Then you will encounter another problem, as <code>introduction</code> now expects an argument <code>myname</code> which you don't provide it. You don't actually need it since you now have access to <code>self.myname</code>.</p>
<pre><code>class Person:
    def __init__(self, name):
        """Make a new person with the given name."""
        self.myname = name

    def introduction(self):
        """Returns an introduction for this person."""
        return "Hi, my name is {}.".format(self.myname)


# Use the class to introduce Mark and Steve
mark = Person("Mark")
steve = Person("Steve")

print(mark.introduction())
print(steve.introduction())
</code></pre>
<p>Will output</p>
<pre><code>Hi, my name is Mark.
Hi, my name is Steve.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to declare <code>introduction()</code> -&gt; <code>introduction(self)</code> as an instance method (<em>by passing in</em> <code>self</code>) to be able to access the instance variable <code>self.myname</code>. </p>
<pre><code>class Person:

    def __init__(self, name):
        """Make a new person with the given name."""
        self.myname = name

    def introduction(self):
        """Returns an introduction for this person."""
        return "Hi, my name is {}.".format(self.myname)
</code></pre>
<p><strong>Sample output:</strong></p>
<pre><code># Use the class to introduce Mark and Steve
mark = Person("Mark")
steve = Person("Steve")

print(mark.introduction())
print(steve.introduction())
&gt;&gt;&gt; Hi, my name is Mark.
&gt;&gt;&gt; Hi, my name 
</code></pre>
<p>Please note however, that the first parameter in a function within a <strong>class</strong> is reserved for either a class, or object to pass itself to (<em>unless a</em> <a href="https://docs.python.org/2/library/functions.html#staticmethod" rel="nofollow"><code>@staticmethod</code></a> <em>tag is applied to the method, then the first implicit parameter is not passed; which essentially behave as module methods</em>).</p>
<p>Also keep in mind that <code>self</code> is not a reserved word, so you could name it anything (<em>even though</em> <code>self</code> <em>is PEP convention</em>). The below example executes the same output as the example above, and is <em>semantically</em> the same. </p>
<pre><code>def introduction(myname):
    """Returns an introduction for this person."""
    return "Hi, my name is {}.".format(myname.myname)
</code></pre>
<p><a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables" rel="nofollow">9.3.5. Class and Instance Variables</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that your giving your introduction method the parameter <code>myname</code>, but never supplying it with a  valid argument.You can simply do:</p>
<pre><code>mark = Person(" Mark")
steve = Person(" Steve")

print(mark.introduction(mark.myname))
print(steve.introduction(steve.myname))
</code></pre>
<p>your giving the introduction method, the variable from your class <code>myname</code>.</p>
<p>But the above is not even necessary. Since your initializing your name variable in the <code>__init__</code> method of your class, it is like a global variable. So you can simply say:</p>
<pre><code>class Person:
    def __init__(self, name):
        """Make a new person with the given name."""
        self.myname = name

    def introduction(self):
        """Returns an introduction for this person."""
        return "Hi, my name is{}".format(self.myname)


# Use the class to introduce Mark and Steve
mark = Person(" Mark")
steve = Person(" Steve")

print(mark.introduction())
print(steve.introduction())
</code></pre>
</div>
<span class="comment-copy">Why must you hate indenting?</span>
<span class="comment-copy">@mrdomoboto that really wasn't needed dude. Just ask the guy to indent his code.</span>
<span class="comment-copy">im sorry. i dont understand. indenting which one?</span>
<span class="comment-copy">@Mr.Python It's basic courtesy when you're asking others to help you out with a question in a language that relies on white-space for scope.</span>
<span class="comment-copy">I completely agree. But there no need to say it that way</span>
