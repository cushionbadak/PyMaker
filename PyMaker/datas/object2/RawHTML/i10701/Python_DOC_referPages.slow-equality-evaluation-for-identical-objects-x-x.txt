<div class="post-text" itemprop="text">
<p>Is there any reason <code>x == x</code> is not evaluated quickly? I was hoping <code>__eq__</code> would check if its two arguments are identical, and if so return True instantly. But it doesn't do it:</p>
<pre><code>s = set(range(100000000))
s == s # this doesn't short-circuit, so takes ~1 sec
</code></pre>
<p>For built-ins, <code>x == x</code> always returns True I think? For user-defined classes, I guess someone could define <code>__eq__</code> that doesn't satisfy this property, but is there any reasonable use case for that?</p>
<p>The reason I want <code>x == x</code> to be evaluated quickly is because it's a huge performance hit when <a href="https://stackoverflow.com/a/12726843/336527">memoizing functions with very large arguments</a>:</p>
<pre><code>from functools import lru_cache
@lru_cache()
def f(s):
    return sum(s)
large_obj = frozenset(range(50000000))
f(large_obj) # this takes &gt;1 sec every time
</code></pre>
<p>Note that the reason @lru_cache is <em>repeatedly</em> slow for large objects is not because it needs to calculate <code>__hash__</code> (this is only done once and is then hard-cached as <a href="https://stackoverflow.com/a/12726793/336527">pointed out</a> by @jsbueno), but because the dictionary's hash table needs to execute <code>__eq__</code> <em>every time</em> to make sure it found the right object in the bucket (equality of hashes is obviously insufficient).</p>
<p>UPDATE:</p>
<p>It seems it's worth considering this question separately for three situations.</p>
<p>1) User-defined types (i.e., not built-in / standard library).</p>
<p>As @donkopotamus pointed out, there are cases where <code>x == x</code> should not evaluate to True. For example, for <code>numpy.array</code> and <code>pandas.Series</code> types, the result is intentionally not convertible to boolean because it's unclear what the natural semantics should be (does False mean the container is empty, or does it mean all items in it are False?).</p>
<p>But here, there's no need for python to do anything, since the users can always short-circuit <code>x == x</code> comparison themselves if it's appropriate:</p>
<pre><code>def __eq__(self, other):
  if self is other:
    return True
  # continue normal evaluation
</code></pre>
<p>2) Python built-in / standard library types.</p>
<p>a) Non-containers.</p>
<p>For all I know the short-circuit may already be implemented for this case - I can't tell since either way it's super fast.</p>
<p>b) Containers (including <code>str</code>).</p>
<p>As @Karl Knechtel commented, adding short-circuit may hurt total performance if the savings from short-circuit are outweighed by the extra overhead in cases where <code>self is not other</code>. While theoretically possible, even in that case the overhead is a small in relative terms (container comparison is never super-fast). And of course, in cases where short-circuit helps, the savings can be dramatic.</p>
<p>BTW, it turns out that <code>str</code> does short-circuit: comparing huge identical strings is instant.</p>
</div>
<div class="post-text" itemprop="text">
<p>As you say, someone could quite easily define an <code>__eq__</code> that you personally don't happen to approve of ... for example, the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" rel="nofollow">Institute of Electrical and Electronics Engineers</a> might be so foolish as to do that:</p>
<pre><code>&gt;&gt;&gt; float("NaN") == float("NaN")
False
</code></pre>
<p>Another "unreasonable use case":</p>
<pre><code>&gt;&gt;&gt; bool(numpy.ma.masked == numpy.ma.masked)
False
</code></pre>
<p>Or even:</p>
<pre><code>&gt;&gt;&gt; numpy.arange(10) == numpy.arange(10)
array([ True,  True,  True,  True,  True,  True,  True,  True,  True,  True], dtype=bool)
</code></pre>
<p>which has the audacity to not even be convertible to <code>bool</code>!</p>
<p>So there is certainly practical scope for <code>x == x</code> to <strong>not</strong> automagically be short-circuited to be true.  </p>
<h3>Going Off Course</h3>
<p>However the following is perhaps a good question:</p>
<blockquote>
<p>Why doesn't <code>set.__eq__</code> check for instance identity?</p>
</blockquote>
<p>Well, one might think ... because a set <code>S</code> might contain <code>NaN</code> and since <code>NaN</code> cannot equal itself then surely such a set <code>S</code> cannot equal itself?  Investigating:</p>
<pre><code>&gt;&gt;&gt; s = set([float("NaN")])
&gt;&gt;&gt; s == s
True
</code></pre>
<p>Hmm, that's interesting, especially since:</p>
<pre><code>&gt;&gt;&gt; {float("NaN")} == {float("NaN")}
False
</code></pre>
<p>This behaviour is due to Python's desire for <a href="https://docs.python.org/3/reference/expressions.html#value-comparisons" rel="nofollow">sequences to be reflexive</a>.</p>
</div>
<span class="comment-copy">'x == x' is NOT always True for built-ins - in particular, NaN (Not A Number) is never equal to anything, not even itself.</span>
<span class="comment-copy">My best guess is "because it would slow down every other comparison, and is thus not optimizing for the common case". But when it's a matter of O(1) vs O(N), and there are practical reasons for the "rare" case to come up frequently in some context like this, I'd side with you in saying an exception should be made. NaN is an exception to that exception, though... it's entirely arguable that it shouldn't be unique and that other user-defined classes might have their own reasons.</span>
<span class="comment-copy">Just write <code>x is y or x == y</code>, or <code>x in (y,)</code> for short.</span>
<span class="comment-copy">@Veedrac I would, but not in <code>lru_cache</code> and not inside the dictionary hash table algorithm..</span>
<span class="comment-copy">@max It's fairly simple to wrap the values to avoid this.</span>
<span class="comment-copy">+1 I don't know how I forgot about NaN, I even complained about this very thing in my own <a href="http://stackoverflow.com/a/10059796/336527">SO answer with the largest number of downvotes</a>... /facepalm</span>
<span class="comment-copy">To answer the question you pose: <code>[float('NaN')] == [float('NaN')]</code></span>
<span class="comment-copy">@RyanHaining Amusingly, I was just writing about your suggestion ... you should investigate: <code>L = [float('NaN')]; L == L</code> versus <code>[float('NaN')] == [float('NaN')]</code></span>
<span class="comment-copy">@donkopotamus now I'm confused, perhaps it's checking with <code>is</code> after all</span>
<span class="comment-copy">looks like a whole new question</span>
