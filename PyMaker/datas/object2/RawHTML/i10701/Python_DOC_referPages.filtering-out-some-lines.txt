<div class="post-text" itemprop="text">
<p>I have a text file (a.txt). here a small part of that:</p>
<pre class="lang-none prettyprint-override"><code>ENSG00000060642.6   0,023999998 0,015999999 0,666666667 0,006410256 0,006410256 1,000000073 0,016393442 0,016393442 1   0,020202022 0,030303031 1,499999908
ENSG00000149136.3   0,03508772  0,01754386  0,5 0,068627447 0,029411765 0,428571456 0,078947365 0,065789476 0,833333396 0,066666663 0,066666663 1
ENSG00000104889.4   0   0   #DIV/0! 0   0   #DIV/0! 0   0   #DIV/0! 0   0   #DIV/0!
ENSG00000157827.15  0,055555556 0,037037037 0,666666667 0,032258064 0,048387095 1,5 0,150000006 0,024999999 0,16666665  0,222222224 0,037037037 0,166666667
ENSG00000146067.11  0   0   #DIV/0! 0   0   #DIV/0! 0   0   #DIV/0! 0   0   #DIV/0!
ENSG00000167700.4   0,299999982 0   0   0,071428567 0,071428567 1   0   0   #DIV/0! 0   0   #DIV/0!
ENSG00000172137.14  0   0   #DIV/0! 0   0   #DIV/0! 0   0   #DIV/0! 1   0   0
ENSG00000178776.4   0   0   #DIV/0! 0   0   #DIV/0! 0   0   #DIV/0! 0   0   #DIV/0!
</code></pre>
<p>I want to filter out all lines including "#DIV/0!", even if there is only one "#DIV/0!", and make a new text file.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do it this way which is incremental (so it doesn't read the entire file into memory at one time):</p>
<pre><code>from itertools import ifilter

with open('a.txt', 'r') as inf, open('new.txt', 'w') as outf:
    outf.writelines(ifilter(lambda line: '#DIV/0!' not in line, inf))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>with open('a.txt') as f, open('b.txt', 'w') as new_file:
    new_file.writelines([line for line in f if '#DIV/0!' not in line])
</code></pre>
<hr/>
<p>Edit:</p>
<p>This method is probably the fastest. But as discussed with @martineau earlier, it could not be the best answer here depending of the size your file.</p>
<ul>
<li><p><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow"><code>list comprehension</code></a> <code>[line for line in f if '#DIV/0!' not in<br/>
line]</code> is very common in python, it replace the piece of code:</p>
<pre><code>l = []
for line in f:
    if '#DIV/0!' not in line:
        l.append(line)
</code></pre></li>
</ul>
<p>but it is more optimised (see here for an explanation: <a href="http://blog.cdleary.com/2010/04/efficiency-of-list-comprehensions/" rel="nofollow">Efficiency of list comprehensions</a>)</p>
<p><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow"><code>list comprehension</code></a> load everything in memory and thus can
   cause a buffer overflow in the case of huge amount of data.</p>
<p>That's why here, using an incremental method (@martineau's one) is safer when you are not sure how many data you will process!</p>
<ul>
<li>The <a href="https://docs.python.org/3/reference/compound_stmts.html#with" rel="nofollow"><code>with</code></a> statement replace a try and catch. It also
automatically close the file after the block. As you can
see, it could also be nested: you can open several file with one
<a href="https://docs.python.org/3/reference/compound_stmts.html#with" rel="nofollow"><code>with</code></a> statement.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>for line in open('a.txt').read().splitlines():
    if '#DIV/0!' not in line:
        print(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>new_file = open('output.txt' , 'w') 
for line in open('a.txt').read().splitlines():
     if '#DIV/0!' not in line: 
           new_file.write(line)
new_file.close()
</code></pre>
</div>
<span class="comment-copy">yes we do. what have you tried?</span>
<span class="comment-copy">As a side note, you may not necessarily need python. If you're on a *nix machine, you can use <code>grep</code>. If you have the original excel, you can use that to produce a clean file.</span>
<span class="comment-copy">Hi martineau, that is great. yesterday I tried to use ifilter but did not work. now I know what the problem was.</span>
<span class="comment-copy">@martineau, could you explain please why <code>ifilter</code> is more powerful in that case than a simple <code>list comprehension</code>?  eg <code>outf.writelines([line for line in inf if '#DIV/0!' not in line])</code>  I was told than <code>list comprehensions</code> are more pythonic but I'm sure you got your reasons.</span>
<span class="comment-copy">@Max: List comprehensions are definitely Pythonic, but not surprisingly, they create a list which requires all of its elements to be in memory at the same timeâ€”which is often just fine. However if there are potentially a lot of them and/or there's no reason to keep them around, it's also Pythonic to process them iteratively, one item at time, which uses the minimum amount of resources. That was the case here as far as I could tell.</span>
<span class="comment-copy">@martineau: fair enough! And well explained, thank you.</span>
<span class="comment-copy">@user3925736: There's also an <a href="https://docs.python.org/2/library/itertools.html#itertools.ifilterfalse" rel="nofollow noreferrer"><code>itertools.ifilterfalse()</code></a> iterator function which would have been an equally valid choice to use to do this (using the conditional <code>'#DIV/0!' in line</code>). Depends on your perspective...</span>
<span class="comment-copy">A short description would go a long way with newbies.</span>
<span class="comment-copy">Done! I fixed my laziness</span>
<span class="comment-copy">Please edit with more information. Code-only and "try this" answers are discouraged, because they contain no searchable content, and don't explain why someone should "try this". We make an effort here to be a resource for knowledge.</span>
