<div class="post-text" itemprop="text">
<p>I have nested tuples in a list like</p>
<pre><code>l = [(1, 'a', 'b'), (2, 'b', 'c'), (3, 'e', 'a')]
</code></pre>
<p>I want to know how many 'a' and 'b' in the list in total. So I currently use the following code to get the result.</p>
<pre><code>amount_a_and_b = len([None for _, elem2, elem3 in l if elem2 == 'a' or elem3 == 'b'])
</code></pre>
<p>But I got <code>amount_a_and_b = 1</code>, so how to get the right answer?</p>
<p>Also, is there a more elegant way (less code or higher performance or using builtins) to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd flatten the list with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>itertools.chain.from_iterable()</code></a> and pass it to a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter()</code> object</a>:</p>
<pre><code>from collections import Counter
from itertools import chain

counts = Counter(chain.from_iterable(l))
amount_a_and_b = counts['a'] + counts['b']
</code></pre>
<p>Or use <code>sum()</code> to count how many times a value appears in the flattened sequence:</p>
<pre><code>from itertools import chain

amount_a_and_b = sum(1 for v in chain.from_iterable(l) if v in {'a', 'b'})
</code></pre>
<p>The two approaches are pretty much comparable in speed on Python 3.5.1 on my Macbook Pro (OS X 10.11):</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; l = [(1, 'a', 'b'), (2, 'b', 'c'), (3, 'e', 'a')] * 1000  # make it interesting
&gt;&gt;&gt; def counter():
...     counts = Counter(chain.from_iterable(l))
...     counts['a'] + counts['b']
...
&gt;&gt;&gt; def summing():
...     sum(1 for v in chain.from_iterable(l) if v in {'a', 'b'})
...
&gt;&gt;&gt; timeit(counter, number=1000)
0.5640139860006457
&gt;&gt;&gt; timeit(summing, number=1000)
0.6066895100011607
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You want to avoid putting data in a datastructure. The <code>[...]</code> syntax constructs a new list and fills it with the content you put in <code>...</code> , after which the length of the array is taken and the array is never used. If the list if very large, this uses a lot of memory, and it is inelegant in general. You can also use iterators to loop over the existing data structure, e.g., like so:</p>
<pre class="lang-py prettyprint-override"><code>sum(sum(c in ('a', 'b') for c in t) for t in l)
</code></pre>
<p>The <code>c in ('a', 'b')</code> predicate is a bool which evaluates to a 0 or 1 when cast to an int, causing the <code>sum()</code> to only count the tuple entry if the predicate evaluates to <code>True</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just for fun, functional method using reduce:</p>
<pre><code>&gt;&gt;&gt; l = [(1, 'a', 'b'), (2, 'b', 'c'), (3, 'e', 'a')]
&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; reduce(lambda x, y: (1 if 'a' in y else 0) + (1 if 'b' in y else 0) + x, l, 0)
4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can iterate over both the list and the sub-lists in one list comprehension:</p>
<pre><code>len([i for sub_list in l for i in sub_list if i in ("a", "b")])
</code></pre>
<p>I think that's fairly concise.</p>
<p>To avoid creating a temporary list, you could use a generator expression to create a sequence of 1s and pass that to <code>sum</code>:</p>
<pre><code>sum(1 for sub_list in l for i in sub_list if i in ("a", "b"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although this question already has an accepted answer, just wondering why all of them as so complex. I would think that this would suffice.</p>
<pre><code>&gt;&gt;&gt; l = [(1, 'a', 'b'), (2, 'b', 'c'), (3, 'e', 'a')]
&gt;&gt;&gt; total = sum(tup.count('a') + tup.count('b') for tup in l)
&gt;&gt;&gt; total
4
</code></pre>
<p>Or</p>
<pre><code>&gt;&gt;&gt; total = sum(1 for tup in l for v in tup if v in {'a', 'b'})
</code></pre>
</div>
<span class="comment-copy">Is this actually a bottleneck in your program?</span>
<span class="comment-copy">@MartijnPieters Sorry, I have updated my answer.</span>
<span class="comment-copy">I rolled back your last edit, because that changes the nature of your question <i>entirely</i>, which is not fair to everyone that answered the previous version of your question. <code>sum(1 for t in l if '-' not in t)</code> would achieve your other version.</span>
<span class="comment-copy">@MartijnPieters That's ok. It seam is the best choice.</span>
<span class="comment-copy">Creating the set outside is faster</span>
<span class="comment-copy">@PadraicCunningham: in Python 2 or 3? I can only get it (slightly) slower with a closure for the set. Take into account that the <code>in {...}</code> is peephole optimised, the set is stored as a <code>frozenset()</code> in the code object constants and a <code>LOAD_CONST</code> opcode is used to load it each iteration.</span>
<span class="comment-copy">~20 percent faster using 3.5.2</span>
<span class="comment-copy">@PadraicCunningham: code?</span>
<span class="comment-copy"><code>st = {"a","b"}</code> then <code>sum(1 for v in chain.from_iterable(l) if v in st)</code> vs <code>sum(1 for v in chain.from_iterable(l) if v in {'a', 'b'}) </code> <i>2.12ms vs 2.54ms</i></span>
<span class="comment-copy">This is over 3 times as slow: <code>1.9530742168426514</code> against the same timed tests</span>
<span class="comment-copy">nitpick: <i>cast</i> is not the right term; <code>bool</code> is just a subclass of <code>int</code> and as such <code>True</code> and <code>False</code> are <i>integers already</i>. No casting is needed, they just have an integer value when added up.</span>
<span class="comment-copy">It is indeed slower than <code>summing</code> because the chain iterator is probably implemented natively, making it more efficient than a nested loop in pure Python. However, on my machine it is faster than the <code>counter</code> method. I do like the readability and it uses no helper functions, so for small arrays I would use this. I agree that the chain iterator is better for cases where the array is potentially large.</span>
<span class="comment-copy">Are you testing on Python 2 perhaps? <code>Counter</code> got a C-optimisation in Python 3.</span>
<span class="comment-copy">I can't reproduce these timings at all. <code>reduced()</code> is about 25% slower at 0.7757142429982196.</span>
<span class="comment-copy">@MartijnPieters, just runned it again, still almost the same results...maybe processor stuff? Ill try on my laptop</span>
<span class="comment-copy">What version of Python? I'm using 3.5.1 on an OS X Macbook Pro.</span>
<span class="comment-copy">And the numbers <i>make no sense</i>. The <code>lambda</code> executes a hell of a lot of bytecode for each tuple in <code>l</code>. No way that'll be faster than a single set membership test each iteration for the <code>sum()</code> approach.</span>
<span class="comment-copy">@MartijnPieters, just tried on 3.5.1 on W10, true, from 0.77 to 0.85 or so.</span>
<span class="comment-copy">The <code>in (..)</code> tuple test is slower in this cases, but mostly because the small strings <code>'a'</code> and <code>'b'</code> can be interned (so an identity test is used when testing for set membership, which is just a pointer comparison).</span>
<span class="comment-copy">However, I used <code>sum()</code> from the start because, as you note creating a list object just to get the length is a waste of memory (and memory allocation takes time too!)</span>
<span class="comment-copy">Using <code>tuple.count()</code> does a full traverse of each tuple, in C code. You do this twice now; <code>itertools.chain.from_iterable()</code> only needs to iterate each tuple once. As a result, this approach takes <code>0.9097697560064262</code>, a good 60% more time.</span>
<span class="comment-copy">The second option is of comparable speed; the bytecode has to iterate over the same number of steps as <code>chain.from_iterable()</code>, so you end up with `0.5921581570000853.</span>
