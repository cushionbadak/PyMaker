<div class="post-text" itemprop="text">
<p>Sometimes after using <code>async/await</code> syntax I see the program no longer work correctly. But there are no any exceptions.
For example:</p>
<pre><code>async def my_func(self):
   async with self.engine() as conn:
      print('step1')  # step1 shows in console
      await conn.exceute("INSERT INTO bla-bla")
      print('step2')  # I can't watch 'step2', and no any exceptions caughted to console
</code></pre>
<p>But if I use <code>try/except</code> syntax exception can be catched:</p>
<pre><code>async def my_func(self):
   async with self.engine() as conn:
      print('step1')  # step1 shows in console
      try:
          await conn.exceute("INSERT INTO bla-bla")
      except Exception as e:
          print_exc()  # only by this way I can see whats wrong
      print('step2')
</code></pre>
<p>So. Can I see exception immediately without catching? Or I can only use steps and debug it all?</p>
</div>
<div class="post-text" itemprop="text">
<p>Exception is raised, stack is unrolled.</p>
<p>The real question is: what do you use to run your coroutine?</p>
<p><code>loop.run_until_complete(my_func())</code> will process an exception as you are expecting. Another usage scenarios may differ.</p>
</div>
<span class="comment-copy">start by setting the environment variable PYTHONASYNCIODEBUG=1</span>
<span class="comment-copy">@wim does not help (errors still not appears). But now I see a lot of debug tracebacks in console (not errors), dazzles.</span>
<span class="comment-copy">In accordance with the documentation, It has to help.  <a href="https://docs.python.org/3/library/asyncio-dev.html#detect-exceptions-never-consumed" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">I used <code>loop.create_task(my_func())</code> Maybe I need use <code>try/except</code> inside <code>my_func()</code> at once?</span>
<span class="comment-copy">You should never do <b>fire-and-forget</b> technique for created tasks.  Please use <code>result = await loop.create_task(my_func())</code>. Awaiting a task will raise an exception if any. You may split task creation and result awaiting but should ask for task result somewhere.</span>
<span class="comment-copy">I used <code>create_task</code> in properties, properties has no <code>__aget__</code> and <code>__aset__</code> and so I can't use <code>await</code> in them.  Also I used <code>create_task</code> in class inheritors of <code>list</code> and <code>dict</code> methods for writing to DB after any changes. Is this good practice? Or there are better ways to do it?  In any case the fact the lack of async descriptors and assignment it would be nice to fill.</span>
<span class="comment-copy">Sorry, I can say nothing about good or bad practice without looking on code.</span>
<span class="comment-copy">Maybe having IO on descriptor access (as well as in constructor) are smell of design mistake?</span>
