<div class="post-text" itemprop="text">
<p>I want to print some floating point numbers so that they're always written in decimal form (e.g. <code>12345000000000000000000.0</code> or <code>0.000000000000012345</code>, not in <a href="https://en.wikipedia.org/wiki/Scientific_notation" rel="noreferrer">scientific notation</a>, yet I'd want to keep the 15.7 decimal digits of precision and no more.</p>
<p>It is well-known that the <code>repr</code> of a <code>float</code> is written in scientific notation if the exponent is greater than 15, or less than -4:</p>
<pre><code>&gt;&gt;&gt; n = 0.000000054321654321
&gt;&gt;&gt; n
5.4321654321e-08  # scientific notation
</code></pre>
<p>If <code>str</code> is used, the resulting string again is in scientific notation:</p>
<pre><code>&gt;&gt;&gt; str(n)
'5.4321654321e-08'
</code></pre>
<hr/>
<p>It has been suggested that I can use <code>format</code> with <code>f</code> flag and sufficient precision to get rid of the scientific notation:</p>
<pre><code>&gt;&gt;&gt; format(0.00000005, '.20f')
'0.00000005000000000000'
</code></pre>
<p>It works for that number, though it has some extra trailing zeroes. But then the same format fails for <code>.1</code>, which gives decimal digits beyond the actual machine precision of float:</p>
<pre><code>&gt;&gt;&gt; format(0.1, '.20f')
'0.10000000000000000555'
</code></pre>
<p>And if my number is <code>4.5678e-20</code>, using <code>.20f</code> would still lose relative precision:</p>
<pre><code>&gt;&gt;&gt; format(4.5678e-20, '.20f')
'0.00000000000000000005'
</code></pre>
<p>Thus <strong>these approaches do not match my requirements</strong>.</p>
<hr/>
<p>This leads to the question: what is the easiest and also well-performing way to print arbitrary floating point number in decimal format, having the same digits as in <a href="https://stackoverflow.com/a/28493269/918959"><code>repr(n)</code> (or <code>str(n)</code> on Python 3)</a>, but always using the decimal format, not the scientific notation.</p>
<p>That is, a function or operation that for example converts the float value <code>0.00000005</code> to string <code>'0.00000005'</code>; <code>0.1</code> to <code>'0.1'</code>; <code>420000000000000000.0</code> to <code>'420000000000000000.0'</code> or <code>420000000000000000</code> and formats the float value <code>-4.5678e-5</code> as <code>'-0.000045678'</code>.</p>
<hr/>
<p>After the bounty period: It seems that there are at least 2 viable approaches, as Karin demonstrated that using string manipulation one can achieve significant speed boost compared to my initial algorithm on Python 2.</p>
<p>Thus,</p>
<ul>
<li>If performance is important and Python 2 compatibility is required; or if the <code>decimal</code> module cannot be used for some reason, then <a href="https://stackoverflow.com/a/38983595/918959">Karin's approach using string manipulation</a> is the way to do it.</li>
<li>On Python 3, <a href="https://stackoverflow.com/a/38847691/918959">my somewhat shorter code will also be faster</a>.</li>
</ul>
<p>Since I am primarily developing on Python 3, I will accept my own answer, and shall award Karin the bounty.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately it seems that not even the new-style formatting with <code>float.__format__</code> supports this. The default formatting of <code>float</code>s is the same as with <code>repr</code>; and with <code>f</code> flag there are 6 fractional digits by default:</p>
<pre><code>&gt;&gt;&gt; format(0.0000000005, 'f')
'0.000000'
</code></pre>
<hr/>
<p>However there is a hack to get the desired result - not the fastest one, but relatively simple:</p>
<ul>
<li>first the float is converted to a string using <code>str()</code> or <code>repr()</code></li>
<li>then a new <a href="https://docs.python.org/3/library/decimal.html#decimal.Decimal" rel="noreferrer"><code>Decimal</code></a> instance is created from that string.</li>
<li><code>Decimal.__format__</code> supports <code>f</code> flag which gives the desired result, and, unlike <code>float</code>s it prints the actual precision instead of default precision.</li>
</ul>
<p>Thus we can make a simple utility function <code>float_to_str</code>:</p>
<pre><code>import decimal

# create a new context for this task
ctx = decimal.Context()

# 20 digits should be enough for everyone :D
ctx.prec = 20

def float_to_str(f):
    """
    Convert the given float to a string,
    without resorting to scientific notation
    """
    d1 = ctx.create_decimal(repr(f))
    return format(d1, 'f')
</code></pre>
<p>Care must be taken to not use the global decimal context, so a new context is constructed for this function. This is the fastest way; another way would be to use <code>decimal.local_context</code> but it would be slower, creating a new thread-local context and a context manager for each conversion.</p>
<p>This function now returns the string with all possible digits from mantissa, rounded to the <a href="https://stackoverflow.com/a/28493269/918959">shortest equivalent representation</a>:</p>
<pre><code>&gt;&gt;&gt; float_to_str(0.1)
'0.1'
&gt;&gt;&gt; float_to_str(0.00000005)
'0.00000005'
&gt;&gt;&gt; float_to_str(420000000000000000.0)
'420000000000000000'
&gt;&gt;&gt; float_to_str(0.000000000123123123123123123123)
'0.00000000012312312312312313'
</code></pre>
<p>The last result is rounded at the last digit</p>
<p>As @Karin noted, <code>float_to_str(420000000000000000.0)</code> does not strictly match the format expected; it returns <code>420000000000000000</code> without trailing <code>.0</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are satisfied with the precision in scientific notation, then could we just take a simple string manipulation approach? Maybe it's not terribly clever, but it seems to work (passes all of the use cases you've presented), and I think it's fairly understandable:</p>
<pre><code>def float_to_str(f):
    float_string = repr(f)
    if 'e' in float_string:  # detect scientific notation
        digits, exp = float_string.split('e')
        digits = digits.replace('.', '').replace('-', '')
        exp = int(exp)
        zero_padding = '0' * (abs(int(exp)) - 1)  # minus 1 for decimal point in the sci notation
        sign = '-' if f &lt; 0 else ''
        if exp &gt; 0:
            float_string = '{}{}{}.0'.format(sign, digits, zero_padding)
        else:
            float_string = '{}0.{}{}'.format(sign, zero_padding, digits)
    return float_string

n = 0.000000054321654321
assert(float_to_str(n) == '0.000000054321654321')

n = 0.00000005
assert(float_to_str(n) == '0.00000005')

n = 420000000000000000.0
assert(float_to_str(n) == '420000000000000000.0')

n = 4.5678e-5
assert(float_to_str(n) == '0.000045678')

n = 1.1
assert(float_to_str(n) == '1.1')

n = -4.5678e-5
assert(float_to_str(n) == '-0.000045678')
</code></pre>
<p><strong>Performance</strong>:</p>
<p>I was worried this approach may be too slow, so I ran <code>timeit</code> and compared with the OP's solution of decimal contexts. It appears the string manipulation is actually quite a bit faster. <strong>Edit</strong>: It appears to only be much faster in Python 2. In Python 3, the results were similar, but with the decimal approach slightly faster.</p>
<p><strong>Result</strong>:</p>
<ul>
<li><p>Python 2: using <code>ctx.create_decimal()</code>: <code>2.43655490875</code></p></li>
<li><p>Python 2: using string manipulation: <code>0.305557966232</code></p></li>
<li><p>Python 3: using <code>ctx.create_decimal()</code>: <code>0.19519368198234588</code></p></li>
<li><p>Python 3: using string manipulation: <code>0.2661344590014778</code></p></li>
</ul>
<p>Here is the timing code:</p>
<pre><code>from timeit import timeit

CODE_TO_TIME = '''
float_to_str(0.000000054321654321)
float_to_str(0.00000005)
float_to_str(420000000000000000.0)
float_to_str(4.5678e-5)
float_to_str(1.1)
float_to_str(-0.000045678)
'''
SETUP_1 = '''
import decimal

# create a new context for this task
ctx = decimal.Context()

# 20 digits should be enough for everyone :D
ctx.prec = 20

def float_to_str(f):
    """
    Convert the given float to a string,
    without resorting to scientific notation
    """
    d1 = ctx.create_decimal(repr(f))
    return format(d1, 'f')
'''
SETUP_2 = '''
def float_to_str(f):
    float_string = repr(f)
    if 'e' in float_string:  # detect scientific notation
        digits, exp = float_string.split('e')
        digits = digits.replace('.', '').replace('-', '')
        exp = int(exp)
        zero_padding = '0' * (abs(int(exp)) - 1)  # minus 1 for decimal point in the sci notation
        sign = '-' if f &lt; 0 else ''
        if exp &gt; 0:
            float_string = '{}{}{}.0'.format(sign, digits, zero_padding)
        else:
            float_string = '{}0.{}{}'.format(sign, zero_padding, digits)
    return float_string
'''

print(timeit(CODE_TO_TIME, setup=SETUP_1, number=10000))
print(timeit(CODE_TO_TIME, setup=SETUP_2, number=10000))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are ready to lose your precision arbitrary by calling <code>str()</code> on the float number, then it's the way to go:</p>
<pre><code>import decimal

def float_to_string(number, precision=20):
    return '{0:.{prec}f}'.format(
        decimal.Context(prec=100).create_decimal(str(number)),
        prec=precision,
    ).rstrip('0').rstrip('.') or '0'
</code></pre>
<p>It doesn't include global variables and allows you to choose the precision yourself. Decimal precision 100 is chosen as an upper bound for <code>str(float)</code> length. The actual supremum is much lower. The <code>or '0'</code> part is for the situation with small numbers and zero precision.</p>
<p>Note that it still has its consequences:</p>
<pre><code>&gt;&gt; float_to_string(0.10101010101010101010101010101)
'0.10101010101'
</code></pre>
<p>Otherwise, if the precision is important, <code>format</code> is just fine:</p>
<pre><code>import decimal

def float_to_string(number, precision=20):
    return '{0:.{prec}f}'.format(
        number, prec=precision,
    ).rstrip('0').rstrip('.') or '0'
</code></pre>
<p>It doesn't miss the precision being lost while calling <code>str(f)</code>.
The <code>or</code></p>
<pre><code>&gt;&gt; float_to_string(0.1, precision=10)
'0.1'
&gt;&gt; float_to_string(0.1)
'0.10000000000000000555'
&gt;&gt;float_to_string(0.1, precision=40)
'0.1000000000000000055511151231257827021182'

&gt;&gt;float_to_string(4.5678e-5)
'0.000045678'

&gt;&gt;float_to_string(4.5678e-5, precision=1)
'0'
</code></pre>
<p>Anyway, maximum decimal places are limited, since the <code>float</code> type itself has its limits and cannot express really long floats:</p>
<pre><code>&gt;&gt; float_to_string(0.1, precision=10000)
'0.1000000000000000055511151231257827021181583404541015625'
</code></pre>
<p>Also, whole numbers are being formatted as-is.</p>
<pre><code>&gt;&gt; float_to_string(100)
'100'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of NumPy 1.14.0, you can just use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.format_float_positional.html" rel="nofollow noreferrer"><code>numpy.format_float_positional</code></a>. For example, running against the inputs from your question:</p>
<pre><code>&gt;&gt;&gt; numpy.format_float_positional(0.000000054321654321)
'0.000000054321654321'
&gt;&gt;&gt; numpy.format_float_positional(0.00000005)
'0.00000005'
&gt;&gt;&gt; numpy.format_float_positional(0.1)
'0.1'
&gt;&gt;&gt; numpy.format_float_positional(4.5678e-20)
'0.000000000000000000045678'
</code></pre>
<p><code>numpy.format_float_positional</code> uses the Dragon4 algorithm to produce the shortest decimal representation in positional format that round-trips back to the original float input. There's also <code>numpy.format_float_scientific</code> for scientific notation, and both functions offer optional arguments to customize things like rounding and trimming of zeros.</p>
</div>
<div class="post-text" itemprop="text">
<p>Interesting question, to add a little bit more of content to the question, here's a litte test comparing @Antti Haapala and @Harold solutions outputs:</p>
<pre><code>import decimal
import math

ctx = decimal.Context()


def f1(number, prec=20):
    ctx.prec = prec
    return format(ctx.create_decimal(str(number)), 'f')


def f2(number, prec=20):
    return '{0:.{prec}f}'.format(
        number, prec=prec,
    ).rstrip('0').rstrip('.')

k = 2*8

for i in range(-2**8,2**8):
    if i&lt;0:
        value = -k*math.sqrt(math.sqrt(-i))
    else:
        value = k*math.sqrt(math.sqrt(i))

    value_s = '{0:.{prec}E}'.format(value, prec=10)

    n = 10

    print ' | '.join([str(value), value_s])
    for f in [f1, f2]:
        test = [f(value, prec=p) for p in range(n)]
        print '\t{0}'.format(test)
</code></pre>
<p>Neither of them gives "consistent" results for all cases.</p>
<ul>
<li>With Anti's you'll see strings like '-000' or '000'</li>
<li>With Harolds's you'll see strings like ''</li>
</ul>
<p>I'd prefer consistency even if I'm sacrificing a little bit of speed. Depends which tradeoffs you want to assume for your use-case.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think <code>rstrip</code> can get the job done.</p>
<pre><code>a=5.4321654321e-08
'{0:.40f}'.format(a).rstrip("0") # float number and delete the zeros on the right
# '0.0000000543216543210000004442039220863003' # there's roundoff error though
</code></pre>
<p>Let me know if that works for you.</p>
</div>
<span class="comment-copy">And please if you do have a better answer to this question, do share it.</span>
<span class="comment-copy">Project for a rainy day: add a low-level library function to Python (possibly in the <code>sys</code> module) that returns the "raw" binary-to-decimal conversion result for a given finite float (i.e., string of digits, decimal exponent, sign). That would give people the freedom to format as they saw fit.</span>
<span class="comment-copy">Short answer: no, there isn't an easier way to do this; at least, not one that I'm aware of, and that also gives decently precise results. (Any solution that involves first pre-processing the number by scaling by powers of 10 is going to risk introducing numerical errors.)</span>
<span class="comment-copy">Why don't you use <a href="https://docs.python.org/3.5/library/decimal.html#decimal.localcontext" rel="nofollow noreferrer"><code>decimal.localcontext</code></a>? <code>with localcontext() as ctx: ctx.prec = 20; d1 = Decimal(str(f))</code></span>
<span class="comment-copy">@Bakuriu why would I, it can only be slower</span>
<span class="comment-copy">I see precision loss in the output for 0.000000000123123123123123123123 - the <code>float_to_str</code> output cuts off at only 12 digits of precision, not enough to reconstruct the original float.</span>
<span class="comment-copy">@user2357112 good catch. You're using Python 2; in Python 2 <code>str</code> only has 12 digits of precision while <code>repr</code> uses the Python 3 compatible algorithm. In Python 3, both forms are similar, thus the confusion. I changed my code to use <code>repr</code>.</span>
<span class="comment-copy">Ahh that seems obvious from the docs now. Great to know! I've updated my timing code and it looks much cleaner now thanks to you :)</span>
<span class="comment-copy">Eek! Good call! Updated code =D</span>
<span class="comment-copy">I'm consistently surprised how often the naive "just stringify it" approach works, and sometimes works even better than other cases.</span>
<span class="comment-copy">Frankly, I didn't remember that the returned string was without <code>.0</code>, I didn't copy-paste my example output from Python shell, instead writing it here. Good catch :D I fixed my answer.</span>
<span class="comment-copy"><code>decimal</code> has received <a href="https://docs.python.org/3/whatsnew/3.3.html#decimal" rel="nofollow noreferrer">several speed improvements in Python 3.3</a> (switch to libmpdec, caching, etc.) leading to 10x - 100x performance gains depending on what you are trying to make it do.</span>
<span class="comment-copy">There is no need to create that Decimal at all, your approach works for <code>float</code>s already, but the result of false precision was rejected in the question. These are rounded measurement results, not some arbitrary binary fractions.</span>
<span class="comment-copy">You are right. Fixed.</span>
<span class="comment-copy">Hey, that's nice. Not practical if NumPy is not needed otherwise, but if it is this is definitely what one should be using.</span>
<span class="comment-copy">Why are you adjusting the precision in my approach? I fixed it to 20 to get all of the 15.7 decimal digits of precision of IEEE-754 doubles.</span>
<span class="comment-copy">Unfortunately as I stated in my question, I do not want any residual fractional part from the fact that these happened to be stored as binary.</span>
