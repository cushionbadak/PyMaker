<div class="post-text" itemprop="text">
<p>A little background: You'll notice my comments describe what I'll go through later. Let's say I have the following object...</p>
<pre><code>#!/usr/bin/python
import os
import sys

class ContainerField(object):
    ''' An attribute/object storage device '''
    def __init__(self, field=None, value=None):
        self.m_field = field
        self.m_value = value

    def __getattr__(self, key):
        '''
        What can we do here that runs the .get() command but -only- if the key
        does not exist.
        '''
        # super(ContainerField, self).__getattr__(key)

    def __call__(self):
        return self.get()

    def value(self):
        return self.m_value

    def setValue(self, value):
        self.m_value = value

    def _recurseSetAttr(self, attr, values):
        '''Generate our attributes/objects and store them succinctly.'''
        # Container
        #    \_Container
        #    \_Container
        #         \_Container...
        for field, value in values.items():
            if not hasattr(attr, field):
                setattr(attr,
                        field,
                        # field type is known from model caching
                        ContainerField(value=value, field=field_type(field)))

            fdbf = getattr(attr, field)
            if isinstance(value, dict):
                self._recurseSetAttr(fdbf, value)
            else:
                fdbf.setValue(value)

    def get(self):
        # Create the new object from scratch and proliferate it's
        # attributes recursively. 'values' come in the form of a
        # dictionary that we can then use to setattr().
        # So... Create container, set value, find keys for this
        # and create containers that hold the values of those keys
        # and repeate...
        self._recurseSetAttr(self, attr, values)
</code></pre>
<p>Now, when generating the objects I can have a dict that looks something like this: <code>{"myContainer" : { "id" : 2, "foo" : { "id" : 3, "bar" : 1 } }}</code> that, once created, can be called like this: <code>myContainer.foo.id.value()</code></p>
<p>In the scenario there's the <code>self.m_field</code> which tells the application what data type the object really is. This is referencing off of Django models but any python could apply.</p>
<p>All containers will have an <code>id</code> (or <code>pk</code>) key to them as part of their instantiation. This is mandatory.</p>
<hr/>
<h3>The Rub</h3>
<p>Ideally, we fill our the top level attributes and only when the user requests for the attributes that lie underneath it do we construct them based off the <code>id</code> value and the <code>field</code> type.</p>
<p>So finally, let's say the <code>myContainer.foo.bar</code> attribute has a foreign key field type. If we call <code>myContainer.foo.bar.newkey.value()</code> the app should understand that the 'newkey' attribute does not exist, query against our django instance, store the <code>bar</code> attribute as the now more filled out Container, and return the <code>newkey</code> value that's been put to memory.</p>
<h3>The Python Pitfall</h3>
<p>I'd hoped it would be a simple <code>hasattr()</code> but Python seems to just use <code>getattr()</code> with a default <code>None</code> (The recursion is real!). I've also had loads of trouble getting a <code>try: except:</code> to work.</p>
<p>As I write this I'm realizing how much more complicated it may be due to the recursive attribute setting relying on <code>getattr()</code> and <code>hasattr()</code> Any suggestions would be greatly appreciated. - Cheers</p>
</div>
<div class="post-text" itemprop="text">
<p>So to answer the first part of the question: how to have <code>__getattr__</code> call  <code>self.get()</code> only when the attribute is not defined already.  There are two attribute access methods in python classes: <code>__getattribute__</code> and <code>__getattr__</code>.  The first is called every time an attribute lookup is attempted, the second is called only when the normal attribute lookup system fails (including lookups in superclasses).  Since you're defining <code>__getattr__</code>, which is only called when the attribute doesn't already exist, you can simply proxy it to a call to <code>.get</code>.  Where you run into recursion issues is if you try to look up another attribute of <code>self</code>, that also doesn't yet exist, inside of <code>__getattr__</code>.  The way to avoid this is to have a list of keys that require special handling and check if the current attribute requested is one of them.  This typically is only needed when implementing <code>__getattribute__</code>.</p>
<p>Note that your <code>.get</code> method has a problem:  <code>attr</code> and <code>values</code> are undefined.  I'd give a slightly more concrete answer for what to put in <code>__getattr__</code> if I knew what values for <code>.get</code>'s <code>attr</code> and <code>values</code> want.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could consider using the @property decorator with private internal fields. The idea would be something like:</p>
<pre><code>class ContainerField(object):
    def __init__(self, field=None, value=None):
        self._m_field = field
        self._m_value = value

    @property
    def m_field(self):
        if self._m_field is None:
            self._m_field = self.function_to_populate_m_field()
        return self._m_field

    @property
    def m_value(self):
        if self._m_value is None:
            self._m_value = self.function_to_populate_m_value()
        return self._m_value

    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check this out:</p>
<pre><code>class Test(object):
    def __init__(self):
        self.a = 5
        self.b = 6

    def __getattr__(self, key): 
        return 'created a new key: {}'.format(key)


obj = Test()

print(obj.a, obj.b)
print(obj.c)
</code></pre>
<p>Here, instead of returning <code>'created a new key...'</code>, you create a new attribute and return it.</p>
</div>
<span class="comment-copy">You may have read this already, but if not it might help you: <a href="https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access" rel="nofollow noreferrer">docs.python.org/3/reference/â€¦</a></span>
<span class="comment-copy"><code>__getattr__</code> is only ever called for attributes that don't exist. You don't need to test with <code>hasattr()</code> at that point, you already <i>know</i> the attribute is not there.</span>
<span class="comment-copy">Ah! Right on! This was immensely helpful. All of these answers were actually. Thankfully in my actual app I have a few more conditions to work with when creating the <code>Containers</code> so I can understand the difference of who's-who when it comes to calling <code>get()</code> vs. the <code>super()</code>. Thanks again!</span>
