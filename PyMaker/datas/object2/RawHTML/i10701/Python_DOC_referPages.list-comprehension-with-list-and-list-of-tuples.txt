<div class="post-text" itemprop="text">
<p>In my Python 2.7.5 code I have the following data structures:</p>
<p>A simple list...</p>
<pre><code>&gt;&gt;&gt; data["parts"]
['com', 'google', 'www']
</code></pre>
<p>...and a list of tuples...</p>
<pre><code>&gt;&gt;&gt; data["glue"]
[(1L, 'com'), (3L, 'google')]
</code></pre>
<p>When entering the code where these structures exist I will always know what is in <code>data["parts"]</code>; <code>data["glue"]</code>, at best, will contain "matching" tuples with what is in <code>data["parts"]</code> - worst case <code>data["glue"]</code> can be empty.  What I need is to know is the parts that are missing from glue.  So with the example data above, I need to know that 'www' is missing, meaning it is not in any of the tuples that may exist in <code>data["glue"]</code>.</p>
<p>I first tried to produce a list of the missing pieces by way of various for loops coupled with if statements but it was very messy at best.  I have tried list comprehensions and failed.  Maybe list comprehension is not the way to handle this either.</p>
<p>Your help is much appreciated, thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://www.linuxtopia.org/online_books/programming_books/python_programming/python_ch16s03.html" rel="nofollow">set difference</a> operations.</p>
<pre><code>print set(data['parts'])-set(i[1] for i in data['glue'])
&gt;&gt;&gt; set(['www'])
</code></pre>
<p>or with simply using <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehensions</a>:</p>
<pre><code>print [i for i in data['parts'] if i not in (j[1] for j in data['glue'])]
&gt;&gt;&gt; ['www']
</code></pre>
<p>The set operation wins in the speed department, running the operation <em>10,000,000 times</em>, we can see that the list comprehension takes over <strong>16s longer</strong>:</p>
<pre><code>import timeit
print timeit.timeit(lambda : set(data['parts'])-set(i[1] for i in data['glue']), number=10000000)
&gt;&gt;&gt; 16.8089739356
print timeit.timeit(lambda : [i for i in data['parts'] if i not in (j[1] for j in data['glue'])], number=10000000)
&gt;&gt;&gt; 33.5426096522
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use list comprehensions here. Maybe the simplest thing would be to create a set of all indices, then return the missing indices. Note this answer will give you all the missing components, even if there are duplicates in the parts array (for example, if "www" appeared twice in parts). This would not be the case with set comprehension.</p>
<pre><code># set of 0-based indices extracted from the 1-based tuples
indices = set(glue_tuple[0] - 1 for glue_tuple in data['glue'])

# array of missing parts, in order
missing_parts = [part for i, part in enumerate(data["parts"]) if i not in indices]
</code></pre>
</div>
<span class="comment-copy">The index of google and www would be 2 and 3 respectively, right?</span>
<span class="comment-copy">@thefourtheye - no, each item would be its own tuple</span>
<span class="comment-copy">Updated example data structures to add clarity</span>
<span class="comment-copy">What I don't understand is the importance of the index [1] which you mentioned in the question. You mean, ww should be between <code>com</code> tuple and <code>google</code> tuple in the <code>glue</code> entry?</span>
<span class="comment-copy">Maybe I should have simply said meaning 'www' is not in any of the tuples.</span>
<span class="comment-copy">Excellent, thanks very much.</span>
<span class="comment-copy">Np :) If you think I've answered the question, please feel free to check as answered!</span>
<span class="comment-copy">of both, the <code>set</code> solution is more efficient</span>
<span class="comment-copy">Updated the post with benchmarks! @Copperfield</span>
<span class="comment-copy">@mrdomoboto I was thinking of it in a more theoretical way as the set construction take <code>n</code> and <code>m</code> step each and the subtraction take only <code>n</code>  (because test membership in a set is done at constant speed) ending in <code>2n+m</code>, while the list take more or less <code>n*m</code> as the check is done with a linear search. But the benchmark are a nice touch :)</span>
