<div class="post-text" itemprop="text">
<p>I'm using the <code>subprocess</code> module to execute two commands:</p>
<pre><code>import shlex    
from subprocess import check_call()

def comm_1(error_file):
    comm = shlex("mkdir /tmp/kde")
    try:
        check_call(comm)
    except subprocess.CalledProcessError:
        error_file.write("Error comm_1")

def comm_2(error_file):
    comm = shlex("ls -la /tmp/kde")
    try:
        check_call(comm)
    except subprocess.CalledProcessError:
        error_file.write("Error comm_2")

if __name__ == "__main__":
    with open("error_file", "r+") as log_error_file:
         comm_1(log_error_file)
         comm_2(log_error_file)
         log_error_file.write("Success")
</code></pre>
<p>I'm aware of a few pitfalls in this design, like the <code>error_file</code> being shared with the functions. This is easily refactored, though. What I'm trying to do is to detach the entire process to background. I would accomplish this with  </p>
<pre><code> check_call(comm, creationflags=subprocess.CREATE_NEW_CONSOLE)
</code></pre>
<p>But this would pose a race problem, because I want to make sure that <code>comm_1</code> is finished before <code>comm_2</code> starts. What is the best approach to do this with <code>subprocess</code>? I can't use <code>python-daemon</code> or other packages outside the standard Python 2.6 library.</p>
<p>EDIT: I could try to use something like</p>
<pre><code>nohup python myscript.py &amp;
</code></pre>
<p>But the ideia is to have only one way to start the job from the python script.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can check to make sure the process inside of <code>comm_1</code> dies before starting the subprocess call within <code>comm_2</code> by using <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.wait" rel="nofollow"><code>wait()</code></a>. But to do so, you're going to have to use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow"><code>Popen()</code></a> instead of <code>check_call()</code>.</p>
<pre><code>from subprocess import Popen

def comm_1(error_file):
    comm = shlex("mkdir /tmp/kde")
    try:
        proc_1 = Popen(comm)
        proc_1.wait(timeout=20)
    except subprocess.CalledProcessError, TimeoutExpired:
        error_file.write("Error comm_1")
</code></pre>
<p><code>proc_1.wait()</code> is going to wait for 20 seconds (you can change the time) for the process to finish before continuing. If it takes longer than 20 secs, it's going to throw a <code>TimeoutExpired</code> exception, which you can catch in your <code>except</code> block.</p>
</div>
<span class="comment-copy">Seems like you could change things so that <code>if __name__ == "__main__"</code> myscript.py spawned something that does what you're currently doing e at the end. With the right conditionals, that could probably be <i>itself</i>.</span>
<span class="comment-copy">Sorry, but I don't follow. Should I remove the functions?</span>
<span class="comment-copy">Thanks. With <code>Popen</code> <code>wait</code> method, would the father process be detached? The sequence should be something like <code>start python process</code> -&gt; <code>detach both functions</code> -&gt; <code>comm_1 executes</code> -&gt; <code>comm_2 executes</code>, without the father process still be present.</span>
<span class="comment-copy">@Ivan Just to clarify, do you mean if the python script would completely execute and finish while <code>comm_1</code> and <code>comm_2</code> continue executing in the background until they also finish?</span>
<span class="comment-copy">Exactly. The python script is a "launcher" and should exit while <code>comm_1</code> and <code>comm_2</code> runs in background.</span>
<span class="comment-copy">@Ivan Unfortunately no.. It completely halts the python process and waits for the <code>comm_1</code> subprocess to finish before continuing to execute the rest of the python script.</span>
<span class="comment-copy">@Ivan I'm not completely sure this works, but if you use <code>Popen(comm, close_fds=True)</code>, I believe the python process continues without waiting for <code>proc_1</code> to finish, but then you might enter a race condition with <code>comm_2</code>. You can give it a try if you like.</span>
