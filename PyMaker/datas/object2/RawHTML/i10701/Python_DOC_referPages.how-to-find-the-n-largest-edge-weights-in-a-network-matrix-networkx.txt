<div class="post-text" itemprop="text">
<p>I have the following code that I attempt to use to generate a network matrix.  With this matrix, I would like to find the 20 highest-weighted edges that ARE NOT on the diagnal (<em>i.e.</em> <code>i!=j</code> in the matrix).  I also would like to get the names of the nodes (in pairs) composed of these edges.</p>
<pre><code>import heapq
def mapper_network(self, _, info):
    G = nx.Graph()  #create a graph
    for i in range(len(info)):   
        edge_from = info[0]  # edge from
        edge_to = info[1]    # edge to
        weight = info[2]     # edge weight
        G.add_edge(edge_from, edge_to, weight=weight) #insert the edge to the graph
    A = nx.adjacency_matrix(G)  # create an adjacency matrix
    A_square = A * A  # find the product of the matrix
    print heapq.nlargest(20, A_square) # to print out the 20 highest weighted edges
</code></pre>
<p>With this code, however, I failed to generate the 20 most weighted edges. I obtain <code>raise ValueError("The truth value of an array with more than one "
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all().</code> </p>
<p>Instead, with this</p>
<pre><code>    print heapq.nlargest(20, range(len(A_square)), A_square.take)
</code></pre>
<p>It gives me:</p>
<pre><code>    raise TypeError("sparse matrix length is ambiguous; use getnnz()"
    TypeError: sparse matrix length is ambiguous; use getnnz() or shape[0]
</code></pre>
<p>With</p>
<pre><code>    def mapper_network(self, _, info):
    G = nx.Graph()
    for i in range(len(info)):
        edge_from = info[0]
        edge_to = info[1]
        weight = info[2]
        G.add_edge(edge_from, edge_to, weight=weight)
    A = nx.adjacency_matrix(G)
    A_square = A * A #can print (A_square.todense())
    weight = nx.get_edge_attributes(A_square, weight)
    edges = A_square.edges(data = True)
    s = sorted(G.edges(data=True), key=lambda (source, target, data): data['weight'])
    print s
</code></pre>
<p>I received</p>
<pre><code>  File         "/tmp/MRQ7_trevor.vagrant.20160814.040827.770006/job_local_dir/1/mapper/0/mrjob.tar.gz/mrjob/job.py", line 433, in run
mr_job.execute()
 File "/tmp/MRQ7_trevor.vagrant.20160814.040827.770006/job_local_dir/1/mapper/0/mrjob.tar.gz/mrjob/job.py", line 442, in execute
self.run_mapper(self.options.step_num)
 File "/tmp/MRQ7_trevor.vagrant.20160814.040827.770006/job_local_dir/1/mapper/0/mrjob.tar.gz/mrjob/job.py", line 507, in run_mapper
for out_key, out_value in mapper(key, value) or ():
File "MRQ7_trevor.py", line 90, in mapper_network
weight = nx.get_edge_attributes(A_square, weight)
File "/home/vagrant/anaconda/lib/python2.7/site-packages/networkx/classes/function.py", line 428, in get_edge_attributes
if G.is_multigraph():
File "/home/vagrant/anaconda/lib/python2.7/site-packages/scipy/sparse/base.py", line 499, in __getattr__
raise AttributeError(attr + " not found")
</code></pre>
<p>AttributeError: is_multigraph not found</p>
<p>Could someone help me solve this question? Thank you very much!</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue with this line:</p>
<pre><code>heapq.nlargest(20, A_square)
</code></pre>
<p>Is that <code>nlargest</code> does not expect an iterable of iterables, but an interable of numbers.</p>
<p>So you could do this instead:</p>
<pre><code>heapq.nlargest(20, itertools.chain.from_iterable(A_square))
</code></pre>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>itertools.chain.iterables</code></a> takes an iterable of iterables, and creates a new iterable with the content of all the inner iterables.</p>
<hr/>
<p>However, that won't entierly solve your initial problem, for two reasons:</p>
<ol>
<li><p>Why do you take the square of the adjacency matrix? Doing so would only give you the highest weighted sum of paths of length 2 in the graph, which is quite different from what you want. Just use the adjacency matrix instead.</p></li>
<li><p>Nowhere in your code you remove the diagonal. You could do it like this: <code>for n in G.number_of_nodes():  A[n][n] = 0</code></p></li>
</ol>
</div>
<span class="comment-copy">Thank you very much for the help. I took the square of the adjacency matrix because I wanted to know which nodes are 'most connected with a shared nodes'. For instance, A-B, A-C, but !B-C. B and C are connected via A. I hope to know which pair of nodes are the most connected in this way. I tried  for n in G.number_of_edges():  A[n][n] = 0 but it shows no attribute number_of edges. I also hope to know the node names (edges) (i.e. A-C) but don't know how to do it with sparse csv matrix. Thank you!</span>
<span class="comment-copy">Sorry, I meant <code>number_of_nodes()</code> (which is the size of the matrix)</span>
