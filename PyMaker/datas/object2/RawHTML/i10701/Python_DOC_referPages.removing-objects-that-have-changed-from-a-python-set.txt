<div class="post-text" itemprop="text">
<p>Given this program:</p>
<pre><code>class Obj:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __hash__(self):
        return hash((self.a, self.b))

class Collection:
    def __init__(self):
        self.objs = set()

    def add(self, obj):
        self.objs.add(obj)

    def find(self, a, b):
        objs = []

        for obj in self.objs:
            if obj.b == b and obj.a == a:
                objs.append(obj)
        return objs

    def remove(self, a, b):
        for obj in self.find(a, b):
            print('removing', obj)
            self.objs.remove(obj)

o1 = Obj('a1', 'b1')
o2 = Obj('a2', 'b2')
o3 = Obj('a3', 'b3')
o4 = Obj('a4', 'b4')
o5 = Obj('a5', 'b5')

objs = Collection()
for o in (o1, o2, o3, o4, o5):
    objs.add(o)

objs.remove('a1', 'b1')
o2.a = 'a1'
o2.b = 'b1'
objs.remove('a1', 'b1')
o3.a = 'a1'
o3.b = 'b1'
objs.remove('a1', 'b1')
o4.a = 'a1'
o4.b = 'b1'
objs.remove('a1', 'b1')
o5.a = 'a1'
o5.b = 'b1'
</code></pre>
<p>If I run this a few times with Python 3.4.2, sometimes it will succeed, other times it throws a KeyError after removing 2 or 3 objects:</p>
<pre><code>$ python3 py_set_obj_remove_test.py
removing &lt;__main__.Obj object at 0x7f3648035828&gt;
removing &lt;__main__.Obj object at 0x7f3648035860&gt;
removing &lt;__main__.Obj object at 0x7f3648035898&gt;
removing &lt;__main__.Obj object at 0x7f36480358d0&gt;

$ python3 py_set_obj_remove_test.py
removing &lt;__main__.Obj object at 0x7f156170b828&gt;
removing &lt;__main__.Obj object at 0x7f156170b860&gt;
Traceback (most recent call last):
  File "py_set_obj_remove_test.py", line 42, in &lt;module&gt;
    objs.remove('a1', 'b1')
  File "py_set_obj_remove_test.py", line 27, in remove
    self.objs.remove(obj)
KeyError: &lt;__main__.Obj object at 0x7f156170b860&gt;
</code></pre>
<p>Is this a bug in Python? Or something about the implementation of sets I don't know about?</p>
<p>Interestingly, it seems to always fail at the second <code>objs.remove()</code> call in Python 2.7.9.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is not a bug in Python, your code is violating a principle of sets: that the <em>hash value must not change</em>. By mutating your object attributes, the hash changes and the set can no longer reliably locate the object in the set.</p>
<p>From the <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__</code> method documentation</a>:</p>
<blockquote>
<p>If a class defines mutable objects and implements an <code>__eq__()</code> method, it should not implement <code>__hash__()</code>, since the implementation of hashable collections requires that a key’s hash value is immutable (if the object’s hash value changes, it will be in the wrong hash bucket).</p>
</blockquote>
<p>Custom Python classes define a default <code>__eq__</code> method that returns True when both operands reference the same object (<code>obj1 is obj2</code> is true).</p>
<p>That it <em>sometimes</em> works in Python 3 is a property of <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-R" rel="nofollow noreferrer">hash randomisation</a> for strings. Because the hash value for a string changes between Python interpreter runs, and because the modulus of a hash against the size of the hash table is used, you <em>can</em> end up with the right hash slot anyway, purely by accident, and then the <code>==</code> equality test will still be true because you didn't implement a custom <code>__eq__</code> method.</p>
<p>Python 2 has hash randomisation too but it is disabled by default, but you could make your test 'pass' anyway by carefully picking the 'right' values for the <code>a</code> and <code>b</code> attributes.</p>
<p>Instead, you could make your code work by basing your hash on the <code>id()</code> of your instance; that makes the hash value not change and would match the default <code>__eq__</code> implementation:</p>
<pre><code>def __hash__(self):
    return hash(id(self))
</code></pre>
<p>You could also just <em>remove</em> your <code>__hash__</code> implementation for the same effect, as the default implementation does basically the above (with the <code>id()</code> value rotated by 4 bits to evade memory alignment patterns). Again, from the <code>__hash__</code> documentation:</p>
<blockquote>
<p>User-defined classes have <code>__eq__()</code> and <code>__hash__()</code> methods by default; with them, all objects compare unequal (except with themselves) and <code>x.__hash__()</code> returns an appropriate value such that <code>x == y</code> implies both that <code>x is y</code> and <code>hash(x) == hash(y)</code>.</p>
</blockquote>
<p>Alternatively, implement an <code>__eq__</code> method that bases equality on equality of the attributes of the instance, and <em>don't mutate the attributes</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are changing the objects (ie changing the objects' hash) <em>after</em> they were added to the set. </p>
<p>When <code>remove</code> is called, it can't find that hash in the set because it was changed after it was calculated (when the objects were originally added to the set). </p>
</div>
<span class="comment-copy">That quote is interesting. Why would the implementation of <code>__eq__</code> (used for comparison, ie not changing the object) affect the implementation of <code>__hash__</code> ?</span>
<span class="comment-copy">@DeepSpace: two objects that compare equal <i>must</i> produce the same hash. In this case, the default <code>__eq__</code> implementation returns true for two references to the same object, so even altering the two attributes doesn't change the equality test outcome.</span>
<span class="comment-copy">@DeepSpace: the hash is used to pick a slot in the hash table (out of a limited number of them, so hash modulo table size is used), and then equality is tested to see if the same object is already in that slot. If your equality test still passes for two objects with different hash values, you are going to break this test; you could 'find' a value in the set that isn't actually there.</span>
<span class="comment-copy">@DeepSpace: in fact, numeric types in Python 'break' sets; <code>True in {1}</code> is true, because <code>True == 1</code> and <code>False == 0</code> (<code>bool</code> is a subclass of <code>int</code> for historical reasons). Same for <code>42.0 in {42}</code>, because whole floating point numbers test equal to their integer counterparts.</span>
<span class="comment-copy">Good points, thanks :)</span>
