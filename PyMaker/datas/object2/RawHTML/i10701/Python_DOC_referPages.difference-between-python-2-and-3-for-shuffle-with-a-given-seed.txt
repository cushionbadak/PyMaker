<div class="post-text" itemprop="text">
<p>I am writing a program compatible with both Python 2.7 and 3.5. Some parts of it rely on stochastic process. My unit tests use an arbitrary seed, which leads to the same results across executions and languages... except for the code using <code>random.shuffle</code>.</p>
<p>Example in Python 2.7:</p>
<pre><code>In[]:   import random
        random.seed(42)
        print(random.random())
        l = list(range(20))
        random.shuffle(l)
        print(l)
Out[]:  0.639426798458
        [6, 8, 9, 15, 7, 3, 17, 14, 11, 16, 2, 19, 18, 1, 13, 10, 12, 4, 5, 0]
</code></pre>
<p>Same input in Python 3.5:</p>
<pre><code>In []:  import random
        random.seed(42)
        print(random.random())
        l = list(range(20))
        random.shuffle(l)
        print(l)
Out[]:  0.6394267984578837
        [3, 5, 2, 15, 9, 12, 16, 19, 6, 13, 18, 14, 10, 1, 11, 4, 17, 7, 8, 0]
</code></pre>
<p>Note that the pseudo-random number is the same, but the shuffled lists are different. As expected, reexecuting the cells does not change their respective output.</p>
<p>How could I write the same test code for the two versions of Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.2 the random module was refactored a little to make the output uniform across architectures (given the same seed), see <a href="http://bugs.python.org/issue7889" rel="noreferrer">issue #7889</a>. The <code>shuffle()</code> method was switched to using <code>Random._randbelow()</code>.</p>
<p>However, the <code>_randbelow()</code> method was <em>also</em> adjusted, so simply copying the 3.5 version of <code>shuffle()</code> is not enough to fix this.</p>
<p>That said, if you pass in your own <code>random()</code> function, the implementation in Python 3.5 is <em>unchanged from the 2.7</em> version, and thus lets you bypass this limitation:</p>
<pre><code>random.shuffle(l, random.random)
</code></pre>
<p>Note however, than now you are subject to the old 32-bit vs 64-bit architecture differences that #7889 tried to solve.</p>
<p>Ignoring several optimisations and special cases, if you include <code>_randbelow()</code> the 3.5 version can be backported as:</p>
<pre><code>import random
import sys

if sys.version_info &gt;= (3, 2):
    newshuffle = random.shuffle
else:
    try:
        xrange
    except NameError:
        xrange = range

    def newshuffle(x):
        def _randbelow(n):
            "Return a random int in the range [0,n).  Raises ValueError if n==0."
            getrandbits = random.getrandbits
            k = n.bit_length()  # don't use (n-1) here because n can be 1
            r = getrandbits(k)          # 0 &lt;= r &lt; 2**k
            while r &gt;= n:
                r = getrandbits(k)
            return r

        for i in xrange(len(x) - 1, 0, -1):
            # pick an element in x[:i+1] with which to exchange x[i]
            j = _randbelow(i+1)
            x[i], x[j] = x[j], x[i]
</code></pre>
<p>which gives you the same output on 2.7 as 3.5:</p>
<pre><code>&gt;&gt;&gt; random.seed(42)
&gt;&gt;&gt; print(random.random())
0.639426798458
&gt;&gt;&gt; l = list(range(20))
&gt;&gt;&gt; newshuffle(l)
&gt;&gt;&gt; print(l)
[3, 5, 2, 15, 9, 12, 16, 19, 6, 13, 18, 14, 10, 1, 11, 4, 17, 7, 8, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Elaborating on Martijn Pieters excellent answer and comments, and on this <a href="https://stackoverflow.com/questions/30585108/disable-hash-randomization-from-within-python-program?noredirect=1&amp;lq=1">discussion</a>, I finally found a workaround, which arguably doesn't answer my very question, but at the same time doesn't require deep changes. To sum up:</p>
<ul>
<li><code>random.seed</code> actually makes every <code>random</code> function deterministic, but doesn't necessarily produces the same output across versions;</li>
<li>setting <code>PYTHONHASHSEED</code> to 0 disables hash randomization for dictionaries and sets, which by default introduces a factor of non-determinism in Python 3.</li>
</ul>
<p>So, in the bash script which launches the Python 3 tests, I added:</p>
<pre><code>export PYTHONHASHSEED=0
</code></pre>
<p>Then, I temporarily changed my test functions in order to brute-force my way to an integer seed which would reproduces in Python 3 the results expected in Python 2. Lastly, I reverted my changes and replaced the lines:</p>
<pre><code>seed(42)
</code></pre>
<p>by something like that:</p>
<pre><code>seed(42 if sys.version_info.major == 2 else 299)
</code></pre>
<p>Nothing to brag about, but as the saying goes, sometimes practicality beats purity ;)</p>
<p>This quick workaround may be useful to somebody who wants to test the same stochastic code across different versions of Python!</p>
</div>
<div class="post-text" itemprop="text">
<p>Someone may correct me if I'm wrong but it seems that <code>numpy.random</code> module do not change between python 2 and 3.</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; l = list(range(20))
&gt;&gt;&gt; np.random.RandomState(42).shuffle(l)
&gt;&gt;&gt; l
[0, 17, 15, 1, 8, 5, 11, 3, 18, 16, 13, 2, 9, 19, 4, 12, 7, 10, 14, 6]
</code></pre>
<p>I got the same result in both Python 2.7 (with np 1.12.1) and 3.7 (with np 1.14.5).</p>
<p>The doc also states that generated numbers <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" rel="nofollow noreferrer">should be the same between versions</a>.</p>
<blockquote>
<p><em>Compatibility Guarantee</em> A fixed seed and a fixed series of calls to
  ‘RandomState’ methods using the same parameters will always produce
  the same results up to roundoff error except when the values were
  incorrect. Incorrect values will be fixed and the NumPy version in
  which the fix was made will be noted in the relevant docstring.
  Extension of existing parameter ranges and the addition of new
  parameters is allowed as long the previous behavior remains unchanged.</p>
</blockquote>
</div>
<span class="comment-copy">Also, quick glance over <a href="https://svn.python.org/projects/python/tags/r27/Lib/random.py" rel="nofollow noreferrer">Py2 implementation</a> and <a href="https://svn.python.org/projects/python/tags/r32/Lib/random.py" rel="nofollow noreferrer">Py3 implementation</a> shows that there are more than one implementations of shuffle itself (although they may be equivalent - I'd expect there should be an unittests for that when modification was introduced).</span>
<span class="comment-copy">Try <code>random.seed(42, version=1)</code> (or maybe version=2; but set this argument) as documented <a href="https://docs.python.org/3/library/random.html#random.seed" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy"><code>[random.random() for _ in range(20)]</code> does return the same results on both versions - so looks like it's an implementation change in <code>random.shuffle</code>...</span>
<span class="comment-copy">@sascha that's not relevant when directly using an <code>int</code> as the seed sadly.</span>
<span class="comment-copy">@sascha same output under Py3, <code>unexpected keyword argument</code> under Py2.</span>
<span class="comment-copy">@Marijn Pieters It's just fine, and as a bonus I can use the same tests I already wrote for Python 2. I would read the issue though.</span>
<span class="comment-copy">Actually, it seems that my tests still don't work under both versions. Specifically, the Py3 version sometimes passes, and sometimes fails, which proves that my seed is not enough to make it deterministic. I guess the other <code>random</code> functions I use (namely <code>randrange</code> and <code>choice</code>) have the same kind of problem. Very strange indeed.</span>
<span class="comment-copy">Yes, <code>choice</code> and <code>randrange</code> were also refactored, see <a href="https://hg.python.org/cpython/diff/c2f8418a0e14/Lib/random.py" rel="nofollow noreferrer">this patch</a>.</span>
<span class="comment-copy">Both functions are easily backported based on the extracted section of <code>_randbelow()</code> I included in my answer as a local function. Just extract that one, and extract the functions you need from the <a href="https://hg.python.org/cpython/file/3.5/Lib/random.py" rel="nofollow noreferrer">3.5 source code of <code>random.py</code></a>.</span>
<span class="comment-copy">Yes, I definitely iterate on a dictionary. That would explain a lot of things, cf. <a href="http://stackoverflow.com/questions/30585108/disable-hash-randomization-from-within-python-program" title="disable hash randomization from within python program">stackoverflow.com/questions/30585108/…</a> for more on this. You, sir, not only answered my exact question, but learnt me a lot of interesting stuff on the way. Thanks again for your time and your expertise.</span>
