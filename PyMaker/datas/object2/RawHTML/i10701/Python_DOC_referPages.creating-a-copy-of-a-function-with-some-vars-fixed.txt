<div class="post-text" itemprop="text">
<p>Assume I have a function</p>
<pre><code>def multiply_by(x, multiplier):
    return x * multiplier
</code></pre>
<p>How can I create a copy of that function and fix the multiplier in that function?</p>
<pre><code>multiply_by_5 = multiply_by?    &lt;-- here I need python magic
</code></pre>
<p>such that multiply_by_5 would have only one argument x and the multiplier would be 5? So that</p>
<pre><code>multiply_by_5(2)
10
</code></pre>
<p>Is there a way in Python 2.7 to do that?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial</code></a> with keyword argument:</p>
<pre><code>&gt;&gt;&gt; def multiply_by(x, multiplier):
...     return x * multiplier
...
&gt;&gt;&gt; from functools import partial
&gt;&gt;&gt; multiply_by_5 = partial(multiply_by, multiplier=5)
&gt;&gt;&gt; multiply_by_5(2)
10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow">functools.partial</a> is made exactly for this.</p>
<p>you can use it like</p>
<pre><code>import functools
multiply_by_5=functools.partial(multiply_by,multiplier=5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As suggested by @niemmi's <a href="https://stackoverflow.com/a/38788966/2289509">answer</a>, <code>functools.partial</code> is probably the way to go. </p>
<p>However, similar work can be done using curried functions:</p>
<pre><code>def multiply_by(multiplier):
    def multiply(x):
        return multiplier * x
    return multiply

&gt;&gt;&gt; multiply_by_5 = multiply_by(5)    # no magic
&gt;&gt;&gt; multiply_by_5(2)
10
</code></pre>
<p>Or using the lambda syntax:</p>
<pre><code>def multiply_by(multiplier):
    return lambda x: multiplier * x
</code></pre>
<p>Note that <code>partial</code> is more succinct, more efficient, and more directly express your intent in a standard way. The above technique is an example of the concept called closure, which is means that a function defined in inner scope may refer to variables defined in enclosing scopes, and "close" over them, remembering them, and even mutating them.</p>
<p>Since this technique is more general, it might take the reader of your code more time to understand what exactly do you mean in your code, since your code may be arbitrarily complicated.</p>
<hr/>
<p>Specifically for multiplication (and other operators) <code>partial</code> can be combined with <code>operator.mul</code>:</p>
<pre><code>&gt;&gt;&gt; import functools, operator
&gt;&gt;&gt; multiply_by_5 = functools.partial(operator.mul, 5)
&gt;&gt;&gt; multiply_by_5(2)
10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an alternative that doesn't use <code>functools.partial</code>. Instead we define a function inside a function. The inner function "remembers" any of the local variables of the outer function that it needs (including the outer function's arguments). The magic that makes this happen is called <a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29" rel="nofollow">closure</a>. </p>
<pre><code>def multiply_factory(multiplier):
    def fixed_multiply(x):
        return x * multiplier
    return fixed_multiply

multiply_by_3 = multiply_factory(3)
multiply_by_5 = multiply_factory(5)

for i in range(5):
    print(i, multiply_by_3(i), multiply_by_5(i))
</code></pre>
<p><strong>output</strong></p>
<pre><code>0 0 0
1 3 5
2 6 10
3 9 15
4 12 20
</code></pre>
<p>If you want, you can use your existing <code>multiply_by</code> function in the closure, although that's slightly less efficient, due to the overhead of an extra function call. Eg:</p>
<pre><code>def multiply_factory(multiplier):
    def fixed_multiply(x):
        return multiply_by(x, multiplier)
    return fixed_multiply
</code></pre>
<p>That can be written more compactly using <code>lambda</code> syntax:</p>
<pre><code>def multiply_factory(multiplier):
    return lambda x: multiply_by(x, multiplier)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you cannot change the <code>multiply_by()</code> function, the simplest and perhaps best way is probably</p>
<pre><code>def multiply_by_5(x):
    return multiply_by(x, 5)
</code></pre>
<p>You can also use <code>lambda</code> if you really want a one-liner.</p>
<p>However, you may want to change your first function to</p>
<pre><code>def multiply_by(x, multiplier = 5):
    return x * multiplier
</code></pre>
<p>Then you can do either of these:</p>
<pre><code>print(multiply_by(4, 3))
12

print(multiply_by(2))
10
</code></pre>
</div>
<span class="comment-copy">What is your expected advantage of using multiply_by_5(x) over multiply_by(x, 5)?</span>
<span class="comment-copy">Sure, use a <a href="https://docs.python.org/2/library/functools.html#functools.partial" rel="nofollow noreferrer">partial</a>. Or create a <a href="http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python">closure</a></span>
<span class="comment-copy">It isn't called copying, since nothing is actually copied. It's called "partial application". A related notion is that of "curried function".</span>
<span class="comment-copy">is there any advantage over just defining another function, eventually inline with a <code>lambda</code> ?</span>
<span class="comment-copy">@norok2: Not much difference here but please see <a href="http://stackoverflow.com/questions/3252228/python-why-is-functools-partial-necessary" title="python why is functools partial necessary">stackoverflow.com/questions/3252228/â€¦</a> for detailed answer</span>
<span class="comment-copy">performance and succinctness</span>
<span class="comment-copy">performance difference did not seem relevant in this case, I am not sure about more complex cases, though. As far as elegance, I would not see a major advantage here, but I recognize that it is not always the case.. but thanks @niemmi for pointing out to that interesting discussion.</span>
<span class="comment-copy">It's not only elegance. It's more about using standard, familiar and predictable tools instead of some more arbitrary code that needs to be read and comprehended.</span>
<span class="comment-copy">Downvotes deserve a comment</span>
<span class="comment-copy">Thanks. Nice example. Wasn't aware one could do that. Something learned about python. that already makes a good day;)</span>
