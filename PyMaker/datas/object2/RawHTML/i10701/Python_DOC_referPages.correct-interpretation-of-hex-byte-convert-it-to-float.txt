<div class="post-text" itemprop="text">
<p>I am currently trying to connect to an electric meter via RS485.
It works quite well so far, except that I have problems reading what the meter is writing back on the RS485 line.</p>
<p>I know that the data from the electric meter is correct since I can read it with Docklight and the internal programm of the manufacturer.</p>
<p>So my only problem is the conversion of hex bytes that I am getting back.</p>
<p>I am receiving</p>
<pre><code>&gt;&gt;&gt; b'\x01\x03\x04Ce/\xec\xe2'
</code></pre>
<p>This should be 8 or 9 hex bytes.
I expect to receive something like</p>
<pre><code>&gt;&gt;&gt; b'\x01\x03\x04\x43\x67\x81\xEC\x43\x68'
</code></pre>
<p>The problem seems to be that python interprets it in "ASCII" whereever it can and I cannot convert it furthermore because of the non-hexadecimal digits.
And the error I get is  </p>
<pre><code>&gt;&gt;&gt; binascii.Error: Non-hexadecimal digit found`
</code></pre>
<p>The equivalent when I look at it from the other side.
I am sending</p>
<pre><code>&gt;&gt;&gt; data=bytearray([0x01,0x03,0x4A,0x38,0x00,0x02,0x53,0xDE])
</code></pre>
<p>which is displayed as </p>
<pre><code>&gt;&gt;&gt; bytearray(b'\x01\x03J8\x00\x02S\xde')
</code></pre>
<p>when I print it</p>
<p>So how can I tell python-3 that I want to see the 8 hex bytes and not some interpretation that he automatically makes? I believe I am missing on something that is really easy once you know where to look for.</p>
<p>I want to convert bytes 4,5,6,7 into float. But since it is showing me non-hexadecimal digits I cannot do that.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>struct.unpack()</code> to get the numbers from the data. Here is the way:</p>
<pre><code>In [171]: import struct

In [190]: b2
Out[190]: b'\x01\x03J8\x00\x02S\xde'

In [191]: struct.unpack('B'*len(b2), b2)
Out[191]: (1, 3, 74, 56, 0, 2, 83, 222)

In [192]: [*map(hex, struct.unpack('B'*len(b2), b2))]
Out[192]: ['0x1', '0x3', '0x4a', '0x38', '0x0', '0x2', '0x53', '0xde']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>C</code>, <code>e</code> and <code>/</code> are bytes too; they are <em>ASCII characters</em> so don't need to be displayed with <code>\x..</code> hex escapes.</p>
<p>You don't need to decode the <code>\x..</code> hex escapes either, they are just how Python gives you the debugging representation of a <code>bytes</code> object; each byte is either displayed as an escape sequence or a printable ASCII letter.</p>
<p>The same happens to your <em>something like this</em> example:</p>
<pre><code>&gt;&gt;&gt; b'\x01\x03\x04\x43\x67\x81\xEC\x43\x68'
b'\x01\x03\x04Cg\x81\xecCh'
</code></pre>
<p>That's the exact same value, but <code>\x68</code> is the ASCII letter <code>h</code>, etc.</p>
<p>The output is the default <code>repr()</code> output for <code>bytes</code> objects. It can't be changed. You'll have to write your own code if you need different output.</p>
<p>You could display all bytes as hex with the <code>binascii.hexlify()</code> function, for example:</p>
<pre><code>&gt;&gt;&gt; import binascii
&gt;&gt;&gt; binascii.hexlify(b'\x01\x03\x04\x43\x67\x81\xEC\x43\x68')
b'010304436781ec4368'
</code></pre>
<p>Now you have a <code>bytes</code> string with hex <em>characters</em>. Or you could use a <code>str.join()</code> function with each individual byte converted to hex with a <code>\x</code> literal text prefixed:</p>
<pre><code>&gt;&gt;&gt; ''.join(r'\x{:02x}'.format(byte) for byte in b'\x01\x03\x04\x43\x67\x81\xEC\x43\x68')
</code></pre>
<p>'\x01\x03\x04\x43\x67\x81\xec\x43\x68'</p>
<pre><code>&gt;&gt;&gt; print(''.join(r'\x{:02x}'.format(byte) for byte in b'\x01\x03\x04\x43\x67\x81\xEC\x43\x68'))
\x01\x03\x04\x43\x67\x81\xec\x43\x68
</code></pre>
<p>That's a <code>str</code> object with <code>\</code>, <code>x</code> and hex digits as characters.</p>
<p>Note that this is all just <em>displaying the value</em>. The value didn't change; the bytes are all there however you display them. If you need to convert 4 bytes to a float, then just convert those 4 bytes:</p>
<pre><code>struct.unpack('f', yourbytes[4:])  # 4 bytes for C float in native order
</code></pre>
<p>This uses the <a href="https://docs.python.org/3/library/struct.html" rel="nofollow"><code>struct</code> module</a> to use the bytes directly. No hexadecimal representation needed:</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.unpack('f', b'\x01\x03\x04Ce/\xec\xe2'[:4])
(132.01173400878906,)
</code></pre>
</div>
<span class="comment-copy">Why do you need those bytes as hex digits? Are you trying to debug your code and want to know the contents of the bytes as hex digits, or do you need to display this data to the user of your program? You are looking at debugging info here, not a end-user-friendly representation.</span>
<span class="comment-copy">If you just want to convert those bytes to an integer, look at the <code>int.from_bytes</code> method.</span>
<span class="comment-copy">How were you planning to convert hexadecimal digits to float? You'd normally take the bytes value. Those values are all still there.</span>
