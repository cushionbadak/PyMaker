<div class="post-text" itemprop="text">
<p>I'm trying to test a Python script (2.7) where I work with the standar input (readed with raw_input() and writed with a simple print) but I don't find how do this and I'm sure that this issue is very simple.</p>
<p>This is a very very very resume code of my script:</p>
<pre><code>def example():
    number = raw_input()
    print number

if __name__ == '__main__':
    example()
</code></pre>
<p>I want to write a unittest test to check this, but I don't find how. I've trying with StringIO and other things but I don't find the solution to do this really simple.</p>
<p>Somebody have a idea?</p>
<p>PD: Of course in the real script I use data blocks with several lines and other kind of data.</p>
<p>Thank you so much.</p>
<p><strong>EDIT:</strong></p>
<p>Thank you so much for the first really specific answer, it works perfectly, only I've had a little problem importing <code>StringIO</code>, because I was doing import StringIO and I needed to import like <code>from StringIO import StringIO</code> (I don't understand really why), but be that as It may, it works.</p>
<p>But I I've found another problem using this way, in my project I need test a scripts with this way (that work perfectly thanks to your support) but I want do this:
I have a file with a lot of test to pass over a script, so I open the file and read blocks of info with their result blocks and I would like to do that the code will be able to process a block checking their result and do the same with other and another...</p>
<p>Something like this:</p>
<pre><code>class Test(unittest.TestCase):
    ...
    #open file and process saving data like datablocks and results
    ...
    allTest = True
    for test in tests:
        stub_stdin(self, test.dataBlock)
        stub_stdouts(self)
        runScrip()
        if sys.stdout.getvalue() != test.expectResult:
            allTest = False

    self.assertEqual(allTest, True)
</code></pre>
<p>I know that maybe unittest doesn't has sense  now, but you can do a idea about I want. So, this way fails and I don't know why.</p>
</div>
<div class="post-text" itemprop="text">
<p>Typical techniques involve mocking the standard <code>sys.stdin</code> and <code>sys.stdout</code> with your desired items.  If you do not care for Python 3 compatibility you can just use the <code>StringIO</code> module, however if you want forward thinking and is willing to restrict to Python 2.7 and 3.3+, supporting for this both Python 2 and 3 in this way becomes possible without too much work through the <a href="https://docs.python.org/library/io.html" rel="nofollow noreferrer"><code>io</code></a> module (but requires a bit of modification, but put this thought on hold for now).</p>
<p>Assuming you already have a <code>unittest.TestCase</code> going, you can create a utility function (or method in the same class) that will replace <code>sys.stdin</code>/<code>sys.stdout</code> as outlined.  First the imports:</p>
<pre><code>import sys
import io
import unittest
</code></pre>
<p>In one of my recent projects I've done this for stdin, where it take a <code>str</code> for the inputs that the user (or another program through pipes) will enter into yours as stdin:</p>
<pre><code>def stub_stdin(testcase_inst, inputs):
    stdin = sys.stdin

    def cleanup():
        sys.stdin = stdin

    testcase_inst.addCleanup(cleanup)
    sys.stdin = StringIO(inputs)
</code></pre>
<p>As for stdout and stderr:</p>
<pre><code>def stub_stdouts(testcase_inst):
    stderr = sys.stderr
    stdout = sys.stdout

    def cleanup():
        sys.stderr = stderr
        sys.stdout = stdout

    testcase_inst.addCleanup(cleanup)
    sys.stderr = StringIO()
    sys.stdout = StringIO()
</code></pre>
<p>Note that in both cases, it accepts a testcase instance, and calls its <a href="https://docs.python.org/library/unittest.html#unittest.TestCase.addCleanup" rel="nofollow noreferrer"><code>addCleanup</code></a> method that adds the <code>cleanup</code> function call that will reset them back to where they were when the duration of a test method is concluded.  The effect is that for the duration from when this was invoked in the test case until the end, <code>sys.stdout</code> and friends will be replaced with the <code>io.StringIO</code> version, meaning you can check its value easily, and don't have to worry about leaving a mess behind.</p>
<p>Better to show this as an example. To use this, you can simply create a test case like so:</p>
<pre><code>class ExampleTestCase(unittest.TestCase): 

    def test_example(self):
        stub_stdin(self, '42')
        stub_stdouts(self)
        example()
        self.assertEqual(sys.stdout.getvalue(), '42\n')
</code></pre>
<p>Now, in Python 2, this test will only pass if the <code>StringIO</code> class is from the <code>StringIO</code> module, and in Python 3 no such module exists.  What you can do is use the version from the <code>io</code> module with a modification that makes it slightly more lenient in terms of what input it accepts, so that the unicode encoding/decoding will be done automatically rather than triggering an exception (such as <code>print</code> statements in Python 2 will not work nicely without the following).  I typically do this for cross compatibility between Python 2 and 3:</p>
<pre><code>class StringIO(io.StringIO):
    """
    A "safely" wrapped version
    """

    def __init__(self, value=''):
        value = value.encode('utf8', 'backslashreplace').decode('utf8')
        io.StringIO.__init__(self, value)

    def write(self, msg):
        io.StringIO.write(self, msg.encode(
            'utf8', 'backslashreplace').decode('utf8'))
</code></pre>
<p>Now plug your example function plus every code fragment in this answer into one file, you will get your self contained unittest that works in both Python 2 and 3 (although you need to call <code>print</code> as a function in Python 3) for doing testing against stdio.</p>
<p>One more note: you can always put the <code>stub_</code> function calls in the <code>setUp</code> method of the <code>TestCase</code> if every single test method requires that.</p>
<p>Of course, if you want to use various mocks related libraries out there to stub out stdin/stdout, you are free to do so, but this way relies on no external dependencies if this is your goal.</p>
<hr/>
<p>For your second issue, test cases have to be written in a certain way, where they must be encapsulated within a method and not at the class level, your original example will fail.  However you might want to do something like this:</p>
<pre><code>class Test(unittest.TestCase):

    def helper(self, data, answer, runner):
        stub_stdin(self, data)
        stub_stdouts(self)
        runner()
        self.assertEqual(sys.stdout.getvalue(), answer)
        self.doCleanups()  # optional, see comments below

    def test_various_inputs(self):
        data_and_answers = [
            ('hello', 'HELLOhello'),
            ('goodbye', 'GOODBYEgoodbye'),
        ]

        runScript = upperlower  # the function I want to test 

        for data, answer in data_and_answers:
            self.helper(data, answer, runScript)
</code></pre>
<p>The reason why you might want to call <code>doCleanups</code> is to prevent the cleanup stack from getting as deep as all the <code>data_and_answers</code> pairs are there, but that will pop everything off the cleanup stack so if you had any other things that need to be cleaned up at the end this might end up being problematic - you are free to leave that there as all of the stdio related objects will be restored at the end in the same order, so the real one will always be there.  Now the function I wanted to test:</p>
<pre><code>def upperlower():
    raw = raw_input()
    print (raw.upper() + raw),
</code></pre>
<p>So yes, a bit of explanation for what I did might help: remember within a <code>TestCase</code> class, the framework relies strictly on the instance's <code>assertEqual</code> and friends for it to function.  So to ensure testing being done at the right level you really want to call those asserts all the time so that helpful error messages will be shown at the moment the error occurred with the inputs/answers that didn't quite show up right, rather than until the very end like what you did with the for loop (that will tell you something was wrong, but not exactly where out of the hundreds and now you are mad).  Also the <code>helper</code> method - you can call it anything you want, as long as it doesn't start with <code>test</code> because then the framework will try to run it as one and it will fail terribly.  So just follow this convention and you can basically have templates within your test case to run your test with - you can then use it in a loop with a bunch of inputs/outputs like what I did.</p>
<p>As for your other question:</p>
<blockquote>
<p>only I've had a little problem importing StringIO, because I was doing import StringIO and I needed to import like from StringIO import StringIO (I don't understand really why), but be that as It may, it works.</p>
</blockquote>
<p>Well, if you look at my original code I did show you how did <code>import io</code> and then overrode the <code>io.StringIO</code> class by defining <code>class StringIO(io.StringIO)</code>.  However it works for you because you are doing this strictly from Python 2, whereas I do try to target my answers to Python 3 whenever possible given that Python 2 will (probably definitely this time) not be supported in less than 5 years.  Think of the future users that might be reading this post who had similar problem as you.  Anyway, yes, the original <code>from StringIO import StringIO</code> works, as that's the <code>StringIO</code> class from the <code>StringIO</code> module.  Though <code>from cStringIO import StringIO</code> should work as that imports the <code>C</code> version of the <code>StringIO</code> module. It works because they all offer close enough interfaces, and so they will basically work as intended (until of course you try to run this under Python 3).</p>
<p>Again, putting all this together along with my code should result in a <a href="https://gist.github.com/metatoaster/64139971b53ad728dba636e34b8a5558" rel="nofollow noreferrer">self-contained working test script</a>.  Do remember to look at documentation and follow the form of the code, and not invent your own syntax and hoping things to work (and as for exactly why your code didn't work, because the "test" code was defined at where the class was being constructed, so all of that was executed while Python was importing your module, and since none of the things that are needed for the test to run are even available (namely the class itself doesn't even exist yet), the whole thing just dies in fits of twitching agony). Asking questions here help too, even though the issue you face is something really common, not having a quick and simple name to search for your exact problem does make it difficult to figure out where you went wrong, I supposed? :)  Anyway good luck, and good on you for taking the effort to test your code.</p>
<hr/>
<p>There are other methods, but given that the other questions/answers I looked at here at SO doesn't seem to help, I hope this one this.  Other ones for reference:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/2617057/how-to-supply-stdin-files-and-environment-variable-inputs-to-python-unit-tests">How to supply stdin, files and environment variable inputs to Python unit tests?</a></li>
<li><a href="https://stackoverflow.com/questions/21046717/python-mocking-raw-input-in-unittests">python mocking raw input in unittests</a></li>
</ul>
<p>Naturally, it bares repeating that all of this <em>can</em> be done using <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>unittest.mock</code></a> available in Python 3.3+ or the <a href="https://pypi.python.org/pypi/mock" rel="nofollow noreferrer">original/rolling backport version on pypi</a>, but given that those libraries hides some of the intricacies on what actually happens, they may end up hiding some of the details on what actually happens (or need to happen) or how the redirection actually happens.  If you want, you can read up on <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow noreferrer"><code>unittest.mock.patch</code></a> and go down slightly to the <code>StringIO</code> patching <code>sys.stdout</code> section.</p>
</div>
<span class="comment-copy">Thank you for the really good answer @metatoaster I've added more info about the problem that now I found using your way to read in a for loop. Thank you again.</span>
