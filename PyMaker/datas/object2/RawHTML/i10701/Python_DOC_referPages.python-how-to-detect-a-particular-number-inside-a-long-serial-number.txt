<div class="post-text" itemprop="text">
<p>I have been working on this project, a small Python and Tkinter project as I'm a beginner and I almost finished it if it weren't for this little issue I have with it that I detected after doing a few tests.
The program should say whether a serial number that I entered in an input is a "devil number" or not depending on whether the number does have the number "666" in it or not. in the positive case, there should be the number "666" in it and it should away from other 6s, which means there shouldn't be something like this "666". If the number "666" is repeated several times inside the serial number (without being stuck together "666666") it can be considered a devil number too.</p>
<p>The issue I have is that when I test numbers that only have one "666" within them and that at the same time end with that number (666), those numbers are not considered as devil numbers while they should be. I can't seem to solve this problem.</p>
<p>To realise this project, I used Python and Tkinter. The code is as follows:</p>
<pre><code>"""*************************************************************************"""
""" Author: CHIHAB        Version: 2.0        Email: chihab2007@gmail.com   """
""" Purpose: Practice     Level: Beginner     2016/2017                     """
"""*************************************************************************"""
############################ I M P O R T S#####################################
from tkinter import*
from types import *
############################ T K I N T E R ####################################
main = Tk()

e = Entry(main, bg="darkblue", fg="white")
e.pack(fill=X)

l = Label(main, bg="blue", fg="yellow")
l.pack(fill=X)
############################ F U N C T I O N S ################################
def devil(x): #TEST ENTERED VALUE FOR DEVIL NUMBER
    c = 0
    i = 0
    l = list(x)
    while i &lt; len(l):                   #This block of code means that as long as the index i 
        if l[i] == "6":                 #   is below the length of the list to which we have 
            c = c+1                     #       converted the entry, the program is allowed to keep 
            print("this is c :", c)     #           reading through the list's characters.
        else:
            c = 0
        if i &lt;= (len(l)-2) and c == 3 and l[i+1] != "6":
            return True
        i = i+1
    return False
def printo():   #GET VALUE ENTRY AND SHOW IT IN LABEL
    x = e.get()
    if x != "":
        if x.isnumeric() == True:   #SHOW ENTERED VALUE IF INTEGER
            y = devil(x)
            if y == True:
                print("The number you entered is a devil number.")                
                l.config(text="The number you entered is a devil number.", bg="blue")
            else:
                print("The number you entered is NOT a devil number.")                
                l.config(text="The number you entered is NOT a devil number.", bg="blue")
            #print(x)
            e.delete(0, END)
        else:   #SHOW ERROR IF NOT INTEGER
            l.config(text="please enter an integer in the entry.", bg="red")
            print("please enter an integer in the entry.")
            e.delete(0, END)
    else:   #SHOW ERROR IF EMPTY
        l.config(text="please enter something in the entry.", bg="red")
        print("please enter something in the entry.")

############################ T K I N T E R ####################################
b = Button(main, text="Go", bg="lightblue", command=printo)
b.pack(fill=X)

main.mainloop()
</code></pre>
<p>Here you go, guyz. I hope my code is neat enough and that you would be able to help me which I have no doubt about.
Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you mean that <code>666</code>, found anywhere in the number should be a match, then it's very simple:</p>
<pre><code>if '666' in '1234666321':
    print("It's a devil's number")
</code></pre>
<p>However, you say that <code>666</code> must be a "lone" <code>666</code>, i.e. exactly three <code>6</code> side by side, no more, no less. Neither two, nor four. Five <code>6</code>'s are right out. In that case, I would use <a href="https://stackoverflow.com/a/38769806/344286">tobias_k's regex</a>. </p>
<p>Though, if you had a passionate hatred for regex, you <em>could</em> do it using <code>string.partition</code>:</p>
<pre><code>def has_devils_number(num):
    start, mid, end = num.partition('666')
    if not mid:
        return False
    else:
        if end == '666':
            return False
        elif start.endswith('6') or end.startswith('6'):
            return has_devils_number(start) or has_devils_number(end)
        return True
</code></pre>
<p>Here's what the performance looks like:</p>
<pre><code>&gt;&gt;&gt; x = '''
... import re
... numbas = ['666', '6', '123666', '12366', '66123', '666123', '666666', '6666', '6'*9, '66661236666']
... 
... def devil(x):
...     return re.search(r"(?:^|[^6])(666)(?:[^6]|$)", x) is not None
... '''
&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit('[devil(num) for num in numbas]', setup=x)
13.822128501953557

&gt;&gt;&gt; x = '''
... numbas = ['666', '6', '123666', '12366', '66123', '666123', '666666', '6666', '6'*9, '6666123
666']
... def has_devils_number(num):
...     start, mid, end = num.partition('666')
...     if not mid:
...         return False
...     else:
...         if end == '666':
...             return False
...         elif start.endswith('6') or end.startswith('6'):
...             return has_devils_number(start) or has_devils_number(end)
...         return True
... '''
&gt;&gt;&gt; timeit.timeit('[has_devils_number(num) for num in numbas]', setup=x)
9.843224229989573
</code></pre>
<p>I'm as surprised as you are.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use a <a href="https://docs.python.org/3/library/re.html#re.search" rel="nofollow">regular expression</a> for this. Something like <code>(?:^|[^6])(666)(?:[^6]|$)</code> seems to work. This means "start of string <code>^</code> or <code>|</code> something that is not a 6 <code>[^6]</code>, then <code>666</code>, then something other than 6 or end of string <code>$</code>".</p>
<pre><code>&gt;&gt;&gt; p = r"(?:^|[^6])(666)(?:[^6]|$)"
&gt;&gt;&gt; re.search(p, "123666")
&lt;_sre.SRE_Match at 0x7fe120f12918&gt;
&gt;&gt;&gt; re.search(p, "666123")
&lt;_sre.SRE_Match at 0x7fe120f128a0&gt;
&gt;&gt;&gt; re.search(p, "12366666123")
None
</code></pre>
<p>In your code, this should do the trick (not tested):</p>
<pre><code>def devil(x):
    p = r"(?:^|[^6])(666)(?:[^6]|$)"
    return re.search(p, x) is not None
</code></pre>
<p>If performance is an issue (but in your case it should not be), you can precompile the regex.</p>
<pre><code>p = re.compile(r"(?:^|[^6])(666)(?:[^6]|$)")
def devil_fast(x):
    return p.search(x) is not None
</code></pre>
<p>Timing:</p>
<pre><code>In [5]: numbers = ['666', '6', '123666', '12366', '66123', '666123', '666666', '6666', '6'*9, '66661236666', '12366664566786669']
In [8]: %timeit [devil(x) for x in numbers]
100000 loops, best of 3: 14 µs per loop
In [9]: %timeit [devil_fast(x) for x in numbers]
100000 loops, best of 3: 6.32 µs per loop
</code></pre>
</div>
<span class="comment-copy">please use re.search(r'.*666.*', input_number) if match is not None it is devil number as per your question above.</span>
<span class="comment-copy">Do you mean that <i>any</i> <code>666</code> should match, or <i>only</i> when there is a sequence of the three of them, potentially repeating? i.e. <code>123666</code> is a devil's number? What about <code>123666666321</code> (two groups of <code>666</code>)? And <code>1236666</code> (four <code>6</code>'s)?</span>
<span class="comment-copy">@WayneWerner, There should be at least one "666" within the serial number even if it's stuck to other numbers different from 6. there could be more, but there shouldn't be a sequence of 666. like for example, 666666 wouldn't work, 6666 wouldn't work either. however, 12366678666 should be considered a devil number. Thank you!!</span>
<span class="comment-copy">@forvaidya, I will definately try that function. I have never seen it before. Thank you!</span>
<span class="comment-copy">You don't need all that code for this problem, and this problem is unrelated to tkinter. I suggest rewriting your example to have a simple function that takes an input and returns true or false. Then, write some simple assertions for various inputs. Including all of the other code clouds the issue.</span>
<span class="comment-copy">OP said that <code>6666</code> should not be a match.</span>
<span class="comment-copy">I have first thought of this. But it wouldn't work as this way it would detect 666 even if it's inside other 6s. 66666 would be  considered devil's number when it shouldn't be. Thanks!!</span>
<span class="comment-copy">@Chihab I've added some code that <i>would</i> work, though I'd probably go with the regex option, even if it may be slower?</span>
<span class="comment-copy">+1 for the second approach. Took me some time to wrap my head around that. However, I think you can do without the recursive call for <code>start</code>. Also, for timing you can use IPythons <code>%timeit</code> function, e.g. <code>%timeit [has_devils_number(n) for n in numbas]</code></span>
<span class="comment-copy">That's probably true, now that I think about it, because partition will always grab the first <code>666</code>. I wonder if the regex performance improves on longer numbers (e.g. CC numbers)</span>
<span class="comment-copy">Yess!!!! thank you!!!!!!!!!</span>
<span class="comment-copy">@Chihab If this solved your problem, you might consider <i>accepting</i> this or another answer to mark your question as being resolved.</span>
<span class="comment-copy">@tobias_k Sorry I didn't see your post. I see now why my answer wouldn't work in those "edge" cases :-)</span>
