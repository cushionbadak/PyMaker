<div class="post-text" itemprop="text">
<p>I have the following program :</p>
<pre><code>import string
import itertools
import multiprocessing as mp

def test(word_list):
    return list(map(lambda xy: (xy[0], len(list(xy[1]))),
        itertools.groupby(sorted(word_list))))

def f(x):
    return (x[0], len(list(x[1])))

def test_parallel(word_list):
    w = mp.cpu_count()
    pool = mp.Pool(w)
    return (pool.map(f, itertools.groupby(sorted(word_list))))

def main():
    test_list = ["test", "test", "test", "this", "this", "that"]

    print(test(test_list))
    print(test_parallel(test_list))

    return

if __name__ == "__main__":
    main()
</code></pre>
<p>The output is :</p>
<pre><code>[('test', 3), ('that', 1), ('this', 2)]
[('test', 0), ('that', 0), ('this', 1)]
</code></pre>
<p>The first line is the expected and correct result. My question is, why isn't pool.map() returning the same results as map()?</p>
<p>Also, I'm aware a 6 item list isn't the perfect case for multiprocessing. This is simply a demonstration of the issue I am having while implementing in a larger application.</p>
<p>I'm using Python 3.5.1.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>groupby()</code> returns <em>iterators</em> per group, and these are <em>not independent</em> from the underlying iterator passed in. You can't independently iterate over these groups in parallel; any preceding group will be prematurely ended the moment you access the next.</p>
<p><code>pool.map()</code> will try to read all of the <code>groupby()</code> iterator results to send those results to separate functions; merely trying to get a second group will cause the first to be empty.</p>
<p>You can see the same result without <code>pool.map()</code> simply by iterating to the next result from <code>groupby()</code>:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; word_list = ["test", "test", "test", "this", "this", "that"]
&gt;&gt;&gt; iterator = groupby(sorted(word_list))
&gt;&gt;&gt; first = next(iterator)
&gt;&gt;&gt; next(first[1])
'test'
&gt;&gt;&gt; second = next(iterator)
&gt;&gt;&gt; list(first[1])
[]
</code></pre>
<p>The remainder of the first group is 'empty' because the second group has been requested.</p>
<p>This is clearly <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow">documented</a>:</p>
<blockquote>
<p>Because the source is shared, when the <code>groupby()</code> object is advanced, the previous group is no longer visible.</p>
</blockquote>
<p>You'd have to 'materialise' each group <em>before</em> sending it to the the function:</p>
<pre><code>return pool.map(lambda kg: f((k[0], list(kg[1]))), itertools.groupby(sorted(word_list)))
</code></pre>
<p>or</p>
<pre><code>return pool.map(f, (
    (key, list(group)) for key, group in itertools.groupby(sorted(word_list))))
</code></pre>
<p>where the generator expression takes care of the materialising as <code>pool.map()</code> iterates.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3.5/library/itertools.html#itertools.groupby" rel="nofollow">https://docs.python.org/3.5/library/itertools.html#itertools.groupby</a>:</p>
<blockquote>
<p>The returned group is itself an iterator that shares the underlying
  iterable with groupby(). Because the source is shared, when the
  groupby() object is advanced, the previous group is no longer visible.
  So, if that data is needed later, it should be stored as a list:</p>
<pre><code>groups = []
uniquekeys = []
data = sorted(data, key=keyfunc)
for k, g in groupby(data, keyfunc):
    groups.append(list(g))      # Store group iterator as a list
    uniquekeys.append(k)
</code></pre>
</blockquote>
<p>I think the issue here is that <code>Pool.map</code> tries to chop up its input, and in doing so, it iterates through the result of <code>groupby</code>, which effectively skips over the elements from all but the last group.</p>
<p>One fix for your code would be to use something like <code>[(k, list(v)) for k, v in itertools.groupby(sorted(word_list))]</code>, but I don't know how applicable that is to your real-world use case.</p>
</div>
<span class="comment-copy">Ah, I understand. Thank you for pointing this out to me! I think I'd have a problem pickling the lambda though.</span>
<span class="comment-copy">@Surtr: right; added a generator expression version to mitigate that. That at least keeps the materialisation lazy.</span>
<span class="comment-copy">Both great answers - I especially appreciate the lack of condescension. I'm giving you Best Answer because yours came through first. Thanks @smarx for an equally great answer.</span>
<span class="comment-copy">Thanks, can't believe I missed that. Will try your suggested workaround.</span>
