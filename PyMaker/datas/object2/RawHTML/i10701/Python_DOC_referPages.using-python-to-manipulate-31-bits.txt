<div class="post-text" itemprop="text">
<p>I have a specification which outlines how instructions should be sent over serial.</p>
<p>Currently I am crafting the packets that will go over the connection.</p>
<p>One segment of the packet, requires a 32-bit (4 byte) binary number. 
The first 31-bits are 'data' and the last bit is merely a flag.</p>
<p>So, The max decimal number that could fit in data is: 2147483647 (2^31). Data could never be bigger than this, Cool!</p>
<p>My problem, is how do I go about encoding the data to 31-bits binary, then setting the final bit to enable the flag?</p>
<p>Say my data is <code>7AAAAAAA</code> what is the desirable way of converting this to 31 bit binary then adding 1 or a 0 to the end?</p>
<p><strong>Edit - I'm Using Python 3.4</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>I think you can use binary shift to add your flag to a number:</p>
<pre><code>a = 0x7AAAAAAA                # 2058005162 = 0b1111010101010101010101010101010
f = 1                         # 1 = 0b1

packet = a + (f &lt;&lt; 31)        # a + 0b10000000000000000000000000000000
bin(packet)                   # 0b11111010101010101010101010101010
</code></pre>
<p>To unpack you can use mask and binary AND like this:</p>
<pre><code>mask = (1 &lt;&lt; 31) - 1          # 2147483647 = 0b1111111111111111111111111111111
a = packet &amp; mask             # 2058005162 = 0b1111010101010101010101010101010
f = packet &gt;&gt; 31              # 1 = 0b1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The only thing which comes to my mind is operation on strings</p>
<p>Say we have two variables:</p>
<pre><code>&gt;&gt;&gt; data = '7AAAAAAA'
&gt;&gt;&gt; flag = '1'
</code></pre>
<p>Convert the data hex to number</p>
<pre><code>&gt;&gt;&gt; num = int(data, 16)
&gt;&gt;&gt; num
2058005162
</code></pre>
<p>Convert the number to string binary representation:</p>
<pre><code>&gt;&gt;&gt; bin_num = bin(num)
&gt;&gt;&gt; bin_num
'0b1111010101010101010101010101010'
</code></pre>
<p>Append flag to the end</p>
<pre><code>&gt;&gt;&gt; bin_num += flag
&gt;&gt;&gt; bin_num
'0b11110101010101010101010101010101'
</code></pre>
<p>Evaluate string to get number and convert back to hex or whatever you need:</p>
<pre><code>&gt;&gt;&gt; eval(bin_num)
4116010325
</code></pre>
<p><strong>#edit1</strong></p>
<p>In order to extend the value to 4-bytes you can use:</p>
<pre><code>&gt;&gt;&gt; final_val = eval(bin_num)
&gt;&gt;&gt; int.to_bytes(final_val, 4, 'big')
b'\xf5UUU'
</code></pre>
<p><strong>#edit2</strong></p>
<pre><code>def convert(data, flag):
    with_flag = eval(bin(int(data, 16)) + flag)
    return int.to_bytes(with_flag, 4, 'big')

def unconvert(byte_data):
    bin_str = bin(int.from_bytes(byte_data, 'big'))
    flag = bin_str[-1]
    data = bin_str[:-1]
    return (hex(eval(data)), flag)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See if this works, similar to other answers but accounts for original bit length.</p>
<p>Define the final number of bits</p>
<pre><code>&gt;&gt;&gt; bits = 16
</code></pre>
<p>Start with a bytes literal</p>
<pre><code>&gt;&gt;&gt; a = b'10'
</code></pre>
<p>Convert to an <code>int</code></p>
<pre><code>&gt;&gt;&gt; b = int(a, base = 16)
</code></pre>
<p>Shift left to the required bit length</p>
<pre><code>&gt;&gt;&gt; shift = bits - b.bit_length()
&gt;&gt;&gt; c = b &lt;&lt; shift
</code></pre>
<p>Add the <em>flag</em></p>
<pre><code>&gt;&gt;&gt; d = c | 1

&gt;&gt;&gt; 
&gt;&gt;&gt; a
b'10'
&gt;&gt;&gt; b
16
&gt;&gt;&gt; c
32768
&gt;&gt;&gt; d
32769

&gt;&gt;&gt; bin(b)
'0b10000'
&gt;&gt;&gt; bin(c)
'0b1000000000000000'
&gt;&gt;&gt; bin(d)
'0b1000000000000001'
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">Look into the <code>struct</code> module plus the bit-modifying operator <code>|</code>.</span>
<span class="comment-copy">Added, thank you</span>
<span class="comment-copy">using <code>struct</code> in this case might be problematic since your data number is not 4-bit integer. Struct operates on full bytes only.</span>
<span class="comment-copy">For hard-coded data, you can do stuff like <code>(0x7AAAAAAA&lt;&lt;1) | flag</code>. But in any case, you should use <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer"><code>struct</code></a> to handle the conversion to bytes in an endian-aware way.</span>
<span class="comment-copy">Bit-fiddling in Python can be a little tricky because we don't have unsigned integers, and our integers are not of a fixed byte length. However, that's really not a problem with careful use of <code>struct</code>.</span>
<span class="comment-copy">or similarly <code>packet = (a &lt;&lt; 1) | f</code> if you want the flag at the end</span>
<span class="comment-copy">This would work, I could use <code>binascii</code> to encode the binary data. However, If data was just <code>FF</code> the binary representation would not be big enough, Maybe a way to pad data to always use a 31-bit binary representation?</span>
<span class="comment-copy">you can use <code>int.to_bytes(final_number, 4, 'big')</code> in order to use big-endian, and extend to 4 bytes</span>
