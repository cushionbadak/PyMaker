<div class="post-text" itemprop="text">
<p>Can anyone tell me how does Python interpreter or PVM manage memories for the following code?</p>
<pre><code>class A(object):
    class_purpose = "template"
    def __init__(self):
        self.a = 0.0
        self.b = 0.0

    def getParams(self):
        return self.a, self.b

    @classmethod
    def getPurpose(cls):
        return cls.class_purpose

    @staticmethod
    def printout():
        print "This is class A"
</code></pre>
<p>When I save this class and run some codes related to this class, how does PVM or Python interpreter store class variables, class/static functions and instance variables? I used to be a C++ programmer. I wonder where those "things" are stored (I know Python only uses Heap)? When are they stored, RunTime or before RunTime?</p>
<p>For example, I run this code after initing this class:</p>
<pre><code>a = A()
a.getParams()
A.getPurpose()
A.printout()
</code></pre>
<p>How does Python interpreter allocate memory behind this code? </p>
</div>
<div class="post-text" itemprop="text">
<p>Everything in your example is simply an object. All objects go on the heap. </p>
<p>The class object is created at runtime and has a mapping from attribute name to objects, where all names you defined in the class body are simply attributes. The majority of those objects implement the <a href="https://docs.python.org/2/howto/descriptor.html" rel="nofollow">descriptor protocol</a> (the exception being the <code>class_purpose</code> attribute). The function objects that form the majority of the attributes are also created at runtime; all the compiler produces are code objects which store bytecode, some constants (anything immutable created by the code, including more code objects for nested scopes).</p>
<p>See the <a href="https://docs.python.org/2/reference/datamodel.html" rel="nofollow"><em>datamodel</em> reference documentation</a> for more details on how these objects relate to one another.</p>
<p>The vast majority of Python developers don't have to worry about memory management. If you develop against the <a href="https://docs.python.org/2/c-api/" rel="nofollow">Python C API</a>, you may want to read up on the <a href="https://docs.python.org/2/c-api/memory.html" rel="nofollow"><em>Memory Management</em> section</a>, which does state:</p>
<blockquote>
<p>It is important to understand that the management of the Python heap is performed by the interpreter itself and that the user has no control over it, even if she regularly manipulates object pointers to memory blocks inside that heap. The allocation of heap space for Python objects and other internal buffers is performed on demand by the Python memory manager through the Python/C API functions listed in this document.</p>
</blockquote>
</div>
<span class="comment-copy">CPython tends to only use the heap (maybe exclusively), but this is not a language spec requirement.  You should not assume it (nor should it matter).</span>
<span class="comment-copy">Since you’re coming from C++ and can read C, you might want to look at the Python source to get an idea on how things work. For example <a href="https://github.com/python/cpython/blob/master/Python/ceval.c" rel="nofollow noreferrer">the byte code interpreter</a>.</span>
<span class="comment-copy">@poke Thanks. This is a good suggestion. I will read the CPython code to understand more. Since it is not very easy to understand CPython, it takes a while to grab the core. Do you have any book recommendation regarding explanation on CPython?</span>
<span class="comment-copy">Not really, since CPython is all “implementation detail”, there is not really a good documentation of it other than the source itself. It might help to read something about the <a href="https://docs.python.org/3/c-api/index.html" rel="nofollow noreferrer">C API</a> first since that gives a higher-level view on some of the internals.</span>
