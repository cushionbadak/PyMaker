<div class="post-text" itemprop="text">
<p>I'm converting some Matlab code in Python. I need to do some matrix manipulation. My matrix (A) is (right now) a 65x3 matrix. However, the number of rows is variable depending on what step I'm at in the program.</p>
<p>In Matlab, the code I'm working on is:</p>
<pre><code>output = inv(A'*A) * A';
</code></pre>
<p>The following Python code reproduces the expected output just fine. I'm just curious if there is a better (more Pythonic, faster, etc) way to do this? I'm trying to stick only to basic Python and numpy.</p>
<pre><code>output = np.dot(np.linalg.inv(np.dot(np.transpose(A), A)), np.transpose(A))
</code></pre>
<p>Thanks to anyone who is willing to help.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a the <code>T</code> attribute (transposes the array). Also, if using Python 3.5, you can use <code>@</code> for the dot product (see <a href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-465" rel="nofollow">PEP 465</a> for details).</p>
<pre><code>output = np.linalg.inv(A.T @ A) @ A.T
</code></pre>
</div>
<span class="comment-copy">apart from using the shortcut <code>A.T</code> for transpose, you can't do much better. (but this really is just eye sugar, won't make any actual difference)</span>
<span class="comment-copy">It looks like you are computing the psuedo-inverse of the matrix <code>A</code>.  Unless your application specifically needs to compute the psuedo-inverse, if you can avoid computing the inverse, then don't do it.  This article by John D. Cook should provide insight: <a href="http://www.johndcook.com/blog/2010/01/19/dont-invert-that-matrix/" rel="nofollow noreferrer">johndcook.com/blog/2010/01/19/dont-invert-that-matrix</a>.  If you are trying to find the least-squares solution to an overdetermined (or underdetermined) system of equations, use the <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html" rel="nofollow noreferrer"><code>numpy.linalg.lstsq</code></a> method to compute your solution directly.</span>
<span class="comment-copy">Thanks. That was perfect. I knew there had to be a better way of writing it.</span>
<span class="comment-copy">You are welcome :)</span>
<span class="comment-copy">Note that if you are using <code>inv</code> a lot, you can do <code>from numpy.linalg import inv</code> at the beginning of your file, and then just do <code>output = inv(A.T @ A) @ A.T</code>.  Also note that this will not behave the same as the MATLAB version when working with complex numbers, in that case the MATLAB transpose is not a simple array transpose, it also takes the conjugate of the elements.</span>
