<div class="post-text" itemprop="text">
<p>I have a class that has instances of other classes as it's properties:</p>
<pre><code>from ctypes import *
class C():
    A = propA()
    B = propB()

    def __init__(self):
        class c_struct(Structure):
            _fields_ = [('_A', c_int), ('_B', c_int)]

        self._c_struct = c_struct()
</code></pre>
<p>What I need to do, is somehow "connect" the <code>propA</code> and <code>propB</code> classes to the internal structure <code>_c_struct</code> created in <code>C</code> to eventually get the behavior like so:</p>
<pre><code>c = C()

c.A.val = 12
c.B.val = 13

c._c_struct._A == c.A.val == 12
</code></pre>
<p>Where <code>C.A</code> is able to manipulate <code>C._c_struct._A</code>.  I've attempted to do something like this:</p>
<pre><code>from ctypes import *

class propParent():
    def set_ref(self, ext_ref):
        self._val = ext_ref

    @property
    def val(self):
        return self._val

    @val.setter
    def val(self, val):
        self._val = val

class propA(propParent):
    # further definition here
    pass

class propB(propParent):
    # further definition here
    pass

class C():
    A = propA()
    B = propB()

    def __init__(self):
        class c_struct(Structure):
            _fields_ = [('_A', c_int), ('_B', c_int)]

        self._c_struct = c_struct()

        self.A.set_ref(self._c_struct._A)
        self.B.set_ref(self._c_struct._B)
</code></pre>
<p>but it appears that <code>self._c_struct._A</code> returns a python integer object and not the reference to the <code>_A</code> internal c_int object of the structure.  How do I connect a property to a sub property of another property in the same class?</p>
</div>
<div class="post-text" itemprop="text">
<p>This'd seem like a fit for a <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor</a>, which the <a href="https://docs.python.org/3/library/ctypes.html#structures-and-unions" rel="nofollow noreferrer">field <code>c_struct._A</code> is also</a>:</p>
<pre><code>In [3]: c_struct._A
Out[3]: &lt;Field type=c_int, ofs=0, size=4&gt;

In [4]: c_struct._A.__get__
Out[4]: &lt;method-wrapper '__get__' of _ctypes.CField object at 0x7f967303cf48&gt;
</code></pre>
<p>which is why it returns an <code>int</code> when accessed through a <code>c_struct</code> instance instead of the field itself. Start by defining one suitable for your use case:</p>
<pre><code>class prop:

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return 'prop({!r})'.format(self.name)

    def __get__(self, instance, owner):
        if not instance:
            return self

        return getattr(instance._c_struct, '_{}'.format(self.name))

    def __set__(self, instance, value):
        setattr(instance._c_struct, '_{}'.format(self.name), value)
</code></pre>
<p>or just</p>
<pre><code>def prop(name):
    name = '_{}'.format(name)
    return property(
        lambda self: getattr(self._c_struct, name),
        lambda self, value: setattr(self._c_struct, name, value))
</code></pre>
<p>Then define your original class:</p>
<pre><code>class C:

    A = prop('A')
    B = prop('B')

    def __init__(self):
        class c_struct(Structure):
            _fields_ = [('_A', c_int), ('_B', c_int)]

        self._c_struct = c_struct()
</code></pre>
<p>Test:</p>
<pre><code>In [36]: c = C()

In [37]: c.A
Out[37]: 0

In [38]: c._c_struct._A
Out[38]: 0

In [39]: c.A = 12

In [40]: c._c_struct._A
Out[40]: 12
</code></pre>
<p>For extra credit and if you're using a recent enough version of Python you can use <a href="https://docs.python.org/3/reference/datamodel.html#object.__set_name__" rel="nofollow noreferrer"><code>object.__set_name__()</code></a> to remove the need to duplicate the name, without having to resort to a meta class:</p>
<pre><code>class prop:

    def __init__(self, name=None):
        self.name = name

    def __set_name__(self, owner, name):
        if self.name is None:
            self.name = name

    ...
</code></pre>
<p>and then define C as:</p>
<pre><code>class C:

    A = prop()
    B = prop()

    ...
</code></pre>
</div>
<span class="comment-copy">Would it be feasible to create a class with a single field? That would naturally pass the class by reference.</span>
<span class="comment-copy">I'm not sure if I follow?  My problem is coming from the fact that <code>self._c_struct._A</code> doesn't appear to be returning a reference when making the assignment.</span>
<span class="comment-copy">is the <code>__set__</code> and <code>__get__</code> Python 3 specific?</span>
<span class="comment-copy">No, they've been around.</span>
<span class="comment-copy">Just to add to previous: you have to use <a href="https://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python">new-style classes</a> in Python 2 for descriptors to work properly.</span>
