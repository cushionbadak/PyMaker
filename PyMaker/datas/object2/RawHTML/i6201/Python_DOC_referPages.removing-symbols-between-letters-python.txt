<div class="post-text" itemprop="text">
<p>I would like to remove certain symbols from a string. I only want to remove symbols that are between letters. If my question wasn't clear enough then here are some examples:
<strong>symbols are <code>@31!</code></strong></p>
<p><strong>Input</strong></p>
<pre><code>@@He11o Wor1d!
!!T3ach !m3
@13!
</code></pre>
<p><strong>Expected Output</strong></p>
<pre><code>@@Heo Word!
!!Tach !m3
@13!
</code></pre>
<p>Can you point me in the right direction? I'm not expecting you to do it for me. I know this can be done with regex and with for loops but regex seems a bit difficult for a beginner like myself. Here's what I'm working on right now: </p>
<pre><code>string = '@@He11o Wor1d!'
string_copy = string
symbols = "@31!"
for char in symbols:
    string_copy = string_copy.replace(char, "")
</code></pre>
<p>I'm aware that this script replaces all symbols</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">Regular expressions</a> are definitely scary at first, but it's worth trying to learn them, as they end up being very useful. What you want in this case is:</p>
<pre><code>import re
string = re.sub(r'([a-zA-Z])[@31!]+(?=[a-zA-Z])', r'\1', string)
</code></pre>
<p><a href="https://regex101.com/r/SMgOmr/2" rel="nofollow noreferrer">Let's look at what this does.</a></p>
<p><a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a> is similar to <code>str.replace</code>, but it uses regular expressions.</p>
<p><code>[a-zA-Z]</code> matches any letter.</p>
<p><code>[@31!]+</code> matches one or more of the listed symbols.</p>
<blockquote>
<p>+
  causes the resulting RE to match 1 or more repetitions of the preceding RE.</p>
</blockquote>
<p><code>(?=[a-zA-Z])</code> is a lookahead assertion for a letter. This means that the match is followed by a letter, but the letter is not part of the match.</p>
<blockquote>
<p>(?=...)
  matches if ... matches next, but doesn’t consume any of the string. This is called a lookahead assertion. For example, Isaac (?=Asimov) will match 'Isaac ' only if it’s followed by 'Asimov'.</p>
</blockquote>
<p>So <code>([a-zA-Z])[@31!]+(?=[a-zA-Z])</code> matches a letter followed by one or more symbols from the list. This match is followed by a letter, but the match does not include the letter.</p>
<p><code>\1</code> is a back-reference to the parenthesized group in the regular expression, in this case <code>[a-zA-Z]</code>. That's what we want to replace what we found with.</p>
<p>(the <code>r</code>s before the strings are to make them raw strings, which often helps when using regular expressions.)</p>
<p><strong>Edit:</strong></p>
<p>As @ctwheels pointed out, <a href="https://regex101.com/r/SMgOmr/1" rel="nofollow noreferrer">you can also use a lookbehind assertion rather than a backreference</a>:</p>
<pre><code>string = re.sub(r'(?&lt;=[a-zA-Z])[@31!]+(?=[a-zA-Z])', r'', string)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is tricky to do correctly. Although I generally prefer to avoid regex unless they're necessary, this is definitely a case where they make the job a <em>lot</em> easier. But anyway, here's a non-regex solution. </p>
<p>We use the standard <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> function to break the input string up into three kinds of groups: 'A' groups contain letters, 'S' groups contain the special symbols, 'O' groups contain anything else. Then we scan over the groups, copying them to the <code>result</code> list unless the group is an 'S' group and it has an 'A' group immediately before it and immediately following it. Finally, we join the copied groups back into a single string.</p>
<p>In order to make it easier to check the following group, we add a "fake" group of <code>('O', '')</code> to the end of the list of groups. That way every real group has a following group.</p>
<pre><code>from itertools import groupby

symbols = '@31!'

def keyfunc(c):
    if c in symbols:
        return 'S'
    elif c.isalpha():
        return 'A'
    else:
        return 'O'

def remove_symbols(s):
    groups = [(k, ''.join(g)) for k, g in groupby(s, keyfunc)] + [('O', '')]
    result = []
    prev = 'O'
    for i, (k, g) in enumerate(groups[:-1]):
        # If a group of symbols has an alpha group on both sides, don't copy it
        if not (k == 'S' and prev == 'A' and groups[i+1][0] == 'A'):
            result.append(g)
        prev = k
    return ''.join(result)

# Test

data = '''\
@@He11o Wor1d!
!!T3ach !m3
@13!
lala@@@@ 
'''

expected = '''\
@@Heo Word!
!!Tach !m3
@13!
lala@@@@
'''
print('Data')
print(data)

print('Expected')
print(expected)

print('Output')
for s in data.splitlines():
    print(remove_symbols(s))   
</code></pre>
<p><strong>output</strong></p>
<pre><code>Data
@@He11o Wor1d!
!!T3ach !m3
@13!
lala@@@@ 

Expected
@@Heo Word!
!!Tach !m3
@13!
lala@@@@

Output
@@Heo Word!
!!Tach !m3
@13!
lala@@@@ 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Code</h2>
<p><a href="https://regex101.com/r/H156UK/2" rel="nofollow noreferrer">See this regex in use here</a></p>
<pre><code>(?&lt;=[a-z])[@13!]+(?=[a-z])
</code></pre>
<hr/>
<h2>Results</h2>
<h3>Input</h3>
<pre><code>@@He11o Wor1d!
!!T3ach !m3
@13!
</code></pre>
<h3>Output</h3>
<pre><code>@@Heo Word!
!!Tach !m3
@13!
</code></pre>
<hr/>
<h2>Explanation</h2>
<ul>
<li><code>(?&lt;=[a-z])</code> Positive lookbehind ensuring what precedes is a letter between <code>a</code> and <code>z</code></li>
<li><code>[@13!]+</code> Match one or more characters present in the set <code>@13!</code></li>
<li><code>(?=[a-z])</code> Positive lookahead ensuring what follows is a letter between <code>a</code> and <code>z</code></li>
</ul>
<p>Using <code>i</code> flag makes the pattern case-insensitive, thus <code>a-z</code> also matches <code>A-Z</code></p>
<hr/>
<h2>Usage</h2>
<pre><code>import re
regex = r"(?&lt;=[a-z])[@13!]+(?=[a-z])"
result = re.sub(regex, "", string, 0, re.IGNORECASE)
# re.IGNORECASE can be replaced with the shortened re.I
</code></pre>
<p><strong>or</strong> (flag in the regex as opposed to passed to the function)</p>
<pre><code>import re
regex = r"(?i)(?&lt;=[a-z])[@13!]+(?=[a-z])"
result = re.sub(regex, "", string)
</code></pre>
</div>
<span class="comment-copy">whats your input and whats your output? write it plz</span>
<span class="comment-copy">why do you not add a check to it then that makes sure they follow and are followed by a letter? Not that this would be the best way to do it, but for you the <i>obvious</i></span>
<span class="comment-copy">I'd still recommend regular expressions in conjunction with <code>str.replace()</code>.</span>
<span class="comment-copy">@DRPK This is what the first three lines are. On the left the input and after the <code>=</code> sign the desired output</span>
<span class="comment-copy">Out of curiosity what's with the downvotes? Please explain</span>
<span class="comment-copy">You could add a link to regex101</span>
<span class="comment-copy">Thank you very much, this information is also very useful</span>
<span class="comment-copy">@AnttiHaapala added links</span>
<span class="comment-copy">I have to admit that this seems a bit tricky, but if it works it works! :) I will try and work through this and see if I can make myself understand everything. Thank you</span>
<span class="comment-copy">@Innit2 My pleasure. I freely admit that this is fairly advanced code, but it <i>is</i> a tricky problem to solve correctly. I could write a solution that doesn't use <code>groupby</code>, but it would be much longer and (IMHO) harder to follow. <code>groupby</code> and <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> are a bit scary at first, but they're so useful that it's definitely worth playing with &amp; getting comfortable with them. And there's less of a learning curve than with regex. :D</span>
<span class="comment-copy">This is the best answer to show that you <i>don't</i> do these without regular expressions. It just gets too complicated.</span>
<span class="comment-copy">@Innit2 So in the end it is easier to just learn to read the regular expression syntax - it can still be easier to see in a glimpse what it does - this one on the other hand, is very hard to understand at first even to a very seasoned Python developer.</span>
<span class="comment-copy">Thanks for the advice!</span>
<span class="comment-copy">btw your link is to a different version of the regex, intentional?</span>
<span class="comment-copy">You can also add the <code>i</code> in flags</span>
<span class="comment-copy">@AnttiHaapala the second version of the link defaults to python.</span>
<span class="comment-copy">@AnttiHaapala I've added a new section under usage. Is this what you're referring to? I've also added a comment under the first usage.</span>
