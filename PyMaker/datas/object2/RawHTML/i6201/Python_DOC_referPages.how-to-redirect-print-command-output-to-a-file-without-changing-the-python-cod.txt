<div class="post-text" itemprop="text">
<p>I want to redirect all the output of my django (1.10.4) app to a file</p>
<p>Firstly, I tried:</p>
<pre><code>python manage.py runserver 0.0.0.0:8000 &gt;test.log 2&gt;&amp;1
</code></pre>
<p>But it doesn't redirect the output of the print command.</p>
<p>For example, in my code there is a statement:</p>
<pre><code>print ('query_content:')
</code></pre>
<p>using command:</p>
<pre><code>python manage.py runserver 0.0.0.0:8000
</code></pre>
<p>I can see that 'query_content:' is printed out on the screen.</p>
<p>But with :</p>
<pre><code>python manage.py runserver 0.0.0.0:8000 &gt;test.log 2&gt;&amp;1
</code></pre>
<p>In the test.log, there are only something like this:</p>
<pre><code>[05/Nov/2017 20:38:20] "GET ... HTTP/1.1" 200 22404
[05/Nov/2017 20:38:26] "POST ... HTTP/1.1" 200 13
[05/Nov/2017 20:38:26] "GET .... HTTP/1.1" 200 16800
[05/Nov/2017 20:38:30] "GET ... 200 22430
...
</code></pre>
<p>One solution is:</p>
<pre><code>import sys
sys.stdout = open('file', 'w')
print 'test'
</code></pre>
<p>But sometimes it is impossible to change the python code, is there any solution?</p>
<p><strong>update:</strong></p>
<p>I found that if the log file already exists, then everything is fine.
But if I specify a new file name, then the output of python "print ..." statement cannot save the log file.</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe that <code>&gt;</code> writes to the file <code>test.log</code> whatever gets logged to console from Django. <br/>
<code>print('query_content:')</code> is not getting logged, therefore is not part of Django output.</p>
<p>You need to create a logger for your application:</p>
<ol>
<li><p>In <code>settings.py</code> add:</p>
<pre><code>LOGGING = {
    'version': 1,
    'disable_existing_loggers': True,
    'formatters': {
    'standard': {
        'format' : "[%(asctime)s] %(levelname)s [%(name)s:%(lineno)s] %(message)s",
        'datefmt' : "%d/%b/%Y %H:%M:%S"
    },
},
'handlers': {
    # This logs to the console
    'console':{
        'level':'INFO',
        'class':'logging.StreamHandler',
        'formatter': 'standard'
    },
},
'loggers': {
    'django': {
        'handlers':['console'],
        'propagate': True,
        'level':'INFO',
     },
},
</code></pre></li>
<li><p>Add the following were you want to log something:</p>
<pre><code>import logging
mylogger = logging.getLogger(__name__)


...
logger.info('query content: {}'.format(your_query_content))
...
</code></pre></li>
</ol>
<hr/>
<p>Although the above solves your immediate problem, you can take it a step further:<br/></p>
<p>Add a file handler in your <code>LOGGER</code> configuration:</p>
<ol>
<li><p>On handlers add:</p>
<pre><code>'file': {  
    'class': 'logging.FileHandler',
    'filename': 'a/file/location/logs.log',  
    'formatter': 'standard'
},
</code></pre></li>
<li><p>On <code>loggers.django</code> update the handlers:</p>
<pre><code>'handlers':['console', 'file'], 
</code></pre></li>
</ol>
<hr/>
<p>You can customize the above even further, but that is another subject:</p>
<p>More info on python and django logging:</p>
<ol>
<li><a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer">https://docs.python.org/3/library/logging.html</a></li>
<li><a href="https://docs.djangoproject.com/en/2.0/topics/logging/" rel="nofollow noreferrer">https://docs.djangoproject.com/en/2.0/topics/logging/</a></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>I think this shell command maybe can output the result.</p>
<pre><code>python manage.py runserver 0.0.0.0:8000 2&gt;&amp;1 | tee file.txt
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>TL;DR: if you have a loop in the end of a file you are feeding to <code>manage.py shell</code> add two newlines in the end.</p>
<p>In my case the reason <code>print</code>s were not present in the stdout was because they were never really executed in the first place. They were in a <code>for</code> loop that was at the end of file without <strong>two</strong> newlines or a newline and any other line (with a comment) after it. This way the shell was left waiting for a <code>for</code> loop code to be finished and it never was.</p>
</div>
<span class="comment-copy">Relevant: <a href="https://askubuntu.com/questions/420981/how-do-i-save-terminal-output-to-a-file" title="how do i save terminal output to a file">askubuntu.com/questions/420981/â€¦</a></span>
<span class="comment-copy">It's possible that the expected output is actually being correctly output, but it is buffered, so might not appear where you expect, if it is mixed with stderr output. Consider using the "-u" option to python when you start the server (that can affect performance)</span>
<span class="comment-copy">Can't reproduce. Works fine in my Django 1.10.</span>
<span class="comment-copy">@JohnAnderson It seems that the issue is related to cache.</span>
<span class="comment-copy">There is no way, you can not interfere with a process except the source code. You can do this by listening to the 8000 port of your local loopback address (raw socket).</span>
<span class="comment-copy">Looks like you are right, thank you! I'll try your suggestion tomorrow</span>
<span class="comment-copy">@int_ua Let me know the outcome. I would suggest using the file logging method!</span>
<span class="comment-copy">TL;DR: you are getting the bounty. In the process I found the real reason of my problem and I'll post it as a separate answer. Also, I don't have time to really test this suggestion, but it's definitely interesting, so I'm awarding the bounty. Real testing is up to you or any future readers.</span>
<span class="comment-copy">@int_ua Ok mate! Happy coding, looking forward to your answer!</span>
<span class="comment-copy"><b>Query not an output !</b></span>
