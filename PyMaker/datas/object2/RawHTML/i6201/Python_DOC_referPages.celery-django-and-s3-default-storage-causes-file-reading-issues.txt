<div class="post-text" itemprop="text">
<p>I have a process whereby a web server injects a file (via an upload), saves that file to S3 using default_storages, then creates a task for that file to be processed by the backend via celery.</p>
<pre><code>def upload_file(request):
  path = 'uploads/my_file.csv'
  with default_storage.open(path, 'w') as file:
    file.write(request.FILES['upload'].read().decode('utf-8-sig'))
  process_upload.delay(path)
  return HttpResponse()

@shared_task
def process_upload(path):
  with default_storage.open(path, 'r') as file:
    dialect = csv.Sniffer().sniff(file.read(1024]))
    file.seek(0)
    reader = csv.DictReader(content, dialect=dialect)
    for row in reader:
      # etc...
</code></pre>
<p>The problem is that, although I'm using text-mode explicitly on writing and read, when I read the file it comes through as <code>bytes</code>, which the csv library cannot handle. Is there any way around this without reading in and decoding the whole file in memory?</p>
</div>
<div class="post-text" itemprop="text">
<p>Seems like you need to add the <code>b</code> (binary mode) to the <code>open</code> call:</p>
<p>From the <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p><code>'b'</code> appended to the mode opens the file in <strong>binary mode</strong>: now the data is read and written in the form of bytes objects. <strong>This mode should be used for all files that donâ€™t contain text</strong>.</p>
</blockquote>
<pre><code>@shared_task
def process_upload(path):
  with default_storage.open(path, 'rb') as file:
      # Rest of your code goes here.
</code></pre>
</div>
