<div class="post-text" itemprop="text">
<p>I'm writing some code that trims down a words in a list of string. if the last character of a word in the string is 't' or 's' it is removed and if the first character is 'x' it is removed.</p>
<pre><code>words = ['bees', 'xerez']
</code></pre>
<p>should return:</p>
<pre><code>['bee', 'erez']
</code></pre>
<p>So far my solution is:</p>
<pre><code>trim_last = [x[:-1] for x in words if x[-1] == 's' or 't']   
</code></pre>
<p>I think this trims the last characters fine. I then to trim the first characters if they are 'x' with this line:  </p>
<pre><code>trim_first = [x[1:] for x in trim_last if x[0] == 'x'] 
</code></pre>
<p>but this just returns an empty list, can i some how incorporate this into one working line?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>[v.lstrip('x').rstrip('ts') for v in words]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You're doing a filter, not a mapping.
The right way would be</p>
<pre><code>trim_first = [x[1:] if x.startswith('x')  else x for x in trim_last]
</code></pre>
<p>Also, your solution should not return an empty list since the filter would match on the second element</p>
</div>
<div class="post-text" itemprop="text">
<p>In one step with <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><strong><code>re.sub()</code></strong></a> function:</p>
<pre><code>import re

words = ['bees', 'xerez']
result = [re.sub(r'^x|[ts]$', '', w) for w in words]

print(result)
</code></pre>
<p>The output:</p>
<pre><code>['bee', 'erez']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just to chime in - since this is in fact, a mapping:</p>
<pre><code>map(lambda x: x[1:] if x[0] == 'x'  else x, words)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are looking for a one-liner you can use some arithmetic to play with the list slicing:</p>
<pre><code>words = ['bees', 'xerez', 'xeret']
[w[w[0] == 'x' : len(w) - int(w[-1] in 'st')] for w in words]
# output: ['bee', 'erez', 'ere']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this code:</p>
<pre><code>trim_last = [x.lstrip('x').rstrip('t').rstrip('s') for x in words]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why you are using two list comprehension for that you can do with one list comprehension :</p>
<blockquote>
<p>one line solution:</p>
</blockquote>
<pre><code>words = ['bees', 'xerez','hellot','xnewt']

print([item[:-1] if item.endswith('t') or item.endswith('s') else item for item in [item[1:] if item.startswith('x') else item for item in words]])
</code></pre>
<p>output:</p>
<pre><code>['bee', 'erez', 'hello', 'new']
</code></pre>
<blockquote>
<p>Explanation of above list comprehension :</p>
</blockquote>
<pre><code>final=[]
for item in words:
    sub_list=[]
    if item.endswith('t') or item.endswith('s'):
        sub_list.append(item[:-1])
    else:
        sub_list.append(item)
    for item in sub_list:
        if item.startswith('x'):
            final.append(item[1:])
        else:
            final.append(item)

print(final)
</code></pre>
</div>
<span class="comment-copy">First of all <code>if x[-1] == 's' or 't'</code> is not doint what you want it to do.</span>
<span class="comment-copy">Just add <code>else</code> statement in your list comprehension.</span>
<span class="comment-copy">Forgot about those, nice.</span>
<span class="comment-copy">nice one ++ ...</span>
<span class="comment-copy">I'd use <code>x.startswith</code> instead of string slicing :)</span>
<span class="comment-copy">copy paste ftl, i'll edit now, thanks</span>
<span class="comment-copy">@Coal_  Why? Is it faster?</span>
<span class="comment-copy">faster no, but it's more readable and IMO that matters more</span>
<span class="comment-copy">It's less error prone, more pythonic and easier to scale up.</span>
<span class="comment-copy">Not sure if the reduction to a one-liner is worth the loss of readability, but this is a neat trick.</span>
<span class="comment-copy">@asongtoruin I know, there are other more readable solutions, but OP explicitly wanted "one working line", so there you have it :)</span>
