<div class="post-text" itemprop="text">
<p>I am trying to read a row in a csv, which I have previously written. 
That written row looks like this when is read: <code>['New York', '(30,40)']</code> 
and like this: <code>['New York', '(30,40)']</code> (converts the tuple in a string).</p>
<p>I need to read each item from the tuple to operate with the ints, but I can't if it is read like a string because if I do something like this: <code>tuple[0]</code>, what I get is: <code>'('</code> -the first character of the string tuple-</p>
<p>Maybe this is a question about how I write and read the rows, which actually is this way:</p>
<pre><code>def writeCSV(data,name):
  fileName = name+'.csv'
  with open(fileName, 'a') as csvfile:
     writer = csv.writer(csvfile, delimiter=',')
     writer.writerow(data)

 def readCSV(filename):
    allRows = []
    with open(filename, 'rb') as f:
       reader = csv.reader(f, delimiter=' ')
       for row in reader:
          allRows.append(row)
 return allRows 
</code></pre>
<p>What I want is <strong>to read that tuple for row, not like a string, but like a tuple to operate</strong> with each item after.
Is it possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval()</code></a> on you tuple string as:</p>
<pre><code>&gt;&gt;&gt; my_file_line =  ['New York', '(30,40)']
&gt;&gt;&gt; import ast
&gt;&gt;&gt; my_tuple = ast.literal_eval(my_file_line[1])
&gt;&gt;&gt; my_tuple[0]
30
</code></pre>
<p>Because currently the list you got after reading the file at index 1 is holding the valid string of the tuple format. <code>ast.literal_eval</code> will convert your tuple string to the <code>tuple</code> object and then you can access the tuple based on the index.</p>
</div>
<div class="post-text" itemprop="text">
<p>since you're producing the file yourself, why not making it right from the start:</p>
<pre><code>import csv

data = ['New York', (30,40)]
with open("out.csv","w",newline="") as f:
    cw=csv.writer(f)
    cw.writerow(data)    # wrong
    cw.writerow(data[:1]+list(data[1]))  # okay
</code></pre>
<p>the first line writes each item of <code>data</code> but tries to convert each item as <code>str</code>. <code>tuple</code> gets converted, where selecting another format could avoid this.</p>
<pre><code>New York,"(30, 40)"
</code></pre>
<p>which explains the need to evaluate it afterwards.</p>
<p>The second write line writes 3 elements (now 3 columns), but preserves the data (except for the <code>int</code> part which is converted to <code>str</code> anyway)</p>
<pre><code>New York,30,40
</code></pre>
<p>in that case, a simple string to integer conversion on rows does the job.</p>
<p>Note that <code>csv</code> isn't the best way to serialize mixed data. Better use <code>json</code> for that.</p>
</div>
<span class="comment-copy">Use <code>ast.literal_eval</code> and parse the string to a tuple.</span>
<span class="comment-copy">don't write a tuple in a csv row for starters. write each value on 1 row</span>
<span class="comment-copy">That's work! This is what I need, but i take note from @Jean-Fran√ßoisFabre to improve the writing method. Thank you so much.</span>
