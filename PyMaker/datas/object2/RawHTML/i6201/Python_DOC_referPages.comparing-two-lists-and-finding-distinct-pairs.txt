<div class="post-text" itemprop="text">
<p>I am trying to compare two lists ( which contain different sizes of sublists) and finding pair (enclosed in round bracket) that's not present in the other list. </p>
<p>Here is the code:</p>
<pre><code>s1 = [
    [('RESOLVED - DUPLICATE', 'VERIFIED')], [('NEW', 'RESOLVED - FIXED'), ('RESOLVED - FIXED', 'VERIFIED')], [('NEW', 'RESOLVED - DUPLICATE'), ('RESOLVED - DUPLICATE', 'VERIFIED')], [('ASSIGNED', 'RESOLVED - FIXED'), ('RESOLVED - FIXED', 'VERIFIED')], [('NEW', 'RESOLVED - WONTFIX'), ('RESOLVED - WONTFIX', 'VERIFIED')], [('NEW', 'RESOLVED - INVALID'), ('RESOLVED - INVALID', 'VERIFIED')]
]

s2 = [
    [('RESOLVED - DUPLICATE', 'VERIFIED')], [('NEW', 'RESOLVED - DUPLICATE'), ('RESOLVED - DUPLICATE', 'VERIFIED')], [('NEW', 'ASSIGNED'), ('ASSIGNED', 'RESOLVED - FIXED')], [('ASSIGNED', 'RESOLVED - FIXED'), ('RESOLVED - FIXED', 'VERIFIED')], [('NEW', 'RESOLVED - WONTFIX'), ('RESOLVED - WONTFIX', 'VERIFIED')]
]

a = []

for item in s2:
    i = 0
    print item
    while (i &lt; len(item)):
        for item1 in s1:
        print item[i]
        if item[i] not in s1:
            a.append(item[i])
        i = i + 1

print a
</code></pre>
<p>The above-mentioned code is not giving distinct pair that is present in s2 but not in s1.<br/>
Any help would be much appreciated. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Flatten your lists into <code>set</code> objects and the set-operations they impelement, in this case, you want the <em>difference</em> between <code>s2</code> and <code>s1</code>, </p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; set(chain.from_iterable(s2)).difference(chain.from_iterable(s1))
{('NEW', 'ASSIGNED')}
</code></pre>
<p>Note, you <em>may</em> actually want the <a href="https://en.wikipedia.org/wiki/Symmetric_difference" rel="nofollow noreferrer"><em>symmetric difference</em></a> between the two, i.e. the items that are not in both:</p>
<pre><code>&gt;&gt;&gt; set(chain.from_iterable(s1)).symmetric_difference(chain.from_iterable(s2))
{('NEW', 'RESOLVED - FIXED'), ('NEW', 'RESOLVED - INVALID'), ('NEW', 'ASSIGNED'), ('RESOLVED - INVALID', 'VERIFIED')}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming the nested structure is not relevant and the lists can be flattened:</p>
<pre><code>s1flat = [x for sublist in s1 for x in sublist]
s2flat = [x for sublist in s2 for x in sublist]

new_pair = list(set(s2flat) - set(s1flat))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if you are finding items of s2 which are not present in s1 then use simply:</p>
<blockquote>
<p>One line</p>
</blockquote>
<pre><code>print([item for item in s2 if item not in s1])
</code></pre>
<blockquote>
<p>detailed:</p>
</blockquote>
<p>That list comprehension is same as :</p>
<pre><code>new_list=[]
for i in s2:
    if i not in s1:
        new_list.append(i)
print(new_list)
</code></pre>
<p>output:</p>
<pre><code>[[('NEW', 'ASSIGNED'), ('ASSIGNED', 'RESOLVED - FIXED')]]
</code></pre>
</div>
<span class="comment-copy">Just to let you know: enclosing them with round brackets makes them tuples. Do you want to create a list of tuples or a list of lists?</span>
<span class="comment-copy">So what is the expected output of this example?</span>
<span class="comment-copy">Thanks for the solution. Is there any way of finding same pair using same way. I tried to look for equal or same function but didn't find it</span>
<span class="comment-copy">@user2293224 yes, you mean the intersection. Like I mentioned, <code>set</code> objects implement set operations, i.e. intersection, union, difference, symmetric difference, ordering is on the subset relation. Check out <a href="https://stackoverflow.com/questions/46680450/how-to-return-sum-of-matching-elements-in-two-separate-sets/46680537#46680537">this answer to a similar question</a></span>
<span class="comment-copy">@user2293224 here is some info in the <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">docs</a></span>
<span class="comment-copy">if you are going to do this, might as well use set-comprehensions: <code>{x for sub in s1 for x in sub}</code></span>
