<div class="post-text" itemprop="text">
<p>I have the following program: </p>
<pre><code>random_pool=[[[0, 2, 3, 1, 3, 2, 0, 1], [0, 1], [1], [0]],
 [[0, 3, 2, 1, 2, 3, 0, 1], [0, 3], [3], [1]],
 [[1, 2, 3, 0, 3, 2, 1, 0], [2, 2], [4], [2]],
 [[2, 1, 3, 0, 3, 1, 2, 0], [2, 1], [3], [3]]]

binary_list=[[0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1],
 [0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1],
 [0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0],
 [1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0]]

def GeneratePopulation(random_pool, binary_list):
    individual = []
    population = []
    for gene in range(0, len(binary_list)):
        gene=binary_list[gene]
        for game in range (0, len(random_pool)):
            fitness=random_pool[game][2]
            counter=random_pool[game][3]
            individual=[gene,fitness,counter]
            population.append(individual)
    return(population)
</code></pre>
<p>With the output: </p>
<pre><code>[[[0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [1], [0]],
 [[0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [3], [1]],
 [[0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [4], [2]],
 [[0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [3], [3]],
 [[0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1], [1], [0]],
 [[0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1], [3], [1]],
 [[0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1], [4], [2]],
 [[0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1], [3], [3]],
 [[0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1], [0]],
 [[0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [3], [1]],
 [[0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [4], [2]],
 [[0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [3], [3]],
 [[1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [1], [0]],
 [[1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [3], [1]],
 [[1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [4], [2]],
 [[1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [3], [3]]] 
</code></pre>
<p>My objective is to combine the elements gene (binary vector), from the binary_list with the last two elements of each item in the random_pool list, so the correct outcome would be: </p>
<pre><code>[[[0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [1], [0]],
 [[0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1], [3], [1]]
 [[0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [4], [2]],
 [[1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [3], [3]]]
</code></pre>
<p>I know there is something wrong with the loops, but I tried many things already and I couldn't get the result I wanted. Can anyone tell what am I doing wrong or hot to fix it?</p>
<p>Thank you! </p>
</div>
<div class="post-text" itemprop="text">
<p>This is the version of your function that will give the expected results:</p>
<pre><code>def GeneratePopulation(random_pool, binary_list):
    individual = []
    population = []
    for ind in range(0,len(binary_list)):
       fitness = random_pool[ind][2]
       counter = random_pool[ind][3]
       gene = binary_list[ind]
       individual=[gene,fitness,counter]
       population.append(individual)
     return(population)
</code></pre>
<p>In your original code the loop iterates ones through <code>random_pool</code> for every element in <code>binary_list</code> - that was not necessary and produced the repeated outcome. </p>
<p>Note that the variables <code>fitness</code>, <code>counter</code>, and <code>individual</code> are redundant here - you could achieve the same result without creating them. Do you need them for something else?</p>
</div>
<div class="post-text" itemprop="text">
<p>A more pythonic solution would be to <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip</a> the lists, so that you can iterate over the <code>random_pool</code> and <code>binary_list</code> at the same time and don't have to use indexes. </p>
<p>You can also unpack the pool in this way: <code>*_, fitness, counter = pool</code>. The <code>*_</code> will unpack the first items into the variable <code>_</code> which is often used for unneeded values, and the last two are unpacked into the variables <code>fitness</code> and <code>counter</code>.</p>
<pre><code>def generate_population(random_pool, binary_list):
    population = []
    for pool, gene in zip(random_pool, binary_list):
        *_, fitness, counter = pool  # Unpack the pool. Ignore the first two items.
        population.append([gene, fitness, counter])
    return population
</code></pre>
<p>With a <a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" rel="nofollow noreferrer">list comprehension</a> or a generator expression, you can reduce the function even more.</p>
<pre><code>def generate_population(random_pool, binary_list):
    return [[gene, fitness, counter]
            for (*_, fitness, counter), gene in zip(random_pool, binary_list)]
</code></pre>
</div>
<span class="comment-copy">this is exactly what I was looking for, great! About the variables, I am naming them so I know which one is what during the program steps but on a second thought, I might delete them now, thank you very much!</span>
<span class="comment-copy">Glad it worked :) Yes, better avoid redundant variables like this, among others they create a false impression of being use somewhere. In that case you can simply pack the loop into one line <code>population.append([binary_list[ind],random_pool[ind][2],random_pool[ind][3]])</code>.</span>
<span class="comment-copy">@skrx true, my personal choice is to keep only variables that are used and comment what is what in one line. But it's personal, you have a point there.</span>
<span class="comment-copy">You're welcome. BTW, I recommend watching Ned Batchelder's presentation <a href="https://www.youtube.com/watch?v=EnSu9hHGq5o" rel="nofollow noreferrer">"Loop like a native: while, for, iterators, generators"</a>.</span>
