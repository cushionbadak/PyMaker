<div class="post-text" itemprop="text">
<p>My data is a nested dicitionary of people in countries. Here's what it looks like with unimportant stuff removed:</p>
<pre><code>{'DE': [{'createdTime': '2017-11-03T13:41:01.000Z',
         'fields': {'Land': 'DE', 'Teilnehmer': 'James Hunt'},
         'id': 'reccgdSZXZFvAztCT'},
        {'createdTime': '2017-11-04T12:50:21.000Z',
         'fields': {'Land': 'DE', 'Teilnehmer': 'Susie Mueller'},
         'id': 'recQhmPmTrlZzoI84'},
        {'createdTime': '2017-11-04T12:50:33.000Z',
         'fields': {'Land': 'DE', 'Teilnehmer': 'Tom Tikky'},
         'id': 'recKCh99xvQwwCmSp'}],
 'UK': [{'createdTime': '2017-11-03T13:41:01.000Z',
         'fields': {'Land': 'UK', 'Teilnehmer': 'John Doe'},
         'id': 'recFTlSMXNET6e2UX'},
        {'createdTime': '2017-11-03T14:16:00.000Z',
         'fields': {'Land': 'UK', 'Teilnehmer': 'Jane Smith'},
         'id': 'recLqDHWh14TLm30g'},
        {'createdTime': '2017-11-03T18:41:56.000Z',
         'fields': {'Land': 'UK', 'Teilnehmer': 'Claire Singer'},
         'id': 'recB8XaFb7va0lT50'}]}
</code></pre>
<p>It has previously been sorted by country already. I now need to build sender/receiver pairs and everyone needs to be in two pairs - once as the sender, once as the receiver. Both sides need to be from the same country. So with the sample data from above there will be 3 pairs per country at the end.</p>
<p>All that matters on the output is the id. Basically I thought a list would work at the output but I'm not sure if those are reliable when it comes to the order of elements within the list. Apart from that this is what the result could look like:</p>
<pre><code>[
    # DE Pairs
    ['reccgdSZXZFvAztCT', 'recQhmPmTrlZzoI84'],
    ['recQhmPmTrlZzoI84', 'recKCh99xvQwwCmSp'],
    ['recKCh99xvQwwCmSp', 'reccgdSZXZFvAztCT'],
    # UK Pairs
    ['recFTlSMXNET6e2UX', 'recLqDHWh14TLm30g'],
    ['recLqDHWh14TLm30g', 'recB8XaFb7va0lT50'],
    ['recB8XaFb7va0lT50', 'recFTlSMXNET6e2UX']
]
</code></pre>
<p>Everything that came to my mind to solve this involves several levels of for loops but I still didn't manage to get it done. I'm very sure there must be a pythonic way to solve this. Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>There's not just one way to produce the pairs you want, at least, not if the number of people in a country is greater than 2. So you'll need to pick a way to select pairs so that each person is on each end exactly once.</p>
<p>One simple approach is to have each person send to the person after them in the country list. Wrap around so that the last person sends to the first, and you have a working algorithm.</p>
<p>Here's a list comprehension that I think does what you want:</p>
<pre><code>result = [(p[i-1]['id'], p[i]['id']) for p in data.values() for i in range(len(p))]
</code></pre>
<p>In the comprehension, <code>p</code> is a list of dictionaries representing people from a single country and <code>i</code> is an index into <code>p</code>. We allow <code>i-1</code> to be <code>-1</code> at the start, as that handles the "wrap around" case we need to make the pairs work the way you want.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import combinations

d = {
    'DE': [{'createdTime': '2017-11-03T13:41:01.000Z',
     'fields': {'Land': 'DE', 'Teilnehmer': 'James Hunt'},
     'id': 'reccgdSZXZFvAztCT'},
    {'createdTime': '2017-11-04T12:50:21.000Z',
     'fields': {'Land': 'DE', 'Teilnehmer': 'Susie Mueller'},
     'id': 'recQhmPmTrlZzoI84'},
    {'createdTime': '2017-11-04T12:50:33.000Z',
     'fields': {'Land': 'DE', 'Teilnehmer': 'Tom Tikky'},
     'id': 'recKCh99xvQwwCmSp'}],
    'UK': [{'createdTime': '2017-11-03T13:41:01.000Z',
     'fields': {'Land': 'UK', 'Teilnehmer': 'John Doe'},
     'id': 'recFTlSMXNET6e2UX'},
    {'createdTime': '2017-11-03T14:16:00.000Z',
     'fields': {'Land': 'UK', 'Teilnehmer': 'Jane Smith'},
     'id': 'recLqDHWh14TLm30g'},
    {'createdTime': '2017-11-03T18:41:56.000Z',
     'fields': {'Land': 'UK', 'Teilnehmer': 'Claire Singer'},
     'id': 'recB8XaFb7va0lT50'}]}
l = [list(combinations((x['id'] for x in v), 2)) for v in d.values()]
</code></pre>
<p>gives us </p>
<pre><code>[[('recFTlSMXNET6e2UX', 'recLqDHWh14TLm30g'),
  ('recFTlSMXNET6e2UX', 'recB8XaFb7va0lT50'),
  ('recLqDHWh14TLm30g', 'recB8XaFb7va0lT50')],
 [('reccgdSZXZFvAztCT', 'recQhmPmTrlZzoI84'),
  ('reccgdSZXZFvAztCT', 'recKCh99xvQwwCmSp'),
  ('recQhmPmTrlZzoI84', 'recKCh99xvQwwCmSp')]]
</code></pre>
<p>Edit:</p>
<pre><code>results = []
for country in d.values():
    ids = [people['id'] for people in country]
    rotated_ids = ids[1:] + ids[:1]
    for a, b in zip(ids, rotated_ids):
        results.append([a, b])
</code></pre>
<p>Would give us something more like</p>
<pre><code>[['recFTlSMXNET6e2UX', 'recLqDHWh14TLm30g'],
 ['recLqDHWh14TLm30g', 'recB8XaFb7va0lT50'],
 ['recB8XaFb7va0lT50', 'recFTlSMXNET6e2UX'],
 ['reccgdSZXZFvAztCT', 'recQhmPmTrlZzoI84'],
 ['recQhmPmTrlZzoI84', 'recKCh99xvQwwCmSp'],
 ['recKCh99xvQwwCmSp', 'reccgdSZXZFvAztCT']]
</code></pre>
</div>
<span class="comment-copy">If everyone in a country needs to be both a sender and a receiver with each other pair, don't you need n*(n-1) entries? For example you would also need (for DE) ['recQhmPmTrlZzoI84','reccgdSZXZFvAztCT'] and two more.</span>
<span class="comment-copy">@JohannesWachs maybe my description was just misleading (sorry, not a native english speaker). Everyone needs to send and receive once, so it should be as many pairs as there are people.</span>
<span class="comment-copy">Is there a typo in the 3rd element: <code>['recKCh99xvQwwCmSp', 'recQhmPmTrlZzoI84']</code>? Should it be: <code>['recKCh99xvQwwCmSp', 'reccgdSZXZFvAztCT'],</code>?</span>
<span class="comment-copy">Does order matters? Is <code>('recFTlSMXNET6e2UX', 'recLqDHWh14TLm30g'),   ('recFTlSMXNET6e2UX', 'recB8XaFb7va0lT50'),   ('recLqDHWh14TLm30g', 'recB8XaFb7va0lT50')</code> - with 2x leading <code>'recFTlSMXNET6e2UX'</code> - the correct output?</span>
<span class="comment-copy">@MaximTitarenko yes it does matter and no it's not correct. See my comment below on the answer on this. Order does matter as I need to know which one is sender and which one is receiver. (and yes there's a typo in the question - I will correct this. Thanks.)</span>
<span class="comment-copy">I think there's a slight misunderstanding. Each person doesn't have to be on one but on two pairs. One as a sender, one as a receiver.</span>
<span class="comment-copy">but nonetheless your solution gives the correct results, so thank you.</span>
<span class="comment-copy">I may not have been as clear as I hoped. The first person sends to the second, the second person sends to the third, and so on. But that's just one convenient selection, there are many others that meet your criteria just as well.</span>
<span class="comment-copy">Great, Patrick, thanks. That's excatly what I was looking for. Is there a similar smart way to flatten this down to a single list of tuples for clarity?</span>
<span class="comment-copy">@Helmi Use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a>.</span>
<span class="comment-copy">took me a while to see the problem but this solution doesn't seem to respect the order within each pair. While the pairs are unique there are duplicates on each side. For example first rows of each dict have the same sender (if we assume the first value in the tuple is the sender).</span>
<span class="comment-copy">@Helmi please see my edit</span>
<span class="comment-copy">Thanks, Patrick. Have to wrap my head around this to get how it works but works perfect.</span>
