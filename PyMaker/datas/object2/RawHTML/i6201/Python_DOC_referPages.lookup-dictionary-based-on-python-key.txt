<div class="post-text" itemprop="text">
<p>I have a list of dictionaries in the format:</p>
<p><code>mylist1 = [{'model': 'one'}, {'color': 'blue'}, {'age': 23}]</code></p>
<p>Is there a way I can look up a dictionary based on its key? For something I want to do something like (pseudocode):</p>
<p><code>mylist1['model'] #should return {'model': 'one'}</code></p>
<p>The reason why I am not doing <code>mylist[0]['model']</code> is because the list elements are not always in that order. Can someone help?</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Collapse your dictionary.</p>
<pre><code>d = {k : v for d in mylist1 for k, v in d.items()}

d
{'age': 23, 'color': 'blue', 'model': 'one'}
</code></pre>
<p>Now, just lookup in constant, <code>O(1)</code> time.</p>
<pre><code>d['model']
'one'
</code></pre>
<p>By keeping multiple disjoint <code>dict</code>s in the same list, you're defeating their purpose in the first place. </p>
<hr/>
<p>If you have multiple possible values with the same keys, use a <code>dict</code> of <code>list</code>s.</p>
<pre><code>d = {}
for dct in mylist1:
    for k, v in dct.items():
        d.setdefault(k, []).append(v)

d
{'age': [23], 'color': ['blue'], 'model': ['one']}
</code></pre>
<p>Supports multiple values with the same key without overwriting entries, as the previous one would've done.</p>
</div>
<div class="post-text" itemprop="text">
<p>The pseudocode you provided is impossible unless you subclass (or monkey patch) <code>list</code> (otherwise you'd get an error that list indices must be integers and not strings).</p>
<p>However you could write a function such as</p>
<pre><code>def find(li, key):
    for d in li:
        if key in d:
            return d
</code></pre>
<p>It will find and return the first dictionary that contains the given key, and can be easily modified to return a list of dictionaries if the keys are not unique.</p>
<h1><strong>But</strong></h1>
<p>it looks like you are using dictionaries wrong. Why do you have a list of dictionaries, each having (apparently) unique keys, and not a single dictionary?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>key = "model"
d = [ x for x in mylist if key in x ]
</code></pre>
<p>If you want just one match:</p>
<pre><code>key = "model"
d = next( x for x in mylist if key in x )
</code></pre>
<p>Second one uses generator, so it just finds first match and then stops.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>list comprehension</code> , find all <code>dictionaries</code> in the <code>list</code> that contain that <code>key</code> :</p>
<pre><code>&gt;&gt;&gt; mylist1 = [{'model': 'one'}, {'color': 'blue'}, {'age': 23}, {'model': 'two'}]
&gt;&gt;&gt; key = 'model'

&gt;&gt;&gt; [ ele for ele in mylist1 if key in ele ]
=&gt; [{'model': 'one'}, {'model': 'two'}]
</code></pre>
<p><strong>NOTE TO OP :</strong> as others have pointed out, its ofcourse quite redundant to have a list of dictionaries; <em>unless you have dictionaries with duplicate keys</em>.</p>
</div>
<span class="comment-copy">Are keys unique? In that case, just collapse them into a single dictionary.</span>
<span class="comment-copy">Why are these separate dictionaries in the first place?</span>
<span class="comment-copy">You need to re-think your data-structure here. You've essentially created a very memory-inefficient <code>list</code>, with none of the advantages of a <code>dict</code> (i.e. constant-lookup time)</span>
<span class="comment-copy">NOT exactly what you want, but related <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer">docs.python.org/3/library/collections.html#collections.ChainMap</a></span>
<span class="comment-copy">@KaushikNP I mentioned in that case that OP should use a dict of lists, or some nested structure.</span>
<span class="comment-copy">OP has thereby completely defeated the purpose of using dictionaries - if you have to iterate over them to find values.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ Indeed</span>
