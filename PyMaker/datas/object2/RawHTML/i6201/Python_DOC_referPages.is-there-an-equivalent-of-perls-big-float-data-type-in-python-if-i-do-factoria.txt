<div class="post-text" itemprop="text">
<p>Is there an equivalent of Perl's BigFloat data type in Python? The reason I ask is that I want to compute nCk using its definition, n!/k!*(n-k)!.</p>
<p>With Perl's BigFloat data type, computing from the definition works correctly for any n and k. For example </p>
<p>factorial(500)/factorial(10)*factorial(490) </p>
<p>produces the exact answer when n and k are BigFloats.</p>
<p>In Python, both factorial(500) and factorial(10)*factorial(49) give the exact answers using whatever Python uses for ints. Thus it appears that python can do very high precision arithmetic. However the quotient</p>
<p>int(factorial(500)/(factorial(10)*factorial(490)) </p>
<p>comes close to the exact answer, but falls a little short?  </p>
<p>Is there a way to  get an exact answers out of python for expressions like the above?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's <code>int</code> objects can grow as big as necessary (subject only to how much memory is available), so they can be used for calculations involving huge numbers. In Python 2, there were 2 integer types, <code>int</code> and <code>long</code>, with <code>int</code> being used for values that fit into machine integers, but in Python 3 they've been amalgamated into a single <code>int</code> type.</p>
<p>Python doesn't have a built-in BigFloat type, but the standard library does have the <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer"><code>decimal</code></a> module which can do basic arithmetic, including square roots, to any desired precision. If you need to do arbitrary precision mathematics with more functions, please see the excellent 3rd-party library, <a href="http://mpmath.org/" rel="nofollow noreferrer"><code>mpmath</code></a>.</p>
<p>You can safely use <code>//</code> floor division when computing binomial coefficients, since the terms in the denominator are guaranteed to divide the numerator. Eg</p>
<pre class="lang-py prettyprint-override"><code>from math import factorial

a = (factorial(500) // factorial(490)) // factorial(10)
print(a)
</code></pre>
<p><strong>output</strong></p>
<pre><code>245810588801891098700
</code></pre>
<hr/>
<p>However, it may be more efficient to calculate the binomial coefficient with a simple loop, rather than calculating those huge factorials.</p>
<pre class="lang-py prettyprint-override"><code>def binomial(n, r):
    ''' Binomial coefficients '''
    if not 0 &lt;= r &lt;= n:
        return 0
    p = 1
    r = min(r, n - r)
    for i in range(1, r+1):
        p *= n
        p //= i
        n -= 1
    return p

# Test

print(binomial(500, 10), '\n')

for i in range(10):
    print([binomial(i, j) for j in range(i+1)])
</code></pre>
<p><strong>output</strong></p>
<pre><code>245810588801891098700 

[1]
[1, 1]
[1, 2, 1]
[1, 3, 3, 1]
[1, 4, 6, 4, 1]
[1, 5, 10, 10, 5, 1]
[1, 6, 15, 20, 15, 6, 1]
[1, 7, 21, 35, 35, 21, 7, 1]
[1, 8, 28, 56, 70, 56, 28, 8, 1]
[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
</code></pre>
</div>
<span class="comment-copy">Don't use <code>/</code> division, use <code>//</code> floor division. And don't use multiplication, use 2 divisions.</span>
<span class="comment-copy"><code>factorial(500)/factorial(490)</code> is just <code>491*492*493*494*495*496*497*498*499*500</code>. No need for huge floats.</span>
<span class="comment-copy">@Eric, I'm aware of the shortcut, but my question really had to do with how to handle big floats correctly. I happened to use a particular binonmial cooefficient as an example of the more general case.</span>
<span class="comment-copy">thanks, the // operator is just what I needed. I had no knowledge of it as I'm just learning Python.  My approach is to convert stuff that I've done in C and Perl to Python.</span>
<span class="comment-copy">@nog642 Thanks for fixing the Python 2 / Python 3 typo, but <code>factorial(500) // factorial(490) // factorial(10)</code> is a little more efficient than <code>factorial(500) // (factorial(490) * factorial(10))</code>, which is why I suggested it in my comment on the question. However, I've added extra parentheses to make it more readable.</span>
<span class="comment-copy">"You can safely use <code>//</code> floor division when computing binomial coefficients, since the terms in the denominator are guaranteed to divide the numerator." Is that true for both division? Obviosuly the first one is true as the top factorial is higher, but is the second division also guaranteed?</span>
<span class="comment-copy">@Adirio Yes, it is. You can prove using mathematical induction that a consecutive sequence of <code>n</code> integers is always divisible by <code>n!</code>. And that's why my looping version works correctly.</span>
