<div class="post-text" itemprop="text">
<p>I'm new to this framework and am trying to understand the difference/benefits of using one over the other</p>
<p>I could use a non-async function that is not a co-routine to do</p>
<pre><code>def while_naughty():
    print("naughty")

loop.call_soon(self.while_naughty)
</code></pre>
<p>or</p>
<pre><code>async def naughty():
    print("naughty")

task = asyncio.ensure_future(naughty())
</code></pre>
<p>I know that ensure_future takes a co-routine as parameter, I hope to learn about situations where it is more advantageous to use <code>call_soon()</code> over <code>ensure_future()</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>The non-coroutine version will never act cooperatively. You can't <code>await</code> on anything else in that function, and because of the way you invoked it, you can't return a result to the caller.</p>
<p><code>loop.call_soon()</code> is specifically meant to be used for callbacks, which usually are very simple functions used to hook into events (job done, exception was raised in future, etc.), and they are not <em>expected</em> to cooperate.</p>
<p>Callbacks are also not expected to return anything; they are fire-and-forget routines, trusted to not lock up the whole system by running anything heavy or blocking. <code>call_soon()</code> returns a <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Handle" rel="nofollow noreferrer"><code>Handle()</code> instance</a> that only lets you <em>cancel</em> it again (a no-op if it already has been executed). The callbacks are executed next time the event loop checks the callback queue, at which point they (hopefully briefly) block any other work from being done<sup>*</sup>.</p>
<p>Note that <code>asyncio.ensure_future()</code> only creates a <code>Future()</code> instance, the task is not actually started! But if you did start it (with, say, <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_until_complete" rel="nofollow noreferrer"><code>loop.run_until_complete()</code></a>), you get more control. You now have proper coroutine, it can await on other coroutines. Awaiting on other coroutines lets the event loop switch to other coroutines that are ready to continue, ensuring your CPU is busy doing actual work when there is work to be done. And your coroutine can return actual results to the caller too.</p>
<p>Use whichever one better fits your use-cases. In a large application, you'll likely use both.</p>
<hr/>
<p><sup>*</sup> When you <a href="https://docs.python.org/3/library/asyncio-dev.html#asyncio-debug-mode" rel="nofollow noreferrer">run in debug mode</a> you are told when callbacks take too long, so you can debug these.</p>
</div>
<span class="comment-copy">You didn't actually execute the <code>whily_naughty()</code> future. You only wrapped it.</span>
<span class="comment-copy">thanks for the reply, both functions perform similarly, what is the difference between only wrapping it?</span>
<span class="comment-copy">I've removed the 'extras'. Please stick to one concrete question at a time, otherwise your question is too broad.</span>
