<div class="post-text" itemprop="text">
<p>Why do we need the <code>asyncio.coroutine</code> decorator? What functionality does it provide?</p>
<p>For example:</p>
<pre><code># import asyncio
# @asyncio.coroutine
def gen():
    value = yield("Started")
    print(value)

a = gen()
a.send(None)
a.send("Done")
</code></pre>
<p>Now if I uncomment the first two lines and use the <code>asyncio.coroutine</code> decorator, I still get the same output.</p>
<p>I mean this is already a <code>coroutine</code> - a function that can be paused and passed in with an argument. Why do I need to decorate it with another <code>coroutine</code> i.e <code>asyncio.coroutine</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's important to understand that <a href="http://anandology.com/python-practice-book/iterators.html#generators" rel="nofollow noreferrer">generators</a> and <code>asyncio</code> <a href="https://docs.python.org/3/library/asyncio-task.html#coroutines" rel="nofollow noreferrer">coroutines</a> - are different things. Coroutines are implemented using generators, but (theoretically) could been implemented without them. Genarators - are part of implementation regarding to coroutines.</p>
<p>Since <code>asyncio</code> coroutines are implemented using generators, you can sometimes use generators as coroutines without errors:</p>
<pre><code>import asyncio


def main():
    yield from asyncio.sleep(1)
    print('done')


loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</code></pre>
<p><strong>Result:</strong></p>
<pre><code>done
</code></pre>
<hr/>
<p>But it doesn't work with every kind of coroutine:</p>
<pre><code>import asyncio


def main():
    # yield from asyncio.sleep(1)
    print('done')


loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</code></pre>
<p><strong>Result:</strong></p>
<pre><code>TypeError: An asyncio.Future, a coroutine or an awaitable is required
</code></pre>
<hr/>
<p>That's why (besides <a href="https://stackoverflow.com/q/47095008/1113207">few other</a> things) <code>asyncio.coroutine</code> decorator uses:</p>
<pre><code>import asyncio


@asyncio.coroutine
def main():
    # yield from asyncio.sleep(1)
    print('done')


loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</code></pre>
<p><strong>Result:</strong></p>
<pre><code>done
</code></pre>
<hr/>
<p>But as already noted by all it doesn't actually matter today: since Python 3.5 decorator and <code>yield from</code> have been replaced with keywords <code>async def</code> and <code>await</code> that's not only nicer, but helps to split coroutines from their implementation details in a better way. </p>
<pre><code>import asyncio


async def main():
    # await asyncio.sleep(1)
    print('done')


loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</code></pre>
</div>
<span class="comment-copy">The <code>async def</code> and <code>await</code> syntax wasn't available until 3.5 while <code>asyncio</code> was formally introduced in 3.4...</span>
<span class="comment-copy">But still what value does the <code>asyncio.coroutine</code> decorator add to my code? I can use the <code>generator</code> as a <code>coroutine</code> without additional code right. [My next question is why do we need the <code>async def</code> and <code>await</code> as a syntax when it can be achieved without that. But I will not mix that with this question.]</span>
<span class="comment-copy">Now I'm not sure what you're asking... you have a normal generator function there that you're sending data back in to - you've been able to do that before any asyncio at all...</span>
<span class="comment-copy">You can then use them as part of an async event loop and have them wait/sleep/cancel each other etc... If you're familiar with twisted, then think of <code>asyncio</code> IO as a base for doing the same thing (without all the ready made reactors and protocols)... Might be worth having a read through a tutorial or basic examples of it and take it from there...</span>
<span class="comment-copy">In your example, you don’t need the decorator. It provides you with nothing. You’d only use it if you’re defining a coroutine that will get passed to an event loop. And even then you’d only want to use the decorator if your code is going to run on 3.4; you can use <code>async def</code> starting in 3.5.</span>
