<div class="post-text" itemprop="text">
<p>Psudo code:</p>
<pre><code>timelines = [
    (range(&lt;from&gt;, &lt;to&gt;), range(&lt;from&gt;, &lt;to&gt;)),
    (range(&lt;from&gt;, &lt;to&gt;), range(&lt;from&gt;, &lt;to&gt;)),
    (range(&lt;from&gt;, &lt;to&gt;), range(&lt;from&gt;, &lt;to&gt;)),
]
</code></pre>
<p><code>&lt;from&gt;</code> and <code>&lt;to&gt;</code> represent datetime objects</p>
<p>This "picture" shows after "Intersection" the values I need to calculate:</p>
<pre><code>        |----------|    |----------|
               |------------|   |-------|
        |---------|     |------------|

Intersection   |--|     |---|   |--|
</code></pre>
<p>How do I calculate these intersections?</p>
<p>I'm coding in python, but answers in any programming language are welcome,
as I only need to understand the algorithm</p>
</div>
<div class="post-text" itemprop="text">
<p>Step 0: Make a <code>Range</code> class for convenience:</p>
<pre><code>from collections import namedtuple
Range = namedtuple("Range", ["start", "end"])
</code></pre>
<p>Step 1: Make a function that calculates the intersection between two ranges. This function will work for anything that consists of two comparable points:</p>
<pre><code>def intersect(range1, range2):
    new_range = Range(
        max(range1.start, range2.start),
        min(range1.end, range2.end)
    )
    return new_range if new_range.start &lt; new_range.end else None
</code></pre>
<p>Step 2: Make a function that finds all intersections of two sets of ranges, by just trying all possible combinations.</p>
<pre><code>def intersect_two(ranges1, ranges2):
    for range1 in ranges1:
        for range2 in ranges2:
            intersection = intersect(range1, range2)
            if intersection:
                yield intersection
</code></pre>
<p>Step 3: <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>reduce()</code></a> a list of sets of ranges using <code>intersect_two</code>:</p>
<pre><code>def intersect_all(ranges):
    return reduce(intersect_two, ranges)
</code></pre>
<p>I'm using integers for simplicity, but it should work just as good with <code>datetime</code> objects:</p>
<pre><code>&gt;&gt;&gt; timelines = [
...     (Range(0, 11), Range(15, 20)),
...     (Range(8, 16), Range(19, 25)),
...     (Range(0, 10), Range(15, 22)),
... ]
&gt;&gt;&gt;
&gt;&gt;&gt; for intersection in intersect_all(timelines):
...     print(intersection)
...
Range(start=8, end=10)
Range(start=15, end=16)
Range(start=19, end=20)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I'm coding in python, but answers in any programming language are welcome, as I only need to understand the algorithm</p>
</blockquote>
<p>If you just want the pseudocode, one algorithm would be:</p>
<pre><code>intersections = total_range
for timeline in timelines:
    intersections = intersection(timeline,intersections)
</code></pre>
<p>For implementing intersections, there are a few different methods. One is to use set function, although you have to convert to sets, and then if you don't want a set as output you have to convert back: <code>intersections = intersections.intersection(timeline)</code>. Another method is list comprehension: <code>intersections = [time_point for time_point in intersections if time_point in timeline]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my implementation of @Felk's answer:</p>
<pre><code>from functools import reduce
from psycopg2.extras import DateTimeTZRange


def _DateTimeTZRange_intersect(range1, range2):
    new_range = DateTimeTZRange(
        max(range1.lower, range2.lower),
        min(range1.upper, range2.upper)
    )
    return new_range if new_range.lower &lt; new_range.upper else None

def DateTimeTZRange_intersect(*args):
    return reduce(_DateTimeTZRange_intersect, args) if args else []


def _DateTimeTZRange_intersect_2d(ranges1, ranges2):
    for range1 in ranges1:
        for range2 in ranges2:
            intersection = DateTimeTZRange_intersect(range1, range2)
            if intersection:
                yield intersection

def DateTimeTZRange_intersect_2d(*args):
    return reduce(_DateTimeTZRange_intersect_2d, args) if args else []
</code></pre>
</div>
<span class="comment-copy">I would consider establishing date ranges using the datetime module in Python, then looping through those lists of sequential dates and identifying any matches. Then proceed to create a new list of dates based on the most recent and least recent dates that exist without gaps.</span>
<span class="comment-copy">You might find the information available from <a href="https://stackoverflow.com/questions/325933/determine-whether-two-date-ranges-overlap/328558#328558">How to detect whether two date ranges overlap</a> useful.  Although the question is couched in terms of date/time ranges, any range type can be tested similarly.  In context, you probably need to calculate the intersections of two of the sets of ranges, and then take that result and calculate the intersection of that with the third range.  An easy optimization is to note that if the result range is empty, you can stop as the result will be empty too.</span>
<span class="comment-copy">I only want the periods where periods on all timelines intersect. What I understand from your psudo code could be accomplished with <code>set.intersection([set(r) for ranges in timelines for r in ranges])</code></span>
<span class="comment-copy">@demux That might work if you insert <code>*</code>: <code>set.intersection(*[set(r) for ranges in timelines for r in ranges])</code></span>
<span class="comment-copy">Not for what I'm doing, but it would be valid python.</span>
