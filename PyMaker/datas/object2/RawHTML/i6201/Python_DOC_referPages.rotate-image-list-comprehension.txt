<div class="post-text" itemprop="text">
<p>While solving a problem on matrix rotation I came across a solution .The question asks to rotate the matrix by 90 degrees in place.</p>
<pre><code>def rotateImage(a):
    rows = len(a)
    cols = len(a[0])
    a=a[::-1]
    return [[m[i] for m in  a] for i in range(cols)]
</code></pre>
<p>Can someone help me in breaking down this list comprehension to regular for-loop and understand the flow of the program</p>
</div>
<div class="post-text" itemprop="text">
<p>You have a <em>nested</em> list comprehension, an outer list comprehension creating a new list for every iteration.</p>
<p>You can deconstruct any list comprehension by reading the <code>for</code> and <code>if</code> components from left to right as nested blocks. <em>Everything</em> before the first <code>for</code> is the expression that produces the elements of the list.</p>
<p>So the basic structure is:</p>
<pre><code>[&lt;expression&gt; for &lt;targets&gt; in &lt;iterable&gt; &lt;optionally more if and for&gt;]
</code></pre>
<p>which can always be converted to a regular loop with:</p>
<pre><code>_result = []
for &lt;targets&gt; in &lt;iterable&gt;:
    &lt;optionally more if and for blocks, add a new level each time&gt;
        _result.append(&lt;expression&gt;)
</code></pre>
<p>I added in <code>_result</code> as an explicit name for the list that is produced; note that the result of <code>&lt;expression&gt;</code> is appended to it each iteration.</p>
<p>Your example breaks down to <strong>two</strong> list comprehensions. The outer loop is this:</p>
<pre><code>[[m[i] for m in  a] for i in range(cols)]
# \              /      |     \       /
#   &lt;expression&gt;    &lt;targets&gt;  &lt;iterable&gt;
</code></pre>
<p>So the <code>[m[i] for m in  a]</code> is the expression here! Writing this out that becomes:</p>
<pre><code>_result_outer = []
for i in range(cols):
    _result_outer.append([m[i] for m in  a])
</code></pre>
<p>The inner list comprehension is straightforward:</p>
<pre><code>_result_inner = []
for m in a:
    _result_inner.append(m[i])
</code></pre>
<p>If you put these two together you get:</p>
<pre><code>_result_outer = []
for i in range(cols):
    _result_inner = []
    for m in a:
        _result_inner.append(m[i])
    _result_outer.append(_result_inner)
</code></pre>
<p>Now you can see that the <code>i</code> target from the <em>outer</em> loop, is used each time in the <em>inner</em> loop. Because <code>i</code> loops over the number of columns, but <code>m</code> is a row, this produces first a list with all the values from the very first column, then the second column, and then the third, etc.</p>
<p>The line before the list comprehension <em>reversed</em> the rows:</p>
<pre><code>a = a[::-1]
</code></pre>
<p>This takes all rows, and goes from the last to the first (stepping backwards, with a <code>-1</code> step size). This makes it so that the list comprehension loops over the rows in reverse order.</p>
<p>The code can be cleaned up and improved a little. The <code>rows</code> variable is never used, for example, and we can use the <a href="https://docs.python.org/3/library/functions.html#reversed" rel="nofollow noreferrer"><code>reversed()</code> function</a> to loop over a list in reverse order without creating a copy:</p>
<pre><code>def rotateImage(a):
    cols = len(a[0])
    return [[m[i] for m in reversed(a)] for i in range(cols)]
</code></pre>
<p>Another method of transposing a matrix (moving columns to rows) is using the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code> function</a> with all the rows applied as separate arguments, with the <code>*&lt;expression&gt;</code> call syntax:</p>
<pre><code>def rotateImage(a):
    return [list(r) for r in zip(*reversed(a))]
</code></pre>
<p>This still uses a list comprehension, because <code>zip()</code> produces an <em>iterable object</em>, not a list, and each time you iterate you get a tuple. The above list comprehension converts the whole result back to a list of lists.</p>
<p>If you want to do this <em>in place</em>, I suggest you read the very excellent answer Jack wrote on rotating a matrix with Python; their explanation of how to code this is second to none: <a href="https://stackoverflow.com/questions/42519/how-do-you-rotate-a-two-dimensional-array/35438327#35438327">How do you rotate a two dimensional array?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>a=a[::-1]</code> is simply a in reverse. The list comprehension is:</p>
<pre><code>res = []
for i in range(cols):
    tmp = []
    for m in a:
        tmp.append(m[i])
    res.append(tmp)
return res
</code></pre>
<p>****EDIT****</p>
<p>What is basically happening here is the for each column index <code>i</code> the algorithm goes through all the rows <code>m</code> (form last to first) and appends the <code>m[i]</code> (the i'th value in the m'th row) to <code>tmp</code>, which is then appended as a row, to <code>res</code>. So each reversed column is added as a row to <code>res</code>.</p>
<p>So for a matrix like:</p>
<pre><code>1 2 3 4
5 6 7 8
9 1 0 4
</code></pre>
<p>The first inner loop iteration will result in <code>tmp=[9, 5, 1]</code></p>
</div>
<span class="comment-copy">Thanks so much.Can you suggest a way in which we can implement a matrix rotation in place using for-loop</span>
<span class="comment-copy">@HasanJunaid: <a href="//stackoverflow.com/a/35438327">How do you rotate a two dimensional array?</a> covers this in more detail than you could ever wish for.</span>
<span class="comment-copy">@HasanJunaid I am not sure what you are further asking, but I edited my answer to help you understand the algorithm's flow.</span>
