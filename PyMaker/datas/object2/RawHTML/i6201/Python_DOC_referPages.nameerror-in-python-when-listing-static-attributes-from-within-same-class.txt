<div class="post-text" itemprop="text">
<p>I have the following python class:</p>
<pre><code>class list_stuff:    
        A = 'a'
        B = 'b'
        C = 'c'
        stufflist = [v for k,v in list_stuff.__dict__.items() if not k.startswith("__")]
</code></pre>
<p>But it shows a NameError saying undefined variable <code>list_stuff</code>.</p>
<p>According to <a href="https://stackoverflow.com/questions/28685828/python-2-7-how-to-get-the-list-of-static-variables-in-a-class">this</a>, it should work.</p>
<p>I also tried with:</p>
<pre><code>list_stuff().__dict__.items()
</code></pre>
<p>But still same error. What am I missing here?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python you cannot reference the class in the class body.
The issue I see here is that you are referring to the class <code>list_stuff</code> within the class definition. To resolve simply move that line outside the class:</p>
<pre><code>class list_stuff:    
    A = 'a'
    B = 'b'
    C = 'c'

stufflist = [v for k,v in list_stuff.__dict__.items() if not k.startswith("__")]
</code></pre>
<p>Here is the <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">documentation on classes</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I ended up doing this:</p>
<pre><code>class list_stuff:    
    A = 'a'
    B = 'b'
    C = 'c'

    @classmethod
    def stufflist(cls):
        return [v for k,v in cls.list_stuff.__dict__.items() if not k.startswith("__")]
</code></pre>
<p>which has the same effect as my original intent.</p>
<p>Thanks all for quick replies.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem seems to be the indentation, as you are essentially calling the class from within. </p>
<p>Try this:</p>
<pre><code>class list_stuff:    
    A = 'a'
    B = 'b'
    C = 'c'
stufflist = [v for k,v in list_stuff.__dict__.items() if not k.startswith("__")]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a method that would generate the list attribute you wish. First you will need to generate an instance of that class, before running the <code>get_list()</code> method.</p>
<pre><code>class list_stuff():
    A = 'a'
    B = 'b'
    C = 'c'  

def get_list(self):
    self.thelist = [v for k,v in list_stuff.__dict__.items() if not k.startswith("__")]
    return self.thelist

list_a = list_stuff()
print list_a.get_list()
print list_a.thelistenter code here
</code></pre>
<p>This is what it returns:</p>
<pre><code>['a', 'b', 'c', &lt;function get_list at 0x7f07d6c63668&gt;]
['a', 'b', 'c', &lt;function get_list at 0x7f07d6c63668&gt;]
</code></pre>
</div>
<span class="comment-copy">Try this: <a href="https://stackoverflow.com/questions/9058305/getting-attributes-of-a-class" title="getting attributes of a class">stackoverflow.com/questions/9058305/…</a></span>
<span class="comment-copy">seems difficult from the inside.</span>
<span class="comment-copy">Nonsense. Undefined variables aren't syntax errors.</span>
<span class="comment-copy">it's a NameError</span>
<span class="comment-copy">That works. But I wanted to keep it inside the class, so i ended up using a @classmethod, then referenced the classname with cls.list_stuff. This gives me the same effect I wanted originally.</span>
<span class="comment-copy">That’s true you could do it achieve what you want that way! Happy to help :)</span>
<span class="comment-copy">I'm not strong at OO, let me know if this is unclear or wrong, I will update...</span>
