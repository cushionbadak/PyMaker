<div class="post-text" itemprop="text">
<p>I know I can do this to get the execute a system command, e.g., make, and it'll give me either a 0 for success, or a non-zero for a failure.</p>
<pre><code>import os
result = os.system('make')
</code></pre>
<p>I also know I can do this so I can see the return string of the command</p>
<pre><code>import commands
result = commands.getoutput('make')
</code></pre>
<p>How can I accomplish both, where I get both the return code and the return string result, so then I can</p>
<pre><code>if return_code &gt; 0:
  print(return_string)
</code></pre>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>The canonical way to run stuff with Python is to use the <code>subprocess</code> module, but it has a good bunch of functions enigmatically called <code>check_call</code> or <code>check_output</code> and these functions tend to have cryptic warnings like "Do not use stdout=PIPE or stderr=PIPE with this function", so let me provide some more:</p>
<h3>Step 1: Run the script</h3>
<pre><code>proc = subprocess.Popen(["your_command", "parameter1", "paramter2"],
                        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
</code></pre>
<p>Now the process is running in the background and you have a reference to it.</p>
<p>EDIT: I almost forgot - if you'd like to retrieve the output later, you have to tell Python to create reading pipes for standard output. If you don't do this step, stdout and stderr will just go to your program's standard output and standard error, and <code>communicate</code> won't pick them up in step 2.</p>
<h3>Step 2: wait for the process to finish and get its output</h3>
<pre><code>stdout, sterr = proc.communicate()
return_code = proc.returncode
</code></pre>
<p><a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow noreferrer"><code>communicate</code></a> allows you to do some more things too:</p>
<ul>
<li>pass stdin data to the process (<code>input=</code> parameter)</li>
<li>give a time limit for the process to finish, to avoid hanging (<code>timeout=</code> parameter)</li>
</ul>
<p>Make sure to also catch and properly handle any exceptions from <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="nofollow noreferrer"><code>Popen</code></a> or <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow noreferrer"><code>communicate</code></a>.</p>
<hr/>
<p>If you don't care about old Python, there's a simpler method called <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer"><code>subprocess.run</code></a> that Does It All:</p>
<pre><code>completed_process = subprocess.run(
    ['your_command', 'parameter'],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE)
# this starts the process, waits for it to finish, and gives you...
completed_process.returncode
completed_process.stdout
completed_process.stderr
</code></pre>
<p>For error-checking you can call <code>completed_process.check_returncode()</code> or just pass <code>check=True</code> as an additional argument to <code>run</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another possibly simpler method is:</p>
<pre><code>import subprocess
try:
 output = subprocess.check_output("make", stderr=subprocess.STDOUT)
except subprocess.CalledProcessError as e:
  print('return code =', e.returncode)
  print(e.output)
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer">Deprecated since version 2.6: The commands module has been removed in Python 3. Use the subprocess module instead.</a></span>
<span class="comment-copy">this is an okay solution if we know that the program will EITHER print to stdout or stderr. If it somehow prints to both, they will be mixed together in a generally unpredictable way.</span>
