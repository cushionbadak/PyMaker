<div class="post-text" itemprop="text">
<p>I would like for child process to have certain properties, but since you can't force child methods to inherit the property decorator, I want to at least assert that these attributes of the child are properties of the class.</p>
<p>Something like this:</p>
<pre><code>class Parent:
    def __init__(self):
        assert isinstance(self.foo, property)

    def foo(self):
        raise NotImplementedError

class Child(Parent):
    def __init__(self):
        super().__init__()

    @property
    def foo(self):
        return 'bar'
</code></pre>
<p>But of course by the time <code>Parent.__init__()</code> is run, <code>self.foo</code> has become <code>'bar'</code> and there is an <code>AssertionError</code>. Is there a way to accomplish what I'm going for using meta classes? If so, can it be that the <code>Parent</code> class is the one that inherits the metaclass, not the <code>Child</code>? </p>
</div>
<div class="post-text" itemprop="text">
<p>I found a solution. Instead of testing whether <code>self.foo</code> is a property, I tested whether it was not a bound method:</p>
<pre><code>from inspect import ismethod

class Parent:
    def __init__(self):
        assert not ismethod(self.foo, property)

    def foo(self):
        raise NotImplementedError
</code></pre>
<p>This will work for most cases, but will fail if the property being returned by <code>Child.foo</code> is itself a bound method. Still open to more complete answers.</p>
</div>
<span class="comment-copy">Why not use <a href="https://docs.python.org/3/library/abc.html#abc.abstractproperty" rel="nofollow noreferrer">docs.python.org/3/library/abc.html#abc.abstractproperty</a>?</span>
<span class="comment-copy">Ahh, perfect. Submit and answer and I'll accept it</span>
<span class="comment-copy">Actually, this looks great but I can't get it to work. abc.abstractproperty is deprecated, and says to use abstractmethod with property. I can't get it to raise an error either way.</span>
