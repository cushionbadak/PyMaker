<div class="post-text" itemprop="text">
<p>Is it possible to modify a class so as to make available a certain method decorator, without having to explicitly import it and without having to prefix it (<code>@something.some_decorator</code>):</p>
<pre><code>class SomeClass:

    @some_decorator
    def some_method(self):
        pass
</code></pre>
<p>I don't think this is possible with a class decorator, because that is applied too late. The option that seems more promising is using a metaclass, but I am unsure how, my guess is that I would have to have <code>some_decorator</code> be introduced into the namespace of <code>SomeClass</code>.</p>
<p>Thanks to @MartijnPieters for pointing out that <code>staticmethod</code> and <code>classmethod</code> are built-ins. I had expected them to be part of the <code>type</code> machinery.</p>
<p>To be clear, I don't have any explicit use-case for this, I am just curious as to whether this is at all possible.</p>
<p>ADDENDUM, now that the question has been answered. The original reason why I was looking beyond simply importing or defining a decorator locally, was that I had defined a decorator that would only work if a certain container attribute was initialised on an object, and I was looking for a way to tie enforcing this to the availability of the decorator. I ended up checking whether the attribute existed and if not initialising it within the decorator, which may very well be the lesser evil here.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, in Python 3 you can use the <a href="https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace" rel="noreferrer">metaclass <code>__prepare__</code> hook</a>. It is expected to return a mapping, and it forms the basis of the local namespace for the class body:</p>
<pre><code>def some_decorator(f):
    print(f'Decorating {f.__name__}')
    return f

class meta(type):
    @classmethod
    def __prepare__(mcls, name, bases, **kw):
        return {'some_decorator': some_decorator}

class SomeClass(metaclass=meta):
    @some_decorator
    def some_method(self):
        pass
</code></pre>
<p>Running the above produces</p>
<pre><code>Decorating some_method
</code></pre>
<p><strong>However</strong>, <em>you should not use this</em>. As the <a href="https://www.python.org/dev/peps/pep-0020/" rel="noreferrer"><em>Zen of Python</em></a> states: <em>Explicit is better than implicit</em>, and introducing magic names into your classes <em>can easily lead to confusion and bugs</em>. Importing a metaclass is no different than importing a decorator, you replaced one name with another.</p>
<p>A class decorator can still apply other decorators to methods on a class after the class body has been created. The <code>@decorator</code> syntax is just syntactic sugar for <code>name = decorator(decorated_object)</code>, you can always apply a decorator later on by using <code>name = decorator(name)</code>, or in a class context, as <code>cls.name = decorator(cls.name)</code>. If you need to pick and choose which methods this should apply to, you could pick criteria like the method name, or attributes set on the method, or the docstring of the method, etc. Or just use the decorator directly on the methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>As best I can tell a metaclass can do this.  You somehow need to get the decorators available to the metaclass, possibly by importing, and then you can include them in the prepared namespace:</p>
<pre><code>class includewraps(type):
    def prepare(*args):
        from functools import wraps
        return {'wraps': wraps}


class haswraps (metaclass = includewraps):
    # wraps is available in this scope
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Write a decorator that takes a list of strings and imports them before the function is called for the first time. This avoids explicit imports until the last possible moment before they're needed. This, like all the other answers here, is probably an indication that your code should be restructured instead.</p>
<pre><code>from functools import wraps
from importlib import import_module

def deferred(*names):
    def decorator(f):
        # this will hold the fully decorated function
        final_f = None

        @wraps(f)
        def wrapper(*args, **kwargs):
            nonlocal final_f

            if final_f is None:
                # start with the initial function
                final_f = f

                for name in names:
                    # assume the last . is the object to import
                    # import the module then get the object
                    mod, obj = name.rsplit('.', 1)
                    d = getattr(import_module(mod), obj)
                    # decorate the function and keep going
                    final_f = d(final_f)

            return final_f(*args, **kwargs)

        return wrapper

    return decorator
</code></pre>
<pre><code># for demonstration purposes, decorate with a function defined after this
# assumes this file is called "example.py"
@deferred('example.double')
def add(x, y):
    return x + y

def double(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        return 2 * f(*args, **kwargs)

    return wrapper

if __name__ == '__main__':
    print(add(3, 6))  # 18
</code></pre>
<p>The arguments to <code>deferred</code> should be strings of the form <code>'path.to.module.decorator</code>. <code>path.to.module</code> is imported and then <code>decorator</code> is retrieved from the module. Each decorator is applied to wrap the function. The function is stored in a <code>nonlocal</code> so that this import and decorating only needs to happen the first time the function is called.</p>
</div>
<span class="comment-copy">Thanks for updating this, the question <i>is</i> now clearer than it was before.</span>
<span class="comment-copy">I just ran a test.  Names in the prepared namespace (<b>prepare</b>) actually are available in the class.  So, a metaclass can do this.</span>
<span class="comment-copy">@SamHartman: I ran a test too, but see now I made an error. Will re-test.</span>
<span class="comment-copy">@SamHartman: ugh, typo in the metaclass I made.</span>
<span class="comment-copy">I'd recommend editing your answer to focus on alternatives to metaclass, and to discussing downsides/complexities of metaclasses.  I think the information about from foo import decorator etc you provide is valuable; you almost never actually want to do the metaclass for this even though you can</span>
<span class="comment-copy">Thanks to both of you! I am actually surprised this is in fact possible. I'll add an explanation to the question why someone might want to do this, although I am not saying this is worth the trade-off.</span>
