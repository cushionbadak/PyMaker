<div class="post-text" itemprop="text">
<p>I am trying to patch the <code>fun_1</code> function from the <code>worker_functions</code> dictionary and I seem to be struggling:</p>

cli.py:

<pre><code>import sys

from worker_functions import (
    fun_1,
    fun_2,
    fun_3,
)

FUNCTION_MAP = {
    'run_1': fun_1,
    'run_2': fun_2,
    'run_3': fun_3,
}

def main():
    command = sys.argv[1]
    tag = sys.argv[2]
    action = FUNCTION_MAP[command]

    action(tag)
</code></pre>
<p>I've tried mocking <code>cli.fun_1</code> and <code>cli.main.action</code> and <code>cli.action</code> but this is leading to failure.</p>

test_cli.py:

<pre><code>from mock import patch

from cli import main


def make_test_args(tup):
    sample_args = ['cli.py']
    sample_args.extend(tup)
    return sample_args


def test_fun_1_command():
    test_args = make_test_args(['run_1', 'fake_tag'])
    with patch('sys.argv', test_args),\
         patch('cli.fun_1') as mock_action:
        main()

        mock_action.assert_called_once()
</code></pre>
<p>Do I seem to be missing something?</p>
</div>
<div class="post-text" itemprop="text">
<p>You'll need to patch the references in the <code>FUNCTION_MAP</code> dictionary itself. Use the <a href="https://docs.python.org/3/library/unittest.mock.html#patch-dict" rel="nofollow noreferrer"><code>patch.dict()</code> callable</a> to do so:</p>
<pre><code>from unittest.mock import patch, MagicMock

mock_action = MagicMock()
with patch('sys.argv', test_args),\
     patch.dict('cli.FUNCTION_MAP', {'run_1': mock_action}):
    # ...
</code></pre>
<p>That's because the <code>FUNCTION_MAP</code> dictionary is the location that the function reference is looked up.</p>
</div>
<span class="comment-copy">This looks potentially brilliant.</span>
<span class="comment-copy">do I import <code>MagicMock</code> from mock?</span>
<span class="comment-copy">Yes, I added the import.</span>
<span class="comment-copy">Flip... Now I know what separates the Padawan from those on the Council...</span>
