<div class="post-text" itemprop="text">
<p>Ok, so I am working on a model which simulates forest growth. The growth is defined by a complicated function, which is based on the age of the forest in years. The forest is periodically cut down every <code>r</code> years, and restarts growth at year 1 (felling is assumed to be instantaneous). The model begins in year <code>r</code> (a standing forest)</p>
<p>if <code>r = 50</code> and the limit of the modelled timescales (<code>limit</code>) <code>=500</code> the following code will return a list of values from 1 to r which cycles until it exceeds the limit, it is then truncated to remove any values beyond <code>limit</code></p>
<pre><code>r = 50
limit = 500

x = list(range(1,r+1)) #produces a list from 1-r
x = x*(int(limit/r)+1) #multiples the list to be bigger than limit (to capture values of r which don't divide into it evenly (no floats allowed)
x2 = [r] #adds the first value of the list (r)
x2 = x2+x #adds the multiplied list to X2
x2 = x2[0:limit] #truncates the list to (limit)
</code></pre>
<p>This code works, but it seems like an unnecessarily cumbersome way of going about things. Can anybody suggest a more elegant solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>Such cyclic repetitions are elegantly replicated with <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle</code></a>:</p>
<pre><code>from itertools import cycle, islice

x = cycle(range(1,r+1))
next(islice(x, r-1, r-1), None)    # advance cycle object to 50 for first entry
x2 = list(islice(x, 0, limit))     # slice up to desired limit
</code></pre>
<p>You could skip the advancement part and just factor it into the final slicing step so slicing starts at <code>r-1</code> and ends at <code>limit+r-1</code>:</p>
<pre><code>from itertools import cycle, islice

x = cycle(range(1,r+1))
x2 = list(islice(x, r-1, limit+r-1)) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use below code:</p>
<pre><code>r =50
limit = 500
x2 = [50]
for i in range(int(limit/r)):
    x2 = x2 + list(range(1,r+1))

del x2[-1]
</code></pre>
</div>
<span class="comment-copy">I don't think this code is doing what you think it is? At the end of running, you have a list of 500 ints- I would have thought from the question that there are 50 trees? Have I misunderstood your question?</span>
<span class="comment-copy">yes, the list gives you the age of the trees over time (so between 1 and 50) I can then use it to calculate the volume of the forest based on the age, which I can use as a y axis on a graph with absolute age as x (1 to 500). Does this make sense?</span>
<span class="comment-copy">Apologies, I interpreted that you may want to iterate through the list and modify the values of each of the elements.  So you want [50, 1,....50, 1, ..... 50, 1, .... 50 etc]?  If this is what you want then yes, the code could be simplified by a few lines, but it may be less readable, but not significantly more efficient?  Readability is good imho.</span>
<span class="comment-copy">I have run this and put in as comments the data you wanted. If you can confirm that the data output is correct, I can create a function to do the work and reduce the number of lines of code needed, if you wish.  Look here: <a href="https://trinket.io/python3/3c834e1891" rel="nofollow noreferrer">trinket.io/python3/3c834e1891</a></span>
<span class="comment-copy">That's right, though I don't need it in a function, as I only need to run it once at the start of the model. Thanks anyway</span>
<span class="comment-copy">Quite inefficient, <code>limit/r</code> list contenatations.</span>
<span class="comment-copy">didnt get u? could u elaborate? r  and limit are just integers.</span>
<span class="comment-copy">I think it is in relation to calculating the (limit/r) value as in python 3 the range function uses an iterator. When you're using an iterator, every loop of the for statement produces the next number on the fly, so the calc is being done many times- under the hood.  This is different from the range function in Python 2.x.</span>
<span class="comment-copy">I meant the number of concatenations makes this quite inefficient.</span>
