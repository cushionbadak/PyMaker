<div class="post-text" itemprop="text">
<p>I'm having some trouble in my program to back and forth between routines within a loop.</p>
<p>Each routine turns on some LEDs for a specific time in a certain order constantly looping, they vary in time and order in each routine. What I have developed so far is a state to determine which routine should be running. For each routine, I have a button that will assign the value to that state. However, I'm not quite achieving this as my buttons to trigger the other routines while one is already running don't stop the current one running an initiate the one selected.</p>
<p>I suppose what I need to know is: <strong><em>How to have a button that can assign the state at any given time throughout the loop?</em></strong> I'd like a routine to start whenever I push the button rather than wait for the current loop to end, like interrupting a sequence to start another. </p>
<p>I don't want to break the loops, I would like to go back and forth between routines.</p>
<p>In short, the program so far is basically:</p>
<pre><code> state= 0

 while True: #routine 1

        if(GPIO.input(4) == True):

            state = 1    

        if state == 1:
            stop current loop
            Run first loop

        if(GPIO.input(17) == True):
            state = 2

        if state == 2:
            stop current loop
            Run second loop

        if(GPIO.input(21) == True):
            stop current loop
            state = 3

        if state == 3:
            Run third loop
etc
</code></pre>
<p>This is my current Code:</p>
<pre><code>import RPi.GPIO as GPIO

import time

GPIO.setmode(GPIO.BCM)
GPIO.setup(16, GPIO.OUT, initial=GPIO.LOW)
GPIO.setup(21, GPIO.OUT, initial=GPIO.LOW)
GPIO.setup(25, GPIO.OUT, initial=GPIO.LOW)
GPIO.setup(4, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(17, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.output(25, False) #determines initial state
GPIO.output(16, False)
GPIO.output(21, False)

state = 0

while True: #Routine 1

    if(GPIO.input(4) == True):
      state = 1


    if state == 1:
        print("Return SOL")
        GPIO.output(25, True)  #greenlight to send signal
        time.sleep(10) #time signal stays on
        print("Advance Sol")
        GPIO.output(25, False) #signal off
        GPIO.output(16, True) 
        time.sleep(2)
        GPIO.output(16, False)
        print("Read switch")
        GPIO.output(21, True)
        time.sleep(6)
        GPIO.output(21, False)
        print ("Advance Sol")
        GPIO.output(16, True)
        time.sleep(15)
        GPIO.output(16, False)
        print("Cycle Complete")
        print (state)

    if(GPIO.input(17) == True):
        state = 2

    if state == 2:
        print("starting routine 2")
        #code body here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an example that doesn't block execution by using <code>sleep</code>:</p>
<pre><code>start_time = time.time()
state = 0
def set_state(state_number):
    """reset timer and change state variable"""
    start_time = time.time()
    state = state_number

def wait_state(duration, next_state):
    """Transition to next_state after duration is exceeded"""
    if time.time() - start_time &gt; duration:
        start_state(0)

while True:
    # All button presses first
    if(GPIO.input(4) == True:
        set_state(100)
    elif GPIO.input(17) == True
        set_state(200)
    elif GPIO.input(21) == True
        set_state(300)
    else:  # no state execution whilst button is held
        if state == 100:
            print("Return SOL")
            GPIO.output(25, True)  #greenlight to send signal
            set_state(101)
        elif state == 101:
            wait_state(10, 102)  # wait ten seconds before changing to state 102
        elif state == 102:
            print("Advance Sol")
            GPIO.output(25, False) #signal off
            GPIO.output(16, True)
            set_state(103)
        elif state == 103:
            wait_state(2, 104)
        elif state == 104:
            GPIO.output(16, False)
            print("Read switch")
            GPIO.output(21, True)
            set_state(105)
        elif state == 105:
            wait_state(6, 106)
        elif state == 106:
            GPIO.output(21, False)
            print ("Advance Sol")
            GPIO.output(16, True)
            set_state(107)
        elif state == 107:
            wait_state(15, 108)
        elif state == 108:
            GPIO.output(16, False)
            print("Cycle Complete")
            print (state)       
        else:
            print("Unhandled State", state)
</code></pre>
<p>Let me know if you have any questions.</p>
</div>
<span class="comment-copy">Yes, there is a question: "how to have a button that can assign the state at any given time throughout the loop?" I'll highlight it for you.</span>
<span class="comment-copy">Sorry for not sounding too specific. I'm just wondering what exactly do I need in order for the routine triggers to work. Currently, when I press the buttons assigned to each routine, they go by ignored rather than starting the routine they're assigned to.   Is there a different way to go about this in order for it to work?</span>
<span class="comment-copy">A job for <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a>?</span>
<span class="comment-copy">Can more than one button be pushed? Is there a hierarchy- do some buttons have precedence over others? does <code>GPIO</code> have a <i>generic</i> <i>input_state_change</i> method?</span>
<span class="comment-copy">@Eric I'll show you my code so far to give you better insight of what happens, I'll edit it in the original post. :)</span>
<span class="comment-copy">Thanks! I was already looking into that method when you suggested to use a non blocking loop. I saw a thread on using time.time to count a duration of a loop, I was just in the middle of figuring out a method to use that to trigger these actions, although I had some complications- which have been cleared up by the example you showed.   I was also Studying up the method Lawrence suggested by multithread using co-routines. I'll try to implement your suggestion into my code and test it. Thank you very much for your time and explanation! Much appreciated!</span>
