<div class="post-text" itemprop="text">
<p>I'm trying to get html code from the QWebEnginePage object. According to Qt reference, QWebEnginePage object's 'toHtml' is asynchronous method as below.</p>
<blockquote>
<p><strong>Asynchronous</strong> method to retrieve the page's content as HTML, enclosed in HTML and BODY tags. Upon successful completion, resultCallback is called with the page's content.</p>
</blockquote>
<p>so I tried to find out how call this method synchronously.</p>
<p>the result what i want to get is below.</p>
<pre><code>class MainWindow(QWidget):
  html = None
  ...
  ...
  def store_html(self, data):
    self.html = data

  def get_html(self):
    current_page = self.web_view.page()
    current_page.toHtml(self.store_html)
    # I want to wait until the 'store_html' method is finished
    # but the 'toHtml' is called asynchronously, return None when try to return self.html value like below.
    return self.html 
  ...
  ...
</code></pre>
<p>Thanks for reading this. </p>
<p>Have a good day you all.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple way to get that behavior is to use <a href="http://doc.qt.io/qt-5/qeventloop.html" rel="nofollow noreferrer"><code>QEventLoop()</code></a>. An object of this class prevents the code that is after <code>exec_()</code> from being executed, this does not mean that the GUI does not continue working.</p>
<pre><code>class Widget(QWidget):
    toHtmlFinished = pyqtSignal()

    def __init__(self, *args, **kwargs):
        QWidget.__init__(self, *args, **kwargs)
        self.setLayout(QVBoxLayout())
        self.web_view = QWebEngineView(self)
        self.web_view.load(QUrl("http://doc.qt.io/qt-5/qeventloop.html"))
        btn = QPushButton("Get HTML", self)
        self.layout().addWidget(self.web_view)
        self.layout().addWidget(btn)
        btn.clicked.connect(self.get_html)
        self.html = ""

    def store_html(self, html):
        self.html = html
        self.toHtmlFinished.emit()

    def get_html(self):
        current_page = self.web_view.page()
        current_page.toHtml(self.store_html)
        loop = QEventLoop()
        self.toHtmlFinished.connect(loop.quit)
        loop.exec_()
        print(self.html)


if __name__ == '__main__':
    import sys
    app = QApplication(sys.argv)
    w = Widget()
    w.show()
    sys.exit(app.exec_())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a multiprocessing.Connection object created as one side of a multiprocessing.Pipe's send method as the call back and then use the other end of the pipe's recv method immediately after.  Recv will block until the html is received, so keep that in mind</p>
<p>example: </p>
<pre><code>from multiprocessing import Pipe

class MainWindow(QWidget):
    def __init__(...):
        ...
        self.from_loopback,self.to_loopback=Pipe(False)

    def get_html(self):
        current_page = self.web_view.page()
        current_page.toHtml(self.to_loopback.send)
        return self.from_loopback.recv() 
</code></pre>
</div>
<span class="comment-copy">It's unclear why you'd want this. QWebEngine is based on Blink, which runs a separate process for web content (just like most modern browsers.) Since the IPC call between the processes may take time, QWebEngine asks you to define a callback function so your main process' event loop can continue while the IPC call completes. So without knowing the justification for this question it would be a stab in the dark to provide the best possible answer.</span>
<span class="comment-copy">@MrEricSir I didn't know about the QWebEngine is base on Blink framework. I just wanted to transform the web view screen's contents after html response delievered using some buttons what i created. thank you for your answering.</span>
<span class="comment-copy">Thank you so much. your answer is very helpful to me. have a good day!</span>
<span class="comment-copy">Interesting perspective, could show an example.</span>
<span class="comment-copy">Never put code in the comments, edit your question and put it there :)</span>
<span class="comment-copy">I see that now, but that's kind of dumb.  It breaks up the flow of the conversation</span>
<span class="comment-copy">by the way, here's the docs on multiprocessing.Pipe:  <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Pipe" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a> <a href="https://docs.python.org/3/library/multiprocessing.html#pipes-and-queues" rel="nofollow noreferrer">docs.python.org/3/library/multiprocessing.html#pipes-and-queues</a></span>
<span class="comment-copy">My idea is not to talk, the comments are not useful for that, they serve to point out the problems and the improvements of the answer or question.  :)</span>
