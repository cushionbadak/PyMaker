<div class="post-text" itemprop="text">
<p>I have two dataframes, and I want to create a filtered df_1 based on the timestamp index of df_2, shown below. For each index value of df_2, I want to take all the rows of df_1 that is within timedelta of 1 day of df_2 index value. </p>
<p>Example: for df_2 index value <code>10/15/2017</code>, I want to include in the new df_outcome, all the rows of df_1 that are between <code>10/14/2017</code> to <code>10/16/2017</code>, which returns <code>10/14/2017  f</code> and <code>10/15/2017  g</code>. Any duplicates from the query are removed.</p>
<pre><code>df_1    
Index   Values
10/2/2017   a
10/4/2017   b
10/5/2017   c
10/7/2017   d
10/9/2017   e
10/14/2017  f
10/15/2017  g
10/20/2017  h


df_2    
Index   Values
10/4/2017   Apple
10/6/2017   Banana
10/13/2017  Pear
10/15/2017  Pineapple


df_outcome  
Index   Values
10/4/2017   b
10/5/2017   c
10/7/2017   d
10/14/2017  f
10/15/2017  g
</code></pre>
<p>Any help is appreciated, thanks.</p>
<p>EDIT:</p>
<p>I edited to change the index to timestamps, to reflect the actual problem. I'm so sorry for any confusion I did not anticipate it would be a problem. The timestamps are uneven.</p>
</div>
<div class="post-text" itemprop="text">
<p>The following indexer should do the trick on datetimes:</p>
<pre><code>threshold = pd.Timedelta('1 hour')

indexer = pd.Series(df1.index, index=df1.index).apply(
  lambda x: min(abs(x - df2.index)) &lt; threshold
)

df1.loc[indexer] 
</code></pre>
<p>Note: It doesn't scale well. It starts to take seconds if <code>len(df1) * len(df2)</code> ~ 10<sup>6</sup></p>
</div>
<div class="post-text" itemprop="text">
<h2>Answer to updated question</h2>
<p>The new answer is based on the orignal one while using sets to identify valid indices:</p>
<pre><code># convert strings to timestamps if not done already
df_1.index = pd.to_datetime(df_1.index)
df_2.index = pd.to_datetime(df_2.index)

# helper function to extract days since epoch
def extract_days_since_epoch(timeseries):
    epoch_start = pd.datetime(1970, 1, 1)
    return (timeseries - epoch_start).days

# get indices as days
index_1_days = extract_days_since_epoch(df_1.index)
index_2_days = extract_days_since_epoch(df_2.index)

threshold = 1
ranges = [range(x-threshold, x+threshold+1) for x in index_2_days]
allowed_indices = {value for sub_range in ranges 
                         for value in sub_range}

# get intersection of allowed and present indicies
valid_indices = allowed_indices.intersection(index_1_days)

# use assign, query and drop to filter matches
df_1.assign(days=index_1_days)\
    .query("days in @valid_indices")\
    .drop(["days"], axis=1) 

            Values
Index   
2017-10-04  b
2017-10-05  c
2017-10-07  d
2017-10-14  f
2017-10-15  g
</code></pre>
<h2>Answer to original question</h2>
<p>You can use pandas <code>Index</code>'s set operations for this purpose. First, create a set of allowed indices using list and <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">set comprehensions</a>. Second, get the <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Index.intersection.html" rel="nofollow noreferrer">intersection</a> of allowed and present indices. Last, use the valid indices to <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.reindex.html" rel="nofollow noreferrer">reindex</a> your target dataframe.:</p>
<pre><code># define threshold range to include values from df2
threshold = 10

# create set of allowed indices via set comprehension
ranges = [range(x-threshold, x+threshold+1) for x in df_2.index]
allowed_indices = {value for sub_range in ranges for value in sub_range}

# get intersection of allowed and present indicies
valid_indices = df_1.index.intersection(allowed_indices)

# use reindex with valid indices
df_result = df_1.reindex(valid_indices)

print(df_result)

    Values
10  a
20  b
30  c
40  d
70  g
80  h
</code></pre>
</div>
<span class="comment-copy">Is there a way to make it faster? My dataset is quite huge</span>
<span class="comment-copy">Thanks, what if the indices were timestamps? When I try your method I get 'Timestamp' object cannot be interpreted as an integer</span>
<span class="comment-copy">@A1122 Well, that's a different requirement. You have to either convert Timestamps to integers (seconds or whatever unit you need) or use <code>pd.Timedelta</code> as the range threshold. However, using the second approach, you will need to ensure that all timestamps share the same frequency.</span>
<span class="comment-copy">I'm going to try the first approach you mentioned</span>
<span class="comment-copy">@A1122 I updated the answer accordingly.</span>
<span class="comment-copy">Thank you. Side question - instead of seconds since epoch, is there a way to extract for microseconds/nanoseconds?</span>
