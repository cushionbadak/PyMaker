<div class="post-text" itemprop="text">
<p>I'm converting values to float from multiple columns in a dataset concurrently in a loop, where I try to skip bad rows with a ValueError exception</p>
<p>My data has been loaded with a structure that enables me to loop over it as such</p>
<pre><code>A_floated = []
B_floated = []

for i in range(len(data)):

    A = data[i]["column_A"]
    B = data[i]["column_B"]

    try:
        A = float(A)
        A_floated.append(A)

        B = float(B)
        B_floated.append(B)

    except(ValueError):
        continue
</code></pre>
<p>I want the exception to encompass both A and B, so that if <em>any</em> of them contains a bad row, all of them will be skipped for this i, so that <code>len(A_floated) == len(B_floated)</code>. Right now, I can only figure out how to skip bad rows on an individual-column basis, but then I end up with floated columns of different lengths.</p>
<p>How can this be done?</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand you correctly, you want to gather 'good' (floated) rows in data structures <code>A_floated</code> and <code>B_floated</code> respectively during iteration through <code>data</code>. If so, try putting the former data structures outside the loop, and check whether values can be converted into floats <em>before</em> putting them into lists. Otherwise, value A may be convertible while value B not, which would result in different lengths of <code>A_floated</code> and <code>B_floated</code>. To sum it up, try the following code:</p>
<pre><code>A_floated = []
B_floated = []

for i in range(len(data)):

    A = data[i]["column_A"]
    B = data[i]["column_B"]

    try:
        # "floatability" check.
        A = float(A)
        B = float(B)

        # If both values can be converted into a float,
        # put them into the respective lists.
        A_floated.append(A)
        B_floated.append(B)

    except(ValueError):
        continue
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use can use the <a href="https://docs.python.org/3/reference/compound_stmts.html#the-try-statement" rel="nofollow noreferrer"><code>else</code> clause</a> which runs if no exception occurs. <code>try</code> and convert, don't do any appending there and, if no errors occur, you append in the <code>else</code> clause:</p>
<pre><code>try:
    A = float(A)
    B = float(B)
except ValueError:
    continue
else:
    A_floated.append(A)
    B_floated.append(B)
</code></pre>
<p>I removed the parentheses around the <code>ValueError</code> since they aren't necessary.</p>
</div>
<span class="comment-copy">Oops, I forgot to put the empty lists outside of the loop while I wrote the example! Sorry for the blunder.</span>
<span class="comment-copy">Also, I didn't know that both of the float checks needed to be called first before appending, and that it would be different from a try block with a potential error <i>somewhere</i> inside. Thanks.</span>
