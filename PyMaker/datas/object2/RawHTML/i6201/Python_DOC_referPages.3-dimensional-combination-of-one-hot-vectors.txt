<div class="post-text" itemprop="text">
<p>I need to create a 3-dimensional list of all pairs of 3x1 one-hot vectors in python, but I'm having trouble generating the array.  I'm trying to do it using <code>np.arange</code>, but I haven't quite been able to get that working.  For example, my one-hot vectors are: <code>A=[1,0,0] B=[0,1,0] and C=[0,0,1]</code>.  The output I need is the three dimensional array <code>[[A,A],[A,B],[A,C],[B,A],[B,B],[B,C],[C,A],[C,B],[C,C]]</code> That is, a 9x2x3 array consisting of all combinations of pairs of one-hot vectors.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Approach #1</strong></p>
<p>Here's a NumPy way with mesh creation of those pairwise combinations of indices -</p>
<pre><code># Create input array from those vectors
a = np.array([A,B,C])
n = len(a)

# Create grid of indices
r,c = np.mgrid[:n,:n]

# Index for final output
out = a[np.c_[c.ravel().T,r.ravel()]]
</code></pre>
<p>Sample input, output -</p>
<pre><code>In [365]: A = [1,0,0]
     ...: B = [0,1,0]
     ...: C = [0,0,1]

In [367]: out
Out[367]: 
array([[[1, 0, 0],
        [1, 0, 0]],

       [[0, 1, 0],
        [1, 0, 0]],

       [[0, 0, 1],
        [1, 0, 0]],

       [[1, 0, 0],
        [0, 1, 0]],

       [[0, 1, 0],
        [0, 1, 0]],

       [[0, 0, 1],
        [0, 1, 0]],

       [[1, 0, 0],
        [0, 0, 1]],

       [[0, 1, 0],
        [0, 0, 1]],

       [[0, 0, 1],
        [0, 0, 1]]])
</code></pre>
<p><strong>Approach #2 (for performance)</strong></p>
<p>We can use the fact that the inputs are one-hot vectors to gain performance, specially for large number of vectors with greater lengths by initializing the output array and assigning ones into it. The trick to using the one-hotness is getting those one-value unique indices per vectors with <code>argmax</code>. We will use these indices to assign into output at only those specific places. The implementation would be -</p>
<pre><code>def multidim_hotvectors(a): # a is input list of vectors = [A,B,C]
    n = len(a)
    idx = np.array([np.argmax(i) for i in a])
    putval = (idx[:,None] == np.arange(n)).astype(int)
    out = np.zeros((n,n,2,n),dtype=int)
    out[:,:,0,:] = putval[:,None,:]
    out[:,:,1,:] = putval
    out.shape = (n**2,2,-1)
    return out
</code></pre>
<h3>Runtime test</h3>
<p>Other approaches for <code>a = [A,B,C]</code> -</p>
<pre><code># @Engineero's soln
np.array([c for c in itertools.product(a, repeat=2)])

# @B. M.'s soln
np.array(list(itertools.product(a,a)))
</code></pre>
<p>Function to setup input list of one-hot vectors -</p>
<pre><code>def create_input_list_vectors(L):
    d = (np.random.choice(L,L,replace=0)[:,None] == range(L)).astype(int)
    return list(map(list,d))
</code></pre>
<p>Timings -</p>
<pre><code>In [359]: a = create_input_list_vectors(L=5)

In [360]: %timeit np.array([c for c in itertools.product(a, repeat=2)])
     ...: %timeit np.array(list(itertools.product(a,a)))
     ...: %timeit multidim_hotvectors(a)
10000 loops, best of 3: 29.4 µs per loop
10000 loops, best of 3: 27.8 µs per loop
10000 loops, best of 3: 30.5 µs per loop

In [361]: a = create_input_list_vectors(L=20)

In [362]: %timeit np.array([c for c in itertools.product(a, repeat=2)])
     ...: %timeit np.array(list(itertools.product(a,a)))
     ...: %timeit multidim_hotvectors(a)
1000 loops, best of 3: 966 µs per loop
1000 loops, best of 3: 967 µs per loop
10000 loops, best of 3: 125 µs per loop

In [363]: a = create_input_list_vectors(L=100)

In [364]: %timeit np.array([c for c in itertools.product(a, repeat=2)])
     ...: %timeit np.array(list(itertools.product(a,a)))
     ...: %timeit multidim_hotvectors(a)
10 loops, best of 3: 98.6 ms per loop
10 loops, best of 3: 98.1 ms per loop
100 loops, best of 3: 3.94 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a>:</p>
<pre><code>import itertools as it
combos = [c for c in it.product([A, B, C], repeat=2)]
# combos = [([1, 0, 0], [1, 0, 0]),
#           ([1, 0, 0], [0, 1, 0]),
#           ([1, 0, 0], [0, 0, 1]),
#           ([0, 1, 0], [1, 0, 0]),
#           ([0, 1, 0], [0, 1, 0]),
#           ([0, 1, 0], [0, 0, 1]),
#           ([0, 0, 1], [1, 0, 0]),
#           ([0, 0, 1], [0, 1, 0]),
#           ([0, 0, 1], [0, 0, 1])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it with itertools  :</p>
<pre><code>A,B,C=np.eye(3,dtype=int)
import itertools 
l=list(itertools.product((A,B,C),(A,B,C)))
a923=np.array(l)
</code></pre>
<p>or directly in numpy :</p>
<pre><code>points=np.array([
[1,0,0],
[0,1,0],
[0,0,1]])
n,dim=points.shape
indices=np.indices((n,n))

# indice.T :
# array([[[0, 0],
#         [1, 0],
#         [2, 0]],
# 
#        [[0, 1],
#         [1, 1],
#         [2, 1]],
# 
#        [[0, 2],
#         [1, 2],
#         [2, 2]]])

res = points[indices.T].reshape(n*n,2,dim) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As I am unfamiliar with numpy here is a one/two liner solution.</p>
<p>To make it easy we will take <code>A='a'</code>, <code>B='b'</code> and <code>C='c'</code></p>
<p>Given all your 'hot vector' (not sure what they are but anyway) are stored in one vector:</p>
<pre><code>&gt;&gt;&gt; options = [A,B,C]
&gt;&gt;&gt; result = [x,y for x in options for y in options]
&gt;&gt;&gt; print(result)
[['a', 'a'], ['b', 'a'], ['c', 'a'],
 ['a', 'b'], ['b', 'b'], ['c', 'b'],
 ['a', 'c'], ['b', 'c'], ['c', 'c']]
</code></pre>
<p><em>Note the newlines in the print result are to make it fit in the screen</em> </p>
</div>
<span class="comment-copy">If I use a generic set, say : <code>A = [0,1,0] ; B = [1,0,0]; C = [0,0,1]</code>, the output seems different from the expected one for the second one. Check again?</span>
<span class="comment-copy">yes order change, but all pairs seems to be there.</span>
