<div class="post-text" itemprop="text">
<p>In most posts, people often say <code>type</code> is a built-in function if it is provided with one argument, and it is a metaclass if provided with 3 arguments.</p>
<p>But in <a href="https://docs.python.org/3/library/functions.html?highlight=type#type" rel="nofollow noreferrer">python's doc</a>, the signature of <code>type</code> is:</p>
<pre><code>class type(object)
class type(name, bases, dict)
</code></pre>
<p>So, does it means <code>type</code> is a built-in class and not a built-in function even if it is provided with one argument? </p>
</div>
<div class="post-text" itemprop="text">
<p><code>type</code> is called a "metaclass" because it's a class that produces other classes (AKA types). It behaves like a normal class. In particular, it has the equivalent of a <code>__new__</code> method that would look something like this in Python:</p>
<pre><code>class type(object):

    def __new__(cls, *args):
        num_args = len(args)

        if num_args not in (1, 3):
            raise TypeError('type() takes 1 or 3 arguments')

        # type(x)
        if num_args == 1:
            return args[0].__class__

        # type(name, bases, dict)
        name, bases, attributes = args
        bases = bases or (object,)

        class Type(*bases):
            pass

        Type.__name__ = name

        qualpath = Type.__qualname__.rsplit('.', 1)[0]
        Type.__qualname__ = '.'.join((qualpath, name))

        for name, value in attributes.items():
            setattr(Type, name, value)

        return Type

Class = type('Class', (), {'i': 1})
instance = Class()

print(type(instance))  # -&gt; Class
print(instance.__class__)  # -&gt; Class
print(type(type(instance)))  # -&gt; type
print(Class.i)  # -&gt; 1
print(instance.i)  # -&gt; 1
</code></pre>
<p>Note that when instantiating a class, the value of the new instance is whatever is returned from <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a>. In the case of <code>type</code>, <code>__new__</code> always returns a type object (AKA class). Here's an example of a class that extends <code>int</code> to use <code>-1</code> as the default value instead of <code>0</code>:</p>
<pre><code>def Int__new__(cls, *args):
    if not args:
        return cls(-1)
    return super(cls, cls).__new__(cls, *args)

Int = type('Int', (int,), {'__new__': Int__new__})

i = Int()
print(type(i))  # -&gt; Int
print(i.__class__)  # -&gt; Int
print(type(type(i)))  # -&gt; type
print(i)  # -&gt; -1

j = Int(1)
print(j)  # -&gt; 1
</code></pre>
<p>To really dig into how <code>type</code> works, take a look at <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c#L2326" rel="nofollow noreferrer">the C code in <code>type_new</code></a>. You can see there (scroll down a few lines) that <code>type(x)</code> is a special case that immediately returns the type (AKA class) of <code>x</code>. When you do <code>type(name, bases, dict)</code>, the type creation machinery is invoked.</p>
<p>For more fun, try the following:</p>
<pre><code>type(object)
type(type)
isinstance(object, object)
isinstance(type, object)
type(1)
type(type(1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The built-in <code>type</code> always returns a <em>type object</em>, which is basically a class.  That's true whether it's the one-argument form or the three-argument form.  In the one-argument case, the returned object is the <em>type</em> (class) of the argument.  In the three argument case, the returned object is a new <em>type object</em> (class).  In both cases the returned object can be used to instantiate new objects (instances of the class).</p>
<p>Some classes can be used as metaclasses.  That's a common use case for the three-argument form of <code>type</code>.  But there are other ways to make a class that can be used as a metaclass, and other uses for the three-argument form of <code>type</code>.</p>
<p>It's not that much different from <code>int</code>, which is a built-in function that returns an object of type <code>int</code>.  <code>int</code> is also the name of a class, and can be used to create new objects:</p>
<pre><code>&gt;&gt;&gt; x = int()
&gt;&gt;&gt; x
0
&gt;&gt;&gt; type(x)
&lt;class 'int'&gt;
</code></pre>
<p>And also like type, it has more than one form:</p>
<pre><code>&gt;&gt;&gt; y = int("A", 16)
&gt;&gt;&gt; y
10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The distinction between classes and functions in Python is not as stark as in other languages.</p>
<p>You can use function call syntax to invoke an actual function, but also an instance of a class with the <code>__call__</code> method, and even a class that overrides <code>__new__</code> can behave like a function.</p>
<p>The word Python uses for all these is <strong>callable</strong>: an object you can invoke using the call syntax (<code>foo()</code>), which evaluates to a result.</p>
<p>The <code>type</code> built-in is a <code>callable</code>. It can be called.</p>
<p>Sometimes you treat <code>type</code> like a function, and it works, so you can say it's a function. Other times you treat it like a class, so you can say it's a class. The actual implementation should not matter.</p>
<p>This is duck typing in action: <a href="https://en.wikipedia.org/wiki/Duck_typing" rel="nofollow noreferrer">if it walks like a duck, and it quacks like a duck, then it must be a duck</a>.</p>
</div>
<span class="comment-copy">Well, it can’t be both – but it acts like a function when passed one argument.</span>
<span class="comment-copy">I think it should be your answer: <a href="https://docs.python.org/3/library/stdtypes.html#bltin-type-objects" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#bltin-type-objects</a></span>
<span class="comment-copy"><code>type</code> is not a keyword.  Examples of keywords are <code>for</code>, <code>in</code>, or <code>as</code>.  You can't name a variable <code>for</code> but you can name a variable <code>type</code> (legal but strongly not recommended!).</span>
<span class="comment-copy">All classes are callable whether they override <code>__new__</code> or not.  The question is regarding the built-in <code>type</code>.  Duck typing is the principle of classifying an object by its behavior rather than by inheritance.  Not related.</span>
