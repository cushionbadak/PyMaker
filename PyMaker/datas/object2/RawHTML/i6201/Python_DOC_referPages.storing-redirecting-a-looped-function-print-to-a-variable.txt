<div class="post-text" itemprop="text">
<p>So I have two python scripts, one of which is calling a function in the other:</p>
<p>First (first.py):</p>
<pre><code>def get_values(number):

   ....

   for x in range(number):
        print x
</code></pre>
<p>Second (second.py):</p>
<pre><code>import first

....

data = first.get_values(10)
</code></pre>
<p>My goal is to save the output from <em>get_value</em> in <em>first.py</em> to save to the variable <em>data</em> as a list (i.e. [0, 1, 2, 3, ...]). Is there any possible way to do this, without printing these values in the process?</p>
<p>Thanks in advance!</p>
<p>EDIT: I can't alter <em>first.py</em>, due to other functions already relying on it's current output.</p>
</div>
<div class="post-text" itemprop="text">
<p>Redirect your output to an io stream and then read that afterward (Python 3.5). </p>
<pre><code>import sys
import io
stdout = sys.stdout  # keep a handle on the real standard output
local_i = io.StringIO()
sys.stdout = local_i  # Choose a file-like object to write to
for i in range(10): # this is just an example, you have to call your function here from first.py
    print(i)
sys.stdout = stdout# revert to standard output

print("This printing is after the function call. You can process it as you want. This is just for demonstration purpose.")

for i in local_i.getvalue():
    if i != '\n':
        print(int(i))
</code></pre>
<p>For Python 2:</p>
<pre><code>import sys
import StringIO
stdout = sys.stdout  # keep a handle on the real standard output
local_i = StringIO.StringIO()
sys.stdout = local_i  # Choose a file-like object to write to
for i in range(10):
    print(i)
sys.stdout = stdout# revert to standard output

print(
    "This printing is after the function call. You can process it as you want. This is just for demonstration purpose")

for i in local_i.getvalue():
    if i != '\n':
        print(int(i))
</code></pre>
<p>Output: </p>
<pre><code>This printing is after the function call. You can process it as you want. This is just for demonstration purpose.
0
1
2
3
4
5
6
7
8
9
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can grab stdout using <a href="https://docs.python.org/3/library/contextlib.html#contextlib.redirect_stdout" rel="nofollow noreferrer">redirect_stdout</a>:</p>
<pre><code>#!/usr/bin/env python

import io
# if python3
# from contextlib import redirect_stdout
# if python2
import sys
from contextlib import contextmanager

# Note: I took this method from someone else's SO answer, but I think
#       they took it from someone else...etc.
@contextmanager
def redirect_stdout(new_target):
    old_target, sys.stdout = sys.stdout, new_target # replace sys.stdout
    try:
        yield new_target # run some code with the replaced stdout
    finally:
        sys.stdout = old_target # restore to the previous value

def get_values(number):
    values = tuple(range(number))
    for v in values:
        print(v)
    return values


def main():
    saved_stdout = io.StringIO()
    with redirect_stdout(saved_stdout):
        data = get_values(4)
    print(data)

    data = get_values(2)
    print(data)


main()
</code></pre>
<p>Output:</p>
<pre><code>$ python stdout.py 
(0, 1, 2, 3)
0
1
(0, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In first.py create a list like:</p>
<pre><code>def get_values(number):
    ....
    return [x for x in range(number)]
</code></pre>
<p>then in second.py you can do</p>
<pre><code>data = first.get_values(10)
</code></pre>
</div>
<span class="comment-copy">So is the print function the only output of first.py?</span>
<span class="comment-copy">@PaulaLivingstone Yes it is. The script first.py was originally used for a another purpose (it's stdout was being piped to another script's stdin), but I'm trying to recycle it so I can use it with second.py in this example. Which is why I can't alter first.py to make this work.</span>
<span class="comment-copy">I'm using python 2.7 -- is this still valid?</span>
<span class="comment-copy">@Jeff yes but you have to change two lines of code as iostream is different in 2 and 3. See my updated answer.</span>
<span class="comment-copy">Thanks for your help!</span>
<span class="comment-copy">Does redirect_stdout work with Python 2.7?</span>
<span class="comment-copy">It does now. :)  (Note: after my edit above)</span>
<span class="comment-copy">Thanks for your help!</span>
<span class="comment-copy">you forgot <code>range()</code></span>
<span class="comment-copy">I should've added this as well; I'm not allowed to alter first.py in any way.</span>
<span class="comment-copy">@Chris_Rands Edited, thanks!</span>
