<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/12423614/local-variables-in-nested-functions">Local variables in nested functions</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<h1>Edit/solution</h1>
<p>Here's an example that more closely mimics my real problem, and a solution implementing the comment by <a href="https://stackoverflow.com/users/3001761/jonrsharpe">jonrsharpe</a>. Thanks!</p>
<pre><code>import io
import heapq


# THIS DOES NOT WORK AS INTENDED
files = dict(f0=io.StringIO("first line\nsecond line"),
             f1=io.StringIO("FIRST LINE\nSECOND LINE"))
iterators = ((line.split() + [fname] for line in f)
             for fname, f in files.items())
list(heapq.merge(*iterators))
# [['FIRST', 'LINE', 'f0'],
#  ['SECOND', 'LINE', 'f0'],
#  ['first', 'line', 'f0'],
#  ['second', 'line', 'f0']]

# THIS DOES WORK
files = dict(f0=io.StringIO("first line\nsecond line"),
             f1=io.StringIO("FIRST LINE\nSECOND LINE"))
iterators = ((lambda x=fname: ((line.split() + [x]) for line in f))(fname)
             for fname, f in files.items())
list(heapq.merge(*iterators))
# [['FIRST', 'LINE', 'f1'],
#  ['SECOND', 'LINE', 'f1'],
#  ['first', 'line', 'f0'],
#  ['second', 'line', 'f0']]
</code></pre>
<h1>Original question</h1>
<p>How can I make the Python code below produce <code>[(1, 0), (1, 1)]</code> instead of <code>[(2, 0), (2, 1)]</code>? That is, I wish the result wasn't affected by changes to <code>const</code> made after the definition of the iterator <code>it</code>.</p>
<pre><code>&gt;&gt;&gt; const = 1
&gt;&gt;&gt; var = range(2)
&gt;&gt;&gt; it = ((const, i) for i in var)
&gt;&gt;&gt; const = 2
&gt;&gt;&gt; list(it)
[(2, 0), (2, 1)]
</code></pre>
<p>My real-world problem is to <a href="https://docs.python.org/3/library/heapq.html#heapq.merge" rel="nofollow noreferrer">heapq.merge</a> multiple files without keeping all their contents in memory. I'd like to programmatically generate iterators that report the file name together with each line of each file, e.g. <code>("file2.txt", "this is line 1")</code>. Currently, all my iterators end up reporting the same filename.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can move the generator expression from the module scope into a function, so the <code>const</code> value is read from the function scope and further changes to <code>const</code> do not influence the evaluation of the generator expression:</p>
<pre><code>def hide_gen(const):
    return ((const, i) for i in [0, 1])

const = 1
it = hide_gen(const)
const = 2
print(list(it))
# [(1, 0), (1, 1)]
</code></pre>
</div>
<span class="comment-copy">You could create a new temporary variable for it to capture instead: <code>tmp = const</code> then <code>it = ((tmp, i) for i in var)</code>.</span>
<span class="comment-copy">Or use a <code>lambda</code> to create a new scope with that value set: <code>it = (lambda x=const: ((x, i) for i in var))(const)</code></span>
<span class="comment-copy">So encapsulate the generator expression in a function? <code>const</code> is a closure, so yes, this is entirely expected. Generator expressions are no different from functions in this respect. Closures are 'live'.</span>
<span class="comment-copy">You should write an answer with a solution (and then accept it), not edit it into the question.</span>
<span class="comment-copy">@River, thanks for letting me know. However, I don't see any "Your Answer" box at the bottom. Could there be anything preventing me from answering, e.g. the [duplicate] tag?</span>
