<div class="post-text" itemprop="text">
<p>Peace, everyone!
I'm using Python 3.6.3 and I find strange that such construction is possible:</p>
<pre><code>class TestClass(object):
    def __init__(self):
        self.arg = "arg"

    def test():
        print("Hey test")
</code></pre>
<p>And using:</p>
<pre><code>&gt;&gt;&gt; TestClass.test()
"Hey test"
</code></pre>
<p>I know that in Python there are standard methods with <code>self</code> as parameter (don't know how to call them properly), static methods, class methods, abstract methods.</p>
<p>But what kind of method the <code>test()</code> is?
Is it static method?</p>
<hr/>
<p>Edited:</p>
<p>Are there any useful usecases of such method of determining a function inside a class?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, (unlike Python 2) a function accessed and called from the class is just another function; nothing special:</p>
<blockquote>
<p>Note that the <strong>transformation</strong> from function object to instance method
  object happens each time the attribute is retrieved from the instance.</p>
</blockquote>
<p>[<em>Emphasis mine</em>]</p>
<p>You just happened to be calling the function with the right set of parameters albeit accessed via the class object. Same as calling the underlying function object for the method via an instance:</p>
<pre><code>TestClass().test.__func__() # "Hey test"
</code></pre>
<p>A quick test explains it further:</p>
<pre><code>print(TestClass().test is TestClass.test)
# False
print(TestClass().test.__func__ is TestClass.test)
# True
</code></pre>
<p>However, in Python 2, the behaviour is different as the transformation from function object to method object happens when the attribute is accessed via both the class or instance:</p>
<blockquote>
<p>Note that the <strong>transformation</strong> from function object to (unbound or
  bound) method object happens each time the attribute is retrieved from
  the class or instance.</p>
</blockquote>
<p>[<em>Emphasis mine</em>]</p>
</div>
<div class="post-text" itemprop="text">
<p>Let me explain with an example:</p>
<pre><code>class TestClass(object):
  def __init__(self):
    self.arg = "arg"

  def test1():
    print("class method test1, Hey test")

  @classmethod
  def test2(cls):
    print("class method test2, Hey test")

  def test3(self):
    print("instance method test3, Hey test")
</code></pre>
<p>Look what happens when you call test1 with the class or with the instance:</p>
<p><strong>First:</strong></p>
<pre><code>  TestClass.test1() #called from class
class method test1, Hey test
   TestClass().test1() #created an instance TestClass()
Traceback (most recent call last):
  File "python", line 1, in &lt;module&gt;
TypeError: test1() takes 0 positional arguments but 1 was given
</code></pre>
<p>that's because when you create an instance, the <code>self</code> parameter is used, but here, the method has not the self parameter, that's why it brakes.</p>
<p><strong>next one!</strong></p>
<pre><code>   TestClass.test2()
class method test2, Hey test
   TestClass().test2()
class method test2, Hey test
</code></pre>
<p>That worked for instance and for class, why? well, as you can see test2(cls) take an argument, <code>cls</code>, here, I'm not using it, so, it's ok that it works.</p>
<p><strong>bring me the next subject, muajaja</strong></p>
<pre><code>  TestClass().test3()
instance method test3, Hey test
   TestClass.test3()
Traceback (most recent call last):
  File "python", line 1, in &lt;module&gt;
TypeError: test3() missing 1 required positional argument: 'self'
</code></pre>
<p>That's easy to see, when you call it as class, you haven't provided the self parameter</p>
</div>
<div class="post-text" itemprop="text">
<p>In python 3, there is no difference between a function and a function defined in a class:</p>
<pre><code>def test():
    print("Hey test")

class TestClass:
    def test():
        print("Hey test")

test() # works
TestClass.test() # also works
</code></pre>
<p>Both of these are normal functions.</p>
<p>The magic of the implicit <code>self</code> argument happens when you access a function through an <strong>instance</strong> of the class, like this:</p>
<pre><code>obj = TestClass()
obj.test() # throws an error because the test function doesn't accept arguments
</code></pre>
<p>This is when the <strong>function</strong> <code>test</code> is turned into the <strong>(bound) method</strong> <code>test</code>. You can see the difference if you print them:</p>
<pre><code>print(TestClass.test) 
print(instance.test)
# output:
# &lt;function TestClass.test at 0xaaaaaa&gt;
# &lt;bound method TestClass.test of &lt;__main__.TestClass object at 0xbbbbbb&gt;&gt;
</code></pre>
<p>To sum it up:</p>
<ul>
<li>Accessing a function through the class gives you the original function.</li>
<li>Accessing a function through an instance gives you a method with a bound <code>self</code> argument.</li>
</ul>
<hr/>
<p>For details about how exactly this conversion from function to bound method works, see <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">the descriptor how-to</a>, and specifically <a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="nofollow noreferrer">the section about functions</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 dispensed with the distinction between a bound and unbound method that existed in Python 2. What was previously an unbound method is now just a regular function.</p>
<pre><code>class A(object):
    def test():
        pass
</code></pre>
<p>In Python 2:</p>
<pre><code>&gt;&gt;&gt; A.test
&lt;unbound method A.test&gt;
</code></pre>
<p>whereas in Python 3:</p>
<pre><code>&gt;&gt;&gt; A.test
&lt;function A.test at 0x101cbbae8&gt;
</code></pre>
<p>(the address may differ)</p>
<p><code>test</code> here is a descriptor; you don't (necessarily) get back the original function object when you access <code>A.test</code>; instead you get the return value of that object's (i.e. the function's) <code>__get__</code> method, which is called with two arguments. Which arguments depends on whether you access it via the class or via an instance of a class.</p>
<ul>
<li><code>A.test</code> =&gt; <code>A.test.__get__(None, A)</code></li>
<li><code>a = A(); a.test</code> =&gt; <code>A.test.__get__(a, A)</code></li>
</ul>
<p>In Python 2, <code>A.test.__get__(None, A)</code> returns an <code>method</code> object, which is a wrapper around the original function. As an <em>unbound</em> <code>method</code>, the wrapper still expects an instance of <code>A</code> as its first argument, even though the function itself was not defined with any parameters.</p>
<p>In Python 3, however, <code>A.test.__get(None, A)</code> simply returns a reference to the original function, <em>not</em> a <code>method</code> object. As a result, you can use it exactly as you defined it in the first place.</p>
<p>You can confirm this by examining <code>id(A.__dict__['test'])</code> and <code>id(A.test)</code> in Python 2 and Python 3. In Python 2, you'll get two different values; in Python 3, you'll get the same value for each.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>TestClass.test()</code> call actually executes the <code>test()</code> on the <em>class</em> object. This is similar to a @staticmethod (a method that can be executed on the class object, without creating an object first).</p>
<pre><code>ins = TestClass()
ins.test()
</code></pre>
<p>will throw an exception, since <em>instance methods</em> pass <strong>self</strong> as the first argument, and test() takes no args.</p>
<p>When an object is created, the methods defined in the clas are <em>bound</em> to it. They are actually different objects, hence they have different ids:</p>
<pre><code>   id(TestClass.test)
=&gt; 140288592901800
   obj = TestClass()
   id(obj.test)
=&gt; 140288605765960
</code></pre>
<p>In Python 2.7, your code throws an exception which is self explantory:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;pyshell#404&gt;", line 1, in &lt;module&gt;
    TestClass.test()
TypeError: unbound method test() must be called with TestClass instance as 
first argument (got nothing instead)
</code></pre>
</div>
<span class="comment-copy">why do you find that code strange?</span>
<span class="comment-copy"><code>test</code> is a function taking no parameters and you're calling it without parameters. All good. Now, <code>TestClass().test()</code> OTOH is a different storyâ€¦</span>
<span class="comment-copy">Yes. It is very weird that it changed "Hey" to lowercase.</span>
<span class="comment-copy">Is the ambiguity of <code>self.test</code> a part of the question, or just a coincidence?</span>
<span class="comment-copy">@tobias_k sorry, it's just coincidence, i fix it</span>
<span class="comment-copy">@staticmethod may be called from instances of the class, but in my example it isn't possible</span>
<span class="comment-copy">That's because <i>when anything is called on an instance method</i>, the self part is passed automatically. If your function don't take any args, you simply can't execute it on an instance object.</span>
