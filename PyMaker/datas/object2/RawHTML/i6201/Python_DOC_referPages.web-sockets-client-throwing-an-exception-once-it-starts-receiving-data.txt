<div class="post-text" itemprop="text">
<p>I am trying to establish a Web-Socket connection to a server and enter into receive mode.Once the client starts receiving the data, it  immediately  closes the connection with below exception </p>
<pre><code>    webSoc_Received = await websocket.recv()
  File "/root/envname/lib/python3.6/site-packages/websockets/protocol.py", line 319, in recv
    raise ConnectionClosed(self.close_code, self.close_reason)
websockets.exceptions.ConnectionClosed: WebSocket connection is closed: code = 1007, no reason.
</code></pre>
<p>Client-side Code Snippet :</p>
<pre><code>import asyncio
import websockets

async def connect_ws():

    print("websockets.client module defines a simple WebSocket client API::::::")        
    async with websockets.client.connect(full_url,extra_headers=headers_conn1) as websocket:

        print ("starting")
        webSoc_Received = await websocket.recv()
        print ("Ending")
        Decode_data = zlib.decompress(webSoc_Received)      
        print(Decode_data)

asyncio.get_event_loop().run_until_complete(connect_ws())
</code></pre>
<p>Any thoughts on this? </p>
</div>
<div class="post-text" itemprop="text">
<p>You use <code>run_until_complete()</code> which completes once you started process.<br/> Instead, you should use <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_forever" rel="nofollow noreferrer"><code>.run_forever()</code></a>. It will keep your socket open, until you close it. <br/>
<strong>EDIT</strong>:<br/>
You can do something like this:</p>
<pre><code>loop = asyncio.get_event_loop()
loop.call_soon(connect_ws)  # Calls connect_ws once the event loop starts
loop.run_forever()
</code></pre>
<p>Or:</p>
<pre><code>loop = asyncio.get_event_loop()
loop.run_until_complete(connect_ws())
loop.run_forever()
</code></pre>
<p>Or if previous examples didn't succeed, you can try with following code:</p>
<pre><code>import asyncio

@asyncio.coroutine
def periodic():
  while True:
    print("websockets.client module defines a simple WebSocket client API::::::")        
    with websockets.client.connect(full_url,extra_headers=headers_conn1) as websocket:
       print ("starting")
       webSoc_Received = websocket.recv()
       print ("Ending")
       Decode_data = zlib.decompress(webSoc_Received)      
       print(Decode_data)

def stop():
  task.cancel()

task = asyncio.Task(periodic())
loop = asyncio.get_event_loop()
loop.call_later(5, stop)

try:
   loop.run_until_complete(task)
except asyncio.CancelledError:
   pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From what I can tell, your current code will exit after it receives its first message.</p>
<p>Try changing your code to a consumer pattern, as mentioned in the websocket docs here:</p>
<p><a href="https://websockets.readthedocs.io/en/stable/intro.html#common-patterns" rel="nofollow noreferrer">https://websockets.readthedocs.io/en/stable/intro.html#common-patterns</a></p>
<pre><code>import asyncio
import websockets

async def connect_ws():
        print("websockets.client module defines a simple WebSocket client API::::::")    
        async with websockets.client.connect(full_url,extra_headers=headers_conn1) as websocket:
                while True:
                        print ("starting")
                        webSoc_Received = await websocket.recv()
                        print ("Ending")
                        Decode_data = zlib.decompress(webSoc_Received)      
                        print(Decode_data)
</code></pre>
</div>
<span class="comment-copy">Thanks but its throwing error as I have to call function inside this as well               asyncio.get_event_loop().run_forever(connect_ws()) TypeError: run_forever() takes 1 positional argument but 2 were given.Any idea on this part ?</span>
<span class="comment-copy">@CoolNetworking see my updated post.</span>
<span class="comment-copy">With the first method, it just gets stuck and never receives data and stuck at below /usr/local/lib/python3.6/asyncio/events.py:127: RuntimeWarning: coroutine 'connect_ws' was never awaited   self._callback(*self._args).With second one its same behavior it actually never runs forever</span>
<span class="comment-copy">@CoolNetworking, what about second example?</span>
<span class="comment-copy">With your third suggestion its throwing the same error   raise ConnectionClosed(self.close_code, self.close_reason) websockets.exceptions.ConnectionClosed: WebSocket connection is closed: code = 1007, no reason.</span>
