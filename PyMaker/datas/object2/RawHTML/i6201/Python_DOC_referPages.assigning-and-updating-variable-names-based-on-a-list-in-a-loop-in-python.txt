<div class="post-text" itemprop="text">
<p>I am working in Pandas to create a series of data frames, each of which is an aggregated version of the previous one. (I have a statistic that has to be calculated recursively.) Let's assume that I have a series of variables that I'll be aggregating, saved in a dictionary called aggVars. The original data frame, <code>df</code>, has nested observations:</p>
<pre><code>year area ind occ aggVars
2000 0001 001 001 ...
2000 0001 001 002 ...
2000 0001 002 001 ...
2000 0001 002 002 ...
2000 0002 001 001 ...
2000 0002 001 002 ...
2000 0002 002 001 ...
2000 0002 002 002 ...
2001 0001 001 001 ...
2001 0001 001 002 ...
.
.
.
</code></pre>
<p>I think you get the idea. Observations are nested in occupations, which are within industries, which are within areas, which are within years.</p>
<p>I can do this the dumb way:</p>
<pre><code># DUMB CODE BLOCK
df_job = df.groupby(['year', 'area', 'ind', 'occ'], as_index=False)
df_job = df_job.agg(aggVars)
df_work = df_job.groupby(['year', 'area', 'ind'], as_index=False)
df_work = df_work.agg(aggVars)
df_county = df_work.groupby(['year', 'area'], as_index=False)
df_county = df_county.agg(aggVars)
df_year = df_county.groupby(['year'], as_index=False)
df_year = df_year.agg(aggVars)
</code></pre>
<p>(I have intentionally used different names for the data frames, i.e., <code>df_county</code> instead of <code>df_area</code>, to reflect that the .groupby() variables in the real data do not map so neatly onto the hierarchical levels.)</p>
<p>I have tested this, and it works fine. But this is CLEARLY a stupid way to do this. This should be a loop of some sort. <strong>And here is where my troubles begin.</strong> I could specify a list of lists:</p>
<pre><code>aggHierarchy = [['job', ['year', 'area', 'ind', 'occ']],
                ['work', ['year', 'area', 'ind']],
                ['county', ['year', 'area']],
                ['year', ['year']]]
</code></pre>
<p>And then loop over the list, something like this:</p>
<pre><code># BROKEN CODE BLOCK
old_df = 'df'
for level in aggHierarchy:
    new_df = 'df_%s' % level[0]
    new_df = old_df.groupby(level[1], as_index=False)
    new_df = new_df.agg(aggVars)
    old_df = new_df
</code></pre>
<p>The logic here would be to assign the new data frame's name based on the first sub-element of the <code>aggHierarchy</code> element, then group things using the second sub-element. But of course, this doesn't work. The loop I've written basically tries to assign a NAME for the new data frame using <code>new_df = 'df_%s' % level[0]</code>, but all I've actually done there is create a string. </p>
<p>Furthermore, Stack Overflow is full of people pointing out that using lists to assign variable names in a loop is <a href="http://stupidpythonideas.blogspot.com/2013/05/why-you-dont-want-to-dynamically-create.html" rel="nofollow noreferrer">Considered Harmful</a>. I get that--I can tell how janky this is. "<a href="https://nedbatchelder.com/blog/201112/keep_data_out_of_your_variable_names.html" rel="nofollow noreferrer">Use a dictionary</a>," I see people writing. But here's the thing: The aggregation of those data frames has to happen in a certain order, which (I believe) I can't specify with a dictionary. I am failing to grasp how I go from adding variable names to a dictionary, to calling them in some specified order in a loop.</p>
<p>Thus my question, which hopefully I've given enough background information to specify well: given a block of code like <code>DUMB CODE BLOCK</code> above, where I need to update variable names based on a list (or dictionary!) whose exact contents I might not know in advance...how can I create some sort of loop there?</p>
</div>
<div class="post-text" itemprop="text">
<p>Keep using your list but use the DataFrame name as a dictionary key to store all the intermediate DataFrames.</p>
<p>Assuming the original DataFrame is named <code>df</code>:</p>
<pre><code>aggHierarchy = [['job', ['year', 'area', 'ind', 'occ']],
                ['work', ['year', 'area', 'ind']],
                ['county', ['year', 'area']],
                ['year', ['year']]]

data_frames = {}
for df_name, group in aggHierarchy:
    df = df.groupby(group, as_index=False)
    df = df.agg(aggVars)
    data_frames[df_name] = df
</code></pre>
<p>If you do not want to lose the original DataFrame:</p>
<pre><code>data_frames = {}
new_df = df
for df_name, group in aggHierarchy:
    new_df = new_df.groupby(group, as_index=False)
    new_df = new_df.agg(aggVars)
    data_frames[df_name] = new_df
</code></pre>
<hr/>
<p>Your comment:</p>
<blockquote>
<p>If, in aggHierarchy, I list the names as df_industry, df_area and so on, and then loop using for df_name, group in aggHierarchy, the resulting dictionary keys are industry, area and so on. That is, python seems to "absorb" the prefix when the prefix is included in the looping variable and the things looped over.</p>
</blockquote>
<p>Surprised  me when I saw it - I certainly don't <em>see</em> that behaviour</p>
<pre><code>aggHierarchy = [['df_job', ['year', 'area', 'ind', 'occ']],
                ['df_work', ['year', 'area', 'ind']],
                ['df_county', ['year', 'area']],
                ['df_year', ['year']]]

d = {}
for df_name, thing in aggHierarchy:
    print(df_name, thing)
    d[df_name] =  thing

&gt;&gt;&gt;
df_job ['year', 'area', 'ind', 'occ']
df_work ['year', 'area', 'ind']
df_county ['year', 'area']
df_year ['year']
&gt;&gt;&gt;
&gt;&gt;&gt; d
{'df_job': ['year', 'area', 'ind', 'occ'], 'df_work': ['year', 'area', 'ind'], 'df_county': ['year', 'area'], 'df_year': ['year']}
&gt;&gt;&gt;
&gt;&gt;&gt; d['df_year']
['year']
&gt;&gt;&gt; d['year']
Traceback (most recent call last):
  File "&lt;pyshell#206&gt;", line 1, in &lt;module&gt;
    d['year']
KeyError: 'year'
&gt;&gt;&gt;
</code></pre>
<p>In the loop, <code>df_name</code> is <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">just a name</a>. The <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow noreferrer">for statement</a> is implicitly(?) <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment" rel="nofollow noreferrer">assigning</a> the first item from each <em>row</em> in <code>aggHierarchy</code> to it.  No magic going on.</p>
</div>
<span class="comment-copy"><code>collections.OrderedDict</code> might suit your usecase.</span>
<span class="comment-copy">Are you only interested in the <i>end</i> result or do you actually need all of those intermediate DataFrames for something else?</span>
<span class="comment-copy">It'd be helpful if you can provide a working minimal example, including specific names and values for <code>aggVars</code>, so it's possible to see the exact input and output.  Also, what is your required output - do you need all of the intermediary data frames, or only the final one (e.g. <code>df_year</code> in your example)?</span>
<span class="comment-copy">I do need the intermediate data frames. I have realized that I can collapse most of that <code>dumb code block</code> in half, i.e., <code>df_year = df_county.groupby(['year'], as_index=False).agg(aggVars)</code>.</span>
<span class="comment-copy">A minimum working example might have three variables over which I'm aggregating, say <code>white</code>, <code>black</code>, and <code>workers</code>. These hold counts. Then <code>aggVars = {'white': 'sum', 'black': 'sum', 'workers': 'sum'}</code>. Each of the aggregated data frames would then hold sums collapsed over the grouping variables. (In this case you can build ALL of the intermediate data frames from the original, but that doesn't hold for more complicated statistics.)</span>
<span class="comment-copy">Bravo. That does indeed produce the same results! Now I'm going to sit for a while and figure out WHY it works. (I came to python with &gt;15 years of using Stata for data analysis, and Stata has no dictionary structure. Hence the intuition still escapes me.) Thanks for the quick, and useful, reply.</span>
<span class="comment-copy">@JPFerguson, Anything specific that you are trying to figure out <code>WHY</code>?</span>
<span class="comment-copy">Sometimes <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Python Names</a> trip people up at first also.</span>
<span class="comment-copy">At this point, no. I understand now that the dictionary is linking those names to data frames. Per one of the posts I linked to: "The thing all these have in common is trying to bridge the gap between two domains: the data in your program, and the names of data in your program. Any time this happens, it's a clear sign that you need to move up a level in your data modeling. Instead of 26 lists, you need one dictionary. Instead of N tables, you should have one table, with one more column in it." I see how this gives us a dictionary of data frames rather than a cluttered set of variables.</span>
<span class="comment-copy">Actually @wwii, one specific question, if you don't mind. If, in aggHierarchy, I list the names as <code>df_industry</code>, <code>df_area</code> and so on, and then loop using <code>for df_name, group in aggHierarchy</code>, the resulting dictionary keys are <code>industry</code>, <code>area</code> and so on. That is, python seems to "absorb" the prefix when the prefix is included in the looping variable and the things looped over. If I keep the names like that and loop using <code>for name, group...</code>, that doesn't happen. What is this phenomenon called, so I can read up on it? It seems like a future landmine if I don't understand it.</span>
