<div class="post-text" itemprop="text">
<p>Let's say I have the following enum:</p>
<pre><code>class LineStyle(Enum):
    SOLID = 'solid'
    DASHED = 'dashed'
    DASHDOT = 'dashdot'
    DOTTED = 'dotted'
</code></pre>
<p>Is it possible to somehow directly import fields from this enum ?</p>
<p>Eg:</p>
<pre><code>from mymodule.LineStyle import SOLID, DASHED  # does not work
</code></pre>
<p>The only workaround I could think of is declaring all enums fields as module variables:</p>
<pre><code>class LineStyle(Enum):
    SOLID = 'solid'
    DASHED = 'dashed'
    DASHDOT = 'dashdot'
    DOTTED = 'dotted'

SOLID = LineStyle.SOLID
DASHED = LineStyle.DASHED
DASHDOT = LineStyle.DASHDOT
DOTTED = LineStyle.DOTTED
</code></pre>
<p>Is there a more elegant way to do this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>No. With <code>import</code> can only ever add references in the current namespace pointing to the module object itself, or to the top-level names in the module. Enum values are not top-level names in the module unless you explicitly put them there, like in your workaround.</p>
<p>You <em>can</em> automate assigning those names to globals, by adding all information from the <a href="https://docs.python.org/3/library/enum.html#iteration" rel="noreferrer"><code>__members__</code> attribute</a> to your module globals:</p>
<pre><code>globals().update(LineStyle.__members__)
</code></pre>
<p>The <a href="https://docs.python.org/3/library/functions.html#globals" rel="noreferrer"><code>globals()</code> function</a> gives you a reference to the namespace of the current module, letting you add names to that namespace dynamically. The <code>LineStyle.__members__</code> attribute is a a mapping of name to value (including <a href="https://docs.python.org/3/library/enum.html#duplicating-enum-members-and-values" rel="noreferrer">aliases</a>), so the above adds all names to the global namespace:</p>
<pre><code>&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class LineStyle(Enum):
...     SOLID = 'solid'
...     DASHED = 'dashed'
...     DASHDOT = 'dashdot'
...     DOTTED = 'dotted'
...
&gt;&gt;&gt; SOLID
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'SOLID' is not defined
&gt;&gt;&gt; globals().update(LineStyle.__members__)
&gt;&gt;&gt; SOLID
&lt;LineStyle.SOLID: 'solid'&gt;
</code></pre>
<p>If you don't want aliases included in that, use a <code>for</code> loop, iterating over the <code>LineStyle</code> object. That only gives you the member objects, from which you can then pull the name:</p>
<pre><code>for member in LineStyle:
    globals()[member.name] = member
</code></pre>
</div>
<span class="comment-copy">The import mechanism does not get access to items in classes. So, no.</span>
<span class="comment-copy">May I ask why can't you use them like that <code>LineStyle.SOLID</code>? why do you need a separate variable for it?</span>
<span class="comment-copy">It is just for cosmetic reasons/code concision. It is redundant to have stuff such as <code>plot_some_stuff(color=Color.RED, line_style=LineStyle.DOTTED)</code> instead of just <code>plot_some_stuff(color=RED, line_style=DOTTED)</code>.</span>
<span class="comment-copy">Generating the fields dynamically kinda defeats the purpose of using Enums in the first place for me, which is to have "pseudo strong typing" / IDE friendly code, so I guess I will just stick with my workaround... Thanks anyway.</span>
<span class="comment-copy">@nicoulaj: sure, but then pay the price of having to repeat yourself. Personally, I'd not make globals at all.</span>
