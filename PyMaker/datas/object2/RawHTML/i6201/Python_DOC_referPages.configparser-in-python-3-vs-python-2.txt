<div class="post-text" itemprop="text">
<p>I've been slowly making the transition from py2 -&gt; py3 and I've run into an issue that I can't quite resolve (as trivial as I'm sure the problem is). When I execute the code below, the config file appears to have no sections :(</p>
<p>Where have I gone astray? </p>
<p>As a note, I did reuse this code from a python 2 script (replacing the old ConfigParser.SafeConfigParser with the new configparser.ConfigParser). I don't think this fact is relevant, but maybe it is? Clearly, I do not know :) </p>
<p>Here's the project/main.py</p>
<pre><code>import inspect
import os
import utilities.utilities

def main():
    config_ini_path = os.path.abspath(inspect.getfile(inspect.currentframe()).split('.py')[0] + '_config.ini'
    print(config_ini_path)
    config = utilities.utilies.get_config(config_ini_path)
    print(config.sections())

if __name__ == "__main__":
    main()
</code></pre>
<p>Here's the project/utilities/utilities.py:</p>
<pre><code>import os
import configparser
import inspect
import sys

def get_config(config_file_path=os.path.abspath(inspect.getfile(inspect.currentframe()).split('.py')[0]) + '_config.ini'):
    parser = configparser.ConfigParser()
    if os.path.exists(config_file_path):
        with open(config_file_path, 'r') as config_file:
            parser.read(config_file)
            return parser
    else:
        print('FAILED TO GET CONFIG')
        sys.exit()

def set_config(parser, config_file_path):
    if os.path.exists(config_file_path):
        with open(config_file_path, 'w') as config_file:
        parser.write(config_file)
    else:
        print('FAILED TO SET CONFIG')
        sys.exit()
</code></pre>
<p>And finally, here is the project/project_config.ini:</p>
<pre><code>[logging]
json_config_path = /project/logging.json
</code></pre>
<p>Interestingly, if I add </p>
<pre><code>config['logging'] = {'json_config_path':'project/other.json'}
utilities.utilities.set_config(config, config_ini_path)
print(config.sections())
</code></pre>
<p>The change will be written to the file, however, upon re-execution, it will not be recalled (as witnessed by .sections()). </p>
<p>I'm sure I am missing something simple! What gives? </p>
</div>
<div class="post-text" itemprop="text">
<p>Turns out <code>.read()</code> accepts filenames, and <code>.read_file()</code> accepts filetypes. Originally, I was using <code>.readfp()</code>, but <code>read_file()</code> has replaced it in py3! Silly, silly me. </p>
</div>
<span class="comment-copy">instead of the whole <code>open(path)</code> thing, <code>parser</code> has a <code>.read()</code> function that you can use to do <code>parser.read(path)</code></span>
<span class="comment-copy">In fact, you're recreating a lot of the methods that <code>parser</code> has already. For e.g. <code>set_config</code> is the same as <code>parser.set()</code></span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/configparser.html#configparser.ConfigParser.read" rel="nofollow noreferrer">config parser docs</a></span>
<span class="comment-copy">Ahhh! This was indirectly rather helpful. Turns out <code>.read()</code> accepts filenames, and <code>read_file()</code> accepts filetypes. Originally, I was using <code>.readfp()</code>, but <code>read_file()</code> has replaced it in py3!   Silly, silly me. Thanks @GiantsLoveDeathMetal!</span>
<span class="comment-copy">Glad I could instigate a solution.</span>
