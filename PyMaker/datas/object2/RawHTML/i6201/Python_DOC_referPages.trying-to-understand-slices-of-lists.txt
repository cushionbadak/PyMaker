<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/19068707/does-a-slicing-operation-give-me-a-deep-or-shallow-copy">Does a slicing operation give me a deep or shallow copy?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I have a list and I want to understand slices of it. I take a slice <code>[0:1]</code> of it: </p>
<pre><code>&gt;&gt;&gt; l=[1,2,3,4]
&gt;&gt;&gt; id(l[0])
140079803522784
&gt;&gt;&gt; id(l[0:1][0])
140079803522784
</code></pre>
<p>They are the same. But:</p>
<pre><code>&gt;&gt;&gt; l[0]=7
&gt;&gt;&gt; l
[7, 2, 3, 4]
&gt;&gt;&gt; l[0:1][0]=13
&gt;&gt;&gt; l
[7, 2, 3, 4]
</code></pre>
<p>So the slice's 0-element is the same as the list's 0-element, but when I change it in the slice, it is not changed in the list. Why not?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/tutorial/introduction.html#lists" rel="nofollow noreferrer">From the documentation</a>:</p>
<blockquote>
<p>All slice operations return a new list containing the requested elements. This means that the following slice returns a new (shallow) copy of the list.</p>
</blockquote>
<p>So basically when you do <code>l[0:1][0] = 13</code> you're assigning 13 as the value in a new list, not <code>l</code>.  It's the same as if you did</p>
<pre><code>[l[0]] = 13
</code></pre>
<p>or</p>
<pre><code>g = [l[0]]
g[0] = 13
</code></pre>
<p>Note this is only true for immutable types, such as <code>int</code> and <code>str</code>.  Since a slice performs a shallow copy, you'd get the behavior you'd expect if you modify an object.</p>
<pre><code>&gt;&gt;&gt; l = [{'hi': 7}, {}, {}, {}]
[{'hi': 7}, {}, {}, {}]
&gt;&gt;&gt; l[0:1][0]['hi'] = 1
&gt;&gt;&gt; l[0]
{'hi': 1}
</code></pre>
</div>
<span class="comment-copy">Slicing creates a shallow <i>copy</i>...</span>
<span class="comment-copy">Because slicing makes a new list.</span>
<span class="comment-copy">Now try the same thing with arbitrary objects (a custom class for example) instead of integers (which are immutable). Your mind will be blown.</span>
<span class="comment-copy">@DeepSpace I did that. Same thing: &gt;&gt;&gt;l=[[1,2],[1,3]] &gt;&gt;&gt; l[0:1][0]=[7] &gt;&gt;&gt; l [[1, 2], [1, 3]]</span>
<span class="comment-copy">In your first example, <code>l[0]</code> and <code>l[0:1][0]</code> are nothing more than elements of <code>l</code>, specifically they are the first element, i.e. the number <code>1</code>.  They have no association with the original list.</span>
<span class="comment-copy">It is a copy, yes, but the elements in the copy refer to the same elements as the original list. Also if I do <code>l[0:1]=[13]</code>, <code>l</code> is changed.</span>
<span class="comment-copy">@ericj they do, but integers are immutable. And your second example is explicit slice assignment, of course <code>l</code> gets changed.</span>
<span class="comment-copy">@jonrsharpe Well, I tried with mutable lists: <code>l=[[1,2],[1,3]];l[0:1][0]=[7]</code>. Then <code>l</code> is <code>[[1, 2], [1, 3]]</code>.</span>
<span class="comment-copy">That example is <b>not</b> slice assignment. It's assigning by index into the <i>result</i> of a slice, effectively <code>m = l[0:1]; m[0] = [7]</code>. It's only slice assignment when the <i>last</i> index is a slice.</span>
<span class="comment-copy">Ah, now I see it. <code>l[0:1]</code> is another list. It's first element equals the first element of <code>l</code>, but I did not modified that element. I replaced it, so I changed the <code>l[0:1]</code> list. Thanks.</span>
