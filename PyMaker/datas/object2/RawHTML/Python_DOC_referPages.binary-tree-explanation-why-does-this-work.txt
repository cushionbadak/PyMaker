<div class="post-text" itemprop="text">
<p>Started reading a book about basic data structures and algorithms which uses this example code,</p>
<pre><code>    def binary_search(list, item):
    low = 0  
    high = len(list)-1  #sets upper range to length of provided list

    while low &lt;= high:
        mid = (low + high) #why does (low + high) give me middle of list?
        guess = list[mid]
        if guess == item:
            return mid
        if guess &gt; item:
            high = mid - 1
        else:
            low = mid + 1
    return None

my_list = [1,3,5,7,9]

print binary_search(my_list,3)
print binary_search(my_list,-1)
</code></pre>
<p>While I understand the concept of the tree I don't understand why </p>
<p><code>mid = (low + high) #why does (low + high) give me middle of list</code>?
wouldn't low + high just give me the same value as high? shouldn't i need low + high / 2 to find the midpoint? yet it works perfectly fine?  </p>
</div>
<div class="post-text" itemprop="text">
<p>It works because <code>mid</code> is always in the right range, but this is linear search, not binary. You can check this by printing the indices that are examined:</p>
<pre><code>def binary_search(list, item):
    low = 0  
    high = len(list)-1  #sets upper range to length of provided list

    while low &lt;= high:
        mid = (low + high) #why does (low + high) give me middle of list?
        print("mid =", mid)
        guess = list[mid]
        if guess == item:
            return mid
        if guess &gt; item:
            high = mid - 1
        else:
            low = mid + 1
</code></pre>
<p>Looking for -1 in your example:</p>
<pre><code>&gt;&gt;&gt; print (binary_search([1,3,5,7,9],-1))
mid = 4
mid = 3
mid = 2
mid = 1
mid = 0
None
</code></pre>
<p>So you are correct: you should divide <code>mid</code> by 2 (and avoid using <code>list</code> as a variable name).</p>
</div>
<div class="post-text" itemprop="text">
<p>It should indeed be <code>(low+high)//2</code>.  As it is now, <code>mid</code> starts from the last item in the list and always goes through the else part of the <code>guess&gt;item</code> condition.  So <code>high</code> is reduced by 1 each time and <code>low</code> never changes (from zero). The process ends up going through all elements from last to first which is not a binary search at all (rather a sequential search).</p>
</div>
<div class="post-text" itemprop="text">
<p>You are correct about this being incorrect!</p>
<p>It will give you the correct result, but let's look at what's actually happening. </p>
<pre><code>  if guess == item:
    return mid
  if guess &gt; item:
    high = mid - 1
  else:
    low = mid + 1
</code></pre>
<p>In the first iteration, <code>guess == list[mid] == list[high] == 9</code>. 3 is less than 9, so high will decrement.</p>
<p>In the next iteration, again <code>mid == high</code>, but high is 1 less.</p>
<p>high will continue to decrement until <code>guess == list[mid] == list[high] == list[1] == 3</code></p>
</div>
<span class="comment-copy">isnt meant to be (low+high) //2 ?</span>
<span class="comment-copy">You are rigth it should be <code>mid = (low + high)//2</code>. It still works because it does not require the middle but it runs longer as is only goes through the complete list instead of "skipping" over is</span>
<span class="comment-copy">"//" 2 solved my other problem of getting back crazy decimals in python shell as well thanks! at this point i needed to go back and look at the operators I never really used before.</span>
