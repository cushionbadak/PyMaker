<div class="post-text" itemprop="text">
<p>I have two <code>DataFrame</code>s, and I would like to perform some operation using both of them as input.</p>
<hr/>
<p><code>DataFrame</code> A:
The <code>x1</code>,<code>y1</code>,<code>x2</code>,<code>y2</code> correspond to the coordinates of a rectangle </p>
<pre><code>+---+----+----------+----------+----------+----------+
|   | ID |    x1    |    y1    |    x2    |    y2    |
+---+----+----------+----------+----------+----------+
| 0 |  0 | 332833.5 | 502144.0 | 333214.5 | 502460.5 |
| 1 |  1 | 333537.5 | 502144.0 | 333918.5 | 502460.5 |
| 2 |  2 | 334945.5 | 502144.0 | 335326.5 | 502352.0 |
| 3 |  3 | 335713.5 | 502144.0 | 336094.5 | 502352.0 |
| 4 |  4 | 336417.5 | 502144.0 | 336798.5 | 502416.0 |
...
+---+----+----------+----------+----------+----------+
</code></pre>
<hr/>
<p><code>DataFrame</code> B:</p>
<pre><code>+---+-------------+-------------+--+--+
|   | min_matchID | max_matchID |  |  |
+---+-------------+-------------+--+--+
| 0 |           0 |           1 |  |  |
| 1 |           2 |           2 |  |  |
| 2 |           3 |           5 |  |  |
| 3 |           6 |           7 |  |  |
| 4 |           8 |           8 |  |  |
...
+---+-------------+-------------+--+--+
</code></pre>
<p>For each row of entry in B with an ID between <code>min_matchID</code> and <code>max_matchID</code>, I would like to:</p>
<ul>
<li>query the corresponding collection of <code>x1</code>,<code>y1</code>,<code>x2</code>,<code>y2</code> in A (whose <code>ID</code>s fall into <code>range(min_matchID, max_matchID+1)</code>)</li>
<li>and construct a <code>MultiPolygon</code> class instance (as in python package <code>shapely</code>), e.g.</li>
</ul>
<pre class="lang-py prettyprint-override"><code>MultiPolygon([box(332833.5, 502144.0, 333214.5, 502460.5), box(333537.5, 502144.0, 333918.5, 502460.5)])
</code></pre>
<p>A brute force for loop is obvious, but it's just too slow. I wonder if there's a vectorized way to do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>First you can use <code>Index.repeat</code> to repeat rows based on your <code>min_matchID</code> and <code>max_matchID</code>.</p>
<pre><code>import pandas as pd
import numpy as np
from shapely.geometry import MultiPolygon,box
# generate test data
A = pd.DataFrame({'ID':range(0,10000),'x1':range(10000,20000),'y1': range(50000, 60000)
                 ,'x2': range(10000, 20000), 'y2': range(50000, 60000)})
B = pd.DataFrame({'min_matchID':np.random.randint(0,10000,size=(10000))})
B['max_matchID'] = B['min_matchID'] + np.random.randint(0,10,size=(10000))

# start 
B = B.reset_index()
idx = B.index.repeat(B.max_matchID - B.min_matchID + 1)
B = B.reindex(idx).reset_index(drop=True)
B['ID'] =  B['min_matchID'] + idx.to_series().groupby(idx).cumcount().values
print(B)

       index  min_matchID  max_matchID    ID
0          0         6889         6891  6889
1          0         6889         6891  6890
2          0         6889         6891  6891
3          1         8299         8307  8299
4          1         8299         8307  8300
5          1         8299         8307  8301
6          1         8299         8307  8302
7          1         8299         8307  8303
...      ...          ...          ...   ...
54740   9998         4278         4282  4282
54741   9999         3061         3067  3061
54742   9999         3061         3067  3062
54743   9999         3061         3067  3063
54744   9999         3061         3067  3064
54745   9999         3061         3067  3065
54746   9999         3061         3067  3066
54747   9999         3061         3067  3067
</code></pre>
<p>Then you can try <code>pd.merge()</code> to combine coordinates.</p>
<pre><code>result = pd.merge(B,A,on='ID',how='left')
print(result)
       index  min_matchID  max_matchID    ID       x1       y1       x2       y2
0          0         6889         6891  6889  16889.0  56889.0  16889.0  56889.0
1          0         6889         6891  6890  16890.0  56890.0  16890.0  56890.0
2          0         6889         6891  6891  16891.0  56891.0  16891.0  56891.0
3          1         8299         8307  8299  18299.0  58299.0  18299.0  58299.0
4          1         8299         8307  8300  18300.0  58300.0  18300.0  58300.0
5          1         8299         8307  8301  18301.0  58301.0  18301.0  58301.0
6          1         8299         8307  8302  18302.0  58302.0  18302.0  58302.0
7          1         8299         8307  8303  18303.0  58303.0  18303.0  58303.0
...      ...          ...          ...   ...      ...      ...      ...      ...
54740   9998         4278         4282  4282  14282.0  54282.0  14282.0  54282.0
54741   9999         3061         3067  3061  13061.0  53061.0  13061.0  53061.0
54742   9999         3061         3067  3062  13062.0  53062.0  13062.0  53062.0
54743   9999         3061         3067  3063  13063.0  53063.0  13063.0  53063.0
54744   9999         3061         3067  3064  13064.0  53064.0  13064.0  53064.0
54745   9999         3061         3067  3065  13065.0  53065.0  13065.0  53065.0
54746   9999         3061         3067  3066  13066.0  53066.0  13066.0  53066.0
54747   9999         3061         3067  3067  13067.0  53067.0  13067.0  53067.0
</code></pre>
<p>Finally you can group by <code>index</code> to achieve it.</p>
<pre><code>result = result.groupby('index').apply(lambda x:MultiPolygon([box(x1,y1,x2,y2) for x1,y1,x2,y2 in zip(x.x1,x.y1,x.x2,x.y2)]))
</code></pre>
</div>
<span class="comment-copy">Have you profiled your code to see where the slowdown is? I suspect instantiating the <code>MultiPolygon</code> is more costly than you think.</span>
<span class="comment-copy">@AndrewGuy My <code>%lprun</code> shows that <code>MultiPolygon</code> instantiation is actually quite down the Pareto, taking ~5% of the total run time. 70% of the run time is consumed by the query (I am using <code>df.iterrows()</code> and <code>df.query()</code>).</span>
<span class="comment-copy">As a stylistic tip to make the code much clearer, I would have called A 'pts' and B 'ids'. (Then I would have renamed B's columns to simply <code>min</code> and <code>max</code>. <code>ids['min'] ... ids['max']</code> is short, clear and self-explanatory.</span>
<span class="comment-copy">@smci thank you very much for the suggestion. That's a great idea. But since there's already a detailed answer that uses the current notation I will not update it to avoid confusion for other readers.</span>
<span class="comment-copy">Thank you very much for this effort! <code>merge</code> does seem to be a great idea~ There's only one caveat - I probably should've made it more clear in my post - that the <code>min_matchID</code> and <code>max_matchID</code> is referring to a range (from <code>min_matchID</code> to <code>max_matchID</code>). So there might be more than 2 rows of A that need to be aggregated.</span>
<span class="comment-copy">@XiUpsilon I've edited the answers according to your new questions.</span>
<span class="comment-copy">Great! This solves my problem. Thanks~</span>
