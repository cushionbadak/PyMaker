<div class="post-text" itemprop="text">
<p>My code is as follows:</p>
<pre><code>from tkinter import *
window = Tk()
print("What is 5 times 5?")
optionA = 25
optionB = 10
optionC = 3125
optionD = 55
print("A:", optionA)
print("B:", optionB)
print("C:", optionC)
print("D:", optionD)
def chooseA():
    userAnswer = optionA
def chooseB():
    userAnswer = optionB
def chooseC():
    userAnswer = optionC
def chooseD():
    userAnswer = optionD
window.bind("&lt;Left&gt;", chooseA)
window.bind("&lt;Up&gt;", chooseB)
window.bind("&lt;Down&gt;", chooseC)
window.bind("&lt;Right&gt;", chooseD)
if userAnswer == 25:
    print("You correctly answered the question!")
</code></pre>
<p>My problem is that I get an error saying that userAnswer is not defined. This is because the code doesn't have a function that waits for the user to press one of the four arrow keys. Does anyone have a suggestion as to how to make the program wait for 1 of 4 key presses? Your answers are greatly appreciated!
(P.S. Using the keyboard.wait command from the keyboard module doesn't wait for multiple keys.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution, but perhaps not the best (there are probably modules just for this, but I like to practice coding with threads when I can). </p>
<pre><code>from threading import Thread
from tkinter import *

def check_with_thread(): # make a function our thread can attach to
    global userAnswer
    local_check = userAnswer
    while True:
        if userAnswer != local_check: # user has selected a new value
            if userAnswer == 25:
                print("That's correct!")
                break # have our thread break infinite loop and end it's execution
            else:
                print(userAnswer)
                local_check = userAnswer # Make it able to detect changes in values


window = Tk() # Actually make a window! Why is this not in the OP???
print("What is 5 times 5?")
optionA = 25
optionB = 10
optionC = 3125
optionD = 55
print("A:", optionA)
print("B:", optionB)
print("C:", optionC)
print("D:", optionD)
def chooseA(event):
    global userAnswer # we are modifying the global variable our thread is looking at
    userAnswer = optionA
def chooseB(event):
    global userAnswer
    userAnswer = optionB
def chooseC(event): # the .bind() sends events, so these need a positional argument for them
    global userAnswer
    userAnswer = optionC
def chooseD(event):
    global userAnswer
    userAnswer = optionD
window.bind("&lt;Left&gt;", chooseA)
window.bind("&lt;Up&gt;", chooseB)
window.bind("&lt;Down&gt;", chooseC)
window.bind("&lt;Right&gt;", chooseD)
userAnswer = None
t = Thread(target=check_with_thread) # make a thread to check the input
t.start() # get our thread running before generating the window

window.mainloop()
</code></pre>
<h1>How it works</h1>
<p>First we define a function for our thread to execute (Threads are one of the methods that your program is able to literally do 2 things at once. This is needed because <code>window.mainloop()</code> will block our main thread of our script from doing anything else). We specify our function needs to read the global variable <code>userAnswer</code> with <code>global userAnswer</code>, otherwise it would expect that variable to be local (defined within the function, and forgotten when the function end unless it is returned). Then we initialize the local variable <code>local_check</code> to be whatever <code>userAnswer</code> happens to be when the function is called. Finally we enter an infinite loop. In this loop we will check if the user has updated their answer by comparing it to our previously created <code>local_check</code>. If the answer has been updated these values will be different! We will continue checking for new answers until they select the correct answer of 25 where we will call <code>break</code> to end our <code>while</code> loop (otherwise it would continue going forever). At this point we've reached the end of our function so the thread that is assigned to it will die off when it reaches this point. Next we will create <code>userAnswers</code> and assign it a value of <code>None</code> so that when our thread reaches the line <code>local_check = userAnswer</code> it will know what to do and won't encounter a NameError. Now all that is left is to make our thread. We do that with <code>t = Thread(target=check_with_thread)</code> and then immediately start it. The thread is now up and checking for changes to the input, and we can finally start <code>window.mainloop()</code> in the main thread of our script.</p>
<h1>Why use a thread?</h1>
<p>A thread is used because <code>window.mainloop()</code> is blocking. This means if we tried:</p>
<pre><code># stuff from previous script
window.mainloop()
thing = 5
print(thing)
</code></pre>
<p>We will not see anything printed until <strong>after</strong> the user closes our GUI. This means our bindings are no longer in effect, and cannot be used to change what the user has selected. Through using a thread we are able to have two infinite loops processing information <strong>simultaneously</strong> which is a very valuable trick to know for programmers (why I practice when I can)</p>
</div>
<div class="post-text" itemprop="text">
<p>Try adding:</p>
<pre><code>window = tkinter.Tk()
</code></pre>
<p>st the top of your code, and </p>
<pre><code>window.mainloop()
</code></pre>
<p>at the end. This will create a window that will stay open until you manually close it.</p>
</div>
<span class="comment-copy">What is <code>window</code>? Please, provide a <a href="https://stackoverflow.com/help/mcve">MCVE</a></span>
<span class="comment-copy">If you search on the phrase "Python wait for keypress", youâ€™ll find resources that can explain it much better than we can in an answer here.</span>
<span class="comment-copy">Window is part of the tkinter library. What window.bind does is it binds a key to a specific command. Typing window = Tk() at the start of your code generates a GUI.</span>
<span class="comment-copy">I'm asking because I tried your code, and I get <code>NameError: name 'window' is not defined</code>. Which is different from the error traceback you posted.</span>
<span class="comment-copy">I'm using it just to bind the keys, but apparently, I need to create a GUI in order for the rest of tkinter's commands to work.</span>
<span class="comment-copy">Thanks! I tested your code and it worked, but I'm new to programming, so can you please explain your code? (threads, local and global variables, check_with_thread, local_check,  breaks, and why it's needed to add userAnswer = None ) Thanks!</span>
<span class="comment-copy">Thanks for your explanation! The one thing I don't understand yet is why you need to use a thread-can't you just call on the function?</span>
<span class="comment-copy">Thanks for responding again! Sorry for bombarding you with questions, but how does the target part of the threading work? Also, can't you call the command before window.mainloop? Or will that also disable the bindings?</span>
<span class="comment-copy">The target tells the thread what function it should execute (or why it is being made). You can't call our function we made before the mainloop() without a thread either or it will loop forever without activating the GUI (the buttons won't be binded). You can try it yourself though if you replace the <code>t = Thread()</code>;<code>t.start()</code> lines with just <code>check_with_thread()</code>. There will be no errors, but pressing keys will have no effect because the GUI hasn't been made</span>
<span class="comment-copy">Ah- so while the thread is going on, the rest of the code continues running?</span>
<span class="comment-copy">This will result in the same <code>NameError</code> you should run your solution locally before posting if possible</span>
<span class="comment-copy">All this does is create a window made by tkinter. It doesn't really solve my problem.</span>
