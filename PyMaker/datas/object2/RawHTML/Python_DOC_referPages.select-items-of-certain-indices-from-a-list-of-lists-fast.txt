<div class="post-text" itemprop="text">
<p>I am on Python Version: 2.7.12 |Anaconda 4.1.1 (64-bit)| (default, Jun 29 2016, 11:07:13) [MSC v.1500 64 bit (AMD64)]</p>
<p>I have a table as list of lists, say "table" with the first list of unique elements being the headers and a list, say "cols" with some of the table columns. I would like to see if there are faster ways of selecting the items of each table list that correspond to the items of cols than the below:</p>
<pre><code>def select_cols(table, cols):
    inds = [table[0].index(col) for col in cols]
    return [[row[i] for i in inds] for row in table]
</code></pre>
<p>Example:</p>
<pre><code>table = [['a','b','c','d'],[1,2,3,4],[5,6,7,8]]
cols = ['b','d']
print select_cols(table, cols)
&gt;&gt;[['b', 'd'], [2, 4], [6, 8]]
</code></pre>
<p>Actually I have made an application which makes those tables by reading big csv files and does a lot of slicing this way so I want this function to run as fast as possible. Also I don't want to use pandas for this job because I want to keep the application light.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the operator <code>itemgetter()</code> to get elements from sublists:</p>
<pre><code>from operator import itemgetter

def select_cols(table, cols):
    cols_ = set(cols)
    inds = []

    # get indices of selected elements
    for num, i in enumerate(table[0]):
        if i in cols_:
            inds.append(num)

    # get sublists with selected elements
    iget = itemgetter(*inds)
    return [iget(i) for i in table]
</code></pre>
<p>Alternatively you can use the function <code>compress()</code>:</p>
<pre><code>from itertools import compress

def select_cols(table, cols):
    cols_ = set(cols)

    # build selector list
    sel = [i in cols_ for i in table[0]]

    # get sublists with selected elements
    return [list(compress(i, sel)) for i in table]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can group the columns from the rows with the <code>zip</code> function, filter columns by retaining only those in <code>cols</code>, and <code>zip</code> the column groups again to obtain the result in rows. <code>map</code> the rows to <code>list</code> if you want the rows as lists instead of tuples:</p>
<pre><code>map(list, zip(*(columns for columns in zip(*table) if columns[0] in cols)))
</code></pre>
<p>This returns:</p>
<pre><code>[['b', 'd'], [2, 4], [6, 8]]
</code></pre>
</div>
<span class="comment-copy">Just use the built-in <code>csv</code> module</span>
<span class="comment-copy">Specifically, <code>DictReader</code> might be useful: <a href="https://docs.python.org/2/library/csv.html#csv.DictReader" rel="nofollow noreferrer">docs.python.org/2/library/csv.html#csv.DictReader</a></span>
<span class="comment-copy">Actually the data may have come from other types of files as well so lets consider that we have a list of lists as table and a list for columns to select as above and we try to find the fastest way to do it</span>
<span class="comment-copy">Are there any other constraints/information that should be IN YOUR QUESTION?</span>
<span class="comment-copy">NO. it is well stated. Thanks!</span>
<span class="comment-copy">After timing all options we have from fastest to slower: 1)itemgettr 2)compress 3)mine 4)map. The bad thing is that if you want to have the same type output from itemgetter (when cols has one item it doesn't return a list of tuples), you have to use a closure on the item getter so that you loose some speed but it still stays in the same place in relation to the other options. Another interesting thing is that converting cols to set is faster than keeping it as a list and use a list comprehension to define inds or sel which is not that intuitive to me...</span>
