<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/py3k/glossary.html#term-hashable" rel="noreferrer">docs</a> say that a class is hashable as long as it defines <code>__hash__</code> method and <code>__eq__</code> method. However:</p>
<pre><code>class X(list):
  # read-only interface of `tuple` and `list` should be the same, so reuse tuple.__hash__
  __hash__ = tuple.__hash__

x1 = X()
s = {x1} # TypeError: unhashable type: 'X'
</code></pre>
<p>What makes <code>X</code> unhashable?</p>
<p>Note that I must have identical lists (in terms of regular equality) to be hashed to the same value; otherwise, I will <a href="http://docs.python.org/dev/reference/datamodel.html?highlight=__hash__#object.__hash__" rel="noreferrer">violate this requirement</a> on hash functions:</p>
<blockquote>
<p>The only required property is that objects which compare equal have
  the same hash value</p>
</blockquote>
<p>The docs do warn that a hashable object shouldn't be modified during its lifetime, and of course I don't modify instances of <code>X</code> after creation. Of course, the interpreter won't check that anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simply setting the <code>__hash__</code> method to that of the <code>tuple</code> class is not enough. You haven't actually told it how to hash any differently. tuples are hashable  because they are immutable. If you really wanted to make you specific example work, it might be like this:</p>
<pre><code>class X2(list):
    def __hash__(self):
        return hash(tuple(self))
</code></pre>
<p>In this case you are actually defining how to hash your custom list subclass. You just have to define exactly how it can generate a hash. You can hash on whatever you want, as opposed to using the tuple's hashing method:</p>
<pre><code>def __hash__(self):
    return hash("foobar"*len(self))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the Python3 docs:</p>
<blockquote>
<p>If a class does not define an __eq__() method it should not define a
  __hash__() operation either; if it defines __eq__() but not __hash__(), its instances will not be usable as items in hashable collections. If a class defines mutable objects and implements an
  __eq__() method, it should not implement __hash__(), since the implementation of hashable collections requires that a key’s hash
  value is immutable (if the object’s hash value changes, it will be in
  the wrong hash bucket).</p>
</blockquote>
<p>Ref: <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="noreferrer">object.__hash__(self)</a></p>
<p>Sample code:</p>
<pre><code>class Hashable:
    pass

class Unhashable:
    def __eq__(self, other):
        return (self == other)

class HashableAgain:
    def __eq__(self, other):
        return (self == other)

    def __hash__(self):
        return id(self)

def main():
    # OK
    print(hash(Hashable()))
    # Throws: TypeError("unhashable type: 'X'",)
    print(hash(Unhashable()))  
    # OK
    print(hash(HashableAgain()))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you could and should do, based on your other question, is:
don't subclass anything, just encapsulate a tuple. It's perfectly fine to do so in the init.</p>
<pre><code>class X(object):
    def __init__(self, *args):
        self.tpl = args
    def __hash__(self):
        return hash(self.tpl)
    def __eq__(self, other):
        return self.tpl == other
    def __repr__(self):
        return repr(self.tpl)

x1 = X()
s = {x1}
</code></pre>
<p>which yields:</p>
<pre><code>&gt;&gt;&gt; s
set([()])
&gt;&gt;&gt; x1
()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't modify instances of <code>X</code> after creation, why aren't you subclassing tuple? </p>
<p>But I'll point out that this actually doesn't throw an error, at least in Python 2.6. </p>
<pre><code>&gt;&gt;&gt; class X(list):
...     __hash__ = tuple.__hash__
...     __eq__ = tuple.__eq__
... 
&gt;&gt;&gt; x = X()
&gt;&gt;&gt; s = set((x,))
&gt;&gt;&gt; s
set([[]])
</code></pre>
<p>I hesitate to say "works" because this doesn't do what you think it does. </p>
<pre><code>&gt;&gt;&gt; a = X()
&gt;&gt;&gt; b = X((5,))
&gt;&gt;&gt; hash(a)
4299954584
&gt;&gt;&gt; hash(b)
4299954672
&gt;&gt;&gt; id(a)
4299954584
&gt;&gt;&gt; id(b)
4299954672
</code></pre>
<p>It's just using the object id as a hash. When you actually call <code>__hash__</code> you still get an error; likewise for <code>__eq__</code>. </p>
<pre><code>&gt;&gt;&gt; a.__hash__()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: descriptor '__hash__' for 'tuple' objects doesn't apply to 'X' object
&gt;&gt;&gt; X().__eq__(X())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: descriptor '__eq__' for 'tuple' objects doesn't apply to 'X' object
</code></pre>
<p>I gather that the python internals, for some reason, are detecting that <code>X</code> has a <code>__hash__</code> and an <code>__eq__</code> method, but aren't calling them. </p>
<p>The moral of all this is: just write a real hash function. Since this is a sequence object, converting it to a tuple and hashing that is the most obvious approach.</p>
<pre><code>def __hash__(self):
    return hash(tuple(self))
</code></pre>
</div>
<span class="comment-copy">Yeah, the read-only interfaces are the same, but why do you expect tuple.__hash__ to only use the external interfaces of it's own class? Especially when written in C. Using the external interfaces would be much slower. You can't reasonably expect a method from class A to work for class B unless class B is subclassed from class A. Did you even try to call x1.__hash__() too see if it worked?</span>
<span class="comment-copy">@LennartRegebro Yes, I agree... See my last comment to <a href="http://stackoverflow.com/a/10254636/336527">stackoverflow.com/a/10254636/336527</a>... I just had a brain freeze.</span>
<span class="comment-copy">But isn't <code>tuple.__hash__</code> a function that takes a tuple, and returns a number? How does that function "notice" that my object is actually a <code>list</code> rather than a <code>tuple</code> - the read API for the two types is identical.</span>
<span class="comment-copy">@max: <code>tuple.__hash__</code> is a bound method of the tuple class. You aren't changing whatever its implementation is doing inside that method to hash. Define your own.</span>
<span class="comment-copy"><code>hash((1,2,3))</code> is the same as <code>(1,2,3).__hash__</code>; that is the same as <code>tuple.__hash__((1,2,3))</code>, right? So <code>tuple.__hash__</code> relies on the non-public API of class <code>tuple</code>, and so it breaks down with a confusing error message when passed an instance of a different class that matches <code>tuple</code>'s public API? I suppose it explains it.. but a bit unexpected.`</span>
<span class="comment-copy">@max: Ultimately the hashing procedure is defined in the tuple classes <code>__hash__</code>, and without looking at the source I can only assume its specifically intended for the internals of a tuple instance. I am in no way surprised that simply passing its method reference over to your list class didn't work as expected.</span>
<span class="comment-copy">@max Methods usually depend on the internals of a class. Do you really expect to be able to take the implementation of a method on class A and apply it to an object of class B, just because of some similarity in the public API of both classes? The fact that tuple and list are built-in classes implemented in C makes this even <i>less</i> likely to work; at Python level if B objects have all the attributes needed by the method you got from A, then this could work, but at the C level we're talking structs, arrays, and pointers.</span>
<span class="comment-copy">Does <code>__hash__</code> need to be unique? Suppose you wanted the instances of <code>HashableAgain</code> to be compared based on the criteria you've defined in <code>__eq__</code> can you just return a constant integer in <code>__hash__</code>? (I don't really understand how hash) is used in deciding an object's membership in a set.</span>
<span class="comment-copy">@MinhTran: In general, hash in not unique, but <i>relatively</i> unique.  It is used to bucket values in a map.  If you use a constant value for hash, all the values will appear in same bucket, so performance will be horrible... but it should still work!</span>
<span class="comment-copy">You're right, for many use cases this is the cleanest, simplest solution; +1</span>
<span class="comment-copy">I'm very sorry, this question is taken out of context of another one. I just was confused about this particular behavior. The reason I subclass list is a bit complicated (see discussion in comments to <a href="http://stackoverflow.com/questions/10253783/making-a-list-subclass-hashable">this question</a>).</span>
<span class="comment-copy">The code doesn't work for me in ActiveState Python 3.2. Perhaps the behavior changed recently?</span>
<span class="comment-copy">I'm using Python 2.6. In any case, you don't want this behavior, because using <code>id</code>s as keys isn't really a good idea. Better to just convert to tuple and hash that. And actually -- I'm sorry; this was just a rather perplexing approach to the problem for me.</span>
<span class="comment-copy">In Python 3 the tuple hash indeed makes a hash of the tuple objects, not just the tuples ID, if I understand the code correctly.</span>
<span class="comment-copy">@LennartRegebro, I think that must be true in Python 2 as well; or at least I am able to create two tuples with different ids that evaluate as equal and have the same hash. The behavior I'm describing here applies only to <code>X</code> objects as defined above.</span>
