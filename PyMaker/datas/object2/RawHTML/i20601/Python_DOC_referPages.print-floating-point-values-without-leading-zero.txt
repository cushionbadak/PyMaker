<div class="post-text" itemprop="text">
<p>Trying to use a format specifier to print a float that will be less than 1 without the leading zero. I came up with a bit of a hack but I assume there is a way to just drop the leading zero in the format specifier. I couldn't find it in the docs.</p>
<p>Issue</p>
<pre><code>&gt;&gt;&gt; k = .1337
&gt;&gt;&gt; print "%.4f" % k
'0.1337'
</code></pre>
<p>Hack</p>
<pre><code>&gt;&gt;&gt; print ("%.4f" % k) [1:]
'.1337'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may use the following <code>MyFloat</code> class instead of the builtin <code>float</code> class.</p>
<pre><code>def _remove_leading_zero(value, string):
    if 1 &gt; value &gt; -1:
        string = string.replace('0', '', 1)
    return string


class MyFloat(float):
    def __str__(self):
        string = super().__str__()
        return _remove_leading_zero(self, string)

    def __format__(self, format_string):
        string = super().__format__(format_string)
        return _remove_leading_zero(self, string)
</code></pre>
<p>Using this class you'll have to use <code>str.format</code> function instead of the modulus operator (<code>%</code>) for formatting. Following are some examples:</p>
<pre><code>&gt;&gt;&gt; print(MyFloat(.4444))
.4444

&gt;&gt;&gt; print(MyFloat(-.4444))
-.4444

&gt;&gt;&gt; print('some text {:.3f} some more text',format(MyFloat(.4444)))
some text .444 some more text

&gt;&gt;&gt; print('some text {:+.3f} some more text',format(MyFloat(.4444)))
some text +.444 some more text
</code></pre>
<p>If you also want to make the modulus operator (<code>%</code>) of <code>str</code> class to behave the same way then you'll have to override the <code>__mod__</code> method of <code>str</code> class by subclassing the class. But it won't be as easy as overriding the <code>__format__</code> method of <code>float</code> class, as in that case the formatted float number could be present at any position in the resultant string.</p>
<p>[Note: All the above code is written in Python3. <strong>You'll also have to override <code>__unicode__</code> in Python2</strong> and also have to change the <code>super</code> calls.]</p>
<p>P.S.: You may also override <code>__repr__</code> method similar to <code>__str__</code>, if you also want to change the <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer">official string representation</a> of <code>MyFloat</code>.</p>
<hr/>
<hr/>
<hr/>
<p><strong>Edit</strong>: Actually you can add new syntax to format sting using <code>__format__</code> method. So, if you want to keep both behaviours, i.e. show leading zero when needed and don't show leading zero when not needed. You may create the <code>MyFloat</code> class as follows:</p>
<pre><code>class MyFloat(float):
    def __format__(self, format_string):
        if format_string.endswith('z'):  # 'fz' is format sting for floats without leading the zero
            format_string = format_string[:-1]
            remove_leading_zero = True
        else:
            remove_leading_zero = False

        string = super(MyFloat, self).__format__(format_string)
        return _remove_leading_zero(self, string) if remove_leading_zero else string
        # `_remove_leading_zero` function is same as in the first example
</code></pre>
<p>And use this class as follows:</p>
<pre><code>&gt;&gt;&gt; print('some text {:.3f} some more text',format(MyFloat(.4444)))
some text 0.444 some more text
&gt;&gt;&gt; print('some text {:.3fz} some more text',format(MyFloat(.4444)))
some text .444 some more text


&gt;&gt;&gt; print('some text {:+.3f} some more text',format(MyFloat(.4444)))
some text +0.444 some more text
&gt;&gt;&gt; print('some text {:+.3fz} some more text',format(MyFloat(.4444)))
some text +.444 some more text


&gt;&gt;&gt; print('some text {:.3f} some more text',format(MyFloat(-.4444)))
some text -0.444 some more text
&gt;&gt;&gt; print('some text {:.3fz} some more text',format(MyFloat(-.4444)))
some text -.444 some more text
</code></pre>
<p>Note that using 'fz' instead of 'f' removes the leading zero.</p>
<p>Also, the above code works in both Python2 and Python3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another way:</p>
<pre><code>&gt;&gt;&gt; ("%.4f" % k).lstrip('0')
'.1337'
</code></pre>
<p>It is slightly more general than <code>[1:]</code> in that it also works with numbers &gt;=1.</p>
<p>Neither method correctly handles negative numbers, however. The following is better in this respect:</p>
<pre><code>&gt;&gt;&gt; re.sub('0(?=[.])', '', ("%0.4f" % -k))
'-.1337'
</code></pre>
<p>Not particularly elegant, but right now I can't think of a better method.</p>
</div>
<div class="post-text" itemprop="text">
<p>As much as I like cute regex tricks, I think a straightforward function is the best way to do this:</p>
<pre><code>def formatFloat(fmt, val):
  ret = fmt % val
  if ret.startswith("0."):
    return ret[1:]
  if ret.startswith("-0."):
    return "-" + ret[2:]
  return ret

&gt;&gt;&gt; formatFloat("%.4f", .2)
'.2000'
&gt;&gt;&gt; formatFloat("%.4f", -.2)
'-.2000'
&gt;&gt;&gt; formatFloat("%.4f", -100.2)
'-100.2000'
&gt;&gt;&gt; formatFloat("%.4f", 100.2)
'100.2000'
</code></pre>
<p>This has the benefit of being easy to understand, partially because <code>startswith</code> is a simple string match rather than a regex.</p>
</div>
<div class="post-text" itemprop="text">
<p>One viable option which works without regex and with negative numbers greater than 10</p>
<pre><code>k = -.1337
("%.4f" % k).replace("-0","-").lstrip("0")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd rather go for readable and simple than anything else: Let's handle the sign and the numerics independently. And a little in-line if statement never hurt anyone.</p>
<pre><code>k = -.1337
"".join( ["-" if k &lt; 0 else "", ("%.4f" % abs(k)).lstrip('0')] )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re
re.sub("^(\-?)0\.", r'\1.', "%.4f" % k)
</code></pre>
<p>This is short, simple and I can't find a scenario for which it doesn't work.</p>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.sub("^(\-?)0\.", r'\1.', "%.4f" % 0)
'.0000'
&gt;&gt;&gt; re.sub("^(\-?)0\.", r'\1.', "%.4f" % 0.1337)
'.1337'
&gt;&gt;&gt; re.sub("^(\-?)0\.", r'\1.', "%.4f" % 1.337)
'1.3370'
&gt;&gt;&gt; re.sub("^(\-?)0\.", r'\1.', "%.4f" % -0)
'.0000'
&gt;&gt;&gt; re.sub("^(\-?)0\.", r'\1.', "%.4f" % -0.1337)
'-.1337'
&gt;&gt;&gt; re.sub("^(\-?)0\.", r'\1.', "%.4f" % -1.337)
'-1.3370'
&gt;&gt;&gt; re.sub("^(\-?)0\.", r'\1.', "%.4f" % 10.337)
'10.3370'
&gt;&gt;&gt; re.sub("^(\-?)0\.", r'\1.', "%.4f" % -10.337)
'-10.3370'
</code></pre>
<p><strong>Edit</strong>:
If you are only considering numbers &gt; -10 and &lt; 10 The following will work:</p>
<pre><code>("%.4f", k).replace('0.', '.')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>.lstrip()</code>, after using string formatting to convert to a string:</p>
<pre><code>&gt;&gt;&gt; k = .1827412
&gt;&gt;&gt; print ("%.4f"%(k)).lstrip('0')
.1827
&gt;&gt;&gt; 
</code></pre>
<p><code>.lstrip()</code> can be used to remove any of the leading characters of a string:</p>
<pre><code>&gt;&gt;&gt; k = 'bhello'
&gt;&gt;&gt; print k.lstrip('b')
hello
&gt;&gt;&gt; print k.lstrip('bhel')
o
&gt;&gt;&gt; print k.lstrip('bel')
hello
&gt;&gt;&gt; 
</code></pre>
<p><a href="https://docs.python.org/2/library/string.html#string.lstrip" rel="nofollow"><em>From the docs</em></a>:</p>
<blockquote>
<p>string.lstrip(s[, chars])</p>
<p>        Return a copy of the string with leading characters removed</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Since we're only considering &gt; -1 to &lt; 1 then the following edit will work.</p>
<pre><code>import re
re.sub(r"0+\.", ".", %0.4f" % k)
</code></pre>
<p>This will maintain the sign, only removing the digit to the left of the decimal.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am surprised nobody suggested a more mathematical way to do it:</p>
<pre><code>n = 0.123456789
'.%d' % (n*1e4)
</code></pre>
<p>Looks much nicer to me. :)</p>
<p>But interestingly yours is the fastest.</p>
<pre><code>$ python -mtimeit '".%d" % (0.123456789*1e4)'
1000000 loops, best of 3: 0.809 usec per loop
$ python -mtimeit '("%.4f"%(0.123456789)).lstrip("0")'
1000000 loops, best of 3: 0.209 usec per loop
$ python -mtimeit '("%.4f"%(0.123456789))[1:]'
10000000 loops, best of 3: 0.0723 usec per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's standard lib's str.format() can be used to generate the string conversion of the float value.  Then the string can be manipulated to form a final result for either a positive or negative number.</p>
<pre><code>n = -.1234567890
print('{0}'.format('-' if n &lt; 0 else '') + ('{:0.4}'.format(n).split('-')[1 if n &lt; 0 else 0].lstrip('0')))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>For Python 3</h1>
<p>When you want something simple and don't need negative number support:</p>
<pre><code>f'{k:.4f}'.lstrip('0')
</code></pre>
<p>There are other solutions when you need negative number support, including the excellent regex by @nettux443. </p>
</div>
<span class="comment-copy">What happens when your value is 0?</span>
<span class="comment-copy">'.0000' I guess</span>
<span class="comment-copy">After studying <a href="https://docs.python.org/2/library/string.html" rel="nofollow noreferrer">the documentation</a>, it seems that there is no canonical way to do this.</span>
<span class="comment-copy">to clarify in the event of minus numbers like -0.1 do you want -.1000?</span>
<span class="comment-copy">Yes, I think the most surprising thing is that this isn't possible with format specifiers alone.</span>
<span class="comment-copy">Doesn't your <code>remove_leading_zeros</code> really <code>remove_all_zeros</code>. Seems clunky and incorrect.</span>
<span class="comment-copy">@hobs, Please test the code before pointing out any issues, it works as expected. <code>string.replace('0', '', 1)</code> would only remove the first zero and <code>if 1 &gt; value &gt; -1</code> condition would make sure that it is only applied when the string is in form <code>0.&lt;some digits&gt;</code>.</span>
<span class="comment-copy">Here's my (<i>unfair/unrealistic</i>) test case that produced an incorrect answer: <code>'.402'.replace('0', '', 1)</code> -&gt; <code>.42</code> . Your code would work for all strings produced by the <code>__str__</code> on <code>float</code>s as currently defined, but your code is fragile (clunky). It's not idempotent. And it's not future-proof. <code>lstrip</code> is much more concise and robust (idempotent and future-proof). Your <code>replace</code> operation could not be applied more than once. And if your particular number type didn't stringify the way python builtin floats did, well...</span>
<span class="comment-copy">I am sure there is a different way but I guess this works.</span>
<span class="comment-copy">The regex here will not work correctly on numbers with absolute value greater than ten that have a zero in the ones place. For example, 100.1337 becomes 10.1337.</span>
<span class="comment-copy">I edited the regex to work with all real number inputs. Awaiting peer review. (<code>re.sub(r'^(-?)0(?=\.)', r'\1', ...)</code>)</span>
<span class="comment-copy">@musicinmybrain You should write up your own answer with that regex</span>
<span class="comment-copy">@musicinmybrain Editing another person's answer is for cleaning-up when something could be stated in a better way, not for fundamentally changing the answer. I agree with Rob Watts that you should create your own answer.</span>
<span class="comment-copy"><code>.</code> is a regex metacharacter.  Do you realize what would happen if <code>k</code> is <code>-100.1337</code>?</span>
<span class="comment-copy">@devnull I accepted the answer 2 years ago. I actually didn't use his answer at the time because I didn't have to deal with negative numbers. Using replace wouldn't have any issues. I am not sure why you commented on this other than to get my attention to cancel my previous answer accept?</span>
<span class="comment-copy">I didn't realize that this was an answer to your question.  Coming back to my comment, it'd produce <code>-10.1337</code> for the above example.</span>
<span class="comment-copy">Modified to work with numbers &gt;= 10</span>
<span class="comment-copy">It's shorter if you concatenate <code>+</code> rather than using <code>join</code>. 'course, you'll need parenthesis around the sign logic.</span>
<span class="comment-copy">I looked into using "+" for concatenation, because I've heard that it is not very pythonic. It turns out that using "".join() instead of + is about two orders of magnitude faster, and it also fits better into the style of python. That said, + is totally equivalent and probably easier to think up for almost any use case.</span>
<span class="comment-copy">What about <code>k=10.2</code></span>
<span class="comment-copy">@JacobKrall damn you sir! edited to use <code>re.sub</code> and bracket matching works now</span>
<span class="comment-copy">The OP only wants to trim digits left of the decimal point when the number is less than 1 and more than -1 eg 0.1 -&gt; .1000 but 1.0 -&gt; 1.0000</span>
<span class="comment-copy">I updated to conform more to the OP @nettux443. Thanks for pointing that out.</span>
<span class="comment-copy">Nice trick for numbers [0,1). It doesn't work outside of that range, though (not for negative numbers, or numbers &gt;= 1.0.</span>
