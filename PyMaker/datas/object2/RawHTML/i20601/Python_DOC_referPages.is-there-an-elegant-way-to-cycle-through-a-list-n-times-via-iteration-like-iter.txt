<div class="post-text" itemprop="text">
<p>I'd like to cycle through a list repeatedly (N times) via an iterator, so as not to actually store N copies of the list in memory.  Is there a built-in or elegant way to do this without writing my own generator?</p>
<p>Ideally, itertools.cycle(my_list) would have a second argument to limit how many times it cycles...  alas, no such luck.  </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools
itertools.chain.from_iterable(itertools.repeat([1, 2, 3], 5))
</code></pre>
<p>Itertools is a wonderful library. :)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>itertools.chain.from_iterable(iter(L) for x in range(N))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the special case where you need to iterate over a list several times, this is not too bad.</p>
<p>It does create a list of <code>n</code> references to <code>my_list</code>, so if <code>n</code> is very large it is better to use Darthfelt's answer</p>
<pre><code>&gt;&gt;&gt; import itertools as it
&gt;&gt;&gt; it.chain(*[my_list]*n)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All the other answers are excellent. Another solution would be to use <code>islice</code>. This allows you to interrupt the cycle at any point:</p>
<pre><code>&gt;&gt;&gt; from itertools import islice, cycle
&gt;&gt;&gt; l = [1, 2, 3]
&gt;&gt;&gt; list(islice(cycle(l), len(l) * 3))
[1, 2, 3, 1, 2, 3, 1, 2, 3]
&gt;&gt;&gt; list(islice(cycle(l), 7))
[1, 2, 3, 1, 2, 3, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You said that you don't want to write your own generator, but a generator expression would probably be the easiest and most efficient way to accomplish what you're after. It doesn't require any function calls or importing of any modules. <code>itertools</code> is a great module, but maybe not necessary in this case?</p>
<pre><code>some_list = [1, 2, 3]
cycles = 3
gen_expr = (elem for _ in xrange(cycles) for elem in some_list)
</code></pre>
<p>or just</p>
<pre><code>(elem for _ in xrange(3) for elem in [1, 2, 3])
</code></pre>
<p>or</p>
<pre><code>for elem in (e for _ in xrange(3) for e in [1, 2, 3]):
    print "hoo-ray, {}!".format(elem)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@Darthfett's answer is documented as an <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a>:</p>
<pre><code>from itertools import chain, repeat

def ncycles(iterable, n):
    "Returns the sequence elements n times"
    return chain.from_iterable(repeat(tuple(iterable), n))


list(ncycles(["a", "b"], 3))
# ['a', 'b', 'a', 'b', 'a', 'b']
</code></pre>
<p>For convenience, I add that the <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> library implements this recipe (and many others) for you:</p>
<pre><code>import more_itertools as mit

list(mit.ncycles(["a", "b"], 3))
# ['a', 'b', 'a', 'b', 'a', 'b']
</code></pre>
</div>
<span class="comment-copy">I believe that multiplying a list by an integer is not good enough, right?  <code>[1, 2, 3] * 4</code></span>
<span class="comment-copy">@C2H5OH That would create 4 shallow copies of the list (N copies is what is not wanted).</span>
<span class="comment-copy">@Darthfett: Indeed.  That's why it is a comment.  But you will agree that it is the most elegant solution :-P</span>
<span class="comment-copy">This is a fairly clear answer, doesn't involve my own generator/iterator (although Matt Anderson's answer shows that that isn't too messy either), and was one of the first answers that satisfied my question.  So, I accept it.  Thanks!!</span>
<span class="comment-copy">I was trying to avoid duplicating the list (or references to it) in memory, otherwise just: mylist*n would have sufficed. :-)  Still, thanks for your input.  Just to be clear, is there any difference between expanding the list via the *list operator and multiplying by n versus just multiplying the list by n?</span>
<span class="comment-copy">@JJC, <code>mylist*n</code> creates a list with <code>len(mylist)*n)</code> elements. For this answer you just create a list of <code>n</code> elements, so depending on <code>len(mylist)</code> and <code>n</code> this could make a huge difference</span>
<span class="comment-copy">I understand that [1,2,3,4]*2 would create a list of 8 elements. So, you're saying that *[1,2,3,4]*2 creates just two elements?  Sorry, I'm confused. Thanks.</span>
<span class="comment-copy">@JJC, no [[1,2,3,4]]*2 creates a list of 2 elements</span>
<span class="comment-copy">Nice, I didn't know islice worked with values for <code>stop</code> that were greater than the length of the iterable.</span>
<span class="comment-copy">@Darthfett, yes, it does. But that's not relevant here; the iterable returned by <code>cycle</code> is infinitely long.</span>
<span class="comment-copy">I do like these generator expressions.  They're more compact than I realized they'd be for this pattern. I'll give the answer credit to @Darthfett, since technically I asked for a non-self-rolled generator, but if I could accept two, I'd accept yours as well (and probably others' :-))  Thanks!</span>
<span class="comment-copy">Thanks, but this is identical to Darthfett's accepted answer.</span>
<span class="comment-copy">Yes, they are equivalent.  I edited to clarify that his code is an existing <code>itertools</code> recipe (no earlier than Python 2.3).  I post this option to demonstrate a third-party library that implements these recipes and obviates manual implementation if desired.  Thank you.</span>
<span class="comment-copy">Cool. That more_itertools package looks very handy. Thanks for sharing it.</span>
