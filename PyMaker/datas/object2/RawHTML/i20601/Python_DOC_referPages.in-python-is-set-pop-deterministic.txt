<div class="post-text" itemprop="text">
<p>I understand that the elements of a python set are not ordered.  Calling the pop method returns an arbitrary element; I'm fine with that.</p>
<p>What I'm wondering is whether or not pop will ALWAYS return the same element when the set has the same history.  Within one version of python of course, I don't mind if different versions/implementations of python do their own thing.  In particular, I'm asking about python 2.7.  It's a matter of implementation more than of api in this case.</p>
<p>I'm using sets a lot in a procedural dungeon generator for a game, and I'd like the outcome to be deterministic for a given seed.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer in general is <strong>no.</strong> The python source that @Christophe and @Marcin (un)helpfully point to shows that elements are popped in the order they appear in the hash table. So, pop order (and presumably iteration order) <em>is</em> deterministic, but only for <em>fixed</em> hash values.
That's the case for numbers but <em>not</em> for strings, according to the <strong>Note</strong> in the documentation of <a href="https://docs.python.org/3.5/reference/datamodel.html#object.__hash__"><code>__hash__</code></a>, which incidentally also touches on your question directly:</p>
<blockquote>
<p>Note by default the <strong>hash</strong>() values of str, bytes and datetime objects are “salted” with an unpredictable random value. Although they remain constant within an individual Python process, they are not predictable between repeated invocations of Python. </p>
<p>[ ... ]</p>
<p>Changing hash values affects the iteration order of dicts, sets and other mappings. Python has never made guarantees about this ordering (and it typically varies between 32-bit and 64-bit builds).</p>
</blockquote>
<p><strong>Edit:</strong> As @Marcin points out, the link I quoted does not apply to Python 2.
Hash randomization <a href="https://docs.python.org/3/whatsnew/3.3.html#summary-release-highlights">became the default with Python 3.3.</a> Python 2.7 does not have intentionally non-deterministic string hashing by default.</p>
<p>In general, this is a problem for any object whose hash is not a repeatable function of its value (e.g., if the hash is based on memory address). But conversely, if you define your own <code>__hash__</code> method for the objects in your sets, you can expect that they will be returned in a reproducible order. (Provided the set's history and the platform are kept fixed).</p>
</div>
<div class="post-text" itemprop="text">
<p>Internally I think the situation is similar to <code>dict</code>. The order is determined by an hash algorithm, which in <em>some</em> situations will yield the same results. But you should not depend on that, since once the number of elements gets large, the set will encounter collisions  (that is it's internal hashing), which eventually lead to a different ordering.</p>
<p>In short: No, <code>set.pop()</code> is not deterministic. Don't assume any order, since the API explicitly states, that</p>
<blockquote>
<p>a set object is an <strong>unordered</strong> collection</p>
</blockquote>
<ul>
<li>Docs: <a href="http://docs.python.org/library/stdtypes.html#set-types-set-frozenset" rel="noreferrer">http://docs.python.org/library/stdtypes.html#set-types-set-frozenset</a></li>
<li>Source: <a href="http://svn.python.org/view/python/trunk/Objects/setobject.c?view=markup" rel="noreferrer">http://svn.python.org/view/python/trunk/Objects/setobject.c?view=markup</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/stdtypes.html#set-types-set-frozenset" rel="nofollow">The documentation</a> does not specify that it must be deterministic, therefore you should assume that it isn't.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to force determinism, you could try something like </p>
<pre><code>value = min(my_set)
my_set.remove(value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you really are targeting one particular version of python, then you can look at the source, and test its behaviour (but test well - consider load factors and the like).</p>
<p>If you want portability, or you find <code>set</code> doesn't perform as required, use an ordereddict (here's one: <a href="http://code.activestate.com/recipes/576693/" rel="nofollow">http://code.activestate.com/recipes/576693/</a> ;  there are loads of others, so find one you like the look of), and adapt it as a set.</p>
<p>Update: here's an ordered set: <a href="http://packages.python.org/Brownie/api/datastructures.html#brownie.datastructures.OrderedSet" rel="nofollow">http://packages.python.org/Brownie/api/datastructures.html#brownie.datastructures.OrderedSet</a></p>
</div>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/3949310/how-is-cpythons-set-implemented" title="how is cpythons set implemented">stackoverflow.com/questions/3949310/…</a> and <a href="http://svn.python.org/view/python/trunk/Objects/setobject.c?view=markup" rel="nofollow noreferrer">svn.python.org/view/python/trunk/Objects/…</a></span>
<span class="comment-copy">Why not test it /  look at the source?</span>
<span class="comment-copy">@delnan " In particular, I'm asking about python 2.7. It's a matter of implementation more than of api in this case." So, no need to test several versions, or future versions as you suggest. You seem to have imagined a requirement for portability and eternity.</span>
<span class="comment-copy">@Marcin Ah yes, sorry. I missed that. It' kind of a knee-jerk reaction, many comments like this actually have the flaws I wrongly accused yours of ("Is ... undefined behavior in C89?" -- "Just try if your version of your compiler, on your machine, with the flags you happen to choose, makes it work").</span>
<span class="comment-copy">If you have the <i>exact</i> same set of objects, and you can guarantee that the same hash function is used, then yes, <code>set.pop()</code>, as well as <code>list(set())</code> can be deterministic.</span>
<span class="comment-copy">You are referring to the documentation for the dev version of python. This question is about python 2.7, and the text you quote does not appear in the corresponding document for that version: <a href="http://docs.python.org/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">docs.python.org/reference/datamodel.html#object.__hash__</a></span>
<span class="comment-copy">Thanks for spotting that!</span>
<span class="comment-copy">Given that the question appears to be about a specific version, there is no need to assume anything - the source can be checked, and behaviour tested.</span>
<span class="comment-copy">note that this is only deterministic when min() is unambiguous. It is possible to have a weird set with distinct values where there are two or more which are all less than all the others (and both are less than the other). not common in the wild, but possible.</span>
<span class="comment-copy">A better example would be values that simply can't be ordered (i.e. which can only be compared for equality). A definition of <code>__lt__</code> which allows <code>x &lt; y</code> and <code>y &lt; x</code> simultaneously, while legal to write, is frankly broken.</span>
<span class="comment-copy">when the set cannot be ordered (e.g., a set of complex numbers), your solution will fail anyway with a TypeError. But consider <code>class epsilon(float): def __lt__(self, other): return True if 0 &lt; other</code></span>
<span class="comment-copy">Ordereddict is in stdlib in 2.7 and 3.1+ (<a href="http://docs.python.org/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">docs.python.org/library/…</a>, <a href="http://docs.python.org/dev/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">docs.python.org/dev/library/…</a>)</span>
<span class="comment-copy">@miku Given that it's implemented in C, that cannot be adapted portably, as specified in the very same sentence you are responding to.</span>
