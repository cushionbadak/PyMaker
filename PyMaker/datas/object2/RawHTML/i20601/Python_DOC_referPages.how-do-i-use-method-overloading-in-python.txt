<div class="post-text" itemprop="text">
<p>I am trying to implement method overloading in Python: </p>
<pre><code>class A:
    def stackoverflow(self):    
        print 'first method'
    def stackoverflow(self, i):
        print 'second method', i

ob=A()
ob.stackoverflow(2)
</code></pre>
<p>but the output is <code>second method 2</code>; similarly:</p>
<pre><code>class A:
    def stackoverflow(self):    
        print 'first method'
    def stackoverflow(self, i):
        print 'second method', i

ob=A()
ob.stackoverflow()
</code></pre>
<p>gives</p>
<pre><code>Traceback (most recent call last):
  File "my.py", line 9, in &lt;module&gt;
    ob.stackoverflow()
TypeError: stackoverflow() takes exactly 2 arguments (1 given)
</code></pre>
<p>How do I make this work?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's method <em>overloading</em> not method <em>overriding</em>. And in Python, you do it all in one function:</p>
<pre><code>class A:

    def stackoverflow(self, i='some_default_value'):    
        print 'only method'

ob=A()
ob.stackoverflow(2)
ob.stackoverflow()
</code></pre>
<p>You can't have two methods with the same name in Python -- and you don't need to.</p>
<p>See the <a href="http://docs.python.org/tutorial/controlflow.html#default-argument-values" rel="noreferrer">Default Argument Values</a> section of the Python tutorial. See <a href="https://stackoverflow.com/questions/1132941/least-astonishment-in-python-the-mutable-default-argument">"Least Astonishment" and the Mutable Default Argument</a> for a common mistake to avoid.</p>
<p><strong>Edit</strong>: See <a href="http://www.python.org/dev/peps/pep-0443/" rel="noreferrer">PEP 443</a> for information about the new single dispatch generic functions in Python 3.4.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, you don't do things that way. When people do that in languages like Java, they generally want a default value (if they don't, they generally want a method with a different name). So, in Python, <a href="http://docs.python.org/tutorial/controlflow.html#default-argument-values" rel="noreferrer">you can have default values</a>.</p>
<pre><code>class A(object):  # Remember the ``object`` bit when working in Python 2.x

    def stackoverflow(self, i=None):
        if i is None:
            print 'first form'
        else:
            print 'second form'
</code></pre>
<p>As you can see, you <em>can</em> use this to trigger separate behaviour rather than merely having a default value.</p>
<pre><code>&gt;&gt;&gt; ob = A()
&gt;&gt;&gt; ob.stackoverflow()
first form
&gt;&gt;&gt; ob.stackoverflow(2)
second form
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <a href="https://pypi.python.org/pypi/pythonlangutil/0.1" rel="nofollow noreferrer">pythonlangutil</a>:</p>
<pre><code>from pythonlangutil.overload import Overload, signature

class A:
    @Overload
    @signature()
    def stackoverflow(self):    
        print 'first method'

    @stackoverflow.overload
    @signature("int")
    def stackoverflow(self, i):
        print 'second method', i
</code></pre>
<p><strong>Edit:</strong> With official support of Overloading in Python 3 you can use <a href="https://docs.python.org/3/library/typing.html#typing.overload" rel="nofollow noreferrer">@overload</a> decorator. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can't, never need to and don't really want to.</p>
<p>In Python, everything is an object. Classes are things, so they are objects. So are methods.</p>
<p>There is an object called <code>A</code> which is a class. It has an attribute called <code>stackoverflow</code>. It can only have one such attribute.</p>
<p>When you write <code>def stackoverflow(...): ...</code>, what happens is that you create an object which is the method, and assign it to the <code>stackoverflow</code> attribute of <code>A</code>. If you write two definitions, the second one replaces the first, the same way that assignment always behaves.</p>
<p>You furthermore do not want to write code that does the wilder of the sorts of things that overloading is sometimes used for. That's not how the language works.</p>
<p>Instead of trying to define a separate function for each type of thing you could be given (which makes little sense since you don't specify types for function parameters anyway), <em>stop worrying about what things <strong>are</strong> and start thinking about what they can <strong>do</strong></em></p></div>
<div class="post-text" itemprop="text">
<p>I write my answer in Python 3.2.1.</p>
<pre><code>def overload(*functions):
    return lambda *args, **kwargs: functions[len(args)](*args, **kwargs)
</code></pre>
<p>How it works:</p>
<ol>
<li><code>overload</code> takes any amount of callables and stores them in tuple <code>functions</code>, then returns lambda.</li>
<li>The lambda takes any amount of arguments, 
then returns result of calling function stored in <code>functions[number_of_unnamed_args_passed]</code> called with arguments  passed to the lambda.</li>
</ol>
<p>Usage:</p>
<pre><code>class A:
    stackoverflow=overload(                    \
        None, \ 
        #there is always a self argument, so this should never get called
        lambda self: print('First method'),      \
        lambda self, i: print('Second method', i) \
    )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the word you're looking for is "overloading".  There is no method overloading in python.  You can however use default arguments, as follows.</p>
<pre><code>def stackoverflow(self, i=None):
    if i != None:     
        print 'second method', i
    else:
        print 'first method'
</code></pre>
<p>When you pass it an argument it will follow the logic of the first condition and execute the first print statement.  When you pass it no arguments, it will go into the <code>else</code> condition and execute the second print statement.</p>
</div>
<div class="post-text" itemprop="text">
<p>I write my answer in Python 2.7:</p>
<p>In Python, method overloading is not possible; if you really want access the same function with different features, I suggest you to go for method overriding.</p>
<pre><code>class Base(): # Base class
    '''def add(self,a,b):
        s=a+b
        print s'''

    def add(self,a,b,c):
        self.a=a
        self.b=b
        self.c=c

        sum =a+b+c
        print sum

class Derived(Base): # Derived class
    def add(self,a,b): # overriding method
        sum=a+b
        print sum



add_fun_1=Base() #instance creation for Base class
add_fun_2=Derived()#instance creation for Derived class

add_fun_1.add(4,2,5) # function with 3 arguments
add_fun_2.add(4,2)   # function with 2 arguments
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python, overloading is not an applied concept. However, if you are trying to create a case where, for instance, you want one initializer to be performed if passed an argument of type <code>foo</code> and another initializer for an argument of type <code>bar</code> then, since everything in Python is handled as object, you can check the name of the passed object's class type and write conditional handling based on that.</p>
<pre><code>class A:
   def __init__(self, arg)
      # Get the Argument's class type as a String
      argClass = arg.__class__.__name__

      if argClass == 'foo':
         print 'Arg is of type "foo"'
         ...
      elif argClass == 'bar':
         print 'Arg is of type "bar"'
         ...
      else
         print 'Arg is of a different type'
         ...
</code></pre>
<p>This concept can be applied to multiple different scenarios through different methods as needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, you'd do this with a default argument.</p>
<pre><code>class A:

    def stackoverflow(self, i=None):    
        if i == None:
            print 'first method'
        else:
            print 'second method',i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just came across this <a href="https://github.com/bintoro/overloading.py" rel="noreferrer">https://github.com/bintoro/overloading.py</a> for anybody who may be interested.</p>
<p>From the linked repository's readme:</p>
<blockquote>
<p>overloading is a module that provides function dispatching based on
  the types and number of runtime arguments.</p>
<p>When an overloaded function is invoked, the dispatcher compares the
  supplied arguments to available function signatures and calls the
  implementation that provides the most accurate match.</p>
<p>Features</p>
<p>Function validation upon registration and detailed resolution rules
  guarantee a unique, well-defined outcome at runtime. Implements
  function resolution caching for great performance. Supports optional
  parameters (default values) in function signatures. Evaluates both
  positional and keyword arguments when resolving the best match.
  Supports fallback functions and execution of shared code. Supports
  argument polymorphism. Supports classes and inheritance, including
  classmethods and staticmethods.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Python does not support method overloading like Java or C++. We may overload the methods but can only use the latest defined method.</p>
<pre><code># First sum method.
# Takes two argument and print their sum
def sum(a, b):
    s = a + b
    print(s)

# Second sum method
# Takes three argument and print their sum
def sum(a, b, c):
    s = a + b + c
    print(s)

# Uncommenting the below line shows an error    
# sum(4, 5)

# This line will call the second sum method
sum(4, 5, 5)
</code></pre>
<p>We need to provide optional arguments or *args in order to provide different number of args on calling.</p>
<p>Courtesy from <a href="https://www.geeksforgeeks.org/python-method-overloading/" rel="nofollow noreferrer">https://www.geeksforgeeks.org/python-method-overloading/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>While @agf was right with the answer in the past now with <a href="https://www.python.org/dev/peps/pep-3124/" rel="nofollow noreferrer">PEP-3124</a> we got our syntax sugger. See <a href="https://docs.python.org/3/library/typing.html#typing.overload" rel="nofollow noreferrer">typing documentation for details</a>  on the <code>@overload</code> decorator but note that this is really just syntax sugger and IMHO this is all people have been arguing about ever since. Personally I agree that having multiple functions with different signatures makes it more readable then having a single function with 20+ arguments all set to a default value (<code>None</code> most of the time) and then having to fiddle around using endless <code>if</code>, <code>elif</code>, <code>else</code>chains to find out what the caller actually wants our function to do with the provided set of arguments. This, this is long overdue following the Python Zen </p>
<blockquote>
<p>Beautiful is better than ugly.</p>
</blockquote>
<p>and arguably also </p>
<blockquote>
<p>Simple is better than complex.</p>
</blockquote>
<p>Straight from the official Python documentation linked above: </p>
<pre><code>@overload
def process(response: None) -&gt; None:
    ...
@overload
def process(response: int) -&gt; Tuple[int, str]:
    ...
@overload
def process(response: bytes) -&gt; str:
    ...
def process(response):
    &lt;actual implementation&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.x includes standard typing library which allows for method overloading with the use of @overload decorator. Unfortunately, this is to make the code more readable, as the @overload decorated methods will need to be followed by a non-decorated method that handles different arguments. 
More can be found here <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">here</a> but for your example:</p>
<pre><code>from typing import overload
from typing import Any, Optional
class A(object):
    @overload
    def stackoverflow(self) -&gt; None:    
        print('first method')
    @overload
    def stackoverflow(self, i: Any) -&gt; None:
        print('second method', i)
    def stackoverflow(self, i: Optional[Any] = None) -&gt; None:
        if not i:
            print('first method')
        else:
            print('second method', i)

ob=A()
ob.stackoverflow(2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In MathMethod.py file</p>
<pre><code>from multipledispatch import dispatch
@dispatch(int,int)
def Add(a,b):
   return a+b 
@dispatch(int,int,int)  
def Add(a,b,c):
   return a+b+c 
@dispatch(int,int,int,int)    
def Add(a,b,c,d):
   return a+b+c+d
</code></pre>
<p>In Main.py file</p>
<pre><code>import MathMethod as MM 
print(MM.Add(200,1000,1000,200))
</code></pre>
<p>We can overload method by using multipledispatch </p>
</div>
<span class="comment-copy">In Python, think of methods as a special set of "<i>attributes</i>", and there can only be one "<i>attribute</i>" (and thus one method) of a given name for an object. The last method <i>overwrites</i> any previous methods. In Java, methods are not first-class citizens (they are not "attributes of objects"), but are rather invoked by "sending messages" that are are statically resolved based on closest type (which is where <i>overloading</i> comes in).</span>
<span class="comment-copy">Also see <a href="http://stackoverflow.com/questions/733264/function-overloading-in-python-missing" title="function overloading in python missing">stackoverflow.com/questions/733264/â€¦</a></span>
<span class="comment-copy">and <a href="http://stackoverflow.com/questions/6434482/python-function-overloading" title="python function overloading">stackoverflow.com/questions/6434482/python-function-overloading</a></span>
<span class="comment-copy">Why is none of the answers to this question accepted yet? Just click on the outlied check mark on the left of your favourite answer...</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/7113032/overloaded-functions-in-python">Overloaded functions in python?</a></span>
<span class="comment-copy"><i>and you don't need to</i> - IMHO sometime it would be very handy to have method overloading like e.g. in C++.  Ok, it is not 'needed' in the sense that it can't be done using other constructs - but it would make some things easier and simpler.</span>
<span class="comment-copy">@AndreasFlorath I disagree. Learn to love duck typing and write each method so it only does one thing, and there is no need for method overloading.</span>
<span class="comment-copy">+1 for making me read about the "common mistake to avoid" before I got caught</span>
<span class="comment-copy">I would like to disagree a little bit  ;) ... overloading often make code cleaner, because you don't pack the method with too many if-else statement to handle different cases. In a sense the whole gamut of functional languages use similar idea i.e. argument-pattern-matching. Which mean you would have smaller more cleaner methods.. rather than giant unreadable ones.</span>
<span class="comment-copy">@user1019129  That's the purpose of the single dispatch generic functions added in Python 3.4, and linked in my answer.</span>
<span class="comment-copy">Mostly <code>None</code> is useful when you want a mutable default value. Separate behavior should be in separate functions.</span>
<span class="comment-copy">@agf: <code>None</code> can also be useful as a genuine default value.</span>
<span class="comment-copy">Yes, but I was referring to using it as a sentinel value, which is how you use it in your answer, and as I think my comment makes clear.</span>
<span class="comment-copy">I think that's the only valid answer to the question. I would double-upvote if I could.</span>
<span class="comment-copy">it's good, but it doesn't work on raw functions, just methods within a class.</span>
<span class="comment-copy">@LegitStack That functionality can also be added. It's not impossible.</span>
<span class="comment-copy">@EhsanKeshavarzian I did add it to my own version, and it seems to work, but I don't know if I did it the right way. I also added functionality to allow a signature to be a dictionary so you can specify the name of the argument. that way you can have two functions with the same type signatures but different names and you can differentiate between the two as long as the arguments are named.</span>
<span class="comment-copy">@LegitStack There are multiple ways of doing it. There is also <a href="https://github.com/bintoro/overloading.py" rel="nofollow noreferrer">github.com/bintoro/overloading.py</a> But with Python 3 support of Overloading I do not think there is any need for third party libraries anymore. <a href="https://docs.python.org/3/library/typing.html#typing.overload" rel="nofollow noreferrer">docs.python.org/3/library/typing.html#typing.overload</a></span>
<span class="comment-copy">TBH, I would be more careful with "never need to". This is something that can be tagged upon every feature of any real world and turing complete programming language, and therefore is not a valid argument. Who <i>needs</i> generators? Who <i>needs</i> classes? Programming languages are just syntactic sugar to something more concrete.</span>
<span class="comment-copy">Completely disagree. It may be that you "never needed to" or "never wanted to", but there are enough applications where you desparately want to. Try e.g. writing a program that handles both Python and numpy arrays gracefully without littering your program with instanceof's ...</span>
<span class="comment-copy">Based on masi's answer, I'd say that "you can't" is now incorrect and obsolete. Based on the existence of the <code>@overload</code> decorator, I'd say that "don't really want to" is arguable, at best. From PEP-3124, "...it is currently a common anti-pattern for Python code to inspect the types of received arguments...the 'obvious way' to do this is by type inspection, but this is brittle and closed to extension..." So it seems as if enough people wanted to, that it became part of Python.</span>
<span class="comment-copy">this looks like the most elegant solution to me.</span>
<span class="comment-copy">elegant one +1.</span>
<span class="comment-copy">good job @Matt Thanks</span>
<span class="comment-copy">The "The" at the end of your answer makes me think that you haven't finished writing your answer. Please <a href="https://stackoverflow.com/posts/52743714/edit">edit</a> your answer to complete it.</span>
<span class="comment-copy">This requires use of multipledispatch package (<a href="https://pypi.org/project/multipledispatch/" rel="nofollow noreferrer">pypi.org/project/multipledispatch</a>), which is not part of python core.</span>
