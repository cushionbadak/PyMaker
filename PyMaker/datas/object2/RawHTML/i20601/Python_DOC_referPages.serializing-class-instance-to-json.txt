<div class="post-text" itemprop="text">
<p>I am trying to create a JSON string representation of a class instance and having difficulty. Let's say the class is built like this:</p>
<pre><code>class testclass:
    value1 = "a"
    value2 = "b"
</code></pre>
<p>A call to the json.dumps is made like this:</p>
<pre><code>t = testclass()
json.dumps(t)
</code></pre>
<p>It is failing and telling me that the testclass is not JSON serializable.</p>
<pre><code>TypeError: &lt;__main__.testclass object at 0x000000000227A400&gt; is not JSON serializable
</code></pre>
<p>I have also tried using the pickle module :</p>
<pre><code>t = testclass()
print(pickle.dumps(t, pickle.HIGHEST_PROTOCOL))
</code></pre>
<p>And it gives class instance information but not a serialized content of the class instance.</p>
<pre><code>b'\x80\x03c__main__\ntestclass\nq\x00)\x81q\x01}q\x02b.'
</code></pre>
<p>What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>The basic problem is that the JSON encoder <code>json.dumps()</code> only knows how to serialize a limited set of object types by default, all built-in types.  List here: <a href="https://docs.python.org/3.3/library/json.html#encoders-and-decoders" rel="noreferrer">https://docs.python.org/3.3/library/json.html#encoders-and-decoders</a></p>
<p>One good solution would be to make your class inherit from <code>JSONEncoder</code> and then implement the <code>JSONEncoder.default()</code> function, and make that function emit the correct JSON for your class.</p>
<p>A simple solution would be to call <code>json.dumps()</code> on the <code>.__dict__</code> member of that instance.  That is a standard Python <code>dict</code> and if your class is simple it will be JSON serializable.</p>
<pre><code>class Foo(object):
    def __init__(self):
        self.x = 1
        self.y = 2

foo = Foo()
s = json.dumps(foo) # raises TypeError with "is not JSON serializable"

s = json.dumps(foo.__dict__) # s set to: {"x":1, "y":2}
</code></pre>
<p>The above approach is discussed in this blog posting:</p>
<p>    <a href="http://www.marcstober.com/blog/2007/07/07/serializing-arbitrary-python-objects-to-json-using-__dict__/" rel="noreferrer">Serializing arbitrary Python objects to JSON using __dict__</a></p>
</div>
<div class="post-text" itemprop="text">
<p>There's one way that works great for me that you can try out:</p>
<p><code>json.dumps()</code> can take an optional parameter <strong>default</strong> where you can specify a custom serializer function for unknown types, which in my case looks like </p>
<pre><code>def serialize(obj):
    """JSON serializer for objects not serializable by default json code"""

    if isinstance(obj, date):
        serial = obj.isoformat()
        return serial

    if isinstance(obj, time):
        serial = obj.isoformat()
        return serial

    return obj.__dict__
</code></pre>
<p>First two ifs are for date and time serialization
and then there is a <code>obj.__dict__</code> returned for any other object.</p>
<p>the final call looks like:</p>
<pre><code>json.dumps(myObj, default=serialize)
</code></pre>
<p>It's especially good when you are serializing a collection and you don't want to call <code>__dict__</code> explicitly for every object. Here it's done for you automatically.</p>
<p>So far worked so good for me, looking forward for your thoughts.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can specify the <code>default</code> named parameter in the <code>json.dumps()</code> function:</p>
<pre><code>json.dumps(obj, default=lambda x: x.__dict__)
</code></pre>
<p>Explanation:</p>
<p>Form the docs (<a href="https://docs.python.org/2/library/json.html#basic-usage" rel="noreferrer">2.7</a>, <a href="https://docs.python.org/3/library/json.html#basic-usage" rel="noreferrer">3.6</a>):</p>
<pre><code>``default(obj)`` is a function that should return a serializable version
of obj or raise TypeError. The default simply raises TypeError.
</code></pre>
<p>(Works on Python 2.7 and Python 3.x)</p>
<p>Note: In this case you need <code>instance</code> variables and not <code>class</code> variables, as the example in the question tries to do. (I am assuming the asker meant <code>class instance</code> to be an object of a class)</p>
<p>I learned this first from @phihag's answer <a href="https://stackoverflow.com/questions/7408647/convert-dynamic-python-object-to-json">here</a>. Found it to be the simplest and cleanest way to do the job.</p>
</div>
<div class="post-text" itemprop="text">
<p>I just do:</p>
<pre><code>data=json.dumps(myobject.__dict__)
</code></pre>
<p>This is not the full answer, and if you have some sort of complicated object class you certainly will not get everything. However I use this for some of my simple objects. </p>
<p>One that it works really well on is the "options" class that you get from the OptionParser module. 
Here it is along with the JSON request itself. </p>
<pre><code>  def executeJson(self, url, options):
        data=json.dumps(options.__dict__)
        if options.verbose:
            print data
        headers = {'Content-type': 'application/json', 'Accept': 'text/plain'}
        return requests.post(url, data, headers=headers)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="http://jsonpickle.github.io/" rel="noreferrer">jsonpickle</a></p>
<pre><code>import jsonpickle

object = YourClass()
json_object = jsonpickle.encode(object)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here are two simple functions for serialization of any non-sophisticated classes, nothing fancy as explained before.</p>
<p>I use this for configuration type stuff because I can add new members to the classes with no code adjustments.</p>
<pre><code>import json

class SimpleClass:
    def __init__(self, a=None, b=None, c=None):
        self.a = a
        self.b = b
        self.c = c

def serialize_json(instance=None, path=None):
    dt = {}
    dt.update(vars(instance))

    with open(path, "w") as file:
        json.dump(dt, file)

def deserialize_json(cls=None, path=None):
    def read_json(_path):
        with open(_path, "r") as file:
            return json.load(file)

    data = read_json(path)

    instance = object.__new__(cls)

    for key, value in data.items():
        setattr(instance, key, value)

    return instance

# Usage: Create class and serialize under Windows file system.
write_settings = SimpleClass(a=1, b=2, c=3)
serialize_json(write_settings, r"c:\temp\test.json")

# Read back and rehydrate.
read_settings = deserialize_json(SimpleClass, r"c:\temp\test.json")

# results are the same.
print(vars(write_settings))
print(vars(read_settings))

# output:
# {'c': 3, 'b': 2, 'a': 1}
# {'c': 3, 'b': 2, 'a': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>JSON is not really meant for serializing arbitrary Python objects.  It's great for serializing <code>dict</code> objects, but the <code>pickle</code> module is really what you should be using in general.  Output from <code>pickle</code> is not really human-readable, but it should unpickle just fine.  If you insist on using JSON, you could check out the <code>jsonpickle</code> module, which is an interesting hybrid approach.</p>
<p><a href="https://github.com/jsonpickle/jsonpickle" rel="nofollow">https://github.com/jsonpickle/jsonpickle</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I believe instead of inheritance as suggested in accepted answer, it's better to use polymorphism. Otherwise you have to have a big if else statement to customize encoding of every object. That means create a generic default encoder for JSON as:</p>
<pre><code>def jsonDefEncoder(obj):
   if hasattr(obj, 'jsonEnc'):
      return obj.jsonEnc()
   else: #some default behavior
      return obj.__dict__
</code></pre>
<p>and then have a <code>jsonEnc()</code> function in each class you want to serialize. e.g.</p>
<pre><code>class A(object):
   def __init__(self,lengthInFeet):
      self.lengthInFeet=lengthInFeet
   def jsonEnc(self):
      return {'lengthInMeters': lengthInFeet * 0.3 } # each foot is 0.3 meter
</code></pre>
<p>Then you call <code>json.dumps(classInstance,default=jsonDefEncoder)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Python3.x</p>
<p>The best aproach I could reach with my knowledge was this.<br/>
Note that this code treat set() too.<br/>
This approach is generic just needing the extension of class (in the second example).<br/>
Note that I'm just doing it to files, but it's easy to modify the behavior to your taste.</p>
<p>However this is a CoDec.</p>
<p>With a little more work you can construct your class in other ways.
I assume a default constructor to instance it, then I update the class dict.</p>
<pre><code>import json
import collections


class JsonClassSerializable(json.JSONEncoder):

    REGISTERED_CLASS = {}

    def register(ctype):
        JsonClassSerializable.REGISTERED_CLASS[ctype.__name__] = ctype

    def default(self, obj):
        if isinstance(obj, collections.Set):
            return dict(_set_object=list(obj))
        if isinstance(obj, JsonClassSerializable):
            jclass = {}
            jclass["name"] = type(obj).__name__
            jclass["dict"] = obj.__dict__
            return dict(_class_object=jclass)
        else:
            return json.JSONEncoder.default(self, obj)

    def json_to_class(self, dct):
        if '_set_object' in dct:
            return set(dct['_set_object'])
        elif '_class_object' in dct:
            cclass = dct['_class_object']
            cclass_name = cclass["name"]
            if cclass_name not in self.REGISTERED_CLASS:
                raise RuntimeError(
                    "Class {} not registered in JSON Parser"
                    .format(cclass["name"])
                )
            instance = self.REGISTERED_CLASS[cclass_name]()
            instance.__dict__ = cclass["dict"]
            return instance
        return dct

    def encode_(self, file):
        with open(file, 'w') as outfile:
            json.dump(
                self.__dict__, outfile,
                cls=JsonClassSerializable,
                indent=4,
                sort_keys=True
            )

    def decode_(self, file):
        try:
            with open(file, 'r') as infile:
                self.__dict__ = json.load(
                    infile,
                    object_hook=self.json_to_class
                )
        except FileNotFoundError:
            print("Persistence load failed "
                  "'{}' do not exists".format(file)
                  )


class C(JsonClassSerializable):

    def __init__(self):
        self.mill = "s"


JsonClassSerializable.register(C)


class B(JsonClassSerializable):

    def __init__(self):
        self.a = 1230
        self.c = C()


JsonClassSerializable.register(B)


class A(JsonClassSerializable):

    def __init__(self):
        self.a = 1
        self.b = {1, 2}
        self.c = B()

JsonClassSerializable.register(A)

A().encode_("test")
b = A()
b.decode_("test")
print(b.a)
print(b.b)
print(b.c.a)
</code></pre>
<hr/>
<p><strong>Edit</strong></p>
<p>With some more of research I found a way to generalize without the need of the <strong>SUPERCLASS</strong> register method call, using a <strong>metaclass</strong></p>
<pre><code>import json
import collections

REGISTERED_CLASS = {}

class MetaSerializable(type):

    def __call__(cls, *args, **kwargs):
        if cls.__name__ not in REGISTERED_CLASS:
            REGISTERED_CLASS[cls.__name__] = cls
        return super(MetaSerializable, cls).__call__(*args, **kwargs)


class JsonClassSerializable(json.JSONEncoder, metaclass=MetaSerializable):

    def default(self, obj):
        if isinstance(obj, collections.Set):
            return dict(_set_object=list(obj))
        if isinstance(obj, JsonClassSerializable):
            jclass = {}
            jclass["name"] = type(obj).__name__
            jclass["dict"] = obj.__dict__
            return dict(_class_object=jclass)
        else:
            return json.JSONEncoder.default(self, obj)

    def json_to_class(self, dct):
        if '_set_object' in dct:
            return set(dct['_set_object'])
        elif '_class_object' in dct:
            cclass = dct['_class_object']
            cclass_name = cclass["name"]
            if cclass_name not in REGISTERED_CLASS:
                raise RuntimeError(
                    "Class {} not registered in JSON Parser"
                    .format(cclass["name"])
                )
            instance = REGISTERED_CLASS[cclass_name]()
            instance.__dict__ = cclass["dict"]
            return instance
        return dct

    def encode_(self, file):
        with open(file, 'w') as outfile:
            json.dump(
                self.__dict__, outfile,
                cls=JsonClassSerializable,
                indent=4,
                sort_keys=True
            )

    def decode_(self, file):
        try:
            with open(file, 'r') as infile:
                self.__dict__ = json.load(
                    infile,
                    object_hook=self.json_to_class
                )
        except FileNotFoundError:
            print("Persistence load failed "
                  "'{}' do not exists".format(file)
                  )


class C(JsonClassSerializable):

    def __init__(self):
        self.mill = "s"


class B(JsonClassSerializable):

    def __init__(self):
        self.a = 1230
        self.c = C()


class A(JsonClassSerializable):

    def __init__(self):
        self.a = 1
        self.b = {1, 2}
        self.c = B()


A().encode_("test")
b = A()
b.decode_("test")
print(b.a)
# 1
print(b.b)
# {1, 2}
print(b.c.a)
# 1230
print(b.c.c.mill)
# s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are some good answers on how to get started on doing this. But there are some things to keep in mind:</p>
<ul>
<li>What if the instance is nested inside a large data structure?</li>
<li>What if also want the class name?</li>
<li>What if you want to deserialize the instance?</li>
<li>What if you're using <code>__slots__</code> instead of <code>__dict__</code>?</li>
<li>What if you just don't want to do it yourself?</li>
</ul>
<p><a href="https://github.com/mverleg/pyjson_tricks" rel="nofollow noreferrer">json-tricks</a> is a library (that I made and others contributed to) which has been able to do this for quite a while. For example:</p>
<pre><code>class MyTestCls:
    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)

cls_instance = MyTestCls(s='ub', dct={'7': 7})

json = dumps(cls_instance, indent=4)
instance = loads(json)
</code></pre>
<p>You'll get your instance back. Here the json looks like this:</p>
<pre><code>{
    "__instance_type__": [
        "json_tricks.test_class",
        "MyTestCls"
    ],
    "attributes": {
        "s": "ub",
        "dct": {
            "7": 7
        }
    }
}
</code></pre>
<p>If you like to make your own solution, you might look at the source of <code>json-tricks</code> so as not to forget some special cases (like <code>__slots__</code>).</p>
<p>It also does other types like numpy arrays, datetimes, complex numbers; it also allows for comments.</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/2343535/easiest-way-to-serialize-a-simple-class-object-with-simplejson" title="easiest way to serialize a simple class object with simplejson">stackoverflow.com/questions/2343535/…</a></span>
<span class="comment-copy">Use one line, <code>s = json.dumps(obj, default=lambda x: x.__dict__)</code>, to serialize object's instance variables (<code>self.value1</code>, <code>self.value2</code>, ...). Its the simplest and the most straight forward way. It will serialize nested object structures. The <code>default</code> function is called when any given object is not directly serializable. You can also look at my answer below. I found the popular answers unnecessarily complex, which were probably true quite a long time back.</span>
<span class="comment-copy">Your <code>testclass</code> has no <code>__init__()</code> method, so all instances will share the same two class attributes (<code>value1</code> and <code>value2</code>) defined in the class statement. Do you understand the difference between a class and an instance of one?</span>
<span class="comment-copy">I tried this. The end result of a call to json.dumps(t.__dict__) is just {}.</span>
<span class="comment-copy">That is because your class doesn't have a <code>.__init__()</code> method function, so your class instance has an empty dictionary.  In other words, <code>{}</code> is the correct result for your example code.</span>
<span class="comment-copy">Thanks. This does the trick. I added a simple <b>init</b> with no parameters and now calling the json.dumps(t.__dict__) returns proper data in the format of: {"value2": "345", "value1": "123"}  I had seen posts like this before, wasn't sure whether I needed a custom serializer for members, needing <b>init</b> wasn't mentioned explicitly or I missed it. Thank you.</span>
<span class="comment-copy">This work for a single class but not with related classes objets</span>
<span class="comment-copy">@NwawelAIroume: True. If you have an object which e.g. is containing multiple objects in a list the error is still <code>is not JSON serializable</code></span>
<span class="comment-copy">Many thanks for this answer - it helped me a lot.</span>
<span class="comment-copy">You should get more points for this answer :) it is a very nice and elegant solution!!</span>
<span class="comment-copy">This worked for me, but because of datetime.date members I changed it slightly: <code>default=lambda x: getattr(x, '__dict__', str(x))</code></span>
<span class="comment-copy">@Dakota nice work-around; <code>datetime.date</code> is a C implementation hence it has no <code>__dict__</code> attribute. IMHO for uniformity's sake, <code>datetime.date</code> should be having it...</span>
<span class="comment-copy">You might want to remove self, if you are not using this inside a class.</span>
<span class="comment-copy">That will work okay, as long as the object isn't composed of other objects.</span>
<span class="comment-copy">The main problem I see with pickle is that it's a Python-specific format, while JSON is a platform-independant format. JSON is specially useful if you're writing either a web application or a backend for some mobile application. That having been said, thanks for pointing out to jsonpickle.</span>
<span class="comment-copy">@Haroldo_OK Doesn't jsonpickle still export to JSON, just not very human readable?</span>
