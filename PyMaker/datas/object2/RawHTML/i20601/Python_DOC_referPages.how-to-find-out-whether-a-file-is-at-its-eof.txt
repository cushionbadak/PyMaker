<div class="post-text" itemprop="text">
<pre><code>fp = open("a.txt")
#do many things with fp

c = fp.read()
if c is None:
    print 'fp is at the eof'
</code></pre>
<p>Besides the above method, any other way to find out whether is fp is already at the eof?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>fp.read()</code> reads up to the end of the file, so after it's successfully finished you know the file is at EOF; there's no need to check. If it cannot reach EOF it will raise an exception.</p>
<p>When reading a file in chunks rather than with <code>read()</code>, you know you've hit EOF when <code>read</code> returns less than the number of bytes you requested. In that case, the following <code>read</code> call will return the empty string (not <code>None</code>). The following loop reads a file in chunks; it will call <code>read</code> at most once too many.</p>
<pre><code>assert n &gt; 0
while True:
    chunk = fp.read(n)
    if chunk == '':
        break
    process(chunk)
</code></pre>
<p>Or, shorter:</p>
<pre><code>for chunk in iter(lambda: fp.read(n), ''):
    process(chunk)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The "for-else" design is often overlooked. See: <a href="https://docs.python.org/2/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops">Python Docs "Control Flow in Loop"</a>:</p>
<p><strong>Example</strong></p>
<pre><code>with open('foobar.file', 'rb') as f:
    for line in f:
        foo()

    else:
        # No more lines to be read from file
        bar()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd argue that reading from the file is the most reliable way to establish whether it contains more data. It could be a pipe, or another process might be appending data to the file etc.</p>
<p>If you <em>know</em> that's not an issue, you could use something like:</p>
<pre><code>f.tell() == os.fstat(f.fileno()).st_size
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When doing binary I/O the following method is useful:</p>
<pre><code>while f.read(1):
    f.seek(-1,1)
    # whatever
</code></pre>
<p>The advantage is that sometimes you are processing a binary stream and do not know in advance how much you will need to read.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can compare the returned value of <code>fp.tell()</code> before and after calling the <code>read</code> method. If they return the same value, fp is at eof.</p>
<p>Furthermore, I don't think your example code actually works. The <code>read</code> method to my knowledge never returns <code>None</code>, but it does return an empty string on eof.</p>
</div>
<div class="post-text" itemprop="text">
<p>read returns an empty string when EOF is encountered. Docs are <a href="http://docs.python.org/release/2.5.2/lib/bltin-file-objects.html">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As python returns empty string on EOF, and not "EOF" itself, you can just check the code for it, written here</p>
<pre><code>f1 = open("sample.txt")

while True:
    line = f1.readline()
    print line
    if ("" == line):
        print "file finished"
        break;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>f=open(file_name)
for line in f:
   print line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If file is opened in non-block mode, returning less bytes than expected does not mean it's at eof, I'd say @NPE's answer is the most reliable way:</p>
<blockquote>
<p>f.tell() == os.fstat(f.fileno()).st_size</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The Python read functions will return an empty string if they reach EOF</p>
</div>
<div class="post-text" itemprop="text">
<p>I really don't understand why python still doesn't have such a function. I also don't agree to use the following</p>
<pre><code>f.tell() == os.fstat(f.fileno()).st_size
</code></pre>
<p>The main reason is <code>f.tell()</code> doesn't likely to work for some special conditions.</p>
<p>The method works for me is like the following. If you have some pseudocode like the following</p>
<pre><code>while not EOF(f):
     line = f.readline()
     " do something with line"
</code></pre>
<p>You can replace it with:</p>
<pre><code>lines = iter(f.readlines())
while True:
     try:
        line = next(lines)
        " do something with line"
     except StopIteration:
        break
</code></pre>
<p>This method is simple and you don't need to change most of you code.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>f = open(filename,'r')
f.seek(-1,2)     # go to the file end.
eof = f.tell()   # get the end of file location
f.seek(0,0)      # go back to file beginning

while(f.tell() != eof):
    &lt;body&gt;
</code></pre>
<p>You can use the <a href="https://docs.python.org/2/tutorial/inputoutput.html#methods-of-file-objects" rel="nofollow noreferrer">file methods</a> <strong><em>seek()</em></strong> and <strong><em>tell()</em></strong> to determine the position of the end of file. Once the position is found, seek back to the file beginning</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>tell()</code> method after reaching <code>EOF</code> by calling <code>readlines()</code>
method, like this:</p>
<pre><code>fp=open('file_name','r')
lines=fp.readlines()
eof=fp.tell() # here we store the pointer
              # indicating the end of the file in eof
fp.seek(0) # we bring the cursor at the begining of the file
if eof != fp.tell(): # we check if the cursor
     do_something()  # reaches the end of the file
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Get the EOF position of the file:</p>
<pre><code>def get_eof_position(file_handle):
    original_position = file_handle.tell()
    eof_position = file_handle.seek(0, 2)
    file_handle.seek(original_position)
    return eof_position
</code></pre>
<p>and compare it with the current position: <code>get_eof_position == file_handle.tell()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Although I would personally use a <code>with</code> statement to handle opening and closing a file, in the case where you have to read from stdin and need to track an EOF exception, do something like this:</p>
<p>Use a try-catch with <code>EOFError</code> as the exception:</p>
<pre><code>try:
    input_lines = ''
    for line in sys.stdin.readlines():
        input_lines += line             
except EOFError as e:
    print e
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Reading a file in batches of <code>BATCH_SIZE</code> lines (the last batch can be shorter):</p>
<pre><code>BATCH_SIZE = 1000  # lines

with open('/path/to/a/file') as fin:
    eof = False
    while eof is False:
        # We use an iterator to check later if it was fully realized. This
        # is a way to know if we reached the EOF.
        # NOTE: file.tell() can't be used with iterators.
        batch_range = iter(range(BATCH_SIZE))
        acc = [line for (_, line) in zip(batch_range, fin)]

        # DO SOMETHING WITH "acc"

        # If we still have something to iterate, we have read the whole
        # file.
        if any(batch_range):
            eof = True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I use this function:</p>
<pre><code># Returns True if End-Of-File is reached
def EOF(f):
    current_pos = f.tell()
    file_size = os.fstat(f.fileno()).st_size
    return current_pos &gt;= file_size
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use below code snippet to read line by line, till end of file:</p>
<pre><code>line = obj.readline()
while(line != ''):
    # Do Something
    line = obj.readline()
</code></pre>
</div>
<span class="comment-copy">It's worth taking a look at the <a href="http://docs.python.org/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer"><code>with</code> statement</a> for opening files - it handles closing and exceptions for you nicely, and reads well.</span>
<span class="comment-copy">Yes, you're right. So there is no effective way to check whether <code>eof</code> is reached?</span>
<span class="comment-copy">@Alcott: there's aix's method for ordinary files. When reading in chunks, say with <code>fp.read(n)</code>, you'll know you've hit EOF when that returns less than <code>n</code> characters.</span>
<span class="comment-copy">Unless you have some reason to process a file in chunks, it's generally more natural to process it line by line, which python provides as files are iterators - so you can just do <code>for line in file: ...</code> and let the for loop deal with it for you.</span>
<span class="comment-copy">According to the <a href="http://docs.python.org/3/library/io.html#io.BufferedIOBase" rel="nofollow noreferrer">BufferedIOBase doc</a>: "For interactive raw streams (tty/terminal), a short result does not imply that EOF is imminent."</span>
<span class="comment-copy">@larsmans just used this, thanks! Though mine was for a binary stream, I should note here that <code>if chunk == '':</code> only works for literal string streams, <code>if chunk == b'':</code> is needed for binary streams, note the extra b.</span>
<span class="comment-copy">There is literally no point to this <code>else:</code>. Not writing it and just having <code>bar()</code> works the same. <code>else</code> only makes a difference if you use <code>break</code>.</span>
<span class="comment-copy">agreed if you call read() and you are at EOF its going to return <code>''</code></span>
<span class="comment-copy">I prefer <code>fh.seek(0, 2); file_size = fh.tell(); fh.seek(0)</code> beforehand and then <code>fh.tell() == file_size</code> later on. Is there an advantage to doing it your way? NOTE: I would certainly suggest caching the size to a variable and not calling <code>os.fstat</code> on every loop.</span>
<span class="comment-copy">Note that this won't work if the file is open in text mode: <code>f.tell()</code> gives you the file position in characters and <code>os.fstat(f.fileno()).st_size</code> gives you the file length in bytes.  @BrunoBronosky's method will work, though.</span>
<span class="comment-copy">How does this tell you if you are at EOF?</span>
<span class="comment-copy">@GreenAsJade, <code>f.read(1)</code> will return the empty string at EOF.</span>
<span class="comment-copy">Huh!  And ... is the seek essential, and not just part of whatever?  What's it's role?</span>
<span class="comment-copy">When you use <code>f.read(1)</code> and the file is not at <code>EOF</code>, then you just read one byte, so the <code>f.seek(-1,1)</code> tells the file to move back one byte.</span>
<span class="comment-copy">@Chris, as far as I know any non empty string will always evaluate to True. You can check this in the interpreter by running <code>bool('\0')</code>.</span>
<span class="comment-copy">This code will not run.</span>
<span class="comment-copy">Thanks for this simple solution, it is exactly what I was looking for. Upvoting, and submitting an edit to fix the indentation so the code runs.</span>
<span class="comment-copy">very pythonic and no additional tests</span>
<span class="comment-copy">Can you explain what your solution is doing by editing your post? Posting only code is often not enough.</span>
<span class="comment-copy">Can you format this post -- it seems to have a code snippet that is hard to read because its formatted all on one line.</span>
<span class="comment-copy">I suppose you meant to test for equality in your last line.</span>
