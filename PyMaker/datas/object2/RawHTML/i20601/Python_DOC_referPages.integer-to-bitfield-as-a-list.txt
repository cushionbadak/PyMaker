<div class="post-text" itemprop="text">
<p>I've created a method to convert an <code>int</code> to a bitfield (in a list) and it works, but I'm sure there is more elegant solution- I've just been staring at it for to long.</p>
<p>I'm curious, how would you convert a <code>int</code> to a bitfield represented in a <code>list</code>?</p>
<pre><code>def get(self):
    results = []

    results.append(1 if (self.bits &amp;   1) else 0)
    results.append(1 if (self.bits &amp;   2) else 0)
    results.append(1 if (self.bits &amp;   4) else 0)
    results.append(1 if (self.bits &amp;   8) else 0)
    results.append(1 if (self.bits &amp;  16) else 0)
    results.append(1 if (self.bits &amp;  32) else 0)
    results.append(1 if (self.bits &amp;  64) else 0)
    results.append(1 if (self.bits &amp; 128) else 0)

    return results

def set(self, pin, direction):
    pin -= 1
    if pin not in range(0, 8): raise ValueError

    if direction: self.bits |= (2 ** pin)
    else: self.bits &amp;=~(2 ** pin)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>def bitfield(n):
    return [int(digit) for digit in bin(n)[2:]] # [2:] to chop off the "0b" part 
</code></pre>
<p>This gives you</p>
<pre><code>&gt;&gt;&gt; bitfield(123)
[1, 1, 1, 1, 0, 1, 1]
&gt;&gt;&gt; bitfield(255)
[1, 1, 1, 1, 1, 1, 1, 1]
&gt;&gt;&gt; bitfield(1234567)
[1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1]
</code></pre>
<p>This only works for positive integers, though. </p>
<p><strong>EDIT:</strong></p>
<p>Conversion to <code>int</code> using <code>int()</code> is a bit overkill here. This is a lot faster:</p>
<pre><code>def bitfield(n):
    return [1 if digit=='1' else 0 for digit in bin(n)[2:]]
</code></pre>
<p>See the timings:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit("[int(digit) for digit in bin(123)[2:]]")
7.895014818543946
&gt;&gt;&gt; timeit.timeit("[123 &gt;&gt; i &amp; 1 for i in range(7,-1,-1)]")
2.966295244250407
&gt;&gt;&gt; timeit.timeit("[1 if digit=='1' else 0 for digit in bin(123)[2:]]")
1.7918431924733795
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This doesn't use <code>bin</code>:</p>
<pre><code> b = [n &gt;&gt; i &amp; 1 for i in range(7,-1,-1)]
</code></pre>
<p>and this is how to handle any integer this way:</p>
<pre><code> b = [n &gt;&gt; i &amp; 1 for i in range(n.bit_length() - 1,-1,-1)]
</code></pre>
<p>See <a href="https://docs.python.org/3/library/stdtypes.html#int.bit_length" rel="noreferrer"><code>bit_length</code></a>.</p>
<p>If you want index 0 of the list to correspond to the lsb of the int, change the range order, i.e.</p>
<pre><code>b = [n &gt;&gt; i &amp; 1 for i in range(0, n.bit_length()-1)]
</code></pre>
<p>Note also that using n.bit_length() can be a point of failure if you're trying to represent fixed length binary values. It returns the minimum number of bits to represent n.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try</p>
<pre><code>&gt;&gt;&gt;n=1794
&gt;&gt;&gt;bitfield=list(bin(n))[2:]
&gt;&gt;&gt;bitfield
['1', '1', '1', '0', '0', '0', '0', '0', '0', '1', '0']
</code></pre>
<p>This does not work for negative n though and as you see gives you a list of strings</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm doing this for my program where you specify a template to get your values from an int:</p>
<pre><code>def field(template, value):
    sums = [int(v) if v.__class__==str else len(bin(v))-2 for v in template]
    return [(value&gt;&gt; (sum(sums[:i]) if i else 0) )&amp;(~(~0&lt;&lt;int(t)) if t.__class__==str else t) for i,t in enumerate(template)]
</code></pre>
<p><strong>how to use</strong><br/>
in the template, specify ints relating to your bit-sizes:</p>
<pre><code>field([0b1,0b111,0b1111], 204) #&gt;&gt;&gt; [0, 6, 12]
</code></pre>
<p>or you can specify the bit-size of each value needed using strings: (noob friendly)</p>
<pre><code>field(['1','3','4'], 204) #&gt;&gt;&gt; [0, 6, 12]
</code></pre>
<p>EDIT: and vice versa: (separate code)</p>
<pre><code>field(['1','3','4'], [0, 6, 12]) #&gt;&gt;&gt; 204
field([0b1,0b111,0b1111], [0,3,9]) #&gt;&gt;&gt; 150
</code></pre>
<p>the code:</p>
<pre><code>def field(template, value):
    res = 0
    for t, v in zip(template, value)[::-1]: res = (res &lt;&lt; (t.bit_length() if t.__class__ is int else int(t)) )|v
    return res
</code></pre>
<p>EDIT2: faster code^</p>
</div>
<div class="post-text" itemprop="text">
<p>Does not work for negative values </p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; [int(x) for x in np.binary_repr(123)]
[1, 1, 1, 1, 0, 1, 1]
</code></pre>
</div>
<span class="comment-copy">+1 for nice timing considerations</span>
<span class="comment-copy"><code>[123 &gt;&gt; i &amp; 1 for i in range(7,-1,-1)]</code> is the fastest on my machine.</span>
<span class="comment-copy">@tMC: I've redone the timings on both my PCs (Win 7 Ultimate 64bit), under Python 2.7.3 and 3.2.3, and my solution was always faster by at least 20 % (Python 2) and 45 % (Python 3).</span>
<span class="comment-copy">the difference is negligible.  I just thought it was interesting that i got different results on my Linux laptop.</span>
<span class="comment-copy">This is perfect- I knew there was a list comprehension I was missing</span>
<span class="comment-copy">Of course this only handles 8-bit integers.</span>
<span class="comment-copy">It may handle any integers in this way:  [n &gt;&gt; i &amp; 1 for i in range(n.bit_length() - 1,-1,-1)]</span>
<span class="comment-copy">@mennanov: thanks, added (btw, feel free to edit posts if you have something valuable to add).</span>
<span class="comment-copy">For the sake of performance, you should use <code>%2</code> instead of <code>&amp;1</code>, even though the latter looks smarter: <code>timeit.timeit("n=193; n%2")</code> returns <code>0.043587817999650724</code>, while <code>timeit.timeit("n=193; n&amp;1")</code> returns <code>0.0545583209986944</code> (I set <code>n</code> to an arbitrary value so as to avoid optimizations).</span>
<span class="comment-copy">+1, I seem to forget that there is <code>list()</code> constructor all the time.</span>
<span class="comment-copy">Even though it does not return list of integers.</span>
<span class="comment-copy">This is not what tMC asked for. He needs a list of integers, you give him a list of strings. As nice as the <code>list()</code> constructor may be, it's not the right tool here.</span>
<span class="comment-copy">@Tim Pietzcker - You are right.</span>
<span class="comment-copy">@Kroltan map(int, bitfield)</span>
