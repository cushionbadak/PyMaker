<div class="post-text" itemprop="text">
<p>Usually Python descriptor are defined as class attributes. But in my case, I want every object instance to have different set descriptors that depends on the input. For example:</p>
<pre><code>class MyClass(object):
  def __init__(self, **kwargs):
    for attr, val in kwargs.items():
      self.__dict__[attr] = MyDescriptor(val)
</code></pre>
<p>Each object are have different set of attributes that are decided at instantiation time. Since these are one-off objects, it is not convenient to first subclass them.</p>
<pre><code>tv = MyClass(type="tv", size="30")
smartphone = MyClass(type="phone", os="android")

tv.size   # do something smart with the descriptor
</code></pre>
<p>Assign Descriptor to the object does not seem to work. If I try to access the attribute, I got something like</p>
<pre><code>&lt;property at 0x4067cf0&gt;
</code></pre>
<p>Do you know why is this not working? Is there any work around?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is not working because you have to assign the descriptor to the class of the object.</p>
<pre><code>class Descriptor:

    def __get__(...):
        # this is called when the value is got

    def __set__(...
    def __del__(...
</code></pre>
<p>if you write</p>
<pre><code>obj.attr
=&gt; type(obj).__getattribute__(obj, 'attr') is called
=&gt; obj.__dict__['attr'] is returned if there else:
=&gt; type(obj).__dict__['attr'] is looked up
if this contains a descriptor object then this is used.
</code></pre>
<p>so it does not work because the type dictionairy is looked up for descriptors and not the object dictionairy.</p>
<p>there are possible work arounds:</p>
<ol>
<li><p>put the descriptor into the class and make it use e.g. obj.xxxattr to store the value. 
If there is only one descriptor behaviour this works.</p></li>
<li><p>overwrite <strong>setattr</strong> and <strong>getattr</strong> and <strong>delattr</strong> to respond to discriptors.</p></li>
<li><p>put a discriptor into the class that responds to descriptors stored in the object dictionairy. </p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You are using descriptors in the wrong way.</p>
<p>Descriptors don't make sense on an instance level. After all the <code>__get__</code>/<code>__set__</code>
methods give you access to the <code>instance</code> of the class.</p>
<p>Without knowing what exactly you want to do, I'd suggest you put the per-instance
logic inside the <code>__set__</code> method, by checking who is the "caller/instance" and act accordingly.</p>
<p>Otherwise tell us what you are trying to achieve, so that we can propose alternative solutions.</p>
</div>
<div class="post-text" itemprop="text">
<p>This looks like a use-case for <a href="http://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow">named tuples</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The reason it is not working is because Python only checks for descriptors when looking up attributes on the class, not on the instance; the methods in question are:</p>
<ul>
<li><a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow"><code>__getattribute__</code></a></li>
<li><a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow"><code>__setattr__</code></a></li>
<li><a href="https://docs.python.org/3/reference/datamodel.html#object.__delattr__" rel="nofollow"><code>__delattr__</code></a></li>
</ul>
<p>It is possible to override those methods on your class in order to implement the <a href="https://docs.python.org/2/howto/descriptor.html#descriptor-protocol" rel="nofollow">descriptor protocol</a> on instances as well as classes:</p>
<pre><code># do not use in production, example code only, needs more checks
class ClassAllowingInstanceDescriptors(object):
    def __delattr__(self, name):
        res = self.__dict__.get(name)
        for method in ('__get__', '__set__', '__delete__'):
            if hasattr(res, method):
                # we have a descriptor, use it
                res = res.__delete__(name)
                break
        else:
            res = object.__delattr__(self, name)
        return res
    def __getattribute__(self, *args):
        res = object.__getattribute__(self, *args)
        for method in ('__get__', '__set__', '__delete__'):
            if hasattr(res, method):
                # we have a descriptor, call it
                res = res.__get__(self, self.__class__)
        return res
    def __setattr__(self, name, val):
        # check if object already exists
        res = self.__dict__.get(name)
        for method in ('__get__', '__set__', '__delete__'):
            if hasattr(res, method):
                # we have a descriptor, use it
                res = res.__set__(self, val)
                break
        else:
            res = object.__setattr__(self, name, val)
        return res
    @property
    def world(self):
        return 'hello!'
</code></pre>
<p>When the above class is used as below:</p>
<pre><code>huh = ClassAllowingInstanceDescriptors()
print(huh.world)
huh.uni = 'BIG'
print(huh.uni)
huh.huh = property(lambda *a: 'really?')
print(huh.huh)
print('*' * 50)
try:
    del huh.world
except Exception, e:
    print(e)
print(huh.world)
print('*' * 50)
try:
    del huh.huh
except Exception, e:
    print(e)
print(huh.huh)
</code></pre>
<p>The results are:</p>
<blockquote>
<p>hello!</p>
<p>BIG</p>
<p>really?</p>
<hr/>
<p>can't delete attribute</p>
<p>hello!</p>
<hr/>
<p>can't delete attribute</p>
<p>really?</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I dynamically create instances by <code>exec</code>ing a made-up class. This may suit your use case.  </p>
<pre><code>def make_myclass(**kwargs):

    class MyDescriptor(object):
        def __init__(self, val):
            self.val = val

        def __get__(self, obj, cls):
            return self.val

        def __set__(self, obj, val):
            self.val = val

    cls = 'class MyClass(object):\n{}'.format('\n'.join('    {0} = MyDescriptor({0})'.format(k) for k in kwargs))

    #check if names in kwargs collide with local names
    for key in kwargs:
        if key in locals():
            raise Exception('name "{}" collides with local name'.format(key))

    kwargs.update(locals())
    exec(cls, kwargs, locals())
    return MyClass()  
</code></pre>
<p>Test;  </p>
<pre><code>In [577]: tv = make_myclass(type="tv", size="30")

In [578]: tv.type
Out[578]: 'tv'

In [579]: tv.size
Out[579]: '30'

In [580]: tv.__dict__
Out[580]: {}  
</code></pre>
<p>But the instances are of different class.  </p>
<pre><code>In [581]: phone = make_myclass(type='phone')

In [582]: phone.type
Out[582]: 'phone'

In [583]: tv.type
Out[583]: 'tv'

In [584]: isinstance(tv,type(phone))
Out[584]: False

In [585]: isinstance(phone,type(tv))
Out[585]: False

In [586]: type(tv)
Out[586]: MyClass

In [587]: type(phone)
Out[587]: MyClass

In [588]: type(phone) is type(tv)
Out[588]: False
</code></pre>
</div>
<span class="comment-copy">Why not using different subclasses of MyClass with overriden descriptors?</span>
<span class="comment-copy">Edited to add more example. I guess per-instance descriptor just cannot be done. I have worked around it using <b>getattr</b>. Still don't understand the underlying language constraint though.</span>
<span class="comment-copy">Descriptors only work at the class level, sorry.</span>
<span class="comment-copy">Can you explain <i>why</i> you want to do this? It seems like a <code>NamedTuple</code> or a <code>dict</code> would be sufficient as a data structure.</span>
<span class="comment-copy">On the good side, performance will be better than with <a href="http://stackoverflow.com/a/35657853/208880">my answer</a>; on the down side, instances are not the same class, and there could be confusion because they all have the same class name.  Still, a good solution in the appropriate circumstances.</span>
