<div class="post-text" itemprop="text">
<p>What is the most idiomatic way to achieve something like the following, in Haskell:</p>
<pre><code>foldl (+) 0 [1,2,3,4,5]
--&gt; 15
</code></pre>
<p>Or its equivalent in Ruby:</p>
<pre><code>[1,2,3,4,5].inject(0) {|m,x| m + x}
#&gt; 15
</code></pre>
<p>Obviously, Python provides the <code>reduce</code> function, which is an implementation of fold, exactly as above, however, I was told that the 'pythonic' way of programming was to avoid <code>lambda</code> terms and higher-order functions, preferring list-comprehensions where possible. Therefore, is there a preferred way of folding a list, or list-like structure in Python that isn't the <code>reduce</code> function, or is <code>reduce</code> the idiomatic way of achieving this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The Pythonic way of summing an array is <code>sum</code>. For other purposes, you can sometimes use some combination of <code>reduce</code> and the <code>operator</code> module, e.g.</p>
<pre><code>def product(xs):
    return reduce(operator.mul, xs, 1)
</code></pre>
<p>Be aware that <code>reduce</code> is actually a <code>foldl</code>, in Haskell terms. There is no special syntax to perform folds, there's no builtin <code>foldr</code>, and actually using <code>reduce</code> with non-associative operators is considered bad style.</p>
<p>Using higher-order functions is quite pythonic; it makes good use of Python's principle that everything is an object, including functions and classes. You are right that lambdas are frowned upon by some Pythonistas, but mostly because they tend not to be very readable when they get complex.</p>
</div>
<div class="post-text" itemprop="text">
<p>Haskell</p>
<p><code>foldl (+) 0 [1,2,3,4,5]</code></p>
<p>Python</p>
<p><code>reduce(lambda a,b: a+b, [1,2,3,4,5], 0)</code></p>
<p>Obviously, that is a trivial example to illustrate a point. In Python you would just do <code>sum([1,2,3,4,5])</code> and even Haskell purists would generally prefer <code>sum [1,2,3,4,5]</code>.</p>
<p>For non-trivial scenarios when there is no obvious convenience function, the idiomatic pythonic approach is to explicitly write out the for loop and use mutable variable assignment instead of using <code>reduce</code> or a <code>fold</code>.</p>
<p>That is not at all the functional style, but that is the "pythonic" way. Python is not designed for functional purists. See how Python favors exceptions for flow control to see how non-functional idiomatic python is.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, the <code>reduce</code> has been removed: <a href="https://docs.python.org/3.0/whatsnew/3.0.html#builtins" rel="noreferrer">Release notes</a>. Nevertheless you can use the <a href="https://docs.python.org/3/howto/functional.html#the-functools-module" rel="noreferrer">functools module</a></p>
<pre><code>import operator, functools
def product(xs):
    return functools.reduce(operator.mul, xs, 1)
</code></pre>
<p>On the other hand, the documentation expresses preference towards <code>for</code>-loop instead of <code>reduce</code>, hence:</p>
<pre><code>def product(xs):
    result = 1
    for i in xs:
        result *= i
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can reinvent the wheel as well:</p>
<pre><code>def fold(f, l, a):
    """
    f: the function to apply
    l: the list to fold
    a: the accumulator, who is also the 'zero' on the first call
    """ 
    return a if(len(l) == 0) else fold(f, l[1:], f(a, l[0]))

print "Sum:", fold(lambda x, y : x+y, [1,2,3,4,5], 0)

print "Any:", fold(lambda x, y : x or y, [False, True, False], False)

print "All:", fold(lambda x, y : x and y, [False, True, False], True)

# Prove that result can be of a different type of the list's elements
print "Count(x==True):", 
print fold(lambda x, y : x+1 if(y) else x, [False, True, True], 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not really answer to the question, but one-liners for foldl and foldr:</p>
<pre><code>a = [8,3,4]

## Foldl
reduce(lambda x,y: x**y, a)
#68719476736

## Foldr
reduce(lambda x,y: y**x, a[::-1])
#14134776518227074636666380005943348126619871175004951664972849610340958208L
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The actual answer to this (reduce) problem is: Just use a loop!</p>
<pre><code>initial_value = 0
for x in the_list:
    initial_value += x #or any function.
</code></pre>
<p>This will be faster than a reduce and things like PyPy can optimize loops like that.</p>
<p>BTW, the sum case should be solved with the <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow"><code>sum</code></a> function </p>
</div>
<div class="post-text" itemprop="text">
<p>I may be quite late to the party, but we can create custom <code>foldr</code> using simple lambda calculus and curried function. Here is my implementation of foldr in python.</p>
<pre><code>def foldr(func):
    def accumulator(acc):
        def listFunc(l):
            if l:
                x = l[0]
                xs = l[1:]
                return func(x)(foldr(func)(acc)(xs))
            else:
                return acc
        return listFunc
    return accumulator  


def curried_add(x):
    def inner(y):
        return x + y
    return inner

def curried_mult(x):
    def inner(y):
        return x * y
    return inner

print foldr(curried_add)(0)(range(1, 6))
print foldr(curried_mult)(1)(range(1, 6))
</code></pre>
<p>Even though the implementation is recursive (might be slow), it will print the values <code>15</code> and <code>120</code> respectively</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe some of the respondents of this question have missed the broader implication of the <code>fold</code> function as an abstract tool. Yes, <code>sum</code> can do the same thing for a list of integers, but this is a trivial case. <code>fold</code> is more generic. It is useful when you have a sequence of data structures of varying shape and want to cleanly express an aggregation. So instead of having to build up a <code>for</code> loop with an aggregate variable and manually recompute it each time, a <code>fold</code> function (or the Python version, which <code>reduce</code> appears to correspond to) allows the programmer to express the intent of the aggregation much more plainly by simply providing two things:</p>
<ul>
<li>A default starting or "seed" value for the aggregation.</li>
<li>A function that takes the current value of the aggregation (starting with the "seed") and the next element in the list, and returns the next aggregation value.</li>
</ul>
</div>
<span class="comment-copy"><code>sum</code> isn't good enough?</span>
<span class="comment-copy">not sure if this is a good example for your question. It can easily be achieved with <code>sum</code>, you may want to provide some different types of examples.</span>
<span class="comment-copy">Hey JBernardo - Summing over a list of numbers was meant as a rather degenerate example, I'm more interested in the general idea of accumulating the elements of a list using some binary operation, and a starting value, not summing integers specifically.</span>
<span class="comment-copy">@mistertim: <code>sum()</code> actually provides limited functionality with this. <code>sum([[a], [b, c, d], [e, f]], [])</code> returns <code>[a, b, c, d, e, f]</code> for example.</span>
<span class="comment-copy">Although the case of doing it with lists is a good demonstration of things to watch for with this technique - <code>+</code> on lists is a linear time operation in both time and memory, making the whole call quadratic. Using <code>list(itertools.chain.from_iterable([a], [b,c,d],[e,f],[]])</code> is linear overall - and if you only need to iterate over it once, you can drop the call to <code>list</code> to make it constant in terms of memory.</span>
<span class="comment-copy">@JBernardo: you're saying that anything not in the builtins module is not pythonic?</span>
<span class="comment-copy">No, that would be stupid to say. But give me a single reason why do you think <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow noreferrer">GvR would hate so much the reduce function</a> at the point of removing it from builtins?</span>
<span class="comment-copy">@JBernardo: because people try to play too smart tricks with it. To quote from that blog post, "the applicability of <code>reduce()</code> is pretty much limited to associative operators, and in all other cases it's better to write out the accumulation loop explicitly." So, its use is limited, but even GvR apparently had to admit its useful enough to keep it in the standard library.</span>
<span class="comment-copy">@JBernardo, so does that mean that every usage of fold in Haskell and Scheme is equally bad? It's just a different style of programming, ignoring it and putting your fingers in your ears and saying it's unclear doesn't make it so. Like most things that are a different style <i>it takes practice to get used to it</i>. The idea is to put things into general categories so it's easier to reason about programs. "Oh I want to do this, hmm, looks like a fold" (or a map, or an unfold, or an unfold then a fold over that)</span>
<span class="comment-copy">@Wes: I was thinking primarily of functions passed to <code>reduce</code> or <code>map</code> that perform side-effects, or that take and return long tuples to perform too many computations at once. In Haskell, using <code>foldl</code> may sometimes the only reasonable option, but even in Scheme, there is a point where the loop gets so complicated that you want a named <code>let</code> instead.</span>
<span class="comment-copy">folds are useful to more than functional "purists".  They are general purpose abstractions.  Recursive problems are pervasive in computing.  Folds offer a way to remove the boilerplate and a way to make recursive solutions safe in languages which don't natively support recursion.  So a very practical thing.  GvR's prejudices in this area are unfortunate.</span>
<span class="comment-copy"><code>reduce</code> wasn't removed from the Python 3 standard library. <code>reduce</code> moved to the <code>functools</code> module as you show.</span>
<span class="comment-copy">@clay, I just took the phrase from Guido's release notes, but you may be right :)</span>
<span class="comment-copy">You swap the arguments to <code>f</code> around in your recursive case.</span>
<span class="comment-copy">Because Python lacks tail recursion, this will break on longer lists and is wasteful. Furthermore, this is not truly the "fold" function, but merely a left fold, i.e. foldl, that is, <i>exactly</i> what <code>reduce</code> already offers (note that reduce's function signature is <code>reduce(function, sequence[, initial]) -&gt; value</code> - it, too, includes the functionality of giving an initial value for the accumulator).</span>
<span class="comment-copy">I think this is a better way to write your foldr: <code>reduce(lambda y, x: x**y, reversed(a))</code>. It now has a more natural usage, works with iterators, and consumes less memory.</span>
<span class="comment-copy">This would not be considered pythonic for an example such as this one.</span>
<span class="comment-copy">Python loops are notoriously slow. Using (or abusing) <code>reduce</code> is a common way of optimizing a Python program.</span>
<span class="comment-copy">@jamylak Read again the last line I wrote....</span>
<span class="comment-copy">@larsmans Please, don't come to say reduce is faster than a simple loop... It will have always a function call overhead for each iteration. Also, again, Pypy can optimize loops to C speed</span>
<span class="comment-copy">@JBernardo: yes, that's what I'm claiming. I just profiled my version of <code>product</code> against one in your style, and <i>it's faster</i> (marginally, though).</span>
<span class="comment-copy">Hi rq_! I think your answer would be improved and add a great deal if you gave a non-trivial example of <code>fold</code> that is difficult to do cleanly in Python, and then "<code>fold</code>" that in Python :-)</span>
