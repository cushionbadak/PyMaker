<div class="post-text" itemprop="text">
<p>I'm working on a project with a friend where we need to generate a random hash. Before we had time to discuss, we both came up with different approaches and because they are using different modules, I wanted to ask you all what would be better--if there is such a thing.</p>
<pre><code>hashlib.sha1(str(random.random())).hexdigest()
</code></pre>
<p>or </p>
<pre><code>os.urandom(16).encode('hex')
</code></pre>
<p>Typing this question out has got me thinking that the second method is better. Simple is better than complex. If you agree, how reliable is this for 'randomly' generating hashes? How would I test this?  </p>
</div>
<div class="post-text" itemprop="text">
<p>This solution:</p>
<pre><code>os.urandom(16).encode('hex')
</code></pre>
<p>is the best since it <a href="http://docs.python.org/library/os.html#os.urandom">uses the OS</a> to generate randomness which <em>should</em> be usable for cryptographic purposes (depends on the OS implementation).</p>
<p><code>random.random()</code> generates <a href="http://docs.python.org/library/random.html">pseudo-random values</a>.</p>
<p>Hashing a random value does not add any new randomness.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>random.random()</code> is a pseudo-radmom generator, that means the numbers are generated from a sequence. if you call <code>random.seed(some_number)</code>, then after that the generated sequence will always be the same.</p>
<p><code>os.urandom()</code> get's the random numbers from the os' rng, which uses an entropy pool to collect real random numbers, usually by random events from hardware devices, there exist even random special entropy generators for systems where a lot of random numbers are generated.</p>
<p>on unix system there are traditionally two random number generators: <code>/dev/random</code> and <code>/dev/urandom</code>. calls to the first block if there is not enough entropy available, whereas when you read <code>/dev/urandom</code> and there is not enough entropy data available, it uses a pseudo-rng and doesn't block.</p>
<p>so the use depends usually on what you need: if you need a few, equally distributed random numbers, then the built in prng should be sufficient. for cryptographic use it's always better to use real random numbers.</p>
</div>
<div class="post-text" itemprop="text">
<p>The second solution clearly has more entropy than the first. Assuming the quality of the source of the random bits would be the same for <code>os.urandom</code> and <code>random.random</code>:</p>
<ul>
<li>In the second solution you are fetching 16 bytes = 128 bits worth of randomness</li>
<li>In the first solution you are fetching a floating point value which has roughly 52 bits of randomness (IEEE 754 double, ignoring subnormal numbers, etc...). Then you hash it around, which, of course, doesn't add any randomness.</li>
</ul>
<p>More importantly, the quality of the randomness coming from <code>os.urandom</code> is expected and documented to be much better than the randomness coming from <code>random.random</code>. <code>os.urandom</code>'s docstring says "suitable for cryptographic use".</p>
</div>
<div class="post-text" itemprop="text">
<p>Testing randomness is notoriously difficult - however, I would chose the second method, but ONLY (or, only as far as comes to mind) for this case, where the hash is seeded by a random number. </p>
<p>The whole point of hashes is to create a number that is <em>vastly different</em> based on <em>slight differences in input</em>. For your use case, the randomness of the input should do. If, however, you wanted to hash a file and detect one eensy byte's difference, that's when a hash algorithm shines.</p>
<p>I'm just curious, though: why use a hash algorithm at all? It seems that you're looking for a purely random number, and there are lots of libraries that generate uuid's, which have far stronger guarantees of uniqueness than random number generators.</p>
</div>
<div class="post-text" itemprop="text">
<p>if you want a unique identifier (uuid), then you should use</p>
<pre><code>import uuid
uuid.uuid4().hex
</code></pre>
<p><a href="https://docs.python.org/3/library/uuid.html" rel="nofollow">https://docs.python.org/3/library/uuid.html</a></p>
</div>
<span class="comment-copy">These are all really great answers. Thank you.</span>
<span class="comment-copy">AttributeError: 'bytes' object has no attribute 'encode'</span>
<span class="comment-copy">This is generally true except in a few situations including freshly booted system which lacks the randomness pool (entropy) to generate a quality random number, or when the pool is depleted by a large number of calls to it (don't ask how large since I'm no expert). The latter can also be exploited by the attacker to make the randomness more predictable (e.g., creating a large number of accounts that require random salt). So unless you need a cryptographically safe random number, you should avoid using <code>os.urandom</code>, and also make sure it cannot be abused if you use it.</span>
<span class="comment-copy">Note that python's random.SystemRandom[1] class offers the same api interface as random.* while relying on urandom.  [1] <a href="https://docs.python.org/2/library/random.html#random.SystemRandom" rel="nofollow noreferrer">docs.python.org/2/library/random.html#random.SystemRandom</a></span>
<span class="comment-copy">@CristopheD: try <code>base64.b64encode(os.urandom(16))</code></span>
