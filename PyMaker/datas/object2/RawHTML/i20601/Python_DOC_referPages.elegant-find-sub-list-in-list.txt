<div class="post-text" itemprop="text">
<p>Given a list containing a known pattern surrounded by noise, is there an elegant way to get all items that equal the pattern. See below for my crude code.</p>
<pre><code>list_with_noise = [7,2,1,2,3,4,2,1,2,3,4,9,9,1,2,3,4,7,4,3,1,2,3,5]
known_pattern = [1,2,3,4]
res = []


for i in list_with_noise:
    for j in known_pattern:
        if i == j:
            res.append(i)
            continue

print res
</code></pre>
<p>we would get <code>2, 1, 2, 3, 4, 2, 1, 2, 3, 4, 1, 2, 3, 4, 4, 3</code></p>
<p><strong>bonus</strong>: avoid appending i if the full pattern is not present (ie., allow 1,2,3,4 but not 1,2,3)</p>
<p>examples: </p>
<pre><code>find_sublists_in_list([7,2,1,2,3,4,2,1,2,3,4,9,9,1,2,3,4,7,4,3,1,2,3,5],[1,2,3,4])

[1,2,3,4],[1,2,3,4],[1,2,3,4]


find_sublists_in_list([7,2,1,2,3,2,1,2,3,6,9,9,1,2,3,4,7,4,3,1,2,6],[1,2,3,4])

[1,2,3],[1,2,3],[1,2,3]
</code></pre>
<p>The lists contain named tuples.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this question is 5 months old and already "accepted", but googling a very similar problem brought me to this question and all the answers seem to have a couple of rather significant problems, plus I'm bored and want to try my hand at a SO answer, so I'm just going to rattle off what I've found.</p>
<p>The first part of the question, as I understand it, is pretty trivial: just return the original list with all the elements not in the "pattern" filtered out. Following that thinking, the first code I thought of used the filter() function:</p>
<pre><code>def subfinder(mylist, pattern):
    return list(filter(lambda x: x in pattern, mylist))
</code></pre>
<p>I would say that this solution is definitely more succinct than the original solution, but it's not any faster, or at least not appreciably, and I try to avoid lambda expressions if there's not a very good reason for using them. In fact, the best solution I could come up with involved a simple list comprehension:</p>
<pre><code>def subfinder(mylist, pattern):
    pattern = set(pattern)
    return [x for x in mylist if x in pattern]
</code></pre>
<p>This solution is both more elegant and significantly faster than the original: the comprehension is about 120% faster than the original, while casting the pattern into a set first bumps that up to a whopping 320% faster in my tests.</p>
<p>Now for the bonus: I'll just jump right into it, my solution is as follows:</p>
<pre><code>def subfinder(mylist, pattern):
    matches = []
    for i in range(len(mylist)):
        if mylist[i] == pattern[0] and mylist[i:i+len(pattern)] == pattern:
            matches.append(pattern)
    return matches
</code></pre>
<p>This is a variation of Steven Rumbalski's "inefficient one liner", that, with the addition of the "mylist[i] == pattern[0]" check and thanks to python's short-circuit evaluation, is significantly faster than both the original statement and the itertools version (and every other offered solution as far as I can tell) <em>and</em> it even supports overlapping patterns. So there you go.</p>
</div>
<div class="post-text" itemprop="text">
<p>This will get the "bonus" part of your question:</p>
<pre><code>pattern = [1, 2, 3, 4]
search_list = [7,2,1,2,3,4,2,1,2,3,4,9,9,1,2,3,4,7,4,3,1,2,3,5]
cursor = 0
found = []
for i in search_list:
    if i == pattern[cursor]:
        cursor += 1
        if cursor == len(pattern):
            found.append(pattern)
            cursor = 0
    else:
        cursor = 0
</code></pre>
<p>For non-bonus:</p>
<pre><code>pattern = [1, 2, 3, 4]
search_list = [7,2,1,2,3,4,2,1,2,3,4,9,9,1,2,3,4,7,4,3,1,2,3,5]
cursor = 0
found = []
for i in search_list:
    if i != pattern[cursor]:
        if cursor &gt; 0:
            found.append(pattern[:cursor])
        cursor = 0
    else:
        cursor += 1
</code></pre>
<p>Finally, this one handles overlaps:</p>
<pre><code>def find_matches(pattern_list, search_list):
    cursor_list = []
    found = []
    for element in search_list:
        cursors_to_kill = []
        for cursor_index in range(len(cursor_list)):
            if element == pattern_list[cursor_list[cursor_index]]:
                cursor_list[cursor_index] += 1
                if cursor_list[cursor_index] == len(pattern_list):
                    found.append(pattern_list)
                    cursors_to_kill.append(cursor_index)
            else:
                cursors_to_kill.append(cursor_index)
        cursors_to_kill.reverse()
        for cursor_index in cursors_to_kill:
            cursor_list.pop(cursor_index)
        if element == pattern_list[0]:
            cursor_list.append(1)
    return found
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>list_with_noise = [7,2,1,2,3,4,2,1,2,3,4,9,9,1,2,3,4,7,4,3,1,2,3,5]
string_withNoise = "".join(str(i) for i in list_with_noise)
known_pattern = [1,2,3,4]
string_pattern = "".join(str(i) for i in known_pattern)
string_withNoise.count(string_pattern)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given:</p>
<pre><code>a_list = [7,2,1,2,3,4,2,1,2,3,4,9,9,1,2,3,4,7,4,3,1,2,3,5]
pat = [1,2,3,4]
</code></pre>
<p>Here is an inefficient one liner:</p>
<pre><code>res = [pat for i in range(len(a_list)) if a_list[i:i+len(pat)] == pat]
</code></pre>
<p>Here is a more efficient itertools version:</p>
<pre><code>from itertools import izip_longest, islice

res = []
i = 0  

while True:
    try:
        i = a_list.index(pat[0], i)
    except ValueError:
        break
    if all(a==b for (a,b) in izip_longest(pat, islice(a_list, i, i+len(pat)))):
        res.append(pat)
        i += len(pat)
    i += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An idiomatic, composable solution to the problem.</p>
<p>First off, we need to borrow <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">an <code>itertools</code> recipe</a>, <code>consume</code> (which consumes and discards a given number of elements from an iterator. Then we take the <code>itertools</code> recipe for <code>pairwise</code>, and extend it to an <code>nwise</code> function using <code>consume</code>:</p>
<pre><code>import itertools

def nwise(iterable, size=2):
    its = itertools.tee(iterable, size)
    for i, it in enumerate(its):
        consume(it, i)  # Discards i elements from it
    return zip(*its)
</code></pre>
<p>Now that we have that, solving the bonus problem is really easy:</p>
<pre><code>def find_sublists_in_list(biglist, searchlist):
    searchtup = tuple(searchlist)
    return [list(subtup) for subtup in nwise(biglist, len(searchlist)) if subtup == searchtup]

    # Or for more obscure but faster one-liner:
    return map(list, filter(tuple(searchlist).__eq__, nwise(biglist, len(searchlist))))
</code></pre>
<p>Similarly, a more succinct and speedier (if somewhat less pretty) solution to the main problem replaces:</p>
<pre><code>def subfinder(mylist, pattern):
    pattern = set(pattern)
    return [x for x in mylist if x in pattern]
</code></pre>
<p>with:</p>
<pre><code>def subfinder(mylist, pattern):
    # Wrap filter call in list() if on Python 3 and you need a list, not a generator
    return filter(set(pattern).__contains__, mylist)
</code></pre>
<p>This behaves the same way, but avoids needing to store the temporary <code>set</code> to a name, and pushes all the filtering work to C.</p>
</div>
<span class="comment-copy">Feast your eyes on <a href="http://en.wikipedia.org/wiki/String_searching_algorithm" rel="nofollow noreferrer">en.wikipedia.org/wiki/String_searching_algorithm</a></span>
<span class="comment-copy">You might want to give some examples of inputs and the corresponding expected outputs. Your question in its present form is not clear.</span>
<span class="comment-copy">Is this a question or a programming exercise?</span>
<span class="comment-copy">@FerdinandBeyer I don't understand the difference. I currently Have the above code but want something "nicer"</span>
<span class="comment-copy">Let me clarify, do you want to get those entries from <code>list_with_nose</code> which are in <code>known_patterns</code> in the same order?</span>
<span class="comment-copy">nice! I would do  for i in xrange( len(mylist) - len(patern) +1 )  though to avoid needless comparisons: e.g., if len(mylist) was 1000, and len(pattern)was 50 then when i = 951 then len(mylist[i+len(pattern)]) will be 49, and len(pattern) would be 50 and so there is no way that can be matched</span>
<span class="comment-copy">also, list comprehension'd it</span>
<span class="comment-copy">I found that the second example also found sub-lists that were out of order.</span>
<span class="comment-copy">I think I would return a list of indices into mylist where matches were found. Returning copies of the pattern is not helpful since we know what the pattern is.  Good solution though. Thanks!</span>
<span class="comment-copy">Note that this is optimized for relatively short search patterns.  At root, this sort of algorithm should be optimized to limit visits per node in the search area.  As you increase the length (and/or repetition) of the search string, you will increase the number of repeat visits to nodes.  For instance, <code>[1,2,1,2,3] in [1,2,1,2,1,2,3]</code> will result in 21 visits, while  my overlap solution would only do 13.  Where the visit count starts to give worse perf than the optimizations from dropping in to C is is an open question though.</span>
<span class="comment-copy">@rikAtee Note that this solution will return 2, not 3 results in the overlap condition mentioned by EOL in the comments to the question.</span>
<span class="comment-copy">@rikAtee, no, we aren't appending in real time, we are only appending once we've found a complete match, so we need to append the entire pattern.</span>
<span class="comment-copy">My answer gets downvoted (without even a comment) while the answer that actually introduces new bugs by unnecessarily and jankily converting the entire list to a string gets 3 upvotes?  SO is a weird place sometimes...</span>
<span class="comment-copy">indeed, but it also got a big green tick next to it!</span>
<span class="comment-copy">This is actually a imperfect solution.  For instance, if you are searching for <code>[1, 2, 1, 2, 3]</code> in <code>[1, 2, 1, 2, 1, 2, 3]</code>, it will miss the match.  But for any non-repeating match patterns, this solution will work fine.  If you want to handle repeating match patterns, the most efficient way to do it involves pre-processing the search string for the repeating sections and being able to have the loop track multiple concurrent overlapping matching subsections.</span>
<span class="comment-copy">Same as Roman's solution, but a little less robust (accepts only single-digit values).</span>
<span class="comment-copy">Why not replace <code>all(a==b…)</code> simply by <code>pat == a_list[i:i+len(pat)]</code>?  This would also make your code more robust, as list <code>a_list</code> might contain <code>None</code> elements that would break the <code>izip_longest()</code> test (since it yields <code>None</code> for missing elements).</span>
<span class="comment-copy">@EOL The idea behind using <code>all</code> is to avoid the creation of sublists.  The only risk with <code>None</code> is if <code>pat</code> contains <code>None</code>, in which case the <code>fillvalue</code> parameter to <code>izip_longest</code> can be used.  <code>izip</code> was not used because to avoid matching a partial pattern at the end of the list.</span>
