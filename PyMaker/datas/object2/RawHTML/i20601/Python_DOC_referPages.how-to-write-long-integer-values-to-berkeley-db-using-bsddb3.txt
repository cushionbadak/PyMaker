<div class="post-text" itemprop="text">
<p>I am trying to use Berkeley DB to store a frequency table (i.e. hashtable with string keys and integer values). The table will be written, updated, and read from Python; so I am currently experimenting with bsddb3. This looks like it will do most of what I want, except it looks like it only supports string values?</p>
<p>If I understand correctly, Berkeley DB supports any kind of binary key and value. Is there a way to efficiently pass raw long integers in/out of Berkeley DB using bsddb3? I know I can convert the values to/from strings, and this is probably what I will end up doing, but is there a more efficient way? I.e. by storing 'raw' integers?</p>
<hr/>
<p>Background: I am currently working with a large (potentially tens, if not hundreds, of millions of keys) frequency table. This is currently implemented using a Python dictionary, but I abort the script when it starts to swap into virtual memory. Yes I looked at  Redis, but this stores the entire database in memory. So I'm about to try Berkeley DB. I should be able to improve the creation efficiency by using short-term in-memory caching. I.e. create an in-memory Python dictionary, and then periodically add this to the master Berkeley DB frequency table.</p>
</div>
<div class="post-text" itemprop="text">
<p>Do you need to read the data back from a language other than python? If not, you can just use pickle on the python long integers, and unpickle them when you read them back in. You might be able to (probably be able to) use the <code>shelve</code> module, which would do this automatically for you.  But even if not, you can manually pickle and unpickle the values.</p>
<pre><code>&gt;&gt;&gt; import cPickle as pickle
&gt;&gt;&gt; pickle.dumps(19999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999, pickle.HIGHEST_PROTOCOL)
'\x80\x02\x8a(\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x7fT\x97\x05p\x0b\x18J#\x9aA\xa5.{8=O,f\xfa\x81|\xa1\xef\xaa\xfd\xa2e\x02.'
&gt;&gt;&gt; pickle.loads('\x80\x02\x8a(\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x7fT\x97\x05p\x0b\x18J#\x9aA\xa5.{8=O,f\xfa\x81|\xa1\xef\xaa\xfd\xa2e\x02.')
19999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999L
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python <a href="https://docs.python.org/3/library/struct.html" rel="nofollow"><code>struct</code></a> to convert an integer to bytes in Python 3 or string in Python 2. Depending on your data you might use different packing format for <em>unsigned long long</em> or <code>uint64_t</code> :</p>
<pre><code>struct.unpack('&gt;Q', my_integer)
</code></pre>
<p>This will return the byte representation of <code>my_integer</code> on <strong>bigendian</strong> which match the lexicographical order required by bsddb key values. You can come with smarter packing function (have a look at <a href="https://github.com/wiredtiger/wiredtiger/blob/155fec24f63b3ffb845110d2baed47799c400dd8/lang/python/wiredtiger/intpacking.py#L75" rel="nofollow"><code>wiredtiger.intpacking</code></a>) to save a space.</p>
<p>You don't need a Python cache, use <a href="https://www.jcea.es/programacion/pybsddb_doc/dbenv.html#set_cache_max" rel="nofollow"><code>DBEnv.set_cache_max</code> and <code>set_cache</code></a>.</p>
</div>
<span class="comment-copy">Probably don't need another language. Although I do have a C# use-case in mind, it would be an import utility (ie. one off import rather than random access), so it could work with a Python-produced text dump(s).  I assume pickle is going to be a little bit more efficient than string formatting?</span>
<span class="comment-copy">Looks to be running okay, and I've had the script running overnight. Looks like speed might be an issue - perhaps I need a bigger in-memory cache.</span>
