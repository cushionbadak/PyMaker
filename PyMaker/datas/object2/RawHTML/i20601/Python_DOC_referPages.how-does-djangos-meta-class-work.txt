<div class="post-text" itemprop="text">
<p>I am using Django which allows people to add extra parameters to a class by using <code>class Meta</code>.</p>
<pre><code>class FooModel(models.Model):
    ...
    class Meta:
        ...
</code></pre>
<p>The only thing I found in Python's documentation was:</p>
<pre><code>class FooMetaClass(type):
    ...

class FooClass:
    __metaclass__ = FooMetaClass
</code></pre>
<p>However, I don't think this is the same thing.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are asking a question about two different things:</p>
<ol>
<li><p><strong><code>Meta</code> inner class in Django models</strong>:</p>
<p>This is just a class container with some options (metadata) attached to the model. It defines such things as available permissions, associated database table name, whether the model is abstract or not, singular and plural versions of the name etc.</p>
<p>Short explanation is here: <a href="https://docs.djangoproject.com/en/dev/topics/db/models/#meta-options" rel="noreferrer">Django docs: Models: Meta options</a></p>
<p>List of available meta options is here: <a href="https://docs.djangoproject.com/en/dev/ref/models/options/" rel="noreferrer">Django docs: Model Meta options</a></p></li>
<li><p><strong>Metaclass in Python</strong>:</p>
<p>The best description is here: <a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">What is a metaclass in Python?</a></p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Extending on Tadeck's Django answer above, the use of 'class Meta:' in Django is just normal Python too.</p>
<p>The internal class is a convenient namespace for shared data among the class instances (hence the name Meta for 'metadata' but you can call it anything you like). While in Django it's generally read-only configuration stuff, there is nothing to stop you changing it:</p>
<pre><code>In [1]: class Foo(object):
   ...:     class Meta:
   ...:         metaVal = 1
   ...:         
In [2]: f1 = Foo()
In [3]: f2 = Foo()
In [4]: f1.Meta.metaVal
Out[4]: 1
In [5]: f2.Meta.metaVal = 2
In [6]: f1.Meta.metaVal
Out[6]: 2
In [7]: Foo.Meta.metaVal
Out[7]: 2
</code></pre>
<p>You can explore it in Django directly too e.g:</p>
<pre><code>In [1]: from django.contrib.auth.models import User
In [2]: User.Meta
Out[2]: django.contrib.auth.models.Meta
In [3]: User.Meta.__dict__
Out[3]: 
{'__doc__': None,
 '__module__': 'django.contrib.auth.models',
 'abstract': False,
 'verbose_name': &lt;django.utils.functional.__proxy__ at 0x26a6610&gt;,
 'verbose_name_plural': &lt;django.utils.functional.__proxy__ at 0x26a6650&gt;}
</code></pre>
<p>However, in Django you are more likely to want to explore the <code>_meta</code> attribute which is an <code>Options</code> object created by the model <code>metaclass</code> when a model is created. That is where you'll find all of the Django class 'meta' information. In Django, <code>Meta</code> is just used to pass information into the process of creating the <code>_meta</code> <code>Options</code> object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Django's <code>Model</code> class specifically handles having an attribute named <code>Meta</code> which is a class. It's not a general Python thing.</p>
<p>Python metaclasses are completely different.</p>
</div>
<div class="post-text" itemprop="text">
<p>Answers that claim Django model's <code>Meta</code> and metaclasses are "completely different" are misleading answers.</p>
<p>The construction of Django model <strong>class objects</strong> (that is to say the object that stands for the class definition itself; yes, classes are also objects) are indeed controlled by a metaclass called <code>ModelBase</code>, you can see that code here:</p>
<p><a href="https://github.com/django/django/blob/master/django/db/models/base.py#L61" rel="nofollow noreferrer">https://github.com/django/django/blob/master/django/db/models/base.py#L61</a></p>
<p>And one of the things that <code>ModelBase</code> does is to create the <code>_meta</code> attribute on every Django model which contains validation machinery, field details, saving machinery and so forth. And, during this operation, anything that is specified in the model's inner <code>Meta</code> class is read and used within that process.</p>
<p>So, while yes, in a sense <code>Meta</code> and metaclasses are different 'things', within the mechanics of Django model construction they are intimately related; understanding how they work together will deepen your insight into both at once.</p>
<p>This might be a helpful source of information to better understand how Django models employ metaclasses.</p>
<p><a href="https://code.djangoproject.com/wiki/DevModelCreation" rel="nofollow noreferrer">https://code.djangoproject.com/wiki/DevModelCreation</a></p>
<p>And this might help too if you want to better understand how objects work in general.</p>
<p><a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Inner Meta Class Document
This document of django
Model metadata is “anything that’s not a field”, such as ordering options (ordering), database table name (db_table), or human-readable singular and plural names (verbose_name and verbose_name_plural). None are required, and adding class Meta to a model is completely optional.
<a href="https://docs.djangoproject.com/en/dev/topics/db/models/#meta-options" rel="nofollow noreferrer">https://docs.djangoproject.com/en/dev/topics/db/models/#meta-options</a></p>
</div>
<span class="comment-copy">Title asks about Python meta, but question seems to ask about Django meta - which one are you asking about?</span>
<span class="comment-copy">@ckhan he is confused due to the absurd decision (IMO) to call a nested class "Meta", which is very misleading; to beginners, about Python's metaclasses, and to more experienced users that have never seen it, about its purpose a priori (instead of using class attributes or real metaclasses)</span>
<span class="comment-copy">Are these two things related at all? i.e., does Django's <code>Meta</code> inner class prevent you from using Python's builtin metaclass features?</span>
<span class="comment-copy">@nnyby: There are two things that create relation between these two concepts: name and confusion many users have (as OP had it in original question). I believe addressing that common confusion is significant advantage of this topi.  Don't you agree?</span>
<span class="comment-copy">This doesn't work on user-defined models:  &gt;&gt;&gt;from myapp.models import MyModel  &gt;&gt;&gt;MyModel.Meta  Traceback (most recent call last):   File "&lt;console&gt;", line 1, in &lt;module&gt; AttributeError: type object 'MyModel' has no attribute 'meta'</span>
<span class="comment-copy">You need the underscore e.g. <code>MyUser.objects.get(pk=1)._meta</code></span>
<span class="comment-copy">Right, but that doesn't access the Model's class's inner Meta class. That accesses the _meta options for that Model's instance...there doesn't appear to be a way to access the inner Meta class itself. The use case for me was subclassing a proxy MyModelProxy class from MyModel in a way where MyModelProxy can inherit MyModel's inner Meta class.</span>
<span class="comment-copy">I'm not entirely clear on what you mean by the model's 'inner Meta class' but you can always work directly with the instance's class e.g <code>type(MyUser.objects.get(pk=1)).Meta</code></span>
<span class="comment-copy">"convenient namespace for shared data among the class instances" That line did it for me.</span>
<span class="comment-copy">I think your answer is not clear enough - could you elaborate on how <code>Meta</code> class works? I believe OP asked specifically about that.</span>
