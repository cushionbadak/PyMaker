<div class="post-text" itemprop="text">
<p>I have a list say <code>lis1 = [1,2,3]</code>
and a list of subset of above list say </p>
<pre><code>lis2 = [[1,2],[2,3],[3],[1],[2]]
</code></pre>
<p>I want to generate all combinations of lis2 such that all items of lis1 should present in the combination. </p>
<p>For eg. this is a valid combinations</p>
<p>one such combination is <code>[[1,2],[2,3]]</code> (all items of <code>lis1</code> i.e <code>[1,2,3]</code> is present in it)</p>
<p>whereas this is not </p>
<pre><code>[[1,2],[1],[2]] # (3 is not present in it)
</code></pre>
<p>What I did was generated powerset of lis2 via this function</p>
<pre><code>from itertools import chain, combinations

def powerset(iterable):
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(1,len(s)+1))
</code></pre>
<p>But as obvious the returning set contain combinations which are of type</p>
<pre><code>[[1,2],[1],[2]] # (3 is not present in it)
</code></pre>
<p>How do I check for the combinations which contain all the item of lis1</p>
</div>
<div class="post-text" itemprop="text">
<p>You can apply your <code>powerset</code> function to get combinations of subsets and filter the results:</p>
<pre><code>&gt;&gt;&gt; lis1 = [1,2,3]
&gt;&gt;&gt; lis2 = [[1,2],[2,3],[3],[1],[2]]
&gt;&gt;&gt; filter(lambda s: set(sum(s,[])) == set(lis1), powerset(lis2))
[([1, 2], [2, 3]),
 ([1, 2], [3]),
 ([2, 3], [1]),
 ([1, 2], [2, 3], [3]),
 ([1, 2], [2, 3], [1]),
 ([1, 2], [2, 3], [2]),
 ([1, 2], [3], [1]),
 ([1, 2], [3], [2]),
 ([2, 3], [3], [1]),
 ([2, 3], [1], [2]),
 ([3], [1], [2]),
 ([1, 2], [2, 3], [3], [1]),
 ([1, 2], [2, 3], [3], [2]),
 ([1, 2], [2, 3], [1], [2]),
 ([1, 2], [3], [1], [2]),
 ([2, 3], [3], [1], [2]),
 ([1, 2], [2, 3], [3], [1], [2])]
</code></pre>
<p>If you want no duplicate elements in the resulting subsets, use this instead:</p>
<pre><code>&gt;&gt;&gt; filter(lambda s: sorted(sum(s,[])) == sorted(lis1), powerset(lis2))
[([1, 2], [3]), ([2, 3], [1]), ([3], [1], [2])]
</code></pre>
<p>Both methods use <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow"><code>sum(s, [])</code></a> to flatten the nested lists and then compare those to the original elements using either <code>set</code> (all present, ignore duplicates) or <code>sorted</code> (all present, exact same count).</p>
</div>
<span class="comment-copy">"one such combination is <code>[[1,2],[2,3]]</code> (all items of <code>lis1</code> i.e <code>[1,2]</code> is present in it)" -- what do you mean? It's missing <code>3</code>, which is present in <code>lis1</code>.</span>
<span class="comment-copy">So, the list of lists can contain duplicate elements? What about duplicate subsets? Would <code>[[1,2],[3],[1,2]]</code> be allowed or not? Also, does the order matter?</span>
<span class="comment-copy">@tobias_k duplicate elements are not allowed and order does not matter</span>
<span class="comment-copy">Duplicates as sublist are not allowed [1,2] is not equals [2,3]-- but 2 is contained in both [1,2] and [2,3]. Your example above is [[1,2],[3],[1,2]] is not allowed because it has 2 sub-list [1,2] and [1,2] which are equal. Also this is not a valid eg [[1,2],[3],[2,1]] (as order does not matter so [1,2],[2,1] are treated as equal and these cases will never exits in lis2 above)</span>
<span class="comment-copy">Whops, sorry, I was already writing an answer and totally forgot what I was asking about in the comment. Sorry for the confusion.</span>
<span class="comment-copy">I have to get combinations of lis2 not lis1. If going by above procedure I have to make an extra check that sub-items(individual items returned by single row) returned by filter function must also match items in lis2.</span>
<span class="comment-copy">@AnuragSharma I edited my answer to better fit to your question.</span>
