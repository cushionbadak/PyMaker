<div class="post-text" itemprop="text">
<p>I need to multiply two big matrices and sort their columns.</p>
<pre><code> import numpy
 a= numpy.random.rand(1000000, 100)
 b= numpy.random.rand(300000,100)
 c= numpy.dot(b,a.T)
 sorted = [argsort(j)[:10] for j in c.T]
</code></pre>
<p>This process takes a lot of time and memory. Is there a way to fasten this process? If not how can I calculate RAM needed to do this operation? I currently have an EC2 box with 4GB RAM and no swap. </p>
<p>I was wondering if this operation can be serialized and I dont have to store everything in the memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>One thing that you can do to speed things up is compile numpy with an optimized BLAS library like e.g. ATLAS, GOTO blas or Intel's proprietary MKL.</p>
<p>To calculate the memory needed, you need to monitor Python's Resident Set Size ("RSS"). The following commands were run on a UNIX system (FreeBSD to be precise, on a 64-bit machine).</p>
<pre><code>&gt; ipython

In [1]: import numpy as np

In [2]: a = np.random.rand(1000, 1000)

In [3]: a.dtype
Out[3]: dtype('float64')

In [4]: del(a)
</code></pre>
<p>To get the RSS I ran:</p>
<pre><code>ps -xao comm,rss | grep python
</code></pre>
<p>[<em>Edit:</em> See the <a href="http://www.freebsd.org/cgi/man.cgi?query=ps" rel="nofollow"><code>ps</code> manual page</a> for a complete explanation of the options, but basically these <code>ps</code> options make it show only the command and resident set size of all processes. The equivalent format for Linux's <code>ps</code> would be <code>ps -xao c,r</code>, I believe.]</p>
<p>The results are;</p>
<ul>
<li>After starting the interpreter: 24880 kiB</li>
<li>After importing numpy: 34364 kiB</li>
<li>After creating <code>a</code>: 42200 kiB</li>
<li>After deleting <code>a</code>: 34368 kiB</li>
</ul>
<p>Calculating the size;</p>
<pre><code>In [4]: (42200 - 34364) * 1024
Out[4]: 8024064

In [5]: 8024064/(1000*1000)
Out[5]: 8.024064
</code></pre>
<p>As you can see, the calculated size matches the 8 bytes for the default datatype <code>float64</code> quite well. The difference is internal overhead.</p>
<p>The size of your original arrays in MiB will be approximately;</p>
<pre><code>In [11]: 8*1000000*100/1024**2
Out[11]: 762.939453125

In [12]: 8*300000*100/1024**2
Out[12]: 228.8818359375
</code></pre>
<p>That's not too bad. However, the dot product will be way too large:</p>
<pre><code>In [19]: 8*1000000*300000/1024**3
Out[19]: 2235.1741790771484
</code></pre>
<p>That's 2235 GiB!</p>
<p>What you can do is split up the problem and perfrom the <code>dot</code> operation in pieces;</p>
<ul>
<li>load <code>b</code> as an ndarray</li>
<li>load every row from <code>a</code> as an <code>ndarray</code> in turn.</li>
<li>multiply the row by every column of <code>b</code> and write the result to a file.</li>
<li><code>del()</code> the row and load the next row.</li>
</ul>
<p>This wil not make it faster, but it would make it use less memory!</p>
<p><em>Edit:</em> In this case I would suggest writing the output file in binary format (e.g. using <code>struct</code> or <code>ndarray.tofile</code>). That would make it much easier to read a column from the file with e.g. a <code>numpy.memmap</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>What DrV and Roland Smith said are good answers; they should be listened to. My answer does nothing more than present an option to make your data sparse, a complete game-changer.</p>
<p>Sparsity can be extremely powerful. It would transform your <code>O(100 * 300000 * 1000000)</code> operation into an <code>O(k)</code> operation with k non-zero elements (sparsity only means that the matrix is largely zero). I know sparsity has been mentioned by DrV and disregarded as not applicable but I would guess it is.</p>
<p>All that needs to be done is to find a <a href="http://en.wikipedia.org/wiki/Sparse_approximation" rel="nofollow">sparse representation</a> for computing this transform (and interpreting the results is another ball game). Easy (and fast) methods include the <a href="https://en.wikipedia.org/wiki/Fourier_transform" rel="nofollow">Fourier transform</a> or <a href="https://en.wikipedia.org/wiki/Wavelet_transform" rel="nofollow">wavelet transform</a> (both rely on similarity between matrix elements) but this problem is generalizable through <a href="http://en.wikipedia.org/wiki/Sparse_approximation#Algorithms" rel="nofollow">several different algorithms</a>.</p>
<p>Having experience with problems like this, this smells like a relatively common problem that is typically solved through some clever trick. When in a field like machine learning where these types of problems are classified as "simple," that's often the case.</p>
</div>
<div class="post-text" itemprop="text">
<p>YOu have a problem in any case. As <code>Roland Smith</code> shows you in his answer, the amount of data and number of calculations is enormous. You may not be very familiar with linear algebra, so a few words of explanation might help in understanding (and then hopefully solving) the problem.</p>
<p>Your arrays are both a collection of vectors with length 100. One of the arrays has 300 000 vectors, the other one 1 000 000 vectors. The dot product between these arrays means that you calculate the dot product of each possible pair of vectors. There are 300 000 000 000 such pairs, so the resulting matrix is either 1.2 TB or 2.4 TB depending on whether you use 32 or 64-bit floats.</p>
<p>On my computer dot multiplying a (300,100) array with a (100,1000) array takes approximately 1 ms. Extrapolating from that, you are looking at a 1000 s calculation time (depending on the number of cores).</p>
<p>The nice thing about taking a dot product is that you can do it piecewise. Keeping the output is then another problem.</p>
<hr/>
<p><em>If you were running it on your own computer</em>, calculating the resulting matrix could be done in the following way:</p>
<ul>
<li>create an output array as a <code>np.memmap</code> array onto the disk</li>
<li>calculate the results one row at a time (as explained by <code>Roland Smith</code>)</li>
</ul>
<p>This would result in a linear file write with a largish (2.4 TB) file. </p>
<p>This does not require too many lines of code. However,  make sure everything is transposed in a suitable way; transposing the input arrays is cheap, transposing the output is extremely expensive. Accessing the resulting huge array is cheap if you can access elements close to each other, expensive, if you access elements far away from each other.</p>
<p>Sorting a huge memmapped array has to be done carefully. You should use in-place sort algorithms which operate on contiguous chunks of data. The data is stored in 4 KiB chunks (512 or 1024 floats), and the fewer chunks you need to read, the better.</p>
<hr/>
<p>Now that you are not running the code in our own machine but on a cloud platform, things change a lot. Usually the cloud SSD storage is very fast with random accesses, but IO is expensive (also in terms of money). Probably the least expensive option is to calculate suitable chunks of data and send them to S3 storage for further use. The "suitable chunk" part depends on how you intend to use the data. If you need to process individual columns, then you send one or a few columns at a time to the cloud object storage.</p>
<hr/>
<p>However, a lot depends on your sorting needs. Your code looks as if you are finally only looking at a few first items of each column. If this is the case, then you should only calculate the first few items and not the full output matrix. That way you can do everything in memory.</p>
<p>Maybe if you tell a bit more about your sorting needs, there can be a viable way to do what you want.</p>
<p>Oh, one important thing: Are your matrices dense or sparse? (Sparse means they mostly contain 0's.) If your expect your output matrix to be mostly zero, that may change the game completely.</p>
</div>
<span class="comment-copy">how "huge"? . . . .</span>
<span class="comment-copy">So all you are actually interested in are the 10 smallest scalar products? Then you can iterate through in blocks and throw a lot away on the way.</span>
<span class="comment-copy">That seems to be a nice idea.. how can I do so? I mean is there a pythonic way or do I have to write my own algorithm?</span>
<span class="comment-copy">If you only need the 10 smallest you should have a look at <a href="http://docs.scipy.org/doc/numpy-1.8.1/reference/generated/numpy.argpartition.html" rel="nofollow noreferrer"><code>np.argpartition</code></a>, I think it will save you some time. For other suggestions: <a href="http://stackoverflow.com/q/6910641/2379410">stackoverflow.com/q/6910641/2379410</a></span>
<span class="comment-copy">Hey thanks for the help. Can you explain what is <i>xao comm,rss</i> in your bash script.I got the full understanding of memory issues. Thanks a zillion.</span>
<span class="comment-copy">@mousecoder See update.</span>
<span class="comment-copy">It's also possible to get the resident set size directly in python by calling <code>resource.getrusage(resource.RUSAGE_SELF).ru_maxrss</code> <a href="https://docs.python.org/3/library/resource.html" rel="nofollow noreferrer">docs.python.org/3/library/resource.html</a></span>
<span class="comment-copy">That was an eye opener. Thanks a lot for sharing</span>
<span class="comment-copy">Hey, thanks for the help. Unfortunately my matrices are not sparse. I just read about np.memmap. It says it uses Python's Memory Map Object and does not allow files &gt; 2GB. As you said it will take around 2TB for data is there a way to increase size of memmap.</span>
<span class="comment-copy">Can you explain a bit about sorting on chunks of data? How is that possible in python? any specific library. As far as I understand my problem can be solved by multiplying one vector at a time with matrix and sorting it and then storing it in the file.</span>
<span class="comment-copy">Modern versions of <code>memmap</code> do not have any practical limits with 64-bit Pythons, the 2 GB limit is an old one and may depend on the operating system. Also, your life is much easier if you only sort items within a row (transpose your matrix if you need), as then a simple <code>sort</code> sorts the row very efficiently. (I understood that you need to move columns or rows in a matrix, and that would have been more difficult.)</span>
