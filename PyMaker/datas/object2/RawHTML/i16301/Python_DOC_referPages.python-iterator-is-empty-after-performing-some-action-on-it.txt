<div class="post-text" itemprop="text">
<p>I was trying to do a challenge on codeeval in python3 and got stuck trying to improve my solution. Every time i tried to iterate (or print, or some other action) two times consecutively over the same iterator, the second loop came up empty. Here is a minimal example that produces this behavior, although I tried several different combinations with lists etc. that gave me the same result:</p>
<pre><code>numbers = ('1','2','3','4','5')
numbers = map(int, numbers)                                                    
print(list(numbers))                                                          
print(list(numbers))
</code></pre>
<p>results in:</p>
<pre><code>[1, 2, 3, 4, 5]
[]
</code></pre>
<p>Why does print (in this case) delete the content of numbers? </p>
</div>
<div class="post-text" itemprop="text">
<p>This is exactly how iterators work. They're designed to generate data on the fly exactly one time, no more. If you want to get data out of it a second time, you either have to save all the iterated data to another list, or initiate the iterator again. In cases where you need to read from files or do other annoying things to re-obtain that iterator, it's probably best to just store that data in a list when it's generated.</p>
<pre><code>&gt;&gt;&gt; numbers = ('1','2','3','4','5')
&gt;&gt;&gt; ints = [x for x in map(int, numbers)]
&gt;&gt;&gt; print(list(ints))
[1, 2, 3, 4, 5]
&gt;&gt;&gt; print(list(ints))
[1, 2, 3, 4, 5]
</code></pre>
<p><a href="https://docs.python.org/2/library/stdtypes.html#iterator-types" rel="nofollow">https://docs.python.org/2/library/stdtypes.html#iterator-types</a></p>
<blockquote>
<p>The intention of the protocol is that once an iteratorâ€™s next() method
  raises StopIteration, it will continue to do so on subsequent calls.
  Implementations that do not obey this property are deemed broken.
  (This constraint was added in Python 2.3; in Python 2.2, various
  iterators are broken according to this rule.)</p>
</blockquote>
<p>I should note that I ran the exact code you gave on Python 2.4.3, and it printed out the list every time. So it's a version dependent thing, I suppose.</p>
</div>
<span class="comment-copy">That's the nature of an iterator. Once done, it <i>stays</i> done.</span>
<span class="comment-copy">You can just call the <code>map</code> function again. Though if you're going to do that, it's best not to do <code>numbers = map(int, numbers)</code>. Try giving it another name, like <code>ints = map(int, numbers)</code>. That way you're not destroying the original data.</span>
<span class="comment-copy">What would be the way to re-initiate an iterator? Do I really have to map it for each print? Also, in my specific cast (but not the minimal example) the initial list comes from an open('file') statement. Would I have to do that twice too?</span>
<span class="comment-copy">@Guerki you might have to, yes. In that case, you should iterate over the data and save it to a list; that will keep the data there permanently. I'll update my answer.</span>
<span class="comment-copy">@TheSoundDefense: In Python 3.x, many functions that previously returned lists now return iterators. In this case, <code>map()</code> has been converted in that way. So the equivalent py3k code is: <code>ints = list(map(int, numbers))</code></span>
<span class="comment-copy">One other thing worth noting is <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>itertools.tee()</code></a>, which can be helpful if you don't think you're going to iterate through the entire iterator, but you may need to iterate up to that point multiple times.</span>
