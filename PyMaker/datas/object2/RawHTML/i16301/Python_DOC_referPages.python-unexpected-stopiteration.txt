<div class="post-text" itemprop="text">
<p>This is my code</p>
<pre><code>class A:
    pass

def f():
    yield A()

def g():
    it = f()
    next(it).a = next(it, None)

g()
</code></pre>
<p>that produces the <code>StopIteration</code> error, caused by <code>next(it).a = next(it, None)</code>. Why?</p>
<p>The documentation says that <a href="https://docs.python.org/3/library/functions.html?highlight=next#next" rel="nofollow"><code>next</code></a> function does not raise the <code>StopIteration</code> if the default value is provided, and I expected it to get me the first item from the generator (the <code>A</code> instance) and set the <code>a</code> attribute to <code>None</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>f</code> only yields a single value, you can only call <code>next</code> on it once.</p>
<p>The right hand side of your expression (<code>next(it, None)</code>) is evaluated <em>before</em> the left hand side, and thus exhausts the generator.</p>
<p>Calling <code>next(it).a</code> on the left hand side will then raise <code>StopIteration</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>f()</code> generator function yields just <strong>one</strong> value. After that it is exhausted and raises <code>StopIteration</code>.</p>
<pre><code>&gt;&gt;&gt; class A:
...     pass
... 
&gt;&gt;&gt; def f():
...     yield A()
... 
&gt;&gt;&gt; generator = f()
&gt;&gt;&gt; generator
&lt;generator object f at 0x10be771f8&gt;
&gt;&gt;&gt; next(generator)
&lt;__main__.A object at 0x10be76f60&gt;
&gt;&gt;&gt; next(generator)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>That's because there is <em>no loop</em> in <code>f()</code> to yield more than once, a generator function does not, on its own, loop, just because you can use it <em>in</em> a loop.</p>
<p>Note that for an assignment, Python executes the right-hand-side expression <em>first</em>, before figuring out what to assign it <em>to</em>. So the <code>next(it, None)</code> is called first, the <code>next(it).a</code> for the assignment is called <em>second</em>.</p>
<p>The body of the <code>f()</code> function is executed just like any other Python function, with the addition of <em>pausing</em>. <code>next()</code> on the generator un-pauses the code, and the code then runs until the next <code>yield</code> statement is executed. That statement then pauses the generator again. If the function instead <em>ends</em> (returns), <code>StopIteration</code> is raised.</p>
<p>In your <code>f()</code> generator that means:</p>
<ol>
<li>when you call <code>f()</code> a new generator object is created. The function body is paused.</li>
<li>you call <code>next()</code> on it the first time. The code starts running, creates an instance of <code>A()</code> and yields that instance. The function is paused again.</li>
<li>you call <code>next()</code> on it a second time. The code starts running, reaches the end of the function, and returns. <code>StopIteration</code> is raised.</li>
</ol>
<p>If you add a loop to <code>f()</code>, or simply add a <em>second</em> <code>yield</code> line, your code works:</p>
<pre><code>def f():
    yield A()
    yield A()
</code></pre>
<p>or</p>
<pre><code>def f():
    while True:
        yield A()
</code></pre>
</div>
