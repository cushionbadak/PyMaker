<div class="post-text" itemprop="text">
<p>I get this pep8 warning whenever I use lambda expressions. Are lambda expressions not recommended? If not why?</p>
</div>
<div class="post-text" itemprop="text">
<p>The recommendation in <a href="http://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="noreferrer">PEP-8</a> you are running into is:</p>
<blockquote>
<p>Always use a def statement instead of an assignment statement that
  binds a lambda expression directly to a name.</p>
<p>Yes:</p>
<pre><code>def f(x): return 2*x 
</code></pre>
<p>No:</p>
<pre><code>f = lambda x: 2*x 
</code></pre>
<p>The first form means that the name of the resulting
  function object is specifically 'f' instead of the generic '&lt;lambda&gt;'.
  This is more useful for tracebacks and string representations in
  general. The use of the assignment statement eliminates the sole
  benefit a lambda expression can offer over an explicit def statement
  (i.e. that it can be embedded inside a larger expression)</p>
</blockquote>
<p>Assigning lambdas to names basically just duplicates the functionality of <code>def</code> - and in general, it's best to do something a single way to avoid confusion and increase clarity.</p>
<p>The legitimate use case for lambda is where you want to use a function without assigning it, e.g:</p>
<pre><code>sorted(players, key=lambda player: player.rank)
</code></pre>
<p>For simple operations, <a href="https://docs.python.org/3/library/operator.html#module-operator" rel="noreferrer">the <code>operator</code> module</a> provides some useful options in <a href="https://docs.python.org/3/library/operator.html#operator.attrgetter" rel="noreferrer"><code>attrgetter</code></a>, <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="noreferrer"><code>itemgetter</code></a> and <a href="https://docs.python.org/3/library/operator.html#operator.methodcaller" rel="noreferrer"><code>methodcaller</code></a> which can often replace labmdas that are just accessing attribute(s), item(s) and calling methods. </p>
<p>For example, the above could be done with <code>operator.attrgetter</code> like so:</p>
<pre><code>sorted(players, key=operator.attrgetter('rank'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is the story, I had a simple lambda function which I was using twice. </p>
<pre><code>a = map(lambda x : x + offset, simple_list)
b = map(lambda x : x + offset, another_simple_list)
</code></pre>
<p>This is just for the representation, I have faced couple of different versions of this.</p>
<p>Now, to keep things DRY, I start to reuse this common lambda. </p>
<pre><code>f = lambda x : x + offset
a = map(f, simple_list)
b = map(f, another_simple_list)
</code></pre>
<p>At this point my code quality checker complains about lambda being a named function so I convert it into a function. </p>
<pre><code>def f(x):
    return x + offset
a = map(f, simple_list)
b = map(f, another_simple_list)
</code></pre>
<p>Now the checker complains that a function has to be bounded by one blank line before and after. </p>
<pre><code>def f(x):
    return x + offset

a = map(f, simple_list)
b = map(f, another_simple_list)
</code></pre>
<p>Here we have now 6 lines of code instead of original 2 lines with no increase in readability and no increase in being pythonic. At this point the code checker complains about the function not having docstrings. </p>
<p>In my opinion this rule better be avoided and broken when it makes sense, use your judgement. </p>
</div>
<div class="post-text" itemprop="text">
<p>Lattyware is absolutely right: Basically <a href="http://legacy.python.org/dev/peps/pep-0008/#programming-recommendations">PEP-8</a> wants you to avoid things like</p>
<pre><code>f = lambda x: 2 * x
</code></pre>
<p>and instead use</p>
<pre><code>def f(x):
    return 2 * x
</code></pre>
<p>However, as addressed in a recent <a href="https://github.com/jcrocholl/pep8/issues/311">bugreport</a> (Aug 2014), statements such as the following are now compliant:</p>
<pre><code>a.f = lambda x: 2 * x
a["f"] = lambda x: 2 * x
</code></pre>
<p>Since my PEP-8 checker doesn't implement this correctly yet, I turned off E731 for the time being.</p>
</div>
<div class="post-text" itemprop="text">
<p>I also encountered a situation in which it was even impossible to use a def(ined) function.</p>
<pre><code>class SomeClass(object):
  # pep-8 does not allow this
  f = lambda x: x + 1  # NOQA

  def not_reachable(self, x):
    return x + 1

  @staticmethod
  def also_not_reachable(x):
    return x + 1

  @classmethod
  def also_not_reachable(cls, x):
    return x + 1

  some_mapping = {
      'object1': {'name': "Object 1", 'func': f},
      'object2': {'name': "Object 2", 'func': some_other_func},
  }
</code></pre>
<p>In this case, I really wanted to make a mapping which belonged to the class. Some objects in the mapping needed the same function. It would be illogical to put the a named function outside of the class. 
I have not found a way to refer to a method (staticmethod, classmethod or normal) from inside the class body. SomeClass does not exist yet when the code is run. So referring to it from the class isn't possible either. </p>
</div>
<span class="comment-copy">For clarity, the question refers to a message for an automated check in <code>flake8</code> (<a href="http://flake8.pycqa.org/" rel="nofollow noreferrer">flake8.pycqa.org</a>)</span>
<span class="comment-copy">Personally I think the lambda version is prettier.  That's why there's ignore.</span>
<span class="comment-copy">I don't see how it's worse.  The traceback is still going to include the errant line number and source file.  One might say "f" whereas the other says "lambda".  Maybe the lambda error is easier to scan because it's not a single-character function name, or a poorly-named long name?</span>
<span class="comment-copy">@g33kz0r Well, sure, if you assume the rest of your code is going to have poor quality, following conventions won't gain you much. In general, no, it's not the end of the world, but it's still a bad idea.</span>
<span class="comment-copy">This answer is not very helpful, because when running the suggested approach of using <code>def</code> through the PEP8 checker, you get <code>E704 multiple statements on one line (def)</code>, and if you split it into two lines you get <code>E301 expected 1 blank line, found 0</code> :-/</span>
<span class="comment-copy">I agree it should be split. My points were that a) it is not split in the answer's code above, causing E704, and b) if you split it, you need an ugly blank line above it to avoid E301.</span>
<span class="comment-copy">Great commentary.  This is exactly how I think about it as well.</span>
<span class="comment-copy"><code>a = [x + offset for x in simple_list]</code>. No need to use <code>map</code> and <code>lambda</code> here.</span>
<span class="comment-copy">@Georgy I believe the point was to move the <code>x + offset</code> portion to an abstracted location that can be updated without changing more than one line of code.  With list comprehensions as you mentioned, you would still need two lines of code that contained <code>x + offset</code> they would just now be in list comprehensions.  In order to pull those out as the author wanted, you would need a <code>def</code> or <code>lambda</code>.</span>
<span class="comment-copy">@Julian Apart from <code>def</code> and <code>lambda</code> one could also use <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer">functools.partial</a>: <code>f = partial(operator.add, offset)</code> and then <code>a = list(map(f, simple_list))</code>.</span>
<span class="comment-copy">Even when using <code>def</code>, the PEP8 checker complains with <code>E301 expected 1 blank line, found 0</code>, so you then have to add an ugly blank line before it.</span>
<span class="comment-copy">You could refer to <code>also_not_reachable</code> in the mapping definition as <code>SomeClass.also_not_reachable</code></span>
<span class="comment-copy">I don't know what point you're trying to make here. Every one of your function names is as reachable as <code>f</code> in both 2.7 and 3.5 for me</span>
