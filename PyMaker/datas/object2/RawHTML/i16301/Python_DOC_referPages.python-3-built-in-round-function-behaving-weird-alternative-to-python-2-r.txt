<div class="post-text" itemprop="text">
<p>I was just re-reading <a href="http://docs.python.org/py3k/whatsnew/3.0.html" rel="noreferrer">What’s New In Python 3.0</a> and it states:</p>
<blockquote>
<p>The round() function rounding strategy and return type have changed.
  Exact halfway cases are now rounded to the nearest even result instead
  of away from zero. (For example, round(2.5) now returns 2 rather than
  3.)</p>
</blockquote>
<p>and
the documentation for <a href="http://docs.python.org/release/3.1.5/library/functions.html#round" rel="noreferrer">round</a>:</p>
<blockquote>
<p>For the built-in types supporting round(), values are rounded to the
  closest multiple of 10 to the power minus n; if two multiples are
  equally close, rounding is done toward the even choice</p>
</blockquote>
<p>So, under <strong>v2.7.3</strong>:</p>
<pre><code>In [85]: round(2.5)
Out[85]: 3.0

In [86]: round(3.5)
Out[86]: 4.0
</code></pre>
<p>as I'd have expected. However, now under <strong>v3.2.3</strong>:</p>
<pre><code>In [32]: round(2.5)
Out[32]: 2

In [33]: round(3.5)
Out[33]: 4
</code></pre>
<p>This seems counter-intuitive and contrary to what I understand about
rounding (and bound to trip up people). English isn't my native language but
until I read this I thought I knew what rounding meant :-/  I am sure
at the time v3 was introduced there must have been some discussion of
this, but I was unable to find a good reason in my search.</p>
<ol>
<li>Does anyone have insight into why this was changed to this?</li>
<li>Are there any other mainstream programming languages (e.g., <em>C, C++, Java, Perl,</em> ..) that do this sort of (to  me inconsistent) rounding?</li>
</ol>
<p>What am I missing here?</p>
<p>UPDATE: @Li-aungYip's comment re "Banker's rounding" gave me the right search term/keywords to search for and I found this SO question: <a href="https://stackoverflow.com/questions/311696/why-does-net-use-bankers-rounding-as-default">Why does .NET use banker's rounding as default?</a>, so I will be reading that carefully.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.0's way is considered the standard rounding method these days, though some language implementations aren't on the bus yet.</p>
<p>The simple "always round 0.5 up" technique results in a slight bias toward the higher number. With large numbers of calculations, this can be significant. The Python 3.0 approach eliminates this issue.</p>
<p>There is more than one method of rounding in common use. IEEE 754, the international standard for floating-point math, defines <a href="https://en.wikipedia.org/w/index.php?title=IEEE_754#Rounding_rules" rel="noreferrer">five different rounding methods</a> (the one used by Python 3.0 is the default). And there are others.</p>
<p>This behavior is not as widely known as it ought to be. AppleScript was, if I remember correctly, an early adopter of this rounding method. The <code>round</code> command in AppleScript actually does offer several options, but round-toward-even is the default as it is in IEEE 754. Apparently the engineer who implemented the <code>round</code> command got so fed up with all the requests to "make it work like I learned in school" that he implemented just that: <code>round 2.5 rounding as taught in school</code> is a valid AppleScript command.  :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can control the rounding you get in Py3000 using the <a href="http://docs.python.org/library/decimal.html#decimal-faq">Decimal module</a>:</p>
<pre><code>&gt;&gt;&gt; decimal.Decimal('3.5').quantize(decimal.Decimal('1'), 
    rounding=decimal.ROUND_HALF_UP)
&gt;&gt;&gt; Decimal('4')

&gt;&gt;&gt; decimal.Decimal('2.5').quantize(decimal.Decimal('1'),    
    rounding=decimal.ROUND_HALF_EVEN)
&gt;&gt;&gt; Decimal('2')

&gt;&gt;&gt; decimal.Decimal('3.5').quantize(decimal.Decimal('1'), 
    rounding=decimal.ROUND_HALF_DOWN)
&gt;&gt;&gt; Decimal('3')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just to add here an important note from documentation:</p>
<p><a href="https://docs.python.org/dev/library/functions.html#round" rel="noreferrer">https://docs.python.org/dev/library/functions.html#round</a></p>
<blockquote>
<p>Note</p>
<p>The behavior of round() for floats can be surprising: for example,
  round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a
  bug: it’s a result of the fact that most decimal fractions can’t be
  represented exactly as a float. See Floating Point Arithmetic: Issues
  and Limitations for more information.</p>
</blockquote>
<p>So don't be surprised to get following results in Python 3.2:</p>
<pre><code>&gt;&gt;&gt; round(0.25,1), round(0.35,1), round(0.45,1), round(0.55,1)
(0.2, 0.3, 0.5, 0.6)

&gt;&gt;&gt; round(0.025,2), round(0.035,2), round(0.045,2), round(0.055,2)
(0.03, 0.04, 0.04, 0.06)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I recently had problems with this, too. Hence, I have developed a python 3 module that has 2 functions trueround() and trueround_precision() that address this and give the same rounding behaviour were are used to from primary school (not banker's rounding). Here is the module. Just save the code and copy it in or import it. Note: the trueround_precision module can change the rounding behaviour depending on needs according to the ROUND_CEILING, ROUND_DOWN, ROUND_FLOOR, ROUND_HALF_DOWN, ROUND_HALF_EVEN, ROUND_HALF_UP, ROUND_UP, and ROUND_05UP flags in the decimal module (see that modules documentation for more info). For the functions below, see the docstrings or use help(trueround) and help(trueround_precision) if copied into an interpreter for further documentation.</p>
<pre><code>#! /usr/bin/env python3
# -*- coding: utf-8 -*-

def trueround(number, places=0):
    '''
    trueround(number, places)

    example:

        &gt;&gt;&gt; trueround(2.55, 1) == 2.6
        True

    uses standard functions with no import to give "normal" behavior to 
    rounding so that trueround(2.5) == 3, trueround(3.5) == 4, 
    trueround(4.5) == 5, etc. Use with caution, however. This still has 
    the same problem with floating point math. The return object will 
    be type int if places=0 or a float if places=&gt;1.

    number is the floating point number needed rounding

    places is the number of decimal places to round to with '0' as the
        default which will actually return our interger. Otherwise, a
        floating point will be returned to the given decimal place.

    Note:   Use trueround_precision() if true precision with
            floats is needed

    GPL 2.0
    copywrite by Narnie Harshoe &lt;signupnarnie@gmail.com&gt;
    '''
    place = 10**(places)
    rounded = (int(number*place + 0.5if number&gt;=0 else -0.5))/place
    if rounded == int(rounded):
        rounded = int(rounded)
    return rounded

def trueround_precision(number, places=0, rounding=None):
    '''
    trueround_precision(number, places, rounding=ROUND_HALF_UP)

    Uses true precision for floating numbers using the 'decimal' module in
    python and assumes the module has already been imported before calling
    this function. The return object is of type Decimal.

    All rounding options are available from the decimal module including 
    ROUND_CEILING, ROUND_DOWN, ROUND_FLOOR, ROUND_HALF_DOWN, ROUND_HALF_EVEN, 
    ROUND_HALF_UP, ROUND_UP, and ROUND_05UP.

    examples:

        &gt;&gt;&gt; trueround(2.5, 0) == Decimal('3')
        True
        &gt;&gt;&gt; trueround(2.5, 0, ROUND_DOWN) == Decimal('2')
        True

    number is a floating point number or a string type containing a number on 
        on which to be acted.

    places is the number of decimal places to round to with '0' as the default.

    Note:   if type float is passed as the first argument to the function, it
            will first be converted to a str type for correct rounding.

    GPL 2.0
    copywrite by Narnie Harshoe &lt;signupnarnie@gmail.com&gt;
    '''
    from decimal import Decimal as dec
    from decimal import ROUND_HALF_UP
    from decimal import ROUND_CEILING
    from decimal import ROUND_DOWN
    from decimal import ROUND_FLOOR
    from decimal import ROUND_HALF_DOWN
    from decimal import ROUND_HALF_EVEN
    from decimal import ROUND_UP
    from decimal import ROUND_05UP

    if type(number) == type(float()):
        number = str(number)
    if rounding == None:
        rounding = ROUND_HALF_UP
    place = '1.'
    for i in range(places):
        place = ''.join([place, '0'])
    return dec(number).quantize(dec(place), rounding=rounding)
</code></pre>
<p>Hope this helps,</p>
<p>Narnie</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 2 rounding behaviour in python 3.</p>
<p>Adding 1 at the 15th decimal places.
Accuracy upto 15 digits.</p>
<pre><code>round2=lambda x,y=None: round(x+1e-15,y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.x rounds .5 values to a neighbour which is even</p>
<pre><code>assert round(0.5) == 0
assert round(1.5) == 2
assert round(2.5) == 2

import decimal

assert decimal.Decimal('0.5').to_integral_value() == 0
assert decimal.Decimal('1.5').to_integral_value() == 2
assert decimal.Decimal('2.5').to_integral_value() == 2
</code></pre>
<p>however, one can change decimal rounding "back" to always round .5 up, if needed :</p>
<pre><code>decimal.getcontext().rounding = decimal.ROUND_HALF_UP

assert decimal.Decimal('0.5').to_integral_value() == 1
assert decimal.Decimal('1.5').to_integral_value() == 2
assert decimal.Decimal('2.5').to_integral_value() == 3

i = int(decimal.Decimal('2.5').to_integral_value()) # to get an int
assert i == 3
assert type(i) is int
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some cases:</p>
<pre><code>in: Decimal(75.29 / 2).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
in: round(75.29 / 2, 2)
out: 37.65 GOOD

in: Decimal(85.55 / 2).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
in: round(85.55 / 2, 2)
out: 42.77 BAD
</code></pre>
<p>For fix:</p>
<pre><code>in: round(75.29 / 2 + 0.00001, 2)
out: 37.65 GOOD
in: round(85.55 / 2 + 0.00001, 2)
out: 42.78 GOOD
</code></pre>
<p>If you want more decimals, for example 4, you should add (+ 0.0000001).</p>
<p>Work for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sample Reproduction:</p>
<pre><code>['{} =&gt; {}'.format(x+0.5, round(x+0.5)) for x in range(10)]

['0.5 =&gt; 0', '1.5 =&gt; 2', '2.5 =&gt; 2', '3.5 =&gt; 4', '4.5 =&gt; 4', '5.5 =&gt; 6', '6.5 =&gt; 6', '7.5 =&gt; 8', '8.5 =&gt; 8', '9.5 =&gt; 10']
</code></pre>
<p>API: <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#round</a></p>
<p>States:</p>
<blockquote>
<p>Return number rounded to ndigits precision after the decimal point. If
  ndigits is omitted or is None, it returns the nearest integer to its
  input.</p>
<p>For the built-in types supporting round(), values are rounded to the
  closest multiple of 10 to the power minus ndigits; if two multiples
  are equally close, rounding is done toward the even choice (so, for
  example, both round(0.5) and round(-0.5) are 0, and round(1.5) is 2).
  Any integer value is valid for ndigits (positive, zero, or negative).
  The return value is an integer if ndigits is omitted or None.
  Otherwise the return value has the same type as number.</p>
<p>For a general Python object number, round delegates to
  number.<strong>round</strong>.</p>
<p>Note The behavior of round() for floats can be surprising: for
  example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This
  is not a bug: it’s a result of the fact that most decimal fractions
  can’t be represented exactly as a float. See Floating Point
  Arithmetic: Issues and Limitations for more information.</p>
</blockquote>
<p>Given this insight you can use some math to resolve it</p>
<pre><code>import math
def my_round(i):
  f = math.floor(i)
  return f if i - f &lt; 0.5 else f+1
</code></pre>
<p>now you can run the same test with my_round instead of round.</p>
<pre><code>['{} =&gt; {}'.format(x + 0.5, my_round(x+0.5)) for x in range(10)]
['0.5 =&gt; 1', '1.5 =&gt; 2', '2.5 =&gt; 3', '3.5 =&gt; 4', '4.5 =&gt; 5', '5.5 =&gt; 6', '6.5 =&gt; 7', '7.5 =&gt; 8', '8.5 =&gt; 9', '9.5 =&gt; 10']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <strong>round</strong> operator will round off the value to nearest integer value. </p>
<p><strong>For Example</strong>: </p>
<p>If value is greater than o.5 than it will round off to 1</p>
<pre><code>print(round(211.5554, 2)) // output is 211.56
</code></pre>
<p>If value is less than 0.5 than it will round off to 0</p>
<pre><code>print(round(211.5544, 2)) // output is 211.55
</code></pre>
<p><strong>Edit</strong>:</p>
<p>Previously mentioned <strong>//</strong> operator is not used for rounding off, it is used e.g to handle the division's float output.</p>
<pre><code> print(10//3) // output is 3 instead of 3.3333333333333335
</code></pre>
</div>
<span class="comment-copy">I don't have time to look this up, but I believe this is called "Banker's rounding". I believe it's common  in the finance industry.</span>
<span class="comment-copy">@sberry well, yes, its behavior is consistent with its own description. So if it would say "rounding" is doubling its value and did it, it would also be consistent :) .. but it seems contrary to what rounding commonly <i>means</i>. So I'm looking for a better understanding.</span>
<span class="comment-copy">@Li-aungYip Thanks for the lead re "Banker's rounding" .. I will look it up.</span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/10093783/rounding-error-in-python-with-non-odd-number/10093820#10093820" title="rounding error in python with non odd number">stackoverflow.com/questions/10093783/…</a></span>
<span class="comment-copy">Just a note: Bankers rounding isn't common just in finance. This is how I was taught to round in elementary school already in the 70's :-)</span>
<span class="comment-copy">I wasn't aware of this "default standard rounding method pretty much universally these days", would you (or anyone else) know if C/C++/Java/Perl or any other "main-stream" languages implement rounding the same way?</span>
<span class="comment-copy">Ruby does it. Microsoft's .NET languages do it. Java doesn't appear to, though. I can't track it down for every possible language, but I guess it's most common in fairly recently-designed languages. I imagine C and C++ are old enough that they don't.</span>
<span class="comment-copy">ruby returns <code>3</code> for <code>2.5.round</code></span>
<span class="comment-copy">I added a bit about AppleScript's handling of this because I love the sarcastic way the "old" behavior is implemented.</span>
<span class="comment-copy">@kindall This method has been the IEEE default rounding mode since 1985 (when IEEE 754-1985 was published). It has also been the default rounding mode in C since at least C89 (and thus also in C++), <i>however</i>, since C99 (and C++11 with sporadic support before that) a "round()" function has been available that uses ties round away from zero instead. Internal floating point rounding and the rint() family of functions still obey the rounding mode setting, which defaults to round ties to even.</span>
<span class="comment-copy">Thanks .. I was not familiar with this module. Any idea how I would get the behavior of Python v 2.x? The examples you show don't seem to do that. Just curious if that would be possible.</span>
<span class="comment-copy">@Levon: The constant <code>ROUND_HALF_UP</code> is the same as Python 2.X's old behavior.</span>
<span class="comment-copy">You can also set a context for the Decimal module that does this for you implicitly. See the <code>setcontext()</code> function.</span>
<span class="comment-copy">This is exactly what I was looking for today. Working as expected in Python 3.4.3. Also worth noting, you can control how much it rounds by changing <code>quantize(decimal.Decimal('1')</code> to <code>quantize(decimal.Decimal('0.00')</code> if you want to round to nearest 100s such as for money.</span>
<span class="comment-copy">This solution works as a replacement for <code>round(number, ndigits)</code> as long as <code>ndigits</code> is positive, but annoyingly you cannot use it to replace something like <code>round(5, -1)</code>.</span>
<span class="comment-copy">I saw that. And my first reaction: Who is using a 16-bit CPU that is incapable of representing all permutations of "2.67x" ? Saying that fractions can't be expressed in float seems like a scapegoat here: no modern CPU is that inaccurate, in ANY langauge (except Python?)</span>
<span class="comment-copy">@Adam: I think you're misunderstanding. The binary format (IEEE 754 binary64) used to store floats can't represent <code>2.675</code> exactly: the closest the computer can get is <code>2.67499999999999982236431605997495353221893310546875</code>. That's pretty close, but it's not <i>exactly</i> equal to <code>2.675</code>: it's <i>very slightly</i> closer to <code>2.67</code> than to <code>2.68</code>. So the <code>round</code> function does the right thing, and rounds it to the closer 2-digit-after-the-point value, namely <code>2.67</code>. This has nothing to do with Python, and everything to do with binary floating-point.</span>
<span class="comment-copy">It's not "the right thing" because it was given a source-code constant :), but I see your point.</span>
<span class="comment-copy">@Adam: I ran into this same quirkiness in JS before so it is not language specific.</span>
<span class="comment-copy">Could you explain the intuition behind this formula?</span>
<span class="comment-copy">From what I understand, fractions that can't be accurately represented will have up to 15 9's, then the imprecision.  For example, <code>2.675</code> is <code>2.67499999999999982236431605997495353221893310546875</code>. Adding 1e-15 will tip it over 2.675 and get it rounded correctly. if the fraction is already over the code constant, adding 1e-15 will change nothing to the rounding.</span>
<span class="comment-copy"><code>//</code> operator is not used for rounding, see <a href="https://stackoverflow.com/questions/1535596/what-is-the-reason-for-having-in-python" title="what is the reason for having in python">stackoverflow.com/questions/1535596/…</a></span>
