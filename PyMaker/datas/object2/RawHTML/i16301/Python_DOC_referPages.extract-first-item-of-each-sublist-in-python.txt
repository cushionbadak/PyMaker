<div class="post-text" itemprop="text">
<p>I am wondering what is the best way to extract the first item of each sublist in a list of lists and append it to a new list. So if I have:</p>
<pre><code>lst = [[a,b,c], [1,2,3], [x,y,z]]
</code></pre>
<p>and I want to pull out <code>a</code>, <code>1</code> and <code>x</code> and create a separate list from those.</p>
<p>I tried:</p>
<pre><code>lst2.append(x[0] for x in lst)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a>:</p>
<pre><code>&gt;&gt;&gt; lst = [['a','b','c'], [1,2,3], ['x','y','z']]
&gt;&gt;&gt; lst2 = [item[0] for item in lst]
&gt;&gt;&gt; lst2
['a', 1, 'x']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use zip:</p>
<pre><code>&gt;&gt;&gt; lst=[[1,2,3],[11,12,13],[21,22,23]]
&gt;&gt;&gt; zip(*lst)[0]
(1, 11, 21)
</code></pre>
<p>Or, Python 3 where <code>zip</code> does not produce a list:</p>
<pre><code>&gt;&gt;&gt; list(zip(*lst))[0]
(1, 11, 21)
</code></pre>
<p>Or, </p>
<pre><code>&gt;&gt;&gt; next(zip(*lst))
(1, 11, 21)
</code></pre>
<p>Or, (my favorite) use numpy:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a=np.array([[1,2,3],[11,12,13],[21,22,23]])
&gt;&gt;&gt; a
array([[ 1,  2,  3],
       [11, 12, 13],
       [21, 22, 23]])
&gt;&gt;&gt; a[:,0]
array([ 1, 11, 21])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python includes a function called itemgetter to return the item at a specific index in a list:</p>
<pre><code>from operator import itemgetter
</code></pre>
<p>Pass the itemgetter() function the index of the item you want to retrieve.  To retrieve the first item, you would use itemgetter(0).  The important thing to understand is that itemgetter(0) itself returns a function.  If you pass a list to that function, you get the specific item:</p>
<pre><code>itemgetter(0)([10, 20, 30]) # Returns 10
</code></pre>
<p>This is useful when you combine it with map(), which takes a function as its first argument, and a list (or any other iterable) as the second argument.  It returns the result of calling the function on each object in the iterable:</p>
<pre><code>my_list = [['a', 'b', 'c'], [1, 2, 3], ['x', 'y', 'z']]
list(map(itemgetter(0), my_list)) # Returns ['a', 1, 'x']
</code></pre>
<p>Note that map() returns a generator, so the result is passed to list() to get an actual list.  In summary, your task could be done like this:</p>
<pre><code>lst2.append(list(map(itemgetter(0), lst)))
</code></pre>
<p>This is an alternative method to using a list comprehension, and which method to choose highly depends on context, readability, and preference.</p>
<p>More info:
<a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="noreferrer">https://docs.python.org/3/library/operator.html#operator.itemgetter</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Had the same issue and got curious about the performance of each solution.</p>
<p>Here's is the <code>%timeit</code>:</p>
<pre><code>import numpy as np
lst = [['a','b','c'], [1,2,3], ['x','y','z']]
</code></pre>
<p>The first numpy-way, transforming the array:</p>
<pre><code>%timeit list(np.array(lst).T[0])
4.9 µs ± 163 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p>Fully native using list comprehension (as explained by @alecxe):</p>
<pre><code>%timeit [item[0] for item in lst]
379 ns ± 23.1 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
<p>Another native way using <code>zip</code> (as explained by @dawg):</p>
<pre><code>%timeit list(zip(*lst))[0]
585 ns ± 7.26 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
<p>Second numpy-way. Also explained by @dawg:</p>
<pre><code>%timeit list(np.array(lst)[:,0])
4.95 µs ± 179 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p>Surprisingly (well, at least for me) the native way using list comprehension is the fastest and about 10x faster than the numpy-way. Running the two numpy-ways without the final <code>list</code> saves about one µs which is still in the 10x difference.</p>
<p>Note that, when I surrounded each code snippet with a call to <code>len</code>, to ensure that Generators run till the end, the timing stayed the same. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your code is almost correct. The only issue is the usage of list comprehension.</p>
<p>If you use like: (x[0] for x in lst), it returns a generator object.
If you use like: [x[0] for x in lst], it return a list.</p>
<p>When you append the list comprehension output to a list, the output of list comprehension is the single element of the list.</p>
<pre><code>lst = [["a","b","c"], [1,2,3], ["x","y","z"]]
lst2 = []
lst2.append([x[0] for x in lst])
print lst2[0]
</code></pre>
<p>lst2    = [['a', 1, 'x']]</p>
<p>lst2[0] = ['a', 1, 'x']</p>
<p>Please let me know if I am incorrect.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>lst = [['a','b','c'], [1,2,3], ['x','y','z']]
outputlist = []
for values in lst:
    outputlist.append(values[0])

print(outputlist) 
</code></pre>
<p>Output:  <code>['a', 1, 'x']</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You said that you have an existing list. So I'll go with that.</p>
<pre><code>&gt;&gt;&gt; lst1 = [['a','b','c'], [1,2,3], ['x','y','z']]
&gt;&gt;&gt; lst2 = [1, 2, 3]
</code></pre>
<p>Right now you are appending the generator object to your second list.</p>
<pre><code>&gt;&gt;&gt; lst2.append(item[0] for item in lst)
&gt;&gt;&gt; lst2
[1, 2, 3, &lt;generator object &lt;genexpr&gt; at 0xb74b3554&gt;]
</code></pre>
<p>But you probably want it to be a list of first items</p>
<pre><code>&gt;&gt;&gt; lst2.append([item[0] for item in lst])
&gt;&gt;&gt; lst2
[1, 2, 3, ['a', 1, 'x']]
</code></pre>
<p>Now we appended the list of first items to the existing list. If you'd like to add the items themeselves, not a list of them, to the existing ones, you'd use list.extend. In that case we don't have to worry about adding a generator, because extend will use that generator to add each item it gets from there, to extend the current list.</p>
<pre><code>&gt;&gt;&gt; lst2.extend(item[0] for item in lst)
&gt;&gt;&gt; lst2
[1, 2, 3, 'a', 1, 'x']
</code></pre>
<p>or</p>
<pre><code>&gt;&gt;&gt; lst2 + [x[0] for x in lst]
[1, 2, 3, 'a', 1, 'x']
&gt;&gt;&gt; lst2
[1, 2, 3]
</code></pre>
<p><a href="https://docs.python.org/3.4/tutorial/datastructures.html#more-on-lists" rel="nofollow">https://docs.python.org/3.4/tutorial/datastructures.html#more-on-lists</a>
<a href="https://docs.python.org/3.4/tutorial/datastructures.html#list-comprehensions" rel="nofollow">https://docs.python.org/3.4/tutorial/datastructures.html#list-comprehensions</a></p>
</div>
<span class="comment-copy">Your code is almost correct. The only issue is the usage of list comprehension.</span>
<span class="comment-copy">List comprehension method is also the fastest, even faster than Numpy method. <a href="https://stackoverflow.com/a/48157038/8093108">jboi</a>'s answer talks about performance comparison,</span>
<span class="comment-copy">May I ask why the down vote?</span>
<span class="comment-copy">Have not downvoted but the first code snippet (the zip) produces: "'zip' object is not subscriptable". Python 3.6 on Jupyter.</span>
<span class="comment-copy">@jboi: Just wrap <code>list</code> around it first or use <code>next</code>. Thanks</span>
<span class="comment-copy">there's a substantial overhead when creating an array.</span>
<span class="comment-copy">agree with hpaulj, if you start off with numpy array, [:,0] is faster. Give it a go: lst = np.array([['a','b','c'], [1,2,3], ['x','y','z']]), then lst[:,0]. The conversion in the example time trials gives list comprehension an unfair advantage. So if you can, use a numpy array to store your data if speed is your ultimate goal. Numpy is almost always faster. It's built for speed.</span>
<span class="comment-copy">Your answer is nice and complete for what it <i>sounds</i> like the OP wants, but I think the word <code>append</code> in the question is causing confusion. It sounds like s/he simply wants the list comprehension portion of your solution.</span>
