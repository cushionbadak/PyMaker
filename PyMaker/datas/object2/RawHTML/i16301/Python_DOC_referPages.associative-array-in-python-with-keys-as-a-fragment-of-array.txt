<div class="post-text" itemprop="text">
<p>How to better implement such thing:</p>
<p>Loop over the numbers. Each number in diapason and belong to one part of associative array.</p>
<p>E.g.</p>
<pre><code> di = {}
 di[ xrange(0,10) ] = "A"
 di[ xrange(11,20) ] = "B"
 di[ xrange(21,30) ] = "C"

 direction = di[ 24 ]
 # direction should be "C"

 direction = di[ 6 ]
 # direction should be "A"
</code></pre>
<p><strong>Edit:</strong> Populate whole <code>di</code> with discreet numbers is not my way, because I'm talking about IP addresses,  really big data, such as netmasks 255.255.255.255. Such <code>di</code> will overflow my RAM. </p>
</div>
<div class="post-text" itemprop="text">
<p>I would create a custom dict that takes xranges as keys :</p>
<pre><code>class DictRange(dict):
    def __getitem__(self, val):
        for key in self.keys():
            if val in key:
                return super(DictRange,self).__getitem__(key)
</code></pre>
<p>The drawback is that you have to go through all the keys to find your element. Use like that :</p>
<pre><code>di = DictRange()
di[ xrange(0,10) ] = "A"
di[ xrange(11,20) ] = "B"
di[ xrange(21,30) ] = "C"

print di[24]
# C
print di[6]
# A
</code></pre>
<p>See <a href="http://repl.it/WAJ" rel="nofollow">http://repl.it/WAJ</a></p>
<h2>Update</h2>
<p>Using bisect and assuming that you can spare some time during initialization to speed up access, you can do something like:</p>
<pre><code>import bisect
class DictRange(dict):

    def __setitem__(self, key, val):
        super(DictRange,self).__setitem__(key, val)
        self.ks = [key[0] for key in self.keys()]

    def __getitem__(self, val):
        return super(DictRange,self).__getitem__(self.keys()[bisect.bisect(self.ks, val) - 1])
</code></pre>
<p>the get will be <code>O(logn)</code> where n is the number of keys, but the set will become <code>O(n)</code>. As for the next solution, it relies on the ranges being contiguous.</p>
<h2>Other solution</h2>
<p>An other solution, which could be faster, depending on your range sizes, would be to use as key the first item of the range, and a bisect to find the proper key:</p>
<pre><code>import bisect
ranges = [0, 11, 21, 31]
di = {}
di[0] = 'A'
di[11] = 'B'
di[21] = 'C'
di[31] = 'unknown' # special value to indicate the end of the range

print di[ranges[bisect.bisect(ranges, 24) - 1]]
# C
print di[ranges[bisect.bisect(ranges, 6) - 1]]
# A
print di[ranges[bisect.bisect(ranges, 31) - 1]]
# Unknown
</code></pre>
<p>This will be much faster. <code>bisect</code> is <code>O(logn)</code> where <code>n</code> is the number of ranges, the rest is <code>O(1)</code></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>di = dict.fromkeys(xrange(0, 10), 'A')
di.update(dict.fromkeys(xrange(10, 20), 'B'))
di.update(dict.fromkeys(xrange(20, 30), 'C'))
print(di)
</code></pre>
<p>yields</p>
<pre><code>{0: 'A', 1: 'A', 2: 'A', 3: 'A', 4: 'A', 5: 'A', 6: 'A', 7: 'A', 8: 'A', 9: 'A', 10: 'B', 11: 'B', 12: 'B', 13: 'B', 14: 'B', 15: 'B', 16: 'B', 17: 'B', 18: 'B', 19: 'B', 20: 'C', 21: 'C', 22: 'C', 23: 'C', 24: 'C', 25: 'C', 26: 'C', 27: 'C', 28: 'C', 29: 'C'}
</code></pre>
<p>Note that <code>xrange(N, M)</code> generates ints starting at <code>N</code> and ending at <code>M-1</code> (inclusive). So if you want to include 10, 20 in the keys, then the xranges should be <code>xrange(10, 20)</code> and <code>xrange(20, 30)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use tuples instead of lists to solve the <code>TypeError</code> (which your code doesn't raise FWIW) but the lookup still wouldn't work. The simplest thing that could possibly work would be to populate you dict with every discrete key for a given value, ie:</p>
<pre><code>map = (
   (0, 10, "A"),
   (11, 20, "B"),
   # etc
   )

d = {}
for start, stop, val in map:
   for k in xrange(start, stop):
       d[k] = val
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to populate a dictionary just use a function, </p>
<pre><code>from __future__ import division
import string
def return_ltr(i):
    n = i//10 
    return string.ascii_uppercase[n]
</code></pre>
<p>Otherwise, if you want to populate a dictionary do the following.  Your current code is generating <code>xrange objects</code> and using them as keys.  However, that is not the same as using the numbers for keys.  Try the following, </p>
<pre><code>import string
d = {}
i = 0
for ltr in string.ascii_uppercase:
    for j in xrange(10):
        d[i] = ltr
        i += 1
</code></pre>
<p>If you only want a subset of the letters you can slice <code>string.ascii_uppercase</code>.  For example using <code>string.ascii_uppercase[0:3]</code> will just give you <code>A</code>, <code>B</code>, and <code>C</code>. </p>
</div>
<span class="comment-copy">Your code does not generate that error.</span>
<span class="comment-copy">@BrenBarn, Thank you.</span>
<span class="comment-copy">What are you trying to <i>do</i> with the array? For IP addresses, it's unlikely you want any explicit mapping; rather, you'll use bitwise operations involving the integer representations of the addresses and masks.</span>
<span class="comment-copy">if you want zero storage just use a function (in my answer) that maps numbers to letters.  for more complicated things you probably want a specialized module</span>
<span class="comment-copy">what's the data space of keys to values? i.e. you want <code>di[range] = value</code>, how many ranges are there, and how many values? You most likely want some kind of binary tree-based approach (actually list + <code>bisect</code>) or a graph model of some kind.</span>
<span class="comment-copy">Thank you. Great solution. I searched exactly this.</span>
<span class="comment-copy">Could you tell me, why it is so slow? How to improve the speed?</span>
<span class="comment-copy">it is very slow because each search needs to browse through all keys until the correct one is found. I suppose the <code>in</code> implementation of xrange is probably O(1), but overall, it is still O(n) where n is the number of keys in the dict, compared to O(1) for a proper hash search as used in a regular dict.</span>
<span class="comment-copy">the way a dict (or any hash set) works is that the hash of the key is pseudo unique and easily mappable. in your case it is not possible, as the key is not identified with the search value.</span>
<span class="comment-copy">I will suggest a solution base on bisect in a few minutes</span>
<span class="comment-copy">this is great, but I'm talking about really big data, such as netmask 255.255.255.255. In your way this di will overflow my RAM.</span>
<span class="comment-copy">Then a <code>dict</code> is the wrong data structure. Perhaps then you should be using the <a href="https://docs.python.org/3/howto/ipaddress.html" rel="nofollow noreferrer"><code>ipaddress</code> module</a>.</span>
<span class="comment-copy">What about <code>map</code>, or something else? I'm interesting in this way: di[5] == "A". or map[11] == "B"</span>
<span class="comment-copy">See <code>Edit</code>, I can't use such dict, because it is too big.</span>
<span class="comment-copy">Typical XY problem. Why didn't you post your real question instead ?</span>
