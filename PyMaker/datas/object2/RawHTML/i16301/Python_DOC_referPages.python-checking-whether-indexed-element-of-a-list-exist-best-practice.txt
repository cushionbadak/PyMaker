<div class="post-text" itemprop="text">
<p>I have something like this:       </p>
<pre><code>for i in range(0,100,5):

    text = ("Price\t",
            foo[i+0].bar, "\t",
            foo[i+1].bar, "\t",
            foo[i+2].bar, "\t",
            foo[i+3].bar, "\t",
            foo[i+4].bar, "\t",
            "Value", "\n")

    file.writelines(text)
</code></pre>
<p>My problem is: let's assume that <code>i=0</code>. For that case, it is certain that I will have foo[0]. But for indices 1,2,3,4 foo can be empty. For example, if foo is empty for indices greater than 2, I want my text to be like:</p>
<pre><code>text = ("Price\t",
        foo[0].bar, "\t",
        foo[1].bar, "\t",
        foo[2].bar, "\n")
</code></pre>
<p>I thought of using exceptions, but I guess, I will not be able to construct <code>text</code> if I do not have all the indexed elements. (Iteration will stop?) So, what is the best practice to do that? I could not think of a short way to do it. Basically what I need is:</p>
<pre><code>text= ("Price\t",
        ifexist(foo[0].bar, "\t"),
        ifexist(foo[1].bar, "\t"),
        ifexist(foo[2].bar, "\t"),
        ifexist(foo[3].bar, "\t"),
        ifexist(foo[4].bar, "\t"),
        "Value", "\n")
</code></pre>
<p>ps: Please do not forget I assumed <code>i=0</code> for the sake of simplicity. But in fact, generally I am going to have more than hundred values.</p>
<p>edit: By saying "can be empty", I meant to say that the index might be beyond the size of the list.</p>
<p>edit2: Abot foo:</p>
<pre><code># start class
class Test:
    def __init__(self, bar, bar2, bar3):
        self.bar= a
        self.bar2= b
        self.bar3= c

# end class    


for i in particular_list:
    # read and parse the input file with indeces obtained from particular_list
    # do calculations for temp_bar,temp_bar2,temp_bar3
    foo.append(Test(temp_bar, temp_bar2, temp_bar3))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My suggestion would be, do not rely on indices but rather structure your code around your data. If you are not indexing, then you would never have issues in IndexError</p>
<p>Consider A List <code>L</code> of size <code>N</code> to be divided evenly of size <code>n</code>. This problem has various  <a href="https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks-in-python">accepted solutions and approaches</a></p>
<p>The one I generally preach (though you are free to accept any of the alternate approaches) is</p>
<pre><code>izip_longest(*[iter(L)]*n)
</code></pre>
<p>So Given a List </p>
<p>L = [a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub> ... a<sub>N</sub>]</p>
<p>This will generate  ⌊N/n⌋ equally sized chunks. The last shorter lists of size <code>Mod(N, n)</code> would be appended by a filler, default in this case is None</p>
<p>L = [[a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub> ... a<sub>n</sub>],[a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub> ... a<sub>n</sub>],[a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub> ... a<sub>n</sub>],.(N Items)..[a<sub>1</sub>, a<sub>2</sub>, .. a<sub>N%n</sub>],None,None.. (n terms)]</p>
<p>Now just iterate through this list of lists ignorining any <code>Nones</code> in the sublists</p>
<p><strong>Demo</strong></p>
<pre><code>from itertools import izip_longest
class Foo(object):
    def __init__(self, n):
        self.bar = n
foo = [Foo(i) for i in range(12)]
for rows in izip_longest(*[iter(foo)]*5):
    print "Price\t{}".format('\t'.join(str(row.bar)
                       for row in rows
                       if row is not None))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>Price   0   1   2   3   4
Price   5   6   7   8   9
Price   10  11
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You would take a different approach; you'd slice the original list, and use the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow"><code>csv</code> module</a> to handle tab-delimiting and newlines:</p>
<pre><code>import csv

with open('outputfile', 'w', newline='') as file:
    writer = csv.writer(file, delimiter='\t')
    for i in range(0, 100, 5):
        row = foo[i:i + 5]
        writer.writerow(['Price'] + row + ['Value']) 
</code></pre>
<p>Slicing on a list always returns a new list object, but if you use slice indices outside the valid range the result is a shorter or empty list:</p>
<pre><code>&gt;&gt;&gt; foo = ['spam', 'ham', 'eggs']
&gt;&gt;&gt; foo[0:5]
['spam', 'ham', 'eggs']
&gt;&gt;&gt; foo[5:10]
[]
</code></pre>
<p>The <code>csv.writer()</code> object, meanwhile, takes care of writing the list as a tab-delimited string, plus a newline, to your file.</p>
<p>Instead of using the <code>csv</code> module, you would still use slicing, but make use of other techniques that take arbitrary lists of elements. <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow"><code>str.join()</code></a> for example:</p>
<pre><code>'\t'.join(['Price'] + foo[i:i + 5] + ['Value']) + '\n'
</code></pre>
<p>would produce one string of tab-delimited values, with a newline appended. This does require that all values in the list passed to <code>str.join()</code> are already strings.</p>
</div>
<div class="post-text" itemprop="text">
<p>To expand on my comment, you could implement something like:</p>
<pre><code>def if_exist(seq, index, attr, default):
    """Return seq[index].attr or default."""
    try:
        return getattr(seq[index], attr)
    except IndexError:
        return default
</code></pre>
<p>Which you could use like:</p>
<pre><code>if_exist(foo, 0, "bar", "\t")
</code></pre>
<p>A demo:</p>
<pre><code>&gt;&gt;&gt; if_exist([1, 2, 3], 4, "bar", "\n")
'\n'
</code></pre>
<p>However, I suspect this to be an <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a> - if you provide more background information, it is likely that we can help you come up with a different approach that removes this issue entirely.</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends on what <code>foo</code> is. If it is a <code>list</code> or <code>tuple</code>, there will be no empty indices. If it is a <code>dict</code>, referencing an unknown key will result in a <code>KeyError</code> exception.</p>
<p>Assuming <code>foo</code> is a list of tuples, you can easily print it;</p>
<pre><code>In [3]: t = range(30)

In [4]: p = [tuple(t[i:i+3]) for i in range(0, len(t), 4)]

In [5]: p
Out[5]: [(0, 1, 2), (4, 5, 6), (8, 9, 10), (12, 13, 14), (16, 17, 18), (20, 21, 22), (24, 25, 26), (28, 29)]
</code></pre>
<p>You can iterate over that list of tuples and print them;</p>
<pre><code>In [6]: for k in p:
    print '\t'.join(['Price'] + [str(i) for i in k] + ['Value'])
   ...:     
Price   0   1   2   Value
Price   4   5   6   Value
Price   8   9   10  Value
Price   12  13  14  Value
Price   16  17  18  Value
Price   20  21  22  Value
Price   24  25  26  Value
Price   28  29  Value
</code></pre>
</div>
<span class="comment-copy">The minimal fix is to <code>try</code> and then catch <code>except IndexError</code>. But you are probably better off changing your data structure - why not e.g. a list of tuples instead of a long, flat list?</span>
<span class="comment-copy">What do you mean by <code>empty</code>? Do you mean the index is beyond the size of the list? Or that the value of <code>foo[4]</code> is <code>None</code>? Or that the value of <code>foo[4]</code> is <code>''</code>?</span>
<span class="comment-copy">@jonrsharpe using a class structure to store the elements seemed like a neat thing to do. but tbh, it's been an intuitive desicion. I tried to use try&amp;except IndexError, but in that case, if one of the elements is missing, I lose the <code>text</code>. Could you please show me how to use it?</span>
<span class="comment-copy">@Robᵩ I was trying to say if the index is beyond the size of the list. Thank you, I will edit the question.</span>
<span class="comment-copy">@FrankBrewer Your <code>Test</code> class might as well be a tuple since it contains no methods. That would make <code>foo</code> a list of tuples that could be easily processed by iterating over the list and <code>join</code>-ing the tuples.</span>
<span class="comment-copy">added info about <code>foo</code></span>
