<div class="post-text" itemprop="text">
<p>Python Tutorial <a href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="nofollow">4.7.1. Default Argument Values</a> states the following:</p>
<blockquote>
<p><strong>Important warning:</strong> The default value is evaluated only once. This makes a difference
  when the default is a mutable object such as a list, dictionary, or instances of most
  classes. For example, the following function accumulates the arguments passed to it on
  subsequent calls:</p>
<pre><code>def f(a, L=[]):
    L.append(a)
    return L

print f(1)
print f(2)
print f(3)
</code></pre>
<p>This will print</p>
<pre><code>[1]
[1, 2]
[1, 2, 3]
</code></pre>
</blockquote>
<p>I don't quite understand the meaning of "evaluated only once" in terms of memory management. Apparently, the default value of the function is evaluated once when the function is first called and stored in a separate memory address even after the function has ended. (according to my understanding, after the function ended, all local variables should be freed?)</p>
<p>Am I correct?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, functions are objects too, and the defaults are stored with the function object. Defaults are <strong>not</strong> locals; it is just that when the function is called, the arguments are bound to a default when not given an explicit value.</p>
<p>When Python encounters a <code>def &lt;functionname&gt;(&lt;arguments&gt;):</code> statement, it creates a function object for you <em>there and then</em>; this is 'definition time'; the function is not called but merely created. It is <em>then</em> that defaults are evaluated and stored, in an attribute on the function object.</p>
<p>Then when you call the function, the defaults have <em>already</em> been created and are used when you didn't provide a more concrete value for the argument. Because the defaults are stored with the function object, you get to see changes to mutable objects between function calls.</p>
<p>The locals are still cleared up of course, but as they are <em>references</em> (all identifiers in Python are), the objects they were bound to are only cleared up if nothing else is referencing them anymore either.</p>
<p>You can take a look a the defaults of any function object:</p>
<pre><code>&gt;&gt;&gt; def foo(bar='spam', eggs=[]):
...     eggs.append(bar)
...     return eggs
... 
&gt;&gt;&gt; foo.__defaults__
('spam', [])
&gt;&gt;&gt; foo()
['spam']
&gt;&gt;&gt; foo.__defaults__
('spam', ['spam'])
&gt;&gt;&gt; foo() is foo.__defaults__[1]
True
</code></pre>
<p>The <code>foo()</code> function has a <code>__defaults__</code> attribute, a tuple of default values to use when no values for the arguments have been passed in. You can see the mutable list change as the function is called, and because the function returns the <code>eggs</code> list, you can also see that it is the <em>exact same object</em> as the second value in that tuple.</p>
</div>
<div class="post-text" itemprop="text">
<p>The function that you have defined <code>f</code> is an object in its own regard.  When you define defaults, these defaults are bound to the function that you have created.</p>
<p>You can see this in action:</p>
<pre><code>&gt;&gt;&gt; def f(a, L=[]):
...    L.append(a)
...    return L

&gt;&gt;&gt; print id(f)
4419902952

&gt;&gt;&gt; print f.__defaults__
([],)
&gt;&gt;&gt; f(1)
[1]

&gt;&gt;&gt; print id(f)
4419902952

&gt;&gt;&gt; print f.__defaults__
([1],)
</code></pre>
<p>edit, further, you can see that the list container does not change either:</p>
<pre><code>&gt;&gt;&gt; print id(f.__defaults__[0])
4419887544
&gt;&gt;&gt; f(2)
[1, 2]
&gt;&gt;&gt; print id(f.__defaults__[0])
4419887544
</code></pre>
<p>On each subsequent call, the default list ("<code>L</code>") of your <code>f</code> function will have your <code>a</code> value appended.</p>
</div>
<div class="post-text" itemprop="text">
<p>A function is just an object in python, that is created using the <code>def</code> syntax. Default values are stored within the function object when the function is defined, and they are not re-evaluated later.</p>
<p>This is sometimes used to create <em>function variables</em> that persist to subsequent invocations. You can use the <code>__defaults__</code> methods to check what the default values are for your function.</p>
<p>A common way to initialize new objects instead of reusing the same is:</p>
<pre><code>def f(a, L=None):
    if L is None:
        L = []

    L.append(a)
    return L
</code></pre>
<p>You can check <a href="http://blog.amir.rachum.com/blog/2013/07/06/python-common-newbie-mistakes-part-1/" rel="nofollow">this page</a> for more details.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sorry this answer was meant for a different question, but I'll leave it here as a reference if anyone who wants to look at it.  Define once means that at the first point when the code is executed, the default variable gets assigned to an object which is retained within the function object itself.    </p>
<p>Notice only 1 object address gets printed, the default list object is used.  </p>
<pre><code>  def f(a, L=[]):
    print("id default: ", id(L))
    L.append(a)
    print("id used: ", id(L)
    return L
</code></pre>
<p>Notice 2 different object addresses are printed, when you perform L=[] within the function, you are binding L to a different list object, therefore the default list object does not get change.  </p>
<pre><code>def f(a, L=[]):
    print("id default: ", id(L))
    if L == []:
        L = []
    L.append(a)
    print("id used: ", id(L))      
    return L 
</code></pre>
<p>The function above is basically the same as the one below except it uses the None object instead of a empty list object.  </p>
<pre><code>def f(a, L=None):
    print("id default", id(L))
    if L is None:
        L = []
   L.append(a) 
   print("id used: ", id(L))      
   return L 
</code></pre>
</div>
<span class="comment-copy">Not "when first called", but rather "when defined".</span>
<span class="comment-copy">Closely related, but not a duplicate: <a href="http://stackoverflow.com/q/1132941">"Least Astonishment" in Python: The Mutable Default Argument</a></span>
<span class="comment-copy">This is not about what the work-around is. This is about <i>when function defaults are evaluated</i>.</span>
<span class="comment-copy">You're right, I misunderstood the question, but still, adding a way to obtain the desired behavior is normally useful.</span>
<span class="comment-copy">Sure, but that's what <a href="http://stackoverflow.com/q/1132941">"Least Astonishment" in Python: The Mutable Default Argument</a> is for; e.g. the post this was originally closed as a dupe of.</span>
<span class="comment-copy">And if you now see the question, it has the relevant part of the tutorial linked (with the solution there too).</span>
<span class="comment-copy">This answer need to explain</span>
