<div class="post-text" itemprop="text">
<p>Let's say I have</p>
<pre><code>a = [['a1', 'b1'], ['a1', 'b2'], ['a2', 'b1'], ['a2', 'b4']]
</code></pre>
<p>As a result I want</p>
<pre><code>a = [[0, 2], [0, 3], [1, 2], [1, 4]]
</code></pre>
<p>Give an id to the first item of every sub-list (i.e <code>a[:][0]</code>) and then continue with the second item of every sub-list (i.e <code>a[:][1]</code>)</p>
<p>I've tried:</p>
<pre><code>&gt;&gt;&gt; aa=[[] for cells in range(len(a))]
&gt;&gt;&gt; for i in range(len(a)):
    for j in range(len(a[i])):
        aa[i].append(id(a[i][j]))
</code></pre>
<p>result:</p>
<pre><code>&gt;&gt;&gt; aa
[[34378168, 51409056], [34378168, 51507304], [34301464, 51409056], [34301464, 51467576]]
</code></pre>
<p>Which is "close" but I want the id to start from <code>0</code> and go on.</p>
<p>I know what <code>id()</code> returns and I don't need that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict()</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow"><code>itertools.count()</code></a>; transpose the sublists with the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip()</code> function</a> first, transpose back again after assigning numbers:</p>
<pre><code>from itertools import count
from collections import defaultdict

counts = defaultdict(lambda c=count(): next(c))

aa = zip(*((counts[cell] for cell in col) for col in zip(*a)))
</code></pre>
<p>The <code>defaultdict()</code> stores a new <code>count()</code> value each time a key has not yet been seen, producing a unique counter per string.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; a=[['a1', 'b1'], ['a1', 'b2'], ['a2', 'b1'], ['a2', 'b4']]
&gt;&gt;&gt; counts = defaultdict(lambda c=count(): next(c))
&gt;&gt;&gt; zip(*((counts[cell] for cell in col) for col in zip(*a)))
[(0, 2), (0, 3), (1, 2), (1, 4)]
</code></pre>
</div>
<span class="comment-copy">Not sure why this is being downvoted. The OP has input, expected output, a reasonably clear description of what is needed, and an attempt at solving it.</span>
<span class="comment-copy">@MartijnPieters I didn't downvote it, but I still don't get what the OP wants.</span>
<span class="comment-copy">@miindlek: they want to produce a unique number per string value. <code>a1</code> is assigned 0, <code>a2</code> is 1. That's all the first column values assigned. Then the count continues for the unique 2nd column values: <code>b1</code> gets 2, <code>b2</code> gets 3, <code>b4</code> gets 4. If there were more unique values, more numbers are assigned.</span>
<span class="comment-copy">@miindlek: so <code>[['foo', 'bar'], ['spam', 'ham'], ['foo', 'baz'], ['spam', 'bar']]</code> would produce <code>[[0, 2], [1, 3], [0, 4], [1, 2]]</code>.</span>
<span class="comment-copy">New here @ MartijnPieters ,you've been very helpful.</span>
