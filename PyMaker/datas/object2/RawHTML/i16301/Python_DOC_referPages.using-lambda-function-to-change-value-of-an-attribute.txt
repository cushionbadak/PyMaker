<div class="post-text" itemprop="text">
<p>Can I use lambda function to loop over a list of class objects and change value of an attribute (for all objects or for the one that meet a certain condition)?</p>
<pre><code>class Student(object):
    def __init__(self,name,age):
        self.name = name
        self.age = age

student1 = Student('StudOne',18)
student2 = Student('StudTwo',20)
student3 = Student('StudThree',29)
students = [student1,student2,student3]

new_list_of_students = map(lambda student:student.age+=3,students)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately, that’s not possible since the <a href="http://docs.python.org/3/reference/expressions.html#lambda" rel="nofollow">body of a lambda</a> only allows for <a href="http://docs.python.org/3/reference/expressions.html#grammar-token-expression_nocond" rel="nofollow">simple <em>expressions</em></a> while a <code>student.age += 3</code> is a <a href="http://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements" rel="nofollow"><em>statement</em></a>. So you can’t use a lambda there. You could however still use the map solution:</p>
<pre><code>def incrementAge (student):
    student.age += 3
    return student

students2 = map(incrementAge, students)
</code></pre>
<p>Note that <code>students2</code> will contain the same students as <code>students</code> though, so you don’t really need to capture the output (or return something from <code>incrementAge</code>). Also note that in Python 3, <code>map</code> returns a generator which you need to iterate on first. You can call <code>list()</code> on it to do that: <code>list(map(…))</code>.</p>
<p>Finally, a better solution for this would be to use a simple loop. That way, you don’t have overhead of needing a function or create a duplicate students list, and you would also make the intention very clear:</p>
<pre><code>for student in students:
    student.age += 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Lambda functions can only contain expressions, not statements.  Assignment in Python is a statement.  Lambdas cannot do assignments.  Additionally, assignment statements do not evaluate to their values, so your map would not produce a list of students.</p>
<p>You want this:</p>
<pre><code>for student in students:
    student.age += 3
</code></pre>
<p>This does not give you a new list, it modifies the old list, but your old list would be modified anyway, you aren't doing anything to produce new Students.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>setattr</code>, which will apply the change to the objects. A big plus is that you can continue using the same list.</p>
<pre><code>map(lambda s: setattr(s, 'age', s.age + 3), students)
</code></pre>
<p>From the docs:</p>
<blockquote>
<p><a href="https://docs.python.org/2/library/functions.html#setattr" rel="nofollow noreferrer">The function assigns the value to the attribute, provided the object allows it. For example, <code>setattr(x, 'foobar', 123)</code> is equivalent to <code>x.foobar = 123</code>.</a></p>
</blockquote>
<p>The equivalency of which is:</p>
<pre><code>for s in students:
    s.age += 3
</code></pre>
<hr/>
<h3>If you <em>really</em> want a new list:</h3>
<p>The above approach doesn't return a new list; instead returning <code>None</code> (the return value of <code>setattr</code>). Adding an <code>or</code> comparison with the object you want in the array (in this case <code>s</code>) will amend that, though.</p>
<pre><code>new_students = map(lambda s: setattr(s, 'age', s.age + 3) or s, students)
</code></pre>
<p>The comparison is equivalent to <code>None or s</code> which will always yield the latter. Also note that the new list is identical to the old one.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using a simple for-loop to retrieve the <code>students</code> to update the <code>age</code> for each is good enough like others said, but if you still want to use a <code>lambda</code> to update the values, you may need to leverage the <code>exec()</code> function:</p>
<pre><code>_ = list(map(lambda student: exec("student.age+=3"), students))
for _ in students: print(_.age)
</code></pre>
<p>Output:</p>
<pre><code>21 23 32
</code></pre>
<p>In this case, what actually does the updating is the <code>exec()</code>, and the <code>map()</code> just yields <code>None</code>. So the returned result makes no sense and I put a <code>_</code> to clarify this. A more concise form would be this:</p>
<pre><code>list(map(lambda _: exec("_.age+=3"), students))
</code></pre>
<p>Besides, if only considering what you want to do, you don't need to use a <code>map()</code> at all (probably more confusing though):</p>
<pre><code>[(lambda _: exec("_.age += 3"))(_) for _ in students]
</code></pre>
<p>Furthermore, a <code>lambda</code> can be discarded either:</p>
<pre><code>[exec("_.age += 3") for _ in students]
</code></pre>
<p>As you can see, no "trick" codes above seem more concise than what other answers post:</p>
<pre><code>for s in students:
    s.age += 3
</code></pre>
<p>So maybe the so-called "one-liner" is useful just when it comes to having fun... :)  </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Q:  "Can I use lambda function to loop over a list of class objects and change value of an attribute"</strong></p>
<p><strong>A: Yes....but you shouldn't.  It's poor coding style, inefficient, and only appropriate for things like code golf</strong></p>
<p>You should write it like the other two answers have suggested.</p>
<p>...but if you really wanted to...</p>
<pre><code>new_list_of_students = [(lambda student:(setattr(student, 'age', student.age+3), 
student))(s)[1] for s in students]

print [student.age for student in new_list_of_students]
</code></pre>
<p>Prints: </p>
<pre><code>[21, 23, 32]
</code></pre>
<p>...or even:</p>
<pre><code>from operator import itemgetter
new_list_of_students = map(itemgetter(1),map(lambda student:(setattr(student, 
'age', student.age+3), student),students))

print [student.age for student in new_list_of_students]
</code></pre>
<p>[Same output]</p>
</div>
<span class="comment-copy">@Ned 'def change_age(student):     student.age +=3     return student new_students_age_list = map(change_age,students)'</span>
<span class="comment-copy">As you have been told, lambda doesn't allow to do assignments. So you have to add an appropriate method to the class and call it from lambda. If you cant change the class, you always can add a method to the instances and get the same effect</span>
<span class="comment-copy">@pythondev if you do that, then <code>increased_students_age_list</code> has exactly the same contents as <code>students</code>. You have two lists that are identical, there's no point in that.</span>
<span class="comment-copy">Other than the space in the function def line, I really like this answer! :)</span>
<span class="comment-copy">@NedBatchelder Heh, I figured you disliked that space—but I like to place one there for definitions ;P</span>
<span class="comment-copy">Pedantically speaking, <code>Assignment</code> in Python is an operation.  The typical way of performing this operation is with a statement. ...and lambdas can do assignments, just not <code>assignment statements</code>.  Poke avoided this issue entirely (although he created one of his own with that unseemly extra space)</span>
<span class="comment-copy">Haha..knew the downvotes would be forthcoming!</span>
