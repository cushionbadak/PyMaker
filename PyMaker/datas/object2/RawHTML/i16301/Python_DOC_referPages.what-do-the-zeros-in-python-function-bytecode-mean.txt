<div class="post-text" itemprop="text">
<p>I'm trying to teach myself about how python bytecode works so I can do some stuff with manipulating functions' code (just for fun, not for real usage) so I started with some simple examples, such as:</p>
<pre><code>def f(x):
    return x + 3/x
</code></pre>
<p>The bytecode is*:</p>
<pre><code>(124, 0, 0, 100, 1, 0, 124, 0, 0, 20, 23, 83)
</code></pre>
<p>So it makes sense to me that <code>124</code> is the <code>LOAD_FAST</code> bytecode, and the name of the object being loaded is <code>f.__code__.co_varnames[0]</code> where <code>0</code> is the number after <code>124</code>. And <code>100</code> indicates a <code>LOAD_CONST</code> to load <code>f.__code__.co_consts[1]</code> where <code>1</code> is the number after <code>100</code>. But then there are a bunch of auxiliary zeros, like the second and third and fifth zeros that seem to serve no purpose, at least to me. What do they indicate?</p>
<p>Textual bytecode:</p>
<pre><code>&gt;&gt;&gt; dis.dis(f)
  2           0 LOAD_FAST                0 (x)
              3 LOAD_CONST               1 (3)
              6 LOAD_FAST                0 (x)
              9 BINARY_DIVIDE       
             10 BINARY_ADD          
             11 RETURN_VALUE   
</code></pre>
<hr/>
<p>*Note: In Python 3 (where bytecodes may be different from above), the bytecode can be found via:</p>
<pre><code>&gt;&gt;&gt; list(f.__code__.co_code)
[124, 0, 100, 1, 124, 0, 27, 0, 23, 0, 83, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A large number of bytecodes take arguments (any bytecode with a codepoint at or over <a href="https://docs.python.org/3/library/dis.html#opcode-HAVE_ARGUMENT"><code>dis.HAVE_ARGUMENT</code></a>. Those that do have a 2-byte argument, in little-endian order.</p>
<p>You can see the definition for what bytecodes Python currently uses and what they mean in the <a href="https://docs.python.org/3/library/dis.html#opcode-HAVE_ARGUMENT"><code>dis</code> module documenation</a>.</p>
<p>With 2 bytes you can give any bytecode an argument value between 0 and 65535, for bytecodes than need more, you can <em>prefix</em> the bytecode with the <a href="https://docs.python.org/3/library/dis.html#opcode-EXTENDED_ARG"><code>EXTENDED_ARG</code> bytecode</a>, adding 2 more bytes for a value between 0 and 4294967295. In theory you could use <code>EXTENDED_ARG</code> multiple times, but the CPython interpreter uses <code>int</code> for the <code>oparg</code> variable and is thus for practical purposes limited to 4-byte values.</p>
<p>As of Python 3.4 the <code>dis</code> module provides you with <a href="https://docs.python.org/3/library/dis.html#dis.Instruction"><code>Instruction</code> instances</a> that make it easier to introspect each bytecode and their arguments. Using this we can walk through the byte codes you found for your function <code>f</code>:</p>
<pre><code>&gt;&gt;&gt; def f(x):
...     return x + 3/x
... 
&gt;&gt;&gt; f.__code__.co_varnames
('x',)
&gt;&gt;&gt; f.__code__.co_consts
(None, 3)
&gt;&gt;&gt; import dis
&gt;&gt;&gt; instructions = dis.get_instructions(f)
&gt;&gt;&gt; instructions
&lt;generator object _get_instructions_bytes at 0x10be77048&gt;
&gt;&gt;&gt; instruction = next(instructions)
&gt;&gt;&gt; instruction
Instruction(opname='LOAD_FAST', opcode=124, arg=0, argval='x', argrepr='x', offset=0, starts_line=2, is_jump_target=False)
</code></pre>
<p>So the first opcode, 124 or <code>LOAD_FAST</code> puts the value for first local name on the stack; this is the <code>0 0</code> argument, little-endian interpreted as integer <code>0</code>, an index into the code locals array. <code>dis</code> has filled out the <code>argval</code> attribute, showing us that the first local name is <code>x</code>. In the above session I show how you can introspect the code object to see the list of names.</p>
<pre><code>&gt;&gt;&gt; instruction = next(instructions)
&gt;&gt;&gt; instruction
Instruction(opname='LOAD_CONST', opcode=100, arg=1, argval=3, argrepr='3', offset=3, starts_line=None, is_jump_target=False)
</code></pre>
<p>The next instruction pushes a constant onto the stack; the argument is now <code>1 0</code>, or little-endian for integer <code>1</code>; the second constant associated with the code object. The <code>f.__code__.co_consts</code> tuple shows that it is <code>3</code>, but the <code>Instruction</code> object gives it too, as the <code>argval</code> attribute.</p>
<pre><code>&gt;&gt;&gt; next(instructions)
Instruction(opname='LOAD_FAST', opcode=124, arg=0, argval='x', argrepr='x', offset=6, starts_line=None, is_jump_target=False)
</code></pre>
<p>Next we have another <code>LOAD_FAST</code>, pushing another reference to local name <code>x</code> onto the stack.</p>
<pre><code>&gt;&gt;&gt; next(instructions)
Instruction(opname='BINARY_TRUE_DIVIDE', opcode=27, arg=None, argval=None, argrepr='', offset=9, starts_line=None, is_jump_target=False)
</code></pre>
<p>This is a bytecode <em>without argument</em>, the opcode 27 is below <code>dis.HAVE_ARGUMENT</code>. No argument is needed, because this opcode takes the top two values on the stack, divides them, pushing the floating point result back on the stack. So the last <code>x</code> and the <code>3</code> constant are taken, divided and the result is push back on.</p>
<pre><code>&gt;&gt;&gt; next(instructions)
Instruction(opname='BINARY_ADD', opcode=23, arg=None, argval=None, argrepr='', offset=10, starts_line=None, is_jump_target=False)
</code></pre>
<p>Another argument-less bytecode; this one adds up the top two stack values, replacing those with the outcome. The outcome of the <code>BINARY_TRUE_DIVIDE</code> is taken, and the value of <code>x</code> that was pushed on first, and the result is put back on the stack.</p>
<pre><code>&gt;&gt;&gt; next(instructions)
Instruction(opname='RETURN_VALUE', opcode=83, arg=None, argval=None, argrepr='', offset=11, starts_line=None, is_jump_target=False)
</code></pre>
<p>Last instruction, and another that doesn't take arguments. <code>RETURN_VALUE</code> ends the current frame, returning the top value from the stack as the result to the caller.</p>
</div>
<div class="post-text" itemprop="text">
<p>Before CPython 3.6, CPython bytecode arguments take 2 bytes. The extra zeros are the high bytes of the arguments.</p>
</div>
<span class="comment-copy">I ran <code>dis.dis()</code> on your function and added the textual version of the bytecode. Feel free to rollback if you'd rather leave it as it was.</span>
<span class="comment-copy">That's a nice addition, thank you!</span>
<span class="comment-copy">So that's one guy saying big-endian, and another saying little-endian.</span>
<span class="comment-copy">Big-endian? The bytecode in the OP looks like the 1 is represented in little-endian. Do you have a reference or source link I could look at?</span>
<span class="comment-copy">@user2357112: ++++ OUT OF CAFFEINE ERROR +++ REDO FROM START ++++ I was wrong, corrected.</span>
<span class="comment-copy">Oh wow, that's incredibly useful! Thanks for teaching me about it!</span>
<span class="comment-copy">I see, do you think you could elaborate on the difference between "low" bytes and high bytes, or link me to something that would explain it?</span>
<span class="comment-copy">Would that make Python big-endian or little-endian? I can never get those two straight.</span>
<span class="comment-copy">@TheSoundDefense: Little-endian.</span>
<span class="comment-copy">@user3002473: If the argument is greater than 255, you'll only get the last 8 bits of it. That'll be a problem if the code uses more than 255 variables or 255 constants, such as if there's a really long list literal. If the arguments get <i>really</i> big, you'll need to handle <a href="https://docs.python.org/2/library/dis.html#opcode-EXTENDED_ARG" rel="nofollow noreferrer">extended arguments</a>, where a separate opcode provides two additional bytes of argument.</span>
<span class="comment-copy">@user3002473: <code>(l &lt;&lt; 24)</code>, not <code>32</code>, but other than that, yup.</span>
