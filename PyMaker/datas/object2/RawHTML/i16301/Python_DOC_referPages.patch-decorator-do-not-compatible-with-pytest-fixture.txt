<div class="post-text" itemprop="text">
<p>I have encountered something mysterious, when using patch decorator from mock package integrated with pytest fixture.</p>
<p>I have two modules</p>
<pre><code>    -----test folder
          -------func.py
          -------test_test.py
</code></pre>
<p>in func.py:</p>
<pre><code>    def a():
        return 1

    def b():
        return a()     
</code></pre>
<p>in test_test.py</p>
<pre><code>    import pytest
    from func import a,b
    from mock import patch,Mock

    @pytest.fixture(scope="module")
    def brands():
        return 1


    mock_b=Mock()

    @patch('test_test.b',mock_b)
    def test_compute_scores(brands):                 
         a()
</code></pre>
<p>It seems that patch decorate is not compatible with pytest fixture. Does anyone have a insight on that? Tnanks</p>
</div>
<div class="post-text" itemprop="text">
<p>I had the same problem and solution for me was to use mock library in 1.0.1 version (before I was using unittest.mock in 2.6.0 version). Now it works like a charm :)</p>
</div>
<div class="post-text" itemprop="text">
<p>When using pytest <code>fixture</code> with <code>mock.patch</code>, test parameter order is crucial.</p>
<p>If you place a fixture parameter before a mocked one:</p>
<pre><code>from unittest import mock

@mock.patch('my.module.my.class')
def test_my_code(my_fixture, mocked_class):
</code></pre>
<p>then the mock object will be in <code>my_fixture</code> and <code>mocked_class</code> will be search as a fixture:</p>
<pre><code>fixture 'mocked_class' not found
</code></pre>
<p>But, if you reverse the order, placing the fixture parameter at the end:</p>
<pre><code>from unittest import mock

@mock.patch('my.module.my.class')
def test_my_code(mocked_class, my_fixture):
</code></pre>
<p>then all will be fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>As of <strong><a href="https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock" rel="nofollow noreferrer">Python3.3</a></strong>, the <code>mock</code> module has been pulled into the <code>unittest</code> library. There is also a backport (for previous versions of Python) available as the standalone library <code>mock</code>.</p>
<p>Combining these 2 libraries within the same test-suite yields the above-mentioned error:</p>
<pre><code>E       fixture 'fixture_name' not found
</code></pre>
<p>Within your test-suite's virtual environment, run <code>pip uninstall mock</code>, and make sure you aren't using the backported library alongside the core unittest library. When you re-run your tests after uninstalling, you would see <code>ImportError</code>s if this were the case.</p>
<p>Replace all instances of this import with <code>from unittest.mock import &lt;stuff&gt;</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This doesn't address your question directly, but there is the <a href="https://pypi.python.org/pypi/pytest-mock" rel="nofollow">pytest-mock</a> plugin which allows you to write this instead:</p>
<pre><code>def test_compute_scores(brands, mock):                 
     mock_b = mock.patch('test_test.b')
     a()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Hopefully this answer on an old question will help someone.</p>
<p>First off, the question doesn't include the error, so we don't <em>really</em> know what's up. But I'll try to provide something that helped me.</p>
<p>If you want a test decorated with a patched object, then in order for it to work with pytest you could just do this:</p>
<pre><code>@mock.patch('mocked.module')
def test_me(*args):
    mocked_module = args[0]
</code></pre>
<p>Or for multiple patches:</p>
<pre><code>@mock.patch('mocked.module1')
@mock.patch('mocked.module')
def test_me(*args):
    mocked_module1, mocked_module2 = args
</code></pre>
<p>pytest is looking for the names of the fixtures to look up in the test function/method. Providing the <code>*args</code> argument gives us a good workaround the lookup phase. So, to include a fixture with patches, you could do this:</p>
<pre><code># from question
@pytest.fixture(scope="module")
def brands():
    return 1

@mock.patch('mocked.module1')
def test_me(brands, *args):
    mocked_module1 = args[0]
</code></pre>
<p>This worked for me running python 3.6 and pytest 3.0.6.</p>
</div>
<span class="comment-copy">I had a similar issue, i was importing <code>from unittest.mock import patch</code> as well as  <code>import mock</code> , i had to remove the import mock statement, then is stopped throwing <code>fixture 'mocked_instance' not found</code> errors</span>
<span class="comment-copy">thank you for your answer. I have this problem when using mock library 1.0.1</span>
<span class="comment-copy">save my life. thx.</span>
<span class="comment-copy">should be the accepted answer</span>
<span class="comment-copy">Unfortunately, this question is about mixing pytest fixtures and patches in the method signature, not just patches.</span>
<span class="comment-copy">I've added the bit about the fixtures that completes the answer to the question. I'd say its a tad hacky but it works. Thanks @zalpha314 for pointing that out.</span>
