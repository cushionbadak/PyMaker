<div class="post-text" itemprop="text">
<p>Should I test <code>if</code> something is valid or just <code>try</code> to do it and catch the exception?</p>
<ul>
<li>Is there any solid documentation saying that one way is preferred?</li>
<li>Is one way more <em>pythonic</em>?</li>
</ul>
<p>For example, should I:</p>
<pre><code>if len(my_list) &gt;= 4:
    x = my_list[3]
else:
    x = 'NO_ABC'
</code></pre>
<p>Or:</p>
<pre><code>try:
    x = my_list[3]
except IndexError:
    x = 'NO_ABC'
</code></pre>
<hr/>
<p>Some thoughts...<br/>
<a href="http://www.python.org/dev/peps/pep-0020/" rel="noreferrer">PEP 20</a> says:</p>
<blockquote>
<p>Errors should never pass silently.<br>
  Unless explicitly silenced.</br></p>
</blockquote>
<p>Should using a <code>try</code> instead of an <code>if</code> be interpreted as an error passing silently?  And if so, are you explicitly silencing it by using it in this way, therefore making it OK?</p>
<hr/>
<p>I'm <strong><em>not</em></strong> referring to situations where you can only do things 1 way; for example:</p>
<pre><code>try:
    import foo
except ImportError:
    import baz
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should prefer <code>try/except</code> over <code>if/else</code> if that results in</p>
<ul>
<li>speed-ups (for example by preventing extra lookups)</li>
<li>cleaner code (less lines/easier to read)</li>
</ul>
<p>Often, these go hand-in-hand.</p>
<hr/>
<p><b>speed-ups</b></p>
<p>In the case of trying to find an element in a long list by:</p>
<pre><code>try:
    x = my_list[index]
except IndexError:
    x = 'NO_ABC'
</code></pre>
<p>the try, except is the best option when the <code>index</code> is probably in the list and the IndexError is usually not raised. This way you avoid the need for an extra lookup by <code>if index &lt; len(mylist)</code>.</p>
<p><b>Python encourages the use of exceptions, <em>which you handle</em></b> is a phrase from <a href="http://www.diveintopython3.net/your-first-python-program.html#exceptions" rel="noreferrer">Dive Into Python</a>. Your example not only handles the exception (gracefully), rather than letting it <em>silently pass</em>, also the exception occurs only in the <em>exceptional</em> case of index not being found (hence the word <em>exception</em>!).</p>
<hr/>
<p><b>cleaner code</b></p>
<p>The official Python Documentation mentions <a href="https://docs.python.org/3/glossary.html?highlight=eafp#term-eafp" rel="noreferrer">EAFP</a>: <em>Easier to ask for forgiveness than permission</em> and <a href="http://bayes.colorado.edu/PythonIdioms.html" rel="noreferrer">Rob Knight</a> notes that <b>catching errors rather than avoiding them</b>, can result in cleaner, easier to read code. His example says it like this:</p>
<p>Worse <em>(LBYL 'look before you leap')</em>:</p>
<pre><code>#check whether int conversion will raise an error
if not isinstance(s, str) or not s.isdigit:
    return None
elif len(s) &gt; 10:    #too many digits for int conversion
    return None
else:
    return int(str)
</code></pre>
<p>Better <em>(EAFP: Easier to ask for forgiveness than permission)</em>:</p>
<pre><code>try:
    return int(str)
except (TypeError, ValueError, OverflowError): #int conversion failed
    return None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this particular case, you should use something else entirely:</p>
<pre><code>x = myDict.get("ABC", "NO_ABC")
</code></pre>
<p>In general, though: If you expect the test to fail frequently, use <code>if</code>. If the test is expensive relative to just trying the operation and catching the exception if it fails, use <code>try</code>. If neither one of these conditions applies, go with whatever reads easier.</p>
</div>
<div class="post-text" itemprop="text">
<p>If it's trivial to check whether something will fail before you do it, you should probably favor that. After all, constructing exceptions (including their associated tracebacks) takes time.</p>
<p>Exceptions should be used for:</p>
<ol>
<li>things that are unexpected, or...</li>
<li>things where you need to jump more than one level of logic (e.g. where a <code>break</code> doesn't get you far enough), or...</li>
<li>things where you don't know exactly what is going to be handling the exception ahead of time, or...</li>
<li>things where checking ahead of time for failure is expensive (relative to just attempting the operation)</li>
</ol>
<hr/>
<p>Note that oftentimes, the real answer is "neither" - for instance, in your first example, what you really <em>should</em> do is just use <code>.get()</code> to provide a default:</p>
<pre><code>x = myDict.get('ABC', 'NO_ABC')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>try</code> and <code>except</code> directly rather than inside an <code>if</code> guard should <em>always</em> be done if there is any possibility of a race condition.  For example, if you want to ensure that a directory exists, do not do this:</p>
<pre><code>import os, sys
if not os.path.isdir('foo'):
  try:
    os.mkdir('foo')
  except OSError, e
    print e
    sys.exit(1)
</code></pre>
<p>If another thread or process creates the directory between <code>isdir</code> and <code>mkdir</code>, you'll exit.  Instead, do this:</p>
<pre><code>import os, sys, errno
try:
  os.mkdir('foo')
except OSError, e
  if e.errno != errno.EEXIST:
    print e
    sys.exit(1)
</code></pre>
<p>That will only exit if the 'foo' directory can't be created.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Should using a try instead of an if be interpreted as an error passing silently? And if so, are you explicitly silencing it by using it in this way, therefore making it OK?</p>
</blockquote>
<p>Using <code>try</code> is acknowledging that an error may pass, which is the opposite of having it pass silently. Using <code>except</code> is causing it not to pass at all.</p>
<p>Using <code>try: except:</code> is preferred in cases where <code>if: else:</code> logic is more complicated. Simple is better than complex; complex is better than complicated; and it's easier to ask for forgiveness than permission.</p>
<p>What "errors should never pass silently" is warning about, is the case where code could raise an exception that you know about, and where your design admits the possibility, but you haven't designed in a way to deal with the exception. Explicitly silencing an error, in my view, would be doing something like <code>pass</code> in an <code>except</code> block, which should only be done with an understanding that "doing nothing" really is the correct error handling in the particular situation. (This is one of the few times where I feel like a comment in well-written code is probably really needed.)</p>
<p>However, in your particular example, neither is appropriate:</p>
<pre><code>x = myDict.get('ABC', 'NO_ABC')
</code></pre>
<p>The reason everyone is pointing this out - even though you acknowledge your desire to understand in general, and inability to come up with a better example - is that equivalent side-steps actually exist in quite a lot of cases, and looking for them is the first step in solving the problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>As the other posts mention, it depends on the situation.  There are a few dangers with using try/except in place of checking the validity of your data in advance, especially when using it on bigger projects.</p>
<ul>
<li>The code in the try block may have a chance to wreak all sorts of havoc before the exception is caught - if you proactively check beforehand with an if statement you can avoid this.</li>
<li>If the code called in your try block raises a common exception type, like TypeError or ValueError, you may not actually catch the same exception you were expecting to catch - it may be something else that raise the same exception class before or after even getting to the line where your exception may be raised.  </li>
</ul>
<p>e.g., suppose you had:</p>
<pre><code>try:
    x = my_list[index_list[3]]
except IndexError:
    x = 'NO_ABC'
</code></pre>
<p>The IndexError says nothing about whether it occurred when trying to get an element of index_list or my_list.</p>
</div>
<div class="post-text" itemprop="text">
<p>For a general meaning, you may consider reading <a href="https://docs.python.org/2/howto/doanddont.html#exceptions" rel="nofollow noreferrer">Idioms and Anti-Idioms in Python: Exceptions</a>.</p>
<p>In your particular case, as others stated, you should use <a href="http://docs.python.org/library/stdtypes.html#dict" rel="nofollow noreferrer"><code>dict.get()</code></a>:</p>
<blockquote>
<p>get(key[, default])</p>
<p>Return the value for key if key is in the
  dictionary, else default. If default is not given, it defaults to
  None, so that this method never raises a KeyError.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Whenever you use <code>try/except</code> for control flow, ask yourself:</p>
<ol>
<li>Is it easy to see when the <code>try</code> block succeeds and when it fails?</li>
<li>Are you aware of <em>all</em> side effects inside the <code>try</code> block?</li>
<li>Are you aware of <em>all</em> cases in which the <code>try</code> block throws the exception?</li>
<li>If the implementation of the <code>try</code> block changes, will your control flow still behave as expected?</li>
</ol>
<p>If the answer to one or more of these questions is 'no', there might be a lot of forgiveness to ask for; most likely from your future self.</p>
<hr/>
<p>An example.
I recently saw code in a larger project that looked like this:</p>
<pre><code>try:
    y = foo(x)
except ProgrammingError:
    y = bar(x)
</code></pre>
<p>Talking to the programmer it turned that the intended control flow was:</p>
<blockquote>
<p>If x is an integer, do y = foo(x)</p>
<p>and if x is a list of integers, do y = bar(x).</p>
</blockquote>
<p>This worked because <code>foo</code> made a database query and the query would be successful if <code>x</code> was an integer and throw a <code>ProgrammingError</code> if <code>x</code> was a list.</p>
<p>Using <code>try/except</code> is a bad choice here:</p>
<ol>
<li>The name of the exception, <code>ProgrammingError</code>, does not give away the actual problem (that <code>x</code> is not an integer). That makes it difficult to figure out what is going on.</li>
<li>The <code>ProgrammingError</code> is raised during a database call, which unnecessarily wastes time. Things would get truly horrible if it turned out that <code>foo</code> writes something to the database before it throws an exception, or alters the state of some other system.</li>
<li>It is unclear whether every <code>ProgrammingError</code> is caused by <code>x</code> being a list. Suppose for instance that there is a typo in <code>foo</code>'s database query. This might also raise a <code>ProgrammingError</code>. The consequence is that <code>bar(x)</code> is now also called if <code>x</code> is an integer. This might raise cryptic exceptions or produce unforeseeable results.</li>
<li>The <code>try/except</code> block adds a requirement to all future implementations of <code>foo</code>. Whenever we change <code>foo</code>, we must now think about how it handles lists and make sure that it throws a <code>ProgrammingError</code> and not, say, an <code>AttributeError</code> or no error at all.</li>
</ol>
</div>
<span class="comment-copy">Really in your first example, you should just use <code>myDict.get('ABC', 'NO_ABC')</code>.</span>
<span class="comment-copy">I don't Python, but I'd be surprised if using exception handling to control program flow in non-exceptional circumstances is particularly Pythonic.</span>
<span class="comment-copy">@agf: I don't really know what you mean, but I'd be interested to know.</span>
<span class="comment-copy">@spender It was a joke because there was <i>just</i> an answer posted taking an extreme opposite stance to the one you suggest: <a href="http://stackoverflow.com/questions/7604380/check-for-operator/7604410#7604410" title="check for operator">stackoverflow.com/questions/7604380/check-for-operator/â€¦</a></span>
<span class="comment-copy">That makes a compelling enough argument for me, thanks Remi!</span>
<span class="comment-copy"><code>if index in mylist</code> tests wether index is an element of mylist, not a possible index. You would want <code>if index &lt; len(mylist)</code> instead.</span>
<span class="comment-copy">+1 for the explanation under the code sample, which is spot on.</span>
<span class="comment-copy">I think it's pretty clear this isn't what he was asking, and he's now edited the post to make it even more clear.</span>
<span class="comment-copy">except that <code>if 'ABC' in myDict: x = myDict['ABC']; else: x = 'NO_ABC'</code> is actually often faster than using <code>get</code>, unfortunately. Not saying this is the most important criteria, but it's something to be aware of.</span>
<span class="comment-copy">@agf: Better to write clear and concise code. If something needs to be optimized later, it's easy to come back and rewrite it, but <a href="http://c2.com/cgi/wiki?PrematureOptimization" rel="nofollow noreferrer">c2.com/cgi/wiki?PrematureOptimization</a></span>
<span class="comment-copy">I <i>know</i> that; my point was that <code>if / else</code> and <code>try / except</code> can have their place <i>even when there are case-specific alternatives</i> because they have different performance characteristics.</span>
<span class="comment-copy">@agf,  do you know if the get() method will be improved in future versions to be (at least) as fast as looking up explicitly? By the way, when looking up twice (as in if 'ABC' in d: d['ABC']), is try: d['ABC'] except KeyError:... not fastest?</span>
<span class="comment-copy">@Remi The slow part of <code>.get()</code> is the attribute lookup and function call overhead at the Python level; using keywords on built-ins basically goes right to C. I don't think it'll be getting too much faster any time soon. As far as <code>if</code> vs. <code>try</code>, read <a href="http://stackoverflow.com/questions/7153893/dict-get-method-returns-a-pointer">dict.get() method returns a pointer</a> which has some performance info. The ratio of hits to misses matter (<code>try</code> can be faster if the key almost always exists) as does the size of the dictionary.</span>
<span class="comment-copy">I don't think the link covers this situation at all. Its examples are about handling things <i>that represent real errors</i>, not about whether to use exception handling for expected situations.</span>
<span class="comment-copy">First link is outdated.</span>
