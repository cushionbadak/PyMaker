<div class="post-text" itemprop="text">
<p>To avoid MemoryError's in Python, I am trying to read in chunks. Been searching for half a day on how to read chunks form a RestResponse but to no avail.</p>
<p>The source is a file-like object using the Dropbox SDK for python.</p>
<p>Here's my attempt:</p>
<pre><code>import dropbox
from filechunkio import FileChunkIO
import math

file_and_metadata = dropbox_client.metadata(path)

hq_file = dropbox_client.get_file(file_and_metadata['path'])

source_size = file_and_metadata['bytes']
chunk_size = 4194304
chunk_count = int(math.ceil(source_size / chunk_size))
for i in range(chunk_count + 1):
    offset = chunk_size * i
    bytes = min(chunk_size, source_size - offset)
    with FileChunkIO(hq_file, 'r', offset=offset,
                 bytes=bytes) as fp:
        with open('tmp/testtest123.mp4', 'wb') as f:
            f.write(fp)
            f.flush()
</code></pre>
<p>This results in "TypeError: coercing to Unicode: need string or buffer, RESTResponse found"</p>
<p>Any clues or solutions would be greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Without knowing anything about <code>FileChunkIO</code>, or even knowing where your code is raising an exception, it's hard to be sure, but my guess is that it needs a real file-like object. Or maybe it does something silly, like checking the type so it can decide whether you're looking to chunk up a string or chunk up a file.</p>
<p>Anyway, according to the docs, <a href="https://www.dropbox.com/developers/core/docs/python#RESTResponse" rel="nofollow"><code>RESTResponse</code></a> isn't a full file-like object, but it implements <code>read</code> and <code>close</code>. And you can easily chunk something that implements <code>read</code> without any fancy wrappers. File-like objects' <code>read</code> methods are guaranteed to return <code>b''</code> when you get to EOF, and can return fewer bytes than you asked for, so you don't need to guess how many times you need to <code>read</code> and do a short read at the end. Just do this:</p>
<pre><code>chunk_size = 4194304
with open('tmp/testtest123.mp4', 'wb') as f:
    while True:
        buf = hq_file.read(chunk_size)
        if not buf:
            break
        f.write(buf)
</code></pre>
<p>(Notice that I moved the <code>open</code> outside of the loop. Otherwise, for each chunk, you're going to open and empty out the file, then write the next chunk, so at the end you'll end up with just the last one.)</p>
<p>If you want a chunking wrapper, there's a perfectly good builtin function, <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow"><code>iter</code></a>, that can do it for you:</p>
<pre><code>chunk_size = 4194304
chunks = iter(lambda: hq_file.read(chunk_size), '')
with open('tmp/testtest123.mp4', 'wb') as f:
    f.writelines(chunks)
</code></pre>
<p><sub>Note that the exact same code works in Python 3.x if you change that <code>''</code> to <code>b''</code>, but that breaks Python 2.5.</sub></p>
<p><sub>This might be a bit of an abuse of <code>writelines</code>, because we're writing an iterable of strings that aren't actually lines. If you don't like it, an explicit loop is just as simple and not much less concise.</sub></p>
<p><sub>I usually write that as <code>partial(hq_file.read, chunk_size)</code> rather than <code>lambda: hq_file.read(chunk_size_</code>, but it's really a matter of preference; read the docs on <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>partial</code></a> and you should be able to understand why they ultimately have the same effect, and decide which one you prefer.</sub></p>
</div>
<span class="comment-copy">Please show the complete traceback. Is it the <code>FileChunkIO</code> that's making that complaint, or something else?</span>
