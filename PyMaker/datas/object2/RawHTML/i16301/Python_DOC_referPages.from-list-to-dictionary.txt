<div class="post-text" itemprop="text">
<pre><code>def build_placements(shoes):
    """ (list of str) -&gt; dict of {str: list of int}
    Return a dictionary where each key is a company and each value is a
    list of placements by people wearing shoes made by that company.

    build_placements(['Saucony', 'Asics', 'Asics', 'NB', 'Saucony',
    'Nike', 'Asics', 'Adidas', 'Saucony', 'Asics'])
    {'Saucony': [1, 5, 9], 'Asics': [2, 3, 7, 10], 'NB': [4], 'Nike': [6], 
    'Adidas': [8]}

    The following is the answer:
    """
    company_to_placements = {}

    for i in range(len(shoes)):
        company = shoes[i]
        if company not in company_to_placements:
            company_to_placements[company] = []
        company_to_placements[company].append(i + 1)

    return company_to_placements
</code></pre>
<p>One thing I do not understand is why <code>company_to_placements[company] = []</code>? If a <code>company</code> is not in  <code>company_to_placements</code>, shouldn't that <code>company_to_placements[company] = [1]</code> since it is the first time for that company to appear?  </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>If a company is not in  company_to_placements, shouldn't that company_to_placements[company] = [1] since it is the first time for that company to appear?</p>
</blockquote>
<p>No, because you are explicitly adding the company in the next line. However, you cannot use the <code>list.append()</code> method yet if there is not yet a list in the dictionary for a given key:</p>
<pre><code>&gt;&gt;&gt; company_to_placements = {}
&gt;&gt;&gt; company = 'Saucony'
&gt;&gt;&gt; company_to_placements[company].append(1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'Saucony'
&gt;&gt;&gt; company_to_placements[company] = []
&gt;&gt;&gt; company_to_placements[company].append(1)
&gt;&gt;&gt; company_to_placements
{'Saucony': [1]}
</code></pre>
<p>Because there is no <code>'Saucony'</code> key at first, trying to use that key to retrieve a list and call <code>append()</code> on that list object fails; a <code>KeyError</code> is thrown.</p>
<p>The <code>if company not in company_to_placements:</code> test simply creates the initial empty list, the next line then adds the integer to the list.</p>
<p>The code could be simplified to:</p>
<pre><code>company_to_placements = {}

for i, company in enumerate(shoes, 1):
    company_to_placements.setdefault(company, []).append(i)
</code></pre>
<p>using the <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow"><code>dict.setdefault()</code> method</a> to add an empty list to the dictionary if the <code>company</code> key is not yet present.</p>
<p>Another option would be to use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict()</code> object</a> to materialise a new list every time you try and access a key that isn't yet present:</p>
<pre><code>from collections import defaultdict

company_to_placements = defaultdict(list)

for i, company in enumerate(shoes, 1):
    company_to_placements[company].append(i)
</code></pre>
</div>
<span class="comment-copy">You seem to be missing the closing """ for your docstring.</span>
<span class="comment-copy"><i>"shouldn't that company_to_placements[company] = [1]?"</i>. If you want results like <code>{'Saucony': [1, 1, 5, 9], 'Asics': [1, 2, 3, 7, 10], 'NB': [1, 4], 'Nike': [1, 6], 'Adidas': [1, 8]}</code>, then yes.</span>
<span class="comment-copy">You should look at collections.defaultdict.</span>
