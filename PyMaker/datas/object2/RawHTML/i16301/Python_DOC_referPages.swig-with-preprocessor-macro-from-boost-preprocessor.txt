<div class="post-text" itemprop="text">
<p>I'm utilizing the enum with ToString implementation that was suggested here: 
<a href="https://stackoverflow.com/questions/5093460/how-to-convert-an-enum-type-variable-to-a-string">How to convert an enum type variable to a string?</a>
It utilizes  and works fine as far as I can  tell.</p>
<p>My issues arise when I try to wrap and export the macro to a Python library wrapped with SWIG. Similar question: <a href="https://stackoverflow.com/questions/10760287/swig-errors-because-of-preprocessor-directive">SWIG errors because of preprocessor directive</a>
There, the solution was to add headers / declarations to the SWIG interface. I haven't had success with this so far. Chances are that I just don't know what I have to add.</p>
<p>Tried:</p>
<pre><code>%include &lt;boost/preprocessor/config/config.hpp&gt;
%include &lt;boost/preprocessor/stringize.hpp&gt;
%include &lt;boost/preprocessor/seq/for_each.hpp&gt;
%include &lt;boost/preprocessor/seq/enum.hpp&gt;
</code></pre>
<p>MWE:</p>
<p>minimal.h</p>
<pre><code>#ifndef MINIMAL_H
#define MINIMAL_H
#include &lt;boost/preprocessor.hpp&gt;

//Found this here: https://stackoverflow.com/questions/5093460/how-to-convert-an-enum-type-variable-to-a-string

#define X_DEFINE_ENUM_WITH_STRING_CONVERSIONS_TOSTRING_CASE(r, data, elem)    \
    case elem : return BOOST_PP_STRINGIZE(elem);

#define DEFINE_ENUM_WITH_STRING_CONVERSIONS(name, enumerators)                \
    enum name {                                                               \
        BOOST_PP_SEQ_ENUM(enumerators)                                        \
    };                                                                        \
                                                                              \
    inline const char* ToString(name v)                                       \
    {                                                                         \
        switch (v)                                                            \
        {                                                                     \
            BOOST_PP_SEQ_FOR_EACH(                                            \
                X_DEFINE_ENUM_WITH_STRING_CONVERSIONS_TOSTRING_CASE,          \
                name,                                                         \
                enumerators                                                   \
            )                                                                 \
            default: return "[Unknown " BOOST_PP_STRINGIZE(name) "]";         \
        }                                                                     \
    }

DEFINE_ENUM_WITH_STRING_CONVERSIONS(my_enum, (A)(B))
#endif
</code></pre>
<p>minimal.cpp</p>
<pre><code>#include &lt;iostream&gt; 
#include "minimal.h"

int main(){
    using namespace std;
    cout &lt;&lt; A &lt;&lt; ": " &lt;&lt; ToString(A) &lt;&lt; endl;
    cout &lt;&lt; B &lt;&lt; ": " &lt;&lt; ToString(B) &lt;&lt; endl;

}
</code></pre>
<p>minimal.i</p>
<pre><code>%module minimal
%{
#include "minimal.h"
%}
%include "minimal.h"
</code></pre>
<p>The error is not very indicative. Line 29 is the actual definition of my_enum.</p>
<pre><code>matthias@rp3deb:~/dvl/swig_boost_minimal$ swig minimal.i
minimal.h:29: Error: Syntax error in input(1).
</code></pre>
<p>Any advice on how I could wrap this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you wanted to make SWIG read boost/preprocessor.hpp you'd do that with:</p>
<pre><code>%module minimal
%{
#include "minimal.h"
%}
%include &lt;boost/preprocessor.hpp&gt;
%include "minimal.h"
</code></pre>
<p>Since by default SWIG doesn't follow <code>#include</code> directives. (You could also use <code>-includeall</code> to make it follow them instead). In this case though I think making the SWIG preprocessor make any kind of sense of the crazy magic that the Boost preprocessor library uses is a lost cause. </p>
<p>Instead though we can try to get something with equally nice, but "Pythonic" syntax instead. In esscence what we're going to do is write a totally different version of <code>DEFINE_ENUM_WITH_STRING_CONVERSIONS</code> for SWIG wrappers only. It will be compatible with the definitions seen by C++ though.</p>
<p>To do this I'm going to start by splitting your file minimal.h into two files. One with the macro definition and one that uses it. (We could have done this different ways, for example by wrapping the macro definitions with <code>#ifndef DEFINE_ENUM_WITH_STRING_CONVERSIONS</code> or <code>#ifndef SWIG</code>, which would be equally valid solutions).</p>
<p>Thus we now have enum.hh:</p>
<pre><code>#ifndef ENUM_H
#define ENUM_H
#include &lt;boost/preprocessor.hpp&gt;

//Found this here: https://stackoverflow.com/questions/5093460/how-to-convert-an-enum-type-variable-to-a-string
#define X_DEFINE_ENUM_WITH_STRING_CONVERSIONS_TOSTRING_CASE(r, data, elem)    \
    case elem : return BOOST_PP_STRINGIZE(elem);

#define DEFINE_ENUM_WITH_STRING_CONVERSIONS(name, enumerators)                \
    enum name {                                                               \
        BOOST_PP_SEQ_ENUM(enumerators)                                        \
    };                                                                        \
                                                                              \
    inline const char* ToString(name v)                                       \
    {                                                                         \
        switch (v)                                                            \
        {                                                                     \
            BOOST_PP_SEQ_FOR_EACH(                                            \
                X_DEFINE_ENUM_WITH_STRING_CONVERSIONS_TOSTRING_CASE,          \
                name,                                                         \
                enumerators                                                   \
            )                                                                 \
            default: return "[Unknown " BOOST_PP_STRINGIZE(name) "]";         \
        }                                                                     \
    }
#endif
</code></pre>
<p>And minimal.h:</p>
<pre><code>#ifndef MINIMAL_H
#define MINIMAL_H
#include "enum.h"

DEFINE_ENUM_WITH_STRING_CONVERSIONS(my_enum, (A)(B))
#endif
</code></pre>
<p>So your minimal.cpp continues to work as before, but now we can write a SWIG module that at least compiles, even if it doesn't do anything useful yet:</p>
<pre><code>%module minimal
%{
#include "minimal.h"
%}
%define DEFINE_ENUM_WITH_STRING_CONVERSIONS(name,enumerators)
%enddef
%include "minimal.h"
</code></pre>
<p>This currently has a stub, SWIG specific macro that we're going to fill out. It's a little ugly how I've done this, simply because I'm trying to avoid changing the way the existing macro is defined/used at all.</p>
<p>What I produced as a starting point is another file, enum.i:</p>
<pre class="lang-cpp prettyprint-override"><code>%include &lt;std_vector.i&gt;
%include &lt;std_string.i&gt;

%{
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
%}

%define DEFINE_ENUM_WITH_STRING_CONVERSIONS(name,enumerators)
%{
  typedef std::tuple&lt;name,std::string&gt; name ## _entry;
  struct name ## _helper {
    std::vector&lt;name ## _entry&gt; list;
    name ## _helper(const name value) {
      list.push_back(std::make_tuple(value,ToString(value)));
    }
    name ## _helper operator()(const name value) {
      list.push_back(std::make_tuple(value,ToString(value)));
      return *this;
    }
  };

  static const std::vector&lt;name ## _entry&gt; name ## _list = name ## _helper enumerators . list;
%}

struct name ## _entry {
  %extend {
    const unsigned long value {
      return std::get&lt;0&gt;(*$self);
    }
    const std::string&amp; label {
      return std::get&lt;1&gt;(*$self);
    }
  }
};

%template(name ## vec) std::vector&lt;name ## _entry&gt;;

const std::vector&lt;name ## _entry&gt; name ## _list;

%enddef
</code></pre>
<p>Such that minimal.i just needs to become:</p>
<pre><code>%module minimal

%{
#include "minimal.h"
%}

%include "enum.i"
%include "minimal.h"
</code></pre>
<p>All that macro does is take the value of <code>enumerators</code>, which is going to be something like <code>(A)(B)</code> and generate some code that's completely standard (if quirky) C++ that expands this into a <code>std::vector&lt;std::tuple&lt;my_enum,std::string&gt;&gt;</code>. That's done by mapping the first enum member onto a constructor call, and the rest onto an overloaded <code>operator()</code>. We use the <code>ToString()</code> supplied by enum.h to find the string representation. Finally our macro has enough information to wrap the vector of tuples in a way which makes sense from within Python. </p>
<p>With this in place we can do something like:</p>
<pre class="lang-py prettyprint-override"><code>import minimal
print ", ".join(("%s(%d)" % (x.label,x.value) for x in minimal.my_enum_list))
</code></pre>
<p>Which, when compiled and run gives:</p>
<pre class="lang-none prettyprint-override"><code>A(0), B(1)
</code></pre>
<p>I.e. enough to start writing Python code that's aware of both the label and the value of a C++ enum.</p>
<p>But let's not stop there! Why did I deliberately call the resulting vector <code>my_enum_list</code> instead of just <code>my_enum</code>? Because there's more we can do now.</p>
<p>Python 2.7 doesn't have any default "enum-ish", but that doesn't prevent us from wrapping this as something both Pythonic and natural to people who know about enums. I made my Python 2.7 enum support by reading <a href="https://stackoverflow.com/a/1695250/168175">this other answer</a>. To start with I added some generic enum support routines to the file using <code>%pythoncode</code>, (labelled #1 in final source) but outside the SWIG macro since there's no need to vary it. I also added a <code>%pythoncode</code> inside the SWIG macro (labelled #2) that invokes this once per actual enum. In order to make this work I had to convert the <code>const std::vector</code> from the previous version into a function so that it was accessible in the right part of the generated Python. Finally I had to show SWIG a forward declaration of the real enum, in order to persuade it to actually accept that as an argument to functions. The final result is:</p>
<pre class="lang-cpp prettyprint-override"><code>%include &lt;std_vector.i&gt;
%include &lt;std_string.i&gt;

%{
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
%}

// #1
%pythoncode %{
class EnumValue(int):
  def __new__(cls,v,l):
    result = super(EnumValue,cls).__new__(cls,v)
    result._value = l
    return result
  def __str__(self):
    return self._value

def make_enum(name,enums):
    return type(name, (), enums)
%}

%define DEFINE_ENUM_WITH_STRING_CONVERSIONS(name,enumerators)
%{
  typedef std::tuple&lt;name,std::string&gt; name ## _entry;
  struct name ## _helper {
    std::vector&lt;name ## _entry&gt; list;
    name ## _helper(const name value) {
      list.push_back(std::make_tuple(value,ToString(value)));
    }
    name ## _helper operator()(const name value) {
      list.push_back(std::make_tuple(value,ToString(value)));
      return *this;
    }
  };

  static const std::vector&lt;name ## _entry&gt; name ## _list() {
    return name ## _helper enumerators . list;
  }
%}

struct name ## _entry {
  %extend {
    const unsigned long value {
      return std::get&lt;0&gt;(*$self);
    }
    const std::string&amp; label {
      return std::get&lt;1&gt;(*$self);
    }
  }
};

%template(name ## vec) std::vector&lt;name ## _entry&gt;;

const std::vector&lt;name ## _entry&gt; name ## _list();

// #2
%pythoncode %{
  name = make_enum('name', {x.label: EnumValue(x.value, x.label) for x in name ## _list()})
%}

enum name;

%enddef
</code></pre>
<p>I added a function to minimal.i to prove it really does work:</p>
<pre class="lang-cpp prettyprint-override"><code>%module minimal

%{
#include "minimal.h"
%}

%include "enum.i"
%include "minimal.h"

%inline %{
  void foo(const my_enum&amp; v) {
    std::cerr &lt;&lt; "GOT: " &lt;&lt; v &lt;&lt; "\n";
  }
%}
</code></pre>
<p>And finally test it with:</p>
<pre class="lang-py prettyprint-override"><code>import minimal
print minimal.my_enum
print minimal.my_enum.A
print minimal.my_enum.B

minimal.foo(minimal.my_enum.B)
</code></pre>
<p>Which you'll be pleased to see worked and resulted in:</p>
<pre class="lang-none prettyprint-override"><code>&lt;class 'minimal.my_enum'&gt;
A
B
GOT: 1
</code></pre>
<p>If you're using Python 3 there's a possibly nicer way to <a href="https://docs.python.org/3/library/enum.html#module-enum" rel="nofollow noreferrer">represent enums</a>, but I'll leave that as an exercise for the reader for now. You can obviously tweak the Python 2.7 fake enums to your taste as well.</p>
</div>
<span class="comment-copy">I almost have an answer, but out of curiosity are you targeting python 2.x or 3.x?</span>
<span class="comment-copy">I'm still on Python 2.7. The last time I considered switching (a while ago), Python 3 was still missing some libraries I require.</span>
<span class="comment-copy">This is a tremendous answer and I'm sure it works. Unfortunately, it somewhat misses the question. It creates a lot of duplicate code and does not solve the issue of including boost headers. I guess I was hoping there would be a way to nicely include the right boost headers. There is so many of them however, so it must be really tedious. Given that you really know your way around SWIG and chose to go this route confirms that, I would say. I'm accepting this answer as an "it's probably not worth bothering with boost macros that need to be externalized"</span>
