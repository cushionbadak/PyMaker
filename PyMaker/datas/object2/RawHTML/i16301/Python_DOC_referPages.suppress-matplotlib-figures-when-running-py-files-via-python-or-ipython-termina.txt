<div class="post-text" itemprop="text">
<p>I am writing a <code>test_examples.py</code> to test the execution of a folder of python examples.  Currently I use <code>glob</code> to parse the folder and then use <code>subprocess</code> to execute each python file. The issue is that some of these files are plots and they open a <code>Figure</code> window that halts until the window is closed.</p>
<p>A lot of the questions on this issue offer solutions from within the file, but how could I suppress the output whilst running the file externally without any modification?</p>
<p>What I have done so far is:</p>
<pre><code>import subprocess as sb
import glob
from nose import with_setup

def test_execute():
    files = glob.glob("../*.py")
    files.sort()
    for fl in files:
        try:
            sb.call(["ipython", "--matplotlib=Qt4", fl])
        except:
            assert False, "File: %s ran with some errors\n" % (fl)
</code></pre>
<p>This kind of works, in that it suppresses the Figures, but it doesn't throw any exceptions (even if the program has an error). I am also not 100% sure what it is doing. Is it appending all of the figures to Qt4 or will the Figure be removed from memory when that script has finished?</p>
<p>Ideally I would like to ideally run each <code>.py</code> file and capture its <code>stdout</code> and <code>stderr</code>, then use the exit condition to report the <code>stderr</code> and fail the tests. Then when I run <code>nosetests</code> it will run the examples folder of programs and check that they all run. </p>
</div>
<div class="post-text" itemprop="text">
<p>You could force matplotlib to use the <code>Agg</code> backend (which won't open any windows) by inserting the following lines at the top of each source file:</p>
<pre><code>import matplotlib
matplotlib.use('Agg')
</code></pre>
<p>Here's a one-liner shell command that will <em>dynamically</em> insert these lines at the top of <code>my_script.py</code> (without modifying the file on disk) before piping the output to the Python interpreter for execution:</p>
<pre><code>~$ sed "1i import matplotlib\nmatplotlib.use('Agg')\n" my_script.py | python
</code></pre>
<p>You should be able to make the equivalent call using <code>subprocess</code>, like this:</p>
<pre><code>p1 = sb.Popen(["sed", "1i import matplotlib\nmatplotlib.use('Agg')\n", fl],
              stdout=sb.PIPE)
exit_cond = sb.call(["python"], stdin=p1.stdout)
</code></pre>
<p>You could capture the <code>stderr</code> and <code>stdout</code> from your scripts by passing the <code>stdout=</code> and <code>stderr=</code> arguments to <code>sb.call()</code>. This would, of course, only work in Unix environments that have the <code>sed</code> utility.</p>
<hr/>
<h2>Update</h2>
<p>This is actually quite an interesting problem. I thought about it a bit more, and I think this is a more elegant solution (although still a bit of a hack):</p>
<pre><code>#!/usr/bin/python

import sys
import os
import glob
from contextlib import contextmanager
import traceback

set_backend = "import matplotlib\nmatplotlib.use('Agg')\n"

@contextmanager
def redirected_output(new_stdout=None, new_stderr=None):
    save_stdout = sys.stdout
    save_stderr = sys.stderr
    if new_stdout is not None:
        sys.stdout = new_stdout
    if new_stderr is not None:
        sys.stderr = new_stderr
    try:
        yield None
    finally:
        sys.stdout = save_stdout
        sys.stderr = save_stderr

def run_exectests(test_dir, log_path='exectests.log'):

    test_files = glob.glob(os.path.join(test_dir, '*.py'))
    test_files.sort()
    passed = []
    failed = []
    with open(log_path, 'w') as f:
        with redirected_output(new_stdout=f, new_stderr=f):
            for fname in test_files:
                print("&gt;&gt; Executing '%s'" % fname)
                try:
                    code = compile(set_backend + open(fname, 'r').read(),
                                   fname, 'exec')
                    exec(code, {'__name__':'__main__'}, {})
                    passed.append(fname)
                except:
                    traceback.print_exc()
                    failed.append(fname)
                    pass

    print "&gt;&gt; Passed %i/%i tests: " %(len(passed), len(test_files))
    print "Passed: " + ', '.join(passed)
    print "Failed: " + ', '.join(failed)
    print "See %s for details" % log_path

    return passed, failed

if __name__ == '__main__':
    run_exectests(*sys.argv[1:])
</code></pre>
<p>Conceptually this is very similar to my previous solution - it works by reading in the test scripts as strings, and prepending them with a couple of lines that will import matplotlib and set the backend to a non-interactive one. The string is then compiled to Python bytecode, then executed. The main advantage is that it this ought to be platform-independent, since <code>sed</code> is not required.</p>
<p>The <code>{'__name__':'__main__'}</code> trick with the globals is necessary if, like me, you tend to write your scripts like this:</p>
<pre><code>    def run_me():
        ...
    if __name__ == '__main__':
        run_me()
</code></pre>
<p>A few points to consider:</p>
<ul>
<li>If you try to run this function from within an ipython session where you've already imported matplotlib and set an interactive backend, the <code>set_backend</code> trick won't work and you'll still get figures popping up. The easiest way is to run it directly from the shell (<code>~$ python exectests.py testdir/ logfile.log</code>), or from an (i)python session where you haven't set an interactive backend for matplotlib. It should also work if you run it in a different subprocess from within your ipython session.</li>
<li>I'm using the <code>contextmanager</code> trick from <a href="https://stackoverflow.com/a/14707227/1461210">this answer</a> to redirect <code>stdin</code> and <code>stdout</code> to a log file. Note that this isn't threadsafe, but I think it's pretty unusual for scripts to open subprocesses.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Coming to this late, but I am trying to figure something similar out myself, and this is what I have come up with so far. Basically, if your plots are calling, for example, <code>matplotlib.pyplot.show</code> to show the plot, you can <a href="https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock" rel="nofollow noreferrer">mock</a> that method out using a <a href="https://docs.python.org/3/library/unittest.mock.html#the-patchers" rel="nofollow noreferrer">patch decorator</a>. Something like:</p>
<pre><code>from unittest.mock import patch

@patch('matplotlib.pyplot.show')  # passes a mock object to the decorated function
def test_execute(mock_show):
    assert mock_show() == None  # shouldn't do anything
    files = glob.glob("../*.py")
    files.sort()
    for fl in files:
        try:
            sb.call(["ipython", fl])
        except:
            assert False, "File: %s ran with some errors\n" % (fl)
</code></pre>
<p>Basically the patch decorator should replace any call to <code>matplotlib.pyplot.show</code> within the decorated function with a mock object that doesn't do anything. At least that's how it's supposed to work in theory. In my application, my terminal is still trying to open plots and this is resulting in errors. I hope it works better for you, and I will update if I figure out something wrong in the above that is leading to my issue.</p>
<p><strong>Edit:</strong> for completeness, you might be generating figures with a call to <code>matplotlib.pyplot.figure()</code> or <code>matplotlib.pyplot.subplots()</code>, in which case these are what you would mock out instead of <code>matplotlib.pyplot.show()</code>. Same syntax as above, you would just use:</p>
<pre><code>@patch('matplotlib.pyplot.figure')
</code></pre>
<p>or:</p>
<pre><code>@patch('matplotlib.pyplot.subplots')
</code></pre>
</div>
<span class="comment-copy">thanks for these neat ideas. I have written nose tests for the functions embedded in the library. This is a run check added into the test suite that runs the example programs in case the API has changed etc which would get flagged in this test</span>
<span class="comment-copy">@sanguineturtle OK, that makes more sense to me. I think I've come up with a slightly better solution - see my update.</span>
