<div class="post-text" itemprop="text">
<p>Same question as <a href="https://stackoverflow.com/questions/24773514/is-there-a-module-that-prints-a-list-like-ls-c">this</a>, but for python. If I have a list</p>
<pre><code>['a','b','cdefg','jk','lmnopqr','st','uv','wxyz',1,2,3,4]
</code></pre>
<p>I would like to print it something like the default output of the ls command in bash, something like</p>
<pre><code>[ 'a',   'b',        'cdefg',
  'jk',  'st',       'lm',
  'no',  'pqrstuv',  'wxyz',  
  1,     2,          3,
  4,     ]
</code></pre>
<p>The goal being maximization of visually parsable data on the screen at one time. I can only find the pprint library, which for simple lists either prints as default or one per line. Does something like this exist already?</p>
</div>
<div class="post-text" itemprop="text">
<p>Thank you everyone for your thoughts and for clarifying that there indeed is no extant solution for this. I coded up exactly what I wanted, code below. In a terminal with a width of 80 characters</p>
<pre><code>pprint_list( [ string.lowercase[i % 26]*random.randint(1,20) for i in range(8) ] )
</code></pre>
<p>printed as</p>
<pre><code>[ 'aaaa',         'bbbbbbbbbbbbbbb',   'ccccccccccccccccccc',  'd',  
  'eeeeeeeeeee',  'ffffffffffffffff',  'gggggggggggggggg',     'h'   ]
</code></pre>
<p>A look at the code shows there is obviously some overhead figuring out how to size the columns, with more entries and wider terminals requiring more calculation, but moving the number of entries up from 8 to 50000 didn't have much lag time, so I think I'm happy with it.</p>
<p>This code relies on the get_terminal_size function <a href="https://gist.github.com/jtriley/1108174" rel="nofollow">here</a>.</p>
<pre><code>#!/usr/bin/env python
def pprint_list(input_list):
    (term_width, term_height) = get_terminal_size()
    if len( str(input_list) ) &lt;= term_width:
        print input_list
        return

    repr_list = [repr(x) for x in input_list]
    min_chars_between = 3 # a comma and two spaces
    usable_term_width = term_width - 3 # For '[ ' and ']' at beginning and end
    min_element_width = min( len(x) for x in repr_list ) + min_chars_between
    max_element_width = max( len(x) for x in repr_list ) + min_chars_between
    if max_element_width &gt;= usable_term_width:
        ncol = 1
        col_widths = [1]
    else:
        # Start with max possible number of columns and reduce until it fits
        ncol = min( len(repr_list), usable_term_width / min_element_width  )
        while True:
            col_widths = [ max( len(x) + min_chars_between \
                                for j, x in enumerate( repr_list ) if j % ncol == i ) \
                                for i in range(ncol) ]
            if sum( col_widths ) &lt;= usable_term_width: break
            else: ncol -= 1

    sys.stdout.write('[ ')
    for i, x in enumerate(repr_list):
        if i != len(repr_list)-1: x += ','
        sys.stdout.write( x.ljust( col_widths[ i % ncol ] ) )
        if i == len(repr_list) - 1:
            sys.stdout.write(']\n')
        elif (i+1) % ncol == 0:
            sys.stdout.write('\n  ')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def columnify(iterable):
    # First convert everything to its repr
    strings = [repr(x) for x in iterable]
    # Now pad all the strings to match the widest
    widest = max(len(x) for x in strings)
    padded = [x.ljust(widest) for x in strings]
    return padded
</code></pre>
<hr/>
<p>Now you should be able to use <code>pprint.pprint(compact=True)</code>, or <code>textwrap</code>, or other tools to get the formatting however you want.</p>
<p>But if you want to do it manually, it's not too hard to do anything you want. For example:</p>
<pre><code>def colprint(iterable, width=72):
    columns = columnify(iterable)
    colwidth = len(columns[0])+2
    perline = (width-4) // colwidth
    print('[ ', end='')
    for i, column in enumerate(columns):
        print(column, end=', ')
        if i % perline == perline-1:
            print('\n  ', end='')
    print(' ]')
</code></pre>
<p>So:</p>
<pre><code>&gt;&gt;&gt; arr = ['a', 'b', 'cdefg', 'jk', 'lmnopqr', 'st', 'uv', 'wxyz', 1, 2, 3, 4]
&gt;&gt;&gt; colprint(arr, 60)
[ 'a'      , 'b'      , 'cdefg'  , 'jk'     , 'lmnopqr',
  'st'     , 'uv'     , 'wxyz'   , 1        , 2        ,
  3        , 4        ,  ]
</code></pre>
<hr/>
<p>This still won't give you exactly what <code>ls</code> does; for example, <code>ls</code> has some heuristics that try to make sure that filenames that are "too long" don't count toward the max width, and instead span multiple columns. If you really want to do everything <em>exactly</em> the same as <code>ls</code>, you probably need to look at the source code and translate from C to Python…</p>
<p>Also, take a look at <a href="https://docs.python.org/3/library/pprint.html" rel="nofollow"><code>pprint</code></a>. Whenever a module's documentation starts off with a link to the source code, that means the module was meant to serve as useful sample code, as well as to be useful on its own. So, if you want to look at the rules it uses to determine when to split lines (based on the <code>compact</code> flag as well as the widths), you should be able to figure it out from there.</p>
</div>
<span class="comment-copy">Your example does not match that of the linked question. In the output of <code>ls</code>, consecutive elements are in the same column, not in the same row.</span>
<span class="comment-copy">True, but that was intentional. I think it would be confusing if default output wrote them consecutively horizontally and then pretty print made it vertical. I don't have terribly strong feelings one way or the other, though.</span>
<span class="comment-copy">As a side note, there's been some recent interest in the Python community behind beefing up <code>pprint</code>, so if you have ideas for pretty-printing—like equal-sized columns—now might be a great time to bring them up. Start by searching <a href="http://bugs.python.org" rel="nofollow noreferrer">bugs.python.org</a> and the python-ideas and -dev <a href="https://mail.python.org/mailman/listinfo/" rel="nofollow noreferrer">mailing lists</a> to see where things stand and figure out where to speak up.</span>
<span class="comment-copy">A generalization of the problem of formatting text into columns is described in <a href="http://stackoverflow.com/questions/12503655/how-do-i-print-parameters-of-multiple-python-objects-in-table-form/12503806#12503806">this answer</a> to the question <a href="http://stackoverflow.com/questions/12503655/how-do-i-print-parameters-of-multiple-python-objects-in-table-form"><i>How do I print parameters of multiple Python objects in table form?</i></a></span>
<span class="comment-copy">Thanks for this, what I was looking for, I don't think what martineau linked can do the same thing.</span>
