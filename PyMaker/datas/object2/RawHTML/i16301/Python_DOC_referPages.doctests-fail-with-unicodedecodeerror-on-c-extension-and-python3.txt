<div class="post-text" itemprop="text">
<p>I am having difficulty getting my testing framework to work for a C-extension module for both Python2 and Python3. I like to run my docstrings through <code>doctest</code> to make sure that I am not feeding my users bad information, so I want to run <code>doctest</code> as part of my testing.</p>
<p>I don't believe that the source of my problem is the docstrings themselves, but rather how the <code>doctest</code> module is trying to read my extension module.  If I run <code>doctest</code> with Python2 (on the module compiled against Python2), I get the output that I expect:</p>
<pre><code>$ python -m doctest myext.so -v
...
1 items passed all tests:
98 tests in myext.so
98 tests in 1 items.
98 passed and 0 failed.
Test passed.
</code></pre>
<p>However, when I do the same but with Python3, I get a <code>UnicodeDecodeError</code>:</p>
<pre><code>$ python3 -m doctest myext3.so -v
Traceback (most recent call last):
...
  File "/usr/local/Cellar/python3/3.3.3/Frameworks/Python.framework/Versions/3.3/lib/python3.3/doctest.py", line 223, in _load_testfile
    return f.read(), filename
  File "/usr/local/Cellar/python3/3.3.3/Frameworks/Python.framework/Versions/3.3/lib/python3.3/codecs.py", line 301, in decode
    (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xcf in position 0: invalid continuation byte
</code></pre>
<p>To get some more info, I ran it through <code>pytest</code> with full traceback:</p>
<pre><code>$ python3 -m pytest --doctest-glob "*.so" --full-trace
...
self = &lt;encodings.utf_8.IncrementalDecoder object at 0x102ff5110&gt;
input = b'\xcf\xfa\xed\xfe\x07\x00\x00\x01\x03\x00\x00\x00\x08\x00\x00\x00\r\x00\x00\x00\xd0\x05\x00\x00\x85\x00\x00\x00\x00\x...edString\x00_PyUnicode_FromString\x00_Py_BuildValue\x00__Py_FalseStruct\x00__Py_TrueStruct\x00dyld_stub_binder\x00\x00'
final = True

    def decode(self, input, final=False):
        # decode input (taking the buffer into account)
        data = self.buffer + input
&gt;       (result, consumed) = self._buffer_decode(data, self.errors, final)
E       UnicodeDecodeError: 'utf-8' codec can't decode byte 0xcf in position 0: invalid continuation byte

/usr/local/Cellar/python3/3.3.3/Frameworks/Python.framework/Versions/3.3/lib/python3.3/codecs.py:301: UnicodeDecodeError    
</code></pre>
<hr/>
<p>It looks like <code>doctest</code> is actually <em>reading</em> the <code>.so</code> file to get the docstrings (rather than importing the module), but Python3 doesn't know how to decode the input.  I can confirm this by replicating the byte string and traceback by trying to read the <code>.so</code> file myself:</p>
<pre><code>$ python3
Python 3.3.3 (default, Dec 10 2013, 20:13:18) 
[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.2.79)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; open('myext3.so').read()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/local/Cellar/python3/3.3.3/Frameworks/Python.framework/Versions/3.3/lib/python3.3/codecs.py", line 301, in decode
    (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xcf in position 0: invalid continuation byte
&gt;&gt;&gt; open('myext3.so', 'rb').read()
b'\xcf\xfa\xed\xfe\x07\x00\x00\x01\x03\x00\x00\x00\x08\x00\x00\x00\r\x00\x00\x00\xd0\x05...'
</code></pre>
<hr/>
<p>Has anyone else run into this problem before?  Is there a standard (or not-so-standard) way to get <code>doctest</code> to execute tests on C extension modules on python3?</p>
<p><strong>Update</strong>: I should also add that I get identical results on Travis-CI (<a href="https://travis-ci.org/SethMMorton/fastnumbers/jobs/31680811" rel="nofollow">see here</a>), so it's not specific to my local build.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have found a workaround to this problem so I will post it, but I find it rather unsatisfying.  I am still looking for more elegant/less hacky solutions to this.</p>
<hr/>
<p>There are <strong>three</strong> problems with <code>doctest.py</code> that need to be overcome to make this work:</p>
<p><strong>1) Get doctest to consider .so files as python modules.</strong></p>
<p>If you look at the <code>doctest.py</code> source, you will notice in the test runner a block that looks similar to this (depending on the python version you are running):</p>
<pre><code>if filename.endswith(".py"):
    # It is a module -- insert its dir into sys.path and try to
    # import it. If it is part of a package, that possibly
    # won't work because of package imports.
    dirname, filename = os.path.split(filename)
    sys.path.insert(0, dirname)
    m = __import__(filename[:-3])
    del sys.path[0]
    failures, _ = testmod(m)
else:
    failures, _ = testfile(filename, module_relative=False)
</code></pre>
<p>What is happening here is <code>doctest.py</code> is checking for the ".py" extension, and if so the file is loaded as a python module, but otherwise the file is read as if it were text (like a README.rst might be).  We need to get <code>doctest.py</code> to acknowledge that a file with ".so" extension is a python module.  To do this, simply add a check for the ".so" extension by modifying this <code>if</code> block to read</p>
<pre><code>if filename.endswith(".py") or filename.endswith(".so"):
    ...
</code></pre>
<p><strong>2) Get doctest to identify the functions in the C-extension module</strong></p>
<p><code>doctest.py</code> uses the <a href="https://docs.python.org/3/library/inspect.html#inspect.isfunction" rel="nofollow">inspect.isfunction</a> function to determine what objects are functions when recursively searching for docstrings within a module object.  The problem with this function is that it only identifies functions written in python, not in C (python identifies C-extension functions as builtin).  So, to identify our functions when recursing through the module, we need to use <a href="https://docs.python.org/3/library/inspect.html#inspect.isbuiltin" rel="nofollow">inspect.isbuiltin</a> instead.</p>
<p>To rectify this, we need to locate the <code>DocTestFinder._find</code> method in <code>doctest.py</code> and change how it looks for functions.  I converted</p>
<pre><code># Recurse to functions &amp; classes.
if ((inspect.isfunction(val) or inspect.isclass(val)) and
    self._from_module(module, val)):
    self._find(tests, val, valname, module, source_lines,
               globs, seen)
</code></pre>
<p>to </p>
<pre><code># Recurse to functions &amp; classes.
if ((inspect.isbuiltin(val) or inspect.isclass(val)) and
    self._from_module(module, val)):
    self._find(tests, val, valname, module, source_lines,
               globs, seen)
</code></pre>
<p><strong>3) Properly remove the version tag on the .so file (Python3 only).</strong></p>
<p>On Python3, C-extensions can be tagged with a version identifier (i.e. "myext.cpython-3mu.so", please see <a href="http://legacy.python.org/dev/peps/pep-3149/" rel="nofollow">PEP 3149</a>).  We need to know how to remove this when doing the initial import in the <code>doctest.py</code> test runner.</p>
<p>To do this, I converted the line</p>
<pre><code>m = __import__(filename[:-3])
</code></pre>
<p>to</p>
<pre><code>from sysconfig import get_config_var
m = __import__(filename[:-3] if filename.endswith(".py") else filename.replace(get_config_var("EXT_SUFFIX"), ""))
</code></pre>
<p>This is only needed for Python3.</p>
<hr/>
<p>After making these modifications, I can get doctest to work as expected on both Python2 and Python3.  Since these modifications are rather annoying, I have made a <code>patch_doctest.py</code> script that does this automatically and puts the patched <code>doctest.py</code> in your current directory.  You can get this file <a href="https://github.com/SethMMorton/fastnumbers/blob/develop/patch_doctest.py" rel="nofollow">here</a> if you want to use it.  You can then run the tests on the extension modules like this</p>
<pre><code>$ python2 patch_doctest.py
$ python2 -m doctest myext2.so
$ rm doctest.py
$ python3 patch_doctest.py
$ python3 -m doctest myext3.so
</code></pre>
<p>As evidence that this works, <a href="https://travis-ci.org/SethMMorton/fastnumbers/builds/31772265" rel="nofollow">here are the new Travis-CI results</a>.</p>
</div>
<span class="comment-copy">Perhaps there's a different version of <code>doctest</code> you need to compile for Python 3?</span>
<span class="comment-copy">For python3, I am using the doctest module from the std lib. Is there another version you recommend?  Isn't doctest a pure python module, so does it need compilation?</span>
<span class="comment-copy">Sorry, I've never used <code>doctest</code> before, didn't realize it was a built in module. Maybe your PYTHONPATH is putting the version 2 module ahead of the version 3 one?</span>
<span class="comment-copy">My PYTHONPATH is empty... I rely solely on the hardcoded paths in <code>sys.path</code>.  Also, in the first traceback you can see that the <code>doctest.py</code> file is in the python 3.3 standard library location, so I don't think that is the problem.  I appreciate your suggestions, keep them coming!</span>
<span class="comment-copy">Considering that it doesn't take <i>much</i> to get this to work, I wonder if this is an enhancement the python devs might be interested in...</span>
