<div class="post-text" itemprop="text">
<p>I am a bit stuck on creating the anti_vowel definition:</p>
<blockquote>
<p>Define a function called anti_vowel that takes one string, text, as input and returns the text with all of the vowels removed</p>
</blockquote>
<p>This is my attempt:</p>
<pre><code>def anti_vowel(text):
    vowels=["a","A","e","E","i","I","o","O","u","U"]
    text_input=[""]
    for char in text:
        text_input.append(char)
    av = [char for char in text_input if char not in vowels]
    return av
</code></pre>
<p>My code returns the input as separate characters.</p>
<p>This is the error I get:</p>
<pre><code>Oops, try again. Your function fails on anti_vowel("Hey look Words!"). It returns "['', 'H', 'y', ' ', 'l', 'k', ' ', 'W', 'r', 'd', 's', '!']" when it should return "Hy lk Wrds!". 
</code></pre>
<p>Could someone please point me in the right direction?</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider:</p>
<pre><code>&gt;&gt;&gt; tgt='This is some text with vowels'
&gt;&gt;&gt; vowels='aeiou'
&gt;&gt;&gt; ''.join(e for e in tgt if e.lower() not in vowels)
'Ths s sm txt wth vwls'
</code></pre>
<hr/>
<p>Or, as pointed out in comments, using an actual list comprehension inside join <a href="https://stackoverflow.com/questions/9060653/list-comprehension-without-python/9061024#9061024">is better</a>:</p>
<pre><code>&gt;&gt;&gt; ''.join([e for e in tgt if e.lower() not in vowels])
'Ths s sm txt wth vwls'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>return ''.join(av)
</code></pre>
<p>will make it back into a string from a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're returning the list. Using join function you can convert the list to corresponding string.</p>
<p>Try:</p>
<pre><code>return ''.join(av)
</code></pre>
<p>instead of <code>return av</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You're looking for <a href="https://docs.python.org/2/library/stdtypes.html#str.join" rel="nofollow">str.join</a> which takes an iterable (like a list) as an argument and returns the string formed by using the object as a separator between each element of that iterable. For example:</p>
<pre><code>lst = ['a','b','c','d','e','f','g']

''.join(lst) # 'abcdefg'
'/'.join(lst) # 'a/b/c/d/e/f/g'
'a'.join(lst # 'aabacadaeafag' etc etc...
</code></pre>
<p>Note that there are better ways to implement your function. <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow"><code>str.translate</code></a>(use THIS <a href="https://docs.python.org/2/library/stdtypes.html#str.translate" rel="nofollow"><code>str.translate</code></a> in Python2, which iirc is what Codecademy uses for their interpreter, it's changed between versions) is BORN to delete characters from strings.</p>
<pre><code># Python3
def hate_vowels_py3(instring):
    transmap = str.maketrans('', '', 'aeiouAEIOU')
    outstring = instring.translate(transmap)
    return outstring

# Python2
def hate_vowels_py2(instring):
    outstring = instring.translate(None, 'aeiouAEIOU')
    return outstring
</code></pre>
<p>And using your method, there's even an incremental improvement to be made. Any time you both</p>
<ul>
<li>Don't need to keep something in order and</li>
<li>Don't need to have more than one of something</li>
</ul>
<p>You should strongly consider using a <code>set</code> instead of a <code>list</code>. The <code>set</code> takes slightly longer to build for the first time, but lookups are MUCH faster. Remember that if you unroll that list comp you have:</p>
<pre><code># example string "Hello world!"

chars_to_delete = ["a","e","i","o","u","A","E","I","O","U"]
string = "Hello world!"
output_list = []
char = "H"
can_append_to_list = True
if char == "a": can_append_to_list = False
if char == "e": can_append_to_list = False
if char == "i": can_append_to_list = False
if char == "o": can_append_to_list = False
if char == "u": can_append_to_list = False
if char == "A": can_append_to_list = False
if char == "E": can_append_to_list = False
if char == "I": can_append_to_list = False
if char == "O": can_append_to_list = False
if char == "U": can_append_to_list = False # ten lookups to this list
if can_append_to_list: output_list.append(char)
char = "e"
can_append_to_list = True
# begin again..........
</code></pre>
<p>As you can see that's a LOT of lookups to that list. Instead use a set, whose lookup time is BLINDINGLY fast. Either use the literal declaration:</p>
<pre><code>vowels = {'a','e','i','o','u','A','E','I','O','U'} # looks like a dict with only keys
# (also IS a dict with no keys, but shhh that's an implementation detail)
</code></pre>
<p>or you can create one from any iterable by calling <code>set()</code> with the iter as an argument</p>
<pre><code>vowels = set('aeiouAEIOU')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is my solution:</p>
<pre><code>def anti_vowel(text):
    vowels = 'aeiouAEIOU'
    textlist = []
    for char in text:
        if char in vowels:
            continue
        else: 
            textlist.append(char)      
    return "".join(textlist)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is my solution:</p>
<pre><code> passage = '''We hold these truths to be self evident,
    that all men are created equal!'''
    def anti_vowel(text):
        vowels = ['a','e','i','o','u','A','E','I','O','U']
        text = list(text)
        i = 0 
        while i &lt; len(text):
            if text[i] in vowels:
                del(text[i])
                print(i)
                i = i
            else:
                print(text[i])
                i += 1
                s = ''.join(text)
        return s

    print(anti_vowel(passage))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>another simple way to solve this problem...</strong> </p>
<pre><code>def anti_vowel (text):
   new_text=""
   for char in text:
     if char not in "aeiouAEIOU":
       new_text+=char
   return new_text
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def anti_vowel(text):
    vowels = "aeiouAEIOU"
    for x in vowels:
        text = text.replace(x, "")
    return text
</code></pre>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/9060653/list-comprehension-without-python/9061024#9061024">use list comps with str.join</a></span>
<span class="comment-copy">Well the speed difference there is not <i>obvious better</i> but it is <i>Raymond</i> so change made ;-)</span>
<span class="comment-copy">Thanks, that was such a simple solution</span>
<span class="comment-copy">Please answer the question -- "<i>Could someone please point me in the right direction to improve my code</i>" -- rather than posting code that also works.</span>
