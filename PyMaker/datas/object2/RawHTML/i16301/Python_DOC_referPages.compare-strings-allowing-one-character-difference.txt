<div class="post-text" itemprop="text">
<p>I have been trying to implement tabular method for simplification of boolean expressions in python. For that I need to check whether two given strings differ at only one index
for example, the function should return the following for the following examples:</p>
<ul>
<li><code>0011</code> and <code>0111</code> - true as the two differ only at position 1</li>
<li><code>0-001</code> and <code>0-101</code> - true as differ at only 2</li>
<li><code>0-011</code> and <code>0-101</code> - false as differ at 2,3</li>
</ul>
<p>right now I am using the following function:</p>
<pre><code>def match(s1,s2):

    l=[False,-1]##returns false when they cant be combined
    for i in range(len(s1)):
        if s1[:i]==s2[:i] and s1[i]!=s2[i] and s1[i+1:]==s2[i+1:]:
            l= [True,i]
            break
    return l
</code></pre>
<p>I want to implement it in a very fast manner (low complexity). Is there a way to do so in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a more well-performing solution, coded in Python 3:</p>
<pre><code>def match(s1, s2):
    ok = False

    for c1, c2 in zip(s1, s2):
        if c1 != c2:
            if ok:
                return False
            else:
                ok = True

    return ok
</code></pre>
<p>I do not checked for length difference because you said the two strings are equal, but for a more general approach I would add it.</p>
<p>If you need the position of the different character:</p>
<pre><code>def match(s1, s2):
    pos = -1

    for i, (c1, c2) in enumerate(zip(s1, s2)):
        if c1 != c2:
            if pos != -1:
                return -1
            else:
                pos = i

    return pos
</code></pre>
<p>These are benchmarks performed with timeit, tested with match("0-001", "0-101"). I translated all solutions to py3 and removed length test.</p>
<ol>
<li>your solution: 5.12</li>
<li>Martijn Pieters' solution: 4.92</li>
<li>enrico.bacis' and lakesh's solution: 5.51</li>
<li>my solution: 2.42</li>
</ol>
<p>Tests with a longer string:</p>
<p>Martijn Pieters' solution:</p>
<pre><code>timeit.timeit('match("0-0016ub5j2oi06u30tj30g6790v3nug[hoyj39867i6gy9thvb05y4b896y3n098vty98thn98qg5y4n8ygnqp", "0-0016ub5j2oi06u30tj30g6790v3gug[hoyj39867i6gy9thvb05y4b896y3n098vty98thn98qg5y4n8ygnqp")', setup="""
def match(s1, s2):
    combo = zip(s1, s2)
    return any(c1 != c2 for c1, c2 in combo) and all(c1 == c2 for c1, c2 in combo)
""")
</code></pre>
<p>result: 32.82</p>
<p>My solution:</p>
<pre><code>timeit.timeit('match("0-0016ub5j2oi06u30tj30g6790v3nug[hoyj39867i6gy9thvb05y4b896y3n098vty98thn98qg5y4n8ygnqp", "0-0016ub5j2oi06u30tj30g6790v3gug[hoyj39867i6gy9thvb05y4b896y3n098vty98thn98qg5y4n8ygnqp")', setup="""
def match(s1, s2):
    ok = False

    for c1, c2 in zip(s1, s2):
        if c1 != c2:
            if ok:
                return False
            else:
                ok = True

    return ok
""")
</code></pre>
<p>Result: 20.21</p>
</div>
<div class="post-text" itemprop="text">
<p>I used the Levenshtein distance to match strings that are different by one character added or removed only (and not simply replaced). So:</p>
<ul>
<li>John's dog</li>
<li>Johns dog</li>
</ul>
<p>are considered as a match.</p>
<p>The Levenshtein distance is the number of edits it would take to replace one string by another. The Levenshtein distance of the two above strings is 1, because the only thing to do is to remove one character.</p>
<p>To use it, you can simply install the according Levenshtein python module:</p>
<pre><code>pip install python-Levenshtein
</code></pre>
<p>and then use it:</p>
<pre><code>from Levenshtein import distance 
def match(s1, s2):
    return distance(s1, s2) &lt;= 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def match(a,b):
    s = sum([a[i] != b[i] for i in range(len(a))])
    if s == 1:
       return True
    else:
       return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2, use <a href="https://docs.python.org/2/library/future_builtins.html#future_builtins.zip" rel="nofollow"><code>future_builtins.zip()</code></a> (Python 2 and 3 compatible <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip()</code></a>-as-iterator) (in Python 3 the built-in will do fine) to combine the two strings character by character, then use <code>any()</code> and <code>all()</code> to loop over the resulting iterator:</p>
<pre><code>try:
    from future_builtins import zip
except ImportError:
    pass

def match(s1, s2):
    if len(s1) != len(s2):
        return False
    combo = zip(s1, s2)
    return any(c1 != c2 for c1, c2 in combo) and all(c1 == c2 for c1, c2 in combo)
</code></pre>
<p>This works because <code>combo</code> is an <em>iterator</em>; it yields pairs of characters one by one on demand, and <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow"><code>any()</code></a> and <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow"><code>all()</code></a> only take as many pairs as needed to determine their outcome. </p>
<p><code>any()</code> stops iterating as soon as it finds two characters that are <em>not</em> equal. <code>all()</code> will only return True if all the <em>remaining</em> characters are equal.</p>
<p>Together the two conditions then are <em>only</em> True if there is <em>exactly one pair</em> that differs.</p>
<p>Because an iterator approach is used, the above does the absolute minimum amount of work to determine if your strings are a match; the moment a second pair is found that doesn't match iteration stops; there is no point in looking at the rest of the character combinations.</p>
<p>Demo (Python 2, so <code>zip()</code> is imported):</p>
<pre><code>&gt;&gt;&gt; from future_builtins import zip
&gt;&gt;&gt; def match(s1, s2):
...     if len(s1) != len(s2):
...         return False
...     combo = zip(s1, s2)
...     return any(c1 != c2 for c1, c2 in combo) and all(c1 == c2 for c1, c2 in combo)
... 
&gt;&gt;&gt; match('0011', '0111')
True
&gt;&gt;&gt; match('0-001', '0-101')
True
&gt;&gt;&gt; match('0-011', '0-101')
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Same Lengths</h2>
<p>If the two string have the same length:</p>
<pre><code>def match(s1, s2):
    return sum(s1[i] != s2[i] for i in xrange(len(s1))) &lt;= 1
</code></pre>
<p>You can also create a generator of matchers like this:</p>
<pre><code>def create_matcher(maxdiff):
    return lambda s1, s2: sum(s1[i] != s2[i] for i in xrange(len(s1))) &lt;= maxdiff

match = create_matcher(1)
</code></pre>
<p>Example:</p>
<pre><code>print match('0011', '0111')      # True
print match('0-001', '0-101')    # True
print match('0-011', '0-101')    # False
</code></pre>
<hr/>
<h2>Different Lengths</h2>
<p>If they have different length we can assume that the exceeding characters are different, so:</p>
<pre><code>def match(s1, s2):
    l = min(len(s1), len(s2))
    return sum(s1[i] != s2[i] for i in xrange(l)) + abs(len(s1) - len(s2)) &lt;= 1
</code></pre>
</div>
<span class="comment-copy">Is "0011" equal to "011"? Or must the length be the same?</span>
<span class="comment-copy">Do you mean 'at most'?</span>
<span class="comment-copy">the two input strings have the same length</span>
<span class="comment-copy">i mean that the two strings should differ at exactly one position</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/682367/good-python-modules-for-fuzzy-string-comparison">Good Python modules for fuzzy string comparison?</a></span>
<span class="comment-copy">Instead of setting <code>ok</code> to False and breaking, you can just <code>return False</code> at that point.</span>
<span class="comment-copy">Can you update this with benchmarks including all test inputs and also <i>longer</i> strings?</span>
<span class="comment-copy">@MartijnPieters: done, thank you!</span>
<span class="comment-copy">@lucas its a very efficient way.Is there a way ,your function can be modified to give position(index) of difference also.Thanks a lot.</span>
<span class="comment-copy">@DeepakSaini: you can do: <code>pos=-1; for i, cc in enumerate(zip(s1, s2)): if cc[0] != cc[1]: if pos != -1: return -1; else: pos =i</code> and <code>return pos</code>. You don't need to return also <code>True</code> or <code>False</code> if you need the position, because <code>-1</code> means there's no match.</span>
<span class="comment-copy">Its performances?</span>
<span class="comment-copy">Or you could <code>return s&lt;2</code></span>
<span class="comment-copy">@ Matrtijn Pieters thanks.But iam getting an error that there is no module named future_builtins</span>
<span class="comment-copy">@DeepakSaini: What version of Python is this? You can also use <code>from itertools import izip as zip</code>.</span>
<span class="comment-copy">i am using python 3.3.2</span>
<span class="comment-copy">@DeepakSaini: right, then <code>zip()</code> is already the 'future builtin'; adjusted to ignore the import error in that case.</span>
<span class="comment-copy">i dont get it.i can see that the method you have given will do my work .But i am not able to import the library.</span>
