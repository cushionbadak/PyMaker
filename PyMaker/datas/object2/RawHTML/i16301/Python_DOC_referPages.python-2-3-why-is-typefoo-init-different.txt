<div class="post-text" itemprop="text">
<p>Consider the class:</p>
<pre><code>Foo(object):
    def __init__(self):
        pass
</code></pre>
<p>Executing <code>type(Foo.__init__)</code> on Python 2:</p>
<pre><code>Python 2.7.5 (default, Mar  9 2014, 22:15:05)
[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.0.68)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; class Foo(object):
...     def __init__(self):
...             pass
...
&gt;&gt;&gt; type(Foo.__init__)
&lt;type 'instancemethod'&gt;
</code></pre>
<p>Executing <code>type(Foo.__init__)</code> on Python 3:</p>
<pre><code>Python 3.4.1 (default, May 19 2014, 13:10:29)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.40)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; class Foo(object):
...     def __init__(self):
...             pass
...
&gt;&gt;&gt; type(Foo.__init__)
&lt;class 'function'&gt;
</code></pre>
<p>Why is the return of <code>type(Foo.__init__)</code> different on Python 2 and 3?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're asking <em>what</em> changed, the short version is in <a href="https://docs.python.org/3/whatsnew/3.0.html#operators-and-special-methods" rel="nofollow">What's New in 3.0</a>:</p>
<blockquote>
<p>The concept of “unbound methods” has been removed from the language. When referencing a method as a class attribute, you now get a plain function object.</p>
</blockquote>
<p>In more detail:</p>
<p>A function object is a <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow">descriptor</a> whose <code>__get__</code> returns a method. In Python 2.x, it looks like this (in pure Python pseudocode, and slightly simplified):</p>
<pre><code>class FunctionType(object):
    # other stuff
    def __get__(self, instance, cls):
        return MethodType(func=self, instance=instance, cls=cls)

class MethodType(object):
    def __init__(self, func, instance, cls):
        self.__func__, self.__instance__, self.__class__ = func, instance, cls
    def __call__(self, *args, **kwargs):
        if self.__self__ is not None:
            return self.__func__(self.__self__, *args, **kwargs)
        else:
            return self.__func__(*args, **kwargs)
</code></pre>
<p>So, when you write <code>Foo.__init__</code>, you get back the unbound method <code>MethodType(__init__, None, Foo)</code>.</p>
<p>In 3.x, it instead looks like this:</p>
<pre><code>class FunctionType(object):
    # other stuff
    def __get__(self, instance, cls):
        if instance is not None:
            return MethodType(func=self, instance=instance)
        else:
            return self

class MethodType(object):
    def __init__(self, func, instance):
        self.__func__, self.__instance__, self.__class__ = func, instance, type(instance)
    def __call__(self, *args, **kwargs):
        return self.__func__(self.__self__, *args, **kwargs)
</code></pre>
<p>For the full details, see The standard hierarchy in the reference docs for <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow">3.x</a> vs. <a href="https://docs.python.org/2/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow">2.x</a>, under "Callable Types".</p>
<hr/>
<p>If you're asking <em>why</em> it was changed… well, as far as I remember, there wasn't much discussion on this—no PEP, no long discussion on python-dev or -ideas, etc.—and it was only given that one line in the docs.</p>
<p>But the reasoning seems pretty obvious. Unbound methods aren't particularly useful; they're just extra scaffolding that provides the exact same behavior as the function they're wrapping.* They were only there in 2.2-2.7 to better model the behavior of classic classes** and/or because it seemed easier to implement that way and/or because early in the design it wasn't clear that you could implement things like <code>@classmethod</code> without it, and by the time Guido got far enough to realize that there was no problem there, it was easier to leave the design as he'd originally written it.</p>
<hr/>
<p><sub>* The CPython implementation of bound methods adds an <code>isinstance</code> check to verify that the first argument is a <code>self.__class__</code>, but that isn't clearly documented, nobody's written code that relies on it, and it isn't as helpful for debugging as you'd expect.</sub></p>
<p><sub>** If you want to know why classic classes worked the way they did, you have to dig through Guido's <a href="http://python-history.blogspot.com" rel="nofollow">Python History</a> blog—all of which is worth a read if you've got the time.</sub></p>
</div>
<span class="comment-copy">The entire object model was redesigned. Notably, the concept of unbound methods was removed. What are you doing where this matters?</span>
<span class="comment-copy">Is it not  <code>builtins.function</code>?</span>
<span class="comment-copy">@PadraicCunningham You are right. Silly copy and paste mistake. Now fixed.</span>
<span class="comment-copy">@Wooble My goal is to check whether the constructor is defined or not. I ran into this problem while converting my current code from Python 2 to Python 3.</span>
<span class="comment-copy">@Trein: Why do you need to know its type to know whether it's defined? (More to the point: If I used my a decorator that turned my <code>__init__</code> into a different kind of callable or descriptor, why should that not still count as being defined?)</span>
