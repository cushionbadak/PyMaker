<div class="post-text" itemprop="text">
<p>I have a list of dictionaries that all have the same structure within the list.  For example:</p>
<pre><code>test_data = [{'id':1, 'value':'one'}, {'id':2, 'value':'two'}, {'id':3, 'value':'three'}]
</code></pre>
<p>What I need to do is compare each of these dictionaries and return "similar" dictionaries based on a value key pair.  For example, given the key <code>value</code> and the value <code>oen</code>, I want to find all the matching dictionaries almost similar to <code>oen</code> which in this case would be <code>[{'id':1, 'value':'one'}]</code>. </p>
<p>The <a href="https://docs.python.org/3/library/difflib.html" rel="nofollow noreferrer"><code>difflib</code></a> has a function <a href="https://docs.python.org/3/library/difflib.html#difflib.get_close_matches" rel="nofollow noreferrer"><code>get_close_matches</code></a> which is close to what I need.  I'm able to extract the values of the specific key using <a href="https://stackoverflow.com/q/25148611/447015">a list comprehension</a> and then compare those values to my search:</p>
<pre><code>values = [ item['value'] for item in test_data ]
found_vals = get_close_matches('oen', values) #returns ['one']
</code></pre>
<p>What I need this to do is go one step further and tie everything back together with the original dictionary:</p>
<pre><code>In  [1]: get_close_dicts('oen', test_data, 'value')
Out [1]: [{'id':1, 'value':'one'}]
</code></pre>
<hr/>
<p>Note: The list of dictionaries is quite large, and therefore I'm hoping to be as efficient/fast as possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a reverse lookup dict prior to running get_close_dicts on your data, so that once you have a set of values returned, you can use them to lookup the relevant dict(s).</p>
<p>If you're guaranteed to have unique values across your dicts for the 'value' key, then you can do:</p>
<pre><code>reverselookup = {thedict['value']:thedict for thedict in test_data}
</code></pre>
<p>If, however, you need to handle the case where multiple dicts will have the same value for the 'value' key, then you need to map all of them (this will give you a dict where the key is the value in 'value' and the value is the list of dicts that have that value):</p>
<pre><code>from collections import defaultdict
reverselookup = defaultdict(list)
for testdict in test_data:
    reverselookup[testdict['value']].append(testdict)
</code></pre>
<p>For example, if your test data had an extra dict in it like this:</p>
<pre><code>&gt;&gt;&gt; test_data = [{'id':1, 'value':'one'}, {'id':2, 'value':'two'}, 
                 {'id':3, 'value':'three'}, {'id':4, 'value':'three'}]
</code></pre>
<p>Then the above reverse lookup construction would give you this:</p>
<pre><code>{
  "three": [
    {
      "id": 3,
      "value": "three"
    },
    {
      "id": 4,
      "value": "three"
    }
  ],
  "two": [
    {
      "id": 2,
      "value": "two"
    }
  ],
  "one": [
    {
      "id": 1,
      "value": "one"
    }
  ]
}
</code></pre>
<p>Then after you have your values, just retrieve the dicts  (then you can chain if you have the list of lists use case, no need to chain if you have the first use case):</p>
<pre><code>from itertools import chain    
chain(*[reverselookup[val] for val in found_vals])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could:</p>
<pre><code>return [d for d in test_data if get_close_matches('oen', [d['value'])]]
</code></pre>
<p>Pay attention get_close_matches could return more than one result.</p>
</div>
<div class="post-text" itemprop="text">
<p>No matter what, you're going to end up iterating through every dictionary at some point. There's no getting around that. What you can do is get all the work done in a preprocessing phase, to make your actual calls to the function immediate.</p>
<p>As ValAyal mentioned, a reverse lookup dictionary is a good idea here. I'm imagining a dictionary <code>value_dict</code>, where the <code>key</code> is the value from the first dictionary, and the <code>value</code> contains both exact and similar <code>value</code> matches. Take this example with <code>d1</code> and <code>d2</code>, which are in your list that you want to search. If</p>
<pre><code>d1 = {'id':1, 'value':'one'}
d2 = {'id':3, 'value':'oen'}
</code></pre>
<p>Then:</p>
<pre><code>value_dict["one"] = {"exact": [d1], "close": [d2]}
value_dict["oen"] = {"exact": [d2], "close": [d1]}
</code></pre>
<p>Whenever you insert a dictionary that has an already-seen value, you can immediately determine all the exact and close matches (just by looking up that value), and add to the various lists accordingly. If you have a new value that hasn't been seen before, you'd have to compare it to all the values currently in the <code>value_dict</code>. For example, if you wanted to add</p>
<pre><code>d3 = {'id':5, 'value':'one'}
</code></pre>
<p>You'd look up <code>value_dict["one"]</code> and get both the <code>exact</code> and <code>close</code> lists. These lists include all of the other <code>value_dict</code> entries you need to modify. You'd need to add to the exact matches of <code>one</code> and the close matches of <code>oen</code>; both these values you can get from the returned lists. You end up with</p>
<pre><code>value_dict["one"] = {"exact": [d1, d3], "close": [d2]}
value_dict["oen"] = {"exact": [d2], "close": [d1, d3]}
</code></pre>
<p>So once all that preprocessing is done, your function becomes simpler: something like <code>get_close_dicts(val)</code> (I don't know what the third argument does in your example) can just do <code>return value_dict[val]["exact"] + value_dict[val]["close"]</code>. You now have a function that gives an immediate answer.</p>
<p>The preprocessing step is pretty complex, but the resulting speedup in <code>get_close_dicts</code> will hopefully make up for it. I can elaborate on this more when I get back from work, if you want to know how to implement this. Hopefully this can give you a good idea of a helpful data structure, and I didn't horrendously overthink this.</p>
</div>
<span class="comment-copy">Is the list of dictionaries constant, or will it be changing often?</span>
<span class="comment-copy">constant.  But multiple comparisons against that list.</span>
<span class="comment-copy">Ok, good to know. Preprocessing may be the way to go in that case. I'm working on an answer.</span>
<span class="comment-copy">If you have more than one dict with the same value will get override the lookup. it should be fixed or else it wouldnt work</span>
<span class="comment-copy">Nice catch Acsisr, thanks</span>
<span class="comment-copy">Will this handle his close-match requirement?</span>
<span class="comment-copy">@TheSoundDefense of course.</span>
<span class="comment-copy">actually your original edit was closer to what I wanted.</span>
<span class="comment-copy">If I'm reading this right, this iterates through the list and does the comparison of each dictionary.  That's going to be very costly in processing time :/</span>
<span class="comment-copy">You did not mention that was a problem in your question :) I'll give you a more efficient one</span>
