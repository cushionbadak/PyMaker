<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/14816341/define-a-python-dictionary-with-immutable-keys-but-mutable-values">Define a python dictionary with immutable keys but mutable values</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>Is it possible to "freeze" a python dict after creation so that it's impossible to add new keys to it? It would only be possible to change existing key values.</p>
<p>If not, how do you know when you are changing an existing keyvalue pair, and when you are adding a new one?</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe something like this:</p>
<pre><code>class FreezableDict (dict):
    __frozen = False

    def freeze (self):
        self.__frozen = True

    def __setitem__ (self, key, value):
        if self.__frozen and key not in self:
            raise ValueError('Dictionary is frozen')
        super().__setitem__(key, value)
</code></pre>
<pre><code>&gt;&gt;&gt; x = FreezableDict({'foo': 'bar', 'baz': 'bla'})
&gt;&gt;&gt; x
{'baz': 'bla', 'foo': 'bar'}
&gt;&gt;&gt; x['asdf'] = 'fdsa'
&gt;&gt;&gt; x
{'asdf': 'fdsa', 'baz': 'bla', 'foo': 'bar'}
&gt;&gt;&gt; x.freeze()
&gt;&gt;&gt; x['hello'] = 'world'
Traceback (most recent call last):
  File "&lt;pyshell#20&gt;", line 1, in &lt;module&gt;
    x['hello'] = 'world'
  File "&lt;pyshell#13&gt;", line 8, in __setitem__
    raise ValueError('Dictionary is frozen')
ValueError: Dictionary is frozen
</code></pre>
<p>Note that you might want to overwrite other methods too, including <a href="https://docs.python.org/3/reference/datamodel.html#object.__delitem__" rel="nofollow"><code>__delitem__</code></a>, <a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow"><code>update</code></a>, <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow"><code>setdefault</code></a>, <a href="https://docs.python.org/3/library/stdtypes.html#dict.pop" rel="nofollow"><code>pop</code></a>, and <a href="https://docs.python.org/3/library/stdtypes.html#dict.popitem" rel="nofollow"><code>popitem</code></a>, as they can all modify the dictionary.</p>
<hr/>
<p>If you are interested in locking the dictionary completely, you could use <a href="https://docs.python.org/3/library/types.html#types.MappingProxyType" rel="nofollow"><code>types.MappingProxyType</code></a> which provides a read-only view onto your dictionary. Once you have created your normal dictionary, you can then just create a mapping proxy of it which simply does not have any of the assignment/update functionality. You can also then get rid of any reference to the original dictionary (the mapping will keep one), to prevent it from being used to update it any further:</p>
<pre><code>&gt;&gt;&gt; x = {'foo': 'bar'}
&gt;&gt;&gt; y = types.MappingProxyType(x)
&gt;&gt;&gt; y
mappingproxy({'foo': 'bar'})
&gt;&gt;&gt; x['baz'] = 'bla'
&gt;&gt;&gt; y
mappingproxy({'baz': 'bla', 'foo': 'bar'})
&gt;&gt;&gt; y['hello'] = 'world'
Traceback (most recent call last):
  File "&lt;pyshell#55&gt;", line 1, in &lt;module&gt;
    y['hello'] = 'world'
TypeError: 'mappingproxy' object does not support item assignment
&gt;&gt;&gt; del x
&gt;&gt;&gt; y
mappingproxy({'baz': 'bla', 'foo': 'bar'})
</code></pre>
<p>Or just in a single line, without ever having a reference to the original dictionary:</p>
<pre><code>&gt;&gt;&gt; x = types.MappingProxyType({'foo': 'bar', 'baz': 'bla'})
&gt;&gt;&gt; x
mappingproxy({'baz': 'bla', 'foo': 'bar'})
&gt;&gt;&gt; x['hello'] = 'world'
Traceback (most recent call last):
  File "&lt;pyshell#60&gt;", line 1, in &lt;module&gt;
    x['hello'] = 'world'
TypeError: 'mappingproxy' object does not support item assignment
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This isn't possible with a "vanilla" dict.  You'll probably want to subclass <code>collections.MutableMapping</code> . . . </p>
<p><sup>Untested code follows</sup></p>
<pre><code>class FrozenKeyDict(collections.MutableMapping):
    """Mapping which doesn't allow keys to be added/deleted.

    It does allow existing key/value pairs to be modified.
    """
    def __init__(self, *args, **kwargs):
        self._frozen = False
        self._dict = {}
        super(FrozenKeyDict, self).__init__(*args, **kwargs)
        self._frozen = True

    def __getitem__(self, key):
        return self._dict[key]

    def __setitem__(self, key, value):
        if self._frozen and key not in self._dict:
            raise KeyError('must be one of %s' % list(self))
        self._dict[key] = value

    def __delitem__(self, key):
        # modify to suit your needs ...
        raise KeyError('Removing keys not supported')

    def __iter__(self):
        return iter(self._dict)

    def __len__(self):
        return len(self._dict)
</code></pre>
</div>
<span class="comment-copy">You can check to see if a value is in the dictionary with <code>if(key in dict):...</code></span>
<span class="comment-copy">So you want to freeze only the keys, not all the dictionary, right?</span>
<span class="comment-copy">@jonrsharpe -- I'm not sure if I agree with this closing.  OP says "frozen", but doesn't really mean it since he/she really just wants to specify the keys which can be manipulated and not allow any others. . .</span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/2703599/what-would-be-a-frozen-dict" title="what would be a frozen dict">stackoverflow.com/questions/2703599/what-would-be-a-frozen-dict</a></span>
<span class="comment-copy">I don't think it's an exact duplicate of that since you want to freeze only the keys. By the way no, in the standard library there isn't such a thing. In order to know if a key is in the dictionary use @iwin suggestion: <code>print 'already in' if key in dict else 'not here'</code></span>
<span class="comment-copy">Cool idea but I don't like the class name <code>FrozenDict</code>, this to me suggests an immutable, hashable dict.</span>
<span class="comment-copy">@wim Iâ€™m open for suggestions ;)</span>
<span class="comment-copy">+1 but to win's point maybe <code>class FreezableDict</code></span>
<span class="comment-copy">Love the use of <code>types.MappingProxyType</code> - definitely +1</span>
<span class="comment-copy">Is there a MappingProxyType equivalent for 2.7 ?</span>
<span class="comment-copy">Your <code>super</code> and class name don't seem consistent :)</span>
<span class="comment-copy">@JonClements -- D'oh!  that's what happens when you can't decide how you want to name things and aren't using python3.x for your example ;-)</span>
<span class="comment-copy">I'd also probably change <code>self._dict.keys()</code> to be <code>list(self._dict)</code> so it's 3.x compatible as well</span>
<span class="comment-copy">@JonClements -- I go back and forth on that one -- People often expect <code>list(self._dict)</code> to list the <code>items</code>, not just the keys.  Maybe <code>list(self)</code> to force a little bit of thought?</span>
<span class="comment-copy">ummm, <code>list(self)</code> will be empty though as all the data is in the <code>self._dict</code> not the <code>collections.MutableMapping</code> part of the object (pick one or the other)</span>
