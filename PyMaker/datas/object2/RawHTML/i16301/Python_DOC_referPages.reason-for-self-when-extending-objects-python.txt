<div class="post-text" itemprop="text">
<p>So say I am extending an object called Frame (found in 'tkinter'), as shown below, </p>
<pre><code>class GraphRegion(Frame):

    def __init__(self, master):
        Frame.__init__(self,master)
</code></pre>
<p>Now, I know why 'master' is needed. Why does Frame.<strong>__init__</strong> need 'self'? Doesn't 'self' point to GraphRegion? What is this actually telling the object 'Frame'? Is it to create GraphRegion as a type 'Frame'?</p>
</div>
<div class="post-text" itemprop="text">
<p>Although Martjin's answer is great, I'm going to expand on it, in some, let's say, "lower level" terms.</p>
<p>Basically, whenever you create a new GraphRegion object (<code>myobject = GraphRegion(master)</code>), <code>__init__</code> is called with the new object as the first parameter (<code>self</code>), and the <code>master</code> argument as the second parameter.</p>
<p>Basically, if you do this:</p>
<pre><code>myobject = GraphRegion(master)
</code></pre>
<p><code>__init__</code> get's called like this:</p>
<pre><code>__init__(myobject, master)
</code></pre>
<p>This is because you often want to assign properties to specific instances of an object, and self lets you do that. For example, if I had a class Movie, where each instance of it had it's own title, I would use <code>self</code> like this:</p>
<pre><code>class Movie(object):
    def __init__(self, title):
        self.title = title
</code></pre>
<p>That way, every instance of <code>Movie</code> can have it's own title.</p>
<p>Now, whenever you run <code>Frame.__init__(self, master)</code>, that <code>__init__</code> function often needs to modify the specific instance of the GraphRegion class you're creating (the object you're creating), and self is that instance, so you pass it to the <code>__init__</code> method.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>Frame.__init__</code> is an <em>unbound method</em>.</p>
<p>Only looking up methods on <em>instances</em> produces a bound method, there is an instance to bind <code>self</code> <em>to</em>. Because <code>Frame.__init__</code> is unbound, you need to pass in the first argument, the instance, explicitly.</p>
<p>You cannot otherwise access that method; <code>self.__init__</code> is <code>GraphRegion.__init__</code> bound to <code>self</code>. So if you want to reuse the <code>Frame.__init__</code> version, you have to go and ask for it from <code>Frame</code> directly.</p>
<p>Essentially, when creating a new instance with, say, `GraphRegion(application), Python does this:</p>
<ol>
<li>Python creates a new empty instance for the <code>GraphRegion</code> class, let's give it a temporary name <code>new</code>.</li>
<li>Python wants to initialise the instance, so it calls <code>new.__init__(application)</code>.</li>
<li>The <code>__init__</code> attribute is looked up. It is not found on the instance itself, so Python looks at the class next.</li>
<li><code>__init__</code> is found on the class. When looking up attributes on the class, if the attribute has supports the <a href="https://docs.python.org/2/howto/descriptor.html" rel="nofollow">descriptor protocol</a>, an extra step takes place: <em>binding</em>. <code>__init__</code> is bound to the instance, producing a <em>bound method</em>.</li>
<li>Python calls the bound method, passing in <code>application</code>.</li>
<li>The bound method calls the actual <code>__init__</code> function, passing in <code>new</code> (the instance) and <code>application</code>.</li>
<li>Now, inside <code>GraphRegion.__init__</code> you have both <code>self</code> (the <code>new</code> instance) and <code>master</code> (bound to the same thing <code>application</code> was bound to), but you need to call the <code>Frame.__init__</code> method too.</li>
<li>Looking up <code>__init__</code> on <code>Frame</code> happens <em>directly on the class</em>, so the descriptor protocol has no instance to bind to. An <em>unbound method</em> is returned.</li>
<li>Calling the method, <code>Frame.__init__</code> cannot be handed a bound instance. You need to pass it in explicitly.</li>
</ol>
<p>When using new-style classes, you can also use <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow"><code>super()</code></a> to access <em>bound</em> methods on super classes. For <code>Tkinter.Frame</code> that only works in Python 3, in Python 2 the whole <code>Tkinter</code> module still uses old-style classes.</p>
<p>For Python 3, that would look like:</p>
<pre><code>class GraphRegion(Frame):
    def __init__(self, master):
        super().__init__(master)
</code></pre>
<p>But, as stated, in Python 2 when using <code>Tkinter</code>, your only option is to directly reference the unbound method retrieved directly from the <code>Frame</code> class.</p>
</div>
<span class="comment-copy">So say then I was to add a widget to it, like if I added 'self.labelYEQUALS=Label(self)' into the initialization. Let me see if I understand this. The 'self' is being passed to the 'master' variable. Passing in 'self' into that Label is passing in the current instance of GraphRegion, so therefore the master of the instance of GraphRegion is the master of the label I created. Is that right?</span>
<span class="comment-copy">Think of it like this: The <code>Frame</code> class has it's own <code>__init__</code> method, which probably looks something like this: <code>def __init__(self, master, ...)</code>. So, when you call <code>Frame.__init__(self, master)</code>, you're basically just calling that <code>__init__</code> method, with the <code>master</code> parameter being the master of your <code>GraphRegion</code> instance.. The master of the <code>Label</code> you created is your instance of <code>GraphRegion</code>, and the master of the <code>GraphRegion</code> is whatever you passed into the <code>__init__</code> function when you created it.</span>
