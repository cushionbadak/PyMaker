<div class="post-text" itemprop="text">
<p>I am aware that Python reduce only accepts a function with two arguments. However, is there a way to make more than two arguments available to the function? I don't want to make it a global variable because that would be visible for all other imports. The following snippet might help describing the problem (Please read the comments in the snippets):</p>
<pre><code># The reduce function
def apply_something(something, config):
    # Consrtuct a class object based on the truth value of some other variable.
    # some_var can be changed and is being accessed in different threads so its 
    # not safe to make it global. The reduce function is being called from 
    # inside some other function so It would be better to make 
    # some_var only accessible in the function context.

    if some_var:
        obj = Klass(some_var)
    else:
        obj = Klass()

def callee():
    # This is how I apply the reduce operation.
    reduce(apply_something, [1, 2, 3], something_initializer)

    # I want something like this:
    some_var = True  # So this can be accessed in apply_something
</code></pre>
<p>Please provide some insight into this kind of problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think what you're looking for is <a href="https://en.wikipedia.org/wiki/Partial_application" rel="noreferrer">partial function application</a>, which you can do using <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="noreferrer">functools</a>.</p>
<pre><code>def apply_something(something, config, some_var):
    pass  # ...

import functools

reduce(functools.partial(apply_something, some_var=True), 
       [1, 2, 3], something_initializer)
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; def foo(a, b, c):
...     return a + b if c else a * b

&gt;&gt;&gt; reduce(functools.partial(foo, c=True), [1,2,3,4,5], 0)
15

&gt;&gt;&gt; reduce(functools.partial(foo, c=False), [1,2,3,4,5], 1)
120
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Strictly speaking, the function passed to reduce will always be called with two arguments. However, these types of functions will often access variables in an outer scope. Since I'm unclear on your exact problem, let's implement <code>join</code> in terms of <code>reduce</code>:</p>
<pre><code>def join(joining_string, strings_to_join):
    # i.e., join('-', ['a', 'b', 'c']) -&gt; 'a-b-c'
    # Here, we need an extra piece of data in our reduce function:
    #   joining_string.

    def do_reduce(a, b):
        # Joining string comes from the outer scope:
        return a + joining_string + b

    return reduce(do_reduce, strings_to_join)
</code></pre>
<p>Also, Chris Martin's solution involving <code>partial</code> is perfectly correct as well. Applying it to the above would look like this:</p>
<pre><code># This didn't *need* to move out of join, but it can. Before, it needed
# to be in join to be able to "capture" the local variable joining_string.
def do_reduce(a, b, joiner):
    # Joining string comes from the outer scope:
    return a + joiner + b


def join(joining_string, strings_to_join):
    # i.e., join('-', ['a', 'b', 'c']) -&gt; 'a-b-c'
    # Here, we need an extra piece of data in our reduce function:
    #   joining_string.

    return reduce(
        functools.partial(do_reduce, joiner=joining_string),
        strings_to_join)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could as well just use a <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow noreferrer">lambda</a>:</p>
<pre><code>def foo(total, cur, some_var=False):
    pass  # ...

reduce(lambda total, cur: foo(total, cur, some_var=True), [1, 2, 3], init)
</code></pre>
</div>
<span class="comment-copy">It is not clear to me how this is a reduce function. Can you give an example input, and show how it would reduce that input?</span>
<span class="comment-copy">@Thanatos I have modified the question. Can you please review it?</span>
<span class="comment-copy">Thanks for the answer. I accepted the other one because he answered first.</span>
