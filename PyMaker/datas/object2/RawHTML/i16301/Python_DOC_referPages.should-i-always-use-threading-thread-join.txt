<div class="post-text" itemprop="text">
<p>I learned multithreading from <a href="http://www.tutorialspoint.com/python/python_multithreading.htm" rel="nofollow">here</a>, and I use the last example as my template for all multithreading applications. Here's the code:</p>
<pre><code>#!/usr/bin/python

import Queue
import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q
    def run(self):
        print "Starting " + self.name
        process_data(self.name, self.q)
        print "Exiting " + self.name

def process_data(threadName, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print "%s processing %s" % (threadName, data)
        else:
            queueLock.release()
        time.sleep(1)

threadList = ["Thread-1", "Thread-2", "Thread-3"]
nameList = ["One", "Two", "Three", "Four", "Five"]
queueLock = threading.Lock()
workQueue = Queue.Queue(10)
threads = []
threadID = 1

# Create new threads
for tName in threadList:
    thread = myThread(threadID, tName, workQueue)
    thread.start()
    threads.append(thread)
    threadID += 1

# Fill the queue
queueLock.acquire()
for word in nameList:
    workQueue.put(word)
queueLock.release()

# Wait for queue to empty
while not workQueue.empty():
    pass

# Notify threads it's time to exit
exitFlag = 1

#here is where i do my write to file, the last operation**

# Wait for all threads to complete
for t in threads:
    t.join()
#print "Exiting Main Thread"
</code></pre>
<p>As you can see, this example uses t.join() on all of the threads to wait for them to complete. My actual version of this is super long and a large project, but that's not the point. I'm just wondering if there are any special cases when <code>join()</code> doesn't need to be used?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I'm just wondering if there are any special cases when join() doesn't need to be used?</p>
</blockquote>
<p>The obvious case is when some <em>other</em> thread (which you're joining) is joining the thread, so you don't have to, but presumably you didn't need to be told about that one. :)</p>
<p>First, <a href="https://docs.python.org/3/library/threading.html#thread-objects" rel="nofollow"><code>daemon</code></a> threads do not need to be joined (and usually shouldn't be). You can just abandon them, and they'll be terminated abruptly at some point while your main thread is exiting. (Make sure not to do anything dangerous, like overwriting a file, in a daemon thread, of course.)</p>
<p>Second, if you don't <code>join</code> your (normal, non-daemon) threads, it's not actually documented exactly what will happen. Your main thread may wait for all of them in some arbitrary order, or it may exit and return to the shell while the threads keep working in the background, or it may kill them. But if you for some reason don't care at all which one of those happens, then don't <code>join</code>.</p>
<p>Third, on many platforms, it <em>is</em> well defined what will happen (and usually, it's "they all get <code>join</code>ed in some arbitrary order"). If, say, you're writing a program that only has to run on CPython under Red Hat Linux, and you're sure of what happens in CPython under Red Hat Linux, and your program structure makes it hard to keep track of your threads, then it's reasonable to just not <code>join</code> them (maybe with a comment) rather than rearchitecting your whole program.</p>
<p>Finally, dummy threads shouldn't be joined. But if you have dummy threads and didn't know you had dummy threads, you have bigger problems than <code>join</code>.</p>
</div>
<span class="comment-copy">I know you're getting this from example code, but the whole <code>queueLock</code>/busy loop setup this example uses is really over-complicated. It would be much better to remove <code>queueLock</code> and <code>if not workQueue.empty():</code> altogether, use <code>q.get(timeout=1)</code> instead of <code>time.sleep(1)</code>, call <a href="https://docs.python.org/2/library/queue.html#Queue.Queue.task_done" rel="nofollow noreferrer"><code>q.task_done()</code></a> at the end of every iteration of the <code>while not exitFlag:</code> loop, and call <a href="https://docs.python.org/2/library/queue.html#Queue.Queue.join" rel="nofollow noreferrer"><code>workQueue.join()</code></a> in the main thread instead of <code>while not workQueue.empty(): pass</code>.</span>
<span class="comment-copy">Are there actually any platforms that <i>don't</i> <code>join</code> all non-daemonic threads in an arbitrary order when the main thread exits?</span>
<span class="comment-copy">@dano: As far as I know, not in CPython, at least not on platforms that have threads rather than using <code>dummy</code>. But I haven't tried every implementation with every platform, or even read the code for all of the major implementations; if the docs don't guarantee it, you probably shouldn't assume it without doing one of those thingsâ€¦</span>
<span class="comment-copy">Fair enough. Though I wonder it's just a matter of it being overlooked in the docs vs. really being considered an implementation detail.</span>
<span class="comment-copy">In my example above, should I change <code>self.q</code> to just <code>q</code> since I want all threads to share the same queue (static class variable)?</span>
<span class="comment-copy">@macdonjo That's not necessary. All the threads get a reference to the same <code>Queue</code> object the way you have it now.</span>
