<div class="post-text" itemprop="text">
<p>PYTHON: </p>
<pre><code>def _siftdown(heap, startpos, pos):
    newitem = heap[pos]
    # Follow the path to the root, moving parents down until finding a place
    # newitem fits.
    while pos&gt; startpos:
        parentpos = (pos - 1)&gt;&gt; 1
        parent = heap[parentpos]
        if cmp_lt(newitem, parent):
            heap[pos] = parent
            pos = parentpos
            continue
        break
    heap[pos] = newitem
</code></pre>
<p>I just looked at heapq source code and can anyone explain what the line 6 do? What is &gt;&gt; operator and how it works?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>&gt;&gt;</code> operator means <a href="https://docs.python.org/2/library/stdtypes.html#bitwise-operations-on-integer-types" rel="nofollow">bitwise right shift</a>. Shifting (nonnegative integers) right by one bit is equivalent to dividing by two and rounding down. In other words, <code>spam &gt;&gt; 1</code> and <code>spam // 2</code> are the same.</p>
<p>So, why use <code>&gt;&gt;</code>? Some CPUs—especially older ones—can do bit-shifting orders of magnitude faster than division. Most modern C compilers will optimize <code>n / 2</code> into <code>n &gt;&gt; 1</code> whenever appropriate, but older ones wouldn't. Of course that makes almost no difference in Python, but most traditional heap implementations—the kinds you'll see in data structures textbooks—will use <code>&gt;&gt;</code>. On top of that, to some people (the kind of people who learned from those textbooks), <code>&gt;&gt;</code> in an algorithm is a good signal that it's logarithmic.</p>
<hr/>
<blockquote>
<p>so this <code>parentpos = (pos-1) &gt;&gt; 1</code> line is trying to return the index of its parent. But why minus 1? Say the current index is 4 which is the third level of the tree, and then you minus 1 get 3. And the binary number is 11, if you shift one right then it will be index 1, and its not the parent index. </p>
</blockquote>
<p>Read the top of <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow">the documentation</a>:</p>
<blockquote>
<p>This implementation uses arrays for which <code>heap[k] &lt;= heap[2*k+1]</code> and <code>heap[k] &lt;= heap[2*k+2]</code> for all <code>k</code>…</p>
</blockquote>
<p>So, for <code>k=1</code>, the children are <code>2*1+1 = 3</code> and <code>2*1+2 = 4</code>. As the next paragraph notes, this is potentially confusing:</p>
<blockquote>
<p>The API below differs from textbook heap algorithms in two aspects: (a) We use zero-based indexing. This makes the relationship between the index for a node and the indexes for its children slightly less obvious, but is more suitable since Python uses zero-based indexing.</p>
</blockquote>
<p>So, you expect that the children of <code>1</code> are <code>2</code> and <code>3</code>, but if you think of it in 0-based terms, you should be expecting that the children of <code>0</code> are <code>1</code> and <code>2</code>, and the children of <code>1</code> are <code>3</code> and <code>4</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>&gt;&gt;</code> is the right-shift operator.  It drop the rightmost bit which is the same as dividing by two and ignoring the remainder.  So that line could have been written <code>parentpos = (pos - 1)  // 2</code>.</p>
<p>Python's heaps are zero-based, so a node <em>i</em> has children at <code>2 * i + 1</code> and <code>2 * i + 2</code>.   And its parent is located at <code>(i - 1) // 2</code>.</p>
<p>What <em>siftdown</em> does is move a value upward (by swapping it with its parent) until the parent is smaller than the child.</p>
</div>
<span class="comment-copy">It's a <a href="https://docs.python.org/2/library/stdtypes.html#bitwise-operations-on-integer-types" rel="nofollow noreferrer">bitwise shift right operator</a>.</span>
<span class="comment-copy">Following up on @dano, shifting right by one bit is the same as dividing by two and rounding down. A lot of traditional C, assembly, etc. implementations of heaps use the equivalent of <code>&gt;&gt; 1</code> instead of <code>// 2</code> because on older systems you'd generally get a huge speed improvement. Needless to say, that doesn't apply in Python, but having the code look more like what you'd find in a data structures textbook can be valuable. Also, some people (usually the ones who learned C or assembly) find that <code>&gt;&gt;</code> is a good signal that something is a logarithmic algorithm.</span>
<span class="comment-copy">can I ask a follow up question. so this parentpos = (pos-1) &gt;&gt; 1 line is trying to return the index of its parent. But why minus 1? Say the current index is 4 which is the third level of the tree, and then you minus 1 get 3. And the binary number is 11, if you shift one right then it will be index 1, and its not the parent index.</span>
<span class="comment-copy">You're forgetting that Python's <code>heapq</code> is 0-based. This is easy to forget, and can lead to confusion. See my answer.</span>
