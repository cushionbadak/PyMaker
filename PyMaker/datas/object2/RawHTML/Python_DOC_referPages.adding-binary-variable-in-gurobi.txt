<div class="post-text" itemprop="text">
<p>So I want to add a binary variable <code>z</code> where <code>z[i, j] = 1</code> when the distance between <code>i</code> and <code>j</code> are less than or equal to 150 and <code>z[i, j] = 0</code> otherwise. I have a list <code>c</code> where each <code>c[i][j]</code> represents the distance between <code>i</code> and <code>j</code>. I certainly can't set up <code>z</code> as an ordinary binary variable below:</p>
<pre><code>y = m.addVars(I, J, vtype=GRB.BINARY, name="assign")
</code></pre>
<p>And I want to add constraints:</p>
<pre><code># One day mailing
m.addConstrs(
    z[i,j] &lt;= y[i,j] for i in I for j in J,
    "Serve")

# Coverage Constraint
m.addConstr(
   quicksum(h[i] * z[i, j] for i in I for j in J) &lt;= 
        0.9 * quicksum(h[i] * y[i, j] for i in I for j in J),
        "Cover")
</code></pre>
<p>where <code>h</code> is a list with integers. How do I set up <code>z</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>First you need to add <code>z</code> as a binary variable:</p>
<pre><code>z = m.addVars(I, J, vtype=GRB.BINARY, name="z")
</code></pre>
<p>Then you need constraints to ensure that <code>z[i, j] = 1</code> if and only if <code>c[i, j] &lt;= 150</code>.
One way to do this is by using indicator constraints:</p>
<pre><code>z = 1 -&gt; c &lt;= 150
z = 0 -&gt; c &gt;= 150
</code></pre>
<p>This is equivalent to</p>
<pre><code>c &gt; 150 -&gt; z = 0
c &lt; 150 -&gt; z = 1
</code></pre>
<p>You add these as follows:</p>
<pre><code>m.addConstrs((z[i, j] == 1) &gt;&gt; (c[i][j] &lt;= 150) for i in I for j in J)
m.addConstrs((z[i, j] == 0) &gt;&gt; (c[i][j] &gt;= 150) for i in I for j in J)
</code></pre>
<p>You can also model this yourself explicitly:
If you have upper and lower bounds <code>M</code> and <code>m</code> on the value of <code>c[i][j] - 150</code> (i.e., <code>M &gt;= c[i][j] - 150 &gt;= m</code> for all <code>i, j</code>), you can use the following constraints:</p>
<pre><code>M * (1-z) &gt;= c - 150
m * z &lt;= c - 150
</code></pre>
<p>If <code>c &gt; 150</code>, the right-hand-sides of both inequalities will be positive. The first one then forces <code>1 - z = 1</code> and hence <code>z = 0</code>. The second inequality will trivially be satisfied.</p>
<p>If <code>c &lt; 150</code>, the right-hand-sides are negative. The first inequality becomes trivial while the second one forces <code>z = 1</code>.</p>
<p>For <code>M</code> the maximum entry in <code>c</code> will do, for <code>m</code> you can choose <code>-150</code> if all <code>c[i][j]</code> are non-negative.</p>
<p>You add these constraints as follows:</p>
<pre><code>m.addConstrs( M * (1 - z[i, j]) &gt;= c[i][j] - 150 for i in I for j in J )
m.addConstrs( m * z[i,j] &lt;= c[i][j] - 150 for i in I for j in J )
</code></pre>
<p>Note that I neglected the case where <code>c = 150</code>. This is because for floating point numbers equalities are always only considered to be satisfied within tolerances and hence there is no easy way to distinguish between strict and non-strict inequalities. You can approximate this with an epsilon, e.g.:</p>
<pre><code>z = 0 -&gt; c &gt;= 150 + epsilon
</code></pre>
</div>
