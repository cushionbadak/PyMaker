<div class="post-text" itemprop="text">
<p>I am working on a genetic algorithm, defined a class:</p>
<pre><code>class Solution:
    def __init__(self, N=1, K=1):
        self.wi = {}
        self.loss = 0
        id = random.sample([i for i in range(N)], K)
        wi = [random.random() for _ in range(K)]
        for i in range(K):
            self.wi[id[i]] = wi[i]
</code></pre>
<p>Generated a list of obj</p>
<pre><code>population = [Solution(N, K) for _ in range(100)]
</code></pre>
<p>In my algorithm a new obj <code>C</code> will be created from the <code>population</code> list, and replace the obj in the <code>population</code> with the largest <code>loss</code></p>
<p>I tried</p>
<pre><code>largest = max(population, key = attrgetter('loss'))
largest = C
</code></pre>
<p>But the obj in the list do not change with <code>largest</code>, what can I do to make that happen?</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of calculating the maximum object, you can calculate the maximum index, and then set population for that index:</p>
<pre><code>largest<b>_i</b> = max(<b>range(len(population))</b>,key=<b>lambda i:population[i]</b>.loss)</code></pre>
<p>and then set:</p>
<pre><code>population[largest_i] = C
</code></pre>
<p>this will only scan the list once.</p>
</div>
<div class="post-text" itemprop="text">
<p>Replace</p>
<pre><code>from operator import attrgetter

largest = max(population, key = attrgetter('loss'))
largest = C
</code></pre>
<p>with</p>
<pre><code>largest = max(population, key = attrgetter('loss'))
population[population.index(largest)] = C
</code></pre>
</div>
<span class="comment-copy">You expected <code>largest = C</code> to alter the <i>list</i>? You need to find the <i>index</i>, and replace on that basis - <code>population[index_of_largest] = C</code>.</span>
<span class="comment-copy">Rather than keep finding the <code>max()</code> object, why not keep these objects in a sorted list, or better still, a <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer"><code>heapq</code></a> as a priority queue? With <a href="https://docs.python.org/3/library/heapq.html#heapq.heappushpop" rel="nofollow noreferrer"><code>heapq.heappoppush()</code></a> taking an extreme element from the list while adding another is trivial and efficient; for <code>heapq</code> you only have to invert the <code>loss</code> value.</span>
<span class="comment-copy">Simple enough, thank you @jonrsharpe</span>
<span class="comment-copy">Great idea, Thanks a lot @Martijn Pietersâ™¦</span>
<span class="comment-copy">This requires scanning <code>population</code> <i>twice</i>; once to find the largest, once to find its index. That is inefficient on larger populations.</span>
<span class="comment-copy">Does the <code>index</code> method compare two object by all attributes? What about keys and values for attribute of <code>dict</code> type like <code>Solution.wi</code>?</span>
<span class="comment-copy">compare address not value</span>
<span class="comment-copy">@QuentinLewes as you haven't implemented <code>__eq__</code>, it will only match on object identity</span>
<span class="comment-copy">thanks guys, much to learn in Python :)</span>
