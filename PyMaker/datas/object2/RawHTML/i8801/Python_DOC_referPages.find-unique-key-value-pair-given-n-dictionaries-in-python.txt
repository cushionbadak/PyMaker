<div class="post-text" itemprop="text">
<p>I would like to find an easy and/or fast way to find all <em>common</em> couple (pair: value) given N dictionaries in python. (<em>3.X would be best</em>)</p>
<p><strong>PROBLEM</strong></p>
<p>Given a set of 3 <code>dicts</code> (but it could be any <code>dict</code>, it is just for the example)</p>
<pre><code>n1 = {'a': 1, 'b': 2, 'c': 3}
n2 = {'a': 1, 'b': 4, 'c': 3, 'd': 4}
n3 = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
</code></pre>
<p>The result for common (key: values) for <code>n1</code>, <code>n2</code> and <code>n3</code>
should be:</p>
<pre><code>({'a': 1, 'c': 3})
</code></pre>
<p>And for <code>n2</code> and <code>n3</code> it should be</p>
<pre><code>({'a': 1, 'c': 3, 'd': 4})
</code></pre>
<p>I first though about using a <em>brute force</em> algorithm that will check every pair (key: value) for every dict</p>
<p>Here is a implementation using a recursive algorithm</p>
<p><strong>SOLUTION A</strong></p>
<pre><code>list_dict = [n1, n2, n3]

def finding_uniquness(ls):

    def recursion(ls, result):
        if not ls:
            return result
        result = {k: v  for k, v in result.items()  for k1, v1 in ls[0].items() if k == k1 and v == v1}
        return recursion(ls[1:], result)

    return recursion(ls[1:], ls[0])


finding_uniquness(list_dict)
# {'c': 3, 'a': 1}
</code></pre>
<p>But it is not easily understandable and the complexity is high
(I'm not sure how to calculate complexity; but since we compare all the elements on all <code>dict</code>, the complexity should be O(N²)?)</p>
<p>Then, I though about <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer"><code>Sets</code></a>. because it could naturally compare all the element</p>
<p><strong>SOLUTION B</strong> </p>
<pre><code>import functools

list_dict = [n1, n2, n3]
set_list = [set(n.items()) for n in list_dict]

functools.reduce(lambda x, y: x &amp; y, set_list)
 # {('a', 1), ('c', 3)}
</code></pre>
<p>It is so much better than the previous solution, unfortunately, when one of the <code>key</code> have a <code>list</code> as values it throws an error:</p>
<pre><code>&gt;&gt;&gt; n = {'a': [], 'b': 2, 'c': 3}
&gt;&gt;&gt; set(n.items()) 
</code></pre>
<blockquote>
<p>TypeError: unhashable type: 'list'</p>
</blockquote>
<p>My question is then double:</p>
<ul>
<li>is there any better algorithm than <strong>SOLUTION A</strong>? </li>
<li>or is there a way to avoid the <code>TypeError</code> with <strong>SOLUTION B</strong>?</li>
</ul>
<p>of course, any other remarks will be welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simpler and more efficient way:</p>
<pre><code>&gt;&gt;&gt; {k: v
     for k, v in list_dict[0].items()
     if all(k in d and d[k] == v
            for d in list_dict[1:])}
{'c': 3, 'a': 1}
</code></pre>
<p>Using an extra variable for <code>list_dict[1:]</code> might be beneficial, otherwise the short-circuiting of <code>all</code> somewhat goes to waste. Or if you don't need the list afterwards you could just pop the "master" dictionary:</p>
<pre><code>&gt;&gt;&gt; {k: v
     for k, v in list_dict.pop().items()
     if all(k in d and d[k] == v
            for d in list_dict)}
{'c': 3, 'a': 1}
</code></pre>
<p>Or using <code>get</code> with a default that cannot be in the dictionary as suggested by @Jean-FrançoisFabre:</p>
<pre><code>&gt;&gt;&gt; marker = object()
&gt;&gt;&gt; {k: v
         for k, v in list_dict.pop().items()
         if all(d.get(k, marker) == v
                for d in list_dict)}
{'c': 3, 'a': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If unhashable values are a problem you can always compute the intersection of the keys up-front by using <code>.keys()</code> and then compare only the values associated with the keys that all dictionaries have in common:</p>
<pre><code>import operator as op
from functools import reduce

common_keys = reduce(op.and_, (d.keys() for d in my_dicts))
common_items = {}
for key in common_keys:
    value = my_dicts[0][key]
    if all(d[key] == value for d in my_dicts):
        common_items[key] = value
</code></pre>
<p>This should be pretty faster than solution a, slower than solution b, but works on all inputs.</p>
</div>
<div class="post-text" itemprop="text">
<p>A batteries-included version.</p>
<p>To handle unhashable types, we use pickling; replace it with dill or json or any other predictable serialization to taste.</p>
<pre><code>import collections
import itertools
import pickle  

def findCommonPairs(dicts):
    all_pairs = itertools.chain(*[d.items() for d in dicts])
    cnt = collections.Counter(map(pickle.dumps, all_pairs))
    return [pickle.loads(pickled_pair)
            for pickled_pair, count in cnt.items()
            if count == len(dicts)]


&gt;&gt;&gt; findCommonPairs([n1, n2, n3])
[('a', 1), ('c', 3)]

&gt;&gt;&gt; findCommonPairs([{'a': [1,2], 'b': [2,3]}, {'a': [1,2]}])
[('a', [1, 2])]
</code></pre>
<p>Note that serialization only goes so far. To properly compare dicts if dicts, for instance, these dicts must be turned into (key, value) pairs <em>and sorted</em> before serialization. Any structures that reference each other may have issues (or not). Replace pickling with a custom predictable serializer if you care about these issues.</p>
</div>
<span class="comment-copy">You say "unique" several times but actually it seems you're looking for the <i>common</i> key:value pair? In other words, the one that all dictionaries share.</span>
<span class="comment-copy">which types can you have in your dictionaries? flat lists? lists of lists? because you could convert to <code>tuple</code> beforehand so the hash issue is gone.</span>
<span class="comment-copy">@roganjosh that would make <code>6</code> and <code>"6"</code> equal for instance. Maybe safer with <code>repr</code></span>
<span class="comment-copy"><b>Pro tip</b>: In python3 <code>.items()</code>, <code>.values()</code> and <code>.keys()</code> already return set-like objects,hence there's no need to do <code>set(d.items())</code>!</span>
<span class="comment-copy">BTW good question. shows research, and generate some nice answers (that's a sign :))</span>
<span class="comment-copy">that one I understand when I'm reading the code! (even at this late hour)</span>
<span class="comment-copy">nitpick: <code>k in d and d[k] == v</code> could be <code>d.get(k,marker) == v</code> where <code>marker=object()</code>, to handle the case where keys could be <code>None</code>. That would probably be even faster.</span>
<span class="comment-copy">@Jean-FrançoisFabre Ah, yeah, I thought about <code>get</code> but rejected it because of <code>None</code> and forgot about the trick you mention.</span>
<span class="comment-copy">nice. edited a little bit more for clarity. Read this marker trick on SO a couple of weeks ago.</span>
<span class="comment-copy">@Jean-FrançoisFabre do you happen to remember the question that raised it? I understand how it works in this context but I'm interested in whether the question/answer elaborates on it more.</span>
