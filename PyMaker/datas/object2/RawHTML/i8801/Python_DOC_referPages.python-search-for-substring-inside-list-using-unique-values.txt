<div class="post-text" itemprop="text">
<p>I have two lists, both containing file paths to PDFs. The first list contains PDFs that have unique file names. The second list contains the file names with the same unique file names that need to be matched up to the first list, although it is possible that there could be multiple PDFs in the second list that could be matched to the first. It is a one to many relationship from ListA to ListB. Below is an example.</p>
<p>List A: C:\FolderA\A.pdf, C:\FolderA\B.pdf, C:\FolderA\C.pdf</p>
<p>List B: C:\FolderB\A_1.pdf, C:\FolderB\B_1.pdf, C:\FolderB\C_1.pdf, C:\FolderB\C_2.pdf</p>
<p>I need to find a way to iterate through both lists and combine the PDFs by matching the unique filename. If I can find a way to iterate and match the files, then I think I can combine the PDFs on my own. Below is the code I have so far.</p>
<pre><code>folderA = C:\FolderA
ListA = []
for root, dirs, filenames in os.walk(folderA):
  for filename in filenames:
    ListA.append(str(filename))
    filepath = os.path.join(root, filename)
    ListA.append(str(filepath))

folderB: C:\FolderB
ListB = []
for root, dirs, filenames in os.walk(folderB):
  for filename in filenames:
    filepath = os.path.join(root, filename)
    folderB.append(str(filepath))

#Split ListB to file name only without the "_#" so it can be matched to the PDFs in ListA.
for pdfValue in ListB:
  pdfsplit = pdfValue.split(".")[0]
  pdfsplit1 = pdfsplit.split("\\")[-1]
  pdfsplit2 = pdfsplit1.rsplit("_", 1)[0]
  for pdfValue2 in ListA:
    if pdfsplit2 in ListA:
      #combine PDF code
</code></pre>
<p>I have verified everything works up to the last if statement. From here is when I am not sure how to go about it. I know how to search for a substring within a string, but I cannot get it to work correctly with a list. No matter how I code it, I either end up in an endless loop or it does not successfully match.</p>
<p>Any ideas on how to make this work, if it is possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>It would be better to use gather all the information together in one data structure, rather than separate lists. That should allow you to reduce your code to a single function.</p>
<p>Completely untested, but something like this should work.</p>
<pre><code>from collections import defaultdict

pdfs = defaultdict(lambda: defaultdict(list))

def find_pdfs(pdfs, folder, split=False):
    for root, dirs, filenames in os.walk(folder):
        for filename in filenames:
            basename, ext = os.path.splitext(filename)
            if ext == '.pdf':
                if split:
                    basename = basename.partition('_')[0]
                pdfs[basename][root].append(filename)

find_pdfs(pdfs, folderA)
find_pdfs(pdfs, folderB, True)
</code></pre>
<p>This should produce a data structure like this:</p>
<pre><code>pdfs = {
    'A':
        {'C:\FolderA': ['A.pdf'],
         'C:\FolderB': ['A_1.pdf']},
    'B':
        {'C:\FolderA': ['B.pdf'],
         'C:\FolderB': ['B_1.pdf']},
    'C':
        {'C:\FolderA': ['C.pdf'],
         'C:\FolderB': ['C_1.pdf', 'C_2.pdf']},
    }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think what you want to do is create a <a href="https://docs.python.org/3/library/collections.html?highlight=collections.defaultdict#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> and set it up to hold lists of matching names.</p>
<pre><code>import collections
matching_files = collections.defaultdict(list)
</code></pre>
<p>You can then strip the filenames in folder B down to base names, and put the paths into the dict:</p>
<pre><code>matching_files[pdfsplit2].append(pdfValue)
</code></pre>
<p>Now you have a list of pdf files from folder B, grouped by base name. Go back to folder A and do the same thing (split off the path and extension, use that for the key, add the full path to the list). You'll have lists, which have files sharing a common base name.</p>
<pre><code>for key,file_list in matching_files.items(): #use .iteritems() for py-2.x
    print("Files with base name '%s':"%key)
    print(' ', '\n  '.join(file_list))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>To compare the two files names, rather than split along the '_', you should try the str.startwith() method : </li>
</ul>
<p>A.startwith(B) returns <code>True</code> if the string A beginning is the string B.</p>
<p>In your case, your code would be : </p>
<pre><code>match={}                            #the dictionary where you will stock the matching names

for pdfValue in ListA:
    match[pdfValue]=[]              # To create an entry in the dictionary with the wanted keyword
    A=pdfValue.split("\\")[-1]      #You want just the filename part

    for pdfValue2 in ListB:
        B=pdfValue2.split("\\")[-1]

        if B.startswith(A):        # Then B has the same unique namefile than A

            match[pdfValue].append(pdfValue2)  #so you associate it with A in the dictionnary
</code></pre>
<p>I hope it works for you</p>
</div>
<div class="post-text" itemprop="text">
<p>One more solution</p>
<pre><code>lista = ['C:\FolderA\A.pdf', 'C:\FolderA\B.pdf', 'C:\FolderA\C.pdf']
listb = ['C:\FolderB\A_1.pdf', 'C:\FolderB\B_1.pdf', 'C:\FolderB\C_1.pdf', 'C:\FolderB\C_2.pdf']

# get the filenames for folder a and folder b
lista_filenames =  [l.split('\\')[-1].split('.')[0] for l in lista]
listb_filenames =  [l.split('\\')[-1].split('.')[0] for l in listb]

# create a dictionary to store lists of mappings
from collections import defaultdict
data_structure = defaultdict(list)

for i in lista_filenames:
     for j in listb_filenames:
         if i in j:
            data_structure['C:\\FolderA\\' + i +'.pdf'].append('C:\\FolderB\\' + j +'.pdf') 

# this is how the mapping dictionary looks like
print data_structure
</code></pre>
<p>results in :</p>
<pre><code>defaultdict(&lt;type 'list'&gt;, {'C:\\FolderA\\C.pdf': ['C:\\FolderB\\C_1.pdf', 'C:\\FolderB\\C_2.pdf'], 'C:\\FolderA\\A.pdf': ['C:\\FolderB\\A_1.pdf'], 'C:\\FolderA\\B.pdf': ['C:\\FolderB\\B_1.pdf']})
</code></pre>
</div>
