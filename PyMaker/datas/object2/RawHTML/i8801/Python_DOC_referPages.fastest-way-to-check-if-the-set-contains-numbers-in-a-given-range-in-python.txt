<div class="post-text" itemprop="text">
<p>What is the fastest way to check if a set contains at least one number within a given range? </p>
<p>For example <code>setA = set(1,4,7,9,10)</code>, <code>lowerRange=6</code>, <code>upperRange=8</code>, will return True because of 7.</p>
<p>Currently I am using:</p>
<pre><code>filtered = filter(lambda x: lowerRange&lt;=x&lt;=upperRange,setA)
</code></pre>
<p>Then if filtered is not empty, returns a True.</p>
<p>Assuming that setA can be a very large set, is this the optimal solution?  Or is this iterating through the entire setA?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since the membership chick is approximately O(1) for sets you can use a generator expression within <code>any()</code> built-in function:</p>
<pre><code>rng = range(6, 9)
any(i in setA for i in rng)
</code></pre>
<p>Note that for a short range you'll give a better performance with <code>set.intersection()</code>:</p>
<pre><code>In [2]: a = {1,4,7,9,10}

In [3]: rng = range(6, 9)

In [8]: %timeit bool(a.intersection(rng))
1000000 loops, best of 3: 344 ns per loop

In [9]: %timeit any(i in a for i in rng)
1000000 loops, best of 3: 620 ns per loop
</code></pre>
<p>But in this case for longer ranges you'd definitely go with <code>any()</code>:</p>
<pre><code>In [10]: rng = range(6, 9000)

In [11]: %timeit any(i in a for i in rng)
1000000 loops, best of 3: 620 ns per loop

In [12]: %timeit bool(a.intersection(rng))
1000 loops, best of 3: 233 Âµs per loop
</code></pre>
<p>And note that the reason that <code>any()</code> performs better is because it returns True right after it encounter an item that exist in your set (based on our membership condition) an since the number 8 is at the beginning of the range it makes the <code>any()</code> per forms so fast. Also as mentioned in comment as a more pythonic way for checking the validity of the intersection of an iterable within a set you can use <code>isdisjoint()</code> method. Here is a benchmark with this method for small rage:</p>
<pre><code>In [26]: %timeit not a.isdisjoint(rng)
1000000 loops, best of 3: 153 ns per loop

In [27]: %timeit any(i in a for i in rng)
1000000 loops, best of 3: 609 ns per loop
</code></pre>
<p>And here is a benchmark that makes the <code>any()</code> checks the membership for all the numbers which shows that <code>isdisjoint()</code> performs so better:</p>
<pre><code>In [29]: rng = range(8, 1000)

In [30]: %timeit any(i in a for i in rng)
1000000 loops, best of 3: 595 ns per loop

In [31]: %timeit not a.isdisjoint(rng)
10000000 loops, best of 3: 142 ns per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The fastest way is to work with a sorted list or tuple instead of a set.  That way you can do the range searches using the <a href="https://docs.python.org/3/library/bisect.html#module-bisect" rel="nofollow noreferrer">bisect module</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unless you plan to use those values, using the <code>filter</code> function is unnecessary, because it stores data that you won't end up using. It also keeps going even after it finds one that fits the criteria, slowing you down quite a bit.</p>
<p>My solution would have been to write and use the following function.</p>
<pre><code>def check(list, lower, upper):
    for i in list:
        if i &gt;= lower and i &lt;= upper:
            return True
    return False
</code></pre>
<p>Like with @Kasramvd's answer, and your idea, this is the brute-force search (O(n) solution). That's impossible to beat unless there are some constraints on the data beforehand, like that it has to be sorted. </p>
</div>
<span class="comment-copy">Are they always ints?</span>
<span class="comment-copy">Yes, always int</span>
<span class="comment-copy">It should be <code>range(6, 9)</code>. The question specifies inclusiveness on both ends.</span>
<span class="comment-copy">@SarcasticSully It's not in OP's explanations. But yeah it's in the code! just fixed.</span>
<span class="comment-copy"><code>isdisjoint</code> beats <code>intersection</code> for this purpose, since it doesn't need to build a whole result set: <code>not a.isdisjoint(rng)</code></span>
<span class="comment-copy">I'm fairly certain this has an inherent bias in your test methodology: <code>any()</code> will return immediately once it finds a single example... in this case, it only processes 2 numbers(6, 7) before returning, which is why it is beating intersection. If the range was not so strongly biased in it's favor, <code>intersection</code> will probably be more competitive.</span>
<span class="comment-copy">@TemporalWolf Yes, in fact I was about the add a more comprehensive explanation about that point too. Thanks for note!</span>
<span class="comment-copy">More Pythonic: <code>lower &lt;= i &lt;= upper</code>.</span>
