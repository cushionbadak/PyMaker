<div class="post-text" itemprop="text">
<p>The following minimal program reproduces the problem.</p>
<pre><code>import asyncio
import signal

class A:
    def __init__(self):
        self._event_loop = asyncio.new_event_loop()

    def run(self):
        print('starting event loop')
        self._event_loop.run_forever()
        print('event loop has stopped')

    def stop(self):
        print('stopping event loop')
        self._event_loop.stop()


if __name__ == '__main__':
    a = A()

    def handle_term(*args):
        a.stop()

    signal.signal(signal.SIGTERM, handle_term)
    a.run()
</code></pre>
<p>If you run the program and send a SIGTERM to the process, the print statement in line 16 (stopping event loop) is called but the programm does not terminate and the print statement in line 13 (event loop has stopped) is never called. So it seems that the event loop is never stopped and <code>self._event_loop.run_forever()</code> blocks indefinitely.</p>
<p>Why is this?</p>
<p>Note: A modified version of the program, where <code>a.stop()</code> is not called by a signal handler but by a seperate thread with a delay, works as expected. How can it make a difference how <code>a.stop()</code> is called?</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of <code>signal.signal()</code> use <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.add_signal_handler" rel="nofollow noreferrer"><code>loop.add_signal_handler()</code></a>:</p>
<pre><code>import asyncio
import signal

import os


class A:
    def __init__(self):
        self.loop = asyncio.new_event_loop()
        self.loop.add_signal_handler(signal.SIGTERM, self.stop)

    def stop(self):
        print('stopping')
        self.loop.stop()

    def run(self, close=True):
        print('starting loop')
        try:
            self.loop.run_forever()
            print('loop stopped')
        finally:
            if close:
                self.loop.close()


if __name__ == '__main__':
    print("to stop run:\nkill -TERM {}".format(os.getpid()))
    a = A()
    a.run()
</code></pre>
</div>
<span class="comment-copy">That is how I solved it for now. But I don't like it. It couples the logic that runs inside the event loop of class A with how it is stopped. Architecturally it would be much cleaner to seperate these two and let A's event loop be stopped from outside of A.  Also: I am still curious why my example does not work. From what I understand, it should work, right?</span>
<span class="comment-copy">You can use <code>faulthandler.dump_traceback()</code> to see your program is stuck in <code>select()</code>.  Unix requires using <a href="https://docs.python.org/3.4/library/signal.html#signal.set_wakeup_fd" rel="nofollow noreferrer"><code>signal.set_wakeup_fd()</code></a> to wake up poll/select.</span>
