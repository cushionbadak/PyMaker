<div class="post-text" itemprop="text">
<p>With Python 3:</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; d1 = OrderedDict([('foo', 'bar')])
&gt;&gt;&gt; d2 = OrderedDict([('foo', 'bar')])
</code></pre>
<p>I wanted to check for equality:</p>
<pre><code>&gt;&gt;&gt; d1 == d2
True
&gt;&gt;&gt; d1.keys() == d2.keys()
True
</code></pre>
<p>But:</p>
<pre><code>&gt;&gt;&gt; d1.values() == d2.values()
False
</code></pre>
<p>Do you know why values are not equal?</p>
<p>I've tested this with Python 3.4 and 3.5.</p>
<hr/>
<p><em>Following this question, I posted on the Python-Ideas mailing list to have additional details:</em></p>
<p><em><a href="https://mail.python.org/pipermail/python-ideas/2015-December/037472.html" rel="noreferrer">https://mail.python.org/pipermail/python-ideas/2015-December/037472.html</a></em></p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, <code>dict.keys()</code> and <code>dict.values()</code> return special iterable classes - respectively a <code>collections.abc.KeysView</code> and a <code>collections.abc.ValuesView</code>. The first one inherit it's <code>__eq__</code> method from <code>set</code>, the second uses the default <code>object.__eq__</code> which tests on object identity. </p>
</div>
<div class="post-text" itemprop="text">
<p>In python3, <code>d1.values()</code> and <code>d2.values()</code> are <code>collections.abc.ValuesView</code> objects:</p>
<pre><code>&gt;&gt;&gt; d1.values()
ValuesView(OrderedDict([('foo', 'bar')]))
</code></pre>
<p>Don't compare them as an  object, c
onvert them to lists and then compare them:</p>
<pre><code>&gt;&gt;&gt; list(d1.values()) == list(d2.values())
True
</code></pre>
<hr/>
<p>Investigating why it works for comparing keys, in <code>_collections_abc.py</code> of CPython, <code>KeysView</code> is inheriting from <code>Set</code> while <code>ValuesView</code> does not:</p>
<pre><code>class KeysView(MappingView, Set):

class ValuesView(MappingView):
</code></pre>
<ul>
<li><p>Tracing for <code>__eq__</code> in <code>ValuesView</code> and its parents: </p>
<p><code>MappingView ==&gt; Sized ==&gt; ABCMeta ==&gt; type ==&gt; object</code>.</p>
<p><code>__eq__</code> is implemented only in <code>object</code> and not overridden. </p></li>
<li><p>In the other hand, <code>KeysView</code> inherits <code>__eq__</code> directly from <code>Set</code>.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately, both current answers don't address why this is but focus on how this is done. That mailing list discussion was amazing, so I'll sum things up:</p>
<p>For <code>odict.keys</code>/<code>dict.keys</code> and <code>odict.items</code>/<code>dict.items</code>: </p>
<ul>
<li><code>odict.keys</code> (<a href="https://github.com/python/cpython/blob/72eb1a22c7ea1a6e22e6892a9c68e9d0533aa27a/Objects/odictobject.c#L2089" rel="nofollow noreferrer">subclass of <code>dict.keys</code></a>) supports comparison due to its conformance to <code>collections.abc.Set</code> (it's a set-like object). This is possible due to the fact that <code>keys</code> inside a dictionary (ordered or not) are guaranteed to be unique and hashable.</li>
<li><p><code>odict.items</code> (<a href="https://github.com/python/cpython/blob/72eb1a22c7ea1a6e22e6892a9c68e9d0533aa27a/Objects/odictobject.c#L2156" rel="nofollow noreferrer">subclass of <code>dict.items</code></a>) also supports comparison for the same reason as <code>.keys</code> does. <code>itemsview</code> is allowed to do this since it raises the appropriate error if one of the <code>item</code>s (specifically, the second element representing the value) is not hashable, uniqueness is guaranteed, though (due to <code>keys</code> being unique):</p>
<pre><code>&gt;&gt;&gt; od = OrderedDict({'a': []})
&gt;&gt;&gt; set() &amp; od.items()
TypeErrorTraceback (most recent call last)
&lt;ipython-input-41-a5ec053d0eda&gt; in &lt;module&gt;()
----&gt; 1 set() &amp; od.items()

TypeError: unhashable type: 'list'
</code></pre>
<p>For both these views <code>keys</code>, <code>items</code>, the comparison uses a simple function called <a href="https://github.com/python/cpython/blob/72eb1a22c7ea1a6e22e6892a9c68e9d0533aa27a/Objects/dictobject.c#L3734" rel="nofollow noreferrer"><code>all_contained_in</code></a> (pretty readable) that uses the objects <code>__contain__</code> method to check for membership of the elements in the views involved.</p></li>
</ul>
<p>Now, about <code>odict.values</code>/<code>dict.values</code>:</p>
<ul>
<li><p>As noticed, <code>odict.values</code> (<a href="https://github.com/python/cpython/blob/72eb1a22c7ea1a6e22e6892a9c68e9d0533aa27a/Objects/odictobject.c#L2223" rel="nofollow noreferrer">subclass of <code>dict.values</code></a> [shocker]) <em>doesn't</em> compare like a set-like object. This is because the <code>values</code> of a <code>valuesview</code> cannot be represented as a set, the reasons are two-fold:</p>
<ol>
<li>Most importantly, the view might contain duplicates which cannot be dropped.</li>
<li>The view might contain non-hashable objects (which, on it's own, isn't sufficient to not treat the view as set-like).</li>
</ol></li>
</ul>
<p></p>
<p>As stated in a comment by <a href="https://stackoverflow.com/users/2357112/user2357112">@user2357112</a> and by <a href="https://stackoverflow.com/users/908494/abarnert">@abarnett</a> in the mailing list, <code>odict.values</code>/<code>dict.values</code> is a multiset, a generalization of sets that allows multiple instances of it's elements. 
Trying to compare these is not as trivial as comparing <code>keys</code> or <code>items</code> due to the inherent duplication, the ordering and the fact that you probably need to take into consideration the keys that correspond to those values. Should <code>dict_values</code> that look like this: </p>
<pre><code>&gt;&gt;&gt; {1:1, 2:1, 3:2}.values()
dict_values([1, 1, 2])
&gt;&gt;&gt; {1:1, 2:1, 10:2}.values()
dict_values([1, 1, 2])
</code></pre>
<p>actually be equal even though the values that correspond to the keys isn't the same? Maybe? Maybe not? It isn't straight-forward either way and will lead to inevitable confusion.</p>
<p>The point to be made though is that it isn't trivial to compare these as is with <code>keys</code> and <code>items</code>, to sum up, with another comment from @abarnett on <a href="https://mail.python.org/pipermail/python-ideas/2015-December/037496.html" rel="nofollow noreferrer">the mailing list</a>:</p>
<blockquote>
<p>If you're thinking we could define what multisets should do, despite not having a standard multiset type or an ABC for them, and apply that to values views, the next question is how to do that in better than quadratic time for non-hashable values. (And you can't assume ordering here, either.) Would having a values view hang for 30 seconds and then come back with the answer you intuitively wanted instead of giving the wrong answer in 20 millis be an improvement? (Either way, you're going to learn the same lesson: don't compare values views. I'd rather learn that in 20 millis.) </p>
</blockquote>
</div>
<span class="comment-copy">Works good on Python 2.7.6</span>
<span class="comment-copy"><b><code>dict.values</code></b> returns a <a href="https://docs.python.org/3/glossary.html#term-dictionary-view" rel="nofollow noreferrer"><b><code>ValuesView</code></b></a></span>
<span class="comment-copy">Seems like a defect to me. Do you happen to know whether the decision not to override <code>__eq__</code> was intentional or merely an oversight?</span>
<span class="comment-copy">@RobKennedy not the sligthtest idea - but Python is free software so nothing prevents you from submitting a patch ;)</span>
<span class="comment-copy">I guess the decision not to override <code>object.__eq__</code> makes sense because it's ambiguous exactly what you're comparing. Should two <code>ValueView</code>s be equal if they contain the same values in any order, or not? Should this be independent of the keys, or not? Depending on what you want, it's much clearer to compare <code>.items()</code> or put the values in a list or set and compare those instead.</span>
<span class="comment-copy">While this may indeed be the answer, this is a deeply unsatisfying answer...</span>
<span class="comment-copy">@wim: Even if that seems like the one obvious way to you, making that decision for <code>OrderedDict</code> puts pressure on <code>dict</code> to have an <code>__eq__</code> for its <code>values</code>, and <code>dict</code> can't really do that. A dict's ValuesView is a multiset of not-necessarily-hashable objects, and there's no efficient way to compare such multisets. Also, an order-sensitive <code>values</code> comparison doesn't fit nicely with the <a href="http://ideone.com/KfA9mY" rel="nofollow noreferrer">existing order-insensitive <code>OrderedDict.keys</code> comparison</a>, and making <code>keys</code> comparisons order-sensitive could break things.</span>
<span class="comment-copy"><code>values()</code> returns an iterator on python 3, and a list in python 2.7</span>
<span class="comment-copy">@bgusach it's not an iterator, but it is iterable. See <a href="https://docs.python.org/3/library/stdtypes.html#dict-views" rel="nofollow noreferrer">view objects</a>.</span>
<span class="comment-copy">@PeterWood, I thought <code>values</code> was the equivalent of <code>itervalues</code>, but you are right, they aren't.</span>
