<div class="post-text" itemprop="text">
<p>I have a little bit of experience with promises in Javascript. I am quite experienced with Python, but new to its coroutines, and there is a bit that I just fail to understand: where does the asynchronicity kick in?</p>
<p>Let's consider the following minimal example:</p>
<pre><code>async def gen():
    await something
    return 42
</code></pre>
<p>As I understand it, <code>await something</code> puts execution of our function aside and lets the main program run other bits. At some point <code>something</code> has a new result and <code>gen</code> will have a result soon after.</p>
<p>If <code>gen</code> and <code>something</code> are coroutines, then by all internet wisdom they are generators. And the only way to know when a generator has a new item available, afaik, is by polling it: <code>x=gen(); next(x)</code>. But this is blocking! How does the scheduler "know" when <code>x</code> has a result? The answer can't be "when <code>something</code> has a result" because <code>something</code> must be a generator, too (for it is a coroutine). And this argument applies recursively.</p>
<p>I can't get past this idea that at some point the process will just have to sit and wait synchronously.</p>
</div>
<div class="post-text" itemprop="text">
<p>The secret sauce here is the <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code> module</a>. Your <code>something</code> object has to be an awaitable object itself, and either depend on more awaitable objects, or must yield from a <a href="https://docs.python.org/3/library/asyncio-eventloop.html#futures" rel="nofollow noreferrer"><code>Future</code> object</a>. </p>
<p>For example, the <a href="https://github.com/python/cpython/blob/master/Lib/asyncio/tasks.py#L462-L478" rel="nofollow noreferrer"><code>asyncio.sleep()</code> coroutine</a> yields a <code>Future</code>:</p>
<pre><code>@coroutine
def sleep(delay, result=None, *, loop=None):
    """Coroutine that completes after a given time (in seconds)."""
    if delay == 0:
        yield
        return result

    if loop is None:
        loop = events.get_event_loop()
    future = loop.create_future()
    h = future._loop.call_later(delay,
                                futures._set_result_unless_cancelled,
                                future, result)
    try:
        return (yield from future)
    finally:
        h.cancel()
</code></pre>
<p>(The syntax here uses the older generator syntax, to remain backwards compatible with older Python 3 releases).</p>
<p>Note that a future doesn't use <code>await</code> or <code>yield from</code>; they simply use <a href="https://github.com/python/cpython/blob/74382a3f175ac285cc924a73fd758e8dc3cc41bb/Lib/asyncio/futures.py#L260" rel="nofollow noreferrer"><code>yield self</code> until some condition is met</a>. In the above <code>async.sleep()</code> coroutine, that condition is met when a result has been produced (in the <code>async.sleep()</code> code above, via the <code>futures._set_result_unless_cancelled()</code> function called after a delay).</p>
<p>An event loop then keeps pulling in the next 'result' from each pending future it manages (polling them efficiently) until the future signals it is done (by raising a <code>StopIteration</code> exception holding the results; <code>return</code> from a co-routine would do that, for example). At that point the coroutine that yielded the future can be signalled to continue (either by sending the future result, or by throwing an exception if the future raised anything other than <code>StopIteration</code>).</p>
<p>So for your example, the loop will kick off your <code>gen()</code> coroutine, and <code>await something</code> then (directly or indirectly) yields a future. That future is polled until it raises <code>StopIteration</code> (signalling it is done) or raises some other exception. If the future is done, <code>coroutine.send(result)</code> is executed, allowing it to then advance to the <code>return 42</code> line, triggering a new <code>StopIteration</code> exception with that value, allowing a calling coroutine awaiting on <code>gen()</code> to continue, etc.</p>
</div>
<span class="comment-copy">So what you're saying is, a coroutine is not always a generator, but can instead yield a <code>Future</code> (assuming we choose to use <code>asyncio</code>)? And this <code>Future</code> is the one at the end of the recursion, that knows how to tie in to the async framework? So the generator coroutine is actually not async at all?</span>
<span class="comment-copy">@Paul: coroutines are just generators that know how to handle thrown exceptions, really. With nicer syntax. It is always up to the developer to ensure that a coroutine is really cooperative and allows itself to be used in an async context. If you write a <code>async def</code> coroutine that just blocks, then that's your own fault. :-)</span>
<span class="comment-copy">@Paul: this is true for any coroutine framework in any language. Java has no <code>async</code> or <code>await</code> syntax, but does have <code>Futures</code>. C# and JS have the same coroutine features, and there too is the whole premise of async cooperation based on futures and an event loop.</span>
<span class="comment-copy">My misunderstanding was that I thought <code>asyncio</code> was the one responsible for not blocking while a coroutine needs to wait, but that is actually the coroutine's responsibility. Also I didn't realise how coroutines ultimately need to reach out back to the event loop to stay asynchronous. I always regarded the <code>asyncio.sleep</code> line in example code as purely for demonstration purposes, but missed the point that it is important here to actually tie in with the event loop. Now I see. I think.</span>
<span class="comment-copy">@Paul: and remember that the <i>co</i> in <i>coroutine</i> stands for <i>cooperative</i>. Coroutines are ultimately responsible for cooperating with other coroutines. Rather than switching arbitrarily (like threads do), you switch at points where it suits the coroutine.</span>
