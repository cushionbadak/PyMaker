<div class="post-text" itemprop="text">
<p>I want program that outputs a list consisting of the longest streak of consecutive occurrences of the same value in L in PYTHON.</p>
<p>In case multiple values have the equal number of streak, smallest value is chosen.</p>
<p>Input:</p>
<pre><code>L=[2,4,3,3,3,5,6,7,7,7]
</code></pre>
<p>Output:</p>
<pre><code>R=[3,3,3]
</code></pre>
<p>Code</p>
<pre><code>R = L
i=0
for i in range(len(L)-1):
    if L[i]==L[i+1]:
    R=[L[i],L[i+1]]
    i=i+1
    else:
    R=[]
print('\nThe longest streak of the same value is:')
print('  ', R)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a></p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; longest = max((list(g) for _, g in groupby(L)), key=len)
&gt;&gt;&gt; longest
[3, 3, 3]
</code></pre>
<p>There are actually two groups of 3, so I presume you want the first of such groups.</p>
<p><code>groupby</code> returns two things. The grouped element and the group, we only care about the later. So we make a list of just the grouper elements, use <code>list</code> to convert them from grouper objects, which have no <code>len</code> function. </p>
<p>Now we can use <code>max</code> to determine the largest element, returning the first such element in the event of a tie. We need to use a <code>key</code> function as using <code>max</code> on lists themselves has no meaning. So pass <code>len</code> as the <code>key</code> function used to determine <code>max</code>ness.</p>
<p>I notice you ask that the item with the lowest value is selected, rather than the first in the list. This complicates matter a little. Although your code makes no effort to account for it, heres a solution. </p>
<p>Instead now you have to create a list just of the elements that have the longest length <code>[[3,3,3], [7,7,7]]</code> and select the value with the lower value.</p>
<p>Trying to do this in a one liner might be a bit much.</p>
<pre><code>from itertools import groupby
from operator import itemgetter
L=[2,4,3,3,3,5,6,7,7,7]

# list of groupers, converted to list
groups = [list(g) for _, g in groupby(L)]

# read longest value across all groups
longest = max(map(len, groups))

# filter any smaller groups from the list
# and find the entry with the lowest (min) number in it
result = min(filter(lambda g: len(g) == longest, groups), key=itemgetter(0))

print(result)
</code></pre>
<p>Try switching the final <code>min</code> call for a <code>max</code> and see that a different entry is chosen.</p>
<p>Or more simply, as pointed out by @ShadowRanger in comments, you can return a tuple of length and negated value from the key function to favour lower values in the event of a tie in length. To favour larger values, remove the negation.</p>
<pre><code>longest = max((list(g) for _, g in groupby(L)), key=lambda g: (len(g), -g[0]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Below python code will do the same. @Paul's version is more Pythonic</p>
<pre><code>lst = [2,4,3,3,3,5,6,7,7,7, 7]
n = len(lst)

# Store overall max consecutive length
max_len = 1
num = lst[0]

#  Store current consecutive length
cur_len = 1
cur_num = lst[0]

for i in range(1, n):
   if lst[i] == cur_num:
     cur_len += 1
   elif cur_len &gt; max_len:
     max_len = cur_len
     num = cur_num   
     cur_num = lst[i]
     cur_len = 1
   else:
     cur_num = lst[i]


if cur_len &gt; max_len:
    num = lst[-1]
    max_len = cur_len


print [num]*max_len
</code></pre>
</div>
<span class="comment-copy">What does Xcode have to do with this?</span>
<span class="comment-copy">Sorry @ShawnicHedgehog</span>
<span class="comment-copy">What have you tried? Post that, and what didn't work, and we'll help.</span>
<span class="comment-copy">Could you provide code that you have tried? This isn't a forum for us to do homework for you.</span>
<span class="comment-copy">@ShawnicHedgehog I have pasted code</span>
<span class="comment-copy">The "push it all to C" version to eliminate byte code execution per item to speed it up when given large inputs: <code>max(map(list, map(operator.itemgetter(1), itertools.groupby(it))), key=len)</code></span>
<span class="comment-copy">FYI, for the numeric case, making it return the smallest value of ties for max length is still easy. Just change the <code>key</code> to <code>lambda x: (len(x), -x[0])</code>. Loses the "wholly C" aspect of my all C version, but what can you do?</span>
<span class="comment-copy">Good point that actually makes a lot of sense.</span>
