<div class="post-text" itemprop="text">
<p>I am wondering if it is possible to prevent the user from invoking the methods of a parent class when using the child class. At the same time, I do wish that these methods be available to the methods of the child class themselves.</p>
<p>For instance, suppose I have an implementation of a linked list. I then base a stack ADT implementation on it by inheriting (not sure if it is good design ...). Hence, I wish to "hide" the methods of LinkedList class from the user of the Stack class.</p>
<p>LinkedList:</p>
<pre><code>class LinkedList(object):
    class Node(object):
        """
        Inner class of LinkedList. Contains a blueprint for a node of the LinkedList
        """
        def __init__(self, v, n=None):
            """
            Initializes a List node with payload v and link n
            """
            self.value=v
            self.next=n

    def __init__(self):
        """
        Initializes a LinkedList and sets list head to None
        """
        self.head=None

    def insert(self, v):
        """
        Adds an item with payload v to beginning of the list
        in O(1) time 
        """
        Node = self.Node(v, self.head)
        self.head = Node
        print("Added item: ", Node.value, "self.head: ", self.head.value)

    def size(self):
        """
        Returns the current size of the list. O(n), linear time
        """
        current = self.head
        count = 0
        while current:
            count += 1
            current = current.next
        return count

    def search(self, v):
        """
        Searches the list for a node with payload v. Returns the node object or None if not found. Time complexity is O(n) in worst case.
        """
        current = self.head
        found = False
        while current and not found:
            if current.value == v:
                found = True
            else:
                current = current.next
        if not current:
            return None
        return current

    def delete(self, v):
        """
        Searches the list for a node with payload v. Returns the node object or None if not found. Time complexity is O(n) in worst case.
        """
        current = self.head
        previous = None
        found = False
        while current and not found:
            if current.value == v:
                found = True
            else:
                previous = current
                current = current.next
        # nothing found, return None
        if not current:
            return None
        # the case where first item is being deleted
        if not previous:
            self.head = current.next
        # item from inside of the list is being deleted    
        else:
            previous.next = current.next

        return current

    def __str__(self):
        """
        Prints the current list in the form of a Python list            
        """
        current = self.head
        toPrint = []
        while current != None:
            toPrint.append(current.value)
            current = current.next
        return str(toPrint)
</code></pre>
<p>Stack:</p>
<pre><code>from PythonADT.lists import LinkedList

class Stack(LinkedList):
    def __init__(self):
        LinkedList.__init__(self)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here are the official syntax to declare protected and private method in a class.</p>
<ol>
<li>The protected method declared in the parent class will be callable from a child class. </li>
<li>The private method declared in the parent class will be hidden from a child class.</li>
</ol>
<p>The raised Exception is:</p>
<blockquote>
<p><code># AttributeError: '&lt;ChildClass&gt;' object has no attribute '__&lt;private_function&gt;'</code></p>
</blockquote>
<p><strong>Step 1</strong> - declare both private and protected method in the <code>class Parent</code>.</p>
<pre><code>class Parent(object):
    # a private method starts by 2 '_'
    def __parent_private(self):
        print('inside __parent_private()')

    # a protected method starts by 1 '_'
    def _parent_protected(self):
        print('inside _parent_protected()')
</code></pre>
<p><strong>Step 2</strong> - declare function to call the both function from a <code>class Child</code>.</p>
<pre><code>class Child(Parent):

    def call__parent_private(self):
        self.__parent_private()

    def call_parent_protected(self):
        self._parent_protected()
</code></pre>
<p><strong>Step 3</strong> - create an instance of <code>class Child</code> to check private and protected accesses.</p>
<pre><code>myChild = Child()
</code></pre>
<blockquote>
<p>Check of protected method from the Child class ==&gt; Access is allowed</p>
</blockquote>
<pre><code># internal access of protected method
myChild.call_parent_protected()
</code></pre>
<p>Output: "<code>inside _parent_protected()</code>"</p>
<pre><code># direct access of protected method
myChild._parent_protected()
</code></pre>
<p>Output: "<code>inside _parent_protected()</code>"</p>
<blockquote>
<p>Check of private method from the Child class ==&gt; Access is denied</p>
</blockquote>
<pre><code># internal access of private method
myChild.call__parent_private()
</code></pre>
<p>Error: "<code>AttributeError: 'Child' object has no attribute '_Child__parent_private'</code>"</p>
<pre><code># direct access of private method
myChild.__parent_private()
</code></pre>
<p>Error: "<code>AttributeError: 'Child' object has no attribute '__parent_private'</code>"</p>
</div>
<span class="comment-copy">No, that's probably not a good design. If you don't want to expose the same interface, <i>compose</i> don't <i>inherit</i>.</span>
<span class="comment-copy">If Stack isn't going to fulfill the interface promises that LinkedList makes, it should not extend LinkedList.</span>
<span class="comment-copy">As described in the official Python documentation <b><a href="https://docs.python.org/3/tutorial/classes.html?highlight=private#private-variables" rel="nofollow noreferrer">"9.6. Private Variables"</a></b>, it is possible to protected a method inside a <code>class</code>. Simply declare that function by naming it starting by twice underscores (ex: <code>__private_search(self):</code>).</span>
<span class="comment-copy">@jonrsharpe are you suggesting something like this? <code>class Stack(object):          def __init__(self):         self.items = LinkedList()</code> after which I would proceed to implement the Stack ADT but using the LinkedList behind the scenes.</span>
<span class="comment-copy">Yes, exactly that. Or <code>self._items</code> to indicate that the list itself is also not part of the stack's public interface.</span>
