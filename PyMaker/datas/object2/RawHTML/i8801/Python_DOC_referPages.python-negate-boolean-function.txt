<div class="post-text" itemprop="text">
<p>A python boolean function can easily be negated with lambda functions, but it's a bit verbose and hard to read for something so basic, for example:</p>
<pre><code>def is_even(n):
    return n % 2 == 0

odds_under_50 = filter(lambda x: not is_even(x), range(50))
</code></pre>
<p>I'm wondering if there is a function to do this in the standard library, which might look like:</p>
<pre><code>odds_under_50 = filter(negate(is_even), range(50))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As far as I know there is no <em>builtin</em> function for that, or a popular library that does that.</p>
<p>Nevertheless, you can easily write one yourself:</p>
<pre><code>from functools import wraps

def negate(f):
    @wraps(f)
    def g(*args,**kwargs):
        return not f(*args,**kwargs)
    return g
</code></pre>
<p>You can then use:</p>
<pre><code>odds_under_50 = filter(<b>negate(is_even)</b>, range(50))</code></pre>
<p>The <code>negate</code> functions works for an arbitrary amount of parameters of the given function: if you would have defined <code>is_dividable(x,n=2)</code>. Then <code>negate(is_dividable)</code> is a function with two arguments (one optional) that would also accept these parameters.</p>
</div>
<div class="post-text" itemprop="text">
<p>In case of <code>filter</code> you can use <code>ifilterfalse</code> from <code>itertools</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a decorator:</p>
<pre><code>def negate(function):
    def new_function(*args, **kwargs):
       return not function(*args, **kwargs)
return new_function


def is_even(x):
    return x % 2 == 0

print is_even(1)
print is_even(2)

is_odd = negate(is_even)
print is_odd(1)
print is_odd(2)
</code></pre>
<p>This decorator can also be used with @negate.</p>
<pre><code>@negate
def is_odd(x):
    return x % 2 == 0
</code></pre>
</div>
<span class="comment-copy">As far as I know, there is no <i>builtin</i> function, but you can easily define your own higher order function for that...</span>
<span class="comment-copy">Not to my knowledge; in this case I would just go with a list comprehension: <code>[xi for xi in range(50) if not is_even(xi)]</code></span>
<span class="comment-copy">@Cleb: not that in Python-3.x <code>filter</code> and this list comprehension are not equivalent since <code>filter</code> is lazy: you can <code>filter</code> an infinite generator whereas you cannot do that with list comprehension.</span>
<span class="comment-copy">@WillemVanOnsem: What exactly would be the differences in practical terms? Might be tricky to discuss in the comments but I currently don't see the difference. When I read the <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer">documentation</a>, I don't spot the difference either (apart from list vs. iterator).</span>
<span class="comment-copy">if you <code>import itertools</code> and then do <code>[xi for xi in itertools.repeat(1) if not is_even(xi)]</code> this will run out of memory. <code>filter</code> will evaluate lazily and thus not consume CPU/memory at all.</span>
<span class="comment-copy">That does not really answers the question.</span>
