<div class="post-text" itemprop="text">
<p>I would like to intersect two nested lists:</p>
<pre><code>source = [['one', 'two', 'three'], ['four', 'five', 'six'], ['seven', 'eight', 'nine']]
target = [['three', 'whatever'], ['four', 'whatever'], ['whatever', 'whatever']]
</code></pre>
<p>So I can return the lists in <code>source</code> where intersections were found:</p>
<pre><code>result = [['one', 'two', 'three'], ['four', 'five', 'six']]
</code></pre>
<p>How can I do this using <code>lambda</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <em>set</em> to check if there is any intersection between elements:</p>
<pre><code>[s for s in source if any(set(s) &amp; set(t) for t in target)]
# [['one', 'two', 'three'], ['four', 'five', 'six']]
</code></pre>
<hr/>
<p>This could be slightly more efficient if convert the <em>target</em> to a list of sets before hand:</p>
<pre><code>target_set = [set(t) for t in target]
[s for s in source if any(set(s) &amp; t for t in target_set)]
</code></pre>
<p>When saying <code>lambda</code>, maybe you need a <code>filter</code> function:</p>
<pre><code>filter(lambda s: any(set(s) &amp; t for t in target_set), source)
</code></pre>
<p>Or in python 3:</p>
<pre><code>list(filter(lambda s: any(set(s) &amp; t for t in target_set), source))
</code></pre>
<hr/>
<p>It seems like your logic is equivalent to the following as @JohnColeman commented:</p>
<pre><code>target_set = {j for i in target for j in i}    
filter(lambda s: set(s) &amp; target_set, source)

# [['one', 'two', 'three'], ['four', 'five', 'six']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use <a href="https://docs.python.org/3/library/stdtypes.html#set.difference" rel="nofollow noreferrer"><code>set.difference</code></a> in the <code>lambda</code> combined with a filter:</p>
<pre><code>list(filter(lambda s: set(s).difference(*target) != set(s), 
            source))
</code></pre>
<p>This will keep any list that contains at least one item that is in any of the <code>target</code>-lists.</p>
<p>Or if you don't like <code>set</code>s you can do the checks explicitly:</p>
<pre><code>list(filter(lambda s: any(item in sublist for sublist in target for item in s), 
            source))
</code></pre>
</div>
<span class="comment-copy">when you say intersect, what exactly do you mean? You mean one item of the sublist should be in one item of the other sublist? Or should it be in the "same" sublist (same index)?</span>
<span class="comment-copy">@MSeifert yes, one item of the sublist should have the same item of the other sublist.</span>
<span class="comment-copy">"This could be slightly more efficient if convert the target to a list of sets before hand" -- why not convert it into a single set by forming the union?</span>
<span class="comment-copy">@JohnColeman Ahh, I think you are right, the logic seems to be like this.</span>
<span class="comment-copy"><code>target_set = reduce(lambda s, b: s|b, [set(t) for t in target], set())</code> and then <code>[s for s in source if set(s) &amp; target_set]</code></span>
