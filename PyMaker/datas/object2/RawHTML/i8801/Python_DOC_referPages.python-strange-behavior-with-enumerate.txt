<div class="post-text" itemprop="text">
<p>I know I'm not supposed to modify the list inside a loop, but just out of curiosity, I would like to know why the number of iterations is different between the following two examples.</p>
<p>Example 1:</p>
<pre><code>x = [1, 2, 3, 4, 5]
for i, s in enumerate(x):
    del x[0]
    print(i, s, x)
</code></pre>
<p>Example 2:</p>
<pre><code>x = [1,2,3,4,5]
for i, s in enumerate(x):
    x = [1]
    print(i, s, x)
</code></pre>
<p>Example 1 runs only 3 times because when <code>i==3</code>, <code>len(x)==2</code>. </p>
<p>Example 2 runs 5 times even though <code>len(x)==1</code>.</p>
<p>So my question is, does <code>enumerate</code> generate a full list of <code>(index, value)</code> pairs at the beginning of the loop and iterate through it? Or are they generated on each iteration of the loop?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><strong>enumerate()</strong></a> returns an iterator, or some other object which supports iteration. The <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="nofollow noreferrer"><strong>__next__()</strong></a> method of the iterator returned by <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><strong>enumerate()</strong></a> returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over <em>iterable</em>.</p>
<p><a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="nofollow noreferrer"><strong>__next__()</strong></a> returns the next item from the container. If there are no further items, raise the <code>StopIteration</code> exception.</p>
<blockquote>
<p>Does enumerate() generate a full list of (index, value) pairs at the beginning of the loop and iterates through it? Or are they generated on each iteration of the loop? </p>
</blockquote>
<p>So, <code>enumerate()</code> returns an iterator and at every iteration, <code>__next__()</code> checks if there are further items. <code>enumerate()</code> doesn't create a full list at the beginning of the loop. </p>
<p>As, <a href="https://stackoverflow.com/a/42654677/5352399">@Wisperwind</a> mentioned, in your second case, you're assigning a new object to the name <code>x</code>. The object, the loop iterates over does not change during the iteration.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the first example, you're actually modifying the list you're iterating over.</p>
<p>On the other hand, in the second case, you're only assigning a new object to the name <code>x</code>. The object the loop iterates over does not change, though.</p>
<p>Have a look at <a href="http://foobarnbaz.com/2012/07/08/understanding-python-variables/" rel="noreferrer">http://foobarnbaz.com/2012/07/08/understanding-python-variables/</a> for a more detailed explanation about names and variables in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just a clarification to what Wasi Ahmad and Wisperwind have said.  Both state that "you're only assigning a new object to the name x".  This might be slightly confusing as it might be interpreted as saying "you're creating a new object (<code>[1]</code>) and storing it to the name <code>x</code>, to which you'd say "Well yah, so why isn't it changing?!"  To see what's happening, print out the id of the object </p>
<pre><code>x = [1, 2, 3, 4, 5]
y = x  # To keep a reference to the original list
print id(x), id(y)
for i, v in enumerate(x):
    x = [1]
    print id(x), id(y)
print id(x), id(y)


# output (somewhat contrived as I don't have a python environment set up)
#    X ID            Y ID
10000000000001 10000000000001
10000000000002 10000000000001
10000000000003 10000000000001
10000000000004 10000000000001
10000000000005 10000000000001
10000000000006 10000000000001
10000000000006 10000000000001
</code></pre>
<p>You'll notice that the <code>id</code> of <code>x</code> is changing each time through the loop and when you're finished with the loop, <code>x</code> will point to the last modification made in the loop.  When you're going through your loop, it is iterating over the original instance of x, regardless of whether you can still reference it.  </p>
<p>As you can see, <code>y</code> points to the original <code>x</code>.  As you make your iterations through the loop, even though <code>x</code> is changing, <code>y</code> is still pointing to the original <code>x</code> which is still being looped over.</p>
</div>
<div class="post-text" itemprop="text">
<p>Indeed: Your first snippet modifies the iterated-over list in place; the second points the variable <code>x</code> to a new list, leaving unmodified the list transversed by <code>enumerate()</code>. You can see this in action by going to the following links on www.pythontutor.com, which allow you to single-step over your code and visualize the contents of your variables:</p>
<ul>
<li><p><a href="http://www.pythontutor.com/visualize.html#code=x%20%3D%20%5B1,%202,%203,%204,%205%5D%0Afor%20i,%20s%20in%20enumerate%28x%29%3A%0A%20%20%20%20del%20x%5B0%5D%0A%20%20%20%20print%28i,%20s,%20x%29&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=false&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" rel="nofollow noreferrer">First version</a> (<code>x</code> is modified in place).</p></li>
<li><p><a href="http://www.pythontutor.com/visualize.html#code=x%20%3D%20%5B1,%202,%203,%204,%205%5D%0Afor%20i,%20s%20in%20enumerate%28x%29%3A%0A%20%20%20%20x%20%3D%20%5B1%5D%0A%20%20%20%20print%28i,%20s,%20x%29&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=false&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" rel="nofollow noreferrer">Second version</a> (<code>x</code> is redirected to <code>[1]</code>).</p></li>
</ul>
<p>To better see what's going on, go <a href="http://www.pythontutor.com/visualize.html#code=x%20%3D%20%5B1,2,3,4,5%5D%0Aview%20%3D%20enumerate%28x%29%0Afor%20i,%20s%20in%20view%3A%0A%20%20%20%20x%20%3D%20%5B1%5D%0A%20%20%20%20print%28i,%20s,%20x%29&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=false&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" rel="nofollow noreferrer">here</a> instead to step over the following expanded code:</p>
<pre><code>x = [1,2,3,4,5]
view = enumerate(x)
for i, s in view:
    x = [1]
    print(i, s, x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Others have already pointed out that your second example only changes the value to which <code>x</code> points, but not the list over which you're iterating. This is a perfect example for the difference between ordinary assignment (<code>x = [1]</code>) and <a href="https://stackoverflow.com/q/10623302/857390">slice assignment</a> (<code>x[:] = [1]</code>). The latter modifies the list <code>x</code> points to <em>in-place</em>:</p>
<pre><code>x = [1, 2, 3, 4, 5]
for i, s in enumerate(x):
    x[:] = [1]
    print(i, s, x)
</code></pre>
<p>will print</p>
<pre><code>(0, 1, [1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>x = [1, 2, 3, 4, 5]
</code></pre>
<p>The list <code>[1, 2, 3, 4, 5]</code> is 'tagged' with <code>x</code></p>
<pre><code>for i, s in enumerate(x):
</code></pre>
<p>enumerate() attaches another tag, so <code>[1, 2, 3, 4, 5]</code> is now tagged <code>x</code> and <code>y</code>. enumerate() will continue using the <code>y</code> tag, not the <code>x</code> tag. </p>
<pre><code>del x[0]
</code></pre>
<p>The list stored in memory is modified, so <code>x</code> and <code>y</code> now both refer to <code>[2, 3, 4, 5]</code></p>
<p>Alternatively, when you use</p>
<pre><code>x = [1]
</code></pre>
<p>A new list <code>[1]</code> is created in memory, and the <code>x</code> tag now points to that. The <code>y</code> tag is still pointing to the original list.</p>
<p>How Python variable work:<br/>
<a href="http://foobarnbaz.com/2012/07/08/understanding-python-variables/" rel="nofollow noreferrer">http://foobarnbaz.com/2012/07/08/understanding-python-variables/</a></p>
</div>
<span class="comment-copy">I can't pretend I know enough to answer your question but as to why it behaves differently here is my guess. In the first case you are deleting from the very same list so it makes sense the iteration stops before. In the second case however you are reassigning it. So python probably considers it as a <code>different</code> variable and keeps going with the <code>original</code> value of x.</span>
<span class="comment-copy">The same happens without enumerate at all! The <code>for</code> loop does not re-evaluate the iterator, so even if you re-assign <code>x</code> inside the <code>for</code> loop the loop will still use the old value. Obviously if you remove elements from a list, the loop will complete with less iterations.</span>
<span class="comment-copy">This has got to be a dupe of something.</span>
<span class="comment-copy">enumerate needs to work for unbound sequences, so it wouldn't be possible to generate the pairs up front. If you want to, just use <code>list(enumerate(...))</code></span>
<span class="comment-copy">@jpmc26  indeed there is <a href="http://stackoverflow.com/a/986145/3451198">stackoverflow.com/a/986145/3451198</a> which I did not find yesterday. It does explain the underlying issue very well, however not in the context of a loop. Should this be flagged? I'm rather new at SO and not sure about it.</span>
<span class="comment-copy">So the reason that the original x's value [1, 2,..., 5] does not get garbage collected even after assigning x=[0] is because the iterator is still referring to this list.</span>
<span class="comment-copy">Thanks for the answer! I chose Wasi's answer only because it was clearer to understand with the __next__() call.</span>
<span class="comment-copy">@dbdq I think it has more to do with how Python variables work, which is probably why this answer has more upvotes.</span>
<span class="comment-copy">@dbdq I think with my answer it's clear what is going on here</span>
<span class="comment-copy">Python is very much a reference based language. You don't assign a value to the name x, you assign a reference to the name x.</span>
<span class="comment-copy">When I run this code, the id of <code>x</code> inside the loop alternates between 139917134004304 and 139917134053248.  This is because the new object  is being created in the same location as the last-but-one object.  However, that wrinkle would make your answer <i>much</i> more complicated!</span>
<span class="comment-copy">In addition, if the OP wants to reduce the <i>original</i> list that <code>x</code> referenced (and that he is looping over), he could write:  <code>del x[1:] : x[0] = 1</code></span>
<span class="comment-copy">@MartinBonner Or even: <code>x[:] = [1]</code></span>
