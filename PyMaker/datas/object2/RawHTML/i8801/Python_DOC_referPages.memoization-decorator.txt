<div class="post-text" itemprop="text">
<p>I have the following pseudocode:</p>
<pre><code>class myClass()
  def slow_method(self):
     try:
         return self.memo_slow_method
     except:
         self.memo_slow_method = some_slow_function()
         return self.memo_slow_method
</code></pre>
<p>Is it possible build a memoization decorator that performs <strong>exactly</strong> this logic?</p>
<p>Restrictions:</p>
<ul>
<li>Though memo_slow_method doesn't need to be directly accessible, it must be defined on the object, such that it is cleaned up when object itself is purged- <strong>very important</strong>.</li>
<li>There's no need to consider parameters other than <code>self</code> - no parameters will ever be passed.</li>
</ul>
<p>PS I have been using @lrucache but it's not suitable for my purposes. It really needs to follow the above logic exactly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of a decorator you can use a descriptor (property-like):</p>
<pre><code>class Memoize(object):
    def __init__(self, name, func):
        self.name = name  # name of the memo attribute
        self.func = func  # the function that is executed when there is no memo

    def __get__(self, obj, typ=None):
        if obj:
            try:
                return getattr(obj, self.name)
            except:
                setattr(obj, self.name, self.func())
                return getattr(obj, self.name)
        else:
            return self
</code></pre>
<p>Then set the descriptor:</p>
<pre><code>class Fun(object):
    meth = Memoize('x', lambda: print('in') or 10)
</code></pre>
<p>Then the interactive test:</p>
<pre><code>&gt;&gt;&gt; f = Fun()
&gt;&gt;&gt; f.meth  # function is executed
'in'
10
&gt;&gt;&gt; f.x
10
&gt;&gt;&gt; f.meth  # function is not executed
10
</code></pre>
<p>If you really want a decorator:</p>
<pre><code>def memoize(func):
    def inner(self):
        try:
            return self.memo_slow_method   # hardcoded memo attribute name
        except:
            self.memo_slow_method = func(self)  # execute the method body
            return self.memo_slow_method
    return inner

class Fun(object):
    @memoize
    def meth(self):
        print('in')
        return 100

&gt;&gt;&gt; f = Fun()
&gt;&gt;&gt; f.meth()
'in'
100
&gt;&gt;&gt; f.meth()
100
&gt;&gt;&gt; f.memo_slow_method
100
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a decorator that implements your logic exactly, as requested.
It coins the name for the memo field from the function name (which is available in  <code>func.__name__</code>) by adding a prefix to it:</p>
<pre><code>from __future__ import print_function
import time
from functools import wraps

memo_prefix = '_memo_' # Check for possible name collision

def deco(func):
    memo_field_name = memo_prefix + func.__name__

    def ret_func(self):
        try:
            return getattr(self, memo_field_name)
        except AttributeError:
            ret_val = func(self)
            setattr(self, memo_field_name, ret_val)
            return ret_val
    return ret_func

def some_slow_function():
    for x in range(3):
        time.sleep(1)
        print('Waiting...', x)
    return 'Done'

class myClass():
    @deco
    def slow_method(self):
        return some_slow_function()
</code></pre>
<p>Now test it:</p>
<pre><code>In [2]: it = myClass()

In [3]: print(it.slow_method())
Waiting... 0
Waiting... 1
Waiting... 2
Done

In [4]: print(it.slow_method())
Done

In [5]: print(it.__dict__)
{'_memo_slow_method': 'Done'}
</code></pre>
</div>
<span class="comment-copy">What will some_slow_function return? method or value? Will slow_method return function?</span>
<span class="comment-copy">There is a <a href="https://wiki.python.org/moin/PythonDecoratorLibrary#Memoize" rel="nofollow noreferrer">recipe for a memoization decorator</a>. Since Python 3.2, <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer">something similar</a> is contained in the standard library.</span>
