<div class="post-text" itemprop="text">
<p>I'm looking for a way how to evenly distribute objects according to their attributes to list. </p>
<p>For example:</p>
<pre><code>[{'fruit':'apple', 'price':45},{'fruit':'apple', 'price':5},
 {'fruit':'orange','price':4},{'fruit':'orange','price':45},                                    
 {'fruit':'orange','price':8},{'fruit':'orange','price':450},]
</code></pre>
<p>I want to reorder this list to make all fruits of the same kind apart as much as possible. The solution for this simple example is:</p>
<pre><code>[{'fruit':'orange', 'price':45},{'fruit':'apple', 'price':5},
 {'fruit':'orange','price':4},{'fruit':'apple','price':45},                                    
 {'fruit':'orange','price':8},{'fruit':'orange','price':450},]
</code></pre>
<p>So <code>orange,apple,orange,orange,apple,orange</code> is one of the correct solutions. </p>
<p>This is a simplified example. In fact, it is about scraping huge number of urls. I scrape those urls using pool of 100 workers. There can be multiple urls with the same site so I want to distribute them evenly because I don't want to overload someones server. </p>
<p>Do you have an idea what to solve this? Or is there some module which can do that?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>roundrobin</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipe</a> combined with itertools.groupby</p>
<pre><code>from itertools import cycle, groupby, islice

def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).__next__ for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))

earls = [{'fruit':'apple', 'price':45},{'fruit':'apple', 'price':5},
         {'fruit':'orange','price':4},{'fruit':'orange','price':45},
         {'fruit':'orange','price':8},{'fruit':'orange','price':450},]

key = operator.itemgetter('fruit')
earls.sort(key = key)
groups = (tuple(group) for key, group in groupby(earls, key))

for thing in roundrobin(*groups):
    print(thing)
</code></pre>
<p>Result:</p>
<pre><code>{'fruit': 'apple', 'price': 45}
{'fruit': 'orange', 'price': 4}
{'fruit': 'apple', 'price': 5}
{'fruit': 'orange', 'price': 45}
{'fruit': 'orange', 'price': 8}
{'fruit': 'orange', 'price': 450}
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">What you mean by <i>apart as much as possible</i> ? why apple items are not first and last items ?</span>
<span class="comment-copy">Because there would be three oranges next to each other so this is a better solution.</span>
<span class="comment-copy">Always two kind of <code>fruits</code> exists? Explain more please ! it's not really obvious what you are asking here.</span>
<span class="comment-copy">@Arman I tried to explain it at the bottom of the question. In fact, it's the web scraping problem. I don't want to have for example 100 urls of one site next to each other because I don't want to overload server. The better way is to  distribute those urls across the queue/list so urls having the same site aren't scraped in one pool.</span>
<span class="comment-copy">@Arman There can be any number of fruits there (sites).</span>
