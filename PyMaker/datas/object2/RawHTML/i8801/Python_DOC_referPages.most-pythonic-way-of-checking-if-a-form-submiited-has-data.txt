<div class="post-text" itemprop="text">
<p>I'm currently learning Django however I'm torn on how to structure the equivalent of add method using it. I'm creating a URL shortener and I'm between the following methods to implement in creating the shortened URL:</p>
<pre><code>def shorten(request):
if request.method == 'POST':
    http_url = request.POST.get("http_url","")

    if http_url: # test if not blank
        short_id = get_short_code()
        new_url = Urls(http_url=http_url, short_id=short_id)
        new_url.save()

        return HttpResponseRedirect(reverse('url_shortener:index'))
    else:
        error_message = "You didn't provide a valid url"
        return render(request, 'url_shortener/shorten.html', { 'error_message' : error_message })

return render(request, 'url_shortener/shorten.html')
</code></pre>
<p>vs.</p>
<pre><code>def shorten(request):
    http_url = request.POST["http_url"]
    if http_url:
        short_id = get_short_code()
        new_url = Urls(http_url=http_url, short_id=short_id)
        new_url.save()
        return HttpResponseRedirect(reverse('url_shortener:index'))

    else:
        error_message = "You didn't provide a valid url"
        return render(request, 'url_shortener/shorten.html', { 'error_message' : error_message })

    return render(request, 'url_shortener/shorten.html')
</code></pre>
<p>Specifically, I want to know the best practice on the following:</p>
<ol>
<li>Is it best practice to explicity test if method is post or <code>http_url = request.POST["http_url"]</code> is enough</li>
<li>Is <code>http_url = request.POST.get("http_url","")</code> recommended to be used or this is just suppressing the error?</li>
<li><p>If (2) is not recommended, how can I make the <code>http_url</code> required and throw an error? I also tried the following but the except block is not triggered when I submit a blank form</p>
<pre><code>def shorten(request):
    if request.method == 'POST':
        try:
            http_url = request.POST["http_url"]
            short_id = get_short_code()
            new_url = Urls(http_url=http_url, short_id=short_id)
            new_url.save()

            return HttpResponseRedirect(reverse('url_shortener:index'))
        except KeyError:
            error_message = "You didn't provide a valid url"
            return render(request, 'url_shortener/shorten.html', { 'error_message' : error_message })

    return render(request, 'url_shortener/shorten.html')
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<pre><code>request.POST["key"]
</code></pre>
<p>will throw a <code>KeyError</code> when the <code>key</code> is not present in the dictionary. You can use a <code>try...catch</code> clause to handle the error.</p>
<p>Generally though, its idiomatic and perfectly normal to do:</p>
<pre><code>request.POST.get("key")
</code></pre>
<p>More about get <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer">here</a>.</p>
</div>
<span class="comment-copy">Use CBV <a href="https://docs.djangoproject.com/en/1.10/topics/class-based-views/intro/" rel="nofollow noreferrer">docs.djangoproject.com/en/1.10/topics/class-based-views/intro</a></span>
<span class="comment-copy">Django has a whole forms framework that is meant for <b>exactly</b> this. You should be using it.</span>
<span class="comment-copy">Yeah, I think the class-based views are appropriate for this but I decided to stick to the <code>request.POST.get("key")</code> for simplicity. I'll think of much complex project to implement the CBV. Thanks!</span>
<span class="comment-copy">Thanks! I decided to stick with the <code>request.POST.get("key")</code> since this is just a simple project. I'll implement the class based views once I have a much complex project to work with :)</span>
