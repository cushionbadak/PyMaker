<div class="post-text" itemprop="text">
<p>I need to convert a json-string to python object. By object I mean "new" python3 object like:</p>
<pre><code>class MyClass(object):
</code></pre>
<p>I found several help for example on jsonpickle documentation. But all I found are tutorials which convert object to json first and after this convert backwards.</p>
<p>I want to convert a json-string from a <a href="https://www.openligadb.de/api/getmatchdata/39738" rel="noreferrer">Rest-API</a>.</p>
<p>Here is what I have done so far:</p>
<pre><code>import requests
import jsonpickle

class Goal(object):
    def __init__(self):
        self.GoaldID = -1
        self.IsPenalty = False

class Match(object):
    def __init__(self):
        self.Goals = []

headers = {
    "Content-Type": "application/json; charset=utf-8"
}

url = "https://www.openligadb.de/api/getmatchdata/39738"

result = requests.get(url=url, headers=headers)
obj = jsonpickle.decode(result.json)
print (obj)
</code></pre>
<p>This results in:</p>
<pre class="lang-none prettyprint-override"><code>TypeError: the JSON object must be str, bytes or bytearray, not 'method'
</code></pre>
<p>It's quite clear to me that jsonpickle can't convert this to my classes (Goal, Match), because I don't tell jsonpickle in which class the output should be converted. The problem is I don't know how to tell jsonpickle to convert the JSON in object from type Match? And how can I tell that the list of goals should be of type <code>List&lt;Goal&gt;</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The following lines will give you a dictionary:</p>
<pre><code>obj = jsonpickle.decode(result.content)  # NOTE: `.content`, not `.json`

obj = result.json()
</code></pre>
<p>But none of above will give you what you want (python object (not dicitonary)). because the json from the url is not encoded with <code>jsonpickle.encode</code> - whcih add additional information to a generated json (something like <code>{"py/object": "__main__.Goal", ....}</code>)</p>
<hr/>
<pre><code>&gt;&gt;&gt; import jsonpickle
&gt;&gt;&gt; class Goal(object):
...     def __init__(self):
...         self.GoaldID = -1
...         self.IsPenalty = False
...
&gt;&gt;&gt; jsonpickle.encode(Goal())
'{"py/object": "__main__.Goal", "IsPenalty": false, "GoaldID": -1}'
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# JSON encoded with jsonpickle.encode  (default unpicklable=True)
#   =&gt; additional python class information attached
#   =&gt; can be decoded back to Python object
&gt;&gt;&gt; jsonpickle.decode(jsonpickle.encode(Goal()))
&lt;__main__.Goal object at 0x10af0e510&gt;


&gt;&gt;&gt; jsonpickle.encode(Goal(), unpicklable=False)
'{"IsPenalty": false, "GoaldID": -1}'
# with unpicklable=False   (similar output with json.dumps(..))
#   =&gt; no python class information attached
#   =&gt; cannot be decoded back to Python object, but a dict
&gt;&gt;&gt; jsonpickle.decode(jsonpickle.encode(Goal(), unpicklable=False))
{'IsPenalty': False, 'GoaldID': -1}
</code></pre>
<hr/>
<p>If you want an actual Python object which is not a dictionary, i.e. you prefer <code>dic.Goals.[0].GoalGetterName</code> to <code>dic["Goals"][0]["GoalGetterName"]</code>, use <a href="https://docs.python.org/3/library/json.html#json.loads" rel="nofollow noreferrer"><code>json.loads</code></a> with object_hook:</p>
<pre><code>import json
import types    
import requests

url = "https://www.openligadb.de/api/getmatchdata/39738"

result = requests.get(url)
data = json.loads(result.content, object_hook=lambda d: types.SimpleNamespace(**d))
# OR   data = result.json(object_hook=lambda d: types.SimpleNamespace(**d))
goal_getter = data.Goals[0].GoalGetterName
# You get `types.SimpleNamespace` objects in place of dictionaries
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do you mean something like this?</p>
<pre><code>import json

class JsonObject(object):   

    def __init__(self, json_content):
        data = json.loads(json_content)
        for key, value in data.items():
            self.__dict__[key] = value      


jo = JsonObject("{\"key1\":1234,\"key2\":\"Hello World\"}")
print(jo.key1)
</code></pre>
<p>which prints:</p>
<pre><code>1234
[Finished in 0.4s]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A clean approach on recent python versions might be to use <a href="https://github.com/lovasoa/marshmallow_dataclass" rel="nofollow noreferrer">marshmallow-dataclass</a> :</p>
<pre><code>from dataclasses import field
from marshmallow_dataclass import dataclass 
from typing import List

@dataclass
class Goal:
    GoaldID: int = field(default=-1)
    IsPenalty: bool = field(default=False)


@dataclass
class Match:
    Goals: List[Goal] = field(default_factory=lambda: [])

my_match, _ = Match.Schema().load(result.json())
</code></pre>
</div>
<span class="comment-copy"><code>obj = jsonpickle.decode(result.content)</code> =&gt; This will give you a dictionary.</span>
<span class="comment-copy"><code>obj = result.json()</code> will also give you a dictionary.</span>
<span class="comment-copy">Ok thank you very much. Because I don't like the magic string access via dic, is it best practice to use a class method which converts a dic to an object?</span>
<span class="comment-copy">@Sebi, Why do you convert the dict to an object? I just used the dictionary/list/... without converting when I was using Python. (I don't think it's a magic string access ;;;)</span>
<span class="comment-copy">@Sebi, I didn't use this, but check this out: <a href="http://jsonmodels.readthedocs.io/en/latest/" rel="nofollow noreferrer">jsonmodels.readthedocs.io/en/latest</a></span>
<span class="comment-copy">It's because I just don't like the magic string access, for example: dic["Goals"][0]["GoalGetterName"], I would prefer match.goals[0].goalGetterName but maybe this needs to much afford.</span>
<span class="comment-copy">@Sebi, if you don't want to define mapping, you can define custom <a href="https://docs.python.org/3/library/json.html#json.JSONDecoder" rel="nofollow noreferrer"><code>JSONDecoder</code></a> which convert JSON object to <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer"><code>types.SimpleNamespace</code></a> instead of Python dictionary.</span>
<span class="comment-copy">Good approach thanks :)</span>
<span class="comment-copy">You're welcome :)</span>
