<div class="post-text" itemprop="text">
<p>I have two lists:</p>
<pre><code>a = ['a', 'b']
b = [1, 2, 3]
</code></pre>
<p>I want to get the combinations produced between the elements of list <code>b</code> and the elements of list a but treating elements of <code>a</code> as pairs (or triples etc. etc.) as the example below which gives <code>len(b) ** len(a)</code> number of combinations.</p>
<pre><code>c = ["a_1 b_1", "a_1 b_2", "a_1 b_3", "a_2 b_1", "a_2 b_2", "a_2 b_3", "a_3 b_1", "a_3 b_2" "a_3 b_3"]
</code></pre>
<p>I have tried to use <code>itertools.product</code> (as described <a href="https://stackoverflow.com/questions/12935194/combinations-between-two-lists">here</a>) but this will give only the 6 possible combinations. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product(..)</code></a> but specify <code>repeat</code> to be <code>repeat=len(a)</code>. So you can use:</p>
<pre><code>from itertools import product

def mul_product(a,b):
    for tup in product(b,repeat=len(a)):
        yield ' '.join('%s_%s'%t for t in zip(a,tup))
</code></pre>
<p>The <code>product(..)</code> will generate tuples like:</p>
<pre><code>&gt;&gt;&gt; list(product(b,repeat=len(a)))
[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]
</code></pre>
<p>So here the first element of the tuple is the one that is attached to <code>a_</code>, the second one to <code>b_</code>. Now we <code>zip(..)</code> them together with the <code>a</code> list, producing:</p>
<pre><code>&gt;&gt;&gt; list(map(lambda bi:list(zip(a,bi)),product(b,repeat=len(a))))
[[('a', 1), ('b', 1)], [('a', 1), ('b', 2)], [('a', 1), ('b', 3)], [('a', 2), ('b', 1)], [('a', 2), ('b', 2)], [('a', 2), ('b', 3)], [('a', 3), ('b', 1)], [('a', 3), ('b', 2)], [('a', 3), ('b', 3)]]
</code></pre>
<p>Now it is only a matter of formatting (<code>'%s_%s'%t</code>), and <code>' '.join(..)</code>ining them together and <code>yield</code> them (or you can use list comprehension to produce a list).</p>
<p>The result for your sample input is:</p>
<pre><code>&gt;&gt;&gt; list(mul_product(a,b))
['a_1 b_1', 'a_1 b_2', 'a_1 b_3', 'a_2 b_1', 'a_2 b_2', 'a_2 b_3', 'a_3 b_1', 'a_3 b_2', 'a_3 b_3']
</code></pre>
<p>Note that the elements here are generated lazily. This can be useful if you are for instance only interested in the first <code>k</code> ones, or when you do not want to generate all of them at once.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could explicitly create your pairwise items using <code>itertools.product</code>, then operate on those pairs again with <code>itertools.product</code></p>
<pre><code>import itertools
a = ['a', 'b']
b = [1, 2, 3]
pairs = [list(itertools.product([ai], b)) for ai in a]
</code></pre>
<p><code>pairs</code> will contain the two lists that can fed into <code>itertools.product</code> again.</p>
<pre><code>list(itertools.product(*pairs))
</code></pre>
<p>The result is:</p>
<pre><code>[(('a', 1), ('b', 1)),
 (('a', 1), ('b', 2)),
 (('a', 1), ('b', 3)),
 (('a', 2), ('b', 1)),
 (('a', 2), ('b', 2)),
 (('a', 2), ('b', 3)),
 (('a', 3), ('b', 1)),
 (('a', 3), ('b', 2)),
 (('a', 3), ('b', 3))]
</code></pre>
</div>
