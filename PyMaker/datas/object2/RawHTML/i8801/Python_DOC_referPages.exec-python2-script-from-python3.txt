<div class="post-text" itemprop="text">
<p>I would like to know if it is possible to execute a python2 script from a python3 script. </p>
<p>I have a file written using py3 that must execute legacy code written in py2 to obtain dictionaries for processing within the initial file. </p>
<p>The line in py3 to call the mentioned py2 script is</p>
<pre><code>exec(open('python2script.py').read())
</code></pre>
<p>The script runs without error until it begins processing <code>python2script.py</code>, at which point it crashes at the first difference with version3.</p>
</div>
<div class="post-text" itemprop="text">
<p>As the comments pointed out, <code>exec()</code> uses the current python implementation, so you can't execute python 2 code from python 3 using it.</p>
<p>Unless you port it, your best bet is simply to call it as a subprocess, using either <a href="https://docs.python.org/3/library/os.html#os.system" rel="nofollow noreferrer"><code>os.system</code></a>..:</p>
<p>./py3.py</p>
<pre><code>#!/usr/bin/env python3
import os

print('running py2')
os.system('./py2.py')
print('done')
</code></pre>
<p>./py2.py</p>
<pre><code>#!/usr/bin/env python2.7
print "hello from python2!"
</code></pre>
<p>Then (after making them both executable) run:</p>
<pre><code>$ ./py3.py
</code></pre>
<p>Or alternatively you can use the more flexible <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer"><code>subprocess</code></a>, which allows you to pass data back and forward more easily using a serialising module such as <a href="https://docs.python.org/2/library/json.html" rel="nofollow noreferrer">json</a> so that you can get your results from the python2 script in your python3 code:</p>
<p>./py3.py</p>
<pre><code>#!/usr/bin/env python3
import json
from subprocess import PIPE, Popen

print('running py2')
py2_proc = Popen(['./py2.py'], stdout=PIPE)
# do not care about stderr
stdout, _ = py2_proc.communicate()
result = json.loads(stdout.decode())
print('value1 was %s, value2 was %s' % (result['value1'], result['value2']))
</code></pre>
<p>./py2.py</p>
<pre><code>#!/usr/bin/env python2.7
import json

my_result = {
    'value1': 1,
    'value2': 3
}
print json.dumps(my_result)
</code></pre>
<p>Like that it may be easy to pack up the data you need and transport it over.</p>
<p><strong>Note:</strong> I have used a very simple environment setup here using my system's python2.7 and python3. In the real world the most painful thing about getting this sort of thing to work properly is configuring the environment correctly. Perhaps, e.g., you are using virtual environments. Perhaps you are running as a user which doesn't have the right python2 version in their path. Perhaps you can't make the files executable and so have to specify the path to python in your subprocess / os.system call. There are many options and it is very complicated, but out of the scope of the question. You just have to read the doc pages very carefully and try a few things out!</p>
</div>
<span class="comment-copy">Could you use <code>os.system('python python2script.py')</code>? This is equivalent to issuing the command that's in quotes on the command line.</span>
<span class="comment-copy"><code>exec</code> will naturally execute everything that it receives in the current (python 3) interpreter.</span>
<span class="comment-copy">If <code>os.system</code> does not work, then you could look at rewriting the python2 script to use <code>__future__</code> imports and more python3-friendly syntax. However, exec(open(python2file).read()) is an extremely clunky way to do this. The preferred method is to <code>import python2file</code> and run its code.</span>
<span class="comment-copy">@Benjamin - I would like to stay away from modifying the py2 script as it is currently in use by legacy code for initialization of data for processing (which is the case I am calling it from my script py3). See my comment to @daphtdazz 's answer with usability of <code>os.system('script.py')</code></span>
<span class="comment-copy">The issue with using <code>os.system</code> to execute as @Benjamin and you(@daphtdazz) mention is parameters from the py3 script are used for execution of py2, then objects saved from py2 are called within modules of the py3 script. An example error returned states <code>TypeError: 'module' object is not subscriptable</code>. The py3 script is modified of an original py2 script (using py3 for interaction with new modules frm imports). This process was originally done using <code>execfile('py2script.py')</code> and all I've described was permissable.</span>
<span class="comment-copy">Sorry, I should have read a bit more carefully. I've updated my answer to show how to transfer data between the two using <code>json</code>. You may find this an easier thing to do than converting your python2 script to python3 – you could even write a small wrapping python2 script that uses the old exec mechanism to get the result and then send it over to python 3 – but I think those are your only real options.</span>
