<div class="post-text" itemprop="text">
<p>I am trying to export a Dataframe to an Oracle table and keep running into the error</p>
<p><code>TypeError: expecting string or bytes object</code>.</p>
<p>I would like to be able to ignore or bypass this error in order to export what I have. Is that possible? </p>
<p>Here is a link to where I go into detail explaining the entirety of my problem: <a href="https://stackoverflow.com/questions/42635198/python-typeerror-expecting-string-or-bytes-object?noredirect=1#comment72399858_42635198">Python - TypeError: expecting string or bytes object</a>. My data honestly appears perfect, it is all consistently the correct number of columns and rows, they're all the same data type, I've used this exact method to export hundreds of other Dataframes before, and I would like to go around the error message in order to export what I have so far.</p>
<p>Also, because it fails on the <code>cursor.executemany(</code> line I decided to research that command. Here is the documentation for <code>cx_Oracle</code>: <a href="http://cx-oracle.readthedocs.io/en/latest/cursor.html" rel="nofollow noreferrer">http://cx-oracle.readthedocs.io/en/latest/cursor.html</a>. It states that:</p>
<p><code>When true, the batcherrors parameter enables batch error support within Oracle and ensures that the call succeeds even if an exception takes place in one or more of the sequence of parameters.</code></p>
<p>So I set it to true as <code>cursor.executemany(sql_query, exported_data, batcherrors=True)</code> and it changed nothing. </p>
<p>Here is my relevant code:</p>
<pre><code>df = pd.read_excel(file_path)


df = df.fillna(0)
df = df.ix[1:]


cursor = con.cursor()
exported_data = [tuple(x) for x in df.values]
#exported_data = [str(x) for x in df.values]
#print("exported_data:", exported_data)

sql_query = ("INSERT INTO FISHTABLE(date_posted, stock_id, species, pounds, advertised_price, email_year, email_month, email_day, sector_name, ask)" "VALUES(:1, :2, :3, :4, :5, :6, :7, :8, 'Sustainable Harvest Sector', '1')")

cursor.executemany(sql_query, exported_data)

con.commit() #commit to database

cursor.close()
con.close()
</code></pre>
<p>And here is a printout of <code>exported_data</code>:</p>
<p><code>[('DATE', 'TRADE ID', 'AVAILABLE STOCK', 'AMOUNT', 'BUY PRICE', '2013', '4', '16'), ('04/02/13', 130014, 'WINTER SNE', 12000, 'TRADE IN RETURN FOR', '2013', '4', '16'), (0, 0, 0, 0, 'HADDOCK GOM,', '2013', '4', '16'), (0, 0, 0, 0, 'YELLOWTAIL GOM, OR', '2013', '4', '16'), (0, 0, 0, 0, 'WITCH - OFFERS', '2013', '4', '16'), ('FY13 QUOTA â€“ TO BUY', 0, 0, 0, 0, '2013', '4', '16'), ('DATE', 'TRADE ID', 'DESIRED STOCK', 'AMOUNT', 'BUY PRICE', '2013', '4', '16'), ('3/26/13', 130006, 'COD GBE', 'ANY', 'OFFERS', '2013', '4', '16'), ('4/9/13', 130012, 'COD GBW', 'UP TO 100,000', 0.3, '2013', '4', '16'), ('3/26/13', 130007, 'COD GBW', 'ANY', 'OFFERS', '2013', '4', '16'), ('3/26/13', 130001, 'COD GOM', 'INQUIRE', 1.5, '2013', '4', '16'), ('3/26/13', 130009, 'WINTER GB', 'ANY', 'OFFERS', '2013', '4', '16'), ('4/9/13', 130013, 'WINTER SNE', 'UP TO 100,000', 0.3, '2013', '4', '16'), ('3/26/13', 130010, 'WINTER SNE', 'ANY', 'OFFERS', '2013', '4', '16'), ('3/26/13', 130008, 'YELLOWTAIL GB', 'ANY', 'OFFERS', '2013', '4', '16'), ('3/26/13', 130011, 'YELLOWTAIL GOM', 'ANY', 'TRADE FOR GB STOCKS -\nOFFERS', '2013', '4', '16'), (1, 0, 0, 0, 0, '2013', '4', '16')]</code></p>
<p>I would really like help solving this because I've been stuck on it for over a week now. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/tutorial/errors.html" rel="nofollow noreferrer">Error or exception handling in Python is done by using try-except blocks</a></p>
<pre><code>try:
    cursor.executemany(sql_query, exported_data)
except TypeError:
    pass # put your error handling code here, pass will ignore the error
</code></pre>
<p>What you want to do for error handling is up to you. The default Python behaviour is to <code>raise</code> the error (hence you are seeing it). When an error is encountered excecution is <strong>stopped</strong> at that point and the error handling routines you defined are executed. Ignoring the error will <strong>not</strong> make the method <code>cursor.executemany</code> pick up where it left off, but rather simply does not handle the error. You can call the method again in there (with the same arguments), but that obviously will not help, since it will just produce the same error again.</p>
</div>
<span class="comment-copy">Please add the relevant code snippets to this question instead of referring to your other question.</span>
<span class="comment-copy">You did answer my question perfectly, but the export still fails. Believe me, I have broken this down into the smallest and most specific pieces I can and I can't figure it out. I tried making <code>exported_data</code> a <code>str</code> instead of a <code>tuple</code> and it still failed, I've replaced <code>NaN</code>s with 0's, I've changed all values in the Dataframe to strings, I've confirmed that the export to the table works with simple one word exports, and more. But I guess even bypassing the error that holds me up still doesn't allow for an export</span>
<span class="comment-copy">I will add some more info to the answer regarding your expecations.</span>
<span class="comment-copy">But no thoughts on solving the underlying problem?</span>
<span class="comment-copy">Your <code>data_posted</code> and <code>species</code> values are sometimes numbers and sometimes strings. I guess you should not use <code>0</code> to fill in blanks but emtpy string <code>''</code>.</span>
<span class="comment-copy">I honestly thought that would solve this, that's a pretty smart idea and makes sense given the error <code>expecting string or bytes</code>........but that also didn't solve it :(</span>
