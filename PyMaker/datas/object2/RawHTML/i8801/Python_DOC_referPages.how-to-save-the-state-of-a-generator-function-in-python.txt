<div class="post-text" itemprop="text">
<p>Consider this scenario:</p>
<pre>#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os

walk = os.walk('/home')

for root, dirs, files in walk:
    for pathname in dirs+files:
        print os.path.join(root, pathname)

for root, dirs, files in walk:
    for pathname in dirs+files:
        print os.path.join(root, pathname)</pre>
<p>I know that this example is kinda redundant, but you should consider that we need to use the same <code>walk</code> data more than once. I've a benchmark scenario and the use of same <code>walk</code> data is mandatory to get helpful results.</p>
<p>I've tried <code>walk2 = walk</code> to clone and use in the second iteration, but it didn't worked. The question is... How I can copy it? Is it ever possible?</p>
<p>Thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/library/itertools.html#itertools.tee"><code>itertools.tee()</code></a>:</p>
<pre><code>walk, walk2 = itertools.tee(walk)
</code></pre>
<p>Note that this might "need significant extra storage", as the documentation points out.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you know you are going to iterate through the whole generator for every usage, you will probably get the best performance by unrolling the generator to a list and using the list multiple times.</p>
<p><code>walk = list(os.walk('/home'))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Define a function</p>
<pre><code> def walk_home():
     for r in os.walk('/home'):
         yield r
</code></pre>
<p>Or even this</p>
<pre><code>def walk_home():
    return os.walk('/home')
</code></pre>
<p>Both are used like this:</p>
<pre><code>for root, dirs, files in walk_home():
    for pathname in dirs+files:
        print os.path.join(root, pathname)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a good usecase for <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial()</code></a>
to make a quick generator-factory:  </p>
<pre><code>from functools import partial
import os

walk_factory = partial(os.walk, '/home')

walk1, walk2, walk3 = walk_factory(), walk_factory(), walk_factory()
</code></pre>
<p>What <code>functools.partial()</code> does is hard to describe with human-words, but this^ is what it's for. </p>
<p>It <strong>partially</strong> fills out function-params without executing that function. Consequently it acts as a function/generator factory.</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer aims to extend/elaborate on what the other answers have expressed. The solution will necessarily vary depending on what <em>exactly</em> you aim to achieve.</p>
<p>If you want to iterate over the exact same result of <code>os.walk</code> multiple times, you will need to initialize a list from the <code>os.walk</code> iterable's items (i.e. <code>walk = list(os.walk(path))</code>).</p>
<p>If you must guarantee the data remains the same, that is probably your only option. However, there are several scenarios in which this is not possible or desirable.</p>
<ol>
<li>It will not be possible to <code>list()</code> an iterable if the output is of sufficient size (i.e. attempting to <code>list()</code> an entire filesystem may freeze your computer).</li>
<li>It is not desirable to <code>list()</code> an iterable if you wish to acquire "fresh" data prior to each use.</li>
</ol>
<p>In the event that <code>list()</code> is not suitable, you will need to run your generator on demand. Note that generators are extinguised after each use, so this poses a slight problem. In order to "rerun" your generator multiple times, you can use the following pattern:</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os

class WalkMaker:
    def __init__(self, path):
        self.path = path
    def __iter__(self):
        for root, dirs, files in os.walk(self.path):
            for pathname in dirs + files:
                yield os.path.join(root, pathname)

walk = WalkMaker('/home')

for path in walk:
    pass

# do something...

for path in walk:
    pass
</code></pre>
<p>The aforementioned design pattern will allow you to keep your code DRY.</p>
</div>
<span class="comment-copy">What's wrong with using <code>os.walk('/home')</code> twice?  How is that a problem?</span>
<span class="comment-copy">@S.Lott Well, that kind of task vary so much on each run. Another problem is that after first run the system will probably cache the results, so in the next runs we'll get unprecise results. The idea is to walk before and then measure two scenarios passing it as argument. :)</span>
<span class="comment-copy">Caching won't cause false results.</span>
<span class="comment-copy">@pf.me: If you are doing profiling on the following operation, then you should definitely unroll the generator to a list in order to eliminate the variations in directory crawling (see my answer below). However, if the directory structure you are walking is very large, you might still get variation because of memory paging.</span>
<span class="comment-copy">@pf.me: "I noticed that on subsequently runs I get randomly results with seconds of difference."  How does "cloning" the  <code>os.walk('/home')</code> generator fix that?</span>
<span class="comment-copy">also, the <a href="http://docs.python.org/2/library/itertools.html#itertools.tee" rel="nofollow noreferrer">documentation</a> says: "In general, if one iterator uses most or all of the data before another iterator starts, it is faster to use <code>list()</code> instead of <code>tee()</code>." Given the OP's original code snippet iterates through once completely, and then again, wouldn't it be recommended for him to use <code>list()</code>?</span>
<span class="comment-copy">Use a cached generator instead, for example with <code>lambda: a_new_generator</code>, as described <a href="http://stackoverflow.com/a/21315536/1959808">here</a>.</span>
<span class="comment-copy">See also the comments to <a href="http://stackoverflow.com/a/1271481/1959808">this answer</a>.</span>
<span class="comment-copy">why do i see so many people saying there is no way to clone generators in python??</span>
<span class="comment-copy">@IshanSrivastava This doesn't actually clone the generator object.  It just creates a new iterator yielding the same values, but the new objects aren't generators anymore.</span>
<span class="comment-copy">Just out of curiosity, why does the necessity of iterating over every object in a generator make it more efficient to save a value-map in memory before iteration?</span>
<span class="comment-copy">While not the answer to the exact question the OP asked, this is a good way to do it without storing the complete directory tree in memory. +1</span>
<span class="comment-copy">The loop is unnecessary. <code>def walk_home(): return os.walk('/home')</code> does the same thing.</span>
<span class="comment-copy">@Sven Marnach: The "exact" question makes little sense.</span>
<span class="comment-copy">@shang: Good point!</span>
