<div class="post-text" itemprop="text">
<p>I have a list with 200 elements. I want to randomly calculate 10% of all the combinations of length <em>k</em> of those elements and store the result in a list.</p>
<p>For example:</p>
<p>Assume <code>'ABCD'</code> as in <code>['A', 'B', 'C', 'D']</code> and I want combinations of length 2. All possible combinations in this case would be 6 (<em>n! / ((n-k)! x k!)</em>). I want to get 10% of that which is 0.6 -&gt; 1 (round up).</p>
<p>I tried <code>itertools.combinations('ABCD', 2)</code> but it gives me all combinations.</p>
<hr/>
<p>Here's some more information about my problem.</p>
<p>I have </p>
<pre><code>all_points_coordinates =  [
    [-1.6339171050450814, 2.5160117038362722], 
    [-1.7207293090531386, 2.4574561328669748], 
    [0.10469849010750323, 2.9981724810572872],
]
</code></pre>
<p>and I want to calculate combinations of 3 of them and use</p>
<pre><code>def all_way(points):
    point = len(points)
    allrout = []
    allrout = list(itertools.permutations(points, point))
    return allrout
</code></pre>
<p>but it gives me all combinations of my points. When I run it for 100 points it is very time consuming so I want to calculate just a limited number of these combinations.</p>
</div>
<div class="post-text" itemprop="text">
<p>We can generate the random combinations using <code>random.sample</code>, and use a set to ensure we don't generate any combination more than once. Here's a simple demo.</p>
<pre><code>from random import seed, sample

seed(42)

def random_combinations(seq, size, num):
    combos = set()
    while len(combos) &lt; num:
        item = sample(seq, size)
        combos.add(tuple(item))
    return list(combos)

# test

data = [
    (0, 1), (2, 3), (4, 5), (6, 7), (8, 9), 
    (10, 11), (12, 13), (14, 15), (16, 17), (18, 19),
]

# Make 20 random 3-element combinations
combos = random_combinations(data, 3, 20)
for i, item in enumerate(combos, 1):
    print('{:&gt;2}: {}'.format(i, item))
</code></pre>
<p><strong>output</strong></p>
<pre><code> 1: ((2, 3), (12, 13), (8, 9))
 2: ((6, 7), (18, 19), (4, 5))
 3: ((2, 3), (16, 17), (18, 19))
 4: ((0, 1), (4, 5), (12, 13))
 5: ((14, 15), (10, 11), (4, 5))
 6: ((2, 3), (0, 1), (8, 9))
 7: ((6, 7), (16, 17), (0, 1))
 8: ((12, 13), (2, 3), (8, 9))
 9: ((6, 7), (14, 15), (8, 9))
10: ((10, 11), (18, 19), (8, 9))
11: ((0, 1), (14, 15), (2, 3))
12: ((18, 19), (10, 11), (6, 7))
13: ((18, 19), (12, 13), (0, 1))
14: ((10, 11), (8, 9), (4, 5))
15: ((8, 9), (2, 3), (6, 7))
16: ((2, 3), (0, 1), (6, 7))
17: ((16, 17), (6, 7), (12, 13))
18: ((2, 3), (12, 13), (18, 19))
19: ((0, 1), (2, 3), (6, 7))
20: ((6, 7), (10, 11), (2, 3))
</code></pre>
<p>As tobias_k mentions in the comments, this code is only suitable when <code>num</code> is not too close to the total number of combinations. If you want &lt; 50% of the total number of combinations it should be fine, but beyond that it will have a high chance of re-generating combinations that it's already generated, which will cause it to loop for a long time.</p>
<hr/>
<p>Note that this code considers <code>((2, 3), (12, 13), (8, 9))</code> to be distinct from a tuple containing those 3 pairs in a different order, eg <code>((2, 3), (8, 9), (12, 13))</code>. </p>
<p>If you don't want that we can make our items into sets. We need to use <code>frozenset</code> for this, since normal sets are mutable and therefore unhashable and hence cannot be set items.</p>
<pre><code>from random import seed, sample

seed(42)

def random_combinations(seq, size, num):
    combos = set()
    while len(combos) &lt; num:
        item = sample(seq, size)
        combos.add(frozenset(item))
    return [tuple(u) for u in combos]

# test

data = [
    (0, 1), (2, 3), (4, 5), (6, 7), (8, 9), 
    (10, 11), (12, 13), (14, 15), (16, 17), (18, 19),
]

# Make 20 random 3-element combinations
combos = random_combinations(data, 3, 20)
for i, item in enumerate(combos, 1):
    print('{:&gt;2}: {}'.format(i, item))
</code></pre>
<p><strong>output</strong></p>
<pre><code> 1: ((0, 1), (2, 3), (6, 7))
 2: ((0, 1), (2, 3), (8, 9))
 3: ((16, 17), (6, 7), (0, 1))
 4: ((12, 13), (2, 3), (18, 19))
 5: ((12, 13), (2, 3), (8, 9))
 6: ((12, 13), (18, 19), (0, 1))
 7: ((8, 9), (4, 5), (10, 11))
 8: ((16, 17), (2, 3), (18, 19))
 9: ((8, 9), (6, 7), (14, 15))
10: ((0, 1), (4, 5), (12, 13))
11: ((8, 9), (10, 11), (18, 19))
12: ((10, 11), (6, 7), (2, 3))
13: ((0, 1), (14, 15), (2, 3))
14: ((10, 11), (18, 19), (6, 7))
15: ((8, 9), (2, 3), (6, 7))
16: ((4, 5), (6, 7), (18, 19))
17: ((8, 9), (4, 5), (2, 3))
18: ((16, 17), (4, 5), (6, 7))
19: ((16, 17), (6, 7), (12, 13))
20: ((4, 5), (10, 11), (14, 15))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another rather simple possibility: Generate all the combinations, but only keep those where some random variable is <code>&lt; 0.1</code> to get (roughly) 10% of the resulting combinations.</p>
<pre><code>&gt;&gt;&gt; sum(1 for _ in itertools.combinations(range(100), 3)) # total count for comparison
161700
&gt;&gt;&gt; res = [c for c in itertools.combinations(range(100), 3) if random.random() &lt; 0.1]
&gt;&gt;&gt; len(res)
16227
</code></pre>
<p>Compared with using <code>random.sample</code>, this has the advantage that it does not need to <em>keep</em> all the combinations <em>in memory</em>, although it will still <em>generate</em> all the combinations, but discard 90% of them immediately. Also, the result will be only <em>roughly</em> 10% of the combinations, but not exactly. For large numbers, that should not be too much of a problem, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to calculate all combinations in advance before picking a small subset of them, you have two options:</p>
<ol>
<li><p>Ugly, but does the job</p>
<ul>
<li>Shuffle the elements of your list. Add the result to a set</li>
<li>Continue until the set has the desired length.</li>
</ul></li>
<li><p>Beautiful but complicated</p>
<ul>
<li>Create a list of indices &lt; n! (where n is the number of elements in your list)</li>
<li>Calculate the combination for each index (similar to <a href="https://stackoverflow.com/questions/29236556/how-can-i-calculate-n-th-permutation-or-tell-the-lexicographic-order-of-a-given">this question</a>.</li>
</ul></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Option 1 (<em>not random but generates what is needed only</em>):</p>
<p>Take the first 10% percent of the results returned by <code>itertools.combinations()</code>.</p>
<pre><code>import itertools
from math import factorial, ceil    

original = 'ABCD'
k = 2
percentage = 0.1
configurations = factorial(len(original)) / (factorial(len(original) - k) * factorial(k))
take = ceil(percentage * configurations)
res = []
for i, comb in enumerate(itertools.combinations(original, k), 1):
    res.append(comb)
    if i == take:
        break
print(res, len(res))
</code></pre>
<hr/>
<p>Option 2 (<em>random but generates the full list first</em>):</p>
<p>Take 10% percent of the results returned by <code>itertools.combinations()</code> randomly. <strong>Requires Python 3.6</strong> because of <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices()</code></a></p>
<pre><code># Python 3.6 you can do this
import random
import itertools
from math import factorial, ceil

original = 'ABCD'
k = 2
percentage = 0.1
configurations = factorial(len(original)) / (factorial(len(original) - k) * factorial(k))
take = ceil(percentage * configurations)
res = random.choices([x for x in itertools.combinations(original, k)], k=take)
</code></pre>
<p><code>original</code> can also be a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>ı solve my problem like this</p>
<pre><code>point=  len(points)
p=int(point*10/100)
allrout = list(itertools.islice(itertools.permutations(points, point),p ))
print(len(allrout))
return allrout
</code></pre>
</div>
<span class="comment-copy">Why not stop iterating after 10% of combinations have been found? I don't clearly see the problem here...can you elaborate further?</span>
<span class="comment-copy">The first 10%? Your question is not entirely clear.</span>
<span class="comment-copy">I mean for all combination of abcd in 4 is abcd abdc acbd acdb adbc adcb  bacd badc bdac bdca bcad bcda  cabd cadb cbad cbda cdab cdba  dabc dacb dbac dbca dcab dcba but ı dont want do callculste all ı just want to  3 of them which badc bdac bdca and order not importem just random</span>
<span class="comment-copy"><code>itertools.combinations</code> returns an iterator, it doesn't create all the combinations all at once. So just loop over the combinations and break out of the loop when you have enough combinations. They will be in order, not random. Does that matter?</span>
<span class="comment-copy">@OzanTunahanIsmailoglu Could it be the case that you have duplicates in your list?</span>
<span class="comment-copy">Nice, but you might add a warning not to use this with <code>num</code> being close to the total number of combinations, as finding the last few not-yet-seen combinations might take a long time.</span>
<span class="comment-copy">@tobias_k <i>Very</i> good point!</span>
<span class="comment-copy">but it is work for set ı have list how can ı solve this question. ı have data=[[9, -3], [5, 8], [-6, 7]]</span>
<span class="comment-copy">It's generally better to store coordinate pairs as tuples instead of lists. See <a href="http://stackoverflow.com/q/626759/4014959">here</a> for details. And my code needs the data in that form, but it's easy to do the conversion: <code>newdata = [tuple(u) for u in olddata]</code>. And of course you can do the reverse conversion like this <code>[list(u) for u in newdata]</code>.</span>
<span class="comment-copy">Nice approach. Hopefully, this will suit the OP's needs. I'll post a version using <code>sample</code> shortly.</span>
<span class="comment-copy">The total number of combinations can be analytically calculated in case the <code>sum</code> take a long time</span>
<span class="comment-copy">@Ev.Kounis Sure, just show the number for reference. For actually getting the 10%, I do not need the sum.</span>
<span class="comment-copy">I'm familiar with <a href="http://stackoverflow.com/a/28525468/4014959">permutation indices</a>, but how do you apply that to combinations?</span>
<span class="comment-copy">Option 1 does not guarantee that there will be no duplicates though, right?</span>
<span class="comment-copy">@Ev.Kounis: Yes, it does by using a set. The ugliness of this solution is that it becomes very inefficient when the percentage goes up because it has to throw away more and more duplicates.</span>
<span class="comment-copy">@TimPietzcker Of course, thanks!!</span>
<span class="comment-copy">But version 1 is not random, and version 2 needs to generate all the combinations first.</span>
<span class="comment-copy">@tobias_k True. Added comments in the answer to make it clear. 200 elements are not that many but OP didn't specify how many elements the combinations will consist of so runtime cannot be estimated easily</span>
<span class="comment-copy">It's not clear what the OP actually wants. My <i>guess</i> is that they want a random 10% of the (roughly) 200,000 pairs of points from their 200 point list. But I Could Be Totally Wrong. ;)</span>
<span class="comment-copy">BTW, why are you using <code>random.choices</code>? Shouldn't <code>random.sample</code> so the same?</span>
<span class="comment-copy">@tobias_k The only difference is replacement.<code>sample</code> is without replacement, <code>choices</code> with.</span>
