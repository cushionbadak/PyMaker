<div class="post-text" itemprop="text">
<p>Suppose I have a package containing two submodules and also a substantial amount of code in <code>__init__.py</code> itself:</p>
<pre><code>pkg/__init__.py
pkg/foo.py
pkg/bar.py
</code></pre>
<p>and, to make planned future refactorings easier, I want components of the package to exclusively use relative imports to refer to each other.  In particular, <code>import pkg</code> should never appear.</p>
<p>From <code>foo.py</code> I can do</p>
<pre><code>from __future__ import absolute_import
from . import bar
</code></pre>
<p>to get access to the <code>bar.py</code> module, and vice versa.</p>
<p>The question is, <em>what do I write to import <code>__init__.py</code> in this manner?</em>  I want exactly the same effect as <code>import pkg as local_name</code>, only without having to specify the absolute name <code>pkg</code>.</p>
<pre><code>#import pkg as local_name
from . import ??? as local_name
</code></pre>
<hr/>
<p><strong>UPDATE:</strong> Inspired by maxymoo's answer, I tried</p>
<pre><code>from . import __init__ as local_name
</code></pre>
<p>This does not set <code>local_name</code> to the the module defined by <code>__init__.py</code>; it instead gets what appears to be a bound method wrapper for the <code>__init__</code> <em>method</em> of that module.  I suppose I could do</p>
<pre><code>from . import __init__ as local_name
local_name = local_name.__self__
</code></pre>
<p>to get the thing I want, but (a) yuck, and (b) this makes me worry that the module hasn't been fully initialized.</p>
<p>Answers need to work on <em>both</em> Python 2.7 and Python 3.4+.</p>
<p>Yes, it would probably be better to hollow out <code>__init__.py</code> and just have it reexport stuff from the submodules, but that can't happen just yet.</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li><p>python2 and python3 (uses the <a href="https://docs.python.org/3/library/functions.html#__import__" rel="nofollow noreferrer">discouraged</a> <code>__import__</code>):</p>
<ul>
<li><p>from 1st level module (<code>pkg.foo</code>, <code>pgk.bar</code>, ...):</p>
<pre><code>local_name = __import__("", globals(), locals(), [], 1)
</code></pre></li>
<li><p>from module in subpackage (<code>pkg.subpkg.foo</code>, ...):</p>
<pre><code>local_name = __import__("", globals(), locals(), [], 2)
</code></pre></li>
</ul></li>
<li><p>python3 only*:</p>
<ul>
<li><p>From <code>pkg.foo</code> or <code>pkg.bar</code>:</p>
<pre><code>import importlib
local_name = importlib.import_module("..", __name__)
</code></pre></li>
<li><p>From <code>pkg.subpkg.baz</code>:</p>
<pre><code>import importlib
local_name = importlib.import_module("...", __name__)
</code></pre></li>
</ul></li>
</ul>
<p>*<code>import_module</code> on python2 tries load <code>pkg.</code> in this case, unfortunately.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's nothing special about the dunders (they're just discouraged when writing your own module/function names); you should just be able to do</p>
<pre><code>from .__init__ import my_function as local_name
</code></pre>
</div>
<span class="comment-copy">I don't want to import specific functions from <code>__init__.py</code>, I want the <i>entire module</i>.</span>
<span class="comment-copy">Explicitly importing the <code>__init__</code> module reexecutes the module, resulting in tow <i>different</i> modules (<code>pkg is pkg.__init__</code> is False). Each has its own namespace. If you change something in <code>pkg</code> (say somthing like <code>pkg.config.setSomeValue(...)</code>) it won't affect the counterpart in <code>pkg.__init__</code>.</span>
<span class="comment-copy">@mata This is starting to feel like a bug report :-/</span>
<span class="comment-copy">@zwol could you do <code>from .__init__ import *</code>?</span>
<span class="comment-copy">@maxymoo No, that would dump a huge amount of junk into the submodule and it would also require extensive and painful code changes.</span>
