<div class="post-text" itemprop="text">
<p>I have a function in which:</p>
<blockquote>
<p>Given a list of Python values xs and a non-negative integer n, construct and return a copy of xs but with each value replicated n times. Do NOT modify the original list 'xs'</p>
</blockquote>
<p>To do this, I created some small code that multiplied the list xs and then sorted it. </p>
<p><code>def replicate(xs,n):
    xscopy = sorted(n * xs)
    return xscopy</code> </p>
<p>This code will result in a function input like "replicate([1,2,2,3],2)" to output as [1,1,2,2,2,2,3,3] which is correct. Note how the correct output has the numbers' places matching. </p>
<p><strong>However</strong>, when a negative number is in the list, the 'sort' function sees the negative number as smaller than the positive numbers and shifts the position of the negative number from where it was originally on the list. </p>
<p>For example: replicate([1,-1,2,1],2) outputs to [-1,-1,1,1,1,1,2,2] rather than, the correct version, [1,1,-1,-1,2,2,1,1]. </p>
<p>Notice how the negative 1 shifted?</p>
<p>I am required to use a loop of some sort (while or for) for this task and I can't figure out how I could incorporate a loop that would both preserve the positions of the numbers and append the numbers properly into a new list (a new list that contains both the original xs, and the duplicates, in the same order as the original.</p>
<p>EDIT: I should add that list comprehension is restricted for this task</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to sort it. For each number in the list, loop <code>n</code> times and add it to a new list, so you preserve the original list and still get what you wanted.</p>
<pre><code>def replicate(xs,n):
    result = []
    for num in xs:
        for _ in range(n):
            result.append(num)

    return result
</code></pre>
<p>A cleaner way would be using list comprehension <code>return [num for num in xs for _ in range(n)]</code></p>
<p>Either way, output of  <code>replicate([1,-1,2,1],2)</code> is <code>[1, 1, -1, -1, 2, 2, 1, 1]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You could just use a nested list comprehension if you want to keep the order of the elements from the original list, this will take each element from the list <em>xs</em>, repeat it n times and then go for the next element and so on:</p>
<pre><code>xs = [1,-1,2,1]
n = 2

[x for x in xs for _ in range(n)]
# [1, 1, -1, -1, 2, 2, 1, 1]

xs = [1,2,3]
n = 2
[x for x in xs for _ in range(n)]
# [1, 1, 2, 2, 3, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def replicate(xs, n):
  return [item for item in xs for repeat in range(n)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a single-element list, and then multiply it. Once you have an n-element list, you can <a href="https://docs.python.org/3/library/itertools.html?highlight=itertools.chain#itertools.chain" rel="nofollow noreferrer"><code>extend()</code></a> the result list with that portion of the result.</p>
<pre><code>result = []
for item in xs:
    nitems = [item] * n
    result.extend(nitems)
</code></pre>
<p>The <code>functools.reduce</code> function can be used for this:</p>
<pre><code>import functools
return functools.reduce((lambda a,b: a + [b]*n), xs, [])
</code></pre>
<p>The <code>sum</code> builtin can do something similar:</p>
<pre><code>return sum( [ [x]*n for x in xs], [])
</code></pre>
<p>The <a href="https://docs.python.org/3/library/itertools.html?highlight=itertools.chain#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> function can paste together a bunch of iterables, so you could just multiply the values into a bunch of sub-lists and pass them to it:</p>
<pre><code>import itertools
return list(itertools.chain(*[ [x]*n for x in xs ]))
</code></pre>
<p>Or, without the splat (<code>*</code>) operator:</p>
<pre><code>import itertools
return list(itertools.chain.from_iterable([[x]*n for x in xs])
</code></pre>
<p>Or, you could <code>zip</code> the original list against itself, then flatten those tuples. (This would be good for long lists, especially if you could just return the iterable instead of a list):</p>
<pre><code>import itertools
return list(itertools.chain.from_iterable(zip(*[iter(xs) for _ in range(n)])))
</code></pre>
</div>
<span class="comment-copy">Sorry maybe I'm missing something here, but why exactly are you sorting it?</span>
<span class="comment-copy">As mitch said, both of your examples are being sorted with the <code>sorted()</code> function. You should avoid that if you don't want the order to change.</span>
<span class="comment-copy">I'm sorting it because if I didn't, the output for, say, "replicate([1,2,3],2)" would be "[1,2,3,1,2,3]" instead of "[1,1,2,2,2,2,3,3]" since I am multiplying the list as a whole.</span>
<span class="comment-copy">Could you explain what the "_" is doing in the loop? I understand that the value num is being appended after every iteration but how exactly is that happening?</span>
<span class="comment-copy">@PrithviBoinpally the "_" is to indicate a throw away variable, a variable which value we don't care about</span>
<span class="comment-copy">It just means you ignore that value. Say instead of <code>[for i in range(10)]</code>, but you don't use the value <code>i</code>, then you could write <code>[for _ in range(10)]</code></span>
<span class="comment-copy">So is it simply a place to fill with the value of the appeneded num?</span>
<span class="comment-copy">No it wouldn't. Unless you use <code>i</code> somewhere you shouldn't.</span>
<span class="comment-copy">Thank you for the answer but I avoided using list comprehension because I am not allowed to for the assignment.</span>
<span class="comment-copy">Thank you for the answer, but I am not allowed to import anything.</span>
<span class="comment-copy">Hi I edited answer without <code>itertools </code></span>
<span class="comment-copy">Sorry, but I avoided using list comprehension because that is also restricted.</span>
