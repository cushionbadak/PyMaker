<div class="post-text" itemprop="text">
<p>I have a stream of strings where I need to analyze each one and check whether it is a valid JSON.
The pythonic way (<a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a>) dictates something like this:</p>
<pre><code>import json
def parse_json(string):
    try:
        return json.loads(string)
    except:
        return string
</code></pre>
<p>The problem is that a significant number of strings are not JSONs, and the many exceptions raised by this code slow the process quite a bit.</p>
<p>I am looking for some way to try and parse the text as JSON, returning some kind of pre-defined value (e.g. an empty <code>tuple()</code>) indicating the string is not JSON compatible.
I don't mind hacking around the standard json package (overriding a function or two..) if this is the easiest solution.</p>
<p>Any suggestions?</p>
<p>Update:
As I'm only interested in 'complex' JSONs (arrays and objects), I've eventually decided to go with a simple if to check the first and last characters of the string:</p>
<pre><code>try:
    import ujson as json
except ImportError:
    import json


def parse_json(string):
    if len(text) &gt; 0:
        text = text.strip()
        if text != "" and ((text[0] == "{" and text[-1] == "}") or (text[0] == "[" and text[-1] == "]")):
            try:
                return json.loads(string)
            except:
                return string
</code></pre>
<p>ujson is a much more efficient implementation than Python's standard json. Additionally, skipping all strings which are not wrapped with [] or {} reduces the amount of exceptions by a large factor. It turns out that mixing <a href="https://docs.python.org/3/glossary.html#term-lbyl" rel="nofollow noreferrer">LBYL</a> and EAFP was what I needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>for speed issue you can use multiprocessing to speed up the parsing , for example by utilizing 5 workers in multiprocessing you parse 5 string at a time instead of one</p>
<p>if i understand second part of question , for custom exception do something like this to get custom error for different error that return by json:</p>
<pre><code>def parse_json(string):
    try:
        return json.loads(string)
    except exception1 as ex1:
        print(ex1)
        return string
    except exception2 as ex2:
        print(ex2)
        return string
    exc....
</code></pre>
<p>or if you don't want to get any exception on error raising do this , just give it a pass to do nothing , not showing up anything:</p>
<pre><code>def parse_json(string):

try:
    return json.loads(string)
except exception1 as ex1:
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the string is JSON it should start with "{" and end with "}".</p>
<p>I think you can firstly do a check if the string starts with "{"; if not, you know for sure it's a simple string; if it starts with "{" you can parse it and use the try/except (just to be sure it's not just a simple string starting with "{").</p>
</div>
<span class="comment-copy">I doubt very much that the overhead is in catching the exception, but rather in trying to parse the string in the first place.</span>
<span class="comment-copy">As @Danield points out, try/except handling is relatively cheap in Python. Checking if a string is valid JSON and then converting it is likely to be slower than what you're doing. However if the invalid ones are all broken in the same way, you <i>may</i> be able to avoid trying to convert them with <code>loads()</code> if a way to checking for that condition is extremely quick.</span>
<span class="comment-copy">@DanielRoseman while a try-except clause is practically free when no exceptions are raised, but costly otherwise (e.g. <a href="http://stackoverflow.com/a/2522013/4369617">stackoverflow.com/a/2522013/4369617</a>). As I have to process hundreds of millions of strings per day, this becomes a burden.</span>
<span class="comment-copy">@marineau interesting approach. I'll analyze what are the most common exception causes and check them accordingly üëçüèº</span>
<span class="comment-copy">multi/distributed processing is an option, but it does not reduce the extra processing time of exceptions, which I want to offload. Ideally, I'd like the json.loads() function to return a pre-defined value when the parsing fails instead of raising an exception.</span>
<span class="comment-copy">Not all valid JSON values are objects.</span>
