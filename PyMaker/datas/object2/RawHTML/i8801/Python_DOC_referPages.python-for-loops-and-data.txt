<div class="post-text" itemprop="text">
<p>I have data that looks like this:</p>
<p>The columns are Name, ID, Dev ID, Date</p>
<pre><code>('Anthony', '1', '10', '4/3/2017')
('Anthony', '1', '11', '5/2/2017')
('Anthony', '1', '13', '12/30/2017
('Anthony', '1', '15', '8/20/2017'
('Anthony', '4', '17', '2/3/2018')
('Anthony', '4', '18', '3/28/2017'
('Bob', '1', '111', '4/3/2017')
('Bob', '1', '200', '5/2/2017')
('Bob', '1', '113', '12/30/2017')
('Bob', '1', '115', '8/20/2017')
('Bob', '4', '117', '2/3/2018')
('Bob', '4', '118', '3/28/2017')
</code></pre>
<p>I'm trying to find unique Name's and ID's and then compare any dates and return only the one furthest in the future.</p>
<p>Ideally I want output that looks like:</p>
<pre><code>('Anthony', '1', '12/30/2017')
('Anthony', '4', '2/3/2018')
('Bob', '1', '12/30/2017')
('Bob', '4', '2/3/2018')
</code></pre>
<p>I'm struggling because I have multiple keys and I can't figure out how to make it work. Any ideas?</p>
<p>Edit: This is only a sample I have 30ish people names and 10 unique id's. So i'm looking to make a For loop to figure this out.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby</code> combined with <code>max</code> to get output similar to what you're looking for.</p>
<pre><code>import itertools
from datetime import datetime

data = [('Anthony', '1', '10', '4/3/2017'),
         ('Anthony', '1', '11', '5/2/2017'),
         ('Anthony', '1', '13', '12/30/2017'),
         ('Anthony', '1', '15', '8/20/2017'),
         ('Anthony', '4', '17', '2/3/2018'),
         ('Anthony', '4', '18', '3/28/2017'),
         ('Bob', '1', '111', '4/3/2017'),
         ('Bob', '1', '200', '5/2/2017'),
         ('Bob', '1', '113', '12/30/2017'),
         ('Bob', '1', '115', '8/20/2017'),
         ('Bob', '4', '117', '2/3/2018'),
         ('Bob', '4', '118', '3/28/2017')]

groups_with_max_date = []
for key, group in itertools.groupby(data, lambda d: (d[0], d[1])):
    # convert to datetime and get max of group
    group_max = max(group, key=lambda q: datetime.strptime(q[3], '%m/%d/%Y'))
    groups_with_max_date.append(group_max)

groups_with_max_date
</code></pre>
<p>Gives us:</p>
<pre><code>[('Anthony', '1', '13', '12/30/2017'),
 ('Anthony', '4', '17', '2/3/2018'),
 ('Bob', '1', '113', '12/30/2017'),
 ('Bob', '4', '117', '2/3/2018')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The solution using <code>datetime</code> object, <code>dict.setdefault()</code>, <code>max</code> and <code>datetime.strptime</code> functions:</p>
<pre><code>import datetime

l = [('Anthony', '1', '10', '4/3/2017'),('Anthony', '1', '11', '5/2/2017'),('Anthony', '1', '13', '12/30/2017'),('Anthony', '1', '15', '8/20/2017'),
('Anthony', '4', '17', '2/3/2018'),('Anthony', '4', '18', '3/28/2017'),('Bob', '1', '111', '4/3/2017'),('Bob', '1', '200', '5/2/2017'),
('Bob', '1', '113', '12/30/2017'),('Bob', '1', '115', '8/20/2017'),('Bob', '4', '117', '2/3/2018'),('Bob', '4', '118', '3/28/2017')]

d = {}
for t in l:
    # grouping items by first two values of each tuple(accumulating `date` strings) 
    d.setdefault(t[0] +'-'+ t[1], []).append(t[3]) # first two values of a tuple are combined to be a "hash" key

# getting max date from the list of `datetime` objects
result = [(*k.split('-'), max(v, key=lambda dt: datetime.datetime.strptime(dt, '%m/%d/%Y'))) for k,v in sorted(d.items())]

print(result)
</code></pre>
<p>The output:</p>
<pre><code>[('Anthony', '1', '12/30/2017'), ('Anthony', '4', '2/3/2018'), ('Bob', '1', '12/30/2017'), ('Bob', '4', '2/3/2018')]
</code></pre>
</div>
<span class="comment-copy">This will only work if the columns are sorted by "Name" and "Id"</span>
<span class="comment-copy">You could use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter(0,1)</code></a> as the key to sort and groupby <code>data</code>.</span>
