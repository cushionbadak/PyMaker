<div class="post-text" itemprop="text">
<p>I am dealing with a dictionary with alphanumeric key and I need to sort them.
The desired order is</p>
<pre><code>a1 : 3
a2 : 2
b1 : 2
b2 : 3
c1 : 5
a1 b2 : 3
a2 b1 : 2
a1 c1 : 3
a2 c1 : 2
b1 c1 : 2
b2 c1 : 3
a1 b2 c1 : 3
a2 b1 c1 : 2
</code></pre>
<p>However, What i got so far is </p>
<pre><code> for key in sorted(s1.keys(),key = lambda item: (len(item),item,)):
      print("%s: %s" % (key, s1[key]))

 a1: 3
 a2: 2
 b1: 2
 b2: 3
 c1: 5
 a1 b2: 3
 a1 c1: 3
 a2 b1: 2
 a2 c1: 2
 b1 c1: 2
 b2 c1: 3
 a1 b2 c1: 3
 a2 b1 c1: 2
</code></pre>
<p>The thing is I want to go in the order of A-&gt;B-&gt;C-&gt;AB-&gt;AC-&gt;BC-&gt;ABC first then sort each small group according to the number value, for example, for AB, if I have a1b1,a2b1,a1b2,a2b2, then the order will be a1b1,a1b2,a2b1,a2b2. </p>
</div>
<div class="post-text" itemprop="text">
<p>As a <code>key</code> function, you could <code>split</code> and <a href="https://docs.python.org/3.5/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> the keys:</p>
<pre><code>&gt;&gt;&gt; s = 'a1 b2 c1'
&gt;&gt;&gt; list(zip(*s.split()))
[('a', 'b', 'c'), ('1', '2', '1')]
</code></pre>
<p>To sort <code>b</code> before <code>a b</code>, you also have to take the number of segments into account.</p>
<p>For your <code>s1</code> data:</p>
<pre><code>&gt;&gt;&gt; sorted(s1, key=lambda s: (s.count(' '), list(zip(*s.split()))))
['a1',
 'a2',
 'b1',
 'b2',
 'c1',
 'a1 b2',
 'a2 b1',
 'a1 c1',
 'a2 c1',
 'b1 c1',
 'b2 c1',
 'a1 b2 c1',
 'a2 b1 c1']
</code></pre>
<p>If there can be more than one letter or digit per block, you could use <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer"><code>re.findall</code></a> instead:</p>
<pre><code>&gt;&gt;&gt; s = "aa12 bb34 cc56"
&gt;&gt;&gt; re.findall("[a-z]+", s), re.findall("\d+", s)
(['aa', 'bb', 'cc'], ['12', '34', '56'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One possibility would be to extend your approach and explicitly partition the letters and numbers in the creation of the sorting key:</p>
<pre><code>d = {
'a1': 3,
'a2': 2,
'b1': 2,
'b2': 3,
'c1': 5,
'a1 b2': 3,
'a2 b1': 2,
'a1 c1': 3,
'a2 c1': 2,
'b1 c1': 2,
'b2 c1': 3,
'a1 b2 c1': 3,
'a2 b1 c1': 2
}

def fn(key):
    letters = key[0::3] #extract the "letter" part of the key
    idx = key[1::3] #extract the "numeric" part of the key

    #construct the composite key
    return (len(letters), letters, idx)

for key in sorted(d.keys(), key = fn):
    print(key, d[key])
</code></pre>
<p>produces</p>
<pre><code>('a1', 3)
('a2', 2)
('b1', 2)
('b2', 3)
('c1', 5)
('a1 b2', 3)
('a2 b1', 2)
('a1 c1', 3)
('a2 c1', 2)
('b1 c1', 2)
('b2 c1', 3)
('a1 b2 c1', 3)
('a2 b1 c1', 2)
</code></pre>
</div>
<span class="comment-copy">have a look at groupby <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">docs.python.org/2/library/itertools.html#itertools.groupby</a>. But I'm not sure that's going to be the most elegant solution.</span>
<span class="comment-copy">Are letter and number always one digit? Is there always a space in between? Can there be letters without numbers or vice versa?</span>
<span class="comment-copy">@tobias_k yes the format will always be a letter and a digit and a space in between</span>
<span class="comment-copy">Thank you for your help!</span>
<span class="comment-copy">Thank you for your help!</span>
