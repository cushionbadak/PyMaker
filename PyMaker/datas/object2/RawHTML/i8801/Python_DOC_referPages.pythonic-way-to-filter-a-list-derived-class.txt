<div class="post-text" itemprop="text">
<p>Here is the pseudo code:</p>
<pre><code>class Foo (list):
    def methods...

foo=Foo()
foo.readin()

rule='....'
bar=[for x in foo if x.match(rule)]
</code></pre>
<p>Here, bar is of a list, however I'd like it to be a instance of Foo, The only way I know is to create a for loop and append items one by one:</p>
<pre><code>bar=Foo()

for item in foo:
    if item.match(rule):
        bar.append(item)
</code></pre>
<p>So I'd like to know if there is any more concise way or more pythonic way to do this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can pass in a <a href="https://docs.python.org/3/tutorial/classes.html#generator-expressions" rel="nofollow noreferrer">generator expression</a> to the <code>Foo()</code> call:</p>
<pre><code>bar = Foo(x for x in foo if x.match(rule))
</code></pre>
<p>(When passing a generator expression to a call, where it is the only argument, you can drop the parentheses you normally would put around a generator expression).</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems another answer got deleted because the original answerer deleted it. So I post the other way here for completeness. If the origin answerer restore he's answer I will delete this answer myself.</p>
<p>another way to do this is to use the build in filter function. the code is :</p>
<pre><code>bar=filter( lambda x: x.match(rule) , foo )
</code></pre>
<p>I guess why the original answer guy deleted his answer because it is said to be a not encouraged using the filter function. I have done some research before asked this question. But I think I learned a lot from that answer. Because I have tried to use the filter function myself , but never figured out how to use it correctly. So this answer taught me how to read the manual Correctly, and no matter what, it is still a valid way to solve my problem. So here, if the original answerer can see my post, thank you I appreciate your help and it surely helped me.</p>
<p>updated:
   as what said by Martijn in the comment, this is not a valid answer. I'll keep this anwser because this talk is good. but this is not a valid way to solve my problem.</p>
</div>
<span class="comment-copy">You could do <code>bar = Foo(x for x in foo if x.match(rule))</code>.</span>
<span class="comment-copy">hey ,where is another answer ? another guy answered using filter() function, but while I was commenting , it is deleted. hey , answerer guy, I appreciate your answer, you can put it back. because I learned from your answer and it is surely a valid way.</span>
<span class="comment-copy">Wow, never know comprehension expressions can be used in class creation, great, thank you.</span>
<span class="comment-copy">@social_loser You mean instance creation.</span>
<span class="comment-copy">@social_loser: you can pass a generator expression to any call (functions, methods, classes to create an instance).</span>
<span class="comment-copy">Definitely the pythonic and elegant way, but could fail if <code>methods</code> included a mischievously overwritten <code>__init__</code>.</span>
<span class="comment-copy">Isn't the generator missing an expression before <code>for</code>?</span>
<span class="comment-copy">This doesn't create a new <code>Foo</code> instance; in Python 3 this produces a filter object (an iterator), in Python 2 a <code>list</code> object. So in Python 3, this <i>might</i> qualify if you did <code>Foo(filter(lambda x: x.match(rule), foo))</code>, but that's more verbose and slower than the generator expression option in my answer. In Python 2, it's no better than the list comprehension that your question already had, you again have to pass it to <code>Foo()</code> to turn it into an instance of the list subclass, but now you have the added memory duplication.</span>
<span class="comment-copy">In other words, in Python 2, any list comprehension of the form <code>[target for target in iterable if &lt;condition on target&gt;]</code> is equivalent to <code>filter(lambda target: &lt;condition on target&gt;, iterable)</code>, in Python 3 it's the same thing as a generator expression, but because calling a function is slower, the <code>filter()</code> call usually looses in both speed and readability.</span>
<span class="comment-copy">yes, tested, it returns a filter object which make things more complex. I will note it in this answer and keep it for myself, since i'm a beginner , such kind of mistakes and correction can help me understand python better. thank you, @Martijn Pleters</span>
