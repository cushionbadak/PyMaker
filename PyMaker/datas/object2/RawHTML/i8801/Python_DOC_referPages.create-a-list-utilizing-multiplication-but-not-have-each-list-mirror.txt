<div class="post-text" itemprop="text">
<p>Quick question, hope you guys can help:</p>
<p>Here is my code:</p>
<pre><code>def nd_mkboard(dims, filler):
     n = len(dims)
     helpboard = [filler]
     helpboard = helpboard * dims[n-1]
     for i in reversed(range(n)):
         if i != 1:
             helpboard = [helpboard] * dims[i-1]
     return helpboard
</code></pre>
<p>ex.:</p>
<pre><code>stuff = nd_mkboard([2, 4, 2], False)
print(stuff)

[[[False, False], [False, False], [False, False], [False, False]], 
[[False, False], [False, False], [False, False], [False, False]]]

stuff[0][0][0] = True
print(stuff)

[[[True, False], [True, False], [True, False], [True, False]],
[[True, False],  [True, False], [True, False], [True, False]]]
</code></pre>
<p>How do I avoid this linkage problem? All I want is:</p>
<pre><code>[[[True, False], [False, False], [False, False], [False, False]], 
[[False, False], [False, False], [False, False], [False, False]]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See <a href="https://docs.python.org/3/library/copy.html?highlight=deepcopy#copy.deepcopy" rel="nofollow noreferrer">this question</a>.</p>
<p>Lists are references. So copying a list is copying references, which means you wind up pointing to the same thing.</p>
<p>Multiplying a list is making multiple copies, as above.</p>
<p>To get around this problem, use the <code>list[:]</code> slice notation to clone the list, or structure your code to create new lists each iteration.</p>
<p>You're pretty much doomed as far as making copies goes, since that's what you want to avoid. You could use <a href="https://docs.python.org/3/library/copy.html?highlight=deepcopy#copy.deepcopy" rel="nofollow noreferrer"><code>copy.deepcopy</code></a>, but you might be better off just writing a recursive function.</p>
<p><strong>Update:</strong></p>
<p>Here's a function that recursively builds the structure, and can handle constructed objects as well.</p>
<pre><code>def make_structure(dim1, *args, fill=None):
    fill = False if fill is None else fill
    get_fill = lambda: fill() if callable(fill) else fill

    result = []
    for i in range(dim1):
        if len(args):
            result.append(make_structure(*args, fill=fill))
        else:
            result.append(get_fill())

    return result

lines = [2,4,2]

s = make_structure(2,4,2)
print(s)
s[0][0][0] = True
print(s)

class TestObj:
    def __init__(self):
        self.id = id(self)

    def __repr__(self):
        return str(self.id)

s = make_structure(2,4,2,fill=TestObj)
print(s)
s[0][2][1] = TestObj()
print(s)
</code></pre>
<p><strong>Update 2:</strong></p>
<p>List instead of args:</p>
<pre><code>def make_structure(dims, fill=None):
    fill = False if fill is None else fill
    get_fill = lambda: fill() if callable(fill) else fill

    result = []
    for i in range(dims[0]):
        if len(dims) &gt; 1:
            result.append(make_structure(dims[1:], fill=fill))
        else:
            result.append(get_fill())

    return result
</code></pre>
</div>
<span class="comment-copy">Thank you so much. Any hints for starting the recursive function?</span>
<span class="comment-copy">The function is <b>recursive</b>. Greta Garbo was <b>reclusive.</b> :-) I've added an update.</span>
<span class="comment-copy">This is absolutely wonderful, thank you so much. One last question, is there anyway to pass a dim as a list instead of multiple arguments? Sorry to bother you. For example, make_structure([2,4,2]) instead of make_structure(2,4,2).</span>
<span class="comment-copy">Sure, just modify it. Instead of dim1 it would be dims[0], and len(dims)-1 instead of len(args).</span>
<span class="comment-copy">Added an update.</span>
