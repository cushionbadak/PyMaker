<div class="post-text" itemprop="text">
<p>In this example code, I would like to determine if <code>x</code> is an instance of <code>TestProperty</code>:</p>
<pre><code>class TestProperty(object):
    def __init__(self, name):
        self._name = name

    def __get__(self, instance, cls):
        return getattr(instance, self._name)

    def __set_(self, instance, value):
        setattr(instance, self._name, value)

class Test(object):
    x = TestProperty("x")

print isinstance(Test.x, TestProperty)
</code></pre>
<p>However, I get the following exception:</p>
<pre><code>Traceback (most recent call last):
  File "/home/zenoss/testproperties.py", line 14, in &lt;module&gt;
    print isinstance(Test.x, TestProperty)
  File "/home/zenoss/testproperties.py", line 6, in __get__
    return getattr(instance, self._name)
AttributeError: 'NoneType' object has no attribute 'x'
</code></pre>
<p>Is there anyway to tell if an attribute is an instance of a class when it is a descriptor?</p>
</div>
<div class="post-text" itemprop="text">
<p>With the current <code>__get__</code>, <code>Test.x</code> causes the <code>AttributeError</code> because when the code accessing the descriptor using class, <code>instance</code> is passed <code>None</code>; (=&gt; <code>getattr(None, 'x')</code> =&gt; <code>None.x</code>)</p>
<p>You should modify <code>__get__</code> to handle such case:</p>
<pre><code>&gt;&gt;&gt; class TestProperty(object):
...     def __init__(self, name):
...         self._name = name
...     def __get__(self, instance, cls):
...         if instance is None:  # To handle access through class, not instance
...             return self       # returns the TestProperty instance itself.
...         return getattr(instance, self._name)
...     def __set_(self, instance, value):
...         setattr(instance, self._name, value)
... 
&gt;&gt;&gt; class Test(object):
...     x = TestProperty("x")
... 
&gt;&gt;&gt; isinstance(Test.x, TestProperty)
True
</code></pre>
<hr/>
<p>BTW, as you may know, with <code>x = TestProperty("x")</code>, accessing <code>x</code> attribute through an instance will cause another exception, because it will call the <code>__get__</code> (-&gt; getattr(..) -&gt; __get__ -&gt; getattr(..) -&gt; ...) recursively until stack overflow.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best way to implement a property is with the <code>@property</code> decorator:</p>
<pre><code>class TestProperty(object):

    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        """Getter for '_name'."""
        return self._name

    @name.setter
    def name(self, value):
        """Setter for '_name'."""
        self._name = value

class Test(object):
    x = TestProperty("x")

print(isinstance(Test.x, TestProperty))
</code></pre>
<p>It returns <code>True</code> when I run it.
See the documentation for <code>@property</code> at <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#property</a>.</p>
</div>
<span class="comment-copy">Thanks, returning <code>self</code> when <code>instance is None</code> does the trick.</span>
<span class="comment-copy">@Ben, You're welcome. Happy Python hacking!</span>
