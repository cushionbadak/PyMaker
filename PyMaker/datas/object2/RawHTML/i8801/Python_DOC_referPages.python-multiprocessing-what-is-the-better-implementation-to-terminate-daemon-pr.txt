<div class="post-text" itemprop="text">
<p>I'm using multiprocessing on Python 3.6 on Ubuntu to handle the faster communication with another device. </p>
<p>I set <code>daemon = True</code> to terminate the child process when the parent process finishes. However, when the main process is terminated, the another process (_another_process in the following code) sometimes isn't terminated and continues to be alive. Then, when I run the same program again, I get <code>address already in use</code> error when I run the above code. Of course, I can kill this process, but it's annoying and I'd like to solve. </p>
<pre><code>Class Xxx
 def __init__(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.settimeout(2.5)
        self.sock.bind((self.ip, self.port))
        self.sock.settimeout(None)    
        self.start_process()
        time.sleep(1.5)

    def start_process(self):      
        p = mp.Process(target=self._another_process)
        time.sleep(1)
        p.daemon = True
        p.start()

    def _another_process(self):
        while True:
            # Do continuous (infinite) operation
</code></pre>
<p>I don't know why sometimes terminated and sometimes not, but are there any better implementations to realize what I want? Or, is <code>daemon = True</code> the best way? </p>
<p>I believe I shouldn't use <code>join()</code> because my child process has an infinite operation, but if I misunderstood, please let me know.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the python3 docs, process.terminate() in the main's destructor:</p>
<p><code>p.start()
print(p, p.is_alive())
p.terminate()</code> </p>
<p>This will send SIGTERM to be handled by the child process.
alternatively, use <code>p.kill()</code> to send SIGKILL.</p>
<p>Full example at <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">https://docs.python.org/3/library/multiprocessing.html</a></p>
<p>For how to handle SIGTERM in your application:
<a href="https://stackoverflow.com/questions/18499497/how-to-process-sigterm-signal-gracefully">How to process SIGTERM signal gracefully?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>To solve the "address already in use" problem, try adding the <em>SO_REUSEADDR</em> socket option.</p>
</div>
<span class="comment-copy">Thank you. I already got two solutions but not sure which is better. Is it safe to use SO_REUSEADDR? Is main destructor called whenever terminate the process?</span>
<span class="comment-copy">Thank you. I'd use this. Are there any downside or potential issues to use this?</span>
<span class="comment-copy">Well you should be aware that it does not force the child process to terminate, but rather send unix signal SIGTERM that can be caught, ignored, or handled in any way by the child process.</span>
<span class="comment-copy">I create destructor (I replace <code>p</code> to <code>self.process</code>) and run terminate(), but it still runs. The result of <code>print(self.process, self.process.is_alive())</code> is <code>&lt;Process(Process-1), started daemon)&gt;</code></span>
<span class="comment-copy">I would suggest either SIGKILL that that cannot be caught - instead of <code>terminate()</code> use <code>kill()</code> or otherwise catch the SIGTERM inside your child process and exit gracefully. <a href="http://stackoverflow.com/questions/18499497/how-to-process-sigterm-signal-gracefully" title="how to process sigterm signal gracefully">stackoverflow.com/questions/18499497/â€¦</a></span>
<span class="comment-copy">Thanks. I tried to use graceful exit, but whenever SIGTERM is called, the child process pauses its process, therefore, cannot exit gracefully by using flags.</span>
