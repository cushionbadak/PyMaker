<div class="post-text" itemprop="text">
<p>So I have 2 lists, one looks like:</p>
<pre><code>drivers = ['bob','Lenny','frank','sunny']
</code></pre>
<p>the other looks like:</p>
<pre><code>cities = ['Austin','San Antonio','Houston']
</code></pre>
<p>This could be easily represented by a table like:</p>
<pre><code>            |  bob  | lenny | frank | sunny
Austin      |  $45  |  $15  |  $77  |  $33
San Antonio |  $12  |  $23  |  $10  |  $18
Houston     |  $44  |  $99  |  $78  |  $12
</code></pre>
<p>So I want to calculate all the VALID combinations, meaning that I can leave a drive outside the schedule but I cannot put a driver on 2 cities at the same, and I cannot leave a city without a driver. </p>
<p>Any ideas? </p>
</div>
<div class="post-text" itemprop="text">
<p>If you can make the assumption that <strong>all cities in <code>cities</code> are unique</strong>, you can simply generate all <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>itertools.permutations</code></a> of length <code>len(cities)</code>, and (optionally) zip them with the cities like:</p>
<pre><code>def valid_combinations(cities,drivers):
    return itertools.permutations(drivers,len(cities))
</code></pre>
<p>Or if you want to zip them with the cities:</p>
<pre><code>def valid_combinations(cities,drivers):
    for perm in itertools.permutations(drivers,len(cities)):
        yield zip(cities,perm)
</code></pre>
<p>For the last one we generate:</p>
<pre><code>&gt;&gt;&gt; list(map(tuple,valid_combinations(cities,drivers)))
[(('Austin', 'bob'), ('San Antonio', 'Lenny'), ('Houston', 'frank')),
(('Austin', 'bob'), ('San Antonio', 'Lenny'), ('Houston', 'sunny')),
(('Austin', 'bob'), ('San Antonio', 'frank'), ('Houston', 'Lenny')),
(('Austin', 'bob'), ('San Antonio', 'frank'), ('Houston', 'sunny')),
(('Austin', 'bob'), ('San Antonio', 'sunny'), ('Houston', 'Lenny')),
(('Austin', 'bob'), ('San Antonio', 'sunny'), ('Houston', 'frank')),
(('Austin', 'Lenny'), ('San Antonio', 'bob'), ('Houston', 'frank')),
(('Austin', 'Lenny'), ('San Antonio', 'bob'), ('Houston', 'sunny')),
(('Austin', 'Lenny'), ('San Antonio', 'frank'), ('Houston', 'bob')),
(('Austin', 'Lenny'), ('San Antonio', 'frank'), ('Houston', 'sunny')),
(('Austin', 'Lenny'), ('San Antonio', 'sunny'), ('Houston', 'bob')),
(('Austin', 'Lenny'), ('San Antonio', 'sunny'), ('Houston', 'frank')),
(('Austin', 'frank'), ('San Antonio', 'bob'), ('Houston', 'Lenny')),
(('Austin', 'frank'), ('San Antonio', 'bob'), ('Houston', 'sunny')),
(('Austin', 'frank'), ('San Antonio', 'Lenny'), ('Houston', 'bob')),
(('Austin', 'frank'), ('San Antonio', 'Lenny'), ('Houston', 'sunny')),
(('Austin', 'frank'), ('San Antonio', 'sunny'), ('Houston', 'bob')),
(('Austin', 'frank'), ('San Antonio', 'sunny'), ('Houston', 'Lenny')),
(('Austin', 'sunny'), ('San Antonio', 'bob'), ('Houston', 'Lenny')),
(('Austin', 'sunny'), ('San Antonio', 'bob'), ('Houston', 'frank')),
(('Austin', 'sunny'), ('San Antonio', 'Lenny'), ('Houston', 'bob')),
(('Austin', 'sunny'), ('San Antonio', 'Lenny'), ('Houston', 'frank')),
(('Austin', 'sunny'), ('San Antonio', 'frank'), ('Houston', 'bob')),
(('Austin', 'sunny'), ('San Antonio', 'frank'), ('Houston', 'Lenny'))]
</code></pre>
<p>So in the first case <code>'bob'</code> drives to <code>'Austin'</code>, <code>'Lenny'</code> to <code>'San Antonio'</code> and <code>'frank'</code> to <code>'Houston'</code>; in the second case <code>'bob'</code> drives to <code>'Austin'</code>, <code>'Lenny'</code> to <code>'San Antonio'</code> and <code>'sunny'</code> to <code>'Houston'</code>; and so on. The total number of valid configurations is here <em>2×3×4=24</em> which is also the number of elements that are <code>yield</code>ed.</p>
<p>Nevertheless if you want to find the optimal combinations - something that is not clear from your question - you can use a variant of the <em>Hungarian algorithm</em> to solve this in <em>O(n<sup>3</sup>)</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A way for a hierarchical presentation, using Pandas Dataframe:</p>
<p>with df :</p>
<pre><code>            bob  lenny  frank  sunny
Austin       45     15     77     33
SanAntonio   12     23     10     18
Houston      44     99     78     12
</code></pre>
<p>We can do :</p>
<pre><code>m,n=df.shape
idx=[list(t) for t in itertools.permutations(range(n),m) ]
cash=df.values[range(m),idx]
staff=np.take(df.columns.tolist(),idx)
total=pd.DataFrame(index=staff,data=cash,columns=df.index)
total['amount']=cash.sum(axis=1)
print (total.sort_values('amount',ascending=False))
</code></pre>
<p>For : </p>
<pre><code>                       Austin  SanAntonio  Houston  amount
(frank, sunny, lenny)      77          18       99     194
(frank, bob, lenny)        77          12       99     188
(bob, sunny, lenny)        45          18       99     162
(bob, frank, lenny)        45          10       99     154
(bob, lenny, frank)        45          23       78     146
(frank, lenny, bob)        77          23       44     144
(sunny, bob, lenny)        33          12       99     144
(sunny, frank, lenny)      33          10       99     142
(bob, sunny, frank)        45          18       78     141
(frank, sunny, bob)        77          18       44     139
(sunny, lenny, frank)      33          23       78     134
(sunny, bob, frank)        33          12       78     123
(frank, lenny, sunny)      77          23       12     112
(lenny, sunny, frank)      15          18       78     111
(lenny, bob, frank)        15          12       78     105
(frank, bob, sunny)        77          12       12     101
(sunny, lenny, bob)        33          23       44     100
(sunny, frank, bob)        33          10       44      87
(bob, lenny, sunny)        45          23       12      80
(lenny, sunny, bob)        15          18       44      77
(lenny, frank, bob)        15          10       44      69
(bob, frank, sunny)        45          10       12      67
(lenny, bob, sunny)        15          12       12      39
(lenny, frank, sunny)      15          10       12      37
</code></pre>
</div>
<span class="comment-copy">Can you make the assumption that all elements in the <code>cities</code> are unique?</span>
<span class="comment-copy">Since the OP says that he can exclude drivers from a schedule, but not put two in the same city at once, wouldn't there be more valid combinations leaving out one or more drivers? I'm not sure I understood correctly, so I'd appreciate a clarification.</span>
<span class="comment-copy">@batbrat: well since there are three cities and four drivers in every schedule one drivers is excluded. For instance <code>'sunny'</code> does not drive in the first schedule.</span>
<span class="comment-copy">Ah! I missed the obvious! Thanks for clearing that up. If we can have two drivers in one city, those could be included, right? I realize this is a deviation from the OPs question: I just find myself curious.</span>
<span class="comment-copy">Indeed, what I'm looking is to find the optimal combinations, right now the matrix I'm working with has about 15x20, which takes ages to calculate with this approach, nevertheless, this is the right answer to my initial question.</span>
<span class="comment-copy">@WillemVanOnsem would you also share how to solve the optimal combinations problem with the Hungarian algorithm? This is clearly not my area of expertise. Many thanks in advance.</span>
<span class="comment-copy">I've been trying this but keep hitting:  <code>IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes (3,) (0,)</code></span>
<span class="comment-copy">mmmh.... idx seems to be empty. df.shape must be  (3,4), len(idx) must be 24,  len(idx[0]) =3. can you check that ?</span>
