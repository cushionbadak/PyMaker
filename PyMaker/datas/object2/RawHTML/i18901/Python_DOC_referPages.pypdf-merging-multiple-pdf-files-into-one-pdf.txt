<div class="post-text" itemprop="text">
<p>If I have 1000+ pdf files need to be merged into one pdf,</p>
<pre><code>input = PdfFileReader()
output = PdfFileWriter()
filename0000 ----- filename 1000
    input = PdfFileReader(file(filename, "rb"))
    pageCount = input.getNumPages()
    for iPage in range(0, pageCount):
        output.addPage(input.getPage(iPage))
outputStream = file("document-output.pdf", "wb")
output.write(outputStream)
outputStream.close()
</code></pre>
<p>Execute the above code，when <code>input = PdfFileReader(file(filename500+, "rb"))</code>,</p>
<p>An error message：
<code>IOError: [Errno 24] Too many open files:</code></p>
<p>I think this is a bug, If not, What should I do？</p>
</div>
<div class="post-text" itemprop="text">
<p>I recently came across this exact same problem, so I dug into PyPDF2 to see what's going on, and how to resolve it.</p>
<p><em>Note: I am assuming that <code>filename</code> is a well-formed file path string.  Assume the same for all of my code</em></p>
<p><strong>The Short Answer</strong></p>
<p>Use the <code>PdfFileMerger()</code> class instead of the <code>PdfFileWriter()</code> class.  I've tried to provide the following to as closely resemble your content as I could:</p>
<pre><code>from PyPDF2 import PdfFileMerger, PdfFileReader

[...]

merger = PdfFileMerger()
for filename in filenames:
    merger.append(PdfFileReader(file(filename, 'rb')))

merger.write("document-output.pdf")
</code></pre>
<p><strong>The Long Answer</strong></p>
<p>The way you're using <code>PdfFileReader</code> and <code>PdfFileWriter</code> is keeping each file open, and eventually causing Python to generate IOError 24.  To be more specific, when you add a page to the <code>PdfFileWriter</code>, you are adding references to the page in the open <code>PdfFileReader</code> (hence the noted IO Error if you close the file).  Python detects the file to still be referenced and doesn't do any garbage collection / automatic file closing despite re-using the file handle.  They remain open until <code>PdfFileWriter</code> no longer needs access to them, which is at <code>output.write(outputStream)</code> in your code.</p>
<p>To solve this, create copies in memory of the content, and allow the file to be closed.  I noticed in my adventures through the PyPDF2 code that the <code>PdfFileMerger()</code> class already has this functionality, so instead of re-inventing the wheel, I opted to use it instead.  I learned, though, that my initial look at <code>PdfFileMerger</code> wasn't close enough, and that it only created copies <em>in certain conditions</em>.</p>
<p>My initial attempts looked like the following, and were resulting in the same IO Problems:</p>
<pre><code>merger = PdfFileMerger()
for filename in filenames:
    merger.append(filename)

merger.write(output_file_path)
</code></pre>
<p>Looking at the PyPDF2 source code, we see that <code>append()</code> requires <code>fileobj</code> to be passed, and then uses the <code>merge()</code> function, passing in it's last page as the new files position. <code>merge()</code> does the following with <code>fileobj</code> (before opening it with <code>PdfFileReader(fileobj)</code>:</p>
<pre><code>    if type(fileobj) in (str, unicode):
        fileobj = file(fileobj, 'rb')
        my_file = True
    elif type(fileobj) == file:
        fileobj.seek(0)
        filecontent = fileobj.read()
        fileobj = StringIO(filecontent)
        my_file = True
    elif type(fileobj) == PdfFileReader:
        orig_tell = fileobj.stream.tell()   
        fileobj.stream.seek(0)
        filecontent = StringIO(fileobj.stream.read())
        fileobj.stream.seek(orig_tell)
        fileobj = filecontent
        my_file = True
</code></pre>
<p>We can see that the <code>append()</code> option does accept a string, and when doing so, assumes it's a file path and creates a file object at that location.  The end result is the exact same thing we're trying to avoid.  A <code>PdfFileReader()</code> object holding open a file until the file is eventually written!</p>
<p>However, if we either make a file object of the file path string <em>or</em> a <code>PdfFileReader</code><sup><em>(see Edit 2)</em></sup> object of the path string <em>before</em> it gets passed into <code>append()</code>, it will automatically create a copy for us as a <code>StringIO</code> object, allowing Python to close the file.</p>
<p>I would recommend the simpler <code>merger.append(file(filename, 'rb'))</code>, as others have reported that a <code>PdfFileReader</code> object may stay open in memory, even after calling <code>writer.close()</code>.</p>
<p>Hope this helped!</p>
<p><strong>EDIT:</strong> I assumed you were using <code>PyPDF2</code>, not <code>PyPDF</code>.  If you aren't, I highly recommend switching, as PyPDF is no longer maintained with the author giving his official blessings to Phaseit in developing PyPDF2.  </p>
<p>If for some reason you cannot swap to PyPDF2 (licensing, system restrictions, etc.) than <code>PdfFileMerger</code> won't be available to you.  In that situation you can re-use the code from PyPDF2's <code>merge</code> function (provided above) to create a copy of the file as a <code>StringIO</code> object, and use that in your code in place of the file object. </p>
<p><strong>EDIT 2:</strong> Previous recommendation of using <code>merger.append(PdfFileReader(file(filename, 'rb')))</code> changed based on comments <em>(Thanks @Agostino)</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The pdfrw package reads each file all in one go, so will not suffer from the problem of too many open files.  <a href="https://github.com/pmaupin/pdfrw/blob/master/examples/cat.py" rel="nofollow noreferrer">Here</a> is an example concatenation script.</p>
<p>The relevant part -- assumes <code>inputs</code> is a list of input filenames, and <code>outfn</code> is an output file name:</p>
<pre><code>from pdfrw import PdfReader, PdfWriter

writer = PdfWriter()
for inpfn in inputs:
    writer.addpages(PdfReader(inpfn).pages)
writer.write(outfn)
</code></pre>
<p>Disclaimer:  I am the primary pdfrw author.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you are only allowed to have a certain number of files open at any given time. There are ways to change this (<a href="http://docs.python.org/3/library/resource.html#resource.getrlimit" rel="nofollow">http://docs.python.org/3/library/resource.html#resource.getrlimit</a>), but I don't think you need this.</p>
<p>What you could try is closing the files in the for loop:</p>
<pre><code>input = PdfFileReader()
output = PdfFileWriter()
for file in filenames:
   f = open(file, 'rb')
   input = PdfFileReader(f)
   # Some code
   f.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It maybe just what it says, you are opening to many files.
You may explicitly use <code>f=file(filename) ... f.close()</code> in the loop, or use the <code>with</code> statement. So that each opened file is properly closed. </p>
</div>
<span class="comment-copy">I'll be honest; I haven't read the long answer. Short answer was great though.</span>
<span class="comment-copy">I noticed I couldn't delete some of the files appended creating an intermediate <code>PdfFileReader</code> object with the call <code>writer.append(PdfFileReader(file(filename, 'rb')))</code>. They remain locked even after calling <code>writer.close()</code>. The simpler call <code>merger.append(file(filename, 'rb'))</code> does not seem to have the same problem.</span>
<span class="comment-copy">Wouldn't this run into memory problem if the files are too big?</span>
<span class="comment-copy">@Nishant As with any objects you're creating in memory, yes.  Realistically, if you're getting into the gigabytes for a single PDF file, there's likely a better solution.</span>
<span class="comment-copy">@Rejected Alright thanks, its worth knowing that. A small utility function that choses named temporary file vs memory is a good solution I have seen on this.</span>
<span class="comment-copy">if use f.close(), exec output.write(outputStream), Prompt IO error.</span>
