<div class="post-text" itemprop="text">
<p>I have a Flask app running in a forked Gunicorn environment, but the stacktraces are getting interleaved in the logfile. Can each fork have its own logfile? or can each logger have exclusive access while writing to the log? </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Can each fork have its own logfile?</p>
</blockquote>
<p>Yes, although you probably don't need, or want, that. The easiest way to do this is to just stick <code>os.getpid()</code> somewhere in the filename.</p>
<blockquote>
<p>or can each logger have exclusive access while writing to the log?</p>
</blockquote>
<p>There are a few ways to do this, but the obvious one is to just replace the default <code>threading.RLock</code> in <code>logging</code> with a <code>multiprocessing.RLock</code>.</p>
<p>According to <a href="http://docs.python.org/3/library/logging.html#handler-objects" rel="nofollow">the docs</a>, you do this by overriding <code>createLock</code>, <code>acquire</code>, and <code>release</code>. So:</p>
<pre><code>class CrossProcessFileHandler(logging.FileHandler):
    def createLock(self):
        self.lock = multiprocessing.RLock()
    def acquire(self):
        self.lock.acquire()
    def release(self):
        self.lock.release()
</code></pre>
<p>And now just use that instead of <code>FileHandler</code>.</p>
<p>Just make sure to initializer the logger in the parent process; if each child creates its own separate cross-process lock, that won't help anything.</p>
<hr/>
<p>Note that if you care about cross-platform portability, the obvious trivial code might work as expected on POSIX but not on Windows. (I don't know enough about how <code>gunicorn</code> works on Windows to guess…) But you can deal with that by just not locking on Windows, because, by default, <code>FileHandler</code> opens the file for exclusive access, writes, and closes, meaning the filesystem is already doing your locking for you. (This trick doesn't work on POSIX because there is no such thing as Windows-style exclusive access—or, rather, there are equivalents on most platforms and filesystems, but they're not portable, and you have to go out of your way to do it instead of getting it by default whether you want it or not.)</p>
<hr/>
<p><a href="http://hg.python.org/cpython/file/3.3/Lib/logging/__init__.py#l777" rel="nofollow">The implementation of <code>acquire</code> and <code>release</code> for all built-in handlers for CPython 2.3 to 3.3</a> and every alternate implementation have always just been like this:</p>
<pre><code>if self.lock:
    self.lock.acquire()
</code></pre>
<p>So, you'll see code that cheats by only overriding <code>createLock</code>. I've done that multiple times myself, and I've seen it in various different third-party projects. But really, the documentation doesn't guarantee that, so you should override the other two as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>@abarnert solution works very well, however it requires to subclass every Handler used in the project. It may be simplified by the class decorator:</p>
<pre><code>def multiprocess_handler(cls):
    class MultiProcessHandler(cls):
        def createLock(self):
            self.lock = multiprocessing.RLock()
    return MultiProcessHandler

MFileHandler = multiprocess_handler(logging.FileHandler)
MRotatingFileHandler = multiprocess_handler(logging.handlers.RotatingFileHandler)
# etc.
</code></pre>
</div>
<span class="comment-copy">Not sure if this helps, we've been running with Gunicorns logging purely to <code>stdout</code>. Our process supervisor system is dealing with ensuring that <code>stdout</code> of each app like Gunicorn gets written to a real log file, which can be rotated/removed &amp;c. And Gunicorn apps are entirely unaware of all this... Never observed strack traces interleaving in our setup.</span>
