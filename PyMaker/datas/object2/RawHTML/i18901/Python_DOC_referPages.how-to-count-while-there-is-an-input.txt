<div class="post-text" itemprop="text">
<p>I'm trying to write a function that does not take an input, but instead asks for a name. If you enter an empty string, the function should print for every name the number of people with the same name.</p>
<p>for example:</p>
<pre><code>&gt;&gt;&gt;name()
Enter a name: Paul
Enter a name: Bill
Enter a name: John
Enter a name: Paul
Enter a name: Nick
Enter a name: Bill
Enter a name: Bill
Enter a name:    
There is 1 person named John
There is 1 person named Nick
There are 2 people named Paul
There are 3 people named Bill
</code></pre>
<p>so far I have:</p>
<pre><code>def name():
    name = input ('Enter a name: ')
    count = 0

    while name:
        if name == input ('Enter a name: '):
            count = count + 1
        else:
            print (count)
</code></pre>
<p>I'm pretty sure I'm not counting correctly.
How would you do this function properly, and how do you distinguish different inputs and count them when you do not know how many different names there are going to be?</p>
<p>Also, if possible, I would like basic code while I'm still learning even if it is not efficient.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python comes with a collection specifically made for counting, called <a href="http://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>Counter</code></a>.</p>
<pre><code>import collections

counts = collections.Counter()

while True:
    name = input('Enter a name: ')
    if not name:
        break
    counts[name] += 1

for name, count in counts.items():
    print('There is {} person named {}'.format(count, name))
</code></pre>
<p>If you want the results in order from least common to most, <code>Counter</code> has a function that sorts by count, <code>most_common</code>. Unfortunately, it's backwardâ€¦ but you can fix that by calling <code>reversed</code>:</p>
<pre><code>for name, count in reversed(counts.most_common()):
    print('There is {} person named {}'.format(count, name))
</code></pre>
<p>Or, if you'd prefer them sorted by name:</p>
<pre><code>for name, count in sorted(counts.items()):
    print('There is {} person named {}'.format(count, name))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just for fun a one-liner to do this:</p>
<pre><code>&gt;&gt;&gt; collections.Counter(iter(functools.partial(input, "Enter a name: "), ""))
Enter a name: Paul
Enter a name: Bill
Enter a name: John
Enter a name: Paul
Enter a name: Nick
Enter a name: Bill
Enter a name: Bill
Enter a name: 
Counter({'Bill': 3, 'Paul': 2, 'Nick': 1, 'John': 1})
</code></pre>
<p>This probably isn't the way to do it in real code.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import defaultdict
dic = defaultdict(int)
while True:
    name = input ('Enter a name: ')
    if name:
        dic[name] += 1
    else:
        for k,v in sorted(dic.items(), key = lambda x: (x[1],x[0])):
            print ("There is {} person named {}".format(v,k))
        break    
</code></pre>
<p>Demo:</p>
<pre><code>$ python3 so.py
Enter a name: Paul
Enter a name: Bill
Enter a name: John
Enter a name: Paul
Enter a name: Nick
Enter a name: Bill
Enter a name: Bill
Enter a name: 
There is 1 person named John
There is 1 person named Nick
There is 2 person named Paul
There is 3 person named Bill
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just use a simple python map.  This functions:</p>
<pre><code>names = {}

while True:
    name = raw_input('Enter a name: ')
    if not name:
        break
    if name not in names:
        names[name] = 0
    names[name] = names[name] + 1

for name in sorted(names, key=names.get):
    if names[name] &lt; 2:
        print 'There is %d person named %s' % (names[name], name)
    else:
        print 'There are %d people named %s' % (names[name], name)
</code></pre>
</div>
<span class="comment-copy">+1 - This is one reason why I love Python.</span>
<span class="comment-copy">I love good uses of the two-argument <code>iter</code>, and really, the only reason this is bad as real code is that you've crammed it all into one line, not that it doesn't make sense. But maybe it doesn't quite fit the bill of "basic code while I'm still learning".</span>
<span class="comment-copy">@abarnert: Yeah, this definitely doesn't qualify as "basic".  But it also doesn't really qualify as "readable", so I wouldn't go with this solution regardless of target audience.  I think it's fun anyway.</span>
<span class="comment-copy">@SvenMarnach This is the way to do it in real code. Everyone should know the 2nd form of <code>iter</code></span>
<span class="comment-copy">what is lambda for?</span>
<span class="comment-copy">@M15671 To sort the dict items based on the values and keys.</span>
<span class="comment-copy">Very similar functionality, but a bit more concise: <code>for k in sorted(dic, key=dic.get):</code>.</span>
<span class="comment-copy">@SvenMarnach but that may print <code>Nick</code> before <code>John</code>.</span>
<span class="comment-copy">Yes, just pointing out options (and there is nothing in the specification that requires the results to be in any particular order).</span>
