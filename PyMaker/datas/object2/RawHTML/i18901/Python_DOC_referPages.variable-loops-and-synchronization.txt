<div class="post-text" itemprop="text">
<pre><code>def start(self):
    self.running = True
    while self.running:
        pass

def shut_down(self):
    self.running = False
</code></pre>
<p>Hi i want to knew a good way, to synchronise variable running. I want to have fast solution but i dont knew what will be better semaphores, mutexs or locks. I assume that shut_down is not often used. </p>
<p>This is my best solution but i think we can do this better.</p>
<pre><code>def start(self):
    self.__lock__.acquire()
    self.running = True
    while self.running:
        self.__lock__.release()
        self.__lock__.acquire()

def shut_down(self):
    self.__lock__.acquire()
    self.running = False
    self.__lock__.release()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For your simple example with a primitive value like a Boolean flag, no synchronization is necessary in Python. At least, not in CPython (the standard interpreter you can download from python.org).</p>
<p>That's because the whole interpreter is covered by the "Global Interpreter Lock" so only one thread can be running at a time at the Python level (multiple threads could potentially be doing stuff at the same time in extension modules, if those modules are set up to release the GIL at appropriate times). So, when your worker thread looping in the <code>start</code> function checks the <code>running</code> attribute, it is guaranteed that that object is in a sane state. If no code other than shut_down modifies it, you can even be sure that it will be <code>True</code> or <code>False</code>.</p>
<p>So, if you are going to be using CPython and you're sticking to very simple logic (like a Boolean flag that is only ever written to by one thread), your first example code will work just fine.</p>
<p>If you need more complicated logic, like a counter that can be incremented by any of several threads, then you will need a bit of synchronization to avoid race conditions like <a href="http://en.wikipedia.org/wiki/Time_of_check_to_time_of_use" rel="nofollow">TOCTTOU</a>.</p>
<p>One of the easiest synchronization tools that Python offers is <a href="http://docs.python.org/3/library/queue.html" rel="nofollow">the <code>queue</code> module</a>, which allows synchronized communication between threads in a FIFO manner. I can't speak to its performance compared to lower level stuff, but it's really easy to get code working correctly with queues (whereas its pretty easy to mess up manual locking, ending up with deadlocks or race conditions that are a nightmare to debug).</p>
</div>
<span class="comment-copy">I want to write my own mini server with multiple clients. Multiprocessing or Threading witch will be better?</span>
<span class="comment-copy">@Luffy It depends on what exactly you'll end up waiting on mostly. If your server is running CPU intensive tasks, you'll want to do multiprocessing, since that allows Python to use multiple CPUs/cores at the same time. On the other hand, multithreading is probably good enough if most of the delays your server will encounter are I/O related (reading files off a disk, sending/receiving things over the network). I suspect that multithreading has lower overheads and synchronization costs, but I'd test out various solutions if you are unsure.</span>
<span class="comment-copy">Ok thx for advice. First i will try with threads.</span>
