<div class="post-text" itemprop="text">
<p>Rubyist writing Python here.  I've got some code that looks kinda like this:</p>
<pre><code>result = database.Query('complicated sql with an id: %s' % id)
</code></pre>
<p><code>database.Query</code> is mocked out, and I want to test that the ID gets injected in correctly without hardcoding the entire SQL statement into my test.  In Ruby/RR, I would have done this:</p>
<pre><code>mock(database).query(/#{id}/)
</code></pre>
<p>But I can't see a way to set up a 'selective mock' like that in unittest.mock, at least without some hairy <code>side_effect</code> logic.  So I tried using the regexp in the assertion instead:</p>
<pre><code>with patch(database) as MockDatabase:
  instance = MockDatabase.return_value
  ...
  instance.Query.assert_called_once_with(re.compile("%s" % id))
</code></pre>
<p>But that doesn't work either.  This approach does work, but it's ugly:</p>
<pre><code>with patch(database) as MockDatabase:
  instance = MockDatabase.return_value
  ...
  self.assertIn(id, instance.Query.call_args[0][0])
</code></pre>
<p>Better ideas?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import mock

class AnyStringWith(str):
    def __eq__(self, other):
        return self in other

...
result = database.Query('complicated sql with an id: %s' % id)
database.Query.assert_called_once_with(AnyStringWith(id))
...
</code></pre>
<p><strong>EDIT: preemptively requires a matching string</strong></p>
<pre><code>def arg_should_contain(x):
    def wrapper(arg):
        assert str(x) in arg, "'%s' does not contain '%s'" % (arg, x)
    return wrapper

...
database.Query = arg_should_contain(id)
result = database.Query('complicated sql with an id: %s' % id)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just use <code>unittest.mock.ANY</code> :)</p>
<pre><code>from unittest.mock import Mock, ANY

def foo(some_string):
    print(some_string)

foo = Mock()
foo("bla")
foo.assert_called_with(ANY)
</code></pre>
<p>As described here - 
<a href="https://docs.python.org/3/library/unittest.mock.html#any" rel="noreferrer">https://docs.python.org/3/library/unittest.mock.html#any</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I always write my unit tests so they reflect the 'real world'. I don't really know <em>what</em> you want to test except for <code>the ID gets injected in correctly</code>.</p>
<p>I don't know what the <code>database.Query</code> is supposed to do, but I guess it's supposed to create a query object you can call or pass to a connection later?</p>
<p>The best way you can test this to take a real world example. Doing something simple like checking if the id occurs in the query is too error prone. I often see people wanting to do magic stuff in their unit tests, this <strong>always</strong> leads to problems. Keep your unit tests simple and static. In your case you could do:</p>
<pre><code>class QueryTest(unittest.TestCase):
    def test_insert_id_simple(self):
        expected = 'a simple query with an id: 2'
        query = database.Query('a simple query with an id: %s' % 2)
        self.assertEqual(query, expected)

    def test_insert_id_complex(self):
        expected = 'some complex query with an id: 6'
        query = database.Query('some complex query with an id: %s' 6)
        self.assertEqual(query, expected)
</code></pre>
<p>If <code>database.Query</code> directly executes a query in the database, you might want to consider using something like <code>database.query</code> or <code>database.execute</code> instead. The capital in the <code>Query</code> implies you create an object if it's all lowercase it implies you call a function. It's more a naming convention and my opinion, but I'm just throwing it out there. ;-)</p>
<p>If the <code>database.Query</code> directly queries you can best patch the method it is calling. For example, if it looks like this:</p>
<pre><code>def Query(self, query):
    self.executeSQL(query)
    return query
</code></pre>
<p>You can use <code>mock.patch</code> to prevent the unit test from going to the database:</p>
<pre><code>@mock.patch('database.executeSQL')
def test_insert_id_simple(self, mck):
    expected = 'a simple query with an id: 2'
    query = database.Query('a simple query with an id: %s' % 2)
    self.assertEqual(query, expected)
</code></pre>
<p>As an extra tip, try to use the <code>str.format</code> method. The <code>%</code> formatting may go away in the future. See <a href="https://stackoverflow.com/questions/12382719/python-way-of-printing-with-format-or-percent-form">this question</a> for more info.</p>
<p>I also cannot help but feel testing string formatting is redundant. If <code>'test %s' % 'test'</code> doesn't work it would mean something is wrong with Python. It would only make sense if you wanted to test custom query building. e.g. inserting strings should be quoted, numbers shouldn't, escape special characters, etc.</p>
</div>
<span class="comment-copy">Not bad...  but is there a way to set up the mock so it preemptively requires a matching string, instead of having to assert afterwards?</span>
<span class="comment-copy">@jpatokal, added another version.</span>
<span class="comment-copy">Looks like your new version is effectively your own implementation of mocking?  Not that that's necessarily wrong, I just continue to be surprised that unittest.mock doesn't do this kind of thing...</span>
<span class="comment-copy">Solution with <b>eq</b> overriding is cool, but relies on "small trick". I wonder if there's any better solution out of the box... but so far this one looks the best.</span>
<span class="comment-copy">that's what we usually do; does anybody know a library that implements a bunch of these? like <code>AnyStringWith</code>, <code>StartsWith</code>, <code>OneOf</code> etc?</span>
<span class="comment-copy">That asserts that something was sent, but doesn't check that the ID made it through.</span>
<span class="comment-copy">that would be the same as assert_called ...</span>
<span class="comment-copy">This is a unit test, not an integration test: I care that the ID has been passed into the method call correctly.  (The sample has been simplified, there's more than just a string substitution going on in the real thing.)  What the called method does internally does not belong at this level of test, and (IMHO) it's bad form to start patching implementation details of other libraries -- if I want a 'real world' test, I'll write an integration test that goes through the whole stack and doesn't mock out bits in the middle.</span>
