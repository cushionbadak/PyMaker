<div class="post-text" itemprop="text">
<p>I'm trying to convert an integer to binary using the bin() function in Python. However, it always removes the leading zeros, which I actually need, such that the result is always 8-bit:</p>
<p>Example:</p>
<pre><code>bin(1) -&gt; 0b1

# What I would like:
bin(1) -&gt; 0b00000001
</code></pre>
<p>Is there a way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/2/library/functions.html#format" rel="nofollow noreferrer"><code>format()</code> function</a>:</p>
<pre><code>&gt;&gt;&gt; format(14, '#010b')
'0b00001110'
</code></pre>
<p>The <code>format()</code> function simply formats the input following the <a href="http://docs.python.org/2/library/string.html#format-specification-mini-language" rel="nofollow noreferrer">Format Specification mini language</a>. The <code>#</code> makes the format include the <code>0b</code> prefix, and the <code>010</code> size formats the output to fit in 10 characters width, with <code>0</code> padding; 2 characters for the <code>0b</code> prefix, the other 8 for the binary digits.</p>
<p>This is the most compact and direct option.</p>
<p>If you are putting the result in a larger string, use an <a href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings" rel="nofollow noreferrer">formatted string literal</a> (3.6+) or use <a href="https://docs.python.org/2/library/stdtypes.html#str.format" rel="nofollow noreferrer"><code>str.format()</code></a> and put the second argument for the <code>format()</code> function after the colon of the placeholder <code>{:..}</code>:</p>
<pre><code>&gt;&gt;&gt; value = 14
&gt;&gt;&gt; f'The produced output, in binary, is: {value:#010b}'
'The produced output, in binary, is: 0b00001110'
&gt;&gt;&gt; 'The produced output, in binary, is: {:#010b}'.format(value)
'The produced output, in binary, is: 0b00001110'
</code></pre>
<p>As it happens, even for just formatting a single value (so without putting the result in a larger string), using a formatted string literal is faster than using <code>format()</code>:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit("f_(v, '#010b')", "v = 14; f_ = format")  # use a local for performance
0.40298633499332936
&gt;&gt;&gt; timeit.timeit("f'{v:#010b}'", "v = 14")
0.2850222919951193
</code></pre>
<p>But I'd use that only if performance in a tight loop matters, as <code>format(...)</code> communicates the intent better.</p>
<p>If you did not want the <code>0b</code> prefix, simply drop the <code>#</code> and adjust the length of the field:</p>
<pre><code>&gt;&gt;&gt; format(14, '08b')
'00001110'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; '{:08b}'.format(1)
'00000001'
</code></pre>
<p>See: <a href="https://docs.python.org/2/library/string.html#format-specification-mini-language" rel="noreferrer">Format Specification Mini-Language</a></p>
<hr/>
<p>Note for Python 2.6 or older, you cannot omit the positional argument identifier before <code>:</code>, so use</p>
<pre><code>&gt;&gt;&gt; '{0:08b}'.format(1)
'00000001'      
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am using</p>
<pre><code>bin(1)[2:].zfill(8)
</code></pre>
<p>will print </p>
<pre><code>'00000001'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the string formatting mini language:</p>
<pre><code>def binary(num, pre='0b', length=8, spacer=0):
    return '{0}{{:{1}&gt;{2}}}'.format(pre, spacer, length).format(bin(num)[2:])
</code></pre>
<p>Demo:</p>
<pre><code>print binary(1)
</code></pre>
<p>Output:</p>
<pre><code>'0b00000001'
</code></pre>
<p><strong>EDIT:</strong>
<em>based on @Martijn Pieters idea</em></p>
<pre><code>def binary(num, length=8):
    return format(num, '#0{}b'.format(length + 2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sometimes you just want a simple one liner:</p>
<pre><code>binary = ''.join(['{0:08b}'.format(ord(x)) for x in input])
</code></pre>
<p>Python 3</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use something like this </p>
<pre><code>("{:0%db}"%length).format(num)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>module Adder(
    input upperBit, lowerBit, c_in,
    output s, c_out)

write gate1, gate2, gate3

xor (gate1, upperBit, lowerBit)
xor (s, gate1, c_in)
and (upperBit, lowerBit)
and (gate1, c_in)
or  (c_out, gate1, gate2)

endmodule

module ful_adder8(
    input [7:0) a, b
    input c_in
    output [7:0) s,
    output c_out)

write [7:0] carry

full_adder fa0(
    a(a[o])
    b(b[0])
    c_in(c_in)
    s(s[0])
    c_out(carry[0]))
full_adder fa0(
    a(a[o])
    b(b[0])
    c_in(c_in)
    s(s[0])
    c_out(carry[0]))
full_adder fa0(
    a(a[o])
    b(b[0])
    c_in(c_in)
    s(s[0])
    c_out(carry[0]))
full_adder fa0(
    a(a[o])
    b(b[0])
    c_in(c_in)
    s(s[0])
    c_out(carry[0]))
full_adder fa0(
    a(a[o])
    b(b[0])
    c_in(c_in)
    s(s[0])
    c_out(carry[0]))
full_adder fa0(
    a(a[o])
    b(b[0])
    c_in(c_in)
    s(s[0])
    c_out(carry[0]))
full_adder fa0(
    a(a[o])
    b(b[0])
    c_in(c_in)
    s(s[0])
    c_out(carry[0]))
full_adder fa0(
    a(a[o])
    b(b[0])
    c_in(c_in)
    s(s[0])
    c_out(carry[0]))

endmodule
test
def split (n):
    return (n&amp;0x1,n&amp;0x2,n&amp;0x4,n&amp;0x8,n&amp;0x10,n&amp;0x20,n&amp;0x40,n&amp;0x80)
def glue (b0,b1,b2,b3,b4,b5,b6,b7,c):
    t = 0
    if b0:
        t += 1
    if b1:
        t += 2
    if b2:
        t += 4
    if b3:
        t += 8
    if b4:
        t += 16
    if b5:
        t += 32
    if b6:
        t += 64
    if b7:
        t += 128
    if c:
        t += 256
    return t


def myadd (a,b):
    (a0,a1,a2,a3,a4,a5,a6,a7) = split(a)
    (b0,b1,b2,b3,b4,b5,b6,b7) = split(b)
    (s0,s1,s2,s3,s4,s5,s6,s7,c) = addEightBits(a0,a1,a2,a3,a4,a5,a6,a7,b0,b1,b2,b3,b4,b5,b6,b7,false)
    return glue (s0,s1,s2,s3,s4,s5,s6,s7,c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use zfill:</p>
<pre><code>print str(1).zfill(2) 
print str(10).zfill(2) 
print str(100).zfill(2)
</code></pre>
<p>prints:</p>
<pre><code>01
10
100
</code></pre>
<p>I like this solution, as it helps not only when outputting the number, but when you need to assign it to a variable... 
e.g. - 
x = str(datetime.date.today().month).zfill(2) will return x as '02' for the month of feb.</p>
</div>
<span class="comment-copy">See also: <a href="http://stackoverflow.com/q/699866/562769">Python int to binary?</a>, especially <a href="http://stackoverflow.com/a/21732313/562769">my answer</a> with the n-bit representation. Not exactly the same, but I came to this question searching my answer...</span>
<span class="comment-copy">Exactly what I was looking for, this formatting is really helpful to me. I have started learning bit manipulation and I was googling for bit formatting for numbers in Python. Found this. Thank you.</span>
<span class="comment-copy">Holy... This is amazingly awsome! Thanks! +1 <b>EDIT:</b> and this is also working with hexadecimals! <code>'{:02x}'.format(16)</code></span>
<span class="comment-copy">There is no need to use <code>str.format()</code> here when <code>format()</code> will do. You are missing the <code>0b</code> prefix.</span>
<span class="comment-copy">@MartijnPieters, <code>str.format</code> is more flexible than <code>format()</code> because it will allow you to do multiple variables at once. I keep forgetting that the <code>format</code> function even exists. Admittedly it's perfectly adequate in this case.</span>
<span class="comment-copy">@MarkRansom: Exactly, when you are only using <code>str.format()</code> with just one <code>{}</code> element, no other text, you are not using string templating, you are formatting one value. In that case just use <code>format()</code>. :-)</span>
<span class="comment-copy">I believe the output at the very end should be <code>'00000001'</code>, not <code>'00000010'</code>.</span>
<span class="comment-copy">The same formatting language can be used to include the prefix for you. Use <code>#</code>. There is also <code>format()</code>, which saves you having to do a full string template.</span>
<span class="comment-copy">Thanks @MartijnPieters, I will check that!</span>
<span class="comment-copy">Note that the <code>[  ]</code> shouldn't be needed - <code>join()</code> accepts a generator expression. <code>''.join('{0:08b}'.format(ord(x)) for x in input)</code></span>
<span class="comment-copy">Please at least use code block for your code snippet. And if you really want it to be a good answer, then also add some comments on why this solution is solving OP question.</span>
<span class="comment-copy">problem with zfill is it treats the binary string like a string and adds the zeros before the binary 'b' indicator... eg  <code>bin(14)</code>    gives ` '0b1110' `    and   <code>bin(14).zfill(8)</code>   gives   ` '000b1110' ` not  ` '0b00001110' ` which is whats desired</span>
