<div class="post-text" itemprop="text">
<p>List and dictionary comprehensions are powerful and fast, but they can be hard to read. My mental read buffer quickly fills up, <strong>especially</strong> when they’re deeply nested. Is there a way to make these more readable?</p>
</div>
<div class="post-text" itemprop="text">
<p>You’re right. ;) They can be hard to read, which can also make them hard to compose and debug. Let’s take the following example dict comprehension:</p>
<pre><code>current_team = dict((k,v) for k,v in list(team.items()) for player in v[‘player’] if player['year'] == 2013)
</code></pre>
<p>Too many years of C and Java programming have made this difficult for me to read. The comprehension is <em>logically</em> broken into different parts, but I still need to really stare at it to decompose it.</p>
<p>The key thing to remember is that a comprehension is an expression, not a statement. So you can surround the expression with parens and then use <a href="http://docs.python.org/3/reference/lexical_analysis.html#implicit-line-joining" rel="nofollow">implicit line joining</a> to add line breaks that organize the expression based on its nesting levels:</p>
<pre><code>current_players = (dict((k,v)
    for k,v in list(team.items())
        for player in v['player']
            if player['year'] == 2013))
</code></pre>
<p>Here it becomes more clear that the “<a href="http://www.python.org/dev/peps/pep-0202/" rel="nofollow">the last index varying fastest, just like nested for loops.</a>”</p>
<p>You can even add blank lines and comments:</p>
<pre><code>current_players = (dict((k,v)            # dict comprehension:

    for k,v in list(team.items())        #   let’s filter the team member dict...
        for player in v['player']        #   for players...
            if player['year'] == 2013))  #   who are playing this year
</code></pre>
<p>One note of caution: the Python Language Reference says that “the indentation of the continuation lines is not important.” So you can use any form of indentation to improve readability, but the interpreter won’t do any extra checking.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach is to keep the power of comprehensions, but build on generators upon generators to remove the nesting then use the builtin <code>list</code>/<code>set</code>/<code>dict</code> etc... - something similar to:</p>
<pre><code>{k:v for k, v in enumerate(range(10)) if v % 2 == 0}
</code></pre>
<p>Could be broken out to:</p>
<pre><code>with_idx = enumerate(range(10))
is_even = (el for el in with_idx if el[1] % 2 == 0)
as_dict = dict(is_even)
</code></pre>
<p>Which is actually <em>way more verbose</em> but if you apply similar logic to the nested levels, then does actually make more sense.</p>
</div>
<span class="comment-copy">If this is code you're in control of or writing yourself, my rule of thumb is "only use list/dict comprehensions if they're single level; use regular loops with <code>list.append()</code> if they're nested".</span>
<span class="comment-copy">"especially when they're deeply nested" -- solution:  Don't deeply nest them :)</span>
