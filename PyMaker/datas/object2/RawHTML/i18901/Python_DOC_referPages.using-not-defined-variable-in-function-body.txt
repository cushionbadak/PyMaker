<div class="post-text" itemprop="text">
<p>There is this code:</p>
<pre><code>def f():
  x = m 
  m = 2 

def g():
  x = m

f() # UnboundLocalError: local variable 'm' referenced before assignment
g() # NameError: global name 'm' is not defined
</code></pre>
<p>In both function bodies there is used variable <code>m</code> which is not defined when used but the error messages are different. Do Python know what variables are defined in function before using them (like in function <code>f</code>)? Why the error messages are different?</p>
</div>
<div class="post-text" itemprop="text">
<p>If there is an assignment to a variable anywhere in a function, then it is considered a local variable everywhere in that function.  This means that for the function <code>f()</code>, even though the assignment to <code>m</code> happens after the attempt to access <code>m</code>, the line <code>x = m</code> will only look for the name <code>m</code> within the local scope.  This is why the error message for <code>f()</code> refers to <code>m</code> as a local variable.</p>
<p>In the function <code>g()</code> there is no assigment to <code>m</code>, so the line <code>x = m</code> will look for <code>m</code> using the order described <a href="http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow">here</a>:</p>
<ul>
<li>the innermost scope, which is searched first, contains the local
names</li>
<li>the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contains non-local, but also non-global names</li>
<li>the next-to-last scope contains the current moduleâ€™s global names</li>
<li>the outermost scope (searched last) is the namespace containing built-in names</li>
</ul>
<p>The error message for <code>g()</code>, "global name 'm' is not defined", refers to the global scope because that is the last location that was searched (except built-in, but it would be confusing to have a message like "the name 'm' was not found in the built-in namespace").</p>
<p>Note that you can use the <a href="http://docs.python.org/2/reference/simple_stmts.html#the-global-statement" rel="nofollow"><code>global</code></a> or <a href="http://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement" rel="nofollow"><code>nonlocal</code></a> statements to change this behavior (<code>nonlocal</code> only exists in Python 3.x).</p>
</div>
<div class="post-text" itemprop="text">
<p>Python checks it as soon as you call it.</p>
<p>When importing, and typing directly into the interpreter, it only cares if you broke any syntax rules. it doesnt care about locals or globals at this level.</p>
<pre><code>&gt;&gt;&gt; def foo():
...     print locals()
...     bar = 34
...     print locals()
...     DIP = SET
...
&gt;&gt;&gt;
&gt;&gt;&gt; foo()
{}
{'bar': 34}
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 5, in foo
NameError: global name 'SET' is not defined
</code></pre>
<p>it runs from top to bottom, and checks locals() and globals() if it sees that variable then its okay and does whatever with it.</p>
<p>it even works with definitions and sub definitions.. or anything else you are assigning</p>
<pre><code>&gt;&gt;&gt; def foo():
...     bar()
...     def bar():
...         print("never gonna give you up")
...
&gt;&gt;&gt;
&gt;&gt;&gt; foo()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in foo
UnboundLocalError: local variable 'bar' referenced before assignment
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes. If you assign to a variable at any point in a function (without using the <code>global</code> keyword), Python treats all references to that name in the function as local.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you execute a function, you actually invoke <code>__call()__</code> on a function object.</p>
<p>The function object is created in the scripts global namespace when the script is parsed.
Created, but not executed.</p>
<p>As part of the parsing process, the objects namespace is computed. So the interpreter can actually know which variable exists and when.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def f():
  x = m 
  m = 2 
</code></pre>
<p>When the above function parsed python thinks that <code>m</code> is  local variable as it finds <code>m = 2</code>, so when the function is actually called <code>x = m</code> will raise error as <code>m</code> is not defined yet in local scope.</p>
<pre><code>def g():
  x = m
</code></pre>
<p>In this python thinks that <code>m</code> is going to be some value from the global scope, it searches the global namespace first and then built-ins, but when <code>m</code> is not found anywhere the error is raised.</p>
<pre><code>&gt;&gt;&gt; m = 1
&gt;&gt;&gt; def g():
       x = m
&gt;&gt;&gt; g()         #works fine because `m` is found in global scope

&gt;&gt;&gt; def g():
       x = sum
&gt;&gt;&gt; g()         # sum is found in built-ins
</code></pre>
<p>To modify a global variable use <code>global</code>:</p>
<pre><code>&gt;&gt;&gt; m = 1
&gt;&gt;&gt; def g():
       global m
       m += 1
...     
&gt;&gt;&gt; g()
&gt;&gt;&gt; m
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to use <code>global m</code> inside the function</p>
</div>
<span class="comment-copy">Yes, it evidently does.</span>
<span class="comment-copy">no, it knows as soon as you call it. which is why you can import this/type the def into the interpreter  if you want. but the second you attempt to call it, it wigs out on you. it checks from top to bottom as you call it</span>
<span class="comment-copy">please, let a comment with the negative vote at <a href="http://stackoverflow.com/a/16808086/842935">stackoverflow.com/a/16808086/842935</a></span>
