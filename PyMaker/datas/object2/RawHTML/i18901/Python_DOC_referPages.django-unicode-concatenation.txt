<div class="post-text" itemprop="text">
<p>unicode and string encoding still gives me some headache.
I followed <a href="https://stackoverflow.com/questions/17049563/django-special-character-handling">this</a> question / answer to be able to add special characters (äÄÜ..) to a message.</p>
<p>For the following structure I have trouble to understand why version 2 works and version 1 does not.</p>
<p>My model:</p>
<pre><code># -*- coding: utf-8 -*-
from __future__ import unicode_literals

class Project(models.Model):
    """
    Representation of a project
    """

    name = models.CharField(max_length=200)

    def __unicode__(self):
            return '%s ' % (self.name)
</code></pre>
<p>Version 1:</p>
<pre><code># -*- coding: utf-8 -*-
from __future__ import unicode_literals

def print_project(self, project):
        project_prefix = "Project: "
        print (project_prefix + str(project))
</code></pre>
<p>Version 2:</p>
<pre><code> # -*- coding: utf-8 -*-

def print_project(self, project):
        project_prefix = "Project: "
        print (project_prefix + str(project))
</code></pre>
<p>As you see the only difference is that I do this <code>from __future__ import unicode_literals</code> import. The error thrown is the following:</p>
<pre><code>'ascii' codec can't decode byte 0xc3 in position 0: ordinal not in range(128)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After that <code>__future__</code> statement, your literals are not <code>str</code> objects, but <code>unicode</code> objects. That's the whole point of the statement. That isn't described too well, either in the <a href="http://docs.python.org/2/library/__future__.html" rel="nofollow"><code>__future__</code></a> docs or in <a href="http://www.python.org/dev/peps/pep-3112/" rel="nofollow">PEP 3112</a> which they refer to (which spends most of its time talking about how to write Python 2-style <code>bytes</code> objects, given that string literals are now Unicode). But that's what it does.</p>
<p>You can test this in the interactive interpreter:</p>
<pre><code>&gt;&gt;&gt; 'abc'
'abc'
&gt;&gt;&gt; from __future__ import unicode_literals
&gt;&gt;&gt; 'abc'
u'abc'
</code></pre>
<p>So, in version 2, you're adding two <code>str</code> objects together, which is easy. But in version 1, you're adding a <code>unicode</code> and a <code>str</code>. This works by automatically converting the <code>str</code> to a <code>unicode</code> using the default encoding, which is ASCII, which doesn't work.</p>
<hr/>
<p>The easiest way to fix this is to make <code>project</code> be a <code>unicode</code> itself:</p>
<pre><code>def print_project(self, project):
    project_prefix = "Project: "
    print (project_prefix + unicode(project))
</code></pre>
<p>This will, in fact, work with or without the <code>__future__</code> statement—with it, <code>project_prefix</code> is already <code>unicode</code>; without it, it's a <code>str</code> and will be decoded from ASCII, but that's fine, because it <em>is</em> ASCII.</p>
<p>If you want to use non-ASCII literals (in the project_prefix), and you want your code to work with and without the <code>__future__</code> statement, you will have to manually decode:</p>
<pre><code>def print_project(self, project):
    project_prefix = "Project: ".decode('utf-8')
    print (project_prefix + unicode(project))
</code></pre>
<p>(Make sure to match the source file's coding declaration, of course.)</p>
<hr/>
<p>In a comment, you ask:</p>
<blockquote>
<p>when using the <code>__future__</code> import statement do I still have to define the coding at the beginning of the .py file? # -- coding: utf-8 --</p>
</blockquote>
<p>The short answer is yes.</p>
<p>I don't know if the documentation directly covers this anywhere, but if you think about it, there's no other way it could work.</p>
<p>In order to interpret literals in your 8-bit source code as Unicode, the Python compiler has to decode them. The only way it knows what to decode them from is your coding declaration.</p>
<p>Another way to look at this is that the <code>__future__</code> statement makes Python 2 work like Python 3 as far as string literals are concerned, and Python 3 needs coding declarations.</p>
<p>If you want to test this for yourself, copy the following as UTF and paste it into a text file. (Note that you have to use an editor that doesn't understand coding declarations to do this—something like emacs may convert your UTF-8 text to Latin-1 on saving!).</p>
<pre><code># -*- coding: latin-1 -*-
from __future__ import unicode_literals
print repr('é')
</code></pre>
<p>When you run this, it will print out <code>u'\xc3\xa9'</code>, not <code>u'\xe9'</code>.</p>
<p>While Python 3 defaults to UTF-8 if you don't specify a coding, Python 2.5-2.7 defaults to ASCII, even with <code>unicode_literals</code>. So, you still need the coding declaration. (It's always <em>safe</em> to add, even in 3.x, and it also makes many programmers' text editors happy, so it maybe a habit worth keeping until we get far enough into the future that nobody remembers Latin-1 and Shift-JIS and cp1250 and so on.)</p>
</div>
<span class="comment-copy">Should this be useful? <a href="http://stackoverflow.com/questions/809796/any-gotchas-using-unicode-literals-in-python-2-6" title="any gotchas using unicode literals in python 2 6">stackoverflow.com/questions/809796/…</a></span>
<span class="comment-copy">Thanks. Definitely  helpful!</span>
<span class="comment-copy">Thanks for this perfect answer! I already checked it and it works. I will go with the unicode(project) approach. Just one more question that pops up in my mind.. when using the <b>future</b> import statement do I still have to define the coding at the beginning of the .py file? # -<i>- coding: utf-8 -</i>-</span>
<span class="comment-copy">@Tom: Yes. Let me edit the answer for further details.</span>
<span class="comment-copy">Thank you very much! Learned a lot about encoding through your answer..</span>
<span class="comment-copy">Have you read the <a href="http://docs.python.org/2/howto/unicode.html" rel="nofollow noreferrer">2.x</a> and <a href="http://docs.python.org/3/howto/unicode.html" rel="nofollow noreferrer">3.x</a> HOWTO files on Unicode? (If you're using <code>unicode_literals</code> in 2.x, you kind of need both, but at least you can skim over the parts that are repeated.)</span>
<span class="comment-copy">Also a good read.. <a href="http://www.joelonsoftware.com/articles/Unicode.html" rel="nofollow noreferrer">joelonsoftware.com/articles/Unicode.html</a></span>
