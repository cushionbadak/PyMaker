<div class="post-text" itemprop="text">
<p>One of my python applications appears to leak memory, judging from steadily increasing memory usage. My hypothesis is a cyclic reference somewhere, despite best efforts to avoid this. To isolate the problem I am looking into ways to manually check for unreachable items, a tool aimed purely at debugging.</p>
<p>The gc module seems capable of the necessary tracking, and I attempted the following code that aims to compile a list of unreacheable items that were formed since the last call. The first call merely sets a base checkpoint and will not identify unreachable items.</p>
<pre><code>def unreachable():
  # first time setup
  import gc
  gc.set_threshold( 0 ) # only manual sweeps
  gc.set_debug( gc.DEBUG_SAVEALL ) # keep unreachable items as garbage
  gc.enable() # start gc if not yet running (is this necessary?)
  # operation
  if gc.collect() == 0:
    return 'no unreachable items'
  s = 'unreachable items:\n ' \
    + '\n '.join( '[%d] %s' % item for item in enumerate( gc.garbage ) )
  _deep_purge_list( gc.garbage ) # remove unreachable items
  return s # return unreachable items as text
</code></pre>
<p>Here, _deep_purge_list aims to break cycles and remove objects manually. The following implementation handles some common cases but is not near water tight. My first question relates to this, see down.</p>
<pre><code>def _deep_purge_list( garbage ):
  for item in garbage:
    if isinstance( item, dict ):
      item.clear()
    if isinstance( item, list ):
      del item[:]
    try:
      item.__dict__.clear()
    except:
      pass
  del garbage[:]
</code></pre>
<p>Based on very limited testing the setup appears to function properly. The following cyclic reference correctly reports once:</p>
<pre><code>class A( object ):
  def __init__( self ):
    self.ref = self

print unreachable()
# no unreachable items

A()

print unreachable()
# unreachable items:
#  [0] &lt;__main__.A object at 0xb74579ac&gt;
#  [1] {'ref': &lt;__main__.A object at 0xb74579ac&gt;}

print unreachable()
# no unreachable items
</code></pre>
<p>However with the following something odd happens:</p>
<pre><code>print unreachable()
# no unreachable items

import numpy

print unreachable()
# unreachable items:
#  [0] (&lt;type '_ctypes.Array'&gt;,)
#  [1] {'__module__': 'numpy.ctypeslib', '__dict__': &lt;attribute '__dict__' of 'c_long_Array_1' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'c_long_Array_1' objects&gt;, '_length_': 1, '_type_': &lt;class 'ctypes.c_long'&gt;, '__doc__': None}
#  [2] &lt;class 'numpy.ctypeslib.c_long_Array_1'&gt;
#  [3] &lt;attribute '__dict__' of 'c_long_Array_1' objects&gt;
#  [4] &lt;attribute '__weakref__' of 'c_long_Array_1' objects&gt;
#  [5] (&lt;class 'numpy.ctypeslib.c_long_Array_1'&gt;, &lt;type '_ctypes.Array'&gt;, &lt;type '_ctypes._CData'&gt;, &lt;type 'object'&gt;)

print unreachable()
# unreachable items:
#  [0] (&lt;type '_ctypes.Array'&gt;,)
#  [1] {}
#  [2] &lt;class 'c_long_Array_1'&gt;
#  [3] (&lt;class 'c_long_Array_1'&gt;, &lt;type '_ctypes.Array'&gt;, &lt;type '_ctypes._CData'&gt;, &lt;type 'object'&gt;)
</code></pre>
<p>Repeated invocations keep returning that last result. The problem does not occur when unreachable is called for the first time after the import. However, at this point I have no reason to believe that this problem is numpy specific; my guess is it exposes a flaw in my approach.</p>
<p>My questions:</p>
<ol>
<li>Is there a better way to remove items in gc.garbage? Ideally, is
there a way to have gc remove them, like it would (should?) have done
without DEBUG_SAVEALL?</li>
<li>Can anybody explain the problem with the numpy import, and/or
suggest ways to fix it?</li>
</ol>
<p>Afterthought:</p>
<p>It appears that the code below performs close to intended:</p>
<pre><code>def unreachable():
  import gc
  gc.set_threshold( 0 )
  gc.set_debug( gc.DEBUG_LEAK )
  gc.enable()
  print 'collecting {{{'
  gc.collect()
  print '}}} done'
</code></pre>
<p>However, for debugging I prefer rich string representations over type/id as provided by gc. Moreover I would like to understand the flaw in my former approach, and learn something about the gc module.</p>
<p>Appreciating your help,</p>
<p>Gertjan</p>
<p>Update 06/05:</p>
<p>I ran into a situation where the first implementation did not report any unreachable items, unless locals() was called just prior to it (discarding the return value). Not understanding how this could possibly affect gc's object tracking this leaves me even more confused. I am not sure how easy it will be to construct a small example that demonstrates this issue, but if demand calls for it I can give it a shot.</p>
</div>
<div class="post-text" itemprop="text">
<p>The last time I had such a need I ended up using the <a href="https://github.com/mgedmin/objgraph" rel="nofollow noreferrer"><code>objgraph</code> module</a> to good effect.  It gives much more accurate information than you can easily get from the <a href="https://docs.python.org/3/library/gc.html" rel="nofollow noreferrer"><code>gc</code> module</a> directly.  Unfortunately I don't have any code at hand illustrating its usage. </p>
<p>The one place where it falls down is in memory allocated by any C code libraries called.  For instance if a project uses PIL it is very easy to leak memory due to not releasing python objects properly that are backed by C data.  It is C backed module dependent how to properly close out such objects.</p>
</div>
<span class="comment-copy">I've only skimmed this, but you might have misunderstood <code>gc.DEBUG_SAVEALL</code>: it is meant to append freed objects to <code>gc.garbage</code> (instead of only freeing them).</span>
<span class="comment-copy">Hi Samantha, thanks, yes I agree objgraph is a great tool for tracing object references. However, I could not figure out how to use it to give me a list of unreacheable items, in a way that 'A' shows up in my example; experiments with get_leaking_objects were unsuccessful. In his blog post Marius explains memory leaks by the example of references from global objects, so I was led to believe that objgraph may not be suitable for tracing cyclic references. If that conclusion is wrong I am most interested to learn how these can be uncovered.</span>
