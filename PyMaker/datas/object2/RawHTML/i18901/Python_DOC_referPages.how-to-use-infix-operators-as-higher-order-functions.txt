<div class="post-text" itemprop="text">
<p>Is there any way to use infix operators (like +,-,*,/) as higher order functions in python without creating "wrapper" functions?</p>
<pre><code>def apply(f,a,b):
  return f(a,b)

def plus(a,b):
  return a + b

# This will work fine
apply(plus,1,1)

# Is there any way to get this working?
apply(+,1,1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="http://docs.python.org/3/library/operator.html?highlight=operator#operator" rel="nofollow">operator</a> module, which has the "wrapper" functions written for you already.</p>
<pre><code>import operator

def apply(f,a,b):
  return f(a,b)

print apply(operator.add,1,1)
</code></pre>
<p>Result:</p>
<pre><code>2
</code></pre>
<p>You can also define the wrapper using lambda functions, which saves you the trouble of a standalone <code>def</code>:</p>
<pre><code>print apply(lamba a,b: a+b, 1, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use operator module and a dictionary:</p>
<pre><code>&gt;&gt;&gt; from operator import add, mul, sub, div, mod
&gt;&gt;&gt; dic = {'+':add, '*':mul, '/':div, '%': mod, '-':sub}
&gt;&gt;&gt; def apply(op, x, y):
        return dic[op](x,y)
... 
&gt;&gt;&gt; apply('+',1,5)
6
&gt;&gt;&gt; apply('-',1,5)
-4
&gt;&gt;&gt; apply('%',1,5)
1
&gt;&gt;&gt; apply('*',1,5)
5
</code></pre>
<p>Note that you can't use <code>+</code>, <code>-</code>, etc directly as they are not valid identifiers in python.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="http://docs.python.org/3/library/operator.html?highlight=operator#operator" rel="nofollow">operator</a> module this way:</p>
<pre><code>import operator

def apply(op, a, b):
    return op(a, b)

print(apply(operator.add, 1, 2))
print(apply(operator.lt, 1, 2))
</code></pre>
<p>Output:</p>
<pre><code>3
True
</code></pre>
<p>The other solution is to use a <code>lambda</code> function, but "there should be one -- and preferably only one -- obvious way to do it", so I prefer to use the operator module</p>
</div>
<div class="post-text" itemprop="text">
<p>you can use anonymous function : <code>apply(lambda x,y : x + y, 1,1)</code></p>
</div>
<div class="post-text" itemprop="text">
<pre><code># Is there any way to get this working?
apply(+,1,1)
</code></pre>
<p>No.  As others have already mentioned, there are function forms of all of the operators in the <code>operator</code> module.  But, you can't use the operators themselves as that is a <code>SyntaxError</code> and there is no way to dynamically change python's core syntax.  You can get close though using dictionaries and passing strings:</p>
<pre><code>_mapping = {'+':operator.add}
def apply(op,*args):
    return _mapping[op](*args)

apply('+',1,1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It <strong>is</strong> possible to give the operators <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> special behavior for a class using magic methods, you can read about this here: <a href="http://www.rafekettler.com/magicmethods.html" rel="nofollow">http://www.rafekettler.com/magicmethods.html</a></p>
<p>This isn't exactly what you were asking for because this still requires the creation of a method for each operator, but it does allow you to use the operators by symbol in your code.  Note that I don't think this is better than the other methods, it is just an illustration of how you can define behavior for operators:</p>
<pre><code>class Prefix(object):
    def __add__(self, other):
        """ Prefix() + (a, b) == a + b """
        return other[0] + other[1]
    def __sub__(self, other):
        """ Prefix() - (a, b) == a - b """
        return other[0] - other[1]
    def __mul__(self, other):
        """ Prefix() * (a, b) == a * b """
        return other[0] * other[1]
    def __div__(self, other):
        """ Prefix() / (a, b) == a / b """
        return other[0] / other[1]
</code></pre>
<p>And examples:</p>
<pre><code>&gt;&gt;&gt; prefix = Prefix()
&gt;&gt;&gt; prefix + (12, 3)
15
&gt;&gt;&gt; prefix - (12, 3)
9
&gt;&gt;&gt; prefix * (12, 3)
36
&gt;&gt;&gt; prefix / (12, 3)
4
</code></pre>
<p>Of course this method can't be used for a more complex prefix equation like <code>* / 6 2 5</code> because there is no way to define behavior for adjacent operators, which will always give a SyntaxError (except for a few special cases where <code>+</code> or <code>-</code> are interpreted as making the next element positive or negative).</p>
</div>
<span class="comment-copy">In the last sentence, did you mean "which saves you the trouble of an <code>import</code>"? Because, as you show, using <code>operator</code> you <i>don't</i> have to define these wrapper functions (regardless of whether you'd use <code>def</code> or <code>lambda</code>) at all.</span>
<span class="comment-copy">That is also a valid statement. To cover all my bases, I should have said, "saves you the trouble of either an import line, or writing your own <code>def</code>".</span>
<span class="comment-copy">I like this solution, it is closest to the OP's desired form. It would also support non-standard operators, such as '@', '~' and so on.</span>
