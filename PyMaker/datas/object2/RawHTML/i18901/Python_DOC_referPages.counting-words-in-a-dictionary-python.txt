<div class="post-text" itemprop="text">
<p>I have this code, which I want to open a specified file, and then every time there is a while loop it will count it, finally outputting the total number of while loops in a specific file. I decided to convert the input file to a dictionary, and then create a for loop that every time the word while followed by a space was seen it would add a +1 count to WHILE_ before finally printing WHILE_ at the end.</p>
<p>However this did not seem to work, and I am at a loss as to why. Any help fixing this would be much appreciated.</p>
<p>This is the code I have at the moment:</p>
<pre><code>WHILE_ = 0
INPUT_ = input("Enter file or directory: ")


OPEN_ = open(INPUT_)
READLINES_ = OPEN_.readlines()
STRING_ = (str(READLINES_))
STRIP_ = STRING_.strip()
input_str1 = STRIP_.lower()


dic = dict()
for w in input_str1.split():
    if w in dic.keys():
        dic[w] = dic[w]+1
    else:
        dic[w] = 1
DICT_ = (dic)


for LINE_ in DICT_:
    if  ("while\\n',") in LINE_:
        WHILE_ += 1
    elif ('while\\n",') in LINE_:
        WHILE_ += 1
    elif ('while ') in LINE_:
        WHILE_ += 1

print ("while_loops {0:&gt;12}".format((WHILE_)))
</code></pre>
<p>This is the input file I was working from:</p>
<pre><code>'''A trivial test of metrics
Author: Angus McGurkinshaw
Date: May 7 2013
'''

def silly_function(blah):
    '''A silly docstring for a silly function'''
    def nested():
        pass
    print('Hello world', blah + 36 * 14)
    tot = 0  # This isn't a for statement
    for i in range(10):
        tot = tot + i
        if_im_done = false  # Nor is this an if
    print(tot)

blah = 3
while blah &gt; 0:
    silly_function(blah)
    blah -= 1
    while True:
        if blah &lt; 1000:
            break
</code></pre>
<p>The output should be 2, but my code at the moment prints 0</p>
</div>
<div class="post-text" itemprop="text">
<p>This is an incredibly bizarre design. You're calling <code>readlines</code> to get a list of strings, then calling <code>str</code> on that list, which will join the whole thing up into one big string with the quoted <code>repr</code> of each line joined by commas and surrounded by square brackets, then splitting the result on spaces. I have no idea why you'd ever do such a thing.</p>
<p>Your bizarre variable names, extra useless lines of code like <code>DICT_ = (dic)</code>, etc. only serve to obfuscate things further.</p>
<p>But I can explain why it doesn't work. Try printing out <code>DICT_</code> after you do all that silliness, and you'll see that the only keys that include <code>while</code> are <code>while</code> and <code>'while</code>. Since neither of these match any of the patterns you're looking for, your count ends up as 0.</p>
<p>It's also worth noting that you only add 1 to <code>WHILE_</code> even if there are multiple instances of the pattern, so your whole dict of counts is useless.</p>
<hr/>
<p>This will be a lot easier if you don't obfuscate your strings, try to recover them, and then try to match the incorrectly-recovered versions. Just do it directly.</p>
<p>While I'm at it, I'm also going to fix some other problems so that your code is readable, and simpler, and doesn't leak files, and so on. Here's a complete implementation of the logic you were trying to hack up by hand:</p>
<pre><code>import collections

filename = input("Enter file: ")
counts = collections.Counter()
with open(filename) as f:
    for line in f:
        counts.update(line.strip().lower().split())
print('while_loops {0:&gt;12}'.format(counts['while']))
</code></pre>
<p>When you run this on your sample input, you correctly get <code>2</code>. And extending it to handle <code>if</code> and <code>for</code> is trivial and obvious.</p>
<hr/>
<p>However, note that there's a serious problem in your logic: Anything that looks like a keyword but is in the middle of a comment or string will still get picked up. Without writing some kind of code to strip out comments and strings, there's no way around that. Which means you're going to overcount <code>if</code> and <code>for</code> by 1. The obvious way of stripping—<code>line.partition('#')[0]</code> and similarly for quotes—won't work. First, it's perfectly valid to have a string before an <code>if</code> keyword, as in <code>"foo" if x else "bar"</code>. Second, you can't handle multiline strings this way.</p>
<p>These problems, and others like them, are why you almost certainly want a real parser. If you're just trying to parse Python code, <a href="http://docs.python.org/3/library/ast.html" rel="noreferrer">the <code>ast</code> module</a> in the standard library is the obvious way to do this. If you want to be write quick&amp;dirty parsers for a variety of different languages, try <a href="http://pyparsing.wikispaces.com" rel="noreferrer"><code>pyparsing</code></a>, which is very nice, and comes with some great examples.</p>
<p>Here's a simple example:</p>
<pre><code>import ast

filename = input("Enter file: ")
with open(filename) as f:
    tree = ast.parse(f.read())
while_loops = sum(1 for node in ast.walk(tree) if isinstance(node, ast.While))
print('while_loops {0:&gt;12}'.format(while_loops))
</code></pre>
<p>Or, more flexibly:</p>
<pre><code>import ast
import collections

filename = input("Enter file: ")
with open(filename) as f:
    tree = ast.parse(f.read())
counts = collections.Counter(type(node).__name__ for node in ast.walk(tree))    
print('while_loops {0:&gt;12}'.format(counts['While']))
print('for_loops {0:&gt;14}'.format(counts['For']))
print('if_statements {0:&gt;10}'.format(counts['If']))
</code></pre>
</div>
<span class="comment-copy">Why have you given your variables such bizarre and ugly names?</span>
<span class="comment-copy">They're just placeholders for now</span>
<span class="comment-copy">The standard library includes <a href="http://docs.python.org/3.3/library/ast.html" rel="nofollow noreferrer">a module to parse Python code</a>.</span>
<span class="comment-copy">This is too fugly to even try and understand. Readability counts for yourself and others -- especially when you are asking for help.</span>
<span class="comment-copy">Great answer and great example of using the <code>ast</code> module.</span>
<span class="comment-copy">@JonClements: Well, all I'm doing with the AST is <code>walk</code> and <code>type(node)</code>, so it doesn't really show off the real fun you can have with it (e.g., <a href="https://github.com/lihaoyi/macropy" rel="nofollow noreferrer">MacroPy</a>).</span>
