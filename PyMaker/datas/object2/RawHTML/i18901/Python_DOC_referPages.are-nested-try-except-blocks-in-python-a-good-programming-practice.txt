<div class="post-text" itemprop="text">
<p>I'm writing my own container, which needs to give access to a dictionary inside by attribute calls. The typical use of the container would be like this:</p>
<pre><code>dict_container = DictContainer()
dict_container['foo'] = bar
...
print dict_container.foo
</code></pre>
<p>I know that it might be stupid to write something like this, but that's the functionality I need to provide. I was thinking about implementing this in a following way:</p>
<pre><code>def __getattribute__(self, item):
    try:
        return object.__getattribute__(item)
    except AttributeError:
        try:
            return self.dict[item]
        except KeyError:
            print "The object doesn't have such attribute"
</code></pre>
<p>I'm not sure whether nested try/except blocks are a good practice so another way would be to use <code>hasattr()</code> and <code>has_key()</code>:</p>
<pre><code>def __getattribute__(self, item):
        if hasattr(self, item):
            return object.__getattribute__(item)
        else:
            if self.dict.has_key(item):
                return self.dict[item]
            else:
                raise AttributeError("some customised error")
</code></pre>
<p>Or to use one of them and one try catch block like this:</p>
<pre><code>def __getattribute__(self, item):
    if hasattr(self, item):
        return object.__getattribute__(item)
    else:
        try:
            return self.dict[item]
        except KeyError:
            raise AttributeError("some customised error")
</code></pre>
<p>Which option is most pythonic and elegant?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your first example is perfectly fine. Even the official Python docs recommend this style known as <a href="http://docs.python.org/3/glossary.html#term-eafp" rel="noreferrer">EAFP</a>.</p>
<p>Personally, I prefer to avoid nesting when it's not necessary:</p>
<pre><code>def __getattribute__(self, item):
    try:
        return object.__getattribute__(item)
    except AttributeError:
        pass  # fallback to dict
    try:
        return self.dict[item]
    except KeyError:
        raise AttributeError("The object doesn't have such attribute") from None
</code></pre>
<p>PS. <code>has_key()</code> has been deprecated for a long time in Python 2. Use <code>item in self.dict</code> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>While in Java its indeed a bad practice to use Exceptions for flow control (mainly because exceptions force the jvm to gather resources (<a href="https://stackoverflow.com/questions/6092992/why-is-it-easier-to-ask-forgiveness-than-permission-in-python-but-not-in-java">more here</a>)), in Python you have 2 important principles: <a href="http://docs.python.org/2/glossary.html#term-duck-typing" rel="nofollow noreferrer" title="If it looks like a duck and quacks like a duck, it must be a duck.">Duck Typing</a> and <a href="http://docs.python.org/2/glossary.html#term-eafp" rel="nofollow noreferrer" title="Easier to ask for forgiveness than permission">EAFP</a>. This basically means that you are encouraged to try using an object the way you think it would work, and handle when things are not like that.</p>
<p>In summary the only problem would be your code getting too much indented. If you feel like it, try to simplify some of the nestings like lqc suggested</p>
</div>
<div class="post-text" itemprop="text">
<p>For your specific example, you don't actually need to nest them.  If the expression in the <code>try</code> block succeeds, the function will return, so any code after the whole try/except block will only be run if the first attempt fails.  So you can just do:</p>
<pre><code>def __getattribute__(self, item):
    try:
        return object.__getattribute__(item)
    except AttributeError:
        pass
    # execution only reaches here when try block raised AttributeError
    try:
        return self.dict[item]
    except KeyError:
        print "The object doesn't have such attribute"
</code></pre>
<p>Nesting them isn't bad, but I feel like leaving it flat makes the structure more clear: you're sequentially trying a series of things and returning the first one that works.</p>
<p>Incidentally, you might want to think about whether you really want to use <code>__getattribute__</code> instead of <code>__getattr__</code> here.  Using <code>__getattr__</code> will simplify things because you'll know that the normal attribute lookup process has already failed.</p>
</div>
<div class="post-text" itemprop="text">
<p>In my opinion this would be the most Pythonic way to handle it, although and because it makes your question moot. Note that this defines<code>__getattr__()</code>instead of<code>__getattribute__()</code> because doing so means it only has to deal with the "special" attributes being keep in the internal dictionary.</p>
<pre><code>def __getattr__(self, name):
    """only called when an attribute lookup in the usual places has failed"""
    try:
        return self.my_dict[name]
    except KeyError:
        raise AttributeError("some customized error message")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python it is easier to ask for forgiveness than permission. Don't sweat the nested exception handling.</p>
<p>(Besides, <code>has*</code> almost always uses exceptions under the cover anyways.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Just be careful - in this case first <code>finally</code> is touched BUT skipped too.</p>
<pre><code>def a(z):
    try:
        100/z
    except ZeroDivisionError:
        try:
            print('x')
        finally:
            return 42
    finally:
        return 1


In [1]: a(0)
x
Out[1]: 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/2/tutorial/errors.html" rel="nofollow">documentation</a>, it is better to handle multiple exceptions through tuples or like this:</p>
<pre><code>import sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except IOError as e:
    print "I/O error({0}): {1}".format(e.errno, e.strerror)
except ValueError:
    print "Could not convert data to an integer."
except:
    print "Unexpected error:", sys.exc_info()[0]
    raise
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One thing I like to avoid is raising a new exception while handling an old one.  It makes the error messages confusing to read.</p>
<p>For example, in my code, I originally wrote </p>
<pre><code>try:
    return tuple.__getitem__(self, i)(key)
except IndexError:
    raise KeyError(key)
</code></pre>
<p>And I got this message.</p>
<pre><code>&gt;&gt;&gt; During handling of above exception, another exception occurred.
</code></pre>
<p>What I wanted was this:</p>
<pre><code>try:
    return tuple.__getitem__(self, i)(key)
except IndexError:
    pass
raise KeyError(key)
</code></pre>
<p>It doesn't affect how exceptions are handled.  In either block of code, a KeyError would have been caught.  This is merely an issue of getting style points.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think it's a matter of being pythonic or elegant.
It's a matter of preventing exceptions as much as you can.
Exceptions are meant to handle errors that might occur in code or events you have no control over.
In this case you have full control when checking if an item is an attribute or in a dictionary, so avoid nested exceptions and stick with your second attempt.</p>
</div>
<div class="post-text" itemprop="text">
<p>If try-except-finally is nested inside finally block, the result from "child" finally is preserved. I have not found official expaination yet, but the following code snippet shows this behavior in Python 3.6. </p>
<pre><code>def f2():
    try:
        a = 4
        raise SyntaxError
    except SyntaxError as se:
        print('log SE')
        raise se from None
    finally:
        try:
            raise ValueError
        except ValueError as ve:
            a = 5
            print('log VE')
            raise ve from None
        finally:
            return 6       
        return a

In [1]: f2()
log SE
log VE
Out[2]: 6
</code></pre>
</div>
<span class="comment-copy">Would appreciate the python gods providing <code>if 'foo' in dict_container:</code>. Amen.</span>
<span class="comment-copy"><code>return object.__getattribute__(item)</code> is incorrect and will produce a <code>TypeError</code> because the wrong number of arguments are being passed. It should instead be <code>return object.__getattribute__(self, item)</code>.</span>
<span class="comment-copy">PEP 20: flat is better than nested.</span>
<span class="comment-copy">What does the <code>from None</code> mean in the last line?</span>
<span class="comment-copy">@niklas It essentially suppresses exception context ("during handling this exception another exception occurred"-esque messages). See <a href="https://stackoverflow.com/a/24752607">here</a></span>
<span class="comment-copy">Note that raising an exception in an <code>except</code> block may give confusing output in Python 3. That's because (per PEP 3134) Python 3 tracks the first exception (the <code>KeyError</code>) as the "context" of the second exception (the <code>AttributeError</code>), and if it reaches the top level, it will print a traceback that includes both exceptions. This can be helpful when a second exception was not expected, but if you're deliberately raising the second exception, it's undesirable. For Python 3.3, PEP 415 added the ability to suppress the context by using <code>raise AttributeError("whatever") from None</code>.</span>
<span class="comment-copy">@Blckknght: Printing a traceback that includes both exceptions would be fine in this case. In other words, I don't think your blanket statement that it's always undesirable is true. In the usage here, it's turning a <code>KeyError</code> into an <code>AttributeError</code> and showing that's what happened in a traceback would be useful and appropriate.</span>
<span class="comment-copy">For more complicated situations you may be right, but I think that when you're converting between exception types you often know that the details of the first exception don't matter to the outside user. That is, if <code>__getattr__</code> raises an exception the bug is probably a typo in the attribute access, not an implementation bug in the current class's code. Showing the earlier exception as context can muddle that. And even when you suppress the context with <code>raise Whatever from None</code>, you can still get at the previous exception if necessary via <code>ex.__context__</code>.</span>
<span class="comment-copy">I wanted to accept your answer however in the question I was more curious whether or not using nested try/catch block is a good practice. On the other hand it's the most elegant solution and I'm going to use it in my code. Many thanks Martin.</span>
<span class="comment-copy">Michal: You're welcome. It's also faster than using <code>__getattribute__()</code>.</span>
<span class="comment-copy">Wow it blows my mind... Could you point me to some documentation fragment explaining this behavior?</span>
<span class="comment-copy">@Michal: fyi: both <code>finally</code> blocks are executed for <code>a(0)</code>, but only parent <code>finally-return</code> is returned.</span>
<span class="comment-copy">This answer doesn't really address the original question but for anyone reading it note the "bare" except at the end is a terrible idea (usually) as it will catch everything including eg NameError &amp; KeyboardInterrupt - which is not usually what you meant!</span>
<span class="comment-copy">From the docs: <i>In a multi-threaded environment, the LBYL</i> (Look Before You Leap) <i>approach can risk introducing a race condition between “the looking” and “the leaping”. For example, the code, if key in mapping: return mapping[key] can fail if another thread removes key from mapping after the test, but before the lookup. This issue can be solved with locks or by using the EAFP</i> (Easier to ask for forgiveness than permission) <i>approach.</i></span>
<span class="comment-copy">This behavior is different from the example given by @Sławomir Lenart when finally is nested inside except block.</span>
