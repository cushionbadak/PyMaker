<div class="post-text" itemprop="text">
<p>I seem to remember that the Python gzip module previously allowed you to read non-gzipped files transparently. This was really useful, as it allowed to read an input file whether or not it was gzipped. You simply didn't have to worry about it.</p>
<p>Now,I get an IOError exception (in Python 2.7.5):</p>
<pre><code>   Traceback (most recent call last):
  File "tst.py", line 14, in &lt;module&gt;
    rec = fd.readline()
  File "/sw/lib/python2.7/gzip.py", line 455, in readline
    c = self.read(readsize)
  File "/sw/lib/python2.7/gzip.py", line 261, in read
    self._read(readsize)
  File "/sw/lib/python2.7/gzip.py", line 296, in _read
    self._read_gzip_header()
  File "/sw/lib/python2.7/gzip.py", line 190, in _read_gzip_header
    raise IOError, 'Not a gzipped file'
IOError: Not a gzipped file
</code></pre>
<p>If anyone has a neat trick, I'd like to hear about it. Yes, I know how to catch the exception, but I find it rather clunky to first read a line, then close the file and open it again.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best solution for this would be to use something like <a href="https://github.com/ahupp/python-magic">https://github.com/ahupp/python-magic</a> with libmagic. You simply cannot avoid at least reading a header to identify a file (unless you implicitly trust file extensions)</p>
<p>If you're feeling spartan the magic number for identifying gzip(1) files is the first two bytes being 0x1f 0x8b.</p>
<pre><code>In [1]: f = open('foo.html.gz')
In [2]: print `f.read(2)`
'\x1f\x8b'
</code></pre>
<p>gzip.open is just a wrapper around GzipFile, you could have a function like this that just returns the correct type of object depending on what the source is without having to open the file twice:</p>
<pre><code>#!/usr/bin/python

import gzip

def opener(filename):
    f = open(filename,'rb')
    if (f.read(2) == '\x1f\x8b'):
        f.seek(0)
        return gzip.GzipFile(fileobj=f)
    else:
        f.seek(0)
        return f
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you're thinking of zless or zgrep, which will open compressed or uncompressed files without complaining.</p>
<p>Can you trust that the file name ends in .gz?</p>
<pre><code>if file_name.endswith('.gz'):
    opener = gzip.open
else:
    opener = open

with opener(file_name, 'r') as f:
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Read the first four bytes.  If the first three are 0x1f, 0x8b, 0x08, and if the high three bits of the fourth byte are zeros, then fire up the gzip compression starting with those four bytes.  Otherwise write out the four bytes and continue to read transparently.</p>
<p>You should still have the clunky solution to back that up, so that if the gzip read fails nevertheless, then back up and read transparently.  But it should be quite unlikely to have the first four bytes mimic a gzip file so well, but not be a gzip file.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can iterate over files transparently using <a href="https://docs.python.org/3/library/fileinput.html#fileinput.input" rel="nofollow noreferrer">fileinput(files, openhook=fileinput.hook_compressed)</a></p>
</div>
<span class="comment-copy">Are you sure you remember correctly? I can't get that behaviour in any version from 2.4, and there is no mention of this behaviour in the docs since <a href="http://docs.python.org/2.0/lib/module-gzip.html" rel="nofollow noreferrer">2.0</a>! And I wouldn't ever expect gzip to read uncompressed files anyway.</span>
<span class="comment-copy">Can't you just open the file, pass it to gzip, catch the exception and then work with the already open file?</span>
<span class="comment-copy">I am trying to understand you right. Please take no offense. Why would you want to use gzip to open a file which is not gripped? Sorry, but it makes no sense to me. Please clarify your question.</span>
<span class="comment-copy">The reason you would want to have a generic opener for gzip or non-gzipped data is if you're processing a mixed group of files that are arbitrarily gzipped or not gzipped. But, the slippery slope question is - if you're doing that what do you do with a bzip2 or rar file or anything that doesn't fit in the category of gzip/not-gzip), since a lot of things are 'not gzipped'.</span>
