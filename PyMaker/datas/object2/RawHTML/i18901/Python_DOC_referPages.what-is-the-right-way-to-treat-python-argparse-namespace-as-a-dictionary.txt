<div class="post-text" itemprop="text">
<p>If I want to use the results of <code>argparse.ArgumentParser()</code>, which is a <code>Namespace</code> object, with a method that expects a dictionary or mapping-like object (see <a href="http://docs.python.org/2/library/collections.html#collections.Mapping" rel="noreferrer">collections.Mapping</a>), what is the right way to do it?</p>
<pre><code>C:\&gt;python
Python 2.7.3 (default, Apr 10 2012, 23:31:26) [MSC v.1500 32 bit (Intel)] on win
32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import argparse
&gt;&gt;&gt; args = argparse.Namespace()
&gt;&gt;&gt; args.foo = 1
&gt;&gt;&gt; args.bar = [1,2,3]
&gt;&gt;&gt; args.baz = 'yippee'
&gt;&gt;&gt; args['baz']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'Namespace' object has no attribute '__getitem__'
&gt;&gt;&gt; dir(args)
['__class__', '__contains__', '__delattr__', '__dict__', '__doc__', '__eq__', '_
_format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__',
'__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__
', '__str__', '__subclasshook__', '__weakref__', '_get_args', '_get_kwargs', 'ba
r', 'baz', 'foo']
</code></pre>
<p><strong>Is it proper to "reach into" an object and use its <code>__dict__</code> property?</strong></p>
<p>I would think the answer is no: <code>__dict__</code> smells like a convention for implementation, but not for an interface, the way <code>__getattribute__</code> or <code>__setattr__</code> or <code>__contains__</code> seem to be.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can access the namespace's dictionary with <a href="http://docs.python.org/3/library/functions.html#vars" rel="noreferrer"><em>vars()</em></a>:</p>
<pre><code>&gt;&gt;&gt; import argparse
&gt;&gt;&gt; args = argparse.Namespace()
&gt;&gt;&gt; args.foo = 1
&gt;&gt;&gt; args.bar = [1,2,3]
&gt;&gt;&gt; d = vars(args)
&gt;&gt;&gt; d
{'foo': 1, 'bar': [1, 2, 3]}
</code></pre>
<p>You can modify the dictionary directly if you wish:</p>
<pre><code>&gt;&gt;&gt; d['baz'] = 'store me'
&gt;&gt;&gt; args.baz
'store me'
</code></pre>
<p>Yes, it is okay to access the __dict__ attribute.  It is a well-defined, tested, and guaranteed behavior.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/argparse.html#the-namespace-object" rel="noreferrer">Straight from the horse's mouth</a>:</p>
<blockquote>
<p>If you prefer to have dict-like view of the attributes, you can use the standard Python idiom, <a href="https://docs.python.org/3/library/functions.html#vars" rel="noreferrer"><code>vars()</code></a>:</p>
<pre><code>&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; parser.add_argument('--foo')
&gt;&gt;&gt; args = parser.parse_args(['--foo', 'BAR'])
&gt;&gt;&gt; vars(args)
{'foo': 'BAR'}
</code></pre>
<p>â€” The Python Standard Library, 16.4.4.6. <a href="https://docs.python.org/3/library/argparse.html#the-namespace-object" rel="noreferrer">The Namespace object</a></p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is it proper to "reach into" an object and use its <strong>dict</strong> property?</p>
</blockquote>
<p>In general, I would say "no". However <code>Namespace</code> has struck me as over-engineered, possibly from when classes couldn't inherit from built-in types. </p>
<p>On the other hand, <code>Namespace</code> does present a task-oriented approach to argparse, and I can't think of a situation that would call for grabbing the <code>__dict__</code>, but the limits of my imagination are not the same as yours.</p>
</div>
<span class="comment-copy">The docs say: "The returned dictionary should not be modified: the effects on the corresponding symbol table are undefined." Which <i>may</i> only refer to the behavior of <code>vars()</code> (which is either <code>locals()</code> or <code>globals()</code>), but I'm not really sure.</span>
<span class="comment-copy">hmm, I guess I don't really understand the difference between using <code>vars()</code> and <code>__dict__</code></span>
<span class="comment-copy">@delnan Someone had made an incorrect edit to the docs and made an over-broad admonition.  The docs were subsequently corrected.  See  <a href="http://docs.python.org/2.7/library/functions.html#vars" rel="nofollow noreferrer">docs.python.org/2.7/library/functions.html#vars</a>  While there are some special cases that have read-only dictionaries (such as locals and class dictionary proxies), the rest of the cases are updateable.  The <i>vars(obj)</i> call is synonymous with obj.__dict__.  In the case of an <i>argparse</i> namespace, <i>vars(args)</i> gives direct access to an updateable dictionary.</span>
<span class="comment-copy">@RaymondHettinger Okay, neat. I got that note from the <code>/3/</code> version of the docs (on closer inspection, 3.1 to 3.4 including), so the correction is apparently missing there.</span>
<span class="comment-copy">@delnan I just updated the 3.3 and 3.3 docs.  It will be visible tomorrow.  Thanks for pointing it out.</span>
<span class="comment-copy">Still 'foo' misses '--'. Any idea to that?</span>
<span class="comment-copy">@user2678074 this is intentional to match shell flags. The dashes are extraneous inside python execution.</span>
<span class="comment-copy"><code>vars(args)</code> gives me <code>TypeError: 'dict' object is not callable</code></span>
<span class="comment-copy">@user5359531 you probably overwrote the global <code>vars</code> with a variable. You can use <code>__builtins__.vars</code> to access it directly, or <code>del vars</code> to stop shadowing it.</span>
<span class="comment-copy">It is perfectly okay to access the __dict__ attribute.  Introspection is fundamental to the language.  The attribute was made public for a reason :-)</span>
<span class="comment-copy">But everything in Python is "public". There are no distinctions (except the leading underscore convention) between the implementation variables used in an instance, and the public interface it presents. Especially in a dictionary-like object: the line between instance methods, and dictionary values which are functions, is a bit blurry.</span>
<span class="comment-copy">If you're passing the arguments as named parameters? <code>do_something(**args.__dict__)</code></span>
