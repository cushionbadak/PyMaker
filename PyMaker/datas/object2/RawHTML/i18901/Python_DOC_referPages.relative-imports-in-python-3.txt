<div class="post-text" itemprop="text">
<p>I want to import a function from another file in the same directory.</p>
<p>Sometimes it works for me with <code>from .mymodule import myfunction</code> but sometimes I get a:</p>
<pre class="lang-none prettyprint-override"><code>SystemError: Parent module '' not loaded, cannot perform relative import
</code></pre>
<p>Sometimes it works with <code>from mymodule import myfunction</code>, but sometimes I also get a:</p>
<pre class="lang-none prettyprint-override"><code>SystemError: Parent module '' not loaded, cannot perform relative import
</code></pre>
<p>I don't understand the logic here, and I couldn't find any explanation. This looks completely random.</p>
<p>Could someone explain to me what's the logic behind all this?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>unfortunately, this module needs to be inside the package, and it also
  needs to be runnable as a script, sometimes. Any idea how I could
  achieve that?</p>
</blockquote>
<p>It's quite common to have a layout like this...</p>
<pre><code>main.py
mypackage/
    __init__.py
    mymodule.py
    myothermodule.py
</code></pre>
<p>...with a <code>mymodule.py</code> like this...</p>
<pre><code>#!/usr/bin/env python3

# Exported function
def as_int(a):
    return int(a)

# Test function for module  
def _test():
    assert as_int('1') == 1

if __name__ == '__main__':
    _test()
</code></pre>
<p>...a <code>myothermodule.py</code> like this...</p>
<pre><code>#!/usr/bin/env python3

from .mymodule import as_int

# Exported function
def add(a, b):
    return as_int(a) + as_int(b)

# Test function for module  
def _test():
    assert add('1', '1') == 2

if __name__ == '__main__':
    _test()
</code></pre>
<p>...and a <code>main.py</code> like this...</p>
<pre><code>#!/usr/bin/env python3

from mypackage.myothermodule import add

def main():
    print(add('1', '1'))

if __name__ == '__main__':
    main()
</code></pre>
<p>...which works fine when you run <code>main.py</code> or <code>mypackage/mymodule.py</code>, but fails with <code>mypackage/myothermodule.py</code>, due to the relative import...</p>
<pre><code>from .mymodule import as_int
</code></pre>
<p>The way you're supposed to run it is...</p>
<pre><code>python3 -m mypackage.myothermodule
</code></pre>
<p>...but it's somewhat verbose, and doesn't mix well with a shebang line like <code>#!/usr/bin/env python3</code>.</p>
<p>The simplest fix for this case, assuming the name <code>mymodule</code> is globally unique, would be to avoid using relative imports, and just use...</p>
<pre><code>from mymodule import as_int
</code></pre>
<p>...although, if it's not unique, or your package structure is more complex, you'll need to include the directory containing your package directory in <code>PYTHONPATH</code>, and do it like this...</p>
<pre><code>from mypackage.mymodule import as_int
</code></pre>
<p>...or if you want it to work "out of the box", you can frob the <code>PYTHONPATH</code> in code first with this...</p>
<pre><code>import sys
import os

PACKAGE_PARENT = '..'
SCRIPT_DIR = os.path.dirname(os.path.realpath(os.path.join(os.getcwd(), os.path.expanduser(__file__))))
sys.path.append(os.path.normpath(os.path.join(SCRIPT_DIR, PACKAGE_PARENT)))

from mypackage.mymodule import as_int
</code></pre>
<p>It's kind of a pain, but there's a clue as to why in <a href="http://mail.python.org/pipermail/python-3000/2007-April/006793.html" rel="noreferrer">an email</a> written by a certain Guido van Rossum...</p>
<blockquote>
<p>I'm -1 on this and on any other proposed twiddlings of the <code>__main__</code>
  machinery. The only use case seems to be running scripts that happen
  to be living inside a module's directory, which I've always seen as an
  antipattern. To make me change my mind you'd have to convince me that
  it isn't.</p>
</blockquote>
<p>Whether running scripts inside a package is an antipattern or not is subjective, but personally I find it really useful in a package I have which contains some custom wxPython widgets, so I can run the script for any of the source files to display a <code>wx.Frame</code> containing only that widget for testing purposes.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Explanation</h1>
<p>From <a href="https://www.python.org/dev/peps/pep-0328/" rel="noreferrer">PEP 328</a></p>
<blockquote>
<p>Relative imports use a module's __name__ attribute to determine that
  module's position in the package hierarchy. If the module's name does
  not contain any package information (e.g. it is set to '__main__')
  <strong>then relative imports are resolved as if the module were a top level
  module</strong>, regardless of where the module is actually located on the file
  system.</p>
</blockquote>
<p>At some point <a href="https://www.python.org/dev/peps/pep-0338/" rel="noreferrer">PEP 338</a> conflicted with <a href="https://www.python.org/dev/peps/pep-0328/" rel="noreferrer">PEP 328</a>:</p>
<blockquote>
<p>... relative imports rely on <em>__name__</em> to determine the current
  module's position in the package hierarchy. In a main module, the
  value of <em>__name__</em> is always <em>'__main__'</em>, so explicit relative imports
  will always fail (as they only work for a module inside a package)</p>
</blockquote>
<p>and to address the issue, <a href="https://www.python.org/dev/peps/pep-0366/" rel="noreferrer">PEP 366</a> introduced the top level variable <a href="https://docs.python.org/3/reference/import.html#__package__" rel="noreferrer"><code>__package__</code></a>:</p>
<blockquote>
<p>By adding a new module level attribute, this PEP allows relative
  imports to work automatically if the module is executed using the <em>-m</em>
  switch. A small amount of boilerplate in the module itself will allow
  the relative imports to work when the file is executed by name. [...] When it [the attribute] is present, relative imports will be based on this attribute
  rather than the module <em>__name__</em> attribute. [...] When the main module is specified by its filename, then the <em>__package__</em> attribute will be set to <em>None</em>. [...] <strong>When the import system encounters an explicit relative import in a
  module without __package__ set (or with it set to None), it will
  calculate and store the correct value</strong> (<strong>__name__.rpartition('.')[0]
  for normal modules</strong> and <em>__name__</em> for package initialisation modules)</p>
</blockquote>
<p>(emphasis mine)</p>
<p>If the <code>__name__</code> is <code>'__main__'</code>, <code>__name__.rpartition('.')[0]</code> returns empty string. This is why there's empty string literal in the error description:</p>
<pre class="lang-none prettyprint-override"><code>SystemError: Parent module '' not loaded, cannot perform relative import
</code></pre>
<p>The relevant part of the CPython's <a href="https://hg.python.org/cpython/file/9d65a195246b/Python/import.c#l1494" rel="noreferrer"><code>PyImport_ImportModuleLevelObject</code> function</a>:</p>
<pre class="lang-c prettyprint-override"><code>if (PyDict_GetItem(interp-&gt;modules, package) == NULL) {
    PyErr_Format(PyExc_SystemError,
            "Parent module %R not loaded, cannot perform relative "
            "import", package);
    goto error;
}
</code></pre>
<p>CPython raises this exception if it was unable to find <code>package</code> (the name of the package) in <code>interp-&gt;modules</code> (accessible as <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="noreferrer"><code>sys.modules</code></a>). Since <code>sys.modules</code> is <em>"a dictionary that maps module names to modules which have already been loaded"</em>, it's now clear that <strong>the parent module must be explicitly absolute-imported before performing relative import</strong>.</p>
<p><strong><em>Note:</em></strong>  The patch from the <a href="http://bugs.python.org/issue18018" rel="noreferrer">issue 18018</a> has added <a href="https://hg.python.org/cpython/file/c4e4886c6052/Python/import.c#l1494" rel="noreferrer">another <code>if</code> block</a>, which will be executed <strong>before</strong> the code above:</p>
<pre class="lang-c prettyprint-override"><code>if (PyUnicode_CompareWithASCIIString(package, "") == 0) {
    PyErr_SetString(PyExc_ImportError,
            "attempted relative import with no known parent package");
    goto error;
} /* else if (PyDict_GetItem(interp-&gt;modules, package) == NULL) {
    ...
*/
</code></pre>
<p>If <code>package</code> (same as above) is empty string, the error message will be</p>
<pre class="lang-none prettyprint-override"><code>ImportError: attempted relative import with no known parent package
</code></pre>
<p>However, you will only see this in Python 3.6 or newer.</p>
<h1>Solution #1: Run your script using -m</h1>
<p>Consider a directory (which is a Python <a href="https://docs.python.org/3/glossary.html#term-package" rel="noreferrer">package</a>):</p>
<pre class="lang-none prettyprint-override"><code>.
├── package
│   ├── __init__.py
│   ├── module.py
│   └── standalone.py
</code></pre>
<p>All of the files in <em>package</em> begin with the same 2 lines of code:</p>
<pre><code>from pathlib import Path
print('Running' if __name__ == '__main__' else 'Importing', Path(__file__).resolve())
</code></pre>
<p>I'm including these two lines <em>only</em> to make the order of operations obvious. We can ignore them completely, since they don't affect the execution.</p>
<p><em>__init__.py</em> and <em>module.py</em> contain only those two lines (i.e., they are effectively empty).</p>
<p><em>standalone.py</em> additionally attempts to import <em>module.py</em> via relative import:</p>
<pre><code>from . import module  # explicit relative import
</code></pre>
<p>We're well aware that <code>/path/to/python/interpreter package/standalone.py</code> will fail. However, we can run the module with the <a href="https://docs.python.org/3/using/cmdline.html?highlight=#cmdoption-m" rel="noreferrer"><code>-m</code> command line option</a> that will <em>"search <a href="https://docs.python.org/3/library/sys.html#sys.path" rel="noreferrer"><code>sys.path</code></a> for the named module and execute its contents as the <code>__main__</code> module"</em>:</p>
<pre class="lang-bash prettyprint-override"><code>vaultah@base:~$ python3 -i -m package.standalone
Importing /home/vaultah/package/__init__.py
Running /home/vaultah/package/standalone.py
Importing /home/vaultah/package/module.py
&gt;&gt;&gt; __file__
'/home/vaultah/package/standalone.py'
&gt;&gt;&gt; __package__
'package'
&gt;&gt;&gt; # The __package__ has been correctly set and module.py has been imported.
... # What's inside sys.modules?
... import sys
&gt;&gt;&gt; sys.modules['__main__']
&lt;module 'package.standalone' from '/home/vaultah/package/standalone.py'&gt;
&gt;&gt;&gt; sys.modules['package.module']
&lt;module 'package.module' from '/home/vaultah/package/module.py'&gt;
&gt;&gt;&gt; sys.modules['package']
&lt;module 'package' from '/home/vaultah/package/__init__.py'&gt;
</code></pre>
<p><code>-m</code> does all the importing stuff for you and automatically sets <code>__package__</code>, but you can do that yourself in the</p>
<h1>Solution #2: Set __package__ manually</h1>
<p><strong><em>Please treat it as a proof of concept rather than an actual solution. It isn't well-suited for use in real-world code.</em></strong></p>
<p><a href="https://www.python.org/dev/peps/pep-0366/" rel="noreferrer">PEP 366</a> has a workaround to this problem, however, it's incomplete, because setting <code>__package__</code> alone is not enough. You're going to need to import at least <em>N</em> preceding packages in the module hierarchy, where <em>N</em> is the number of parent directories (relative to the directory of the script) that will be searched for the module being imported.</p>
<p>Thus,</p>
<ol>
<li><p>Add the parent directory of the <em>Nth</em> predecessor of the current module to <code>sys.path</code></p></li>
<li><p>Remove the current file's directory from <code>sys.path</code></p></li>
<li><p>Import the parent module of the current module using its fully-qualified name</p></li>
<li><p>Set <code>__package__</code> to the fully-qualified name from <em>2</em></p></li>
<li><p>Perform the relative import</p></li>
</ol>
<p>I'll borrow files from the <em>Solution #1</em> and add some more subpackages:</p>
<pre class="lang-none prettyprint-override"><code>package
├── __init__.py
├── module.py
└── subpackage
    ├── __init__.py
    └── subsubpackage
        ├── __init__.py
        └── standalone.py
</code></pre>
<p>This time <em>standalone.py</em> will import <em>module.py</em> from the <em>package</em> package using the following relative import</p>
<pre><code>from ... import module  # N = 3
</code></pre>
<p>We'll need to precede that line with the boilerplate code, to make it work.</p>
<pre><code>import sys
from pathlib import Path

if __name__ == '__main__' and __package__ is None:
    file = Path(__file__).resolve()
    parent, top = file.parent, file.parents[3]

    sys.path.append(str(top))
    try:
        sys.path.remove(str(parent))
    except ValueError: # Already removed
        pass

    import package.subpackage.subsubpackage
    __package__ = 'package.subpackage.subsubpackage'

from ... import module # N = 3
</code></pre>
<p>It allows us to execute <em>standalone.py</em> by filename:</p>
<pre class="lang-bash prettyprint-override"><code>vaultah@base:~$ python3 package/subpackage/subsubpackage/standalone.py
Running /home/vaultah/package/subpackage/subsubpackage/standalone.py
Importing /home/vaultah/package/__init__.py
Importing /home/vaultah/package/subpackage/__init__.py
Importing /home/vaultah/package/subpackage/subsubpackage/__init__.py
Importing /home/vaultah/package/module.py
</code></pre>
<p>A more general solution wrapped in a function can be found <a href="https://gist.github.com/vaultah/d63cb4c86be2774377aa674b009f759a" rel="noreferrer">here</a>. Example usage:</p>
<pre><code>if __name__ == '__main__' and __package__ is None:
    import_parents(level=3) # N = 3

from ... import module
from ...module.submodule import thing
</code></pre>
<h1>Solution #3: Use absolute imports and <a href="https://setuptools.readthedocs.io/en/latest/" rel="noreferrer">setuptools</a></h1>
<p>The steps are -</p>
<ol>
<li><p>Replace explicit relative imports with equivalent absolute imports</p></li>
<li><p>Install <code>package</code> to make it importable</p></li>
</ol>
<p>For instance, the directory structure may be as follows</p>
<pre class="lang-none prettyprint-override"><code>.
├── project
│   ├── package
│   │   ├── __init__.py
│   │   ├── module.py
│   │   └── standalone.py
│   └── setup.py
</code></pre>
<p>where <em>setup.py</em> is</p>
<pre><code>from setuptools import setup, find_packages
setup(
    name = 'your_package_name',
    packages = find_packages(),
)
</code></pre>
<p>The rest of the files were borrowed from the <em>Solution #1</em>.</p>
<p>Installation will allow you to import the package regardless of your working directory (assuming there'll be no naming issues).</p>
<p>We can modify <em>standalone.py</em> to use this advantage (step 1):</p>
<pre><code>from package import module  # absolute import
</code></pre>
<p>Change your working directory to <code>project</code> and run <code>/path/to/python/interpreter setup.py install --user</code> (<code>--user</code> installs the package in <a href="https://docs.python.org/3/library/site.html#site.USER_SITE" rel="noreferrer">your site-packages directory</a>) (step 2):</p>
<pre class="lang-bash prettyprint-override"><code>vaultah@base:~$ cd project
vaultah@base:~/project$ python3 setup.py install --user
</code></pre>
<p>Let's verify that it's now possible to run <em>standalone.py</em> as a script:</p>
<pre class="lang-bash prettyprint-override"><code>vaultah@base:~/project$ python3 -i package/standalone.py
Running /home/vaultah/project/package/standalone.py
Importing /home/vaultah/.local/lib/python3.6/site-packages/your_package_name-0.0.0-py3.6.egg/package/__init__.py
Importing /home/vaultah/.local/lib/python3.6/site-packages/your_package_name-0.0.0-py3.6.egg/package/module.py
&gt;&gt;&gt; module
&lt;module 'package.module' from '/home/vaultah/.local/lib/python3.6/site-packages/your_package_name-0.0.0-py3.6.egg/package/module.py'&gt;
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.modules['package']
&lt;module 'package' from '/home/vaultah/.local/lib/python3.6/site-packages/your_package_name-0.0.0-py3.6.egg/package/__init__.py'&gt;
&gt;&gt;&gt; sys.modules['package.module']
&lt;module 'package.module' from '/home/vaultah/.local/lib/python3.6/site-packages/your_package_name-0.0.0-py3.6.egg/package/module.py'&gt;
</code></pre>
<p><strong><em>Note</em></strong>: If you decide to go down this route, you'd be better off using <a href="https://docs.python.org/3/library/venv.html" rel="noreferrer">virtual environments</a> to install packages in isolation.</p>
<h1>Solution #4: Use absolute imports and some boilerplate code</h1>
<p>Frankly, the installation is not necessary - you could add some boilerplate code to your script to make absolute imports work.</p>
<p>I'm going to borrow files from <em>Solution #1</em> and change <em>standalone.py</em>:</p>
<ol>
<li><p>Add the parent directory of <em>package</em> to <code>sys.path</code> <em>before</em> attempting to import anything from <em>package</em> using absolute imports:</p>
<pre><code>import sys
from pathlib import Path # if you haven't already done so
file = Path(__file__).resolve()
parent, root = file.parent, file.parents[1]
sys.path.append(str(root))

# Additionally remove the current file's directory from sys.path
try:
    sys.path.remove(str(parent))
except ValueError: # Already removed
    pass
</code></pre></li>
<li><p>Replace the relative import by the absolute import:</p>
<pre><code>from package import module  # absolute import
</code></pre></li>
</ol>
<p><em>standalone.py</em> runs without problems:</p>
<pre class="lang-bash prettyprint-override"><code>vaultah@base:~$ python3 -i package/standalone.py
Running /home/vaultah/package/standalone.py
Importing /home/vaultah/package/__init__.py
Importing /home/vaultah/package/module.py
&gt;&gt;&gt; module
&lt;module 'package.module' from '/home/vaultah/package/module.py'&gt;
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.modules['package']
&lt;module 'package' from '/home/vaultah/package/__init__.py'&gt;
&gt;&gt;&gt; sys.modules['package.module']
&lt;module 'package.module' from '/home/vaultah/package/module.py'&gt;
</code></pre>
<p>I feel that I should warn you: try not to do this, <em>especially</em> if your project has a complex structure.</p>
<hr/>
<p>As a side note, <a href="https://www.python.org/dev/peps/pep-0008/#imports" rel="noreferrer">PEP 8</a> recommends the use of absolute imports, but states that in some scenarios explicit relative imports are acceptable:</p>
<blockquote>
<p>Absolute imports are recommended, as they are usually more readable
  and tend to be better behaved (or at least give better error
  messages). [...] However, explicit relative imports are an acceptable
  alternative to absolute imports, especially when dealing with complex
  package layouts where using absolute imports would be unnecessarily
  verbose.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I ran into this issue.  A hack workaround is importing via an if/else block like follows:</p>
<pre><code>#!/usr/bin/env python3
#myothermodule

if __name__ == '__main__':
    from mymodule import as_int
else:
    from .mymodule import as_int


# Exported function
def add(a, b):
    return as_int(a) + as_int(b)

# Test function for module  
def _test():
    assert add('1', '1') == 2

if __name__ == '__main__':
    _test()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Put this inside your package's __init__.py file</strong>:</p>
<pre><code># For relative imports to work in Python 3.6
import os, sys; sys.path.append(os.path.dirname(os.path.realpath(__file__)))
</code></pre>
<p>Assuming your package is like this:</p>
<pre><code>├── project
│   ├── package
│   │   ├── __init__.py
│   │   ├── module1.py
│   │   └── module2.py
│   └── setup.py
</code></pre>
<p>Now use regular imports in you package, like:</p>
<pre><code># in module2.py
from module1 import class1
</code></pre>
<p>This works in both python 2 and 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Hopefully, this will be of value to someone out there - I went through half a dozen stackoverflow posts trying to figure out relative imports similar to whats posted above here. I set up everything as suggested but I was still hitting <code>ModuleNotFoundError: No module named 'my_module_name'</code></p>
<p>Since I was just developing locally and playing around, I hadn't created/run a <code>setup.py</code> file. I also hadn't apparently set my <code>PYTHONPATH</code>. </p>
<p>I realized that when I ran my code as I had been when the tests were in the same directory as the module, I couldn't find my module:</p>
<pre><code>$ python3 test/my_module/module_test.py                                                                                                               2.4.0
Traceback (most recent call last):
  File "test/my_module/module_test.py", line 6, in &lt;module&gt;
    from my_module.module import *
ModuleNotFoundError: No module named 'my_module'
</code></pre>
<p>However, when I explicitly specified the path things started to work:</p>
<pre><code>$ PYTHONPATH=. python3 test/my_module/module_test.py                                                                                                  2.4.0
...........
----------------------------------------------------------------------
Ran 11 tests in 0.001s

OK
</code></pre>
<p>So, in the event that anyone has tried a few suggestions, believes their code is structured correctly and still finds themselves in a similar situation as myself try either of the following if you don't export the current directory to your PYTHONPATH:</p>
<ol>
<li>Run your code and explicitly include the path like so:
<code>$ PYTHONPATH=. python3 test/my_module/module_test.py</code> </li>
<li>To avoid calling <code>PYTHONPATH=.</code>, create a <code>setup.py</code> file with contents like the following and run <code>python setup.py development</code> to add packages to the path:</li>
</ol>
<blockquote>
<pre><code># setup.py
from setuptools import setup, find_packages

setup(
    name='sample',
    packages=find_packages()
)
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>if both packages are in your import path (sys.path), and the module/class you want is in example/example.py, then to access the class without relative import try:</p>
<pre><code>from example.example import fkt
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To obviate this problem, I devised a solution with the <a href="https://pypi.python.org/pypi/repackage/0.5" rel="nofollow noreferrer">repackage</a> package, which has worked for me for some time. It adds the upper directory to the lib path:</p>
<pre><code>import repackage
repackage.up()
from mypackage.mymodule import myfunction
</code></pre>
<p>Repackage can make relative imports that work in a wide range of cases, using an intelligent strategy (inspecting the call stack).</p>
</div>
<div class="post-text" itemprop="text">
<p>I needed to run python3 from the main project directory to make it work.</p>
<p>For example, if the project has the following structure:</p>
<pre><code>project_demo/
├── main.py
├── some_package/
│   ├── __init__.py
│   └── project_configs.py
└── test/
    └── test_project_configs.py
</code></pre>
<h3>Solution</h3>
<p>I would run python3 inside folder <em>project_demo/</em> and then perform a</p>
<pre><code>from some_package import project_configs
</code></pre>
</div>
<span class="comment-copy">This means you are running a module inside the package as a script. Only run scripts from <i>outside</i> the package.</span>
<span class="comment-copy">Probably you should define the conditions you have those 'sometimes' you mention. I understand you do not mean you have random errors.</span>
<span class="comment-copy">@ joaquin: I don't remember. It happened many, many times over the last weeks in different conditions.</span>
<span class="comment-copy">@MartijnPieters: well, unfortunately, this module needs to be inside the package, and it also needs to be runnable as a script, sometimes. Any idea how I could achieve that?</span>
<span class="comment-copy">@JohnSmithOptional: Mixing scripts inside packages is <i>tricky</i> and should be avoided if at all possible. Use a wrapper script that imports the package and runs your 'scripty' function instead.</span>
<span class="comment-copy">A better way to get SCRIPTDIR is given in <a href="http://stackoverflow.com/questions/279237/import-a-module-from-a-relative-path?lq=1#comment15918105_6098238">a comment of Import a module from a relative path</a> as <code>os.path.realpath(os.path.dirname(inspect.getfile(inspect.currentframe())))</code> if your confident that your module has always a proper <code>file</code> you could also use <code>os.path.realpath(os.path.dirname(__file__))</code>.</span>
<span class="comment-copy">You can expand your PYTHONPATH by applying more shorter and readable code snippet:  <code>sys.path.append( os.path.join( os.path.dirname(__file__), os.path.pardir ) ) </code></span>
<span class="comment-copy">I still had trouble when dealing with a script that had the same name as the package, e.g. in <code>foo/foo.py:  from foo.bar import baz</code>. Inserting the path at the beginning instead of appending solved the issue. The full command: <code>sys.path.insert(0, os.path.join(os.path.dirname(__file__), os.path.pardir))</code></span>
<span class="comment-copy">Is it possible to set <code>__package__</code> manually if name is <code>__main__</code> in order to solve the problem?</span>
<span class="comment-copy">@PauloScardine: No, I don't think so. <a href="https://www.python.org/dev/peps/pep-0366/" rel="nofollow noreferrer">PEP 366</a> provides a boilerplate example, but it also states that just setting <code>__package__</code> is not enough. C source suggests that the package must be in <code>sys.modules</code> at the time of relative import, ergo the top level package must be imported at some point before.</span>
<span class="comment-copy">Thanks, nice answers! I was able to load the module using the <code>imp</code> module and set <code>__package__</code> accordingly but the result is clearly an anti-pattern.</span>
<span class="comment-copy">I get the error <code>AttributeError: 'PosixPath' object has no attribute 'path'</code>.</span>
<span class="comment-copy">You can also import a file by file path (relative too): <a href="https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">that's not a very nice solution. also, bare <code>except:</code> is bad. use <code>except ImportError:</code> instead!</span>
<span class="comment-copy">It is <code>SystemError</code> here. (Py 3.4)</span>
<span class="comment-copy">This isn't a terrible idea, but it would be better to detect which import to use rather than try/except.  Something like <code>if __name__ == '__main__': from mymod import as_int; else: from .mymod import as_int</code>.</span>
<span class="comment-copy">@Perkins Well... in most cases it <i>wouldn't</i>. I think relative imports may be the exception though.</span>
<span class="comment-copy">This edited answer seems very elegant to me. Are there people who still object?</span>
<span class="comment-copy">Brilliant! All the other options hurt my head and result in code that was clean and straightforward becoming all messed up.</span>
<span class="comment-copy">Awesome. The simplest solution to solve relative ImportError.</span>
<span class="comment-copy">does this work if we package it as weel</span>
<span class="comment-copy">This and relatively importing from my test files finally fixed something I'd been hammering my head against for far too long. Thank you, thank you, thank you.</span>
<span class="comment-copy">Thank you! your solution works great and deserves more votes!</span>
