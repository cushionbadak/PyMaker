<div class="post-text" itemprop="text">
<p>I have 3 lists-of-lists.</p>
<p>The sub-lists' field 1 is a name, field 2 is a number, and field 3 is a number. This format is always the same, and doesn't change. There are always the same names in the 3 lists; however, the <strong>order may not be the same</strong>.</p>
<pre><code>a = [['jane', '1', '120'], ['bob', '3', '35'], ['joe', '5', '70']]
b = [['bob', '1', '12'], ['jane', '2', '240'], ['joe', '1', '100']]
c = [['joe', '2', '30'], ['jane', '5', '45'], ['bob', '0', '0']]
</code></pre>
<p>I would like a result (any object type) with the sum of fields 2 &amp; 3 of the lists' sub-lists.</p>
<pre><code>result = [['jane', '8', '405'], ['bob', '4', '47'], ['joe', '8', '200']]
</code></pre>
<hr/>
<p>In pseudo Python3 code, I'm guessing it'd look like this, but I cannot figure out the correct way to do it in Python3. Let alone doing it in a Pythonic way:</p>
<pre><code>def sum_f2_f3(list_a, list_b)
    where element[0] in list_a.sub_list == element[0] in list_b.sub_list:
        x = element[0]
        result[x:1] = list_a.sub_list[0:1] + list_b.sub_list[0:1]
        result[x:2] = list_a.sub_list[0:2] + list_b.sub_list[0:2]
    return result

result = sum_f2_f3(sum_f2_f3(a,b), c)
</code></pre>
<p>Any ideas? What built-in Python tools can help me with this?</p>
</div>
<div class="post-text" itemprop="text">
<p>To illustrate why using the right data structures makes things a lot easier…</p>
<p>Let's say that <code>a</code>, <code>b</code>, and <code>c</code> were actually <code>dict</code>s, and your numbers were actually <code>int</code>s instead of <code>str</code>s. After all, the whole point of a <code>dict</code> is to look things up by name, and the whole point of an <code>int</code> is to be able to do arithmetic. So:</p>
<pre><code>a = {'jane': [1, 120], 'bob': [3, 35], 'joe': [5, 70]}
b = {'bob': [1, 12], 'jane': [2, 240], 'joe': [1, 100]}
c = {'joe': [2, 30], 'jane': [5, 45], 'bob': [0, 0]}
</code></pre>
<p>Now, all you have to do is this:</p>
<pre><code>result = {}
for d in a, b, c:
    for k, v in d.items():
        if not k in result:
            result[k] = [0, 0]
        result[k][0] += v[0]
        result[k][1] += v[1]
</code></pre>
<p>And the result is:</p>
<pre><code>{'bob': [4, 47], 'jane': [8, 405], 'joe': [8, 200]}
</code></pre>
<p>There's still a bit of room for improvement—you can use a <code>defaultdict</code> to get rid of the <code>if not k in result:</code> bit—but even with just novice-level stuff this is pretty compact and simple.</p>
<hr/>
<p>But what if you got those lists as input—you'd like to have nice dicts in the end, but you don't start there?</p>
<p>You can write a function to convert them, like this:</p>
<pre><code>def convert(list_of_lists):
    result = {}
    for element in list_of_lists:
        key = element[0]
        values = []
        for value in element[1:]:
            values.append(int(value))
        result[key] = values
    return result
</code></pre>
<p>And if you spot the familiar <code>values = []… for value in … values.append(…)</code> pattern, you can turn that into the simple list comprehension <code>[int(value) for value in element[1:]]</code>. And then the whole thing is the dict equivalent of the same pattern, so you can reduce all of it to:</p>
<pre><code>return {element[0]: [int(value) for value in element[1:]] for element in list_of_lists}
</code></pre>
<p>Meanwhile, if you need to convert back to the original form, that's just:</p>
<pre><code>def unconvert(dict_of_lists):
    result = []
    for key, values in dict_of_lists.items():
        element = [key] + [str(value) for value in values]
        result.append(element)
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This seems to give what you want using more pythonic list comprehensions.</p>
<pre><code>&gt;&gt;&gt; [[e[0][0], sum(int(r[1]) for r in e), sum(int(r[2]) for r in e)] 
        for e in zip(a, b, c)]
[['jane', 8, 405], ['bob', 4, 47], ['joe', 8, 200]]
</code></pre>
<p>If you want it to work with out of order names, you could do something like this</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; [[name] + 
        reduce(
            lambda a, b: [int(c) + int(d) for (c,d) in zip(a, b)], 
            [r[1:] for r in records]) 
        for name, records 
        in groupby(
            sorted(r for l in [a, b, c] for r in l), 
            lambda r: r[0])
    ]

[['bob', 4, 47], ['jane', 8, 405], ['joe', 8, 200]]  
</code></pre>
<p>Don't judge me.  I don't really write code like that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Recursive's answer is the most compact reasonable way to do this, and Ashwini Chaudhary's is the most flexible and conceptually nicest… but if you want to know how to make your almost-code work:</p>
<p>The key thing you're missing is "How do I iterate over two lists in lock-step?" That's exactly what <a href="http://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> is for. Just zip the two lists together, and you get this:</p>
<pre><code>[(['jane', '1', '120'], ['jane', '2', '240']),
 (['bob', '3', '35'], ['bob', '1', '12']),
 (['joe', '5', '70'], ['joe', '1', '100'])]
</code></pre>
<p>(Except it's an iterator, not a list.)</p>
<hr/>
<p>The rest of your code pretty much works, except that you got a bit confused about the names. Here's a fixed-up version.</p>
<pre><code>def sum_f2_f3(list_a, list_b):
    result = []
    for element_a, element_b in zip(list_a, list_b):
        result_element = [element_a[0],
                          element_a[1] + element_b[1],
                          element_a[2] + element_b[2]]
        result.append(result_element)
    return result

result = sum_f2_f3(sum_f2_f3(a,b), c)
</code></pre>
<hr/>
<p>Except that you're summing up a bunch of strings. That's perfectly legal, but what it gets you is this:</p>
<pre><code>[['jane', '125', '12024045'],
 ['bob', '310', '35120'],
 ['joe', '512', '7010030']]
</code></pre>
<p>You probably wanted to convert these values to <code>int</code> at some point. If not, if you want to convert to <code>int</code>, sum, and convert back to <code>str</code>, that's pretty trivial:</p>
<pre><code>def sum_f2_f3(list_a, list_b):
    result = []
    for element_a, element_b in zip(list_a, list_b):
        result_element = [element_a[0],
                          str(int(element_a[1]) + int(element_b[1])),
                          str(int(element_a[2]) + int(element_b[2]))]
        result.append(result_element)
    return result
</code></pre>
<hr/>
<p>Once you've got this, there are a number of ways you can improve it.</p>
<p>For example, you can always replace a <code>results = []</code>, <code>for</code> loop, and <code>result.append(…)</code> with a list comprehension once you recognize that you've hit the exact pattern a comprehension is for:</p>
<pre><code>def sum_f2_f3(list_a, list_b):
    return [[element_a[0],
             element_a[1] + element_b[1],
             element_a[2] + element_b[2]]
            for elementa, element_b in zip(list_a, list_b)]
</code></pre>
<p>Or, you can generalize it to work on all three lists together, or even any number of lists—<code>zip</code> already does that, and you can just replace the <code>+</code> with <code>sum</code>:</p>
<pre><code>def sum_f_lists(*lists):
    results = []
    for elements in zip(*lists):
        result_element = [elements[0][0],
                          sum(element[1] for element in elements),
</code></pre>
<p>                              sum(element[2] for element in elements)]
            result.append(result_element)
        return result</p>
<p>Or you can make it work for 0 or more numbers instead of exactly two, or not depend on ordering, etc. When you take it far enough, step by step, you'll end up with something like one of the two other answers.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>dict</code>, this will work for unordered items as well:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; a = [['jane', '1', '120'], ['bob', '3', '35'], ['joe', '5', '70']]
&gt;&gt;&gt; b = [['bob', '1', '12'], ['jane', '2', '240'], ['joe', '1', '100']]
&gt;&gt;&gt; c = [['joe', '2', '30'], ['jane', '5', '45'], ['bob', '0', '0']]

for k in chain(a,b,c):
    if k[0] not in dic:
        dic[k[0]] = [ int(x) for x in k[1:]]
    else:
        dic[k[0]] = [x + int(y) for x,y in zip(dic[k[0]], k[1:])]

&gt;&gt;&gt; [ [k]+[str(x) for x in v]  for k,v in dic.items()]
[['joe', '8', '200'], ['jane', '8', '405'], ['bob', '4', '47']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Once again, list comprehension will do the trick:</p>
<pre><code>l = [a, b, c]
result =[ [e[0], sum( [int(ls[id][1]) for ls in l] ),
sum( [int(ls[id][2]) for ls in l] ) ] for id, e in enumerate(l[0])]
</code></pre>
<p>But don't forget what the Zen of Python says: <code>Readability counts</code>. You should avoid one-liners if they require too much time to be understood.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you state <code>any result type</code> is accepted, here is a form that returns a dict, which I think is an appropriate return type for this sort of work:</p>
<pre><code>a = [['jane', '1', '120'], ['bob', '3', '35'], ['joe', '5', '70']]
b = [['jane', '2', '240'], ['bob', '1', '12'], ['joe', '1', '100']]
c = [['jane', '5', '45'], ['bob', '0', '0'], ['joe', '2', '30']]

def summation(*args):
    d = {}
    for name, v1, v2 in [item for sublist in args for item in sublist]:
        v1, v2 = int(v1), int(v2)
        try:
            d[name] = (d[name][0]+v1, d[name][1]+v2)
        except KeyError:
            d[name] = (v1, v2)

    return d

print summation(a,b,c)
</code></pre>
<p>RETURNS</p>
<pre><code>{'jane': (8, 405), 'bob': (4, 47), 'joe': (8, 200)}
</code></pre>
<p>There's certain to be more compact and perhaps performant options, but the plus to this approach (I believe!) is that it does seem readable.</p>
</div>
<span class="comment-copy">Small point, all your fields are strings.</span>
<span class="comment-copy">@BurhanKhalid Yes, you're right... I should have said that the sub-lists contain a 'name', 'number', 'number'.</span>
<span class="comment-copy">You have a missing <code>'</code> on the <code>8</code> in the <code>jane</code> sublist of your example result. Also, just as a general comment, I feel like those nested <code>list</code>s should be object. It could make your list comprehensions more readable. (Attribute names instead of mysterious indexes.)</span>
<span class="comment-copy">If the lists aren't always in the same order, you probably don't want lists in the first place. Wouldn't a dict like <code>a = {'joe': [2, 30], 'jane': [5, 45], 'bob': [0, 0]}</code> be easier to understand? (It would also make the code easier to write, but that's a much less important point. Having the data in a form that makes sense usually makes code simpler, but it's generally worth doing even when it doesn't.)</span>
<span class="comment-copy">@abarnert Using dicts could definitely work. In fact, I tried to solve this using dicts first, but gave up when my brain took a nap. Assuming I had a dict in the same format, how would you sum the the values for multiple dicts based on index name?</span>
<span class="comment-copy">I like this one!</span>
<span class="comment-copy">@svenglar: Just keep in mind that it doesn't use the same data types you started with, and it doesn't give you results in the format you wanted, either. But, even if that's important, it might be worth writing the code to convert back and forth and still do it with dicts.</span>
<span class="comment-copy">I'm accepting this as the answer even though I know that I originally never mentioned dicts. Thanks to everyone for all the additional answers though, they really did help me understand the problem.</span>
<span class="comment-copy">@abarnet I can start off with the data being in a dict if I tweak some things that aren't mentioned in this post.   What I'm doing is receiving a comma-separated list of names &amp; values from 3 remote servers. I then need to combine those results into one. I can accept the output from the server as a dict to begin with which will make your answer relevant.</span>
<span class="comment-copy">Thanks, this gives me the desired output. Now if only I could understand/read it :)</span>
<span class="comment-copy">@svenglar: My answer tries to show you to get step by step from where you've started to this answer (which is likely where you want to end up, or at least close to it).</span>
<span class="comment-copy">Thanks for the thorough explanation! My question is just a part of larger project, so you're ideas are helping me to streamline the entire project, not just this summing of lists problem.</span>
<span class="comment-copy">The lists may not always be in the same order. Sorry, I should have mentioned that at first. I've edited my original post.</span>
<span class="comment-copy">@svenglar then the dict based solution is going to work fine.</span>
<span class="comment-copy">Let's say I had a dict where the name is the index. Would it be best to have the 2 values in a list? Can a dict have an index with more than one value?</span>
<span class="comment-copy">@svenglar You can use a <code>tuple</code> as a key in a <code>dict</code>.</span>
<span class="comment-copy">@svenglar But there's no problem in keeping just two item in the value list. In dicts a key is always unique, so should be chosen properly.</span>
