<div class="post-text" itemprop="text">
<p>This is a program we've written for html parsing.
It works perfectly.</p>
<p>We found a demo program on the net, and we modified it for our needs.
But we don't understand how it works. </p>
<pre><code>import urllib
from urllib.request import urlopen


address='http://www.iitb.ac.in/acadpublic/RunningCourses.jsp?deptcd=EE&amp;year=2012&amp;semester=1'
print(address)
source= urlopen(address).read()
source=str(source)


from html.parser import HTMLParser

str1 = input('Enter name of prof:')

class MyHTMLParser(HTMLParser):
    y=" "
    def handle_data(self, data):
        flag=0
        x=str(data)
        for i in range(len(x)):
            if (x[i]=='\\'):
                flag=1
                break
        if(flag==0) :
            if(x==str1):
                global y
                print("Name of professor:",x)
                print("Name of course:",y) 
            y=x

parser = MyHTMLParser(strict=False)
parser.feed(source)
</code></pre>
<p>Our questions:</p>
<ol>
<li><p>why does the class <code>HTMLparser</code> have to be called in the first place?</p></li>
<li><p>why is that function <code>handle_data</code> being called, and how does that function work?</p></li>
<li><p>why is <code>global y</code> necessary despite <code>y</code> being in the class itself?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>It is not being called; you are inheriting from it instead; <code>MyHTMLParser</code> is called to create an instance of the class.</p></li>
<li><p><code>handle_data()</code> is called by the <code>HTMLParser</code> code; your subclass overrides it to handle textual data in the document. By calling <code>.feed()</code> on your <code>MyHTMLParser</code> instance the process is started.</p>
<p>See the <a href="http://docs.python.org/3/library/html.parser.html" rel="nofollow"><code>html.parser</code> module</a> documentation for the full API. You could try to understand the <a href="http://hg.python.org/cpython/file/3.3/Lib/html/parser.py" rel="nofollow">full <code>html.parser</code> source code</a> if you really want to know how this all works.</p></li>
<li><p>The example you found is doing things quite wrong, actually. The <code>global y</code> refers to a <strong>different</strong> <code>y</code> variable, one that lives in the module scope. That line shows that the original developer of that example did not understand what they were doing. The <code>global y</code> line is not the only example; the code could be made much more Pythonic in other ways.</p>
<p>The <code>y</code> definition in the class scope otherwise unused. The <code>handle_data()</code> method should refer to <code>self.y</code> instead:</p>
<pre><code>class MyHTMLParser(HTMLParser):
    y = None

    def handle_data(self, data):
        if '\\' not in data:
            if data == str1:
                print("Name of professor:", data)
                print("Name of course:", self.y) 
            self.y = x
</code></pre>
<p>This stores the element text in <code>self.y</code> for each element, and if a <em>next</em> element matches your <code>str1</code> global variable, then it is printed as well, together with the professor name.</p></li>
</ol>
<p>You may want to look into using <a href="http://www.crummy.com/software/BeautifulSoup/" rel="nofollow">BeautifulSoup</a> instead for a more intuitive HTML parser API.</p>
</div>
