<div class="post-text" itemprop="text">
<p>I know that when a <em>module</em> or even if a specific object in <em>that</em> module is imported -- <code>from foo import bar</code> -- that entire module is evaluated first. But I was just being curious that if we define an <code>__init__</code> or a <code>__new__</code> inside that module would it have an specially meaning or treatment like it does inside a <em>class</em> and a <em>package</em>? And why so?</p>
</div>
<div class="post-text" itemprop="text">
<p>No. There is a module class, and modules are instances of this class, but it's internal to Python. Defining magic methods in a module won't add them to the module class, and they won't do anything special at import time.</p>
</div>
<div class="post-text" itemprop="text">
<p>Putting it loosely, modules do not have methods.</p>
<p>More strictly, each module is an instance of some class, usually <code>builtins.module</code> (although you can replace this with an import hook or by monkeypatching), and that class does of course have methods. But the module's global functions are not methods of the module object.</p>
<p>You can verify this pretty easily by just printing out <code>type(foo.func)</code>. It's a function, not a bound method of the <code>foo</code> instance.</p>
<p>On top of that, even if module global functions <em>were</em> instance methods, that wouldn't make any difference, because <code>__init__</code> is checked in the <em>class</em> dictionary, not the <em>instance</em> dictionary. If you think about it, there's no way it could possibly be otherwise, because you don't <em>have</em> an instance dictionary to check until <code>__init__</code> returns. So, this could only possibly work if each module were a class object (and instance of <code>type</code>), which they obviously aren't.</p>
<hr/>
<p>Your confusion with <code>__init__.py</code> is a red herring. Files are not functions, much less methods, and neither files nor modules can be called.</p>
<hr/>
<p>If you want the rigorous definitions: classes and modules are defined <a href="http://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow">here</a>. As you can see, the <code>__new__</code> method is a feature specific to classes. Its behavior is defined <a href="http://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow">here</a>. Note that <code>__init__</code> is actually called as a consequence of <code>object.__new__</code>, so it's not even technically defined for classes—but it certainly isn't defined for anything else.</p>
<p>Meanwhile, <code>__init__.py</code> is defined <a href="http://docs.python.org/3/reference/import.html#regular-packages" rel="nofollow">here</a>. (Note that, as of Python 3.2, this is just a convention used by the default importers for regular packages, not actually part of the language itself.)</p>
<p>The two features have nothing in common except naming and some vague similarities. Maybe the naming was a mistake, but I think more people get useful intuitions out of the naming than are confused. (At any rate, since it goes back to the <code>ni</code> module for Python 1.3, I doubt it will be changed anytime soon.)</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you could make a class that had <code>__init__()</code> and/or <code>__new__()</code> methods module-like by doing something similar to what is done in my answer to the unrelated question <a href="https://stackoverflow.com/questions/3711657/can-i-prevent-modifying-an-object-in-python">Can I prevent modifying an object in Python?</a></p>
</div>
<span class="comment-copy"><code>__init__</code> and <code>__new__</code> functions don't have any meaning inside a package.</span>
<span class="comment-copy">@abarnert well we do have a <code>__init__.py </code></span>
<span class="comment-copy">Yes, but that's not a function, or a method.</span>
<span class="comment-copy">@abarnert question updated. It gets executed though. Akin to function call? Different semantics I guess</span>
<span class="comment-copy">It's not a very close kin to a function call. A module contains code that gets executed when at first import time—that is, exactly once, when the module's definition is evaluated. A function contains code that does <i>not</i> get executed when the function's definition is evaluated, but instead gets executed each time the resulting function is later called. A module is not a <code>callable</code>, as you'd see immediately if you typed, e.g., <code>sys()</code> at the interactive prompt.</span>
<span class="comment-copy">This is a bit misleading. The key point here is that the global functions in a module are not methods of the module object. If you <i>do</i> define <code>__init__</code> and <code>__new__</code> methods in the module class (or, rather, in a subclass that you import-hook or monkeypatch in), they'll work.</span>
<span class="comment-copy">then why are packages treated differently? Referring to <code>__init__.py</code></span>
<span class="comment-copy">@hus787: They aren't treated differently. Who said they were?</span>
<span class="comment-copy">@abarnert when a package is imported the <code>__init__.py</code> is executed. But inside a module the <b>init</b> is not called/executed. Therefore seemingly different as per observation.</span>
<span class="comment-copy"><code>__init__.py</code> merely has the same name as the <code>__init__()</code> method. A file is, however, not a method, so there should be no confusion.</span>
