<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; line = "cat,ant,ate,abc,tan,act,tea"
&gt;&gt;&gt; words = line.split(",")
&gt;&gt;&gt; words
['cat', 'ant', 'ate', 'abc', 'tan', 'act', 'tea']
&gt;&gt;&gt; sorted_words = map(tuple, [sorted(eachword) for eachword in words])
&gt;&gt;&gt; sorted_words
[('a', 'c', 't'), ('a', 'n', 't'), ('a', 'e', 't'), ('a', 'b', 'c'), ('a', 'n', 't'), ('a', 'c', 't'), ('a', 'e', 't')]
&gt;&gt;&gt; repeated_words = set(sorted_words)
&gt;&gt;&gt; repeated_words
set([('a', 'b', 'c'), ('a', 'e', 't'), ('a', 'c', 't'), ('a', 'n', 't')])
&gt;&gt;&gt; for repeated_word in repeated_words:
    for index in [i for i, x in enumerate(sorted_words) if sorted_words.count(x) &gt; 1 and x == repeated_word]:
        print words[index],
    print '\t'



ate tea     
cat act     
ant tan
</code></pre>
<p>Able to get the anagrams in a line but wanted to know if there is any better approach to solve the above problem in less complexity. Please help me in calculating complexity for the above approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>The big efficiency problem here is the <code>if sorted_words.count(x) &gt; 1</code> that you do on each one.</p>
<p>Let's go through the parts. Say we have N elements, K unique elements, and the average word is length M.</p>
<ul>
<li>Sort each element of the list and put the result in another list. That's <code>O(MlogM)</code> time per element, or <code>O(NMlogM)</code> total.</li>
<li>Make a set out of that new list, which is <code>O(N)</code>.</li>
<li>For each word in the set, for each word in the list, count how many times the list-word appears in the list. This is the biggie. Counting how many times something appears in a list takes <code>O(N)</code> time, and you do it <code>KN</code> times, so that's <code>O(N^2 * K)</code>.</li>
<li>For each word in the set, iterate the list finding all matching values if the <code>count &gt; 1</code>. That's <code>O(NK)</code> time.</li>
</ul>
<p>You could fix that <code>O(N^2 * K)</code> part just by lifting the counting out of the list comprehension. Let's assume you did that, without explaining exactly how (it's pretty easy). Now your time is <code>O(NMlogM + N + NK)</code>. Assuming <code>M &lt;&lt; K</code>, that's <code>O(NK)</code>.</p>
<hr/>
<p>To fix this, you want to create a mapping from sorted words to original words, so you can look up the original words in constant time.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; repeated_words = {}
&gt;&gt;&gt; for word in words:
...     sorted_word = tuple(sorted(word))
...     repeated_words.setdefault(sorted_word, set()).add(word)
&gt;&gt;&gt; repeated_words
{('a', 'b', 'c'): {'abc'},
 ('a', 'c', 't'): {'act', 'cat'},
 ('a', 'e', 't'): {'ate', 'tea'},
 ('a', 'n', 't'): {'ant', 'tan'}}
&gt;&gt;&gt; for repeated_word, words in repeated_words.viewitems():
...     if len(words) &gt; 1:
...         print(' '.join(words))
tea ate
act cat
ant tan
</code></pre>
<p>Now, our first two steps are <code>O(NMlogM + N)</code>, but our third step is <code>O(K)</code> instead of <code>O(KN)</code>, because we're just doing one constant-time set lookup per set word, instead of one linear list traversal per set word.</p>
<p>So our total time is <code>O(NMlogM)</code>.</p>
<p>(If the order of the anagrams in each set matters, or if there can be actual duplicated words, you can map each sorted word to a list rather than a set of original words. That doesn't really affect the performance here, because the only thing we ever do with that list/set is append/add and iterate; I just used a set because it seemed like conceptually the order is irrelevant and there shouldn't be any duplicates.)</p>
<hr/>
<p>But we can do even better than that. It probably won't matter, given that <code>M &lt;&lt; K</code>, but… </p>
<p>Why do we need to sort the words? Because if two words are the same, their sorted letters are the same. But if two words are the same, their set of letters is <em>also</em> the same, as long as there aren't any duplicate letters—which there aren't in your example. (Even if there <em>were</em>, you could handle that by using a "multiset", like <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>Counter</code></a>, but immutable and hashable… although then comparisons aren't quite constant time anymore, they depend on the average number of duplicate letters… let's ignore that complexity, since it's not relevant to your example, but we could work it out if needed.)</p>
<pre><code>&gt;&gt;&gt; repeated_words = {}
&gt;&gt;&gt; for word in words:
...     letter_set = frozenset(word)
...     repeated_words.setdefault(letter_set, set()).add(word)
&gt;&gt;&gt; repeated_words
{frozenset({'a', 'b', 'c'}): {'abc'},
 frozenset({'a', 'e', 't'}): {'ate', 'tea'},
 frozenset({'a', 'n', 't'}): {'ant', 'tan'},
 frozenset({'a', 'c', 't'}): {'act', 'cat'}}
&gt;&gt;&gt; for repeated_word, words in repeated_words.viewitems():
...     if len(words) &gt; 1:
...         print(' '.join(words))
tea ate
ant tan
act cat
</code></pre>
<p>And now, our total time is just <code>O(NM)</code> instead of <code>O(NMlogM)</code>.</p>
<p>Again, that last improvement is probably not worth doing (especially if you need the multiset solution, because the time we'd spend figuring out how to express the complexity of <code>Counter.__eq__</code>, and building and explaining <code>FrozenCounter</code>, is probably more than the time we'd save running the program:), given <code>M &lt;&lt; K</code>.</p>
</div>
<span class="comment-copy">Try <code>words = ['aab', 'abb']</code> with your <code>set</code> solution.</span>
<span class="comment-copy">@StefanPochmann: Yes, for that case you need a multiset rather than a set. I was in the middle of editing that in when you commented.</span>
<span class="comment-copy">How would you do it with Counter? It's not hashable.</span>
<span class="comment-copy">@StefanPochmann: You just need to write a <code>FrozenCounter</code>.</span>
<span class="comment-copy">It's really useful, thank you for the explanation @abarnert</span>
