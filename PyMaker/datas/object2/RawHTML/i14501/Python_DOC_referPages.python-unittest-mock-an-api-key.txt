<div class="post-text" itemprop="text">
<p>I'm writing unit tests for the <code>Client</code> class of client.py, which queries an API. Each test instantiates the client with <code>c = client.Client("apikey")</code>. Running one test at a time works fine, but running them all (e.g. with <code>py.test</code>) I get a 401: "Exception: Response 401: Unauthorized Access. Requests must contain a valid api-key."</p>
<p>I have a valid API key but this should not be included in the unit tests. I would appreciate an explanation of why <code>"apikey"</code> works for only one query. More specifically, how can I mock out the calls to the API? Below is an example unit test:</p>
<pre><code>def testGetContextReturnFields(self):
  c = client.Client("apikey")
  contexts = c.getContext("foo")

  assert(isinstance(contexts[0]["context_label"], str))
  assert(contexts[0]["context_id"] == 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Separate out the tests for API calls and for the <code>Client.getContext()</code> method. For explicitly testing the API calls, patch a request object...</p>
<pre><code>import client
import httpretty
import requests
from mock import Mock, patch
...
def testGetQueryToAPI(self):
  """
  Tests the client can send a 'GET' query to the API, asserting we receive
  an HTTP status code reflecting successful operation.
  """
  # Arrange: patch the request in client.Client._queryAPI().
  with patch.object(requests, 'get') as mock_get:
    mock_get.return_value = mock_response = Mock()
    mock_response.status_code = 200

    # Act:
    c = client.Client()
    response = c._queryAPI("path", 'GET', {}, None, {})

    # Assert:
    self.assertEqual(response.status_code, 200)

# Repeat the same test for 'POST' queries.
</code></pre>
<p>And for testing <code>getContext()</code>, mock out the HTTP with httpretty...</p>
<pre><code>@httpretty.activate
def testGetContextReturnFields(self):
  """
  Tests client.getContext() for a sample term.
  Asserts the returned object contains the corrcet fields and have contents as
  expected.
  """
  # Arrange: mock JSON response from API, mock out the API endpoint we expect
  # to be called.
  mockResponseString = getMockApiData("context_foo.json")
  httpretty.register_uri(httpretty.GET,
                         "http://this.is.the.url/query",
                         body=mockResponseString,
                         content_type="application/json")

  # Act: create the client object we'll be testing.
  c = client.Client()
  contexts = c.getContext("foo")

  # Assert: check the result object.
  self.assertTrue(isinstance(contexts, list),
    "Returned object is not of type list as expected.")
  self.assertTrue(("context_label" and "context_id") in contexts[0], 
    "Data structure returned by getContext() does not contain"
    " the required fields.")
  self.assertTrue(isinstance(contexts[0]["context_label"], str),
    "The \'context_label\' field is not of type string.")
  self.assertEqual(contexts[0]["context_id"], 0,
    "The top context does not have ID of zero.")
</code></pre>
</div>
<span class="comment-copy">What and how you mock depends heavily on the internals of the <code>Client</code> class. After all, you <i>could</i> just mock <code>Client.getContext</code> to return something fixed, but then you are only testing that you configured the mock to match the expected output.</span>
<span class="comment-copy">I'm not sure if I understand correctly: Do you would like test <code>Client</code> by real call to API? You should trust API (you cannot test API again) and just test if your client make the correct calls.</span>
<span class="comment-copy">@Micheled'Amico how can I test my client makes correct queries to the API without actually querying the API?</span>
<span class="comment-copy">It is hard to answer without know what API is. In some cases you can write a your own direct interface (1-1 to the API calls) that you can replace by a fake in test environment or mock http requests if it is a http API. In python is simple enough mock directly the library without create a your own interface: this way is a best practice in C, C++ and Java. Take a look to <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>mock</code> framework</a></span>
