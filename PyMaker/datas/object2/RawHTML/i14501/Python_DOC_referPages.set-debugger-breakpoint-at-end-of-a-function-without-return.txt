<div class="post-text" itemprop="text">
<p>I am debugging method <code>f()</code> that has no <code>return</code> in it. </p>
<pre><code>class A(object):

    def __init__(self):
        self.X = []

    def f(self):            
        for i in range(10):
            self.X.append(i)
</code></pre>
<p>I need to see how this method modifies variable <code>X</code> right after it is called. To do that, I insert a <code>return</code> at the end of the method, and set the breakpoint there:</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/3ReGl.png"/></p>
<p>That way, as soon as the method reaches its <code>return</code>, I can see the value of my variable <code>X</code>. </p>
<hr/>
<p>This does the job, but I am pretty sure there is a better way. Editing a method or function every time I need to debug it seems silly.</p>
<p><strong>Question</strong>:<br/>
Is there a different way (e.g. an option in the debugger) to set a breakpoint at the end of a method that does not have a <code>return</code>?</p>
<p>(Note that setting a breakpoint at the function call and using <kbd>Step Over</kbd> would not display <code>X</code> when mouseovering, since the function is called from a different module.)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can add a conditional breakpoint on the last line and set the condition to be something that occurs only in the last iteration.</p>
<p>In this instance the condition is very easy since it's just <code>i == 9</code>, but it may be a lot more complex depending on your loop condition so sometimes adding a statement at the end will be the easier solution.</p>
<p><img alt="Conditional breakpoint in IntelliJ IDEA" src="https://i.stack.imgur.com/JwJf4.png"/></p>
<p>That screenshot is from IntelliJ IDEA and your screenshot looks like it's from the same IDE, so just right-click the breakpoint to show the dialog and enter your condition.</p>
<p>If you're using some other IDE I'm sure there is capability to make a breakpoint conditional.</p>
<p><strong>Update:</strong></p>
<p>There is no support for breaking at the end of a method in the <a href="https://docs.python.org/3/library/pdb.html" rel="noreferrer">Python debugger</a>, only at the start of a method:</p>
<blockquote>
<p><strong>b(reak) [[filename:]lineno | function[, condition]]</strong></p>
<p>With a lineno argument, set a break there in the current file. With a function argument, set a break at the first executable statement within that function. The line number may be prefixed with a filename and a colon, to specify a breakpoint in another file (probably one that hasn't been loaded yet). The file is searched on sys.path. Note that each breakpoint is assigned a number to which all the other breakpoint commands refer.</p>
<p>If a second argument is present, it is an expression which must evaluate to true before the breakpoint is honored.</p>
<p>Without argument, list all breaks, including for each breakpoint, the number of times that breakpoint has been hit, the current ignore count, and the associated condition if any.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>There is a quick&amp;dirty solution that works on <em>any</em> language that supports monkeypatching (Python, Ruby, ObjC, etc.). I honestly can't remember ever needing it in Python, but I did it quite a bit in both SmallTalk and ObjC, so maybe it'll be useful for you.</p>
<p>Just dynamically wrap <code>A.f</code> in a function, like this:</p>
<pre><code>real_A_f = A.f
def wrap_A_f(self, *args, **kwargs):
    result = real_A_f(self, *args, **kwargs)
    return result
A.f = wrap_A_f
</code></pre>
<p>In most scriptable debuggers, you should be able to write a script that does this automatically for a method by name. In pdb, which lets you execute normal Python code right in the debugger, it's especially simple.</p>
<p>Now you can put a breakpoint on that <code>return result</code>, and it's guaranteed to hit immediately after the real <code>A.f</code> returns (even if it returns in the middle or falls off the end without a <code>return</code> statement).</p>
<p>A few things you may want to add:</p>
<ul>
<li>If you also want to catch <code>A.f</code> raising, put a <code>try:</code> and <code>except: raise</code> around the code, and add a breakpoint on the <code>raise</code>.</li>
<li>For Python 2.x, you may want to wrap that up with types.MethodType to make a real unbound method.</li>
<li>If you only want a breakpoint on a specific <code>A</code> instance, you can either use a conditional breakpoint that checks <code>self is a</code>, or use <code>types.MethodType</code> to create a bound instance and store that as <code>a.f</code>.</li>
<li>You may want to use <code>functools.wraps</code> if you want to hide the wrapper from the rest of the code (and from your debugging, except in the cases where you really want to see it).</li>
<li>Since pdb lets you execute dynamic code right in the live namespace, you can put a <code>wrap_method</code> function somewhere in your project that does this, and then, at the prompt, write <code>p utils.wrap_method(A, 'f')</code>. But if you wrap multiple methods this way, they're going to share the same breakpoints (inside the wrapper function defined inside <code>wrap_method</code>). Here I think a conditional breakpoint is the only reasonable option.</li>
<li>If you want access to the real A.f's locals from the wrapper's breakpoint, that's a lot harder. I can think of some very hacky options (e.g., <code>exec(real_A_f.__code__, real_A_f.globals())</code>, but nothing I'd be happy with.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Your IDE is hiding what's under the hood.
That is, something like</p>
<pre><code>import pdb
</code></pre>
<p>is prepended to your script and</p>
<pre><code>pdb.set_trace()
</code></pre>
<p>is inserted before the line onto which your placed your breakpoint.
From what you say I deduce that PyCharm does not like placing breakpoints on empty lines. However <code>pdb.set_trace()</code> can perfectly be placed at the end of a method.</p>
<p>So you could insert those yourself (or write a macro) and run <code>python -m pdb</code> to start debugging. </p>
<p><strong>(Edit) example</strong></p>
<pre><code>import pdb

class A(object):

    def __init__(self):
        self.X = []

    def f(self):
        for i in range(10):
            self.X.append(i)
        pdb.set_trace()

if __name__ == '__main__':
    a = A()
    a.f()
</code></pre>
<p>Debug with</p>
<pre><code>$ python -m pdb test.py 
&gt; /dev/test.py(1)&lt;module&gt;()
----&gt; 1 import pdb
      2 
      3 class A(object):

ipdb&gt; cont
--Return--
&gt; /dev/test.py(11)f()-&gt;None
-&gt; pdb.set_trace()
(Pdb) self.X
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
(Pdb)
</code></pre>
<p><code>ipdb</code> can be used instead of <code>pdb</code>.                                                                                                                     </p>
</div>
<div class="post-text" itemprop="text">
<p>With <a href="https://docs.python.org/3.2/library/pdb.html" rel="nofollow"><code>pdb</code></a> you can use nice combination of <a href="https://docs.python.org/3.2/library/pdb.html#pdbcommand-break" rel="nofollow"><code>break function</code></a> and <a href="https://docs.python.org/3.2/library/pdb.html#pdbcommand-until" rel="nofollow"><code>until lineno</code></a>:</p>
<blockquote>
<p>Without argument, continue execution until the line with a number
  greater than the current one is reached.</p>
<p>With a line number, continue execution until a line with a number
  greater or equal to that is reached. In both cases, also stop when the
  current frame returns.</p>
<p>Changed in version 3.2: Allow giving an explicit line number.</p>
</blockquote>
<p>You can achieve what you needed.</p>
<p>I modified your example a bit (so you would see that instruction gets executed although pdb reports it as "<em>next instruction</em>"):</p>
<pre class="lang-python prettyprint-override"><code>01: class A(object):
02: 
03:     def __init__(self):
04:         self.X = []
05:         
06:     def f(self):         
07:         print('pre exec')
08:         for i in range(10):
09:             self.X.append(i)
10:         print('post exec')
11:             
12: a = A()
13: a.f()
14: print('Game is over')
15:
</code></pre>
<p>And result from running with <code>python -m pdb test.py</code> goes like this:</p>
<p>Start debugging and run it just after class declaration (so you can add named breakpoint):</p>
<pre class="lang-none prettyprint-override"><code>&gt; d:\tmp\stack\test.py(1)&lt;module&gt;()
-&gt; class A(object):
(Pdb) until 11
&gt; d:\tmp\stack\test.py(12)&lt;module&gt;()
-&gt; a = A()
</code></pre>
<p>Now, break at the beginning of function:</p>
<pre class="lang-none prettyprint-override"><code>(Pdb) break A.f
Breakpoint 1 at d:\tmp\stack\test.py:6
</code></pre>
<p>Just continue with execution until it hits breakpoint:</p>
<pre class="lang-none prettyprint-override"><code>(Pdb) continue
&gt; d:\tmp\stack\test.py(7)f()
-&gt; print('pre exec')
</code></pre>
<p>Take advantage of <em>"also stop when the current frame returns"</em>:</p>
<pre class="lang-none prettyprint-override"><code>(Pdb) until 14
pre exec
post exec
--Return--
</code></pre>
<p>As you can see, both <em>pre exec</em> and <em>post exec</em> were printed, but when executing <code>where</code> you are still in <code>f()</code>:</p>
<pre class="lang-none prettyprint-override"><code>(Pdb) w
  c:\python32\lib\bdb.py(405)run()
-&gt; exec(cmd, globals, locals)
  &lt;string&gt;(1)&lt;module&gt;()
  d:\tmp\stack\test.py(13)&lt;module&gt;()
-&gt; a.f()
&gt; d:\tmp\stack\test.py(10)f()-&gt;None
-&gt; print('post exec')
&gt; d:\tmp\stack\test.py(10)f()-&gt;None
-&gt; print('post exec')
</code></pre>
<p>And all context variables are intact:</p>
<pre class="lang-none prettyprint-override"><code>(Pdb) p self.X
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<hr>
<p>Now with your real life example:</p>
<pre class="lang-python prettyprint-override"><code>01: class A(object):
02:     def __init__(self):
03:         self.X = []
04:         
05:     def f(self):         
06:         for i in range(10):
07:             self.X.append(i)
08:             
09: a = A()
10: a.f()
11: print('Game is over')
</code></pre>
<p>Start the similar fashion as before:</p>
<pre class="lang-none prettyprint-override"><code>&gt; d:\tmp\stack\test.py(1)&lt;module&gt;()
-&gt; class A(object):
(Pdb) until 8
&gt; d:\tmp\stack\test.py(9)&lt;module&gt;()
-&gt; a = A()
(Pdb) break A.f
Breakpoint 1 at d:\tmp\stack\test.py:5
(Pdb) cont
&gt; d:\tmp\stack\test.py(6)f()
-&gt; for i in range(10):
</code></pre>
<p>Now... Breakpoint in <code>f.A</code> actually means breakpoint at first statement of <code>f.A</code> which is unfortunately <code>for i in...</code> so it would break on it every time.</p>
<p>If you don't actually start your real code with loop, you can skip this part.</p>
<pre class="lang-none prettyprint-override"><code>(Pdb) disable 1
Disabled breakpoint 1 at d:\tmp\stack\test.py:5
</code></pre>
<p>Again, use the <code>until &lt;end of file&gt;</code>:</p>
<pre class="lang-none prettyprint-override"><code>(Pdb) until 10
--Return--
&gt; d:\tmp\stack\test.py(6)f()-&gt;None
-&gt; for i in range(10):
</code></pre>
<p>And again, all frame variables are available:</p>
<pre class="lang-none prettyprint-override"><code>(Pdb) p i
9
(Pdb) w
  c:\python32\lib\bdb.py(405)run()
-&gt; exec(cmd, globals, locals)
  &lt;string&gt;(1)&lt;module&gt;()
  d:\tmp\stack\test.py(10)&lt;module&gt;()
-&gt; a.f()
&gt; d:\tmp\stack\test.py(6)f()-&gt;None
-&gt; for i in range(10):
(Pdb)
</code></pre>
<hr/>
<p>The sad thing here is, that I wanted to try this piece of automation:</p>
<pre class="lang-none prettyprint-override"><code>(Pdb) break A.f
Breakpoint 1 at d:\tmp\stack\test.py:5
(Pdb) commands 1
(com) disable 1
(com) until 11
(com) end
</code></pre>
<p>Which would do everything you need automatically (again, <code>disable 1</code> not needed when you have at least one pre-loop statement), but according to documentation on <a href="https://docs.python.org/3.2/library/pdb.html#pdbcommand-commands" rel="nofollow"><code>commands</code></a>:</p>
<blockquote>
<p>Specifying any command resuming execution (currently continue, step, next, return, jump, quit and their abbreviations) terminates the command list (as if that command was immediately followed by end). This is because any time you resume execution (even with a simple next or step), you may encounter another breakpoint–which could have its own command list, leading to ambiguities about which list to execute.</p>
</blockquote>
<p>So <code>until</code> just doesn't seem to work (at least for Python 3.2.5 under windows) and you have to do this by hand.</p>
</hr></div>
<div class="post-text" itemprop="text">
<p>You have a few options here.</p>
<ol>
<li>Add a break point to the last line in the function.</li>
</ol>
<p>In this case, the last line is within a loop, so you would have to iterate over each item in the loop.</p>
<ol start="2">
<li>Add a break point where the function is being called.</li>
</ol>
<p>This will stop the debugger prior to the function being called, but you can "Step Over" the function to see the value of <code>A.x</code> after <code>A.f()</code> is called.</p>
<ol start="3">
<li>Add a temporary statement the end of the function to break at</li>
</ol>
<p>This trick would work if your function ends in a loop and there are multiple places the function is called or you don't want to track down the function call.</p>
<p>You can add a simple statement to the end of the function for debugging purposes and add a break point there.</p>
<pre><code>def f(self):            
    for i in range(10):
        self.X.append(i)
    debug_break = 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not just leave the return in there? Or a <code>return None</code>. It's implicit anyway, the interpreter/compiler will do the same thing regardless:</p>
<blockquote>
<p>In fact, even functions without a return statement do return a value, albeit a rather boring one. This value is called None (it’s a built-in name).</p>
</blockquote>
<p><a href="https://docs.python.org/2/tutorial/controlflow.html#defining-functions" rel="nofollow">[source: Python Tutorial 4.6]</a>.</p>
</div>
<span class="comment-copy">This probably isn't the best answer, so I'll just post it as a comment, but there's a quick&amp;dirty method that works in any language with monkeypatching (Python, Ruby, ObjC, Smalltalk, etc.): you can dynamically wrap <code>A.f</code> in a function that just does <code>return real_A_dot_f(*args, **kw)</code>, then put the breakpoint on that line. I've used gdb/lldb/pdb/etc. scripts to do that wrapping for me in the past.</span>
<span class="comment-copy">@abarnert I think your comment is more suited as a full answer. There might be better solutions (i don't know) but if your suggestion works, it's still a solution.</span>
<span class="comment-copy">I'm not sure, because I don't think it serves the purpose of breaking while the <code>A.f</code> frame's locals are still alive to inspect... But I wrote it anyway; if it's not useful for the OP, he can always ignore it, or even downvote it. :)</span>
<span class="comment-copy">Perhaps no support in PyCharm, but you definitely <b>can</b> break at the end of a method with pdb (or ipdb).</span>
<span class="comment-copy">Then please explain how to do that, because the docs for pdb (which i cited above) doesn't tell of any way of doing that.</span>
<span class="comment-copy">Sure. This is in my (separate) answer. Please comment on that one if it is still unclear.</span>
<span class="comment-copy">Your break condition works in PyCharm 4 (not sure about 3).  You can even set the condition to a evaluated statement, for example <code>i == item_list[-1]</code></span>
<span class="comment-copy">A small improvement is needed. You need to place the breakpoint in <code>for</code>, otherwise you get self.X before it gets updated with last value (unless you additionally press Step Over).</span>
<span class="comment-copy">Having some health issues, I was left with minutes before the bounty expires. Since this was the only answer saying that it can be done, i assigned the bounty here. I have not tested it yet though. If it works, i will accept this as an answer as well.</span>
<span class="comment-copy">How can I make a macro that will insert <code>pdb.set_trace() </code> at the end of a function I am testing? Would it be faster than writing <code>return</code> at the end of the function? An example would be useful for future readers.</span>
<span class="comment-copy">For example, the <a href="https://atom.io/packages/atom-python-debugger" rel="nofollow noreferrer">atom-python-debugger</a> for Github's editor <a href="https://atom.io/" rel="nofollow noreferrer">atom</a> has it implemented for you by pressing &lt;F7&gt;</span>
<span class="comment-copy">I do not know if or how it could be done in PyCharm.</span>
<span class="comment-copy">But found this link about <a href="https://www.jetbrains.com/pycharm/help/using-macros-in-the-editor.html" rel="nofollow noreferrer">PyCharm macros in the editor</a></span>
<span class="comment-copy">1. doesn't work since the function has a <code>for</code> loop. 2. Doesn't work because the function is called from a different module, so when i mouseover <code>X</code> after i "step over", the value of <code>X</code> can't be displayed. 3. is what i am currently doing.</span>
<span class="comment-copy">I have many functions like those. As mentioned in my question, editing them with <code>return</code> whenever I debug them is something i want to avoid, if there is a better (faster) way to achieve my goal.</span>
<span class="comment-copy">I'm saying leave the return statements there in production, they don't cost anything.</span>
