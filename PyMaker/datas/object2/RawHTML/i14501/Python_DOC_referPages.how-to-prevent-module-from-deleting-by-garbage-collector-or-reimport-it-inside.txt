<div class="post-text" itemprop="text">
<p>I wrote a wrapper class for logging module which has __del__method to delete log file at the end of the programm.</p>
<p>My programm copy this log files into archive from other class and it is important to have no log files in working folder before next programm execution. But I can't delete it from other module, because they are still hanlded with logger.</p>
<p>So I used __del__ method for this.</p>
<pre><code>def __del__(self):
    if self.config_object.logfile is not None:
        import os
        try:
            os.unlink(self.config_object.logfile)
        except (WindowsError, AttributeError):
            pass
</code></pre>
<p>I reimport os because sometimes in has been destroed by garbage collector before my Logging class. And this work fine in python3.2</p>
<p>But after switching to python3.4 I saw errors like this:</p>
<pre><code>  File "&lt;frozen importlib._bootstrap&gt;", line 2236, in _find_and_load
  File "&lt;frozen importlib._bootstrap&gt;", line 263, in __enter__
  File "&lt;frozen importlib._bootstrap&gt;", line 287, in _get_module_lock
  File "&lt;frozen importlib._bootstrap&gt;", line 173, in __init__
TypeError: 'NoneType' object is not callable
</code></pre>
<p>I tried to prevent os deleting instead of reimporting os but failed.</p>
<p>I tried this ideas:
Creating cycle referencing with os inside. Adding field with os module inside my class. Calling gc.disabled() direclty.
But none of them helped.</p>
<p>So I has two questions.
First is how can one reimport os in python 3.4 with its new importlib while python programm is destroying by garbage collector.
And second is how one can prevent the garbage collector from deleting os module.</p>
<p>P.S. I know that use context manager is better then __del__ and read questions about this iat SO. And of course I can change my program logic to avoid necessity of deleting log files.
So this problem with log is just an example that awakened my curiosity. And if somebody can proof that both my goals is impossible it's ok and the best answer. But if an ugly and unpythonic solution exists I want to know about it even it is changing bytecode direclty someway or something like this.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can bind a reference to the <code>os.unlink()</code> function as default argument, so you still have access to just the function when the hook runs:</p>
<pre><code>def __del__(self, _os_unlink=os.unlink):
    if self.config_object.logfile is not None:
        import os
        try:
            _os_unlink(self.config_object.logfile)
        except (WindowsError, AttributeError):
            pass
</code></pre>
<p>However, take into account that there is never a guarantee that the hook is executed on Python shutdown.</p>
<p>Also, if you need to call other functions that happen to be implemented in pure python then you'll need to take into account that <em>those functions too</em> could be using dependencies that have been set to <code>None</code> at this time. You may have to either re-implement those functions with 'captured' references, or you'd have to restore the dependencies just for your call. For example, <code>os.path.exists()</code> requires <code>os.stat()</code> to still be available. Either re-implement the <a href="https://github.com/python/cpython/blob/v3.7.0/Lib/genericpath.py#L14-L22" rel="nofollow noreferrer"><code>genericpath.exists()</code> function</a> with <code>os.stat</code> captured, or <em>at least</em> ensure that <code>os.stat</code> exists before calling the captured <code>os.path.exists()</code> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>In your case it would be better to simply use a temporary file created using the <a href="https://docs.python.org/3/library/tempfile.html" rel="nofollow"><code>tempfile</code></a> module rather than trying to manage your own temporary file.</p>
<p>In the more abstract sense you make use of the fact that python guarantees a module's private globals (with a leading underscore) are deleted before its public globals. eg.</p>
<pre><code>from os import unlink

class TempFileManager:
    def __init__(self):
        self.temp_files = []
    def __del__(self):
        for file_ in self.temp_files:
            # unlink still available as _temp_file_manager is deleted first
            unlink(file_)

_temp_file_manager = TempFileManager()
</code></pre>
<p>You may also wish to take a look at the <a href="https://docs.python.org/3/library/atexit.html" rel="nofollow"><code>atexit</code></a> module rather than relying on <code>__del__</code> semantics. eg.</p>
<pre><code>import os
import atexit

file_ = ...

atexit.register(os.unlink, file_)
</code></pre>
</div>
<span class="comment-copy">Thank you! This is exactly what I want! But I still can't unserstand why this works (also I tried to save os.ulink in object field and it works too), but using os itself as function argument __del__(self, _os=os) doesn't and I get TypeError: 'NoneType' object is not callable.</span>
<span class="comment-copy">@Aprectu: the garbage collector sets all names in the module to <code>None</code> to clear references.</span>
<span class="comment-copy">This solution does not work with <code>os.path.exists</code>:      File "/usr/lib/python3.4/genericpath.py", line 19, in exists     TypeError: 'NoneType' object is not callable</span>
<span class="comment-copy">Instead I used <code>_os_stat=os.stat</code> in the <code>__del__</code> method and used it in a try/except OSError. It worked like a charm.</span>
<span class="comment-copy">@Frodon: Yes, any transient dependencies of the function you call could have the same problem, and you'd have to reimplement their functionality, as you did for <code>os.path.exists()</code>.</span>
