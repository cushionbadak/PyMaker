<div class="post-text" itemprop="text">
<p>Hey I wonder if you can help me, I did some research on using eval() to read the lines of my CSV and then put it into a dictionary. The problem is that my CSV has 4 pieces of data: the name, the first score, the second score and the third score. How would I transfer this data from a CSV into a dictionary within python so then later on I can check if that users name is the dictionary to append to it or edit the score. </p>
<p>I would like to have it so the key the name, and the scores  are the list and are kept in a list so they can be appended to/deleted later.</p>
<p>Thanks for your help.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a module in the Python standard library that will help you with reading/writing <a href="https://docs.python.org/2/library/csv.html" rel="nofollow">CSV files</a>. Let me assume that your csv file looks like this:</p>
<pre><code>Jim, 45, 78, 90
Mary, 100,98, 99
Molly, 78, 45,46
Mat, 76, 89, 95
</code></pre>
<p>Then:</p>
<pre><code>import csv                                                                                                                                   
scores = {}                                                                                                                                         
with open('score.csv') as f:                                                                                                                 
    reader = csv.reader(f)                                                                                                                   
    for row in reader:                                                                                                                                                                                                                                                    
       scores.setdefault(row[0],[]).extend(row[1:])  
</code></pre>
<p>This will create a dictionary <code>scores</code> with names as keys  and a list of scores as values:</p>
<pre><code>{'Mat': [' 76', ' 89', ' 95'], 'Jim': [' 45', ' 78', ' 90'], 'Molly': [' 78', ' 45', '46'], 'Mary': [' 100', '98', ' 99']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import csv
from collections import defaultdict

# Your target is a dictionary {name : [scores]}
scores = defaultdict(list)
with open(csvfilename) as csvfile:
    for row in csv.reader(csvfile):
        scores[row[0]].extend(row[1:])
</code></pre>
<p>I don't think <code>eval</code> is a good tool for this. It is really easy to introduce  security vulnerabilities with it, as it will parse and execute whatever you pass it. As an exercise, think about why it may not be okay to execute  data from some csv-file. Spoiler: your csv-file is a serialization format, this talk <a href="https://youtu.be/kjZHjvrAS74" rel="nofollow">Tom Eastman - Serialization formats are not toys - PyCon 2015</a> shows dangers that may exist there. For bonus insights look at the source of the collections module we imported the defaultdict from and think about why <a href="https://github.com/python/cpython/blame/774918b528c49baed5cb3c1b87bdffcfab561a6a/Lib/collections/__init__.py#L404" rel="nofollow">this use of <code>exec</code></a> by @raymond-hettinger is different from using <code>eval</code> on data.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>eval()</code> is not what you want here I don't think. <code>eval()</code> reads a string and interprets it as python code; what you want is simple file I/O manipulation.</p>
<pre><code>data = numpy.genfromtxt("filename.csv", delimter=";")  # non-numpy possibilities available
my_dict = {}
for i in data:
    my_dict[data[i,0]] = data[i,1:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you really, really want to do it with <code>eval</code>: Well, first, you shouldn't, unless you have a very good reason. Just parse the file as CSV, not as Python code. The right way to do that is with the <code>csv</code> module, as in <a href="https://stackoverflow.com/a/30000814/908494">Chris Wesseling's answer</a> (or, if you're already using NumPy or Pandas, using their functions).</p>
<p>But if you really, really, really want to, can you?</p>
<p>Well, sometimes.</p>
<p>The most basic CSV dialect doesn't quote strings, so its lines aren't going to be valid as Python code. And some CSV dialects handle embedded quotes in ways that either aren't valid in Python, or mean something different.</p>
<p>But some dialects do happen to make at least most rows legal, and meaningful, as Python <code>tuple</code> literals consisting of Python <code>str</code>, <code>int</code>, and <code>float</code> literals. And for those dialects, technically, yes, you could parse them with <code>eval</code>, like this:</p>
<pre><code>scores = {}
with open(path) as f:
    for line in f:
        name, *newscores = eval(line)
        scores.setdefault(name, []).extend(newscores)
</code></pre>
<p>But again, you shouldn't.</p>
<p>And even if you really, really, really want to do this, you should at least use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>literal_eval</code></a> instead; it will handle all the same legal values that <code>eval</code> would without opening the big gaping security holes (e.g., someone putting <code>__import__('os').system('rm -rf /')</code> in a CSV) and painful-to-debug edge cases.</p>
<p>But even with <code>literal_eval</code>, you don't want it. You want to parse the actual CSV dialect you have, not just treat it as a similar but different language and cross your fingers.</p>
</div>
<span class="comment-copy">need sample input and output? are you try for coding?</span>
<span class="comment-copy">A input would be the name, and the output would be a name with a score writing to a CSV file from a dictionary, appending to the score if name is already in the CSV. There is a quiz in my code where the score comes from.</span>
<span class="comment-copy">Using <code>eval</code> is almost always a bad idea. Especially for parsing a CSV file. What makes you think it's what you want to use?</span>
<span class="comment-copy">You're using <code>setdefault</code> wrong. This will either set <code>scores[row[0]]</code> to <code>row[1:]</code> and then set it to <code>row[1:]</code> again, or set <code>scores[row[0]]</code> back to its already-existing value while ignoring <code>row[1:]</code>. I don't know why you'd want that, but if you do, you can leave off the assignment and just call <code>setdefault</code>. But more likely, what you wanted was something like <code>scores.setdefault(row[0], []).extend(row[1:])</code>.</span>
<span class="comment-copy">+1 Your solution silently handles lines in the csv-file that have an out of spec number of scores. It caters the possibility of adding/removing scores that the OP expressed.</span>
<span class="comment-copy">Anyway, I'm out of +1 votes for the day, so apparently it's bed time. Hopefully I remember to give you one tomorrow. :)</span>
<span class="comment-copy">Hey @VidhyaG thanks for this piece of code. I implemented it into my code and it'll work work just reading the CSV file. How would I also allow the file to be appended. I want to try and implement it into this code. if os.path.exists("outputfile.csv"):     filehandle = open("outputfile.csv", "a+") else: filehandle = open('outputfile.csv', "w+")</span>
<span class="comment-copy">@abarnet Thank you. I started off with scores.setdefault(row[0], []) as you figured, but then put in the unnecessary assignment which led me to .... Thanks again.</span>
<span class="comment-copy">Thanks for your contribution, it looks quite neat as a piece of code.</span>
<span class="comment-copy">:-) While you were writing this answer I was expanding mine with some bonus material on the eval.</span>
<span class="comment-copy">@ChrisWesseling: I was writing this hoping that your answer, and maybe the other <code>csv</code> one and the NumPy one, would get enough votes that mine wasn't anywhere near the top of the page. If that doesn't happen, I think I may need more "really"s in there just to be safeâ€¦</span>
<span class="comment-copy">I think we'll need uncountable many "really"s to protect peoples feet. ;-)</span>
