<div class="post-text" itemprop="text">
<p>So, if we create some class, implementing <code>collections.abc.MutableSequence</code>, and <code>list</code> is such an example,</p>
<pre><code>class Woof(collections.MutableSequence):
    def __init__(self, data=[]):
        self.s = list(data)
    def __setitem__(self, k, v):
        self.s[k] = v
    def __getitem__(self,k):
        return self.s[k]
    def __delitem__(self,k):
        del self.s[k]
    def __repr__(self):
        return repr(self.s)
    def __len__(self):
        return len(self.s)
    def insert(self,k,v):
        self.s[k] = v
</code></pre>
<p>we cannot pass its instance to default JSONEncoder.</p>
<pre><code>&gt;&gt;&gt; w = Woof(range(5,10))
&gt;&gt;&gt; json.dumps(w)
TypeError: [5, 6, 7, 8, 9] is not JSON serializable
</code></pre>
<p>Question is not <strong>how</strong> to serialize custom classes, but <strong>why</strong> python can serialize only its own implementations of <code>Sequence</code> and <code>Mapping</code>, but not arbitrary ones, implementing exactly same interface.</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I know, Bob Ippolito (the primary author of <a href="http://simplejson.readthedocs.org/" rel="nofollow"><code>simplejson</code></a>, who also did the changes to stdlibify it as <a href="http://docs.python.org/library/json" rel="nofollow"><code>json</code></a> in the stdlib, and does most of the maintenance on the stdlib version) has never given his rationale for this, so if you really wanted to know for sure, the only thing you could do is to ask him.</p>
<p>But I think there's an obvious answer: If you encoded all <code>Sequence</code> types to JSON arrays, there'd be no way to distinguish the difference <code>Sequence</code> types at decode time. And, since your code is presumably using something other than <code>list</code> for some reason, and some reason that the <code>json</code> module can't predict, it may be throwing away important information.</p>
<p>That said, wanting to treat other sequence types—or even arbitrary iterables—the same as <code>list</code> is a common-enough use case that it was made easy to do if you want it, and it's <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder.default" rel="nofollow">the example the docs use for <code>JSONEncode.default</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, the standard library's <a href="https://docs.python.org/2/library/json.html" rel="nofollow">json</a> module knows how to encode Lists and Tuples into JSON because that support is explicitly built-in to the module: the <a href="https://github.com/python/cpython/blob/master/Lib/json/encoder.py#L426" rel="nofollow">relevant code is here</a>.</p>
<p>You'll notice that code knows nothing about collections.MutableSequence, or your custom subclass thereof; that's why your <code>json.dumps(w)</code> call fails with TypeError. There are <a href="https://github.com/python/cpython/blob/master/Lib/json/encoder.py#L161" rel="nofollow">some instructions</a> in JSONEncoder.default() for how you might subclass that function to support serializing your class.   </p>
</div>
