<div class="post-text" itemprop="text">
<p>Is there a way I could calculate the number of routes in a list of lists? The rule is to pick an element in each sub-list to form a list, and the value in the new list is ascending. (The length of the list or sub-list is not fixed)</p>
<p>e.q.
a list is </p>
<pre><code>[[1, 10], [5, 16], [3, 20]]
</code></pre>
<p>There are three ways to fulfill the requirement:</p>
<pre><code>[1, 5, 20]
[1, 16, 20]
[10, 16, 20]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use some sort of recursion based on the starting element. For efficiency, add <a href="http://en.wikipedia.org/wiki/Memoization" rel="nofollow">memoization</a>, which <a href="http://www.python-course.eu/python3_memoization.php" rel="nofollow">can be done in Python quite easily</a> (see esp. <a href="https://docs.python.org/3/library/functools.html" rel="nofollow"><code>functools.lru_cache</code></a> as pointed out by @abarnert in the comments below).</p>
<p>Say you have a function like so:</p>
<pre><code>def num_routes_starting_with(list_of_lists, starting_elem)
</code></pre>
<p>where <code>starting_elem</code> is the starting element of the route. That is, each element in the route taken from <code>list_of_lists[0]</code> must be at least larger than <code>starting_elem</code>.</p>
<p>Then there are two points:</p>
<ol>
<li><p>It's not so hard to code <code>num_routes_starting_with</code> recursively. Because for any element in <code>list_of_lists[0]</code> which you use (which is simple to find - just check if it is not smaller than <code>starting_elem</code>), you just need to call <code>routes_starting_with</code> with <code>list_of_lists[1: ]</code> and <code>starting_elem</code> replaced by the element you just used. You need to return the sum of the return values.</p></li>
<li><p>Once you have <code>num_routes_starting_with</code>, it's easy to wrap it in some toplevel <code>routes</code> - simply:</p></li>
</ol>
<p>a. If  <code>list_of_lists</code> is empty, the answer is 0).</p>
<p>b. If it is not, choose the smallest element in <code>list_of_lists[0]</code>, subtract from it 1, and call <code>numroutes_starting_with</code> with <code>list_of_lists</code> and the subtraction result.</p>
<hr/>
<p>Here's how it looks altogether:</p>
<pre><code>def num_routes(list_of_lists):
    if len(list_of_lists) == 0:
        return 0

    return num_routes_starting_with(list_of_lists, min(list_of_lists[0]) - 1)

# You should add here some memoization decorator, something like:
# @memoized
def num_routes_starting_with(list_of_lists, starting_elem):
    if not list_of_lists:
        return 1

    s = 0
    for e in list_of_lists[0]:
        if e &gt; starting_elem:
            s += num_routes_starting_with(list_of_lists[1: ], e)
    return s

list_of_lists = [[1, 10], [5, 16], [3, 20]]
print num_routes(list_of_lists)
</code></pre>
</div>
<span class="comment-copy">An interesting problem.  Do you need the routes themselves or just the count?  What have you tried so far?</span>
<span class="comment-copy">@wim I just need the result, what I currently have is not good, I found all the possibilities then validate if it is ascending.</span>
<span class="comment-copy">google "dynamic programming".  I think this is a nice use-case.</span>
<span class="comment-copy">@wim Thanks for your advice, I will use this case to strengthen my knowledge of dp.</span>
<span class="comment-copy">Good explanation!</span>
<span class="comment-copy">Thanks! it's helpful to see such feedback.</span>
<span class="comment-copy">Thanks a lot! This is what I was trying to figure out.</span>
<span class="comment-copy">You should be able to just use <code>functools.lru_cache(maxsize=None)</code> for your memoization here.</span>
<span class="comment-copy">Nice point. Will add.</span>
