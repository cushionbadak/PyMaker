<div class="post-text" itemprop="text">
<p>Flask by default will log things like GET and POST requests directly with an INFO tag. When implementing a custom logger, these are posted to the same logger and clutter my INFO layer. Is there a way to downgrade them to another layer like DEBUG?</p>
<p>This is the logger I use:</p>
<pre><code># create logger
FORMAT = '%(asctime)s - %(module)s - %(levelname)s - Thread_name: %(threadName)s - %(message)s'
logging.basicConfig(
    format=FORMAT, datefmt='%m/%d/%Y %I:%M:%S %p',
    filename='wizard/logs/example.log', level=logging.DEBUG)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure about a way to downgrade log level of requests (as it usually is stated explicitly in the code like logging.info("...")) but the following may help you to reduce the verbosity of Flask itself.</p>
<p>Python allows you to have multiple loggers, each with its own log level.
You can modify any existing logger if you know the module name it is in or the name it was registered with as described <a href="https://docs.python.org/2/library/logging.html#logger-objects" rel="noreferrer">here</a>.</p>
<p>For example:</p>
<pre><code>import logging
logger = logging.getLogger("mypackage.mymodule")  # or __name__ for current module
logger.setLevel(logging.ERROR)
</code></pre>
<p>The above can be done for any python module. Flask provides a logger per app. You can get a reference to it like this:</p>
<pre><code>import logging
from flask import Flask
app = Flask(__name__)  # or instead of __name__ provide the name of the module
app.logger.setLevel(logging.ERROR)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In fact, there is a way to downgrade a log record from INFO to DEBUG (even if it was already emitted using a call such as <code>info()</code>). This can be achieved using a filter attached to a logger. According to the <a href="https://docs.python.org/3/library/logging.html#logging.Filter.filter" rel="noreferrer">docs</a> a filter checks:</p>
<blockquote>
<p>Is the specified record to be logged? Returns zero for no, nonzero for
  yes. <strong>If deemed appropriate, the record may be modified in-place</strong> by
  this method.</p>
</blockquote>
<p>So a filter may change the level of a log record (<em>levelno</em> and <em>levelname</em> attributes). Later on, a handler may then allow or drop this record based on the new level.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just in case anyone visits this place,</p>
<p>I'm facing the same issue as well. It seems that print calls have the tendency to 'not run'. But if you use the logger instead of print you will find that codes are actually still running.</p>
<p>Not quite sure what the reason is, but when other sections of my code starts running suddenly all the old prints will appear.</p>
<p>tldr; don't use print, use logger</p>
</div>
<span class="comment-copy">Right the thing is that by setting the level in the app to ERROR, although it removes the INFO logs from Flask, it doesn't allow for me to have DEBUG level logs without seeing the INFO, right? I would have to turn all my DEBUG logs to ERROR, at least, to get it working. Even if I use the getLogger function, it still seems like Flask logs the INFO logs to my logger...</span>
<span class="comment-copy">Did you create a custom logger as describe by @foobarto? And that is reporting both your custom logs and flask logs?</span>
<span class="comment-copy">did not, just did, works well now :)</span>
<span class="comment-copy">This is the right answer, not a clumsy work-around like the other.</span>
