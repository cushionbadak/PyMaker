<div class="post-text" itemprop="text">
<p>I have an enum in Python (backported <code>enum</code> package to 2.7) that is meant to be of only integers:</p>
<pre class="lang-python prettyprint-override"><code>import enum
class MyEnum(enum.Enum):
  val = 0
</code></pre>
<p>Let's say I receive a <code>PyObject *</code> in a C extension pointing to <code>MyEnum.val</code>. I want the integer value associated with the <code>PyObject *</code>. How do I get it most succinctly?</p>
</div>
<div class="post-text" itemprop="text">
<p>Looking at the source to the <a href="https://pypi.python.org/pypi/enum34" rel="nofollow"><code>enum34</code></a> backport, just like the <a href="https://hg.python.org/cpython/file/3.4/Lib/enum.py" rel="nofollow"><code>enum</code></a> module in 3.4+, it's pure Python, and does nothing to expose a custom C API.</p>
<p>So, you just use <a href="https://docs.python.org/2.7/c-api/object.html#c.PyObject_GetAttr" rel="nofollow"><code>PyObject_GetAttr</code></a> and friends to access class attributes. In particular, if you have a <code>MyEnum.val</code>, you need to get its <code>value</code> attribute, which will be an <code>int</code>, which you can then <code>PyInt_AsLong</code>.</p>
<p>This is the same way things work in Python. If you try to use <code>MyEnum.val</code> where an <code>int</code> is expected, you should get a <code>TypeError</code>; if you try to explicitly call <code>int(MyEnum.val)</code>, you will <em>definitely</em> get a <code>TypeError</code>. So, although I haven't tested it, <code>PyInt_AsLong</code> directly on the constant instead of its <code>value</code> should raise a <code>TypeError</code> and return -1.</p>
<p>If you want enumeration constants that act like subtypes of <code>int</code>, then, as the <a href="https://docs.python.org/3/library/enum.html#module-contents" rel="nofollow"><code>enum</code></a> docs explain, you want <a href="https://docs.python.org/3/library/enum.html#intenum" rel="nofollow"><code>IntEnum</code></a>. Usually, that isn't really what you want (as the docs explain), but if it is, of course it works. And you should be able to <code>PyInt_Check</code> and <code>PyInt_AsLong</code> an <code>IntEnum</code> value (although, again, I haven't tested).</p>
</div>
<span class="comment-copy">As far as I know, the <code>enum34</code> package doesn't provide any special C representation or API, so you just have to call <code>PyObject_GetAttr</code> and friends, as with any other pure-Python type.</span>
<span class="comment-copy">Does it provide anything that'd let me unify code-paths for handling them alongside objects <code>x</code> for which <code>PyInt_Check(x) != 0</code>? e.g. support for built-in protocols, something like <code>PyNumber_Int(x)</code> (if that actually worked).</span>
<span class="comment-copy"><code>Enum</code> values are explicitly designed <i>not</i> to act like they're a subtype of <code>int</code>. <code>IntEnum</code> values are another story. You should be able to <code>PyInt_Check</code> those and <code>PyInt_AsLong</code> them. But for <code>Enum</code>, you shouldn't be able to, so you (at least should) need to get the <code>value</code> attr if you want to use them as ints, just as you do from Python.</span>
<span class="comment-copy">Using <code>enum.IntEnum</code> on the Python-side instead of <code>enum.Enum</code> does seem to be the most convenient path to take then. Thanks.</span>
<span class="comment-copy">Well, it's convenient if it's what you actually want. Two different <code>IntEnum</code> types' constants will compare equal to each other—e.g., <code>Colors.red == Days.sunday</code> will be true. The <a href="https://docs.python.org/3/library/enum.html#intenum" rel="nofollow noreferrer"><code>IntEnum</code></a> docs explain why usually, that's <i>not</i> what you want… but of course sometimes it is, which is why they included it in the module.</span>
