<div class="post-text" itemprop="text">
<p>I'm developing an application with some threads, each one running an infinite loop with a time sleep. What I want is to finish all threads once the main one has finished, here an example:</p>
<pre><code>def main():

    display_res_stop = threading.Condition()
    display_result_t = threading.Thread(target=sample_t, args=(display_res_stop, ))
    display_result_t.start()

    time.sleep(4)

    display_res_stop.acquire()
    display_res_stop.notify()
    display_res_stop.release()


def sample_t(stop_cond):
    stop_cond.acquire()

    while True:
        print 5
        c = stop_cond.wait(10)

    stop_cond.release()

if __name__ == '__main__':
    main()
</code></pre>
<p>The problem with this solution is that I don't know if condition.wait has finished because the timeout or because has been notified. In the second case while loop should finish.</p>
<p>At first I was doing a time.sleep(t) and using threading events but then the application has to wait until t on all threads has passed.</p>
<p>I'm thinking about a mixed solution using threading.Condition and Event but I don't know if it's the nicest thing to do (Condition for the 'sleep' and Event to replace while True).</p>
</div>
<div class="post-text" itemprop="text">
<p>After all it was very simple, I was just focusing on the wrong thing: I just needed a sleep that could be stopped with an event and thats what Event.wait(t) does. The problem then, can be solved just with Events.</p>
<pre><code>import threading
import time

def sample_thread(stop_ev):
    while not stop_ev.is_set():
        print 'Thread iteration'
        stop_ev.wait(0.1)

def main():
    stop_ev = threading.Event()
    sample_t = threading.Thread(target=sample_thread, args=(stop_ev, ))
    sample_t.start()

    # Other stuff here, sleep is just dummy
    time.sleep(14)

    stop_ev.set()

    print 'End reached.'

if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easy way to do this is to use Python 3.2 or later, or get the backport of the current <code>threading</code> to 3.1/2.7/etc. from PyPI, or just copy the code for that method from, say, <a href="https://hg.python.org/cpython/file/3.4/Lib/threading.py#l258" rel="nofollow">3.4's source</a>.</p>
<p>As the docs for <a href="https://docs.python.org/3/library/threading.html#threading.Condition.wait" rel="nofollow"><code>Condition.wait</code></a> explain:</p>
<blockquote>
<p>The return value is <code>True</code> unless a given timeout expired, in which case it is <code>False</code>.</p>
<p><em>Changed in version 3.2</em>: Previously, the method always returned <code>None</code>.</p>
</blockquote>
<hr/>
<p>As a side note, I'm not sure you need a <code>Condition</code> here at all; you're not checking a flag inside the loop, or doing anything else that should be susceptible to a race condition, you're just waiting to be notified. That implies that, as long as you don't need magic auto-reset, an <code>Event</code> should be just fine. And <code>Event.wait</code> has had the <code>True</code>/<code>False</code> return since 2.7/3.1+, rather than 3.2+.</p>
</div>
<span class="comment-copy">Usually you should be checking some condition inside the <code>while</code> loop; if you're just waiting to be notified, and have no flag to test or any other races to avoid, an <code>Event</code> does that just as well.</span>
<span class="comment-copy">The correct use is explained <a href="https://docs.python.org/2/library/threading.html#condition-objects" rel="nofollow noreferrer">here</a>. The whole point is to provide an atomic "unlock and wait" operation.</span>
<span class="comment-copy">I just did a quick search and it looks like either the <code>threading32</code> backport has been withdrawn, or that wasn't the name and I'm just misremembering, so… that option may not be available. But since you already accepted this answer, I'm guessing you found something that works? If not, another alternative to consider is to use one of the alternative threading modules, like <code>threading2</code>, which have provided an equivalent feature for years (but which may not be quite as portable as the stdlib).</span>
<span class="comment-copy">Yes, maybe I accepted your answer too quick, it's true that there is no backport. Finally I solved it by mixing condition and an event, and I think it's the only solution to solve this problem with python2 and threading.</span>
<span class="comment-copy">@JairoVadillo The fact that there's no <code>threading32</code> backport doesn't really matter, except for meaning a bit more work for you. The right solution is still the same, you just have to use <code>threading2</code>, or copy the 3.4 <code>Condition.wait</code> source into your own code, etc.</span>
<span class="comment-copy">I've finally accepted your answer, I was focused on using Conditions but like you said in the last paragraph it's not necessary in this case. Thanks a lot!</span>
<span class="comment-copy">@JairoVadillo: Before accepting your edit… the whole point of your question was being able to distinguish between timeout and signaling. But your new code still ignores the result of the <code>Event.wait</code> call.</span>
