<div class="post-text" itemprop="text">
<p>I am running ubuntu 12.04 and running programs through the terminal.  I have a file that compiles and runs without any issues when I am in the current directory. Example below,</p>
<pre><code>    david@block-ubuntu:~/Documents/BudgetAutomation/BillList$ pwd
    /home/david/Documents/BudgetAutomation/BillList
    david@block-ubuntu:~/Documents/BudgetAutomation/BillList$ python3.4 bill.py
    ./otherlisted.txt
    ./monthlisted.txt
    david@block-ubuntu:~/Documents/BudgetAutomation/BillList$
</code></pre>
<p>Now when I go back one directory and try running the same piece of code, I get an error message, <code>ValueError: need more than 1 value to unpack</code>. Below is what happens when I run the sample code one folder back and then the sample code below that.</p>
<pre><code>    david@block-ubuntu:~/Documents/BudgetAutomation$ python3.4 /home/david/Documents/BudgetAutomation/BillList/bill.py 
    Traceback (most recent call last):
    File "/home/david/Documents/BudgetAutomation/BillList/bill.py", line 22, in &lt;module&gt;
        bill_no, bill_name, trash = line.split('|', 2)
    ValueError: need more than 1 value to unpack
</code></pre>
<p>The code, <code>bill.py</code>, below.  This program reads two text files from the folder that it is located in and parses the lines into variables. </p>
<pre><code>#!/usr/bin/env python
import glob

# gather all txt files in directory
arr = glob.glob('./*.txt')
arrlen = int(len(arr))

# create array to store list of bill numbers and names
list_num = []
list_name = []

# for loop that parses lines into appropriate variables
for i in range(arrlen):
    with open(arr[i]) as input:
        w = 0 ## iterative variable for arrays
        for line in input:
            list_num.append(1) ## initialize arrays
            list_name.append(1)

            # split line into variables.. trash is rest of line that has no use
            bill_no, bill_name, trash = line.split('|', 2)

            # stores values in array
            list_num[w] = bill_no
            list_name[w] = bill_name

            w += 1
</code></pre>
<p>What is going on here?  Am I not running the compile and run command in the terminal correctly?  Another note to know is that I eventually call this code from another file and it will not run the for loop, I am assuming since it doesn't run unless its called from its own folder/directory?</p>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/a/30114648/908494">eomer explains</a>, the problem is that <code>'./*.txt'</code> is a relative path—relative to the current working directory. If you're not running from the directory that all those <code>*.txt</code> files are in, you won't find anything.</p>
<p>If the <code>*.txt</code> files are supposed to be <em>in the same directory as the script</em>, use <em>the same directory as the script</em>, not <em>the current working directory</em>.</p>
<p>The standard way of doing that is to put code like this at the top of your script:</p>
<pre><code>import os
import sys

scriptdir = os.path.abspath(os.path.dirname(sys.argv[0]))
</code></pre>
<ul>
<li><p><a href="https://docs.python.org/3/library/sys.html#sys.argv" rel="nofollow noreferrer"><code>argv[0]</code></a> gets the path to the script itself. So, if you ran the script as <code>python BillList/bill.py</code>, this will be <code>'BillList/bill.py'</code>.<sup>*</sup></p></li>
<li><p><a href="https://docs.python.org/3/library/os.path.html#os.path.dirname" rel="nofollow noreferrer"><code>dirname</code></a> just takes a path to a file, and gives you the path to the directory the file was in.  So, in this case, <code>BillList</code>.</p></li>
<li><p><a href="https://docs.python.org/3/library/os.path.html#os.path.abspath" rel="nofollow noreferrer"><code>abspath</code></a> normalizes and absolutizes the path.<sup>**</sup> So, you'll get <code>/home/david/Documents/BudgetAutomation/BillList/</code>. And that's the directory the <code>*.txt</code> files are in.</p></li>
</ul>
<p>Then, instead of this:</p>
<pre><code>glob.glob('./*.txt')
</code></pre>
<p>… you do this:</p>
<pre><code>glob.glob(os.path.join(scriptdir, '*.txt'))
</code></pre>
<hr/>
<p><sub>* Actually, on some platforms you will get an absolute path here, rather than relative, meaning the later <code>abspath</code> is unnecessary. But for portability, it's worth doing. A bigger problem is that in some cases you will get just <code>bill.py</code>, with no path. There used to be cases where it was worth checking for that and trying <code>__file__</code> instead, but as far as I know that isn't true on any modern platform—and there are cases where <code>__file__</code> is wrong but <code>argv[0]</code> is right.</sub></p>
<p><sub>** For a relative path, it absolutizes it relative to the current working directory. That's why it's important to do this at the top of the script—in case someone does an <code>os.chdir</code> later.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem starts in line 5:</p>
<pre><code>arr = glob.glob('./*.txt')
</code></pre>
<p>You are telling glob to look in the local directory for all .txt files. Since you are one directory up you do not have these files.</p>
<p>You are getting a ValueError because the line variable is empty. </p>
<p>As it is written you will need to run it from that directory.</p>
<p>Edit:
The way I see it you have three separate options.</p>
<ol>
<li><p>You could simply run script with the full path (assuming it is executable)</p>
<p>~/Documents/BudgetAutomation/BillList/bill.py</p></li>
<li><p>You could put the full path into the file (although not very Pythonic)</p>
<p>arr = glob.glob('/home/[username]/Documents/BudgetAutomation/BillList/*.txt')</p></li>
<li><p>You could use <a href="https://docs.python.org/3/library/sys.html?highlight=sys.argv#sys.argv" rel="nofollow">sys.argv</a> to pass the path in the file. This would be my personal preferred way. Use os.path.join to put the correct slashes.</p>
<p>arr = glob.glob(os.path.join(sys.argv<a href="https://docs.python.org/3/library/sys.html?highlight=sys.argv#sys.argv" rel="nofollow">1</a>, '*.txt'))</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to create that range object to iterate over the glob result. You can just do it like this:</p>
<pre><code>for file_path in arr:
    with open(file_path) as text_file:
        #...code below...
</code></pre>
<p>The reason of why that exception is raised, I guess, is there exist text files contain content not conforming with your need. You read a line from that file, which is something may be like "foo|bar", then the splitting result of it is ["foo", "bar"].</p>
<p>If you want to avoid this exception, you could just catch it:</p>
<pre><code>try:
    bill_no, bill_name, trash = line.split('|', 2)
except ValueError:
    # You can do something more meaningful but just "pass"
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You must use absolute path <code>arr = glob.glob('./*.txt')</code> here.</p>
<p>Do something like <code>arr = glob.glob('/home/abc/stack_overflow/*.txt')</code></p>
<p>If possible use below code</p>
<pre><code>dir_name = "your directory name" # /home/abc/stack_overflow
[file for file in os.listdir(dir_name) if file.endswith('txt')]
</code></pre>
<p>This will provide you with list of files that you want to <code>glob</code> with</p>
</div>
<span class="comment-copy">Yeah I agree that is much more elegant solution. @young_buffett this should be your answer.</span>
<span class="comment-copy">Thank you guys a lot! I understand the problem now.  This will work for me I am sure.  <i>thumbs up</i> for everyone a part of this thread.</span>
<span class="comment-copy">I see... That makes sense.  Do you have a solution for fixing this problem? Obviously I want to be able to run/call it from other files and directories.</span>
<span class="comment-copy">Sorry had to go to lunch. I made an edit.</span>
<span class="comment-copy">Those are good suggestions in general… but in this case, the text files are apparently supposed to be in the same directory as the script, so there's a simpler choice.</span>
