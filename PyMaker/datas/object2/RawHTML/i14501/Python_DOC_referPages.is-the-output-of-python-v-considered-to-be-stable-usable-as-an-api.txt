<div class="post-text" itemprop="text">
<p><code>python -V</code> is about 40% faster than <code>python -c 'import sys; print(".".join(map(str, sys.version_info[:3])))'</code>.</p>
<p>But is <code>python -V</code> considered to be as stable?</p>
<p>At least it used to print to stderr before Python 3.4 (<a href="http://bugs.python.org/issue18338" rel="nofollow">http://bugs.python.org/issue18338</a>), which would require you to use <code>python -V 2&gt;&amp;1</code> (which is a bit slower already).</p>
<p>The main question however is: what's the fastest way to get the python version?</p>
<p>Anything better than <code>python -V 2&gt;&amp;1 | cut -f2 -d' '</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You've got two questions here. I'll skip the "what's the fastest way" and just answer the main question.</p>
<blockquote>
<p>But is python -V considered to be as stable?</p>
</blockquote>
<p>Definitely not. All that's <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-V" rel="nofollow">documented</a> is:</p>
<blockquote>
<p>Print the Python version number and exit. Example output could be:</p>
</blockquote>
<pre><code>Python 3.0
</code></pre>
<ul>
<li>As you noted yourself, it's not only not documented where it gets printed, but they changed it between 3.3 and 3.4.</li>
<li>Nothing is guaranteed about the format. And even the example in the docs isn't the format you wanted. (I'm assuming the <code>[:3]</code> in your other example means you actually need <code>3.0.2</code> rather than <code>3.0</code>).</li>
<li>In practice, your script doesn't even get the <code>X.Y.Z</code> version for every popular Python interpreter.
<ul>
<li>PyPy reports <em>two</em> version numbers, the version of the Python language and the version of the PyPy interpreter. If I run your script in a PyPy virtualenv, it gives me two values, <code>2.7.8</code> and <code>2.5.0</code>. In this case, the one you want is the first one, but how far do you trust that "in this case"?</li>
<li>Jython reports only one version number, which is the one you want for the first two digits in 2.2, 2.5, and pre-2.7, but there were pre-2.3 versions that didn't support most of Python 2.3 but still called themselves <code>2.3.0</code>.</li>
</ul></li>
</ul>
<p>By contrast, <a href="https://docs.python.org/3/library/sys.html#sys.version_info" rel="nofollow"><code>sys.version_info</code></a> is documented to give you three integers that are exactly what you want. (Well, as long as you don't need Python 1.5 compatibility, because <code>version_info</code> didn't exist until 1.6/2.0.)</p>
<p>Also notice that the docs specifically say not to extract version information out of <code>sys.version</code>, which I think is more stable than <code>python -V</code> (as in all the major implementations interpret the wording to mean that it must actually start with the Python version number, even though it's a bit vague).</p>
<p>But you don't really care whether it's "as stable", you just care whether it's "stable enough". And the answer to that is at least partly subjective and very use-dependent. If it works on every Python version and implementation you care about (which assumes you know and can test all the ones you care about…), it's stable enough, right?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think that if you want to programmatically determine the Python interpreter version that you should just <code>import sys</code> and read <code>sys.version_info</code>.</p>
<pre><code>python -c 'import sys; print sys.version_info.major, sys.version_info.minor, sys.version_info.micro'
</code></pre>
</div>
<span class="comment-copy">In what situation are you grabbing the Python version so many times that the time difference between different methods is meaningful?</span>
<span class="comment-copy">During Neovim startup (for its Python providers - minimum version requirements), and in Vim plugins in general. Also, it's used to check if <code>python</code>'s major version 3 or 2.</span>
<span class="comment-copy">Anyway, I don't think the output format of <code>python -V</code> or which fd it writes to are a documented part of either Python the language or CPython the implementation (see <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-V" rel="nofollow noreferrer">these</a> are the only docs I know), while <code>sys.version_info</code> definitely is, so it's clearly not "as stable".</span>
<span class="comment-copy">@abarnert <code>python-config --libs</code> is slower as the <code>python -c</code> approach. 8,376s vs. 7,515s (for 100 calls).</span>
<span class="comment-copy">What about just caching the value somewhere? I'm guessing most people don't change which version <code>python</code> means nearly as often as they start new vi sessions. (I even often start emacs multiple times in the same virtualenv, so I'm sure vi users must do it more…) I'm not sure what you'd want to check for invalidating the cache (you can have false positives as long as they don't happen too often…), but if you can think of anything that works for your app, that'll be hard to beat.</span>
<span class="comment-copy">This just takes the code the OP already has, breaks Python 3 compatibility (which I'm pretty sure is a key requirement), and changes the output format for no good reason.</span>
<span class="comment-copy">That's funny; it sounds largely identical to your statement that <code>sys.verison_info</code> is a more appropriate source of version information.  The output format and actual code you use to inspect the value is up to the consumer; I was just providing an example of what values were available.</span>
<span class="comment-copy">The OP obviously knows these values are available, because he already has the exact same code in the question. And if you don't understand the difference between describing the advantages of A over B vs just saying "I like A" with no explanation, I don't even know how to begin to deal with that.</span>
