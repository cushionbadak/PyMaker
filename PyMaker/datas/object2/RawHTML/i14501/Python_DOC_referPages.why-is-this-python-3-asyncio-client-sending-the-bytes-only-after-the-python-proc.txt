<div class="post-text" itemprop="text">
<p>Why is my client timing out at code line:</p>
<p><code>response = yield from asyncio.wait_for(reader.read(), timeout=3.0)</code></p>
<p>instead of getting a message back?</p>
<p>The server piece only registers it got a message from this client after the client times out and I actually issue a <code>ctrl + d</code> to kill the Python interpreter</p>
<hr/>
<h2>client.py</h2>
<pre><code>@asyncio.coroutine
def test_connection(host, port):
    # Get the streams for the socket
    print('Starting client connection')
    reader, writer = yield from asyncio.open_connection(host, port)

    message = 'Test Message'.encode('ascii')

    # Start communication
    print('Sending message to {}:{} - {}'.format(host, port, message))
    writer.write(message)

    print('Waiting 3 sec for response...')
    response = yield from asyncio.wait_for(reader.read(), timeout=3.0)
    print('Got response: {}'.format(response.decode('ascii')))

    writer.close()


def run():
    loop = asyncio.get_event_loop()
    task = asyncio.async(test_connection())
    loop.run_until_complete(task)
    loop.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is likely that you're calling <code>reader.read()</code> on the server-side (and also on the client-side), which will block until an <code>EOF</code> is sent from the server. But presumably you're not doing that - you're just sending some bytes over and keeping the connection open.</p>
<p>Instead, you need either to call <code>readline()</code> and make sure to append <code>b'\n'</code> to your mess payloads, call <code>read</code> with some size to limit the number of bytes you wait for, or call <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamWriter.write_eof" rel="nofollow"><code>writer.write_eof()</code></a> after writing your message payload, assuming you don't plan to use the <code>writer</code> anymore. Using <code>readline()</code> or <code>write_eof</code> are probably your safest options. Here's a complete example demonstrating using <code>readline()</code>:</p>
<h1>client.py</h1>
<pre><code>import asyncio

@asyncio.coroutine
def test_connection(host, port):
    # Get the streams for the socket
    print('Starting client connection')
    reader, writer = yield from asyncio.open_connection(host, port)

    message = 'Test Message\n'.encode('ascii')

    # Start communication
    print('Sending message to {}:{} - {}'.format(host, port, message))
    writer.write(message)

    print('Waiting 3 sec for response...')
    response = yield from asyncio.wait_for(reader.readline(), timeout=5.0)
    print('Got response: {}'.format(response.decode('ascii')))

    writer.close()


def run():
    loop = asyncio.get_event_loop()
    task = asyncio.async(test_connection('localhost', 5000))
    loop.run_until_complete(task)
    loop.close()

run()
</code></pre>
<h1>server.py</h1>
<pre><code>import asyncio

@asyncio.coroutine
def got_connection(reader, writer):
    msg = yield from reader.readline()
    message = 'another Test Message\n'.encode('ascii')
    print('Sending message to {}:{} - {}'.format('localhost', 5000, message))
    writer.write(message)


def run():
    loop = asyncio.get_event_loop()
    server = loop.run_until_complete(asyncio.start_server(
                                        got_connection, 'localhost', 5000))
    loop.run_until_complete(server.wait_closed())
    loop.close()

run()
</code></pre>
<p>And here are the changes to use <code>write_eof()</code>:</p>
<h1>client.py</h1>
<pre><code>@asyncio.coroutine
def test_connection(host, port):
    # Get the streams for the socket
    print('Starting client connection')
    reader, writer = yield from asyncio.open_connection(host, port)

    message = 'Test Message'.encode('ascii')

    # Start communication
    print('Sending message to {}:{} - {}'.format(host, port, message))
    writer.write(message)
    writer.write_eof()

    print('Waiting 3 sec for response...')
    response = yield from asyncio.wait_for(reader.read(), timeout=5.0)
    print('Got response: {}'.format(response.decode('ascii')))

    writer.close()
</code></pre>
<h1>server.py</h1>
<pre><code>@asyncio.coroutine
def got_connection(reader, writer):
    msg = yield from reader.read()
    message = 'another Test Message'.encode('ascii')
    print('Sending message to {}:{} - {}'.format('localhost', 5000, message))
    writer.write(message)
    writer.write_eof()
</code></pre>
</div>
