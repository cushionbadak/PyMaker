<div class="post-text" itemprop="text">
<p>I have array of primes e.g. between integers 0 to 1000</p>
<pre><code>primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
</code></pre>
<p>I get input</p>
<pre><code>n = int(input())
</code></pre>
<p>What is the most efficient way to slice array to new array where last element of array will be less than <code>n</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make use of the fact that <code>primes</code> is already sorted, with <a href="https://docs.python.org/3/library/bisect.html#bisect.bisect"><code>bisect</code></a>, like this</p>
<pre><code>&gt;&gt;&gt; from bisect import bisect
&gt;&gt;&gt; primes[:bisect(primes, n)]
</code></pre>
<p><code>bisect</code> does binary search on the input list and returns the index of the element which is lesser than <code>n</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have a <code>list</code>, not an array. If you actually need to slice the list and build a new list, that's going to take linear time, no matter how you do it. <a href="https://stackoverflow.com/a/29957912/908494">The answer by thefourtheye</a> is probably the best you're going to do:</p>
<pre><code>small_primes = primes[:bisect.bisect(primes, n)]
</code></pre>
<p>If you have NumPy, it knows how to create views that <em>look</em> like slices, but actually reference rather than copying the data. In fact, if <code>primes</code> were an <code>ndarray</code>, you could use exactly the same code as thefourtheye's answer and it would be O(log N).</p>
<pre><code>small_primes = primes[:bisect.bisect(primes, n)]
</code></pre>
<p>If you only need to iterate the "array" once rather than use it as a list, you can use a lazy iterator:</p>
<pre><code>small_primes = itertools.takewhile(lambda p: p&lt;n, primes)
</code></pre>
<p>Now the up-front time cost is 0; but there's a comparison attached to each value at the time you consume it. Of course it's more space-efficient than anything else.</p>
<p>Realistically, "most efficient" here is unlikely to matter, and if it does matter you'll need to measure it, and if you're not using NumPy or running your code under PyPy you almost certainly want to do one of those before any micro-optimizations…</p>
</div>
<div class="post-text" itemprop="text">
<p>You didn't explain why you're asking for "the most efficient way", or what you mean by that (time? space? something else?), and I highly doubt this really is a performance bottleneck worth optimizing anywhere, but if it is:</p>
<p>You've only got 168 elements. And you're not going to have lots of similar lists, so space is unlikely to be relevant. Meanwhile, for a linear algorithm over N=168 to matter, you must be calling it zillions of times—but there are only 1000 possible values. So, just pre-create a table:</p>
<pre><code>prime_slices = [[prime for prime in primes if prime &lt; n] for n in range(1000)]
</code></pre>
<p>Now, to get the primes up to <code>n</code>:</p>
<pre><code>prime_slices[n]
</code></pre>
<p>That's constant time. Of course the setup takes O(N^2) time, but that's nothing, since it only happens once vs. saving O(N) work zillions of times. And it takes O(N^2) space, but really that's just a constant 15K-ish pointers, which you can almost certainly afford.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't need the full prime list again, truncating the primes may be the fastest approach:</p>
<pre><code>primes[bisect(primes, n):]=[]
</code></pre>
<p>But as always with performance, measure it if you care.</p>
</div>
<span class="comment-copy">Yeah, the bisect takes O(log N) time. The slicing takes O(N) time just like the simple solution, however. It's only doing on average N/2 rather than N, and, more importantly, it's got a blindingly-fast multiplier because list slicing is mostly just a memmove… But it's still O(N), not O(log N). And you can't beat that without using some kind of view class instead of slicing.</span>
<span class="comment-copy">@abamert <code>primes[bisect(primes, n):]=[]</code> may be able to do less work but I don't know enough about the implementation to be sure</span>
<span class="comment-copy">@tobyodavies: Good point. I don't know for sure either, but it would be worth testing if this really were someone's bottleneck…</span>
<span class="comment-copy">I think even faster is possible using some domain knowledge!  Consider the prime counting function π(n) returning the number of primes &lt;= n.  It's related to riemann zeta function.  There exist closed formulas which give very good estimates of the prime counting function.  You can use one of these functions to give a better location to begin the search.  For example, <code>n/log(n)</code> is one such estimator, there are more sophisticated ones too.</span>
<span class="comment-copy">@wim: Good point. But you're still just optimizing the O(log N) part (bisecting) to close-ish-to-constant while still leaving the O(N) part linear. Practically it may be worth it (again, that's very fast O(N)…), but I personally wouldn't waste time trying unless I had a real test case where it mattered.</span>
<span class="comment-copy">This is literally what I was thinking. Only 168 values? Abuse RAM! +1</span>
<span class="comment-copy">Also we can have multiple indexes in the outer list pointing to the same inner list. Then you would have only 168 or so inner lists and 1000 indexes that map to those inner lists. That would make it a bit more efficient.</span>
<span class="comment-copy">That's cheating.  Breaks for n = 5321573289143782914738291437218490372184.    :)</span>
<span class="comment-copy">@Shashank: Yeah, I really should have added something to explicitly "intern" the lists instead of building each one ~7 times… but I wanted to write it as an obvious 1-liner.</span>
<span class="comment-copy">@wim: OK, so <code>def prime_slices(n):\n\ttry: return _prime_slices[n]\n\texcept IndexError: return prime_slices[-1]\n</code>. :) But honestly, I think that "I have a list of the primes up to 1000" and "I want to get the number of primes up to any <i>n</i>" probably <i>should</i> raise an exception for n&gt;1000. Otherwise, it's returning misleading answers…</span>
<span class="comment-copy">Of course this doesn't actually "slice array to new array"… but then the OP doesn't have an "array" in the first place, so I'm not too worried about following instructions to the letter…</span>
