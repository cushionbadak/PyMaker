<div class="post-text" itemprop="text">
<p>This is what I have:</p>
<pre><code>glob(os.path.join('src','*.c'))
</code></pre>
<p>but I want to search the subfolders of src. Something like this would work:</p>
<pre><code>glob(os.path.join('src','*.c'))
glob(os.path.join('src','*','*.c'))
glob(os.path.join('src','*','*','*.c'))
glob(os.path.join('src','*','*','*','*.c'))
</code></pre>
<p>But this is obviously limited and clunky.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python 3.5+</strong></p>
<p>Starting with Python version 3.5, the <a href="https://docs.python.org/3/library/glob.html" rel="noreferrer"><code>glob</code></a> module supports the <code>"**"</code> directive (which is parsed only if you pass <code>recursive</code> flag):</p>
<pre><code>import glob

for filename in glob.iglob('src/**/*.c', recursive=True):
    print(filename)
</code></pre>
<p>If you need a list, just use <a href="https://docs.python.org/3/library/glob.html#glob.glob" rel="noreferrer"><code>glob.glob</code></a> instead of <a href="https://docs.python.org/3/library/glob.html#glob.iglob" rel="noreferrer"><code>glob.iglob</code></a>.</p>
<p>For cases where matching files beginning with a dot (.); like files in the current directory or hidden files on Unix based system, use the <a href="https://docs.python.org/2/library/os.html#os.walk" rel="noreferrer"><code>os.walk</code></a> solution below.</p>
<p><strong>Python 2.2 to 3.4</strong></p>
<p>For older Python versions, starting with Python 2.2, use <a href="https://docs.python.org/2/library/os.html#os.walk" rel="noreferrer"><code>os.walk</code></a> to recursively walk a directory and <a href="https://docs.python.org/2/library/fnmatch.html#fnmatch.filter" rel="noreferrer"><code>fnmatch.filter</code></a> to match against a simple expression:</p>
<pre><code>import fnmatch
import os

matches = []
for root, dirnames, filenames in os.walk('src'):
    for filename in fnmatch.filter(filenames, '*.c'):
        matches.append(os.path.join(root, filename))
</code></pre>
<p><strong>Python 2.1 and earlier</strong></p>
<p>For even older Python versions, use <a href="https://docs.python.org/2/library/glob.html#glob.glob" rel="noreferrer"><code>glob.glob</code></a> against each filename instead of <a href="https://docs.python.org/2/library/fnmatch.html#fnmatch.filter" rel="noreferrer"><code>fnmatch.filter</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Similar to other solutions, but using fnmatch.fnmatch instead of glob, since os.walk already listed the filenames:</p>
<pre><code>import os, fnmatch


def find_files(directory, pattern):
    for root, dirs, files in os.walk(directory):
        for basename in files:
            if fnmatch.fnmatch(basename, pattern):
                filename = os.path.join(root, basename)
                yield filename


for filename in find_files('src', '*.c'):
    print 'Found C source:', filename
</code></pre>
<p>Also, using a generator alows you to process each file as it is found, instead of finding all the files <em>and then</em> processing them.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've modified the glob module to support ** for recursive globbing, e.g:</p>
<pre><code>&gt;&gt;&gt; import glob2
&gt;&gt;&gt; all_header_files = glob2.glob('src/**/*.c')
</code></pre>
<p><a href="https://github.com/miracle2k/python-glob2/" rel="noreferrer">https://github.com/miracle2k/python-glob2/</a></p>
<p>Useful when you want to provide your users with the ability to use the ** syntax, and thus  os.walk() alone is not good enough.</p>
</div>
<div class="post-text" itemprop="text">
<p>Starting with Python 3.4, one can use the <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob" rel="noreferrer"><code>glob()</code></a> method of one of the <code>Path</code> classes in the new <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer">pathlib</a> module, which supports <code>**</code> wildcards. For example:</p>
<pre class="lang-py prettyprint-override"><code>from pathlib import Path

for file_path in Path('src').glob('**/*.c'):
    print(file_path) # do whatever you need with these files
</code></pre>
<p><strong>Update:</strong>
Starting with Python 3.5, the same syntax is also supported by <code>glob.glob()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
import fnmatch


def recursive_glob(treeroot, pattern):
    results = []
    for base, dirs, files in os.walk(treeroot):
        goodfiles = fnmatch.filter(files, pattern)
        results.extend(os.path.join(base, f) for f in goodfiles)
    return results
</code></pre>
<p><a href="http://docs.python.org/library/fnmatch.html?highlight=fnmatch#fnmatch.filter" rel="noreferrer"><code>fnmatch</code></a> gives you exactly the same patterns as <a href="http://docs.python.org/library/glob.html?highlight=glob#glob.glob" rel="noreferrer"><code>glob</code></a>, so this is really an excellent replacement for <code>glob.glob</code> with very close semantics.  An iterative version (e.g. a generator), IOW a replacement for <code>glob.iglob</code>, is a trivial adaptation (just <code>yield</code> the intermediate results as you go, instead of <code>extend</code>ing a single results list to return at the end).</p>
</div>
<div class="post-text" itemprop="text">
<p>You'll want to use <code>os.walk</code> to collect filenames that match your criteria. For example:</p>
<pre><code>import os
cfiles = []
for root, dirs, files in os.walk('src'):
  for file in files:
    if file.endswith('.c'):
      cfiles.append(os.path.join(root, file))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution with nested list comprehensions, <code>os.walk</code> and simple suffix matching instead of <code>glob</code>:</p>
<pre><code>import os
cfiles = [os.path.join(root, filename)
          for root, dirnames, filenames in os.walk('src')
          for filename in filenames if filename.endswith('.c')]
</code></pre>
<p>It can be compressed to a one-liner:</p>
<pre><code>import os;cfiles=[os.path.join(r,f) for r,d,fs in os.walk('src') for f in fs if f.endswith('.c')]
</code></pre>
<p>or generalized as a function:</p>
<pre><code>import os

def recursive_glob(rootdir='.', suffix=''):
    return [os.path.join(looproot, filename)
            for looproot, _, filenames in os.walk(rootdir)
            for filename in filenames if filename.endswith(suffix)]

cfiles = recursive_glob('src', '.c')
</code></pre>
<p>If you do need full <code>glob</code> style patterns, you can follow Alex's and
Bruno's example and use <code>fnmatch</code>:</p>
<pre><code>import fnmatch
import os

def recursive_glob(rootdir='.', pattern='*'):
    return [os.path.join(looproot, filename)
            for looproot, _, filenames in os.walk(rootdir)
            for filename in filenames
            if fnmatch.fnmatch(filename, pattern)]

cfiles = recursive_glob('src', '*.c')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Johan and Bruno provide excellent solutions on the minimal requirement as stated. I have just released <a href="http://pypi.python.org/pypi/formic">Formic</a> which implements Ant <a href="http://ant.apache.org/manual/dirtasks.html#patterns">FileSet and Globs</a> which can handle this and more complicated scenarios. An implementation of your requirement is:</p>
<pre><code>import formic
fileset = formic.FileSet(include="/src/**/*.c")
for file_name in fileset.qualified_files():
    print file_name
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>based on other answers this is my current working implementation, which retrieves nested xml files in a root directory:</p>
<pre><code>files = []
for root, dirnames, filenames in os.walk(myDir):
    files.extend(glob.glob(root + "/*.xml"))
</code></pre>
<p>I'm really having fun with python :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Recently I had to recover my pictures with the extension .jpg. I ran photorec and recovered 4579 directories 2.2 million files within, having tremendous variety of extensions.With the script below I was able to select 50133 files havin .jpg extension within minutes:</p>
<pre><code>#!/usr/binenv python2.7

import glob
import shutil
import os

src_dir = "/home/mustafa/Masaüstü/yedek"
dst_dir = "/home/mustafa/Genel/media"
for mediafile in glob.iglob(os.path.join(src_dir, "*", "*.jpg")): #"*" is for subdirectory
    shutil.copy(mediafile, dst_dir)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way to do it using just the glob module. Just seed the rglob method with a starting base directory and a pattern to match and it will return a list of matching file names.</p>
<pre><code>import glob
import os

def _getDirs(base):
    return [x for x in glob.iglob(os.path.join( base, '*')) if os.path.isdir(x) ]

def rglob(base, pattern):
    list = []
    list.extend(glob.glob(os.path.join(base,pattern)))
    dirs = _getDirs(base)
    if len(dirs):
        for d in dirs:
            list.extend(rglob(os.path.join(base,d), pattern))
    return list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just made this.. it will print files and directory in hierarchical way</p>
<p>But I didn't used fnmatch or walk</p>
<pre><code>#!/usr/bin/python

import os,glob,sys

def dirlist(path, c = 1):

        for i in glob.glob(os.path.join(path, "*")):
                if os.path.isfile(i):
                        filepath, filename = os.path.split(i)
                        print '----' *c + filename

                elif os.path.isdir(i):
                        dirname = os.path.basename(i)
                        print '----' *c + dirname
                        c+=1
                        dirlist(i,c)
                        c-=1


path = os.path.normpath(sys.argv[1])
print(os.path.basename(path))
dirlist(path)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the suggested answers, you can do this with some lazy generation and list comprehension magic:</p>
<pre><code>import os, glob, itertools

results = itertools.chain.from_iterable(glob.iglob(os.path.join(root,'*.c'))
                                               for root, dirs, files in os.walk('src'))

for f in results: print(f)
</code></pre>
<p>Besides fitting in one line and avoiding unnecessary lists in memory, this also has the nice side effect, that you can use it in a way similar to the ** operator, e.g., you could use <code>os.path.join(root, 'some/path/*.c')</code> in order to get all .c files in all sub directories of src that have this structure.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simplified version of Johan Dahlin's answer, without <a href="http://docs.python.org/2/library/fnmatch.html" rel="nofollow">fnmatch</a>.</p>
<pre><code>import os

matches = []
for root, dirnames, filenames in os.walk('src'):
  matches += [os.path.join(root, f) for f in filenames if f[-2:] == '.c']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or with a list comprehension:</p>
<pre><code> &gt;&gt;&gt; base = r"c:\User\xtofl"
 &gt;&gt;&gt; binfiles = [ os.path.join(base,f) 
            for base, _, files in os.walk(root) 
            for f in files if f.endswith(".jpg") ] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That one uses fnmatch or regular expression:</p>
<pre><code>import fnmatch, os

def filepaths(directory, pattern):
    for root, dirs, files in os.walk(directory):
        for basename in files:
            try:
                matched = pattern.match(basename)
            except AttributeError:
                matched = fnmatch.fnmatch(basename, pattern)
            if matched:
                yield os.path.join(root, basename)

# usage
if __name__ == '__main__':
    from pprint import pprint as pp
    import re
    path = r'/Users/hipertracker/app/myapp'
    pp([x for x in filepaths(path, re.compile(r'.*\.py$'))])
    pp([x for x in filepaths(path, '*.py')])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution using list comprehension to search for <strong>multiple</strong> file extensions <strong>recursively</strong> in a directory and all subdirectories:</p>
<pre><code>import os, glob

def _globrec(path, *exts):
""" Glob recursively a directory and all subdirectories for multiple file extensions 
    Note: Glob is case-insensitive, i. e. for '\*.jpg' you will get files ending
    with .jpg and .JPG

    Parameters
    ----------
    path : str
        A directory name
    exts : tuple
        File extensions to glob for

    Returns
    -------
    files : list
        list of files matching extensions in exts in path and subfolders

    """
    dirs = [a[0] for a in os.walk(path)]
    f_filter = [d+e for d in dirs for e in exts]    
    return [f for files in [glob.iglob(files) for files in f_filter] for f in files]

my_pictures = _globrec(r'C:\Temp', '\*.jpg','\*.bmp','\*.png','\*.gif')
for f in my_pictures:
    print f
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import sys, os, glob

dir_list = ["c:\\books\\heap"]

while len(dir_list) &gt; 0:
    cur_dir = dir_list[0]
    del dir_list[0]
    list_of_files = glob.glob(cur_dir+'\\*')
    for book in list_of_files:
        if os.path.isfile(book):
            print(book)
        else:
            dir_list.append(book)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I modified the top answer in this posting.. and recently created this script which will loop through all files in a given directory (searchdir) and the sub-directories under it... and prints filename, rootdir, modified/creation date, and size.</p>
<p>Hope this helps someone... and they can walk the directory and get fileinfo.</p>
<pre><code>import time
import fnmatch
import os

def fileinfo(file):
    filename = os.path.basename(file)
    rootdir = os.path.dirname(file)
    lastmod = time.ctime(os.path.getmtime(file))
    creation = time.ctime(os.path.getctime(file))
    filesize = os.path.getsize(file)

    print "%s**\t%s\t%s\t%s\t%s" % (rootdir, filename, lastmod, creation, filesize)

searchdir = r'D:\Your\Directory\Root'
matches = []

for root, dirnames, filenames in os.walk(searchdir):
    ##  for filename in fnmatch.filter(filenames, '*.c'):
    for filename in filenames:
        ##      matches.append(os.path.join(root, filename))
        ##print matches
        fileinfo(os.path.join(root, filename))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution that will match the pattern against the full path and not just the base filename.</p>
<p>It uses <a href="https://docs.python.org/2/library/fnmatch.html?highlight=fnmatch.translate#fnmatch.translate" rel="nofollow"><code>fnmatch.translate</code></a> to convert a glob-style pattern into a regular expression, which is then matched against the full path of each file found while walking the directory.</p>
<p><code>re.IGNORECASE</code> is optional, but desirable on Windows since the file system itself is not case-sensitive. (I didn't bother compiling the regex because docs indicate it should be cached internally.)</p>
<pre><code>import fnmatch
import os
import re

def findfiles(dir, pattern):
    patternregex = fnmatch.translate(pattern)
    for root, dirs, files in os.walk(dir):
        for basename in files:
            filename = os.path.join(root, basename)
            if re.search(patternregex, filename, re.IGNORECASE):
                yield filename
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I needed a solution for <strong>python 2.x</strong> that works <strong>fast</strong> on large directories.<br/>
I endet up with this:</p>
<pre><code>import subprocess
foundfiles= subprocess.check_output("ls src/*.c src/**/*.c", shell=True)
for foundfile in foundfiles.splitlines():
    print foundfile
</code></pre>
<p>Note that you might need some exception handling in case <code>ls</code> doesn't find any matching file.</p>
</div>
<span class="comment-copy">how is about <code>os.path.join('src','**', '*.c')</code>?</span>
<span class="comment-copy">For Python older than 2.2 there is <code>os.path.walk()</code> which is a little more fiddly to use than <code>os.walk()</code></span>
<span class="comment-copy">@gnibbler I know that is an old comment, but my comment is just to let people know that <code>os.path.walk()</code> is deprecated and has been removed in Python 3.</span>
<span class="comment-copy">why not .endwith('.c'), I think that will be faster than fnmatch in this scenario?</span>
<span class="comment-copy">@DevC that might work in the specific case asked in this question, but it's easy to imagine someone that wants to do use it with queries such as 'a*.c' etc, so I think it's worth keeping the current somewhat slow answer.</span>
<span class="comment-copy">For the Python 3 solution, <code>glob</code> skips directories beginning with <code>.</code> unless you code for them specifically. I think traversing the directory tree using <code>os.walk</code> is a more robust and ultimately simpler solution.</span>
<span class="comment-copy">because 1-liners are fun: <code>reduce(lambda x, y: x+y, map(lambda (r,_,x):map(lambda f: r+'/'+f, filter(lambda f: fnmatch.fnmatch(f, pattern), x)), os.walk('src/webapp/test_scripts')))</code></span>
<span class="comment-copy">@njzk2 <code>(os.path.join(root,filename) for root, dirs, files in os.walk(directory) for filename in files if fnmatch.fnmatch(filename, pattern))</code></span>
<span class="comment-copy">Can we make this stop after it finds the first match? Maybe make it possible to use it as a generator rather than having it return a list of every possible result? Also, is this a DFS or a BFS? I'd much prefer a BFS, I think, so that files which are near the root are found first. +1 for making this module and providing it on GitHub/pip.</span>
<span class="comment-copy">The ** syntax was added to the official glob module in Python 3.5.</span>
<span class="comment-copy">Ended up using this in python 2.7. Works like a charm.</span>
<span class="comment-copy">@ArtOfWarfare Alright, fine. This is still useful for &lt; 3.5.</span>
<span class="comment-copy">success.Thank you!!! Env:python 2.7,anaconda</span>
<span class="comment-copy">This should be the default behaviour of glob module. Thank you.</span>
<span class="comment-copy">Indeed, and <a href="https://hg.python.org/cpython/rev/ff4b9d654691/" rel="nofollow noreferrer">it will be in Python 3.5</a>. It was supposed to already be so in Python 3.4, but was <a href="http://bugs.python.org/issue13968#msg212878" rel="nofollow noreferrer">omitted by mistake</a>.</span>
<span class="comment-copy">Beautiful solution, this should be the accepted answer. Thank you.</span>
<span class="comment-copy">This syntax is now <a href="https://docs.python.org/3.5/whatsnew/3.5.html#glob" rel="nofollow noreferrer">supported by glob.glob() as of Python 3.5</a>.</span>
<span class="comment-copy">Thanks for this, I incorporated these changes into my answer.</span>
<span class="comment-copy">What do you think about using <code>recursive_glob(pattern, treeroot='.')</code> as I suggested in my edit? This way, it can be called for example as <code>recursive_glob('*.txt')</code> and intuitively match the syntax of <code>glob</code>.</span>
<span class="comment-copy">@ChrisRedford, I see it as a pretty minor issue either way.  As it stands now, it matches the "files then pattern" argument order of <code>fnmatch.filter</code>, which is roughly as useful as the possibility of matching single-argument <code>glob.glob</code>.</span>
<span class="comment-copy">Formic appears to be abandoned?! And it does not support Python 3 (<a href="https://bitbucket.org/aviser/formic/issue/12/support-python-3" rel="nofollow noreferrer">bitbucket.org/aviser/formic/issue/12/support-python-3</a>)</span>
<span class="comment-copy">I just realized that <code>ls src/**/*.c</code> only works if globstar option is enabled (<code>shopt -s globstar</code>) - see <a href="https://stackoverflow.com/a/28199633/3301051">this answer</a> for details.</span>
