<div class="post-text" itemprop="text">
<p>Is there a way in python 3 to append, to a list, both a string and a number as a single entry.
For example if I had a list of class names, and wanted to be able to sort the list alphabetically, I would use:</p>
<pre><code>classNames = []
classNames.sort()
print(classNames)
</code></pre>
<p>This would produce something like the following once names were appended:</p>
<pre><code>["Adam", "Ben", "Charlotte"]
</code></pre>
<p>But if I wanted to be able to assign a score for a test such to produce:</p>
<pre><code>["Adam" 12/15, "Ben" 9/15, "Charlotte" 14/15]
</code></pre>
<p>Would this be possible? Can I do it using lists or do I have to use other more complicated syntax?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can insert a tuple containing the elements you want.</p>
<pre><code>a=[]
a.append(("Test",(12,15)))
</code></pre>
<p>then <code>a[0][0]</code> will be equal to "Test", <code>a[0][1][0]</code> will be <code>12</code> and <code>a[0][1][1]</code> will be <code>15</code>.</p>
<p>To my mind, you don't need that <code>12/15</code> business.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a <a href="https://docs.python.org/3.4/library/fractions.html" rel="nofollow">fractions library</a> therefore you can structure your data like so:</p>
<pre><code> [("John", Fraction(5,12)), ("Alice", Fraction(8, 13))]
</code></pre>
<p>As it has been pointed out you can also use a named tuple: </p>
<pre><code>from collections import namedtuple
from fractions import Fraction
StudentScore = namedtuple('StudentScore', ['name', 'score'])
x = StudentScore('John', Fraction(5, 12))


In [109]: x.name
Out[109]: 'John'

In [110]: x.score
Out[110]: Fraction(5, 12)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <code>tuple</code>:</p>
<pre><code>data = [("Adam",12/15), ("Ben",9/15), ("Charlotte",14/15)] 
data.append(("new name", new_numerator/new_denominator))
</code></pre>
<p>Or you could store the numerator and the denominator separately:</p>
<pre><code>data = [( "Adam",(12,15) ), ( "Ben",(9,15) ), ( "Charlotte",(14,15) )] 
data.append(("new name", (new_numerator,new_denominator)))
</code></pre>
<p>You could also fore go the <code>list</code> and just use a <code>dict</code>:</p>
<pre><code>data = {
     "Adam":(12,15),
     "Ben":(9,15),
     "Charlotte":(14,15)
}
data["new name"] = (new_numerator,new_denominator)
</code></pre>
<p><strong>EDIT:</strong></p>
<p>After consideration of my discussion in the comments with <strong>@TigerhawkT3</strong>.  Though based on an assumption, I felt he had a good point.</p>
<p>If your denominator is a constant across all your data it would be better to store it once in some variable and only score the number of questions answered correctly by each student:</p>
<pre><code>number_of_questions = 15
data = [( "Adam",12 ), ( "Ben",9 ), ( "Charlotte",14 )] 
data.append(("new name", (new_numerator,new_denominator)))
</code></pre>
<p>or as a <code>dict</code></p>
<pre><code>number_of_questions = 15
data = {
     "Adam":12,
     "Ben":9,
     "Charlotte":14
}
data["new name"] = new_score
</code></pre>
</div>
<span class="comment-copy">List of list. Or list of tuple.</span>
<span class="comment-copy"><code>12/15</code> will work fine. You just have to multiply by 15 when you want the original raw score.</span>
<span class="comment-copy">I don't know why its all a block text sorry if that makes it hard to understand, I did actually have separate lines for my code</span>
<span class="comment-copy">The <code>9/15</code> is a score, not a date.</span>
<span class="comment-copy">If needed, you might use <a href="https://docs.python.org/3/library/fractions.html" rel="nofollow noreferrer">fractions</a> to store rational numbers</span>
<span class="comment-copy">copy that line into python and tell me it works</span>
<span class="comment-copy">still gonna give you not expected output</span>
<span class="comment-copy">9/15 ends up as 0</span>
<span class="comment-copy">lol my dyslexia kicked in :P</span>
<span class="comment-copy">The original post did specify Python 3.</span>
