<div class="post-text" itemprop="text">
<p>I have a third party python console script, which source I don't want to modify.</p>
<p>But I want to configure the logging which is done by the script and its libraries. The script uses the standard python logging, but does not support configuration of it.</p>
<p>The script uses this pattern:</p>
<pre><code>import logging
logger=logging.getLogger(__name__)
</code></pre>
<p>Use cases: </p>
<ul>
<li>I want INFO messages of file foo.py to be ignored.</li>
<li>I want to include the PID in the loggings messages.</li>
</ul>
<p>How can I configure the logging, if I don't want to modify the sources of the console script?</p>
<p>The script gets called via <code>cron</code>.</p>
<p>How can I configure the logging if this script?</p>
<h1>Important</h1>
<p>Creating a wrapper script like in <a href="https://stackoverflow.com/questions/23711400/settings-up-logging-in-console-script">this answer</a> is not a solution for me.</p>
<p>The linux process hierarchy looks like this:</p>
<pre><code>Cron -&gt; third_party_script
</code></pre>
<p>There should be any "glue", "wrapping" or "dirty-hack" script between cron and <code>third_party_script</code>.</p>
<h1>Why obtrusive/netpicking?</h1>
<p>I want to practice "separation of concerns". I want to be able to configure logging one time and in one place. This configuration should get used by all python code of a virtualenv. Writing a wrapper would be a work-around. I want a solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>A library isn't supposed to configure logging - that's up to the application developer. Inbar Rose's answer isn't <em>quite</em> right. If the module you're referring to is called <code>foo</code>, then the reference to <code>__name__</code> in its <code>getLogger</code> call will be passing in <code>foo</code>. So in <em>your</em> configuration code, you would need to do the equivalent of</p>
<pre><code>logging.getLogger('foo').setLevel(logging.WARNING)
</code></pre>
<p>To include the PID in the logs, just ensure that you use an appropriate format string for your Formatters, i.e. one which includes <code>%(process)d</code>. A simple example would be:</p>
<pre><code>logging.basicConfig(format='%(process)d %(message)s')
</code></pre>
<p>Note that you can't write to the same log file from multiple processes concurrently - you may need to consider <a href="https://stackoverflow.com/a/18843553/118903">an alternative approach</a> if you want to do this.</p>
<p><strong>Update:</strong> An application developer is someone who writes Python code which is not the library, but is invoked by e.g. a user or another script via a command line or other means of creating a Python process.</p>
<p>To use the code I posted above, there is no need to wrap or modify the third-party code, as long as it's a library. For example, in the main script which invokes the third-party library:</p>
<pre><code>if __name__ == '__main__':
    # configure logging here
    # sets the third party's logger to do WARNING or greater
    # replace 'foo' with whatever the top-level package name your
    # third party package uses
    logging.getLogger('foo').setLevel(logging.WARNING)
    # set any other loggers to use INFO or greater,
    # unless otherwise configured explicitly
    logging.basicConfig(level=logging.INFO, format='%(process)d %(message)s')
    # now call the main function (or else inline code here)
    main()
</code></pre>
<p>If the third party code runs via cron, it's not library code - it's an application, and you are probably out of luck.</p>
</div>
<div class="post-text" itemprop="text">
<p>I asked this question several months ago. Unfortunately I got no answer which satisfied me.</p>
<p>The distinction between using logging and setting it up is important for me.</p>
<p>This is my solution: In our context we set up logging in a method which gets called in <code>usercustomize.py</code>.</p>
<p>This way the optional plugins can use the logging without the need to set it up. </p>
<p>This almost solved all my needs.</p>
<p>Up to now I found no better way than <code>usercustomize.py</code>. My perfect solution would be something I would call <code>virtualenvcustomize.py</code>: Some initialization code which gets run if the interpreter loads virtualenv. Up to now I could not find such a hook. Please let me know if you have a solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>Several possibilities:</p>
<p><strong>Wrapper</strong></p>
<p>If you can edit your cron table you could create a small script in python that get the lib logger, remove the existing log handler and hook your custom handler on it:</p>
<pre><code># Assumes the lib defines a logger object
from third_party_lib import *

# Note this assumes only one handler was defined by the lib
logger.removeHandler(logger.handlers[0])

# Then we can hook our custom format handler
custom_handler = logging.StreamHandler(sys.stdout)
custom_handler.setFormatter(logging.Formatter(format = '%(asctime)s %(levelname)s %(name)s %(process)d: %(message)s', None))
logger.addHandler(custom_handler)
logger.setLevel(logging.WARNING)
</code></pre>
<p>Also keep in mind this suppose the lib does not re-declare the logger on the way.</p>
<p><strong>Dynamic code edit</strong></p>
<p>If you do not have the possibility to modify the cron call, you might be able to do dynamic code edit but that is equivalent to editing the file by hand (hacky): </p>
<ul>
<li>get the third party file containing the logger configuration</li>
<li>modify that and save back the modified version</li>
<li>the cron job starts the task using third party code</li>
<li>after execution of the cron job, you restore the file to their original state.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can change the minimum log level of that logger.</p>
<pre><code>logging.getLogger(__name__).setLevel(logging.WARNING)
</code></pre>
<p>Now, only WARNING and above will be shown. No INFO and no DEBUG.</p>
<p>Addionally, you could also change the format. <code>%(process)d</code> being the PID.</p>
<pre><code>log_format = logging.Formatter('%(asctime)s %(levelname)s %(name)s %(process)d: %(message)s', '%H:%M:%S')
logging.getLogger(__name__).setFormatter(log_format)
</code></pre>
<p>All together:</p>
<pre><code>log_format = logging.Formatter('%(asctime)s %(levelname)s %(name)s %(process)d: %(message)s', '%H:%M:%S')
log_handle = logging.getLogger(__name__)
log_handle.setLevel(logging.WARNING)
log_handle.setFormatter(log_format)
</code></pre>
<p>Note: You should replace <code>__name__</code> in your code with the relevant log handler.</p>
</div>
<div class="post-text" itemprop="text">
<h1>tl;dr</h1>
<p>In a nutshell, what we want to do is to inject code that gets executed by the python interpreter before our main code gets executed.</p>
<p>The best way to achieve this is to create a virtualenv and add
<code>sitecustomize.py</code> in the virtualenv's site-packages.</p>
<h2>Demonstration</h2>
<p>Let's assume that the application we want to run is called <code>my_app.py</code> and that its
logger has the same name.</p>
<pre><code>$ cat my_app.py

import logging
logger = logging.getLogger("my_app")

logger.debug("A debug message")
logger.info("An info message")
logger.warning("A warning message")
logger.error("An error message")
</code></pre>
<p>Running <code>my_app.py</code> should only show the messages whose severity is &gt; <code>WARNING</code> (which
is the default behavior in python's logging).</p>
<pre><code>$ python my_app.py

A warning message
An error message
</code></pre>
<p>Now let's create a virtual environment</p>
<pre><code>python3 -m venv my_venv
</code></pre>
<p>And let's add <code>sitecustomize.py</code> to the virtualenv's site packages.</p>
<pre><code>$ cat my_venv/lib/python3.7/site-packages/sitecustomize.py

import logging

# Setup logging for my_app
# We will only setup a console handler
logger = logging.getLogger("my_app")
logger.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setFormatter(
    logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
)
logger.addHandler(ch)
</code></pre>
<p>Now let's try to run <code>my_app.py</code> using the virtualenv:</p>
<pre class="lang-sh prettyprint-override"><code>$ ./my_venv/bin/python my_app.py

2019-01-25 16:03:16,815 - my_app - DEBUG - A debug message
2019-01-25 16:03:16,815 - my_app - INFO - An info message
2019-01-25 16:03:16,815 - my_app - WARNING - A warning message
2019-01-25 16:03:16,815 - my_app - ERROR - An error message
</code></pre>
<p>And that was all)
We got proper logging without having to modify <code>my_app.py</code> or write a wrapper!</p>
<p>Now if you want to know <em>why</em> this is the optimal approach, keep on reading.</p>
<h1>(Really) long answer</h1>
<p>Before understanding why using a virtualenv + <code>sitecustomize.py</code> is the correct approach
to this problem, we need to make a not so short introduction.</p>
<p><em>Note</em>: I am going to assume that you create virtual environments using the
<a href="https://github.com/python/cpython/tree/master/Lib/venv" rel="nofollow noreferrer"><code>venv</code></a> module which uses
stdlib's <a href="https://github.com/python/cpython/blob/master/Lib/site.py" rel="nofollow noreferrer"><code>site.py</code></a>.  The
<a href="https://github.com/pypa/virtualenv" rel="nofollow noreferrer"><code>virtuaelnv</code></a> library, uses its own
<a href="https://github.com/pypa/virtualenv/blob/master/virtualenv_embedded/site.py" rel="nofollow noreferrer"><code>site.py</code></a>
and  might be doing things slighly differently. Nevertheless, after reading this answer
you should be able to examine if there are any differences between <code>venv</code> and
<code>vitualenv</code> and understand how to handle them.</p>
<h3>What are <code>site-packages</code></h3>
<p>The short answer is that <code>site-packages</code> is the place where python installs 3rd party
code (as in non-stdlib code). For more info read
<a href="https://stackoverflow.com/questions/31384639/what-is-pythons-site-packages-directory">this</a>
and the provided links.</p>
<h3>How to inject code?</h3>
<p>Python does allow you to customize the python interpreter while it starts up, i.e.
before our main code/script/whatever gets executed.  This can be useful for e.g.:</p>
<ul>
<li><a href="https://nedbatchelder.com/blog/201001/running_code_at_python_startup.html" rel="nofollow noreferrer">code-coverage</a></li>
<li>profilers</li>
<li>and to generally inject code, as we need to do for this question.</li>
</ul>
<p>The way you achieve the injection is by creating/modyfing either <code>sitecustomize.py</code> or
<code>usercustomize.py</code>.  You can also use a "path configuration file" (i.e. <code>*.pth</code>) file
with an import statement but I will not cover this case here since:</p>
<ul>
<li>These import statements feel like a terrible hack</li>
<li>I am not convinced that it offers any real advantage compared to
<code>sitecustomize</code>/<code>usercustomize</code>.</li>
<li>I would like to keep things simple</li>
</ul>
<p>Anyway, if you need more info WRT to path configuration files you can check
<a href="https://pymotw.com/3/site/index.html#path-configuration-files" rel="nofollow noreferrer">PyMOTW</a> and if you want
an example of using them with import statement check this <a href="https://nedbatchelder.com/blog/201001/running_code_at_python_startup.html" rel="nofollow noreferrer">blog
post</a>.</p>
<h3><code>sitecustomize</code> &amp; <code>usercustomize</code></h3>
<p>So, <code>sitecustomize</code> and <code>usercustomize</code> are special files that don't exist by default,
but if we create them python will automatically import them before it starts to execute
our code.  We can create these files:</p>
<ul>
<li>either on the global site-packages (e.g. <code>/usr/lib/python3.7/site-packages/</code>)</li>
<li>or on the user site-packages (e.g. <code>~/.local/lib/python3.7/site-packages/</code>)</li>
</ul>
<p><code>sitecustomize</code> is always imported before <code>usercustomize</code>.  If either file is missing,
the <code>ImportError</code> is silently ignored.</p>
<p>As a security precaution, if there is a mismatch between user or group id and the
effective id, then user site-packages are disabled
(<a href="https://docs.python.org/3/library/site.html#site.ENABLE_USER_SITE" rel="nofollow noreferrer">source</a>).
Moreover, the python interpreter has CLI arguments that either <a href="https://docs.python.org/3/using/cmdline.html#id3" rel="nofollow noreferrer">completely disable
site-packages</a> (both system and user
ones) or <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-s" rel="nofollow noreferrer">disable user
site-packages</a>. Assuming that
we don't have an id mismatch and that we don't use any CLI flags, then user
site-packages have higher priority than system site-packages. So if we have both:</p>
<pre><code>~/.local/lib/python3.7/site-packages/sitecustomize.py
/usr/lib/python3.7/site-packages/sitecustomize.py
</code></pre>
<p>the first one is the one that will be imported.  We can actually check the sys.path
priority by executing the <code>site.py</code> module:</p>
<pre class="lang-sh prettyprint-override"><code>$ python3 -msite

sys.path = [
    '/tmp/test',
    '/usr/lib/python37.zip',
    '/usr/lib/python3.7',
    '/usr/lib/python3.7/lib-dynload',
    '/home/username/.local/lib/python3.7/site-packages',      # user site-packages
    '/usr/lib/python3.7/site-packages',                       # system site-packages
]
USER_BASE: '/home/username/.local' (exists)
USER_SITE: '/home/username/.local/lib/python3.7/site-packages' (exists)
ENABLE_USER_SITE: True
</code></pre>
<p>The important information here is the value of <code>ENABLE_USER_SITE</code>. If it is <code>True</code> then
user site-packages are enabled. If it <code>False</code> then we can only use global site-packages.
E.g. if we use <code>python -s</code>:</p>
<pre><code>$ python3 -s -msite

sys.path = [
    '/tmp/test',
    '/usr/lib/python37.zip',
    '/usr/lib/python3.7',
    '/usr/lib/python3.7/lib-dynload',
    '/usr/lib/python3.7/site-packages',
]
USER_BASE: '/home/username/.local' (exists)
USER_SITE: '/home/username/.local/lib/python3.7/site-packages' (exists)
ENABLE_USER_SITE: False
</code></pre>
<p>Note that in this case <code>ENABLE_USER_SITE</code> is <code>False</code>.</p>
<p>Just for completeness, let's completely disable the site-packages:</p>
<pre><code>$ python3 -S -msite

sys.path = [
    '/tmp/test',
    '/usr/lib/python37.zip',
    '/usr/lib/python3.7',
    '/usr/lib/python3.7/lib-dynload',
]
USER_BASE: '/home/username/.local' (exists)
USER_SITE: '/home/username/.local/lib/python3.7/site-packages' (exists)
ENABLE_USER_SITE: None
</code></pre>
<h3>Experiment</h3>
<p>In order to better understand this, let's do an experiment. First let's create
<code>usercustomize</code> <code>sitecustomize</code> modules in both system and user site-packages.</p>
<p><strong>WARNING</strong>: We will be creating files in system site-packages. This will be
interfering with your python distribution. <strong>Be careful</strong> and <strong>REMEMBER</strong> to remove
them when we are done.</p>
<pre class="lang-sh prettyprint-override"><code># system site packages
echo 'print(f"-&gt; {__file__}")' | sudo tee /usr/lib/python3.7/site-packages/usercustomize.py
echo 'print(f"-&gt; {__file__}")' | sudo tee /usr/lib/python3.7/site-packages/sitecustomize.py

# user site packages
echo 'print(f"-&gt; {__file__}")' | tee ~/.local/lib/python3.7/site-packages/usercustomize.py
echo 'print(f"-&gt; {__file__}")' | tee ~/.local/lib/python3.7/site-packages/sitecustomize.py
</code></pre>
<p>Let's also create a python module:</p>
<pre class="lang-sh prettyprint-override"><code>echo 'print("Inside foo")' | tee foo.py
</code></pre>
<p>Now let's execute <code>foo.py</code>:</p>
<pre class="lang-sh prettyprint-override"><code>$ python3 foo.py

-&gt; /home/username/.local/lib/python3.7/site-packages/sitecustomize.py
-&gt; /home/username/.local/lib/python3.7/site-packages/usercustomize.py
Inside foo
</code></pre>
<p>As we can see:</p>
<ul>
<li><em>both</em> <code>sitecustomize</code> and <code>usercustomize</code> are being imported</li>
<li>they are being imported from <em>user site-packages</em></li>
</ul>
<p>Now what will happen if we disable user site-packages?</p>
<pre class="lang-sh prettyprint-override"><code>$ python3 -s foo.py

-&gt; /usr/lib/python3.7/site-packages/sitecustomize.py
Inside foo
</code></pre>
<p>This time we see that we:</p>
<ul>
<li><strong>only</strong> <code>sitecustomize</code> is being imported. Even though <code>usercustomize</code> exists in
system site-packages python does not import it! This is important! Keep it mind for when
we discuss virtualenvs! (TIP: this has to do with <code>ENABLE_USER_SITE</code>; do you remember
what value does it have in this case?)</li>
<li><code>sitecustomize</code> is being imported from system site-packages</li>
</ul>
<p>Finally, if we completely disable site-packages, obviously <code>usercustomize</code> and
<code>sitecustomize</code> will be ignored:</p>
<pre class="lang-sh prettyprint-override"><code>$ python3 -S foo.py

Inside foo
</code></pre>
<h3>What about virtualenvs?</h3>
<p>OK, now let's bring virtualenv's into the game too. There are two types of virtualenvs:</p>
<ul>
<li>the normal ones</li>
<li>those created with <code>--system-site-packages</code>.</li>
</ul>
<p>Let's create virtualenvs of both types</p>
<pre class="lang-sh prettyprint-override"><code>python3 -mvenv venv_no_system
python3 -mvenv venv_system
</code></pre>
<p>Let's also create <code>sitecustomize.py</code> and <code>usercustomize.py</code> modules into the
virtualenv's site-packages:</p>
<pre class="lang-sh prettyprint-override"><code>echo 'print(f"-&gt; {__file__}")' | tee ./venv_no_system/lib/python3.7/site-packages/usercustomize.py
echo 'print(f"-&gt; {__file__}")' | tee ./venv_no_system/lib/python3.7/site-packages/sitecustomize.py

echo 'print(f"-&gt; {__file__}")' | tee ./venv_system/lib/python3.7/site-packages/usercustomize.py
echo 'print(f"-&gt; {__file__}")' | tee ./venv_system/lib/python3.7/site-packages/sitecustomize.py
</code></pre>
<p>and let's see the differences:</p>
<pre><code>$ ./venv_no_system/bin/python -msite

/tmp/test/venv_no_system/lib/python3.7/site-packages/sitecustomize.py
sys.path = [
    '/tmp/test',
    '/usr/lib/python37.zip',
    '/usr/lib/python3.7',
    '/usr/lib/python3.7/lib-dynload',
    '/tmp/test/venv_no_system/lib/python3.7/site-packages',
]
USER_BASE: '/home/username/.local' (exists)
USER_SITE: '/home/username/.local/lib/python3.7/site-packages' (exists)
ENABLE_USER_SITE: False
</code></pre>
<p>What do we see here? That on <strong>normal</strong> virtualenv's <code>ENABLE_USER_SITE</code> is <code>False</code>,
which means that:</p>
<ol>
<li>user site-packages are being ignored</li>
<li><strong>only</strong> <code>sitecustomize</code> is being imported! I.e. we can't use <code>usercustomize</code> to
inject code!!!</li>
</ol>
<p>We can also see that instead of our global site-packages, the virtualenv is using its
own one (i.e. <code>/tmp/test/venv_no_system/lib/python3.7/site-packages</code>).</p>
<p>Now let's repeat this but this time with the virtualenv that <em>uses</em> the system
site-packages:</p>
<pre><code>$ ./venv_system/bin/python -msite

-&gt; /home/username/.local/lib/python3.7/site-packages/sitecustomize.py
-&gt; /home/username/.local/lib/python3.7/site-packages/usercustomize.py
sys.path = [
    '/tmp/test',
    '/usr/lib/python37.zip',
    '/usr/lib/python3.7',
    '/usr/lib/python3.7/lib-dynload',
    '/tmp/test/venv_system/lib/python3.7/site-packages',
    '/home/username/.local/lib/python3.7/site-packages',
    '/usr/lib/python3.7/site-packages',
]
USER_BASE: '/home/username/.local' (exists)
USER_SITE: '/home/username/.local/lib/python3.7/site-packages' (exists)
ENABLE_USER_SITE: True
</code></pre>
<p>In this case, the behavior is different...</p>
<p><code>ENABLE_USER_SITE</code> is <code>True</code> which means:</p>
<ol>
<li>that user site-packages are being enabled</li>
<li>that <code>usercustomize</code> is being imported normally.</li>
</ol>
<p>But there is also one more difference. In this case we have <strong>3</strong> site-packages
directories.  The virtualenv one is the one with the higher priority followed by the
user site-packages while the system site-packages is the last one.</p>
<h3>So what to use?</h3>
<p>I think that there are three options:</p>
<ol>
<li>use the system python installation</li>
<li>use a normal virtualenv</li>
<li>use a virtualenv with system site-packages</li>
</ol>
<p>I think that in the majority of the cases, e.g. on normal servers/desktops, modifying
the system python installation should generally be avoided. At least on *nix, too many
things depend on Python. I would be really reluctant to change its behavior. Possible
exceptions are ephemeral or static "systems" (e.g.  inside a container).</p>
<p>As far as virtual environments go, unless we know we are going to need system
site-packages, I think it makes sense to stick with the current practise and use normal
ones.  If we adhere to this, then in order to inject code before our script gets
executed we only have one option:</p>
<blockquote>
<p>To add a <code>sitecustomize.py</code> in the virtuaelenv's site packages.</p>
</blockquote>
<h3>Cleaning up</h3>
<pre><code># remove the virtualenvs
rm -rf my_venv
rm -rf venv_system
rm -rf venv_no_system

# remove our usercustomize.py and sitecustomize.py
sudo rm /usr/lib/python3.7/site-packages/sitecustomize.py
sudo rm /usr/lib/python3.7/site-packages/usercustomize.py
rm ~/.local/lib/python3.7/site-packages/sitecustomize.py
rm ~/.local/lib/python3.7/site-packages/usercustomize.py

# remove the modules
rm foo.py
rm my_app.py
</code></pre>
</div>
<span class="comment-copy">I updated my answer.</span>
<span class="comment-copy">You have 2 "topics" here: one is to modify the logging from that third party (which I believe is addressed in one of the solutions proposed); the other one is how (what you refer as strategy) you apply that solution. Can you confirm if one of the proposed solution works (or none works and why)?</span>
<span class="comment-copy">@TocToc I updated the question to emphasis what is important in this question. Up to now I see only answer which works. But I would like to see a better one.</span>
<span class="comment-copy">In that case wouldn't it be better to re-qualify that questions as "Configure the logging of a running python service or script"? (I assume the script or service is already running, is it correct?)</span>
<span class="comment-copy">@TocToc it is a script which you can call from the shell or via cron. There is no service involved in this context.</span>
<span class="comment-copy">That is supposing the file is actually called "foo.py" I assume the OP just doesn't want to share the name of his module/file. And is therefore using the Anonymous <code>__name__</code>. Clearly he must replace that with the correct log handler.</span>
<span class="comment-copy">Quoting from the answer: "A library isn't supposed to configure logging - that's up to the application developer". What's an "application developer"? I think configuring the logging needs to be done by an operator (the "op" part of "devop"). But maybe I am wrong.</span>
<span class="comment-copy">How can I execute <code>logging.getLogger('foo').setLevel(logging.WARNING)</code> without modifying or wrapping the third-party code?</span>
<span class="comment-copy">In order to use a virtualenv you need to either use <code>sitecustomize.py</code> or to use <code>--system-site-packages</code> when you create the virtualenv. On "normal" virtualenvs, <code>usercustomize.py</code> is not being imported. For details check my answer.</span>
<span class="comment-copy">I would like to avoid to write wrapper.</span>
<span class="comment-copy">Normally your wrapper is as simple as the code above where you import "*" form the third party lib. But you could also include it in your own python code (you would not need a wrapper then). But I think we are missing some element in your description: Are you trying to modify the module logging after this is started via the cron job?</span>
<span class="comment-copy">you said "Are you trying to modify the module logging after this is started via the cron job?". What you said is a "strategy". Up to now I have only a goal, and I don't care which strategy gets used to get to the goal. My goal: I don't want to write a wrapper, and I want to configure the logging of code which I won't modify.</span>
<span class="comment-copy">2 questions still:   - Although this should not matter, I would like to know which third party lib are we talking about?  - Is it ok to change the call command from your cron table?</span>
<span class="comment-copy">why do you want to which third party script I am talking about? For me it does not matter at all. Call it "say_om", "have_fun" or "some_fundamentals_are_not_solved_yet".</span>
<span class="comment-copy">How can I execute <code>logging.Formatter()</code> without modifying or wrapping the third-party code?</span>
<span class="comment-copy">Do it from <i>your</i> script. The one that calls the other.</span>
<span class="comment-copy">The third party script gets called via cron.</span>
<span class="comment-copy">There is no way to modify the logging behavior of a script without being able to access it. you <b><i>must</i></b> wrap/embed the "third-party-script" with your own code. You can have the cron activate your own script which wraps the third-party one.</span>
<span class="comment-copy">You need to hook into the main Python process that is running the third-party script in order to access its logging module.</span>
