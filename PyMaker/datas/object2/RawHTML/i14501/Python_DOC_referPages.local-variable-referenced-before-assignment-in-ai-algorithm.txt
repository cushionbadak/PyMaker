<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/370357/python-variable-scope-error">Python variable scope error</a>
<span class="question-originals-answer-count">
                    11 answers
                </span>
</li>
</ul>
</div>
<p>The following code gives the error <code>UnboundLocalError: local variable 'Var1' referenced before assignment</code>:</p>
<pre><code>Var1 = 1
Var2 = 0
def function(): 
    if Var2 == 0 and Var1 &gt; 0:
        print("Result One")
    elif Var2 == 1 and Var1 &gt; 0:
        print("Result Two")
    elif Var1 &lt; 1:
        print("Result Three")
    Var1 =- 1
function()
</code></pre>
<p>How can I fix this? Thanks for any help!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can fix this by passing parameters rather than relying on Globals</p>
<pre><code>def function(Var1, Var2): 
    if Var2 == 0 and Var1 &gt; 0:
        print("Result One")
    elif Var2 == 1 and Var1 &gt; 0:
        print("Result Two")
    elif Var1 &lt; 1:
        print("Result Three")
    return Var1 - 1
function(1, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is because, even though <code>Var1</code> exists, you're also using an assignment statement on the name <code>Var1</code> inside of the function (<code>Var1 -= 1</code> at the bottom line). Naturally, this creates a variable inside the function's scope called <code>Var1</code> (truthfully, a <code>-=</code> or <code>+=</code> will only update (reassign) an existing variable, but for reasons unknown (likely consistency in this context), Python treats it as an assignment). The Python interpreter sees this at module load time and decides (correctly so) that the global scope's <code>Var1</code> should not be used inside the local scope, which leads to a problem when you try to reference the variable before it is locally assigned.</p>
<p>Using global variables, outside of necessity, is usually frowned upon by Python developers, because it leads to confusing and problematic code. However, if you'd like to use them to accomplish what your code is implying, you can simply add:</p>
<pre><code>global Var1, Var2
</code></pre>
<p>inside the top of your function. This will tell Python that you don't intend to define a <code>Var1</code> or <code>Var2</code> variable inside the function's local scope. The Python interpreter sees this at module load time and decides (correctly so) to look up any references to the aforementioned variables in the global scope.</p>
<h3>Some Resources</h3>
<ul>
<li>the Python website has a <a href="https://docs.python.org/3/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" rel="noreferrer">great explanation</a> for this common issue.</li>
<li>Python 3 offers a related <a href="https://docs.python.org/3/reference/simple_stmts.html#nonlocal" rel="noreferrer"><code>nonlocal</code></a> statement - check that out as well.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>If you set the value of a variable inside the function, python understands it as creating a local variable with that name. This local variable masks the global variable.</p>
<p>In your case, <code>Var1</code> is considered as a local variable, and it's used before being set, thus the error.</p>
<p>To solve this problem, you can explicitly say it's a global by putting <code>global Var1</code> in you function.</p>
<pre><code>Var1 = 1
Var2 = 0
def function():
    global Var1
    if Var2 == 0 and Var1 &gt; 0:
        print("Result One")
    elif Var2 == 1 and Var1 &gt; 0:
        print("Result Two")
    elif Var1 &lt; 1:
        print("Result Three")
    Var1 =- 1
function()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't like this behavior, but this is how Python works. The question has already been answered by others, but for completeness, let me point out that Python 2 has more such quirks.</p>
<pre><code>def f(x):
    return x

def main():
    print f(3)
    if (True):
        print [f for f in [1, 2, 3]]

main()
</code></pre>
<p>Python 2.7.6 returns an error:</p>
<pre><code>Traceback (most recent call last):
  File "weird.py", line 9, in &lt;module&gt;
    main()
  File "weird.py", line 5, in main
    print f(3)
UnboundLocalError: local variable 'f' referenced before assignment
</code></pre>
<p>Python sees the <code>f</code> is used as a local variable in <code>[f for f in [1, 2, 3]]</code>, and decides that it is also a local variable in <code>f(3)</code>. You could add a <code>global f</code> statement:</p>
<pre><code>def f(x):
    return x

def main():
    global f
    print f(3)
    if (True):
        print [f for f in [1, 2, 3]]

main()
</code></pre>
<p>It does work; however, <em>f becomes 3 at the end...</em> That is, <code>print [f for f in [1, 2, 3]]</code> now changes the global variable <code>f</code> to <code>3</code>, so it is not a function any more.</p>
<p>Fortunately, it works fine in Python3 after adding the parentheses to <code>print</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not simply return your calculated value and let the caller modify the global variable. It's not a good idea to manipulate a global variable within a function, as below:</p>
<pre><code>Var1 = 1
Var2 = 0

def function(): 
    if Var2 == 0 and Var1 &gt; 0:
        print("Result One")
    elif Var2 == 1 and Var1 &gt; 0:
        print("Result Two")
    elif Var1 &lt; 1:
        print("Result Three")
    return Var1 - 1

Var1 = function()
</code></pre>
<p>or even make local copies of the global variables and work with them and return the results which the caller can then assign appropriately</p>
<pre><code>def function():
v1, v2 = Var1, Var2
# calculate using the local variables v1 &amp; v2
return v1 - 1

Var1 = function()
</code></pre>
</div>
<span class="comment-copy">I think you should update the accepted answer to give credit where it's due.</span>
<span class="comment-copy">I think orokusaki's answer should be used instead. The accepted answer only says what to do instead and is not descriptive enough to describe this issue, why it's a problem, why not to do it, and if you really wanted to do it, how to actually do it.</span>
<span class="comment-copy">Notice that it will work if you use <code>dic = {'Var1':1, 'Var2':0}</code> and access Var1 and Var2 through the dictionary.</span>
<span class="comment-copy">I think this simple sample code just shows the issue. The specific solution is not clear enough for such a case.</span>
<span class="comment-copy">This should be the accepted answer, not only the solution is given but also explains the reason to cause the error</span>
<span class="comment-copy">@user7344209 Indeed. Answers should ideally explain what's happening in the actual example shown, and how to fix that, rather than suggesting a whole different approach.</span>
