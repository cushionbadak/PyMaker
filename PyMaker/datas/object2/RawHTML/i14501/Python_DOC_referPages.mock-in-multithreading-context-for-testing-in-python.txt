<div class="post-text" itemprop="text">
<p>In a Django project, I would like to write a test for a function that is used in a multiprocessing context (Processing.create_all_files). If I were using a single thread, I would do 'mock' in order to check the parameters used for calling a given function (FileCreator.create in my case).</p>
<p>However, once the function FileCreator.create is called by a multiprocessing.Pool, mock does not work anymore with it.</p>
<p>How should I do my test for create_all_files? Thanks.</p>
<p><code>test_program.py</code>:</p>
<pre><code>def test_create_all_files(self):
    file_paths = [ (...) ] # Initialize file_paths
    processing = Processing()
        with mock.patch('FileCreator.create', return_value=True) as create:
            with mock.patch('os.path.isfile', return_value=False):
                processing.create_all_files()
                calls = create.call_args_list

        for file_path in file_paths:
            self.assertTrue(((file_path),) in calls)


program.py

def unwrap_self_create_one_file(arg):
    return Processing.process_one_file(*arg)

class Processing:
    (...)

    def create_one_file(self, file_path):
       if os.path.isfile(file_path):
        FileCreator.create(file_path) # CREATE FILE

        def create_all_files(file_paths):
       (...) # define args_lst considering file_paths
       ncpus = 4
           pool = multiprocessing.Pool(ncpus)
           pool.map(unwrap_create_one_file, args_lst, chunksize=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your issue have nothing to do with multithreading but it is more related on 
<a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow">Where to patch</a>.</p>
<p>In your test you use <code>FileCreator.create(file_path)</code> to create your file object so I guess you have something like <code>from mymodule import FileCreator</code> in <code>program.py</code>.</p>
<p>What you should do in these case is <code>patch</code> the <code>FileCreator</code> reference in <code>program</code> by:</p>
<pre><code>with mock.patch('program.FileCreator.create', return_value=True) as create:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After adding multithreading you risk your 'patch' to go out of scope, in other words, when executing <code>FileCreator.create</code> on a different thread chances are the <code>with patch()</code> statement has ended.</p>
</div>
<span class="comment-copy">Ok! Thanks. I misunderstood the point related to 'Where to patch'... now I wonder why it worked before adding multithreading support.</span>
<span class="comment-copy">Even when using the @patch.object annotation on a test method, the thread could run when the test method has ended so it is necessary to join threads inside the test method.</span>
