<div class="post-text" itemprop="text">
<p>Can magic methods be overridden outside of a class?
When I do something like this</p>
<pre><code>def __int__(x):
    return x + 5

a = 5
print(int(a))
</code></pre>
<p>it prints '5' instead of '10'. Do I do something wrong or magic methods just can't be overridden outside of a class?</p>
</div>
<div class="post-text" itemprop="text">
<p>Short answer; not really.</p>
<p>You cannot arbitrarily change the behaviour of <code>int()</code> a builtin function (*which internally calls <code>__int__()</code>)  on arbitrary builtin types such as <code>int</code>(s).</p>
<p>You <strong>can</strong> however change the behaviour of custom objects like this:</p>
<p><strong>Example:</strong></p>
<pre><code>class Foo(object):

    def __init__(self, value):
        self.value = value

    def __add__(self, other):
        self.value += other

    def __repr__(self):
        return "&lt;Foo(value={0:d})&gt;".format(self.value)
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; x = Foo(5)
&gt;&gt;&gt; x + 5
&gt;&gt;&gt; x
&lt;Foo(value=10)&gt;
</code></pre>
<p>This overrides two things here and implements two special methods:</p>
<ul>
<li><code>__repr__()</code> which get called by <code>repr()</code></li>
<li><code>__add__()</code> which get called by the <code>+</code> operator.</li>
</ul>
<p><strong>Update:</strong> As per the comments above; techincally you can redefine the builtin function <code>int</code>; Example:</p>
<pre><code>def int(x):
    return x + 5

int(5)  # returns 10
</code></pre>
<p><em>However</em> this is not recommended and does not change the overall behaviour of the object <code>x</code>.</p>
<p><strong>Update #2:</strong> The reason you cannot change the behaviour of bultin types (<em>without modifying the underlying source or using <a href="https://pypi.python.org/pypi/Cython/" rel="nofollow">Cuthon</a> or <a href="https://docs.python.org/2/library/ctypes.html" rel="nofollow">ctypes</a></em>) is because builtin types in Python are not exposed or mutable to the user unlike <a href="http://c2.com/cgi/wiki?HomoiconicLanguages" rel="nofollow">Homoiconic Languages</a> (<em>See: <a href="http://en.wikipedia.org/wiki/Homoiconicity" rel="nofollow">Homoiconicity</a></em>). -- Even then I'm not really sure you can with Cython/ctypes; but the reason question is "Why do you want to do this?"</p>
<p><strong>Update #3:</strong> See Python's documentation on <a href="https://docs.python.org/3/reference/datamodel.html#object.__complex__" rel="nofollow">Data Model</a> (<em><code>object.__complex__</code> for example</em>).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can redefine a top-level <code>__int__</code> function, but nobody ever calls that.</p>
<p>As implied in the <a href="https://docs.python.org/3/reference/datamodel.html#object.__complex__" rel="nofollow">Data Model</a> documentation, when you write <code>int(x)</code>, that calls <code>x.__int__()</code>, not <code>__int__(x)</code>.</p>
<p>And even that isn't really true. First, <code>__int__</code> is a special method, meaning it's allowed to call <code>type(x).__int__(x)</code> rather than <code>x.__int__()</code>, but that doesn't matter here. Second, it's not required to call <code>__int__</code> unless you give it something that isn't already an <code>int</code> (and call it with the one-argument form). So, it could be as if it's was written like this:</p>
<pre><code>def int(x, base=None):
    if base is not None:
        return do_basey_stuff(x, base)
    if isinstance(x, int):
        return x
    return type(x).__int__(x)
</code></pre>
<p>So, there is no way to change what <code>int(5)</code> will do… short of just shadowing the builtin <code>int</code> function with a different builtin/global/local function of the same name, of course.</p>
<p>But what if you wanted to, say, change <code>int(5.5)</code>? That's not an <code>int</code>, so it's going to call <code>float.__int__(5.5)</code>. So, all we have to do is monkeypatch that, right?</p>
<p>Well, yes, except that Python allows builtin types to be immutable, and most of the builtin types in CPython are. So, if you try it:</p>
<pre><code>&gt;&gt;&gt; _real_float_int = float.__int__
&gt;&gt;&gt; def _float_int(self):
...     return _real_float_int(self) + 5
&gt;&gt;&gt; _float_int(5.5)
10
&gt;&gt;&gt; float.__int__ = _float_int
TypeError: can't set attributes of built-in/extension type 'float'
</code></pre>
<p>However, if you're defining your <em>own</em> types, that's a different story:</p>
<pre><code>&gt;&gt;&gt; class MyFloat(float):
...     def __int__(self):
...         return super().__int__() + 5
&gt;&gt;&gt; f = MyFloat(5.5)
&gt;&gt;&gt; int(f)
10
</code></pre>
</div>
<span class="comment-copy">This seems to work: <code>def int(x): return x + 5</code>. Not recommended however..</span>
<span class="comment-copy">@user2864740: There's an <code>__int__</code> special method. <a href="http://ideone.com/8DqvuN" rel="nofollow noreferrer">Try it!</a></span>
<span class="comment-copy">Documented <a href="https://docs.python.org/3/reference/datamodel.html#object.__complex__" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">why I can redefine int() function, but can't redefine __int__()?</span>
<span class="comment-copy">@trollpidor: My answer explains why you can't redefine <code>__int__</code>—or, rather, why you <i>can</i> redefine the ones that don't matter, but not the ones that do.</span>
<span class="comment-copy">If you only care about one specific version of CPython, you probably <i>can</i> mutate the <code>int</code> type using <code>ctypes.pythonapi</code> and a solid understanding of the C API and a willingness to debug segfaults. But it's actually a lot easier to just change the value of <code>5</code> into <code>10</code>. :)</span>
<span class="comment-copy">I couldn't agree more :) Haha!</span>
<span class="comment-copy">By the way, I'm not sure homoiconicity is the issue here. Common Lisp systems, emacs-lisp, etc. have different builtin-function and function types, but their function types are just data and can be manipulated without having to decompile and recompile and so on; does that mean they're not homoiconic? And if Lisp isn't homoiconic, what is?</span>
<span class="comment-copy">So glad I was right about not being able to mutate builtin types :) (<i>their default behaviours that is</i>).</span>
