<div class="post-text" itemprop="text">
<p>I've stumbled across some odd python (2.7) import behaviour, which, whilst easy to work around, has me scratching my head.</p>
<p>Given the following folder structure:</p>
<pre><code>test/
    __init__.py
    x.py
    package/
        __init__.py
        x.py
</code></pre>
<p>Where test/package/__init__.py contains the following</p>
<pre><code>from .. import x
print x
from .x import hello
print x
print x.hello
</code></pre>
<p>And test/package/x.py contains the following</p>
<pre><code>hello = 1
</code></pre>
<p>Why would running <code>import test.package</code> from a REPL result in the following output?</p>
<pre><code>&lt;module 'test.x' from 'test/x.pyc'&gt;
&lt;module 'test.package.x' from 'test/package/x.pyc'&gt;
1
</code></pre>
<p>I would have expected <code>x</code> to reference the top level <code>x</code> module, however what the second import does instead, is to import the whole local <code>x</code> module (not just <code>hello</code> as I expected), effectively trampling on the first import.</p>
<p>Can anyone explain the mechanics of the import here?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>from .x import name</code> realizes that <code>test.package.x</code> needs to be a module. It then checks the corresponding entry in <code>sys.modules</code>; if it is found there, then <code>sys.modules['test.package.x'].hello</code> is imported into the calling module.</p>
<p>However, if <code>sys.modules['test.package.x']</code> does not exist yet, the module is loaded; and as the last step of loading the <code>sys.modules['test.package'].x</code> is set to point to the newly loaded module, even if you explicitly did not ask for it. Thus the second import overrides the name of the first import.</p>
<p>This is by design, otherwise</p>
<pre><code>import foo.bar.baz
foo.bar.baz.x()
</code></pre>
<p>and</p>
<pre><code>from foo.bar import baz
baz.x() 
</code></pre>
<p>wouldn't be interchangeable.</p>
<hr/>
<p>I am unable to find good documentation on this behaviour in the Python 2 documentation, but the <a href="https://docs.python.org/3/reference/import.html#submodules" rel="nofollow">Python 3 behaviour</a> is essentially the same in this case:</p>
<blockquote>
<p>When a submodule is loaded using any mechanism (e.g. <code>importlib</code> APIs, the <code>import</code> or <code>import</code>-<code>from</code> statements, or built-in  <code>__import__()</code>) a binding is placed in the parent module’s namespace to the submodule object. For example, if package <code>spam</code> has a submodule <code>foo</code>, after importing <code>spam.foo</code>, <code>spam</code> will have an attribute <code>foo</code> which is bound to the submodule.</p>
<p><em>[...]</em></p>
<p>The invariant holding is that if you have <code>sys.modules['spam']</code> and <code>sys.modules['spam.foo']</code> (as you would after the above import), the latter must appear as the <code>foo</code> attribute of the former.</p>
</blockquote>
</div>
<span class="comment-copy">What makes you think the first import brought in one <code>x</code> and the second replaced it with a different <code>x</code>? There's nothing in your code or description that tests or demonstrates that.</span>
<span class="comment-copy">actually I think OP is right</span>
<span class="comment-copy">@AnttiHaapala he could be, but he hasn't actually tested that (e.g., by <code>print x</code> before and after the second <code>import</code>)</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/29974455/why-might-pythons-the-from-form-of-an-import-statement-bind-a-module-name" title="why might pythons the from form of an import statement bind a module name">stackoverflow.com/questions/29974455/…</a></span>
<span class="comment-copy">abarnert, when I alter the code to add a print before the second import, it does highlight the expected module is imported  FIRST: &lt;module 'test.x' from 'test/x.pyc'&gt; SECOND: &lt;module 'test.package.x' from 'test/package/x.pyc'&gt;</span>
