<div class="post-text" itemprop="text">
<p>I have a dictionary as follows:-</p>
<pre><code>dict={'a':'1','b':'2', 'c':'3'}
</code></pre>
<p>To convert it into into a comma separated keys string <code>key_string</code> and a comma separated values string <code>val_string</code> I do the following:-</p>
<pre><code>key_list=[]
val_list=[]

 for key,value in dict.iteritems():
     key_list.append(key)
     val_list.append(value)

 key_string = ','.join(key_list)
 val_string = ','.join(val_list)
</code></pre>
<p>The result is</p>
<pre><code> key_string = "a,b,c"
 val_string = "1,2,3" 
</code></pre>
<p>Is there a more efficient/elegant way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow"><code>str.join(iterable)</code></a> (Hint: don't name your dict <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="nofollow"><code>dict</code></a>):</p>
<pre><code>d = {'a':'1', 'b':'2', 'c':'3'}
print(",".join(d.keys()))
print(",".join(d.values()))
</code></pre>
<p>Output:</p>
<pre><code>c,a,b
3,1,2
</code></pre>
<p>Note that a dictionary has no order. So the output does not have any order you can rely on, too.</p>
</div>
<div class="post-text" itemprop="text">
<p>The obvious solution is to just use <code>iterkeys</code> and <code>itervalues</code> instead of <code>iteritems</code>:</p>
<pre><code>key_string = ','.join(d.iterkeys())
val_string = ','.join(d.itervalues())
</code></pre>
<p>If you're worried about the keys and values showing up in different orders, while Python allows dicts to iterate in any order they want, it does document <a href="https://docs.python.org/2/library/stdtypes.html#dict.items" rel="nofollow">here</a> that if you iterate them over and over without doing anything else between you will get the same order:</p>
<blockquote>
<p>If <code>items()</code>, <code>keys()</code>, <code>values()</code>, <code>iteritems()</code>, <code>iterkeys()</code>, and <code>itervalues()</code> are called with no intervening modifications to the dictionary, the lists will directly correspond.</p>
</blockquote>
<p>(The 2.7 docs were never updated to say so, but it's also true for <code>viewitems</code>, <code>viewkeys</code>, and <code>viewvalues</code>.)</p>
<hr/>
<p>At least in CPython, it will probably be slightly more efficient to use <code>keys</code> and <code>values</code> instead of <code>iterkeys</code> and <code>itervalues</code> (because, when given an iterator, the CPython implementation of <code>str.join</code> just makes a list out of it), but I doubt that matters. As Padraic Cunningham points out in the comments, for the keys (but not the values), you may be able to get the same list even faster with just <code>list(d)</code> instead of <code>d.keys()</code> (although maybe notâ€”it avoids a <code>LOAD_ATTR</code> call, but at the cost of a <code>LOAD_NAME</code>, unless you've first copied <code>list</code> to a local so it can be <code>LOAD_FAST</code>ed).</p>
<hr/>
<p>Finally, if you want to do it with <code>iteritems</code> (let's say you're using a broken not-quite-compliant Python interpreter that randomizes the iteration order each time), you can use <code>zip</code> for that:</p>
<pre><code>keys, values = zip(*d.iteritems())
</code></pre>
<p>That turns a sequence of pairs into a pair of sequences.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do it like this:</p>
<pre><code>key_string = ','.join(dict.keys()) 
val_string = ','.join(dict.values())
</code></pre>
</div>
<span class="comment-copy">Do you want "efficient" or "elegant"? The two are often at cross purposes. And do you mean "efficient" as in "least time" or "least temporary space" or some other measure?</span>
<span class="comment-copy">If I tell you <code>val_string = ','.join(dict.values())</code>, I'm sure you can work out the other one...</span>
<span class="comment-copy">Something like this? ','.join(map(lambda x:str(x), [1,2]))</span>
<span class="comment-copy">Are you expecting the keys/values in any particular order?</span>
<span class="comment-copy">@AshishAcharya: That doesn't do the separating out keys and values. And <code>lambda x: str(x)</code> is just a slower and less elegant want to write <code>str</code>. And it's not necessary anyway, given that all of his keys and values are already strings.</span>
<span class="comment-copy">You could just call  "".join() on d without the call to .iterkeys although as you already said something like <code>list(d)</code> would be more efficient, also in python 3 different runs of the script can change the order of the keys and values which is different behaviour to python 2.</span>
<span class="comment-copy">@PadraicCunningham: Yeah, I suppose <code>','.join(list(d))</code> would be probably the most efficient in CPython 2.7. If anyone really cared, I'd test all the possibilities, but I doubt anyone does. At any rate, for parallelism with the <code>itervalues()</code>, I think <code>iterkeys()</code> is more readable here.</span>
<span class="comment-copy">@PadraicCunningham: As for order between runs, actually, Python has definitely never guaranteed that you'd get the same order every run. 2.7 and 3.4 have nearly identical wording for the order. It's true that CPython 3.4 uses hash randomization for strings by default, while 2.7 (and 3.3) doesn't, but then Jython 2.5 would already give you a different order in each run, and meanwhile, there's talk of having <code>dict</code> preserve insertion order by default in CPython 3.5 (and maybe even requiring it for other implementations), so that's not really a Python 2 vs. Python 3 thing.</span>
<span class="comment-copy">@abarnet , I always thought on cpython 2.7 that at least  for strings and ints you would always get the same order across different runs.</span>
<span class="comment-copy">@PadraicCunningham: Yes, but that's something implementation-specific, not a 2.x-vs.-3.x difference. CPython 1.0-3.3 behave one way, CPython 3.4 behaves a different way, CPython 3.5 might behave a different way, Jython 2.2-2.5 behave a different way, I don't know about IronPython or Skulpt or etc. You should not assume that "Python 2" means "same order across runs", or that "Python 3" means "randomized order".</span>
