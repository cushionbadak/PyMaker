<div class="post-text" itemprop="text">
<p>A complicated situation:</p>
<ol>
<li><p>A Pyramid app needs to start/restart some Java processes (e.g. Jetty) sometimes (e.g. on receiving new WAR files for Jetty, etc, etc).</p></li>
<li><p>That Jetty process is expected to continue working after Pyramid process (<code>pserve</code>) quits or between Pyramid restarts.</p></li>
<li><p>Jetty process is started via <code>subprocess.Popen</code> + shell script. Naturally, being a child process, it inherits file descriptors, including sockets.</p></li>
<li><p>Now if Pyramid needs to restart while Jetty is still running, it can't do so as child Jetty process still has the socket bound to Pyramid's main address/port.</p></li>
</ol>
<p>Solution so far: </p>
<ol start="4">
<li><p>For restarting Java/Jetty, do a <code>fork</code></p></li>
<li><p>in a child process close every file descriptor &gt; 3 and &lt; <code>resource.RLIMIT_NOFILE</code>. </p></li>
<li><p>do <code>sys.exit</code> in a child process after starting/restarting Jetty.</p></li>
</ol>
<p>Neat, right? </p>
<p>No.</p>
<p>It's complicated and kludgy. Is there a simpler way of avoiding this "child process inheriting sockets" problem?</p>
<p>Plus I have services (like <code>APScheduler</code>, etc) running and that requires elaborate shutdowns of all the running services (in a child process of course) or else they raise exceptions on <code>sys.exit</code>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a simpler way of avoiding this "child process inheriting sockets" problem?</p>
</blockquote>
<p>Yes, just pass <code>close_fds=True</code> to the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow"><code>Popen</code></a> constructor or wrapper function. This closes all fds except 0, 1, and 2.<sup>*</sup></p>
<p>If you need to keep some different set alive instead of 0, 1, and 2, use <code>pass_fds=[0, 2, special_file.fileno()]</code> instead of <code>close_fds=True</code>. But hopefully you don't need that.<sup>**</sup></p>
<hr/>
<p><sub>* I'm assuming you don't care about Windows portability—after all, you're already using <code>os.fork</code>. If I'm wrong, <code>close_fds=True</code> won't work on non-POSIX systems with redirected stdio handles, so if you need both, you'll need a more complex solution.</sub></p>
<p><sub>** If you do: <code>pass_fds</code> requires 3.2+, or a backport of the 3.2+ <code>subprocess</code> module. I'm pretty sure you don't have 3.2+, because if you did, <code>close_fds=True</code> would already be the default behavior on POSIX systems, and you wouldn't have this problem in the first place. One common reason to need it for web services is when you don't have permissions to bind port 80, so you inherit a socket from a suid program, and need to pass that socket to your own child.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>IMHO, you should de-couple the process control from your web application process.  Use a process control system like <a href="http://supervisord.org/" rel="nofollow">supervisord</a> to start/stop/restart long-running applications; this can be done over <a href="http://supervisord.org/api.html" rel="nofollow">XML-RPC</a>.</p>
<p><em>Not a bad plus that Pyramid creator Chris McDonough is the primary author of Supervisor too.</em></p>
</div>
<span class="comment-copy">I am not really sure if that is what you want, but using Apache Java Services, you may run Jetty as an OS service and start/stop it as such.</span>
<span class="comment-copy">I agree with @SJuan76 -- you should definitively use an higher level API to start and stop that service. This will somehow decouple the two parts, let the "service manager" handle the messy part (start vs restart, restart abnormally terminated Jetty instance and so on...) In addition, it will take care of proper "identity management", as a plain old fork will let the child process run under the same identity (i.e.: the same permissions) as the parent process. Which might be not desirable.</span>
<span class="comment-copy">@SylvainLeroux: Well, you can handle the identity in the subprocess with <code>preexec_fn=lambda: os.setresuid(unprived_user)</code> or similar, and in the plain old fork just by calling it explicitly after <code>fork</code>, so the child code never even gets loaded by the privileged user.</span>
<span class="comment-copy">@SylvainLeroux: Basically, <code>setresuid</code> sets all three of the real, effective, and saved uid at once; it's just a convenience over the separate methods. For example, if you have effective uid of <code>pyramid</code> but saved uid of <code>root</code>, <code>setresuid(geteuid())</code> prevents the child from (ab)using that saved uid. Anyway, I agree with your general point, I just wanted to mention that it's not <i>impossible</i> to do what you need; the problem is that you have to know that you need it, and how to test it, and so forth; whoever wrote your system tools (hopefully) already thought of all that. :)</span>
<span class="comment-copy">He's not suggesting building a service manager integrated with your whole app. Just use the one that comes with your OS (upstart, systemd, launchd, …—if you prefer an alternative one to your OS's, you can install that too). Then communicate by running simple command-line calls tools (via <code>subprocess</code>) like <code>systemctl restart jetty</code> or <code>launchctl stop jetty</code> or whatever. Restarting or stopping Jetty shouldn't require passing live objects, should it?</span>
<span class="comment-copy">Unfortunately I don't have good experience using supervisord, about a year ago when it was supposed to handle many services (like dozens) it caused a lot of problems (like failing to observe some processes IIRC).</span>
<span class="comment-copy">@LetMeSOThat4U: If you don't like <code>supervisord</code>, there are a half-dozen major alternatives. Most of them don't have an RPC server built in, but they at least have something you can easily script, like a non-interactive command-line interface.</span>
