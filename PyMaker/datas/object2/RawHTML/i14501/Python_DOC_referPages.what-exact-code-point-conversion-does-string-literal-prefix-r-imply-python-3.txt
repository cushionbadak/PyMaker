<div class="post-text" itemprop="text">
<p>What Unicode code-point conversion does the stringprefix "r" (or "R") actually perform on string literals in Python 3 (literals/files parsed as UTF-8)?</p>
<p>I am using Python 3.4 on Windows 7.</p>
<p>I want to to parse this "evil" path on Windows:</p>
<pre><code>&gt;&gt;&gt; a = 'c:\a\b\f\v' 
&gt;&gt;&gt; a
'c:\x07\x08\x0c\x0b'
&gt;&gt;&gt; a.decode(encoding='utf-8')
b'c:\x07\x08\x0c\x0b'
</code></pre>
<p>With the prefix "r", I get:</p>
<pre><code>&gt;&gt;&gt; b = r'c:\a\b\f\v'
&gt;&gt;&gt; b
c:\a\b\f\v
</code></pre>
<p>My question: How do I mimic (exactly) the "raw" code-point mapping/conversion on a Unicode string object in memory (not a string literal)? I could use <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow" title="str.translate">str.translate</a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.maketrans" rel="nofollow" title="str.maketrans">str.maketrans</a>, but what exact mapping are we talking about then?</p>
<p>Context: Generally, I want to be to support all kinds of weird directory names on Windows (and other platforms) being handed to my application as strings via command line parameters. How can I?</p>
</div>
<div class="post-text" itemprop="text">
<p><em>What Unicode code-point conversion does the string prefix "r" (or "R") actually perform on string literals in Python 3 (literals/files parsed as UTF-8)?</em></p>
<p>Python 3 native strings are already UTF-8 (by default), no conversions are done with the <code>r</code> prefix.  </p>
<p><em>Without</em> the <code>r</code> prefix then conversions are done to characters prefixed <code>\</code>.  See <a href="http://en.wikipedia.org/wiki/ASCII" rel="nofollow">here</a></p>
<pre><code>\a gives the code for a bell (a - alarm)  0x07
\b gives the code for a backspace         0x08
\f is a form feed                         0x0c
\v is a vertical tab                      0x0b
</code></pre>
<p>So, if you have (what you call) weird Windows path names, then always use raw strings, or use a <code>/</code> for a directory separator instead.  However you only need to worry about those that are hard-coded because they are parsed by python, those entered by the user should be fine.</p>
<p>Edit:</p>
<p>if you do this:</p>
<pre><code>&gt;&gt;&gt; import os.path
&gt;&gt;&gt; os.path.normpath('C:\bash')
'C:\x08ash'

&gt;&gt;&gt; var = input("Enter a filename: ")
Enter a filename: C:\bash
&gt;&gt;&gt; print(var)
C:\bash
&gt;&gt;&gt; os.path.normpath(var)
'C:\\bash'
</code></pre>
<p>Double back-slashing has the same effect as using raw strings.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; 'c:\a\b\f\v'
'c:\x07\x08\x0c\x0b'
</code></pre>
<p>When you type a string literal like this <em>in Python source code</em>, you need to either double the backslashes or use <code>r</code> for a raw string.</p>
<pre><code>&gt;&gt;&gt; 'c:\\a\\b\\f\\v'
'c:\\a\\b\\f\\v'
&gt;&gt;&gt; r'c:\a\b\f\v'
'c:\\a\\b\\f\\v'

&gt;&gt;&gt; print('c:\\a\\b\\f\\v')
c:\a\b\f\v
&gt;&gt;&gt; print(r'c:\a\b\f\v')
c:\a\b\f\v
</code></pre>
<p><em>This has nothing to do with Unicode.</em> It's the Python interpreter which is evaluating backslash escape sequences in string literals.</p>
<p>This is only the case with string literals in your source code. If you read a string from the command line or from a file you don't have to worry about any of this. Python does not interpret backslashes in these cases.</p>
</div>
<span class="comment-copy">It is a <b>syntax</b>, the results are still strings. Just like you can use <code>0xFF</code> or <code>255</code> to define an integer using two different forms (hex and decimal), <code>r'...'</code> allows you to define a string value. As such there is no 'mapping' taking place here.</span>
<span class="comment-copy">The syntax disables escape sequences such as <code>\b</code> (the bell character) normally used when interpreting string literals.</span>
<span class="comment-copy">When a user enters a string on a prompt, it is not a Python string literal. It is just data. No escape sequences are interpreted that way. No paths using bell characters or form-feed characters will be used.</span>
<span class="comment-copy">@MartijnPieters Thank you for your comments, but a string literal is also just data ... Any string literal given (be it in file or console) is by default parsed as though being encoded as UTF-8 (is it not?). Actually, a string literal can be considered as a <code>bytes</code> object (it obviously not a string). I simply seek the exact functional form of what the prefix "r" does with the UTF-8 octets before decoding to a string (or what happens without it applied). Such a method should actually exist on <code>bytes</code> objects. (so this has nothing to do with unicode code-point conversion after all -- my bad).</span>
<span class="comment-copy">Using a raw string literal does nothing. The Python parser takes the <i>already decoded source text</i> and creates a Python string object from it.</span>
<span class="comment-copy">Thanks. Take a look at my comment above. It makes it a bit more clear what I seek. This whole thing originated when trying to use <code>os.path.normpath</code>, which seems to convert "\a" to "\x07".</span>
<span class="comment-copy">@OleThomsenBuus: but how are you passing the path into <code>normpath</code>?  If it is a string literal, then it is not <code>norm path</code> doing the changes, but the python parser.  See edit.</span>
<span class="comment-copy">Okay - I see your point now. This all started in an IPython Notebook running in Chrome, and I got the same in the python interpreter. I had not considered that it was the parser that was messing with me. With input(), I guess you send the individual characters through the console directly and thus avoid the parser doing stuff that it would otherwise do with a literal. Correct? :-)</span>
<span class="comment-copy">Yup, you got it.  The parser only kicks-in when the program is compiled, at runtime there is no further parsing (unless you use messy stuff like <code>exec</code> and <code>eval</code>).</span>
<span class="comment-copy">@OleThomsenBuus: sorry, I didn't flag you for my previous comment</span>
