<div class="post-text" itemprop="text">
<pre><code>text = 'how much are you pledging to spend on education?!'

p = re.compile('education?!')

print p.search(text)

None
</code></pre>
<p>But why? What's so special about a word following by multiple punctuations that makes re search not working?? I don't understand it :(</p>
</div>
<div class="post-text" itemprop="text">
<p><code>?</code> is a special character in regex, meaning "optionally match the preceding rule".  In this case, it's optionally matching "n", which is fine, but then expects the next character to be "!".</p>
<p>Instead, escape the "?" in the regex.  Now it matches "?" rather than acting as a special character.</p>
<pre><code>p = re.compile('education\?!')
</code></pre>
<p>The <a href="https://docs.python.org/3/library/re.html" rel="nofollow">docs on the <code>re</code> module</a> explain this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you don't appear to know regular expressions anyway and thus are unlikely to really want/need them, may I suggest this?</p>
<pre><code>&gt;&gt;&gt; text = 'how much are you pledging to spend on education?!'
&gt;&gt;&gt; needle = 'education?!'
&gt;&gt;&gt; start = text.index(needle)
&gt;&gt;&gt; end = start + len(needle)
&gt;&gt;&gt; start, end
(38, 49)
</code></pre>
<p>But what I really want to know is why you want start and end index. If you for example want them in order to replace that substring, there's a much better way:</p>
<pre><code>&gt;&gt;&gt; text.replace(needle, 'health care?')
'how much are you pledging to spend on health care?'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have meta characters that you want to match literally, you should use <a href="https://docs.python.org/2/library/re.html#re.escape" rel="nofollow">re.escape</a> to help you escape them by prepending a <code>\</code> to all non-alphanumerics:</p>
<pre><code>&gt;&gt;&gt; text = 'how much are you pledging to spend on education?!'
&gt;&gt;&gt; pat=re.escape(r'education?!')
&gt;&gt;&gt; pat
'education\\?\\!'
&gt;&gt;&gt; p=re.compile(pat)
&gt;&gt;&gt; p.search(text)
&lt;_sre.SRE_Match object; span=(38, 49), match='education?!'&gt;
</code></pre>
<p>This allows you to escape metacharacters in unknowns:</p>
<pre><code>&gt;&gt;&gt; [re.escape(w) for w in ('education?!', 'dog', 'cat?', 'ba\ll')]
['education\\?\\!', 'dog', 'cat\\?', 'ba\\\\ll']
</code></pre>
<p>There is a great discussion about the <a href="https://docs.python.org/3/howto/regex.html#the-backslash-plague" rel="nofollow">backslash plague</a> on the Python 3.4 re <a href="https://docs.python.org/3/howto/regex.html#regular-expression-howto" rel="nofollow">HOWTO</a></p>
<hr/>
<p>Based on comments:</p>
<pre><code>&gt;&gt;&gt; m=p.search(text)
&gt;&gt;&gt; m.span()
(38, 49)
&gt;&gt;&gt; text[38:49]
'education?!'
&gt;&gt;&gt; text[slice(*m.span())]
'education?!'
</code></pre>
</div>
<span class="comment-copy">Why do you want start and end offsets anyway? That's rather unusual, there might be a better way for what you're actually trying to achieve.</span>
<span class="comment-copy">Thanks! But span=(38, 49) and text[49] is string index out of range.....</span>
<span class="comment-copy">I thought it was because of the backslashes but it is not. Why does re.search always gives a additional position in the ending offset</span>
<span class="comment-copy">I added additional examples...</span>
