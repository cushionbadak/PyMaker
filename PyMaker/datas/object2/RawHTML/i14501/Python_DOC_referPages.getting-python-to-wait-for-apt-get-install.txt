<div class="post-text" itemprop="text">
<p>I'm trying to write a Python script that installs some packages but unfortunately it's not playing friendly with Ubuntu's <code>apt-get install</code>.</p>
<p>Here's my code:</p>
<pre><code>subprocess.Popen( 'sudo apt-get install nginx',
                   shell=True,
                   stdin=subprocess.PIPE ).communicate()
</code></pre>
<p>And here is the output:</p>
<pre><code>Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following extra packages will be installed:
  fontconfig-config fonts-dejavu-core libfontconfig1 libgd3 libjbig0
  libjpeg-turbo8 libjpeg8 libtiff5 libvpx1 libxpm4 libxslt1.1 nginx-common
  nginx-core
Suggested packages:
  libgd-tools fcgiwrap nginx-doc
The following NEW packages will be installed:
  fontconfig-config fonts-dejavu-core libfontconfig1 libgd3 libjbig0
  libjpeg-turbo8 libjpeg8 libtiff5 libvpx1 libxpm4 libxslt1.1 nginx
  nginx-common nginx-core
0 upgraded, 14 newly installed, 0 to remove and 40 not upgraded.
Need to get 2,704 kB of archives.
After this operation, 9,056 kB of additional disk space will be used.
Do you want to continue? [Y/n] Abort.
(None, None)
</code></pre>
<p>From what I understand, I believe the auto <code>Abort</code> is due to the blocking nature of the call, so it's not able to wait. Assuming that's true, how can I get around this?</p>
<p>Edit: I forgot to mention that I am well aware of the <code>-y</code> flag that may be passed to <code>apt-get</code>. I'm more interested to know whether it's possible to call a command that requires input and wait for that to complete before returning back to Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem has nothing to do with "the blocking nature of the call".</p>
<p>The <code>apt-get</code> program is waiting for input, a <code>Y</code> or <code>N</code>.</p>
<p>But you've told <code>communicate</code> to send no input and just close the input pipe as quickly as possible.</p>
<p>So, <code>apt-get</code> gets an EOF or a closed-pipe error instead of a <code>Y</code> or <code>N</code>, and it takes that as you wanting to abort.</p>
<p>What you probably want to do here is pass the appropriate arguments to <code>apt-get</code> to tell it to never ask you for confirmation. Usually you want the <code>-y</code> flag, which answers yes to anything that's not too dangerous. IIRC, there are also flags that always answer no and answer yes whenever there's a yes answer, but I could be wrong; you can <code>man apt-get</code> yourself to find out what it provides and decide which one you want.</p>
<hr/>
<p>You almost certainly don't want to just unconditionally pass a <code>y</code> and a newline to the <code>apt-get</code> process. At best, that'll do the same thing as just passing the <code>-y</code> flag. But at worst, who knows what it'll do? The <code>-y</code> flag is <em>documented</em> to answer "yes" to all safe prompts and abort on anything that can't be safely ignored; sending a <code>y</code> response to the first prompt happens to do the same thing in this one particular case on this one particular version of <code>apt-get</code>, but in another case it could very well mean "yes, reinitialize my <code>dpkg</code> database" or "yes, ignore the bad signature and install this malware" or anything else.</p>
<p>But if you really do want to do this, it's pretty easy: <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow"><code>communicate</code></a> takes an <code>input</code> parameter, and it sends whatever you pass it to the child process's input, so:</p>
<pre><code>subprocess.Popen( 'sudo apt-get install nginx',
                   shell=True,
                   stdin=subprocess.PIPE ).communicate('y\n')
</code></pre>
<hr/>
<p>But what if you can't just use <code>-y</code> or similar flags because you need to do something more complicated (drive an installation like MySQL's, or access the super cow powers)? Well, there are good ways of doing that—e.g., you can preconfigure the setup with <code>debconf-set-selections</code> and then use noninteractive mode to skip the setup screens.</p>
<p>If you really do want to try to access the output and prompts provided by both <code>apt-get</code> and individual packages and respond to them, that's doable. But it's not easy. First, you need to capture the output, by adding <code>stdout=subprocess.PIPE</code> to your <code>Popen</code>. Then, instead of calling <code>communicate</code>, you store the <code>Popen</code> in a variable, say, <code>p</code>. Then you can read from <code>p.stdout</code>, parse the responses, and respond appropriately to each prompt by writing to <code>p.stdin</code>. And then <code>p.wait()</code> at the end. But if you really want to do something like this, you're usually better off using a library like <a href="https://pexpect.readthedocs.org/en/latest/" rel="nofollow"><code>pexpect</code></a> instead of doing it manually. But the big problem is… what are you going to do with that output? Do you really want to write a parser than understands everything that <code>apt-get</code> in verbose mode prints out? And, even if you do, how are you going to know when to answer <code>'y\n'</code> or <code>'n\n'</code> or something completely different? If you can do that, you can probably just use multiple <code>apt</code> commands in non-interactive mode with a lot less effort.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try adding <strong>-y</strong> to your apt-get install command so that manual intervention is not required.</p>
<pre><code>subprocess.Popen( 'sudo apt-get -y install nginx',
                   shell=True,
                   stdin=subprocess.PIPE ).communicate()
</code></pre>
<p>This will tell the apt-get install command to automatically presume that you want to continue.</p>
</div>
<span class="comment-copy">You might read up <code>-q</code> and <code>-y</code> switches for <code>apt-get</code>.</span>
<span class="comment-copy">As a side note, if you just want to run a program in one line, without interacting with it or doing anything fancier than just <code>communicate()</code> with no args, just use the <code>check_call</code> or <code>check_output</code> helpers.</span>
<span class="comment-copy">Thanks for the detailed answer abarnert, but I'm curious if there's a way to actually allow for input rather than just bypass it.</span>
<span class="comment-copy">@smaili: Yes, although I don't think it's what you want. Let me edit the answer to explain.</span>
<span class="comment-copy">Perhaps the communication with stdin/stdout for interactive programs should be discouraged a bit more explicitly. If in the future for instance <code>apt-get</code> modifies it behavior (for instance recommending another package if <code>nginx</code> does not appear in the repository), this can lead to unwanted behavior.</span>
<span class="comment-copy">@CommuSoft: Thanks for the feedback; does the new edited version seem sufficiently scary?</span>
