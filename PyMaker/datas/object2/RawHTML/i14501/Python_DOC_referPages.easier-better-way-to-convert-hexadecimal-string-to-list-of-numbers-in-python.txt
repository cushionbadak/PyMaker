<div class="post-text" itemprop="text">
<p>My goal is to  get a 64 characters long hex number from a user (which represent a serial number) and convert to c_type 32bytes number.
Serial Number is defined like this:</p>
<pre><code>_sn =  c_ubyte * 32
</code></pre>
<p>I accept SN string from user into args.sn variable. Here's how I managed to solve it. I'm sure there is an easier and more elegant way, would appreciate your help.</p>
<pre><code>SN_List= []
for i in range(0,len(args.sn),2):
    myByte = args.sn[i: i+2]
    num = int("0x" + myByte,16)
    SN_List.append(num)

if(len(SN_List) != 32):
    print("S/N is not valid, it should be 64 hex characters long")
    return 1
_sn = (c_ubyte * 32)(*SN_List)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The very easy way, using <a href="https://docs.python.org/3/library/binascii.html" rel="nofollow"><code>binascii</code></a> (Python 3):</p>
<pre><code>import binascii

print(list(binascii.unhexlify(args.sn)))
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; list(binascii.unhexlify('09F911029D74E35BD84156C5635688C0'))
[9, 249, 17, 2, 157, 116, 227, 91, 216, 65, 86, 197, 99, 86, 136, 192]
</code></pre>
<hr/>
<p>In Python 2, you would use</p>
<pre><code>print map(ord, args.sn.decode('hex'))
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; sn = '09F911029D74E35BD84156C5635688C0'
&gt;&gt;&gt; print map(ord, sn.decode('hex'))
[9, 249, 17, 2, 157, 116, 227, 91, 216, 65, 86, 197, 99, 86, 136, 192]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Expanding on @nneonneo's comment (<a href="https://docs.python.org/3.4/library/binascii.html#binascii.unhexlify" rel="nofollow"><code>binascii.unhexlify</code></a> is equivelent to <code>binascii.a2b_hex</code>):</p>
<pre><code>_sn = (c_ubyte * 32)(*binascii.unhexlify("ffaabb"))
</code></pre>
<p>Example (with the hex <code>ffaabb</code>):</p>
<pre><code>&gt;&gt;&gt; binascii.unhexlify("ffaabb")
b'\xff\xaa\xbb'
&gt;&gt;&gt; _sn = (c_ubyte * 32)(*binascii.unhexlify("ffaabb"))
&gt;&gt;&gt; _sn
&lt;__main__.c_ubyte_Array_32 object at 0x7fe14fee8bf8&gt;
&gt;&gt;&gt; for i in _sn:
...     print(i)
... 
255
170
187
0
0
&lt;27 more zeros&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, you can use a list comprehension to eliminate most of the overhead code. Second, it's not necessary to prepend <code>0x</code> to the string when you convert to int, as long as you've specified the second parameter. Third, if you need to validate the string to make sure it contains the correct number of digits, that should be a separate step. Or perhaps you can just rely on a raised exception when things go wrong.</p>
<pre><code>SN_List = [int(args.sn[i: i+2], 16) for i in range(0, 64, 2)]
</code></pre>
</div>
<span class="comment-copy">Have you tried <code>binascii.a2b_hex</code>?</span>
<span class="comment-copy">As a side note, you don't need both the <code>"0x" +</code> and the <code>, 16</code>; one or the other will do.</span>
<span class="comment-copy">It should be almost as easy in Python 2, just with <code>map(ord, …)</code>) instead of <code>list(…)</code>.</span>
<span class="comment-copy">In Python 2, it's actually slightly easier because of <code>.decode('hex')</code>. I amended my answer.</span>
<span class="comment-copy">I never found <code>decode('hex')</code> to be any simpler than <code>unhexlify</code>. But if you really like that, you can use <code>codecs.decode(args.sn, 'hex')</code>, which works in 2.x and 3.3+.</span>
<span class="comment-copy">Wow. Amazingly easy. Thanks.</span>
<span class="comment-copy">@abarnert: I always liked it because it let me skip an import - this is important to me when doing short little things on the command-line.</span>
<span class="comment-copy">that gives what the question asks for (a byte array) in the simplest way.</span>
