<div class="post-text" itemprop="text">
<p>If I have a dictionary in a dictionary, how can I ask for a key in constant time? 
For example:</p>
<pre><code>def get_hobby(hobby):
    d = {'An' : {'Hobby': "Paintball", 'Age' : 22}, 'Jef' : {'Hobby' : "Football", 'Age': 24}, 'Jos' : {'Hobby': "Paintball", 'Age' : 46}}
assert get_hobby("Paintball") == ['An', 'Jos']
</code></pre>
<p>This doesn't work:</p>
<pre><code>return d.keys[hobby]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a list comprehension:</p>
<pre><code>return [name for name, props in d.items() if props['Hobby'] == hobby]
</code></pre>
<p><code>d.items()</code> gives you a sequence of <code>(key, value)</code> pairs, where the value is the nested dictionary. The list comprehension filters these by matching the <code>hobby</code> variable to the nested <code>'Hobby'</code> key, producing a list of the names for which the filter test returns <code>True</code>.</p>
<p>You cannot ask for the keys in constant time, because that number is variable.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; def get_hobby(hobby):
...     d = {'An' : {'Hobby': "Paintball", 'Age' : 22}, 'Jef' : {'Hobby' : "Football", 'Age': 24}, 'Jos' : {'Hobby': "Paintball", 'Age' : 46}}
...     return [name for name, props in d.items() if props['Hobby'] == hobby]
... 
&gt;&gt;&gt; get_hobby("Paintball")
['Jos', 'An']
</code></pre>
<p>Note that the returned list of keys is in <em>arbitrary order</em>, because dictionaries have no set ordering. You cannot simply test that list against another list and expect it to be equal every single time, because lists do have order. The exact order depends on the <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED" rel="nofollow">Python hash seed</a> and the insertion and deletion history of the dictionary.</p>
<p>You may want to return a <em>set</em> instead; sets do not have ordering either and better reflect the nature of the matching keys returned:</p>
<pre><code>return {name for name, props in d.items() if props['Hobby'] == hobby}
</code></pre>
<p>after which your assertion would become:</p>
<pre><code>assert get_hobby("Paintball") == {'An', 'Jos'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should work:</p>
<pre><code>return [key for key, val in d.items() if val['Hobby'] == hobby]
</code></pre>
<p>For example:</p>
<pre><code>def get_hobby(hobby):
    d = {
        'An': {'Hobby': "Paintball", 'Age' : 22},
        'Jef': {'Hobby' : "Football", 'Age': 24},
        'Jos' : {'Hobby': "Paintball", 'Age' : 46}
    }
    return [key for key, val in d.items() if val['Hobby'] == hobby]

print get_hobby("Paintball")
</code></pre>
<p>Result:</p>
<pre><code>['Jos', 'An']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you need to make lots of these queries in constant time, you have to change to an appropriate data structure. For example:</p>
<pre><code>d2 = {}
for name, subdict in d.items():
    for key, value in subdict:
        d2.setdefault((key, value), set()).add(name)
</code></pre>
<p>(Notice that I used a <code>set</code>, not a <code>list</code>; <a href="https://stackoverflow.com/a/29930072/908494">Martijn Pieters' answer</a> explains why.)</p>
<p>Now:</p>
<pre><code>d2['Hobby', 'Paintball']
</code></pre>
<p>Simple, and efficient.</p>
<p>Of course building the data structure doesn't take constant time; it obviously has to iterate over every sub element of every element of your whole dict. But you only do that once, and then all of your zillion queries are constant time. So, as long as you can afford the space, and "zillion" is actually a large number, this is the optimization you want.</p>
<p>You will need to restructure your code so the dict actually <em>is</em> built once, rather than every time <code>get_hobbies</code> is called. Whether that means putting this in a class, using a closure, explicitly memoizing in an attribute stashed on the function, or just using a global that's built at the top level is up to you. Taking the last one, just because it's shortest (it's probably not best):</p>
<pre><code>d = {'An' : {'Hobby': "Paintball", 'Age' : 22}, 'Jef' : {'Hobby' : "Football", 'Age': 24}, 'Jos' : {'Hobby': "Paintball", 'Age' : 46}}
d2 = {}
for name, subdict in d.items():
    for key, value in subdict:
        d2.setdefault((key, value), set()).add(name)

def get_hobby(hobby):
    return d2['Hobby', hobby]

assert get_hobby("Paintball") == {'An', 'Jos'}
</code></pre>
</div>
<span class="comment-copy">You cannot ask for the key in constant time because you have a variable number of values.</span>
<span class="comment-copy">You <i>can</i> ask for the key in constant time if you build the right data structure. Of course changing the data structure will take linear time, but it only has to be done once, instead of once per queryâ€¦</span>
<span class="comment-copy">@Materials: for consistency I'd just stick with an empty list, but you can add <code>or None</code> to the <code>return</code> line if you need to have <code>None</code> for empty results.</span>
<span class="comment-copy">I'm afraid I can't use the notation of <code>name for name</code>... can I write it otherwise, probably far more inefficient?</span>
<span class="comment-copy">@Materials: then use a regular loop; create an empty list (<code>results = []</code>), then use a regular <code>for</code> loop (<code>for name, props in d.items():</code>) and <code>if</code> filter (<code>if props['Hobby'] == hobby:</code>), and append qualifying names (<code>results.append(name)</code>). Return the <code>results</code> list, or <code>None</code> if it is empty (<code>return results or None</code>).</span>
