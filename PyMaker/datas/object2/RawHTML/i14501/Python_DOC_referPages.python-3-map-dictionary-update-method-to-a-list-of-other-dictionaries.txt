<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1303347/getting-a-map-to-return-a-list-in-python-3-x">Getting a map() to return a list in Python 3.x</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
</ul>
</div>
<p>In Python 2 I can do the following:</p>
<pre><code>&gt;&gt; d = {'a':1}
&gt;&gt; extras = [{'b':2}, {'c':4}]
&gt;&gt; map(d.update, extras)
&gt;&gt; d['c']
&gt;&gt; 4
</code></pre>
<p>In Python 3 in get a <code>KeyError</code>:</p>
<pre><code>&gt;&gt; d = {'a':1}
&gt;&gt; extras = [{'b':2}, {'c':4}]
&gt;&gt; map(d.update, extras)
&gt;&gt; d['c']
&gt;&gt; KeyError: 'c'
</code></pre>
<p>I would like to achieve the same behavior in Python 3 as in Python 2.</p>
<p>I understand that map in Python 3 will return an iterator (lazy evaluation and whatnot), which has to be iterated for the dictionary to be updated.</p>
<p>I had assumed the <code>d['c']</code> key lookup would trigger the map iteration somehow, which is not the case.</p>
<p>Is there a pythonic way to achieve this behavior without writing a for loop,
which I find to be verbose compared to map.</p>
<p>I have thought of using list comprehensions:</p>
<pre><code>&gt;&gt; d = {'a':1}
&gt;&gt; extras = [{'b':2}, {'c':4}]
&gt;&gt; [x for x in map(d.update, extras)]
&gt;&gt; d['c']
&gt;&gt; 4
</code></pre>
<p>But it does not seem pythonic.</p>
</div>
<div class="post-text" itemprop="text">
<p>As you note, <code>map</code> in Python 3 creates an iterator, which doesn't (in and of itself) cause any <code>update</code>s to occur:</p>
<pre><code>&gt;&gt;&gt; d = {'a': 1}
&gt;&gt;&gt; extras = [{'b':2}, {'c':4}]
&gt;&gt;&gt; map(d.update, extras)
&lt;map object at 0x105d73c18&gt;
&gt;&gt;&gt; d
{'a': 1}
</code></pre>
<p>To force the <code>map</code> to be fully evaluated, you could pass it to <code>list</code> explicitly:</p>
<pre><code>&gt;&gt;&gt; list(map(d.update, extras))
[None, None]
&gt;&gt;&gt; d
{'a': 1, 'b': 2, 'c': 4}
</code></pre>
<hr/>
<p>However, as the relevant section of <a href="https://docs.python.org/3/whatsnew/3.0.html#views-and-iterators-instead-of-lists">What's new in Python 3</a> puts it:</p>
<blockquote>
<p>Particularly tricky is <code>map()</code> invoked for the side effects of the
  function; the correct transformation is to use a regular <code>for</code> loop
  (since creating a list would just be wasteful).</p>
</blockquote>
<p>In your case, this would look like:</p>
<pre><code>for extra in extras:
    d.update(extra)
</code></pre>
<p>which doesn't result in an unnecessary list of <code>None</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Alongside the @jonrsharpe's explanation that explains the problem clearly In Python 3 you can use <a href="https://docs.python.org/3.4/library/collections.html#collections.ChainMap" rel="nofollow noreferrer"><code>collections.ChainMap</code></a> for such tasks:</p>
<pre><code>&gt;&gt;&gt; from collections import ChainMap
&gt;&gt;&gt; chain=ChainMap(d, *extras)
&gt;&gt;&gt; chain
ChainMap({'a': 1}, {'b': 2}, {'c': 4})
&gt;&gt;&gt; chain['c']
4
</code></pre>
<p>But note that if there are duplicate keys, the values from the <em>first</em> mapping get used.</p>
<p>Read more about the advantages of using ChainMap :<a href="https://stackoverflow.com/questions/23392976/what-is-the-purpose-of-collections-chainmap">What is the purpose of collections.ChainMap?</a></p>
</div>
<span class="comment-copy"><code>list(map(d.update, extras))</code> will force the iterator to be consumed</span>
<span class="comment-copy">The pythonic way <i>is</i> to use a for loop!  Using map (or a list comprehension) for its side effects rather than its results is definitely <i>not</i> pythonic.</span>
<span class="comment-copy">that for loop was just going bite me! thanks anyway</span>
<span class="comment-copy">Note: instead of <code>list</code> one can use <code>collections.deque(iterable, maxlen=0)</code> to consume the <code>iterable</code> without consuming memory. This also executes only one bytecode so should be slightly more time efficient than an explicit <code>for</code> at least in CPython.</span>
<span class="comment-copy">@Bakuriu interesting, I wouldn't have thought of doing that; I didn't know a <code>deque</code> <i>could</i> have a zero maximum length!</span>
