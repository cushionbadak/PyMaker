<div class="post-text" itemprop="text">
<p>I have a dictionary containing a list as value (see below) and want to save it to a csv. Saving works fine so far, but when I read it back into my program, I get the results below, where the two lists [1,2,3] and [4,5,6] aren't lists anymore, but strings ("[1,2,3]" and "[4,5,6]").</p>
<p>How can I load the list from the csv as list and not as string? So that I can access the elements in the list again and not the single chars (see below).</p>
<pre><code>nodes = []

test_list = [{'Key' : 'key1', 'List' : [1,2,3]}, 
        {'Key' : 'key2', 'List' : [4,5,6]}]

with open('list.csv', 'wb') as f:
    writer = csv.DictWriter(f, test_list[0].keys(), delimiter=';')
    writer.writeheader()
    for entry in test_list:
        writer.writerow(entry)

with open('list.csv') as f:
    dataset = csv.DictReader(f, delimiter=';')
    for row in dataset:
        nodes.append(row)

for elem in nodes:
    print elem
</code></pre>
<p>Result:</p>
<pre><code>{'Key': 'key1', 'List': '[1, 2, 3]'}
{'Key': 'key2', 'List': '[4, 5, 6]'}
</code></pre>
<p>Problem:</p>
<p>So now the lists are strings and I can't access the numbers in the list, since it is a list of chars now.</p>
<pre><code>&gt;&gt; print nodes[0]['List'][0] # print first number from list in first dictionary
[
</code></pre>
<p>Is anyone able to help me or offer me an alternative?
Thanks a lot in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>CSV isn't really made for storing nested lists in this fashion. You could use <code>eval</code>, but it is quite a security hassle since it would allow people to run code on your computer, if you for instance would have people upload their files to your server. Instead I would recommend you to store your dictionary as a JSON object. This would take care of a lot of special cases that might come up later. </p>
<pre><code>import json

test_list = [{'Key' : 'key1', 'List' : [1,2,3]}, 
        {'Key' : 'key2', 'List' : [4,5,6]}]

with open('/tmp/test_list.json', 'w') as f:
    json.dump(test_list, f)
</code></pre>
<p>And then to load it:</p>
<pre><code>with open('/tmp/test_list.json') as f:
    test_list = json.load(f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I agree with @Jimmy: CSVs are not really well suited to storing lists. Switching to JSON, as he suggests, is the best off-the-shelf solution.</p>
<p>If you can't or don't want to switch to JSON for some reason, you should pack your lists yourself so they can be stored and retrieved as single cells in the CSV, and handle the unpacking yourself. <strong>IF</strong> all your list data are lists of integers, you could pack and unpack them like this:</p>
<pre><code>...
for entry in test_list:
    entry["List"] = ",".join( str(n) for n in entry["List"] )
    writer.writerow(entry)

# Reading in
for row in csv.DictReader(f, delimiter=';'):
    row["List"] = [ int(n) for n in row["List"].split(",") ]
    nodes.append(row)
</code></pre>
<p>Since you used ";" as the field separator in the CSV, I used "," as the list separator. This is not necessary if your writer quotes properly, but it's cleaner.</p>
</div>
<div class="post-text" itemprop="text">
<p>The root problem here is that CSV only stores strings. So, putting a <code>list</code> in a CSV cell inherently means automatically stringifying that list and then forcing you to parse it back out again.</p>
<p>If the list really is just a list of integers, <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>literal_eval</code></a> will work. (And it the list is <em>supposed to be</em> just a list of integers, but turns out to <em>actually</em> be something different—whether because of bugs, or because of malicious users—it'll give you a nice error instead of silently doing something dangerous or raising some bewildering exception that makes no sense.) But this is rarely a good idea. Python's <code>repr</code> is not meant to be a data serialization or interchange format; it's meant to be a format that helps human programmers understand their data.</p>
<p>The <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" rel="nofollow noreferrer">Input/Output</a> chapter of the tutorial explains the options that <em>are</em> meant for data serialization and interchange: <code>json</code>, <code>pickle</code>, and <code>csv</code>* in the stdlib. Or you can turn to third-party modules like <code>PyYAML</code>, or store things in a database, etc. If you read up on the strengths and weaknesses of each, <code>json</code> is the obvious answer in this case, as <a href="https://stackoverflow.com/a/30156772/908494">Jimmy C's answer</a> demonstrates.</p>
<hr/>
<p><sub>* Yes, you can use lists of comma-separated values within a row of a CSV file, as long as you either use different delimiters, or allow <code>csv</code> to quote things. See <a href="https://stackoverflow.com/a/30156949/908494">alexis's answer</a> for a simple way to do it, or search the ActiveState recipes for a fancy way to store 2-level lists of lists by using <code>csv.writer</code> and <code>csv.reader</code> recursively. But usually, you don't want to do this; JSON has the advantage of being arbitrarily-recursive, instead of just 2-level recursive, and the even bigger advantage of being dead simple to use.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>I would use pickle</p>
<pre><code>import pickle

test_list = [{'Key' : 'key1', 'List' : [1,2,3]},
                {'Key' : 'key2', 'List' : [4,5,6]}]

pickle.dump(test_list,open('list.p','wb'))
test_list = pickle.load(open('list.p','rb'))
print test_list

&gt;&gt;&gt; [{'List': [1, 2, 3], 'Key': 'key1'}, {'List': [4, 5, 6], 'Key': 'key2'}]
</code></pre>
</div>
<span class="comment-copy">why don't you just json the dicts?</span>
<span class="comment-copy">You can use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>literal_eval</code></a> instead of <code>eval</code>. That avoids the security hassles, and it also gives you a little free validation (if your format isn't actually a literal, you'll get a nice exception instead of possibly doing something wrong, and potentially dangerous, or raising a bewildering exception). But you're right that <code>eval</code> isn't a good idea here, even with <code>literal_eval</code>.</span>
<span class="comment-copy">You can even recursively use a <code>csv.reader(delimiter=',')</code> on the cells from the <code>csv.reader(delimiter=';')</code>. There's a recipe somewhere on ActiveState that wraps this up nicely.</span>
<span class="comment-copy"><i>shudder</i>... :-)</span>
<span class="comment-copy">What's <i>really</i> fun is the recipe linked from there that uses quoting for arbitrary levels of recursion. You can imagine what that looks like with Excel-style quoting that escapes quote characters with quotes… I suppose it's still <i>theoretically</i> human-editable, I just haven't met the human who can do it. :)</span>
<span class="comment-copy">If I recall correctly there's no standard way to embed quotes, right? Some systems recognize backslashing <code>\"</code>, some double the quote <code>""</code>, ... The result must be a monument to non-portability. This application sounds like the poster child for switching to JSON.</span>
<span class="comment-copy">Right, that's why you have to specify a dialect (either by name, or by assembling all the separate dialect-variation arguments). And of course guessing the wrong dialect might mean that whatever program you're trying to interoperate with can open your file with no complaints, but doesn't give the results you wanted, which makes it even more fun to debug… Anyway, you're right about it being the poster child for JSON. I upvoted your answer too, but I hope the OP accepts Jimmy C's.</span>
<span class="comment-copy">Why use <code>pickle</code> instead of <code>JSON</code>? It has the same interface, but it gives you results that aren't human-readable or -editable (or JavaScript/Ruby/etc.-readable), adds potential security holes, etc. <code>pickle</code> is great when you need to store data that JSON can't handle (or when you need compactness, but not using the default pickle protocol 0, which is often slower and bigger than JSON…), but when JSON will do, why not use it?</span>
<span class="comment-copy">I tend to use <code>pickle</code> because it is more flexible than <code>JSON</code>, e.g., <code>pickle</code> can serialize a class.  However, it is nice to use the human readable and cross-language editable <code>JSON</code> too. In my opinion either one of them is fine and I just wanted to introduce the <code>pickle</code> module in case the OP has not had exposure to it yet.</span>
<span class="comment-copy">The problem with <code>pickle</code> is that very flexibility. It opens potential security holes, and robustness problems (e.g., if you change a class between versions, you have to be careful not to break your pickles), and debugging pickles is a lot less fun than JSON, and so on. When you need it (or think you might later), it's definitely worth it despite all that, but as a simple substitute for <code>repr</code>/<code>literal_eval</code>, I think JSON is better. (Although it's still an improvement over <code>repr</code>/<code>literal_eval</code>…)</span>
<span class="comment-copy">That makes a lot of sense. I'll try to use JSON more.</span>
