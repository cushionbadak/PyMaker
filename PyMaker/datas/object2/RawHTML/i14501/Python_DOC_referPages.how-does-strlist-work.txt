<div class="post-text" itemprop="text">
<p><strong>Why does <code>str(list)</code> returns how we see list on the console? How does <code>str(list)</code> work? (any reference to the CPython code for <code>str(list)</code>)?</strong></p>
<pre><code>&gt;&gt;&gt; x = ['abc', 'def', 'ghi']
&gt;&gt;&gt; str(x)
"['abc', 'def', 'ghi']"
</code></pre>
<p>To get the original list back from the <code>str(list)</code> I have to:</p>
<pre><code>&gt;&gt;&gt; from ast import literal_eval
&gt;&gt;&gt; x = ['abc', 'def', 'ghi']
&gt;&gt;&gt; str(x)
"['abc', 'def', 'ghi']"
&gt;&gt;&gt; list(str(x))
['[', "'", 'a', 'b', 'c', "'", ',', ' ', "'", 'd', 'e', 'f', "'", ',', ' ', "'", 'g', 'h', 'i', "'", ']']
&gt;&gt;&gt; literal_eval(str(x))
['abc', 'def', 'ghi']
</code></pre>
<p><strong>Why doesn't <code>list(str(list))</code> turns the <code>str(list)</code> back to the original list?</strong></p>
<p>Or I could use:</p>
<pre><code>&gt;&gt;&gt; eval(str(x))
['abc', 'def', 'ghi']
</code></pre>
<p><strong>Is <code>literal_eval</code> the same as <code>eval</code>? Is <code>eval</code> safe to use?</strong></p>
<p><strong>How many times can I do the following? Does the code break if it keep on doing <code>str(list(str(list))))</code>?</strong> E.g.</p>
<pre><code>&gt;&gt;&gt; x = 'abc'
&gt;&gt;&gt; list(x)
['a', 'b', 'c']
&gt;&gt;&gt; str(list(x))
"['a', 'b', 'c']"
&gt;&gt;&gt; list(str(list(x)))
['[', "'", 'a', "'", ',', ' ', "'", 'b', "'", ',', ' ', "'", 'c', "'", ']']
&gt;&gt;&gt; str(list(str(list(x))))
'[\'[\', "\'", \'a\', "\'", \',\', \' \', "\'", \'b\', "\'", \',\', \' \', "\'", \'c\', "\'", \']\']'
&gt;&gt;&gt; list(str(list(str(list(x)))))
['[', "'", '[', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", 'a', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", 'b', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", 'c', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ']', "'", ']']
&gt;&gt;&gt; str(list(str(list(str(list(x))))))
'[\'[\', "\'", \'[\', "\'", \',\', \' \', \'"\', "\'", \'"\', \',\', \' \', "\'", \'a\', "\'", \',\', \' \', \'"\', "\'", \'"\', \',\', \' \', "\'", \',\', "\'", \',\', \' \', "\'", \' \', "\'", \',\', \' \', \'"\', "\'", \'"\', \',\', \' \', "\'", \'b\', "\'", \',\', \' \', \'"\', "\'", \'"\', \',\', \' \', "\'", \',\', "\'", \',\', \' \', "\'", \' \', "\'", \',\', \' \', \'"\', "\'", \'"\', \',\', \' \', "\'", \'c\', "\'", \',\', \' \', \'"\', "\'", \'"\', \',\', \' \', "\'", \']\', "\'", \']\']'
&gt;&gt;&gt; list(str(list(str(list(str(list(x)))))))
['[', "'", '[', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", '[', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', "'", '"', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", '"', "'", ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", 'a', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', "'", '"', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", '"', "'", ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', "'", '"', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", '"', "'", ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", 'b', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', "'", '"', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", '"', "'", ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', "'", '"', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", '"', "'", ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", 'c', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', "'", '"', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", '"', "'", ',', ' ', "'", ',', "'", ',', ' ', "'", ' ', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ']', "'", ',', ' ', '"', "'", '"', ',', ' ', "'", ']', "'", ']']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well you have a total of 4 questions, let us go one by one. </p>
<blockquote>
<p><strong>1. Why does <code>str(list)</code> returns how we see <code>list</code> on the console? How does <code>str(list)</code> work?</strong></p>
</blockquote>
<h1>What is <a href="https://docs.python.org/3/library/functions.html#str" rel="noreferrer"><code>str()</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="noreferrer"><code>__str__()</code></a>?</h1>
<p>The <code>str()</code> callable is to return a <em>printable</em> form of the object only! From the <a href="https://docs.python.org/3/library/functions.html#str" rel="noreferrer">docs</a></p>
<blockquote>
<p><code>str(object)</code> does not always attempt to return a string that is
  acceptable to <code>eval()</code>; its goal is to return a printable string.</p>
</blockquote>
<p>The <code>__str__()</code> function in a class is called whenever you call <code>str()</code> on an object. Again from the <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="noreferrer">documentation</a></p>
<blockquote>
<p><code>object.__str__(self)</code></p>
<p>Called by the <code>str()</code> built-in function and by the <code>print</code> statement to compute the “informal” string representation of an object.</p>
</blockquote>
<h1>What is the <a href="https://docs.python.org/3/library/functions.html#list" rel="noreferrer"><code>list</code></a> callable?</h1>
<p>The <code>list()</code> callable is to create a list from an iterable passed as an argument. Again from the <a href="https://docs.python.org/3/library/functions.html#list" rel="noreferrer">docs</a></p>
<blockquote>
<p>Return a <code>list</code> whose items are the same and in the same order as
  iterable‘s items</p>
</blockquote>
<p>Thus, <code>str(list)</code> gives you a printable form and <code>list(str(list))</code> will iterate over the string. That is <code>list(str(list))</code> will give you a list of the individual characters of the printable form of the argument passed.</p>
<p>A small walk-through between the nested calls,</p>
<p>Given list, <code>l = ['a','b']</code> <sub>(Apologies for taking a smaller example than that in your question)</sub>. </p>
<p>When you call <code>str(l)</code>, it returns a printable form of the list <code>l</code>, that is <code>"['a','b']"</code>.</p>
<p>Now you can see clearly that <code>"['a','b']"</code> is a string and is indeed an <em>iterable</em>. Now when you call <code>list</code> on this i.e. <code>list("['a','b']")</code> you get a weird list like <code>['[', "'", 'a', "'", ',', "'", 'b', "'", ']']</code>. <em>Why does this happen?</em> This happens because the string iterates over its characters, you can test this by using a dummy string,</p>
<pre><code>&gt;&gt;&gt; 'dummy'
'dummy'
&gt;&gt;&gt; list('dummy')
['d', 'u', 'm', 'm', 'y']
</code></pre>
<p>Thus when you call the <code>list</code> on a string you get a list of character. Note that again here, when you call <code>str()</code> on <code>list('dummy')</code>, you will not get back your original string <code>'dummy'</code>, so again you will have to use <a href="https://docs.python.org/3/library/functions.html#join" rel="noreferrer"><code>join</code></a>! Thus recalling the same function will <strong>NOT</strong> get you back your original object!</p>
<p><strong>So, Calling <code>str()</code> over a list calls the builtin <code>__str__()</code> method of the list?</strong></p>
<p><strong><em>The answer is NO!</em></strong></p>
<h2>What happens internally when you call <code>str()</code> on a list?</h2>
<p>Whenever you call <code>str()</code> on an list object, the steps followed are </p>
<ol>
<li>Call the <code>repr()</code> of each of the list element.</li>
<li>Add a fancy <code>[</code> at the front and another <code>]</code> at the end of the list. </li>
<li>Join all of them with a comma. </li>
</ol>
<p><s>As you can see from the source code of the list object in <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c" rel="noreferrer">cpython on github</a>.</s> Going through the source code of cpython in <a href="https://hg.python.org/cpython/file/e8783c581928/Objects/listobject.c#l362" rel="noreferrer">hg.python</a>, which is more clear, you can see the following three comments. <sub>(Thanks to Ashwini for the link on that particular <a href="https://stackoverflow.com/questions/30109030/how-does-strlist-work#comment48330380_30109030">code</a>)</sub></p>
<blockquote>
<pre><code>/* Do repr() on each element.  Note that this may mutate the list,
   so must refetch the list size on each iteration. */ line (382)

/* Add "[]" decorations to the first and last items. */ line (398)

/* Paste them all together with ", " between. */ line (418)
</code></pre>
</blockquote>
<p>These correspond to the points I mentioned above.</p>
<h1>Now what is <a href="https://docs.python.org/3/library/functions.html#repr" rel="noreferrer"><code>repr()</code></a>?</h1>
<p><code>repr()</code> prints the string representation of all the objects. Again from the <a href="https://docs.python.org/3/library/functions.html#repr" rel="noreferrer">documentation</a></p>
<blockquote>
<p>Return a string containing a printable representation of an object.</p>
</blockquote>
<p>and also note this sentence!</p>
<blockquote>
<p>For many types, this function makes an attempt to return a string
  that would yield an object with the same value when passed to <code>eval()</code>,
  otherwise the representation is a string enclosed in angle brackets
  that contains the name of the type of the object together with
  additional information often including the name and address of the
  object.</p>
</blockquote>
<p>And now your second question here,</p>
<blockquote>
<p><strong>2. Why doesn't <code>list(str(list))</code> turns the <code>str(list)</code> back to the original list?</strong></p>
</blockquote>
<p>Internally, <code>str(list)</code> actually creates the <code>repr()</code> representation of the list object. So to get back the list after calling <code>str</code> on the list, you actually need to do <a href="https://docs.python.org/3/library/functions.html#eval" rel="noreferrer"><code>eval</code></a> on it and not a <code>list</code> call. </p>
<h1>Workarounds</h1>
<p>But we all know that <a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="noreferrer"><code>eval</code> is <em>evil</em></a>, so what is/are the workaround(s)? </p>
<h2>1. Using <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="noreferrer"><code>literal_eval</code></a></h2>
<p>The first work-around would be to use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="noreferrer"><code>ast.literal_eval</code></a>. That brings us to your 3rd question,</p>
<blockquote>
<p><strong>3. Is <code>literal_eval()</code> the same as <code>eval()</code>? Is <code>eval()</code> safe to use?</strong></p>
</blockquote>
<p><a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="noreferrer"><code>ast.literal_eval()</code></a> is safe <a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="noreferrer">unlike</a> the <code>eval()</code> function. The docs themselves mention that it is safe -- </p>
<blockquote>
<p><em>Safely</em> evaluate an expression node or a string containing a Python literal or container display</p>
</blockquote>
<h2>2. Using string functions and builtins</h2>
<p>Another workaround can be done using <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="noreferrer"><code>str.split()</code></a></p>
<pre><code>&gt;&gt;&gt; x = ['abc', 'def', 'ghi']
&gt;&gt;&gt; a = str(x)
&gt;&gt;&gt; a[2:-2].split("', '")
['abc', 'def', 'ghi']
</code></pre>
<p>This is just a simple way to do that for a list of strings. For a list of integers you will need <a href="https://docs.python.org/3/library/functions.html#map" rel="noreferrer"><code>map</code></a>. </p>
<pre><code>&gt;&gt;&gt; x = [1,2,3]
&gt;&gt;&gt; a =str(x)
&gt;&gt;&gt; list(map(int,a[1:-1].split(', '))) # No need for list call in Py2
[1, 2, 3]
</code></pre>
<p>Thus unlike <code>literal_eval</code> these are simple hacks given that you know the  elements of the list. If they are heterogeneous in nature like <code>[1, "a", True]</code> then you will have to loop through the split list and discover the element type and then convert it and append the converted element to a final list. </p>
<p>Another place where this fails is when the string itself contains quote characters. As mentioned by <a href="https://stackoverflow.com/users/1204143/nneonneo">nneonneo</a> in a <a href="https://stackoverflow.com/questions/30109030/how-does-strlist-work/30109108#comment76928391_30109108">comment</a></p>
<blockquote>
<p>The <code>str.split</code> solution is very fragile and will break if the input contains e.g. strings that contain <code>", "</code>, or tuples, or other lists, ... It is much better to use <code>ast.literal_eval</code> because that will deal with all the subtleties of the syntax.</p>
</blockquote>
<p>And for your final question,</p>
<blockquote>
<p><strong>4. Does the code break if you do <code>str(list(str(list))))</code> again and again?</strong></p>
</blockquote>
<p>Not really. The output will grow longer and longer as each time you are creating a <code>list</code> of a <code>str</code> and then again getting the printable version of it. The limitation is your physical machine's limitation only. (which will be soon reached as each step the string length is multiplied by 5.)</p>
</div>
<div class="post-text" itemprop="text">
<p>You appear to have the expectation that creating a string from a list is round-trippable. It is not meant to be; lists are not end-user presentable objects and you get the same output as <code>repr(listobject)</code>; debug information for developer consumption only.</p>
<p>The <code>list()</code> callable creates a new list object from any arbitrary iterable object; Python strings are iterable producing individual characters when you do so, <code>list(stringobject)</code> always produces a list with individual characters.</p>
<p>As such, <code>list()</code> will never attempt to interpret a string argument as Python syntax; and doing so would not even work if the original list contained objects without a Python literal notation. Take for example:</p>
<pre><code>&gt;&gt;&gt; def foo(): return 'bar'
... 
&gt;&gt;&gt; alist = [foo]
&gt;&gt;&gt; alist
[&lt;function foo at 0x106c748c0&gt;]
</code></pre>
<p>You cannot take that debug string output and turn that back into the original list, especially if you run this in a Python interpreter where there is not even such a function defined.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>str()</code> function in python is used to turn a value into a string. The simple answer to what the <code>str()</code> does to a <code>list</code> is that it creates a string representation of the list (square brackets and all).</p>
<p>As for the <code>list(str(list))</code>, all you are doing is telling python to convert the original list to a string then you are splitting that string and putting it into a list so that each index has one character. So you could nest <code>list</code> and <code>str</code> calls as many times as you want (assuming your computer is has enough memory).</p>
</div>
<span class="comment-copy">You appear to have the expectation that creating a string from a list is round-trippable. It is not meant to be; lists are not end-user presentable objects and you get the same output as <code>repr(listobject)</code>; debug information for developer consumption only.</span>
<span class="comment-copy">Lists have not <code>__str__</code> method at all, its <code>tp_str</code> slot is actually empty. So, instead its <code>tp_repr</code> slot is used to get the <code>repr</code> representation of the list and its items(including cylic objects): <a href="https://hg.python.org/cpython/file/e8783c581928/Objects/listobject.c#l362" rel="nofollow noreferrer">hg.python.org/cpython/file/e8783c581928/Objects/…</a></span>
<span class="comment-copy">About the <i>What happens internally when you call <code>str</code> on a <code>list</code>?</i> part, why isn't do <b>3</b> before <b>2</b> like <code>', '.join(i.__repr__() for i in l).join('[]')</code>?</span>
<span class="comment-copy">@KevinGuan 1. Efficiency 2. Simplicity. It is easier to add the brackets to the first and last elements at once. Once they are added the individual elements can be directly passed to <code>_PyString_Join</code> and return the result.  As you can see in your example you are <code>join</code>ing twice. On an average this method works out better.</span>
<span class="comment-copy">The <code>str.split</code> solution is very fragile and will break if the input contains e.g. strings that contain <code>", "</code>, or tuples, or other lists, ... It is much better to use <code>ast.literal_eval</code> because that will deal with all the subtleties of the syntax.</span>
