<div class="post-text" itemprop="text">
<p>I am working on a project in BGE and I want to make an object slowly accelerate to its max speed when I press the button. When I press another button it should decelerate and then again slowly accelerate to the top speed in the other direction.</p>
<p>Here is the code:</p>
<pre><code>import bge

cont = bge.logic.getCurrentController()
own = cont.owner
keyboard = bge.logic.keyboard
ACTIVE = bge.logic.KX_INPUT_ACTIVE
INACTIVE = bge.logic.KX_INPUT_NONE
accelerate = own['accelerateProp']

accelerateFactor = 0.005

own.applyMovement((0, accelerate, 0))

if(keyboard.events[bge.events.WKEY] == ACTIVE and accelerate &gt; -0.05):
    own['accelerateProp'] -= accelerateFactor

if(keyboard.events[bge.events.SKEY] == ACTIVE and accelerate &lt; 0.05):
    own['accelerateProp'] += accelerateFac
</code></pre>
<p>I have an object with the <code>accelerateProp</code> property which I'm using to controll the speed of the object. </p>
<p>When I hold W key it accelerates. But instead of stopping at -0.05, it runs one more time and it stops at -0.055. If I then hold S button, it deccelerates and then again accelerates and stops at 0.05.</p>
<p>The confusing thing is that if I hold S key first, it Will accelerate to 0.055, and it will work fine the other way around.</p>
<p>So actuali, the direction, which will reach the top speed firs will be broken and the other will be fine and it will stay that way, so one side will always have max speed 0.055 and the other 0.05.</p>
<p>I can't understand what's wrong. I suspect it has to do something wit game properties, but I realy don't Know. Also if there's another way of doing what I did, please let me know.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason for the problems are rounding-errors with floating-points. Unfortunately, for floating-points addition and multiplication introduce small errors that can lead to problems with comparisons.</p>
<p>Instead, you should use "clamping", which means you prevent over/undershooting by comparing with a threshold, and then setting the value to the threshold itself:</p>
<pre><code>acceleration = -0.05 if braking else 0.05
speed = max(0, min(max_speed, speed + acceleration))
</code></pre>
<p>Thus speed will never exceed the boundaries of [0..max_speed]</p>
</div>
<div class="post-text" itemprop="text">
<p>It's hard to be sure without more information, but I'm almost certain this is just a typical floating-point rounding error.</p>
<p>Consider this code (which is effectively doing the same thing as your code, but without all the user interaction stuff in the middle):</p>
<pre><code>x = 0
while x &lt; 0.05:
    x += 0.005
print(x)
</code></pre>
<p>You'd think the result would be <code>0.05</code>, right? But it's not. It's <code>0.05499999999999999</code>. Why did it go one step too far?</p>
<p>If you print out all the values along the way, the reason is obvious:</p>
<pre><code>0.005
0.01
0.015
0.02
0.025
0.030000000000000002
0.035
0.04
0.045
0.049999999999999996
0.05499999999999999
</code></pre>
<p>There is no floating-point double exactly equal to all of these numbers, so you accumulate rounding error. When you get to the 10th one, it's not <code>0.05</code>, it's <code>0.049999999999999996</code>, which is still less than <code>0.05</code>, so it goes one more step.</p>
<hr/>
<p>There are two solutions to problems like this.</p>
<hr/>
<p>First, you can use <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow"><code>Decimal</code></a> instead of <code>float</code>. Of course <code>Decimal</code> is just as inexact and subject to rounding errors as <code>float</code> in general; the difference is that any number that has an exact decimal string representation (like <code>0.005</code> and all of your other values) also has an exact <code>Decimal</code> representation. So:</p>
<pre><code>from decimal import Decimal
x = Decimal('0')
while x &lt; Decimal('0.05'):
    x += Decimal('0.005')
print(x)
</code></pre>
<p>And now you get <code>0.05</code> instead of <code>0.05499999999999999</code>.</p>
<hr/>
<p>Alternatively, you can use absolute or relative epsilon comparisons. For example:</p>
<pre><code>eps = 1e-5

while x + eps &lt; 0.05:
    x += 0.005
print(x)
</code></pre>
<p>Now you get <code>0.049999999999999996</code> instead of <code>0.05499999999999999</code> at the end.</p>
</div>
<div class="post-text" itemprop="text">
<p>round off your property. <code>prop = round(prop["value"], 2)</code>
The 2 is the round point.</p>
</div>
<span class="comment-copy">Thanks a lot. I didn't know about those rounding errors. I didn't use your code however. I changed all floats into integers (multiplied everithing by 1000) and then when I applyed movement I devided it by 1000.</span>
<span class="comment-copy">Or use integer by multiplying by 1000 - range becomes 50 to -50 in steps of 5, then adjust with <code>accelerateFactor/1000</code></span>
<span class="comment-copy">@deets: How is this not useful? The solutions that work in normal Python code work in Blender. In particular, using an absolute or relative epsilon for all comparisons is both necessary and sufficient for dealing with floats in Blender to make them work with rounding errors.</span>
<span class="comment-copy">Sorry @abarnert, I focused on the Decimal stuff and didn't read the answer to the end. Forget that I said anything.</span>
