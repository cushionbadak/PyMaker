<div class="post-text" itemprop="text">
<p>Let me prefice this by saying: I am by no means a Windows programmer. Please help me by correcting any misunderstanding I may have.</p>
<p>My understanding is that Windows has both (legacy) single-byte string interfaces and modernized Unicode interfaces.</p>
<p>My goal is to closely examine the cp1252 as implemented in the Windows kernel. I'll start with Windows XP, but I plan to check as many versions as I can.</p>
<p>I'm going to make the output of such a program similar in format to: <a href="https://encoding.spec.whatwg.org/index-windows-1252.txt" rel="nofollow">https://encoding.spec.whatwg.org/index-windows-1252.txt</a></p>
<p>My question is primarily: what Windows API functions would I use to accomplish the above task? I think it's <a href="https://msdn.microsoft.com/en-us/library/eyktyxsx.aspx" rel="nofollow">mbstowcs_s</a>.</p>
<p>Secondarily: Must I write C in order to examine the relevant interfaces? If so what compiler would I use? I think Visual Studio Express 2010 is a good match, but I can't find any (legitimate) place to download it.</p>
<hr/>
<p>For those that must know the X to my Y, there are two competing standards and implementations of cp1252. They differ only slightly but they do differ, and it's significant to me.</p>
<p>The WHATWG specifies, and all browsers implement this standard:
<a href="https://encoding.spec.whatwg.org/index-windows-1252.txt" rel="nofollow">https://encoding.spec.whatwg.org/index-windows-1252.txt</a></p>
<p>Microsoft specifies, and python implements this standard:
<a href="http://unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT" rel="nofollow">http://unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT</a></p>
<p>The difference is in the five non-printable characters. In the windows spec they're entirely undefined, so these bytes cannot be round-tripped through cp1252. In the WHATWG spec (and all browsers), these bytes map to non-printing characters of the same value, as in latin1, meaning that those bytes can round-trip successfully through cp1252.</p>
<p>I strongly suspect that Microsoft's implementation actually matches the WHATWG spec and browsers' implementations, rather than the spec they've published. This is what I'm trying to prove/disprove above.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using @abernert's help, I came up with this. In conclusion, Microsoft's spec doesn't match their implementation, as I suspected:</p>
<pre><code>from ctypes import cdll, windll, c_char_p
c = cdll.msvcrt
k = windll.kernel32
LC_ALL = 0  # from locale.h
# reference: https://msdn.microsoft.com/en-US/library/x99tb11d.aspx
c.setlocale.restype = c_char_p
result = c.setlocale(LC_ALL, '.1252')
assert result == 'English_United States.1252', result

from ctypes import create_string_buffer
# cp1252 is classified as "multi-byte" by the msapi along with utf8
mb = create_string_buffer(1)
wc1 = create_string_buffer(2)
wc2 = create_string_buffer(2)

print 'IN | MSVC  KERN'
print '---+-----------'
for b in range(0x80, 0xA0):
    mb.value = chr(b)

    # reference: https://msdn.microsoft.com/en-us/library/yk02bkxb.aspx
    result = c.mbtowc(wc1, mb, 1)
    assert result == 1, result

    # reference:
    #     https://msdn.microsoft.com/en-us/library/windows/desktop/dd319072.aspx
    result = k.MultiByteToWideChar(1252, 0, mb, 1, wc2, 1)
    assert result == 1, result

    print '%02X | %02X%02X  %02X%02X' % (
        ord(mb.value),
        # little-endian:
        ord(wc1.raw[1]), ord(wc1.raw[0]),
        ord(wc2.raw[1]), ord(wc2.raw[0]),
    )
</code></pre>
<p>Output: (tested on Windows XP, Vista, 7, 8.1)</p>
<pre><code>IN | MSVC  KERN
---+-----------
80 | 20AC  20AC
81 | 0081  0081
82 | 201A  201A
83 | 0192  0192
84 | 201E  201E
85 | 2026  2026
86 | 2020  2020
87 | 2021  2021
88 | 02C6  02C6
89 | 2030  2030
8A | 0160  0160
8B | 2039  2039
8C | 0152  0152
8D | 008D  008D
8E | 017D  017D
8F | 008F  008F
90 | 0090  0090
91 | 2018  2018
92 | 2019  2019
93 | 201C  201C
94 | 201D  201D
95 | 2022  2022
96 | 2013  2013
97 | 2014  2014
98 | 02DC  02DC
99 | 2122  2122
9A | 0161  0161
9B | 203A  203A
9C | 0153  0153
9D | 009D  009D
9E | 017E  017E
9F | 0178  0178
</code></pre>
<p>Compare this with <a href="http://unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT" rel="nofollow">the spec</a> that Microsoft registered with unicode.org:</p>
<pre><code>0x80    0x20AC  #EURO SIGN
0x81            #UNDEFINED
0x82    0x201A  #SINGLE LOW-9 QUOTATION MARK
0x83    0x0192  #LATIN SMALL LETTER F WITH HOOK
0x84    0x201E  #DOUBLE LOW-9 QUOTATION MARK
0x85    0x2026  #HORIZONTAL ELLIPSIS
0x86    0x2020  #DAGGER
0x87    0x2021  #DOUBLE DAGGER
0x88    0x02C6  #MODIFIER LETTER CIRCUMFLEX ACCENT
0x89    0x2030  #PER MILLE SIGN
0x8A    0x0160  #LATIN CAPITAL LETTER S WITH CARON
0x8B    0x2039  #SINGLE LEFT-POINTING ANGLE QUOTATION MARK
0x8C    0x0152  #LATIN CAPITAL LIGATURE OE
0x8D            #UNDEFINED
0x8E    0x017D  #LATIN CAPITAL LETTER Z WITH CARON
0x8F            #UNDEFINED
0x90            #UNDEFINED
0x91    0x2018  #LEFT SINGLE QUOTATION MARK
0x92    0x2019  #RIGHT SINGLE QUOTATION MARK
0x93    0x201C  #LEFT DOUBLE QUOTATION MARK
0x94    0x201D  #RIGHT DOUBLE QUOTATION MARK
0x95    0x2022  #BULLET
0x96    0x2013  #EN DASH
0x97    0x2014  #EM DASH
0x98    0x02DC  #SMALL TILDE
0x99    0x2122  #TRADE MARK SIGN
0x9A    0x0161  #LATIN SMALL LETTER S WITH CARON
0x9B    0x203A  #SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
0x9C    0x0153  #LATIN SMALL LIGATURE OE
0x9D            #UNDEFINED
0x9E    0x017E  #LATIN SMALL LETTER Z WITH CARON
0x9F    0x0178  #LATIN CAPITAL LETTER Y WITH DIAERESIS
</code></pre>
<p>It's clear to me that the slots labeled <code>UNDEFINED</code> (bytes 81 8D 8F 90 and 9D) are not undefined, not errors, but decode to unprintable characters of equal ordinal, as they do in <a href="https://encoding.spec.whatwg.org/index-windows-1252.txt" rel="nofollow">the WHATWG spec</a>, below:</p>
<pre><code>  0 0x20AC  € (EURO SIGN)
  1 0x0081   (&lt;control&gt;)
  2 0x201A  ‚ (SINGLE LOW-9 QUOTATION MARK)
  3 0x0192  ƒ (LATIN SMALL LETTER F WITH HOOK)
  4 0x201E  „ (DOUBLE LOW-9 QUOTATION MARK)
  5 0x2026  … (HORIZONTAL ELLIPSIS)
  6 0x2020  † (DAGGER)
  7 0x2021  ‡ (DOUBLE DAGGER)
  8 0x02C6  ˆ (MODIFIER LETTER CIRCUMFLEX ACCENT)
  9 0x2030  ‰ (PER MILLE SIGN)
 10 0x0160  Š (LATIN CAPITAL LETTER S WITH CARON)
 11 0x2039  ‹ (SINGLE LEFT-POINTING ANGLE QUOTATION MARK)
 12 0x0152  Œ (LATIN CAPITAL LIGATURE OE)
 13 0x008D   (&lt;control&gt;)
 14 0x017D  Ž (LATIN CAPITAL LETTER Z WITH CARON)
 15 0x008F   (&lt;control&gt;)
 16 0x0090   (&lt;control&gt;)
 17 0x2018  ‘ (LEFT SINGLE QUOTATION MARK)
 18 0x2019  ’ (RIGHT SINGLE QUOTATION MARK)
 19 0x201C  “ (LEFT DOUBLE QUOTATION MARK)
 20 0x201D  ” (RIGHT DOUBLE QUOTATION MARK)
 21 0x2022  • (BULLET)
 22 0x2013  – (EN DASH)
 23 0x2014  — (EM DASH)
 24 0x02DC  ˜ (SMALL TILDE)
 25 0x2122  ™ (TRADE MARK SIGN)
 26 0x0161  š (LATIN SMALL LETTER S WITH CARON)
 27 0x203A  › (SINGLE RIGHT-POINTING ANGLE QUOTATION MARK)
 28 0x0153  œ (LATIN SMALL LIGATURE OE)
 29 0x009D   (&lt;control&gt;)
 30 0x017E  ž (LATIN SMALL LETTER Z WITH CARON)
 31 0x0178  Ÿ (LATIN CAPITAL LETTER Y WITH DIAERESIS)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To answer your X question instead of your Y question:</p>
<p>You can't really ask how "Windows" handles what it calls "ANSI strings", because there are multiple different levels that handle them independently. It's a pretty good bet that they all do so in ways that are compatible… but your whole point is to avoid that pretty good bet and examine the truth directly.</p>
<p>I think you can safely assume that <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd318026%28v=vs.85%29.aspx" rel="nofollow"><code>MultiByteToWideChar</code></a> will give you the same results as calling SpamA vs. SpamW functions in the Win32 API. (If you can't even assume that, I think you'd really need to test every single function pair in the API to make sure they all have the same results…) You can pass <code>CP_1252</code> directly, but I think passing <code>CP_OEMCP</code> on a system configured for 1252 is a better test of what you're asking. Or just do both.</p>
<p>It's plausible that MSVCRT (which handles providing an 8-bit-string-based standard C interface and large chunks of POSIX to portable programs, including CPython) has its own conversions. To verify that, call <a href="https://msdn.microsoft.com/en-us/library/k1f9b8cy.aspx" rel="nofollow"><code>mbstowcs</code></a> or one of its relatives.</p>
<p>I'm pretty sure the Win32 system layer handles ANSI strings the same way as the user layer, but you may want to search for an undocumented <code>ZwMultiByteToWideChar</code> or similar. And I think the kernel just doesn't handle ANSI strings anywhere—e.g., IIRC, when you write a filesystem driver, the only pathname interfaces are wide… but you may want to download the DDK and make sure I'm right about that.</p>
<p>I think the Explorer GUI shell relies on the Win32 layer to handle everything, and doesn't touch ANSI strings anywhere. The cmd.exe command-line shell only deals in Unicode (except when running DOS programs on Win9x)—but it's also a terminal, and as a terminal, it does actually deal with both ANSI and Unicode strings and map them. In particular, you can send either ANSI or Unicode console output and read either ANSI or Unicode console input. That's probably done via <code>MultiByteToWideChar</code> and friends, but I couldn't promise that. I think MSVCRT's stdin/out and wstdin/out and its DOS-conio-style <a href="https://msdn.microsoft.com/en-us/library/078sfkak.aspx" rel="nofollow">getch/etc. and getwch/etc.</a> functions just access these respective console APIs instead of translating in MSVCRT, but if you don't trust that, you can go around it and either get the native console streams or just call the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682073%28v=vs.85%29.aspx" rel="nofollow">Console</a> I/O functions directly.</p>
<p>So, how do you write a test program for these things, without finding multiple out-of-support versions of Microsoft C++ compiler and an SDK for each OS? (And, even if you did, how could you be sure that later versions of the WinXP SDK weren't hiding problems from you that existed in XP itself?)</p>
<p>The answer is to just <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175(v=vs.85).aspx" rel="nofollow"><code>LoadLibrary</code></a> and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms683212(v=vs.85).aspx" rel="nofollow"><code>GetProcAddress</code></a> the functions out of their respective DLLs at runtime. Which you can do from a program you just compile for one version of Windows.</p>
<p>Or, even more simply, just use Python, and use its <a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow"><code>ctypes</code></a> module to access the functions out of the DLLs. Just make sure you explicitly create and pass <code>LPSTR</code> and <code>LPWSTR</code> buffers instead of passing <code>str</code>/<code>bytes</code>/<code>unicode</code> objects anywhere.</p>
<hr/>
<p>So ultimately, I think all you need is a 20-line Python script that uses <code>ctypes</code> to call <code>MultiByteToWideChar</code> out of <code>KERNEL32.DLL</code> or <code>mbstowcs</code> out of <code>MSVCRT32.DLL</code> or both.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your question doesn't really make any sense. You want to examine "the encoding" used by each version of Windows from 95 through 10.</p>
<p>But none of those versions of Windows have "an encoding". Every single one of them is configurable in the same way: it has a default system encoding, which is pre-configured by Microsoft, and a current user encoding, which is set by Microsoft or the system OEM but which the user can change. So, your test won't depend on Windows 95 vs. Windows 7, it'll depend on US Windows 95 from Microsoft with default settings vs. ES Windows 95 from Microsoft with default settings vs. US Windows 95 from HP with default settings vs. US Windows 95 from Microsoft with each of the 238 possible choices in the Control Panel etc.</p>
<p>Also, to generate the kind of file you're trying to generate, you don't need to touch any Win32 APIs. All you need to do is call any function that uses the configured system locale's character set to decode single-byte/multi-byte text to UTF-16/Unicode text. For example, from C, you can call one of the  <a href="https://msdn.microsoft.com/en-us/library/eyktyxsx.aspx" rel="nofollow"><code>mbcstowcs</code></a> family from the MSVCRT; from Python, you can call the <code>decode</code> method on a <code>str</code> (Python 2)/<code>bytes</code> (Python 3) object with <code>sys.getdefaultencoding()</code>; etc.</p>
<p>If you really want to use the system interfaces to test the same information, you can… but then you'll run into limitations of most of those interfaces. For example, you can <code>CreateFileA</code> to create a new file with an 8-bit name, then try to <code>CreateFileW</code> to open the same file with the corresponding 16-bit name and verify that it works… but then you can't test any of the illegal-for-filenames characters.</p>
<p>Finally, Microsoft <em>has</em> provided free C compilers for most if not all of those platforms, but some of them are long out of service, so I don't know if you can (at least legally) get them or not. But you can always use <a href="http://www.mingw.org/" rel="nofollow">MinGW</a> to set up a gcc-based toolchain. I don't know if the current versions still work on Win95, but if not, the old versions should still be available.</p>
</div>
<span class="comment-copy">The encoding is configurable. In fact, your system can have an "OEM encoding" that was preinstalled by Microsoft or the computer manufacturer, plus a user encoding that can be changed in the Control Panel. Windows-1252 is the OEM encoding for Windows sold by Microsoft in the US, but it may not be the OEM encoding or the user encoding on your machine.</span>
<span class="comment-copy">Meanwhile, to produce output like the file you linked to, you don't have to use <i>any</i> of the Windows API system interfaces; you just need to create a <code>char *</code> of all the chars from 0 to 127, then call something like <a href="https://msdn.microsoft.com/en-us/library/eyktyxsx.aspx" rel="nofollow noreferrer"><code>mbstowcs_s</code></a>.</span>
<span class="comment-copy">Or, in Python 3, just <code>bytes(range(128)).decode(sys.getdefaultencoding())</code>.</span>
<span class="comment-copy">Finally, one big question: <i>why</i> do you want to do this? Are you looking to prove that Microsoft is lying in their documentation, and nobody has noticed for 20 years?</span>
<span class="comment-copy">Pretty difficult to understand why you asked this question. You seem to be massively overthinking what is a trivial problem. You seem to be attempting to write code where no code is needed.</span>
<span class="comment-copy">This doesn't demonstrate that Microsoft's spec doesn't match their implementation, it just demonstrates that they used a different error-handling rule than you did. The <code>MultiByteToWideChar</code> function handles undefined characters by just converting them to the equivalent code point. That's a little weird, but it's not unreasonable or against any spec. It's  reversible transformation that only generates valid Unicode. (Compare to Python's <code>surrogate-escape</code> error handler, which, while more useful in practice, actually <i>does</i> generate invalid Unicode…)</span>
<span class="comment-copy">@abernert: You are re-defining "error" to prove your argument. In point of fact, my above code asserts that there were no encoding errors by any possible reading of the documentation.  <code>mbtowc</code> has no error handlers that I can see, and (depending on windows version) <code>MultiByteToWideChar</code> will either delete invalid bytes or convert them to the Unicode replacement character (U+FFFD), which clearly hasn't happened.</span>
<span class="comment-copy">That sounds very attainable. Thanks for bearing with me. Now to go find a windows box...</span>
<span class="comment-copy">it looks like you've confused <code>CP_OEMCP</code> with <code>CP_ACP</code>.</span>
<span class="comment-copy">@J.F.Sebastian: No, I think he wants <code>CP_OEMCP</code> here. If the user has changed the code page, you want to test with the current code page, not the system-default code page. But really, it shouldn't matter; to do the test properly, you want a system where both are set to cp1252. (But I <i>did</i> get the backward in the other answer…)</span>
<span class="comment-copy">if both encodings are cp1252, where does cp437 come from (in the console)?</span>
<span class="comment-copy">@J.F.Sebastian: In 9x, it comes from the DOS codepage. In NT, I don't remember how the console codepage is set for sure, but IIRC the lookup is actually based on your locale (e.g., 1033 for US English), not your system or OEM codepage, which can be annoying when you're, say, using a German computer and you think you've switched it to use US English for everything but in the command prompt you keep ääääing all over the place because there's actually one more place to switch.</span>
<span class="comment-copy">Thanks. I hadn't considered that Windows has a configurable locale which would affect all these interfaces, but of course that makes sense. In that case I'll specify that I want to examine cp1252. Using python's .decode would show me python's implementation of cp1252, which isn't my goal. I strongly suspect the two implementations differ, which is my impetus for this project.</span>
<span class="comment-copy">@bukzor: Well, in theory, MSVCRT's implementation of cp1252 could differ from the version in the Win32 layer too. And in theory, even <i>that</i> might not actually be a wrapper around the version in the NT/ZW layer but a reimplementation (which would mean you get different results for normal paths and `\\.` paths, or normal paths in user-level code vs. driver-level code). They could even theoretically have 38 different implementations scattered around the Win32 layer, and each function uses a different one. How far do you want to push the test?</span>
<span class="comment-copy">@bukzor: But the reality is, cp1252 is dead-simple. It's an IBM-style code page that just defines the meanings of 256 code points. If either Microsoft or Python got it wrong, you would have heard about it by now.</span>
<span class="comment-copy">Clarified the question.</span>
