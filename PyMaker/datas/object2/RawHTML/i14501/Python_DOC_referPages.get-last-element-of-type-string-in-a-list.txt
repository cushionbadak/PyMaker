<div class="post-text" itemprop="text">
<p>Suppose I have a list of different types:</p>
<p>i.e.</p>
<pre><code>[7, 'string 1', 'string 2', [a, b c], 'string 3', 0, (1, 2, 3)]
</code></pre>
<p>Is there a Pythonic way to return 'string 3' ?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have a given type, you can use several kinds of comprehensions to get what you need.</p>
<pre><code>[el for el in lst if isinstance(el, given_type)][-1]
# Gives the last element if there is one, else IndexError
</code></pre>
<p>or</p>
<pre><code>next((el for el in reversed(lst) if isinstance(el, given_type)), None)
# Gives the last element if there is one, else None
</code></pre>
<p>If this is something you're doing often enough, you can factor it into a function:</p>
<pre><code>def get_last_of_type(type_, iterable):
    for el in reversed(iterable):
        if isinstance(el, type_):
            return el
    return None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd think the easiest way would be to grab the last element of a filtered list.</p>
<pre><code>filter(lambda t: type(t) is type(''), your_list)[-1]
</code></pre>
<p>or</p>
<pre><code>[el for el in your_list if type(el) is type('')][-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Obligatory <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a> solution:</p>
<pre><code>&gt;&gt;&gt; l = [7, 'string 1', 'string 2', 8, 'string 3', 0, (1, 2, 3)]
&gt;&gt;&gt; from itertools import dropwhile
&gt;&gt;&gt; next(dropwhile(lambda x: not isinstance(x, str), reversed(l)), None)
'string 3'
</code></pre>
<p>In case you can't use imports for whatever reason, the polyfill for <a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" rel="nofollow"><code>itertools.dropwhile</code></a> is as follows:</p>
<pre><code>def dropwhile(predicate, iterable):
    # dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1
    iterable = iter(iterable)
    for x in iterable:
        if not predicate(x):
            yield x
            break
    for x in iterable:
        yield x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>try this </p>
<pre><code>lst = [7, 'string 1', 'string 2', [a, b c], 'string 3', 0, (1, 2, 3)]
filtered_string = [ x for x in lst if type(x) is str]
</code></pre>
<p>now you can get any index of it
for last index</p>
<pre><code>filtered_string[-1]
</code></pre>
</div>
<span class="comment-copy">So based on what kind of condition you want that?</span>
<span class="comment-copy">@Kasra, the condition is in the title. "last element of type string".</span>
<span class="comment-copy">Hint: Use <code>next()</code> with <code>reversed()</code> and a generator expression.</span>
<span class="comment-copy">type(a[4])==str</span>
<span class="comment-copy">plus 1 good idea with the <code>reversed</code> generator.</span>
<span class="comment-copy">The <code>next()</code> version avoids copying the list, which may have performance implications under certain circumstances.  However, in many cases, this is a micro-optimization.  Always profile first.</span>
<span class="comment-copy">@Kevin right. More importantly it avoids throwing <code>IndexError</code>s that should really be <code>None</code>s. If I'm asking for the last string in a list, and there are no strings in the list, I expect my answer to be <code>None</code> not to interrupt my program flow! :)</span>
<span class="comment-copy">@Adam: Not necessarily.  If I expect a string to be there, and it isn't, my program has a bug and it should stop running now so it doesn't corrupt any important data.</span>
<span class="comment-copy">It's customary to compare types with <code>is</code> rather than with <code>==</code>, since a metaclass can override the latter.</span>
<span class="comment-copy">@Kevin thanks, done.</span>
<span class="comment-copy">Also, <code>type('')</code> is just <code>str</code> in both 2.x and 3.x.</span>
<span class="comment-copy">@Kevin sure, but that isn't didactic. OP may want to know an abstract way to match types without having to hard-code the type name.</span>
