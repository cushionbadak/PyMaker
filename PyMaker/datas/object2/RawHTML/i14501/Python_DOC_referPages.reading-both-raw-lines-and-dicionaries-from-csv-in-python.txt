<div class="post-text" itemprop="text">
<p>My scenario: I am reading a csv file. I want to have access to both a dictionary of the fields generated by each line, and the raw, un-parsed line. </p>
<p>The goal is ultimately to do some processing on the fields, use the result to decide which lines I am interested in, and write those lines only into an output file. </p>
<p>An easy solution, involving reading the file twice looks something like:</p>
<pre><code>def dict_and_row(filename):
    with open(filename) as f:
        tmp = [row for row in DictReader(f)]

    with open(filename) as f:
        next(f)    # skip header
        for i, line in enumerate(f):
            if len(line.strip()) &gt; 0:
                yield line.strip(), tmp[i]
</code></pre>
<p>Any better suggestions? </p>
<p><strong>Edit</strong>: to be more specific about the usage scenario. I intended to index the lines by some of the data in the dict, and then use this index to find lines I am interested in. Something like:</p>
<pre><code>d = {}
for raw, parsed in dict_and_row(somefile):
      d[(parsed["SOMEFIELD"], parsed ["ANOTHERFIELD"])] = raw
</code></pre>
<p>and then later on </p>
<pre><code>for pair in some_other_source_of_pairs:
      if pair in d:
            output.write(d[pair])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I ended up wrapping the file with an object that saves the last line read, and the handing this object to the DictReader. </p>
<pre><code>class FileWrapper:
  def __init__(self, f):
    self.f = f
    self.last_line = None

  def __iter__(self):
    return self

  def __next__(self):
    self.last_line = next(self.f)
    return self.last_line
</code></pre>
<p>This could be then used this way:</p>
<pre><code>  f = FileWrapper(file_object)
  for row in csv.DictReader(f):
      print(row)   # that's the dict
      print(f.last_line)   # that's the line
</code></pre>
<p>Or I can implement <code>dict_and_row</code>:</p>
<pre><code> def dict_and_row(filename):
    with open(filename) as f:
         wrapper = FileWrapper(f)
         reader = DictReader(wrapper)
         for row in reader:
              yield row, wrapper.last_line 
</code></pre>
<p>This also allows access to other properties such as the number of characters read.</p>
<p>Not sure that's the best solution but it does have the advantage of retaining access to strings as they were originally read from the file.     </p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="http://pandas.pydata.org/" rel="nofollow">Pandas</a> which is an excellent library to do such kind of processing...</p>
<pre><code>import pandas as pd

# read the csv file
data = pd.read_csv('data.csv')

# do some calculation on a column and store it in another column
data['column2'] = data['column1'] * 2

# If you decide that you need only a particular set of rows
# that match some condition of yours
data = data[data['column2'] &gt; 100]

# store only particular columns back    
cols = ['column1', 'column2', 'column3']
data[cols].to_csv('data_edited.csv')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is similar to something that I had to do at one point.  I needed to put rows of properly-formatted CSV data into a list, manipulate it, and then save it.  I used <a href="https://docs.python.org/3/library/io.html#io.StringIO" rel="nofollow"><code>io.StringIO()</code></a> to get CSV to write to a list, then passed that back.  Without your data, I can't be 100% certain, but this should work.  Note that, rather than reading the file in twice, I'm reading it in once and then writing the relevant lines back into CSV format.</p>
<pre><code>import csv
from io import StringIO

def dict_and_row(filename):
    field_names = ['a', 'b']  # Your field names here.
    output = StringIO(newline='\n')
    with open(filename, 'r', newline='\n') as f:
        writer = csv.DictWriter(output, fieldnames=field_names)
        reader = csv.DictReader(f)

        writer.writeheader()  # If you want to return the header.
        for line in reader:
            if True:  # Do your processing here...
                writer.writerow(line)

    data = [line.strip() for line in output.getvalue().splitlines()]

    for line in data:
        yield line
</code></pre>
</div>
<span class="comment-copy">Can this processing be done on the parsed line as you get it from the reader?</span>
<span class="comment-copy">A bit more explanation might be helpful - what processing do you need to do? Why do you think you need the raw line and the dictionary? Could you use <code>DictWriter</code> for the output?</span>
<span class="comment-copy">@jonrsharpe - I suppose you're right about DictWriter. I could re-format the dictionary in the original order using the DictReader fieldnames, instead of saving the raw line.</span>
<span class="comment-copy">This is quite a good idea when working with improperly formatted csv files, where you will typically want diagnostics stats after running to validate your processing. Thank you for sharing this with us!</span>
