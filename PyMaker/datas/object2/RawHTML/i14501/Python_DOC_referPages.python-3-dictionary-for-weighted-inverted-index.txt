<div class="post-text" itemprop="text">
<p>First, this is homework, so I would just like suggestions, please. I am writing a program that generates a weighted inverted index. The weighted inverted index is a dictionary with a word as a key; the value is a list of lists, with each item in the list containing the document number, and the number of times that word appears in the document.</p>
<p>For example,</p>
<pre><code>{"a": [[1, 2],[2,1]]}
The word "a" appears twice in document 1 and once in document 2.
</code></pre>
<p>I am practicing with two small files.</p>
<p>file1.txt:</p>
<pre><code>    Where should I go
    When I want to have
    A smoke,
    A pancake, 
    and a nap.
</code></pre>
<p>file2.txt:</p>
<pre><code>I do not know
Where my pancake is
I want to take a nap.
</code></pre>
<p>Here is my program code:</p>
<pre><code>def cleanData(myFile):
    file = open(myFile, "r")

    data = file.read()
    wordList = []

    #All numbers and end-of-sentence punctuation
    #replaced with the empty string
    #No replacement of apostrophes
    formattedData = data.strip().lower().replace(",","")\
                 .replace(".","").replace("!","").replace("?","")\
                 .replace(";","").replace(":","").replace('"',"")\
                 .replace("1","").replace("2","").replace("3","")\
                 .replace("4","").replace("5","").replace("6","")\
                 .replace("7","").replace("8","").replace("9","")\
                 .replace("0","")

    words = formattedData.split() #creates a list of all words in the document
    for word in words:
        wordList.append(word)     #adds each word in a document to the word list
    return wordList

def main():

fullDict = {}

files = ["file1.txt", "file2.txt"]
docNumber = 1

for file in files:
    wordList = cleanData(file)

    for word in wordList:
        if word not in fullDict:
            fullDict[word] = []
            fileList = [docNumber, 1]
            fullDict[word].append(fileList)
        else:
            listOfValues = list(fullDict.values())
            for x in range(len(listOfValues)):
                if docNumber == listOfValues[x][0]:
                    listOfValues[x][1] +=1
                    fullDict[word] = listOfValues
                    break
            fileList = [docNumber,1]
            fullDict[word].append(fileList)

    docNumber +=1
return fullDict
</code></pre>
<p>What I am trying to do is generate something like this:</p>
<pre><code>{"a": [[1,3],[2,1]], "nap": [[1,1],[2,1]]}
</code></pre>
<p>What I am getting is this:</p>
<pre><code>{"a": [[1,1],[1,1],[1,1],[2,1]], "nap": [[1,1],[2,1]]}
</code></pre>
<p>It records all occurrences of each word in all documents, but it records repeats separately. I cannot figure this out. Any help would be appreciated! Thank you in advance. :)</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two main problems in your code.</p>
<p><strong>Problem 1</strong></p>
<pre><code>        listOfValues = list(fullDict.values())
        for x in range(len(listOfValues)):
            if docNumber == listOfValues[x][0]:
</code></pre>
<p>Here, you take all the values of the dictionary, <em>irrespective of the current word</em>, and incrementing the count, but you should be incrementing the count in the lists corresponding to the current word. So, you should change it to</p>
<pre><code>listOfValues = fullDict[word]
</code></pre>
<p><strong>Problem 2</strong></p>
<pre><code>        fileList = [docNumber,1]
        fullDict[word].append(fileList)
</code></pre>
<p>apart from incrementing the count for all the words, you are adding a new value to the <code>fullDict</code> always. But you should be adding it, only if the <code>docNumber</code> is not already there in the <code>listOfValues</code>. So, you can use an <code>else</code> with the <code>for</code> loop, like this</p>
<pre><code>    for word in wordList:
        if word not in fullDict:
            ....
        else:
            listOfValues = fullDict[word]
            for x in range(len(listOfValues)):
                ....
            else:
                fileList = [docNumber, 1]
                fullDict[word].append(fileList)
</code></pre>
<p>After making these two changes, I got the following output</p>
<pre><code>{'a': [[1, 3], [2, 1]],
 'and': [[1, 1]],
 'do': [[2, 1]],
 'go': [[1, 1]],
 'have': [[1, 1]],
 'i': [[1, 2], [2, 2]],
 'is': [[2, 1]],
 'know': [[2, 1]],
 'my': [[2, 1]],
 'nap': [[1, 1], [2, 1]],
 'not': [[2, 1]],
 'pancake': [[1, 1], [2, 1]],
 'should': [[1, 1]],
 'smoke': [[1, 1]],
 'take': [[2, 1]],
 'to': [[1, 1], [2, 1]],
 'want': [[1, 1], [2, 1]],
 'when': [[1, 1]],
 'where': [[1, 1], [2, 1]]}
</code></pre>
<hr/>
<p>There are few suggestions to improve your code.</p>
<ol>
<li><p>Instead of using lists to store the document number and the count, you can actually use a dictionary. That would make your life easier.</p></li>
<li><p>Instead of counting manually, you can use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a>.</p></li>
<li><p>Instead of using multiple replaces, you can use a simple regular expression, like this</p>
<pre><code>formattedData = re.sub(r'[.!?;:"0-9]', '', data.strip().lower())
</code></pre></li>
</ol>
<p>If I were to clean the <code>cleanData</code>, I would do it like this</p>
<pre><code>import re
def cleanData(myFile):
    with open(myFile, "r") as input_file:
        data = input_file.read()
    return re.sub(r'[.!?;:"0-9]', '', data.strip().lower()).split()
</code></pre>
<p>In the <code>main</code> loop, you can use the improvements suggested by Brad Budlong, like this</p>
<pre><code>def main():
    fullDict = {}
    files = ["file1.txt", "file2.txt"]
    for docNumber, currentFile in enumerate(files, 1):
        for word in cleanData(currentFile):
            if word not in fullDict:
                fullDict[word] = [[docNumber, 1]]
            else:
                for x in fullDict[word]:
                    if docNumber == x[0]:
                        x[1] += 1
                        break
                else:
                    fullDict[word].append([docNumber, 1])
    return fullDict
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My preferred implementation of the for loops doesn't iterate using a len and range functions.  Since these are all mutable lists, you don't need to know the index, you just need to have each of the lists and then can be modified without the index.  I replaced the for loop with the following and get the same output as thefourtheye.</p>
<pre><code>for word in wordList:
    if word not in fullDict:
        fullDict[word] = [[docNumber, 1]]
    else:
        for val in fullDict[word]:
            if val[0] == docNumber:
                val[1] += 1
                break
        else:
            fullDict[word].append([docNumber, 1])
</code></pre>
</div>
<span class="comment-copy">Perhaps Counter can be of use <a href="https://docs.python.org/3.4/library/collections.html#collections.Counter" rel="nofollow noreferrer">docs.python.org/3.4/library/â€¦</a></span>
<span class="comment-copy">Thank you for your suggestions! I accepted your answer :)</span>
