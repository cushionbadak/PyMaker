<div class="post-text" itemprop="text">
<p>Python code:</p>
<pre><code>import xml.etree.ElementTree as ET
root = ET.parse("h.xml")
print root.findall('saybye')
</code></pre>
<p>h.xml code:</p>
<pre><code>&lt;hello&gt;
  &lt;saybye&gt;
   &lt;saybye&gt;
   &lt;/saybye&gt;
  &lt;/saybye&gt;
  &lt;saybye&gt;
  &lt;/saybye&gt;
&lt;/hello&gt;
</code></pre>
<p>Code outputs,</p>
<pre><code>[&lt;Element 'saybye' at 0x7fdbcbbec690&gt;, &lt;Element 'saybye' at 0x7fdbcbbec790&gt;]
</code></pre>
<p><code>saybye</code> which is a child of another <code>saybye</code> is not selected here. So, how to instruct findall to recursively walk down the DOM tree and collect all three <code>saybye</code> elements? </p>
</div>
<div class="post-text" itemprop="text">
<p>Quoting <a href="https://docs.python.org/2/library/xml.etree.elementtree.html#finding-interesting-elements" rel="nofollow noreferrer"><code>findall</code></a>,</p>
<blockquote>
<p><code>Element.findall()</code> finds only elements with a tag which are direct children of the current element. </p>
</blockquote>
<p>Since it finds only the direct children, we need to recursively find other children, like this</p>
<pre><code>&gt;&gt;&gt; import xml.etree.ElementTree as ET
&gt;&gt;&gt; 
&gt;&gt;&gt; def find_rec(node, element, result):
...     for item in node.findall(element):
...         result.append(item)
...         find_rec(item, element, result)
...     return result
... 
&gt;&gt;&gt; find_rec(ET.parse("h.xml"), 'saybye', [])
[&lt;Element 'saybye' at 0x7f4fce206710&gt;, &lt;Element 'saybye' at 0x7f4fce206750&gt;, &lt;Element 'saybye' at 0x7f4fce2067d0&gt;]
</code></pre>
<p>Even better, make it a generator function, like this</p>
<pre><code>&gt;&gt;&gt; def find_rec(node, element):
...     for item in node.findall(element):
...         yield item
...         for child in find_rec(item, element):
...             yield child
... 
&gt;&gt;&gt; list(find_rec(ET.parse("h.xml"), 'saybye'))
[&lt;Element 'saybye' at 0x7f4fce206a50&gt;, &lt;Element 'saybye' at 0x7f4fce206ad0&gt;, &lt;Element 'saybye' at 0x7f4fce206b10&gt;]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From version 2.7 on, you can use <code>xml.etree.ElementTree.Element.iter</code>:</p>
<pre><code>import xml.etree.ElementTree as ET
root = ET.parse("h.xml")
print root.iter('saybye')
</code></pre>
<p>See <a href="https://docs.python.org/2/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element.iter" rel="noreferrer">19.7. xml.etree.ElementTree — The ElementTree XML API</a></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><code>Element.findall()</code> finds only elements with a tag which are direct children of the current element.</p>
</blockquote>
<p>we need to recursively traversing all childrens to find elements matching your element.
</p>
<pre><code>def find_rec(node, element):
    def _find_rec(node, element, result):
        for el in node.getchildren():
            _find_rec(el, element, result)
        if node.tag == element:
            result.append(node)
    res = list()
    _find_rec(node, element, res)
    return res
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you aren't afraid of a little XPath, you can use the <code>//</code> syntax that means find any descendant node:</p>
<pre class="lang-py prettyprint-override"><code>import xml.etree.ElementTree as ET
root = ET.parse("h.xml")
print root.findall('.//saybye')
</code></pre>
<p>Full XPath isn't supported, but here's the list of what is:
<a href="https://docs.python.org/2/library/xml.etree.elementtree.html#supported-xpath-syntax" rel="nofollow noreferrer">https://docs.python.org/2/library/xml.etree.elementtree.html#supported-xpath-syntax</a></p>
</div>
<span class="comment-copy">unfortunately they forgot the namespaces for that one</span>
<span class="comment-copy">@kassiopeia: I am not sure I understand what you mean. Could you help me out?</span>
<span class="comment-copy">In python 3 any of the functions <code>find()</code>, <code>findall()</code>, <code>findtext()</code> and even <code>iterfind()</code> have an optional <code>namespaces</code> argument to specify a dictionary with namespaces. Only <code>iter()</code> does not. See: <a href="https://docs.python.org/3/library/xml.etree.elementtree.html#elementtree-objects" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">I see, thank you for pointing this out.</span>
