<div class="post-text" itemprop="text">
<p>I have created a custom descriptor for configuration options that can be used to create classes like this:</p>
<pre><code>class Configuration(SomeSpecificBackend):
    basedir = ConfigurationProperty('basedir', int)
    logfile = ConfigurationProperty('logfile', Path)
</code></pre>
<p>The real instances contain a lot more properties. The problem is that I would like to have an <code>__init__</code> that allows me to initialise any properties I want upon construction, like this:</p>
<pre><code>    def __init__(self, basdir=None, logfile=None):
        if basedir is not None:
            self.basedir = basedir
        if logfile is not None:
            self.logfile = logfile
</code></pre>
<p>Since in practice there are many more properties, this becomes hard to maintain, and since the pattern here is very regular, I am wondering if there is a way to automatically provide this functionality.</p>
<p>My first draft was this class:</p>
<pre><code>class ConfigurationBase():
    def __init__(self, **kwargs):
        super().__init__()
        for key, value in kwargs.items():
            if hasattr(self, key): # don't create new attributes
                setattr(self, key, value)
</code></pre>
<p>This does what I want, but in some cases even more, since it also initialises attributes that are not configuration properties, which might cause problems with other base classes. I don't know how to fix that. <code>type(getattr(self, key))</code> does not yield <code>ConfigurationProperty</code>, but rather the type of the current value.</p>
<p>Also, it treats all <code>kwargs</code>  as configuration properties to be initialised. Some of them might be arguments for other base class constructors though, so I'd need to be able to distinguish that.</p>
<p>So, is there a way to provide this functionality in a generic way and safe way?</p>
</div>
<div class="post-text" itemprop="text">
<p>Simply use <code>locals</code>:</p>
<pre><code>def __init__(self, basdir=None, logfile=None):
    for name, value in locals().items():
        if values is not None and hasattr(self, name):
            setattr(self, name, value)
</code></pre>
<p>On the other hand, to automate this process even further, one can introduce a mapping configuration parameter -&gt; type and create and fill the properties dynamically:</p>
<pre><code>class Configuration(SomeSpecificBackend):
    CONFIGURATION_PROPERTIES = {
        'basedir': int,
        'logfile': Path,
    }
    for name, type_ in CONFIGURATION_PROPERTIES.items():
        locals()[name] = ConfigurationProperty(name, type_)

    def __init__(self, **properties):
        for name in self.CONFIGURATION_PROPERTIES:
            if name in properties:
                setattr(self, name, properties[name])
</code></pre>
</div>
<span class="comment-copy">How is <code>ConfigurationProperty</code> implemented? Because there's obviously some magic happening that transforms the return value from <code>getattr()</code>. You might also have a look at the differences between <code>__getattr__()</code> and <code>__getattribute__()</code> and maybe call <code>__getattr__()</code> directly.</span>
<span class="comment-copy"><code>ConfigurationProperty</code> is implemented using the <a href="https://docs.python.org/3.4/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a>. So yes, there is magic, but that is Python's built-in magic.</span>
<span class="comment-copy">In that case, the original <code>ConfigurationProperty</code> object should still be in <code>__class__.__dict__</code> (without the magic) and that type can be checked.</span>
<span class="comment-copy">Thanks, this significantly reduces the manual work, but it still requires me to list each property twice (once in the class, and once in the argument list of the initialiser). There should be a way to fix that as well.</span>
<span class="comment-copy">Often, it is better, not to put too much magic into an interface. With <code>**kwargs</code> it's harder to see, which arguments are allowed.</span>
<span class="comment-copy">I agree, but in this case the list of allowed arguments is actually right above the <code>__init__</code> function.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer">Modifying <code>locals</code> is undefined.</a> Also, there's no guarantee that Python won't inject things into <code>locals</code>, or that this will work well at all.</span>
<span class="comment-copy">@Bj√∂rnPollex What about if you do <code>help(Configuration)</code>? You'd still want debug information to show up, surely.</span>
