<div class="post-text" itemprop="text">
<p>Self-taught programming student, so I apologize for all the amateur mistakes. I want to learn some deeper subjects, so I'm trying to understand threading, and exception handling. </p>
<pre><code>import threading
import sys
from time import sleep
from random import randint as r

def waiter(n):
    print "Starting thread " + str(n)
    wait_time = r(1,10)
    sleep(wait_time)
    print "Exiting thread " + str(n)

if __name__=='__main__':
    try:
        for i in range(5):
            t = threading.Thread(target=waiter, args=(i+1,))
            t.daemon = True
            t.start()
            sleep(3)
        print 'All threads complete!'
        sys.exit(1)
    except KeyboardInterrupt:
        print ''
        sys.exit(1)
</code></pre>
<p>This script just starts and stops threads after a random time and will kill the program if it receives a <code>^C</code>. I've noticed that it doesn't print when some threads finish:</p>
<pre><code>Starting thread 1
Starting thread 2
Starting thread 3
Exiting thread 3
Exiting thread 2
Starting thread 4
Exiting thread 1
Exiting thread 4
Starting thread 5
All threads complete!
</code></pre>
<p>In this example, it never states it exits thread 5. I find I can fix this if I comment out the <code>t.daemon = True</code> statement, but then exception handling waits for any threads to finish up.</p>
<pre><code>Starting thread 1
Starting thread 2
^C
Exiting thread 1
Exiting thread 2
</code></pre>
<p>I can understand that when dealing with threads, it's best that they complete what they're handling before exiting, but I'm just curious as to why this is. I'd really appreciate any answers regarding the nature of threading and daemons to guide my understanding.</p>
</div>
<div class="post-text" itemprop="text">
<p>The whole <em>point</em> of a daemon thread is that if it's not finished by the time the main thread finishes, it gets summarily killed. Quoting <a href="https://docs.python.org/3/library/threading.html#thread-objects" rel="nofollow">the docs</a>:</p>
<blockquote>
<p>A thread can be flagged as a “daemon thread”. The significance of this flag is that the entire Python program exits when only daemon threads are left. The initial value is inherited from the creating thread. The flag can be set through the daemon property or the daemon constructor argument.</p>
<p>Note Daemon threads are abruptly stopped at shutdown. Their resources (such as open files, database transactions, etc.) may not be released properly. If you want your threads to stop gracefully, make them non-daemonic and use a suitable signalling mechanism such as an Event.</p>
</blockquote>
<p>Now, look at your logic. The main thread only sleeps for 3 seconds after starting thread 5. But thread 5 can sleep for anywhere from 1-10 seconds. So, about 70% of the time, it's not going to be finished by the time the main thread wakes up, prints "All threads complete!", and exits. But thread 5 is still asleep for another 5 seconds. In which case thread 5 will be killed without ever going to print "Exiting thread 5".</p>
<p>If this isn't the behavior you want—if you want the main thread to wait for all the threads to finish—then don't use daemon threads.</p>
</div>
<span class="comment-copy">I suspect what you're <i>actually</i> looking for is a way to have threads that normally act like normal threads, but that can be asynchronously killed like daemon-threads when you really want (e.g., if the user desperately needs to ^C the app), right? That's tricky to do, but not impossible.</span>
<span class="comment-copy">@abarnert that's not initially what I was trying to do, but now that you mention it I would like to see how that would be done. I don't really have any need for this knowledge at this moment (not scripting anything important or worthwhile), I just want to develop an understanding because I enjoy this sort of thing :)</span>
<span class="comment-copy">For example: Use daemon threads, but pretend you didn't in most of your code. Exit by waiting on all the workers to signal you that they're done (using some sync object). Exit early signaling all of them to exit (note that this means you need to refactor the workers so they check the flag and sync object regularly) and then waiting for them. Exit early and quickly with by signaling them, waiting for them with timeout, then exit (this means they need to almost always check the flag within that timeout). Exit early and immediately by just exiting.</span>
<span class="comment-copy">@abarnert ... Well I'm sure how I'm doing it will work just fine for now lol thank you for the explanation. I don't understand most of it but in 5 years time when I actually learn this stuff from somewhere I'll look back on your comment and think, "Ah yes, how stupid I was."</span>
<span class="comment-copy">Or, if we're still writing concurrent code at the low level (threads and sync objects), it'll be for massively-non-uniform systems with 16 full cores, 256 micro-cores, and thousands of SIMD channels and GPU lanes, and everything I know today will be hopelessly wrong. :)</span>
<span class="comment-copy">I see, that makes sense. So I assume that any thread that handles critical and sensitive data (ie, a thread that should not be abruptly killed) should not be flagged as a daemon thread?</span>
<span class="comment-copy">@dbishop: In general, yes. But if your sensitive-data-handling thread can do its work in batches "on the side" and then commit each one atomically (e.g., writing to a tempfile, then moving that tempfile to the permanent location), it can be safely killable.</span>
<span class="comment-copy">@dbishop: Also, it's possible to use synchronization mechanisms to have the main thread signal the workers that it's time to shut down and give them some time to all respond, only bailing and letting them be killed if they don't respond fast enough. This kind of design is common for things that need to be "pretty reliable" but not 100%, like web server connection handlers.</span>
<span class="comment-copy">Gotcha. I think I'm understanding a little bit better now. Thanks for all the help! Much appreciated!</span>
