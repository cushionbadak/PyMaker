<div class="post-text" itemprop="text">
<p>I am calculating Euclidean Distance with python code below:</p>
<pre><code>def getNeighbors(trainingSet, testInstance, k, labels):
    distances = []
    for x in range(len(trainingSet)):
        dist = math.sqrt(((testInstance[0] - trainingSet[x][0]) ** 2) +    ((testInstance[1] - trainingSet[x][1]) ** 2))
        distances.append([dist, labels[x]])
    distances = np.array(distances)   
    return distances
</code></pre>
<p>For calculating distance of a given point with 10 other points, it's good. But when I calculate distance of a point with 18563 other points, then the computer gets hanged and don't response for around 3 Hrs.</p>
<p><strong>How can I make calculation for</strong> 18563 <strong>points faster?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>You can speed this up by converting to NumPy first, then using vector operations, instead of doing the work in a loop, then converting to NumPy. Something like this:</p>
<pre><code>trainingArray = np.array(trainingSet)
distances = ((testInstance[0] - trainingArray[:, 0]) ** 2 +
             (testInstance[1] - trainingArray[:, 1]) ** 2).sqrt()
</code></pre>
<p>(That's obviously untested, because without enough context to know what's actually in those variables I had to guess, but it will be something close to that.)</p>
<p>There are other things you can do to squeeze out a few extra %—try replacing the <code>** 2</code> with self-multiplication or the <code>sqrt</code> with <code>** .5</code>, or (probably best) replacing the whole thing with <code>np.hypot</code>. (If you don't know how to use <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow"><code>timeit</code></a>—or, even better, IPython and it's <code>%timeit</code> magic—now is a great time to learn.)</p>
<p>But ultimately, this is just going to give you a constant-multiplier speedup of about an order of magnitude. Maybe it takes 15 minutes instead of 3 hours. That's nice, but… why is it taking 3 hours in the first place? What you're doing here should be taking on the order of seconds, or even less. There's clearly something much bigger wrong here, like maybe you're calling this function N**2 times when you think you're only calling it once. And you really need to fix that part.</p>
<p>Of course it's still worth doing this. First, element-wise operations are simpler and more readable than loops, and harder to get wrong. Second, even if you reduce the whole program to 3.8 seconds, you'll be happy for the order-of-magnitude speedup to 0.38 seconds, right?</p>
</div>
<span class="comment-copy">you may use <code>math.hypot(x, y)</code> instead of <code>dist = math.sqrt(((testInstance[0] - trainingSet[x][0]) ** 2) +    ((testInstance[1] - trainingSet[x][1]) ** 2))</code>, and <code>xrange</code>instead of <code>range</code></span>
<span class="comment-copy">Are you doing anything that might require pairwise distances, or are you only calculating distances to one distinguished point? Pairwise distances for 18563 points are going to take a lot longer, simply because there are about 172 million of them to calculate.</span>
<span class="comment-copy">I am taking one example and calculating it's distances with other points.</span>
<span class="comment-copy">Don't use for loops to do heavy lifting (in python). Either vectorize so you can numpy or use something different like cython or numba.</span>
<span class="comment-copy">Can you give a <a href="http://stackoverflow.com/help/mcve">complete minimal example</a> instead of just this function on its own? Because if you're just calling this once, even with a list of 18563 points, it really shouldn't take long at all. It's not clear what you <i>are</i> doing that's taking 3 hours, but the little 5% optimizations that people can make to just this code in isolation aren't going to help (except to reduce it to 2 hours and 51 minutes).</span>
<span class="comment-copy">what is <code>trainingArray</code> for ?</span>
<span class="comment-copy">@user2831683: It's a NumPy <code>array</code> with the same elements as are in the <code>list</code> or <code>set</code> or whatever in <code>trainingSet</code>. By making it a NumPy <code>array</code> instead of a native Python collection, we can do NumPy slicing—and, more importantly, NumPy vectorized operations.</span>
<span class="comment-copy">I meant, you aren't using it.</span>
<span class="comment-copy">@user2831683: Oh, thanks! Fixed.</span>
<span class="comment-copy">@abarnert in answer to my own question, for 18563 points: <code>** 0.5</code> and <code>np.sqrt()</code> take 0.77ms <code>np.hypot()</code> and self multiplication (instead of <code>** 2</code>) take 1.14ms. Obviously your other points are the critical step here (both these values are effectively instantaneous c.f. 3h) but interesting to know when squeezing the last bit of speed out.</span>
