<div class="post-text" itemprop="text">
<p>I receive a byte-array buffer from network, containing many fields. When I want to print the buffer, I get the following error:</p>
<blockquote>
<p>(:ord() expected string of length 1, int
  found</p>
</blockquote>
<pre><code> print(" ".join("{:02X}".format(ord(c)) for c in buf))
</code></pre>
<p>How can I fix this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python <code>bytearray</code> and <code>bytes</code> objects yield integers when iterating or indexing, not characters. Remove the <code>ord()</code> call:</p>
<pre><code>print(" ".join("{:02X}".format(c) for c in buf))
</code></pre>
<p>From the <a href="https://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow"><em><code>Bytes</code></em> documentation</a>:</p>
<blockquote>
<p>While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that <code>0 &lt;= x &lt; 256</code> (attempts to violate this restriction will trigger <code>ValueError</code>. This is done deliberately to emphasise that while many binary formats include ASCII based elements and can be usefully manipulated with some text-oriented algorithms, this is not generally the case for arbitrary binary data (blindly applying text processing algorithms to binary data formats that are not ASCII compatible will usually lead to data corruption).</p>
</blockquote>
<p>and further on:</p>
<blockquote>
<p>Since bytes objects are sequences of integers (akin to a tuple), for a bytes object <em>b</em>, <code>b[0]</code> will be an integer, while <code>b[0:1]</code> will be a bytes object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1)</p>
</blockquote>
<p>I'd not use <code>str.format()</code> where a <a href="https://docs.python.org/3/library/functions.html#format" rel="nofollow"><code>format()</code> function</a> will do; there is no larger string to interpolate the hex digits into:</p>
<pre><code>print(" ".join([format(c, "02X") for c in buf]))
</code></pre>
<p>For <code>str.join()</code> calls, using list comprehension is marginally faster as the <code>str.join()</code> call has to convert the iterable to a list <em>anyway</em>; it needs to do a double scan to build the output.</p>
</div>
