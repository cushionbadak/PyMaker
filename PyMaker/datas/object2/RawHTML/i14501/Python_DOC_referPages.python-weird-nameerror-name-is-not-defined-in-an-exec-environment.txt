<div class="post-text" itemprop="text">
<p>I was confident to have at least some basic understanding of Python's scope system. Now I get an error and unfortunately I'm not even able to write a good code snippet for reproduction so far. I tried to reproduce it in a new small project, but everything works as I expect there :-/</p>
<p>I can only describe what I do and hopefully somebody detects a pattern and can tell me what possibly goes wrong here.</p>
<p>At first there is a python file <code>x.py</code> which implements a class <code>X</code>.</p>
<p>In some other python file, there is the following string:</p>
<pre><code>code="""
...
from x import X
...
class Y(X): # does not crash here, ...
    def __init__(self):
        X.__init__(self) # ... but here
        ...
foo=Y()
"""
</code></pre>
<p>You can assume that python is able to find the <code>x</code> module. At some place, I try to execute that:</p>
<pre><code>exec(code, globals(), locals())
</code></pre>
<p>And now I get the <code>NameError</code>. It tells me that <code>X</code> is not defined when it tries to call it's constructor. It was obviously defined a few lines above.</p>
<p>If I modify <code>Y.__init__</code> with adding <code>from x import X</code> as first line, it works. But why the hell do I have to import it again there?</p>
<p>As already indicated, the actual code is more complex and does more things. In an unlucky case, my posting does not even show the part which actually leads to the problem. But maybe you have some general ideas, how one can get such a behaviour.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is just a guess, because you haven't shown us enough code, and what you've shown us doesn't actually reproduce the problem, but…</p>
<p>If you're doing this <code>exec</code> inside a function, then <code>locals()</code> and <code>globals()</code> are going to be different. In which case the code will be executed as if it were inside a class definition. So, it'll be (sort of) as if you did this:</p>
<pre><code>class _:
    from x import X
    class Y(X): # does not crash here, ...
        def __init__(self):
            X.__init__(self) # ... but here
    foo=Y()
del _
</code></pre>
<p>(I previously thought you'd have to <em>also</em> be doing something like <code>Y()</code> outside the <code>exec</code>, but <a href="https://stackoverflow.com/a/29979677/908494">user2357112's answer</a> convinced me that isn't necessary.)</p>
<p>If that's your problem, you may be able to fix it by just calling <code>exec(code, globals(), globals())</code> or <code>exec(code, locals(), locals())</code>. (Which one is appropriate, if either, depends on what you're actually trying to do, of course, which you haven't told us.)</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/functions.html#exec" rel="noreferrer"><code>exec</code> documentation</a>:</p>
<blockquote>
<p>If exec gets two separate objects as globals and locals, the code will be executed as if it were embedded in a class definition.</p>
</blockquote>
<p>There are good reasons for this, which I won't go into here.</p>
<p>Functions defined in a class definition don't look in the scope of the class definition for variable resolution. When you <code>exec</code> your <code>code</code>, it's actually executed like this:</p>
<pre><code>class Dummy:
    from x import X
    ...
    class Y(X):
        def __init__(self):
            X.__init__(self)
            ...
    foo=Y()
</code></pre>
<p>That means this function:</p>
<pre><code>def __init__(self):
    X.__init__(self)
</code></pre>
<p>doesn't see this variable:</p>
<pre><code>from x import X
</code></pre>
<p>even though this bit:</p>
<pre><code>class Y(X):
</code></pre>
<p>does see it.</p>
</div>
<span class="comment-copy">Just out of curiosity, why call <code>X.__init__(self)</code> and not <code>X(self)</code></span>
<span class="comment-copy">I don't immediately see the problem, and it depends what else has happened to the global namespace, but usually you'd use <code>super(Y, self).__init__()</code> for such a case and avoid the whole issue.</span>
<span class="comment-copy">... well, just because I wasn't aware of that shortcut. But using it doesn't change anything about the error :(</span>
<span class="comment-copy">Nothing changes the global namespace between the definition of Y and the instantiation which crashes. There really really is no code inbetween.</span>
<span class="comment-copy">There is nothing wrong in what you have shown. what are the lines you are not showing?</span>
<span class="comment-copy">I don't quite follow this... Why would <code>Y()</code> work in one scope and fail in a different scope, even though <code>Y</code> refers to the same class in both scopes?</span>
<span class="comment-copy">I think the recommendation in the last paragraph is probably right, regardless.</span>
<span class="comment-copy">Yeah, you were correct with your guesses ;) Great, thank you! I call <code>exec</code> in my real code from inside a function. In my test code, it was not in a function, so globals() and locals() maybe returned the same thing which leads to another behavior of <code>exec</code> (as you mentioned).</span>
<span class="comment-copy">@abarnet Ah, OK, I see you've edited the part of the answer I wasn't following, so everything makes sense now.</span>
<span class="comment-copy">@JasonOrendorff: Yeah, I upvoted user2357112's answer, but mine had already been accepted, so rather than delete it I corrected it.</span>
<span class="comment-copy">I'm pretty sure this isn't quite right—if it were, his code as posted would raise, and it doesn't. That's why I think there has to be something else going on. My best guess, as in my answer, is that his actual code, unlike his example, is constructing <code>Y</code> instances <i>outside</i> the <code>exec</code>, after the dummy class definition has finished executing and its scope has gone away and <code>X</code> is no longer available (or only available as a class attribute on an inaccessible class). But that's just a wild guess.</span>
<span class="comment-copy">@abarnert: I'm not sure what you mean when you say it doesn't raise.</span>
<span class="comment-copy">Take his code, remove the <code>...</code>s, create a <code>x.py</code> with <code>class X: pass</code>, and run it. No exception. Everything works. (The OP admitted from the start that his example isn't an MCVE because he's been unable to come up with a simple reproduction of the problem, and later edited it to make that even clearer: "In an unlucky case, my posting does not even show the part which actually leads to the problem.")</span>
<span class="comment-copy">For that matter, just take your "as-if" code, remove the <code>...</code>s, and run it. It'll execute just fine, and you can verify that <code>Dummy.foo</code> is an instance of <code>__main__.Dummy.Y</code>. So, <code>Y.__init__</code>  is clearly able to see <code>X</code> at execution time.</span>
<span class="comment-copy">@abarnert: I'm trying to run a simple example through ideone, but it's not loading. I don't have Python 3; could you link me an example?</span>
