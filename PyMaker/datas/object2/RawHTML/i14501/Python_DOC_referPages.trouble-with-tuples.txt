<div class="post-text" itemprop="text">
<p>I'm doing some OOP in Python and I'm having trouble when the user inputs a tuple as one of the arguments. Here's the code:</p>
<pre><code>class Height:
    def __init__(self,ft,inch=0):
        if isinstance(ft,tuple):
            self.feet = ft
            self.inches = inch
        elif isinstance(ft,int):
            self.feet = ft // 12
            self.inches = ft % 12
    def __str__(self):
        return str(self.feet) + " Feet " + str(self.inches) + " Inches"
    def __repr__(self):
        return "Height (" + str(self.feet * 12 + self.inches) + ")"
</code></pre>
<p>I tried thought initializing  the inch to 0 would help thing out but that didn't work. Tuples also don't support indexing so that option was also non-existent. I feel like the answer is simple and I'm just overthinking it. The test code that I'm using is: </p>
<pre><code>from height import *
def test(ht):
    """tests the __str__, __repr__, and to_feet methods for the height
   Height-&gt;None"""
    #print("In inches: " + str(ht.to_inches()))
    #print("In feet and inches: " + str(ht.to_feet_and_inches()))
    print("Convert to string: " + str(ht))
    print("Internal representation: " + repr(ht))
    print()
print("Creating ht1: Height(5,6)...")
ht1 = Height(5,6)
test(ht1)
print("Creating ht2: Height(4,13)...")
ht2 = Height(4,13)
test(ht2)
print("Creating ht3: Height(50)...")
ht3 = Height(50)
test(ht3)
</code></pre>
<p>My code works as expected when an <code>int</code> is input but, again, I can't seem to figure it out when a tuple is input. Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you really being passed a tuple? It looks to me that your constructor should simply be:</p>
<pre><code>def __init__(self, ft, inch=0):
   self.ft = int(ft)
   self.inch = int(inch)
</code></pre>
<p>That works if you create your object with any of these (because you have a default value for the <code>inch</code> argument): </p>
<pre><code>foo = Height(6)
bar = Height(6, 3)
baz = Height("5", 3)
</code></pre>
<p>etc. Note that in the second and third instances, you still aren't being passed a tuple. In order to actually receive a tuple, you'd need to call it like this:</p>
<pre><code>foo2 = Height((6, 3))
</code></pre>
<p>or use the '*' operator in the constructor declaration.</p>
</div>
<div class="post-text" itemprop="text">
<p>Tuples <em>do</em> support indexing. They don't support index assignment, because they are immutable, but do support index access.</p>
<p>Your code isn't working because your code is designed to accept the tuple in as <code>ft</code>. It isn't doing anything to <code>int</code>, which is an entirely different argument. All you need to do is use indexing instead:</p>
<pre><code>class Height:
    def __init__(self,ft,inch=0):
        if isinstance(ft,tuple):
            self.feet = ft[0]
            self.inches = ft[1]
        elif isinstance(ft,int):
            self.feet = ft // 12
            self.inches = ft % 12
    def __str__(self):
        return str(self.feet) + " Feet " + str(self.inches) + " Inches"
    def __repr__(self):
        return "Height (" + str(self.feet * 12 + self.inches) + ")"
</code></pre>
<p>However, this only works if you actually pass in a tuple, which your test code never does! <code>Height(5,6)</code> is just passing in two arguments. For a tuple input, you'd need <code>Height((5,6))</code>.</p>
<p>As others have noted, the way you are calling it actually makes more sense than using a tuple. To get that working, you just need to see if your second argument is being used (and let's change to v1 and v2, for reasons I'll get to later):</p>
<pre><code>def __init__(self, v1, v2=None): # set v2 to None, and then check to see if it isn't None
    if v2 is not None:
        self.feet = v1
        self.inches = v2
    else:
        self.feet = v1 // 12
        self.inches = v1 % 12
</code></pre>
<p>But this has a usability problem: the meaning of the first argument depends on whether there is a second argument there! That's why naming it <code>ft</code> is particularly bad: if the second argument isn't provided, it's actually in inches!</p>
<p>One solution to this is to make <em>both</em> arguments have names, allowing the user to choose the ones they want to use:</p>
<pre><code>def __init__(self, feet=0, inches=0):
    self.feet = feet + inches // 12
    self.inches = inches % 12
</code></pre>
<p>Then you have many choices, and less chance for confusion:</p>
<pre><code>In [4]: str(Height(5,0))
Out[4]: '5 Feet 0 Inches'

In [5]: str(Height(0,5))
Out[5]: '0 Feet 5 Inches'

In [6]: str(Height(5))
Out[6]: '5 Feet 0 Inches'

In [7]: str(Height(inches=25))
Out[7]: '2 Feet 1 Inches'

In [8]: str(Height(feet=3,inches=25))
Out[8]: '5 Feet 1 Inches'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have numerous problems in your code, from formatting to functionality. Most important is this:</p>
<pre><code>elif isinstance(ft,int):
    self.feet = ft // 12
    self.inches = ft % 12
</code></pre>
<p>so if the user passes a number <strong>in feet</strong>, it's assumed to actually be <strong>in inches</strong>? Why?!</p>
<hr/>
<p>I think you are fundamentally mistaking what happens when you call e.g.</p>
<pre><code>Height(5, 10)
</code></pre>
<p>Inside <code>__init__</code>, this effectively sets <code>ft = 5</code> and <code>inch = 10</code>, <strong>not</strong> <code>ft = (5, 10)</code>.</p>
<hr/>
<p>Here's how I'd have done it:</p>
<pre><code>class Height:

    def __init__(self, feet=0, inches=0):
        self.feet, self.inches = feet, inches % 12
        self.feet += inches // 12

    def __str__(self):
        return '{0.feet}\' {0.inches}"'.format(self)

    def __repr__(self):
        return 'Height({0.feet}, {0.inches})'.format(self)
</code></pre>
<p>This allows any of the following to work correctly:</p>
<pre><code>&gt;&gt;&gt; Height()
Height(0, 0)
&gt;&gt;&gt; Height(5, 0)
Height(5, 0)
&gt;&gt;&gt; Height(5)
Height(5, 0)
&gt;&gt;&gt; Height(inches=60)
Height(5, 0)
&gt;&gt;&gt; print(str(Height(inches=123)))
10' 3"
</code></pre>
<p>Note also use of <a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="nofollow"><code>str.format</code></a> and compliance with <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow">the style guide</a>. Another alternative would be to raise an error if <code>inches &gt; 11 and feet &gt; 0</code>, as that is potentially erroneous input. You might also want to look into <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow">emulating numeric types</a>.</p>
</div>
<span class="comment-copy">tuples do support indexing.</span>
<span class="comment-copy">Having a star trek reference in the question title gets an upvote from me :)</span>
<span class="comment-copy">@PadraicCunningham (Since when does <code>a = (2, 0); print(a[0])</code> throw an IndexError ? Tuples support indexing...) Sorry, forget what I've said, I misread your comment... My apologizes!!</span>
<span class="comment-copy">Why do you <i>want</i> a tuple input? Why would the user call <code>Height((5, 5))</code> instead of <code>Height(5, 5)</code>? Note you can unpack a tuple as arguments: <code>Height(*(5, 5))</code> (see e.g. <a href="http://stackoverflow.com/q/36901/3001761">stackoverflow.com/q/36901/3001761</a>). Also, you seem to be mixing up <i>feet</i> and <i>inches</i>, which is a pretty critical failure when that's the core of your code.</span>
<span class="comment-copy">Nowhere in your test code are you passing in a tuple... just two arguments.</span>
<span class="comment-copy">While this is the better way to go about things, I should point out that Trevor's Height object takes interprets <code>ft</code> as being in inches if there is only one argument.</span>
<span class="comment-copy">Good point. Actually makes more sense to maintain the value internally in one unit anyway (either feet or inches [or mm or whatever]), then convert it to human-familiar feet/inches on output, as needed.</span>
<span class="comment-copy">It should be clearer now.</span>
