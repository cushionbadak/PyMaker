<div class="post-text" itemprop="text">
<p>This is a bit of a silly thing, but I want to know if there is concise way in Python to define class variables that contain string representations of their own names.  For example, one can define:</p>
<pre><code>class foo(object):
    bar = 'bar'
    baz = 'baz'
    baf = 'baf'
</code></pre>
<p>Probably a more concise way to write it in terms of lines consumed is:</p>
<pre><code>class foo(object):
    bar, baz, baf = 'bar', 'baz', 'baf'
</code></pre>
<p>Even there, though, I still have to type each identifier twice, once on each side of the assignment, and the opportunity for typos is rife.</p>
<p>What I want is something like what <code>sympy</code> provides in its <code>var</code> method:</p>
<pre><code>sympy.var('a,b,c')
</code></pre>
<p>The above injects into the namespace the variables <code>a</code>, <code>b</code>, and <code>c</code>, defined as the corresponding <code>sympy</code> symbolic variables.</p>
<p>Is there something comparable that would do this for plain strings?</p>
<pre><code>class foo(object):
    [nifty thing]('bar', 'baz', 'baf')
</code></pre>
<p><strong>EDIT:</strong> To note, I want to be able to access these as separate identifiers in code that uses <code>foo</code>:</p>
<pre><code>&gt;&gt;&gt; f = foo(); print(f.bar)
bar
</code></pre>
<p><strong>ADDENDUM:</strong> Given the interest in the question, I thought I'd provide more context on why I want to do this.  I have two use-cases at present: (1) typecodes for a set of custom exceptions (each <code>Exception</code> subclass has a distinct typecode set); and (2) lightweight enum.  My desired feature set is:</p>
<ol>
<li>Only having to type the typecode / enum name (or value) once in the source definition. <code>class foo(object): bar = 'bar'</code> works fine but means I have to type it out twice in-source, which gets annoying for longer names and exposes a typo risk.</li>
<li>Valid typecodes / enum values exposed for IDE autocomplete.</li>
<li><p>Values stored internally as comprehensible strings:</p>
<ol>
<li>For the <code>Exception</code> subclasses, I want to be able to define <code>myError.__str__</code> as just something like <code>return self.typecode + ": " + self.message + " (" + self.source + ")"</code>, without having to do a whole lot of <code>dict</code>-fu to back-reference an <code>int</code> value of <code>self.typecode</code> to a comprehensible and meaningful string.</li>
<li><p>For the enums, I want to just be able to obtain <code>widget</code> as output from <code>e = myEnum.widget; print(e)</code>, again without a lot of <code>dict</code>-fu. </p>
<ul>
<li>I recognize this will increase overhead. My application is not speed-sensitive (GUI-based tool for driving a separate program), so I don't think this will matter at all.</li>
</ul></li>
</ol></li>
<li><p>Straightforward membership testing, by also including (say) a <code>frozenset</code> containing all of the typecodes / enum string values as <code>myError.typecodes</code>/<code>myEnum.E</code> classes.  This addresses potential problems from accidental (or intentional.. but why?!) use of an invalid typecode / enum string  via simple sanity checks like <code>if not enumVal in myEnum.E: raise(ValueError('Invalid enum value: ' + str(enumVal)))</code>.</p></li>
<li>Ability to import individual enum / exception subclasses via, say, <code>from errmodule import squirrelerror</code>, to avoid cluttering the namespace of the usage environment with non-relevant exception subclasses.  I believe this prohibits any solutions requiring post-twiddling on the module level like what Sinux proposed.</li>
<li>For the enum use case, I would rather avoid introducing an additional package dependency since I don't (think I) care about any extra functionality available in the official <code>enum</code> class. In any event, it still wouldn't resolve #1.</li>
</ol>
<p>I've already figured out implementation I'm satisfied with for all of the above but #1.  My interest in a solution to #1 (without breaking the others) is partly a desire to typo-proof entry of the typecode / enum values into source, and partly plain ol' laziness.  (Says the guy who just typed up a gigantic SO question on the topic.)</p>
</div>
<div class="post-text" itemprop="text">
<p>I recommend using <a href="https://docs.python.org/2/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="nofollow"><code>collections.namedtuple</code></a>:</p>
<p><strong>Example:</strong></p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple as nifty_thing
&gt;&gt;&gt; Data = nifty_thing("Data", ["foo", "bar", "baz"])
&gt;&gt;&gt; data = Data(foo=1, bar=2, baz=3)
&gt;&gt;&gt; data.foo
1
&gt;&gt;&gt; data.bar
2
&gt;&gt;&gt; data.baz
3
</code></pre>
<p><strong>Side Note:</strong> If you are using/on Python 3.x I'd recommend <a href="https://docs.python.org/3/library/enum.html" rel="nofollow">Enum</a> as per @user2357112's comment. This is the standardized approach going forward for Python 3+</p>
<p><strong>Update:</strong> Okay so if I understand the OP's <em>exact</em> requirement(s) here I think the only way to do this (<em>and presumably <code>sympy</code> does this too</em>) is to inject the names/variables into the <code>globals()</code> or <code>locals()</code> namespaces. Example:</p>
<pre><code>#!/usr/bin/env python


def nifty_thing(*names):
    d = globals()
    for name in names:
        d[name] = None


nifty_thing("foo", "bar", "baz")

print foo, bar, bar
</code></pre>
<p>Output:</p>
<pre><code>$ python foo.py 
None None None
</code></pre>
<p><strong>NB:</strong> <em>I don't really recommend this!</em> :)</p>
<p><strong>Update #2:</strong> The other example you showed in your question is implemented like this:</p>
<pre><code>#!/usr/bin/env python


import sys


def nifty_thing(*names):
    frame = sys._getframe(1)
    locals = frame.f_locals

    for name in names:
        locals[name] = None


class foo(object):

    nifty_thing("foo", "bar", "baz")


f = foo()

print f.foo, f.bar, f.bar
</code></pre>
<p>Output:</p>
<pre><code>$ python foo.py 
None None None
</code></pre>
<p><strong>NB:</strong> This is inspired by <code>zope.interface.implements()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>current_list  = ['bar', 'baz', 'baf']

class foo(object):
    """to be added"""

for i in current_list:
    setattr(foo, i, i)
</code></pre>
<p>then run this:</p>
<pre><code>&gt;&gt;&gt;f = foo()
&gt;&gt;&gt;print(f.bar)
bar
&gt;&gt;&gt;print(f.baz)
baz
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This doesn't work exactly like what you asked for, but it seems like it should do the job:</p>
<pre><code>class AutoNamespace(object):
    def __init__(self, names):
        try:
            # Support space-separated name strings
            names = names.split()
        except AttributeError:
            pass
        for name in names:
            setattr(self, name, name)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; x = AutoNamespace('a b c')
&gt;&gt;&gt; x.a
'a'
</code></pre>
<p>If you want to do what SymPy does with <code>var</code>, you can, but I would strongly recommend against it. That said, here's a function based on the source code of <code>sympy.var</code>:</p>
<pre><code>def var(names):
    from inspect import currentframe
    frame = currentframe().f_back
    try:
        names = names.split()
    except AttributeError:
        pass
    for name in names:
        frame.f_globals[name] = name
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; var('foo bar baz')
&gt;&gt;&gt; bar
'bar'
</code></pre>
<p>It'll always create global variables, even if you call it from inside a function or class. <code>inspect</code> is used to get at the caller's globals, whereas <code>globals()</code> would get <code>var</code>'s own globals.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about you define the variable as emtpy string and then get their name:</p>
<pre><code>class foo(object):
    def __getitem__(self, item):
        return item


foo = foo()
print foo['test']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an extension of bman's idea. This has its advantages and disadvantages, but at least it does work with some autocompleters.</p>
<pre><code>class FooMeta(type):
    def __getattr__(self, attr):
        return attr

    def __dir__(self):
        return ['bar', 'baz', 'baf']

class foo:
    __metaclass__ = FooMeta
</code></pre>
<p>This allows access like <code>foo.xxx</code> â†’ <code>'xxx'</code> for all <code>xxx</code>, but also guides autocomplete through <code>__dir__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Figured out what I was looking for:</p>
<pre><code>&gt;&gt;&gt; class tester:
...     E = frozenset(['this', 'that', 'the', 'other'])
...     for s in E:
...         exec(str(s) + "='" + str(s) + "'") # &lt;--- THIS
...         
&gt;&gt;&gt; tester()
&lt;__main__.tester instance at 0x03018BE8&gt;
&gt;&gt;&gt; t = tester()
&gt;&gt;&gt; t.this
'this'
&gt;&gt;&gt; t.that in tester.E
True
</code></pre>
<p>Only have to define the element strings once, and I'm pretty sure it will work for all of my requirements listed in the question.  In actual implementation, I plan to encapsulate the <code>str(s) + "='" + str(s) + "'"</code> in a helper function, so that I can just call <code>exec(helper(s))</code> in the <code>for</code> loop.  (I'm pretty sure that the <code>exec</code> has to be placed in the body of the class, not in the helper function, or else the new variables would be injected into the (transitory) scope of the helper function, not that of the class.)</p>
<p><strong>EDIT:</strong> Upon detailed testing, this DOES NOT WORK -- the use of <code>exec</code> prevents the introspection of the IDE from knowing of the existence of the created variables.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you can achieve a rather beautiful solution using metaclasses, but I'm not fluent enough in using those to present that as an answer, but I do have an option which seems to work rather nicely:</p>
<pre><code>def new_enum(name, *class_members):                
    """Builds a class &lt;name&gt; with &lt;class_members&gt; having the name as value."""

    return type(name, (object, ), { val : val for val in class_members })

Foo = new_enum('Foo', 'bar', 'baz', 'baf')
</code></pre>
<p>This should recreate the class you've given as example, and if you want you can change the inheritance by changing the second parameter of the call to <a href="//docs.python.org/2.7/library/functions.html?highlight=type#type" rel="nofollow"><em>class</em> <code>type</code>(<em>name</em>, <em>bases</em>, <em>dict</em>)</a>. </p>
</div>
<span class="comment-copy">How about using <code>namedtuple</code>(s)?</span>
<span class="comment-copy">This seems like an odd requirement. Why do you need this?</span>
<span class="comment-copy">@JamesMills Ahh, yeah, <code>namedtuple</code> might do it. I knew about them, actually, but hadn't thought of using them this way.</span>
<span class="comment-copy">@Brian: Have you considered using <a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">enums</a>? They're a Python 3.4 feature with a <a href="https://pypi.python.org/pypi/enum34" rel="nofollow noreferrer">backported version</a> for Python 2 and Python 3 versions before 3.4.</span>
<span class="comment-copy">When <code>enum</code> was being discussed for addition to the stdlib, about 69105 different enum libraries were built and uploaded to PyPI or posted on ActiveState to demonstrate all the possible features, including string enums that don't require a value. Even if you don't want to actually <i>use</i> one of them, you can look through the code to see all the different ways of doing all the different things similar to what you asked for.</span>
<span class="comment-copy">Ahhh, but it still requires <code>Data(foo=1, ...)</code>.  I don't want to have to supply extra values for the members, and I don't want to have to instantiate a new <code>namedtuple</code> type <i>and</i> an instance of the new type every time I have the list of things.  It's quicker/easier just to type in the names twice.</span>
<span class="comment-copy">This doesn't really seem to do what the OP is looking for. The attributes don't automatically hold string representations of their names, and you have to specify both name and value.</span>
<span class="comment-copy">James, +1 for <code>import namedtuple as nifty_thing</code>. :-)</span>
<span class="comment-copy">Yeah, I may not have accurately described what I was actually looking for in OP. (May not have had a clear idea in my head...)</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer">Modifying <code>locals</code> is implementation-defined and not guaranteed to work.</a></span>
<span class="comment-copy">Testing now.....</span>
<span class="comment-copy">This gives me what I want. I can define multiple classes in a module all with a <code>typecodes</code> variable that's a <code>frozenset</code> of strings; I can then put <code>for c in [class1, class2, class3, ...]: for t in c.typecodes: setattr(c,t,t)</code> at the end of the module. Having to tag those extra <code>for</code> loops at the end is disappointing, but I get the structure I want &amp; it avoids risk of typos.</span>
<span class="comment-copy">Ahhhh, it's not quite what I want after all.  The <code>setattr</code> call has to come on the module level, and I want to be able to <code>from module import foo</code>, in which case the module-level <code>for</code> loops won't be executed.</span>
<span class="comment-copy">I like this solution, but it doesn't quite align with how I want to use it. In particular, I don't know if subclassing <code>__init__</code> is feasible. See my edit just now to OP.</span>
<span class="comment-copy">I don't want to have to index using magic strings, or define an external library of string keys elsewhere in code.  I want the variable to appear as a class member, so that I can exploit IDE autocomplete.</span>
<span class="comment-copy"><i>sigh</i> <code>exec()</code> seriously? :P</span>
<span class="comment-copy">@JamesMills &lt;hangs head, closes IDE, burns laptop&gt;</span>
<span class="comment-copy">Oh it's <i>okay</i>; it's not that bad :) (<i>yes it is!</i>) :P</span>
<span class="comment-copy">@JamesMills In all seriousness, constructed as it is, is it a massive security hole? Or just hacktastic to the max?</span>
<span class="comment-copy">That <i>depends</i> -- Do you trust the data that's being <code>eval()</code>'d?</span>
