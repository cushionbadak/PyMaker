<div class="post-text" itemprop="text">
<p>I'm writing two scripts which are intended to be run from the command line.  Let's call them <code>foo.py</code> and <code>bar.py</code>.  In addition, I have a utility module called <code>util</code> which is to be shared by both of these scripts.  How do I structure my code so that <code>foo</code> and <code>bar</code> can both have a simple line like <code>import util</code>?  Currently, my directory structure is like this:</p>
<pre><code>MyProject
\--foo
   \--foo.py
   \--foo_util.py
\--bar
   \--bar.py
   \--bar_util.py
\--util
   \--util.py
</code></pre>
<p>Within <code>foo</code>, I want to be able to write <code>import foo_util</code> and <code>import util</code> but I dont' want to be able to write <code>import bar</code>, because they are independent programs which have no reason to use each others' code.</p>
<p>Update: A slightly modified version of chepner's solution, I've found something that seems to work for me.  My project is now structured like this:</p>
<pre><code>MyProject
   \--__init__.py
   \--foo.py
   \--bar.py
   \--MyProject
      \--__init__.py
      \--foo
         \--__init__.py
         \--foo_impl.py
      \--bar
         \--__init__.py
         \--bar_impl.py
      \--shared
         \--__init__.py
         \--util.py
</code></pre>
<p><code>foo.py</code> can write <code>import MyProject.foo as foo</code> and <code>bar.py</code> can do something similar, and both <code>foo</code> and <code>bar</code> can do <code>import MyProject.shared</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest the following layout: <code>foo.py</code> and <code>bar.py</code>, as scripts, can be placed anywhere. You should install in a known place the following packages:</p>
<pre><code>&lt;known location, such as /usr/lib/python/site-packages&gt;
\--foo
   \--util.py
\--bar
   \--util.py
\--util.py
</code></pre>
<p>Then, use <code>import foo.util</code>, <code>import bar.util</code>, and <code>import util</code> to access the individual modules where and when necessary.</p>
<p>As abarnert pointed out, you can't hide <code>bar/util.py</code> from <code>foo</code>, nor should you care about doing so.</p>
</div>
<div class="post-text" itemprop="text">
<p>Put <code>util</code> in <code>site-packages</code>. That's where any modules that you want to be able to <code>import</code> into multiple projects are supposed to go.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>import util</code>, given your current structure, does not import your util: it imports Python's util module. To solve this, you have to add __init__.py to util directory, which makes it valid Python package.</p>
<p>In order to import your util, you can either do relative import (which would violate your second wish and require even your app to be a package) or use <code>PYTHONPATH</code> to run your script.</p>
<pre><code>PYTHONPATH="../util" python foo.py
</code></pre>
<p>If you wanted to use util as a library, it belongs to a <code>site-packages</code> directory, located implicitly in <code>PYTHONPATH</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think what you're missing here is that building an installable <code>setuptools</code>-based package solves your problem <em>without actually requiring you to install anything system-wide</em>.</p>
<p>First, this kind of thing is exactly what <a href="https://virtualenv.pypa.io/" rel="nofollow"><code>virtualenv</code></a> was created for. (Or, if you're on 3.4+, the stdlib's <a href="https://docs.python.org/3/library/venv.html" rel="nofollow"><code>venv</code></a>.) You create a new virtual environment. Within that environment, you <code>pip install .</code> your <code>util</code> library, and now it's in that environment's <code>site-packages</code>. And then you can run <code>foo</code> and <code>bar</code> and whatever else you want inside that environment, and they can all <code>import util</code>—but nothing has changed in your main system environment.</p>
<p>Even if you don't want to use <code>virtualenv</code> for some reason (but you really should…), if you build your setup right, it will allow you to run everything in "development" mode, which does a fake install to a directory under your source tree and sets up all the links to make it work. This can be a bit fussy when you're trying to install multiple separate scripts as well as modules that they share, but it does work.</p>
<p>A full tutorial on how to layout distributions, make <code>setuptools</code> auto-generate the wrapper scripts and install them to <code>bin</code>, etc. is way too big for an answer here, and the PyPA people <a href="https://packaging.python.org/" rel="nofollow">already wrote one</a>. There are some complicated bits, so you probably will get stuck at some point, but when you do, you'll have another good question to ask at SO. :)</p>
</div>
<span class="comment-copy">First, Python (and <code>setuptools</code>) was designed to make this easy if you write your code to be <i>installed</i>. You'll end up with a <code>util</code> package, a <code>foo</code> package, and a <code>bar</code> package in site-packages, and auto-generated scripts named <code>foo</code> and <code>bar</code> in your bin directory. Or, when run in "development" mode, all those things will get packed up somewhere under your source tree so you can access them as if they were in site-packages and bin. Then you don't have to worry about the details of getting the layout you want in the source tree.</span>
<span class="comment-copy">Second, why do you care about actually <i>preventing</i> <code>foo</code> code from doing an <code>import bar</code>? It's your code; just don't import it and it won't be a problem.</span>
<span class="comment-copy">But if you really must do this, you can have a <code>sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), 'util'))</code> or similar at the start of <code>foo.py</code> and <code>bar.py</code>.</span>
<span class="comment-copy">I'm not crazy about the idea of using <code>setuptools</code> or installing the package.  I'd like to be able to have an approach that doesn't require installing anything.  Is it possible to have a <code>site-packages</code> folder that is private to a package?  So that even if nothing is installed, the script is just run from a random location, it will find the <code>site-packages</code> and add those moduels to sys.path?</span>
<span class="comment-copy">Again, you don't actually <i>have</i> to install the setuptools package to use it; that's what development mode is for. But you still design it so that it <i>could</i> be installed. And besides, why aren't you crazy about using <code>setuptools</code>? That's the standard, recommended way to do things. Anything else you do is going to be at least somewhat idiosyncratic and hacky, and have less support from the tools, and for what benefit?</span>
<span class="comment-copy">Stupid autocorrect.</span>
<span class="comment-copy">Thanks, I accepted your answer.  This at least pointed me in the right direction.  I did something slightly different because I didn't want to install to a known location, but you helped get me there.</span>
<span class="comment-copy">By "known", I mainly just meant somewhere in your script's <code>PYTHONPATH</code>, rather than assuming the modules were in the same directory as the script.</span>
<span class="comment-copy">The global <code>site-packages</code>, or is it possible to have a local <code>site-packages</code>?  Because I dont' want random other packages to be able to import it.  (Not that they would, but still I would prefer if stuff that is logically private to my project were also physically private to my project)</span>
<span class="comment-copy">@ZacharyTurner: It's not <i>directly</i> possible to have a local <code>site-packages</code> (per-user <code>site-packages</code>, yes, but that's probably not enough here), but simulating that's exactly the point of <a href="https://virtualenv.pypa.io/" rel="nofollow noreferrer"><code>virtualenv</code></a> (or, if you're on 3.4+, the <code>venv</code> in the stdlib).</span>
<span class="comment-copy">@ZacharyTurner: What you're describing makes no sense. Either <code>foo</code> and <code>bar</code> are entirely unrelated Python projects that both benefit from a general module <code>util</code>, in which case you should put <code>util</code> in <code>site-packages</code> as I suggested, or <code>util</code> is not a general module and can only ever be useful in <code>foo</code> and <code>bar</code>, which means that <code>foo</code> and <code>bar</code> are related. If <code>util</code> is a general module, that means it could be useful in any project. That doesn't mean it's useful in every project. IE, there is a general module for XML parsing. It could be useful in any project. Not every project uses it.</span>
<span class="comment-copy">Even if it's only useful in <code>foo</code> and <code>bar</code>, that doesn't mean <code>foo</code> and <code>bar</code> are useful to each other.  That's why you typically layer your components, one on top of the other.  For example, do <code>foo</code> and <code>bar</code> need access to each others' command line options?  Certainly not.  Nor do they need access to any other parts of each other that are specific to the execution of those individual scripts.  The whole point of creating something like <code>util</code> is so that the stuff that <i>is</i> useful to both of them, can be visible to both of them, while leaving the stuff that they don't care about elsewhere.</span>
