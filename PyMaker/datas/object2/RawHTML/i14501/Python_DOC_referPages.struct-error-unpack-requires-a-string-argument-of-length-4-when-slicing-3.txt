<div class="post-text" itemprop="text">
<p>I have a problem with a little server-client assignment in python 2.7.</p>
<p>The client can send 5 types of requests to the server:</p>
<ol>
<li>get the server's IP</li>
<li>get contents of a directory on the server</li>
<li>run cmd command on the server and get the output</li>
<li>open a calculator on the server</li>
<li>disconnect</li>
</ol>
<p>This is the error I get:</p>
<pre><code>error:
msg_type, data_len = unpack("BH", client_structs[:3])
struct.error: unpack requires a string argument of length 4
</code></pre>
<p>Code:</p>
<pre><code>client_structs = client_soc.recv(1024)
msg_type, data_len = unpack("BH", client_structs[:3])
</code></pre>
<p>Doesn't the substring contain 4 chars including the null?</p>
<p>Would appreciate explanation about this error + how to solve it.</p>
<p>Entire server code:</p>
<pre><code>__author__ = 'eyal'

from struct import pack, unpack, calcsize
import socket
from os import listdir
from subprocess import check_output, call


def server():
    ser_soc = socket.socket()
    ser_soc.bind(("0.0.0.0", 8080))
    ser_soc.listen(1)
    while True:
        accept_flag = raw_input("Would you like to wait for a client? (y/n) ")
        if accept_flag == "y":
            client_soc, client_address = ser_soc.accept()
            while True:
                client_structs = client_soc.recv(1024)
                data_size = calcsize(client_structs) - 3
                data_str = 'c' * data_size
                unpacked_data = unpack("BH" + data_str, client_structs)
                if unpacked_data[0] == 1:
                    ip = socket.gethostbyname(socket.gethostname())
                    ip_data = 'c' * len(ip)
                    to_send = pack("BH" + str(len(ip)) + ip_data, unpacked_data[0], len(ip), ip)
                elif unpacked_data[0] == 2:
                    content = listdir(str(unpacked_data[2]))
                    content_str = "\r\n".join(content)
                    content_data = 'c' * len(content_str)
                    to_send = pack("BH" + str(len(content_str)) + content_data, unpacked_data[0],
                                   len(content_str), content_str)
                elif unpacked_data[0] == 3:
                    command = str(unpacked_data[2:]).split()
                    output = check_output(command)
                    message_data = 'c' * len(output)
                    to_send = pack("BH" + message_data, unpacked_data[0], len(output), output)
                elif unpacked_data[0] == 4:
                    call("gnome-calculator")
                    msg_data = 'c' * len("The calculator is open.")
                    to_send = pack("BH" + msg_data, unpacked_data[0], len("The calculator is open."),
                                   "The calculator is open.")
                elif unpacked_data[0] == 5:
                    client_soc.close()
                    break
                else:
                    to_send = pack("BH" + 'c' * len("invalid message type, try again"),
                                   unpacked_data[0], len("invalid message type, try again"),
                                   "invalid message type, try again")
                if unpacked_data[0] != 5:
                    client_soc.send(to_send)
        else:
            break
    ser_soc.close()


def main():
    server()


if __name__ == "__main__":
    main()
</code></pre>
<p>Entire client code:</p>
<pre><code>__author__ = 'eyal'


from struct import pack, unpack, calcsize
import socket


def client():
    my_soc = socket.socket()
    my_soc.connect(("127.0.0.1", 8080))
    while True:
        send_flag = raw_input("Would you like to send the server a request? (y/n) ")
        if send_flag == "y":
            msg_code = input("What type of request would you like to send?\n"
                             "1. Get the server's IP address.\n"
                             "2. Get content of a directory on the server.\n"
                             "3. Run a terminal command on the server and get the output.\n"
                             "4. Open a calculator on the server.\n"
                             "5. Disconnect from the server.\n"
                             "Your choice: ")
            if msg_code == 1 or msg_code == 4 or msg_code == 5:
                to_send = pack("BH", msg_code, 0)
            elif msg_code == 2:
                path = raw_input("Enter path of wanted directory to get content of: ")
                to_send = pack("BH" + 'c' * len(path), msg_code, len(path), path)
            elif msg_code == 3:
                command = raw_input("Enter the wanted terminal command, including arguments: ")
                to_send = pack("BH" + 'c' * len(command), msg_code, len(command), command)
            else:
                print "Invalid message code, try again\n"

            if 1 &lt;= msg_code &lt;= 5:
                my_soc.send(to_send)
        else:
            break
    data = my_soc.recv(1024)
    unpacked_data = unpack("BH" + 'c' * (calcsize(data) - 3), data)
    print "The server's response to your type-" + str(msg_code) + " request:"
    print unpacked_data[2]
    my_soc.close()


def main():
    client()


if __name__ == "__main__":
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is explained <a href="https://docs.python.org/3/library/struct.html" rel="nofollow">in a big box at the very top of the docs</a>:</p>
<blockquote>
<p><strong>Note</strong> By default, the result of packing a given C struct includes pad bytes in order to maintain proper alignment for the C types involved; similarly, alignment is taken into account when unpacking. This behavior is chosen so that the bytes of a packed struct correspond exactly to the layout in memory of the corresponding C struct. To handle platform-independent data formats or omit implicit pad bytes, use standard size and alignment instead of native size and alignment: see <a href="https://docs.python.org/3/library/struct.html#struct-alignment" rel="nofollow"><em>Byte Order, Size, and Alignment</em></a> for details.</p>
</blockquote>
<p>So, on most platforms, <code>'BH'</code> is 4 bytes—1 byte for the <code>B</code>, 1 byte of padding so the <code>H</code> ends up aligned, and 2 bytes for the <code>H</code>. But on some platforms it might be 3 bytes, or 6. For that matter, <code>B</code> and <code>H</code> aren't even guaranteed to be 1 and 2 bytes respectively in native format, so it could be 17 bytes.</p>
<p>If you don't want that, because you're using this for a network protocol rather than for accessing C structs in memory, don't use the default native order, padding, and alignment. On all platforms, <code>'&gt;BH'</code> is 3 bytes—1 byte for the <code>B</code>, and 2 for the <code>H</code>. (And the <code>H</code> is always in network order, even if one of the two machines communicating is little-endian.)</p>
<hr/>
<p>If you <em>do</em> want that, then use <code>[:struct.calcsize('BH')]</code> instead of <code>[:3]</code>, to make sure you read the right number of bytes for your platform. But honestly, if you do want that, you're shouldn't.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why would there be any null included? The slice includes 3 characters, which is exactly how many you specified — indexed 0 to 2.</p>
<p>Instead, slice it with <code>client_structs[:4]</code>. (Or, as <a href="https://stackoverflow.com/a/29997265/4099598">abarnert points out</a>, slice <code>[:3]</code> or <code>[:struct.calcsize('&gt;BH')]</code> <strong>and</strong> pack/unpack with <code>"&gt;BH"</code> to avoid endianness problems.)</p>
<p>Python is not as tricky about most fencepost errors as most C-ish languages, so you may have inadvertently gotten too clever for yourself.</p>
</div>
<span class="comment-copy">If you are using Python 2.7 or later, use <code>unpack_from</code>, and you can simply pass the entire string; <code>unpack_from</code> will use the bytes it needs and ignore the rest.</span>
<span class="comment-copy">Meanwhile, just as I said on <a href="http://stackoverflow.com/questions/29996458/struct-error-bad-char-in-struct-format">your previous question</a>, stop posting a dump of your entire code. Create an <a href="http://stackoverflow.com/help/mcve">MCVE</a> that shows the part that's relevant, and explains what it's actually supposed to do and what it's doing differently, instead of making us read all of your code and guess at what it's supposed to do differently from what it actually does.</span>
