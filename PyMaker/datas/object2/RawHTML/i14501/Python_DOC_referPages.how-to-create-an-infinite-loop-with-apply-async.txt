<div class="post-text" itemprop="text">
<p>I havea pool of processes with apply_async in which the different processes take different times to provide output. Once one process is finished I do some calculations with their output. After I want to launch another process. In this way I want to create an infinite loop which launches processes, reads the output of the recently finished process, does some calculations and relaunches another process.</p>
<p>So far I have been able to do what I want except that the main process gets stuck in the get() function. This because I don't know which process terminated and hence which entry of results I should do get().</p>
<p>Some attempt code:</p>
<pre><code>import multiprocessing as mp
import numpy as np
from time import sleep


def squared(x,y):
    result = np.array((x,x))
    if x%2 == 0:
    sleep(2) 
return result




if __name__ == "__main__":

    pool = mp.Pool() 

    pool_r = []
    for i in xrange(0,8):
        pool_r.append(pool.apply_async(squared, (i,i)))

    count_results = 0

    for j in xrange(0,10):
        result = pool_r[count_results].get()
        print result
        count_results += 1
        pool_r.append(pool.apply_async(squared, (j,j)))

    pool.close()
    pool.join()
</code></pre>
<p>And the output is: 
    [0 0]
    [1 1]
    [2 2]
    [3 3]
    [4 4]
    [5 5]
    [6 6]
    [7 7]
    [0 0]
    [1 1]</p>
<p>Instead of the odd numbers first and then the even ones (since these ones have a sleep).</p>
<p>Any suggestions?</p>
<hr/>
<p>Thank you very much for your fast reply abarnert. </p>
<p>In reality I want to keep an infinite loop after the processes are completed (I need their results to be able to enter the loop). </p>
<p>Q1 - If I create a pool with 30 works can I submit more than 30 processes? Will the computer wait for one to finish to put another to work? </p>
<p>Q2 - In your code there is a callback function. However, the code that the I need to run when one worker finishes has to be in the main process since I have to update variables which will be sent to the new processes that I create.</p>
<p>Q3 - The code that the main process does takes, let say 10% of the time that the processes need to realize their tasks. So is it a good approach to have the main process to realize some calculations and then launch new processes? </p>
<p>Q4 - Right now if I <kbd>Ctrl</kbd>+<kbd>C</kbd> the code only terminates when all the processes are over. What can I do to be able to terminate the code as soon as I do <kbd>Ctrl</kbd>+<kbd>C</kbd>? And finally, after my comment do you think futures is still the way to go?</p>
<p>Some pseudo-code for what I need:</p>
<pre><code>launch several processes
wait for the results

launch several processes

while True:

    get results from a recently finished process

    do some calculations

    launch two more processes

    # some ending condition
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you're waiting for the results in the order the jobs were issued, rather than the order they finished. So, if job 1 finishes before job 0, it doesn't matter; you're still waiting on job 0.</p>
<p>Fundamentally, the problem is that <code>apply_async</code> returns <code>AsyncResult</code> objects, which are not composable futures, but you want to use them as if they were. You can't do that. There's no way to wait on a bunch of <code>AsyncResult</code>s in parallel until one of them finishes. If you want that, use <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow"><code>concurrent.futures</code></a> insteadâ€”or, for Python 2.7, the backport on PyPI, <a href="https://pypi.python.org/pypi/futures" rel="nofollow"><code>futures</code></a>; then you can call <code>wait</code> on any sequence of futures, or iterate over <code>as_completed</code>.</p>
<p>You <em>can</em> simulate this on top of <code>AsyncResult</code> by using callbacks instead of <code>wait</code>, but that's making your life harder than it needs to be, because you have to turn the flow of control inside-out. Something like:</p>
<pre><code>pool = mp.Pool() 

count_results = 0
def handle_result(result):
    global count_results, done
    print result
    if count_results &lt; 10:
        pool.apply_async(squared, (count_results, count_results),
                         callback=handle_result)
    elif count_results == 18:
        pool.close()
    count_results += 1

for i in xrange(0,8):
    pool.apply_async(squared, (i,i), callback=handle_result)

pool.join()
</code></pre>
</div>
