<div class="post-text" itemprop="text">
<p>I have a string like</p>
<pre><code>foo/bar/baz
</code></pre>
<p>I also have <code>val=1</code> for example. Is there a clean way to split the <code>foo/bar/baz</code> into a multi-dimensional dict with the last item in the dict to equal 1. So it would look like</p>
<pre><code>{'foo': {'bar': {'baz': 1}}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/functions.html#reduce" rel="noreferrer"><code>reduce</code></a> and <a href="https://docs.python.org/2/library/functions.html#reversed" rel="noreferrer"><code>reversed</code></a> functions, like this</p>
<pre><code>&gt;&gt;&gt; reduce(lambda res, cur: {cur: res}, reversed("foo/bar/baz".split("/")), 1)
{'foo': {'bar': {'baz': 1}}}
</code></pre>
<p>If you are using Python 3.x, then you need to import <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="noreferrer"><code>reduce</code> from <code>functools</code></a></p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; reduce(lambda res, cur: {cur: res}, reversed("foo/bar/baz".split("/")), 1)
{'foo': {'bar': {'baz': 1}}}
</code></pre>
<p>Here, the last argument to <code>reduce</code> is the starting value. It will take values one by one from the iterable passed, call the function with the result and the current value and then the next time onwards, the last result will be the first argument and the current value as the second argument. When the iterable is exhausted, it will return the result.</p>
<p>So, the execution would have gone, step-by-step, as following</p>
<p>Let's say <code>func</code> is the lambda function and it gets repeatedly called like this</p>
<pre><code>func(1, "baz")                   =&gt; {"baz": 1}
func({"baz": 1}, "bar")          =&gt; {"bar": {"baz": 1}}
func({"bar": {"baz": 1}}, "foo") =&gt; {"foo": {"bar": {"baz": 1}}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>d = 1
for part in reversed(s.split('/')):
    d = {part: d}
</code></pre>
<p>If this needs to be extended to create something like a directory tree, you might want a solution based on <code>defaultdict</code>:</p>
<pre><code>import collections

def tree():
    return collections.defaultdict(tree)

def parsetree(path_strings):
    t = tree()
    for s in path_strings:
        temp = t
        parts = s.split('/')
        for part in parts[:-1]:
            temp = temp[part]
        temp[parts[-1]] = 1
    return t
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; t = parsetree([
...     'foo/bar/baz',
...     'foo/bar/bop',
...     'foo/spam'
... ])
&gt;&gt;&gt; t['foo']['bar']['baz']
1
&gt;&gt;&gt; t['foo']['spam']
1
</code></pre>
</div>
