<div class="post-text" itemprop="text">
<p>I'm trying to test a context manager that makes use of a class that uses some <code>__getattr__</code> magic to resolve several attributes which don't actually exist on the class.  I'm running into a problem where mock is raising an AttributeError when trying to patch the class.</p>
<p>Simplified example of objects I want to patch.</p>
<pre><code>class MyClass(object):
    def __getattr__(self, attr):
        if attr == 'myfunc':
            return lambda:return None
        raise AttributeError('error')


class MyContextManager(object):
    def __init__(self):
        super(MyContextManager, self).__init__()
        self.myclass = MyClass()

    def __enter__(self):
        pass

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.myclass.myfunc()
</code></pre>
<p>Test code</p>
<pre><code>def test_MyContextManager():
    with patch.object(MyClass, 'myfunc', return_value=None) as mock_obj:
        with MyContextManager():
             pass

    # Do some tests on mock object
</code></pre>
<p>Here is the error I get:</p>
<pre><code>AttributeError: &lt;class 'MyClass'&gt; does not have the attribute 'myfunc'
</code></pre>
<p>I'm able to do this and run the test, but it doesn't restore the attribute (or simply remove the mock attribute in this case) automatically:</p>
<pre><code>MyClass.myfunc= Mock(return_value=None)
</code></pre>
<p>I'm open to using another library besides mock to achieve this.  I'm also using pytest.</p>
</div>
<div class="post-text" itemprop="text">
<p>To use <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="noreferrer">patch</a> in these kind of tests you should use <code>create</code> parameter that will force to create the attribute if not exist.</p>
<p>So your test should do something like this:</p>
<pre><code>def test_MyContextManager():
    with patch.object(MyClass, 'myfunc', create=True, return_value=None) as mock_obj:
        with MyContextManager():
             pass
</code></pre>
</div>
