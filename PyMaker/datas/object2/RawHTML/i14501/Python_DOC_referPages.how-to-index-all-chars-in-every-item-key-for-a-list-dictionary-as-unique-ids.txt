<div class="post-text" itemprop="text">
<p>I would like to know if there is a more efficient way to reference every index of every item/key in a list/dictionary. <a href="http://justpaste.it/ATGC" rel="nofollow">Here's a bigger sample dictionary.</a></p>
<pre><code>raw_dict = {'atgc': 1, 't': 0, 'gcccctttc': 1, 'cttc': 1}
sorted_list = sorted(list(raw_dict))
translation = dict()
i_all = 0
for i_list, item in enumerate(sorted_list):
    for i_item in range(len(item)):
        translation[i_all] = ([i_list, i_item])
        i_all += 1

print sorted_list
# output ['atgc', 'cttc', 'gcccctttc', 't']

print translation
# output {0: [0, 0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [1, 0], 5: [1, 1], 6: [1, 2], 7: [1, 3], 8: [2, 0], 9: [2, 1], 10: [2, 2], 11: [2, 3], 12: [2, 4], 13: [2, 5], 14: [2, 6], 15: [2, 7], 16: [2, 8], 17: [3, 0]}
</code></pre>
<p>The indices 'i_all' are analogous to a hypothetical string 'atgccttcgcccctttct', joining the sorted 'raw_dict' keys</p>
<p>I want to use an index of all characters to make substrings with variable lengths and variable start indices for keys in 'raw_dict'. However, I can't actually join all keys as a string since that may generate substrings which don't exist. </p>
</div>
<div class="post-text" itemprop="text">
<p>I’m not sure what you are trying to do (e.g. it’s strange that you are never actually using the <em>values</em> of the initial dictionary), but here is how to produce a similar list using <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehensions</a>:</p>
<pre><code># Replace .keys() with .iterkeys() if using Python 2
&gt;&gt;&gt; r = [(i, j) for i, k in enumerate(sorted(raw_dict.keys())) for j in range(len(k))]
&gt;&gt;&gt; print(r)
[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (3, 0)]
</code></pre>
<p>If you actually want to get a <em>dict</em>, as in your example, then:</p>
<pre><code>&gt;&gt;&gt; s = {i: v for i, v in enumerate(r)}
&gt;&gt;&gt; print(s)
0: (0, 0), 1: (0, 1), 2: (0, 2), 3: (0, 3), 4: (1, 0), 5: (1, 1), 6: (1, 2), 7: (1, 3), 8: (2, 0), 9: (2, 1), 10: (2, 2), 11: (2, 3), 12: (2, 4), 13: (2, 5), 14: (2, 6), 15: (2, 7), 16: (2, 8), 17: (3, 0)}
</code></pre>
<p>(And I used a <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow">dict comprehension</a> here.)</p>
</div>
<span class="comment-copy">This doesn't make any sense to me.  The "yields something like" output that you give seems to bear no relation to your sample dictionary.  I can't figure out what you're trying to do.  What do you mean by "index all chars" or "to reference every index"?  I understand each word but the sentences mean nothing.  Clarify what you mean by the weird phrase "item/key for a list/dictionary".  At least try to rewrite that without using the /.</span>
<span class="comment-copy">I understand. I'm updating the question now.</span>
<span class="comment-copy">I didn't fully understand the question. But i believe Collections module can help you here.</span>
<span class="comment-copy">There are 2 options to reference each character: use an index pair or, use a master index referencing an index pair. I hadn't thought of using a pair of indices as a unique id. The unique id will later be used to conditionally generate substrings marked as useful or to be ignored.</span>
<span class="comment-copy">@mattkaeo Ok then, but you don’t need a <code>dict</code> in this case, you can refer to an item of a <code>list</code> by index as well.</span>
<span class="comment-copy">I am using a dictionary so that I may quickly remove indices from substring consideration in each iteration of a loop.</span>
<span class="comment-copy">@mattkaeo You need a <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer">set</a> then.</span>
<span class="comment-copy">I think using a set of unique ids as tuples of index pairs is the best solution.</span>
