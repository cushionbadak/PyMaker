<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/222877/what-does-super-do-in-python">What does 'super' do in Python?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>I'm trying to understand the use of <code>super()</code>. From the looks of it, both child classes can be created, just fine. </p>
<p>I'm curious to know about the actual difference between the following 2 child classes.</p>
<pre><code>class Base(object):
    def __init__(self):
        print "Base created"

class ChildA(Base):
    def __init__(self):
        Base.__init__(self)

class ChildB(Base):
    def __init__(self):
        super(ChildB, self).__init__()

ChildA() 
ChildB()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>super()</code> lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=236275" rel="noreferrer">fun stuff</a> can happen. See the <a href="https://docs.python.org/2/library/functions.html#super" rel="noreferrer">standard docs on super</a> if you haven't already.</p>
<p>Note that <a href="https://docs.python.org/3/library/functions.html#super" rel="noreferrer">the syntax changed in Python 3.0</a>: you can just say <code>super().__init__()</code> instead of <code>super(ChildB, self).__init__()</code> which IMO is quite a bit nicer. The standard docs also refer to a <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="noreferrer">guide to using super()</a> which is quite explanatory.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>I'm trying to understand <code>super()</code></h2>
</blockquote>
<p>The reason we use <code>super</code> is so that child classes that may be using cooperative multiple inheritance will call the correct next parent class function in the Method Resolution Order (MRO).</p>
<p>In Python 3, we can call it like this:</p>
<pre><code>class ChildB(Base):
    def __init__(self):
        super().__init__() 
</code></pre>
<p>In Python 2, we are required to use it like this:</p>
<pre><code>        super(ChildB, self).__init__()
</code></pre>
<p>Without super, you are limited in your ability to use multiple inheritance:</p>
<pre><code>        Base.__init__(self) # Avoid this.
</code></pre>
<p>I further explain below.</p>
<blockquote>
<h2>"What difference is there actually in this code?:"</h2>
</blockquote>
<pre><code>class ChildA(Base):
    def __init__(self):
        Base.__init__(self)

class ChildB(Base):
    def __init__(self):
        super(ChildB, self).__init__()
        # super().__init__() # you can call super like this in Python 3!
</code></pre>
<p>The primary difference in this code is that you get a layer of indirection in the <code>__init__</code> with <code>super</code>, which uses the current class to determine the next class's <code>__init__</code> to look up in the MRO.</p>
<p>I illustrate this difference in an answer at the <a href="https://stackoverflow.com/a/33469090/541136">canonical question, How to use 'super' in Python?</a>, which demonstrates <strong>dependency injection</strong> and <strong>cooperative multiple inheritance</strong>.</p>
<h2>If Python didn't have <code>super</code></h2>
<p>Here's code that's actually closely equivalent to <code>super</code> (how it's implemented in C, minus some checking and fallback behavior, and translated to Python):</p>
<pre><code>class ChildB(Base):
    def __init__(self):
        mro = type(self).mro()             # Get the Method Resolution Order.
        check_next = mro.index(ChildB) + 1 # Start looking after *this* class.
        while check_next &lt; len(mro):
            next_class = mro[check_next]
            if '__init__' in next_class.__dict__:
                next_class.__init__(self)
                break
            check_next += 1
</code></pre>
<p>Written a little more like native Python:</p>
<pre><code>class ChildB(Base):
    def __init__(self):
        mro = type(self).mro()
        for next_class in mro[mro.index(ChildB) + 1:]: # slice to end
            if hasattr(next_class, '__init__'):
                next_class.__init__(self)
                break
</code></pre>
<p>If we didn't have the <code>super</code> object, we'd have to write this manual code everywhere (or recreate it!) to ensure that we call the proper next method in the Method Resolution Order!</p>
<p>How does super do this in Python 3 without being told explicitly which class and instance from the method it was called from? </p>
<p>It gets the calling stack frame, and finds the class (implicitly stored as a local free variable, <code>__class__</code>, making the calling function a closure over the class) and the first argument to that function, which should be the instance or class that informs it which Method Resolution Order (MRO) to use. </p>
<p>Since it requires that first argument for the MRO, <a href="https://bugs.python.org/issue31118" rel="noreferrer">using <code>super</code> with static methods is impossible</a>.</p>
<h2>Criticisms of other answers:</h2>
<blockquote>
<p>super() lets you avoid referring to the base class explicitly, which can be nice. . But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven't already.</p>
</blockquote>
<p>It's rather hand-wavey and doesn't tell us much, but the point of <code>super</code> is not to avoid writing the parent class. The point is to ensure that the next method in line in the method resolution order (MRO) is called. This becomes important in multiple inheritance.</p>
<p>I'll explain here.</p>
<pre><code>class Base(object):
    def __init__(self):
        print("Base init'ed")

class ChildA(Base):
    def __init__(self):
        print("ChildA init'ed")
        Base.__init__(self)

class ChildB(Base):
    def __init__(self):
        print("ChildB init'ed")
        super(ChildB, self).__init__()
</code></pre>
<p>And let's create a dependency that we want to be called after the Child:</p>
<pre><code>class UserDependency(Base):
    def __init__(self):
        print("UserDependency init'ed")
        super(UserDependency, self).__init__()
</code></pre>
<p>Now remember, <code>ChildB</code> uses super, <code>ChildA</code> does not:</p>
<pre><code>class UserA(ChildA, UserDependency):
    def __init__(self):
        print("UserA init'ed")
        super(UserA, self).__init__()

class UserB(ChildB, UserDependency):
    def __init__(self):
        print("UserB init'ed")
        super(UserB, self).__init__()
</code></pre>
<p>And <code>UserA</code> does not call the UserDependency method:</p>
<pre><code>&gt;&gt;&gt; UserA()
UserA init'ed
ChildA init'ed
Base init'ed
&lt;__main__.UserA object at 0x0000000003403BA8&gt;
</code></pre>
<p>But <code>UserB</code>, because <code>ChildB</code> uses <code>super</code>, does!:</p>
<pre><code>&gt;&gt;&gt; UserB()
UserB init'ed
ChildB init'ed
UserDependency init'ed
Base init'ed
&lt;__main__.UserB object at 0x0000000003403438&gt;
</code></pre>
<h3>Criticism for another answer</h3>
<p>In no circumstance should you do the following, which another answer suggests, as you'll definitely get errors when you subclass ChildB:</p>
<pre><code>        super(self.__class__, self).__init__() # Don't do this. Ever.
</code></pre>
<p><sub>(That answer is not clever or particularly interesting, but in spite of direct criticism in the comments and over 17 downvotes, the answerer persisted in suggesting it until a kind editor fixed his problem.)</sub></p>
<p>Explanation: That answer suggested calling super like this:</p>
<pre><code>super(self.__class__, self).__init__()
</code></pre>
<p>This is <em>completely</em> wrong. <code>super</code> lets us look up the next parent in the MRO (see the first section of this answer) for child classes. If you tell <code>super</code> we're in the child instance's method, it will then lookup the next method in line (probably this one) resulting in recursion, probably causing a logical failure (in the answerer's example, it does) or a <code>RuntimeError</code> when the recursion depth is exceeded.</p>
<pre><code>&gt;&gt;&gt; class Polygon(object):
...     def __init__(self, id):
...         self.id = id
...
&gt;&gt;&gt; class Rectangle(Polygon):
...     def __init__(self, id, width, height):
...         super(self.__class__, self).__init__(id)
...         self.shape = (width, height)
...
&gt;&gt;&gt; class Square(Rectangle):
...     pass
...
&gt;&gt;&gt; Square('a', 10, 10)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in __init__
TypeError: __init__() missing 2 required positional arguments: 'width' and 'height'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's been noted that in Python 3.0+ you can use</p>
<p><code>super().__init__()</code> </p>
<p>to make your call, which is concise and does not require you to reference the parent OR class names explicitly, which can be handy. I just want to add that for Python 2.7 or under, it is possible to get this name-insensitive behaviour by writing <code>self.__class__</code> instead of the class name, i.e.</p>
<pre><code>super(self.__class__, self).__init__()
</code></pre>
<p>HOWEVER, this breaks calls to <code>super</code> for any classes that inherit from your class, where <code>self.__class__</code> could return a child class. For example:</p>
<pre><code>class Polygon(object):
    def __init__(self, id):
        self.id = id

class Rectangle(Polygon):
    def __init__(self, id, width, height):
        super(self.__class__, self).__init__(id)
        self.shape = (width, height)

class Square(Rectangle):
    pass
</code></pre>
<p>Here I have a class <code>Square</code>, which is a sub-class of <code>Rectangle</code>. Say I don't want to write a separate constructor for <code>Square</code> because the constructor for <code>Rectangle</code> is good enough, but for whatever reason I want to implement a Square so I can reimplement some other method.</p>
<p>When I create a <code>Square</code> using <code>mSquare = Square('a', 10,10)</code>, Python calls the constructor for <code>Rectangle</code> because I haven't given <code>Square</code> its own constructor. However, in the constructor for <code>Rectangle</code>, the call <code>super(self.__class__,self)</code> is going to return the superclass of <code>mSquare</code>, so it calls the constructor for <code>Rectangle</code> again. This is how the infinite loop happens, as was mentioned by @S_C. In this case, when I run <code>super(...).__init__()</code> I am calling the constructor for <code>Rectangle</code> but since I give it no arguments, I will get an error.</p>
</div>
<div class="post-text" itemprop="text">
<p>Super has no side effects</p>
<pre><code>Base = ChildB

Base()
</code></pre>
<p>works as expected</p>
<pre><code>Base = ChildA

Base()
</code></pre>
<p>gets into infinite recursion.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just a heads up... with Python 2.7, and I believe ever since <code>super()</code> was introduced in version 2.2, you can only call <a href="http://docs.python.org/library/functions.html#super" rel="noreferrer"><code>super()</code></a> if one of the parents inherit from a class that eventually inherits <code>object</code> (<a href="http://docs.python.org/glossary.html#term-new-style-class" rel="noreferrer">new-style classes</a>).</p>
<p>Personally, as for python 2.7 code, I'm going to continue using <code>BaseClassName.__init__(self, args)</code> until I actually get the advantage of using <code>super()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There isn't, really. <code>super()</code> looks at the next class in the MRO (method resolution order, accessed with <code>cls.__mro__</code>) to call the methods. Just calling the base <code>__init__</code> calls the base <code>__init__</code>. As it happens, the MRO has exactly one item-- the base. So you're really doing the exact same thing, but in a nicer way with <code>super()</code> (particularly if you get into multiple inheritance later).</p>
</div>
<div class="post-text" itemprop="text">
<p>The main difference is that <code>ChildA.__init__</code> will unconditionally call <code>Base.__init__</code> whereas <code>ChildB.__init__</code> will call <code>__init__</code> in <strong>whatever class happens to be <code>ChildB</code> ancestor in <code>self</code>'s line of ancestors</strong>
(which may differ from what you expect). </p>
<p>If you add a <code>ClassC</code> that uses multiple inheritance: </p>
<pre><code>class Mixin(Base):
  def __init__(self):
    print "Mixin stuff"
    super(Mixin, self).__init__()

class ChildC(ChildB, Mixin):  # Mixin is now between ChildB and Base
  pass

ChildC()
help(ChildC) # shows that the the Method Resolution Order is ChildC-&gt;ChildB-&gt;Mixin-&gt;Base
</code></pre>
<p>then <strong><code>Base</code> is no longer the parent of <code>ChildB</code></strong> for <code>ChildC</code> instances. Now <code>super(ChildB, self)</code> will point to <code>Mixin</code> if <code>self</code> is a <code>ChildC</code> instance.</p>
<p>You have inserted <code>Mixin</code> in between <code>ChildB</code> and <code>Base</code>. And you can take advantage of it with <code>super()</code></p>
<p>So if you are designed your classes so that they can be used in a Cooperative Multiple Inheritance scenario, you use <code>super</code> because you don't really know who is going to be the ancestor at runtime. </p>
<p>The <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="noreferrer">super considered super post</a> and <a href="https://youtu.be/EiOglTERPEo" rel="noreferrer">pycon 2015 accompanying video</a> explain this pretty well.  </p>
</div>
<span class="comment-copy">Can you provide an example of <code>super()</code> being used with arguments?</span>
<span class="comment-copy">Can you please explain <code>super(ChildB, self).__init__()</code> this , what does <code>ChildB</code> and <code>self</code> have to do with the super</span>
<span class="comment-copy">@rimiro The syntax of super() is <code>super([type [, object]])</code> This will return the superclass of <code>type</code>. So in this case the superclass of <code>ChildB</code> will be returned. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, then <code>isinstance(object, type)</code> must be true.</span>
<span class="comment-copy">If you are here and still confused, please read the answer by Aaron Hall you will leave this page much happier: <a href="https://stackoverflow.com/a/27134600/1886357">stackoverflow.com/a/27134600/1886357</a></span>
<span class="comment-copy">I'll still need to work my head around this <code>super()</code> function, however, this answer is clearly the best in terms of depth and details. I also appreciate greatly the criticisms inside the answer. It also help to better understand the concept by identifying pitfalls in other answers. Thank you !</span>
<span class="comment-copy">@Aaron Hall, thanks for so detailed information. I think there should be one more option available(atleast) to mentors to call some answer as inappropriate or incomplete if they do not provide correct sufficient information.</span>
<span class="comment-copy">Thanks, this was super helpful. The criticism of the poor/improper usage was very illustrative of why, and how to use super</span>
<span class="comment-copy">Very good explanation of Python Inheritance. Thanks</span>
<span class="comment-copy">I have been using <code>tk.Tk.__init__(self)</code> over <code>super().__init__()</code> as I didn't fully understand what super was but this post has been very enlightening. I guess in the case of Tkinter classes <code>tk.Tk.__init__(self)</code> and <code>super().__init__()</code> are the same thing but it looks like you are saying we should avoid doing something like <code>Base.__init__(self)</code> so I may be switching to <code>super()</code> even though I am still trying to grasp its complexity.</span>
<span class="comment-copy">What this answer suggests, <code>super(self.__class__, self).__init__()</code> does not work if you subclass again without providing a new <code>__init__</code>. Then you have an infinite recursion.</span>
<span class="comment-copy">This answer is ridiculous. If you're going to abuse super this way, you might as well just hardcode the base class name. It is less wrong than this. The whole point of first argument of super is that it's <i>not</i> necessarily the type of self. Please read "super considered super" by rhettinger (or watch some of his videos).</span>
<span class="comment-copy">The shortcut demonstrated here for Python 2 has pitfalls that have been mentioned already. Don't use this, or your code will break in ways you can't predict. This "handy shortcut" breaks super, but you may not realize it until you've sunk a whole lot of time into debugging. Use Python 3 if super is too verbose.</span>
<span class="comment-copy">Edited the answer.  Sorry if that edit changes the meaning 180 degrees, but now this answer should make some sense.</span>
<span class="comment-copy">What makes no sense is to tell someone they can do something that is trivially demonstrated as incorrect. You can alias <code>echo</code> to <code>python</code>. Nobody would ever suggest it!</span>
<span class="comment-copy">The statement, "Super has no side effects," doesn't make sense in this context. Super simply guarantees we call the correct next class's method in the method resolution order, whereas the other way hard-codes the next method to be called, which makes cooperative multiple inheritance more difficult.</span>
<span class="comment-copy">very good point. IF you don't clearly mention:     class Base(object): then you will get error like that:      "TypeError: must be type, not classobj"</span>
<span class="comment-copy">@andi I got that error the other day and I eventually just gave up trying to figure it out. I was just messing around on iPython. What a freaking nightmare of a bad error message if that was actually code I had to debug!</span>
<span class="comment-copy">I see. Could you elaborate a little as to why its nicer to use super() with multiple inheritance? To me, the base.__init__(self) is shorter (cleaner). If I had two baseclasses, it would be two of those lines, or two super() lines. Or did I misunderstand what you meant by "nicer"?</span>
<span class="comment-copy">Actually, it would be one super() line. When you have multiple inheritance, the MRO is still flat. So the first super().__init__ call calls the next class's <b>init</b>, which then calls the next, and so on. You should really check out some docs on it.</span>
<span class="comment-copy">The child class MRO contains object too - a class's MRO is visible in the <b>mro</b> class variable.</span>
<span class="comment-copy">Also note that classic classes (pre 2.2) don't support super - you have to explicitly refer to base classes.</span>
<span class="comment-copy">"The child class MRO contains object too - a class's MRO is visible in the <b>mro</b> class variable." That is a big oops. Whoops.</span>
<span class="comment-copy">This.  The meaning of <code>super(ChildB, self)</code> changes depending on the MRO of the object referred to by <code>self</code>, which cannot be known until runtime.  In other words, the author of <code>ChildB</code> has no way of knowing what <code>super()</code> will resolve to in all cases unless they can guarantee that <code>ChildB</code> will never be subclassed.</span>
