<div class="post-text" itemprop="text">
<p>I read about the wrapper function to move a cmp style comparison into a key style comparison in Python 3, where the cmp capability was removed.</p>
<p>I'm having a heck of a time wrapping my head around how a Python3 straight key style sorted() function, with, at least as I understand it, just one item specified for the key, can allow you to properly compare, for instance, two IPs for ordering. Or ham calls.</p>
<p>Whereas with cmp there was nothing to it: sorted() and sort() called you with the two ips, you looked at the appropriate portions, made your decisions, done.</p>
<pre><code>def ipCompare(dqA,dqB):
    ...

ipList = sorted(ipList,cmp=ipCompare)
</code></pre>
<p>Same thing with ham radio calls. The sorting isn't alphabetic; the calls are generally letter(s)+number(s)+letter(s); the first sorting priority is the number portion, then the first letter(s), then the last letter(s.)</p>
<p>Using cmp... no sweat.</p>
<pre><code>def callCompare(callA,callB):
    ...

hamlist = sorted(hamlist,cmp=callCompare)
</code></pre>
<p>With Python3... without going through the hoop jumping of the wrapper... and being passed one item... I think... how can that be done?</p>
<p>And if the wrapper is absolutely required... then why remove cmp within Python3 in the first place?</p>
<p>I'm sure I'm missing something. I just can't see it. :/</p>
<hr/>
<p>ok,  now I know what I  was missing. Solutions for <code>IPs</code> were given in the answers below. Here's a key I came  up with for sorting ham calls of the common prefix, region, postfix form:</p>
<pre><code>import re

def callKey(txtCall):
    l = re.split('([0-9]*)',txtCall.upper(),1)
    return l[1],l[0],l[2]

hamList = ['N4EJI','W1AW','AA7AS','na1a']

sortedHamList = sorted(hamList,key=callKey)
</code></pre>
<p><code>sortedHamList</code> result is <code>['na1a','W1AW','N4EJI','AA7AS']</code></p>
<p>Detail:</p>
<ul>
<li><code>AA7AS</code> comes out of <code>callKey()</code> as <code>7,AA,AS</code></li>
<li><code>N4EJI</code> comes out of <code>callKey()</code> as <code>4,N,EJI</code></li>
<li><code>W1AW</code> comes out of <code>callKey()</code> as <code>1,W,AW</code></li>
<li><code>na1a</code> comes out of <code>callKey()</code> as <code>1,NA,A</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>First, if you haven't read the <a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow">Sorting HOWTO</a>, definitely read that; it explains a lot that may not be obvious at first.</p>
<hr/>
<p>For your first example, two IPv4 addresses, the answer is pretty simple.</p>
<p>To compare two addresses, one obvious thing to do is convert them both from dotted-four strings into tuples of 4 ints, then just compare the tuples:</p>
<pre><code>def cmp_ip(ip1, ip2):
    ip1 = map(int, ip1.split('.'))
    ip2 = map(int, ip2.split('.'))
    return cmp(ip1, ip2)
</code></pre>
<p>An even better thing to do is convert them to some kind of object that represents an IP address and has comparison operators. In 3.4+, the stdlib has such an object built in; let's pretend 2.7 did as well:</p>
<pre><code>def cmp_ip(ip1, ip2):
    return cmp(ipaddress.ip_address(ip1), ipaddress.ip_address(ip2))
</code></pre>
<p>It should be obvious that these are both even easier as key functions:</p>
<pre><code>def key_ip(ip):
    return map(int, ip.split('.'))

def key_ip(ip):
    return ipaddress.ip_address(ip)
</code></pre>
<hr/>
<p>For your second example, ham radio callsigns: In order to write a <code>cmp</code> function, you have to be able to break each ham address into the letters, numbers, letters portions, then compare the numbers, then compare the first letters, then compare the second letters. In order to write a <code>key</code> function, you have to be able to break down a ham address into the letters, numbers, letters portions, then return a tuple of (numbers, first letters, second letters). Again the key function is actually <em>easier</em>, not <em>harder</em>.</p>
<hr/>
<p>And really, this is the case for <em>most</em> examples anyone was able to come up with. Most complicated comparisons ultimately come down to a complicated conversion into some sequence of parts, and then simple lexicographical comparison of that sequence.</p>
<p>That's why <code>cmp</code> functions were deprecated way back in 2.4 and finally removed in 3.0.</p>
<hr/>
<p>Of course there are some cases where a <code>cmp</code> function is easier to read—most of the examples people try to come up with turn out to be wrong, but there are some. And there's also code which has been working for 20 years and nobody wants to rethink it in new terms for no benefit. For those cases, you've got <a href="https://docs.python.org/2.7/library/functools.html#functools.cmp_to_key" rel="nofollow"><code>cmp_to_key</code></a>.</p>
<hr/>
<p>There's actually another reason <code>cmp</code> was deprecated, on top of this one, and maybe a third.</p>
<p>In Python 2.3, types had a <code>__cmp__</code> method, which was used for handling all of the operators. In 2.4, they grew the six methods <code>__lt__</code>, <code>__eq__</code>, etc. as a replacement. This allows for more flexibility—e.g., you can have types that aren't total-ordered. So, 2.3's when compared <code>a &lt; b</code>, it was actually doing <code>a.__cmp__(b) &lt; 0</code>, which maps in a pretty obvious way to a <code>cmp</code> argument. But in 2.4+, <code>a &lt; b</code> does <code>a.__lt__(b)</code>, which doesn't. This confused a lot of people over the years, and removing both <code>__cmp__</code> and the <code>cmp</code> argument to sort functions removed that confusion.</p>
<p>Meanwhile, if you read the Sorting HOWTO, you'll notice that before we had <code>cmp</code>, the only way to do this kind of thing was decorate-sort-undecorate (DSU). Notice that it's blindly obvious how to map a good <code>key</code> function to a good DSU sort and vice-versa, but it's definitely not obvious with a <code>cmp</code> function. I don't remember anyone explicitly mentioning this one on the py3k list, but I suspect people may have had it in their heads when deciding whether to finally kill <code>cmp</code> for good.</p>
</div>
<div class="post-text" itemprop="text">
<p>To use <a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow">the new <code>key</code> argument</a>, simply decompose the comparison to another object that already implements a well-ordered comparison, such as to a tuple or list (eg. a sequence of integers). These types work well because they are sequence-wise ordered.</p>
<pre><code>def ip_as_components (ip):
    return map(int, ip.split('.'))

sorted_ips = sorted(ips, key=ip_as_components)
</code></pre>
<p><em>The ordering of the each of the components are the same as the individual tests as found in a traditional compare-and-then-compare-by function.</em></p>
<p>Looking at the HAM ordering it may look like:</p>
<pre><code>def ham_to_components (ham_code):
    # .. decompose components based on ordering of each
    return (prefix_letters, numbers, postfix_letters)
</code></pre>
<p>The <code>key</code> approach (similar to "order by" found in other languages) is generally a simpler and more natural construct to deal with - assuming that the original types are <em>not</em> already well-ordered. The main drawback with this approach is that partially reversed (eg. asc then desc) ordering can be tricky, but that is solvable by returning nested tuples etc.</p>
<blockquote>
<p>In Py3.0, <em>the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language</em>, eliminating the conflict between rich comparisons and the <code>__cmp__()</code> magic method).</p>
</blockquote>
<p>If absolutely needing <code>sorted</code> with a custom "cmp", <a href="https://docs.python.org/3/library/functools.html#functools.cmp_to_key" rel="nofollow"><code>cmp_to_key</code></a> can be trivially used.</p>
<pre><code>sorted_ips = sorted(ips, key=functools.cmp_to_key(ip_compare))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to official docs - <a href="https://docs.python.org/3/howto/sorting.html#the-old-way-using-the-cmp-parameter" rel="nofollow noreferrer">https://docs.python.org/3/howto/sorting.html#the-old-way-using-the-cmp-parameter</a></p>
<blockquote>
<p>When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function. The following wrapper makes that easy to do:</p>
</blockquote>
<pre><code>def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K:
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) &lt; 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) &gt; 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) &lt;= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) &gt;= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return K
</code></pre>
<blockquote>
<p>To convert to a key function, just wrap the old comparison function:</p>
</blockquote>
<pre><code>&gt;&gt;&gt; def reverse_numeric(x, y):
...     return y - x

&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]
</code></pre>
</div>
<span class="comment-copy">You haven't provide the code in your <code>ipCompare()</code> cmp function, but from the verbal description it sounds like an equivalent could be written as key function without too much trouble. Maybe that's the question you should be asking.</span>
<span class="comment-copy">Return a type such as a tuple or a list from the key function.</span>
<span class="comment-copy">key is so much nicer, but it's hard to show if you don't show actual cmp examples you think are so good.</span>
<span class="comment-copy">It wasn't that I thought they were good, it was that I <i>understood</i> them, lol. Now I understand key, and yes, it's better.</span>
<span class="comment-copy">ok, I think I get it now. the key isn't a comparison. It's  a value. The comparison is hidden.</span>
<span class="comment-copy">"comments may only be edited for five minutes" :( Again: ok, let's see if I get it now: The key isn't a comparison. Totally different idea. It's  a value. The comparison is hidden from me. To perform one of these hidden ordering steps, the key function will get called <i>twice</i> and the  <i>results</i> compared. So my task is to take whatever needs sorting as handed to me in the key, turn it into something Python understands, hand it back, and then the sort will work.</span>
<span class="comment-copy">@fyngyrz: Yes, the <code>key</code> function is called on each element, and the results of that are compared. (Also note that most operations—in particular, in <code>list.sort</code>—guarantee that it will only ever be called once on each element. The results get cached somewhere magical that you don't have to worry about. This also means that using a <code>key</code> function is similar to the decorate-sort-undecorate method that we had to use back in really, really old Python.)</span>
<span class="comment-copy">Super. I  just did the ip key thing three ways; map, turning the thing into a 32-bit number, and as text, just padding with zeros. All of them worked and make sense to me now. Thank you most kindly.</span>
