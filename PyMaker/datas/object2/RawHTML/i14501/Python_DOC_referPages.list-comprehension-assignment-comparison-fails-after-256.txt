<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/306313/is-operator-behaves-unexpectedly-with-integers">“is” operator behaves unexpectedly with integers</a>
<span class="question-originals-answer-count">
                    11 answers
                </span>
</li>
</ul>
</div>
<p>I tried to find the performance difference between slice assignment and regular assignment for lists. Here is the code:</p>
<pre><code>import time

N =  1000  
a = list(range(N))
b = list(range(N))

time1 = time.time()
for i in range(N):
    a = [x for x in a if x is not i]
time2 = time.time()
for i in range(N):
    b[:] = [x for x in b if x is not i]
time3 = time.time()

print a
print b    
print time2 - time1
print time3 - time2
</code></pre>
<p>My expectation is that, for each list <code>a</code> and <code>b</code>, this will remove one element at a time, so that <code>print a</code> and <code>print b</code> both print empty lists. Instead, they seem to always print the starting lists, but with the first <code>256</code> elements missing.</p>
<p>They both print:</p>
<pre><code>[257, 258, 259 ... N-1]
</code></pre>
<p>What is happening?</p>
<p>I'm using Python 2.7.6.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you're using <code>is</code> instead of <code>==</code>.</p>
<p>The former checks for object <em>identity</em>, not equality. There's no reason to believe that evaluating, say, <code>300+1</code> twice will give you the same <code>int</code> object, just that they'll both give you <code>int</code> objects whose value is <code>301</code>.</p>
<p>This happens to "work" for numbers up to 256 because your particular Python implementation<sup>*</sup> happens to intern integers up to 256. At startup, it creates a singleton object for the number <code>1</code>, a singleton object for <code>2</code>, and so on. Any time an expression evaluates to the number <code>1</code>, it gives you that object, instead of a new one.<sup>**</sup></p>
<p>Needless to say, you should not rely on that optimization.</p>
<hr/>
<p><sub>* IIRC, every version of CPython from the 1.x days to 3.5 defaults to this behavior for all integers from -5 to 256, but you can change those limits, or turn off the feature, at build time, and a different implementation might do something different.</sub></p>
<p><sub>** If you're wondering how this works in CPython, at the C API level, <a href="https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong" rel="nofollow"><code>PyLong_FromLong</code></a> does this by looking up numbers from -5 to 256 in an array of singleton values. You can see the 3.4 version of the code, for example, <a href="https://hg.python.org/cpython/file/3.4/Objects/longobject.c#l230" rel="nofollow">here</a>; the macro <code>CHECK_SMALL_INT</code> and the actual function <code>get_small_int</code> that it calls, and the static array that function uses, are all are in the same file, up near the top.</sub></p>
</div>
<span class="comment-copy">Because small integers are cached in CPython, use <code>!=</code> not <code>is</code> operator.</span>
