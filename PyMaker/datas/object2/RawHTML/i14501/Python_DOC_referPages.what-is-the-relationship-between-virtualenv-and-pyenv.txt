<div class="post-text" itemprop="text">
<p>I recently learned how to use virtualenv and virtualenvwrapper in my workflow but I've seen pyenv mentioned in a few guides but I can't seem to get an understanding of what pyenv is and how it is different/similar to virtualenv. Is pyenv a better/newer replacement for virtualenv or a complimentary tool? If the latter what does it do differently and how do the two (and virtualenvwrapper if applicable) work together? </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Pyenv</strong> and <strong>virtualenv</strong> are very different tools that work in different ways to do different things:</p>
<ul>
<li><p><strong>Pyenv</strong> is a bash extension - will not work on Windows - that intercepts your calls to python, pip, etc., to direct them to one of several of the system python tool-chains.  So you always have all the libraries that you have installed in the selected python version available - as such it is good for users who have to switch between different versions of python.</p></li>
<li><p><strong>VirtualEnv</strong>, is pure python so works everywhere, it makes a copy of, <em>optionally a specific version of,</em> python and pip local to the activate environment which may or may not include links to the current system tool-chain, if it does not you can install just a known subset of libraries into that environment.  As such it is almost certainly much better for testing and deployment as you know <strong>exactly</strong> which libraries, at which versions, are used and a global change will not impact your module.  </p></li>
</ul>
<h2>venv <em>python &gt; 3.3</em></h2>
<p>Note that from Python 3.3 onward there is a built in implementation of VirtualEnv called venv (with, on some installations a wrapper called pyvenv - this wrapper is <a href="https://docs.python.org/dev/whatsnew/3.6.html#id8" rel="noreferrer">deprecated in Python 3.6</a>), which should probably be used in preference. To avoid possible issues with the wrapper it is often a good idea to use it directly by using <code>/path/to/python3 -m venv desired/env/path</code> or you can use the excellent <code>py</code> python selector on windows with <code>py -3 -m venv desired/env/path</code>.  It will create the directory specified with <code>desired/env/path</code> configure and populate it appropriately.  In general it is very much like using VirtualEnv.</p>
<h2>Additional Tools</h2>
<p>There are a number of tools that it is worth mentioning, and considering, as they can help with the use of one or more of the above:</p>
<ul>
<li><a href="https://pypi.python.org/pypi/virtualenvwrapper" rel="noreferrer">VirtualEnvWrapper</a> Manage and simplify the use and management of VirtualEnv - <strong>Cross Platform</strong>.</li>
<li><a href="https://github.com/yyuu/pyenv-virtualenv" rel="noreferrer">pyenv-virtualenv</a>, <em>installed by <a href="https://github.com/yyuu/pyenv-installer" rel="noreferrer">pyenv-installer</a></em>, which gives PyEnv tools for managing and interfacing to VirtualEnv - with this you can have a base installation that includes more than one version of python and create isolated environments within each of them - <em>Linux/OS-X</em>. <em>Suggested by Johann Visagie</em></li>
<li><a href="http://www.pyinstaller.org/" rel="noreferrer">PyInstaller</a> can take your python code, possibly developed &amp; tested under VirtualEnv, and bundle it up so that it can run one platforms that do not have <em>your version of</em> python installed - Note that it is not a cross compiler you will need a Windows (virtual-)machine to build Windows installs, etc., but it can be handy even where you can be sure that python will be installed but cannot be sure that the version of python and all the libraries will be compatible with your code.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><code>virtualenv</code> allows you to create a custom Python installation e.g. in a subdirectory of your project. Each of your projects can thus have their own <code>python</code> (or even several) under their respective virtualenv. It is perfectly fine for some/all virtualenvs to even have the same version of <code>python</code> (e.g. 2.7.16) without conflict - they live separately and don't know of each other. If you want to use any of those <code>python</code>s, you have to <code>activate</code> it (by running a script which will temporarily modify your <code>PATH</code> to ensure that that virtualenv's <code>bin/</code> directory comes first). From that point, calling <code>python</code> (or <code>pip</code> etc.) will invoke that virtualenv's version until you <code>deactivate</code> it (which restores the <code>PATH</code>).</p>
<p><code>pyenv</code> operates on a wider scale than <code>virtualenv</code> - it holds a register of Python installations (and can be used to install new ones) and allows you to configure which version of Python to run when you use the <code>python</code> command. Sounds similar but practical use is a bit different. It works by prepending its shim <code>python</code> script to your <code>PATH</code> (permanently) and then deciding which "real" <code>python</code> to invoke. You can even configure pyenv to call into one of your virtualenv pythons (by using the <code>pyenv-virtualenv</code> plugin). Python versions you install using <code>pyenv</code> go into its <code>$(pyenv root)/versions/</code> directory (by default, pyenv root is ~/.pyenv) so are more 'global' than virtualenv. Ordinarily, you can't duplicate Python versions installed through <code>pyenv</code>, at least doing so is not the main idea.</p>
<p>To create a virtualenv with a specific Python version, you need to have that version somewhere in your system (whether it's on the <code>PATH</code> or not) and essentially clone it into your newly created virtualenv. Of course, one way to obtain a particular version is to install it via <code>pyenv</code>. Once that's done, individual virtualenvs are free to diverge by having different modules (or versions thereof) installed into them.</p>
<p>In short:</p>
<ul>
<li><code>virtualenv</code> allows you to create local, independent python
installations by cloning from existing ones</li>
<li><code>pyenv</code> allows you to
install different versions of python simultaneously (either
system-wide or just for the local user) and then choose which of the
multitude of pythons to run at any given time (including those
created by virtualenv or Anaconda)</li>
</ul>
</div>
<span class="comment-copy"><a href="http://fgimian.github.io/blog/2014/04/20/better-python-version-and-environment-management-with-pyenv/" rel="nofollow noreferrer">fgimian.github.io/blog/2014/04/20/…</a>: <i>However, there is another alternative called pyenv which has several significant advantages</i>.</span>
<span class="comment-copy">Don't be like me and get <a href="https://github.com/yyuu/pyenv" rel="nofollow noreferrer"><code>pyenv</code></a> confused with <a href="https://docs.python.org/3/library/venv.html" rel="nofollow noreferrer"><code>pyvenv</code></a></span>
<span class="comment-copy">It probably worth mentioning pyenv-virtualenv, a pyenv plugin that allows pyenv and virtualenv to work seamlessly in unison.  If you’ve installed pyenv using pyenv-installer, pyenv-virtualenv will already be present.  * <a href="https://github.com/yyuu/pyenv-virtualenv" rel="nofollow noreferrer">github.com/yyuu/pyenv-virtualenv</a> * <a href="https://github.com/yyuu/pyenv-installer" rel="nofollow noreferrer">github.com/yyuu/pyenv-installer</a></span>
<span class="comment-copy">What about <code>venv</code>, now in the standard library?</span>
<span class="comment-copy">@Flimm: From python 3.3 onward venv is a part of the standard library and should be used instead of virtualenv as it is often described as "virtualenv done right" - <a href="https://www.reddit.com/r/learnpython/comments/4hsudz/pyvenv_vs_virtualenv/" rel="nofollow noreferrer">reddit.com/r/learnpython/comments/4hsudz/pyvenv_vs_virtualenv</a></span>
<span class="comment-copy">pyenv-virtualenv is not (or at least is no longer) linux only. There is a homebrew package for it for an easy install on MacOS.</span>
<span class="comment-copy">Thank you for highlighting interoperability!</span>
