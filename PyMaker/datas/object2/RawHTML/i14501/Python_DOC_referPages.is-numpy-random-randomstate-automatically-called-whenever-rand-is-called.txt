<div class="post-text" itemprop="text">
<p>Languages like C++ require the programmer to set the seed of the random number generator, otherwise its output will always be the same. However, libraries like numpy do not require you to initialize the seed manually.</p>
<p>For example, code like:</p>
<pre><code>from numpy.random import rand
rand()
</code></pre>
<p>gives a different result every time.</p>
<p>Does this mean that <code>numpy.random.RandomState(seed=None)</code> is called every time you call <code>rand</code>?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Does that mean <code>numpy.random.RandomState(seed=None)</code> is called every time you call rand?</p>
</blockquote>
<p>No, it means the <code>RandomState</code> is seeded once at startup. If it were re-seeded every time you call <code>rand</code>, then there would be no way to explicitly <em>ask</em> for a repeatable pattern.</p>
<p>The same is true for the Python stdlib's <a href="https://docs.python.org/3/library/random.html" rel="nofollow"><code>random</code></a> module.</p>
<p>And, despite what you say about C++, it's <em>also</em> true for the C++ stdlib's <a href="http://www.cplusplus.com/reference/random/" rel="nofollow"><code>&lt;random&gt;</code></a> functions.</p>
<p>All of these document that the default seed, if you don't do anything, comes from something like the system time or a system entropy generator (like <code>/dev/random</code> on most *nix systems).</p>
<p>This is not the case for C's <code>rand</code> (which is still there in C++, although you should treat it as deprecated<sup>*</sup>), but only because C goes out of its way to require that startup must do the equivalent of calling <code>srand(1)</code>.</p>
<hr/>
<p>If you're interested in exactly how the "once at startup" works in NumPy:</p>
<ul>
<li>At the top level of the <code>numpy.random</code> module (which gets run the first time you <code>import numpy.random</code> or <code>from numpy.random import something</code> in your code), it constructs a global <code>RandomState</code>, with the default arguments (meaning <code>seed=None</code>).</li>
<li><code>RandomState</code>'s initializer just passes the <code>seed</code> argument on to the <code>seed</code> method.</li>
<li><code>RandomState.seed</code>, when called with <code>None</code>, uses an appropriate source of system entropy for your platform (like <code>/dev/urandom</code>).</li>
<li>When you call the top-level <code>rand</code>, it uses that global <code>RandomState</code>.</li>
</ul>
<hr/>
<p><sub>* Not because of this problem; it's easy enough to remember to call <code>srand</code> at the start of your program. But a PRNG that explicitly doesn't guarantee a cycle length longer than 32767, an unbiased distribution, etc. is just a bad idea for almost anythingâ€¦</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>numpy.random</code> module is like the <a href="https://docs.python.org/2/library/random.html" rel="nofollow"><code>random</code></a> module from the Python standard library, in that the functions in <code>numpy.random</code> are bound methods of a hidden generator object that is instantiated when you import the module. This hidden <code>numpy.random.RandomState</code> instance currently lives in <code>np.random.mtrand._rand</code> (although you shouldn't rely on it always being there in future versions of numpy):</p>
<pre><code>print(np.random.rand)
# &lt;built-in method rand of mtrand.RandomState object at 0x7f50ced03660&gt;

# note the same memory address of the RandomState object:
print(np.random.mtrand._rand)
# &lt;mtrand.RandomState object at 0x7f50ced03660&gt;
</code></pre>
<p>The hidden <code>RandomState</code> instance will be seeded only <em>once</em> when you import the module (unless you then set the seed explicitly using <code>np.random.seed()</code>). If a new seed was chosen every time you called <code>rand()</code> then there would be no way to create reproducible sequences of pseudorandom numbers.</p>
<p>The situation looks something like:</p>
<pre><code># implicit RandomState created and seeded
from numpy import random

# # we could subsequently re-seed the hidden RandomState, e.g.:
# random.seed(None)

# different random variates
r1 = random.rand(1)
r2 = random.rand(1)
r3 = random.rand(1)
# ...
</code></pre>
<p>The automatic seeding is equivalent to <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" rel="nofollow"><code>np.random.RandomState(None)</code></a>, which uses some platform-dependent source of randomness (usually <code>/dev/urandom</code> on *nix) to set the seed.</p>
</div>
