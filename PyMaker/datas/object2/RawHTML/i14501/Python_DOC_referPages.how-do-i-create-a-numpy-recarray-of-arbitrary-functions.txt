<div class="post-text" itemprop="text">
<p>I am creating a <code>numpy.recarray</code> as follows:</p>
<pre class="lang-py prettyprint-override"><code>import numpy as np

arr = np.array((1., 2.), dtype = [('alpha', np.float, 'beta', np.float)])
arr = np.view(np.recarray)
</code></pre>
<p>How would I do this if instead of <code>np.floats</code> <code>alpha</code> and <code>beta</code> referred to arbitrary functions?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>np.object</code> dtype can contain any Python object, including functions.</p>
<p>For example:</p>
<pre><code>import numpy as np

lmb = lambda: "help, I'm trapped in an array!"
arr = np.array([(max, lmb)], dtype=[('alpha', np.object), ('beta', np.object)])
arr = arr.view(np.recarray)

print(repr(arr))
# array([(&lt;built-in function max&gt;, &lt;function &lt;lambda&gt; at 0x63992a8&gt;)], 
#       dtype=[('alpha', 'O'), ('beta', 'O')]).view(numpy.recarray)

print(arr.alpha[0](1, 2))
# 2

print(arr.beta[0]())
# help, I'm trapped in an array!
</code></pre>
<p>The extra set of square brackets around the tuple of functions was added in order to force the array to be one-dimensional, which allows you to index the first row in order to access the functions it contains.</p>
<p>It's a bit more awkward to access the functions if you allow the array to be 0-dimensional, but it's still possible, as user2357112 pointed out in the comments below:</p>
<pre><code>arr2 = np.array((max, lmb), dtype=[('alpha', np.object), ('beta', np.object)])
arr2 = arr2.view(np.recarray)

print(repr(arr2))
# array((&lt;built-in function max&gt;, &lt;function &lt;lambda&gt; at 0x63995f0&gt;), 
#       dtype=[('alpha', 'O'), ('beta', 'O')]).view(numpy.recarray)

print(repr(arr2['alpha']))
# array(&lt;built-in function max&gt;, dtype=object)

# we can't access the function without any indexing, because `arr2['alpha']` 
# is still an ndarray containing a function, rather than a plain function,
# and arrays have no `.__call__()` method:

arr2.alpha(1, 2)
# ---------------------------------------------------------------------------
# TypeError                                 Traceback (most recent call last)
# &lt;ipython-input-100-dc1bd6446de4&gt; in &lt;module&gt;()
# ----&gt; 1 arr2['alpha'](1, 2)

# TypeError: 'numpy.ndarray' object is not callable

# it is possible to access the function by indexing with an empty tuple
print(arr2.alpha[()](1, 2))
# 2
</code></pre>
<p>There were a couple of other syntax issues in your example that I've fixed here. </p>
<ul>
<li><p>Your <code>dtype=</code> argument should contain a separate <code>(name, dtype)</code> tuple for each field, rather than a single long tuple. </p></li>
<li><p><code>.view</code> is a method of an ndarray, not a standalone function.</p></li>
</ul>
<p>I do have to ask why you want to do this, though. A simple <code>dict</code> seems like a much more appropriate data structure.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the clarification in the comments, this doesn't sound like a job for a recarray. In Python 3, you'd want <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow"><code>types.SimpleNamespace</code></a>; in Python 2, you could implement it yourself pretty easily:</p>
<pre><code>class Namespace(object):
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

namespace = Namespace(func1=print, func2=len, func3=sum)

namespace.func1(namespace.func2([1, 2])) # prints 2
</code></pre>
</div>
<span class="comment-copy">What would it mean for a dtype to be an arbitrary function? If one of the dtypes was <code>print</code> (using <code>from __future__ import print_function</code> to have that as a function), what would you expect to happen, and how would you interact with the resulting array?</span>
<span class="comment-copy">Also, that's not a recarray.</span>
<span class="comment-copy">In that case one would be able to access the <code>print</code> function via <code>arr.print</code> and for instance print 'foo' to the screen via <code>arr.print('foo')</code> that is the only functionality I require here.</span>
<span class="comment-copy">I don't see why you'd want to use a recarray for that.</span>
<span class="comment-copy">I agree it doesn't seem very logical. In short I have some code that I am trying to modify to suit my needs. Unfortunately the last coder seemed to like <code>np.recarray</code> (or whatever these constructs are)... a lot and it just so happens that if I can get this functionality using <code>np.recarray</code> it will save me re writing a lot of code...</span>
<span class="comment-copy">"It seems to be necessary to create the empty array first, then fill in the fields with the functions." - that's probably related to the fact that you're creating a 1-dimensional array of length 1, while the original code seems to create a 0-dimensional array.</span>
<span class="comment-copy">@user2357112 Yes, it's actually necessary to create a 1-dimensional array in order to call the function (see my update)</span>
<span class="comment-copy">Not quite; you can get the same effect with a 0-dimensional array and <code>arr.alpha[()]</code> or <code>arr.alpha[...]</code> instead of <code>arr.alpha[0]</code>.</span>
<span class="comment-copy">Good point, although <code>arr2.alpha[...]</code> does not work, since it also returns an array rather than the function it contains</span>
<span class="comment-copy">What the - I could have sworn <code>[...]</code> was supposed to do the conversion, but it looks like only <code>[()]</code> does the job. I remember trying <code>[...]</code> and having it work before.</span>
