<div class="post-text" itemprop="text">
<p>I often include this, or something close to it, in Python scripts and IPython notebooks.</p>
<pre><code>import cPickle
def unpickle(filename):
    with open(filename) as f:
        obj = cPickle.load(f)
    return obj
</code></pre>
<p>This seems like a common enough use case that the standard library should provide a function that does the same thing. Is there such a function? If there isn't, how come?</p>
</div>
<div class="post-text" itemprop="text">
<p>Most of the serialization libraries in the stdlib and on PyPI have a similar API. I'm pretty sure it was <a href="https://docs.python.org/3/library/marshal.html"><code>marshal</code></a> that set the standard,<sup>*</sup> and <code>pickle</code>, <code>json</code>, <code>PyYAML</code>, etc. have just followed in its footsteps.</p>
<p>So, the question is, why was <code>marshal</code> designed that way?</p>
<p>Well, you obviously need <code>loads</code>/<code>dumps</code>; you couldn't build those on top of a filename-based function, and to build them on top of a file-object-based function you'd need <code>StringIO</code>, which didn't come until later.</p>
<p>You don't necessarily <em>need</em> <code>load</code>/<code>dump</code>, because those could be built on top of <code>loads</code>/<code>dumps</code>—but doing so could have major performance implications: you can't save anything to the file until you've built the whole thing in memory, and vice-versa, which could be a problem for huge objects.</p>
<p>You definitely don't need a <code>loadf</code>/<code>dumpf</code> function based on filenames, because those can be built trivially on top of <code>load</code>/<code>dump</code>, with no performance implications, and no tricky considerations that a user is likely to get wrong.</p>
<p>On the one hand, it would be convenient to have them anyway—and there are some libraries, like <code>ElementTree</code>, that do have analogous functions. It may only save a few seconds and a few lines per project, but multiply that by thousands of projects…</p>
<p>On the other hand, it would make Python larger. Not so much the extra 1K to download and install it if you added these two functions to every module (although that did mean a lot more back in the 1.x days than nowadays…), but more to document, more to learn, more to remember. And of course more code to maintain—every time you need to fix a bug in <code>marshal.dumpf</code> you have to remember to go check <code>pickle.dumpf</code> and <code>json.dumpf</code> to make sure they don't need the change, and sometimes you won't remember.</p>
<p>Balancing those two considerations is really a judgment call. One someone made decades ago and probably nobody has really discussed since. If you think there's a good case for changing it today, you can always post a feature request on <a href="http://bugs.python.org/">the issue tracker</a> or start a thread on <a href="https://mail.python.org/mailman/listinfo/python-ideas"><code>python-ideas</code></a>.</p>
<hr/>
<p><sub>* Not in <a href="https://hg.python.org/cpython/file/457661e47c7b/Python/marshal.c">the original 1991 version of <code>marshal.c</code></a>; that just had <code>load</code> and <code>dump</code>. Guido added <code>loads</code> and <code>dumps</code> <a href="https://hg.python.org/cpython/file/38f0054f44a7/Python/marshal.c">in 1993</a> as part of a change whose main description was "Add separate main program for the Mac: macmain.c". Presumably because something inside the Python interpreter needed to dump and load to strings.<sup>**</sup></sub></p>
<p><sub>** <code>marshal</code> is used as the underpinnings for things like importing <code>.pyc</code> files. This also means (at least in CPython) it's not just implemented in C, but statically built into the core of the interpreter itself. While I think it actually <em>could</em> be turned into a regular module since the 3.4 <code>import</code> changes, but it definitely couldn't have back in the early days. So, that's extra motivation to keep it small and simple.</sub></p>
</div>
<span class="comment-copy">Assuming you already imported cPickle elsewhere, everything else can be done in a single line: <code>obj = cPickle.load(open(filename, "rb"))</code></span>
<span class="comment-copy">@ODiogoSilva: Only if you like leaking file descriptors.</span>
<span class="comment-copy">Apparently not common/basic enough. Have you had a look at what kind of functions are actually built-ins?</span>
<span class="comment-copy">This is like asking: "Why did the chicken cross the road?" :)</span>
<span class="comment-copy">@StefanPochmann There's some stuff in there that I wouldn't call "basic". Does a <code>str</code> class really need <code>expandtabs</code>? Does a stdlib need a <code>SimpleHTTPServer</code>? A lot of the early stuff that's built in, there's really more historical reasons than rational ones; when it seems consistent, it's more because Guido has good taste (and/or a time machine) than because anyone thought it through and argued it out in public like newer changes.</span>
