<div class="post-text" itemprop="text">
<p>I understand that threads in Python use the same instance of Python interpreter. My question is it the same with process created by <code>os.fork</code>? Or does each process created by <code>os.fork</code> has its own interpreter?</p>
</div>
<div class="post-text" itemprop="text">
<p>Whenever you fork, the entire Python process is duplicated in memory (<em>including</em> the Python interpreter, your code and any libraries, current stack etc.) to create a second process - one reason why forking a process is much more expensive than creating a thread.</p>
<p>This creates a <strong>new copy</strong> of the python interpreter.</p>
<p>One advantage of having two python interpreters running is that you now have two GIL's (Global Interpreter Locks), and therefore can have true multi-processing on a multi-core system.</p>
<p>Threads in one process share the same GIL, meaning only one runs at a given moment, giving only the illusion of parallelism.</p>
</div>
<div class="post-text" itemprop="text">
<p>While <code>fork</code> does indeed create a copy of the current Python interpreter rather than running with the same one, it usually isn't what you want, at least not on its own. Among other problems:</p>
<ul>
<li>There can be problems forking multi-threaded processes on some platforms. And some libraries (most famously Apple's Cocoa/CoreFoundation) may start threads for you in the background, or use thread-local APIs even though you've only got one thread, etc., without your knowledge.</li>
<li>Some libraries assume that every process will be initialized properly, but if you <code>fork</code> after initialization that isn't true. Most infamously, if you let <code>ssl</code> seed its PRNG in the main process, then fork, you now have potentially predictable random numbers, which is a big hole in your security.</li>
<li>Open file descriptors are inherited (as dups) by the children, with details that vary in annoying ways between platforms.</li>
<li>POSIX only requires platforms to implement a very specific set of syscalls between a <code>fork</code> and an <code>exec</code>. If you never call <code>exec</code>, you can only use those syscalls. Which basically means you can't do <em>anything</em> portably.</li>
<li>Anything to do with signals is <em>especially</em> annoying and nonportable after <code>fork</code>.</li>
</ul>
<p>See <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fork.html">POSIX <code>fork</code></a> or your platform's manpage for details on these issues.</p>
<p>The right answer is almost always to use <a href="https://docs.python.org/3/library/multiprocessing.html"><code>multiprocessing</code></a>, or <a href="https://docs.python.org/3/library/concurrent.futures.html"><code>concurrent.futures</code></a> (which wraps up <code>multiprocessing</code>), or a similar third-party library.</p>
<p>With 3.4+, you can even specify a <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods">start method</a>. The <code>fork</code> method basically just calls <code>fork</code>. The <code>forkserver</code> method runs a single "clean" process (no threads, signal handlers, SSL initialization, etc.) and forks off new children from that. The <code>spawn</code> method calls <code>fork</code> then <code>exec</code>, or an equivalent like <code>posix_spawn</code>, to get you a brand-new interpreter instead of a copy. So you can start off with <code>fork</code>, ut then if there are any problems, switch to <code>forkserver</code> or <code>spawn</code> and nothing else in your code has to change. Which is pretty nice.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>os.fork()</code> is equivalent to the <code>fork()</code> syscall in many UNIC(es). So <strong>yes</strong> your sub-process(es) will be separate from the parent and have a different interpreter (<em>as such</em>).</p>
<p><a href="http://linux.die.net/man/2/fork" rel="nofollow"><code>man fork</code></a>:</p>
<blockquote>
<p>FORK(2)</p>
<p>NAME
         fork - create a child process</p>
<p>SYNOPSIS
         #include </p>
<pre><code>   pid_t fork(void);
</code></pre>
<p>DESCRIPTION
         fork()  creates  a new process by duplicating the calling process.  The new process, referred to as the child,
         is an exact duplicate of the calling process, referred to as the parent, except for the following points:</p>
</blockquote>
<p><a href="https://docs.python.org/2/library/os.html#os.fork" rel="nofollow"><code>pydoc os.fork()</code></a>:</p>
<blockquote>
<p><code>os.fork()</code> Fork a child process. Return 0 in the child and the
  child’s process id in the parent. If an error occurs OSError is
  raised.</p>
<p>Note that some platforms including FreeBSD &lt;= 6.3, Cygwin and OS/2 EMX
  have known issues when using fork() from a thread.</p>
</blockquote>
<p>See also: Martin Konecny's response as to the why's and advantages of "forking" :)</p>
<p>For brevity; other approaches to concurrency which don't involve a separate process and therefore a separate Python interpreter include:</p>
<ul>
<li>Green or Lightweight threads; ala <a href="https://pypi.python.org/pypi/greenlet" rel="nofollow">greenlet</a></li>
<li>Coroutines ala Python generators and the new Python 3+ <a href="https://www.python.org/dev/peps/pep-0380/" rel="nofollow"><code>yield from</code></a></li>
<li>Async I/O ala <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow">asyncio</a>, <a href="https://pypi.python.org/pypi/Twisted" rel="nofollow">Twisted</a>, <a href="https://pypi.python.org/pypi/circuits" rel="nofollow">circuits</a>, etc.</li>
</ul>
</div>
<span class="comment-copy">Nice response to some of the many caveats of "blindly <code>fork()</code>ing" :)</span>
<span class="comment-copy">@JamesMills: Now that you put "blind" and "fork" together, I've got the Angry Samoans' <a href="http://www.plyrics.com/lyrics/angrysamoans/lightsout.html" rel="nofollow noreferrer">Lights Out</a> stuck in my head, and it's not on my iTunes Match. Thanks a lot. :P</span>
<span class="comment-copy">Hahaha sorry! :) Puns are funny even if it's having fun at one's expense :)</span>
<span class="comment-copy">So ... is multiprocess safe with locks? The docs don't seem clear. I assume is calls a fork somewhere in its implementation -- which, if its not followed by an exec, is unsafe.</span>
<span class="comment-copy">@user48956 I’m not sure what you’re asking. This answer explains how multiprocessing works under the covers (e.g., it may be passing a message to a fork server, or calling a spawn/CreateProcess function, not forking), and the linked docs explain it in more detail. Meanwhile, of course multiprocessing is safe with the locks and other sync objects from the multiprocessing module, but isn’t generally safe with threading locks. (It should just give you errors for even trying to share threading locks, but with the fork start method, you can sometimes get around the checks and have useless locks).</span>
<span class="comment-copy">One thing to note: <code>asyncio</code> actually uses yield-from coroutines (although in 3.5, it may use the new <a href="https://www.python.org/dev/peps/pep-0492/" rel="nofollow noreferrer"><code>async</code>/<code>await</code> coroutines</a> instead). It might also be worth mentioning more explicit callback-driven/future-driven designs like Twisted, and just directly looping over a <code>selector</code> or <code>select</code>. Or the equivalents with GUI-style event loops. But I already gave you a +1, so you may not get any extra votes for adding all that. :)</span>
<span class="comment-copy">@abarnert There ya go :) It's nice to include the many options I agree :)</span>
