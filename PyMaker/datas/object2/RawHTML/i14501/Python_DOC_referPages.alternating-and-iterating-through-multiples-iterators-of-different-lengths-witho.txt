<div class="post-text" itemprop="text">
<p>Here is an example:</p>
<pre><code>for i in f('abcde','fg','hijk'):
print(i,end='')
#should print out
afhbgicjdke
</code></pre>
<p>Here is what I have so far:</p>
<pre><code>def f(*args):
    arg_list = [argument for argument in args]
    iter_list = []
    for arg in arg_list:
        iter_list.append(iter(arg))

    try:
        while True:
            for i in iter_list:
                yield next(i)
    except StopIteration:
        iter_list.remove(i)
        for i in reversed(iter_list):
            yield next(i)
</code></pre>
<p>With the same example this is what I am printing out:</p>
<pre><code>afhbgicjd
</code></pre>
<p>i can't figure out how to handle this StopIteration error. I am trying to implement this without using itertools</p>
</div>
<div class="post-text" itemprop="text">
<p>This is an application for <a href="https://docs.python.org/2/library/itertools.html#itertools.izip_longest" rel="nofollow">izip_longest</a>.</p>
<pre><code>from itertools import chain, izip_longest
''.join(chain.from_iterable(izip_longest('abcde', 'fg', 'hijk', fillvalue='')))
</code></pre>
<p>Output:</p>
<pre><code>'afhbgicjdke'
</code></pre>
<p>In this example it zipped the three sequences into tuples of three elements. If there wasn't a corresponding element for one of our sequences, we used a default value of <code>''</code>. Then we flattened those tuples using <code>chain.from_iterable</code> and we finally joined all the characters together.</p>
<p>If we are allowed only to use basic functions, we could do it like this:</p>
<pre><code>def f(*args):
    n = len(args)
    iters = map(iter, args)
    exhausted = [False] * n
    while n &gt; 0:
        for i, it in enumerate(iters):
            if not exhausted[i]:
                try:
                    yield next(it)
                except StopIteration:
                    exhausted[i] = True
                    n -= 1

print ''.join(f('abcde', 'fg', 'hijk'))
</code></pre>
<p>With this code we keep track of the exhausted iterators. When the number of <em>live</em> ones reaches to zero, we stop our generator. If an iterator is exhausted, then we don't check it next time.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple solution that doesn’t use itertools or zipping (and also doesn’t try to embed the zipping implementation):</p>
<pre><code>def f (*args):
    maxLen = max(map(len, args))
    for i in range(maxLen):
        for arg in args:
            if i &lt; len(arg):
                yield arg[i]
</code></pre>
<hr/>
<p>For any iterable:</p>
<pre><code>def f (*args):
    args = [iter(arg) for arg in args]
    while True:
        yielded = False
        for arg in args:
            x = next(arg, None)
            if x is not None:
                yielded = True
                yield x
        if not yielded:
            break
</code></pre>
<pre><code>&gt;&gt;&gt; list(f(range(3), range(3, 5), range(5, 10)))
[0, 3, 5, 1, 4, 6, 2, 7, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is <a href="https://docs.python.org/2/library/itertools.html#recipes" rel="nofollow">a recipe in the <code>itertools</code> documentation</a></p>
<pre><code>def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).next for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))
</code></pre>
<p>For example, using the <code>IPython</code> REPL:</p>
<pre><code>In [19]: from itertools import *

In [20]: def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).next for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))
   ....:                     

In [21]: "afhbgicjdke" == "".join(roundrobin('abcde','fg','hijk'))
Out[21]: True
</code></pre>
</div>
<span class="comment-copy">I am trying to implement this without itertools</span>
<span class="comment-copy">dustinyourface: In Python 3, it's called <code>zip_longest()</code>. The <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">documentation</a> provides a pure Python equivalent to it (so does the Python 2 documentation for <code>izip_longest()</code>. Same for <code>chain()</code>.</span>
<span class="comment-copy">@dustinyourface I updated my answer</span>
<span class="comment-copy">@dustinyourface if you don't mind me asking, why don't you want to use itertools? It's in the standard library, it's there for you to use without fear.</span>
<span class="comment-copy">These don't yield the values in the desired order.</span>
<span class="comment-copy">Thanks this info was useful but I am trying to alternate. See example.</span>
<span class="comment-copy">Oops, I wasn’t reading the question correctly. Changed my answer.</span>
<span class="comment-copy">Could you please explain what exactly the map method is doing? And why are you checking if i &lt; len(arg)?</span>
<span class="comment-copy"><code>map(len, x)</code> applies the <code>len</code> function to every element of <code>args</code>. So it essentially gives you a sequence of the lengths of all arguments. So <code>max()</code> on that gives you the maximum length, which is the maximum number of iterations we need to do to get the very last item from the longest argument. The check <code>i &lt; len(arg)</code> is there to prevent an index error for arguments which are not long enough. At that point, we have consumed them completely, so we can skip them.</span>
<span class="comment-copy">I saw in a comment to an answer that the OP is trying not to use <code>itertools</code>... Having said that the proper place for such statement is the body of the question (or, maybe, the question's title itself) I don't remove my answer as I see it as a sort of direction post pointing to the excellent documentation of <code>itertools</code> and the large numbers of recipes that have been collected there.</span>
