<div class="post-text" itemprop="text">
<p>In python you can do list.pop(i) which removes and returns the element in index i, but is there a built in function like list.remove(e) where it removes and returns the first element equal to e?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>I mean, there is <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow"><code>list.remove</code></a>, yes. </p>
<pre><code>&gt;&gt;&gt; x = [1,2,3]
&gt;&gt;&gt; x.remove(1)
&gt;&gt;&gt; x
[2, 3]
</code></pre>
<p>I don't know why you need it to return the removed element, though. You've already passed it to <code>list.remove</code>, so you know what it is... I guess if you've overloaded <code>__eq__</code> on the objects in the list so that it doesn't actually correspond to some reasonable notion of equality, you could have problems. But don't do that, because that would be terrible.</p>
<p>If you have done that terrible thing, it's not difficult to roll your own function that does this:</p>
<pre><code>def remove_and_return(lst, item):
    return lst.pop(lst.index(item))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is there a builtin?  No.  Probably because if you already know the element you want to remove, then why bother returning it?<sup>1</sup></p>
<p>The best you can do is get the index, and then pop it.  Ultimately, this isn't such a big deal -- Chaining 2 O(n) algorithms is still O(n), so you still scale roughly the same ...</p>
<pre><code>def extract(lst, item):
    idx = lst.index(item)
    return lst.pop(idx)
</code></pre>
<p><sup><sup>1</sup>Sure, there are pathological cases where the item returned might not be the item you already know... but they aren't important enough to warrant a new method which takes only 3 lines to write yourself :-)</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>Strictly speaking, you would need something like:</p>
<pre><code>def remove(lst, e):
    i = lst.index(e)
    # error if e not in lst
    a = lst[i]
    lst.pop(i)
    return a
</code></pre>
<p>Which would make sense only if <code>e == a</code> is true, but <code>e is a</code> is false, and you really need <code>a</code> instead of <code>e</code>.</p>
<p>In most case, though, I would say that this suggest something suspicious in your code.</p>
<p>A short version would be :</p>
<pre><code>a = lst.pop(lst.index(e))
</code></pre>
</div>
<span class="comment-copy">Well, if you have <code>e</code> already defined, why do you need it to be returned?</span>
<span class="comment-copy">@TidB -- It's the first element <i>equal</i> to <code>e</code> -- objects can define their own equality in interesting ways... (whether or not they <i>should</i> is another discussion all together)</span>
<span class="comment-copy">It seems pointless to return <code>e</code> from <code>list.remove(e)</code> because the return value would just be <code>e</code>. Perhaps you'd like something that wouldn't raise a <code>ValueError</code> when e` wasn't found.</span>
<span class="comment-copy">To be pedantic, if you do <code>x.remove(e1)</code>, <code>e2</code> is the removed element it's possible for <code>e1 == e2</code> without <code>e1 is e2</code>, and therefore you want a particular instance of that element - of course, a system that relies on that is very questionable.</span>
<span class="comment-copy">@sacma: isn't it?</span>
<span class="comment-copy">@sacma This is a valid answer to the question, the answer being that the asked-for functionality shouldn't be needed.</span>
<span class="comment-copy">@sacma "But don't do that, because that would be terrible." That's how this answer addresses the situation you're raising.</span>
<span class="comment-copy">@sacma No, I'm going through the Close Queue. O_o I don't know why you'd even think that. As far as I know, this is my first encounter with you.</span>
<span class="comment-copy">It is, however, worth taking a look at what you are doing and asking if relying on getting a particular instance of an element considered equal to the one you have is a good design idea (it's almost definitely not).</span>
<span class="comment-copy">Also, can I suggest <code>extract()</code> as a good name for this method?</span>
<span class="comment-copy">@Lattyware -- Sure you can :-).  And I described the practice of having non-equal equal things as "pathological".  Admittedly, there are (very common) libraries whose objects are subject to this problem.  <code>numpy.ndarray</code> instances come to mind immediately... it's a bit sad that concessions needed to be made, but I think that the numpy devs did the right thing here since overriding <code>==</code> to return an array really makes the syntax for more common things that you do with numpy a lot nicer.</span>
<span class="comment-copy"><code>list.pop(i)</code> returns <code>a</code>, so no need to get it separately.</span>
<span class="comment-copy">@Lattyware: I just needed to name the value to compare it to <code>e</code> in the explaination</span>
<span class="comment-copy">I see, might want to clarify that in the answer.</span>
<span class="comment-copy">an example where this (strange) condition could hold is it <code>e</code> and <code>a</code> are <code>numpy.ndarray</code> instances.  Of course, this answer doesn't help there because their <code>__eq__</code> doesn't return a boolean -- or even something with a non-ambiguous boolean value :-)</span>
