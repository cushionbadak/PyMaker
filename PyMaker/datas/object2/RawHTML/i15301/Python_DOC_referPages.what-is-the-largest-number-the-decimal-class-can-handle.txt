<div class="post-text" itemprop="text">
<p>My program calculates the mathematical constant <em>e</em>, which is irrational. In order to do this, I needed to get factorials of very large numbers.</p>
<p><code>int</code> cannot handle numbers larger than 170!. (I found that the largest Google's calculator can handle is 170.654259, but I'm not sure how a non integer can be factorized.)  <code>float</code> can not handle very large numbers either.</p>
<p>I calculated <em>e</em> to 750000 digits, and <code>math.factorial(750000)</code> is a mind-boggling, large number. Yet, <code>Decimal</code> handled it with apparent ease.</p>
<p>How large of a number can <code>Decimal</code> handle before an <code>OverflowError</code> is raised?  Is the size different in Python 2 versus Python 3?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>What is the largest number the Decimal class can handle?</p>
</blockquote>
<p>The largest magnitude is infinity:</p>
<pre><code>&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; Decimal('Inf')
Decimal('Infinity')
</code></pre>
<p>The largest representable finite number on a given platform depends on <a href="https://docs.python.org/3/library/decimal.html#decimal.MAX_EMAX"><code>decimal.MAX_EMAX</code></a>:</p>
<pre><code>&gt;&gt;&gt; from decimal import Context, MAX_EMAX
&gt;&gt;&gt; d = Context(Emax=MAX_EMAX, prec=1).create_decimal('9e'+str(MAX_EMAX))
&gt;&gt;&gt; d.is_finite()
True
&gt;&gt;&gt; d.next_plus()
Decimal('Infinity')
&gt;&gt;&gt; d
Decimal('9E+999999999999999999')
</code></pre>
<p>The number of significant digits depends on <a href="https://docs.python.org/3/library/decimal.html#decimal.MAX_PREC"><code>decimal.MAX_PREC</code></a> e.g., to calculate <code>e</code> with the given precision:</p>
<pre><code>&gt;&gt;&gt; from decimal import Context
&gt;&gt;&gt; Context(prec=60).exp(1)
Decimal('2.71828182845904523536028747135266249775724709369995957496697')
</code></pre>
<p>The constants (<code>MAX_EMAX</code>, <code>MAX_PREC</code>) are only relevant for the C implementation. Pure Python version can use larger values:</p>
<pre><code>&gt;&gt;&gt; from decimal import Context, MAX_EMAX
&gt;&gt;&gt; Context(Emax=MAX_EMAX+1, prec=1).create_decimal('9e'+str(MAX_EMAX+1))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: valid range for Emax is [0, MAX_EMAX]
&gt;&gt;&gt; from _pydecimal import Context, MAX_EMAX
&gt;&gt;&gt; Context(Emax=MAX_EMAX+1, prec=1).create_decimal('9e'+str(MAX_EMAX+1))
Decimal('9E+1000000000000000000')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It depends on the context you provide for the Decimal object. From the <a href="https://docs.python.org/2/library/decimal.html" rel="nofollow">library documentation</a>:</p>
<blockquote>
<p>class decimal.Context(prec=None, rounding=None, traps=None,
  flags=None, Emin=None, Emax=None, capitals=1)</p>
</blockquote>
<p><code>Emax</code> and <code>Emin</code> control the bounds of your decimal. If the exponent is greater than <code>Emax</code> or less than <code>Emin</code> there will be an overflow signal. You can look at the fields in <code>decimal.defaultContext</code> to see what they are by default, or <code>decimal.getContext()</code> to see what they are at any given time.</p>
<p>Edit: As @davidism pointed out you don't get exact answers from <code>decimal</code> calculations. The default precision of the module is 28. So all integers up to 999999999999999999999999999999 (28 nines) can be represented exactly, and higher numbers might be rounded.</p>
</div>
<span class="comment-copy"><code>Decimal</code> is not actually giving you exact answers.</span>
<span class="comment-copy">Integers have infinite precision in Python e.g., <code>math.factorial(170)</code> is <code>7257415615307998967396728211129263114716991681296451376543577798900561843401706157852350749242617459511490991237838520776666022565442753025328900773207510902400430280058295603966612599658257104398558294257568966313439612262571094946806711205568880457193340212661452800000000000000000000000000000000000000000</code>. See <a href="http://stackoverflow.com/a/347749/4279">how you could use <code>decimal.Decimal</code> to compute an answer with arbitrary (but fixed) precision</a></span>
<span class="comment-copy">FWIW, it's not that hard to calculate large numbers of decimal digits of e using integer arithmetic. See <a href="http://forums.xkcd.com/viewtopic.php?t=14661&amp;p=3066871#p3066964" rel="nofollow noreferrer">here</a> for example code in Python and C.</span>
<span class="comment-copy">@PM2Ring: it is even simpler <a href="http://stackoverflow.com/a/28082106/4279">using <code>decimal</code> module</a></span>
<span class="comment-copy">@J.F.Sebastian: Oh, I wasn't suggesting my algorithm was simpler, or even faster. Just that it's not <i>that</i> hard to do this particular calculation with simple (fixed precision) integer arithmetic. OTOH, one nice thing about my algorithm is that you don't have to wait for the calculation to complete before it starts printing digits.</span>
<span class="comment-copy">Only then it will raise an overflow error? When I was calculating e, my computer fan was loud and the system monitor displayed that one of my CPUs was at 100% usage, and they would switch every 15 minutes or so. What if my computer is tasked with intensive instruction that causes it to reach its max temperature? Or what if the number is stored in RAM and the RAM Runs out of space?</span>
<span class="comment-copy">not enough memory would give a <code>MemoryError</code>. overheating is not something that would give any signal in python as far as i know.</span>
<span class="comment-copy">the <code>traps</code> field determines what things will cause errors and what things it will sweep under the rug. By default overflows are treated as errors. I can't really tell you how much python cares about the physical limits of your computer. But if you don't care too much about your data, I encourage you to run some tests.</span>
<span class="comment-copy">So there's virtually no limitations for the size of the number Decimal can handle? That's really neat! What about the getcontext() class?</span>
<span class="comment-copy">@DorianDore The only limitation is the amount of memory python has available. And I added the getContext() function to my answer. Thanks.</span>
