<div class="post-text" itemprop="text">
<p>I run a command remotely using Python and this is the output I get:</p>
<pre class="lang-none prettyprint-override"><code>Vserver   Volume       Aggregate    State      Type       Size  Available Used%
--------- ------------ ------------ ---------- ---- ---------- ---------- -----
vs_cfm06  Available    aggr_backup_1 online    RW        100GB    66.37GB   33%
vs_cfm06  Discovery    aggr_backup_1 online    RW        100GB    66.36GB   33%
vs_cfm06  NonDebugCF01 aggr_backup_1 online    RW        100GB    64.63GB   35%
vs_cfm06  NonDebugCF01_BACKUP aggr_backup_1 online RW      5GB     4.75GB    5%
vs_cfm06  Software     aggr_backup_1 online    RW        100GB    65.08GB   34%
vs_cfm06  Template     aggr_backup_1 online    RW        100GB    66.35GB   33%
vs_cfm06  breakresetafterfaildelCF01 aggr_backup_1 online RW 100GB 69.52GB  30%
vs_cfm06  breakresetafterfaildelCF01_BACKUP aggr_backup_1 online RW 5GB 4.75GB  5%
vs_cfm06  rootvol      aggr_backup_1 online    RW          1GB    972.5MB    5%
vs_cfm06  vol          aggr_backup_1 online    RW          1GB    972.6MB    5%
10 entries were displayed.
</code></pre>
<p>How do I extract one column from this so my output is something like this:</p>
<pre class="lang-none prettyprint-override"><code>Available   
Discovery    
NonDebugCF01 
NonDebugCF01_BACKUP 
Software     
Template     
breakresetafterfaildelCF01 
breakresetafterfaildelCF01_BACKUP 
rootvol      
vol         
</code></pre>
<p>The code to run the command and print the output is this:</p>
<pre><code>def get_volumes(usrname, ip):

    raw_output = ru.run('volume show', user=usrname, host=ip, set_e=False) //logs onto netapp and runs command

    print raw_output
</code></pre>
<p>When I run <code>print type(raw_output)</code> it says it's unicode.
Any help would be much appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Reading Columns from a File</h1>
<p>A text file is inherently <em>row oriented</em>, when you open it in a text editor you see, and you can operate on, lines of text.</p>
<p>This inherent structure is reflected in an idiomatic way of slurping a text file content using python:</p>
<pre><code>data = [line for line in file(fname)]
</code></pre>
<p><code>data</code> being a list of strings corresponding to the rows of the file.</p>
<p>Sometimes the text is more structured and you can see that there is a columnar organization in it. For the sake of simplicity, say that we have</p>
<ul>
<li>an initial line of headers,</li>
<li>possibly some line of junk and</li>
<li>a number of lines containing the actual data,</li>
</ul>
<p>moreover we assume that every relevant line contains the same number of columns.</p>
<p>An idiom that you can use is</p>
<pre><code>data = [line.split() for line in file(fname)]
</code></pre>
<p>here <code>data</code> is now a list of lists, one sublist for each row of the file, each sublist a list of the strings obtained splitting column-wise a row.</p>
<h2>Reordering in Columns</h2>
<p>While you can access every single data item by <code>data[row][column]</code> it may be more convenient to refer to data using the headers, as in <code>data['Aggregate'][5]</code>... In python, to address data using a string you usually use a <em>dictionary</em>, and you can build a dictionary using what is called a <em>dictionary comprehension</em></p>
<pre><code>n = 2 # in your example data
data_by_rows = [line.split() for line in file(fname)]
data_by_cols = {col[0]:list(col[n:]) for col in zip(*data_by_rows)}
</code></pre>
<p>This works because the idiom <code>zip(*list_of_rows)</code> returns you a <code>list_of_cols</code>.</p>
<pre><code>&gt;&gt;&gt; a = [[1,2,3],[10,20,30]]
&gt;&gt;&gt; zip(*a)
[(1, 10), (2, 20), (3, 30)]
&gt;&gt;&gt; 
</code></pre>
<h2>Moving On</h2>
<p>What we have seen is simple and convenient to use if the file format is simple and the manipulations you want to do are not involved. For more complex formats and/or manipulation requirements, python offers a number of options, either in the <em>standard library</em></p>
<ul>
<li>the <code>csv</code> module eases the task of reading (and writing as well) <em>comma(/tab) separated values</em> files,</li>
</ul>
<p>or as optional maodules</p>
<ul>
<li>the <code>numpy</code> module, aimed to numerical analysis, has facilites for slurping all data from a text file and putting them in an <code>array</code> structure,</li>
<li>the <code>pandas</code> module, aimed at data analysis and modeling, built on <code>numpy</code>, also has facilities to turn a structured text file into a <em>dataframe</em> structure.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>There are two handy functions for what you want: <a href="https://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects" rel="nofollow"><code>readlines()</code></a> splits a files in lines and <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow"><code>str.split()</code></a> splits a string (by default, using any whitespace as separator).</p>
<pre><code>with open("input.txt") as f:
     lines = f.readlines()

for line in lines[2:]:
     columns = line.split()
     print(columns[1])
</code></pre>
<p>An alternative way to it without using <code>readlines()</code> would be:</p>
<pre><code>with open("input.txt") as f:
     content = f.read()  # does not detect lines

lines = content.split("\n")
for line in lines[2:]:
     columns = line.split()
     print(columns[1])
</code></pre>
<p>Finally, you may be handling files whose line termination is either "\n", (GNU/Linux), "\r\n" (Windows) or "\r" (Mac OS). Then you have to use the <a href="https://docs.python.org/3/library/re.html" rel="nofollow"><code>re</code></a> module:</p>
<pre><code>with open("input.txt") as f:
     content = f.read()  # does not detect lines

lines = re.split("\r?\n?", content)
for line in lines[2:]:
     columns = line.split()
     print(columns[1])
</code></pre>
</div>
<span class="comment-copy">Have you tried anything in the direction of your goal?</span>
<span class="comment-copy">So, is that table stored in a string object?</span>
<span class="comment-copy">The <code>file</code> object does not exist in Python 3 though.</span>
<span class="comment-copy">Also, <code>data_by_cols</code> needs braces instead of brackets. I could not edit it myself since the fix would be less than 6 characters.</span>
<span class="comment-copy">@Yoha Oooops! fixed now, thank you.</span>
<span class="comment-copy">but the raw output is a variable, not a file</span>
<span class="comment-copy">Then you can use <code>variable.split("\n")</code> instead of <code>readlines()</code>. I'll put it in the answer.</span>
<span class="comment-copy">what if there is a blank data in some column?</span>
<span class="comment-copy">My answer was specifically for the original question, where columns are misaligned. If your columns are well aligned, you can just use slices to get the relevant data for each line; for instance <code>column4 = line[42:57]</code>.  Now, if your columns are both misaligned and include empty fields, it will get very tricky to parse correctly.</span>
