<div class="post-text" itemprop="text">
<p>Occasionally, I have this problem where I want to check:</p>
<pre><code>a = 'my string'
if 'string1' in a or 'string2' in a or 'string3' in a ... or 'stringN' in a:
    [[do something]]
else:
    [[something else]]
</code></pre>
<p>Suppose I know that there's a 90% chance <code>'string1' in a</code> evaluates to <code>True</code>. Will Python still evaluate if <code>'string2' in a</code> in this case where <code>'string1' in a</code> is <code>True</code>? Or is it technically more efficient to write:</p>
<pre><code>if 'string1' in a:
    [[do something]]
elif 'string2' in a:
    [[do something]]
elif 'string3' in a:
    [[do something]]
...
elif 'stringN' in a:
    [[do something]]
else:
    [[something else]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not" rel="noreferrer"><code>or</code> and <code>and</code> both use short-circuiting</a>; they will only evaluate as many conditions as necessary to determine a result.  So, if <code>'string1' in a</code> returns <code>True</code>, <code>'string2' in a</code> will never be touched.</p>
</div>
<div class="post-text" itemprop="text">
<p>The or stalemate and the if ladder are equivalent in this case. The or statement should be preferred as it reduces code duplication. You only have to change one section of code if you want to do something different if one of the strings is in the given string. </p>
<p>If you have many strings to search for them you may find it preferable to use the <code>any</code> function and a generator. </p>
<pre><code>any(s in a for s in strings) 
</code></pre>
<p>The above evaluates to the same as the or statement where <code>strings</code> is a list of the strings your are searching for. It also stops checking whether <code>s in a</code> the first time it evaluates to <code>True</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>No it'll stop when evaluates <code>True</code>. Because in <code>or</code> operator, one <code>True</code> is enough to process that statement. If any condition returns <code>True</code> there, for example <code>string1</code> is True then other conditions are not going to process. As you know except <code>False or False</code> every condition is <code>True</code>, so no need to check rest of them.</p>
</div>
<div class="post-text" itemprop="text">
<p>I realize this isn't your question, but you should consider using sets for situations like this. </p>
<p>Instead of: </p>
<pre><code>if 'string1' in a or 'string2' in a or 'string3' in a ... or 'stringN' in a:
</code></pre>
<p>You can do: </p>
<pre><code>if set(a.split()).intersection({'string1','string2', ... }):
</code></pre>
<p>Using sets in this way is more terse as well as faster than multiple condition if statements. </p>
<p>EDIT: Note that the above will only work to check the presence of individual words with no white space between. </p>
</div>
<span class="comment-copy">Your second code is very different from the first one. They dont do the same.</span>
<span class="comment-copy">They don't? Every <code>elif</code> clause is a repeated call to the same thing. How would you reach a state where they don't do the same thing?</span>
<span class="comment-copy">more readable version: <code>strings = ['string1', 'string2', 'string3', ..., 'stringN']</code> then <code>if any(s in a for s in strings):</code>. Same effect (short circuiting).</span>
<span class="comment-copy">Or use <code>any((True if s in a for s in strings))</code> so the generator can return early in <code>any</code>, I think. Whoops, n/m didn't see your use of <code>any</code> correctly.</span>
<span class="comment-copy">@prpl.mnky.dshwshr Here he puts <code>[[do something]]</code> , i think, as a placeholder. In real case it would do differents things, so, its not the same to put a especial case for any statement, than put them all together (like in the first case).</span>
<span class="comment-copy">I think this is probably the best method suggested so far.</span>
<span class="comment-copy">Um, taking a set of a string gives you the individual characters so you'll never match multicharacter strings.</span>
<span class="comment-copy">I was thinking <code>a</code> was a list of strings, but looking at the OP I am incorrect. Thanks.</span>
<span class="comment-copy">now corrected. it will only work for checking individual words, though.</span>
<span class="comment-copy">now corrected. it will only work for checking individual words, though. <a href="http://stackoverflow.com/a/28114750/2437514">@Dunes' answer</a> is better.</span>
