<div class="post-text" itemprop="text">
<p>I have a string that I am getting from a command line application. It has the following structure:</p>
<pre><code>-- section1 --
item11|value11
item12|value12
item13

-- section2 --
item21|value21
item22
</code></pre>
<p>what I would like is to parse this to a dict so that I can easily access the values with:</p>
<pre><code>d['section1']['item11']
</code></pre>
<p>I already solved it for the case when there are no sections and every key has a value but I get errors otherwise. I have tried a couple things but it is getting complicated because and nothing seems to work. This is what I have now:</p>
<pre><code>s="""
item11|value11
item12|value12
item21|value21
"""
d = {}
for l in s.split('\n'):
    print(l, l.split('|'))
    if l != '':
        d[l.split('|')[0]] = l.split('|')[1]
</code></pre>
<p>Can somebody help me extend this for the section case and when no values are present?</p>
</div>
<div class="post-text" itemprop="text">
<p>Seems like a perfect fit for the <a href="https://docs.python.org/3/library/configparser.html" rel="noreferrer">ConfigParser</a> module in the standard library:</p>
<pre><code>d = ConfigParser(delimiters='|', allow_no_value=True)
d.SECTCRE = re.compile(r"-- *(?P&lt;header&gt;[^]]+?) *--")  # sections regex
d.read_string(s)
</code></pre>
<p>Now you have an object that you can access like a dictionary:</p>
<pre><code>&gt;&gt;&gt; d['section1']['item11']
'value11'
&gt;&gt;&gt; d['section2']['item22']   # no value case
None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/re.html#re.sub" rel="nofollow">Regexes</a> are a good take at this:</p>
<pre><code>import re


def parse(data):
    lines = data.split("\n") #split input into lines
    result = {}
    current_header = ""

    for line in lines:
        if line: #if the line isn't empty
            #tries to match anything between double dashes:
            match = re.match(r"^-- (.*) --$", line)
            if match: #true when the above pattern matches
                #grabs the part inside parentheses:
                current_header = match.group(1)
            else:
                #key = 1st element, value = 2nd element:
                key, value = line.split("|")
                #tries to get the section, defaults to empty section:
                section = result.get(current_header, {})
                section[key] = value #adds data to section
                result[current_header] = section #updates section into result
    return result #done.

print parse("""
-- section1 --
item1|value1
item2|value2
-- section2 --
item1|valueA
item2|valueB""")
</code></pre>
</div>
<span class="comment-copy">What is the question exactly?</span>
<span class="comment-copy">This woke fine in this case . what you expect to it do ?</span>
<span class="comment-copy">...parsing the text file into nested dicts for secctions?</span>
<span class="comment-copy">is it clearer now?</span>
<span class="comment-copy">Can I assume <b>section</b> headers will always appear? If not, what you want to do in that case, just set them (keys, values) as root elements?</span>
<span class="comment-copy">Damn, this is freaking awesome! Kilometers above my regex+iteration manual approach.</span>
