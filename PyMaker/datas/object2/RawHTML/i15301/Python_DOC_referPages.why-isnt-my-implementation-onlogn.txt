<div class="post-text" itemprop="text">
<p>I was implementing and testing answers to <a href="https://stackoverflow.com/q/27705359/2823755">this SO question</a> - </p>
<blockquote>
<p>Given an array of integers find the number of all ordered pairs of elements in the array whose sum lies in a given range [a,b]</p>
</blockquote>
<p><a href="https://stackoverflow.com/a/27705519/2823755">The answer with the most upvotes</a> (currently) only provides a text description of an algorithm that should be O(NlogN):</p>
<blockquote>
<p>Sort the array... .
  For each element x in the array:
  Consider the array slice after the element.
  Do a binary search on this array slice for [a - x], call it y0. If no exact match is found, consider the closest match bigger than [a - x] as y0.
  Output all elements (x, y) from y0 forwards as long as x + y &lt;= b. ... If you only need to count the number of pairs, you can do it in O(nlogn). Modify the above algorithm so [b - x] (or the next smaller element) is also searched for.</p>
</blockquote>
<p>My implementation:</p>
<pre><code>import bisect
def ani(arr, a, b):
    # Sort the array (say in increasing order).
    arr.sort()
    count = 0
    for ndx, x in enumerate(arr):
        # Consider the array slice after the element
        after = arr[ndx+1:]
        # Do a binary search on this array slice for [a - x], call it y0
        lower = a - x
        y0 = bisect.bisect_left(after, lower)
        # If you only need to count the number of pairs
        # Modify the ... algorithm so [b - x] ... is also searched for
        upper = b - x
        y1 = bisect.bisect_right(after, upper)
        count += y1 - y0
    return count
</code></pre>
<p>When I plot Time versus N or some function of N I am seeing an exponential or N^2 response.</p>
<pre><code># generate timings
T = list()    # run-times
N = range(100, 10001, 100)    # N
arr = [random.randint(-10, 10) for _ in xrange(1000000)]
print 'start'
start = time.time()
for n in N:
    arr1 = arr[:n]
    t = Timer('ani(arr1, 5, 16)', 'from __main__ import arr1, ani')
    timing_loops = 100
    T.append(t.timeit(timing_loops) / timing_loops)
</code></pre>
<p>Is my implementation incorrect or is the author's claim incorrect?</p>
<p>Here are some plots of the data.</p>
<p>T vs N
<img alt="T vs N" src="https://i.stack.imgur.com/mwNKq.png"/>
T / NlogN vs N - one commenter thought this should NOT produce a linear plot - but it does.
<img alt="T / NlogN vs N" src="https://i.stack.imgur.com/XzoeN.png"/>
T vs NlogN - I thought this should be linear if the complexity is NlogN but it is not.
<img alt="T vs NlogN" src="https://i.stack.imgur.com/G3bfM.png"/></p>
</div>
<div class="post-text" itemprop="text">
<p>If nothing else, this is your error:</p>
<pre><code>for ndx, x in enumerate(arr):
    # Consider the array slice after the element
    after = arr[ndx+1:]
</code></pre>
<p><code>arr[ndx+1:]</code> creates a copy of the list of length <code>len(arr) - ndx</code>, so therefore your loop is O(n^2).</p>
<p>Instead, use the <code>lo</code> and <code>hi</code> arguments to <a href="https://docs.python.org/3/library/bisect.html#bisect.bisect_left" rel="noreferrer"><code>bisect.bisect</code></a>.</p>
</div>
<span class="comment-copy">Why are you slicing at all? <code>bisect</code> functions take lower and upper bounds, so you can avoid creating a new list altogether (which cumulative takes 2N operations, times N steps, making your code N^2, albeit in fast C code for the inner loop).</span>
<span class="comment-copy">@MartijnPieters unfortunately I was trying to keep it simple for clarity then couldn't see the consequence of that decision.</span>
<span class="comment-copy">And a more compact implementation using <code>sum()</code> to illustrate: <a href="https://gist.github.com/mjpieters/88c039207be8353e8620" rel="nofollow noreferrer">gist.github.com/mjpieters/88c039207be8353e8620</a></span>
<span class="comment-copy">I'm not sure I follow the recommendation.  Are you saying to just search the entire array not a slice of of it?  Also do you think I implemented the author's intent?</span>
<span class="comment-copy">No, please see the linked documentation. The <code>lo</code> and <code>hi</code> arguments are precisely for searching through only a slice of the list, but without needing to create that slice explicitly.</span>
<span class="comment-copy">And yes, it does seem that you implemented the author's intent.</span>
<span class="comment-copy">@wwii: no, instead of creating a new list <code>after</code>, use <code>ndx + 1</code> as a lower bound for the <code>bisect.bisect_left()</code> function; the third argument. Replace <code>bisect.bisect_left(after, lower)</code> with <code>bisect.bisect_left(arr, lower, ndx + 1)</code> to start the bisection at index <code>ndx + 1</code>.</span>
<span class="comment-copy">Very good thank you.  I couldn't see the forest for the trees.</span>
