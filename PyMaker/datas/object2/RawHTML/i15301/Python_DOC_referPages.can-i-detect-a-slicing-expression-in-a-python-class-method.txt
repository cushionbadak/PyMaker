<div class="post-text" itemprop="text">
<p>I am developing an application where I have defined a "variable" object containing data in the form of a numpy array. These variables are linked to (netcdf) data files, and I would like to dynamically load the variable values when needed instead of loading all data from the sometimes huge files at the start.</p>
<p>The following snippet demonstrates the principle and works well, including access to data portions with slices. For example, you can write:</p>
<pre><code>a = var()   # empty variable
print a.values[7]   # values have been automatically "loaded"
</code></pre>
<p>or even:</p>
<pre><code>a = var()
a[7] = 0
</code></pre>
<p>However, this code still forces me to load the entire variable data at once. Netcdf (with the netCDF4 library) would allow me to directly access data slices from the file. Example:</p>
<pre><code>f = netCDF4.Dataset(filename, "r")
print f.variables["a"][7]
</code></pre>
<p>I cannot use the netcdf variable objects directly, because my application is tied to a web service which cannot remember the netcdf file handler, and also because the variable data don't always come from netcdf files, but may originate from other sources such as OGC web services.</p>
<p>Is there a way to "capture" the slicing expression in the property or setter methods and use them? The idea would be to write something like:</p>
<pre><code>    @property
    def values(self):
        if self._values is None:
            self._values = np.arange(10.)[slice]  # load from file ...
        return self._values
</code></pre>
<p>instead of the code below.    </p>
<p>Working demo:</p>
<pre><code>import numpy as np

class var(object):

    def __init__(self, values=None, metadata=None):
        if values is None:
            self._values = None
        else:
            self._values = np.array(values)
        self.metadata = metadata  # just to demonstrate that var has mor than just values

    @property
    def values(self):
        if self._values is None:
            self._values = np.arange(10.)  # load from file ...
        return self._values

    @values.setter
    def values(self, values):
        self._values = values
</code></pre>
<p>First thought: Should I perhaps create values as a separate class and then use <code>__getitem__</code>? See <a href="https://stackoverflow.com/questions/23213057/in-python-how-do-i-create-two-index-slicing-for-my-own-matrix-class">In python, how do I create two index slicing for my own matrix class?</a> </p>
</div>
<div class="post-text" itemprop="text">
<p>No, you cannot detect what will be done to the object after returning from <code>.values</code>. The result could be stored in a variable and only (much later on) be sliced, or sliced in different places, or used in its entirety, etc.</p>
<p>You indeed should instead return a <em>wrapper object</em> and hook into <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow"><code>object.__getitem__</code></a>; it would let you detect slicing and load data as needed. When slicing, Python passes in a <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow"><code>slice()</code> object</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to the guidance of Martijn Pieters and with a bit more reading, I came up with the following code as demonstration. Note that the Reader class uses a netcdf file and the netCDF4 library. If you want to try out this code yourself you will either need a netcdf file with variables "a" and "b", or replace Reader with something else that will return a data array or a slice from a data array.</p>
<p>This solution defines three classes: Reader does the actual file I/O handling, Values manages the data access part and invokes a Reader instance if no data have been stored in memory, and var is the final "variable" which in real life will contain a lot more metadata. The code contains a couple of extra print statements for educational purposes.</p>
<pre><code>"""Implementation of a dynamic variable class which can read data from file when needed or
return the data values from memory if they were read already. This concepts supports
slicing for both memory and file access.""" 

import numpy as np
import netCDF4 as nc

FILENAME = r"C:\Users\m.schultz\Downloads\data\tmp\MACC_20141224_0001.nc"
VARNAME = "a"


class Reader(object):
    """Implements the actual data access to variable values. Here reading a
    slice from a netcdf file.
    """

    def __init__(self, filename, varname):
        """Final implementation will also have to take groups into account...
        """
        self.filename = filename
        self.varname = varname

    def read(self, args=slice(None, None, None)):
        """Read a data slice. Args is a tuple of slice objects (e.g.
        numpy.index_exp). The default corresponds to [:], i.e. all data
        will be read.
        """
        with nc.Dataset(self.filename, "r") as f:
            values = f.variables[self.varname][args]
        return values


class Values(object):

    def __init__(self, values=None, reader=None):
        """Initialize Values. You can either pass numerical (or other) values,
        preferrably as numpy array, or a reader instance which will read the
        values on demand. The reader must have a read(args) method, where
        args is a tuple of slices. If no args are given, all data should be
        returned.
        """
        if values is not None:
            self._values = np.array(values)
        self.reader = reader

    def __getattr__(self, name):
        """This is only be called if attribute name is not present.
        Here, the only attribute we care about is _values.
        Self.reader should always be defined.
        This method is necessary to allow access to variable.values without
        a slicing index. If only __getitem__ were defined, one would always
        have to write variable.values[:] in order to make sure that something
        is returned.
        """
        print "&gt;&gt;&gt; in __getattr__, trying to access ", name
        if name == "_values":
            print "&gt;&gt;&gt; calling reader and reading all values..."
            self._values = self.reader.read()
        return self._values

    def __getitem__(self, args):
        print "in __getitem__"
        if not "_values" in self.__dict__:
            values = self.reader.read(args)
            print "&gt;&gt;&gt; read from file. Shape = ", values.shape
            if args == slice(None, None, None):
                self._values = values  # all data read, store in memory
            return values
        else:
            print "&gt;&gt;&gt; read from memory. Shape = ", self._values[args].shape
            return self._values[args]

    def __repr__(self):
        return self._values.__repr__()

    def __str__(self):
        return self._values.__str__()


class var(object):

    def __init__(self, name=VARNAME, filename=FILENAME, values=None):
        self.name = name
        self.values = Values(values, Reader(filename, name))


if __name__ == "__main__":
    # define a variable and access all data first
    # this will read the entire array and save it in memory, so that
    # subsequent access with or without index returns data from memory
    a = var("a", filename=FILENAME)
    print "1: a.values = ", a.values
    print "2: a.values[-1] = ", a.values[-1]
    print "3: a.values = ", a.values
    # define a second variable, where we access a data slice first
    # In this case the Reader only reads the slice and no data are stored
    # in memory. The second access indexes the complete array, so Reader
    # will read everything and the data will be stored in memory.
    # The last access will then use the data from memory.
    b = var("b", filename=FILENAME)
    print "4: b.values[0:3] = ", b.values[0:3]
    print "5: b.values[:] = ", b.values[:]
    print "6: b.values[5:8] = ",b.values[5:8]
</code></pre>
</div>
<span class="comment-copy">Thanks! Upon some further reading I came upon <code>__getattribute__</code> rather than <code>__getattr__</code> (which is only called if an attribute is <b>not</b> defined). So why did you point out <code>__getattr__</code>?</span>
<span class="comment-copy">@maschu I actually mistyped. I meant to point to <code>__getitem__</code> here. Mea Culpa!</span>
<span class="comment-copy">OK. I believe I am getting close to a solution now. One more thing, though: using <code>__getitem__</code> means that I always have to index my "values", i.e. I should use "[:]" (or "[...]") to obtain the complete data. Without any slice, <code>__getitem__</code>is not called and I would indeed have to tweak <code>__getattribute__</code> which is somewhat nasty. Is there a good way to determine whether a slice or tuple of slices is supposed to index the entire data array? The following expressions all result in different args in <code>__getitem__</code>: [:], [:,:], [...], [:,...], etc.</span>
<span class="comment-copy">@maschu: as soon as you get a tuple you'll be addressing individual dimensions; you need to have all elements in the first dimension of the tuple loaded for the rest to work; <code>[:,...]</code> is a full slice (<code>slice(None, None, None)</code>) and you need to load everything anyway.</span>
<span class="comment-copy">@maschu: You can try using <code>__getattr__</code> to detect all other uses of your object and load the whole thing at that moment; as long as the object is treated as a duck rather than having <code>isinstance()</code> applied you should be able to get away with proxying like that.</span>
