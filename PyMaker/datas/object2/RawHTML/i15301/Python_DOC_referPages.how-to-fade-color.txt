<div class="post-text" itemprop="text">
<p>I would like to fade the color of a pixel out toward white, but obviously maintain the same color. If I have a pixel <code>(200,120,40)</code>, will adding 10 to each value to make <code>(210,130,50)</code> make it the same color, just lighter, or will it change the color entirely? For example, I know that <code>(100,100,100)</code> going to <code>(110,110,110)</code> is a greyscale fade. I would like the same with RGB values and I would like to do it numerically, as indicated. Is there an equation to do so?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a bunch of ways to do this. How you choose to do it will depend on whether you value speed and simplicity or perceptual uniformity. If you need it to be truly uniform you will need to define you RGB colors with a color profile and you'll need the primaries of the profile so you can convert to XYZ and then to LAB where you can manipulate the L channel.</p>
<p>Most of the time you don't need to do that and you can instead use a simple HSB model like Photoshop does in the info palette. </p>
<p>To do this you simply imagine a line between your RGB point and the white point in 3D space and move your color along that line. In practical terms you can just create a parametric equation for that line and move the parameter.</p>
<pre><code>import numpy as np

def lighter(color, percent):
    '''assumes color is rgb between (0, 0, 0) and (255, 255, 255)'''
    color = np.array(color)
    white = np.array([255, 255, 255])
    vector = white-color
    return color + vector * percent
</code></pre>
<p>A percentage of 0.0 will return the same color and 1.0 will return white. Everything between will be a lighter shade of the same hue. This should give you results that agree with Photoshop's HSB implementation, but will be device dependent and may not be perfectly uniform. </p>
<p>If you have <code>RGB [200, 100, 50]</code> and put in a percentage of .50 it should return <code>RGB[ 227.5  177.5  152.5]</code> Photoshop reports both as a hue of 20ยบ.</p>
<p>It is not hard to do this without numpy, but the element wise operations are convenient. </p>
<p><strong>Edit based on comment:</strong></p>
<p>I'm not suggesting you do this unless you know you really need to do it the hard way. But if you want to convert to LAB you can without too much trouble. The most important thing is that you need to know what color space your RGB numbers are in to begin with or you need to make some assumptions about their meaning. Since sRGB is pretty standard on the web, I'll assume that here.</p>
<p>The conversions aren't that difficult, but it's easy to make mistakes. Happily, there's a pretty nice colormath module with good documentation: <a href="https://github.com/gtaylor/python-colormath" rel="noreferrer">https://github.com/gtaylor/python-colormath</a></p>
<p>Using that you can convert between sRGB and LAB  like this:</p>
<pre><code>from colormath.color_objects import sRGBColor, LabColor
from colormath.color_conversions import convert_color

sRGB = sRGBColor(126, 126, 126, is_upscaled=True) # or between [0, 1] with out is_upscaled
lab =  convert_color(sRGB, LabColor)
</code></pre>
<p>lab now is a color with a Luminance channel <code>lab.lab_l</code> which you can move up or down between black(0) and white(100). This should be more perceptually uniform than HSB (but, depending on your application, maybe not enough to warrant the work).</p>
<p>You can simply change <code>lab_l</code> and then convert back:</p>
<pre><code>lab.lab_l = 80
new_sRGB = convert_color(lab, color_objects.sRGBColor).get_upscaled_value_tuple()
</code></pre>
<p><code>new_sRGB</code> is now <code>[198, 198, 198]</code>. colormath took care of the illuminant and gamma issues for you. </p>
</div>
<div class="post-text" itemprop="text">
<p>Simply linearly interpolate between your color and white:</p>
<pre><code>def lerp(a, b, t):
    return a*(1 - t) + b*t

import numpy as np
white = np.array([255, 255, 255])
my_color = np.array([...])
lightened25 = lerp(my_color, white, 0.25)
</code></pre>
<p>Or without numpy:</p>
<pre><code>lightened25 = [lerp(c, w, 0.25) for c, w in zip(my_color, white)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I prefer to use <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" rel="nofollow">HSV color mode</a>.</p>
<p>To grayer your color you have to decrease Saturation factor.</p>
<p>Standard <a href="https://docs.python.org/3/library/colorsys.html" rel="nofollow">colorsys</a> module can help in RGB &lt;-&gt; HSV conversions, but please keep in mind: <code>colorsys</code> operates with channel values in range [0, 1), not [0, 256).</p>
<p>There is full code example:</p>
<pre><code>&gt;&gt;&gt; from colorsys import hsv_to_rgb, rgb_to_hsv
&gt;&gt;&gt; color = (200, 120, 40)
&gt;&gt;&gt; normalized_color = (color[0]/256., color[1]/256., color[2]/256.)
&gt;&gt;&gt; normalized_color
(0.78125, 0.46875, 0.15625)
&gt;&gt;&gt; hsv_color = rgb_to_hsv(*normalized_color)
&gt;&gt;&gt; hsv_color
(0.08333333333333333, 0.8, 0.78125)
&gt;&gt;&gt; grayed_hsv_color = (hsv_color[0], 0.6, hsv_color[2])
&gt;&gt;&gt; grayed_rgb_color = hsv_to_rgb(*grayed_hsv_color)
&gt;&gt;&gt; grayed_rgb_color
(0.78125, 0.546875, 0.3125)
&gt;&gt;&gt; denormalized_rgb_color = (int(grayed_rgb_color[0]*256), int(grayed_rgb_color[1]*256), int(grayed_rgb_color[2]*256))
&gt;&gt;&gt; denormalized_rgb_color
(200, 140, 80)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not that simple because in your monitor each color channel is weighted differently.  I'd say the best bet is to do this in scikit image by converting to gray, dimming or brightening, and then back-converting to color.  Scikit-image will take care of keeping the colors straight.</p>
<pre><code>from skimage.color import gray2rgb, rgb2gray
scale_factor = 0.9 #90 percent
img_new = gray2rgb(rgb2gray(img) * scale_factor)
</code></pre>
<p>If you want to work directly with hue, saturation and value, check out this example:</p>
<p><a href="http://scikit-image.org/docs/dev/auto_examples/plot_tinting_grayscale_images.html" rel="nofollow">http://scikit-image.org/docs/dev/auto_examples/plot_tinting_grayscale_images.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As MarkM suggested, HSB (or HSL) is a simple method for doing this, but will not give perfect hue constance. If this is good enough (I assume you want your own method instead of a module) then <a href="http://www.easyrgb.com/index.php?X=MATH&amp;H=20#text20" rel="nofollow">this page</a> has code for doing it.</p>
<p>In python it would look like this:</p>
<pre><code>def rgb_to_hsl(rgb):
    '''
    Converts an rgb (0..255) tuple to hsl
    '''
    r, g, b = rgb

    _r = r / 255                     # RGB in percentage
    _g = g / 255
    _b = b / 255

    rgbMin = min(_r, _g, _b)    
    rgbMax = max(_r, _g, _b)
    rgbDelta = rgbMax - rgbMin

    l = ( rgbMax + rgbMin ) / 2

    if rgbDelta == 0:                        #Greyscale
        h = 0
        s = 0
    else:                                    # Chromatic data...
        if l &lt; 0.5: s = rgbDelta / (rgbMax + rgbMin)
        else:       s = rgbDelta / (2 - rgbMax - rgbMin)

        deltaR = (((rgbMax - _r) / 6) + rgbDelta/2) / rgbDelta
        deltaG = (((rgbMax - _g) / 6) + rgbDelta/2) / rgbDelta
        deltaB = (((rgbMax - _b) / 6) + rgbDelta/2) / rgbDelta

        if   _r == rgbMax: h = deltaB - deltaG
        elif _g == rgbMax: h = 1/3 + deltaR - deltaB
        elif _b == rgbMax: h = 2/3 + deltaG - deltaR

        if h &lt; 0: h += 1
        if h &gt; 1: h -= 1

    return (h, s, l)

def hsl_to_rgb(hsl):
    '''
    Converts a hsl tuple to rgb(0..255)
    '''
    h, s, l = hsl
    if s == 0:                      #Greyscale
        r = l * 255
        g = l * 255
        b = l * 255
    else:
        if l &lt; 0.5: var_2 = l * (1 + s)
        else:       var_2 = l + s - (s * l)

        var_1 = 2 * l - var_2

        r = 255 * hue_to_RGB(var_1, var_2, h + 1/3)
        g = 255 * hue_to_RGB(var_1, var_2, h)
        b = 255 * hue_to_RGB(var_1, var_2, h - 1/3)
    return r, g, b   

def hue_to_RGB (v1, v2, vH):
    '''
    Helper for hsl_to_rgb
    '''
    if vH &lt; 0: vH += 1
    if vH &gt; 1: vH -= 1
    if (6 * vH) &lt; 1: return v1 + (v2 - v1) * 6 * vH
    if (2 * vH) &lt; 1: return v2
    if (3 * vH) &lt; 2: return v1 + (v2 - v1) * 6 * (2/3 - vH)
    return v1
</code></pre>
<p>Then to brighten:</p>
<pre><code>def lighten(rgb):
    '''
    Given RGB values, returns the RGB values of the same colour slightly
    brightened (towards white) 
    '''
    h,s, l = rgb_to_hsl(rgb)
    l = min(l+0.1, 1)              #limit to 1
    return hsl_to_rgb((h, s, l))
</code></pre>
<p>The benefit of this method is that the increment is a percentage of the <em>total</em> brightness. Modifying this to take the percentage as an input would be trivial.</p>
<p>You can reverse engineer the mathematical equations form this code, or see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV#Converting_to_RGB" rel="nofollow">HSL to RGB</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The question, "to fade the color of a pixel out toward white" (not some shade of gray), is really about mixing the original pixel color with white, going from 100% original color and 0% white to 0% original color and 100% white. There's not more to it. Doing this in, for example, 101 steps would look like this:</p>
<pre><code>r0= 200; // as in the question
g0= 120;
b0=  40;
for(i= 100; i &gt;= 0; i--){
  r= (i * r0 + (100 - i) * 255) / 100;
  g= (i * g0 + (100 - i) * 255) / 100;
  b= (i * b0 + (100 - i) * 255) / 100;
  // use this color (r, g, b) somehow
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might want to check out <a href="https://stackoverflow.com/a/689547/444991">this answer</a> by <a href="https://stackoverflow.com/users/86643/denis">denis</a>:</p>
<blockquote>
<h3>RGB -&gt; ^gamma -&gt; Y -&gt; L*</h3>
<p>In color science, the common RGB values, as in html rgb( 10%, 20%, 30%
  ), are called "nonlinear" or <a href="http://en.wikipedia.org/wiki/Gamma_correction" rel="nofollow noreferrer">Gamma
  corrected</a>. "Linear"
  values are defined as</p>
<pre><code>Rlin = R^gamma,  Glin = G^gamma,  Blin = B^gamma
</code></pre>
<p>where gamma is 2.2 for many PCs. The usual R G B are sometimes written
  as R' G' B' (R' = Rlin ^ (1/gamma)) (purists tongue-click) but here
  I'll drop the '.</p>
<p>Brightness on a CRT display is proportional to RGBlin = RGB ^ gamma,
  so 50% gray on a CRT is quite dark: .5 ^ 2.2 = 22% of maximum
  brightness. (LCD displays are more complex; furthermore, some graphics
  cards compensate for gamma.)</p>
<p>To get the measure of lightness called <code>L*</code> from RGB, first divide R G
  B by 255, and compute</p>
<pre><code>Y = .2126 * R^gamma + .7152 * G^gamma + .0722 * B^gamma
</code></pre>
<p>This is <code>Y</code> in XYZ color space; it is a measure of color "luminance".
  (The real formulas are not exactly x^gamma, but close; stick with
  x^gamma for a first pass.)</p>
<p>Finally,
      L* = 116 * Y ^ 1/3 - 16 "... aspires to perceptual uniformity ... closely matches human perception of lightness." -- Wikipedia <a href="http://en.wikipedia.org/wiki/Lab_color_space" rel="nofollow noreferrer">Lab
  color space</a></p>
</blockquote>
</div>
<span class="comment-copy">Basically, you want to <i>desaturate</i> the color of your pixel, i.e. reduce its saturation while maintaining the hue and the value. Have a look at the Wikipedia page on <a href="https://en.wikipedia.org/wiki/HSL_and_HSV" rel="nofollow noreferrer">HSL and HSV color spaces</a>, I think there is everything you need to know.</span>
<span class="comment-copy">Your statement <i>"I know that (100,100,100) going to (110,110,110) is a greyscale fade"</i> is not entirely correct. These are still RGB values. But they <b><i>appear</i></b> to our human eyes to be gray shades.</span>
<span class="comment-copy">If you elaborate on the `define RGB colors and...convert to XYZ...manipulate L channel' approach, I will accept this answer. I think that is how I would like to do it.</span>
<span class="comment-copy">Surely this removes all hue from the image?</span>
<span class="comment-copy">Probably, but the HSV transformation is just as easy as the gray transform.  <code>rgb2hsv</code></span>
<span class="comment-copy">No point doing this manually when <code>colorsys</code> is a builtin</span>
<span class="comment-copy">You are correct, however the questions states <i>"... I would like to do it numerically, as indicated. Is there an equation to do so?"</i>. Though apparently he only wanted a method not the equations behind it.</span>
