<div class="post-text" itemprop="text">
<p>Okay, so this is a little hard to explain, but here goes:</p>
<p>I have a dictionary, which I'm adding content to. The content is a hashed username (key) with an IP address (value). 
I was putting the hashes into an order by running them against base 16, and then using Collection.orderedDict. 
So, the dictionary looked a little like this:</p>
<pre><code>d = {'1234': '8.8.8.8', '2345':'0.0.0.0', '3213':'4.4.4.4', '4523':'1.1.1.1', '7654':'1.3.3.7', '9999':'127.0.0.1'}
</code></pre>
<p>What I needed was a mechanism that would allow me to pick one of those keys, and get the key/value item one higher and one lower. So, for example, If I were to pick 2345, the code would return the key:value combinations '1234:8.8.8.8' and '3213:4.4.4.4'</p>
<p>So, something like:</p>
<pre><code>for i in d:
  while i &lt; len(d)
   if i == '2345':
     print i.nextItem
     print i.previousItem
     break()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As seen in the <a href="https://hg.python.org/cpython/file/2.7/Lib/collections.py#l69" rel="nofollow"><code>OrderedDict</code> source code</a>, 
if you have a key and you want to find the next and prev in O(1) here's how you do that.</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; d = OrderedDict([('aaaa', 'a',), ('bbbb', 'b'), ('cccc', 'c'), ('dddd', 'd'), ('eeee', 'e'), ('ffff', 'f')])
&gt;&gt;&gt; i = 'eeee'
&gt;&gt;&gt; link_prev, link_next, key = d._OrderedDict__map['eeee']
&gt;&gt;&gt; print 'nextKey: ', link_next[2], 'prevKey: ', link_prev[2]
nextKey:  ffff prevKey:  dddd
</code></pre>
<p>This will give you next and prev by insertion order. If you add items in random order then just keep track of your items in sorted order. </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edit:</strong> OP now states that they are using OrderedDicts but the use case still requires this sort of approach.</p>
<p>Since dicts are not ordered you cannot directly do this. From your example, you are trying to reference the item like you would use a linked list.</p>
<p>A quick solution would be instead to extract the keys and sort them then iterate over that list:</p>
<pre><code>keyList=sorted(d.keys())
for i,v in enumerate(keyList):
    if v=='eeee':
        print d[keyList[i+1]]
        print d[keyList[i-1]]
</code></pre>
<p>The <code>keyList</code> holds the order of your items and you have to go back to it to find out what the next/previous key is to get the next/previous value. You also have to check for i+1 being greater than the list length and i-1 being less than 0.</p>
<p>You can use an OrderedDict similarly but I believe that you still have to do the above with a separate list as OrderedDict doesn't have next/prev methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a generic function, based on iterators, to get a moving window (taken from <a href="https://stackoverflow.com/questions/6822725/rolling-or-sliding-window-iterator-in-python">this</a> question):</p>
<pre><code>import itertools

def window(iterable, n=3):
    it = iter(iterable)
    result = tuple(itertools.islice(it, n))
    if len(result) == n:
        yield result
    for element in it:
        result = result[1:] + (element,)
        yield result

l = range(8)
for i in window(l, 3):
    print i
</code></pre>
<p>Using the above function with <code>OrderedDict.items()</code> will give you three (key, value) pairs, in order:</p>
<pre><code>d = collections.OrderedDict(...)

for p_item, item, n_item in window(d.items()):
    p_key, p_value = p_item
    key, value = item
    # Or, if you don't care about the next value:
    n_key, _ = n_item
</code></pre>
<p>Of course using this function the first and last values will never be in the middle position (although this should not be difficult to do with some adaptation).</p>
<p>I think the biggest advantage is that it does not require table lookups in the previous and next keys, and also that it is generic and works with any iterable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try:</p>
<pre><code>pos = 0
d = {'aaaa': 'a', 'bbbb':'b', 'cccc':'c', 'dddd':'d', 'eeee':'e', 'ffff':'f'}

for i in d:
    pos+=1
    if i == 'eeee':
        listForm = list(d.values())
        print(listForm[pos-1])
        print(listForm[pos+1])
</code></pre>
<p>As in @AdamKerz's answer <code>enumerate</code> seems pythonic, but if you are a beginner this code might help you understand it in an easy way.</p>
<p>And I think its faster + smaller compared to sorting followed by building list &amp; then enumerating</p>
</div>
<div class="post-text" itemprop="text">
<p>You can store the keys and values in temp variable in prior, and can access previous and next key,value pair using index. </p>
<p>It is pretty dynamic, will work for any key you query. Please check this code :</p>
<pre><code>d = {'1234': '8.8.8.8', '2345':'0.0.0.0', '3213':'4.4.4.4', '4523':'1.1.1.1', '7654':'1.3.3.7', '9999':'127.0.0.1'}
ch = raw_input('Pleasure Enter your choice : ')
keys = d.keys()
values = d.values()
#print keys, values
for k,v in d.iteritems():
    if k == ch:
        ind = d.keys().index(k)
        print keys[ind-1], ':',values[ind-1]
        print keys[ind+1], ':',values[ind+1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe it is an overkill, but you can keep Track of the Keys inserted with a Helper Class and according to that list, you can retrieve the Key for Previous or Next. Just don't forget to check for border conditions, if the objects is already first or last element. This way, you will not need to always resort the ordered list or search for the element.</p>
<pre><code>from collections import OrderedDict

class Helper(object):
    """Helper Class for Keeping track of Insert Order"""
    def __init__(self, arg):
        super(Helper, self).__init__()

    dictContainer = dict()
    ordering = list()

    @staticmethod
    def addItem(dictItem):
        for key,value in dictItem.iteritems():
            print key,value
            Helper.ordering.append(key)
            Helper.dictContainer[key] = value

    @staticmethod
    def getPrevious(key):
        index = (Helper.ordering.index(key)-1)
        return Helper.dictContainer[Helper.ordering[index]]


#Your unordered dictionary
d = {'aaaa': 'a', 'bbbb':'b', 'cccc':'c', 'dddd':'d', 'eeee':'e', 'ffff':'f'}

#Create Order over keys
ordered = OrderedDict(sorted(d.items(), key=lambda t: t[0]))

#Push your ordered list to your Helper class
Helper.addItem(ordered)


#Get Previous of    
print Helper.getPrevious('eeee')
&gt;&gt;&gt; d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also use the <code>list.index()</code> method.</p>
<p>This function is more generic (you can check positions +n and -n), it will catch attempts at searching a key that's not in the dict, and it will also return <code>None</code> if there's nothing before of after the key:</p>
<pre><code>def keyshift(dictionary, key, diff):
    if key in dictionary:
        token = object()
        keys = [token]*(diff*-1) + sorted(dictionary) + [token]*diff
        newkey = keys[keys.index(key)+diff]
        if newkey is token:
            print None
        else:
            print {newkey: dictionary[newkey]}
    else:
        print 'Key not found'


keyshift(d, 'bbbb', -1)
keyshift(d, 'eeee', +1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think this is a nice Pythonic way of resolving your problem using a <a href="https://docs.python.org/3/tutorial/controlflow.html?highlight=lambda#lambda-expressions" rel="nofollow noreferrer">lambda</a> and <a href="https://docs.python.org/3/library/stdtypes.html?highlight=list%20comprehension#lists" rel="nofollow noreferrer">list comprehension</a>, although it may not be optimal in execution time:</p>
<pre><code>import collections

x = collections.OrderedDict([('a','v1'),('b','v2'),('c','v3'),('d','v4')])

previousItem = lambda currentKey, thisOrderedDict : [
    list( thisOrderedDict.items() )[ z - 1 ] if (z != 0) else None
    for z in range( len( thisOrderedDict.items() ) )
    if (list( thisOrderedDict.keys() )[ z ] == currentKey) ][ 0 ]

nextItem = lambda currentKey, thisOrderedDict : [
    list( thisOrderedDict.items() )[ z + 1 ] if (z != (len( thisOrderedDict.items() ) - 1)) else None
    for z in range( len( thisOrderedDict.items() ) )
    if (list( thisOrderedDict.keys() )[ z ] == currentKey) ][ 0 ]

assert previousItem('c', x) == ('b', 'v2')
assert nextItem('c', x) == ('d', 'v4')
assert previousItem('a', x) is None
assert nextItem('d',x) is None
</code></pre>
</div>
<span class="comment-copy">Dicts are not ordered. There is no next or previous item.</span>
<span class="comment-copy">I have mine ordered using 'collections.orderedDict'. If There isn't a way of doing this in a dict, can I take the keys out, and put them into a list (or tuple, or whatever), and then search for the next and previous item, and then use that to re-query the dictionary for their values?</span>
<span class="comment-copy"><code>collections.OrderedDict</code> objects have a list of 2-tuples internally.  If you iterate through them using <code>.items()</code> you should get them in the order they are added.</span>
<span class="comment-copy">If you're using an <code>OrderedDict</code>, you should <b>definitely mention that</b>, in the question itself.</span>
<span class="comment-copy">@jamylak OP was already using a <code>for</code> to iterate through the keys, might as well iterate through that using <code>items()</code>. As you noted, question is misleading and unclear hence I just left a comment to hopefully guide him to figure something out.</span>
<span class="comment-copy">That's not good practice - __map is a private attribute and is not guaranteed to exist or continue to function the same way in different versions or different platforms.</span>
<span class="comment-copy">@AdamKerz It's the only way to access the <code>OrderedDict</code> linked list if you need it for whatever purpose, it doesn't matter, you need this if you want to find the <code>next</code> and <code>prev</code> in O(1). Keep in mind I answered the actual question, and the title was misleading for the actual problem OP is having</span>
<span class="comment-copy">I never said that it doesn't work, or that there's another way to access <code>OrderedDict</code>'s linked list, just that it's not good practice. The OP never mentioned O(1) complexity, and yet my solution is also generally O(1) complexity (assuming dict lookup is O(1) or close as it is in normal cases).</span>
<span class="comment-copy">Note this only works if you actually use an OrderedDict... :-) And you are also creating a list there: list(d.values()). And possibly multiple lists if the conditional matches more than one key (no, it won't in this example). Note that sorted does build a list (but that is necessary if you are interested in alphabetical order rather than insert order (as was the original request)). And finally, enumerate returns an iterator so that is basically the same in terms of efficiency as what you are doing and less verbose.</span>
<span class="comment-copy">@AdamKerz k, thanks for the insights -</span>
<span class="comment-copy">This one is good as well, i think the usage should be considered, if the access to prev/next element will happen very often or how often the inserts to the dictionary will happen.</span>
