<div class="post-text" itemprop="text">
<p>I have some objects which can either be floats (or integers) or tuples (or lists or arrays). Is it possible to use idiomatic Python to avoid writing an <code>if</code>/<code>elif</code> function? Right now I have</p>
<pre><code>def f(attribute_a,attribute_b):
    if type(attribute_a) == float or type(attribute_a) == int:
        result = attribute_a + attribute_b
    elif type(attribute_a) == list or type(attribute_a) == tuple or type(attribute_a) == array:
        result = numpy.array([ attribute_a[i] + attribute_b[i] for i in range(len(attribute_a)) ])
    return result
</code></pre>
<p>I'd like to avoid the elif stuff because sometimes I want attribute_a to be a float but attribute_b to be a list in which case, I'd like something like</p>
<pre><code>result = numpy.array([ attribute_a + attribute_b[i] for i in range(len(attribute_b)) ])
</code></pre>
<p>since I have five different attributes, it's infeasible to write out the full set of possible <code>if</code> loops for every possible combination of which one is a number and which is a list.</p>
<p>Any help is appreciated,
Thanks,
Sam</p>
<p><em>EDIT, 1/23/15:</em> One idea is to define two new functions as follows</p>
<pre><code>def general_value(x,i):
    if type(x)==float or type(x)==int:
        return x
    elif type(x)==list or type(x)==tuple:
        return x[i]
def general_len(x):
    if type(x)==float or type(x)==int:
        return 1
    elif type(x)==list or type(x)==tuple:
         return len(x)
</code></pre>
<p>(or with the various generalizations to isintance, etc.), and then plug these in where needed. Is this a reasonable hack, or is it somehow infelicitous?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use isinstance where you can pass a tuple of types to avoid your multiple <code>or's</code>:</p>
<pre><code>if  isinstance(attribute_a,(int,float))
   ...
elif isinstance(attribute_a,(list,tuple, array)):
</code></pre>
<p>If you can only have either two possible cases use if/else:</p>
<pre><code>  if  isinstance(attribute_a,(int,float))
     result =  ...
  else:
     result =  ...
</code></pre>
<p>You could use a conditional expression but your statement would be rather long:</p>
<pre><code>result =  attribute_a + attribute_b if isinstance(attribute_a,(int,float)) else numpy.array([ attribute_a[i] + attribute_b[i] for i in range(len(attribute_a)) ])
</code></pre>
<p>If you want to check two attributes for a group of possible match combinations:</p>
<pre><code>if isinstance(attribute_a,(list,tuple,float) and isinstance(attribute_b,(float,list))):
</code></pre>
<p>Another way is to store the result of isinstance and negate the checks to avoid repeated calls:</p>
<pre><code>a,b = if isinstance(attribute_a,(list,tuple) ,isinstance(attribute_b,float))

if a and b:
   ...
elif  a and not b:
   ...
else:
    ....
</code></pre>
<p>If you want to check if either is a tuple,list, etc.. then you can use:</p>
<pre><code>from collections import Iterable
def check(ele):
   return isinstance(ele,Iterable) and not isinstance(ele,basestring)
</code></pre>
<p>Then:</p>
<pre><code>if check(attribute_a) and check(attribute_b):
    .....
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may want to consider using an abstract base class to cut down on the number of combinations. </p>
<p>There is already an abc to test if one of your arguments is <code>int</code> or <code>float</code>; it is <code>numbers.Real</code>: </p>
<pre><code>assert isinstance(1,numbers.Real)
assert isinstance(1.1,numbers.Real)
</code></pre>
<p>There is also already an abc to test if one of your arguments is  <code>list</code>, <code>tuple</code>, or <code>array</code>. It is <code>collections.abc.Container</code>: </p>
<pre><code>assert isinstance((1,),collections.abc.Container)
assert isinstance([],collections.abc.Container)
assert isinstance(array([]),collections.abc.Container)
</code></pre>
<p>So the function becomes: </p>
<pre><code>def f(attribute_a,attribute_b):
    if isinstance(attribute_a,numbers.Real) and isinstance(attribute_b,numbers.Real):
        #Both arguments are Real numbers
        result = attribute_a + attribute_b
    elif isinstance(attribute_a,collections.abc.Container) and isinstance(attribute_b,collections.abc.Container):
        #Both arguments are Containers
        result = numpy.array([ attribute_a[i] + attribute_b[i] for i in range(len(attribute_a)) ])
    elif isinstance(attribute_a,numbers.Real) and isinstance(attribute_b,collections.abc.Container):
        # First argument is a Real number, second is a Container
        result = numpy.array([ attribute_a + attribute_b[i] for i in range(len(attribute_b)) ])
    elif isinstance(attribute_a,collections.abc.Container) and isinstance(attribute_b,numbers.Real):
        # First argument is a Container, second is a Real number
        result = numpy.array([ attribute_a[i] + attribute_b for i in range(len(attribute_a)) ])
    return result
</code></pre>
<p>There is one important potential advantage to using abstract base classes instead of <code>isinstance(var,(list, tuple, array))</code> as in the <a href="https://stackoverflow.com/a/28115527/2437514">Padraic Cunningham's answer</a>: checking against an abc instead will allow your code to work even for types that "act like" these kinds of containers, but are not necessarily subclasses of them. The same is true for classes that "act like" a <code>Real</code> but are not necessarily subclassed from <code>int</code> or <code>float</code>. Depending on your use case, this can also be a disadvantage as well (see the note below about <code>str</code> objects, for instance). </p>
<p>EDIT: Important gotcha from the comments below is this:</p>
<pre><code>assert isinstance("some string",collections.abc.Container)
</code></pre>
<p>If it is important to restrict strings from the iterable types (looks like it might be), a custom abstract base class can be created <a href="https://docs.python.org/2/library/abc.html" rel="nofollow noreferrer">using the <code>abc</code> module</a>.</p>
<p>Or alternatively, you can just add <code>and not isinstance(var,str)</code> (Python 3 only).</p>
<hr/>
<p>EDIT: Unfortunately the <code>overload</code> part of this answer won't work for OP since he's &lt;3.0, but maybe it will help somebody else. </p>
<p>This question also reminded me of the <a href="https://pypi.python.org/pypi/overload" rel="nofollow noreferrer"><code>overload</code> library</a>, which I have been meaning to try out. </p>
<p>Using that module, here's an attempt to solve your problem using abstract base classes: </p>
<pre><code>from overload import overload
from collections.abc import Container
from numbers import Real

@overload
def f(attribute_a:Container,attribute_b:Container):
    '''Both arguments are Containers, e.g. list, tuple, or array'''
    return numpy.array([ attribute_a[i] + attribute_b[i] for i in range(len(attribute_a)) ])

@f.add
def f(attribute_a:Real,attribute_b:Real):
    '''Both arguments are Real numbers, e.g. int, float'''
    attribute_a + attribute_b

@f.add
def f(attribute_a:Real,attribute_b:Container):
    '''First argument is a Real number, second is a Container'''
    return numpy.array([ attribute_a + attribute_b[i] for i in range(len(attribute_b)) ])

@f.add
def f(attribute_a:Container,attribute_b:Real):
    '''First argument is a Container, second is a Real number'''
    return f(attribute_b,attribute_a)
</code></pre>
</div>
<span class="comment-copy">It is a design smell if you need to pass both a scalar and a sequence to the same function. There are exceptions such as <code>numpy.array</code> (the same function may work on 0D arrays (scalars), 1D arrays -- sequences, N-D -- multidimensional arrays. If you think it is justified in your case; you could create a <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=101605" rel="nofollow noreferrer">multimethod</a> similar to how <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer"><code>functools.singledispatch()</code> works</a> -- note: it uses only the first argument -- you need two.</span>
<span class="comment-copy">Here're are <a href="http://stackoverflow.com/q/20771788/4279">several</a> <a href="http://stackoverflow.com/q/17098553/4279">code</a> <a href="http://stackoverflow.com/q/23550870/4279">examples</a>.</span>
<span class="comment-copy">Why was his voted down?</span>
<span class="comment-copy">@dopstar, who knows some strange things happen on SO ;)</span>
<span class="comment-copy">Thanks. The issue is that sometimes <code>attribute_a</code> is going to be a float while <code>attribute_b</code> is a list; sometimes vice versa; and sometimes they will be the same. Is there any succinct way of covering the different options for each <code>attribute</code> individually when they enter <code>result</code>?</span>
<span class="comment-copy">Overload does seem perfect! Regrettably, I am still on py27!</span>
<span class="comment-copy">In principle it's more than a "few" <code>if</code> statements: I have 5 attributes, so I have 2**5 = 32 statements, right?</span>
<span class="comment-copy">only problem is if I saw that code I would have absolutely no idea what was happening. I think I would quite happily stick to  a few if/elif's</span>
<span class="comment-copy">definitely needs some commentary!</span>
<span class="comment-copy">using the abc's alone (without overload) would do a lot to cut down on the number of test statements needed, though.</span>
<span class="comment-copy">I am just in the process of using collections.Iterable or some variation. I was not fully sure exactly what the OP wanted to check for. It seems more a combination that is the problem</span>
<span class="comment-copy">you can use the <code>not isinstance("foo",str)</code> in python 3</span>
