<div class="post-text" itemprop="text">
<p>I'm trying to reimplement (once more... i know...) a simple network in python made of node classes that reference other node classes (theyr children), and I was wondering what would happen if I create a recursive network (node1 -&gt; node2 -&gt; node3 -&gt; node1) and accidentally lose all references to any of the nodes.</p>
<p>Imagine I have the following code</p>
<pre><code>class node():
    def __init__(self):
        self.children = []

    def append(self, child):
        self.children.append(child)

node1 = node()
node2 = node()

node1.append(node2)
node2.append(node1) # now the network is recursive

node1 = 0
# node1 is still referenced in node2.children so will not be deleted
node2 = 0

# now both node1 and node2 are not directly referenced by any variable
# but they are referenced by the two children instances
</code></pre>
<p>after the last line of code, all references to node1 and node2 are lost, but the memory originally allocated to the nodes sill contain a reference to themselves.</p>
<p>Would node1 and node2 still be destroyed?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, the objects will be garbage collected. The garbage collector will detect the circular reference and break it so that normal reference counting cleanup can take place. See the <a href="https://docs.python.org/2/library/gc.html" rel="nofollow"><code>gc</code> module</a>.</p>
<p>You <em>would</em> have a problem if your <code>node</code> class implemented a <code>__del__</code> method and you are using a Python version &lt; 3.4. In 3.4 now can <a href="https://docs.python.org/3/whatsnew/3.4.html#pep-442-safe-object-finalization" rel="nofollow">break circular references involving instances with <code>__del__</code> methods</a> in most cases.</p>
<p>From the <a href="https://docs.python.org/2/reference/datamodel.html#object.__del__" rel="nofollow"><code>object.__del__</code> documentation</a>:</p>
<blockquote>
<p><strong>Note</strong>: <code>del x</code> doesn’t directly call <code>x.__del__()</code> — the former decrements the reference count for <code>x</code> by one, and the latter is only called when <code>x</code>‘s reference count reaches zero. Some common situations that may prevent the reference count of an object from going to zero include: circular references between objects (e.g., a doubly-linked list or a tree data structure with parent and child pointers); a reference to the object on the stack frame of a function that caught an exception (the traceback stored in <code>sys.exc_traceback</code> keeps the stack frame alive); or a reference to the object on the stack frame that raised an unhandled exception in interactive mode (the traceback stored in <code>sys.last_traceback</code> keeps the stack frame alive). The first situation can only be remedied by explicitly breaking the cycles; the latter two situations can be resolved by storing <code>None</code> in <code>sys.exc_traceback</code> or <code>sys.last_traceback</code>. Circular references which are garbage are detected when the option cycle detector is enabled (it’s on by default), but can only be cleaned up if there are no Python-level <code>__del__()</code> methods involved. Refer to the documentation for the <code>gc</code> module for more information about how <code>__del__()</code> methods are handled by the cycle detector, particularly the description of the garbage value.</p>
</blockquote>
</div>
<span class="comment-copy">thanks for the info... that was very helpful!</span>
