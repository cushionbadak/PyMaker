<div class="post-text" itemprop="text">
<p>When you call the <code>object.__repr__()</code> method in Python you get something like this back: </p>
<blockquote>
<pre><code>&lt;__main__.Test object at 0x2aba1c0cf890&gt; 
</code></pre>
</blockquote>
<p>Is there any way to get a hold of the memory address if you overload <code>__repr__()</code>, other then calling <code>super(Class, obj).__repr__()</code> and regexing it out? </p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/2/library/functions.html#id" rel="noreferrer">Python manual</a> has this to say about <code>id()</code>:</p>
<blockquote>
<p>Return the "identity'' of an object.
  This is an integer (or long integer)
  which is guaranteed to be unique and
  constant for this object during its
  lifetime. Two objects with
  non-overlapping lifetimes may have the
  same id() value. (Implementation note:
  this is the address of the object.)</p>
</blockquote>
<p>So in CPython, this will be the address of the object. No such guarantee for any other Python interpreter, though.</p>
<p>Note that if you're writing a C extension, you have full access to the internals of the Python interpreter, including access to the addresses of objects directly.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could reimplement the default repr this way:</p>
<pre><code>def __repr__(self):
    return '&lt;%s.%s object at %s&gt;' % (
        self.__class__.__module__,
        self.__class__.__name__,
        hex(id(self))
    )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just use </p>
<pre><code>id(object)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are a few issues here that aren't covered by any of the other answers.</p>
<p>First, <a href="https://docs.python.org/3/library/functions.html#id" rel="noreferrer"><code>id</code></a> only returns:</p>
<blockquote>
<p>the “identity” of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same <code>id()</code> value.</p>
</blockquote>
<hr/>
<p>In CPython, this happens to be the pointer to the <a href="https://docs.python.org/3/c-api/object.html" rel="noreferrer"><code>PyObject</code></a> that represents the object in the interpreter, which is the same thing that <code>object.__repr__</code> displays. But this is just an implementation detail of CPython, not something that's true of Python in general. Jython doesn't deal in pointers, it deals in Java references (which the JVM of course probably represents as pointers, but you can't see those—and wouldn't want to, because the GC is allowed to move them around). PyPy lets different types have different kinds of <code>id</code>, but the most general is just an index into a table of objects you've called <code>id</code> on, which is obviously not going to be a pointer. I'm not sure about IronPython, but I'd suspect it's more like Jython than like CPython in this regard. So, in most Python implementations, there's no way to get whatever showed up in that <code>repr</code>, and no use if you did.</p>
<hr/>
<p>But what if you only care about CPython? That's a pretty common case, after all.</p>
<p>Well, first, you may notice that <code>id</code> is an integer;* if you want that <code>0x2aba1c0cf890</code> string instead of the number <code>46978822895760</code>, you're going to have to format it yourself. Under the covers, I believe <code>object.__repr__</code> is ultimately using <code>printf</code>'s <code>%p</code> format, which you don't have from Python… but you can always do this:</p>
<pre><code>format(id(spam), '#010x' if sys.maxsize.bit_length() &lt;= 32 else '#18x')
</code></pre>
<p><sub>* In 3.x, it's an <code>int</code>. In 2.x, it's an <code>int</code> if that's big enough to hold a pointer—which is may not be because of signed number issues on some platforms—and a <code>long</code> otherwise.</sub></p>
<p>Is there anything you can do with these pointers besides print them out? Sure (again, assuming you only care about CPython).</p>
<p>All of the <a href="https://docs.python.org/3/c-api/index.html" rel="noreferrer">C API</a> functions take a pointer to a <code>PyObject</code> or a related type. For those related types, you can just call <code>PyFoo_Check</code> to make sure it really is a <code>Foo</code> object, then cast with <code>(PyFoo *)p</code>. So, if you're writing a C extension, the <code>id</code> is exactly what you need.</p>
<p>What if you're writing pure Python code? You can call the exact same functions with <a href="https://docs.python.org/3/library/ctypes.html#accessing-values-exported-from-dlls" rel="noreferrer"><code>pythonapi</code></a> from <code>ctypes</code>.</p>
<hr/>
<p>Finally, a few of the other answers have brought up <a href="https://docs.python.org/3/library/ctypes.html#ctypes.addressof" rel="noreferrer"><code>ctypes.addressof</code></a>. That isn't relevant here. This only works for <code>ctypes</code> objects like <code>c_int32</code> (and maybe a few memory-buffer-like objects, like those provided by <code>numpy</code>). And, even there, it isn't giving you the address of the <code>c_int32</code> value, it's giving you the address of the C-level <code>int32</code> that the <code>c_int32</code> wraps up.</p>
<p>That being said, more often than not, if you really think you need the address of something, you didn't want a native Python object in the first place, you wanted a <code>ctypes</code> object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just in response to Torsten, I wasn't able to call <code>addressof()</code> on a regular python object. Furthermore, <code>id(a) != addressof(a)</code>. This is in CPython, don't know about anything else.</p>
<pre><code>&gt;&gt;&gt; from ctypes import c_int, addressof
&gt;&gt;&gt; a = 69
&gt;&gt;&gt; addressof(a)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: invalid type
&gt;&gt;&gt; b = c_int(69)
&gt;&gt;&gt; addressof(b)
4300673472
&gt;&gt;&gt; id(b)
4300673392
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With <a href="http://docs.python.org/lib/module-ctypes.html" rel="nofollow noreferrer">ctypes</a>, you can achieve the same thing with</p>
<pre><code>&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; a = (1,2,3)
&gt;&gt;&gt; ctypes.addressof(a)
3077760748L
</code></pre>
<p>Documentation:</p>
<blockquote>
<p><code>addressof(C instance) -&gt; integer</code><br/>
  Return the address of the C instance internal buffer</p>
</blockquote>
<p>Note that in CPython, currently <code>id(a) == ctypes.addressof(a)</code>, but <code>ctypes.addressof</code> should return the real address for each Python implementation, if</p>
<ul>
<li>ctypes is supported</li>
<li>memory pointers are a valid notion.</li>
</ul>
<p><strong>Edit</strong>: added information about interpreter-independence of ctypes</p>
</div>
<div class="post-text" itemprop="text">
<p>You can get something suitable for that purpose with:</p>
<pre><code>id(self)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While it's true that <code>id(object)</code> gets the object's address in the default CPython implementation, this is generally useless... you can't <i>do</i> anything with the address from pure Python code.</p>
<p>The only time you would actually be able to use the address is from a C extension library... in which case it is trivial to get the object's address since Python objects are always passed around as C pointers.</p>
</div>
<span class="comment-copy">This is <b>not</b> a universal answer to the question; it only applies to CPython.</span>
<span class="comment-copy">Note to self:  The guarantee does not apply to multiprocessing</span>
<span class="comment-copy">Some ways to use it (to compare the value it contains): <a href="https://forum.freecodecamp.com/t/python-id-object/19207" rel="nofollow noreferrer">forum.freecodecamp.com/t/python-id-object/19207</a></span>
<span class="comment-copy">What does an object's <code>lifetime</code> (and what does it mean for lifetime to <code>overlap/not overlap</code>) refer to in this context?</span>
<span class="comment-copy">@MinhTran because the id is the memory address of the object, it is guaranteed unique within the process, and while the object exists. Some time after the object is garbage collected the memory may be reused. A non overlapping lifetime would mean the original object no longer exists when the new object is created. So this limitation means you can't safely use id() to create a hash of an object to store off, free it, and later reinstate it.</span>
<span class="comment-copy">I know this is old, but you can just do <code>return object.__repr__(self)</code> or even just do <code>object.__repr__(obj)</code> whenever you need this instead of making a new class</span>
<span class="comment-copy">@Artyer: What does this comment have to do with the original question? The answer posted here is recreating the address as requested by the original question. Wouldn't you have to string mangle if you did it the way you suggest?</span>
<span class="comment-copy">This seems like the best answer to me. Just try making an object(), print it, then print hex(id(object)) and the results match</span>
<span class="comment-copy">@Rafe Your answer is a long winded way of doing <code>__repr__ = object.__repr__</code>, and isn't nearly as fool proof, as there are a variety of situations where this doesn't work, e.g. an overrided <code>__getattribute__</code> or a non-CPython implementation where the id isn't the memory location. It also doesn't z-fill, so you would have to work out if the system is 64bit and add the zeroes as necessary.</span>
<span class="comment-copy">@Artyer: My example shows how to construct a repr. We often add custom information (and I would say this is good coding practice as it aids in debugging). We use this style heavily and I have never run in to your edge cases. Thanks for sharing them!</span>
<span class="comment-copy">which gives a number. ... What's next? Can i access the object with that number?</span>
<span class="comment-copy">You can check this <a href="https://docs.python.org/2/library/functions.html#id" rel="nofollow noreferrer"><code>id()</code></a> @JLT</span>
<span class="comment-copy">well this is the only way to store mutable objects in maps/sets when identity is important...</span>
<span class="comment-copy">@Enerccio The other uses of <code>id</code>—including using them to hold mutable values in a <code>seen</code> set or a <code>cache</code> dict—don’t depend on any way on the <code>id</code> being a pointer, or related in any way to the <code>repr</code>. Which is exactly why such code works in all Python implementations, instead of only working in CPython.</span>
<span class="comment-copy">yeah, I used <code>id</code> for it, but I mean still even in java you can get address of object, seems strange there is no way in (C)Python since that one has actually stable gc that won't move objects thus address stays the same</span>
<span class="comment-copy">@Enerccio But you don't want to use the address of an object for a cacheable value—you want to use the <code>id</code> fo an object, whether it's an address or not. For example, in PyPy, <code>id</code> is still just as useful as a key in CPython, even though it's usually just an index into some hidden table in the implementation, but a pointer would be useless, because (like Java) the object can be moved in memory.</span>
<span class="comment-copy">@Enerccio Anyway, there <i>is</i> a way to get a pointer in CPython. As explained in the answer, CPython explicitly documents, as an implementation-specific detail, that the <code>id</code> of an object is the pointer to the object's location in memory. So, if you have any use for the pointer value (which you almost never do, as also explained in the answer) in CPython-specific code, there is a way to get it that's documented and guaranteed to work.</span>
<span class="comment-copy">That's a good pick! Did you find out anymore on this?</span>
<span class="comment-copy">&gt;&gt;&gt; import ctypes &gt;&gt;&gt; a = (1,2,3) &gt;&gt;&gt; ctypes.addressof(a) Traceback (most recent call last):   File "&lt;input&gt;", line 1, in &lt;module&gt; TypeError: invalid type &gt;&gt;&gt; id(a) 4493268872 &gt;&gt;&gt;</span>
<span class="comment-copy">I concur with Barry: the above code results in <code>TypeError: invalid type</code> when I try it with Python 3.4.</span>
<span class="comment-copy">Unless you use the built-in <code>ctypes</code> toolkit in the Standard Library. In which case you can do all sorts of things with the address :)</span>
