<div class="post-text" itemprop="text">
<p>I have two files in the same directory one that contains the contents of my program <code>poker.py</code> and the other that has test cases <code>poker_test.py</code>.</p>
<p>In <code>poker_test.py</code> I execute the following commands to run the test cases:</p>
<pre><code>import unittest
import poker


class PokerTest(unittest.TestCase):
      (...)
</code></pre>
<p>Then at the end of <code>poker.py</code> while I'm developing i have the following commnands:</p>
<pre><code>if __name__ == "__main__":
    #imports Test case and unittest
    from poker_test import *
    unittest.main() 
</code></pre>
<p>Everything works just fine(for now) and this setup is great for iterative development. My question is how does python evaluate <code>poker.py</code> when I run it, given that <code>poker_test.py</code> depends on <code>poker.py</code> and vice versa?</p>
<p>I have a rough idea, but was wondering what the "official" answer is.</p>
<p>Thanks,
-M</p>
</div>
<div class="post-text" itemprop="text">
<p>In terms of whether you should do it, as Alex says, avoid it at all costs.  Cyclical imports are a state of sin.</p>
<p>With that aside, it's interesting to look at what's happening (roughly - it looks like the module import mechanism is <a href="https://docs.python.org/3/reference/import.html#references" rel="nofollow">an area that gets tweaked from version to version in Python</a>.  My main source for this was the Python 3.4.2 docs on the importing system)</p>
<p>When the line within <code>poker_test.py</code>:</p>
<pre><code>import poker
</code></pre>
<p>gets executed, the system first checks if the module is already loaded.  Loaded modules live in a dictionary called <code>sys.modules</code>.</p>
<ul>
<li>If the module being imported is in <code>sys.modules</code> already, any reference to <code>poker</code> in <code>poker_test.py</code> just points to that namespace.  (Note that in the case of cyclical imports, the module might already be added to <code>sys.modules</code>, but the populating of the namespace may not be fully over.  Execution of that module might be paused for the moment at the line that says <code>import this_or_that_other_module</code>)</li>
<li>If the module is not there, then the system creates a new namespace, adds it to <code>sys.modules</code>, looks for the code that is associated with the <code>poker</code> module (in this case, living in <code>poker.py</code>) and begins to execute it, putting all the variables in the newly created namespace.</li>
</ul>
<p>So you'd think <code>poker.py</code> gets run once, and <code>poker_test.py</code> gets run once and already notices that <code>poker</code> is a loaded module, so the importing ends there.  Except...</p>
<p>When a module is run as the original script, it gets registered as <code>__main__</code> in <code>sys.modules</code>, instead of its actual name.  </p>
<p>So <code>poker.py</code> is going to be called the <code>__main__</code> module, and as a result, when <code>poker_test</code> tries running <code>import poker</code>, it can't find <code>poker</code> under <code>sys.modules</code>.  <code>poker</code> <em>will</em> be loaded twice, once as <code>__main__</code> and again as <code>poker</code>.  Cyclical imports are frowned upon, but cyclical imports of the <code>__main__</code> module is downright condemned because of this issue of creating two identical(ish) namespaces and the potential weird errors that can result.</p>
<p>There are two more complications in your code.</p>
<p>1) <code>from poker_test import *</code></p>
<p>Because you're doing an <code>import *</code>, instead of putting all the variables created from <code>poker_test</code> in its own namespace, it gets thrown into the <code>__main__</code> namespace.</p>
<p>2) <code>if __name__=='__main__':</code></p>
<p>Because you're only importing from <code>poker_test</code> if the module is the main script being executed, the Python interpreter will not touch that line when <code>poker</code> gets imported from <code>poker_test</code>.  So your code isn't really looping conceptually.  <code>poker</code> as <code>__main__</code> imports <code>poker_test</code> which imports <code>poker</code> and stops there.  Simple!</p>
<p>...so let's not do circular imports.</p>
<p>Some reference material:</p>
<p><a href="https://docs.python.org/3/reference/import.html" rel="nofollow">Official Python 3.4.2 docs on the import system</a></p>
<p><a href="https://groups.google.com/forum/#!topic/comp.lang.python/HYChxtsrhnw" rel="nofollow">2008 comp.lang.python discussion on cyclical imports</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It's always soundest to avoid circular dependencies like the one you've created here.  However you luck out because the <code>from poker_test import *</code> comes at the very end of <code>poker.py</code>, i.e, after the latter has defined all it does define, so it can be imported in a good state by the circularly-dependent <code>poker_test.py</code>.</p>
<p>However, while this happens to work in current Python version,s it's not guaranteed by the language spec.  For solidity, break the circular dependency, e.g as follows:</p>
<ul>
<li>move all the "substantial" contents of <code>poker.py</code> before the <code>if __name__</code> check to e.g <code>_poker.py</code></li>
<li>in <code>poker.py</code>, just do <code>from _poker import *</code></li>
<li>in <code>poker_test.py</code>, instead of <code>import poker</code>, use <code>import _poker as poker</code></li>
</ul>
<p>This way, your dependency graph becomes acyclical, and as a consequence your code will work as intended in any correct version of Python, including hypothetical future ones:-).</p>
</div>
<span class="comment-copy">Note that unittest also supports limited commandline arguments: <a href="https://docs.python.org/2/library/unittest.html#command-line-interface" rel="nofollow noreferrer">docs.python.org/2/library/unittest.html#command-line-interface</a> -- In this case, rather than <code>python poker.py</code> to run the test, you'd do <code>python -m unittest poker_test.py</code> and Bob is your uncle.  you can even run only specific tests.  <code>python -m unittest poker_test.PokerTest.testSomething</code></span>
