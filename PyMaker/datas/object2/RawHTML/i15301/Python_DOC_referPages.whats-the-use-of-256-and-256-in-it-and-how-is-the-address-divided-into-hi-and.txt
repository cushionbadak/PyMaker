<div class="post-text" itemprop="text">
<p>This is a code snippet from <code>lib_robotis</code> and the value <code>n</code> is the angle that we are inputting(to rotate the dimexel motor).</p>
<p>According to the architecture of the chip within the motor, we require to give the lower bit (identified by <code>lo</code>) of the goal position into the address 0x1e and the higher bit (identified by <code>hi</code>) of the goal position into the address 0x1f.</p>
<pre><code>def move_to_encoder(self,n);
    n=min(max(n,0),self.settings['max_encoder'])
    hi,lo=n/256, n%256
    return self.write_address(0x1e, [hi,lo])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>n is a number in the range 0 &lt;= n &lt; 256*256. It takes two bytes to express that number since one byte can encode a value from 0 to 255.</p>
<p><code>hi,lo=n/256, n%256</code></p>
<p>is the same as </p>
<pre><code>hi = n / 256
lo = n % 256
</code></pre>
<p><code>/</code> is the division operator and <code>%</code> is the remainder operator, so the above code says to divide <code>n</code> by 256 and store the quotient in <code>hi</code> and the remainder in <code>lo</code>. Each of <code>hi</code> and <code>lo</code> will be in the range 0 to 255, so they will each fit into one byte. And n == (256 * hi) + lo, so no information has been lost &amp; the motor controller has all the information it needs to perform the desired operation.</p>
<p>I assume that the code in your post was written for Python 2; it won't work properly on Python 3. You should replace the <code>n / 256</code> by <code>n // 256</code> to make the code work on all versions of Python.</p>
<p>FWIW, there are various better ways to break a number up into high and low bytes. One uses the built-in <a href="https://docs.python.org/3/library/functions.html#divmod" rel="nofollow">divmod</a> function:</p>
<p><code>hi, lo = divmod(n, 256)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>First of all you're talking about higher/lower <em>bytes</em>, not <em>bits</em>.</p>
<p>Dividing by 256 is the same as shifting rightwards 8 times, so that will basically yield the high byte. Taking the remainder of the division by 256 (through the <em>modulo operator</em> '%') effectively extracts the lower byte, since the result will be &lt; 256 by definition.</p>
</div>
<div class="post-text" itemprop="text">
<p>Think of bits like they are the "digits" in the binary notation. If you need to take, say, 2 rightmost digits of the number 256, you simply write 256%100, where 100 is 10^2. Likewise, to take 8 rightmost "binary digits", i.e. bits, you have to divide the number by 2^8, i.e. 256.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>we require to give the lower bit (identified by lo) of the goal position into the address 0x1e</p>
</blockquote>
<p>256 is 2<sup>8</sup>, so dividing by 256 meaning <em>rightshifting</em> by 8 bits, giving you the high <em>byte</em>.</p>
<p>Take for example a 16-bits number:</p>
<pre><code>1100101100101101
↑↑↑↑↑↑↑↑
</code></pre>
<p>dividing it by 256 is rightshifting by 8 bits, will give you:</p>
<pre><code>0000000011001011
        ↑↑↑↑↑↑↑↑
</code></pre>
<p>The <em>remainder</em> of the division by 256 gives you the lower <em>byte</em>.</p>
</div>
<span class="comment-copy">Maybe we should merge our answers. :)</span>
<span class="comment-copy">@PM2Ring your answer is well detailed, I like it and upvoted :) very nice explanation.</span>
<span class="comment-copy">Ditto. :)  I didn't want to get too technical in case the OP didn't know much about binary; besides, I was racing against the clock...</span>
