<div class="post-text" itemprop="text">
<p>For part of log parser I need to filter occurrences of baud rate in the log.  </p>
<p>First I get all occurrences using <code>re.findall</code>, then I'm trying to remove duplicates in subsequences in its result. Results are like <code>[10000,10000,10000,10000,0,0,0,10000,10000]</code>, the list can contain several hundreds of values. So the first baud rate was <code>10000</code>, then <code>0</code>, then again <code>10000</code>.
I need to see how the baud rate changed, so I can't use <code>set</code>, as it will lose information of baud rate switching points.  </p>
<p>So, once again input: <code>[10000,10000,10000,10000,0,0,0,10000,10000]</code></p>
<p>Desired output: <code>[10000,0,10000]</code></p>
<p>What I have made already:  </p>
<pre><code>m = [10000,10000,10000,10000,0,0,0,10000,10000] 
n = []
for i,v in enumerate(m):
    if i == 0:
        n.append(v)
        n_index = 0
    else:
        if v != n[n_index]:
            n.append(v)
            n_index = n_index + 1
</code></pre>
<p>it works, but it doesn't seem pythonic enough to me. Please advise: is there some more efficient way possible, or do I even not need to invent the wheel again?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a>:</p>
<pre><code>&gt;&gt;&gt; rates = [10000,10000,10000,10000,0,0,0,10000,10000]
&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; [e for e, g in groupby(rates)]
[10000, 0, 10000]
</code></pre>
<p>Explanation: If no <code>key</code> function is given, then the elements are just grouped by identity, i.e. groups of consecutive equal elements are collapsed. The result is an iterator of key-elements and the groups (in this case, just repetitions of the key element). We need just the keys.</p>
<p>Update: Using IPython's <code>%timeit</code> magic command and a list of 100,000 random baud rates, <code>itertools.groupby</code> seems to be about as fast as the "compare to previous element loop" solutions, and a good deal shorter.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>m = [10000,10000,10000,10000,0,0,0,10000,10000] 
n = []

n.append(m[0])
for i in m[1:]:
    if n[-1] != i:
        n.append(i)
print n
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>Iterate list <code>m</code> by normal method or by enumerate.</li>
<li>Check last element of list <code>n</code> is equal to current element of list <code>m</code>.</li>
<li>If not equal then append current element of list <code>m</code> to list 'n`.</li>
<li>Used try and expect because first time list <code>n</code> is empty </li>
</ol>
<p>code :</p>
<pre><code>m = [10000,10000,10000,10000,0,0,0,10000,10000] 
n = []
for v in m:
    try:
        if n[-1] != v:
            n.append(v)
    except IndexError:
        n.append(v)

print "Result:-", n 
</code></pre>
<p>Output:</p>
<pre><code>$ python test.py 
Result:- [10000, 0, 10000]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had to do the same thing, except I needed to save the position of each element. I am a physicist, so this code is probably crap, but it works. One can remove the aesthetic things like "print" and "press any key to continue..." as those were for debugging. Probably will adapt one of the answers on this thread.</p>
<pre><code>xvalues=[]
M=[1,1,1,1,1,1,2,3,3,3,3,3,4,4,5,5,5,5,5,6,6,6,7,7,7,7,7,8,9,9]
print len(M)
i=0
while i &lt; len(M):
    print "i " + str(i)
    j=i+1
    while j &lt; len(M) and j &gt; i:
        print "j " + str(j)
        if j == len(M)-1: #kills the while loop
            xvalues.append(i) #append the last element index
            print xvalues
            print range(i+1,len(M))
            a=raw_input("Press any key to continue...")
            i=len(M) #the loop killer
            break
        if M[i]!=M[j]:
            xvalues.append(i) #first index in the subsequence of duplicates
            print xvalues
            print range(i+1,len(M))
            a=raw_input("Press any key to continue...")
            i=j #skip to the next subsequence
            break
        if M[i]==M[j]:
            j+=1
            continue

Mnew=[M[i] for i in xvalues]
print xvalues
print Mnew
</code></pre>
<p>Final output. Position in array, then the value of that element.</p>
<pre><code>[0, 6, 7, 12, 14, 19, 22, 27, 28]
[1, 2, 3,  4,  5,  6,  7,  8,  9]
</code></pre>
</div>
<span class="comment-copy">This is not a duplicate, please read description carefully</span>
<span class="comment-copy">Natty.Though it took me longer than it should to realise I should be reading the third line as:      <code>[e for (e, g) in groupby(rates)]</code></span>
<span class="comment-copy">Nice......................................</span>
<span class="comment-copy">Is there any chance to convert it to nice (almost) one-liner using list comprehension?</span>
<span class="comment-copy">@AlexC I don't think so, because the check <code>if n[-1] != i</code> is using the list from the previous iteration. If you want a one-liner, use tobias_k's groupby method :)</span>
<span class="comment-copy">@user3468054 You could use <code>reduce</code> to put your algo into a one-liner, but to be honest, I would not do that... <code>reduce(lambda lst, e: lst if lst and lst[-1] == e else lst + [e], rates, [])</code></span>
<span class="comment-copy">@tobias_k Interesting! I've not met <code>reduce</code> to date. But that's definitely one from the one-liners-just-because-we-can department :-)</span>
