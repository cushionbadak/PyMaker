<div class="post-text" itemprop="text">
<p>I am using PySide version 1.2.2, which wraps the Qt v4.8 framework. I am in a situation where I have to choose between having my application wait for a <code>QThread</code> that I no longer need to exit normally (it is quite possible that the thread will block indefinitely), and giving the unresponsive thread a grace period (of several seconds), then calling <code>QThread.terminate()</code> on it. Though I wish I could, I cannot let the <code>QThread</code> object go out of scope while the underlying thread is still running, since this will throw the error "QThread: Destroyed while thread is still running" and almost surely cause a segfault.</p>
<p>Please note that I am aware that <a href="http://srinikom.github.io/pyside-docs/PySide/QtCore/QThread.html#PySide.QtCore.PySide.QtCore.QThread.terminate" rel="nofollow">terminating <code>QThread</code>s is dangerous and highly discouraged</a>. I am just trying to explore my options here.</p>
<p>When I try to terminate a thread however, my application crashes with the following error:</p>
<blockquote>
<p>Fatal Python error: This thread state must be current when releasing</p>
</blockquote>
<p>You can try this out yourself by copy/pasting and running the following code:</p>
<pre><code>from PySide import QtCore, QtGui

class Looper(QtCore.QThread):
    """QThread that prints natural numbers, one by one to stdout."""
    def __init__(self, *args, **kwargs):
        super(Looper, self).__init__(*args, **kwargs)
        self.setTerminationEnabled(True)

    def run(self):
        i = 0
        while True:
            self.msleep(100)
            print(i)
            i += 1

# Initialize and start a looper.                                                                      
looper = Looper()
looper.start()

# Sleep main thread for 5 seconds.                                                                    
QtCore.QThread.sleep(5)

# Terminate looper.                                                                                   
looper.terminate()

# After calling terminate(), we should call looper.wait() or listen
# for the QThread.terminated signal, but that is irrelevant for
# the purpose of this example.

app = QtGui.QApplication([])
app.exec_()
</code></pre>
<p><strong>How do you properly terminate QThreads in Python?</strong></p>
<p>I reckon that the error I am getting has got something to do with releasing of the Global Interpreter Lock, but I am not sure exactly what is going wrong, and how to fix it.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems that the error may be specific to PySide: running your example with PyQt4 does not produce any errors at all.</p>
<p>As for the general issue of how to terminate a <code>QThread</code> safely: it entirely depends on how much control you have over the work that is being done in the thread. If it is effectively a loop where you can periodically check a flag, then the solution is simple:</p>
<pre><code>class Looper(QtCore.QThread):
    ...         

    def interrupt(self):
        self._active = False

    def run(self):
        i = 0
        self._active = True
        while self._active:
            self.msleep(100)
            print(i)
            i += 1

app = QtGui.QApplication([])

looper = Looper()
looper.finished.connect(app.quit)
looper.start()

QtCore.QTimer.singleShot(3000, looper.interrupt)

app.exec_()
</code></pre>
<p>The thread will finish cleanly once the <code>run</code> method returns, so you must find some mechanism to allow that happen. If you can't do that (perhaps because the work being done in the thread is largely outside of your control), you should probably consider switching to a <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="nofollow">multiprocessing</a> approach instead.</p>
</div>
<span class="comment-copy">I am already using flags as you suggested. The operation that is taking too long is a library function call that I have little control over. I am saving the multi-processing option as a last resort. For now, I would like to understand why I cannot terminate() my QThreads.</span>
<span class="comment-copy">It is interesting though that this runs fine on PyQt</span>
<span class="comment-copy">@nullstellensatz. Even though your toy example seems to work in PyQt, I don't think many people would recommend using <code>terminate</code> in any serious code. So surely it's <code>terminate</code> that should be your last resort, rather than something like <code>multiprocessing</code>?</span>
<span class="comment-copy">I completely agree. It just happens that for what I am working on, terminating() threads is an acceptable stopgap. Other solutions, like replacing the offending library (or writing my own), or the multiprocessing alternative you have suggested are likely to be more involved, given the code that we already have. I plan on coming back later and implementing a cleaner/more predictable solution.</span>
