<div class="post-text" itemprop="text">
<p>I have a bunch of strings that are of the form:</p>
<pre><code>'foo.bar.baz.spam.spam.spam...etc'
</code></pre>
<p>In all likelihood they have three or more multi-letter substrings separated by <code>.</code>'s. There might be ill formed strings with less than two <code>.</code>'s, and I want the original string in that case.</p>
<p>The first thing that comes to mind is the str.partition method, which I would use if I were after everything after the first <code>.</code>:</p>
<pre><code>'foo.bar.baz.boink.a.b.c'.partition('.')[2]
</code></pre>
<p>returns </p>
<pre><code>'bar.baz.boink.a.b.c'
</code></pre>
<p>This could be repeated:</p>
<pre><code>def secondpartition(s):
    return s.partition('.')[2].partition('.')[2] or s
</code></pre>
<p>But is this efficient? It doesn't seem efficient to call a method twice and use a subscript twice. It is certainly inelegant. Is there a better way? </p>
<p>The main question is:</p>
<blockquote>
<p>How do you drop everything from the beginning up to the second instance of the <code>.</code> character, so that <code>'foo.bar.baz.spam.spam.spam'</code> becomes <code>'baz.spam.spam.spam'</code>? What would be the best/most efficient way to do that?</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow"><code>str.split</code></a> with <code>maxsplit</code> argument:</p>
<pre><code>&gt;&gt;&gt; 'foo.bar.baz.spam.spam.spam'.split('.', 2)[-1]
'baz.spam.spam.spam'
</code></pre>
<p><strong>UPDATE</strong></p>
<p>To handle string with less than two <code>.</code>s:</p>
<pre><code>def secondpartition(s):
    parts = s.split('.', 2)
    if len(parts) &lt;= 2:
        return s
    return parts[-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Summary:</strong> This is the most performant approach (generalized to n characters):</p>
<pre><code>def maxsplittwoexcept(s, n, c):
    '''
    given string s, return the string after the nth character c
    if less than n c's, return the whole string s.
    '''
    try:
        return s.split(c, 2)[2]
    except IndexError:
        return s
</code></pre>
<p>but I show other approaches for comparison.</p>
<p>There are various ways of doing this with string methods and regular expressions. I'll ensure you can follow along with an interpreter by being able to cut and paste everything in order.</p>
<p>First imports:</p>
<pre><code>import re
import timeit
from itertools import islice
</code></pre>
<p><strong>Different approaches: string methods</strong></p>
<p>The way mentioned in the question is to partition twice, but I discounted it because it seems rather inelegant and unnecessarily repetitive:</p>
<pre><code>def secondpartition(s):
    return s.partition('.')[2].partition('.')[2] or s
</code></pre>
<p>The second way that came to mind to do this is to split on the <code>.</code>'s, slice from the second on, and join with <code>.</code>'s. This struck me as fairly elegant and I assumed it would be rather efficient.</p>
<pre><code>def splitslicejoin(s):
    return '.'.join(s.split('.')[2:]) or s
</code></pre>
<p>But slices create an unnecessary extra list. However, <code>islice</code> from the itertools module provides an iterable that doesn't! So I expected this to do even better:</p>
<pre><code>def splitislicejoin(s):
    return '.'.join(islice(s.split('.'), 2, None)) or s
</code></pre>
<p><strong>Different approaches: regular expressions</strong></p>
<p>Now regular expressions. First way that came to mind with regular expressions was to find and substitute with an empty string up to the second <code>.</code>.</p>
<pre><code>dot2 = re.compile('.*?\..*?\.')
def redot2(s):
    return dot2.sub('', s)
</code></pre>
<p>But it occurred to me that it might be better to use a non-capturing group, and return a match on the end:</p>
<pre><code>dot2match = re.compile('(?:.*?\..*?\.)(.*)')
def redot2match(s):
    match = dot2match.match(s)
    if match is not None:
        return match.group(1)
    else:
        return s
</code></pre>
<p>Finally, I could use a regular expression search to find the end of the second <code>.</code> and then use that index to slice the string, which would use a lot more code, but might still be fast and memory efficient.</p>
<pre><code>dot = re.compile('\.')
def find2nddot(s):
    for i, found_dot in enumerate(dot.finditer(s)):
        if i == 1:
            return s[found_dot.end():] or s
    return s
</code></pre>
<p><strong>update</strong> Falsetru suggests <code>str.split</code>'s maxsplit argument, which had completely slipped my mind. My thoughts are that it may be the most straightforward approach, but the assignment and extra checking might hurt it.</p>
<pre><code>def maxsplittwo(s):
    parts = s.split('.', 2)
    if len(parts) &lt;= 2:
        return s
    return parts[-1]
</code></pre>
<p>And JonClements suggests using an except referencing <a href="https://stackoverflow.com/a/27989577/541136">https://stackoverflow.com/a/27989577/541136</a> which would look like this:</p>
<pre><code>def maxsplittwoexcept(s):
    try:
        return s.split('.', 2)[2]
    except IndexError:
        return s
</code></pre>
<p>which would be totally appropriate since not having enough <code>.</code>s would be exceptional.</p>
<p><strong>Testing</strong></p>
<p>Now let's test our functions. First, let's assert that they actually work (not a best practice in production code, which should use unittests, but useful for fast validation on StackOverflow):</p>
<pre><code>functions = ('secondpartition', 'redot2match', 'redot2', 
             'splitslicejoin', 'splitislicejoin', 'find2nddot',
             'maxsplittwo', 'maxsplittwoexcept')

for function in functions:
    assert globals()[function]('foo.baz') == 'foo.baz'
    assert globals()[function]('foo.baz.bar') == 'bar'
    assert globals()[function]('foo.baz.bar.boink') == 'bar.boink'
</code></pre>
<p>The asserts don't raise <code>AssertionError</code>s, so now let's time them to see how they perform:</p>
<p><strong>Performance</strong></p>
<pre><code>setup = 'from __main__ import ' + ', '.join(functions)

perfs = {}
for func in functions:
    perfs[func] = min(timeit.repeat(func + '("foo.bar.baz.a.b.c")', setup))

for func in sorted(perfs, key=lambda x: perfs[x]):
    print('{0}: {1}'.format(func, perfs[func]))
</code></pre>
<p><strong>Results</strong></p>
<p><strong>Update</strong> Best performer is falsetru's <code>maxsplittwo</code>, which slightly edges out the secondpartition function. Congratulations to falsetru. It makes sense since it is a very direct approach. And JonClements's modification is even better...</p>
<pre><code>maxsplittwoexcept: 1.01329493523
maxsplittwo: 1.08345508575
secondpartition: 1.1336209774
splitslicejoin: 1.49500417709
redot2match: 2.22423219681
splitislicejoin: 3.4605550766
find2nddot: 3.77172589302
redot2: 4.69134306908
</code></pre>
<p><strong>Older run</strong> and analysis without falsetru's maxsplittwo and JonClements' maxsplittwoexcept:</p>
<pre><code>secondpartition: 0.636116637553
splitslicejoin: 1.05499717616
redot2match: 1.10188927335
redot2: 1.6313087087
find2nddot: 1.65386564664
splitislicejoin: 3.13693511439
</code></pre>
<p>It turns out that the <em>most</em> performant approach is to partition twice, even though my intuition didn't like it.</p>
<p>Also, it turns out my intuition on using islice was wrong in this case, it is much less performant, and so the extra list from the regular slice is probably worth the tradeoff if faced with a similar bit of code.</p>
<p>Of the regular expressions, the match approach for my desired string is the best performer here, nearly tied with <code>splitslicejoin</code>.</p>
</div>
<span class="comment-copy"><code>There might be ill formed strings with less than two .'s, and I want the original string in that case.</code></span>
<span class="comment-copy">@thefourtheye, Thank you for pointing that. I updated the answer accordingly.</span>
<span class="comment-copy">Cool idea, no time to test it now, wonder how it will profile...</span>
<span class="comment-copy">@AaronHall, Could you provide the code (and data) used to measure  time spent for each approach?</span>
<span class="comment-copy">I found you're quite right, see my analysis below. Good job. It edges out my double-partition.</span>
