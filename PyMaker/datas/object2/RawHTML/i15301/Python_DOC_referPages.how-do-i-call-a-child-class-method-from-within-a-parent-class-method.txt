<div class="post-text" itemprop="text">
<p>I know this question might be pointless but there is a reason why I am looking to do it this way. I want to call something exactly opposite to <code>super()</code></p>
<pre><code>    class A(object):
        def use_attack(self, damage, passive, spells):

            #do stuff with passed parameters
            #return something

        def use_spell(self, name , enemy_hp):

            #other code      

            if name == 'Enrage':
                #call child method use_attack right here


    class B(A):
        def use_attack(self):

            #bunch of code here

            return super(B, self).use_attack(damage, passive, spells)

        def use_spell(self, name , enemy_hp):

            return super(B , self).use_attack(name ,enemy_hp)

    b = B()
    b.use_spell('Enrage', 100)
</code></pre>
<p>I have a bunch of code in <code>class B</code>'s <code>use_attack()</code> method that I would not like to replicate in the parent method of <code>use_spell()</code> .</p>
<p>I would like to call the child method <code>use_attack()</code> in the line indicated.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I have a bunch of code in class B's use_attack() method that I would not like to replicate in the parent method of use_spell() .</p>
</blockquote>
<p>Then factor that code out into a method on the parent class. This is exactly what inheritance is for. Children inherit code from parents, not the other way around.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the python docs: "The <strong>mro</strong> attribute of the type lists the method resolution search order used by both getattr() and super()"</p>
<p><a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow">https://docs.python.org/3/library/functions.html#super</a></p>
<p>This should help shed some light on Inheritance and Method Resolution Order (mro).</p>
<pre><code>class Foo(object):
    def __init__(self):
        print('Foo init called')
    def call_child_method(self):
        self.child_method()

class Bar(Foo):
    def __init__(self):
        print('Bar init called')
        super().__init__()
    def child_method(self):
        print('Child method called')

bar = Bar()
bar.call_child_method()
</code></pre>
</div>
<span class="comment-copy">You just made me think of classes on a whole new level. I don't think I understood inheritance until now. Thanks so much for the help!</span>
<span class="comment-copy">Awesome! OOP is really fun when you get those early insights. Glad I could help and here's to many more. :)</span>
