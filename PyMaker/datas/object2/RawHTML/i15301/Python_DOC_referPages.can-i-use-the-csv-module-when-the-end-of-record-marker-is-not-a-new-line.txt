<div class="post-text" itemprop="text">
<p>I want to parse a csv-like file which uses non-ascii delimiters. The csv module lets me set the quote character and the field delimiter. Is it possble to set the end of record delimiter so it can be used with the csv module?</p>
<p>Take a csv-like file where, instead of:</p>
<pre><code>'"', ',', '\n'
</code></pre>
<p>it uses </p>
<pre><code>'¦', '¶', '§'
</code></pre>
<p>for example</p>
<pre><code>data = [
    [1,r'''text "could" be
'tricky'\\'''],
    [2,r'or easy']
]
</code></pre>
<p>would be represented as</p>
<pre><code>'1¶¦text "could" be\n\'tricky\'\\\\¦§2¶¦or easy¦'
</code></pre>
<p>I know how to solve this using split etc. But is there a better way with the csv module?</p>
<p>This expression generates examples:</p>
<pre><code>chr(167).join(
[
        chr(182).join(
            [
                '\xa6{}\xa6'.format(val) if type(val)==str else str(val)
                for val in row
            ]
        ) for row in data
    ])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, you cannot directly use <code>csv.reader()</code> for this, as the <a href="https://docs.python.org/3/library/csv.html#csv.Dialect.lineterminator" rel="nofollow"><code>Dialect.lineterminator</code> parameter</a> is hardcoded:</p>
<blockquote>
<p><strong>Note</strong>: The <code>reader</code> is hard-coded to recognise either <code>'\r'</code> or <code>'\n'</code> as end-of-line, and ignores <code>lineterminator</code>. This behavior may change in the future.</p>
</blockquote>
<p>You'd have to create a wrapper around the reader to translate your line terminators:</p>
<pre><code>class LineTerminatorTranslator(object):
    def __init__(self, orig, terminator, buffer=2048):
        self._orig = orig
        self._terminator = terminator
        self._buffer = buffer

    def __iter__(self):
        terminator = self._terminator
        buffer = ''

        if hasattr(self._orig, 'read'):
            # read in chunks, rather than in lines, where possible
            iterator = iter(lambda: self._orig.read(self._buffer), '')
        else:
            iterator = iter(self._orig)

        while True:
            try:
                while terminator not in buffer:
                    buffer += next(iterator)
            except StopIteration:
                # done, yield remainder
                yield buffer
                return
            entries, _, buffer = buffer.rpartition(terminator)
            for entry in entries.split(terminator):
                yield entry
</code></pre>
<p>This reads the input file in chunks of 2kb (configurable) and splits out the lines by the given line terminator.</p>
<p>Because <code>csv.reader()</code> can handle any iterable, the code can accept other iterables too, but becomes less efficient if such an iterable produces large strings each iteration.</p>
<p>The code should work on both Python 2 and 3.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import csv
&gt;&gt;&gt; import io
&gt;&gt;&gt; sample = '1¶¦text "could" be\'tricky\n\'\\\\¦§2¶¦or easy¦'
&gt;&gt;&gt; input = LineTerminatorTranslator(io.StringIO(sample), '§')
&gt;&gt;&gt; list(csv.reader(input, delimiter='¶', quotechar='¦'))
[['1', 'text "could" be\'tricky\n\'\\\\'], ['2', 'or easy']]
</code></pre>
<p>Slightly contrived Python 2 version:</p>
<pre><code>&gt;&gt;&gt; import csv
&gt;&gt;&gt; from cStringIO import StringIO
&gt;&gt;&gt; sample = '1P|text "could" be\'tricky\n\'\\\\|T2P|or easy|'
&gt;&gt;&gt; input = LineTerminatorTranslator(StringIO(sample), 'T')
&gt;&gt;&gt; list(csv.reader(input, delimiter='P', quotechar='|'))
[['1', 'text "could" be\'tricky\n\'\\\\'], ['2', 'or easy']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't read such files with the <code>csv</code> module.  There is an option called <code>lineterminator</code>, but the <a href="https://docs.python.org/3/library/csv.html#csv.Dialect.lineterminator" rel="nofollow">documentation</a> says:</p>
<blockquote>
<p>The reader is hard-coded to recognise either '\r' or '\n' as end-of-line, and ignores lineterminator. This behavior may change in the future.</p>
</blockquote>
<p>You could apparently use this <code>lineterminator</code> parameter to <em>write</em> such a file, but you wouldn't be able to read it back in using the <code>csv</code> module.</p>
</div>
<span class="comment-copy">Thanks. How would I create such a wrapper? Is it eaier / more elegant than the 'split' solution?</span>
<span class="comment-copy">@MichaelGrazebrook: I added a wrapper, untested for now. Will test next.</span>
<span class="comment-copy">@MichaelGrazebrook: tested the wrapper now under various circumstances; it should handle your input as demonstrated.</span>
<span class="comment-copy">Martijn, an excellent solution. As a theoretical point, is StringIO possibly more efficient than buffer? However since in practice one can set the buffer size to be somewhat more than the record size, I can't see it would make much practical difference.</span>
<span class="comment-copy">@MichaelGrazebrook: I don't think so; using a <code>StringIO</code> object certainly would complicate the code, and the real bottleneck here is the <i>disk I/O</i>, so there isn't all that much to gain.</span>
<span class="comment-copy">Thanks. Bake your own seems best then. Unless there's a way to wrap the file and convert record terminators to '\n' on the fly?</span>
<span class="comment-copy">@MichaelGrazebrook: You could probably do that, but it's probably more trouble than just writing a simple tool to statically convert the entire file to use normal delimiters instead of odd ones.</span>
