<div class="post-text" itemprop="text">
<pre><code>def change(s):
    result=""
    for index,item in enumerate(s):
        if(index%2 !=0): result=result+item
    return(result)
</code></pre>
<p>This function can extract all of the even characters from a string into a new string:</p>
<pre><code>&gt;&gt;&gt; x="hallo world"
&gt;&gt;&gt; change(x)
'al ol'
</code></pre>
<ol>
<li><p>How can I make it into a method on the <code>str</code> class?  When you input  <code>x.change()</code>  in the Python console, I would get the same output as <code>change(x)</code>. <code>x.change()</code> will get <code>'al ol'</code>.   </p></li>
<li><p><code>dir(x)</code> will get <code>'change'</code> in the output such as:</p>
<pre><code>['__add__', '__class__', ...omitted..., 'zfill', 'change'] 
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You can't do this.  Well, at least not directly.  Python does not allow you add custom methods/attributes to the built-in types.  It is simply a law of the language.</p>
<p>You could however make your own string type by <a href="https://docs.python.org/3/tutorial/classes.html#inheritance" rel="nofollow">subclassing</a> (inheriting from) <code>str</code>:</p>
<pre><code>class MyStr(str):
    def change(self): # 's' argument is replaced by 'self'
        result=""
        for index,item in enumerate(self): # Use 'self' here instead of 's'
            if(index%2 !=0): result=result+item
        return(result)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class MyStr(str):
...     def change(self):
...         result=""
...         for index,item in enumerate(self):
...             if(index%2 !=0): result=result+item
...         return(result)
...
&gt;&gt;&gt; x = MyStr("hallo world")
&gt;&gt;&gt; x
'hallo world'
&gt;&gt;&gt; x.change()
'al ol'
&gt;&gt;&gt; 'change' in dir(x)
True
&gt;&gt;&gt;
</code></pre>
<p>The new <code>MyStr</code> class will behave like the normal <code>str</code> class in every way.  In fact, it has all of the functionality found on <code>str</code>:</p>
<pre><code>&gt;&gt;&gt; x = MyStr("hallo world")
&gt;&gt;&gt; x.upper()
'HALLO WORLD'
&gt;&gt;&gt; x.split()
['hallo', 'world']
&gt;&gt;&gt;
</code></pre>
<p>The only difference between the two is that <code>MyStr</code> has an added <code>change</code> method.</p>
</div>
<span class="comment-copy">Not sure but you can create your own module with different name than sting and save it in <code>/usr/lib/python2.7/</code> or the lib directory.</span>
<span class="comment-copy">I'd call them the odd characters from a string, since Python uses 0-based indexing. Also, I realise this is just an example of a custom method, but FWIW you can do what your <code>change()</code> method does with slicing: <code>"hallo world"[1::2] -&gt; 'al ol'</code></span>
<span class="comment-copy">Also, just for clarification any string literal created will never be an instance of <code>MyStr</code>.</span>
<span class="comment-copy">Any string literal created   by str class will   be an instance of str ,never be an instance of MyStr. &gt;&gt;&gt; x1=str("haha1") &gt;&gt;&gt; isinstance(x1,str) True  &gt;&gt;&gt; isinstance(x1,MyStr) False  Any string literal created   by MyStr class will   be  either  an instance of str or an instance of MyStr. &gt;&gt;&gt; x2=MyStr("haha2") &gt;&gt;&gt; isinstance(x2,MyStr) True &gt;&gt;&gt; isinstance(x2,str) True</span>
<span class="comment-copy">@it_is_a_literature - Yes, that is expected because <code>MyStr</code> is a subclass of <code>str</code>.  <code>isinstance</code> takes into account inheritance.  If you need a direct test, you could always do <code>type(x) is MyStr</code>.  Note however that there is rarely a need to do this.</span>
