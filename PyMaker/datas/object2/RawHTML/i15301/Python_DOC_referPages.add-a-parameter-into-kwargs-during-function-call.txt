<div class="post-text" itemprop="text">
<p>Is there a way to add key-value-pair into kwargs during the function call?</p>
<pre><code>def f(**kwargs):
    print(kwargs)

# ...

pre_defined_kwargs = {'a': 1, 'b': 2}

f(**pre_defined_kwargs, c=3)
</code></pre>
<p>Or even change the existing arguments?</p>
<pre><code>f(**pre_defined_kwargs, b=3)  # replaces the earlier b=2
</code></pre>
<p>These two examples don't work, as they raise error</p>
<pre><code>&gt;&gt;&gt; f(**pre_defined_kwargs, c=3)
SyntaxError: invalid syntax
</code></pre>
<p>Pointing at the comma in between the arguments</p>
</div>
<div class="post-text" itemprop="text">
<p>For Python versions &lt; 3.5, you need to place the <code>**kwargs</code> variable keyword argument <em>last</em>:</p>
<pre><code>f(c=3, **pre_defined_kwargs)
</code></pre>
<p>See the <a href="https://docs.python.org/3.4/reference/expressions.html#calls" rel="noreferrer"><em>Calls</em> expression syntax</a>; in all forms of the grammar the <code>"**" expression</code> rule is placed <em>last</em>. In other words, using anything after the <code>**expression</code> syntax is a syntax error.</p>
<p>If you want to update the dictionary with new values, you can use the <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="noreferrer"><code>dict()</code> callable</a>; it can create a copy of your existing dictionary <em>and</em> update keys in that, provided the keys are also valid Python identifiers (start with a letter or underscore, and only contain letters, digits and underscores):</p>
<pre><code>f(c=3, **dict(pre_defined_kwargs, b=42))
</code></pre>
<p>Here <code>b=42</code> sets a <em>new</em> value for the <code>'b'</code> key. This same syntax can be used to add keys too, of course.</p>
<p>You cannot use the same key both in the <code>**expression</code> mapping and explicitly; that'll raise a <code>TypeError</code>. Again, from the documentation already linked:</p>
<blockquote>
<p>If the syntax <code>**expression</code> appears in the function call, <code>expression</code> must evaluate to a mapping, the contents of which are treated as additional keyword arguments. In the case of a keyword appearing in both <code>expression</code> and as an explicit keyword argument, a <code>TypeError</code> exception is raised.</p>
</blockquote>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; def f(**kwargs):
...     print(kwargs)
... 
&gt;&gt;&gt; pre_defined_kwargs = {'a': 1, 'b': 2}
&gt;&gt;&gt; f(c=3, **pre_defined_kwargs)
{'a': 1, 'c': 3, 'b': 2}
&gt;&gt;&gt; dict(pre_defined_kwargs, b=42)
{'a': 1, 'b': 42}
&gt;&gt;&gt; f(c=3, **dict(pre_defined_kwargs, b=42))
{'a': 1, 'c': 3, 'b': 42}
</code></pre>
<p>This restriction has been lifted as of Python 3.5 (thanks to <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">PEP-448 -- <em>Additional Unpacking Generalizations</em></a>; you can now freely mix the order of argument types and use multiple <code>**mapping</code> references in a call (using distinct mappings). Keywords still have to be unique across all arguments applied; you still can't 'override' arguments that appear more than once.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; f(c=3, **pre_defined_kwargs)
{'c': 3, 'a': 1, 'b': 2}
</code></pre>
</div>
<span class="comment-copy">put <code>c=3</code> first? <code>f(c=3,**pre_defined_kw)</code></span>
<span class="comment-copy">why would you replace the b and not just use  <code>**pre_defined_kw</code> or change <code>pre_defined_kwargs</code></span>
<span class="comment-copy">@MarkusMeskanen, try <code>f(**dict(pre_defined_kwargs, b=22))</code>.</span>
