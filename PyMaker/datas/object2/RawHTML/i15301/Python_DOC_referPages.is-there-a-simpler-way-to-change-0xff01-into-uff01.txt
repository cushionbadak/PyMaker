<div class="post-text" itemprop="text">
<p>I want to print all the full-width characters in the Python console.</p>
<pre><code>import re
for i  in list(range(65281,65375)):
    x=hex(i)
    x='\\u'+re.search('.{4}$',x).group()
    x.encode("latin1").decode("unicode-escape")
</code></pre>
<p>I want to make it simpler; the important key is that to change <code>0xff01</code> into <code>\\uff01</code>, here is my way to do the transformation.</p>
<pre><code>x='0xff01'
'\\u'+re.search('.{4}$',x).group()
</code></pre>
<p>Is there a simpler way to do that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code produces single Unicode characters from integers, in a <em>very roundabout way</em>. Use the <a href="https://docs.python.org/3/library/functions.html#chr" rel="noreferrer"><code>chr()</code> function</a> instead:</p>
<pre><code>for i  in range(65281, 65375):
    x = chr(i)
</code></pre>
<p>Note that the <code>list()</code> call is very much redundant and wasteful here too; I removed it.</p>
<p>From the documentation:</p>
<blockquote>
<p>Return the string representing a character whose Unicode code point is the integer <em>i</em>. For example, <code>chr(97)</code> returns the string <code>'a'</code>.</p>
</blockquote>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; [chr(i) for i  in range(65281, 65375)]
['！', '＂', '＃', '＄', '％', '＆', '＇', '（', '）', '＊', '＋', '，', '－', '．', '／', '０', '１', '２', '３', '４', '５', '６', '７', '８', '９', '：', '；', '＜', '＝', '＞', '？', '＠', 'Ａ', 'Ｂ', 'Ｃ', 'Ｄ', 'Ｅ', 'Ｆ', 'Ｇ', 'Ｈ', 'Ｉ', 'Ｊ', 'Ｋ', 'Ｌ', 'Ｍ', 'Ｎ', 'Ｏ', 'Ｐ', 'Ｑ', 'Ｒ', 'Ｓ', 'Ｔ', 'Ｕ', 'Ｖ', 'Ｗ', 'Ｘ', 'Ｙ', 'Ｚ', '［', '＼', '］', '＾', '＿', '｀', 'ａ', 'ｂ', 'ｃ', 'ｄ', 'ｅ', 'ｆ', 'ｇ', 'ｈ', 'ｉ', 'ｊ', 'ｋ', 'ｌ', 'ｍ', 'ｎ', 'ｏ', 'ｐ', 'ｑ', 'ｒ', 'ｓ', 'ｔ', 'ｕ', 'ｖ', 'ｗ', 'ｘ', 'ｙ', 'ｚ', '｛', '｜', '｝', '～']
</code></pre>
<p>If you really wanted to produce <em>escaped</em> <code>\uhhhh</code> sequences (without interpreting them to their actual codepoints), use <a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="noreferrer"><code>str.format()</code></a> to format the integers as 4-digit hex values:</p>
<pre><code>for i in range(65281, 65375):
    x = '\\u{:04x}'.format(i)
</code></pre>
<p>The leading <code>0</code> makes the format zero-padded, <code>4</code> sets the field width to 4 characters, and <code>x</code> produces hexadecimal characters:</p>
<pre><code>&gt;&gt;&gt; ['\\u{:04x}'.format(i) for i  in range(65281, 65375)]
['\\uff01', '\\uff02', '\\uff03', '\\uff04', '\\uff05', '\\uff06', '\\uff07', '\\uff08', '\\uff09', '\\uff0a', '\\uff0b', '\\uff0c', '\\uff0d', '\\uff0e', '\\uff0f', '\\uff10', '\\uff11', '\\uff12', '\\uff13', '\\uff14', '\\uff15', '\\uff16', '\\uff17', '\\uff18', '\\uff19', '\\uff1a', '\\uff1b', '\\uff1c', '\\uff1d', '\\uff1e', '\\uff1f', '\\uff20', '\\uff21', '\\uff22', '\\uff23', '\\uff24', '\\uff25', '\\uff26', '\\uff27', '\\uff28', '\\uff29', '\\uff2a', '\\uff2b', '\\uff2c', '\\uff2d', '\\uff2e', '\\uff2f', '\\uff30', '\\uff31', '\\uff32', '\\uff33', '\\uff34', '\\uff35', '\\uff36', '\\uff37', '\\uff38', '\\uff39', '\\uff3a', '\\uff3b', '\\uff3c', '\\uff3d', '\\uff3e', '\\uff3f', '\\uff40', '\\uff41', '\\uff42', '\\uff43', '\\uff44', '\\uff45', '\\uff46', '\\uff47', '\\uff48', '\\uff49', '\\uff4a', '\\uff4b', '\\uff4c', '\\uff4d', '\\uff4e', '\\uff4f', '\\uff50', '\\uff51', '\\uff52', '\\uff53', '\\uff54', '\\uff55', '\\uff56', '\\uff57', '\\uff58', '\\uff59', '\\uff5a', '\\uff5b', '\\uff5c', '\\uff5d', '\\uff5e']
</code></pre>
</div>
<span class="comment-copy">Just do <code>"\\u{}".format(hex(i)[2:]).encode("latin1").decode("unicode-escape")</code></span>
<span class="comment-copy">Why not just <code>x = chr(i)</code> ?</span>
<span class="comment-copy">@thefourtheye: to format hex, use <code>'\\u{:04x}'.format(i)</code> instead. No need to use <code>hex()</code> there. But encode then decode to unicode-escape is... simply overkill.</span>
