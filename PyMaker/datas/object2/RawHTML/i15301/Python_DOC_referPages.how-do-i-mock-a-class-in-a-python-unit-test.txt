<div class="post-text" itemprop="text">
<p>I have a class:</p>
<pre><code>class A:
    __init__(self):
        self.b = B()

   def is_authorized(self)
      name = self.b.get_name()

      if name == 'admin':
          return True
      else:
          return False
</code></pre>
<p>I'd like to write a unit test to test the <code>is_authorized</code> method. The problem is that it requires an instance of the <code>B</code> class which is very complicated to construct in isolation as it requires network connections and other stuff. How can I mock this class and provide something that just has the <code>get_name</code> method. So that I can create the <code>A</code> class and test the method.</p>
</div>
<div class="post-text" itemprop="text">
<p>By use <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>mock</code></a> library you can patch <code>B</code> class and replace it by a <code>MagicMock()</code> object. <code>mock</code> library was designed exactly to do these kind of works and to break hard dependencies from problematic object or real resources.</p>
<p>In your simple example the complete test will be:</p>
<p><strong>module_a.py</strong></p>
<pre><code>class B():
    def __init__(self):
        print("The awful B class!!!")

    def get_name(self):
        print("The awful B.get_name() method!!!")


class A():
    def __init__(self):
        self.b = B()

    def is_authorized(self):
        name = self.b.get_name()
        if name == 'admin':
            return True
        else:
            return False
</code></pre>
<p><strong>module_a_test.py</strong></p>
<pre><code>import unittest
from unittest.mock import patch
from module_a import A


class MyTestCase(unittest.TestCase):

    # patch B class in a_module by a MagicMock instance
    #Â mock_b_constructor passed to test method
    @patch("module_a.B")
    def test_a(self, mock_b_constructor):
        # B() return value will be the B() instance assigned to a.b property
        mock_b = mock_b_constructor.return_value
        # Now start test:
        a = A()
        # Ok! b is our mock...
        self.assertIs(a.b, mock_b)
        # Not authorized
        self.assertFalse(a.is_authorized())
        mock_b.get_name.return_value = 'admin'
        # Yeah!!! we are admin
        self.assertTrue(a.is_authorized())
        # Sanity check
        mock_b.get_name.return_value = 'guest'
        self.assertFalse(a.is_authorized())
</code></pre>
<p><a href="https://docs.python.org/3/library/unittest.mock.html#the-patchers" rel="nofollow noreferrer">Patch</a> will live just for your test method context. That is a simple and straightforward example of how to use mocks and patches from <code>mock</code> but the real cases can be little more complicated. </p>
</div>
<div class="post-text" itemprop="text">
<p>Create a mock class for B, e.g.:</p>
<pre><code>class MockB(object):
    def get_name(self):
        return 'admin'
</code></pre>
<p>Then, in your test case, wrap A in a class that inits with MockB instead of regular B:</p>
<pre><code>class TestA(A):
    def __init__(self):
        self.b = MockB()
</code></pre>
<p>Though, to be honest, I'm not sure what that proves.</p>
</div>
