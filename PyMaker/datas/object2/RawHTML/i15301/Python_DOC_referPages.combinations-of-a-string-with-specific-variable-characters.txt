<div class="post-text" itemprop="text">
<p>How can I collect the combinations of a string, in which certain characters (but not all) are variable?</p>
<p>In other words, I have an input string and a character map. The character map specifies which characters are variable, and what they could be replaced with. The function then yields all possible combinations. </p>
<p>To put this in context, I'm trying to collect possible variations for an OCR output string that could have been misinterpreted by the OCR engine.</p>
<p>Example input:</p>
<pre><code>"ABCD"
</code></pre>
<p>Example character map:</p>
<pre><code>dict(
    B=("X", "Z"),
    D=("E")
)
</code></pre>
<p>Intended output:</p>
<pre><code>[
    "ABCD",
    "ABCE",
    "AXCD",
    "AXCE",
    "AZCD",
    "AZCE"
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.product"><code>itertools.product</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; s = "ABCD"
&gt;&gt;&gt; d = {"B": ["X", "Z"], "D": ["E"]}
&gt;&gt;&gt; poss = [[c]+d.get(c,[]) for c in s]
&gt;&gt;&gt; poss
[['A'], ['B', 'X', 'Z'], ['C'], ['D', 'E']]
&gt;&gt;&gt; [''.join(p) for p in product(*poss)]
['ABCD', 'ABCE', 'AXCD', 'AXCE', 'AZCD', 'AZCE']
</code></pre>
<p>Note that I made <code>d["D"]</code> a list rather than simply a string for consistency.</p>
</div>
<div class="post-text" itemprop="text">
<p>My own solution was very ugly and non-Pythonic, but here goes:</p>
<pre><code>def fuzzy_search(string, character_map):
    all_variations = []

    for i, character in enumerate(string):
        if character in character_map:
            character_variations = list(character_map[character])
            character_variations.insert(0, character)

            if i == len(string) - 1:
                return [string[:-1] + variation for variation in character_variations]

            for variation in character_variations:
                sub_variations = fuzzy_search(string[i + 1:], character_map)

                for sub_variation in sub_variations:
                    all_variations.append(string[:i] + variation + sub_variation)

            return all_variations

    return all_variations

map = dict(
    B=("X", "Z"),
    D=("E")
)

print fuzzy_search("ABCD", map)
</code></pre>
<p>Outputs:</p>
<pre><code>['ABCD', 'ABCE', 'AXCD', 'AXCE', 'AZCD', 'AZCE']
</code></pre>
<p>I figured there should be way more elegant solutions than a recursive function with multiple loops.</p>
</div>
<span class="comment-copy">What about <code>"AABBCCD0"</code> ?</span>
<span class="comment-copy">That one too -- my bad.</span>
<span class="comment-copy">Can somebody explain why the question is too broad? Are there no functions similar to <code>combinations</code> that would pull this trick off with a few additions?</span>
<span class="comment-copy">@Robbert no there's no pre-made function in the stdlib, but one <b>can</b> be made e.g by recursive backtracking and it's in fact an interesting problem.</span>
<span class="comment-copy">Thanks Alex. I've just revised the question a bit -- will this suffice? My headache agrees it is an interesting problem.</span>
<span class="comment-copy">This is crazy. I certainly did not expect this to be solved in merely two lines (see how I solved it in the first place below).</span>
<span class="comment-copy"><code>product</code> is a very nice approach.</span>
