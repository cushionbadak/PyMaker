<div class="post-text" itemprop="text">
<p>I have a string:</p>
<p><code>'ABCDEFGH'</code></p>
<p>I want to cycle through the string and, one by one, replace each character with one of 4 characters (1,2,3,4):</p>
<pre><code>'ABCDEFGH'
'1BCDEFGH'
'A1CDEFGH'
'AB1DEFGH'
</code></pre>
<p>etc </p>
<pre><code>'2BCDEFGH'
'A2CDEFGH'
'AB2DEFGH'
</code></pre>
<p>etc and so forth. However everytime I try, I end up altering the original string and my output ends up being strings of 1s!</p>
<p><code>'1111111'</code></p>
<p>Example code below:</p>
<pre><code>letters = 'ABCDEFGH'

s = list(letters)
y = 0 
while y &lt; len(s): 
   s[y] = '1'
   y = y + 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rather than change a list you reuse between iterations, produce a new list each time and replace the one character:</p>
<pre><code>for i in range(len(letters)):
    s = list(letters)
    s[i] = '1'
    print(''.join(s))
</code></pre>
<p>You can combine this with a nested loop:</p>
<pre><code>for digit in '1234':
    for i in range(len(letters)):
        s = list(letters)
        s[i] = digit
        print(''.join(s))
</code></pre>
<p>In essence you are creating the product of <code>'1234'</code> and a position from <code>range(len(letters))</code>, so you could use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product()</code></a> to make that a single loop:</p>
<pre><code>from itertools import product

for digit, pos in product('1234', range(len(letters))):
    s = list(letters)
    s[pos] = digit
    print(''.join(s))
</code></pre>
<p>With a little <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate()</code></a> trickery you could make this a one-liner generator expression to produce all combinations:</p>
<pre><code>from itertools import product

all_combos = (
    ''.join([digit if i == pos else c for i, c in enumerate(letters)])
    for digit, pos in product('1234', range(len(letters))))
</code></pre>
<p>This builds a new list on the fly by iteration over <code>letters</code>, swapping out the one character at position <code>pos</code> for the digit.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; letters = 'ABCDEFGH'
&gt;&gt;&gt; all_combos = (
...     ''.join([digit if i == pos else c for i, c in enumerate(letters)])
...     for digit, pos in product('1234', range(len(letters))))
&gt;&gt;&gt; 
&gt;&gt;&gt; next(all_combos)
'1BCDEFGH'
&gt;&gt;&gt; next(all_combos)
'A1CDEFGH'
&gt;&gt;&gt; next(all_combos)
'AB1DEFGH'
&gt;&gt;&gt; next(all_combos)
'ABC1EFGH'
&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; print(list(islice(all_combos, 10)))
['ABCD1FGH', 'ABCDE1GH', 'ABCDEF1H', 'ABCDEFG1', '2BCDEFGH', 'A2CDEFGH', 'AB2DEFGH', 'ABC2EFGH', 'ABCD2FGH', 'ABCDE2GH']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Reinitialize the list each time.</p>
<pre><code>while y &lt; len(letters):
  s = list(letters)
  s[y] = '1'
  y = y + 1
  dosomethingwith(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>string = 'ABCDEFG'
dig = []

for i in range(1,8):
    dig.append(str(i))
    for letter in string[:]:
        print string.replace(letter,dig[i-1])
</code></pre>
</div>
<span class="comment-copy">Thank you! Although all the answers were wonderful yours was the most in depth.</span>
