<div class="post-text" itemprop="text">
<p>I would like to send some data from jQuery to a Tornado Python backend.</p>
<p>Here is simple example:</p>
<pre class="lang-js prettyprint-override"><code>$.ajax({
    url: '/submit_net',
    dataType: 'json',
    data: JSON.stringify({"test_1":"1","test_2":"2"}),
    type: 'POST',
    success: function(response) {
        console.log(response);
    },
    error: function(error) {
        console.log(error);
    }

});
</code></pre>
<p>Here is the Python code:</p>
<pre><code>class submit_net(tornado.web.RequestHandler):
    def post(self):
        data_json = self.request.arguments
        print data_json
</code></pre>
<p>When I click the <em>submit</em> button then the Python backend retrieves following dictionary</p>
<pre><code>{'{"test_1":"1","test_2":"2"}': ['']}
</code></pre>
<p>but I would like to retrieve exactly the same dictionary as jQuery sends:</p>
<pre><code>{"test_1":"1","test_2":"2"}
</code></pre>
<p>Could you help me what I am doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>request.arguments</code> should only be used for <em>form encoded data</em>. Use <a href="http://tornado.readthedocs.org/en/latest/httputil.html#tornado.httputil.HTTPServerRequest.body" rel="nofollow"><code>request.body</code></a> to access the JSON raw data and decode with the <a href="https://docs.python.org/2/library/json.html" rel="nofollow"><code>json</code> module</a>:</p>
<pre><code>import json

data_json = self.request.body
data = json.loads(data_json)
</code></pre>
<p><code>request.body</code> contains <em>bytes</em>, which is fine in Python 2, but if you are using Python 3 you need to decode those to Unicode first. Get the request character-set with <a href="https://docs.python.org/3/library/cgi.html#cgi.parse_header" rel="nofollow"><code>cgi.parse_header()</code></a>:</p>
<pre><code>from cgi import parse_header

content_type = self.request.headers.get('content-type', '')
content_type, params = parse_header(content_type)
charset = params.get('charset', 'UTF8')
data = json.loads(data_json.decode(charset))
</code></pre>
<p>This defaults to the UTF-8 character set, which as a default is only valid for <em>JSON</em> requests; other request content types would need to be handled differently.</p>
<p>You may want to make it clear that you are sending a JSON body by setting the content type:</p>
<pre class="lang-js prettyprint-override"><code>$.ajax({
    url: '/submit_net',
    contentType: "application/json; charset=utf-8",
    data: JSON.stringify({"test_1":"1","test_2":"2"}),
    type: 'POST',
    success: function(response) {
        console.log(response);
    },
    error: function(error) {
        console.log(error);
    }
});
</code></pre>
<p>and verify in your Tornado POST handler that that content type is being used before trying to decode the POST as JSON:</p>
<pre><code>content_type = self.request.headers.get('content-type', '')
content_type, params = parse_header(content_type)
if content_type.lower() != 'application/json':
    # return a 406 error; not the right content type
    # ...

charset = params.get('charset', 'UTF8')
data = json.loads(data_json.decode(charset))
</code></pre>
<p>The <code>$.ajax</code> <code>dataType</code> parameter is only needed when you are returning JSON from Python  back to jQuery; it tells jQuery to decode the response for you. This is not strictly needed even then, as a <code>application/json</code> response Content-Type header is enough.</p>
</div>
<span class="comment-copy">Have you tried without stringify?</span>
<span class="comment-copy">@Jai: no, then they'd not be sending JSON. This is a problem to be solved on the <i>receiving end</i>.</span>
<span class="comment-copy">What kind of handler would you use for this in tornado?</span>
