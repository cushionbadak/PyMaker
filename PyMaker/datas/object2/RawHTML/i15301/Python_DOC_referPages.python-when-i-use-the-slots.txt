<div class="post-text" itemprop="text">
<p>Recent I study Python,but I have a question about <code>__slots__</code>. In my opinion, it is for limiting parameters in Class, but also limiting the method in Class?</p>
<p>For example:</p>
<pre><code>from types import MethodType

Class Student(object):
  __slots__=('name','age')
</code></pre>
<p>When I run the code:</p>
<pre><code>def set_age(self,age):
  self.age=age
stu=Student()
stu.set_age=MethodType(set_age,stu,Student)
print stu.age

An error has occurred:
stu.set_age=MethodType(set_age,stu,Student)
AttributeError: 'Student' object has no attribute 'set_age'
</code></pre>
<p>I want to know, why not use set_age for this class?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>__slots__</code> means you don't get a <code>__dict__</code> with each class instance, and so each instance is more lightweight. The downside is that you cannot modify the methods and cannot add attributes. And you cannot do what you attempted to do, which is to add methods (which would be adding attributes). </p>
<p>Also, the pythonic approach is not to instantiate a MethodType, but to simply create the function in the class namespace. If you're attempting to add or modify the function on the fly, as in monkey-patching, then you simply assign the function to the class, as in:</p>
<pre><code>Student.set_age = set_age
</code></pre>
<p>Assigning it to the instance, of course, you can't do if it uses <code>__slots__</code>.</p>
<p>Here's the <code>__slots__</code> docs: 
<a href="https://docs.python.org/2/reference/datamodel.html#slots" rel="nofollow">https://docs.python.org/2/reference/datamodel.html#slots</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In new style classes, methods are not instance attributes. Instead, they're class attributes that follow the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow">descriptor protocol</a> by defining a <code>__get__</code> method. The method call <code>obj.some_method(arg)</code> is equivalent to <code>obj.__class__.method.__get__(obj)(arg)</code>, which is in turn, equivalent to <code>obj.__class__.method(obj, arg)</code>. The <code>__get__</code> implementation does the instance binding (sticking <code>obj</code> in as the first argument to <code>method</code> when it is called).</p>
<p>In your example code, you're instead trying to put a hand-bound method as an instance variable of the already-existing instance. This doesn't work because your <code>__slots__</code> declaration prevents you from adding new instance attributes. However, if you wrote to the class instead, you'd have no problem:</p>
<pre><code>class Foo(object):
    __slots__ = () # no instance variables!

def some_method(self, arg):
    print(arg)

Foo.some_method = some_method     # this works!

f = Foo()
f.some_method()                   # so does this
</code></pre>
<p>This code would also work if you created the instance before adding the method to its class.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your attribute indeed doesn't have an attribute <code>set_age</code> since you didn't create a slot for it. What did you expect?</p>
<p>Also, it should be <code>__slots__</code> not <code>__slots</code> (I imagine this is right in your actual code, otherwise you wouldn't be getting the error you're getting).</p>
</div>
<div class="post-text" itemprop="text">
<p>Why aren't you just using:</p>
<pre><code>class Student(object):
    __slots__ = ('name','age')

    def set_age(self,age):
        self.age = age
</code></pre>
<p>where <code>set_age</code> is a method of the <code>Student</code> class rather than adding the function as a method to an instance of the <code>Student</code> class.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of <code>__slots__</code>, I'm using the following method. It allow the use of only a predefined set of parameters:</p>
<pre><code>class A(object):
   def __init__(self):
      self.__dict__['a']=''
      self.__dict__['b']=''

   def __getattr__(self,name):
      d=getattr(self,'__dict__')
      if d.keys().__contains__(name):
         return d.__dict__[attr]
      else:
         raise AttributeError

   def __setattr__(self,name,value):
      d=getattr(self,'__dict__')
      if d.keys().__contains__(name):
         d[name] = value
      else:
         raise AttributeError
</code></pre>
<p>The use of <code>getattr(..)</code> is to avoid recursion.</p>
<p>There are some merits usin <code>__slots__</code> vs <code>__dict__</code> in term of memory and perhaps speed but this is easy to implement and read.</p>
</div>
<span class="comment-copy">This appears to possibly have been answered already: <a href="http://stackoverflow.com/questions/472000/">stackoverflow.com/questions/472000</a></span>
<span class="comment-copy">As @ThorSummoner's link says, <code>__slots__</code> is mainly used to save space when you're creating a whole bunch of items whose attributes are constrained. You <i>shouldn't</i> use it to limit the attributes that a user can set.</span>
<span class="comment-copy">Plus one for an interesting question.</span>
<span class="comment-copy">Chao, welcome to StackOverflow! If I answered your question, you can accept it by clicking the checkmark next to it and it will add plus 2 to your rep. Good luck as you learn Python!</span>
<span class="comment-copy">Sorry,I wrote the wrong word '__slots'.I had corrected it.</span>
<span class="comment-copy">While this is a good point, it's not really an answer. Perhaps you can change the text around the code to make it into one? Otherwise, it should probably be a comment (alas, without the code).</span>
