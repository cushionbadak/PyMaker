<div class="post-text" itemprop="text">
<p>file1.py:</p>
<pre><code>a = 2;

class adder():

    def __init__(self):
        a = a;
        a = a % 5;
        print a;
</code></pre>
<p>Instantiating <code>adder()</code> results in "<code>UnboundLocalError: local variable 'a' referenced before assignment</code>," but if I change init to:</p>
<pre><code>def __init__(self):

     print a;
</code></pre>
<p>then I get no errors.</p>
</div>
<div class="post-text" itemprop="text">
<p>If <code>a = ...</code> (or any other form of assignment, like <code>for a in ...</code>) appears <em>anywhere</em> in the body of a function, then <code>a</code> becomes a local for the <em>entire function</em>.  You can't have a variable be partly global and partly local.</p>
<p>So you have a local named <code>a</code>, and you're trying to assign <code>a = a</code>.  The first thing Python needs to do is figure out the value of that <code>a</code> on the right-hand side...  but <code>a</code> is a local that hasn't been assigned to yet.  Hence the error.</p>
<p>Just use a different variable name.  If you really really want to change the outer <code>a</code> (which smells fishy in a constructor!), you have to declare your intention with <code>global a</code>.</p>
<p>Also, you don't need semicolons at the end of lines in Python.  And if this is Python 2, your class should inherit from <code>object</code> (as in <code>class Adder(object):</code>), else you'll get an "old-style" class which has different behavior and doesn't exist in later versions of Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to use a global statement to pull the module-level global a variable into your scope:</p>
<pre><code>a = 2

class adder():
    def __init__(self):
        global a # need this!
        # a = a # don't need this
        a = a % 5 # assigning to `a` would be otherwise ambiguous without
                  # the global statement
        print a
</code></pre>
<p>You don't need the semicolons.</p>
<p>Better is to use a default argument, something like this, to avoid changing things on the global level.:</p>
<pre><code>a = 2

class adder():
    def __init__(self, a=a):
        # don't need global statement since we're going to default to 
        # the global a.
        # a = a # don't need this
        a = a % 5
        print a
</code></pre>
<p>Another superior approach would be to use different names on the global and local level. I would rename the global variable, and keep the local variable the same. We tend to capitalize (all caps) global constants (and capitalize class names, and inherit from object), so that might look like this:</p>
<pre><code>A = 2

class Adder(object):
    def __init__(self):
        a = A % 5
        print a
</code></pre>
</div>
<span class="comment-copy">Plus one for the fun question.</span>
<span class="comment-copy">This is such a frequent gotcha that it even <a href="https://docs.python.org/2/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" rel="nofollow noreferrer">gets a mention in the official docs</a></span>
<span class="comment-copy">The <code>UnboundLocalError</code> is covered here: <a href="http://stackoverflow.com/questions/9264763/unboundlocalerror-in-python" title="unboundlocalerror in python">stackoverflow.com/questions/9264763/unboundlocalerror-in-python</a> and <a href="https://docs.python.org/3/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" rel="nofollow noreferrer">in the Python FAQ here</a>.</span>
<span class="comment-copy">Welcome to StackOverflow, if I've answered your question, as I've attempted to give you a practical way to move forward, you can accept my answer by selecting the checkmark next to it.</span>
<span class="comment-copy">because <code>print a</code> by itself does not create a local variable, so python knows you mean the global one. When you add the assignment in python thinks you mean the local a, which isn't defined.</span>
