<div class="post-text" itemprop="text">
<p>I'm basing this off of the sample from <a href="https://docs.python.org/3/library/concurrent.futures.html#id1" rel="nofollow">https://docs.python.org/3/library/concurrent.futures.html#id1</a>.  </p>
<p>I've update the following:<br/>
<code>data = future.result()</code><br/>
to this:<br/>
<code>data = future.result(timeout=0.1)</code> </p>
<p>The doc for <code>concurrent.futures.Future.result</code> states:  </p>
<blockquote>
<p>If the call hasnâ€™t completed in timeout seconds, then a TimeoutError will be raised. timeout can be an int or float </p>
</blockquote>
<p><em>(I know there is a timeout on the request, for 60, but in my real code I'm performing a different action that doesn't use a urllib request)</em></p>
<pre><code>import concurrent.futures
import urllib.request

URLS = ['http://www.foxnews.com/',
        'http://www.cnn.com/',
        'http://europe.wsj.com/',
        'http://www.bbc.co.uk/',
        'http://some-made-up-domain.com/']

# Retrieve a single page and report the url and contents
def load_url(url, timeout):
    conn = urllib.request.urlopen(url, timeout=timeout)
    return conn.readall()

# We can use a with statement to ensure threads are cleaned up promptly
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    # Start the load operations and mark each future with its URL
    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}
    for future in concurrent.futures.as_completed(future_to_url):
        url = future_to_url[future]
        try:
            # The below timeout isn't raising the TimeoutError.
            data = future.result(timeout=0.01)
        except Exception as exc:
            print('%r generated an exception: %s' % (url, exc))
        else:
            print('%r page is %d bytes' % (url, len(data)))
</code></pre>
<p><code>TimeoutError</code> is raised if I set it on the call to <code>as_completed</code>, but I need to set the timeout on a per Future basis, not all of them as a whole.</p>
<hr/>
<h2>Update</h2>
<p>Thanks @jme, that works with a single Future, but not with multiples using the below. Do I need to <code>yield</code> at the beginning of the functions to allow the build-up of the <code>futures</code> dict? From the docs it sounds like the calls to <code>submit</code> shouldn't block.  </p>
<pre><code>import concurrent.futures
import time
import sys

def wait():
    time.sleep(5)
    return 42

with concurrent.futures.ThreadPoolExecutor(4) as executor:
    waits = [wait, wait]
    futures = {executor.submit(w): w for w in waits}
    for future in concurrent.futures.as_completed(futures):
        try:
            future.result(timeout=1)
        except concurrent.futures.TimeoutError:
            print("Too long!")
            sys.stdout.flush()

print(future.result())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The exception <em>is</em> being raised in the main thread, you just aren't seeing it because <code>stdout</code> hasn't been flushed. Try for example:</p>
<pre><code>import concurrent.futures
import time
import sys

def wait():
    time.sleep(5)
    return 42

with concurrent.futures.ThreadPoolExecutor(4) as executor:
    future = executor.submit(wait)
    try:
        future.result(timeout=1)
    except concurrent.futures.TimeoutError:
        print("Too long!")
        sys.stdout.flush()

print(future.result())
</code></pre>
<p>Run this and you'll see "Too long!" appear after one second, but the interpreter will wait an additional four seconds for the threads to finish executing. Then you'll see <code>42</code> -- the result of <code>wait()</code> -- appear.</p>
<p>What does this mean? Setting a timeout doesn't kill the thread, and that's actually a good thing. What if the thread is holding a lock? If we kill it abruptly, that lock is never freed. No, it's much better to let the thread handle its own demise. Likewise, the purpose of <code>future.cancel</code> is to prevent a thread from starting, not to kill it.</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue seems to be with the call to <code>concurrent.futures.as_completed()</code>.  </p>
<p>If I replace that with just a <code>for</code> loop, everything seems to work:  </p>
<pre><code>for wait, future in [(w, executor.submit(w)) for w in waits]:
    ...
</code></pre>
<p>I misinterpreted the doc for <code>as_completed</code> which states:  </p>
<blockquote>
<p>...yields futures as they <strong>complete</strong> (finished or were cancelled)...  </p>
</blockquote>
<p><code>as_completed</code> will handle timeouts but as a whole, not on a per future basis.</p>
</div>
