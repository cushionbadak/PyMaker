<div class="post-text" itemprop="text">
<p>I'm working on a python (2.7) program that produce a lot of different matplotlib figure (the data are not random). I'm willing to implement some test (using unittest) to be sure that the generated figures are correct. For instance, I store the expected figure (data or image) in some place, I run my function and compare the result with the reference. Is there a way to do this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>In my <a href="http://stanford.edu/~mwaskom/software/seaborn/">experience</a>, image comparison tests end up bring more trouble than they are worth. This is especially the case if you want to run continuous integration across multiple systems (like TravisCI) that may have slightly different fonts or available drawing backends. It can be a lot of work to keep the tests passing even when the functions work perfectly correctly. Furthermore, testing this way requires keeping images in your git repository, which can quickly lead to repository bloat if you're changing the code often.</p>
<p>A better approach in my opinion is to (1) assume matplotlib is going to actually draw the figure correctly, and (2) run numerical tests against the data returned by the plotting functions. (You can also always find this data inside the <code>Axes</code> object if you know where to look.)</p>
<p>For example, say you want to test a simple function like this:</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
def plot_square(x, y):
    y_squared = np.square(y)
    return plt.plot(x, y_squared)
</code></pre>
<p>Your unit test might then look like</p>
<pre><code>def test_plot_square1():
    x, y = [0, 1, 2], [0, 1, 2]
    line, = plot_square(x, y)
    x_plot, y_plot = line.get_xydata().T
    np.testing.assert_array_equal(y_plot, np.square(y))
</code></pre>
<p>Or, equivalently,</p>
<pre><code>def test_plot_square2():
    f, ax = plt.subplots()
    x, y = [0, 1, 2], [0, 1, 2]
    plot_square(x, y)
    x_plot, y_plot = ax.lines[0].get_xydata().T
    np.testing.assert_array_equal(y_plot, np.square(y))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Matplotlib has a <a href="http://matplotlib.org/devel/testing.html" rel="noreferrer">testing infrastructure</a>. For example:</p>
<pre><code>import numpy as np
import matplotlib
from matplotlib.testing.decorators import image_comparison
import matplotlib.pyplot as plt

@image_comparison(baseline_images=['spines_axes_positions'])
def test_spines_axes_positions():
    # SF bug 2852168
    fig = plt.figure()
    x = np.linspace(0,2*np.pi,100)
    y = 2*np.sin(x)
    ax = fig.add_subplot(1,1,1)
    ax.set_title('centered spines')
    ax.plot(x,y)
    ax.spines['right'].set_position(('axes',0.1))
    ax.yaxis.set_ticks_position('right')
    ax.spines['top'].set_position(('axes',0.25))
    ax.xaxis.set_ticks_position('top')
    ax.spines['left'].set_color('none')
    ax.spines['bottom'].set_color('none')
</code></pre>
<p>From the <a href="http://matplotlib.org/devel/testing.html#writing-an-image-comparison-test" rel="noreferrer">docs</a>:</p>
<blockquote>
<p>The first time this test is run, there will be no baseline image to
  compare against, so the test will fail. Copy the output images (in
  this case result_images/test_category/spines_axes_positions.*) to the
  correct subdirectory of baseline_images tree in the source directory
  (in this case lib/matplotlib/tests/baseline_images/test_category). When rerunning the tests, they should now pass.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">unittest.mock</a> to mock <code>matplotlib.pyplot</code> and check that appropriate calls with appropriate arguments are made to it. Let's say you have a <code>plot_data(data)</code> function inside <code>module.py</code> that you want to test and which looks like this:</p>
<pre><code>import matplotlib.pyplot as plt

def plot_data(x, y, title):
        plt.figure()
        plt.title(title)
        plt.plot(x, y)
        plt.show()
</code></pre>
<p>In order to test this function in your <code>test_module.py</code> file you need to:</p>
<pre><code>import numpy as np

from unittest import mock
import mypyplot as my_module


@mock.patch("%s.my_module.plt" % __name__)
def test_module(mock_plt):
    x = np.arange(0, 5, 0.1)
    y = np.sin(x)
    my_module.plot_data(x, y, "my title")

    assert mock_plt.title.call_args_list[0][0][0] == "my title"
    assert mock_plt.figure.called
</code></pre>
<p>This checks if a <code>title</code> method is called with an argument <code>my title</code> and that the <code>figure</code> method is invoked inside <code>plot_data</code>.</p>
</div>
<span class="comment-copy">With your solution, you need to return the result of plot. Is there a way to do the same thing without having to return it ? By "catching" the fig ? My plot functions "return" void for now, if it's the only way I can change but I'd like not to.</span>
<span class="comment-copy">Look at the second example, it shows how you can introspect the axes object to find all of the data that is used to draw the plot within it.</span>
<span class="comment-copy">@mwaskom Any experience running tests against a mpl.collection you added explicitly? e.g. <code>ax.add_collection(PatchCollection(...))</code>?</span>
<span class="comment-copy">I was using <code>plt.scatter</code> and found my data in <code>ax.collections[0].get_offsets()</code> instead of <code>ax.lines[0].get_xydata()</code>.</span>
<span class="comment-copy">I've tried your way and I got an Error. In matplotlib.testing.decorators there is an "import matplotlib.tests" that produce an ImportError : No module named tests.  I've done some research and indeed there is no tests module in my matplolib files and the documentation say quiet few about it. Does someone knows how to solve it ?</span>
