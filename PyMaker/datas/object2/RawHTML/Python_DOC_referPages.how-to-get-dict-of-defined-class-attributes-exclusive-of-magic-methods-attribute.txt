<div class="post-text" itemprop="text">
<p>Basically, what I am doing is</p>
<pre><code>class A(object):
    a = 1
    b = 2

copy.deepcopy(dict(A.__dict__))
</code></pre>
<p>It gives the error </p>
<blockquote>
<p>TypeError: object.<strong>new</strong>(getset_descriptor) is not safe, use getset_descriptor.<strong>new</strong>()</p>
</blockquote>
<p>If I update code like below one and pop out <strong>__dict__</strong> and <strong>__weakref</strong>__ from class dictionary items</p>
<pre><code>class A(object):
    a = 1
    b = 2

attrs = dict(A.__dict__)
attrs.pop("__weakref__")
attrs.pop("__dict__")
copy.deepcopy(dict(A.__dict__))
# It gives {'__module__': '__main__', 'a': 1, 'b': 2, '__doc__': None}
</code></pre>
<p>It works fine, I understand this is something related to copying <strong>weakref</strong> which will be wrong. </p>
<p>Is there any better way of doing the same where I don't need to specifically pop out <strong>__dict__</strong> and <strong>__weakref</strong>__ and I can get only <strong>attributes</strong> of the Class, exclusive of magic methods/attributes?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not really that simple in Python, since there often isn't any way to know what's "built-in" and what's not. Also, using <code>__dict__</code> isn't sufficient if you want to get inherited attributes; for that, you'd need to use <code>dir</code> instead, which conveniently also handles instances of objects the same as it'd handle classes themselves, and is thus more general purpose.</p>
<p>The simplest general-purpose solution would be to define yourself a simple little function that encapsulates what you want in terms of "attributes". You can then explicitly remove attributes you don't want to keep around (though, notice that if you deep copy such a filtered object, you probably won't have a usable Python object anymore):</p>
<pre><code>In [1]: {k: getattr(A, k) for k in set(dir(A)) - set(dir(object)) - {'__weakref__', '__dict__', '__module__'}}
Out[1]: {'b': 2, 'a': 1}

In [2]: class B(A):
    ...:     c = 10

In [3]: {k: getattr(B, k) for k in set(dir(B)) - set(dir(object)) - {'__weakref__', '__dict__', '__module__'}}
Out[3]: {'b': 2, 'c': 10, 'a': 1}
</code></pre>
</div>
<span class="comment-copy">Those <i>are</i> attributes. Why are you trying to perform a deep copy, anyway?</span>
<span class="comment-copy">It is very slippery what is an "attribute" of the class.</span>
<span class="comment-copy">@wim Attributes are those which are defined by me like in the above example "a" and "b" are the attributes or say class members.</span>
<span class="comment-copy">@user2357112 It's a requirement needed for some other stuff to be done.</span>
<span class="comment-copy">Wow I post the exact same answer but later. Lol.</span>
<span class="comment-copy">@scnerd Thanks, I knew about this way. Is there no direct way of doing so. Let me give you one more thing here If we define class like   class A():     a = 1     b = 2  without object, It doesn't contain  '<b>weakref</b>', '<b>dict</b>'. but then have compatibitlity issues with this Style of Class.</span>
<span class="comment-copy">@NileshSoni By using set subtraction like this, it doesn't matter if those values aren't found, it won't fail. Magic functions may get used in special circumstances, but that doesn't make them special functions (or special objects of any sort), so I don't think you're going to find any introspection within Python that will definitively tell you whether or not the attribute is a "magic function" or not. Just define a list of attributes you won't be interested in, wrap this logic up in a helper function, and use that function when you need attributes.</span>
