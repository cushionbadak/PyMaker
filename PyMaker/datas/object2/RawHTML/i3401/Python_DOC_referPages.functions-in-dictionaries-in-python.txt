<div class="post-text" itemprop="text">
<p>I can store functions in dictionaries by saying</p>
<pre><code>MyDict = {}

def func():
    print("Hello, world!")

MyDict["func"] = func
</code></pre>
<p>I was wondering if there was a cleaner/neater way to write this - something along the lines of</p>
<pre><code>MyDict = {}

def MyDict["func"]():
    print("Hello, world!")
</code></pre>
<p>However this code throws a syntax error</p>
</div>
<div class="post-text" itemprop="text">
<p>You can (ab)use a decorator.</p>
<pre><code>MyDict = {}

def store(d, name):
    def _(f):
        d[name] = f
        return f
    return _

@store(MyDict, "func")
def func():
    print("Hello, world!")

@store(MyDict, "foo")
def some_other_func():
    print("Goodbye")
</code></pre>
<p>You can simplify this if you just want to use the defined name as the key and hard-code the dictionary to update:</p>
<pre><code>def store(f):
    MyDict[f.__name__] = f
    return f

@store
def func():
    print("Hello, world!")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For your example you can do this:</p>
<pre><code>d = {}
d['func'] = lambda: print('Hello, world!')
d['func']()
&gt;&gt;&gt; 'Hello, world!'
</code></pre>
<p>If you want to use a class:</p>
<pre><code>class MyClass:
    def func(self):
        print('Hello, world!')

c = MyClass()
c.func()
&gt;&gt;&gt; 'Hello, world!'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is wrong:</p>
<pre><code>def MyDict["func"]():
    print("Hello, world!")
</code></pre>
<p>because after <code>def</code> you need to use some word that contains only <a href="https://docs.python.org/2/reference/lexical_analysis.html#grammar-token-identifier" rel="nofollow noreferrer">allowed characters</a>. That's why you got Syntax error.</p>
<p>What you can use is:</p>
<p>1) <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow noreferrer">Lambda</a> functions (as suggested by @bphi)</p>
<pre><code>MyDict = {}
MyDict['func'] = lambda: print("123")
MyDict['func']()
</code></pre>
<p>2) Python <a href="https://docs.python.org/3.5/tutorial/classes.html" rel="nofollow noreferrer">class</a> to dynamically create methods (inside the class) which are stored in <code>MyDict</code>, using <a href="https://docs.python.org/3/library/functions.html#setattr" rel="nofollow noreferrer">setattr</a> built-in function:</p>
<pre><code>def func1():
    print(1)


def func2():
    print(2)


MyDict = {}
MyDict['func1'] = func1
MyDict['func2'] = func2

class MyClass3:
    def __init__(self):
        for name, obj in MyDict.items():
            setattr(self, name, obj)

obj = MyClass3()
obj.func1()
obj.func2()
</code></pre>
<p>or via lambda:</p>
<pre><code>MyDict = {}
MyDict['func1'] = lambda : print(1)
MyDict['func2'] = lambda : print(2)

class MyClass3:
    def __init__(self):
        for name, obj in MyDict.items():
            setattr(self, name, obj)

obj = MyClass3()
obj.func1()
obj.func2()
</code></pre>
<p>or</p>
<pre><code>class MyClass3:
    MyDict = {}
    MyDict['func1'] = lambda: print(1)
    MyDict['func2'] = lambda: print(2)

    def __init__(self):
        for name, obj in self.MyDict.items():
            setattr(self, name, obj)

obj = MyClass3()
obj.func1()
obj.func2()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you can express all your functions as one-liners, use <code>lambda</code>s as suggested in  <a href="https://stackoverflow.com/a/51051934/9568847">@bphi's answer</a>.</p>
<p>If you don't want to be rescricted by using the lambda calculus, another way is to use a class and its static methods. Static methods are methods of a class, not an instance of a class, so they don't have access to the inner state of an object and can be called on the class, not an instance.</p>
<p>However, by reading through this answer you might see why this is not a very elegant (or recommended) approach, even though the result is exactly what you asked for.</p>
<pre><code>class MyClass:
    @staticmethod # this decorator is optional here, but suggested for code clarity
    def func():
        print("Hello, world!")

    def func2():
        print("Hey there, I am another function.")

MyClass.func()
&gt;&gt;&gt; 'Hello, world!'
MyClass.func()
&gt;&gt;&gt; 'Hey there, I am another function.'
</code></pre>
<p>If you want to use the syntax of dictionaries as proposed in your question, you can use <code>__dict__</code> on the class:</p>
<pre><code>MyDict = dict(MyClass.__dict__)

MyDict["func"]()
&gt;&gt;&gt; 'Hello, world!'
MyDict["func2"]()
&gt;&gt;&gt; 'Hey there, I am another function.'
</code></pre>
<p>And you can also add other functions to that dictionary:</p>
<pre><code>MyDict["func3"] = lambda: print("Hi, I am yet another function.")

def func4:
    print("And I am the last function for today.")

MyDict["func4"] = func4

MyDict["func"]()
&gt;&gt;&gt; 'Hi, I am yet another function.'
MyDict["func2"]()
&gt;&gt;&gt; 'And I am the last function for today.'
</code></pre>
<p>But as this dictionary is just a representation of the class <code>MyClass</code>, it also contains some items related to that class, like <code>__weakref__</code>. But you can extract your own functions:</p>
<pre><code>MyCleanDict = {}
for key, value in MyDict:
    if not key.startswith("_"):
        MyCleanDict[key] = value
</code></pre>
<p>The result is exactly what you asked for, but I doubt the complexity of the approach is worth the result. I recommend a) using <code>lambda</code>-functions, b) staying at your first approach (define the functions first and then put them in a <code>dict</code>) or c) rethink your actual problem as you may find another solution besides storing functions in a dictionary.</p>
</div>
<span class="comment-copy">Have you considered using a class?</span>
<span class="comment-copy">I have a feeling this isn't really what you want to do overall. Are you defining functions so distinct that there cannot be a common base?</span>
<span class="comment-copy">Never used a class, can someone give an example of how to use it for this case.</span>
<span class="comment-copy">The "cleanest" way of writing this is how your first code block is written, to be honest. However, this screams a design issue to me overall.</span>
<span class="comment-copy">@the_constant For production-level code, this would definitely be a design issue, but to me the question does not look like that. Also answering questions like "how can I make this work?" with something like "believe me, you don't want to know the answer" is not very helpful, I think OP will get to that point by himself after learning more about Python. :)</span>
<span class="comment-copy">I'm inclined to not use classes where there is no shared state between the methods.</span>
<span class="comment-copy">Sure those are fair use cases for a dict of functions. Given the context though, I doubt that is the best solution. Feel free to add your own answer if you disagree with my interpretation of the question.</span>
<span class="comment-copy">The OP is clearly re-inventing classes in the initial request, and has never used them. I think much of the nuance in the last few comments is well beyond the OPs current understanding.</span>
<span class="comment-copy">@MatthewStory I'm failing to interpret "clearly" when there's no mention of state whatsoever, or even a suggestion of needing access control / modification of any kind.</span>
<span class="comment-copy">Classes are suitable for what I'm trying to accomplish, thank you for all the help!</span>
