<div class="post-text" itemprop="text">
<p>I use a specialized python module which modifies some of the Django class methods in the runtime (aka monkey-patching). If I need these 'old' versions is it possible to 'come back' to them overriding monkey patching? </p>
<p>Something like importing the initial version of these classes, for example?</p>
<p>Here is an example of how patching was done in the package:</p>
<pre><code>from django.template.base import FilterExpression

def patch_filter_expression():
    original_resolve = FilterExpression.resolve
    def resolve(self, context, ignore_failures=False):
        return original_resolve(self, context, ignore_failures=False)

    FilterExpression.resolve = resolve
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It depends on what the patch did. Monkeypatching is nothing special, it's just an assignment of a different object to a name. If nothing else references the old value anymore, then it's gone from Python's memory.</p>
<p>But if the code that patched the name has kept a reference to the original object in the form of a different variable, then the original object is still there to be 'restored':</p>
<pre><code>import target.module

_original_function = target.module.target_function

def new_function(*args, **kwargs):
    result = _original_function(*args, **kwargs)
    return result * 5

target.module.target_function = new_function
</code></pre>
<p>Here the name <code>target_function</code> in the <code>target.module</code> module namespace was re-bound to point to <code>new_function</code>, but the original object is still available as <code>_original_function</code> in the namespace of the patching code.</p>
<p>If this is done in a function, then the original could be available as a <em>closure</em> too. For your specific example, you can get the original with:</p>
<pre><code>FilterExpression.resolve.__closure__[0].cell_contents
</code></pre>
<p>or, if you prefer access by name:</p>
<pre><code>def closure_mapping(func):
    closures, names = func.__closure__, func.__code__.co_freevars
    return {n: c.cell_contents for n, c in zip(names, closures)}

original_resolve = closure_mapping(FilterExpression.resolve)['original_resolve']
</code></pre>
<p>Otherwise, you can tell Python to <em>reload</em> the original module with <a href="https://docs.python.org/3/library/importlib.html#importlib.reload" rel="nofollow noreferrer"><code>importlib.reload()</code></a>:</p>
<pre><code>import target.module
importlib.reload(target.module)
</code></pre>
<p>This refreshes the module namespace, 'resetting' all global names to what they'd been set to at import time (any additional names are retained).</p>
<p>Note, however, that any code holding a direct reference to the <em>patched</em> object (such as your class object), would not see the updated objects! That's because <code>from target.module import target_function</code> creates a new reference to the <code>target_function</code> object in the current namespace and no amount of reloading of the original <code>target.module</code> module will update any of the other direct references. You'd have to update those other references manually, or reload their namespaces too.</p>
</div>
<span class="comment-copy">It depends. How are the names patched?</span>
<span class="comment-copy">I added an example</span>
<span class="comment-copy"><code>importlib.import_module</code> isn't going to create a new copy of the module. It'll just retrieve the existing copy, since there is one.</span>
<span class="comment-copy">@user2357112: ugh, yes, indeed. And <code>reload()</code> is easier anyway.</span>
<span class="comment-copy">thanks! .reload() is what I was looking for</span>
