<div class="post-text" itemprop="text">
<pre><code>import _thread
import time

def test1():
    while True:
        time.sleep(1)
        print('TEST1')

def test2():
    while True:
        time.sleep(3)
        print('TEST2')

try:
    _thread.start_new_thread(test1,())
    _thread.start_new_thread(test2,())
except:
    print("ERROR")
</code></pre>
<p>How can I stop the two threads for example in case of KeyboardInterrupts?
Because for "except KeyboardInterrupt" the threads are still running :/</p>
<p>Important:
The question is about closing threads only with the module _thread!
Is it possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no way to directly interact with another thread, except for the main thread. While some platforms do offer thread cancel or kill semantics, Python doesn't expose them, and for good reason.<sup>1</sup></p>
<p>So, the usual solution is to use some kind of signal to tell everyone to exit. One possibility is a <code>done</code> flag with a <code>Lock</code> around it:</p>
<pre><code>done = False
donelock = _thread.allocate_lock()

def test1():
    while True:
        try:
            donelock.acquire()
            if done:
                return
        finally:
            donelock.release()
        time.sleep(1)
        print('TEST1')

_thread.start_new_thread(test1,())
time.sleep(3)
try:
    donelock.acquire()
    done = True
finally:
    donelock.release()
</code></pre>
<hr/>
<p>Of course the same thing is a lot cleaner if you use <code>threading</code> (or a different higher-level API like Qt's threads). Plus, you can use a <code>Condition</code> or <code>Event</code> to make the background threads exit as soon as possible, instead of only after their next <code>sleep</code> finishes.</p>
<pre><code>done = threading.Event()

def test1():
    while True:
        if done.wait(1):
            return
        print('TEST1')

t1 = threading.Thread(target=test1)
t1.start()
time.sleep(3)
done.set()
</code></pre>
<p>The <code>_thread</code> module doesn't have an <code>Event</code> or <code>Condition</code>, of course, but you can always build one yourselfâ€”or just <a href="https://github.com/python/cpython/blob/3.6/Lib/threading.py#L203" rel="nofollow noreferrer">borrowing from the <code>threading</code> source</a>.</p>
<hr/>
<p>Or, if you wanted the threads to be killed asynchronously (which obviously isn't safe if they're, e.g., writing files, but if they're just doing computation or downloads or the like that you don't care about if you're canceling, that's fine), <code>threading</code> makes it even easier:</p>
<pre><code>t1 = threading.Thread(target=test1, daemon=True)
</code></pre>
<hr/>
<p>As a side note, the behavior you're seeing isn't actually reliable across platforms:</p>
<ul>
<li>Background threads created with <code>_thread</code> may keep running, or shut down semi-cleanly, or terminate hard. So, when you use <code>_thread</code> in a portable application, you have to write code that can handle any of the three.</li>
<li><code>KeyboardInterrupt</code> may be delivered to an arbitrary thread rather than the main thread. If it is, it will usually kill that thread, unless you've set up a handler. So, if you're using <code>_thread</code>, you usually want to handle <code>KeyboardInterrupt</code> and call <code>_thread.interrupt_main()</code>.</li>
</ul>
<hr/>
<p>Also, I don't think your <code>except:</code> is doing what you think it is. That <code>try</code> only covers the <code>start_new_thread</code> calls. If the threads start successfully, the main thread exits the <code>try</code> block and reaches the end of the program. If a <code>KeyboardInterrupt</code> or other exception is raised, the <code>except:</code> isn't going to be triggered. (Also, using a bare <code>except:</code> and not even logging which exception got handled is a really bad idea if you want to be able to understand what your code is doing.) Presumably, on your platform, background threads continue running, and the main thread blocks on them (and probably at the OS level, not the Python level, so there's no code you can write that gets involved there).</p>
<p>If you want your main thread to keep running to make sure it can handle a <code>KeyboardInterrupt</code> and so something with it (but see the caveats above!), you have to give it code to keep running:</p>
<pre><code>try:
    while True:
        time.sleep(1&lt;&lt;31)
except KeyboardInterrupt:
    # background-thread-killing code goes here.    
</code></pre>
<hr/>
<p><sub>1. <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread" rel="nofollow noreferrer"><code>TerminateThread</code></a> on Windows makes it impossible to do all the cleanup Python needs to do. <a href="http://pubs.opengroup.org/onlinepubs/000095399/functions/pthread_cancel.html" rel="nofollow noreferrer"><code>pthread_cancel</code></a> on POSIX systems like Linux and macOS makes it possible, but very difficult. And the semantics are different enough between the two that trying to write a cross-platform wrapper would be a nightmare. Not to mention that Python supports systems (mostly older Unixes) that don't have the full <code>pthread</code> API, or even have a completely different threading API.</sub></p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/_thread.html" rel="nofollow noreferrer">docs.python.org/3/library/_thread.html</a></span>
<span class="comment-copy">Is there a reason you want to do this with only `_thread?</span>
<span class="comment-copy">Yes - I will use this on microcontrollers, and I dont want to use a large python-libary</span>
