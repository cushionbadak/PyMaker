<div class="post-text" itemprop="text">
<p>I'm planning to read millions of small files from disk. To minimize i/o, I planned to use a dictionary that maps a file path to its content. I only want the dictionary to retain the last n keys inserted into it, though (so the dictionary will act as a cache).</p>
<p>Is there a data structure in Python that already implements this behavior? I wanted to check before reinventing the wheel.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>collections.deque</code> for this with a maxlen of 6, so that it stores only the last 6 elements and store the information as key value pairs</p>
<pre><code>from collections import deque
d = deque(maxlen=6)
d.extend([(1,1),(2,2),(3,3),(4,4), (5,5), (6,6)])
d
# deque([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)], maxlen=6)
d.extend([(7,7)])
d
# deque([(2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7)], maxlen=6)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For my particular problem, since I needed to read files from disk, I think I'll use the lru cache as @PatrickHaugh suggested. Here's one way to use the cache:</p>
<pre><code>from functools import lru_cache

@lru_cache(maxsize=10)
def read_file(file_path):
  print(' * reading', file_path)
  return file_path # update to return the read file

for i in range(100):
  if i % 2 == 0:
    i = 0 # test that requests for 0 don't require additional i/o
  print(' * value of', i, 'is', read_file(i))
</code></pre>
<p>The output shows that requests for 0 do not incur additional i/o, which is perfect.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> and its method <code>popitem</code> to ensure you keep only the last <em>n</em> keys added to the dictionary. Specifying <code>last=False</code> with <code>popitem</code> ensures the behaviour is "FIFO", i.e. First-In, First-Out. Here's a trivial example:</p>
<pre><code>from collections import OrderedDict

n = 3
d = OrderedDict()

for i in range(5):
    if len(d) == n:
        removed = d.popitem(last=False)
        print(f'Item removed: {removed}')
    d[i] = i+1

print(d)

Item removed: (0, 1)
Item removed: (1, 2)
OrderedDict([(2, 3), (3, 4), (4, 5)])
</code></pre>
</div>
<span class="comment-copy">If you want to close this can you please leave a note saying why?</span>
<span class="comment-copy">Looks a lot like a LRU cache. You might want to dig into the internals of <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a> to see how it's implemented there.</span>
<span class="comment-copy">Wow thanks @PatrickHaugh the lru_cache looks awesome. It may be the solution I'm after. Digging a bit deeper...</span>
<span class="comment-copy">How will <code>deque</code> help with holding mappings like a dictionary? Have I misread the question?</span>
<span class="comment-copy">You can store anything in a deque, just like a list and I am suggesting to store a mapping (key, value pairs) as each element</span>
<span class="comment-copy">Got it, with a cost, i.e. loss of O(1) lookup.</span>
<span class="comment-copy">Thanks @jpp! So <code>last=False</code> will pop from the start of the keys list (ordered by time of insertion)? If so, this is perfect.</span>
<span class="comment-copy">@duhaime, Yes, that's exactly what it does. <code>OrderedDict</code> is ordered by insertion.</span>
