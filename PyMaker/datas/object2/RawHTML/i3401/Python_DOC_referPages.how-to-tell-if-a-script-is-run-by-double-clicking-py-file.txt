<div class="post-text" itemprop="text">
<p>I'm working on a Python 3X program which requires at least one command line argument. </p>
<p>Currently, I'm handling arguments using the argparse library, which handles insufficient arguments by displaying a help text, and killing the program. This works great when the program is run from the command line. </p>
<p>However, if the user clicks on the .py or .pyc file itself, there is no opportunity for the user to read the help text, or enter arguments - the program runs and finishes almost instantly. I'd like to find out when my program is run by double-clicking a file so I can run an interactive UI in that case.</p>
<p>In other words, I'd like to have the arguments fed in interactively if the program is clicked on, but to keep the standard behavior of argparse if the program is run on the command line i.e., have the user specify them all at once e.g. <code>python myprogram.py argument1</code>. </p>
<p>In order to do this, I need to know if the program was run from the command line or by double-clicking a file. I know that python does have a facility somewhat like this for checking if a module is imported or run as a script <code>if __name__ == "__main__":</code>. </p>
<p>Minimal Example:</p>
<pre><code>#test.py
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("inputpath", help="path to plaintext input file")
args = parser.parse_args()
print(args.inputpath)
</code></pre>
<p>Running on the command line gives us nice error handling if a user doesn't enter appropriate arguments:</p>
<pre><code>user@MyPC:path/to/file$ python test.py
usage: test.py [-h] inputpathtest.py: error: the following arguments are 
required: inputpath
</code></pre>
<p>However, trying to doubleclick on the file just runs it and exits immediately. There is no time to enter arguments or read the error message. </p>
<hr/>
<p>Possible solutions: </p>
<p>One way to do this would be an optional "interactive" argument, which if not present, would prompt the user manually. Defaulting to interactivity on would allow the user to enter inputs if the script was run by doubleclick. However, it would still allow the command line user to use the interactivity option to turn this behavior off. The downside is that the user must enter an option to get "normal" behavior (i.e. interactivity turned off). </p>
<p>Another way I'm investigating is that when run by doubleclick, it appears <code>sys.argv = ["pathtofile", '', '', '', '', '', '', '', '']</code>. This should be a unique way to tell if the script is run by doubleclick or from a terminal. </p>
<p>This works at least for me on Windows 10:</p>
<pre><code>if sys.argv[1:]==['']*8:
    print("Running from a doubleclick")
else:
    print("running from a terminal")
</code></pre>
<p>So just insert your commandline and interactive UIs instead of print statements and voila. </p>
<p>I'm keeping this open in case anyone has a more elegant answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the length of <code>sys.argv</code> to get as many arguments as you want after the ones provided from the command line:</p>
<pre><code>import sys
desired_args = 4  # number of arguments you want
arguments = sys.argv[1:] . # [1:] because the first one is your script
for i in range(desired_args-len(arguments)):
    arguments.append(input("Enter another argument: "))
</code></pre>
<p>Or, if you want to let the user input arguments until they enter a blank line, replace the for loop with:</p>
<pre><code>while True:
    arg = input("Enter another argument")
    if arg == '':
        break
    else:
        arguments.append(arg)
</code></pre>
</div>
<span class="comment-copy">Using <code>if...else</code> loop? Did you try that?</span>
<span class="comment-copy">not sure what to put in the condition</span>
<span class="comment-copy">Test if the program is run with arguments. Ask if not.</span>
<span class="comment-copy">Check the length of <a href="https://docs.python.org/3/library/sys.html#sys.argv" rel="nofollow noreferrer"><code>sys.argv</code></a>.</span>
<span class="comment-copy">Then make it press any key to continue...</span>
<span class="comment-copy">Good solutions. However, I think the question was unclear. I'm looking for a way to have the arguments fed in interactively if the program is clicked on, but to keep the standard behavior of argparse if the program is run on the command line. The standard behavior of argparse is, in the case that insufficient arguments are entered to display a help text and prompt again</span>
<span class="comment-copy">@EvanRosica Essentially the same thing happens if you run it from the command line or by clicking on it -- when you click on it, Windows just knows to run <code>yourscript.py</code> with <code>python.exe</code> because it has a <code>.py</code> extension. I recommend creating a script that just prints <code>sys.argv</code>, running it by clicking on it, and running it from the command line, and using that information along with this answer to get your desired functionality.</span>
<span class="comment-copy">Hmm just noticed something very interesting. If I run this program by double clicking it says len(sys.argv)=9, but if I run it from the command line it says len(sys.argv)=1.  Program  follows: <code>import sys print(len(sys.argv)) a=input('keepalive')</code></span>
<span class="comment-copy">running the script via doubleclick gives sys.argv = ["pathtofile", '', '', '', '', '', '', '', '']. I wonder why...</span>
<span class="comment-copy">@EvanRosica that's actually... really neat, didn't expect that. I guess you could just check for the number of arguments that aren't empty strings</span>
