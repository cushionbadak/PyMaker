<div class="post-text" itemprop="text">
<pre><code>import ftplib
import urllib2
import os
import logging
logger = logging.getLogger('ftpuploader')
hdlr = logging.FileHandler('ftplog.log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.setLevel(logging.INFO)
FTPADDR = "some ftp address"

def upload_to_ftp(con, filepath):
    try:
        f = open(filepath,'rb')                # file to send
        con.storbinary('STOR '+ filepath, f)         # Send the file
        f.close()                                # Close file and FTP
        logger.info('File successfully uploaded to '+ FTPADDR)
    except, e:
        logger.error('Failed to upload to ftp: '+ str(e))
</code></pre>
<p>This doesn't seem to work, I get syntax error, what is the proper way of doing this for logging all kind of exceptions to a file</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to define which type of exception you want to catch. So write <code>except Exception, e:</code> instead of <code>except, e:</code> for a general exception (that will be logged anyway).</p>
<p>Other possibility is to write your whole try/except code this way:</p>
<pre><code>try:
    with open(filepath,'rb') as f:
        con.storbinary('STOR '+ filepath, f)
    logger.info('File successfully uploaded to '+ FTPADDR)
except Exception, e:
    logger.error('Failed to upload to ftp: '+ str(e))
</code></pre>
<p>in Python 3.x and modern versions of Python 2.x use <code>except Exception as e</code> instead of <code>except Exception, e</code>:</p>
<pre><code>try:
    with open(filepath,'rb') as f:
        con.storbinary('STOR '+ filepath, f)
    logger.info('File successfully uploaded to '+ FTPADDR)
except Exception as e:
    logger.error('Failed to upload to ftp: '+ str(e))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The syntax is no longer supported in python 3. Use the following instead.</p>
<pre><code>try:
    do_something()
except BaseException as e:
    logger.error('Failed to do something: ' + str(e))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Updating this to something simpler for logger (works for both python 2 and 3). You do not need traceback module.</p>
<pre><code>import logging

logger = logging.Logger('catch_all')

def catchEverythingInLog():
    try:
        ... do something ...
    except Exception as e:
        logger.error(e, exc_info=True)
        ... exception handling ...
</code></pre>
<p>This is now the old way (though still works):</p>
<pre><code>import sys, traceback

def catchEverything():
    try:
        ... some operation(s) ...
    except:
        exc_type, exc_value, exc_traceback = sys.exc_info()
        ... exception handling ...
</code></pre>
<p>exc_value is the error message.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are some cases where you can use the <strong>e.message</strong> or <strong>e.messages</strong>.. But it does not work in all cases. Anyway the more safe is to use the <strong>str(e)</strong> </p>
<pre><code>try:
  ...
except Exception as e:
  print(e.message)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>logger.exception("msg")</code> for logging exception with traceback:</p>
<pre><code>try:
    #your code
except Exception as e:
    logger.exception('Failed: ' + str(e))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After python 3.6, you can use formatted string literal. It's neat! (<a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498" rel="noreferrer">https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498</a>)</p>
<pre><code>try
 ...
except Exception as e:
    logger.error(f"Failed to upload to ftp: {e}")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want error class, error message and stack trace (or either of them), use <strong><code>sys.exec_info()</code></strong>.</p>
<p>Minimal working code with some formatting,</p>
<pre><code>import sys
import traceback

try:
    ans = 1/0
except BaseException as ex:
    # Get current system exception
    ex_type, ex_value, ex_traceback = sys.exc_info()

    # Extract unformatter stack traces as tuples
    trace_back = traceback.extract_tb(ex_traceback)

    # Format stacktrace
    stack_trace = list()

    for trace in trace_back:
        stack_trace.append("File : %s , Line : %d, Func.Name : %s, Message : %s" % (trace[0], trace[1], trace[2], trace[3]))

    print("Exception type : %s " % ex_type.__name__)
    print("Exception message : %s" %ex_value)
    print("Stack trace : %s" %stack_trace)
</code></pre>
<p>Which will give out following output,</p>
<pre><code>Exception type : ZeroDivisionError
Exception message : division by zero
Stack trace : ['File : .\\test.py , Line : 5, Func.Name : &lt;module&gt;, Message : ans = 1/0']
</code></pre>
<p><strong><a href="https://docs.python.org/3.6/library/sys.html#sys.exc_info" rel="noreferrer">sys.exec_info()</a></strong></p>
<p>This gives you the exception details about most recent exception. It return a tuple.  Following are the tuple values <code>(type, value, traceback)</code>.</p>
<p>traceback is an instance of traceback object. You can format the trace with provided methods. More can be found from <a href="https://docs.python.org/3.6/library/traceback.html" rel="noreferrer">traceback documentation</a> </p>
</div>
<div class="post-text" itemprop="text">
<p>You can try specifying the BaseException type explicitly. However, this will only catch derivatives of BaseException. While this includes all implementation-provided exceptions, it is also possibly to raise arbitrary old-style classes.</p>
<pre><code>try:
  do_something()
except BaseException, e:
  logger.error('Failed to do something: ' + str(e))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use str(ex) to print execption</p>
<pre><code>try:
   #your code
except ex:
   print(str(ex))
</code></pre>
</div>
<span class="comment-copy">Your indentation is broken.  And omit the <code>,</code> after <code>except</code>.</span>
<span class="comment-copy">@SvenMarnach, if you omit the <code>,</code> after <code>except</code>, you'll get <code>global name 'e' is not defined</code>, which is not much better than wrong syntax.</span>
<span class="comment-copy">@Val: Should be <code>except Exception as e</code> or <code>except Exception, e</code>, depending on Python version.</span>
<span class="comment-copy">Probably it's somewhere around those 8 answers, but when you open a file, close part should never be inside the try statement, but either in a finally statement or wrapped by a with statement.</span>
<span class="comment-copy">repr(e) gives you the exception(and the message string); str(e) only gives the message string.</span>
<span class="comment-copy">As an alternative for logging exception you could use <code>logger.exception(e)</code> instead. It will log the exception with traceback at the same <code>logging.ERROR</code> level.</span>
<span class="comment-copy">@mbdevpl this doesn't seem to be true. It appears to call str() on the exception: <a href="http://ideone.com/OaCOpO" rel="nofollow noreferrer">ideone.com/OaCOpO</a></span>
<span class="comment-copy"><code>except Exception, e:</code> throws a Syntax error to me in python 3. Is this expected?</span>
<span class="comment-copy">@CharlieParker in Python3 write <code>except Exception as e:</code></span>
<span class="comment-copy">Thank you for having what seems like the only explanation of this for Python 3. Two years later.</span>
<span class="comment-copy">Actually, you should use logger.error('Failed to do something: %s', str(e)) That way, if your logger level is above error it doesn't do the string interpolation.</span>
<span class="comment-copy">@avyfain - You are incorrect. The statement <code>logging.error('foo %s', str(e))</code> will always convert <code>e</code> to a string. To achieve what you are afterm you would use <code>logging.error('foo %s', e)</code> - thereby allowing the logging framework to do (or not do) the conversion.</span>
<span class="comment-copy">You can verify in a python REPL (here with Python 3.5.2 and ipython): <a href="https://gist.github.com/influenza/e28ffc405f6a53f3689d5ce7c70bca91" rel="nofollow noreferrer">see my gist here</a></span>
<span class="comment-copy">Beware that <code>except BaseException</code> and <code>except Exception</code> are not on the same level. <code>except Exception</code> does work in Python3, but it won't catch <code>KeyboardInterrupt</code> for instance (which can be very convenient if you want to be able to interrupt your code!), whereas <code>BaseException</code> catches any exception. See <a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" rel="nofollow noreferrer">this link</a> for the hierarchy of exceptions.</span>
<span class="comment-copy">This would be my preferred method. Just printing the string is useful for logging I suppose, but if I need to do anything with that information I need more than just a string.</span>
<span class="comment-copy">You don't need to 'import traceback' in the second example, right?</span>
<span class="comment-copy">The problem with this is, for example, if you <code>except Exception as e</code>, and <code>e</code> is an <code>IOError</code>, you get <code>e.errno</code>, <code>e.filename</code>, and <code>e.strerror</code>, but apparently no <code>e.message</code> (at least in Python 2.7.12).  If you want to capture the error message, use <code>str(e)</code>, as in the other answers.</span>
<span class="comment-copy">Coincidently, <code>e.msg</code> is the string representation of <code>Exception</code> class.</span>
<span class="comment-copy">Or simply <code>logger.exception(e)</code>.</span>
<span class="comment-copy">Using <code>e.__class__.__name__ </code> can return the exception class as well.</span>
