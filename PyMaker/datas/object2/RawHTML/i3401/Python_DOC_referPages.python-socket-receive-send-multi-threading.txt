<div class="post-text" itemprop="text">
<p>I am writing a Python program where in the main thread I am continuously (in a loop) receiving data through a TCP socket, using the recv function. In a callback function, I am sending data through the same socket, using the sendall function. What triggers the callback is irrelevant. I've set my socket to blocking.</p>
<p>My question is, is this safe to do? My understanding is that a callback function is called on a separate thread (not the main thread). Is the Python socket object thread-safe? From my research, I've been getting conflicting answers.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sockets in Python are not thread safe.</p>
<p>You're trying to solve a few problems at once:</p>
<ol>
<li>Sockets are not thread-safe.</li>
<li>recv is blocking and blocks the main thread.</li>
<li>sendall is being used from a different thread.</li>
</ol>
<p>You may solve these by either using <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a> or solving it the way asyncio solves it internally: By using <code>select.select</code> together with a <code>socketpair</code>, and using a queue for the incoming data.</p>
<pre><code>import select
import socket
import queue

# Any data received by this queue will be sent
send_queue = queue.Queue()

# Any data sent to ssock shows up on rsock
rsock, ssock = socket.socketpair()

main_socket = socket.socket()

# Create the connection with main_socket, fill this up with your code

# Your callback thread
def different_thread():
    # Put the data to send inside the queue
    send_queue.put(data)

    # Trigger the main thread by sending data to ssock which goes to rsock
    ssock.send(b"\x00")

# Run the callback thread

while True:
    # When either main_socket has data or rsock has data, select.select will return
    rlist, _, _ = select.select([main_socket, rsock], [], [])
    for ready_socket in rlist:
        if ready_socket is main_socket:
            data = main_socket.recv(1024)
            # Do stuff with data, fill this up with your code
        else:
            # Ready_socket is rsock
            rsock.recv(1)  # Dump the ready mark
            # Send the data.
            main_socket.sendall(send_queue.get())
</code></pre>
<p>We use multiple constructs in here. You will have to fill up the empty spaces with your code of choice. As for the explanation:</p>
<p>We first create a <code>send_queue</code> which is a queue of data to send. Then, we create a pair of connected sockets (<code>socketpair()</code>). We need this later on in order to wake up the main thread as we don't wish <code>recv()</code> to block and prevent writing to the socket.</p>
<p>Then, we connect the <code>main_socket</code> and start the callback thread. Now here's the magic:</p>
<p>In the main thread, we use <code>select.select</code> to know if the <code>rsock</code> or <code>main_socket</code> has any data. If one of them has data, the main thread wakes up.</p>
<p>Upon adding data to the queue, we wake up the main thread by signaling <code>ssock</code> which wakes up <code>rsock</code> and thus returns from <code>select.select</code>.</p>
<p>In order to fully understand this, you'll have to read <a href="https://docs.python.org/3/library/select.html#select.select" rel="nofollow noreferrer"><code>select.select()</code></a>, <a href="https://docs.python.org/3/library/socket.html#socket.socketpair" rel="nofollow noreferrer"><code>socketpair()</code></a> and <a href="https://docs.python.org/3/library/queue.html#queue.Queue" rel="nofollow noreferrer"><code>queue.Queue()</code></a>.</p>
</div>
<span class="comment-copy">There are a few hidden questions in here that you're trying to solve at once. Hopefully I gave you an elaborate answer, but feel free to ask if you do not understand.</span>
<span class="comment-copy">Consider using asynchronous I/O for your use case, then you won't need threads.</span>
<span class="comment-copy">I am actually using MicroPython, and it seems like MicroPython doesn't support socket.socketpair(). Is there anyway around that? Maybe creating a similar function or just creating two additional sockets? Thanks!</span>
<span class="comment-copy">@Alon <code>socketpair</code> has almost the same action as creating 2 sockets over localhost. You may either create 2 sockets, or set a low <code>select.select</code> timeout and poll. I obviously don't like the polling option as it wastes resources, slower, and if you're already running on MicroPython I guess you have a reason doing it and polling would suck. Go for two additional sockets.</span>
<span class="comment-copy">@Alon Keep in mind that over unix <code>select.select</code> also works with any other file descriptor and no just sockets. You may use a different fd if it helps you in any way but I don't see the advantages doing so (pipes will be a little more efficient  I guess but not worth breaking cross compatibility for that).</span>
<span class="comment-copy">If I need to create two additional sockets (three in total), would it be better to just create two TCP socket connections, and use one for input and one for output? It would require one less socket, and might be easier to code.</span>
