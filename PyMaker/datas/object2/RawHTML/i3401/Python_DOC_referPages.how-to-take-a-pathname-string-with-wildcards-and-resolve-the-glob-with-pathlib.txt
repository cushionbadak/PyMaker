<div class="post-text" itemprop="text">
<p>If I'm given a path as a string, such as "~/pythoncode/*.py" what is the best way to glob it in <code>pathlib</code>?</p>
<p>Using pathlib, there is a way of appending to a path using a glob:</p>
<pre><code>p = pathlib.Path('~/pythoncode/').expanduser().glob('*.py')
</code></pre>
<p>but this, for example, does not work because the user isn't expanded:</p>
<pre><code>p = pathlib.Path().glob('~/pythoncode/*.py')
</code></pre>
<p>and this is generates an exception because I'm providing no arguments to <code>glob()</code>:</p>
<pre><code>p = pathlib.Path('~/pythoncode/*.py').expanduser().glob()
</code></pre>
<p>Is there a way to do this in <code>pathlib</code>, or must I parse the string first?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're starting from the string <code>"~/pythoncode/*.py"</code> and you'd like to expand and glob, you will need to split the path first. Luckily pathlib provides <code>.name</code> and <code>.parent</code> to help <a href="https://docs.python.org/3/library/pathlib.html#correspondence-to-tools-in-the-os-module" rel="nofollow noreferrer">you out</a>:</p>
<pre><code>path = pathlib.Path("~/pythonpath/*.py")
pathlib.Path(path.parent).expanduser().glob(path.name)
</code></pre>
<p>Note this simple solution will only work when only the <code>name</code> includes a glob, it will not work with globs in other parts of the path, like: <code>~/python*/*.py</code>. A more general solution that is slightly more complex:</p>
<pre><code>path = pathlib.Path("~/python*/*.py").expanduser()
parts = path.parts[1:] if path.is_absolute() else path.parts
pathlib.Path(path.root).glob(str(pathlib.Path("").joinpath(*parts)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found that I <em>really</em> wanted the inline expansion.  It wasn't as easy as I thought it'd be.  </p>
<p>Anyhow, here's what I've got.  Only trivialy tested, but let me know where it falls down for you and I'll edit it.</p>
<pre><code>def expand_pathglobs(pathparts, basepaths=None):
    # Logic:
    # 0. Argue with a Path(str).parts and optional ['/start','/dirs'].
    # 1. for each basepath, expand out pathparts[0] into "expandedpaths"
    # 2. If there are no more pathparts, expandedpaths is the result.
    # 3. Otherwise, recurse with expandedpaths and the remaining pathparts.
    # eg: expand_pathglobs('/tmp/a*/b*')
    #   --&gt; /tmp/a1/b1
    #   --&gt; /tmp/a2/b2

    if isinstance(pathparts, str) or isinstance(pathparts, Path):
        pathparts = Path(pathparts).parts

    if basepaths == None:
        return expand_pathglobs(pathparts[1:], [Path(pathparts[0])])
    else:
        assert pathparts[0] != '/'

    expandedpaths = []
    for p in basepaths:
        assert isinstance(p, Path)
        globs = p.glob(pathparts[0])
        for g in globs:
            expandedpaths.append(g)

    if len(pathparts) &gt; 1:
        return expand_pathglobs(pathparts[1:], expandedpaths)

    return expandedpaths
</code></pre>
</div>
<span class="comment-copy">I think your question answers itself, but I could be wrong</span>
<span class="comment-copy">Look into <code>PurePath.parts</code></span>
<span class="comment-copy">I believe <code>os.path.expanduser()</code> is a no-op passthrough if there is nothing to expand, so you might be able to do something like <code>Path().glob(os.path.expanduser('~/pythoncode/*.py'))</code></span>
<span class="comment-copy">@jedwards: <code>NotImplementedError: Non-relative patterns are unsupported</code></span>
<span class="comment-copy">@MadPhysicist: I think it only answers itself if I'm not overlooking something-- which seemed likely with my lack of experience with this library.  <code>pathlib</code> is quite complete, I was hoping that with the right call order it had a way of more closely mimicking the shell and doing a full expansion.</span>
<span class="comment-copy">This seems to work as long as the wildcards are in the <code>name</code> portion of the path as in my example.  In the general case, would it be better using <code>expanduser()</code> and then iterating over <code>parts()</code> as suggested by @MadPhysicist, or <code>parents()</code> then doing a merge?</span>
<span class="comment-copy">@Omegaman good call. Thankfully iterating and merging is not necessary. I've appended a slightly more complicated version to my original solution that solves this generally for relative and absolute paths with globs at many levels.</span>
<span class="comment-copy">The 2nd solution is good, it's just funny that this isn't implemented in <code>pathlib</code> to start with, when I would expect it to be a very common use case of globs... does anyone care to open a feature request?</span>
