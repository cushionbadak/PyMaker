<div class="post-text" itemprop="text">
<p>So, I'm fiddling around with Python's <code>asyncio</code> and I'm creating new futures using <code>loop.create_task(myfunct())</code>. When <code>myfunct()</code> finishes, it returns. Since I created my loop using <code>loop.run_until_complete(..)</code> I'd expect that a thread created by <code>create_task</code> will be destroyed once it's function finished. But when I watch the Python process in <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer" rel="nofollow noreferrer">Process Explorer</a> I see that the threads are never destroyed. </p>
<p>Threads at process start: 7
<a href="https://i.stack.imgur.com/77bTY.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/77bTY.png"/></a></p>
<p>Threads after some work was done (and finished): 25
<a href="https://i.stack.imgur.com/2dDNo.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/2dDNo.png"/></a></p>
<p>What's going wrong here?</p>
<pre><code>import sys
import asyncio


async def async_process_line(line):
    print("STARTED WORKING LINE\t'" + line + "'")
    await asyncio.sleep(3)
    return line


# Optional callback function
def write_stdout(future):
    print("FINISHED WORKING LINE\t'" + future.result() + "'")


async def async_read_stdin(loop):
    while True:
        line = await loop.run_in_executor(None, sys.stdin.readline)
        line = str(line).strip()
        # Exit loop when "exit" is typed in stdin
        if(line == "exit"):
            break
        elif(line != ""):
            task = loop.create_task(async_process_line(line))
            # optional callback binding
            task.add_done_callback(write_stdout)

if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(async_read_stdin(loop))
    except KeyboardInterrupt:
        pass
    finally:
        loop.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You say</p>
<blockquote>
<p>I'd expect that a thread created by <code>create_task</code> will be destroyed once it's function finished</p>
</blockquote>
<p>but <code>create_task</code> doesn't create threads at all. The threads you're seeing have absolutely nothing to do with <code>create_task</code>. Nothing is going wrong here.</p>
<p>Most of the threads you're seeing come from the <code>ThreadPoolExecutor</code> used as the default executor for <code>run_in_executor</code>.</p>
</div>
<span class="comment-copy">I don't see the connection between the behavior you've observed (the process has lots of threads) and the conclusion you've reached (futures are running forever). Why do you think futures are running forever? And why do you think anything is going wrong?</span>
<span class="comment-copy">I believe that is because you <code>run_until_complete</code> a read task. Have you tried to use <code>with</code> for <code>create_task</code>? Like <code>with loop.create_task(...) as task: task.add_done_callback(.....)</code></span>
<span class="comment-copy">@Fanatique this would result in a <code>Task was destroyed but it is pending!</code> error.</span>
<span class="comment-copy">@user2357112 okay maybe a spelling issue here: <b>threads</b> created with <code>run_in_executor</code> run forever (threads created by <code>create_task</code> seem to do the same). When I check them in process explorer I can see that once they're done running they're in <code>Wait:UserRequest</code></span>
<span class="comment-copy">I can confirm that the threads I'm seeing are from run_in_executor but still: shouldn't they be killed they their method returns?</span>
<span class="comment-copy">@masi: No. You're not spawning per-job threads. It's a thread pool.</span>
<span class="comment-copy">I'm not sure I understand the difference. Do you have any links to where this is documented?</span>
<span class="comment-copy">@masi It is a feature of a thread pool to cache a fixed number of created threads, so it doesn't need to spawn a whole new thread for each new <code>submit</code>. The <code>ThreadPoolExecutor</code> used by asyncio when you pass <code>None</code> to <code>run_in_executor</code> is <a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor" rel="nofollow noreferrer">part of the standard library</a>.</span>
<span class="comment-copy">You seem to be correct. In my test I was unable to spawn more then 25 threads. They'll all stay in waiting state but there will be no more then 25. I also noticed that when I provide a explicit <code>Executor</code> to e.g. the <code>run_in_executor()</code> method I can limit the maximum number of threads BUT when those are reached the thing will start acting blocking (while it's acting non-blocking with the default <code>None</code> Executor, for some reason I have not found out yet)</span>
