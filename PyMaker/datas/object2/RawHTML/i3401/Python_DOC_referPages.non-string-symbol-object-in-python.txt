<div class="post-text" itemprop="text">
<p>Does Python have a builtin type for representing symbolic values, when strings cannot be used?</p>
<p>A quick implementation of my own would look like</p>
<pre><code>class Symbol:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return self.name
</code></pre>
<h2>Usecase</h2>
<p>Such symbols are useful when a value – say a keyword argument or a list entry – needs to be initialized to a value that indicates that it hasn't been explicitly set.</p>
<p>If the values have constraints on allowed types, commonly <code>None</code> or some string would be used, but if <em>any</em> value is allowed, some other unique object is needed. My common method is to use an <code>object()</code> assigned to some private variable, but the symbol pattern is more convenient for debugging due to providing a meaningful printed representation.</p>
<p>As an alternative, one could use e.g. a tuple <code>('default value',)</code> and compare against it with the <code>is</code> operator, but this wouldn't work e.g. for dictionary keys.</p>
<p>While the pattern is simple enough to copy/paste into each shell-script I am writing, a builtin solution with established behavior would be preferable.</p>
<h2>Non-builtins</h2>
<p>I know, that there are packages that provide a symbol type. An obvious one would be the symbol type of <code>sympi</code>, and there is <a href="https://pypi.org/project/SymbolType/" rel="nofollow noreferrer">https://pypi.org/project/SymbolType/</a>. However, adding dependencies to avoid a 5-line pattern seems a heavy overkill, hence my question about a <em>builtin</em> type.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the enum library:
<a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">https://docs.python.org/3/library/enum.html</a></p>
</div>
<span class="comment-copy">I think it is logically not possible to introduce a new standard value (say <code>Undef</code>) for that purpose. We would then need to distinguish between "any value except Undef" (formerly known as "any value") and "any value including Undef".</span>
<span class="comment-copy">I don't mean to introduce a new standard value; Rather I want to be able to easily define my own private ones, e.g. <code>_EMPTY=Symbol('_EMPTY')</code> where right now I'd do the less convenient <code>_EMPTY=object()</code>.</span>
<span class="comment-copy">Perhaps <code>collections.UserString("_EMPTY")</code>. Unlike regular strings, <code>UserString('foo')</code> is <code>UserString('foo')</code> evaluates to False.</span>
<span class="comment-copy">@VPfB Seems viable for many usecases, but unlike <code>object()</code> or my simple <code>Symbol</code> implementation it won't work with dictionaries, as they compare by <code>==</code> semantics.</span>
<span class="comment-copy">Would work as a fallback, but it would introduce an unnecessary class and mislead about the semantics. My symbol pattern would indicate "these are private, singleton objects with no specific relation", while (ab)using enum would indicate "these are private, singleton objects, and they are somehow related."</span>
