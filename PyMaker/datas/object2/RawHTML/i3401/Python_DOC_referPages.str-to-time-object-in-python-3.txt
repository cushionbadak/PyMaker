<div class="post-text" itemprop="text">
<p>Given a pair of <code>str</code> objects representing an <a href="https://en.wikipedia.org/wiki/ISO_8601" rel="nofollow noreferrer">ISO 8601</a> time and time zone:</p>
<pre><code>time_str = '09:30'

time_zone_str = 'America/New_York'
</code></pre>
<p><strong>How can these 2 strings be parsed into a <a href="https://docs.python.org/3/library/datetime.html#datetime.time" rel="nofollow noreferrer"><code>time</code></a> (<a href="https://stackoverflow.com/questions/4183793/str-to-time-in-python">not <code>datetime</code></a>) object?</strong></p>
<p>Note: It's obviously possible to split the <code>time_str</code> by <code>':'</code> and use the time constructor but then the parsing would be a little tricky to count the number of elements in the resulting list to know the resolution (minute, second, microsecond) of the str.  This is because <a href="https://en.wikipedia.org/wiki/ISO_8601" rel="nofollow noreferrer">ISO 8601</a> allows for different representations:</p>
<pre><code> time_str_short = '09:30'

 time_str_long = '09:30:00'
</code></pre>
<p>Thank you in advance for your consideration and response.</p>
</div>
<div class="post-text" itemprop="text">
<p>A timezone without a date is meaningless, so no, you can't use <em>both</em> to produce a <code>time</code> object. While the standard library <code>time</code> object <em>does</em> support having a <code>tzinfo</code> attribute, the 'timezone' object is not really a timezone, but merely a time <em>offset</em>.</p>
<p>A timezone is more than just an offset from UTC. Timezone offsets are date-dependent, and because such details as the Daylight Savings winter / summer time distinction is partly the result of political decisions, what dates the timezone offset changes is also dependent on the year. </p>
<p>To be explicit, <code>America/New_York</code> is a timezone, not a time offset. The exact offset from UTC depends on the date; it'll be minus 4 hours in summer, 5 hours in winter!</p>
<p>So for a <em>timezone</em> such as <code>America/New_York</code>, you need to pick a date too. If you don't care about the date, pick a fixed date so your offset is at least <em>consistent</em>. If you are converting a lot of time stamps, store the timezone offset once as a <code>timedelta()</code>, then use that timedelta to shift <code>time()</code> objects to the right offset.</p>
<p>To parse just a timestring, pretend there is a date attached by using the <code>datetime.strptime()</code> method, then extract the time object:</p>
<pre><code>from datetime import datetime

try:
    timeobject = datetime.strptime(time_str, '%H:%M').time()
except ValueError:
    # input includes seconds, perhaps
    timeobject = datetime.strptime(time_str, '%H:%M:%S').time()
</code></pre>
<p>To update the time given a timezone, get a timezone database that supports your timezone string first; the <a href="https://pypi.org/project/pytz/" rel="nofollow noreferrer"><code>pytz</code> library</a> is regularly updated.</p>
<pre><code>from pytz import timezone

timezone = pytz.timezone(time_zone_str)
</code></pre>
<p>How you use it depends on what you are trying to do. If the input time is not in UTC, you can simply attach the timezone to a <code>datetime()</code> object with the <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.combine" rel="nofollow noreferrer"><code>datetime.combine()</code>method</a>, after which you can move it to the UTC timezone:</p>
<pre><code>dt_in_timezone = datetime.combine(datetime.now(), timeobject, timezone)
utc_timeobject = dt_in_timezone.astimezone(pytz.UTC).time()
</code></pre>
<p>This assumes that 'today' is good enough to determine the correct offset.</p>
<p>If your time is a UTC timestamp, combine it with the <code>UTC</code> timezone, then use the pytz timezone; effectively the reverse:</p>
<pre><code>dt_in_utc = datetime.combine(datetime.now(), timeobject, pytz.UTC)
timeobject_in_timezone = dt_in_timezone.astimezone(timezone).time()
</code></pre>
<p>To store just the offset for bulk application, pass in a reference date to the <a href="https://docs.python.org/3/library/datetime.html#datetime.timezone.utcoffset" rel="nofollow noreferrer"><code>timezone.utcoffset()</code> method</a>:</p>
<pre><code>utc_offset = timezone.utcoffset(datetime.now())
</code></pre>
<p>after which you can <em>add</em> this to any <code>datetime</code> object as needed to move from UTC to local time, or <em>subtract</em> it to go from local to UTC. Note that I said <code>datetime</code>, as <code>time</code> objects also don't support <code>timedelta</code> arithmetic; a timedelta can be larger than the number of seconds left in the day or the number of seconds since midnight, after all, so adding or subtracting could shift days as well as the time:</p>
<pre><code># new time after shifting
(datetime.combine(datetime.now(), timeobject) + utc_offset).time()
</code></pre>
<hr/>
<p>For completion sake, you can't pass in a pytz timezone to a <code>time</code> object; it just doesn't have any effect on the time. The timezone object returns <code>None</code> for the UTC offset in that case, because it can't give any meaningful answer without a date:</p>
<pre><code>&gt;&gt;&gt; from datetime import time
&gt;&gt;&gt; from pytz import timezone
&gt;&gt;&gt; tz = timezone('America/New_York')
&gt;&gt;&gt; time_with_zone = time(12, 34, tzinfo=tz)
&gt;&gt;&gt; time_with_zone
datetime.time(12, 34, tzinfo=&lt;DstTzInfo 'America/New_York' LMT-1 day, 19:04:00 STD&gt;)
&gt;&gt;&gt; time_with_zone.utcoffset()
&gt;&gt;&gt; time_with_zone.utcoffset() is None
True
&gt;&gt;&gt; tz.utcoffset(None) is None    # what time_with_zone.utcoffset() does under the hood
None
</code></pre>
<p>So for all intents an purposes, <code>time_with_zone</code> is just another naive time object as the <code>tzinfo</code> object attached doesn't actually have any effect.</p>
<p>Moreover, because there is no date to determine the correct timezone information, pytz selects the earliest known 'New York' timezone, and that's not exactly a recent one; look closely at that <code>tzinfo</code> representation:</p>
<pre><code>tzinfo=&lt;DstTzInfo 'America/New_York' LMT-1 day, 19:04:00 STD&gt;
                                     ^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>That's the timezone introduced in 1883 by the railroads; the 'modern' EST timezone was not introduced until the 20th century. This is why timezone objects are usually passed in a date when determining the offset:</p>
<pre><code>&gt;&gt;&gt; tz.utcoffset(datetime(1883, 6, 28))
datetime.timedelta(-1, 68640)
&gt;&gt;&gt; tz.utcoffset(datetime(1918, 6, 28))
datetime.timedelta(-1, 72000)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answer to "can I do this?" (with a timezone) is both yes and no. Firstly let's convert the string to a <code>time</code> object. As one commenter mentioned, you can do this in python 3.7 with the <a href="https://docs.python.org/3/library/datetime.html#datetime.time.fromisoformat" rel="nofollow noreferrer"><code>fromisoformat</code></a> method:</p>
<pre><code>from datetime import time
time.fromisoformat("09:30")
</code></pre>
<p>If you are not using 3.7, you can do this by creating a <code>datetime</code> and then converting to a time <code>object</code>:</p>
<pre><code>from datetime import datetime, time
as_time = datetime.datetime.strptime("09:00", "%H:%M").time()
</code></pre>
<p>Now to deal with the timezone. As the timezone is a name, we can use the very convenient <a href="http://pytz.sourceforge.net/" rel="nofollow noreferrer">pytz</a> module to convert it to a tzinfo object:</p>
<pre><code>pytz.timezone('America/New_York')
</code></pre>
<p>At this point you're probably tempted to just pass it to the time constructor as the tzinfo argument, but unfortunately that does not work with pytz:</p>
<blockquote>
<p>Unfortunately using the tzinfo argument of the standard datetime constructors ‘’does not work’’ with pytz for many timezones.
  ~ <a href="http://pytz.sourceforge.net/" rel="nofollow noreferrer">http://pytz.sourceforge.net/</a></p>
</blockquote>
<p>So we will have to use the <code>localize</code> method of the newly created tzinfo object. But unfortunately we will still not be able to successfully localize the <code>time</code> object with this timezone. The reason for this is that pytz needs to know the date in order to determine if this timezone is in daylight savings time or not. As we have not provided the date, achieving this is quite impossible and you will get odd results like:</p>
<pre><code>&gt;&gt;&gt; pytz.timezone('America/New_York').localize(as_dt).isoformat()
'1900-01-01T09:00:00-04:56'
</code></pre>
<p>Note the <code>-04:56</code> offset, which is gibberish. There are a few options for getting to what you ultimately want.</p>
<p>One option is to assume the time is a time today:</p>
<pre><code>as_time = datetime.datetime.strptime("09:00", "%H:%M").time()
tz = pytz.timezone('America/New_York')
local_time = tz.localize(datetime.datetime.now().replace(hour=as_time.hour, minute=as_time.minute))
</code></pre>
<p>The other option is to use naive timezone offsets rather than timezone names:</p>
<pre><code>from datetime import timezone, timedelta  
naive_tz = timezone(timedelta(hours=5))
datetime.time(9, 30).replace(tz_info=naive_tz)
</code></pre>
<p>But I would not recommend this method as it's quite brittle and would require some intermediate steps to derive from the TZ location name that are non-trivial.</p>
</div>
<div class="post-text" itemprop="text">
<p>Hope it works for you,</p>
<pre><code>import datetime

# Hello World program in Python

print "Hello World!\n"

time_str = '09:30'

time_zone_str = 'America/New_York'

s = "I am looking for a course in Paris!" 

print(s)

print(datetime.datetime.strptime(time_str, '%H:%M').time())
print(datetime.time(3, 55))
</code></pre>
<p>Thanks</p>
</div>
<span class="comment-copy">I agree that once you convert the object to a time object, you can't tell what the resolution of the original data was, but isn't that true regardless of how you create the time object?</span>
<span class="comment-copy">Python 3.7 has <code>time.fromisoformat</code>…</span>
<span class="comment-copy">@Kevin It is definitely true regardless of how you create, but I was referring to creation itself.  If I split <code>09:30</code> and <code>09:30:00</code> I have 2 lists with different lengths...</span>
<span class="comment-copy">So, the strings could have different formats? Sometimes <code>09:00</code>, or ``09:00:00<code>, or maybe </code>09:00:00.000`?</span>
<span class="comment-copy">That code doesn't actually work @RamonJRomeroyVigil ... per the pytz docs you can't pass a pytz object as tzinfo because it needs to know the date. If you actually print that to STDOUT you'll see a weird offset. That's why I didn't do it this way in my answer below. The pytz docs make it very clear that you need to use either <code>localize</code> or <code>astimezone</code> for this to work.  I know it's very weird and annoying, but time is very complicated.</span>
<span class="comment-copy">Where is <code>time_zone_str</code> being utilized?</span>
<span class="comment-copy">This will have <b>different output depending on the time of year</b>.</span>
