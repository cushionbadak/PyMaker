<div class="post-text" itemprop="text">
<p>This question might be complicated and my brain can't really explain it well so please bare with this crappy explanation, My question, When you trigger a command for example .start it will start let's say a text based game, of course you would have the commands to be able to actually play the game however my concern is people can still trigger the ingame commands without needing to start the game for example .</p>
<pre><code>     if message.content.startswith("/play"):       #Here is the play command where you execute the game to start
         await client.send_message(message.channel, "Welcome to the game!")
     if message.content.startswith("/examine):
         await client.send_message(message.channel, "You examined the rock and well, got a rock!") #In-Game commands/movements
</code></pre>
<p>What i'm saying is, is there a way of only being able to use the in-game commands only when the game itself is activated?
Additional Question: How would you store a user's information like basically saving the game (You don't really need to answer this as i would like to learn this myself but any tips would be great!)</p>
</div>
<div class="post-text" itemprop="text">
<p>First, we want some object that stores the state of a particular session.  We can just call this object <code>Game</code>.  We'll maintain a mapping of <code>discord.User</code>s to <code>Game</code>s.  A <code>User</code> existing in this mapping means that they are playing the game.  Some basics would look something like:</p>
<pre><code>from discord.ext import commands

class Game:
    def __init__(self):
        self.points = 0
        self.inventory = []

bot = commands.Bot('/')

sessions = {}

@bot.command(pass_context=True)
async def play(ctx):
    if ctx.message.author.id in sessions:
        await bot.say("You're already playing")
        return
    sessions[ctx.message.author.id] = Game()
    await bot.say("Welcome to the game!")

@bot.command(pass_context=True)
async def quit(ctx):
    if ctx.message.author.id not in sessions:
        await bot.say("You're not playing the game")
        return
    del sessions[ctx.message.author.id]
    await bot.say("Game Over")

@bot.command(pass_context=True)
async def examine(ctx):
    session = sessions.get(ctx.message.author.id, None)
    if session is None:
        await bot.say("You're not playing the game")
        return
    session.inventory.append("A rock")
    await bot.say("You examined the rock and well, got a rock!")

bot.run("TOKEN")
</code></pre>
<p>Some things you could do to extend this: make use of <code>check</code>s and <code>CommandError</code>s to avoid having to repeat the code for checking sessions; make sure that <code>Game</code>s are <a href="https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled" rel="nofollow noreferrer">pickleable</a>, and write code for saving games using pickle; write a game that's more fun than collecting rocks.  </p>
</div>
<span class="comment-copy">Is the game played on a per-player or per channel level?  You can see one example of how to persist data in a file <a href="https://stackoverflow.com/questions/50890310/how-to-get-discord-py-bot-to-show-different-stats-for-every-player/50901369#50901369">in this question</a></span>
<span class="comment-copy">Its per-player. My concern as said in the question is just you can still trigger the commands outside of the game.</span>
<span class="comment-copy">Hi! Thanks for the answer however i tried your code and my bot doesn't reply to me and also doesn't display any type of error, i've tried customizing just a bit by a bit just the text (lol) i can't seem to find the problem either that or i'm just dumb.   <code>class Game:     def __init__(self):         self.points = 0         self.inventory = []  sessions = {}  @bot.command(pass_context=True) async def test(ctx):     if ctx.message.author.id in sessions:         await bot.say("oof")         return     sessions[ctx.message.author.id] = Game()     await bot.say("oof 2")</code></span>
<span class="comment-copy">@Cupcake Do you have an <code>on_message</code> event?  See: <a href="https://stackoverflow.com/questions/49331096/why-does-on-message-stop-commands-from-working" title="why does on message stop commands from working">stackoverflow.com/questions/49331096/â€¦</a></span>
<span class="comment-copy">Sorry for the late reply but i don't think iam? It maybe because i use @client.event instead of @bot.command?</span>
<span class="comment-copy">Here is my code btw   <code>class Game:     def __init__(self):         self.points = 0         self.inventory = []  sessions = {}  @client.event async def club(ctx):     if ctx.message.author.id in sessions:         await bot.say("Your already in the game!")         return     sessions[ctx.message.author.id] = Game()     await bot.say("Welcome to the game!")</code></span>
<span class="comment-copy">This won't work, for a few reasons. You're referencing both <code>client</code> and <code>bot</code>.  You should have one <code>commands.Bot</code> object that represents your bot.  Everywhere you have <code>client</code> replace it with <code>bot</code>. <code>@bot.event</code> is for registering event handlers. <a href="https://discordpy.readthedocs.io/en/latest/api.html#event-reference" rel="nofollow noreferrer">There is a limited list of events that <code>discord.py</code> handles by default.</a> You instead want to use <code>@bot.command</code> as I have done above to define commands. You can find some basic instruction on how to do so here <a href="https://discordpy.readthedocs.io/en/rewrite/ext/commands/commands.html" rel="nofollow noreferrer">discordpy.readthedocs.io/en/rewrite/ext/commands/commands.html</a></span>
