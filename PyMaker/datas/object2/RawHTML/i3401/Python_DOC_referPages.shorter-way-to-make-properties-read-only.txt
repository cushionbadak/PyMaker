<div class="post-text" itemprop="text">
<p>I read on many sites that if I want to create a read-only property, I should use the <code>property</code> decorator.</p>
<p>Like this:</p>
<pre><code>class MyClass(object):
  def __init__(self):
    self._a = None

  @property
  def a(self):
    return self._a
</code></pre>
<p>I think this is a good solution if I have just 1-3 read-only properties in a class. But what if I have maybe 10 of these? This would result in 40 extra lines of code only to mark all of them as read-only. In my opinion this does not really fit to Python which is meant to be a language where you do not have to write a big bunch of code to do little things.</p>
<p>Is there really no shorter way to make a property read-only in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>At the very least, you could just call <code>property</code> as a function, rather than using it as a decorator. At the same time, you can store the underlying values in a list or dict rather than as separate attributes.</p>
<pre><code>class MyClass(object):
    def __init__(self):
        self._values = [...]

    a = property(lambda self: self._values[0])
    b = property(lambda self: self._values[1])
    # etc
</code></pre>
<p>However, a read-only property doesn't really need to store its value in the instance dict; just hard-code the value directly in the getter:</p>
<pre><code>class MyClass(object):

    a = property(lambda self: "foo")
    b = property(lambda self: "bar") 
</code></pre>
<p>And then wrap the call to property in another function :)</p>
<pre><code>def constant(value):
    def _(self):
        return value
    return property(_)

class MyClass(object):
    a = constant("foo")
    b = constant("bar")
</code></pre>
<hr/>
<p>Here's a pure-Python read-only property, modeled after the example shown at <a href="https://docs.python.org/3/howto/descriptor.html#properties" rel="nofollow noreferrer">https://docs.python.org/3/howto/descriptor.html#properties</a>:</p>
<pre><code>class Constant(object):
    def __init__(self, value)
        def _(self):
            return value
        self.fget = _

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        return self.fget(obj)
</code></pre>
<p>This is probably simpler than subclassing <code>property</code> and overriding <code>__set__</code> and <code>__del__</code> to "unimplement" them. But, I like my idea of a wrapper around a regular property better.</p>
</div>
<span class="comment-copy">Well, having 10 read-only properties in a class is already a bit unusual. Why do you need this?</span>
<span class="comment-copy">A <code>property</code> is just an application of the descriptor protocol. I'm pretty sure you could define your own <code>readonlyproperty</code> class, letting you write <code>a = readonlyproperty("_a")</code>,  <code>b = readonlyproperty("_b");</code>, etc, although I'd have to spend some time remembering how that would work.</span>
<span class="comment-copy">Do you want to make your entire object immutable, or just certain attributes?  You could implement <code>__setattr__</code> so that it ignores attempts to change certain attributes.</span>
<span class="comment-copy">Well it's read-only from outside the class but this does not mean it can be changed  by the class itself ;) But I like your first attempt. Thanks!</span>
