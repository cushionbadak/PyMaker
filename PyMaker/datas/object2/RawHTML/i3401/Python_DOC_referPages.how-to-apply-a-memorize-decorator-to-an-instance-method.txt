<div class="post-text" itemprop="text">
<p>I'd like to use a memorize decorator on a class method. <code>cExample.pri()</code> calls <code>self.text()</code> but <code>memorize</code> doesn't seem to know about <code>self</code>. When <code>memorize</code> calls <code>self.func(*key)</code> it is missing the <code>cExample</code> obj so it complains about missing args.</p>
<p>How can I change this memorize decorator so that it is able to pass the caller's <code>self</code> to the function?</p>
<p>Python3.5.2</p>
<pre><code>class memorize(dict):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args):
        return self[args]

    def __missing__(self, key):
        result = self[key] = self.func(*key)
        return result

class cExample():
    @memorize
    def pri(self, text):
        return self.text(text)

    def text(self, text):
        return text

c = cExample()
print(c.pri('hi'))
</code></pre>
<p>Output:</p>
<pre><code>Traceback (most recent call last):
  File "x.py", line 23, in &lt;module&gt;
    print(c.pri('hi'))
  File "x.py", line 7, in __call__
    return self[args]
  File "x.py", line 11, in __missing__
    result = self[key] = self.func(*key)
TypeError: pri() missing 1 required positional argument: 'text'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to pass <code>self</code> (i.e. <code>c</code>) to <code>cExample.pri</code> (i.e. <code>self.func</code>). But <code>__missing__</code> won't allow you to do this: it receives only the key.</p>
<p>You can rewrite it using function-based decorator:</p>
<pre><code>import functools

def memorize2(f):
    cache = {}
    @functools.wraps(f)
    def wrapper(*args):
        if args not in cache:
            cache[args] = f(*args)
        return cache[args]
    return wrapper

class cExample():
    @memorize2
    def pri(self, text):
        return self.text(text)

    def text(self, text):
        return text

c = cExample()
print(c.pri('hi'))  # hi
</code></pre>
<p>(I'm using <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer">functools.wraps</a> not to lose the original name of decorated method).</p>
<p>In this approach <code>self</code> will be passed to <code>wrapper</code> as positional arg and proxied to <code>cExample.pri</code>.</p>
</div>
<span class="comment-copy">The builtin <code>functools.lru_cache</code> doesn't seem to have this issue so you can consider using it</span>
<span class="comment-copy">It's tricky to access cExample's <code>self</code> from inside <code>memorize</code> because the usual method binding process only works automatically for function objects, and <code>memorize</code> is a dict, not a function. You can implement method binding yourself by overriding memorize's <code>__get__</code>, but IMO doing so is complicated enough that you lose the concision that made your original idea attractive in the first place. May as well just write an ordinary function-based decorator at that point.</span>
<span class="comment-copy">Do you want a single cache that handles all <code>cExample</code> instances, or do you want each instance to have its own cache? And if the former, do you want the caching to ignore <code>self</code>?</span>
