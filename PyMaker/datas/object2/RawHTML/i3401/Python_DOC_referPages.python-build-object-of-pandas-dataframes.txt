<div class="post-text" itemprop="text">
<p>I have a dataframe that has <code>dtype=object</code>, i.e. categorical variables, for which I'd like to have the counts of each level of. I'd like the result to be a pretty summary of all categorical variables. </p>
<p>To achieve the aforementioned goals, I tried the following:</p>
<p>(line 1) grab the names of all object-type variables</p>
<p>(line 2) count the number of observations for each level (<code>a</code>, <code>b</code> of <code>v1</code>)</p>
<p>(line 3) rename the column so it reads "count"</p>
<pre><code>stringCol = list(df.select_dtypes(include=['object'])) # list object of categorical variables
a = df.groupby(stringCol[0]).agg({stringCol[0]: 'count'})
a = a.rename(index=str, columns={stringCol[0]: 'count'}); a
    count
v1  
a   1279
b   2382
</code></pre>
<p>I'm not sure how to elegantly get the following result where all string column counts are printed. Like so (only <code>v1</code> and <code>v4</code> shown, but should be able to print such results for a variable number of columns):</p>
<pre><code>    count       count
v1           v4
a   1279     l  32
b   2382     u  3055
             y  549
</code></pre>
<p>The way I can think of doing it is: </p>
<ol>
<li>select one element of <code>stringCol</code></li>
<li>calculate the count of for each group of the column.</li>
<li>store the result in a Pandas dataframe.</li>
<li>store the Pandas dataframe in an object (list?)</li>
<li>repeat</li>
<li>if last element of <code>stringCol</code> is done, break.</li>
</ol>
<p>but there must be a better way than that, just not sure how to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think simpliest is use loop:</p>
<pre><code>df = pd.DataFrame({'A':list('abaaee'),
                   'B':list('abbccf'),
                   'C':[7,8,9,4,2,3],
                   'D':[1,3,5,7,1,0],
                   'E':[5,3,6,9,2,4],
                   'F':list('aacbbb')})

print (df)
   A  B  C  D  E  F
0  a  a  7  1  5  a
1  b  b  8  3  3  a
2  a  b  9  5  6  c
3  a  c  4  7  9  b
4  e  c  2  1  2  b
5  e  f  3  0  4  b
</code></pre>
<hr/>
<pre><code>stringCol = list(df.select_dtypes(include=['object']))

for c in stringCol:
    a = df[c].value_counts().rename_axis(c).to_frame('count')
    #alternative
    #a = df.groupby(c)[c].count().to_frame('count')
    print (a)

   count
A       
a      3
e      2
b      1
   count
B       
b      2
c      2
a      1
f      1
   count
F       
b      3
a      2
c      1
</code></pre>
<hr/>
<p>For <code>list of DataFrames</code> use <code>list comprehension</code>:</p>
<pre><code>dfs = [df[c].value_counts().rename_axis(c).to_frame('count') for c in stringCol]
print (dfs)

[   count
A       
a      3
e      2
b      1,    count
B       
b      2
c      2
a      1
f      1,    count
F       
b      3
a      2
c      1]
</code></pre>
</div>
<span class="comment-copy">yeah, this is much better. didn't know about those functions and hard to learn about their existence through google w/o knowing relevant key terms. is there a way to make them print side-by-side to avoid having to scroll through the results? relevant bc may have a number of columns on the order of 1x10^n where n&gt;=2</span>
<span class="comment-copy">@user2205916 - Yes, but it is a bit complicated, check <a href="https://stackoverflow.com/a/38801975/2901002">this</a></span>
<span class="comment-copy">great resource, thx</span>
<span class="comment-copy">You can check <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">this</a></span>
<span class="comment-copy">thx, you've been a great help perfecting this. <code>.value_counts(normalize=True)</code> actually produces floats because it gives proportions. i.e. 0.9 values are "true" and 0.1 values are "false"</span>
