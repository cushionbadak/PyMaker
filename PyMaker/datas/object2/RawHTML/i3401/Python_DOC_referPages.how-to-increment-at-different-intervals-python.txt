<div class="post-text" itemprop="text">
<p>Say I had an IP address <code>192.168.1.1</code>
How would I increment at different intervals like this?</p>
<pre><code>192.168.1.2
192.168.1.3
</code></pre>
<p>... and all the way to <code>192.168.1.999</code> then "roll over" to <code>192.168.2.1</code> ?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>for ip3 in range(1, 127):
    for ip4 in range(1, 999):
        ip = '.'.join("192", "68", str(ip3), str(ip4))
</code></pre>
<p>Will that give you the idea?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use the stdlib <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow noreferrer"><code>ipaddress</code></a> for this. Don't attempt to do it with raw string manipulation, because there are several gotchas and weird edge-cases.  Using the object-oriented libraries will protect you from generating invalid data.</p>
<p>To iterate the ipv4 addresses from 192.168.1.0 through to 192.168.1.255, inclusive, is equivalent to iterate the 192.168.1.0/24 <a href="https://en.wikipedia.org/wiki/Subnetwork" rel="nofollow noreferrer">subnet</a>.  Use a <a href="https://docs.python.org/3/library/ipaddress.html#network-objects" rel="nofollow noreferrer">network</a> object:</p>
<pre><code>&gt;&gt;&gt; from ipaddress import ip_network
&gt;&gt;&gt; list(ip_network('192.168.1.0/24'))
[IPv4Address('192.168.1.0'),
 IPv4Address('192.168.1.1'),
 IPv4Address('192.168.1.2'),
...
 IPv4Address('192.168.1.255')]
</code></pre>
<p>Some of these addresses are not usable hosts, for example the 255 is a <a href="https://en.wikipedia.org/wiki/Broadcast_address" rel="nofollow noreferrer">broadcast address</a>.  Iterate the <a href="https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Network.hosts" rel="nofollow noreferrer">hosts</a> instead if that's what you're looking for:</p>
<pre><code>&gt;&gt;&gt;&gt; list(ip_network('192.168.1.0/24').hosts())
[IPv4Address('192.168.1.1'),
 IPv4Address('192.168.1.2'),
 IPv4Address('192.168.1.3'),
...
 IPv4Address('192.168.1.254')]
</code></pre>
<p>Note that 192.168.1.999 is not a valid ip address, so don't generate that!  The validator will prevent you creating it anyway:</p>
<pre><code>&gt;&gt;&gt; from ipaddress import ip_address
&gt;&gt;&gt; ip_address('192.168.1.254')
IPv4Address('192.168.1.254')
&gt;&gt;&gt; ip_address('192.168.1.999')
# ValueError: '192.168.1.999' does not appear to be an IPv4 or IPv6 address
</code></pre>
<p>To convert from an <a href="https://docs.python.org/3/library/ipaddress.html#ipaddress.ip_address" rel="nofollow noreferrer">ip address object</a> back to a plain old string, just call <code>str</code> on it.</p>
<p>Your question also asked about "rolling over" to 192.168.2.1.  This is just iterating a different subnet. The 24 in 192.168.1.0/24 refers to 24 significant bits allocated for the network prefix (the remaining 8 bits reserved for host addressing), i.e. the <em>subnet mask</em> 255.255.255.0.</p>
<p>To make it "rollover", you really just want to iterate a bigger subnet:</p>
<pre><code>&gt;&gt;&gt; gen = iter(ip_network('192.168.0.0/16'))
&gt;&gt;&gt; for i in range(255*2):
...     next(gen)
...     
&gt;&gt;&gt; next(gen)
IPv4Address('192.168.1.254')
&gt;&gt;&gt; next(gen)
IPv4Address('192.168.1.255')
&gt;&gt;&gt; next(gen)
IPv4Address('192.168.2.0')
&gt;&gt;&gt; next(gen)
IPv4Address('192.168.2.1')
</code></pre>
<p>To get from a single ip address string to the network object, you can use the <a href="https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Network.supernet" rel="nofollow noreferrer"><code>supernet</code></a> method:</p>
<pre><code>&gt;&gt;&gt; from ipaddress import ip_address, ip_interface
&gt;&gt;&gt; ip = ip_address('192.168.1.1')
&gt;&gt;&gt; net = ip_interface(ip).network
&gt;&gt;&gt; net
IPv4Network('192.168.1.1/32')
&gt;&gt;&gt; net.supernet(prefixlen_diff=8)
IPv4Network('192.168.1.0/24')
</code></pre>
<p>Read about <a href="https://en.wikipedia.org/wiki/IPv4" rel="nofollow noreferrer">Internet Protocol version 4</a> for more info, and the official docs for Python's <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow noreferrer"><code>ipaddress</code></a> module.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code># for IP addresses of the form 1.92.168.a.b

a_max = 10
b_max = 999

ips = []
for a in range(a_max):
    for b in range(b_max):
        ips += ['1.92.168.{}.{}'.format(a,b)]
</code></pre>
<p>This will give you a list of all the IP addresses generated as strings. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can split the addresses using <code>ip_address.split(.)</code> resulting in a <code>ip_list</code>. Keep track of the limit you have in mind. Increment each element of <code>ip_list</code> after converting to integer then convert back to string and put them all back together using <code>".".join(ip_list)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a class with an <code>__add__</code> method:</p>
<pre><code>class Ip:
 def __init__(self, _ip:str, _stop = 999) -&gt; None:
   self.ip = _ip
   self.stop = _stop
 def __add__(self, _val):
   _ip = list(map(int, self.ip.split('.')))
   _r = 0
   while _r &lt; 4:
     result = _ip[3 -_r]+_val
     if result &lt; self.stop:
       _ip[3 - _r] += _val
       break
     _ip[3 - _r] += _val%self.stop
     _val = _val%self.stop
     _r += 1
     _ip[4 - _r] = 1
   return Ip('.'.join(map(str, _ip)))
 def __repr__(self):
   return f'&lt;IP {self.ip}&gt;'

p = Ip('192.168.1.1')
new_p = p + 1
print(new_p)
print(p + 1000)
</code></pre>
<p>Output:</p>
<pre><code>&lt;IP 192.168.1.2&gt;
&lt;IP 192.168.2.1&gt;
</code></pre>
</div>
<span class="comment-copy">@MoxieBall it was just an example</span>
<span class="comment-copy">How are you storing this IP address?</span>
<span class="comment-copy">@JacobBoertjes as a string</span>
<span class="comment-copy">Do you want a function that takes an ip string and an interval and increments the ip by that much?</span>
<span class="comment-copy">Wow exactly what I was looking for thank you!</span>
<span class="comment-copy">While this answers the exact question, this produces a number of invalid IP addresses.</span>
<span class="comment-copy">@MatthewStory I have something that handles that, thanks for the comment anyways.</span>
<span class="comment-copy">@MatthewStory: I realize that; OP was looking for an incrementation solution.  I'm assuming he knows how to handle IP limitations -- and thanks for highlighting the potential problem.</span>
<span class="comment-copy">Aye, that was me. You should not write a hacky <code>class Ip</code> for this stuff, when there is already a tried and tested one in the Python stdlibs:  <a href="https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address" rel="nofollow noreferrer">docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address</a></span>
