<div class="post-text" itemprop="text">
<p>I see the below statement in the github link and would like to how this condition is executed. The right expression to the or checks for a condition but the left side is more of a assigment statement.</p>
<p><a href="https://github.com/wkentaro/labelme/blob/30a29a4a9c1f355cdbd69e65a0f3aad6948f458d/labelme/canvas.py#L464" rel="nofollow noreferrer">https://github.com/wkentaro/labelme/blob/30a29a4a9c1f355cdbd69e65a0f3aad6948f458d/labelme/canvas.py#L464</a></p>
<pre><code>shape.fill = shape.selected or shape == self.hShape
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this context, <code>shape.selected</code> is a boolean attribute, so the code is equivalent to this:</p>
<pre><code>if shape.selected:
    shape.fill = shape.selected
else:
    shape.fill = shape == self.hShape  
</code></pre>
<p>Does that help?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're getting the precedence wrong.<sup>1</sup></p>
<p>This is an assignment statement, where the left side is the name <code>shape.fill</code>, and the right side is the <code>or</code> expression. It's not an <code>or</code> statement, where the left side is an assignment and the right side is a comparison.</p>
<p>In other words, it's equivalent to:</p>
<pre><code>shape.fill = (shape.selected or shape == self.hShape)
</code></pre>
<p>And to avoid any other confusion, the <code>==</code> is evaluated before the <code>or</code>, so it's ultimately equivalent to this:</p>
<pre><code>shape.fill = (shape.selected or (shape == self.hShape))
</code></pre>
<p>And hopefully you understand what that means.</p>
<hr/>
<p>The implicit precedence rules<sup>2</sup> for every operator, symbol, and keyword can be inferred by worked out by reading the syntax in the Reference Manual, starting from <a href="https://docs.python.org/3/reference/toplevel_components.html" rel="nofollow noreferrer">Top-level components</a> and working down through statements (simple and complex) and expressions. Or you can read the <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow noreferrer">Full Grammar specification</a> for a more concise but less explanatory version.</p>
<p>But since you're using Python, you might prefer to learn by experimentation rather than by manual. In that case, check out the <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer"><code>ast</code></a> module:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; statement = 'shape.fill = (shape.selected or shape == self.hShape)'
&gt;&gt;&gt; print(ast.dump(ast.parse(statement)), annotate_fields=False)
("Module([Assign([Attribute(Name('shape', Load()), 'fill', Store())], "
 "BoolOp(Or(), [Attribute(Name('shape', Load()), 'selected', Load()), "
 "Compare(Name('shape', Load()), [Eq()], [Attribute(Name('self', Load()), "
 "'hShape', Load())])]))])")
</code></pre>
<p>OK, that may be a bit hard to follow, but there are some nice third-party libs that format the tree more clearly. It comes down to this:</p>
<pre><code>Module
    Assign
        Attribute
            Name('shape')
            'fill'
        BoolOp
            Or
            Attribute
                Name('shape')
                'selected'
            Compare
                Name('shape')
                Eq
                Attribute
                    Name('self')
                    'hShape'
</code></pre>
<p>So, you can see that there's an assignment (<code>Assign</code>) where the left side is the attribution (<code>Attribute</code>) and the right side is the <code>or</code> expression (<code>BoolOp</code>).</p>
<hr/>
<p><sub>1. Technically, there's no precedence going on, because <code>=</code> isn't even an operator in Python. But it's easier to think about it this way, and only a tiny bit misleading, and hopefully the next sentence clears it up.</sub></p>
<p><sub>2. Again, the only <em>explicit</em> precedence rules are those that apply to operators, which doesn't include the <code>=</code> in your example. So you have to work out how the statement will be parsed, effectively the same way the parser does.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>or</code> operator binds less tightly than the <code>=</code> you see on the left. Adding some parentheses may make the situation clearer:</p>
<pre><code> shape.fill = ((shape.selected) or (shape == self.hShape))
</code></pre>
<p>The parentheses I've added don't change anything in how the statement is evaluated. The two arguments to <code>or</code> are <code>shape.selected</code> (which is presumably a <code>bool</code>), and the expression <code>shape == self.hShape</code>. The result of the <code>or</code> expression is what gets assigned to <code>shape.fill</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is evaluating the same sort of statement you would see in an <code>if</code> statement.</p>
<p>They are creating a boolean and assigning it to <code>shape.fill</code>. Presumably, <code>shape.selected</code> is either <code>True</code> or <code>False</code>. They are then applying a logical <code>or</code> with another boolean statement <code>shape == self.hShape</code>. </p>
<p>In the end, it is of the form </p>
<pre><code>shape.fill = (boolean variable) or (boolean expression)
</code></pre>
<p>while evaluates to a boolean.</p>
</div>
<span class="comment-copy">You're getting the precedence wrong. This is an assignment statement, where the right side of the assignment is an or expression. Equivalent to <code>shape.fill = (shape.selected or shape == self.hShape)</code>.</span>
