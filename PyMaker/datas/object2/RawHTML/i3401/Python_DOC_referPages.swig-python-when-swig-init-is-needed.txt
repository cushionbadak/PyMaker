<div class="post-text" itemprop="text">
<p>Hi everyone and thanks for trying to help me !</p>
<p>I encounter trouble when trying to import a python module generated by swig.
I have a basic library "example" containing few methods.
Next to it I have a main program dynamically linked to python.
This program imports the generated module and calls a function in it.</p>
<p>If my library example is a shared one, named _example.so, everything works perfectly, and I can import it in python.</p>
<p>But if my library is static, _example.a, and linked to the main program, then I will have the error "no module named _example was found" unless I add a call to SWIG_init() in the main function.</p>
<p>What exactly does SWIG_init() , and when should I use it ? It seems quite weird to me because it's never said in the documentation to do such a call.</p>
<p>I know that dealing with a .so shared library is better but I try to reproduce the behavior of what I have on a big project at work, so I really have to understand what happens when the module is static.</p>
<p>Here is my main file :</p>
<pre><code>#include "Python.h"
#include &lt;iostream&gt;

#if PY_VERSION_HEX &gt;= 0x03000000
#  define SWIG_init    PyInit__example

#else
#  define SWIG_init    init_example

#endif

#ifdef __cplusplus
extern "C"
#endif

#if PY_VERSION_HEX &gt;= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void);

int main (int arc, char** argv)
{
    Py_Initialize();
    SWIG_init(); // needed only using the statically linked version of example ?    
    PyRun_SimpleString("print \"Hello world from Python !\"");

    PyRun_SimpleString("import sys");
    PyRun_SimpleString("sys.path.append(\"/path/to/my/module\")");

    PyRun_SimpleString("import example");
    PyRun_SimpleString("a = example.Example()");
    PyRun_SimpleString("print a.fact(5)");
}
</code></pre>
<p>Here is how things are generated :</p>
<pre><code>swig -c++ -python example.i

g++ -fpic -c example.cpp example_wrap.cxx -I/include/python2.7 -lstdc++
ar rvs libexample.a example.o example_wrap.o
// to generate dynamic instead of static : g++ -shared example.o example_wrap.o -o _example.so 

g++ main.cpp -I/include/python2.7 libexample.a -lstdc++ -L/lib/python -lpython2.7 -o main
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you are calling is the init function of the native python module <code>_example</code> that is loaded by the SWIG generated python wrapper. For python 2 this function is named <code>init_example</code>, and for <a href="https://docs.python.org/3/extending/extending.html#the-module-s-method-table-and-initialization-function" rel="nofollow noreferrer">python 3 it is named <code>PyInit__example</code></a>.</p>
<p>Every <a href="https://docs.python.org/2/extending/extending.html" rel="nofollow noreferrer">python extension with C or C++</a> needs such a function, it basically initializes everything and registers the name of the module and all the methods available for it. In your case SWIG has generated this function for you.</p>
<p>The reason you have to call this function yourself when you compiled the library statically is simply that the python wrapper example imports the native module _example which is by the python convention a shared object, which you did not compile, and which is thus not found.</p>
<p>By calling SWIG_init, you "preload" the module, so python does not try to reimport it, so it works even though there is no shared object anywhere on the python module path.</p>
<p>If you have the shared object for your module, python will call this function for you after loading the shared object and you don't have to worry about this.</p>
</div>
<span class="comment-copy">Thank you so much ! It was not very clear to me that it was actually possible to use a static library as a module without rebuild the interpreter. Now I understand why this call is done. Thanks again !</span>
