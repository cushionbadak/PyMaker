<div class="post-text" itemprop="text">
<p>Let's suppose I have the following list made out of lists</p>
<pre><code>list1 = [['a','b'],['a'],['b','c'],['c','d'],['b'], ['a','d']]
</code></pre>
<p>I am wondering if there is a way to convert every element of <code>list1</code> in a dictionary where all the new dictionaries will use the same key. E.g: if <code>['a']
</code> gets to be <code>{'a':1}</code>, and <code>['b']</code> gets to be <code>{'b':2}</code>, I would like for all keys <code>a</code> the value of <code>1</code> and for all keys <code>b</code> the value of <code>2</code>. Therefore, when creating the dictionary of <code>['a','b']</code>, I would like  to turn into <code>{'a':1, 'b':2}</code>. </p>
<p>What I have found so far are ways to create a dictionary out of lists of lists but using the first element as the key and the rest of the list as the value:</p>
<p>Please note that's not what I am interested in.
The result I would want to obtain from <code>list1</code> is something like:</p>
<pre><code>dict_list1 = [{'a':1,'b':2}, {'a':1}, {'b':2,'c':3}, {'c':3,'d':4}, {'b':2}, {'a':1,'d':4}]
</code></pre>
<p>I am not that interested in the items being that numbers but in the numbers being the same for each different key.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">chain</a> and <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a> you can do auto mapping</p>
<pre><code>from itertools import chain
from collections import OrderedDict

list1 = [['a','b'],['a'],['b','c'],['c','d'],['b'], ['a','d']]
# do flat list for auto index
flat_list = list(chain(*list1))
# remove duplicates
flat_list = list(OrderedDict.fromkeys(flat_list))
mapping = {x:flat_list.index(x)+1 for x in set(flat_list)}

[{e: mapping[e] for e in li} for li in list1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to declare your mapping first:</p>
<pre><code>mapping = dict(a=1, b=2, c=3, d=4)
</code></pre>
<p>Then, you can just use dict comprehension:</p>
<pre><code>[{e: mapping[e] for e in li} for li in list1]
# [{'a': 1, 'b': 2}, {'a': 1}, {'b': 2, 'c': 3}, {'c': 3, 'd': 4}, {'b': 2}, {'a': 1, 'd': 4}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here a try with <code>ord()</code> also it will work for both capital and lower letters :</p>
<pre><code>[{e: ord(e)%32 for e in li} for li in list1]
</code></pre>
</div>
<span class="comment-copy"><code>{'b':3,'c':4}</code> ?</span>
<span class="comment-copy">My mistake, <code>{'b':2,'c':4}</code></span>
<span class="comment-copy">c should be 3 and d should be 4 ?</span>
<span class="comment-copy">@sachindubey I just add that I am not as interested in the numbers themselves but in being sure that every key in the dictionary have the same value in all the dictionaries.</span>
<span class="comment-copy">thats sth i learned today!</span>
<span class="comment-copy">You could potentially create <code>mapping</code> automatically. e.g. <code>mapping = {a:i for i,a in enumerate(string.ascii_lowercase, 1)}</code>.</span>
<span class="comment-copy">Unfortunately <code>mapping</code> assignment can only be formulated after having looked to the list content.</span>
