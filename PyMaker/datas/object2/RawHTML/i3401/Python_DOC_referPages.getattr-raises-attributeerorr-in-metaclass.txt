<div class="post-text" itemprop="text">
<p>I'm toying with python to understand how it works, but there is something weird. I'm defining a <code>__new__</code> method in my MetaClass, and I expect the fourth argument (which is a dict of attributes of the class-to-be), to contain methods defined in my class-to-be body.</p>
<p>I have this code : </p>
<pre><code>#!/usr/bin/python3


class MyMetaClass(type):
    def __new__(metacls, name, bases, attrs):
        instance = super(MyMetaClass, metacls) #Create instance of super class, which metaclass is type
        print(type(type))
        print(type(type(instance)))
        print(instance.__new__)
        print(type.__new__)
        print(attrs)
        print(getattr(attrs, 'foobar'))
        return super(MyMetaClass, metacls).__new__(metacls, name, bases, attrs)

class TestClass(metaclass=MyMetaClass):
    def __get__(self, obj, type=None):
        return self
    def foobar(self):
        print(f'My name is {self.name}') 
    def __init__(self, args):
        print(args)
        self.firstname = args['firstname'] if 'firstname' in args else ''
        self.lastname = args['lastname'] if 'lastname' in args else ''
        self.name = f'{self.firstname} {self.lastname}'



data = {'firstname': 'Florian'}
c = TestClass(data)
c.foobar()
</code></pre>
<p>The output is:</p>
<pre><code>&lt;class 'type'&gt;
&lt;class 'type'&gt;
&lt;built-in method __new__ of type object at 0x10d759e40&gt;
&lt;built-in method __new__ of type object at 0x10d759e40&gt;
{'__module__': '__main__', '__qualname__': 'TestClass', '__get__': &lt;function TestClass.__get__ at 0x10e192b70&gt;, 'foobar': &lt;function TestClass.foobar at 0x10e192bf8&gt;, '__init__': &lt;function TestClass.__init__ at 0x10e192c80&gt;}
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 25, in &lt;module&gt;
  File "&lt;string&gt;", line 13, in &lt;module&gt;
  File "&lt;string&gt;", line 10, in __new__
AttributeError: 'dict' object has no attribute 'foobar'
</code></pre>
<p>So <code>print(attrs)</code> in <code>MyMetaClass.__new__</code> the result is, as expected : </p>
<pre><code>{'__module__': '__main__', '__qualname__': 'TestClass', '__get__': &lt;function TestClass.__get__ at 0x7f042b9e6158&gt;, 'foobar': &lt;function TestClass.foobar at 0x7f042b9e61e0&gt;, '__init__': &lt;function TestClass.__init__ at 0x7f042b9e6268&gt;}
</code></pre>
<p>How you can see, it contains the 'foobar' key.</p>
<p>However, the next line raises <code>AttributeError : 'dict' object has no attribute 'foobar'</code>. Why ?</p>
<p>I tried <code>hasattr(attrs, 'foobar')</code> which returns false too.</p>
</div>
<div class="post-text" itemprop="text">
<p>A dictionary doesn't expose the keys as attributes. The dictionary will become the namespace for the class being created, but it is <em>not yet part of a class</em>. Classes (and their metaclass) have a <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code> method</a> that translates attribute access to dictionary lookups, but that's not available on the dictionary object itself.</p>
<p>Just use dictionary subscription access:</p>
<pre><code>print(attrs['foobar'])
</code></pre>
<p>or call <code>super().__new__()</code>, store the return value, then look up the attribute on that new class object:</p>
<pre><code>class MyMetaClass(type):
    def __new__(metacls, name, bases, attrs):
        new_class = super(MyMetaClass, metacls).__new__(metacls, name, bases, attrs)
        print(new_class.foobar)
        return new_class
</code></pre>
<p>Note: <code>super(MyMetaClass, metacls)</code> does <em>not</em> produce an instance! It returns the <code>super()</code> proxy object, attributes on which will be looked up on the metaclass Method Resolution Order (MRO). <code>super(MyMetaClass, metacls).__new__</code> is such a lookup, finding the next <code>__new__</code> attribute in the metaclass's MRO. In this case that's <code>type.__new__</code>, and calling that method produces the actual class object. </p>
</div>
<span class="comment-copy"><code>foobar</code> is a dictionary key and not an object attribute. Use key indexing or <code>dict.get</code> to retrieved the value correlating with a key. e.g. <code>attrs['foobar']</code> or <code>attrs.get('foobar')</code></span>
<span class="comment-copy">Thank you for such a detailed answer including <code>__getattribute__</code>.</span>
<span class="comment-copy">Ok I now understand why <code>instance.__new__</code> and <code>type.__new__</code> where pointing at the same address. So you're saying that the super() call does not create an instance, and indeed, <code>hasattr(instance, '__class__')</code> returns false. But then, what is it ?</span>
<span class="comment-copy">@Florian: <code>super(instance, cls)</code> produces a special <i>proxy object</i>, where looking up attributes triggers a search along the objects of <code>type(instance).__mro__</code> starting at the index after the index of <code>cls</code>, to find an attribute of the same name. It also makes sure to bind the object if it's a descriptor (methods are descriptors, see the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor howto</a>).</span>
<span class="comment-copy">@Florian: <code>metaclass.__new__</code> produces a new class object, not instances. You can't create instances until you have a class object, anyway.</span>
<span class="comment-copy">@Florian: don't confuse <code>classobject.__new__</code> there with <code>metaclass.__new__</code> which I helped you with the implementation of in this question. The latter produces class objects, the former instances of the class.</span>
