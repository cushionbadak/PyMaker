<div class="post-text" itemprop="text">
<p>I recently wrote this Python 3 code that is supposed to alternate among all iterables given to it. That is, if the function is given as arguments <code>(first, second, third)</code> then it yields <code>first[0], second[0], third[0], first[1], ...</code>. If <code>second</code> runs out before the others, then it is skipped: <code>second[15], third[16], first[16], third[16], ...</code> until all iterables are exhausted.</p>
<p>Here it is. It is functional, but it doesn't look very "pythonic". I especially don't like having to keep an array of flags that tell me if the generators are empty.</p>
<pre><code>def zipper(*many):
    iterators = [iter(x) for x in many]
    iHasItems = [True]*len(iterators)
    while any(iHasItems):
        for n, iterator in enumerate(iterators):
            if iHasItems[n]:
                try:
                    yield next(iterator)
                except StopIteration:
                    iHasItems[n] = False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are basically re-implementing the <code>roundrobin()</code> function documented in the itertools documentation <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipes section</a>:</p>
<pre><code>from itertools import cycle, islice

def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    num_active = len(iterables)
    nexts = cycle(iter(it).__next__ for it in iterables)
    while num_active:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            # Remove the iterator we just exhausted from the cycle.
            num_active -= 1
            nexts = cycle(islice(nexts, num_active))
</code></pre>
<p>This cycles through iterators and slicing off the last one each time a <code>StopIteration</code> exception is raised; that last iterator is always the one that just got exhausted.</p>
<p>Specifically, for the input example, <code>nexts</code> starts as a circular list of <code>&lt;iter('ABC'), iter('D'), iter('EF')&gt;</code>, in those positions, and <code>num_active</code> is <code>3</code>, after which the algorithm then progresses through:</p>
<ol>
<li>yielding <code>A</code> and leaving <code>&lt;iter('D'), iter('EF'), iter('BC')&gt;</code></li>
<li>yielding <code>D</code> and leaving <code>&lt;iter('EF'), iter('BC'), &lt;iter('')&gt;</code></li>
<li>yielding <code>E</code> and leaving <code>&lt;iter('BC'), &lt;iter(''), iter('F')&gt;</code></li>
<li>yielding <code>B</code> and leaving <code>&lt;iter(''), iter('F'), iter('C')&gt;</code></li>
<li>trying to yield but hitting a <code>StopIteration</code> exception; the cycle is then at <code>&lt;iter('F'), iter('C'), iter(*stopped*)&gt;</code>, so <code>num_active</code> becomes <code>2</code>, <code>cycle(islice(nexts, 2))</code> sets the cycle to <code>&lt;iter('F'), iter('C')&gt;</code> and <code>while</code> loop continues to</li>
<li>yielding <code>F</code> and leaving <code>&lt;iter('C'), iter('')&gt;</code></li>
<li>yielding <code>C</code> and leaving <code>&lt;iter(''), iter('')&gt;</code></li>
</ol>
<p>after which the final two empty iterators trigger further <code>StopIteration</code> exceptions, and <code>num_active</code> goes from 2 to 1 to 0 and the <code>while</code> loop ends.</p>
<p>You could implement the same with a <code>collections.deque()</code> object, and manual rotation:</p>
<pre><code>from collections import deque

def roundrobin(*iterables):
    nexts = deque((iter(it).__next__ for it in iterables))
    while nexts:
        try:
            yield nexts[0]()
            # rotate the queue to the left for the next step
            nexts.rotate(-1)
        except StopIteration:
            # Remove the iterator we just exhausted from the queue
            nexts.popleft()
</code></pre>
<p>but this approach is slower than the <code>cycle</code> variant, as rotation is done 'manually', incurring a cost every iteration, outweighing the simpler 'exhausted' exception case implementation.</p>
<p>Like your approach, this saves you having to repeatedly attempt to iterate over any already-exhausted iterators, and unlike the <code>zip_longest()</code> approaches posted by others, doesn't require you to test for a sentinel value (<code>item is not None</code> or <code>not item</code> or <code>item is not unique_sentinel_singleton</code>) each iteration.</p>
</div>
<div class="post-text" itemprop="text">
<p>You zip the <code>iterables</code> and <code>chain</code> them together</p>
<pre><code>from itertools import chain, zip_longest
def zipper(*many):
    return  filter(None, chain(*zip_longest(*many)))
</code></pre>
</div>
<span class="comment-copy">Refactoring questions are rather broad; this question would be a better fit for Codereview (given that it is your own code and that it works). See <a href="https://codereview.stackexchange.com/help/on-topic">codereview.stackexchange.com/help/on-topic</a></span>
<span class="comment-copy">Oh. Did not even know that SE existed. Thanks.</span>
<span class="comment-copy">Look at the <code>roundrobin</code> function in the "recipes" section of the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">documentation for itertools</a>. I believe it does what you want, is pythonic, and avoids that array of flags.</span>
<span class="comment-copy">And Rory already found it, but you are basically re-implementing the <code>roundrobin()</code> function documented in the itertools documentation <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipes section</a>; it cycles through iterators and slicing off the last one each time a <code>StopIteration</code> exception is raised; that last iterator is always the one that just got exhausted.</span>
<span class="comment-copy">Boy do I feel dumb now. I thought I had googled for it well enough... It did feel weird that nobody had implemented such a basic thing.</span>
<span class="comment-copy">This will stop whenever any iterator is exhausted.</span>
<span class="comment-copy">What if they're not the same length? I thought <code>zip</code> truncated to the length of the shortest</span>
<span class="comment-copy">@RiccardoOrlando. Modified to work with iterators of unequal length</span>
<span class="comment-copy">@Amadan Modified to work with iterators of unequal length</span>
<span class="comment-copy">This would skip any falsy value in the input iterators, such as <code>0</code> or <code>None</code> or <code>False</code> or <code>''</code>. At the <i>very least</i> use a singleton sentinel value that won't appear in the input iterators to test for the 'padding' value <code>zip_longest()</code> inserts. And it's simply not efficient to use this method; what if all but one of the iterators is short, and the long iterator is <b>very very</b> long? You can save yourself all those <code>if item</code> tests by <i>eliminating exhausted iterators</i>.</span>
