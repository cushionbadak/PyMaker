<div class="post-text" itemprop="text">
<p>I need to create a regular expression to validate strings. The strings can have only few characters and each character can be repeated only a few number of times.</p>
<p>The regular expression should check below conditions.</p>
<ol>
<li>The string can have only <strong>a, b, c, d, e</strong> as characters.</li>
<li>The character '<strong>a</strong>' can appear a maximum of 2 times.</li>
<li>The character '<strong>b</strong>' can appear maximum of 3 times.</li>
<li>The character '<strong>c</strong>' can appear maximum of 3 times.</li>
<li>The character '<strong>d</strong>' can be appear maximum of 1 time.</li>
<li>The character '<strong>e</strong>' can be appear maximum of 1 time.</li>
</ol>
<p>I know that this can be achieved by string functions. But I am trying to do it with regular expressions.</p>
<p>Any help on this is highly appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<p>Likely, performance wise, the best way to do this is with Python native string operations.</p>
<p>I would write like so:</p>
<pre><code>lim=(('a',2),('b',3),('c',3),('d',1),('e',1))
results={}
for s in [list_of_many_strings]:
    results[s]=bool(not(set(s)-set('abcde'))) and (not any(s.count(c)&gt;x for c,x in lim))
</code></pre>
<p>This relies on <a href="https://docs.python.org/3.6/library/stdtypes.html#str.count" rel="nofollow noreferrer">str.count(sub[, start[, end]])</a> to count the occurrence of a sub string in a string and <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer">any function</a> to test if any condition is true. </p>
<hr/>
<p>Since you are interested in performance, you can time how long processing 100,000 strings might take with <code>timeit</code>:</p>
<pre><code>import re

def f1(li):
    results={}
    lim=(('a',2),('b',3),('c',3),('d',1),('e',1))
    for s in li:
        results[s]=bool(not(set(s)-set('abcde'))) and (not any(s.count(c)&gt;x for c,x in lim))

    return results    

def f2(li):
    pat=re.compile(r'^a{0,2}b{0,3}c{0,3}d{0,1}e{0,1}$')
    results={}
    for s in li:
        results[s]=True if pat.search(''.join(sorted(s))) else False

    return results

def f3(li):
    pat=re.compile(r'^(?!.*[^a-e])(?!(?:.*a){3})(?!(?:.*b){4})(?!(?:.*c){4})(?!(?:.*d){2})(?!(?:.*e){2}).+')
    results={}
    for s in li:
        results[s]=True if pat.search(s) else False    

    return results    

if __name__=='__main__':
    import timeit    
    import random 
    s='abcdeabcdebc'
    li=[''.join(random.sample(s,8)) for _ in range(100000)]
    print(f1(li)==f2(li)==f3(li))

    for f in (f1,f2,f3):
        print("   {:^10s}{:.4f} secs".format(f.__name__, timeit.timeit("f(li)", setup="from __main__ import f, li", number=10)))
</code></pre>
<p>On my computer, takes:</p>
<pre><code>True
       f1    0.8519 secs
       f2    1.1235 secs
       f3    1.3070 secs
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A regex checking multiple conditions can be constructed the following way:</p>
<ul>
<li><code>^</code> - Start of the source string.</li>
<li>A series of positive lookups, for any "required" condition.</li>
<li>A series of negative lookups, for any "forbidden" condition.</li>
<li><code>.+</code> - If all previous lookups succeeded, match the whole (usually
non-empty) source string.</li>
</ul>
<p>If either positive or negative lookup refers to a char located
<strong>anywhere</strong> in the source string, it should start with <code>.*</code>,
stating that before what we actually check, there can occur any
number of any (other) chars, possibly none.</p>
<p>Your case contains actually only "forbidden" conditions, stating that
it is not allowed:</p>
<ul>
<li><code>(?!.*[^a-e])</code> - Any char other than <code>a-e</code>.</li>
<li><code>(?!(?:.*a){3})</code> - <code>a</code> occurs 3 times (or more).</li>
<li><code>(?!(?:.*b){4})</code> - <code>b</code> occurs 4 times (or more).</li>
<li><code>(?!(?:.*c){4})</code> - <code>c</code> occurs 4 times (or more).</li>
<li><code>(?!(?:.*d){2})</code> - <code>d</code> occurs 2 times (or more).</li>
<li><code>(?!(?:.*e){2})</code> - <code>e</code> occurs 2 times (or more).</li>
</ul>
<p>So the whole regex should be:</p>
<pre><code>^(?!.*[^a-e])(?!(?:.*a){3})(?!(?:.*b){4})(?!(?:.*c){4})(?!(?:.*d){2})(?!(?:.*e){2}).+
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if your strings are already sorted, like all <code>a</code> characters are already in front of all <code>b</code> characters and so on, the simple regular expression like this will do:</p>
<pre><code>r'^a{0,2}b{0,3}c{0,3}d{0,1}e{0,1}$'
</code></pre>
<p>If characters in your strings are unsorted, well, sort them first =)</p>
<p>And if the meaning of your "can appear a maximum of 2 times" is 1 or 2 times (not 0, 1 or 2, as I expected), replaces all <code>0</code> with <code>1</code> in the reg.expression.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you are using pandas, it's probably best to use vectorised operations. These are supposed to be faster, although I am not willing to check. Here is one possible approach, a pandas or numpy expert may have a better method:</p>
<pre><code>import random

import pandas as pd

s = 'abcdeabcdebc'
df = pd.DataFrame({'s': [''.join(random.sample(s, 8)) for _ in range(100000)]})
count = df.s.str.count
df['valid'] = ((count('[^a-e]') == 0) &amp;
               (count('a') &lt;= 2) &amp;
               (count('b') &lt;= 3) &amp;
               (count('c') &lt;= 3) &amp;
               (count('d') &lt;= 1) &amp;
               (count('e') &lt;= 1))

print(df.head())
</code></pre>
<p>Example output:</p>
<pre><code>          s  valid
0  cacbdbec   True
1  cabdceab   True
2  bbdcdabe  False
3  ecaadbce  False
4  ebabcdad  False
</code></pre>
</div>
<span class="comment-copy">I don't think regex is suited in performing such a check. Since you also tagged python, why don't you do it programmatically in python instead?</span>
<span class="comment-copy">I have more than 100,000 strings to process here. Using regex will be faster than performing string manipulations.</span>
<span class="comment-copy">Joel Berkeley the one that was pasted below is not the duplicate. of this. There it is performing a string operation to count number of characters. I need regular expression for this.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/1155617/count-the-number-occurrences-of-a-character-in-a-string">Count the number occurrences of a character in a string</a></span>
<span class="comment-copy">@Ajith Using regular expressions for this task will be significantly slower then iterating through the string once. Especially because the regex needs to be more complex to solve this as it's not a task intended for regular expressions.</span>
<span class="comment-copy">Your solution does not check whether the source string contains any other char than a-e. If it does, the check should fail.</span>
<span class="comment-copy">@Valdi_Bo: Yes -- good observation. Fixing...</span>
<span class="comment-copy">Amazingly, I find that the timings are reversed, e.g. <a href="https://repl.it/repls/PerfumedBabyishBots" rel="nofollow noreferrer">repl.it/repls/PerfumedBabyishBots</a>. I've also added an optimised version of your solution.</span>
<span class="comment-copy">@AlexHall: huh! I ran it on PyPy on a Mac to get those timings. I tried your exact source code and tried all of Py3, Py2 and PyPy. Some variance but not the same as the real.it version. Your optimized solution is a bit faster indeed. Thanks!</span>
<span class="comment-copy">@AlexHall: Actually, this can have great performance. If the regex engine is recent, it will short-circuit on any element quickly. Lookaheads are <i>usually</i> faster than the equivelent non-lookahead construct as well. This is the highest performing solution <b>IF</b> you have many string with characters other than <code>a-e</code> because it fails on the first clause.</span>
<span class="comment-copy">This has surprisingly good performance.</span>
<span class="comment-copy">Nicely translated to Pandas! :-)</span>
