<div class="post-text" itemprop="text">
<p>What is the difference between @property, @property.setter and getattr(), setattr(). When will I use them? If both are the same, which one is preferred to use in python 3.x?</p>
<p>I am new to python and not understanding where to use and how to use them with OO python</p>
<p>I have gone through many websites, but I'm not sure which one to use. Please give me some real time example. Appreciate your help.</p>
<p>EX:</p>
<p>getattr()</p>
<p>class emp:
    name='Harsh'
    salary='25000'
    def show(self):
        print self.name
        print self.salary
e1 = emp()
print getattr(e1,'name')
setattr(e1,'height',152)
@ property</p>
<p>class P:</p>
<pre><code>def __init__(self,x):
    self.x = x

@property
def x(self):
    return self.__x

@x.setter
def x(self, x):
    if x &lt; 0:
        self.__x = 0
    elif x &gt; 1000:
        self.__x = 1000
    else:
        self.__x = x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In python we generally <a href="https://stackoverflow.com/questions/2627002/whats-the-pythonic-way-to-use-getters-and-setters/36943813#36943813">do not use <code>getter</code> and <code>setter</code> methods</a>, instead preferring to directly get and set attributes wherever possible as it is far simpler and more intuitive than intermediating access to values through getter and setter methods.</p>
<p>In the (fairly) rare case where you do need dynamic setters and getters, the <code>@property</code> decorator is the preferred way of defining dynamic setters and getters that can be used via <code>.</code> notation:</p>
<pre><code>class Foo:
    def __init__(self, x=None):
        self.x = x

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, value):
        self._x = value or 0
</code></pre>
<p>These can be used in concert with <code>getattr</code> and <code>setattr</code>, which allow you to dynamically access attributes of an object by the attribute name:</p>
<pre><code>foo = Foo()
getattr(foo, "x")    # 0
setattr(foo, "x", 1) # Same as foo.x = 1
foo.x       # 1
</code></pre>
<p>A more apropos question might be what is the difference between a <code>@property</code> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer"><code>__setattr__</code></a> which allow for dynamic property access similar to <code>property</code> but for any possible name:</p>
<pre><code>class Foo(object):
    def __init__(self, x=None):
        self._other_values = {}
        self.x = x

    def __getattr__(self, k):
        try:
            return self._other_values[k]
        except KeyError:
            raise AttributeError(k)

    def __setattr__(self, k, v):
        if k == "_other_values":
            return super(Foo, self).__setattr__(k,v)
        if k == "x":
            v = v or 0
        self._other_values[k] = v
</code></pre>
<p>Which will function identically to the example above.</p>
</div>
<span class="comment-copy">getattr and setattr are usually used by calling code when the name of the attribute is stored in a variable.</span>
<span class="comment-copy">Please cite the source of that example code ... <a href="https://www.python-course.eu/python3_properties.php" rel="nofollow noreferrer">python-course.eu/python3_properties.php</a></span>
<span class="comment-copy">BTW, making <code>name</code> a class attribute instead of an instance attribute is a bit weird, unless you only have 1 employee. :)</span>
