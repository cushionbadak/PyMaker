<div class="post-text" itemprop="text">
<p>I need to convert to some Python 3 code to Python 2 code</p>
<pre><code>from collections.abc import Sequence

def to_tensor(X, device):
  .....
    if isinstance(X, (list, tuple)):
        return [to_tensor_(x) for x in X]

    if isinstance(X,Sequence):&lt;-------equals to if isinstance(X,(str,bytes))?
        X = torch.tensor(np.array(X))

    return X.to(device)
</code></pre>
<p>as you can see above, I want to know whether:</p>
<pre><code>isinstance(X,Sequence)
</code></pre>
<p>equals to </p>
<pre><code>isinstance(X,(str,bytes))
</code></pre>
<p>and <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" rel="nofollow noreferrer">the documentation</a>
does not make any sense to me.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short answer: no, it's not equivalent.</p>
<p>Longest answer: </p>
<p>First, Python2 has no "bytes" type - Python3 <code>bytes</code> are Python2 <code>str</code> and Python3 <code>str</code> is Python2 <code>unicode</code>, so the right question would be: is <code>isinstance(X,Sequence)</code> equivalent to <code>isinstance(X, (unicode, str))</code>.</p>
<p>Then, the answer is <em>still</em> no. Py3 <code>str</code> and <code>bytes</code> ARE instances of <code>abc.Sequence</code> indeed, <strong>but</strong> so are any instances of a class implementing <code>abc.Sequence</code>, so you can have objects that are <code>Sequence</code> without being <code>str</code> or <code>bytes</code> ((Django orm's <code>Queryset</code> class would be a perfect candidate). </p>
<blockquote>
<p>and this doc: <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" rel="nofollow noreferrer">https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence</a> make not no sense to me</p>
</blockquote>
<p>If you follow the link in this doc, <a href="https://docs.python.org/3/glossary.html#term-sequence" rel="nofollow noreferrer">you get a verbal definition</a> of what a "sequence" is:</p>
<blockquote>
<p>An iterable which supports efficient element access using integer
  indices via the <strong>getitem</strong>() special method and defines a <strong>len</strong>()
  method that returns the length of the sequence
  (..)
  Note that dict also supports <strong>getitem</strong>() and <strong>len</strong>(), but is considered a mapping rather than a sequence</p>
</blockquote>
<p>According to this definition, to test if an object is a sequence, you have to test whether it's iterable, have a <code>__getitem__</code> and a <code>__len_</code> method and is not a <code>dict</code>. This won't be an <em>exact</em> equivalent of the py3 code, but it's the closer you can get (at least without more context, cf below):</p>
<pre><code>def is_sequence(obj):
    if isinstance(obj, dict):
        return False

    if not (
        hasattr(obj, "__getitem__") 
        and hasattr(obj, "__len__")
        ): 
        return False

    # we might have false postive here
    # with dict-likes not inheriting from
    # `dict`, so we also weed out objects 
    # having a `keys()` methods which
    # are most likely dict-likes
    if hasattr(obj, "keys"):
        return False
    return True
</code></pre>
<p>Now the real answer to your problem might be a bit different: there's the (more or les) formal definition of what a "sequence" is, and there's the context in which the code you're porting is called and the author's intent. </p>
<p>The author might have assumed that his function would only ever be passed lists, tuples, strings or bytes, in which case the test intent was indeed a misguided (I'd even say broken) and undocumented attempt to check for strings and bytes. </p>
<p>Or the author might have assumed that his function would just never be passed a string or bytes, but then I can't understand why he would treat lists and tuples differently from other sequences.</p>
<p>To make a long story short: you will have to study the context,  or eventually ask the author for clarification - if possible, of course. </p>
</div>
