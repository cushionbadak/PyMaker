<div class="post-text" itemprop="text">
<pre><code>import random

class Foo(object):
    def __init__(self):
        self._name = ''.join([chr(65 + random.randrange(0, 26)) for _ in range(3)])
        self._data = None

    def __getattr__(self, item):
        dashitem = '_' + item
        # if dhasattr(self, dashitem):
        # is a bad idea because hasattr calls getattr
        # is in self.__dict__.keys() also a bad idea?
        if dashitem in self.__dict__.keys():
            return self.__dict__[dashitem]

obj = Foo()
obj._data = [random.randrange(10, 100) for _ in range(random.randrange(1, 11))]
</code></pre>
<p>So far, so good. I can call <code>obj.name and get back</code>obj._name`</p>
<pre><code>In [2]: obj.name
Out[2]: 'QZB'

In [3]: obj.data
Out[3]: [54]
</code></pre>
<p>Then I try pickling the object:</p>
<pre><code>import pickle
pickle.dumps(obj)
</code></pre>
<p>is a no-go though.</p>
<pre><code>  File "&lt;ipython-input-7-a7748eba906b&gt;", line 2, in &lt;module&gt;
    pickle.dumps(obj)
  File "/usr/local/Cellar/python/2.7.14_2/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 1380, in dumps
    Pickler(file, protocol).dump(obj)
  File "/usr/local/Cellar/python/2.7.14_2/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 224, in dump
    self.save(obj)
  File "/usr/local/Cellar/python/2.7.14_2/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 306, in save
    rv = reduce(self.proto)
  File "/Users/vishal/virtenvs/fm/bin/../lib/python2.7/copy_reg.py", line 84, in _reduce_ex
    dict = getstate()
</code></pre>
<p>How do I do what I want with <code>__getattr__</code> above (return <code>_&lt;attr&gt;</code> if <code>&lt;attr&gt;</code> is not found without breaking other normal behaviour??</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest approach would be to simply protect against infinite recursion and let the default logic handle the rest. It is important to not implicitly return <code>None</code> (which you do in the omitted else-case) and break the default behaviour (which is to raise an <code>AttributeError</code> when an attribute is not found):</p>
<pre><code># ...
def __getattr__(self, item):
    # all double-underscore attrs should be found before calling the fallback
    if item.startswith('__'):  
        raise AttributeError
    return getattr(self, '_'+item)
</code></pre>
<p>See also <a href="https://stackoverflow.com/questions/2405590/how-do-i-override-getattr-in-python-without-breaking-the-default-behavior/31944601">this question</a> and the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer">docs</a>.</p>
</div>
<span class="comment-copy">If the point is to have read-only attributes, using <code>properties</code> (computed attributes) would be a better choice - it's explicit, the properties are thru inspection, and you only expose the one you choose to expose.</span>
<span class="comment-copy">The properties are not read-only, and are not easily explicitly enumerable. I was using properties and it got a bit out of hand.</span>
<span class="comment-copy">A <code>property</code> without a setter IS read-only, and yes you can easily find out a class properties thru inspection - but I fail to imagine why you'd want to do so here.</span>
<span class="comment-copy">Oh and yes, while we're at it : <code>dashitem in self.__dict__.keys()</code> is counter-productive - you're generating a list and do a O(N) lookup, when you could avoid the list generation and have a O(1) lookup with <code>dashitem in self.__dict__:</code>.</span>
<span class="comment-copy">Thank you. I was trying to solve the problems I thought I had because I didn't understand the <code>__getattr__</code> and <code>getattr()</code> worked clearly enough. I have better clarity now.</span>
<span class="comment-copy">Thank you for the answer and the link. Both are helpful. I didn't realize that I needed to return something or raise an exception.</span>
