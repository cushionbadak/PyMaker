<div class="post-text" itemprop="text">
<p>I am trying to use List Comprehension to perform the following. I want to make a new list (unique) that only has the common numbers from both lists.</p>
<pre><code>unique = []
for listcomp in range(len(list1)):
    if list1[listcomp] in list2 and list1[listcomp] not in unique:
        unique.append(list1[listcomp])
    else:
        continue
</code></pre>
<p>Above works fine but when I create the List comprehension below I get duplicates if list1 has duplicate numbers. i.e. list1 = [1, 1, 2], list2 = [1, 5]. I created my list comprehension as</p>
<pre><code>unique = [list1[listcomp] for listcomp in range(len(list1)) if list1[listcomp] in list2 and list1[listcomp] not in unique]
</code></pre>
<p>If I'm getting duplicates I assume the "and" statement isn't being applied? I have read other queries about moving the if statement further up the comprehension statement but this didn't work. Can you use AND to extend your conditions?</p>
<p>Many thanks</p>
<p>My full code is:-</p>
<pre><code>import random as rnd
# Randomly generate the size of your list
list1size = rnd.randint(1,20)
list2size = rnd.randint(1,20)
# Declare your list variables
list1 = []
list2 = []
# Fill your lists with randomly generated numbers upto the listsize generated above
for x in range(list1size):
    list1.append(rnd.randint(1,15))
for y in range(list2size):
    list2.append(rnd.randint(1,15))
# Not required but easier to read lists once sorted
list1.sort()
list2.sort()
print(list1)
print(list2)
# Now to compare old school

unique = []
# for listcomp in range(len(list1)):
#     if list1[listcomp] in list2 and list1[listcomp] not in unique:
#         unique.append(list1[listcomp])
#     else:
#         continue

# Now to compare with list comprehension
unique = [list1[listcomp] for listcomp in range(len(list1)) if list1[listcomp] in list2 and list1[listcomp] not in unique]
# Above doesn't stop duplicates if they are in List1 so I assume you can't use AND        

print(f"The common numbers in both lists are {unique}")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't access elements produced by a list comprehension as you go along. Your condition <code>list1[listcomp] not in unique</code> will always return <code>True</code> since at that moment in time <code>unique</code> is defined as the empty list intialised in <code>unique = []</code>.</p>
<p>So the <code>and</code> statement is being applied, but not the in way you want.</p>
<p>Instead, you can create a "seen" <code>set</code> holding items you have already found and omit them. The standard implementation is found in the <code>itertools</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>unique_everseen</code> recipe</a>.</p>
<p>If you have the 3rd party <a href="http://toolz.readthedocs.io/en/latest/api.html" rel="nofollow noreferrer"><code>toolz</code></a> library, you can use the identical <code>toolz.unique</code> and feed a generator expression. More Pythonic, you can iterate elements directly rather than using indices:</p>
<pre><code>from toolz import unique

unique = list(unique(i for i in list1 if i in list2))
</code></pre>
</div>
<span class="comment-copy">Many thanks, I guess thats the downside of a single line of code :-) I managed to get it working with set "unique = [a  for a in set(list1) if a in list2]"</span>
<span class="comment-copy">@Chunkylump, Just a minor point, the only issue with your code is the ordering is not guaranteed, <code>set</code> is unordered, any ordering you obtain which you expect should be considered a coincidence.</span>
<span class="comment-copy">@Chunkylump, I noticed you unaccepted. Does this solution no longer work for you?</span>
