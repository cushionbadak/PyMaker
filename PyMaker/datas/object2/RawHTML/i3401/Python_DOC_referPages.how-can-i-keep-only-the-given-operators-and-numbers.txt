<div class="post-text" itemprop="text">
<p>In this question i will hardcode acceptable operators, these operators will be allowed in the code:</p>
<pre><code>acceptable_operators = ['x', '/' , '+', '-', '.']
</code></pre>
<p>Now i will give a string let's say :</p>
<pre><code>sentence = "this 78isa6+trap//+sentence78-+6"
</code></pre>
<p>First step, after removing all non numbers and strings not in accepted_operators:</p>
<pre><code>786+//+78-+6
</code></pre>
<p>We can see that it doesn't make much sense here same occurrences of multiplications more than once if <code>...</code> or <code>xxx</code> should be reduced to only one, same with addition and division, however minus operator is different 2 minuses will result a + 3 minuses a minus and so on.</p>
<p>In case of different operators next to each other:
in case it's a +- regular math takes over.
in other cases like having +/ or +x or -/ or -x the multiplication and division operators dominate and the +- are "deleted"
however if we have x-5 we, for example, we don't delete the minus as it indicates 5 is negative.
In case we have <code>x/</code> the one to the right is "deleted" in this case <code>/</code></p>
<p>Final expected result:</p>
<pre><code>786/+78-6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this using <code>re.sub</code>.</p>
<p>The first call will remove unwanted characters.</p>
<p>The second call will remove duplicate <code>/</code>, <code>x</code> and <code>.</code> using a capturing group as well as any <code>+</code> or <code>-</code> before them.</p>
<p>The third one will normalize multiple occurence of a sign <code>+</code> or <code>-</code>.</p>
<h3>Code</h3>
<pre><code>import re

def normalize_sign(m):
    return '-' if m.group().count('-') % 2 else '+'

sentence = "this 78isa6+trap//+sentence78-+6"

# Remove characters that are not digits or operators
tmp = re.sub(r'[^\dx/+-.]', '', sentence)

# Replace multiple occurences of x, / or . by a single occurence
# and remove heading occurences of + and -
tmp = re.sub(r'[+\-]*([x/.])[x/.]*', r'\1', tmp)

# Normalize sign when multiple + and - are encountered
output = re.sub('[+\-]{2,}', normalize_sign, tmp)

print(output)
</code></pre>
<h3>Output</h3>
<pre><code>786/+78-6
</code></pre>
<h3>Regex explanation</h3>
<ul>
<li><p><code>[^\dx/+-.]</code>: a negative set <code>[^...]</code> matches anything that is not in the set</p></li>
<li><p><code>[+\-]*([x/.])\1*</code>: <code>\1</code> matches whatever was matched by the <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">first capturing group</a>, that is the pattern in between <code>(...)</code>.</p></li>
<li><p><code>[+\-]{2,}</code>: matches two or more signs. The method <code>re.sub</code> can then take a callable to which it passes the match and replace by the returned value.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><strong>Start</strong></p>
<ul>
<li>Remove unwanted chars: <code>[^0-9\+\/\-\*\.]</code></li>
</ul>
<p><strong>Loop</strong></p>
<ol>
<li>Remove unwanted duplication: <code>\++(?=[0-9\/\-\*\.])|\*+(?=[0-9\/\-\+\.])</code></li>
<li>Remove negative operators pairs recursively: <code>\-\-</code> until no more <code>\-\-</code></li>
</ol>
<p><strong>End</strong></p>
</div>
<span class="comment-copy">what did you try already?</span>
<span class="comment-copy">"We can see that it doesn't make much sense here same occurrences of multiplications more than once" Apologies, but none of this makes sense to me. Why are we handling <code>"this 78isa6+trap//+sentence78-+6"</code> as a formula in the first place?</span>
<span class="comment-copy">Basically because part of the code i want to write is taking "sentence" as input and instead of giving errors when some user adds strings i should just ignore them and make it function as a formula.</span>
<span class="comment-copy">Ok, so what happens with <code>+-</code>?</span>
<span class="comment-copy">+- should be - right</span>
<span class="comment-copy">@roganjosh Here it's fixed, I added a rule to handle multiple signs</span>
<span class="comment-copy">Works well thanks, i have 2 minor additions if possible, first off i tried doing it with regex myself but being a starter in python i got lost in the docs, i'd appreciate commenting how the regex were written there, and another edge case if a '/', 'x' are at the start of the string or any character other than numbers at the end they should be deleted, but i'll do that part myself after you comment how the regex works, thanks for your time:).</span>
<span class="comment-copy">@alberto I added explanations, let me know if that is sufficient</span>
<span class="comment-copy">I understood the first point, the second one is still difficult and i have a question regarding the third as in shouldn't x be in the [] as well.</span>
<span class="comment-copy">@alberto I added the link to the re syntax for the second point. Have a look at the \number section that explains capturing groups. As for the third point, no because the first re.sub already handles duplicate x</span>
