<div class="post-text" itemprop="text">
<p>I'm replacing part of an existing program. That original program uses threads. There's this particular class which inherits from <code>threading.Thread</code> which functionality I need to replace but I need to keep the interface the same.</p>
<p>The functionality I'm integrating is packaged in a library which uses <code>asyncio</code> a lot.</p>
<p>The original calls to the class I'm replacing go something like this:</p>
<pre><code>network = Network()
network.start()

network.fetch_something()  # crashes!

network.stop()
</code></pre>
<p>I've gotten to a point where my replacing class inherits from <code>threading.Thread</code> too and I can connect, from within the <code>run</code> method to my backends via the client library:</p>
<pre><code>class Network(threading.Thread):
     def __init__(self):
         self._loop = asyncio.new_event_loop()
         self._client = Client()  # this is the library

     def run(self):
         self._loop.run_until_complete(self.__connect())  # works dandy, implementation not shown
         self._loop.run_forever()

     def fetch_something(self):
         return self._loop.run_until_complete(self._client.fetch_something())
</code></pre>
<p>Running this code throws an exception:</p>
<pre><code>RuntimeError: Non-thread-safe operation invoked on an event loop other than the current one
</code></pre>
<p>I sort of get what's going on here. In the <code>run</code> method things worked out because the same thread running the event loop was the caller. In the other case an other thread was the caller hence the problem. 
As you might have noticed I was hoping the problem would have been solved by using the same event loop. Alas, that didn't work out.</p>
<p>I really want to keep the interface exactly as it is otherwise I'm refactoring for the remainder of the year. I could relatively easily pass arguments to the constructor of the <code>Network</code> class. I've tried passing in an event loop created on the main thread but the result was the same.</p>
<p>(Note that this is the opposite problem this author has: <a href="https://stackoverflow.com/questions/44856241/call-coroutine-within-thread">Call coroutine within Thread</a>)</p>
</div>
<div class="post-text" itemprop="text">
<p>When scheduling a coroutine from a different thread, you must use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe" rel="nofollow noreferrer"><code>asyncio.run_coroutine_threadsafe</code></a>. For example:</p>
<pre><code>    def fetch_something(self):
        future = asyncio.run_coroutine_threadsafe(
            self._client.fetch_something(), loop)
        return future.result()
</code></pre>
<p><code>run_coroutine_threadsafe</code> schedules the coroutine with the event loop in a thread-safe way and returns a <a href="https://docs.python.org/3/library/concurrent.futures.html#future-objects" rel="nofollow noreferrer"><code>concurrent.futures.Future</code></a>. You can use the returned future to simply wait for the result as shown above, but you can also pass it to other functions, poll whether the result has arrived, or implement timeouts.</p>
<p>When combining threads and asyncio, remember to make sure that <em>all</em> interfacing with the event loop from other threads (even to call something as simple as <a href="https://docs.python.org/3.7/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.stop" rel="nofollow noreferrer"><code>loop.stop</code></a> to implement <code>Network.stop</code>) is done using <a href="https://docs.python.org/3.7/library/asyncio-eventloop.html?highlight=call_soon_threadsafe#asyncio.AbstractEventLoop.call_soon_threadsafe" rel="nofollow noreferrer"><code>loop.call_soon_threadsafe</code></a> and <code>asyncio.run_coroutine_threadsafe</code>.</p>
</div>
<span class="comment-copy">I'm actually having issues with stopping the thread. The <code>stop</code> method calls a <code>disconnect</code> method on the client which returns a coroutine. As per your suggestion I'm using <code>run_coroutine_threadsafe</code>. But the resulting Future never returns from the <code>result()</code> call. Actually, the <code>disconnect</code> method never seems to be called.</span>
<span class="comment-copy">@harm I'm not sure I'm following you 100%, but if <code>stop</code> calls <code>disconnect</code>, then it should await it. If it failed to do so, you would observe the effect of <code>disconnect</code> never being called.</span>
<span class="comment-copy">I think that is exactly my problem. Using the usual <code>run_until_complete</code> however throws a <code>RuntimeError: This event loop is already running</code> error. This makes sort of sense but I don't know how else I can wait for the coro to finish.</span>
<span class="comment-copy">I believe this call should also be a <code>run_coroutine_threadsafe</code>. But what ever I seem to do the subsequent call to <code>result(&lt;some-time-out&gt;)</code> always times out.</span>
<span class="comment-copy">@harm A minimal reproducible example would help with narrowing down the actual problem.</span>
