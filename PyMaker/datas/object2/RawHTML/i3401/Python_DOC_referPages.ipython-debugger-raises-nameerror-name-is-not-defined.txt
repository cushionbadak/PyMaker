<div class="post-text" itemprop="text">
<p>I can't understand the following exception that is raised in this Python debugger session:</p>
<pre><code>(Pdb) p [move for move in move_values if move[0] == max_value]
*** NameError: name 'max_value' is not defined
(Pdb) [move for move in move_values]
[(0.5, (0, 0)), (0.5, (0, 1)), (0.5, (0, 2)), (0.5, (1, 0)), (0.5, (1, 1)), (0.5, (1, 2)), (0.5, (2, 0)), (0.5, (2, 1)), (0.5, (2, 2))]
(Pdb) max_value
0.5
(Pdb) (0.5, (0, 2))[0] == max_value
True
(Pdb) [move for move in move_values if move[0] == 0.5]
[(0.5, (0, 0)), (0.5, (0, 1)), (0.5, (0, 2)), (0.5, (1, 0)), (0.5, (1, 1)), (0.5, (1, 2)), (0.5, (2, 0)), (0.5, (2, 1)), (0.5, (2, 2))]
(Pdb) [move for move in move_values if move[0] == max_value]
*** NameError: name 'max_value' is not defined
</code></pre>
<p>Why is it sometimes telling me <code>max_value</code> is not defined and other times not?</p>
<p>Incidentally, this is the code immediately prior to the debugger starting:</p>
<pre><code>max_value = max(move_values)[0]
best_moves = [move for move in move_values if move[0] == max_value]
import pdb; pdb.set_trace()
</code></pre>
<p>I am using Python 3.6 running in PyCharm.</p>
<p><strong>AMENDED UPDATE:</strong></p>
<p>After more testing it appears that local variables are not visible within list comprehensions within a <code>pdb</code> session when I do the following from an iPython REPL or in PyCharm:</p>
<pre><code>$ ipython
Python 3.6.5 | packaged by conda-forge | (default, Apr  6 2018, 13:44:09) 
Type 'copyright', 'credits' or 'license' for more information
IPython 6.4.0 -- An enhanced Interactive Python. Type '?' for help.

In [1]: import pdb; pdb.set_trace()
--Call--
&gt; /Users/billtubbs/anaconda/envs/py36/lib/python3.6/site-packages/IPython/core/displayhook.py(247)__call__()
-&gt; def __call__(self, result=None):
(Pdb) x = 1; [x for i in range(3)]
*** NameError: name 'x' is not defined
</code></pre>
<p>But in a regular Python REPL it works:</p>
<pre><code>$ python
Python 3.6.5 | packaged by conda-forge | (default, Apr  6 2018, 13:44:09) 
[GCC 4.2.1 Compatible Apple LLVM 6.1.0 (clang-602.0.53)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import pdb; pdb.set_trace()
--Return--
&gt; &lt;stdin&gt;(1)&lt;module&gt;()-&gt;None
(Pdb) x = 1; [x for i in range(3)]
[1, 1, 1]
</code></pre>
<p>I tested above with versions 3.4, 3.5, 3.6 so it does not appear to be version dependent.</p>
<p><strong>UPDATE 2</strong></p>
<p>Please note, the above test ('AMENDED UPDATE') is problematic because it uses <code>import pdb; pdb.set_trace()</code> in the interactive REPL.  </p>
<p>Also, the original problem is not limited to iPython.</p>
<p>See <a href="https://stackoverflow.com/a/54338006/1609514">answer by user2357112</a> below for a comprehensive explanation of what is going on here.</p>
<p>Sorry if I caused any confusion!</p>
</div>
<div class="post-text" itemprop="text">
<p>You've got two core problems here. The first is that (when calling <code>pdb.set_trace()</code> interactively in IPython) you're debugging IPython's guts instead of the scope you wanted. The second is that list comprehension scoping rules interact badly with cases where the variables present in enclosing scopes can't be determined statically, such as in debuggers or <a href="https://stackoverflow.com/questions/13905741/accessing-class-variables-from-a-list-comprehension-in-the-class-definition">class bodies</a>.</p>
<p>The first problem pretty much only happens when typing <code>pdb.set_trace()</code> into an IPython interactive prompt, which isn't a very useful thing to do, so the simplest way to avoid the problem is to just not do that. If you want to do it anyway, you can enter the <code>r</code> command a few times until pdb says you're out of IPython's guts. (Don't overshoot, or you'll end up in a different part of IPython's guts.)</p>
<p>The second problem is an essentially unavoidable interaction of heavily entrenched language design decisions. Unfortunately, it's unlikely to go away. List comprehensions in a debugger only work in a global scope, not while debugging a function. If you want to build a list while debugging a function, the easiest way is probably to use the <code>interact</code> command and write a <code>for</code> loop.</p>
<hr/>
<p>Here's the full combination of effects going into this.</p>
<ol>
<li><code>pdb.set_trace()</code> triggers pdb on the next <em>trace event</em>, not at the point where <code>pdb.set_trace()</code> is called.</li>
</ol>
<p>The <a href="https://docs.python.org/3/library/sys.html#sys.settrace" rel="nofollow noreferrer">trace function</a> mechanism used by pdb and other Python debuggers only triggers on certain specific events, and "when a trace function is set" is unfortunately not one of those events. Normally, the next event is either a <code>'line'</code> event for the next line or a <code>'return'</code> event for the end of the current code object's execution, but that's not what happens here.</p>
<ol start="2">
<li>IPython sets a <a href="https://docs.python.org/3/library/sys.html#sys.displayhook" rel="nofollow noreferrer"><em>displayhook</em></a> to customize expression statement handling.</li>
</ol>
<p>The mechanism Python uses to display the result of expression statements is <code>sys.displayhook</code>. When you do <code>1+2</code> at the interactive prompt:</p>
<pre><code>&gt;&gt;&gt; 1+2
3
</code></pre>
<p><code>sys.displayhook</code> is what prints the <code>3</code> instead of discarding it. It also sets <code>_</code>. When the result of an expression statement is <code>None</code>, such as with the expression <code>pdb.set_trace()</code>, <code>sys.displayhook</code> does nothing, but it's still called.</p>
<p>IPython replaces <code>sys.displayhook</code> with its own custom handler, responsible for printing the <code>Out[n]:</code> thingy, for setting entries in the <code>Out</code> record, for calling IPython custom pretty-printing, and for all sorts of other IPython conveniences. For our purposes, the important thing is that IPython's displayhook is written in Python, so the next trace event is a <code>'call'</code> event for the displayhook.</p>
<p>pdb starts debugging <strong>inside IPython's displayhook</strong>.</p>
<pre><code>In [1]: import pdb; pdb.set_trace()
--Call--
&gt; /Users/billtubbs/anaconda/envs/py36/lib/python3.6/site-packages/IPython/core/displayhook.py(247)__call__()
-&gt; def __call__(self, result=None):
</code></pre>
<ol start="3">
<li>List comprehensions create a new scope.</li>
</ol>
<p>People didn't like how list comprehensions leaked the loop variable into the containing scope in Python 2, so list comprehensions get their own scope in Python 3.</p>
<ol start="4">
<li>pdb uses <code>eval</code>, which interacts really poorly with closure variables.</li>
</ol>
<p>Python's closure variable mechanism relies on static scope analysis that's completely incompatible with how <code>eval</code> works. Thus, new scopes created inside <code>eval</code> have no access to closure variables; they can only access globals.</p>
<hr/>
<p>Putting it all together, in IPython, you end up debugging the IPython displayhook instead of the scope you're running interactive code in. Since you're inside IPython's displayhook, your <code>x = 1</code> assignment goes into the displayhook's locals. The subsequent list comprehension would need access to the displayhook's locals to access <code>x</code>, but that would be a closure variable to the list comprehension, which doesn't work with <code>eval</code>.</p>
<p>Outside of IPython, <code>sys.displayhook</code> is written in C, so pdb can't enter it, and there's no <code>'call'</code> event for it. You end up debugging the scope you intended to debug. Since you're in a global scope, <code>x = 1</code> goes in globals, and the list comprehension can access it.</p>
<p>You would have seen the same effect if you tried to run <code>x = 1; [x for i in range(3)]</code> while debugging any ordinary function.</p>
</div>
<span class="comment-copy">Can you try running <code>globals()</code> and <code>locals()</code> to see what variables are defined in your scope?</span>
<span class="comment-copy">Output of <code>globals()</code> and <code>locals()</code> is <a href="https://textuploader.com/dzxx7" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">I found <a href="https://bugs.python.org/issue21161" rel="nofollow noreferrer">this issue</a> from 2014 in Python bug tracker with status "closed" and resolution "wont fix" whatever that means.</span>
<span class="comment-copy">This sounds like a bug in the iPython and/or Pycharm interface to Python. I'd add those tags and remove nameerror. One more reason why raw Python is the way to go!</span>
<span class="comment-copy">This issue was raised in 2014 <a href="https://github.com/inducer/pudb/issues/103" rel="nofollow noreferrer">here</a> but it does not appear as though there is a solution yet...</span>
<span class="comment-copy">Note that the original problem occurred when set_trace was called in a script or maybe a Jupyter notebook.  Only in my (admittedly naive) attempt to recreate the error did I use <code>pdb.set_trace</code> in the REPLs.  In any case you may be right.  Today I can only recreate this error in a REPL using set_trace which is not a real problem.  Thanks.</span>
<span class="comment-copy">Actually I can still recreate this NameError <i>from within a script</i>.  Want me to update the question to show how?</span>
<span class="comment-copy">@Bill: Not quite. <code>x = 1</code> sets a name inside whatever scope you're debugging. If that scope is a non-global scope, the list comprehension can't access it.</span>
<span class="comment-copy">(Incidentally, the contortions the debugger has to go through to support setting local variables from a debug prompt are surprisingly nasty, and there are weird edge cases like assignments undoing themselves after a jump.)</span>
<span class="comment-copy">@Bill: I'd say comprehensions and genexps are the more problematic side of the situation. They cause problems in a debugger regardless of whether you perform assignments from the debug prompt, and they're easier to replace than assignments. Also, <code>[i for i in range(x)]</code> doesn't raise the error because the <code>range(x)</code> is evaluated outside the comprehension's scope. It's kind of weird, but it's useful for early error detection in genexps, and comprehensions share the behavior for consistency.</span>
