<div class="post-text" itemprop="text">
<p>I have a list that look like this :</p>
<pre><code>l=[0.1,0.5,2.1,3.3]
</code></pre>
<p>I want to multiply each of these numbers by consecutive natural numbers and form a list out of it.for instance </p>
<pre><code>newlist=[1*0.1,2*0.5,3*2.1,4*3.3]
</code></pre>
<p>I have the following code:</p>
<pre><code>l=[0.1,0.5,2.1,3.3]
s = np.arange(1,len(l)+1)
np.multiply(l,s)
</code></pre>
<p>Just wondering if there is a method, inbuilt or otherwise, in which I don't have to define s.</p>
<p>T
Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps the most "native" way this can be done is by making sure <code>l</code> is a numpy array, then:</p>
<pre><code>import numpy as np

l = np.array([0.1, 0.5, 2.1, 3.3])
print(l * range(1, len(l) + 1))
# array([ 0.1,  1. ,  6.3, 13.2])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a>, <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count</code></a> and <a href="https://docs.python.org/3/library/operator.html#operator.mul" rel="nofollow noreferrer"><code>operator.mul</code></a>:</p>
<pre><code>import operator
import itertools

l=[0.1,0.5,2.1,3.3]
res = list(map(operator.mul, l, itertools.count(1)))
</code></pre>
<p>Here you have a <a href="https://repl.it/repls/OrneryTediousChief" rel="nofollow noreferrer">live example</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I think a simple python list comprehension can be efficient for your problem.</p>
<pre><code>&gt;&gt;&gt; l=[0.1,0.5,2.1,3.3]
&gt;&gt;&gt; l
[0.1, 0.5, 2.1, 3.3]
&gt;&gt;&gt; ll = [item * val for item, val in zip(l, range(1, len(l) + 1))]
&gt;&gt;&gt; ll
[0.1, 1.0, 6.300000000000001, 13.2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are probably many ways to do this:</p>
<pre><code>[a*b for a,b in zip(l,range(1,1+len(l)))]
</code></pre>
</div>
<span class="comment-copy">Why you are not satisfied with your approach? It's just one command after all!</span>
<span class="comment-copy">just <code>l*s</code> is good</span>
<span class="comment-copy">how can that be more "in-built" than a simple operator?</span>
<span class="comment-copy">@Tapasya.A you should update your question with that comment (and the answer would be no)</span>
<span class="comment-copy">You will always have to define <code>s</code>, but you don't have to do it as explicit as you are doing it: <code>l * range(1, len(l) + 1)</code>. Just make sure <code>l</code> is a numpy array</span>
<span class="comment-copy">why the downvoting?</span>
<span class="comment-copy">I believe OPs code already has better performance, especially for longer inputs since they are taking advantage of <code>numpy</code>'s vectorization</span>
<span class="comment-copy"><b>Just wondering if there is an inbuilt function?</b> OP asking...</span>
<span class="comment-copy">Ok then, OP can simply use <code>l * s</code> which is still 'bulit-in` <i>and</i> more perofrmant</span>
<span class="comment-copy">ok, then add that as a answer if you feel so ;)</span>
