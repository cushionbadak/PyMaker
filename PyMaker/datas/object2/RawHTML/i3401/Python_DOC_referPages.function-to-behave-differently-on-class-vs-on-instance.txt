<div class="post-text" itemprop="text">
<p>I'd like a particular function to be callable as a classmethod, and to behave differently when it's called on an instance. </p>
<p>For example, if I have a <code>class Thing</code>, I want <code>Thing.get_other_thing()</code> to work, but also <code>thing = Thing(); thing.get_other_thing()</code> to behave differently.</p>
<p>I think overwriting the <code>get_other_thing</code> method on initialization should work (see below), but that seems a bit hacky.  Is there a better way?</p>
<pre><code>class Thing:

    def __init__(self):
        self.get_other_thing = self._get_other_thing_inst()

    @classmethod
    def get_other_thing(cls):
        # do something...

    def _get_other_thing_inst(self):
        # do something else
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Great question! What you seek can be easily done using <em>descriptors</em>.</p>
<p><strong><a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">Descriptors</a></strong> are Python objects which implement the <em>descriptor protocol</em>, usually starting with <code>__get__()</code>.</p>
<p>They exist, mostly, to be set as a class attribute on different classes. Upon accessing them, their <code>__get__()</code> method is called, with the instance and owner class passed in.</p>
<pre><code>class DifferentFunc:
    """Deploys a different function accroding to attribute access

    I am a descriptor.
    """

    def __init__(self, clsfunc, instfunc):
        # Set our functions
        self.clsfunc = clsfunc
        self.instfunc = instfunc

    def __get__(self, inst, owner):
        # Accessed from class
        if inst is None:
            return self.clsfunc.__get__(None, owner)

        # Accessed from instance
        return self.instfunc.__get__(inst, owner)


class Test:
    @classmethod
    def _get_other_thing(cls):
        print("Accessed through class")

    def _get_other_thing_inst(inst):
        print("Accessed through instance")

    get_other_thing = DifferentFunc(_get_other_thing,
                                    _get_other_thing_inst)
</code></pre>
<p>And now for the result:</p>
<pre><code>&gt;&gt;&gt; Test.get_other_thing()
Accessed through class
&gt;&gt;&gt; Test().get_other_thing()
Accessed through instance
</code></pre>
<p>That was easy!</p>
<p>By the way, did you notice me using <code>__get__</code> on the class and instance function? Guess what? Functions are also descriptors, and that's the way they work!</p>
<pre><code>&gt;&gt;&gt; def func(self):
...   pass
...
&gt;&gt;&gt; func.__get__(object(), object)
&lt;bound method func of &lt;object object at 0x000000000046E100&gt;&gt;
</code></pre>
<p>Upon accessing a function attribute, it's <code>__get__</code> is called, and that's how you get function binding.</p>
<p>For more information, I highly suggest reading the <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">Python manual</a> and the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">"How-To"</a> linked above. Descriptors are one of Python's most powerful features and are barely even known.</p>
<hr/>
<h2>Why not set the function on instantiation?</h2>
<p>Or <strong>Why not set <code>self.func = self._func</code> inside <code>__init__</code>?</strong></p>
<p>Setting the function on instantiation comes with quite a few problems:</p>
<ol>
<li><code>self.func = self._func</code>causes a circular reference. The instance is stored inside the function object returned by <code>self._func</code>. This on the other hand is stored upon the instance during the assignment. The end result is that the instance references itself and will clean up in a much slower and heavier manner.</li>
<li>Other code interacting with your class might attempt to take the function straight out of the class, and use <code>__get__()</code>, which is the usual expected method, to bind it. They will receive the wrong function.</li>
<li>Will not work with <code>__slots__</code>.</li>
<li>Although with descriptors you need to understand the mechanism, setting it on <code>__init__</code> isn't as clean and requires setting multiple functions on <code>__init__</code>.</li>
<li>Takes more memory. Instead of storing one single function, you store a bound function for each and every instance.</li>
<li>Will not work with <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">properties</a>.</li>
</ol>
<p>There are many more that I didn't add as the list goes on and on.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a bit hacky solution:</p>
<pre><code>class Thing(object):
    @staticmethod
    def get_other_thing():
        return 1

    def __getattribute__(self, name):
        if name == 'get_other_thing':
            return lambda: 2
        return super(Thing, self).__getattribute__(name)

print Thing.get_other_thing()  # 1
print Thing().get_other_thing()  # 2
</code></pre>
<p>If we are on class, staticmethod is executed. If we are on instance, <code>__getattribute__</code> is first to be executed, so we can return not <code>Thing.get_other_thing</code> but some other function (<code>lambda</code> in my case)</p>
</div>
<span class="comment-copy">Isn't this what we use inheritance for. Define a separate class with your new method - which inherits from parent class, then by scope, instance will return methods from it's class definition; if not found in its definition it will go to parent class.</span>
<span class="comment-copy">@Poppinyoshi that's two different classes.  I could also create two different classes without inheritance to solve the problem... or I could create different functions in the same class and call them separately.  But that's not what I'm asking.</span>
<span class="comment-copy">Descriptors pass whether or not they're on an instance, but that takes a bit more code.</span>
<span class="comment-copy">I wrote an answer for this that I thought was cleaner than yours and then realized that it was just what you had done. I think what you have is cleaner than overriding <code>__getattribute__</code>, and I can't think of a better way</span>
<span class="comment-copy">Awesome, thanks for the details description and explanations!  Do you see any particular benefit to this approach over resetting the function on instantiation?</span>
<span class="comment-copy">@DilithiumMatrix That's another good one! I really like your questions mate. Resetting the function on instantiation causes a circular reference, is unexpected when invoking <code>__get__</code> externally, doesn't behave as well with other code that expect the function to act normally and all sorts of other pitfalls.</span>
<span class="comment-copy">@DilithiumMatrix See for my edit.</span>
<span class="comment-copy">Ha, very hacky (and I think hackier than mine), but also very clever.  Thanks!</span>
