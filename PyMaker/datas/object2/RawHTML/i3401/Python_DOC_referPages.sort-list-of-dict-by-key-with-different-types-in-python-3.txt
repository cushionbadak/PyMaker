<div class="post-text" itemprop="text">
<p>I have a method that group a list of dict by a key. To do it I found <a href="https://stackoverflow.com/a/16176538/8160995">here</a> that I have to use the <code>groupby</code> function but before I have to sort the list. Here is my method right now:</p>
<pre><code>def group_list_by_key(data, key):
    data.sort(key=lambda x: x[key])
    result = []
    for k, v in groupby(data, key=lambda x: x[key]):
        result.append(list(v))
    return result
</code></pre>
<p>This piece of code works only if every key is defined in all the dicts and the values are all of the same type. However, where I use this method I don't know if the key is defined everywhere and if they are of the same type. On Python 2.x I know that exists <a href="https://docs.python.org/2.7/library/functions.html?highlight=sorted#sorted" rel="nofollow noreferrer"><code>sorted</code></a> function with <code>cmp</code> parameter that could do a custom sort but from <a href="https://docs.python.org/3/whatsnew/3.0.html#ordering-comparisons" rel="nofollow noreferrer">Python 3.x</a> this isn't possible anymore. Is there a way to make a custom sort? I am thinking about use the classic sort by <code>&lt;</code> and sorting also by typename. </p>
<p>By now I thought about use the get function and cast to string in the sort like</p>
<pre><code>data.sort(key=lambda x: str(x.get(key)))
...
for k, v in groupby(data, key=lambda x: x.get(key)):
</code></pre>
<p>It only overcomes in case of string, numeric and None content but not a generic object and it breaks easily if for example I execute</p>
<pre><code>a = [{'b': 0, 'c': 1}, {'b': '0'}, {'b': 0, 'c': 2}, {'b': 1}, {'c': 3}]
group_list_by_key(a, 'b')
</code></pre>
<p>The output is</p>
<pre><code>[[{'b': 0, 'c': 1}], [{'b': '0'}], [{'b': 0, 'c': 2}], [{'b': 1}], [{'c': 3}]]
</code></pre>
<p>instead of what I expect should be (order of lists is not a problem)</p>
<pre><code>[[{'b': 0, 'c': 1}, {'b': 0, 'c': 2}], [{'b': '0'}], [{'b': 1}], [{'c': 3}]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can solve your problem by doing something like this</p>
<pre><code>data = [{'b': 0, 'c': 1}, {'b': '0'}, {'b': 0, 'c': 2}, {'b': 1}, {'c': 3}]
key='b'

def f(x):
     ret = x.get(key, -1)
     return ret if type(ret) == int else -2

result = [list(v) for k, v in groupby(sorted(data, key=f), f)]

# result: [[{'b': '0'}], [{'c': 3}], [{'b': 0, 'c': 1}, {'b': 0, 'c': 2}], [{'b': 1}]]
</code></pre>
<p>But if you still need a custom comparison function, you can do it using <a href="https://docs.python.org/3/library/functools.html#functools.cmp_to_key" rel="nofollow noreferrer">functools.cmp_to_key</a></p>
<pre><code>import functools
sorted(x, key=functools.cmp_to_key(custom_cmp_function))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to @Sunitha and @njzk2 for pointing out the <a href="https://docs.python.org/3/library/functools.html#functools.cmp_to_key" rel="nofollow noreferrer">cmp_to_key</a> function, it did totally what I wanted. So, my grouping now is:</p>
<pre><code>from functools import cmp_to_key
from itertools import groupby

def group_list_by_key(data, key):
    def compare_values_types(a, b):
        a = a.get(key)
        b = b.get(key)
        if a.__class__ == b.__class__:
            if a &lt; b:
                return -1
            elif a &gt; b:
                return 1
            else:
                return 0
        else:
            if a.__class__.__name__ &lt; b.__class__.__name__:
                return -1
            elif a.__class__.__name__ &gt; b.__class__.__name__:
                return 1
            else:
                return 0
    data.sort(key=cmp_to_key(compare_values_types))
    return [list(v) for k, v in groupby(data, key=lambda x: x.get(key))]
</code></pre>
<p>Calling on the sample list</p>
<pre><code>a = [{'b': 0, 'c': 1}, {'b': '0'}, {'b': 0, 'c': 2}, {'b': 1}, {'c': 3}]
group_list_by_key(a, 'b')
</code></pre>
<p>It returns the expected list</p>
<pre><code>[[{'c': 3}], [{'b': 0, 'c': 1}, {'b': 0, 'c': 2}], [{'b': 1}], [{'b': '0'}]]
</code></pre>
<p>What I did is to compare in the classic way the keys of the same type, otherwise I simply do a string comparison between the classes' names (using <code>a.__class__.__name__</code> instead of <code>type(a).__name__</code>, check out to this <a href="https://stackoverflow.com/a/5008854/8160995">answer</a>).
Thanks to all!</p>
</div>
<span class="comment-copy">Can you provide a sample input and expected output ?</span>
<span class="comment-copy">doc says "Use functools.cmp_to_key() to convert an old-style cmp function to a key function." so cmp not being available in python3 is not really a problem</span>
<span class="comment-copy">You might want to just clean up your data. Rather than trying to compare <code>0</code> with <code>'0'</code>, you should convert one to the other (e.g. by calling <code>int</code> on them both, perhaps).</span>
<span class="comment-copy">@RafaelC I have added a sample expected output on the last input I wrote before</span>
<span class="comment-copy">For whatever it is worth to you, <a href="https://www.python.org/dev/peps/pep-0008/?#programming-recommendations" rel="nofollow noreferrer">PEP 8</a> recommends "Always use a def statement instead of an assignment statement that binds a lambda expression directly to an identifier."</span>
<span class="comment-copy">Thank you, your answer is partially good because <code>0</code>, <code>'0'</code> and <code>None</code> are grouped that it's wrong</span>
<span class="comment-copy">@Ripper346.. I miunderstood your requirements. I have updated the answer. Can you check if this is what you wanted?</span>
<span class="comment-copy">@Sunitha I am thinking about a use of your code with generic classes instead of only int, str and None, like datetime, custom classes, etc. Do you think that your function could afford it? In any case, your answer is correct and also more fancy than my solution</span>
<span class="comment-copy">Yes.. You should be able to easily extend the function <code>f</code> as per you need. All you have to do is to check for the type of <code>ret</code> and return a unique value</span>
