<div class="post-text" itemprop="text">
<p>I have 3 NumPy arrays, and I want to create tuples of the i-th element of each list. These tuples represent keys for a dictionary I had previously defined.</p>
<p>Ex:</p>
<pre><code>List 1: [1, 2, 3, 4, 5]

List 2: [6, 7, 8, 9, 10]

List 3: [11, 12, 13, 14, 15]

Desired output: [mydict[(1,6,11)],mydict[(2,7,12)],mydict[(3,8,13)],mydict[(4,9,14)],mydict[(5,10,15)]]
</code></pre>
<p>These tuples represent keys of a dictionary I have previously defined (essentially, as input variables to a previously calculated function). I had read that this is the best way to store function values for lookup.</p>
<p>My current method of doing this is as follows:</p>
<pre><code>[dict[x] for x in zip(l1, l2, l3)]
</code></pre>
<p>This works, but is obviously slow. Is there a way to vectorize this operation, or make it faster in any way? I'm open to changing the way I've stored the function values as well, if that is necessary. </p>
<p>EDIT: My apologies for the question being unclear. I do in fact, have NumPy arrays. My mistake for referring to them as lists and displaying them as such. They are of the same length. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your question is a bit confusing, since you're calling these NumPy arrays, and asking for a way to vectorize things, but then showing lists, and labeling them as lists in your example, and using list in the title. I'm going to assume you do have arrays.</p>
<pre><code>&gt;&gt;&gt; l1 = np.array([1, 2, 3, 4, 5])
&gt;&gt;&gt; l2 = np.array([6, 7, 8, 9, 10])
&gt;&gt;&gt; l3 = np.array([11, 12, 13, 14, 15])
</code></pre>
<p>If so, you can stack these up in a 2D array:</p>
<pre><code>&gt;&gt;&gt; ll = np.stack((l1, l2, l3))
</code></pre>
<p>And then you can just transpose that:</p>
<pre><code>&gt;&gt;&gt; lt = ll.T
</code></pre>
<p>This is better than vectorized; it's constant-time. NumPy is just creating another view of the same data, with different striding so it reads in column order instead of row order.</p>
<pre><code>&gt;&gt;&gt; lt
array([[ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14],
       [ 5, 10, 15]])
</code></pre>
<hr/>
<p>As miradulo points out, you can do both of these in one step with <code>column_stack</code>:</p>
<pre><code>&gt;&gt;&gt; lt = np.column_stack((l1, l2, l3))
</code></pre>
<p>But I suspect you're actually going to want <code>ll</code> as a value in its own right. (Although I admit I'm just guessing here at what you're trying to do…)</p>
<hr/>
<p>And of course if you want to loop over these rows as 1D arrays instead of doing further vectorized work, you can:</p>
<pre><code>&gt;&gt;&gt; for row in lt:
...:     print(row)
[ 1  6 11]
[ 2  7 12]
[ 3  8 13]
[ 4  9 14]
[ 5 10 15]
</code></pre>
<p>Of course, you can convert them from 1D arrays to tuples just by calling <code>tuple</code> on each row. Or… whatever that <code>mydict</code> is supposed to be (it doesn't look like a dictionary—there's no key-value pairs, just values), you can do that.</p>
<pre><code>&gt;&gt;&gt; mydict = collections.namedtuple('mydict', list('abc'))
&gt;&gt;&gt; tups = [mydict(*row) for row in lt]
&gt;&gt;&gt; tups
[mydict(a=1, b=6, c=11),
 mydict(a=2, b=7, c=12),
 mydict(a=3, b=8, c=13),
 mydict(a=4, b=9, c=14),
 mydict(a=5, b=10, c=15)]
</code></pre>
<hr/>
<p>If you're worried about the time to look up a tuple of keys in a dict, <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>itemgetter</code></a> in the <code>operator</code> module has a C-accelerated version. If <code>keys</code> is a <code>np.array</code>, or a <code>tuple</code>, or whatever, you can do this:</p>
<pre><code>for row in lt:
    myvals = operator.itemgetter(*row)(mydict)
    # do stuff with myvals
</code></pre>
<p>Meanwhile, I decided to slap together a C extension that should be as fast as possible (with no error handling, because <s>I'm lazy</s> it should be a tiny bit faster that way—this code will probably segfault if you give it anything but a dict and a tuple or list):</p>
<pre><code>static PyObject *
itemget_itemget(PyObject *self, PyObject *args) {
  PyObject *d;
  PyObject *keys;
  PyArg_ParseTuple(args, "OO", &amp;d, &amp;keys);    
  PyObject *seq = PySequence_Fast(keys, "keys must be an iterable");
  PyObject **arr = PySequence_Fast_ITEMS(seq);
  int seqlen = PySequence_Fast_GET_SIZE(seq);
  PyObject *result = PyTuple_New(seqlen);
  PyObject **resarr = PySequence_Fast_ITEMS(result);
  for (int i=0; i!=seqlen; ++i) {
    resarr[i] = PyDict_GetItem(d, arr[i]);
    Py_INCREF(resarr[i]);    
  }
  return result;
}
</code></pre>
<p>Times for looking up 100 random keys out of a 10000-key dictionary on my laptop with python.org CPython 3.7 on macOS:</p>
<ul>
<li><code>itemget.itemget</code>: 1.6µs</li>
<li><code>operator.itemgetter</code>: 1.8µs</li>
<li>comprehension:  3.4µs</li>
<li>pure-Python <code>operator.itemgetter</code>: 6.7µs</li>
</ul>
<p>So, I'm pretty sure anything you do is going to be fast enough—that's only 34ns/key that we're trying to optimize. But if that really is too slow, <code>operator.itemgetter</code> does a good enough job moving the loop to C and cuts it roughly in half, which is pretty close to the best possibly result you could expect. (It's hard to imagine looping up a bunch of boxed-value keys in a hash table in much less than 16ns/key, after all.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Define your 3 lists. You mention 3 arrays, but show lists (and call them that as well):</p>
<pre><code>In [112]: list1,list2,list3 = list(range(1,6)),list(range(6,11)),list(range(11,16))
</code></pre>
<p>Now create a dictionary with tuple keys:</p>
<pre><code>In [114]: dd = {x:i for i,x in enumerate(zip(list1,list2,list3))}
In [115]: dd
Out[115]: {(1, 6, 11): 0, (2, 7, 12): 1, (3, 8, 13): 2, (4, 9, 14): 3, (5, 10, 15): 4}
</code></pre>
<p>Accessing elements from that dictionary with your code:</p>
<pre><code>In [116]: [dd[x] for x in zip(list1,list2,list3)]
Out[116]: [0, 1, 2, 3, 4]
In [117]: timeit [dd[x] for x in zip(list1,list2,list3)]
1.62 µs ± 11.2 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
<p>Now for an array equivalent - turn the lists into a 2d array:</p>
<pre><code>In [118]: arr = np.array((list1,list2,list3))
In [119]: arr
Out[119]: 
array([[ 1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10],
       [11, 12, 13, 14, 15]])
</code></pre>
<p>Access the same dictionary elements.  If I used <code>column_stack</code> I could have omitted the <code>.T</code>, but that's slower.  (array transpose is fast)</p>
<pre><code>In [120]: [dd[tuple(x)] for x in arr.T]
Out[120]: [0, 1, 2, 3, 4]
In [121]: timeit [dd[tuple(x)] for x in arr.T]
15.7 µs ± 21.2 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p>Notice that this is substantially slower.  Iteration over an array is slower than iteration over a list.   You can't access elements of a dictionary in any sort of numpy 'vectorized' fashion - you have to use a Python iteration.</p>
<p>I can improve on the array iteration by first turning it into a list:</p>
<pre><code>In [124]: arr.T.tolist()
Out[124]: [[1, 6, 11], [2, 7, 12], [3, 8, 13], [4, 9, 14], [5, 10, 15]]
In [125]: timeit [dd[tuple(x)] for x in arr.T.tolist()]
3.21 µs ± 9.67 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<hr/>
<p>Array construction times:</p>
<pre><code>In [122]: timeit arr = np.array((list1,list2,list3))
3.54 µs ± 15.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
In [123]: timeit arr = np.column_stack((list1,list2,list3))
18.5 µs ± 11.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<hr/>
<p>With the pure Python <code>itemgetter</code> (from v3.6.3) there's no savings:</p>
<pre><code>In [149]: timeit operator.itemgetter(*[tuple(x) for x in arr.T.tolist()])(dd)
3.51 µs ± 16.7 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p>and if I move the getter definition out of the time loop:</p>
<pre><code>In [151]: %%timeit idx = operator.itemgetter(*[tuple(x) for x in arr.T.tolist()]
     ...: )
     ...: idx(dd)
     ...: 
482 ns ± 1.85 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
</div>
<span class="comment-copy">length of list1,2,3 is always same?</span>
<span class="comment-copy">Do you have lists or NumPy arrays? Also, if you're trying to create tuples, why are you creating dicts? Also, what kind of thing is <code>mydict[(1,6,11)]</code> supposed to actually be?</span>
<span class="comment-copy">Anyway, if these <i>are</i> NumPy arrays, just stack them together into one 2D array, then transpose the array. This takes constant time—it's just making a new view of the same data with different striding.</span>
<span class="comment-copy">Can you post a working example? It should be easy to dummy up some small arrays.</span>
<span class="comment-copy">Why do you think that's unnecessarily slow?  You can only index a dictionary one key at a time.  <code>zip()</code> is a standard way of 'transposing` a list of lists.</span>
<span class="comment-copy">@miradulo Yeah, I was assuming <code>ll</code> would be something the OP actually wants to have around, and <code>lt</code> would be something just used for some one-shot process and tossed… but that's a complete wild guess based on almost nothing, so I've edited the answer.</span>
