<div class="post-text" itemprop="text">
<p>I want to make a set of tuples in which the order of tuples shouldn't matter.
For eg.- If the tuples I want to add is :</p>
<pre><code>[(1,2),(1,3),(2,1)]
</code></pre>
<p>It should output like this:</p>
<pre><code>{(1,2),(1,3)}
</code></pre>
<p>Is there any efficient way of doing this in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can apply <code>sorted</code> and then <code>tuple</code>, followed by conversion to <code>set</code>:</p>
<pre><code>res = set(map(tuple, map(sorted, L)))

print(res)

{(1, 2), (1, 3)}
</code></pre>
<p><strong>Explanation</strong></p>
<p>There are a couple of good reasons why you should not convert each tuple to <code>set</code> as an initial step:</p>
<ol>
<li>Tuples <code>(1, 1, 2)</code> and <code>(1, 2)</code> would become equal after conversion to <code>set</code>.</li>
<li>Even in the case where we are considering tuples of length 2, we would be adding an assumption that <code>tuple({(1, 2)})</code> and <code>tuple({(2, 1)})</code> are equal. While this may be true, it would be considered an implementation detail, since <code>set</code> is considered to be unordered.</li>
</ol>
<p><strong>Function composition</strong></p>
<p>Function composition is not native to Python, but if you have access to the 3rd party <a href="https://toolz.readthedocs.io/en/latest/#" rel="nofollow noreferrer"><code>toolz</code></a> library you can avoid nested <code>map</code>:</p>
<pre><code>from toolz import compose

tup_sort = compose(tuple, sorted)

res = set(map(tup_sort, L))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can sort the tuples:</p>
<pre><code>l = [(1,2),(1,3),(2,1)]
res = set(map(lambda x: tuple(sorted(x)), l))
print(res)
{(1, 2), (1, 3)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The other answers all work! I'm just going to post mine here because I'm a beginner and I love to practice. </p>
<pre><code>mainSet = set()
l = [(1,2),(1,3),(2,1)]

for i in l:

    if tuple(sorted(i)) not in mainSet:

        mainSet.add(tuple(sorted(i)))

print(mainSet)
</code></pre>
<p>Gives back</p>
<p><code>{(1, 2), (1, 3)}</code></p>
<p>Whether you want to use this or not is up to you! The other answers are much more shorter.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use comprehension, too:</p>
<pre><code>l=[(1, 2), (1, 3), (2, 1)]
res={ tuple(sorted(t)) for t in l }
print(res)
{(1, 2), (1, 3)}
</code></pre>
</div>
<span class="comment-copy">Turn the tuples into <a href="https://docs.python.org/3/library/functions.html#func-frozenset" rel="nofollow noreferrer"><code>frozensets</code></a>?</span>
<span class="comment-copy">@Aran-Fey the problem with that is if the tuples have repetitions like  <code>l = [(1,1,2),(2,1,1)]</code> then the tuples itself would be changed as frozen sets(and normal sets) do not allow repetition</span>
<span class="comment-copy">may I ask why you remove the other solution with just sets? actually i tought that would be better</span>
<span class="comment-copy">@Netwave, So using <code>set</code> then <code>tuple</code> assumes <code>{1, 2}</code> converted to a tuple will always give <code>(1, 2)</code>. While this <i>may</i> be true, it should not be assumed as sets are unordered. If sets were <i>randomly</i> ordered, you could have one <code>{1, 2}</code> set give <code>(1, 2)</code> and another give <code>(2, 1)</code>. Using <code>sorted</code> + <code>tuple</code> has one less assumption.</span>
<span class="comment-copy">aaah, ok, I get It know, thanks!</span>
<span class="comment-copy">@Netwave i think the best reason <i>not</i> to use sets (or frozensets) here is that duplicates are removed e.g. <code>{1,2,2} == {1,2}</code></span>
<span class="comment-copy">@Chris_Rands, that is another good reason indeed</span>
