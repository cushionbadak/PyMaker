<div class="post-text" itemprop="text">
<p>In Python, is there a good way to iterate through lists of different lengths?</p>
<p>For example,</p>
<pre><code>a = [1,2,3]

b=[4,5]

c = [a,b]

for val1, val2, val3 in c:

  print val1
  print val2
  print val3
</code></pre>
<p>Assuming that the list will have at least 2 values, and in some list, 3rd value is optional. The above <code>for</code> loop didn't work for b, obviously, that val3 is not available for list 'b'. In that case, I want to print the val3 as 0. Can I give a default value in case of unavailability? </p>
<pre><code>for val1, val2, val3=0 in c:
</code></pre>
<p>The above syntax didn't work either. Please help.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to be fancy ("elegant"?), you can pad a given list with zeros:</p>
<pre><code>def pad_list(t, size, default):
    return t + [default] * (size - len(t))

for x in c:
    v1, v2, v3 = pad_list(x, 3, 0)

    print(v1)
    print(v2)
    print(v3)
</code></pre>
<hr/>
<p>Similarly, if you're working with tuples, here's another function:</p>
<pre><code>def pad_list(t, size, default):
    return t + (default,) * (size - len(t))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3.4/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><strong><code>zip_longest</code></strong></a> with <code>fillvalue</code> handling empty slot for this case:</p>
<pre><code>from itertools import zip_longest

a = [1,2,3]
b = [4,5]

l = []
for x, y in zip_longest(a, b, fillvalue=0):
    l.append((x, y))

print(list(zip(*l)))
# [(1, 2, 3), (4, 5, 0)]
</code></pre>
<p>If you need values out of list, just replace last <code>print</code> with:</p>
<pre><code>for val1, val2, val3 in zip(*l):
    print(val1)
    print(val2)
    print(val3)

# 1
# 2                                                           
# 3                                                          
# 4                                                          
# 5                                                          
# 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this is very simple</p>
<pre><code>c = [1,2,3]
val1  , val2  , *val3= [1,2 , 3]
</code></pre>
<blockquote>
<p>val1 = 1 , val2 =3 , val3=[3]</p>
</blockquote>
<pre><code>c=[1,2]
val1  , val2  , *val3= [1,2 , 3]
</code></pre>
<blockquote>
<p>val1 = 1 , val2 =3 , val3=[]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>def foreach(l):
    def deco(f):
        for xs in l:
            f(*xs)
    return deco


@foreach([[1, 2, 3], [4, 5]])
def _(a, b, c=6):
    print(a, b, c, sep='\n')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The simplest method to concatenate the lists is via <a href="http://#%20combines%20lists%20a,%20b,%20and%20c%20in%20order" rel="nofollow noreferrer"><code>chain</code></a> function from the <a href="https://docs.python.org/3/library/itertools.html#module-itertools" rel="nofollow noreferrer"><code>itertools</code></a> module.</p>
<h3>Example Snippet</h3>
<pre><code>import itertools

a = [1, 2, 3, 4, 5, 6]
b = [7, 8, 9, 10, 11, 12]
c = ['A', 'B', 'C', 'D', 'E', 'F', 'U']


combined = itertools.chain( a, b, c ) # combines in order

# enumerate lists to allow for iteration
for index, value in enumerate(combined):
    print(value, end = ' ')
</code></pre>
<h3>Output</h3>
<pre><code>1 2 3 4 5 6 7 8 9 10 11 12 A B C D E F U
</code></pre>
</div>
<span class="comment-copy">More succinctly (and generally), <code>zip(*zip_longest(*c, fillvalue=0))</code> where <code>c = [a, b]</code>. This works with arbitrarily sized <code>c</code>.</span>
