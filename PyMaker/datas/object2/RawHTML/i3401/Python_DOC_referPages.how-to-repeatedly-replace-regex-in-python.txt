<div class="post-text" itemprop="text">
<p>I want to remove dangling attributes of html element.</p>
<p>I use regex <code>re.sub(r'(&lt;[\S]+.*\s)[^=]+[\s]', r'\1', x)</code> to find attributes without <code>=</code>.</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; string_list = ['&lt;tag valid1="o n e" valid2=two some dangling&gt;&lt;/tag&gt;', '&lt;tag valid1="o n e" valid2=two some dangling/&gt;']
&gt;&gt;&gt; map(lambda x: re.sub(r'(&lt;[\S]+.*\s)[^=]+[\s]', r'\1', x), string_list)
['&lt;tag valid1="o n e" valid2=two dangling&gt;&lt;/tag&gt;', '&lt;tag valid1="o n e" valid2=two dangling/&gt;']
</code></pre>
<p>But this only removes the first. How to repeatedly remove all?</p>
</div>
<div class="post-text" itemprop="text">
<p>I choose to use <code>HTMLParser</code> to parse HTML instead of preprocessing HTML and using <code>ElementTree</code> to parse HTML as XML.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>re.findall</code> to tokenize the parts.</p>
<pre><code>import re
string_list = ['&lt;div&gt;\n&lt;tag valid1="o n e" valid2=two some dangling&gt;&lt;/tag&gt;\n&lt;tag valid1="o n e" valid2=two some dangling/&gt;\n&lt;/div&gt;', '&lt;tag valid1="o n e"\n valid2=two some dangling&gt;&lt;/tag&gt;']
for string in string_list:
    output = ''
    for pre, attrs, post in re.findall(r'([^&lt;]*&lt;/?\w+)\b(.*?)(/?&gt;[^&lt;]*)', string, re.DOTALL):
        output += pre + ''.join([attr[0] for attr in re.findall(r'(\s+\w+=(?:([\'"]).*?\2|\S+))|\S+', attrs)]) + post
    print(output)
</code></pre>
<p>This outputs:</p>
<pre><code>&lt;div&gt;
&lt;tag valid1="o n e" valid2=two&gt;&lt;/tag&gt;
&lt;tag valid1="o n e" valid2=two/&gt;
&lt;/div&gt;
&lt;tag valid1="o n e"
 valid2=two&gt;&lt;/tag&gt;
</code></pre>
</div>
<span class="comment-copy">Trying to parse HTML with regexes is extremely fragile. Using an actual HTML parser is much easier and safer.</span>
<span class="comment-copy">@user2357112 I would like to use <code>ElementTree</code> to parse it but it only supports xml, which does not allow dangling attributes. That is why I want to do this.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/html.parser.html" rel="nofollow noreferrer">Python comes with an HTML parser</a>, and projects like <a href="https://www.crummy.com/software/BeautifulSoup/" rel="nofollow noreferrer">BeautifulSoup</a> make data extraction even easier.</span>
<span class="comment-copy">@user2357112 This is not available in 2.7 :(</span>
<span class="comment-copy"><a href="https://docs.python.org/2.7/library/htmlparser.html" rel="nofollow noreferrer">It's just under a different name on 2.7.</a></span>
<span class="comment-copy">That's nice, but how do you implement your solution? It will be fine to know for future readers.</span>
<span class="comment-copy">You can mark your answer as accepted, for anyone who stumbles upon the question in future.</span>
<span class="comment-copy">Not good, I updated sample and your method will break it.</span>
<span class="comment-copy">I've updated my answer accordingly.</span>
<span class="comment-copy"><code>&gt;&lt;/tag&gt;</code> and <code>/&gt;</code> will become <code>&gt;</code></span>
<span class="comment-copy"><code>valid2</code> is missing. Anyway, thanks a lot for patience. I choose to use <code>HTMLParser</code> to reconstruct html for <code>ElementTree</code>.</span>
<span class="comment-copy"><code>string = '&lt;tag valid1="o n e"\n valid2=two some dangling&gt;&lt;/tag&gt;'</code>, producing <code>'tag valid1="o n e"\n valid2=two some dangling&gt;&lt;/tag&gt;'</code>, is incorrect (missing leading <code>&lt;</code>). Never mind. Maybe it is truly not good to manually parse HTML in text level. :)</span>
