<div class="post-text" itemprop="text">
<p>I have a file that looks like this - </p>
<pre><code>Col1      Col2     Key       Value
101       a        f1        abc
101       a        f2        def
102       a        f2        xyz
102       a        f3        fgh
103       b        f1        rst
</code></pre>
<p>and I need output file that looks like: </p>
<pre><code>{"Col1":101, "Col2":"a", "kvpairs":{"f1":"abc","f2":"def"}}
{"Col1":102, "Col2":"a", "kvpairs":{"f2":"xyz","f3":"fgh"}}
{"Col1":103, "Col2":"b", "kvpairs":{"f1":"rst"}}
</code></pre>
<p>I can loop through the file clubbing the key values pairs for the grouping fields  Col1 and Col2 into a list and dropping it into a dict but was hoping there was a more pythonic way of doing it. There are questions answered using pandas aggregation but i can't find a neat (and efficient way) of building that nested map. Also, the source file is gonna be large, like 80m records crunching down to 8m in the resulting file. </p>
<p>I can see those eyes lighting up :) </p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code></a>:</p>
<pre><code>from itertools import groupby

for ((c1,c2),items) in groupby(lines, key=lambda x: x[:2]):
    d = {"Col1": c1, "Col2:": c2, "kvpairs":dict(x[2:] for x in items)}
    print(d)
</code></pre>
<p>Produces:</p>
<pre><code>{'Col1': '101', 'Col2:': 'a', 'kvpairs': {'f1': 'abc', 'f2': 'def'}}
{'Col1': '102', 'Col2:': 'a', 'kvpairs': {'f2': 'xyz', 'f3': 'fgh'}}
{'Col1': '103', 'Col2:': 'b', 'kvpairs': {'f1': 'rst'}}
</code></pre>
<p>It looks like you're parsing some of the values to literals -- the int you can do with <code>int(c1)</code>, but I'm not sure how you want to deal with turning <code>"a"</code> into <code>a</code>.</p>
<p>(Assuming your have a list of iterables, maybe from the <code>csv</code> module:)</p>
<pre><code>lines = [
    ['101','a','f1','abc'],
    ['101','a','f2','def'],
    ['102','a','f2','xyz'],
    ['102','a','f3','fgh'],
    ['103','b','f1','rst']
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>data = []
for col1, col2, key, value in input:

    # look for an existing dict with col1 and col2
    for d in data:
        if d['col1'] == col1  and d['col2'] == col2:
            d['kvpairs'][key] = value
            break

    # no existing dict was found
    else:
        d.append({'col1': col1, 'col2': col2, 'kvpairs': {key: value}})

for d in data:
    print d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>groupby</code> + <code>agg</code> + <code>to_dict</code></p>
<pre><code>df.groupby(["Col1", "Col2"])[["Key", "Value"]].agg(list).transform(lambda x: dict(zip(*x)),1).reset_index(name='kvpairs').to_dict('records')

[{'Col1': 101, 'Col2': 'a', 'kvpairs': {'f1': 'abc', 'f2': 'def'}},
 {'Col1': 102, 'Col2': 'a', 'kvpairs': {'f2': 'xyz', 'f3': 'fgh'}},
 {'Col1': 103, 'Col2': 'b', 'kvpairs': {'f1': 'rst'}}]
</code></pre>
<p>Assuming of course, <code>df</code> is</p>
<pre><code>z = io.StringIO("""Col1      Col2     Key       Value
101       a        f1        abc
101       a        f2        def
102       a        f2        xyz
102       a        f3        fgh
103       b        f1        rst""")

df = pd.read_table(z,delim_whitespace=True)
</code></pre>
<hr/>
<h3><em>Explanation</em></h3>
<p>First you <code>aggregate</code> using <code>list</code></p>
<pre><code>df.groupby(["Col1", "Col2"])[["Key", "Value"]].agg(list)

              Key           Value
Col1    Col2        
101     a    [f1, f2]     [abc, def]
102     a    [f2, f3]     [xyz, fgh]
103     b    [f1]         [rst]
</code></pre>
<p>Then <code>transform</code> this output to dictionaries and rename the axis altogether </p>
<pre><code>.transform(lambda x: dict(zip(*x)),1).reset_index(name='kvpairs')

    Col1    Col2    kvpairs
0   101     a       {'f1': 'abc', 'f2': 'def'}
1   102     a       {'f2': 'xyz', 'f3': 'fgh'}
2   103     b       {'f1': 'rst'}
</code></pre>
<p>Finally, use <code>to_dict('records')</code> to get your list of dictionaries</p>
<pre><code>.to_dict('records')
[{'Col1': 101, 'Col2': 'a', 'kvpairs': {'f1': 'abc', 'f2': 'def'}},
 {'Col1': 102, 'Col2': 'a', 'kvpairs': {'f2': 'xyz', 'f3': 'fgh'}},
 {'Col1': 103, 'Col2': 'b', 'kvpairs': {'f1': 'rst'}}]
</code></pre>
</div>
<span class="comment-copy">Your file is delimited by spaces, not commas, correct?</span>
<span class="comment-copy">Its a CSV actually...</span>
<span class="comment-copy">How can it be Comma Separated Values (csv), when there are no commas?</span>
<span class="comment-copy">Well, the post only showed the structure and contents, it will physically be a CSV</span>
<span class="comment-copy">The main problem here is the memory. How do you suppose you will deal with the memory overflow? Have you thought of using some large data file system HDFS? I propose you figure out what you want to do with the data <i>before</i> you turn it into a dictionary.</span>
