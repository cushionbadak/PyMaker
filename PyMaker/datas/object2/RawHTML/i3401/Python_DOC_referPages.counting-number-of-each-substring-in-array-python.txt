<div class="post-text" itemprop="text">
<p>I have a <code>string</code> array for example <code>[a_text, b_text, ab_text, a_text]</code>. I would like to get the number of objects that contain each prefix such as <code>['a_', 'b_', 'ab_']</code> so the number of <code>'a_'</code> objects would be 2.</p>
<p>so far I've been counting each by filtering the array e.g <code>num_a = len(filter(lambda x: x.startswith('a_'), array))</code>. I'm not sure if this is slower than looping through all the fields and incrementing each counter since I am filtering the array for each prefix I am counting. Are functions such as <code>filter()</code> faster than a for loop? For this scenario I don't need to build the filtered list if I use a for loop so that may make it faster.</p>
<p>Also perhaps instead of the <code>filter</code> I could use list comprehension to make it faster?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <strong><code>collections.Counter</code></strong> with a regular expression (if all of your strings have prefixes):</p>
<pre><code>from collections import Counter

arr = ['a_text', 'b_text', 'ab_text', 'a_text']
Counter([re.match(r'^.*?_', i).group() for i in arr])
</code></pre>
<p>Output:</p>
<pre><code>Counter({'a_': 2, 'b_': 1, 'ab_': 1})
</code></pre>
<hr/>
<p>If not all of your strings have prefixes, this will throw an error, since <code>re.match</code> will return None.  If this is a possibility, just add an extra step:</p>
<pre><code>arr = ['a_text', 'b_text', 'ab_text', 'a_text', 'test']
matches = [re.match(r'^.*?_', i) for i in arr]
Counter([i.group() for i in matches if i])
</code></pre>
<p>Output:</p>
<pre><code>Counter({'a_': 2, 'b_': 1, 'ab_': 1})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way would be to use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict()</code></a> object. You just go over the whole list once and count each prefix as you encounter it by splitting at the underscore. You need to check the underscore exists, else the whole word will be taken as a prefix (otherwise it wouldn't distinguish between <code>'a'</code> and <code>'a_a'</code>).</p>
<pre><code>from collections import defaultdict

array = ['a_text', 'b_text', 'ab_text', 'a_text'] * 250000

def count_prefixes(arr):
    counts = defaultdict(int)
    for item in arr:
        if '_' in item:
            counts[item.split('_')[0] + '_'] += 1
    return counts
</code></pre>
<p>The logic is similar to user3483203's answer, in that all prefixes are calculated in one pass. However, it seems invoking regex methods is a bit slower than simple string operations. But I also have to echo Michael's comment, in that the speed difference is insignificant for even 1 million items.</p>
<pre><code>from timeit import timeit

setup = """
from collections import Counter, defaultdict
import re

array = ['a_text', 'b_text', 'ab_text', 'a_text']

def with_defaultdict(arr):
    counts = defaultdict(int)
    for item in arr:
        if '_' in item:
            counts[item.split('_')[0] + '_'] += 1
    return counts

def with_counter(arr):
    matches = [re.match(r'^.*?_', i) for i in arr]
    return Counter([i.group() for i in matches if i])
"""

for method in ('with_defaultdict', 'with_counter'):
    print(timeit('{}(array)'.format(method), setup=setup, number=1))
</code></pre>
<p>Timing results:</p>
<pre><code>0.4836089063341265
1.3238173544676142
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I'm understanding what you're asking for, it seems like you really want to use Regular Expressions (Regex).  They're built for just this sort of pattern-matching use. I don't know Python, but I do see that regular expressions are supported, so it's a matter of using them.  I use <a href="https://regexr.com/" rel="nofollow noreferrer">this tool</a> because it makes it easy to craft and test your regex.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could also try using <a href="https://docs.python.org/3/library/stdtypes.html#str.partition" rel="nofollow noreferrer"><code>str.partition()</code></a> to extract the string before the separator and the separator, then just concatenate these two to form the prefix. Then you just have to check if this prefix exists in the prefixes set, and count them with <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code></a>:</p>
<pre><code>from collections import Counter

arr = ['a_text', 'b_text', 'ab_text', 'a_text']

prefixes = {'a_', 'b_', 'ab_'}

counter = Counter()
for word in arr:
    before, delim, _ = word.partition('_')
    prefix = before + delim
    if prefix in prefixes:
        counter[prefix] += 1

print(counter)
</code></pre>
<p>Which Outputs:</p>
<pre><code>Counter({'a_': 2, 'b_': 1, 'ab_': 1})
</code></pre>
</div>
<span class="comment-copy">wait so your array only contains strings with 'a_' and 'b_' prefixes??</span>
<span class="comment-copy">It can contain any prefixes but let's say I only need to count the number of <code>a_</code> and <code>b_</code> and <code>ab_</code></span>
<span class="comment-copy">to answer your original question as to which is faster, the Unix <code>time</code> command in terminal reveals that as your data gets bigger, the <code>filter()</code> method gets slower, however the delay is not that big (second or two) especially considering that i ran tests with millions of strings.</span>
<span class="comment-copy">what if they don't all have prefixes? would using this method of regex still work</span>
<span class="comment-copy">I just updated for that possibility</span>
<span class="comment-copy">I see! That is a very cool solution. I'm sorry I was probably not very clear, I have a set list of prefixes I am looking for. So in this example, I'm looking for some <code>prefix = ['a_', 'b_']</code>. So not every prefix that occurs. Is this still something I can regex?</span>
<span class="comment-copy">I would still recommend using this method, because the <code>Counter</code> object is a dictionary with <code>O(1)</code> lookup, so getting your desired values is trivial</span>
<span class="comment-copy">I see, thank you!</span>
<span class="comment-copy">you're right that I can do it with Regex. I'm not too familiar with python either but I'm mostly unsure of which method would be faster. I wonder if using regex is match faster than <code>text.startswith()</code></span>
<span class="comment-copy">the op was asking specifically about python</span>
