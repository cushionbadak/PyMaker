<div class="post-text" itemprop="text">
<p>So let's say I have these lines of code: </p>
<pre><code>if __name__ == '__main__':
if '-h' in sys.argv:
    show_help()
elif '-f' or 'function'in sys.argv:
    print(function1)
elif '-n'or '-name' in sys.argv:
    print(function2)
elif '-e' or '-extension'in sys.argv:
    print(function3])
elif '-m' or '-missing'in sys.argv:
    print(function4)
elif 'r' or '-range' in sys.argv:
    print(function5)
else:
    exit
</code></pre>
<p>The letters are supposed to be inputs from the user in the bash terminal. 
Showing the help method works and it is able to show all of the strings.
The -f input works and shows the contents that I need in that function, however the code just spits out the content from function 1 and not from function2 and so on. </p>
<p>How do I get these different letters, -f, -n, -e, -m (if inputted) to carry out that function and spit out that information? 
Also is there a more efficient way to do this without using argparse for a beginner Python scripter? </p>
</div>
<div class="post-text" itemprop="text">
<p>I highly suggest using <strong><a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer">argparse</a></strong>.</p>
<p>If you prefer not to, creating a dictionary of flags is also possible:</p>
<pre><code>flags = {
    '-h': show_help, 
    '-f': function1,
    '-function': function1,
    '-n': function2,
    '-name': function2,
    '-e': function3,
    '-extension': function3,
    '-m': function4,
    '-missing': function4,
    '-r': function5,
    '-range': function5,
}
if __name__ == '__main__':
    for flag in sys.argv:
        print(flags[flag])
</code></pre>
<p>By creating a dictionary, you're able to just look up the keys.</p>
<p>It results in cleaner, faster, and more maintainable code.</p>
</div>
<div class="post-text" itemprop="text">
<p>To test if any one of two values is in a list, you can't use the <code>or</code> operator with the <code>in</code> operator. You need to test each value separately using the <code>in</code> operator, like this:</p>
<pre><code>if '-h' in sys.argv:
    show_help()
elif '-f' in sys.argv or '-function' in sys.argv:
    print(function1)
elif '-n' in sys.argv or '-name' in sys.argv:
    print(function2)
elif '-e' in sys.argv or '-extension'in sys.argv:
    print(function3])
elif '-m' in sys.argv or '-missing'in sys.argv:
    print(function4)
elif '-r' in sys.argv or '-range' in sys.argv:
    print(function5)
else:
    exit
</code></pre>
</div>
<span class="comment-copy">you check if it is in sys.argv ... and that is true also when you pass -n. Use click for this, relatively simpel compared to argparse</span>
<span class="comment-copy">I recommand the argparse module. <a href="https://docs.python.org/2.7/library/argparse.html" rel="nofollow noreferrer">docs.python.org/2.7/library/argparse.html</a></span>
<span class="comment-copy">Don't re-invent the wheel. Use <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer"><code>argparse</code></a> or <a href="http://click.pocoo.org/5/" rel="nofollow noreferrer"><code>click</code></a>.</span>
<span class="comment-copy">As a noobie in python I wanted to try something easier. But will give that a look!</span>
<span class="comment-copy">Thank you. I completely forgot about creating a dictionary and just using a for loop.</span>
<span class="comment-copy">That's terribly inefficient, at least turn the arguments into a <code>set</code> if you're going to do repeated containment checks.</span>
<span class="comment-copy">I'm just correcting his code as it is written.</span>
<span class="comment-copy">How would one create a set for repeated checks?</span>
<span class="comment-copy"><code>set(sys.argv)</code></span>
<span class="comment-copy">@zwer you don't need a set, you need a dictionary. It's a much better overall design.</span>
