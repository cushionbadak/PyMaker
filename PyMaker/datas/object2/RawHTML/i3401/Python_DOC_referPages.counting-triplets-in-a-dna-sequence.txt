<div class="post-text" itemprop="text">
<p>I want to make a code which counts all triplets in a sequence. I've read a plenty of posts so far, but none of them could help me.</p>
<p>This is my code:</p>
<pre><code>def cnt(seq):
    mydict = {}
    if len(seq) % 3 == 0:
        a = [x for x in seq]
        for i in range(len(seq)//3):
            b = ''.join(a[(0+3*i):(3+3*i)])
            for base1 in ['A', 'T', 'G', 'C']:
                for base2 in ['A', 'T', 'G', 'C']:
                    for base3 in ['A', 'T', 'G', 'C']:
                        triplet = base1 + base2 + base3
                        if b == triplet:
                            mydict[b] = 1
        for key in sorted(mydict):
            print("%s: %s" % (key, mydict[key]))
    else:
        print("Error")
</code></pre>
<p>Does Biopython provide a function to solve this problem?</p>
<p>EDIT:</p>
<p><strong>Note</strong> that, for instance, in the sequence 'ATGAAG', 'TGA' or 'GAA' are <strong>not</strong> "valid" triplets, only 'ATG' and 'AAG', because in biology and bioinformatics, we read it 'ATG' and 'AAG', thats the information we need to translate it or whatever else.</p>
<p>You can imagine it as a sequence of words, for example "Hello world". The way we read it is "Hello" and "world", not "Hello", "ello ", "llo  w",...</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use clever techniques, as suggested in the other answers, but I will build a solution starting from your code, which is almost working: Your problem is that every time you do <code>mydict[b] = 1</code>, you reset the count of <code>b</code> to 1.</p>
<h3>A minimal fix</h3>
<p>You could solve this by testing if the key is present, if not, create the entry in the dict, then increment the value, but there are more convenient tools in python.</p>
<p>A minimal change to your code would be to use a <code>defaultdict(int)</code> instead of a dict. Whenever a new key is encountered, it is assumed to have the associated default value for an int: 0. So you can increment the value instead of resetting:</p>
<pre><code>from collections import defaultdict

def cnt(seq):
     # instanciate a defaultdict that creates ints when necessary
     mydict = defaultdict(int)
     if len(seq) % 3 == 0:
         a = [x for x in seq]
         for i in range(len(seq)//3):
             b = ''.join(a[(0+3*i):(3+3*i)])
             for base1 in ['A', 'T', 'G', 'C']:
                 for base2 in ['A', 'T', 'G', 'C']:
                     for base3 in ['A', 'T', 'G', 'C']:
                         triplet = base1 + base2 + base3
                         if b == triplet:
                             # increment the existing count (or the default 0 value)
                             mydict[b] += 1
         for key in sorted(mydict):
             print("%s: %s" % (key, mydict[key]))
     else:
         print("Error")
</code></pre>
<p>It works as desired:</p>
<pre><code>cnt("ACTGGCACT")
ACT: 2
GGC: 1
</code></pre>
<h3>Some possible improvements</h3>
<p>Now let's try to improve your code a bit.</p>
<p>First, as I wrote in the comments, let's avoid the un-necessary conversion of your sequence to a list, and use a better variable name for the currently counted codon:</p>
<pre><code>from collections import defaultdict

def cnt(seq):
     mydict = defaultdict(int)
     if len(seq) % 3 == 0:
         a = [x for x in seq]
         for i in range(len(seq)//3):
             codon = seq[(0+3*i):(3+3*i)]
             for base1 in ['A', 'T', 'G', 'C']:
                 for base2 in ['A', 'T', 'G', 'C']:
                     for base3 in ['A', 'T', 'G', 'C']:
                         triplet = base1 + base2 + base3
                         if codon == triplet:
                             mydict[codon] += 1
         for key in sorted(mydict):
             print("%s: %s" % (key, mydict[key]))
     else:
         print("Error")
</code></pre>
<p>Now lets simplify the nested loop part, trying all possible codons, by generating in advance the set of possible codons:</p>
<pre><code>from collections import defaultdict
from itertools import product

codons = {
    "".join((base1, base2, base3))
        for (base1, base2, base3) in product("ACGT", "ACGT", "ACGT")}

def cnt(seq):
     mydict = defaultdict(int)
     if len(seq) % 3 == 0:
         a = [x for x in seq]
         for i in range(len(seq)//3):
             codon = seq[(0+3*i):(3+3*i)]
             if codon in codons:
                 mydict[codon] += 1
         for key in sorted(mydict):
             print("%s: %s" % (key, mydict[key]))
     else:
         print("Error")
</code></pre>
<p>Now, your code simply ignores the triplets that are not valid codons. Maybe you should instead issue a warning:</p>
<pre><code>from collections import defaultdict
from itertools import product

codons = {
    "".join((base1, base2, base3))
        for (base1, base2, base3) in product("ACGT", "ACGT", "ACGT")}

def cnt(seq):
     mydict = defaultdict(int)
     if len(seq) % 3 == 0:
         a = [x for x in seq]
         for i in range(len(seq)//3):
             codon = seq[(0+3*i):(3+3*i)]
             # We count even invalid triplets
             mydict[codon] += 1
         # We display counts only for valid triplets
         for codon in sorted(codons):
             print("%s: %s" % (codon, mydict[codon]))
         # We compute the set of invalid triplets:
         # the keys that are not codons.
         invalid = mydict.keys() - codons
         # An empty set has value False in a test.
         # We issue a warning if the set is not empty.
         if invalid:
             print("Warning! There are invalid triplets:")
             print(", ".join(sorted(invalid)))
     else:
         print("Error")
</code></pre>
<h3>A more fancy solution</h3>
<p>Now a more fancy solution, using <a href="https://github.com/pytoolz/cytoolz" rel="nofollow noreferrer">cytoolz</a> (probably needs to be installed because it is not part of usual python distributions: <code>pip3 install cytoolz</code>, if you are using pip):</p>
<pre><code>from collections import Counter
from itertools import product, repeat
from cytoolz import groupby, keymap, partition 

# To make strings out of lists of strings
CAT = "".join

# The star "extracts" the elements from the result of repeat,
# so that product has 3 arguments, and not a single one
codons = {CAT(bases) for bases in product(*repeat("ACGT", 3))}

def cnt(seq):
    # keymap(CAT, ...) transforms the keys (that are tuples of letters)
    # into strings
    # if len(seq) is not a multiple of 3, pad="-" will append "-"
    # to complete the last triplet (which will be an invalid one)
    codon_counts = keymap(CAT, Counter(partition(3, seq, pad="-")))

    # separate encountered codons into valids and invalids
    codons_by_validity = groupby(codons.__contains__, codon_counts.keys())
    # get allows to provide a default value,
    # in case one of the categories is not present
    valids = codons_by_validity.get(True, [])
    invalids = codons_by_validity.get(False, [])

    # We display counts only for valid triplets
    for codon in sorted(valids):
        print("%s: %s" % (codon, codon_counts[codon]))

    # We issue a warning if there are invalid codons.
    if invalids:
        print("Warning! There are invalid triplets:")
        print(", ".join(sorted(invalids)))
</code></pre>
<p>Hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>It took me a while to understand that you do not want to count the number of codons but the frequency of each codon. Your title is a bit misleading in this respect. Anyway, you can employ <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> for your task:</p>
<pre><code>from collections import Counter

def cnt(seq):
    if len(seq) % 3 == 0:
        #split list into codons of three
        codons = [seq[i:i+3] for i in range(0, len(seq), 3)]
        #create Counter dictionary for it
        codon_freq = Counter(codons)
        #determine number of codons, should be len(seq) // 3
        n = sum(codon_freq.values())
        #print out all entries in an appealing form
        for key in sorted(codon_freq):
            print("{}: {} = {:5.2f}%".format(key, codon_freq[key], codon_freq[key] * 100 / n))
        #or just the dictionary
        #print(codon_freq)
    else:
        print("Error")

seq = "ATCGCAGAAATCCGCAGAATC"

cnt(seq)
</code></pre>
<p>Sample output:</p>
<pre><code>AGA: 1 = 14.29%
ATC: 3 = 42.86%
CGC: 1 = 14.29%
GAA: 1 = 14.29%
GCA: 1 = 14.29%
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do something like this:</p>
<pre><code>from itertools import product

seq = 'ATGATG'

all_triplets = [seq[i:i+3] for i in range(len(seq)) if i &lt;= len(seq)-3]
# this gives ['ATG', 'TGA', 'GAT', 'ATG']

# add more valid_triplets here
valid_triplets = ['ATG']

len([(i, j) for i, j in product(valid_triplets, all_triplets) if i==j])
</code></pre>
<p>Output:</p>
<p>2</p>
</div>
<div class="post-text" itemprop="text">
<p>It is unclear what output is expected.  Here we use one of many <a href="https://more-itertools.readthedocs.io/en/latest/api.html#grouping" rel="nofollow noreferrer">grouping</a> functions from <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> to build adjacent triplets or "codons".</p>
<pre><code>import more_itertools as mit


seq = "ATGATG"

codons = ["".join(w) for w in mit.grouper(3, seq)]
codons
# ['ATG', 'ATG']
</code></pre>
<p>Count the number of codons by calling <code>len</code>.</p>
<pre><code>len(triplets)
# 2
</code></pre>
<hr/>
<p>For more detailed analysis, consider splitting the problem into smaller functions that (1) extract codons and (2) compute occurrences.</p>
<p><strong>Code</strong></p>
<pre><code>import collections as ct


def split_codons(seq):
    "Return codons from a sequence; raise for bad sequences."
    for w in mit.windowed(seq, n=3, step=3, fillvalue=""):
        part = "".join(w)
        if len(part) &lt; 3:
            raise ValueError(f"Sequence not divisible by 3.  Got extra '{part}'.")
        yield part


def count_codons(codons):
    """Return dictionary of codon occurences."""
    dd = ct.defaultdict(int)
    for i, c in enumerate(codons, 1):
        dd[c] += 1
    return {k: (v, 100 * v/i) for k, v in dd.items()}
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>&gt;&gt;&gt; seq     = "ATCGCAGAAATCCGCAGAATC"
&gt;&gt;&gt; bad_seq = "ATCGCAGAAATCCGCAGAATCA"

&gt;&gt;&gt; list(split_codons(seq))
['ATC', 'GCA', 'GAA', 'ATC', 'CGC', 'AGA', 'ATC']

&gt;&gt;&gt; list(split_codons(bad_seq))
ValueError: Sequence not divisible by 3.  Got extra 'A'.

&gt;&gt;&gt; count_codons(split_codons(seq))
{'ATC': (3, 42.857142857142854),
 'GCA': (1, 14.285714285714286),
 'GAA': (1, 14.285714285714286),
 'CGC': (1, 14.285714285714286),
 'AGA': (1, 14.285714285714286)}
</code></pre>
</div>
<span class="comment-copy">1. Do you know if your seq is aligned to valid triplets, or has some "hanging" (one or two) bases at the beginning?  2. What about valid sequences like "ACTTTC" -  do you want all possible triplets counted ("ACT", "CTT", "TTT" and "TTC") or only "ACT" and "TTC"? 3. Why "GAT" is not valid?</span>
<span class="comment-copy">You don't need to convert your <code>seq</code> into a list <code>a</code>: if <code>seq</code> is a string, it behaves similarly to a list in the sense that you can directly do <code>b = seq[(0+3*i):(3+3*i)]</code>. Also, it would be better to use a more meaningful variable name than <code>b</code>, like <code>codon</code> or something like that.</span>
