<div class="post-text" itemprop="text">
<p>I am trying to build a shared object library from a <code>cpp</code> file that is a simple set of functions.  I want to use <code>ctypes</code> to interface with python.</p>
<p>Say I have  the <code>cpp</code> file:</p>
<pre><code>#include "print.h"
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;dlfcn.h&gt;

void print_array(const std::vector&lt;std::vector&lt;float&gt;&gt; &amp;A){
  for(size_t i = 0; i &lt; A.size(); i++) {
    for(size_t j = 0; j &lt; A[0].size(); j++) {
      std::cout &lt;&lt; A[i][j] &lt;&lt; "\n";
    }
  }
}
</code></pre>
<p>and header file </p>
<pre><code>#ifndef ADD_H
#define ADD_H
#include &lt;vector&gt;

void print_array(const std::vector&lt;std::vector&lt;float&gt;&gt; &amp;A);

#endif
</code></pre>
<p>I tried to build </p>
<pre><code>g++ -fpic -c print.cpp -o print.o
g++ -shared -o print.so print.o
</code></pre>
<p>Then in python</p>
<pre><code>from cytpes import cdll
print_lib = cdll.LoadLibrary("print.so")
</code></pre>
<p>the line </p>
<pre><code>print_lib.print_array()
</code></pre>
<p>yields</p>
<pre><code>AttributeError: ./print.so: undefined symbol: print_array
</code></pre>
<p><code>nm -D print.so</code></p>
<p>gives the output</p>
<pre><code>0000000000201060 B __bss_start
                 U __cxa_atexit
                 w __cxa_finalize
0000000000201060 D _edata
0000000000201068 B _end
0000000000000c14 T _fini
                 w __gmon_start__
0000000000000898 T _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
0000000000000a50 T _Z11print_arrayRKSt6vectorIS_IfSaIfEESaIS1_EE
0000000000000bcc W _ZNKSt6vectorIfSaIfEE4sizeEv
0000000000000bf2 W _ZNKSt6vectorIfSaIfEEixEm
0000000000000b6a W _ZNKSt6vectorIS_IfSaIfEESaIS1_EE4sizeEv
0000000000000ba2 W _ZNKSt6vectorIS_IfSaIfEESaIS1_EEixEm
                 U _ZNSolsEf
                 U _ZNSt8ios_base4InitC1Ev
                 U _ZNSt8ios_base4InitD1Ev
                 U _ZSt4cout
                 U _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
</code></pre>
<p>What am I fundamentally doing wrong in the compilation step?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are calling a C++ function while <code>ctypes</code> expects C functions linkage:</p>
<ul>
<li>C functions have a different (i. e. none) name mangling, as you noticed</li>
<li>C function cannot have C++ parameters (std objects like std::vector, references, etc.)</li>
</ul>
<p>To solve your issue, declare a clean C-style API in your headers, and if you intend to implement the functions in C++ and use g++ as your compiler/linker, you must add an <code>extern "C"</code> declaration right before the function declaration in the header file, or as a block around your declarations:</p>
<pre><code>extern "C" void print_array(...);
</code></pre>
<p>This will prevent the C++ name mangling.</p>
<p>Using vectors and other C++ types in your interface functions will cause you ABI issues, i. e. "it won't work", even if everything links and compiles seemingly cleanly.</p>
<p>Use C functions with the data types supported by ctypes (see <a href="https://docs.python.org/3/library/ctypes.html#fundamental-data-types" rel="nofollow noreferrer">Python docs on ctypes</a>) in your functions as an interface, feel free to implement in C++, but then wrap your C function declarations in an <code>extern "C"</code> block to prevent name mangling.</p>
<p>Please do refer to the documentation of ctypes to find out how to <em>correctly</em> use structs, unions, references, etc. as function parameters, as there are many pitfalls and issues to consider.</p>
</div>
<span class="comment-copy">Notice how it says, <code>undefined symbol: print_array</code>. It seems like the symbol in <b>print.so</b> is <code>_Z11print_arrayRKSt6vectorIS_IfSaIfEESaIS1_EE</code></span>
<span class="comment-copy">You have been hit by c++ ABI. See <a href="https://stackoverflow.com/questions/1615813/how-to-use-c-classes-with-ctypes" title="how to use c classes with ctypes">stackoverflow.com/questions/1615813/â€¦</a></span>
<span class="comment-copy">agreed, I am going to stick with arrays since I do not need dynamic structures.</span>
<span class="comment-copy">print_array is c++. extern "C" is plain wrong.</span>
<span class="comment-copy">@mdoubez What are you talking about? It's absolutely fine to mark C++ functions as <code>extern "C"</code>. <code>extern "C"</code> tells the compiler not to perform name mangling on the function and instead emit a C-compatible symbol.</span>
<span class="comment-copy">it also modifies the calling convention and "C" doesn't have a calling convention for the parameter std::vector&lt;&gt;&amp;. You couldn't expose the same function to a C compiler.</span>
<span class="comment-copy">Passing in a numpy array is passed as float *var.  I then convert to c++ types in an inner function.  This method worked well for me!</span>
