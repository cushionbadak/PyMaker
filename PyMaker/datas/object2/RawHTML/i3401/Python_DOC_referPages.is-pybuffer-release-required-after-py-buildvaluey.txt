<div class="post-text" itemprop="text">
<p>If it makes a difference, I am interested in an answer regarding Python 3.</p>
<p>The docs state (<a href="https://docs.python.org/3/c-api/buffer.html" rel="nofollow noreferrer">here</a> and <a href="https://docs.python.org/3/c-api/arg.html" rel="nofollow noreferrer">here</a>) that <code>PyBuffer_Release()</code> should be called after <code>PyArg_Parse*()</code> with <code>s*</code>, <code>y*</code>.</p>
<p>Nothing of the sort is written about <code>Py_BuildValue()</code>. Is it an oversight, or in case of <code>Py_BuildValue()</code> a <code>simple Py_DECREF()</code> is enough?</p>
<p>Here is my specific case:</p>
<pre><code>uint8_t buf = (uint8_t *)malloc(bufSize);
PyObject *pyBuf = Py_BuildValue("y#", (char *)buf, bufSize);
free(buf);

// do something with pyBuf

// maybe a PyBuffer_Release(get_underlying_buffer(pyBuf)) here?
Py_DECREF(pyBuf);
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think no:</p>
<ol>
<li><p>In both the <code>PyArg_Parse*</code> and <code>Py_BuildValue</code> functions, <code>y#</code> refers to a string and length, rather than a buffer, and therefore there is no underlying buffer object to be released.</p></li>
<li><p>The documentation for <code>Py_BuildValue</code> says:</p>
<blockquote>
<p>When memory buffers are passed as parameters to supply data to build objects, as for the s and s# formats, the required data is copied. Buffers provided by the caller are never referenced by the objects created by Py_BuildValue().</p>
</blockquote>
<p>The purpose of holding a lock on the buffer used by <code>PyArg_Parse*</code> is that you have got <em>a reference</em> to some data <em>out</em> of Python to C, and you want to process it in C without any chance of it being modified by Python. In this case you have <em>copied</em> some data from C into Python and so there's no need to protect the original data from modification.</p></li>
</ol>
</div>
<span class="comment-copy"><b>"In this case you have copied some data from C into Python and so there's no need to protect the original data from modification."</b> - I think at this point Python might decide that there is a new object that has a reference to that copied buffer, therefore during the construction of <code>Py_buffer</code> some internal reference counter is increased that later must be released by <code>PyBuffer_Release()</code>. At least, this is what I fear. Maybe the newly created object is itself a <code>Py_buffer</code>. Maybe later I will create some testcode to ascertain what objects are created and what resources they hold.</span>
<span class="comment-copy">When I test this the newly created object is a <code>bytes</code> object (the only other realistic option was a <code>bytearray</code>). This does expose the buffer interface, and so It would be possible to get a <code>Py_buffer</code>. However, even if <code>Py_BuildValue</code> produced one requiring the buffer to be released, you could do nothing about it since you don't have access to whatever <code>Py_buffer</code> it had created</span>
<span class="comment-copy">So basically, whatever resources are automatically held within <code>bytes</code>, those should be released by the <code>bytes</code> object automatically. That makes sense. I think for absolute certainty, the python code would have to be looked up. For now it is good enough for me.</span>
