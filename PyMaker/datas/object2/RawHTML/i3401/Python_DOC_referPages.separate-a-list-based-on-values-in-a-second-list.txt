<div class="post-text" itemprop="text">
<p>X: a list of lists, where each list element corresponds to a label in Y</p>
<p>Y: a binary list of labels (values are either 1 or 0)</p>
<p>I want to extract the elements in X according to the value at the corresponding index in Y, as follows:</p>
<p>good = values of X where the label/value in Y is 1<br/>
bad = values of X where the label/value in Y is 0</p>
<p>I am still fairly new to sub-setting in Python and not really sure of a good way to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>If something about your problem makes this naturally seems to call out for doing this in terms of slicing with a bunch of bools rather than looping, that may be a sign that you should be using NumPy:</p>
<pre><code>&gt;&gt;&gt; x = np.array([[1,2,3], [4,5,6], [7,8,9]])
&gt;&gt;&gt; y = np.array([1, 0, 1])
&gt;&gt;&gt; y == 1
array([ True, False,  True])
&gt;&gt;&gt; x[y == 1]
array([[1, 2, 3],
       [7, 8, 9]])
</code></pre>
<hr/>
<p>If, on the other hand, this does make sense in terms of looping, the easy thing to do is write the loop statements out verbosely, and only then figure out how to translate that into a neat list comprehension.</p>
<p>So, let's translate your English description into Python.</p>
<p>First, we want to loop over the values of X with the corresponding values of Y. That's what <code>zip</code> does. So:</p>
<pre><code>for x, y in zip(X, Y):
</code></pre>
<p>Now, an <code>x</code> is good if the <code>y</code> equals 1. So:</p>
<pre><code>for x, y in zip(X, Y):
    if y == 1:
        # x is good
</code></pre>
<p>And what we want to do with the good <code>x</code> values is gather them into a new list. So:</p>
<pre><code>good = []
for x, y in zip(X, Y):
    if y == 1:
        good.append(x)
</code></pre>
<p>And that exactly fits the pattern for a list comprehension: you create an empty list, then have a <code>for</code> with zero or more nested <code>for</code> and/or <code>if</code> statements underneath it and an <code>append</code> to the list at the base. So:</p>
<pre><code>good = [x for x, y in zip(X, Y) if y == 1]
</code></pre>
<p>Or, since <code>1</code> is truthy and <code>0</code> is falsey:</p>
<pre><code>good = [x for x, y in zip(X, Y) if y]
</code></pre>
<p>That looks like something general enough to wrap up as a function:</p>
<pre><code>def compress(X, Y):
    return [x for x, y in zip(X, Y) if y]
</code></pre>
<p>And finally, many interesting looping patterns like that are already wrapped up in a function in <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a>â€”or, if not there, then in third-party libraries like <code>more_itertools</code> and <code>toolz</code>. So, it's worth scanning through them to find if there's something that already does exactly what you want. And, in fact, there is:</p>
<pre><code>def compress(data, selectors):
    # compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F
    return (d for d, s in zip(data, selectors) if s)
</code></pre>
<p>So, you can just use that:</p>
<pre><code>import itertools
good = list(itertools.compress(X, Y))
</code></pre>
<p>But it's still worth learning how to write these things yourself, even if you end up using <code>itertools</code> in the end.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>list(itertools.compress(X, Y))</code> will get you the list of good lists. <code>list(itertools.compress(X, [not a for a in Y]))</code> will get you the list of bad lists.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>X = [[9, 8, 7, 6], [5, 4, 3, 2], [10, 11, 12, 13]]
Y = [1, 0, 0]

good = []
bad = []
for i in range(0, len(Y)):

    if Y[i] == 1:
        good.append(X[i])

    else:
        bad.append(X[i])
</code></pre>
<p>Now simply print out the lists <code>good</code> and <code>bad</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can simply treat <code>Y</code> as a list of indices for your desired partition.</p>
<pre><code>xs = [[],[]]

for a, b in zip(X, Y):
    xs[b].append(a)

bad, good = xs
</code></pre>
</div>
<span class="comment-copy"><code>[x for x, y in zip(X,Y) if y]</code>? But really, have you tried writing a for-loop with the logic you've described? The snippet I've provided will work, but you should try to work this out yourself.</span>
