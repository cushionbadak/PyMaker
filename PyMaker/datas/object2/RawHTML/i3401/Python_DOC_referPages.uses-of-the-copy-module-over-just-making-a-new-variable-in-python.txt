<div class="post-text" itemprop="text">
<p>Say I had code like this: </p>
<pre><code>class Animals:
    def __init__(self):
        print('Woah')
    def Eat(self):
        print('yum')
</code></pre>
<p>And then you made an animals Gilberto:
    gilberto = Animals()</p>
<p>And then you wanted to make another animal named Elijah. Why would you use the copy module:</p>
<pre><code>elijah = copy.copy(gilberto)
</code></pre>
<p>When you could just do:</p>
<pre><code>elijah = gilberto
</code></pre>
<p>Is there anything special about the copy module? In the case of the Animals class, it seems the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>When using <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer"><code>copy.copy</code></a> you're creating a new object, instead of referencing the same object (which is what you're doing in the last snippet).</p>
<p>Consider this:</p>
<p><strong>Setting up</strong></p>
<pre><code>import copy
class Animals:
    def __init__(self):
        print('Woah')
    def Eat(self):
        print('yum')

gilberto = Animals()
elijah_copy = copy.copy(gilberto)
elijah_reference = gilberto
</code></pre>
<p><strong>In the interpreter</strong></p>
<pre><code>&gt;&gt;&gt; id(gilberto) == id(elijah_copy) # Different objects!
False

&gt;&gt;&gt; id(gilberto) == id(elijah_reference) # It's the same object!
True
</code></pre>
<p>So if I were to, for example, define a new attribute in <code>elijah_reference</code> it would be available in <code>gilberto</code> also, but not in <code>elijah_copy</code>:</p>
<pre><code>elijah_reference.color = 'red'
</code></pre>
<p><strong>In the interpreter</strong></p>
<pre><code>&gt;&gt;&gt; gilberto.color
'red'

&gt;&gt;&gt; elijah_copy.color
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Animals' object has no attribute 'color'
</code></pre>
</div>
<span class="comment-copy"><code>elijah = gilberto</code> does not make a new variable!</span>
<span class="comment-copy">oops... but why would you use the copy module?</span>
<span class="comment-copy">Because you want a copy.</span>
<span class="comment-copy">yeah, I see now</span>
<span class="comment-copy">@StephenRauch: It does make a new variable, but that's usually pretty useless without a new object.</span>
<span class="comment-copy">That's almost correct. elijah = gilberto is assigning two references to the same object (I'm guessing that's what you meant, but your vocabulary wasn't exactly right).</span>
<span class="comment-copy">There's a few more implications that I didn't cover: for example, if I were to <code>del gilberto</code>, the object would persist and not get garbage collected, since there's still a reference to it.</span>
<span class="comment-copy">Elijah would change, yes, because they're the same object (look at my example with <code>.color</code>, it would work the same way). Side note: if you're adding other objects to your <code>class</code>, like a <code>list</code>, and you would like to avoid this behavior, consider using a <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer"><code>copy.deepcopy</code></a></span>
<span class="comment-copy">okay, I get it now now</span>
<span class="comment-copy">The object is the <code>list</code>, <code>gilberto</code> and <code>elijah</code> are just a reference to it (none of them are the object itself). One object can have as many references as one needs and when you call a function on a reference you'd always be modifying the same object.</span>
