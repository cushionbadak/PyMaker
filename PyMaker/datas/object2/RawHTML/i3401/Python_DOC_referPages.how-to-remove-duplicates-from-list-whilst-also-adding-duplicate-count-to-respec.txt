<div class="post-text" itemprop="text">
<p>My question is the same as</p>
<ul>
<li><a href="https://stackoverflow.com/questions/48283295/how-to-remove-case-insensitive-duplicates-from-a-list-while-maintaining-the-ori">How to remove case-insensitive duplicates from a list, while maintaining the original list order?</a></li>
</ul>
<p>except that I would also like the duplicate items to <strong>reflect the number of duplicates in the item string itself</strong> (in parentheses).</p>
<p>Example input:</p>
<pre><code>myList = ["paper", "Plastic", "aluminum", "PAPer", "TIN", " paper", "glass", "tin", "PAPER", "Polypropylene Plastic"]
</code></pre>
<p>The only acceptable output:</p>
<pre><code>myList = ["paper (3)", "Plastic", "aluminum", "TIN (2)", " paper", "glass", "Polypropylene Plastic"]
</code></pre>
<p>Notes:</p>
<ul>
<li><p>Note that if an item (<code>"Polypropylene Plastic"</code>) happens to contain another item (<code>"Plastic"</code>), I would still like to retain both items.</p></li>
<li><p>So, the cases can differ, but the item must be a character-for-character match, for it to be removed.</p></li>
<li><p>The original list order must be retained.</p></li>
<li><p>All duplicates after the <em>first instance</em> of that item should be removed. The original case of that <em>first instance</em> should be preserved, as well as the original cases of all non-duplicate items.</p></li>
</ul>
<p>I am looking for the <strong>fastest method</strong> to accomplish this in Python 2.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a version using a single <code>Counter</code>, avoiding the use of another <code>set</code> as in @RoadRunner's solution by popping keys from the <code>Counter</code> as we pass them. This may be slightly slower than the OrderedDict solution if there are many duplicates, but will use less memory:</p>
<pre><code>from collections import Counter

words = ["paper", "Plastic", "aluminum", "PAPer", "TIN", " paper", "glass", "tin", "PAPER", "Polypropylene Plastic"]

counter = Counter(w.lower() for w in words)

result = []
for word in words:
    key = word.lower()
    if key in counter:
        count = counter[key]
        if count == 1:
            result.append(word)
        else:
            result.append('{} ({})'.format(word, count))
        counter.pop(key)
</code></pre>
<p><strong>Note</strong> You should use <a href="https://docs.python.org/3/library/stdtypes.html#str.casefold" rel="nofollow noreferrer"><code>casefold</code></a> instead of <code>lower</code> for Python &gt;= 3.3</p>
</div>
<div class="post-text" itemprop="text">
<p>In the original question, you presumably (I just glanced at it) used a <code>set</code> of the casefolded strings to see if you had a new one or a repeat, building a list of new ones as you go along.</p>
<p>You can replace this with a <code>Counter</code> instead of a <code>set</code>. But then you need to build the list and then go back and edit it with the counts.</p>
<p>So instead, replace <em>both</em> the <code>set</code>/<code>Counter</code> and the output list with an <code>OrderedDict</code> that stores item-count pairs for each case-folded item:</p>
<pre><code>d = collections.OrderedDict()
for item in myList:
    caseless = item.lower()
    try:
        d[caseless][1] += 1
    except KeyError:
        d[caseless] = [item, 1]
</code></pre>
<p>… and then do a pass over that dict to generate the output list:</p>
<pre><code>myList = []
for item, count in d.values():
    if count &gt; 1:
        item = '{} ({})'.format(item, count)
    myList.append(item)
</code></pre>
<p>You can make this more concise (e.g., <code>myList = ['{} ({})'.format(item, count) if count &gt; 1 else item for item, count in d.values()</code>), and that will also make it a bit faster by a small constant factor. </p>
<p>You can probably shave off a few nanoseconds by using <code>%</code> instead of <code>format</code> too, and possibly even more with <code>%d</code> instead of <code>%s</code> (although I think that last part no longer true even by 2.7).</p>
<p>Depending on your platform, <code>a[0] += 1</code> may be faster or slower than <code>a[1] += 1</code>. So try it both ways, and if <code>a[0]</code> is faster, use <code>[count, item]</code> pairs instead of <code>[item, count]</code>. If you have a ton of dups, you may want to consider a class with <code>__slots__</code>, which can actually be slightly faster to update, but significantly slower to create, than a list.</p>
<p>Also, using an <code>in</code> test, or maybe storing <code>d.__contains__</code> as a local, may be faster than <code>try</code>—or it may be slower, depending on how many repeats you expect to have, so try it all three ways on your actual data rather than a toy dataset.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could also try using a <a href="https://docs.python.org/3.7/library/collections.html" rel="nofollow noreferrer"><code>collections.Counter()</code></a> object to keep track of the counts, and use it to keep track of what words have been seen, using caseless words as reference. Then when you are finished iterating over the input list, update the result list to have the word counts in the form <code>%s (%d)</code>, if the count is greater than 1. </p>
<p><strong>Code:</strong></p>
<pre><code>from collections import Counter

words = ["paper", "Plastic", "aluminum", "PAPer", "TIN", " paper", "glass", "tin", "PAPER", "Polypropylene Plastic"]

counts = Counter()
result = []

for word in words:
    caseless = word.casefold()

    if caseless not in counts:
        result.append(word)

    counts[caseless] += 1

result = ['%s (%d)' % (w, counts[w.casefold()]) if counts[w.casefold()] &gt; 1 
                                                else w for w in result]

print(result)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>['paper (3)', 'Plastic', 'aluminum', 'TIN (2)', ' paper', 'glass', 'Polypropylene Plastic'] 
</code></pre>
</div>
<span class="comment-copy">Where is the code that you are having a problem with?</span>
<span class="comment-copy">@ReblochonMasque There's no real problem with my code. It's just slow and unsophisticated. All it does is 1) get tallies of duplicate-items, 2) removes duplicates from the list, and 3) modifies each duplicated-item string with the previously-gotten duplicate-count in 3 separate <code>for</code> loops. I didn't post my clunky code because I can't imagine that a SO member would want to use my code as any sort of starting point.</span>
<span class="comment-copy">@Crickets Posting your code does much more than give us a "starting point". It also shows that you have devoted some effort to the problem as well as giving us a point of comparison for the expected behaviour in an executable form which works much better than a description of what you are trying to achieve.</span>
<span class="comment-copy">It seems that Python 2.7 does not support <code>casefold</code>.</span>
<span class="comment-copy">@Crickets use str.lower () instead</span>
<span class="comment-copy">You can get rid of the set by using the Counter to keep track of what you've seen. You also traverse the word list three times in this solution, while you only need two.</span>
<span class="comment-copy">@chthonicdaemon Updated.</span>
<span class="comment-copy">It seems that Python 2.7 does not support <code>casefold</code>.</span>
<span class="comment-copy">@Crickets use <code>str.lower()</code> instead.</span>
