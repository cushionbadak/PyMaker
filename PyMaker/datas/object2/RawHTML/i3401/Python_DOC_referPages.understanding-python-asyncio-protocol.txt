<div class="post-text" itemprop="text">
<p>I am lacking understanding on how Python asyncio and protocols are working.</p>
<p>Documentaion that seems relevant:<br/>
<a href="https://docs.python.org/3/library/asyncio-protocol.html#asyncio.Protocol" rel="nofollow noreferrer"><code>class asyncio.Protocol</code></a><br/>
<a href="https://docs.python.org/3/library/asyncio-protocol.html#asyncio.Protocol.eof_received" rel="nofollow noreferrer"><code>Protocol.eof_received()</code></a>  state machine shows relevant transitions
<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_until_complete" rel="nofollow noreferrer"><code>AbstractEventLoop.run_until_complete(future)</code></a> </p>
<p>Example code that is echo tcp client:</p>
<pre><code>import asyncio

class EchoClientProtocol(asyncio.Protocol):
    def __init__(self, message, loop):
        self.message = message.encode()

    def connection_made(self, transport):
        self.transport = transport
        self.write_data()

    def data_received(self, data):
        print('Data received: {!r}',len(data))
        self.write_data()

    def eof_received(self):
        print("eof")
        return True

    def write_data(self):
        print("write")
        self.transport.write(self.message)

    def connection_lost(self, exc):
        print('The server closed the connection')
        print('Stop the event loop')


loop = asyncio.get_event_loop()
message = 'Hello World!'

coro = loop.create_connection(lambda: EchoClientProtocol(message, loop),
                              '127.0.0.1', 5676)
loop.run_until_complete(coro)
print("done")
</code></pre>
<p>Output when connceted on echo server:</p>
<pre><code>write
Data received: {!r} 12
write
done
</code></pre>
<p>From what I understand this should run until connection is closed. </p>
<p>From: <a href="https://docs.python.org/3/library/asyncio-protocol.html#connection-callbacks" rel="nofollow noreferrer">Connection callbacks</a></p>
<p>connection_made() and connection_lost() are called exactly once per successful connection. All other callbacks will be called between those two methods, which allows for easier resource management in your protocol implementation.</p>
<p>and from also state machine:</p>
<pre><code>start 
-&gt; connection_made
[-&gt; data_received]*
[-&gt; eof_received]?
-&gt; connection_lost 
-&gt; end
</code></pre>
<p>But, function <code>EchoClientProtocol.connection_lost</code> is never called and 
<code>loop.run_until_complete(coro)</code> terminates before Protocol completes. </p>
<p>Question is:<br/>
How to get coroutine/future that wraps protocol in a way that coroutine completes when end state of protocol is reached and loop.run_until_complete returns on such event.</p>
</div>
<div class="post-text" itemprop="text">
<p>As Sraw's answer points out, <code>loop.create_connection</code> is a coroutine that returns as soon as it has created a transport/protocol pair. So you need to run another coroutine (or equivalent object) that will keep the event loop alive for interesting things to happen.</p>
<blockquote>
<p>how to run loop until protocol internal state reaches state end without explicitly closing loop</p>
</blockquote>
<p>You don't necessarily need to close or stop the loop. If I'm following you correctly, you'd like to avoid an unsightly <code>run_forever</code>, instead writing something like:</p>
<pre><code>transport, protocol = loop.run_until_complete(coro)
transport.close()
loop.run_until_complete(protocol.wait_connection_lost())
</code></pre>
<p>While <code>wait_connection_lost()</code> indeed doesn't come with asyncio, you are providing the protocol implementation, so you can easily create one for your protocol:</p>
<pre><code>class EchoClientProtocol(asyncio.Protocol):
    # your other methods are unchanged

    def __init__(self, message, loop):
        self.message = message.encode()
        self.__done = loop.create_future()

    def connection_lost(self, exc):
        # the value passed to set_result will be transmitted to
        # run_until_complete(protocol.wait_connection_lost()).
        self.__done.set_result(None)

    # When awaited, resumes execution after connection_lost()
    # has been invoked on this protocol.
    def wait_connection_lost(self):
        return self.__done
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>loop.run_until_complete(coro)</code> returns <code>transport, protocol</code>.</p>
<p>So to triggle <code>connection_lost</code>, the connection should be closed either by server or client. So you need:</p>
<pre><code>transport, _ = loop.run_until_complete(coro)
transport.close()
loop.run_forever()
print("done")
</code></pre>
<p>As you are not stoping loop in <code>connection_lost</code>, it will be blocked here forever.</p>
<p>BTW, <code>coro</code> returns when connection is connectted successfully.</p>
</div>
<span class="comment-copy">Thank you for your answer. Do you know how to run loop until protocol internal state reaches state end without explicitly closing loop.</span>
<span class="comment-copy">No, there seems isn't an interface in <code>asyncio</code> for this.</span>
