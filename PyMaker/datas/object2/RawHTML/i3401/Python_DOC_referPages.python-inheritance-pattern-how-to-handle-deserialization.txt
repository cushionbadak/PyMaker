<div class="post-text" itemprop="text">
<p>Say we want to serialize <code>B</code> below:</p>
<pre><code>import json
class A:
    def __init__(self):
        self.a = 1
    @classmethod
    def serialize(cls, t):
        with open('temp_A.json', 'wb') as f:
            json.dump({'a':t.a}, f)
    @classmethod
    def deserialize(cls):
        with open('temp_A.json', 'rb') as f:
            d = json.load(f)
            obj = A()
            obj.a = d['a']
            return obj

class B(A):
    def __init__(self):
        super(B, self).__init__()
        self.b = 2
    @classmethod
    def serialize(cls, t):
        with open('temp_B.json', 'wb') as f:
            json.dump({'b':t.b}, f)
    @classmethod
    def deserialize(cls):
        with open('temp_B.json', 'rb') as f:
            d = json.load(f)
            obj = B()
            obj.b = d['b']
            a = A.deserialize()
            #### IMPORTANT: doesn't work
            super(B, b) = a
            ####
            return b
</code></pre>
<p>If this serialization pattern is terrible and you have alternatives, please let me know. However, at the current stage I'm not sure how to re-assign the superclass's member variables as <code>a</code>'s attributes(since <code>a</code>'s state might be different than during initial construction). I know I could do something like <code>super(B,b).__dict__ = a.__dict__</code>, but it just doesn't feel right. <em>What is the python-idiomatic way to perform something like this?</em></p>
</div>
<div class="post-text" itemprop="text">
<p>Borrowing the dunders from <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer"><code>pickle</code></a>:</p>
<pre><code>import json
class A:
    def __init__(self):
        self.a = 1

    def __getstate__(self):
        return {'a': self.a}

    def __setstate__(self, state):
        '''Accepts a json/dict, sets member attributes accordingly'''
        self.a = state['a']

    def serialize(self):
        return json.dumps(self.__getstate__())

    @classmethod
    def deserialize(cls, json_str):
        d = json.loads(json_str)
        obj = cls()
        obj.__setstate__(d)
        return obj

class B(A):
    def __init__(self):
        super(B, self).__init__()
        self.b = 2

    def __setstate__(self, state):
        '''Accepts a json/dict, sets member attributes accordingly'''
        super().__setstate__(state)
        self.b = state['b']

    def __getstate__(self):
        state = super().__getstate__()
        state.update({'b': self.b})  # or state['b'] = self.b
        return state

    def serialize(self):
        return json.dumps(self.__getstate__())

    @classmethod
    def deserialize(cls, json_str):
        d = json.loads(json_str)
        obj = cls()
        obj.__setstate__(d)
        return obj


# Test A roundtrip
a1 = A()
a1_str = a1.serialize()
print(a1_str)               # {"a": 1}

a2 = A.deserialize(a1_str)
a2_str = a2.serialize()
print(a2_str)               # {"a": 1}

print(a1_str == a2_str)     # True

# Test B roundtrip
b1 = B()
b1_str = b1.serialize()
print(b1_str)               # {"a": 1, "b": 2}

b2 = B.deserialize(b1_str)
b2_str = b2.serialize()
print(b2_str)               # {"a": 1, "b": 2}

print(b1_str == b2_str)     # True
</code></pre>
<p>There are a few other changes here, like not hardcoding the class name in the <code>deserialize()</code> classmethod, serializing to string instead of file (for testing), Using consistent <code>dumps</code>/<code>loads</code> instead of one of each.</p>
</div>
<span class="comment-copy">looks great! Thank you. Is this how pickle performs its serialization? What did you mean by "dunder"?</span>
<span class="comment-copy">Pickle allows you to specify what attributes you want to be serialized (and how you want unserialization to occur) via the special methods <a href="https://docs.python.org/3/library/pickle.html#object.__getstate__" rel="nofollow noreferrer"><code>__getstate__</code></a> and <a href="https://docs.python.org/3/library/pickle.html#object.__setstate__" rel="nofollow noreferrer"><code>__setstate__</code></a>.  You don't need to implement these, in which case the the object's <code>__dict__</code> would be used.  And by dunder I mean "double underscore" names, special (or "magic") methods.</span>
<span class="comment-copy">You could call the <code>__getstate__</code> and <code>__setstate__</code> methods whatever you want (e.g. <code>to_dict</code> and <code>from_dict</code>), but since they do exactly what the pickle module expects, naming them using the dunders gives you the nice side effect of also being used by pickle if you were to ever serialize that way.</span>
<span class="comment-copy">Got it, thank you!</span>
