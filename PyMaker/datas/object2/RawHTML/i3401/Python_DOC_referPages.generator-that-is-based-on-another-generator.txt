<div class="post-text" itemprop="text">
<p>My task is actually quite simple, but I cannot figure out how to achieve it. I am intending to use this in my ML algo, but let's simplify the example. Suppose there is a generator like the following:</p>
<pre><code>nums = ((i+1) for i in range(4))
</code></pre>
<p>The above, will yield us <code>1</code>, <code>2</code>, <code>3</code> and <code>4</code>.</p>
<p>Suppose that the above generator returns individual "samples". I want to write a generator method that will batch them up. Suppose, the batch size is <code>2</code>. So if this new method is called:</p>
<pre><code>def batch_generator(batch_size):
    do something on nums
    yield batches of size batch_size
</code></pre>
<p>And then the output of this batch generator would be: <code>1</code> and <code>2</code> and then <code>3</code> and <code>4</code>. Tuples/lists does not matter. What matters is to how to return these batches. I found this <code>yield from</code> keyword that was introduced in Python 3.3, but it seems it is not useful in my case.</p>
<p>And obviously, if we had <code>5</code> nums instead of <code>4</code>, and <code>batch_size</code> is <code>2</code>, we would omit the last yielded value from the first generator.</p>
</div>
<div class="post-text" itemprop="text">
<p>My own solution for this could be,</p>
<pre><code>nums = (i+1 for i in range(4))

def giveBatch(gen, numOfItems):
    try:
        return [next(gen) for i in range(numOfItems)]
    except StopIteration:
        pass

giveBatch(nums, 2)
# [1, 2]
giveBatch(nums, 2)
# [3, 4]
</code></pre>
<hr/>
<p>Another solution is to use <code>grouper</code> as @Bharel mentioned. I have compared the time it takes to run both of these solutions. There is not much of a difference. I guess it can be neglected.</p>
<pre><code>from timeit import timeit

def wrapper(func, *args, **kwargs):
    def wrapped():
        return func(*args, **kwargs)
    return wrapped

nums = (i+1 for i in range(1000000))

wrappedGiveBatch = wrapper(giveBatch, nums, 2)
timeit(wrappedGiveBatch, number=1000000)
# ~ 0.998439

wrappedGrouper = wrapper(grouper, nums, 2)
timeit(wrappedGrouper, number=1000000)
# ~ 0.734342
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Under <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><strong>itertools</strong></a> you have a code snippet which does just that:</p>
<pre><code>from itertools import zip_longest

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
<p>Instead of calling a method every time, you have an iterator that returns batches, much more efficient, faster, and handles corner cases like running out of data too soon without losing it.</p>
</div>
<div class="post-text" itemprop="text">
<p>This was exactly what I needed:</p>
<pre><code>def giveBatch(numOfItems):
    nums = (i+1 for i in range(7))

    while True:
        yield [next(nums) for i in range(numOfItems)]
</code></pre>
</div>
<span class="comment-copy">See the <code>grouper</code> recipe in the <code>itertools</code> documentation.</span>
<span class="comment-copy">love it. And StopIteration would be thrown if there are not enough samples for the batch. Thanks a bunch!</span>
<span class="comment-copy">@isquared-KeepitReal Yes, I was just adding that, you are welcome :)</span>
<span class="comment-copy">or not thrown :)) haha</span>
<span class="comment-copy">25% faster iteration is quite a bit ;-)</span>
<span class="comment-copy">Glad you have found your solution, still instead of defining <code>nums</code> static, it's better to pass it to the function and do your stuff in a more generic and flexible way. That way you can use <code>giveBatch</code> with any generator.</span>
<span class="comment-copy">True, I will refactor :)</span>
