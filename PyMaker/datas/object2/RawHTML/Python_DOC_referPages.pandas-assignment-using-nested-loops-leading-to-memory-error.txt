<div class="post-text" itemprop="text">
<p>I am using pandas and trying to do an assignment using a nested loops. I iterate over a dataframe and then run a distance function if it meets a certain criteria. I am faced with two problems:</p>
<ol>
<li><p>SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame</p></li>
<li><p>Memory Error. It doesn't work on large datasets. I end up having to terminate the process. </p></li>
</ol>
<p>How should I change my solution to ensure it can scale with a larger dataset of 60,000 rows? </p>
<pre><code>for i, row in df.iterrows():
    listy = 0
    school = []
    if row['LS_Type'] == 'Primary (1-4)':
        a = row['Northing']
        b = row['Easting']
        LS_ID = row['LS_ID']
        for j, row2 in df.iterrows():
            if row2['LS_Type'] == 'Primary (1-8)':
                dist_km = distance(a,b, df.Northing[j], df.Easting[j])
                if (listy == 0):
                    listy = dist_km
                    school.append([df.LS_Name[j], df.LS_ID[j]])
                else:
                    if dist_km &lt; listy:
                        listy = dist_km
                        school[0] = [df.LS_Name[j], int(df.LS_ID[j])]
        df['dist_up_prim'][i] = listy
        df["closest_up_prim"][i] = school[0]

    else:
        df['dist_up_prim'][i] = 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The double for loop is what's killing you here. See if you can break it up into two separate apply steps.</p>
<p>Here is a toy example of using <code>df.apply()</code> and <code>partial</code> to do a nested for loop:</p>
<pre><code>import math
import pandas as pd
from functools import partial

df = pd.DataFrame.from_dict({'A': [1, 2, 3, 4, 5, 6, 7, 8],
                             'B': [1, 2, 3, 4, 5, 6, 7, 8]})

def myOtherFunc(row):
    if row['A'] &lt;= 4:

        return row['B']*row['A']

def myFunc(the_df, row):
    if row['A'] &lt;= 2:
        other_B = the_df.apply(myOtherFunc, axis=1)
        return other_B.mean()
    return pd.np.NaN

apply_myFunc_on_df = partial(myFunc, df)

df.apply(apply_myFunc_on_df, axis=1)
</code></pre>
<p>You can rewrite your code in this form, which will be much faster.</p>
</div>
<span class="comment-copy">You should use the df.apply function</span>
<span class="comment-copy">In general, if you use iterrows... stop, do something else.</span>
<span class="comment-copy">Did my answer below help you solve this problem?</span>
