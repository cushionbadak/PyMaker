<div class="post-text" itemprop="text">
<p>I had a previous question about QKeySequence <a href="https://stackoverflow.com/questions/55193612/pyside2-finding-out-which-qkeysequence-was-pressed/55193655#55193655">here</a>. It worked but when I applied it to my code there seemed to be an error when the QKeySequence comes after line when the button click event goes before the QKeySequence line.</p>
<p>Note: The GUI consists of only two buttons: self.btnDSR and self.btnOther.</p>
<p>Taking from the answer of eyllanesc in the previous question, my code follows:</p>
<pre><code>class MainWindow(QtWidgets.QMainWindow, test_mainWindow.Ui_MainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)
        self.setupUi(self)
        self.signals()

    @QtCore.Slot()
    def test_func(self):
        shorcut = self.sender()
        sequence = shorcut.key()
        print(sequence.toString())

    def btn_clicked(self):
        QtWidgets.QShortcut(QtGui.QKeySequence("3"), self, activated=self.test_func)
        print('Shortcut 3 now works!')  # But it doesn't

    def signals(self):
        QtWidgets.QShortcut(QtGui.QKeySequence("1"), self, activated=self.test_func)
        QtWidgets.QShortcut(QtGui.QKeySequence("2"), self, activated=self.test_func)
        QtCore.QObject.connect(self.btnDSR, QtCore.SIGNAL('clicked()'), self.btn_clicked)
        QtCore.QObject.connect(self.btnOther, QtCore.SIGNAL('clicked()'), self.close)
</code></pre>
<p>Typing only 1 and 2 works, typing 3 doesn't work after clicking the btnDSR. Meaning the number 3 is not printing out but number 1 and 2 does when clicked. This error message is returned when pressing 3:</p>
<pre><code>sequence = shorcut.key()
AttributeError: 'NoneType' object has no attribute 'key'
</code></pre>
<p>In case it is relevant, I am also attaching my basic code for testing GUIs here:</p>
<pre><code>from PySide2 import QtCore, QtGui, QtWidgets

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(440, 418)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.btnDSR = QtWidgets.QPushButton(self.centralwidget)
        self.btnDSR.setGeometry(QtCore.QRect(120, 110, 93, 28))
        self.btnDSR.setObjectName("btnDSR")
        self.btnOther = QtWidgets.QPushButton(self.centralwidget)
        self.btnOther.setGeometry(QtCore.QRect(150, 180, 141, 28))
        self.btnOther.setObjectName("btnOther")
        MainWindow.setCentralWidget(self.centralwidget)
        self.btnDSR.setText(QtWidgets.QApplication.translate("MainWindow", "DSR Button", None, -1))
        self.btnOther.setText(QtWidgets.QApplication.translate("MainWindow", "Other Button", None, -1))
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Testing the same with PyQt5 (making some compatibility changes) works correctly so I think it's a PySide2 bug. A workaround is to use a <code>lambda</code> or <code>functools.partial</code> to pass the key.</p>
<p><strong>1. lambda:</strong></p>
<pre><code>class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)
        self.setupUi(self)
        self.signals()

    @QtCore.Slot(str)
    def test_func(self, key):
        print(key)

    def btn_clicked(self):
        QtWidgets.QShortcut(QtGui.QKeySequence("3"), self, activated=  lambda key="3": self.test_func(key))
        print('Shortcut 3 now works!')  # But it doesn't

    def signals(self):
        QtWidgets.QShortcut(QtGui.QKeySequence("1"), self, activated=  lambda key="1": self.test_func(key))
        QtWidgets.QShortcut(QtGui.QKeySequence("2"), self, activated=  lambda key="2": self.test_func(key))
        QtCore.QObject.connect(self.btnDSR, QtCore.SIGNAL('clicked()'), self.btn_clicked)
        QtCore.QObject.connect(self.btnOther, QtCore.SIGNAL('clicked()'), self.close)
</code></pre>
<p><strong>2. functools.partial</strong></p>
<pre><code>class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)
        self.setupUi(self)
        self.signals()

    @QtCore.Slot(str)
    def test_func(self, key):
        print(key)

    def btn_clicked(self):
        QtWidgets.QShortcut(QtGui.QKeySequence("3"), self, activated= partial(self.test_func, "3"))
        print('Shortcut 3 now works!')  # But it doesn't

    def signals(self):
        QtWidgets.QShortcut(QtGui.QKeySequence("1"), self, activated= partial(self.test_func, "1"))
        QtWidgets.QShortcut(QtGui.QKeySequence("2"), self, activated= partial(self.test_func, "2"))
        QtCore.QObject.connect(self.btnDSR, QtCore.SIGNAL('clicked()'), self.btn_clicked)
        QtCore.QObject.connect(self.btnOther, QtCore.SIGNAL('clicked()'), self.close)
</code></pre>
</div>
<span class="comment-copy">Thank you so much, didn't think of using a lambda for this. Also partial is a new thing for me. I will explore this more!</span>
