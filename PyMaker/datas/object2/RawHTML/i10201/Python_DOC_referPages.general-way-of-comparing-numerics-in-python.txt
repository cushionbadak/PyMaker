<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/5595425/what-is-the-best-way-to-compare-floats-for-almost-equality-in-python">What is the best way to compare floats for almost-equality in Python?</a>
<span class="question-originals-answer-count">
                    13 answers
                </span>
</li>
</ul>
</div>
<p>I have been looking around to find a general way of comparing two numerics in Python. In particular, I want to figure out whether they are the same or not.</p>
<p>The numeric types in Python are:</p>
<pre><code>int, long, float &amp; complex
</code></pre>
<p>For example, I can compare 2 integers (a type of numeric) by simply saying:</p>
<pre><code>a == b
</code></pre>
<p>For floats, we have to be more careful due to rounding precision, but I can compare them within some tolerance.</p>
<p><strong>Question</strong></p>
<p>We get 2 general numerics <code>a</code> and <code>b</code>: How do we compare them? I was thinking of casting both to complex (which would then have a 0 imaginary part if the type is, say, <code>int</code>) and compare in that domain?</p>
<p>This question is more general than simply comparing floats directly. Certainly, it is related to this problem, but it is not the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.5 (and in Numpy) you can use <code>isclose</code></p>
<p>Read the <a href="https://www.python.org/dev/peps/pep-0485/" rel="nofollow">PEP 485</a> that describes it, Python 3.5 math <a href="https://docs.python.org/3/library/math.html#math.isclose" rel="nofollow">library listing</a> and <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.isclose.html" rel="nofollow">numpy.isclose</a> for more. The numpy version works in all versions of Python that numpy is supported. </p>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt; from math import isclose
&gt;&gt;&gt; isclose(1,1.00000000001)
True
&gt;&gt;&gt; isclose(1,1.00001)
False
</code></pre>
<p>The relative and absolute tolerance can be changed.  </p>
<p>Relative tolerance can be thought of as +- a percentage between the two values:</p>
<pre><code>&gt;&gt;&gt; isclose(100,98.9, rel_tol=0.02)
True
&gt;&gt;&gt; isclose(100,97.1, rel_tol=0.02)
False
</code></pre>
<p>The absolute tolerance is a absolute value between the two values. It is the same as the test of <code>abs(a-b)&lt;=tolerance</code></p>
<p>All numeric types of Python are support with the Python 3.5 version. (Use the <code>cmath</code> version for complex)</p>
<p>I think longer term, this is your better bet for numerics. For older Python, just import the source. There is a version on <a href="https://github.com/PythonCHB/close_pep/blob/master/is_close.py" rel="nofollow">Github</a>. </p>
<p>Or, (forgoing error checking and <code>inf</code> and <code>NaN</code> support) you can just use:</p>
<pre><code>def myisclose(a, b, *, rel_tol=1e-09, abs_tol=0.0):
   return abs(a-b) &lt;= max( rel_tol * max(abs(a), abs(b)), abs_tol )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are looking to compare different types of numerics, there is nothing wrong with the <code>==</code> operator: Python will handle the type-casting. Consider the following:</p>
<pre><code>&gt;&gt;&gt; 1 == 1 + 0j == 1.0
True
</code></pre>
<p>In cases where you are doing mathematical operations that could result in loss of precision (especially with floats), a common technique is to check if the values are within a certain tolerance. For example:</p>
<pre><code>&gt;&gt;&gt; (10**.5)**2
10.000000000000002
&gt;&gt;&gt; (10**.5)**2 == 10
False
</code></pre>
<p>In this case, you can find the absolute value of the difference and make sure it is under a certain threshold:</p>
<pre><code>&gt;&gt;&gt; abs((10**.5)**2 - 10) &lt; 1e-10
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not just use <code>==</code>  ?</p>
<pre><code>&gt;&gt;1 == (1+0j)
True
&gt;&gt;1.0 == 1
True
</code></pre>
<p>I'm pretty sure this works for all numeric types.</p>
</div>
<span class="comment-copy">+1 for that isclose GitHub library. As they say: They short circuit for exact equality, but then dive into a more careful check if not strict equality. That is what I was thinking (even handling complex types).</span>
<span class="comment-copy">I guess my concern arises with tolerance, how does that work?</span>
<span class="comment-copy">@denvar I added something for tolerance</span>
<span class="comment-copy">@denvar check <a href="http://stackoverflow.com/questions/5595425/what-is-the-best-way-to-compare-floats-for-almost-equality-in-python/33024979#33024979" title="what is the best way to compare floats for almost equality in python">stackoverflow.com/questions/5595425/â€¦</a> for comparing with tolerance. I don't think that answer works with complex numbers though.</span>
<span class="comment-copy">Haha, identical answers :)</span>
<span class="comment-copy">It even works for bools - <code>True==1.0</code> and <code>False==0.0</code> both return <code>True</code>.</span>
