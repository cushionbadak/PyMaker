<div class="post-text" itemprop="text">
<p>I have a csv file with a few patterns. I only want to selectively load lines into the csv reader class of python. Currently, csv only takes a file object. Is there a way to get around this?<br/>
In other words, what I need is:</p>
<pre><code>with open('filename') as f:
    for line in f:
        if condition(line):
            record = csv.reader(line)
</code></pre>
<p>But, currently, csv class fails if it is given a line instead of a file object.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <code>csv.reader</code> docstring:</p>
<blockquote>
<p><em>csvfile</em> can be any object which supports the iterator protocol and returns a string each time its <code>__next__()</code> method is called</p>
</blockquote>
<p>You can feed <code>csv.reader</code> with a generator iterator that yields only the selected rows.</p>
<pre><code>with open('filename') as f:
    lines = (line for line in f if condition(line))
    for record in csv.reader(lines):
        do_something()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To read file as stream you can use this.</p>
<pre><code>io.open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import shlex
lex = shlex.shlex('"sreeraag","100,ABC,XYZ",112',',', posix=True)
lex.whitespace += ','
lex.whitespace_split = True
print list(lex)
</code></pre>
<p>yields</p>
<pre><code>['sreeraag', '100,ABC,XYZ', '112']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Found a solution: As csv expects object which supports  __next__(), I'm using a <strong>StringIO</strong> class to convert string to StringIO object which in turn handles  __next__() and returns one line everytime for csv reader class.</p>
<pre><code>with open('filename') as f:
for line in f:
    if condition(line):
        record = csv.reader(StringIO.StringIO(line))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>```</p>
<pre><code>with open("xx.csv") as f:
    csv = f.readlines()
    print(csv[0])
</code></pre>
<p>```</p>
<p>→_→ Life is short,your need pandas</p>
<p>pip install pandas</p>
<p>```</p>
<pre><code>import pandas as pd
df = pd.read_csv(filepath or url)
df.ix[0]
df.ix[1]
df.ix[1:3]
</code></pre>
<p>```</p>
</div>
<span class="comment-copy">There's another problem to it. The 'lines' can be as big as 16GB. In such case, we won't be streaming the data to csv but would effectively wait till lines is populated and then call the csv reader, which is bad.</span>
<span class="comment-copy">@sreeraag No, it's a <a href="https://docs.python.org/3/glossary.html#term-generator-expression" rel="nofollow noreferrer" title="generator expression">generator expression</a>, it won't be populated, instead it will generate values as needed.</span>
<span class="comment-copy">Agreed, but for some reason, after this change, my process' memory keeps on growing continuously.</span>
<span class="comment-copy">Just iterating over <code>csv.reader(lines)</code> should not make the process'  memory grow and it does not for me.</span>
<span class="comment-copy">Even open(filename) gives me a stream. The problem here is to pass the stream after doing some preliminary checks to csvreader class</span>
<span class="comment-copy">The advantage of using csv reader class is that it handles cases like these: "sreeraag","100, ABC, XYZ", 112 Splitting by ',' would fail in the above case.</span>
<span class="comment-copy">is this better?</span>
<span class="comment-copy">This wont work for a lot of csv usecases</span>
<span class="comment-copy">why? Please tell me what you are looking for</span>
<span class="comment-copy">I want it to work for cases like  "sreeraag","100, ABC, XYZ", 112   which is why I'm using CSV class in the first place, instead of using 'split(',')'  . But the problem is csv class of python expects a file object , not a string.</span>
<span class="comment-copy">This way you are creating a StringIO and a reader for each line. Also there will be a lot of work for the garbage collector. There will be a performance penalty unless these operations are negligible compared to evaluating the condition.</span>
<span class="comment-copy">pandas does not like irregular csv's</span>
