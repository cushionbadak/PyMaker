<div class="post-text" itemprop="text">
<p>I suppose to write a code that prints out the value of a number that occurs twice in the list given, but they don't allow us to use a built in function on python. How would I be able to write it without using enumerate? </p>
<pre><code>def find_second_occurrence(xs,v):
    count = 0
    value = None
    for i, x in enumerate(xs):
        if v == x:
            count += 1
            if count == 2:
                return i
    if (count &lt; 2):
        return value
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>enumerate(sequence)</code> is pretty much similar to a construct of the form:</p>
<pre><code>for i in range(len(sequence)):
    # get sequence[i] and return i and sequence[i] for all i's
</code></pre>
<p>So, in your code, replacing <code>enumerate</code> altogether could be done by:</p>
<pre><code>for i in range(len(xs)):
    x = xs[i]             
    if v == x:
        count += 1
        if count == 2:
            return i
</code></pre>
<p>Or, without assigning to an <code>x</code> name to temporarily hold the sequence item:</p>
<pre><code>for i in range(len(xs)):           
    if v == xs[i]:
        count += 1
        if count == 2:
            return i
</code></pre>
<p>Creating a little <code>my_enumerate</code> function, is also rather simple:</p>
<pre><code>def my_enumerate(sequence, start=0):
    for i in range(len(sequence)):
        yield start+i, sequence[i]
</code></pre>
<p><code>start</code> has also been defined as to match that as used in <code>enumerate</code> and gets a default value of <code>0</code>.</p>
<p>Rather than <code>yield</code>ing values (if this is mystifying to you), you can create a list (generator comprehensions are similar to <code>yield</code>ing) comprehension and return that instead:</p>
<pre><code>def my_enumerate(sequence, start=0):
    return [(start+i, sequence[i]) for i in range(len(sequence))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your own enumerate function might be something like this: </p>
<pre><code>def my_enumerate(a_list):
    result = []
    counter = 0
    for item in a_list:
        result.append((counter, item))
        counter += 1
    return result
</code></pre>
<p>Unlike the built-in <code>enumerate</code>, which is a generator that yields one item at a time, your function is returning a list. </p>
</div>
<span class="comment-copy">Implement your own <code>enumerate</code> function and use it.</span>
<span class="comment-copy">@RickTeachey I don't know where to start. I don't really understand the concept of enumerate that well</span>
<span class="comment-copy">You would make a function just like the one you've made. The counter increments every time you go through the loop. It returns a list of two-tuples with the item number and the item.</span>
<span class="comment-copy">Note that you are not returning the <i>value</i> of a duplicate number, but the second <i>index</i> of it.</span>
<span class="comment-copy">can you explain what xs[i] does?</span>
<span class="comment-copy">@fip <code>xs</code> is your list, for example <code>xs = [5, 1, 2, 4]</code>. <code>xs[i]</code> will <i>index</i> that list and get the item that's at position <code>i</code>. So, for example, <code>xs[0]</code> will be <code>5</code>, <code>xs[1]</code> will be <code>1</code>, <code>xs[2]</code> is <code>2</code> and so on. See <a href="https://docs.python.org/3/tutorial/introduction.html#lists" rel="nofollow noreferrer">here</a> for a Python tutorial on lists where this is explained :)</span>
<span class="comment-copy">That makes sense! Thank you!</span>
