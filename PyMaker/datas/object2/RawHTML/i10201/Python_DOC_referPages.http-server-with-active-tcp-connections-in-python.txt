<div class="post-text" itemprop="text">
<p>I am writing a pseudo-http application in python, the requirements for which are:</p>
<ol>
<li>It should handle HTTP requests.</li>
<li>The connections between the client and the server outlive the request-response, i.e. the underlying TCP connection remains alive after a response has been sent to a client.</li>
<li>The server needs to be able to send data to a particular client for which it already has an opened connection.</li>
</ol>
<p>I looked at twisted and python's TCPServer/BaseHTTPServer, but they don't quite fit the bill. The way I see it, I have two options:</p>
<ol>
<li>Start from a HTTP server implementation and override my way down to connection management.</li>
<li>Have a simple socket server that will manage the connections and pass data between the "http" server and the client.</li>
</ol>
<p>Has anyone tackled a similar issue? Any ideas on other approaches or which one will be a better option?</p>
<p>Thanks!</p>
<p><strong>EDIT 1</strong>
I cannot use HTTP 2 or web sockets; HTTP &lt;2 over TCP is a hard requirement.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you cannot use websockets or http/2, and you require the ability to push data from the server to the client, then long-polling is probably the best option remaining.</p>
<p>See Nevow, at <a href="https://github.com/twisted/nevow" rel="nofollow">https://github.com/twisted/nevow</a>, for one possible implementation of long-polling, via the athena module.</p>
</div>
<div class="post-text" itemprop="text">
<p>I ended up overriding methods in <a href="https://docs.python.org/3/library/http.server.html#http.server.HTTPServer" rel="nofollow noreferrer">http.server.HTTPServer</a>, it was less work than expected and it's all from the standard packages.</p>
<p>Depending on your situation the below could end up being more involved, e.g. using more structured session representation, etc. Then again you should probably consider more developed frameworks like <a href="https://twistedmatrix.com/trac/" rel="nofollow noreferrer">twisted</a> in that case.</p>
<p>The main points are:</p>
<ul>
<li>Use a <a href="https://docs.python.org/3/library/socketserver.html#socketserver.ThreadingMixIn" rel="nofollow noreferrer">ThreadingMixIn</a> - as the connections are long-lived, a separate handler thread would be needed in order to take more than one connection at a time.</li>
<li>Note that if you are using the <a href="https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler" rel="nofollow noreferrer">BaseHTTPRequestHandler</a>, the connection is closed after each response, unless there is a <code>Connection: keep-alive</code> header or you set <code>self.close_connection = False</code> on EVERY request.</li>
</ul>
<p>Anyway, a snippet to get you started:</p>
<pre><code>from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn

class MyHandler(BaseHTTPRequestHandler):

   # Implement do_GET, do_POST, etc.

   def handle_one_request(self):
      super(MyHandler, self).handle_one_request()
      self.close_connection = some_condition()
      if self.close_connection:
         # Remove the session from the server as it will be closed after this
         # method returns
         self.server.sessions.pop(self.client_address)

class MyServer(ThreadingMixIn, HTTPServer):
   def __init__(self, addr_port, handler_class):
      super(MyServer, self).__init__(addr_port, handler_class)
      self.sessions = {} # e.g. (addr, port) -&gt; client socket

   def get_request(self):
      """Just call the super's method and cache the client socket"""
      client_socket, client_addr = super(MyServer, self).get_request()
      self.sessions[client_addr] = client_socket
      return (client_socket, client_addr)

   # You may also want to add the following
   def server_close(self):
      """Close any leftover connections."""
      super(MyServer, self).server_close()
      for _, sock in self.sessions.items():
         try:
            sock.shutdown(socket.SHUT_WR)
         except socket.error:
            pass
         sock.close()
</code></pre>
</div>
