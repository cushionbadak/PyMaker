<div class="post-text" itemprop="text">
<p>In my application, I use boost_python and python 3.5.2. All built from source in Ubuntu 14.</p>
<p>When I built Python 3.5.2 from source with <code>--with-shared</code> options in Ubuntu, I got <code>libpython3.so</code> (7.6kB) and <code>libpython3.5m.so</code> (12MB). I assume the big one is the real one and the small one might be something forwarding calls to the real interfaces.</p>
<p>As boost_python might assume the client to link against python (<a href="https://svn.boost.org/trac/boost/ticket/2615" rel="nofollow">https://svn.boost.org/trac/boost/ticket/2615</a>), I linked <code>libpython3.so</code> with my application. But when I run it, I got the unresolved symbols error.</p>
<p><code>ldd -r myapp</code> or <code>ldd -r libboost_python.so</code> both listed all python symbols unresolved which could be found in <code>nm -D libpython3.5m.so</code>.</p>
<pre><code># ldd -r lib/libboost_python3.so
    linux-vdso.so.1 =&gt; (0x00007ffe767fb000)
    libstdc+.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc+.so.6 (0x00007f130a7a3000)
    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f130a58d000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f130a1c8000)
    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f1309ec2000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f130acf4000)
undefined symbol: PyExc_ImportError (lib/libboost_python3.so)
undefined symbol: PyProperty_Type (lib/libboost_python3.so)
undefined symbol: PyExc_StopIteration (lib/libboost_python3.so)
undefined symbol: PyBool_Type (lib/libboost_python3.so)
undefined symbol: PyExc_ValueError (lib/libboost_python3.so)
undefined symbol: PyList_Type (lib/libboost_python3.so)
undefined symbol: _Py_NotImplementedStruct (lib/libboost_python3.so)
undefined symbol: PyExc_TypeError (lib/libboost_python3.so)
undefined symbol: PyDict_Type (lib/libboost_python3.so)
...
</code></pre>
<p><code>libpython3.so</code> depend on <code>libpython3.5m.so</code> but itself has no those symbols. </p>
<p>I think based on that I should link my application with <code>libpython3.5m.so</code> instead of with <code>libpython3.so</code>. But the weird thing is that if I use LD_PRELOAD to load the libpython3.so, those symbols are found in <code>ldd -r libboost_python3.so</code></p>
<pre><code># LD_LIBRARY_PATH=lib LD_PRELOAD=lib/libpython3.so ldd -r lib/libboost_python3.so
    linux-vdso.so.1 =&gt; (0x00007ffcb51f0000)
    lib/libpython3.so (0x00007f6f728e3000)
    libstdc+.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc+.so.6     (0x00007f6f725df000)
    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f6f723c9000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f6f72004000)
    libpython3.5m.so.1.0 =&gt; lib/libpython3.5m.so.1.0 (0x00007f6f71ae1000)
    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0     (0x00007f6f718c3000)
    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f6f715bd000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f6f72d32000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f6f713b9000)
    libutil.so.1 =&gt; /lib/x86_64-linux-gnu/libutil.so.1 (0x00007f6f711b6000)
</code></pre>
<p>Why having the <code>libpython3.so</code> and how to use it? Or shall I just only use the <code>libpython3.5m.so</code> directly?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>libpython3.so</code> library is there to support <a href="https://www.python.org/dev/peps/pep-0384/" rel="nofollow noreferrer">PEP 384 -- Defining a Stable ABI</a>.</p>
<p>Historically, Python has not guaranteed ABI stability at the C level between minor version releases (e.g. between 3.4 and 3.5).  They might be source compatible but certain structures might change size, or structure members change type, etc.  However, there are portions of the ABI that are mature and have remained stable over a longer period.</p>
<p>The Stable ABI PEP identified a subset of the Python C API that was stable wouldn't place undue restrictions on future Python development if the developers committed to maintaining binary compatibility for the subset.  If a program or extension limited itself to only using this subset, then it could theoretically be used across different Python versions without recompilation.</p>
<p>Once you've compiled some code using the stable ABI, there is still the question of how to link to the runtime.  For Python 3.5.x, you'd want to link using <code>-lpython3.5m</code>.  For Python 3.6.x, you want <code>-lpython3.6m</code>.  This is where <code>libpython3.so</code> comes in.</p>
<p>The <code>libpython3.so</code> library only has one purpose: for Python 3.5 it links to <code>libpython3.5m.so</code>, and on 3.6 it links to <code>libpython3.6m.so</code>, etc.  So if an extension links using <code>-lpython3</code>, it will have access to the runtime of the version of Python installed on the system.</p>
<p>Now back to your original problem: unless you are absolutely sure that you are only using features found in the stable ABI (which in your case means finding out whether <code>libboost_python</code> only uses the stable ABI), then you probably want to link to the versioned <code>libpython3.5m.so</code>.</p>
<p>If in doubt, you're better off linking to the versioned library: it is much easier to debug a dynamic link error than a segfault due to ABI changes, should you upgrade to a newer version of Python.</p>
</div>
<span class="comment-copy">as I know <code>3.5m</code> is <code>3.5</code> with different memory manager - you should have even program <code>python3.5m</code>. There was some information in Python doc but I don't remember where.</span>
<span class="comment-copy">Unofficial Python repo for Ubuntu/Mint - you can get <code>Python 3.5.2</code> for <code>Ubuntu 14.04</code> - <a href="https://launchpad.net/~fkrull/+archive/ubuntu/deadsnakes" rel="nofollow noreferrer">launchpad.net/~fkrull/+archive/ubuntu/deadsnakes</a></span>
<span class="comment-copy">Thanks @furas. <a href="https://docs.python.org/3/extending/embedding.html" rel="nofollow noreferrer">docs.python.org/3/extending/embedding.html</a> gives a example of the link flasg: -lpython3.4m, I think I should use the <code>python3.5m.so</code> instead of <code>python3.so</code> now.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/16675865/difference-between-python3-and-python3m-executables">Difference between python3 and python3m executables</a> - it seems <code>m</code> use <code>pymalloc</code> instead of <code>malloc</code></span>
<span class="comment-copy">Thanks James. In my case, I should define <code>Py_LIMITED_API</code> while building both <code>boost_python</code> and my app to let them only depend on the stable ABI part. I'll have a try.</span>
<span class="comment-copy">It is certainly worth a try.  But if <code>boost_python</code> fails to compile in limited API mode, it probably isn't worth pursuing.</span>
