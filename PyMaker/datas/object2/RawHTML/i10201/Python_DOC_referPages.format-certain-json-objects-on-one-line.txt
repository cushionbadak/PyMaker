<div class="post-text" itemprop="text">
<p>Consider the following code:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; data = {
...     'x': [1, {'$special': 'a'}, 2],
...     'y': {'$special': 'b'},
...     'z': {'p': True, 'q': False}
... }
&gt;&gt;&gt; print(json.dumps(data, indent=2))
{
  "y": {
    "$special": "b"
  },
  "z": {
    "q": false,
    "p": true
  },
  "x": [
    1,
    {
      "$special": "a"
    },
    2
  ]
}
</code></pre>
<p>What I want is to format the JSON so that JSON objects that have only a single property <code>'$special'</code> are rendered on a single line, as follows.</p>
<pre><code>{
  "y": {"$special": "b"},
  "z": {
    "q": false,
    "p": true
  },
  "x": [
    1,
    {"$special": "a"},
    2
  ]
}
</code></pre>
<p>I have played around with implementing a custom <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder" rel="nofollow"><code>JSONEncoder</code></a> and passing that in to <code>json.dumps</code> as the <code>cls</code> argument, but the two methods on <code>JSONEncoder</code> each have a problem:</p>
<ul>
<li><p>The <code>JSONEncoder</code> <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder.default" rel="nofollow"><code>default</code></a> method is called for each part of <code>data</code>, but the return value is not a raw JSON string, so there doesn't appear to be any way to adjust its formatting.</p></li>
<li><p>The <code>JSONEncoder</code> <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder.encode" rel="nofollow"><code>encode</code></a> method does return a raw JSON string, but it is only called once for the <code>data</code> as a whole.</p></li>
</ul>
<p>Is there any way I can get <code>JSONEncoder</code> to do what I want?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>json</code> module is not really designed to give you that much control over the output; indentation is mostly meant to aid readability while debugging.</p>
<p>Instead of making <code>json</code> produce the output, you could <em>transform</em> the output using the standard library <a href="https://docs.python.org/3/library/tokenize.html" rel="nofollow"><code>tokenize</code> module</a>:</p>
<pre><code>import tokenize
from io import BytesIO


def inline_special(json_data):
    def adjust(t, ld,):
        """Adjust token line number by offset"""
        (sl, sc), (el, ec) = t.start, t.end
        return t._replace(start=(sl + ld, sc), end=(el + ld, ec))

    def transform():
        with BytesIO(json_data.encode('utf8')) as b:
            held = []  # to defer newline tokens
            lastend = None  # to track the end pos of the prev token
            loffset = 0     # line offset to adjust tokens by
            tokens = tokenize.tokenize(b.readline)
            for tok in tokens:
                if tok.type == tokenize.NL:
                    # hold newlines until we know there's no special key coming
                    held.append(adjust(tok, loffset))
                elif (tok.type == tokenize.STRING and
                        tok.string == '"$special"'):
                    # special string, collate tokens until the next rbrace
                    # held newlines are discarded, adjust the line offset
                    loffset -= len(held)
                    held = []
                    text = [tok.string]
                    while tok.exact_type != tokenize.RBRACE:
                        tok = next(tokens)
                        if tok.type != tokenize.NL:
                            text.append(tok.string)
                            if tok.string in ':,':
                                text.append(' ')
                        else:
                            loffset -= 1  # following lines all shift
                    line, col = lastend
                    text = ''.join(text)
                    endcol = col + len(text)
                    yield tokenize.TokenInfo(
                        tokenize.STRING, text, (line, col), (line, endcol),
                        '')
                    # adjust any remaining tokens on this line
                    while tok.type != tokenize.NL:
                        tok = next(tokens)
                        yield tok._replace(
                            start=(line, endcol),
                            end=(line, endcol + len(tok.string)))
                        endcol += len(tok.string)
                else:
                    # uninteresting token, yield any held newlines
                    if held:
                        yield from held
                        held = []
                    # adjust and remember last position
                    tok = adjust(tok, loffset)
                    lastend = tok.end
                    yield tok

    return tokenize.untokenize(transform()).decode('utf8')
</code></pre>
<p>This reformats your sample successfully:</p>
<pre><code>import json

data = {
    'x': [1, {'$special': 'a'}, 2],
    'y': {'$special': 'b'},
    'z': {'p': True, 'q': False}
}

&gt;&gt;&gt; print(inline_special(json.dumps(data, indent=2)))
{
  "x": [
    1,
    {"$special": "a"},
    2
  ],
  "y": {"$special": "b"},
  "z": {
    "p": true,
    "q": false
  }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found the following regex-based solution to be simplest, albeit â€¦ <em>regex-based</em>.</p>
<pre><code>import json
import re
data = {
    'x': [1, {'$special': 'a'}, 2],
    'y': {'$special': 'b'},
    'z': {'p': True, 'q': False}
}
text = json.dumps(data, indent=2)
pattern = re.compile(r"""
{
\s*
"\$special"
\s*
:
\s*
"
((?:[^"]|\\"))*  # Captures zero or more NotQuote or EscapedQuote
"
\s*
}
""", re.VERBOSE)
print(pattern.sub(r'{"$special": "\1"}', text))
</code></pre>
<p>The output follows.</p>
<pre><code>{
  "x": [
    1,
    {"$special": "a"},
    2
  ],
  "y": {"$special": "b"},
  "z": {
    "q": false,
    "p": true
  }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it, but you'd basically have to copy/modify a lot of the code out of <code>json.encoder</code> because the encoding functions aren't really designed to be partially overridden.</p>
<p>Basically, copy the entirety of <code>_make_iterencode</code> from <code>json.encoder</code> and make the changes so that your special dictionary gets printed without newline indents.  Then monkeypatch the json package to use your modified version, run the json dump, then undo the monkeypatch (if you want).</p>
<p>The <code>_make_iterencode</code> function is pretty long, so I've only posted the portions that need to be changed.</p>
<pre><code>import json
import json.encoder

def _make_iterencode(markers, _default, _encoder, _indent, _floatstr,
    ...
    def _iterencode_dict(dct, _current_indent_level):
        ...
        if _indent is not None:
            _current_indent_level += 1
            if '$special' in dct:
                newline_indent = ''
                item_separator = _item_separator
            else:
                newline_indent = '\n' + (' ' * (_indent * _current_indent_level))
                item_separator = _item_separator + newline_indent
            yield newline_indent
        ...
        if newline_indent is not None:
            _current_indent_level -= 1
            if '$special' not in dct:
                yield '\n' + (' ' * (_indent * _current_indent_level))

def main():
    data = {
        'x': [1, {'$special': 'a'}, 2],
        'y': {'$special': 'b'},
        'z': {'p': True, 'q': False},
    }

    orig_make_iterencoder = json.encoder._make_iterencode
    json.encoder._make_iterencode = _make_iterencode
    print(json.dumps(data, indent=2))
    json.encoder._make_iterencode = orig_make_iterencoder
</code></pre>
</div>
<span class="comment-copy">Why do you need this in the first place? The <code>json</code> module is not really set up to let you control the output format to that extent, really.</span>
<span class="comment-copy">Also, when <code>"$special"</code> is present, is it guaranteed to be the only key?</span>
<span class="comment-copy">@MartijnPieters I want to display JSON data in a developer-oriented UI.  JSON objects of the form <code>{'$special': 'some key'}</code> appear abundantly throughout this JSON data, so I was just exploring the possibility of visually compacting it a bit.  It can be assumed that <code>'$special'</code> is the only key if it is present, although I suppose that is orthogonal to what I am really asking: how to locally modify JSON formatting.  It might be the answer is simply "you can't with the <code>json</code> module."</span>
<span class="comment-copy">I've tried to do something very similar to this myself and came up with no dice in the <code>JSONEncoder</code>.  I ended up just giving up the fight and going with a standard prettify.</span>
<span class="comment-copy">I was really hoping to find something like <a href="https://github.com/google/yapf" rel="nofollow noreferrer">yapf</a> but for formatting json, ideally as a Python lib.  I haven't found one yet though.</span>
