<div class="post-text" itemprop="text">
<p>I have the following code, why the first one doesn't change <code>alist</code> while the second changes it?</p>
<pre><code>alist = [[1,2], [3,4], [5,6]]
for item in alist:
    item = 1
print(alist)

alist = [[1,2], [3,4], [5,6]]
for item in alist:
    item = item.append(10)
print(alist)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a somewhat unintuitive behavor of variables. It happens because, in Python, variables are always references to values.</p>
<h1>Boxes and tags</h1>
<p>In some languages, we tend to think about variables as "boxes" where we put values; in Python, however, they are references, and behave more like tags or "nicknames" to values. So, when you attribute 1 to <code>item</code>, you are changing only the variable reference, not the list it is pointing to.</p>
<p>A graphic representation can help. The image below represents the list created by <code>alist = [[1,2], [3,4], [5,6]]</code></p>
<p><a href="https://i.stack.imgur.com/KpcjH.png" rel="noreferrer"><img alt="A list with three sublists" src="https://i.stack.imgur.com/KpcjH.png"/></a></p>
<p>Given that, let's see what happens when we execute your first loop.</p>
<h1>The first loop</h1>
<p>When you execute <code>for item in alist</code>, you are asking the interpreter to take each value from the list, one per time, put it on the variable <code>item</code> and do some operation in it. In the first operation, for example, we have this new schema:</p>
<p><a href="https://i.stack.imgur.com/wPXKX.png" rel="noreferrer"><img alt="Now a variable points to a sublist" src="https://i.stack.imgur.com/wPXKX.png"/></a></p>
<p>Note that we do not copy the sublist to <code>item</code>; instead, we <em>point</em> to it through <code>item</code>. Then, we execute <code>item = 1</code> — but what does it mean? It mean that we are making <code>item</code> point to the value <code>1</code>, instead of pointing to the sublist:</p>
<p><a href="https://i.stack.imgur.com/snmRy.png" rel="noreferrer"><img alt="item points to other value now" src="https://i.stack.imgur.com/snmRy.png"/></a></p>
<p>Note that the old reference is lost (it is the red arrow) and now we have a new. But we just changed a variable pointing to a list — we did not alter the list itself.</p>
<p>Then, we enter to the second iteration of the loop, and now <code>item</code> points to the second sublist:</p>
<p><a href="https://i.stack.imgur.com/ERT2X.png" rel="noreferrer"><img alt="item pointing to the second sublist" src="https://i.stack.imgur.com/ERT2X.png"/></a></p>
<p>When we execute <code>item = 1</code>, again, we just make the variable point to aonther value, without changing the list:</p>
<p><a href="https://i.stack.imgur.com/7jxHt.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/7jxHt.png"/></a></p>
<p>Now, what happens when we execute the second loop?</p>
<h1>The second loop</h1>
<p>The second loop starts as the first one: we make <code>item</code> refer to the first sublist:</p>
<p><a href="https://i.stack.imgur.com/wPXKX.png" rel="noreferrer"><img alt="Now a variable points to a sublist" src="https://i.stack.imgur.com/wPXKX.png"/></a></p>
<p>The first difference, however, is that we call <code>item.append()</code>. <code>append()</code> is a <em>method</em>, so it can change the value of the object it is calling. As we use to say, we are sending a <em>message</em> to the object pointed by <code>item</code> to append the value 10. In this case, the operation is <em>not</em> being made in the variable <code>item</code>, but directly in the object it refers! So here is the result of calling <code>item.append()</code>:</p>
<p><a href="https://i.stack.imgur.com/XXcfr.png" rel="noreferrer"><img alt="A list has grown" src="https://i.stack.imgur.com/XXcfr.png"/></a></p>
<p>However, we do not only append a value to the list! We also assign the value returned by <code>item.append()</code>. This will sever the <code>item</code> reference to the sublist, but here is a catch: <code>append()</code> returns <code>None</code>.</p>
<p><a href="https://i.stack.imgur.com/7T77S.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/7T77S.png"/></a></p>
<h1>The <code>None</code> value</h1>
<p><code>None</code> is a value that represents, basically, the unavailability of a relevant value. When a function returns <code>None</code>, it is saying, most of the time, "I have nothing relevant to give you back." <code>append()</code> does change its list directly, so there is nothing it needs to return.</p>
<p>It is important because you probably believed <code>item</code> would point to the appended list <code>[1, 2, 10]</code>, right? No, now it points to <code>None</code>. So, you would expect the code below...</p>
<pre><code>alist = [[1,2], [3,4], [5,6]]
for item in alist:
    item = item.append(10)
    print(item)
</code></pre>
<p>To print something like this:</p>
<pre><code>[1, 2, 10]
[3, 4, 10]
[5, 6, 10]
</code></pre>
<p>But this <em>does not</em> happen. <em>This</em> is what happens:</p>
<pre><code>&gt;&gt;&gt; alist = [[1,2], [3,4], [5,6]]
&gt;&gt;&gt; for item in alist:
...     item = item.append(10)
...     print(item)
...
None
None
None
</code></pre>
<p>Yet, as we commented, the <code>append()</code> method changed the lists themselves. So, while the <code>item</code> variable was useless after the assignment, the final list is modified!</p>
<pre><code>&gt;&gt;&gt; print alist
[[1, 2, 10], [3, 4, 10], [5, 6, 10]]
</code></pre>
<p>If you want to use the appended list inside the loop, just do not assign the method returned value to <code>item</code>. Do this:</p>
<pre><code>&gt;&gt;&gt; alist = [[1,2], [3,4], [5,6]]
&gt;&gt;&gt; for item in alist:
...     item.append(10)
...     print item
... 
[1, 2, 10]
[3, 4, 10]
[5, 6, 10]
</code></pre>
<p>This works because <code>item</code> will still point to the list.</p>
<h1>Conclusion</h1>
<p>References are somewhat complex to understand at first, let alone master. Yet, they are really powerful and can be learned if you follow examples etc. Your example is a bit complicated because there is more happening here.</p>
<p>The <a href="http://www.pythontutor.com/" rel="noreferrer">Python Tutor</a> can help you understand what is going on, because it executes each step graphically. <a href="http://www.pythontutor.com/visualize.html#code=alist%20%3D%20%5B%5B1,2%5D,%20%5B3,4%5D,%20%5B5,6%5D%5D%0Afor%20item%20in%20alist%3A%0A%20%20%20%20item%20%3D%201%0Aprint(alist%29%0A%0Aalist%20%3D%20%5B%5B1,2%5D,%20%5B3,4%5D,%20%5B5,6%5D%5D%0Afor%20item%20in%20alist%3A%0A%20%20%20%20item%20%3D%20item.append(10%29%0Aprint(alist%29&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=false&amp;mode=display&amp;origin=opt-frontend.js&amp;py=2&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" rel="noreferrer">Check your own code running there!</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In the first example <code>item</code> is bound to each element in list <code>alist</code>, and then <code>item</code> is <em>rebound</em> to the integer <code>1</code>. This does not change the element of the list - it merely <em>rebinds</em> the name <code>item</code> to the <code>int</code> object <code>1</code>.</p>
<p>In the second example the list element (itself a list) is mutated by <code>append()</code>. <code>item</code> is still bound to the sub-list so <code>item.append()</code> mutates the sub-list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you forgetting that <code>list.append()</code> does not return the list itself but actually modifies the list in place?</p>
<p><code>item = 1</code> does as expected. For the rest of the for-loop, item is now <code>1</code>, and not the list it originally was. It won't reassign what <code>item</code> is, that's not what for-loops do.</p>
<p>However, in your second loop, you're now assigning <code>item = None</code>, because the append function does not return anything but it appends the item to the list in place:</p>
<pre><code>&gt;&gt;&gt; L = [1, 2, 3]
&gt;&gt;&gt; L.append(4)
&gt;&gt;&gt; L
[1, 2, 3, 4]
</code></pre>
<p>Thus, your code is basically saying "go through each sublist in my main list and append <code>10</code> to it".</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>=</code> operator does not make any change in the second code, using <code>.append</code> causes changes in <code>alist</code>. Use following line as the third line in the second code. You will see the same result:</p>
<pre><code>item.append(10)
</code></pre>
<p>In the first code <code>item</code> point to another object by <code>item=1</code>, so <code>alist</code> does not change. In the second code you make change on <code>alist</code> by calling <code>append</code> method of it.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's pointer variable in python.</p>
<p>The first example:</p>
<pre><code>for item in alist:
   item = 1
</code></pre>
<p>each item is pointing to each _item in alist but suddenly you change the item value, not the of the value of the _item in alist, as a result nothing change to alist</p>
<p>The second example: </p>
<pre><code>for item in alist:
    item = item.append(10)
</code></pre>
<p>each item is pointing to each _item in alist and then you append something to the item sharing the same memory location of _item, as a result value of _item in alist are changed and alist is changed too.</p>
</div>
<div class="post-text" itemprop="text">
<p>Referencing <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow">the document</a>: </p>
<blockquote>
<p>The for-loop makes assignments to the variables(s) in the target list.
  This overwrites all previous assignments to those variables including
  those made in the suite of the for-loop:</p>
<pre><code>for i in range(10):
    print(i)
    i = 5             # this will not affect the for-loop
                      # because i will be overwritten with the next
                      # index in the range
</code></pre>
</blockquote>
<p>So your second example is identical to:</p>
<pre><code>alist = [[1,2], [3,4], [5,6]]
for item in alist:
    item.append(10)    # this statement modifies each item in alist
                       # , which is what item the variable "points to"
print(alist)
</code></pre>
<p>That is to say, <code>item</code> is a new variable <strong>in every iteration</strong>. As a result, assigning values to it in any specific iteration is pointless, because its value will be overridden by the reference to the next item in <code>alist</code> at the very beginning of the next iteration.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you write</p>
<pre><code>for item in alist:
</code></pre>
<p>You are actually creating a copy of each item in <code>liast</code> in the <code>item</code> variable, and you are <em>not</em> getting a reference to <code>item</code>.</p>
<p>However, <code>append</code> changes the list in-place and doesn't return a value, and that's why you're getting the values changed to <code>None</code> (due to the assignment - if you remove it you'll get the appending working fine).</p>
</div>
<span class="comment-copy">First change if used like this : <code>for item in alist : alist[alist.index(item)]= 1</code> So <code>item</code> is local variable in a loop, do nothing outside.</span>
<span class="comment-copy"><code>for each</code> block in python does not make any copy, i.e <code>item</code> points to each member of <code>alist</code> in every iteration.</span>
