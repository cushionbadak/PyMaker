<div class="post-text" itemprop="text">
<p>I'm trying to use pyaes (<a href="https://github.com/ricmoo/pyaes/blob/master/README.md" rel="nofollow">https://github.com/ricmoo/pyaes/blob/master/README.md</a>) in Python 3 to encrypt and decrypt text using pyaes. When I encrypt text, I give pyaes a <code>str</code> value i.e.</p>
<pre><code>plaintext = 'plain text'
key = os.urandom(16)
aes = pyaes.AESModeOfOperationCTR(key)
ciphertext = aes.encrypt(plaintext)
</code></pre>
<p>when I decrypt though, I get back a <code>bytes</code> type:</p>
<pre><code>aes = pyaes.AESModeOfOperationCTR(key)
decrypted_plaintext = aes.decrypt(ciphertext)
</code></pre>
<p>Printing <code>decrypted_plaintext</code> produces the following output, which seems to contain the original text:</p>
<pre><code>b'plain text'
</code></pre>
<p>But its not quite the same; one is a <code>str</code> the other is a <code>bytes</code>:</p>
<pre><code>plaintext == decrypted_plaintext # False
</code></pre>
<p>I'm struggling to understand the relationship between <code>bytes</code> and whatever Python 3's internal representation of <code>str</code> is. How do I convert the <code>bytes</code> type into <code>str</code> to get my plaintext? </p>
<p>I have confirmed that running the examples on the pyaes readme page have the same problem. I'm guessing that is going to be something to do with encodings.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3 <code>str</code> type represents a string in unicode format. It is composed of relatively abstract codepoints, that is numbers coding characters.
There are several ways to transform (encode) those codepoints to actual bytes which are known as "encodings". utf-8 and utf-16 are some encodings which allow to encode unicode characters.</p>
<p><em>Note that some encoding (as ASCII) does <strong>not</strong> allow to encode unicode characters.</em></p>
<p>When you encode a <code>str</code> string in Python, you obtain a list of bytes of type <code>bytes</code>. You can then decode this list of bytes to get a <code>str</code>string.</p>
<p>The point to keep in mind is that you have to specify an encoding to encode a <code>str</code> string and you have to know the encoding of a <code>bytes</code>string to be able to decode it. If you don't specify encoding, Python will try to encode and decode with its default encoding and you could obtain "random" results.</p>
<p>In you specific case, the difference is not visible because all the characters of your strings are ASCII chars and, fortunately, the 128 first codepoints of unicode match the ASCII table.</p>
<p>Try to introduce some 'exeotic' characters (like é, ç or Ë) in your string and you will see a difference.</p>
<hr/>
<p>Now, pyaes does not encrypt/decrypt unicode codepoints but bytes.
So you have to encode the strings you encrypt and you have to know the used encoding to decode the decrypted strings.</p>
<hr/>
<p>More information in the Python doc:</p>
<ul>
<li><a href="https://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow">bytes</a></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str" rel="nofollow">str</a></li>
<li><a href="https://docs.python.org/3/reference/lexical_analysis.html#strings" rel="nofollow">strings and bytes litterals</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><code>decrypted_plaintext.decode()</code> will give you a <code>str</code>, which will most likely be what you want.  A <code>bytes</code> object is a raw string of bytes in an unspecified encoding.  To convert that to a <code>str</code>, you have to tell Python to decode it using <a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode" rel="nofollow"><code>decode()</code></a>.  <code>decode()</code> defaults to UTF-8, but you can tell it which encoding to use.</p>
<p>I just took a glance at the <a href="https://github.com/ricmoo/pyaes/blob/master/pyaes/aes.py" rel="nofollow">source</a> and I see nothing encoding-specific, so the encoding of the decrypted string should match that of the encrypted string.</p>
</div>
<div class="post-text" itemprop="text">
<p>for all others, this can help you: if <strong>decrypted.decode('utf-8')</strong> == plaintext:</p>
<pre><code>    # A 256 bit (32 byte) key
key = b"This_key_for_demo_purposes_only!"

aes = pyaes.AESModeOfOperationCTR(key)
plaintext = "Text may be any length you wish, no padding is required"
ciphertext = aes.encrypt(plaintext)

# '''\xb6\x99\x10=\xa4\x96\x88\xd1\x89\x1co\xe6\x1d\xef;\x11\x03\xe3\xee
#    \xa9V?wY\xbfe\xcdO\xe3\xdf\x9dV\x19\xe5\x8dk\x9fh\xb87&gt;\xdb\xa3\xd6
#    \x86\xf4\xbd\xb0\x97\xf1\t\x02\xe9 \xed'''
print (repr(ciphertext))

# The counter mode of operation maintains state, so decryption requires
# a new instance be created
aes = pyaes.AESModeOfOperationCTR(key)
decrypted = aes.decrypt(ciphertext)

print(type(decrypted))
print(type(plaintext))

# True
if decrypted.decode('utf-8') == plaintext:
    print(plaintext)
    print(True)
    print(decrypted.decode('utf-8'))


# '''WZ\x844\x02\xbfoY\x1f\x12\xa6\xce\x03\x82Ei)\xf6\x97mX\x86\xe3\x9d
#    _1\xdd\xbd\x87\xb5\xccEM_4\x01$\xa6\x81\x0b\xd5\x04\xd7Al\x07\xe5
#    \xb2\x0e\\\x0f\x00\x13,\x07'''
print (repr(ciphertext))
</code></pre>
</div>
<span class="comment-copy">For difference between <code>bytes</code> (data) and <code>str</code> (text): <a href="http://stackoverflow.com/questions/1736228/python-data-vs-text">stackoverflow.com/questions/1736228/python-data-vs-text</a></span>
<span class="comment-copy">For converting between <code>bytes</code> and <code>str</code>: <a href="http://stackoverflow.com/questions/14010551/how-to-convert-between-bytes-and-strings-in-python-3" title="how to convert between bytes and strings in python 3">stackoverflow.com/questions/14010551/…</a></span>
<span class="comment-copy">ta, thought it would be something around encoding. I really needed the ciphertext in some ASCII-like format so that I could easily store, retrieve and transmit it. I ended up with the something like: <code>utf8 = plaintext.encode('utf-8')</code>, <code>cipherbytes = encrypt(utf8)</code>, <code>cipherb64 = base64.encode(cipherbytes)</code>, <code>cipherutf8 = cipherb64.decode('utf-8')</code>. And the reverse for decryption.</span>
