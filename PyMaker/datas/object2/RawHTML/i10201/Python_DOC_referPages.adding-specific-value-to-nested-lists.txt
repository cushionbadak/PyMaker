<div class="post-text" itemprop="text">
<p>I'm having a comprehension issue on a specific problem. I have a preexisting nested list, and I want to match and append one value from a different list to the end of each nested list. A quick example of what I've tried, but where I'm stuck: </p>
<pre><code> initial_values = [["First", 1], ["Second", 2], ["Third", 3], ["Fourth", 4]]
other_values = [1,2,3,4]

for sublist in initial_values:
    for i in other_values:
        sublist.append(i)


print initial_values
</code></pre>
<p>This returns <code>[['First', 1, 1, 2, 3, 4], ['Second', 2, 1, 2, 3, 4], ['Third', 3, 1, 2, 3, 4], ['Fourth', 4, 1, 2, 3, 4]]</code></p>
<p>I want it it to ideally return <code>[['First', 1, 1], ['Second', 2, 2], ['Third', 3, 3], ['Fourth', 4, 4]]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Your double for-loop takes each sublist in turn (the outer for-loop) and appends every element of <code>other_values</code> to it (the inner for-loop). What you want instead is to add each element of <code>other_values</code> to the corresponding sublist (i.e. the sublist at the same position/index). Therefore, what you need is only one for-loop:</p>
<pre><code>initial_values = [["First", 1], ["Second", 2], ["Third", 3], ["Fourth", 4]]
other_values = [1,2,3,4]

for i in range(len(initial_values)):  # get all the valid indices of `initial_values`
    initial_values[i].append(other_values[i])
</code></pre>
<p>Here's are some simpler ways to do it:</p>
<pre><code>for i,subl in enumerate(initial_values):
    subl.append(other_values[i]))
</code></pre>
<p>Or</p>
<pre><code>for subl, val in zip(initial_values, other_values):
    subl.append(val)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow"><code>zip</code></a> to match elements of the same index from different lists. From there on, you're a simple list concatenation away:</p>
<pre><code>[a + [b] for a,b in zip(initial_values, other_values)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems like you want to go through both lists with a single iteration. You could achieve that using zip:</p>
<pre><code>for sublist, i in zip(initial_values, other_values):
    sublist.append(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use for loop you can try  </p>
<pre><code>initial_values = [["First", 1], ["Second", 2], ["Third", 3], ["Fourth", 4]]
other_values = [1,2,3,4]

for i in range(0,len(other_values)):
    initial_values[i].append(other_values[i])

print initial_values
</code></pre>
<p>output:<br/>
<code>[['First', 1, 1], ['Second', 2, 2], ['Third', 3, 3], ['Fourth', 4, 4]]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Built-in function <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow">zip</a> will match first item in first list with first item in second list etc.</p>
<pre><code>initial_values = [["First", 1], ["Second", 2], ["Third", 3], ["Fourth", 4]]
other_values = [1,2,3,4]

for initials, other in zip(initial_values, other_values):
    initials.append(other)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One of the alternative to achieve it using <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow"><code>map()</code></a> as:</p>
<pre><code>&gt;&gt;&gt; map(lambda x: x[0] + [x[1]], zip(initial_values, other_values))
[['First', 1, 1], ['Second', 2, 2], ['Third', 3, 3], ['Fourth', 4, 4]]
</code></pre>
</div>
<span class="comment-copy">the solution with <code>enumerate</code> seems to be the most efficient one. No need to bother <code>zip</code> for this and create a lot of temporary objects.</span>
<span class="comment-copy">@Jean-FrançoisFabre: in python3, zip doesn't create temp objects - it returns an iterator with pointers to the original objects</span>
<span class="comment-copy">I know that, but the tuples inside still have to be created.</span>
<span class="comment-copy">@Jean-FrançoisFabre: it's still O(1) space, since it's an iterator instead of a full list. Technically <code>enumerate</code> and <code>zip</code> have the same space complexity, though the time complexity may be different due to memory caching</span>
<span class="comment-copy">I was talking about memory allocation avoided by the use of <code>enumerate</code> of course.</span>
