<div class="post-text" itemprop="text">
<p>Could anyone please point out whats wrong with this code. I am trying to return the thread through a variable flag, which I want to control in my main thread. </p>
<h1>test27.py</h1>
<pre><code>import threading
import time

lock = threading.Lock()

def Read(x,y):
    flag = 1
    while True:
        lock.acquire()
        try:
            z = x+y; w = x-y
            print z*w
            time.sleep(1)
            if flag == 0:
                print "ABORTING"
                return
        finally:
            print " SINGLE run of thread executed"
            lock.release()
</code></pre>
<h1>test28.py</h1>
<pre><code>import time, threading

from test27 import Read

print "Hello Welcome"
a = 2; b = 5
t = threading.Thread(target = Read, name = 'Example Thread', args = (a,b))
t.start()
time.sleep(5)
t.flag = 0 # This is not updating the flag variable in Read FUNCTION
t.join() # Because of the above command I am unable to wait until the thread finishes. It is blocking.
print "PROGRAM ENDED"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>Thread</code> class can be instantiated with the <code>target</code> argument. Then you just give it a function which should be raun in a new thread. It is a convenient way to start a simple thread, but for more control it is usualy easier to have a class inherited from <code>Thread</code>, which has additional member variables, like the <code>flag</code> for aborting.</p>
<p>For example:</p>
<pre><code>import time
import threading

class MyThread(threading.Thread):
    def __init__(self, x, y):
        super().__init__()
        # or in Python 2:
        # super(MyThread, self).__init__()
        self.x = x
        self.y = y
        self._stop_requested = False

    def run(self):
        while not self._stop_requested:
            z = self.x + self.y
            w = self.x - self.y
            print (z * w)
            time.sleep(1)

    def stop(self, timeout=None):
        self._stop_requested = True
        self.join(timeout)
</code></pre>
<p>Then, to start the thread, call <code>start()</code> and then to stop it call <code>stop()</code>:</p>
<pre><code>&gt;&gt;&gt; def run_thread_for_5_seconds():
...     t = MyThread(3, 4)
...     t.start()
...     time.sleep(5)
...     t.stop()
...
&gt;&gt;&gt; run_thread_for_5_seconds()
-7
-7
-7
-7
-7
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Regular variables should not be tracked in threads. This is done to prevent race condition. You must use thread-safe constructs to communicate between threads. For a simple flag use <code>threading.Event</code>. Also you cannot access local variable <code>flag</code> via thread object. It is local, and is only visible from scope. You must either use a global variable, as in my example below or create an Object before calling your thread and use a member variable.</p>
<pre><code>from threading import Event
flag = Event()

def Read(x,y):
    global flag
    flag.clear()
    ...
    if flag.is_set():
        return
</code></pre>
<p>main thread:</p>
<pre><code>sleep(5)
flag.set()
</code></pre>
<p>P.S.: I just noticed that you attempted to use lock() in the thread, but failed to use it in the main thread. For a simple flag go with Event. For a lock() you need to lock both parts and mitigate a risk of a deadlock.  </p>
</div>
<span class="comment-copy">While this will work for a simple example, using unsafe thread messaging will blow in your face in a real application. <code>"If you want your threads to stop gracefully, make them non-daemonic and use a suitable signalling mechanism such as an Event."</code> - <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">docs.python.org/3/library/threading.html</a></span>
<span class="comment-copy">For further reading I suggest to look up a problem known as "race condition"</span>
<span class="comment-copy">@Muposat This thread is non-daemonic, because <a href="https://docs.python.org/2/library/threading.html#threading.Thread.daemon" rel="nofollow noreferrer">daemon defaults to False</a>. Assignment <code>self._stop_requested = True</code> is thread-safe. Attribute <code>_stop_requested</code> is written only from the main thread, exactly once before the thread is started and exactly once while it is running. If you see a race condition here, please explain how it can happen.</span>
<span class="comment-copy">I am unable to understand your answer. I tried reading it Could you please explain in beginner terms. I edited my question, like exactly how I am doing it and how I want it, The code works once in a while. I have not defined a global variable as flag.</span>
<span class="comment-copy">Beginner version: 1. you cannot access <code>flag</code> outside of <code>Read</code>. 2. You use <code>lock</code> incorrectly; should use Event instead. Just copy this example: <a href="http://itsjustsosimple.blogspot.com/2014/01/python-thread-synchronization-using.html" rel="nofollow noreferrer">itsjustsosimple.blogspot.com/2014/01/â€¦</a></span>
<span class="comment-copy">I defined flag as global as you mentioned and still cant access it. flag.set() is giving me an error</span>
<span class="comment-copy">what's the error text?</span>
<span class="comment-copy">NameError: name 'flag' is not defined -- Happens at flag.set() in my test28.py. Regarding the lock. Am I using it right in my updated code.</span>
