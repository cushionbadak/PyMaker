<div class="post-text" itemprop="text">
<p>I am trying to write a code that determines the winner of a tic-tac-toe game. (This is for a college assignment)</p>
<p>I have written the following function to do so:</p>
<blockquote>
<p>This code only checks for horizontal lines, I haven't added the rest. I feel that this is something that needs a bit of hardcoding.</p>
</blockquote>
<pre><code>def iswinner(board, decorator):
    win = True
    for row in range(len(board)):
        for col in range(len(board)):
            if board[row][col] == decorator:
                win = True
            else:
                win = False
                break
</code></pre>
<p>Where "board" is a 2D array of size n^2 and "decorator" is the "X" or "O" value</p>
<p>What I hope to accomplish is that the function loops through the 2D array's rows. Then loops through the values in each row. If that element matches the "decorator" then it continues and checks the next but if it doesn't, then it breaks from the first loop and goes to the next row. It does this until it finds n elements in the same row. Then it would give a bool value of True otherwise False.</p>
<p>The code doesn't seem to do that and even when I checked with the following "board" it gave me an output of "True"</p>
<blockquote>
<pre><code>check_list = [['O', 'X', 'X'],
              ['O', 'X', 'O'],
              ['O', 'X', 'X']]
</code></pre>
</blockquote>
<p>Thank you so much!</p>
<p>Best,
Seyed</p>
</div>
<div class="post-text" itemprop="text">
<p>You can just make a set of each row, and check its length. If it contains only one element, then the game has been won.</p>
<pre><code>def returnWinner(board):
    for row in board:
        if len(set(row)) == 1:
            return row[0]
    return -1
</code></pre>
<p>This will return "O" if there is a full line of "O", "X" if there is a line of "X", and -1 otherwise.</p>
<p>Below is the code of a full Tic-Tac-Toe checker, it should not be hard to understand, but do not hesitate to ask:</p>
<pre><code>import numpy as np

def checkRows(board):
    for row in board:
        if len(set(row)) == 1:
            return row[0]
    return 0

def checkDiagonals(board):
    if len(set([board[i][i] for i in range(len(board))])) == 1:
        return board[0][0]
    if len(set([board[i][len(board)-i-1] for i in range(len(board))])) == 1:
        return board[0][len(board)-1]
    return 0

def checkWin(board):
    #transposition to check rows, then columns
    for newBoard in [board, np.transpose(board)]:
        result = checkRows(newBoard)
        if result:
            return result
    return checkDiagonals(board)


a = [['X', 'A', 'X'],
     ['A', 'X', 'A'],
     ['A', 'X', 'A']]

print(checkWin(a))
</code></pre>
<p>Note that this works regardless of the symbols you choose to put in your tic-tac-toe ("O" &amp; "X" is as fine as "bloop" &amp; "!"), and for any size of grid, as long as it is a square.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to do this would be to create a set (a generator function would be even better) of all the possible index combinations to check for the win.  Then loop through those index combinations and check if they all contain the same value, if so, then it's a win.</p>
<pre><code>def win_indexes(n):
    # Rows
    for r in range(n):
        yield [(r, c) for c in range(n)]
    # Columns
    for c in range(n):
        yield [(r, c) for r in range(n)]
    # Diagonal top left to bottom right
    yield [(i, i) for i in range(n)]
    # Diagonal top right to bottom left
    yield [(i, n - 1 - i) for i in range(n)


def is_winner(board, decorator):
    n = len(board)
    for indexes in win_indexes(n):
        if all(board[r][c] == decorator for r, c in indexes):
            return True
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are a total of 3 states that a cell can have</p>
<ol>
<li>0 if it is not yet filled ( There is a possibility that the game gets over in 5 moves)</li>
<li>1 if it is filled with 'X'</li>
<li>-1 if it is filled with 'O'</li>
</ol>
<p>I will expand on @EfferLagan answer</p>
<pre><code>def checkRows(board):
for row in board:
    if (len(set(row)) == 1) and (row[0] != 0):
        return row[0]
return 999

def checkDiagonals(board):
    if (len(set([board[i][i] for i in range(len(board))])) == 1) and (board[0][0] != 0):
        return board[0][0]
    if (len(set([board[i][len(board)-i-1] for i in range(len(board))])) == 1) and (board[0][0] !=0):
        return board[0][len(board)-1]
    return 999

def checkWin(board):
    #transposition to check rows, then columns
    for newBoard in [board, np.transpose(board)]:
        result = checkRows(newBoard)
        if result:
            return result
    return checkDiagonals(board)

randomInput=[
    [0,0,1],
    [-1,-1,1],
    [0,0,0]
]
</code></pre>
<p>You have 3 outputs 1, -1, and 999 ( which means neither won )
    checkWin(randomInput)</p>
</div>
<span class="comment-copy">If you can't understand a part of the code, please tell me</span>
<span class="comment-copy">when do you set <code>win</code> to <code>False</code> ? it's always <code>True</code>. And the logic sounds wrong... indentation is wrong, and you don't return <code>win</code> !! that's beginning to accumulate against your code.</span>
<span class="comment-copy">@Jean-FrançoisFabre I updated the code, somehow that line got lost</span>
<span class="comment-copy">@Jean-FrançoisFabre I am sorry for the indentation, it's fixed now</span>
<span class="comment-copy">What is the decorator?  Don't you need 3 in a row to win in tic-tac-toe?  How can you win based off the value of one cell?</span>
<span class="comment-copy">can you explain what the "set" part is doing?</span>
<span class="comment-copy">It is converting the array to a set. A set is an <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">unordered collection of unique elements</a>. Thus <code>set(['X', 'O', 'X'])</code> only contains <code>'X', 'O'</code>, and <code>set(['X', 'X', 'X'])</code> only contains <code>'X'</code>. If the set only contains one element, then there is only one type of decorator on the line.</span>
<span class="comment-copy">Is there a way to generalise this so that it checks horizontally, vertically, and diagonally or is that impossible?</span>
<span class="comment-copy">Thank you very much for your answer btw</span>
<span class="comment-copy">Yes, this is generallized. It currently checks horizontally, vertically, and diagonally.  If you wanted to add more win conditions (like 4 corners) you would just <code>yield</code> additional indexes from the <code>win_indexes</code> generator.</span>
<span class="comment-copy">Can you please explain what the yield does in your code? I am also reading up on it myself.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/1756096/understanding-generators-in-python" title="understanding generators in python">stackoverflow.com/questions/1756096/…</a></span>
