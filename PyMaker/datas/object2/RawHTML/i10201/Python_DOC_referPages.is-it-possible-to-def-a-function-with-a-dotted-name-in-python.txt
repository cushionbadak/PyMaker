<div class="post-text" itemprop="text">
<p>In the question <a href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do"><em>What does the "yield" keyword do?</em></a>, I found a Python syntax being used that I didn't expect to be valid. The question is old and has a huge number of votes, so I'm surprised nobody at least left a comment about this function definition:</p>
<pre><code>def node._get_child_candidates(self, distance, min_dist, max_dist):
    if self._leftchild and distance - max_dist &lt; self._median:
       yield self._leftchild
    if self._rightchild and distance + max_dist &gt;= self._median:
       yield self._rightchild  
</code></pre>
<p>What I tried to get this sort of syntax evaluated:</p>
<ul>
<li>assigning an attribute to a class or object</li>
<li>redefining a function of an imported module</li>
</ul>
<p>fails so far with </p>
<blockquote>
<p>SyntaxError: invalid syntax</p>
</blockquote>
<p>I looked up the <a href="http://well-adjusted.de/~jrschulz/mspace/">link (maybe outdated)</a> given in the question, and searched the web for the usage of <code>def</code>, but I found nothing explaining this "dotted name" pattern. I'm using Python 3, maybe this is a feature of Python 2?</p>
<p><strong>Is (or was) this syntax valid, if yes what does it mean?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>No, the syntax is not valid. It is easy to prove by checking the documentation. In Python 2, an identifier is constructed by the following <a href="https://docs.python.org/2/reference/lexical_analysis.html#identifiers" rel="nofollow">rules</a>:</p>
<pre><code>identifier ::=  (letter|"_") (letter | digit | "_")*
letter     ::=  lowercase | uppercase
lowercase  ::=  "a"..."z"
uppercase  ::=  "A"..."Z"
digit      ::=  "0"..."9"
</code></pre>
<p>In Py3 the rules are more or less the same, beside being expanded up to the range of Unicode characters.</p>
<p>It seems that the author probably meant something like</p>
<pre><code>class Node:
    ...
    def _get_child_candidates(self, ...):
        ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As in my comment you cannot, the valid identifiers for python3 are in the <a href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers" rel="nofollow">docs</a>:</p>
<p><em>Identifiers (also referred to as names) are described by the following lexical definitions.</em></p>
<p><em>The syntax of identifiers in Python is based on the Unicode standard annex UAX-31, with elaboration and changes as defined below; see also PEP 3131 for further details.</em></p>
<p><em>Within the ASCII range (U+0001..U+007F), the valid characters for identifiers are the same as in Python 2.x: the uppercase and lowercase letters A through Z, the underscore _ and, except for the first character, the digits 0 through 9.</em></p>
<p><em>Python 3.0 introduces additional characters from outside the ASCII range (see PEP 3131). For these characters, the classification uses the version of the Unicode Character Database as included in the unicodedata module.</em></p>
<p>If you examine the code you can see it is a typo in the original question:</p>
<pre><code>def node._get_child_candidates(self, distance, min_dist, max_dist):
    if self._leftchild and distance - max_dist &lt; self._median:
        yield self._leftchild
    if self._rightchild and distance + max_dist &gt;= self._median:
        yield self._rightchild  
</code></pre>
<p>And this is the caller:</p>
<pre><code>result, candidates = list(), [self]
while candidates:
    node = candidates.pop() # creates an instance
    distance = node._get_dist(obj)
    if distance &lt;= max_dist and distance &gt;= min_dist:
        result.extend(node._values)
    # the _get_child_candidates node is called 
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))
return result
</code></pre>
<p>So the method <code>_get_child_candidates</code> is called on the instance. So really the actual code looks like:</p>
<pre><code>def _get_child_candidates(self, distance, min_dist, max_dist):
    if self._leftchild and distance - max_dist &lt; self._median:
        yield self._leftchild
    if self._rightchild and distance + max_dist &gt;= self._median:
        yield self._rightchild  
</code></pre>
<p>And this is the caller:</p>
<pre><code>result, candidates = list(), [self]
while candidates:
    node = candidates.pop() # creates an instance
    distance = node._get_dist(obj)
    if distance &lt;= max_dist and distance &gt;= min_dist:
        result.extend(node._values)
    # the _get_child_candidates node is called 
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))
return result
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers" rel="nofollow noreferrer">docs.python.org/3/reference/lexical_analysis.html#identifiers</a>, so no.</span>
<span class="comment-copy">If you look at the code you also you see  <code>node = candidates.pop()</code> then you see <code>node._get_child_candidates</code>, it is a typo in the function. They are calling the method <code>get_child_candidates</code> on the node instance.</span>
<span class="comment-copy">@PadraicCunningham well, a typo in the very case I referred to, but also invalid syntax in all cases (I tried to figure out the <a href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers" rel="nofollow noreferrer">identifier syntax you mentioned</a> but found the <code>Pc</code>rule a little confusing)?</span>
<span class="comment-copy">the only difference between python2 and python3 is <i>Python 3.0 introduces additional characters from outside the ASCII range</i> i.e non-ascii identifiers, the pep <a href="https://www.python.org/dev/peps/pep-3131/" rel="nofollow noreferrer">python.org/dev/peps/pep-3131</a> goes through it in detail</span>
<span class="comment-copy">Yes, seems to be only a shortcut notation for an in-class definition</span>
