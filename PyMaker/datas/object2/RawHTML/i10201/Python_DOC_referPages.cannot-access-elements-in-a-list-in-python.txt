<div class="post-text" itemprop="text">
<p>I working with bigrams and unigrams. </p>
<p>My bigrams are a counter of tuples and my unigrams are a list, where </p>
<pre><code> uni['some key']=count
</code></pre>
<p>I am trying to do the follwing</p>
<pre><code> for b,countB in bigrams.most_common()
      key=b[0] # this is guaranteed to be a key for my unigrams
      uniCount=uni[key]
</code></pre>
<p>The following error occurs:</p>
<pre><code> TypeError: tuple indeces must be integers or slices, not str
</code></pre>
<p>I am confused.  Why should this be a problem? uni is essentially a hash, its key values are strings. How can I access u[key]?</p>
<p>edit: full code</p>
<pre><code> # corpus is a string containing my corpus
 sp=corpus.split()

 uni={}
 for t in sp:
      try:
           uni[t]+=1
      except:
           uni[t]=0
 prev=''
 big=[]
 for t in sp:
      tup=(prev,t)
      big.append(tup)
      prev=t

 bigrams=collections.Counter(big)

 for b,countB in bigrams.most_common():
      key=b[0]
      uniCount=uni[key]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I tried your code and got a <code>KeyError: ''</code> which happens because your initial bigram has an empty string at position 0 and <code>''</code> is not in your unigrams dictionary. I didn't see a <code>TypeError</code> so that may be from somewhere else in your code. </p>
<p>That said, various other comments: </p>
<ol>
<li><p>You seem to understand what a <code>collections.Counter</code> does, but you're haphazardly trying to do it yourself while building <code>uni</code> -- you can replace your first chunk of code with:</p>
<p><code>unigrams = Counter(sp)</code></p></li>
<li><p>You can use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> to iterate over pairs and construct your bigrams that way, instead of DIY looping it, which also gets rid of your <code>''</code> issue:</p>
<p><code>bigrams = Counter(zip(sp, sp[1:]))</code></p></li>
</ol>
<p>So your code becomes:</p>
<pre><code>sp = corpus.split()
unigrams = Counter(sp)
bigrams = Counter(zip(sp, sp[1:]))

for bigram, count in bigrams.most_common():
    # etc. 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are making the mistake of using a tuple when you perhaps need a dictionary. As the error message state, tuples cannot be indexed by a string key - you are expected to use numeric indices.</p>
<p>A dict will let you use string keys as you appear to want to.</p>
<pre><code>d = {}
d['some key] = 23
</code></pre>
<p>Your updated code gives a much better idea of what you are doing. You start by creating a dict of word counts in <code>uni</code>. I think the line that reads</p>
<pre><code>uni[t] = 0
</code></pre>
<p>should in fact read</p>
<pre><code>uni[t] = 1
</code></pre>
<p>because when that branch is executed you are detecting the first occurrence of a word. Next you create a list of bigram tuples in <code>big</code>, and then you count those bigrams.</p>
<p>I get a bit lost with the final <code>for</code> loop, though, where  <code>b</code> will be the key of a <code>Counter</code> item and <code>countB</code> to be the count. So <code>key</code> will be the first word of the bigram, and <code>uniCount</code> will be the number of times that word appeared in the corpus. Having established these value you then proceed to do nothing with them, and move on to the next most common bigram.</p>
<p>Perhaps it's time to do some printing in that final loop? The code as published otherwise looks reasonable.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have executed your code with <code>corpus = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore"</code> since you said the error was a related to <code>uni</code> being a tuple but it actually is a dictionary.</p>
<p>The error I got is different, it is a <code>KeyError</code> on <code>uniCount=uni[key]</code> because you are creating a list of tuples <code>(previous word, word)</code> and the first word of <code>corpus</code> has previous word set as an empty string (<code>prev=''</code> is the initial state). </p>
<p>The key at the <code>uniCount=uni[key]</code> line is equal to the first item of the tuple (<code>key=b[0]</code>) so as there is no key <code>''</code> in the <code>uni</code> dictionary it is throwing a <code>KeyError</code>.</p>
<p>You may want to get the word, not the previous word of the tuple to be the key used in <code>uni</code>.</p>
</div>
<span class="comment-copy">What do you get when you do <code>print("{}".format(key))</code> just after <code>key=b[0]</code> ?</span>
<span class="comment-copy">Need more code; according to the error it looks like your <code>uni</code> is a <code>tuple</code> while you're claiming it's a <code>dict</code>.</span>
<span class="comment-copy">In fact the statement "my unigrams are a list" conflicts with the example <code>uni['some key'] = count</code>.  Lists cannot be indexed that way either.</span>
<span class="comment-copy">@Samundra when I add that, the same thing is printed as when I do print(key)</span>
<span class="comment-copy">@tzaman added more code</span>
<span class="comment-copy">I am not fully understanding your second point.</span>
<span class="comment-copy">@basil <code>zip</code> iterates over multiple sequences and produces pairs. <code>sp[1:]</code> is the second element onwards from the same list. So <code>zip(sp, sp[1:])</code> produces all of your bigram tuples (instead of manually constructing <code>big</code> in your second loop). I've added a documentation link for <code>zip</code> in the main post.</span>
<span class="comment-copy">I'm not sure if my terminology is correct. I am making the mistake of trying to solve a problem using a language I am not overly familiar with. I added more code above.</span>
<span class="comment-copy">Updated with a fuller analysis of your extended code.</span>
<span class="comment-copy">Note also, as mentioned in other answers, that your first bigram currently has the empty string as its first element, and this may cause issues if it is one of the most common bigrams ... (as it might be in a short corpus).</span>
