<div class="post-text" itemprop="text">
<p>I am new to python and have been using python 3 for my learning. I am using python's unit test framework to test my code.</p>
<p>Problem :-</p>
<p>The function that I need to unit test takes inputs in the following manner:-</p>
<pre><code>def compare():
   a, b, c = input().strip().split(' ')
   d, e, f = input().strip().split(' ')
   # other code here
</code></pre>
<p>I am using the following test case to mock the input :-</p>
<pre><code>class TestCompare(unittest.TestCase):

   @patch("builtins.input", lambda: "1 2 3")
   @patch("builtins.input", lambda: "4 5 6")
   def test_compare(self):
      self.assertEqual(compare(), "1 1")
</code></pre>
<p>The problem I am facing is that when the test case is run the variable triplets a,b,c and d,e,f have the same values - 1,2,3</p>
<p>I have been trying to find a way to inject the second set of inputs to run my test but in vain.</p>
<p>Any help regarding the above is greatly appreciated.</p>
<p>Solution environment :- Python 3</p>
</div>
<div class="post-text" itemprop="text">
<p>The patch decorator will ensure the patched function always return that value, and if subsequent calls must be different, your mock object must have a way to simulate that.  This ends up being much more complicated.</p>
<p>What you can do however is go one step lower and patch the underlying layer, which is the standard input/output layer.  One common strategy that other test frameworks have done is to deal with the <code>sys.stdin</code> and <code>sys.stdout</code> objects directly.  Consider this:</p>
<pre><code>import unittest
from unittest.mock import patch

from io import StringIO

def compare():
    a, b, c = input().strip().split(' ')
    d, e, f = input().strip().split(' ')

    return '%s %s' % (a, d)

class TestCompareSysStdin(unittest.TestCase):

    @patch("sys.stdin", StringIO("1 2 3\n4 5 6"))
    def test_compare(self):
        self.assertEqual(compare(), "1 4")
</code></pre>
<p>Execution</p>
<pre><code>$ python -m unittest foo
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
</code></pre>
<p>Naturally, this works at a lower level, and so the option to have an iterator that returns different values on subsequent calls may be more suitable.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't patch it twice like that.  You'll have to patch it once, with an object that returns different values on subsequent calls.  Here's an example:</p>
<pre><code>fake_input = iter(['1 2 3', '4 5 6']).__next__

@patch("builtins.input", fake_input)
def test_compare(self):
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't patch out your function twice like that. When you are looking to mock the same function, and have it return different values each time it is called, you should use <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow">side_effect</a>.</p>
<p><code>side_effect</code> takes a list of values, where each value in the list is the return of every time that function is called in your code: </p>
<pre><code>class TestCompare(unittest.TestCase):

    @patch("builtins.input", side_effect=["1 2 3", "4 5 6"])
    def test_compare(self, mock_input):
        self.assertEqual(compare(), "1 1") 
</code></pre>
</div>
<span class="comment-copy">I noticed you accepted my answer and then accepted another (which removed the accept from my answer, which is fine, just want to make sure you are aware). Are you aware that you can only accept one answer per question?</span>
<span class="comment-copy">Ooops.. I am sorry for that. Actually the one posted by you and the one posted by wim both worked. I will keep in mind that only one answer can be accepted. Thanks for pointing that out.</span>
<span class="comment-copy">nit - you have a tabbing issue at your <code>def</code></span>
<span class="comment-copy">@idjaw thx - feel free to edit it yourself next time</span>
