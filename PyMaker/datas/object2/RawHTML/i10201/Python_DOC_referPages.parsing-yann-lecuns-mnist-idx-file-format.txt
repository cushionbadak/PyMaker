<div class="post-text" itemprop="text">
<p>I would like to understand how to open <a href="http://yann.lecun.com/exdb/mnist/" rel="noreferrer">this version of the MNIST data set</a>. For example, the training set label file <code>train-labels-idx1-ubyte</code> is defined as: </p>
<pre><code>TRAINING SET LABEL FILE (train-labels-idx1-ubyte):
[offset] [type]          [value]          [description]
0000     32 bit integer  0x00000801(2049) magic number (MSB first)
0004     32 bit integer  60000            number of items
0008     unsigned byte   ??               label
0009     unsigned byte   ??               label
........
xxxx     unsigned byte   ??               label
</code></pre>
<p>And I found some code online that seems to work, but do not understand how it works:</p>
<pre><code>with open('train-labels-idx1-ubyte', 'rb') as f:
    bytes = f.read(8)
    magic, size = struct.unpack("&gt;II", bytes)

print(magic) # 2049
print(size)  # 60000
</code></pre>
<p>My understanding is that <code>struct.unpack</code> interprets the second argument as a big-endian byte string of two 4-byte integers (See <a href="https://docs.python.org/3/library/struct.html" rel="noreferrer">here</a>). When I actually print the value of <code>bytes</code>, though, I get:</p>
<pre><code>b'\x00\x00\x08\x01\x00\x00\xea`'
</code></pre>
<p>The first four-byte integer makes sense:</p>
<pre><code>b'\x00\x00\x08\x01'
</code></pre>
<p>The first two bytes are 0. The next indicates the data are unsigned bytes. And <code>0x01</code> indicates a 1-dimensional vector of labels. Assuming my understanding is correct so far, what is happening with the next three (four?) bytes:</p>
<pre><code>...\x00\x00\xea`
</code></pre>
<p>How does this translate to 60,000?</p>
</div>
<div class="post-text" itemprop="text">
<p>To understand how it works, you need to convert it to its binary representation.</p>
<p>As you mentioned, Python is correctly extracting the right information:</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; with open('train-labels-idx1-ubyte', 'rb') as f:
...     data = f.read(8)
... 
&gt;&gt;&gt; print(data)
b'\x00\x00\x08\x01\x00\x00\xea`'
&gt;&gt;&gt; print(struct.unpack('&gt;II', data))
(2049, 60000)
</code></pre>
<p>In the header of the string, there are two 4-bytes integers. We can see their binary and decimal representation if we iterate over <code>data</code>:</p>
<pre><code>&gt;&gt;&gt; for char in data:
...     print('{0:08b} - {0:3d} - {1:s}'.format(char, str(bytes([char]))))
... 
00000000 -   0 - b'\x00'
00000000 -   0 - b'\x00'
00001000 -   8 - b'\x08'
00000001 -   1 - b'\x01'
00000000 -   0 - b'\x00'
00000000 -   0 - b'\x00'
11101010 - 234 - b'\xea'
01100000 -  96 - b'`'
</code></pre>
<p>The easy part is to know that the first 4 bytes are the first integer (the magic number), and the next 4 bytes are the second integer (the number of items).</p>
<p>Then, given these last 4 bytes, there are two ways one can construct the integer value they represent.</p>
<p>The first option (the one used in MNIST), is big or high endian. Which means, that the MOST significant bytes are found first:</p>
<pre><code>00000000 00000000 11101010 01100000
</code></pre>
<p>If you check the decimal value of this binary number, it is 60,000, the number of items in the MNIST dataset.</p>
<p>Also, we could interpret this as little endian. In this case, the LESS significant bytes are found first:</p>
<pre><code>01100000 11101010 00000000 00000000
</code></pre>
<p>Which in its decimal representation, is the number 1,625,948,160.</p>
<p>So, if you simply convert each byte in <code>\x00\x00\xea`</code> to binary, and you find the decimal representation of that whole binary number (reverting the order of the bytes if little endian), you have the integer value they represent.</p>
</div>
<div class="post-text" itemprop="text">
<p>I wrote the following code in case anyone needs to parse the whole dataset of images (as it appears in the question's title), and not just the first two bytes.</p>
<pre><code>import numpy as np
import struct

with open('samples/t10k-images-idx3-ubyte','rb') as f:
    magic, size = struct.unpack("&gt;II", f.read(8))
    nrows, ncols = struct.unpack("&gt;II", f.read(8))
    data = np.fromfile(f, dtype=np.dtype(np.uint8).newbyteorder('&gt;'))
    data = data.reshape((size, nrows, ncols))
</code></pre>
<p>And just to check, show the first digit. In my case it's a 7.</p>
<pre><code>import matplotlib.pyplot as plt
plt.imshow(data[0,:,:], cmap='gray')
plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/a5wqs.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/a5wqs.png"/></a></p>
</div>
<span class="comment-copy">Can I suggest that you change the title of the question? IMO it is misleading. Yhe question is not how to parse the MNIST dataset, but to understand how a bytes sequence from a file becomes an integer number.</span>
<span class="comment-copy">You can find an already decoded version of the MNIST dataset here: <a href="http://mnist-decoded.000webhostapp.com/" rel="nofollow noreferrer">mnist-decoded.000webhostapp.com</a></span>
