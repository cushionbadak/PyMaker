<div class="post-text" itemprop="text">
<p>My function looks like this:</p>
<pre><code>def accum(s):
    a = []
    for i in s:
        b = s.index(i)
        a.append(i * (b+1))
    x = "-".join(a)
    return x.title()
</code></pre>
<p>with the expected input of:</p>
<pre><code>'abcd'
</code></pre>
<p>the output should be and is:</p>
<pre><code>'A-Bb-Ccc-Dddd' 
</code></pre>
<p>but if the input has a recurring character:</p>
<pre><code>'abccba'
</code></pre>
<p>it returns:</p>
<pre><code>'A-Bb-Ccc-Ccc-Bb-A'
</code></pre>
<p>instead of:</p>
<pre><code>'A-Bb-Ccc-Cccc-Bbbbb-Aaaaaa'
</code></pre>
<p>how can I fix this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use <code>str.index()</code>, it'll return the <em>first match</em>. Since <code>c</code> and <code>b</code> and a appear early in the string you get <code>2</code>, <code>1</code> and <code>0</code> back regardless of the position of the <em>current</em> letter.</p>
<p>Use the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate()</code> function</a> to give you position counter instead:</p>
<pre><code>for i, letter in enumerate(s, 1):
    a.append(i * letter)
</code></pre>
<p>The second argument is the starting value; setting this to 1 means you can avoid having to <code>+ 1</code> later on. See <a href="https://stackoverflow.com/questions/22171558/what-does-enumerate-mean">What does enumerate mean?</a> if you need more details on what <code>enumerate()</code> does.</p>
<p>You can use a list comprehension here rather than use <code>list.append()</code> calls:</p>
<pre><code>def accum(s):
    a = [i * letter for i, letter in enumerate(s, 1)]
    x = "-".join(a)
    return x.title()
</code></pre>
<p>which could, at a pinch, be turned into a one-liner:</p>
<pre><code>def accum(s):
    a = '-'.join([i * c for i, c in enumerate(s, 1)]).title()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is because <code>s.index(a)</code> returns the first index of the character. You can use <code>enumerate</code> to pair elements to their indices:</p>
<p>Here is a Pythonic solution:</p>
<pre><code>def accum(s):
    return "-".join(c*(i+1) for i, c in enumerate(s)).title()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>simple:</p>
<pre><code>def accum(s):
    a = []
    for i in range(len(s)):
        a.append(s[i]*(i+1))
    x = "-".join(a)
    return x.title()
</code></pre>
</div>
<span class="comment-copy">"expected output not as expected"?</span>
<span class="comment-copy">Hint: When <code>i</code> occurs multiple times in <code>s</code>, what will <code>s.index(i)</code> return?</span>
<span class="comment-copy">I was unaware of <code>enumerate(_, starting_index)</code>. I'm not certain if using it for this is more or less Pythonic than incrementing a zero-based index. It's definitely a cool solution though.</span>
<span class="comment-copy">@orlp: why would it be less Pythonic to use a built-in iterator that adds an index counter, eliminating a lot of unnecessary manual counting?</span>
<span class="comment-copy">Because, in my mind, the second you write <code>c * i</code>, <code>i</code> is not an index anymore. In this case it's rather coincidental that the formula of the number of characters is 1 + the zero based index, and I think it's not a bad thing to emphasize that this is indeed a formula, by writing <code>(i + 1)</code>. But I'm not really certain either way. P.S.: <code>join([i * c for i, c in enumerate(s, 1)])</code> hurts my eyes, those superfluous <code>[]</code>.</span>
<span class="comment-copy">@orlp: <code>str.join()</code> <i>requires</i> a list; it'll convert anything else to a list. That makes a generator expression slower here, so I always use a list comp. It's an exception, otherwise I'd agree on the redundancy. See <a href="//stackoverflow.com/a/9061024">List comprehension without [ ] in Python</a></span>
<span class="comment-copy">I wasn't aware of that, regardless I wouldn't write it with superfluous parenthesis unless that code is in a profiled bottleneck. But I see where you're coming from.</span>
