<div class="post-text" itemprop="text">
<p>I have a list of <code>(str,int)</code> pairs </p>
<p><code>list_word = [('AND', 1), ('BECAUSE', 1), ('OF', 1), ('AFRIAD', 1), ('NEVER', 1), ('CATS', 2), ('ARE', 2), ('FRIENDS', 1), ('DOGS', 2)]</code></p>
<p>This basically says how many times each word showed up in a text. </p>
<p>What I want to get is the set of words with maximum occurrence along with maximum occurrence number. So, in the above example, I want to get</p>
<p><code>(set(['CATS', 'DOGS','ARE']), 2)</code></p>
<p>The solution I can think of is looping through the list. But is there any elegant way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Two linear scans, first to find the maximal element:</p>
<pre><code>maxcount = max(map(itemgetter(1), mylist)) 
</code></pre>
<p>then a second to pull out the values you care about:</p>
<pre><code>maxset = {word for word, count in mylist if count == maxcount}, maxcount
</code></pre>
<p>If you needed to get the sets for more than just the maximal count, you can use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a> to accumulate by count in a single pass:</p>
<pre><code>from collections import defaultdict

sets_by_count = defaultdict(set)

for word, count in mylist:
    sets_by_count[count].add(word)
</code></pre>
<p>Which can then be followed by <code>allcounts = sorted(sets_by_count.items(), key=itemgetter(0), reverse=True)</code> to get a <code>list</code> of <code>count, set</code> pairs, from highest to lowest count (with minimal sorting work, since it's sorting only a number of items equal to the unique counts, not all words).</p>
</div>
<div class="post-text" itemprop="text">
<p>Convert <code>list</code> to <code>dict</code> with <em>key</em> as count and <em>value</em> as set of words. Find the <code>max</code> value of key, and it;s corresponding value</p>
<pre><code>from collections import defaultdict
my_list = [('AND', 1), ('BECAUSE', 1), ('OF', 1), ('AFRIAD', 1), ('NEVER', 1), ('CATS', 2), ('ARE', 2), ('FRIENDS', 1), ('DOGS', 2)]
my_dict = defaultdict(set)
for k, v in my_list:
    my_dict[v].add(k)

max_value = max(my_dict.keys())
print (my_dict[max_value], max_value)
# prints: (set(['CATS', 'ARE', 'DOGS']), 2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While the more pythonic solutions are certainly easier on the eye, unfortunately the requirement for two scans, or building data-structures you don't really want is significantly slower.</p>
<p>The following fairly boring solution is about ~55% faster than the dict solution, and ~70% faster than the comprehension based solutions based on the provided example data (and my implementations, machine, benchmarking etc.)</p>
<p>This almost certainly down to the single scan here rather than two.</p>
<pre><code>word_occs = [
    ('AND', 1), ('BECAUSE', 1), ('OF', 1), ('AFRIAD', 1), ('NEVER', 1),
    ('CATS', 2), ('ARE', 2), ('FRIENDS', 1), ('DOGS', 2)
]


def linear_scan(word_occs):
    max_val = 0
    max_set = None

    for word, occ in word_occs:
        if occ == max_val:
            max_set.add(word)

        elif occ &gt; max_val:
            max_val, max_set = occ, {word}

    return max_set, max_val
</code></pre>
<p>To be fair, they are all blazing fast and in your case readability might be more important.</p>
</div>
<span class="comment-copy">Calling your variable <code>list</code> can be a dangerous thing to do.</span>
<span class="comment-copy">Ah, thanks for pointing out. I was just writing here for ease of clarity. Editing now</span>
