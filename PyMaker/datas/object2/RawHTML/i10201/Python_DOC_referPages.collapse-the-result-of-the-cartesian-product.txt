<div class="post-text" itemprop="text">
<p>To calculate cartesian product with python is very simple. Just need to use 
<a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow">itertools.product</a></p>
<pre><code>&gt;&gt;&gt; source = [['a', 'b', 'c'], [1, 2, 3]]
&gt;&gt;&gt; list(itertools.product(*source))
[('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1), ('c', 2), ('c', 3)]
</code></pre>
<p>But I can't find the reverse operation. How to find the source <code>[['a', 'b', 'c'], [1, 2, 3]]</code> from the result of a product. Does anyone know the universal solution?</p>
<p>I appreciate any suggestions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Its only a partial solution but assuming you <strong>know for certain</strong> that the result is a valid cartesian product generated by <code>itertools.product</code> and it is over lists of <strong>distinct</strong> values</p>
<pre><code>&gt;&gt;&gt; [list(collections.OrderedDict.fromkeys(y)) for y in zip(*cartesian_product)]
[['a', 'b', 'c'], [1, 2, 3]]
</code></pre>
<p>Here we simply use the <code>zip(*...)</code> idiom to unpack the tuples and then use <code>OrderedDict</code> in lieu of an <code>OrderedSet</code> to reduce them to their unique values.</p>
<p>This approach generalises to larger <code>itertools.product</code> of distinct values.  For example:</p>
<pre><code>&gt;&gt;&gt; source = [['a', 'b', 'c'], [1, 2, 3], [3, 5, 7]]
&gt;&gt;&gt; cartesian_product = itertools.product(*source)
&gt;&gt;&gt; [list(collections.OrderedDict.fromkeys(y)) for y in zip(*cartesian_product)]
[['a', 'b', 'c'], [1, 2, 3], [3, 5, 7]]
</code></pre>
</div>
<span class="comment-copy">You also want to handle the case, where <code>product</code> was passed the <code>repeat</code> kwarg?</span>
<span class="comment-copy">@MosesKoledoye  for me <code>repeat</code> kwarg is unessential</span>
<span class="comment-copy">Are your input lists distinct values (i.e. is <code>source = [['a', 'b', 'c', 'a'], [1, 2, 3,  1]]</code> possible?</span>
<span class="comment-copy">There's no <i>universally</i> solution to this problem. Say your result is <code>(1, 1), (1, 1), (1, 1), (1, 1)</code>: you can't know if your source lists are <code>(1, 1)  (1, 1)</code> or <code>(1, 1, 1, 1), (1)</code>. This could only work if you add some restrictions, like no duplicate values, fixed number of source lists and fixed order of result, which may or may not be ok in your use case.</span>
<span class="comment-copy">@donkopotamus. The input can be a list of lists/tuples with distict values like <code>source = [['a', 'b', 'c'], [1, 2, 3], [3, 5, 7]]</code></span>
<span class="comment-copy">What about <code>source = ['a','b','c','a'], [1,2,3]]</code>?</span>
<span class="comment-copy">Good point, I'm assuming they are distinct values, I'll add that as a caveat</span>
<span class="comment-copy">It will probably cover most use-cases. But, it's not "universal solution". +1 for <code>OrderedDict</code></span>
<span class="comment-copy">@juanpa.arrivillaga cartesian product (as a math operation) returns a set, so <code>cp(['a','b','c','a'], [1,2,3]) == cp(['a','b','c'], [1,2,3])</code>. The solution looks ok as an inverse of cartesian product, but yes, it has a flaw as <code>itertools.product</code> inverse function. +1 anyway.</span>
<span class="comment-copy">@donkopotamus. Good point. Your answer was helpful for me, thanks.</span>
