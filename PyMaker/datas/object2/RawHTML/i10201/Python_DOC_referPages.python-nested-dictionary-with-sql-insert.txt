<div class="post-text" itemprop="text">
<p>I have generated a very large dictionary after processing an XML file, and I am looking extract from this dictionary and to insert columns and values into my mySQL database table.</p>
<p>I am using Python 3.</p>
<p>The dictionary is nested; here's a simplistic example of what I have:</p>
<pre><code>d ={'Test1'{'TestID':'first','Dev_Type':'this device','Version':'v1_0','Address':'some Address'}
    'Test2'{'TestID':'second','Dev_Type':'that device','Version':'v1_0','Address':'other Address'}
    'Test3'{'TestID','third','Dev_Type':'other device','Version':'v1_0','Address':'another Address'}
} 
</code></pre>
<p>Essentially I want to iterate over each primary Key in this dictionary (e.g. Test1,Test2,Test3) and extract the secondary keys as a column name tuple and the associated seconday key values as a values tuple, a bit like this:</p>
<pre><code>cols = ('TestID','Dev_Type','Version','Address')
vals = ('first','this device','v1_0','some Address')
</code></pre>
<p>On iterating over each primary key I will add the two tuples to my mySQL table using this command:</p>
<pre><code>sql = "INSERT INTO Parameters ({0}) VALUES ({1})".format(', '.join(cols), ', '.join(['%s'] * len(cols)));
try:
    cursor.execute(sql, vals)
except Exception as e:
    print(e)
    pass
</code></pre>
<p>Then repeat the process on the next primary key ('Test2').</p>
<p>I have made an initial attempt, but have hard coded the Primary key in this instance:</p>
<pre><code>for k, v in d:
    #Missing appropriate method here
    cols = tuple(d['Test1'].keys())
    vals = tuple(d['Test1'].values())

    sql = "INSERT INTO Parameters ({0}) VALUES ({1})".format(', '.join(cols), ', '.join(['%s'] * len(cols)));
    try:
        cursor.execute(sql, vals)
    except Exception as e:
        pass

connection.close()
return
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can iterate over <code>d.values()</code> and use the <code>.keys()</code> and <code>.values()</code> methods on the nested dictionaries to get the columns and values:</p>
<pre><code>for v in d.values():
    cols = v.keys()
    vals = v.values()

    sql = "INSERT INTO Parameters ({}) VALUES ({})".format(
        ', '.join(cols),
        ', '.join(['%s'] * len(cols)));
    try:
        cursor.execute(sql, vals)
    except Exception as e:
        pass
</code></pre>
<p>Note that in Python 3 <a href="https://docs.python.org/3/library/stdtypes.html#dict.keys" rel="nofollow"><code>dict.keys()</code></a> and <a href="https://docs.python.org/3/library/stdtypes.html#dict.values" rel="nofollow"><code>dict.values()</code></a> return <em>views</em> of the dictionaryâ€™s keys and values (unlike lists in Python 2).</p>
</div>
<div class="post-text" itemprop="text">
<p>Iterating over a dictionary actually iterates over the keys. <code>for k in d:</code> is equivalent to <code>for k in d.keys():</code>. You are looking for the <code>values</code> or <code>items</code> methods, which will actually return the key and the value as a tuple:</p>
<pre><code>for k, v in d.items():
    # k will take the values 'Test1', 'Test2', etc.
    # v will take the values of the corresponding nested dicts.
</code></pre>
<p>or</p>
<pre><code>for v in d.values():
    # v will take on the values of the nested dicts.
</code></pre>
<p>I would recommend using <code>items</code> over <code>values</code> since that way you will have a reference to which primary key (test) you are processing. I am going to go out on a limb here and guess that you will need this for the non-trivial version of your program.</p>
<p>From there, you use <code>v</code> as you are trying to use <code>d[...]</code>, since that is exactly what it is:</p>
<pre><code>for k, v in d.items():
    cols = v.keys()
    vals = v.values()

    sql = "INSERT INTO Parameters ({0}) VALUES ({1})".format(
                ', '.join(cols),
                ', '.join(['%s'] * len(v))
    )

    try:
        cursor.execute(sql, vals)
    except Exception as e:
        pass

connection.close()
return
</code></pre>
<p>Since <code>v</code> is a nested dictionary, you can get the number of elements in both <code>cols</code> and <code>vals</code> as just <code>len(v)</code>.</p>
</div>
<span class="comment-copy">This is tangential, but you should use the database API's parameter substitution to guard against SQL injections: <a href="https://docs.python.org/2/library/sqlite3.html#sqlite3.Cursor.execute" rel="nofollow noreferrer">docs.python.org/2/library/sqlite3.html#sqlite3.Cursor.execute</a></span>
<span class="comment-copy">Did you mean to leave out the <code>:</code> between the keys and values in your example dict?</span>
<span class="comment-copy">Is there any guarantee that <code>v.values()</code> will always come in the same order as the list of keys <code>list(v)</code>? Else, you'll be inserting the wrong values in mismatching columns</span>
<span class="comment-copy">There <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">is</a> such guarantee for <code>d.keys()</code> and <code>d.values()</code>. There's no mention of <code>list(d)</code> though.</span>
<span class="comment-copy">Yep, that looks better</span>
<span class="comment-copy">You can do <code>len(v)</code> instead of needlessly converting <code>cols</code> to a list.</span>
<span class="comment-copy">@Mad Physicist Why? <code>len(cols)</code> would work as well.</span>
