<div class="post-text" itemprop="text">
<p>Recently I am developing a device base on raspberrypi 2b+ which connected to mpu9250(welding by myself).</p>
<p>I could read 9-axis data correctly, but I noticed that each data input with different time differential:</p>
<p><a href="https://i.stack.imgur.com/g2izc.png" rel="nofollow noreferrer"><img alt="" src="https://i.stack.imgur.com/g2izc.png"/></a></p>
<p>the figure shows the time differential between each two data.
But I have used QTimer to make sure my code every 10ms reading mpu9250 once.</p>
<p>So I tried this code on RaspberryPi 2b+:</p>
<pre><code>import time
import matplotlib.pyplot as plt

time_arr = []
for i in range(5000):
    t0 = time.time()
    print "K"
    t1 = time.time() - t0
    time_arr.append(t1)

plt.plot(time_arr)
plt.show()
</code></pre>
<p>And result:</p>
<p><a href="https://i.stack.imgur.com/8Tx9n.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/8Tx9n.png"/></a></p>
<p>even these simple code still shows peaks on diagram, and it's put me down...</p>
<p>Could anyone helps me solve these issue or explains what's going on?</p>
</div>
<div class="post-text" itemprop="text">
<p>In your first test you are using QTimer which treats the timer as a background task. QT is primarily focused on providing a responsive GUI.  </p>
<p>In your second test you have a print statement in the loop -- there are any number of factors involved in printing that can cause a variation in the time needed to execute the statement.  </p>
<p>Take a look at the <a href="https://docs.python.org/3/library/threading.html" rel="nofollow"><code>threading.Timer</code></a> class for a better approach.</p>
<p>The documentation says:</p>
<blockquote>
<p>This class represents an action that should be run only after a certain amount of time has passed â€” a timer. Timer is a subclass of Thread and as such also functions as an example of creating custom threads.</p>
<p>Timers are started, as with threads, by calling their start() method. The timer can be stopped (before its action has begun) by calling the cancel() method. </p>
</blockquote>
<p>Note that it also says:</p>
<blockquote>
<p>The interval the timer will wait before executing its action may not be exactly the same as the interval specified by the user.</p>
</blockquote>
<p>In other words, it won't be perfect, but it is quite likely to be significantly better than what you are seeing now.</p>
<hr/>
<p>If you are interested in MEASURING time with higher precision as opposed to scheduling tasks with better precision, consider using <a href="https://docs.python.org/3/library/time.html" rel="nofollow"><code>time.perf_counter()</code></a> which is available in Python 3.</p>
</div>
<span class="comment-copy">Is the problem that the Pi has inconsistent performance/scheduling? If so, consider using a real time OS for your problem</span>
<span class="comment-copy">I installed rasbian-jessie and update to latest version....and I run my code on graphic environment....is that matters?</span>
<span class="comment-copy">yes, it does matter, do you need the graphical environment to run your code? you may try to limit your processes to improve the performance</span>
<span class="comment-copy">Sorry but it's necessary for me to run the script in graphical environment...so I think that inconsistent data reading time just can't be avoid....</span>
