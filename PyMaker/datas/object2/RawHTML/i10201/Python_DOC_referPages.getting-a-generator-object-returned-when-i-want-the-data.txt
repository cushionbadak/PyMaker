<div class="post-text" itemprop="text">
<p>I am very very new to Python 3, so please be nice.</p>
<p>I have looked at all the documentation I could find regarding this - there does seem to be a lot, it's just I still cannot figure out what to do.</p>
<p>This is my code:</p>
<pre><code>poly = [[36606.0,53223.0],[37332.0,52224.0],[39043.0,53223.0],
[41603.0,53223.0],[42657.0,53278.0],[43123.0,52060.0],
[44054.0,51156.0],[45806.0,51498.0],[46751.0,53237.0],
[46983.0,54606.0],[45861.0,57057.0],[44971.0,58836.0],
[44054.0,60616.0],[43451.0,58138.0],[41850.0,59179.0],
[40850.0,60370.0],[39906.0,59233.0],[38674.0,59179.0],
[35566.0,56249.0],[37592.0,57536.0]]

def perimeter():
     return (sum((abs((x1 - x0)**2)+abs((y1 - y0)**2))**.5)
                        for ((x0, y0), (x1, y1)) in parts1(poly))

def parts1(poly):
    return poly[0:] + [poly[0]]

print(perimeter())
</code></pre>
<p>It is running <em>without</em> any errors but I am getting a return of:</p>
<p><code>generator object perimeter.locals.genexpr at 0x7f47d8671c50</code></p>
<p>How do I make it so that it gives me the value/answer?
I am really not sure what is going on.</p>
</div>
<div class="post-text" itemprop="text">
<p>Wrapping an <code>item for item in iterable</code> construct in parentheses makes it a lazy generator expression, which has the appearance you see. Now, the reason it does this instead of giving you an error that you would get from trying to send a non-iterable to <code>sum()</code> is because it doesn't evaluate anything. If you sent this generator expression to <code>list()</code> to evaluate it, you would get an error.</p>
<p>You need to move some parentheses around:</p>
<pre><code>sum((abs((x1 - x0)**2)+abs((y1 - y0)**2))**.5
                        for ((x0, y0), (x1, y1)) in parts1(poly))
</code></pre>
<p>Now you have <code>sum(expression for element in parts1(poly))</code> rather than <code>(sum(expression) for element in parts1(poly))</code>.</p>
<p>Small test:</p>
<pre><code>&gt;&gt;&gt; x1, x0, y1, y0 = 3, 1, 5, 4
&gt;&gt;&gt; sum((abs((x1 - x0)**2)+abs((y1 - y0)**2))**.5
...     for ((x0, y0), (x1, y1)) in [((x0,y0), (x1, y1))])
2.23606797749979
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first problem is that you have your parentheses in the wrong places. You want to call <code>sum()</code> on a generator expression, but instead you have written a generator expression using <code>sum()</code>. So you might try this:</p>
<pre><code>def perimeter():
    return sum(((x1 - x0) ** 2) + ((y1 - y0) ** 2) ** .5
                 for (x0, y0), (x1, y1) in parts1(poly))
</code></pre>
<p>(I have also taken out your <code>abs()</code> calls, since squaring a number will make it positive, making <code>abs()</code> irrelevant, and deleted some unnecessary parentheses.)</p>
<p>But this still doesn't work: now you get <code>'float' object is not iterable</code>.</p>
<p>This is because you are trying to unpack four values from each element of the list, but each element contains only two. Python unpacks each element to two floats, then tries to unpack each float to two variables. This is where the error message rears its ugly head.</p>
<p>So you need to change <code>parts1()</code> to return a list of a list of lists of lists. That is, each item in the list is a list, which contains two lists, each containing the coordinates of a point (a given point and its successor). One way to do this is to use the built-in <code>zip()</code> function with an offset or rotated copy of the list.</p>
<pre><code>def parts1(poly):
    return zip(poly, poly[1:] + poly[:1])
</code></pre>
<p>Finally, you don't really need the separate function <code>parts1()</code>â€”it can go right in the <code>perimeter()</code> function. And you should pass <code>poly</code> into <code>perimeter()</code>.</p>
<pre><code>def perimeter(poly):
    return sum(((x1 - x0) ** 2) + ((y1 - y0) ** 2) ** .5
                 for (x0, y0), (x1, y1) in zip(poly, poly[1:] + poly[:1]))
</code></pre>
<p>You could do this without the extra copy of the list by iterating over the coordinates in <code>poly</code> and keeping track of the last items you saw. But you couldn't write it as a generator expression. Instead you'd use a regular <code>for</code> loop.</p>
<pre><code>def perimeter(poly):
    x0, y0 = poly[-1][0], poly[-1][1]
    per = 0.0
    for x1, y1 in poly:
        per += ((x1 - x0) ** 2) + ((y1 - y0) ** 2) ** .5
        x0, y0 = x1, y1
    return per 
</code></pre>
<p>Not quite as succinct, and not as fast either, but doesn't use as much memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code has two problems. One is due to parentheses as @TigerhawkT3 pointed out, and the other is you're not iterating through the points properly. The code below addresses both these issues.</p>
<pre><code>poly = [[36606.0,53223.0],[37332.0,52224.0],[39043.0,53223.0],
        [41603.0,53223.0],[42657.0,53278.0],[43123.0,52060.0],
        [44054.0,51156.0],[45806.0,51498.0],[46751.0,53237.0],
        [46983.0,54606.0],[45861.0,57057.0],[44971.0,58836.0],
        [44054.0,60616.0],[43451.0,58138.0],[41850.0,59179.0],
        [40850.0,60370.0],[39906.0,59233.0],[38674.0,59179.0],
        [35566.0,56249.0],[37592.0,57536.0]]

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = iter(iterable), iter(iterable)
    next(b, None)
    return zip(a, b)

def parts1(poly):
    return poly[0:] + [poly[0]]

def perimeter():
    return sum((abs((x1 - x0)**2)+abs((y1 - y0)**2))**.5
                    for ((x0, y0), (x1, y1)) in pairwise(parts1(poly)))

print(perimeter())  # -&gt; 41095.327046386046
</code></pre>
<p>Also note that you could simplify (and speed up) the calculation you're doing by using the built-in <a href="https://docs.python.org/3/library/math.html#math.hypot" rel="nofollow"><code>math.hypot()</code></a> function:</p>
<pre><code>import math

def perimeter2():
    return sum(math.hypot(x1-x0, y1-y0) 
                for ((x0, y0), (x1, y1)) in pairwise(parts1(poly)))

print(perimeter2())  # -&gt; 41095.327046386046
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would try something a bit more explicit like this, this matches your expected answer</p>
<pre><code>import itertools

def calculate_length(x0, x1, y0, y1):
    return ((x1 - x0)**2+(y1 - y0)**2)**.5

def make_point_pairs(poly):
    pairs = zip(poly, poly[1:])
    # Close the shape
    chain = itertools.chain(pairs, [[poly[-1],poly[0]]])
    return chain

def perimeter(poly):
     return sum([calculate_length(x0, x1, y0, y1) for ((x0, y0), (x1, y1)) in make_point_pairs(poly)])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am also a little confused about your question, it seems that you are not intentionally using the generator and just wants to get the perimeter?
I think it would be better to clean up the function <code>perimeter()</code> a little bit and not use a generator there, and simply iterate through the list <code>poly</code> and taking every adjacent pair and calculate it this way.</p>
<pre><code>poly = [[36606.0,53223.0],[37332.0,52224.0],[39043.0,53223.0],
[41603.0,53223.0],[42657.0,53278.0],[43123.0,52060.0],
[44054.0,51156.0],[45806.0,51498.0],[46751.0,53237.0],
[46983.0,54606.0],[45861.0,57057.0],[44971.0,58836.0],
[44054.0,60616.0],[43451.0,58138.0],[41850.0,59179.0],
[40850.0,60370.0],[39906.0,59233.0],[38674.0,59179.0],
[35566.0,56249.0],[37592.0,57536.0]]

def perimeter():
    #return (sum((abs((x1 - x0)**2)+abs((y1 - y0)**2))**.5) \
                        #for ((x0, y0), (x1, y1)) in parts1(poly))
    peri=0
    for [x0, y0], [x1, y1] in get_pair(poly):
        peri+=((x1-x0)**2 + (y1-y0)**2)**0.5
    return peri

def get_pair(poly):
    i=0
    while i&lt;len(poly):
        yield [poly [i],poly [(i+1)%len(poly)]] #The modulo takes the pair of last and first coordinates into account
        #So that when poly [i] is the last coordinate it is returned with the first coordinate
        i+=1

print(perimeter())
</code></pre>
<p>I used a generator function for <code>get_pair()</code> function, but you can also do it with a loop or some other way. It basically just returns a new pair in the list every time you call it.</p>
</div>
<span class="comment-copy">I assume the value/answer you're after is the perimeter of the polygon?</span>
<span class="comment-copy">Tip: <a href="https://wiki.python.org/moin/PythonEditors" rel="nofollow noreferrer">find a text editor</a> that is aware of Python syntax and has <a href="https://en.wikipedia.org/wiki/Comparison_of_text_editors#Programming_features" rel="nofollow noreferrer">brace matching</a>. Using such an editor will help you avoid this error in the future.</span>
<span class="comment-copy">Off-topic: Taking the <code>abs()</code> of <code>(x1 - x0)**2</code> isn't necessary because it will always result in a positive value (even if <code>(x1 - x0)</code> is negative).</span>
<span class="comment-copy">I got my answer to spit out 41095.327, forgot to close the shape initially by matching the last point with the first point</span>
<span class="comment-copy">Thank you for your quick response!</span>
<span class="comment-copy">I am getting an error now:</span>
<span class="comment-copy">TypeError: 'float' object is not iterable</span>
<span class="comment-copy">The only problem I am coming across now is that the answer is coming out incorrect, I believe the answer should be: <b>41095.327</b>, but trying this method or the method @Selecsosi recommends is giving different answers to each other and the real answer...</span>
<span class="comment-copy">It's ok, I used this method:</span>
<span class="comment-copy">'def perimeter():     return sum((((x1 - x0) ** 2) + ((y1 - y0) ** 2)) **.5                  for (x0, y0), (x1, y1) in parts1(poly)) 	 def parts1(poly):     return zip(poly,poly[1:] + [poly[0]])  print(perimeter())'  But had to put in some more parentheses, as the whole lot wasn't being square rooted (or raised to 0.5).</span>
<span class="comment-copy">Sorry about above - I thought I had marked it as code.</span>
<span class="comment-copy"><code>math.hypot()</code> computes the square root of the sum of the square of the two values you pass it. So the code should be computing the sum of the distances between every pair of points in the polygon. To make testing easier, I suggest you try using a simple rectangular or square  shape as input.</span>
