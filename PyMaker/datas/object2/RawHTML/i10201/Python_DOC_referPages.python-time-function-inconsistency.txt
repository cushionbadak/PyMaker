<div class="post-text" itemprop="text">
<p>I've been gave an assignment were i had to create two small functions that gives, with equal chance, "heads" or "tails" and, similary with a 6 faces thrown dice, 1,2,3,4,5 or 6.</p>
<p>Important: I could NOT use randint or similar functions for this assignment.</p>
<p>So i've created those two functions that generate a 'pseudo-random number' utilizing time (first digit of the milliseconds) function from python library:</p>
<pre><code>import time

def dice():
    ctrl = False
    while ctrl == False:
            m = lambda: int(round(time.time() * 1000))
            f = m()
            d = abs(f) % 10
            if d in range(1,7):
                    return d
                    ctrl = True


def coin():
        m = lambda: int(round(time.time() * 1000))
        f = m()
        if f % 2 == 0:
                return "Tails"
        elif f == 0:
                return "Tails"
        else:
                return "Heads" (EDIT: I don't know why i typed "Dimes" before)
</code></pre>
<p>However i've observed a tendency to give 'Tails' over 'Heads', so i've created an function to test the percentage of 'Tails' and 'Heads' in 100 throws:</p>
<pre><code>def _test():
    ta = 0
    he = 0
    x = 100
    while x &gt; 0:
        c = coin()
        if c == "Tails":
            ta += 1
        else:
            he += 1
    x -= 1
    time.sleep(0.001)
print("Tails:%s Heads:%s" % (ta, he))
</code></pre>
<p>The result of the test was (for several times):</p>
<pre><code>Tails:56 Heads:44
</code></pre>
<p>So i did the same thing with the dice function and the result was:</p>
<pre><code>1:20 2:20 3:10 4:20 5:10 6:20
</code></pre>
<p>So, as you can see, for some reason i could not infer - if it is by some mistake of my or some other reason - the time function has a tendency to give less '3' and '5', and running the test again with all the numbers (zeros, sevens, eights and nines included) i've come to see that this tendency extends to '0' and '7'.</p>
<p>I would be grateful for some insight and opinions on the matter.</p>
<p>EDIT:</p>
<p>Remove the round() function from the <code>m = lambda: int(round(time.time() * 1000))</code> function solved the problem - as answered by Makoto.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your utilization of <code>round</code> means that your coin flip function will tend towards even numbers if the values you get from your time-based random operation are equidistant from one another (i.e. you "flip" your coin more consistently every half second due to your computer internals).</p>
<p><a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow">From the documentation</a>:</p>
<blockquote>
<p>For the built-in types supporting <code>round()</code>, values are rounded to the closest multiple of 10 to the power minus <em>ndigits</em>; if two multiples are equally close, rounding is done toward the even choice (so, for example, both <code>round(0.5)</code> and <code>round(-0.5)</code> are 0, and <code>round(1.5)</code> is 2).</p>
</blockquote>
<p>It appears that both of your methods suffer from this sort of bias; if they're executed too quickly after one another, or too close to a single timestamp, then you can tend to get <em>one</em> value out of it:</p>
<pre><code>&gt;&gt;&gt; [dice() for x in range(11)]
[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
&gt;&gt;&gt; [coin() for x in range(11)]
['Dimes', 'Dimes', 'Dimes', 'Dimes', 'Dimes', 'Dimes', 'Dimes', 'Dimes', 'Dimes', 'Dimes', 'Dimes']
</code></pre>
<p>The only realistic thing that you could do is to regenerate the time sample if the values are sufficiently close to one another so that you don't run into time-based biases like this, or generate ten time samples and take the average of those instead.  Principally, if your computer moves quickly enough and executes these functions fast enough, it <em>will</em> likely pull the same timestamp, which will lead to a strong time-based bias.</p>
</div>
<span class="comment-copy">100 simulations is not a large enough sample size for this kind of test. Why not run 100,000+ simulations and see how the results differ?</span>
<span class="comment-copy">Are <code>56</code> and <code>44</code> really statistically significantly different? Could be a not unlikely with outcome with a fair-coin? Likewise for the dice values. Use a larger sample size and then do some stats</span>
<span class="comment-copy">PrestonM I've runned more simulations (10000+), the results had the same tendency (less 0, 3, 5, 7: ~650 over ~1250 in the other numbers)</span>
<span class="comment-copy">Chris_Rands I would never call heads in a coin with +10% chance to give tails</span>
<span class="comment-copy">How likely is <code>time.time()</code> to return <i>exactly</i> <code>.5</code>? Surely this (almost) never happens?</span>
<span class="comment-copy">THANKS! I remove the round() function from the algorithm and that did the job! Tests now give almost 50/50, varying between them: <code>Tails:45 Heads:55</code>; <code>Tails:54 Heads:46</code>; <code>Tails:49 Heads:51</code>. It was a mistake of mine afterall.</span>
