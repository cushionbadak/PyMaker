<div class="post-text" itemprop="text">
<p>Following is my code:</p>
<pre><code>import socket
import time
mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
mysock.connect(('www.py4inf.com', 80))
mysock.send(b'GET /code/romeo.txt HTTP/1.1\n')
mysock.send(b'Host: www.py4inf.com\n\n')
all = b""

while True:
    data = mysock.recv(512)
    all = all + data
    if len(data) &lt; 1:
        break

mysock.close()

stuff = all.decode()
position = stuff.find('\r\n\r\n')
print(stuff[position+4:])
</code></pre>
<p>There must be something wrong because it takes almost 30 seconds to invoke break in while loop.
However, if I change the code <code>if len(data) &lt; 1:</code> to <code>if len(data) &lt; 100:</code> it took just 0.5 second.</p>
<p>Please help. It haunted me for a while.
The sample website: <a href="http://www.py4inf.com/code/romeo.txt" rel="nofollow">http://www.py4inf.com/code/romeo.txt</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Web servers don't have to close connections immediately.In fact, they may be looking for another http request.  Just add <code>print(data)</code> after the recv and you'll see you get the data, then a pause, then <code>b''</code>, meaning the server finally closed the socket.</p>
<p>You'll also notice that the server sends a header that includes "Content-Length: 167\r\n". Once the header has finished, the server will send exactly 167 bytes of data. You could parse out the header yourself but that's why we have client libraries like <code>urllib</code> and <code>requests</code>.</p>
<p>I was curious about how much would need to be added to the request header to get the connection to close immediately, and <code>Connection: close</code> seemed to do it. This returns right away:</p>
<pre><code>import socket
import time
mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
mysock.connect(('www.py4inf.com', 80))
mysock.send(b'GET /code/romeo.txt HTTP/1.1\n')
mysock.send(b'Connection: close\n')
mysock.send(b'Host: www.py4inf.com\n\n')
all = b""

while True:
    data = mysock.recv(512)
    all = all + data
    if len(data) &lt; 1:
        break

mysock.close()

stuff = all.decode()
position = stuff.find('\r\n\r\n')
print(stuff[position+4:])
</code></pre>
</div>
<span class="comment-copy">This makes perfect sense - of course it takes longer for some extremely unlikely to occur, versus something much more likely. Instead, ask yourself what you're trying to do with the break. When do you want to stop listening on the socket?</span>
<span class="comment-copy">This question has been discussed lots of times here on SO (for example here: <a href="http://stackoverflow.com/questions/17667903/python-socket-receive-large-amount-of-data" title="python socket receive large amount of data">stackoverflow.com/questions/17667903/â€¦</a>). There is nothing wrong with your code. This is just how sockets work. mysock.recv(512) waits for 512 Bytes. After some time, the connection is simply dropped. Have a look at the Python docs for non-blocking sockets: <a href="https://docs.python.org/3/howto/sockets.html#non-blocking-sockets" rel="nofollow noreferrer">docs.python.org/3/howto/sockets.html#non-blocking-sockets</a></span>
<span class="comment-copy">I get it! I modify the code above to if len(data) &lt; 100, that works because the second receive from mysock.recv(512) is under 100 by accident. That's why it could cut down the running time so much.  Also, really appreciate your comment so that I am more familiar with socket a little bit. Hope I could be as good as you guys some day.</span>
<span class="comment-copy">thanks a lot, appreciate it!</span>
