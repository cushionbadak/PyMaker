<div class="post-text" itemprop="text">
<p>On codewars.com I encountered the following task:</p>
<blockquote>
<p>Create a function <code>add</code> that adds numbers together when called in succession. So <code>add(1)</code> should return <code>1</code>, <code>add(1)(2)</code> should return <code>1+2</code>, ...</p>
</blockquote>
<p>While I'm familiar with the basics of Python, I've never encountered a function that is able to be called in such succession, i.e. a function <code>f(x)</code> that can be called as <code>f(x)(y)(z)...</code>. Thus far, I'm not even sure how to interpret this notation. </p>
<p>As a mathematician, I'd suspect that <code>f(x)(y)</code> is a function that assigns to every <code>x</code> a function <code>g_{x}</code> and then returns <code>g_{x}(y)</code> and likewise for <code>f(x)(y)(z)</code>. </p>
<p>Should this interpretation be correct, Python would allow me to dynamically create functions which seems very interesting to me. I've searched the web for the past hour, but wasn't able to find a lead in the right direction. Since I don't know how this programming concept is called, however, this may not be too surprising.</p>
<p>How do you call this concept and where can I read more about it?</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know whether this is <em>function</em> chaining as much as it's <em>callable</em> chaining, but, since functions <em>are</em> callables I guess there's no harm done. Either way, there's two ways I can think of doing this:</p>
<h3>Sub-classing <code>int</code> and defining <code>__call__</code>:</h3>
<p>The first way would be with a custom <code>int</code> subclass that defines <a href="https://docs.python.org/3/reference/datamodel.html#object.__call__" rel="noreferrer"><code>__call__</code></a> which returns a new instance of itself with the updated value:</p>
<pre><code>class CustomInt(int):
    def __call__(self, v):
        return CustomInt(self + v)
</code></pre>
<p>Function <code>add</code> can now be defined to return a <code>CustomInt</code> instance, which, as a callable that returns an updated value of itself, can be called in succession:</p>
<pre><code>&gt;&gt;&gt; def add(v):
...    return CustomInt(v)
&gt;&gt;&gt; add(1)
1
&gt;&gt;&gt; add(1)(2)
3
&gt;&gt;&gt; add(1)(2)(3)(44)  # and so on..
50
</code></pre>
<p>In addition, as an <code>int</code> subclass, the returned value retains the <code>__repr__</code> and <code>__str__</code> behavior of <code>int</code>s. <em>For more complex operations though, you should define other dunders appropriately</em>. </p>
<p>As @Caridorc noted in a comment, <code>add</code> could also be simply written as:</p>
<pre><code>add = CustomInt 
</code></pre>
<p>Renaming the class to <code>add</code> instead of <code>CustomInt</code> also works similarly.</p>
<hr/>
<h3>Define a closure, requires extra call to yield value:</h3>
<p>The only other way I can think of involves a nested function that requires an extra empty argument call in order to return the result. I'm <strong>not</strong> using <code>nonlocal</code> and opt for attaching attributes to the function objects to make it portable between Pythons:</p>
<pre><code>def add(v):
    def _inner_adder(val=None):  
        """ 
        if val is None we return _inner_adder.v 
        else we increment and return ourselves
        """
        if val is None:    
            return _inner_adder.v
        _inner_adder.v += val
        return _inner_adder
    _inner_adder.v = v  # save value
    return _inner_adder 
</code></pre>
<p>This continuously returns itself (<code>_inner_adder</code>) which, if a <code>val</code> is supplied, increments it (<code>_inner_adder += val</code>) and if not, returns the value as it is. Like I mentioned, it requires an extra <code>()</code> call in order to return the incremented value:</p>
<pre><code>&gt;&gt;&gt; add(1)(2)()
3
&gt;&gt;&gt; add(1)(2)(3)()  # and so on..
6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can hate me, but here is a one-liner :)</p>
<pre><code>add = lambda v: type("", (int,), {"__call__": lambda self, v: self.__class__(self + v)})(v)
</code></pre>
<p>Edit: Ok, how this works? The code is identical to answer of @Jim, but everything happens on a single line.</p>
<ol>
<li><code>type</code> can be used to construct new types: <code>type(name, bases, dict) -&gt; a new type</code>. For <code>name</code> we provide empty string, as name is not really needed in this case. For <code>bases</code> (tuple) we provide an <code>(int,)</code>, which is identical to inheriting <code>int</code>. <code>dict</code> are the class attributes, where we attach the <code>__call__</code> lambda.</li>
<li><code>self.__class__(self + v)</code> is identical to <code>return CustomInt(self + v)</code></li>
<li>The new type is constructed and returned within the outer lambda.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If you want to define a function to be called multiple times, first you need to return a callable object each time (for example a function) otherwise you have to create your own object by defining a <code>__call__</code> attribute, in order for it to be callable.</p>
<p>The next point is that you need to preserve all the arguments, which in this case means you might want to use <a href="https://docs.python.org/3/library/asyncio-task.html">Coroutines</a> or a recursive function. But note that <strong>Coroutines are much more optimized/flexible than recursive functions</strong>, specially for such tasks.</p>
<p>Here is a sample function using Coroutines, that preserves the latest state of itself. Note that it can't be called multiple times since the return value is an <code>integer</code> which is not callable, but you might think about turning this into your expected object ;-).</p>
<pre><code>def add():
    current = yield
    while True:
        value = yield current
        current = value + current


it = add()
next(it)
print(it.send(10))
print(it.send(2))
print(it.send(4))

10
12
16
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The pythonic way to do this would be to use dynamic arguments:</p>
<pre><code>def add(*args):
    return sum(args)
</code></pre>
<p>This is not the answer you're looking for, and you may know this, but I thought I would give it anyway because if someone was wondering about doing this not out of curiosity but for work. They should probably have the "right thing to do" answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simply:</p>
<pre><code>class add(int):
   def __call__(self, n):
      return add(self + n)
</code></pre>
</div>
<span class="comment-copy">Looks like you are looking for currying functions</span>
<span class="comment-copy">Hint: A nested function is dynamically created, has access to its parent function's locals, and is able to be returned as a (callable) object.</span>
<span class="comment-copy">@JonathonReinhart That's the way I was thinking about the problem. But I didn't really see how to implement it.</span>
<span class="comment-copy">As an aside: Python will <i>definitely</i> allow you to dynamically create functions. If you're interested, here's a couple of related concepts to read up on: <a href="https://en.wikipedia.org/wiki/First-class_function" rel="nofollow noreferrer">WP: First-class functions</a> | <a href="http://effbot.org/pyfaq/how-do-you-make-a-higher-order-function-in-python.htm" rel="nofollow noreferrer">How do you make a higher order function in Python?</a> | <a href="https://docs.python.org/2/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial()</code></a> | <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="nofollow noreferrer">WP: Closures</a></span>
<span class="comment-copy">@LukasGraf I'll have a look at it. Thank you!</span>
<span class="comment-copy">In the interactive code <code>add = CostumInt</code> should work too and be simpler.</span>
<span class="comment-copy">@Caridorc yup, good catch, added it as a comment :-)</span>
<span class="comment-copy">The problem with subclassing built-ins is that <code>(2*add(1)(2))(3)</code> fails with a <code>TypeError</code> because <code>int</code> is not callable. Basically the <code>CustomInt</code> is converted to plain <code>int</code> when used in <i>any</i> context except when calling. For a more robust solution you basically have to re-implement all <code>__*__</code> methods including the <code>__r*__</code> versions...</span>
<span class="comment-copy">@Caridorc Or don't call it <code>CustomInt</code> at all but <code>add</code> when defining it.</span>
<span class="comment-copy">Or even shorter: <code>class add(int):__call__ = lambda self, v: add(self+v)</code></span>
<span class="comment-copy">The code inside a class is executed exactly like normal code so you can define special methods by assignments. The only difference is that the class scope is a bit... peculiar.</span>
<span class="comment-copy">I removed your '<i>P.S</i>' note, nichochar. We are all aware of how elegant Python is :-) I don't think it belongs in the body of the answer.</span>
<span class="comment-copy">I do think you could have just done <code>add = sum</code> if were gonna go that route</span>
