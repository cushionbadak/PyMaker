<div class="post-text" itemprop="text">
<p>I have 3 classes as below:- </p>
<pre><code>class C(object):
    def __init__(self, v):
        self.var = v

class B(object):
    def __init__(self, c):
        self.c = c

class A(object):
    def __init__(self, b):
        self.b = b

I have created instances as 
c = C("required result")
b = B(c)
a = A(b)

&gt;&gt;&gt; a.b.c.var
'required result'
</code></pre>
<p>Now I need to pass b.c.var as a string to some function and get the value of var similar to sample function as below - </p>
<pre><code>`sample(a, 'b.c.var')` should return 'required result'`
</code></pre>
<p>What should be pythonic way to achieve this
This is my attempt :- </p>
<pre><code>for attr in ('b', 'c', 'var'):
    a = getattr(a, attr)
&gt;&gt;&gt; print a
required result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/operator.html#operator.attrgetter" rel="nofollow">operator.attrgetter</a> which takes a dotted name notation, eg:</p>
<pre><code>from operator import attrgetter
attrgetter('b.c.var')(a)
# 'required result'
</code></pre>
<p>Then if you don't like that syntax, use it to make your <code>sample</code> function, eg:</p>
<pre><code>def sample(obj, attribute):
    getter = attrgetter(attribute)
    return getter(obj)
</code></pre>
<p>From the documentation linked above, the <code>operator.attrgetter</code> uses the equivalent of the following code:</p>
<pre><code>def attrgetter(*items):
    if any(not isinstance(item, str) for item in items):
        raise TypeError('attribute name must be a string')
    if len(items) == 1:
        attr = items[0]
        def g(obj):
            return resolve_attr(obj, attr)
    else:
        def g(obj):
            return tuple(resolve_attr(obj, attr) for attr in items)
    return g

def resolve_attr(obj, attr):
    for name in attr.split("."):
        obj = getattr(obj, name)
    return obj
</code></pre>
<p>So in fact - your original code was just trying to do the equivalent of <code>resolve_attr</code>...</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is the more accurate way, I suppose. (using <code>try-except</code> construction):</p>
<pre><code>...

c = C("required result")
b = B(c)
a = A(b)

def sample(obj, path):
    path_attrs = path.split('.')    # splitting inner attributes path
    inner_attr = None

    for p in path_attrs:
        try:
            inner_attr = getattr(inner_attr if inner_attr else  obj, p)
        except AttributeError:
            print('No %s field' % p)

    print(inner_attr)

sample(a, 'b.c.var')  # will output 'required result'
</code></pre>
</div>
<span class="comment-copy">Can you please be more specific on your problem? Having a more readable code would be your first step on having a more pythonic code.</span>
<span class="comment-copy">Take a look at getattr (<a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#getattr</a>) and str.split (<a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#str.split</a>)</span>
<span class="comment-copy">@WilliamFernandes I have update question with my attempt</span>
<span class="comment-copy">What is the result of your attempt?</span>
<span class="comment-copy">So you're almost done, aren't you?  You just need to convert 'b.c.var' to ('b', 'c', 'var') using .split('.'), unless I'm missing something</span>
<span class="comment-copy">Yes, it's working. Thanks much</span>
