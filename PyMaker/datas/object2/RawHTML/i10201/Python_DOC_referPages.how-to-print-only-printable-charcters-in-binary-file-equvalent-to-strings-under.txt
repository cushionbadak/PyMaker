<div class="post-text" itemprop="text">
<p>I am undertaking conversion of my python application from python 2 to python 3. One of the functions which I use is to get the printable character out of binary file. I earlier used following function in python 2 and it worked great:</p>
<pre><code>import string

def strings(filename, min=4):
    with open(filename, "rb") as f:
        result = ""
        for c in f.read():
            if c in string.printable:
                result += c
                continue
            if len(result) &gt;= min:
                yield result
            result = ""
        if len(result) &gt;= min:  # catch result at EOF
            yield result
</code></pre>
<p>Code is actually from <a href="https://stackoverflow.com/questions/17195924/python-equivalent-of-unix-strings-utility">Python equivalent of unix "strings" utility</a>. When I run the above code with python 2 it produces the output like this which is absolutely ok for me:</p>
<pre><code> +s
^!1^
i*Q(
}"~ 
%lh!ghY
#dh!
!`,!
mL#H
o!&lt;XXT0
'   &lt; 
z !Uk
%
 wS
n`  !wl
*ty

(Q  6
!XPLO$
E#kF
</code></pre>
<p>However, the function gives weird results under python 3. It produces the error:</p>
<pre><code>TypeError: 'in &lt;string&gt;' requires string as left operand, not int
</code></pre>
<p>So I converted the 'int' to 'str' by replacing this </p>
<pre><code>if c in string.printable:
</code></pre>
<p>with this</p>
<pre><code>if str(c) in string.printable:
</code></pre>
<p>(I also converted all the places where the same error message is thrown)</p>
<p>Now the python 3 gives the following output:</p>
<pre><code>56700
0000000000000000000000000000000000000000
1236
60000
400234
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2340
0000
5010
5000
17889
2348
23400000000
5600
</code></pre>
<p>I cant see any characters when I use python 3. Any help to get the code working or pointer to the solution is appreciated. All I require is to extract the strings from binary file (very small with few kb) and store it in a variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, opening a file in binary mode gives you <code>bytes</code> results. Iterating over a <code>bytes</code> object gives you <em>integers</em>, not characters, in the range 0 to 255 (inclusive). From the <a href="https://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow"><code>bytes</code> documentation</a>:</p>
<blockquote>
<p>While bytes literals and representations are based on ASCII text, <code>bytes</code> objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that <code>0 &lt;= x &lt; 256</code></p>
</blockquote>
<p>Convert <code>string.printable</code> to a set and test against that:</p>
<pre><code>printable = {ord(c) for c in string.printable}
</code></pre>
<p>and</p>
<pre><code>if c in printable:
</code></pre>
<p>Next, you want to append to a <code>bytesarray()</code> object to keep things reasonably performant, and decode from ASCII to produce a <code>str</code> result:</p>
<pre><code>printable = {ord(c) for c in string.printable}

with open(filename, "rb") as f:
    result = bytearray()
    for c in f.read():
        if c in printable:
            result.append(c)
            continue
        if len(result) &gt;= min:
            yield result.decode('ASCII')
            result.clear()
    if len(result) &gt;= min:  # catch result at EOF
        yield result
</code></pre>
<p>Rather than iterate over the bytes one by one, you could instead split on anything that is <em>not</em> printable:</p>
<pre><code>import re

nonprintable = re.compile(b'[^%s]+' % re.escape(string.printable.encode('ascii')))

with open(filename, "rb") as f:
    for result in nonprintable.split(f.read()):
        if result:
            yield result.decode('ASCII')
</code></pre>
<p>I'd explore reading the file in <em>chunks</em> rather than in one go; don't try to fit a large file into memory in one go here:</p>
<pre><code>with open(filename, "rb") as f:
    buffer = b''
    for chunk in iter(lambda: f.read(2048), b''):
        splitresult = nonprintable.split(buffer + chunk)            
        buffer = splitresult.pop()
        for string in splitresult:
            if string:
                yield string.decode('ascii')
    if buffer:
        yield buffer.decode('ascii')
</code></pre>
<p>The buffer carries over any incomplete word from one chunk to the next; <code>re.split()</code> produces empty values at the start and end if the input started or ended with non-printable characters, respectively.</p>
</div>
<div class="post-text" itemprop="text">
<p>
I am sure this will work.  </p>
<p>As a generator:</p>
<pre class="lang-py prettyprint-override"><code>import string, _io
def getPrintablesFromBinaryFile(path, encoding='cp1252'):
    global _io, string
    buffer = _io.BufferedReader(open(path, 'rb'))
    while True:
        byte = buffer.read(1)
        if byte == b'':
            return #EOF
        try:
            d = byte.decode(encoding)
        except:
            continue
        if d in string.printable:
            yield d
</code></pre>
<p>As a function is to just collect the outputs of the getPrintablesFromBinaryFile() into a iterable.</p>
<p>Explanation:</p>
<ol>
<li>Import the needed modules</li>
<li>Define the function</li>
<li>Load the modules</li>
<li>Create the buffer</li>
<li>Get a byte from the buffer</li>
<li>Check if it is EOF</li>
<li>If yes, stop the generator</li>
<li>Try to decode using the encoding (like <code>'\xef'</code> does not decode using UTF-8)</li>
<li>If impossible, it cannot be a printable</li>
<li>If printable, yield it</li>
</ol>
<p><strong>Note:</strong> <code>cp1252</code> is the encoding for many text files</p>
</div>
<span class="comment-copy">You  have bytes in python3. Use <code>set(string.printable.encode())</code></span>
<span class="comment-copy">I don't know who down voted this question. But I request them to show the documentation and explanation the way 'Mr Martijn Pieters' did in his answer. If shown I will remove this post/question.</span>
<span class="comment-copy">And use <code>result = b""</code> as well.</span>
<span class="comment-copy">@MarkTolonen: better use a <code>bytearray</code>; you can't append integers to a <code>byte</code> object..</span>
<span class="comment-copy">true, it is one of those surprising things.  Iterate over <code>str</code> and get length 1 strs, but iterate over <code>bytes</code> and get integers.  <code>bytearray</code> makes more sense being mutable anyway.  <code>result += bytes([c])</code> would work, but not very efficient.</span>
<span class="comment-copy">Awesome code. Thanks for the help.</span>
<span class="comment-copy">Why use <code>_io</code> and not <code>io</code>? And <code>open()</code> already returns a buffered reader, why wrap this again? Why decode by some arbitrary 8-bit codec? All characters in <code>string.printable</code> are ASCII characters; better to detect these before decoding and avoid that overhead. And since you read just 1 byte at a time you can't use any multi-byte codec <i>anyway</i>; it'd have been more logical to open the file in text mode. Also, don't use blanket <code>except</code> statements; catch specific exceptions instead. The OP code yields whole strings, you yield individual bytes, which isn't helpful.</span>
