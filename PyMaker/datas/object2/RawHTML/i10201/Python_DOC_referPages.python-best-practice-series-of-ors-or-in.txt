<div class="post-text" itemprop="text">
<p>I am working on a <a href="https://github.com/johnroper100/CrowdMaster/pull/17" rel="nofollow">project</a> where a question came up about the following line:</p>
<pre><code>a == "EQUAL" or a == "NOT EQUAL" or a == "LESS" or a == "GREATER"
</code></pre>
<p>I proposed a change to make it "simpler" like so:</p>
<pre><code>a in ["EQUAL", "NOT EQUAL", "LESS", "GREATER"]
</code></pre>
<p>What would be considered best practice and what would be best for performance? This is for user interface code that gets updated frequently so minor performance improvements could be noticeable. I know the first example will "fail fast" if any were found, and I am assuming that the second would as well. </p>
<p>Furthermore, wouldn't it be even faster to use a dict like:</p>
<pre><code>a in {"EQUAL", "NOT EQUAL", "LESS", "GREATER"}
</code></pre>
<p>...so that a list wouldn't need to be constructed?</p>
<p>The only thing PEP-8 says (that I could find):</p>
<blockquote>
<p>...code is read much more often than it is written. The guidelines provided here are intended to improve the readability of code...</p>
<p>However, know when to be inconsistent -- sometimes style guide recommendations just aren't applicable. When in doubt, use your best judgment. Look at other examples and decide what looks best.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I'd go with the set. It's much more readable. The string of <code>or</code>s can be faster in some circumstances since the operator short circuits and there is no overhead of constructing the list of items each time but I don't think it's worth the readability sacrifice. Here is a quick and dirty benchmark. This is with Python 2.7</p>
<pre><code> def t1(x):
   return (x == "Foo" or x == "Bar" or x == "Baz" or x == "Quux")                                                                                    


 def t2(x):
   return x in {"Foo", "Bar", "Baz", "Quux"}

 [2.7.9]&gt;&gt;&gt; import timeit
 [2.7.9]&gt;&gt;&gt; timeit.timeit(lambda : t1("Quux"))                                                                                                                  
 0.22514700889587402
 [2.7.9]&gt;&gt;&gt; timeit.timeit(lambda : t1("Foo"))                                                                                                                   
 0.18890380859375
 [2.7.9]&gt;&gt;&gt; timeit.timeit(lambda : t2("Quux"))                                                                                                                  
 0.27969884872436523
 [2.7.9]&gt;&gt;&gt; timeit.timeit(lambda : t2("Foo"))                                                                                                                   
 0.25904297828674316
</code></pre>
<p>Python 3 numbers.</p>
<pre><code> [3.4.2]&gt;&gt;&gt; timeit.timeit(lambda : t1("Quux"))
 0.25126787397312
 [3.4.2]&gt;&gt;&gt; timeit.timeit(lambda : t1("Foo"))
 0.1722603400121443
 [3.4.2]&gt;&gt;&gt; timeit.timeit(lambda : t2("Quux"))
 0.18982669000979513
 [3.4.2]&gt;&gt;&gt; timeit.timeit(lambda : t2("Foo"))
 0.17984321201220155
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Obviously in your case it's better to use <code>in</code> operator. It's just much more readable.</p>
<p>In more complex cases when it's not possible to use <code>in</code> operator, you may use <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow"><code>all</code></a> and <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow"><code>any</code></a> functions:</p>
<pre><code>operations = {'EQUAL', 'NOT EQUAL', 'LESS', 'GREATER'}
condition1 = any(curr_op.startswith(op) for op in operations)

condition2 = all([
    self.Operation == "EQUAL",
    isinstance(self.LeftHandSide, int),
    isinstance(self.RightHandSide, int),
])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As suggested by multiple people, go for reability.</p>
<p>performance wise there is a difference, the <code>in</code> operator on sets has an average lookup time of O(1), while for lists it's O(n). You can find this <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow">here</a>.</p>
<p>In your case where the list of possibilities is limited you will hardly notice a difference. However, once this list becomes very large (talking about millions), you can notice a difference.</p>
<p>A simple example can show this: For sets:</p>
<pre><code>operation = 9999999
lookupSet = {i for i in range(0,10000000)}
%timeit operation in lookupSet
&gt;&gt; 10000000 loops, best of 3: 89.4 ns per loop
</code></pre>
<p>where with lists:</p>
<pre><code>operation = 9999999
lookupList =  [i for i in range(0,10000000)]
%timeit operation in lookupList
&gt;&gt; 10 loops, best of 3: 168 ms per loop
</code></pre>
</div>
<span class="comment-copy">Your <code>dict</code> is a <code>set</code> but besides that it's a good option.</span>
<span class="comment-copy">There is no problem with a set. Just use it.</span>
<span class="comment-copy">When in doubt, <code>timeit</code></span>
<span class="comment-copy">Note that on top of the overhead from checking each <code>==</code>, the chained <code>or</code>s also have to lookup the object overtime. It's fine if you have just <code>a == "EQUAL"</code>, but in your initial version you had <code>self.Operation == "EQUAL"</code> - depending on how complex objects are, repeated lookups can be costly <i>in  critical code sections</i>.</span>
<span class="comment-copy">@Chris_Rands In general, <code>set</code> is better: either it is faster, or your data is so small that it doesn't matter. So using <code>set</code> as a default is a good idea.</span>
<span class="comment-copy">Would be interesting to see how long it takes when the item is <i>not</i> valid, e.g. <code>"foobar"</code>.</span>
<span class="comment-copy">The set version is much more competitive in later versions of python. In python2 the set is rebuilt each time. In later versions, since the set is never mutated, the compiler creates a frozenset at compile time and caches it.</span>
<span class="comment-copy">This would be worse than any approach as you are evaluating everything every time. any is also slow regardless.</span>
<span class="comment-copy">@PadraicCunningham it won't if you use generators.</span>
<span class="comment-copy">Yes but you weren't until you edited and the second all still is in a list  so you still evaluate all of them each time.</span>
<span class="comment-copy"><code>any</code> and <code>all</code> will short-circuit, so they have similar optimizations as <code>and</code> and <code>or</code>. That's only relevant when feeding them generators, though. <code>all([...</code> still has the entire list built.</span>
<span class="comment-copy">My comment was before you edited.</span>
