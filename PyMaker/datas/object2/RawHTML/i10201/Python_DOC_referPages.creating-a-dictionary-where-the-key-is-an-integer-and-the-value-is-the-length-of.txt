<div class="post-text" itemprop="text">
<p>Super new to to python here, I've been struggling with this code for a while now. Basically the function returns a dictionary with the integers as keys and the values are all the words where the length of the word corresponds with each key.</p>
<p>So far I'm able to create a dictionary where the values are the total number of each word but not the actual words themselves.</p>
<p>So passing the following text</p>
<pre><code>"the faith that he had had had had an affect on his life"
</code></pre>
<p>to the function</p>
<pre><code>def get_word_len_dict(text):
    result_dict = {'1':0, '2':0, '3':0, '4':0, '5':0, '6' :0}
    for word in text.split():
        if str(len(word)) in result_dict:
            result_dict[str(len(word))] += 1
    return result_dict
</code></pre>
<p>returns</p>
<pre class="lang-none prettyprint-override"><code>1 - 0
2 - 3
3 - 6
4 - 2
5 - 1
6 - 1
</code></pre>
<p>Where I need the output to be:</p>
<pre class="lang-none prettyprint-override"><code>2 - ['an', 'he', 'on']
3 - ['had', 'his', 'the']
4 - ['life', 'that']
5 - ['faith']
6 - ['affect']
</code></pre>
<p>I think I need to have to return the values as a list. But I'm not sure how to approach it.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think that what you want is a dic of lists.</p>
<pre><code>result_dict = {'1':[], '2':[], '3':[], '4':[], '5':[], '6' :[]}
for word in text.split():
    if str(len(word)) in result_dict:
        result_dict[str(len(word))].append(word)
return result_dict
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Fixing Sabian's answer so that duplicates aren't added to the list:</p>
<pre><code>def get_word_len_dict(text):
    result_dict = {1:[], 2:[], 3:[], 4:[], 5:[], 6 :[]}
    for word in text.split():
        n = len(word)
        if n in result_dict and word not in result_dict[n]:
            result_dict[n].append(word)
    return result_dict
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check out <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow">list comprehensions</a></p>
<p>Integers are legal dictionaries keys so there is no need to make the numbers strings unless you want it that way for some other reason.
<code>if statement</code> in the <code>for loop</code> controls flow to add word only once. You could get this effect more automatically if you use <code>set()</code> type instead of <code>list()</code> as your value data structure. See more in the docs. I believe the following does the job:</p>
<pre><code>def get_word_len_dict(text):
    result_dict = {len(word) : [] for word in text.split()}
    for word in text.split():
        if word not in result_dict[len(word)]:
            result_dict[len(word)].append(word) 
    return result_dict
</code></pre>
<p>try to make it better ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of defining the default value as <code>0</code>, assign it as <code>set()</code> and within <code>if</code> condition do, <code>result_dict[str(len(word))].add(word)</code>. </p>
<p><em>Also, instead of preassigning <code>result_dict</code>, you should use <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a>.</em> </p>
<p><em>Since you need non-repetitive words, I am using <a href="https://docs.python.org/2/library/functions.html#func-set" rel="nofollow"><code>set</code></a> as value instead of <code>list</code>.</em> </p>
<p>Hence, your final code should be:</p>
<pre><code>from collections import defaultdict
def get_word_len_dict(text):
    result_dict = defaultdict(set)
    for word in text.split():
        result_dict[str(len(word))].add(word)
    return result_dict
</code></pre>
<p>In case it is must that you want <code>list</code> as values (I think <code>set</code> should suffice your requirement), you need to further iterate it as:</p>
<pre><code>for key, value in result_dict.items():
    result_dict[key] = list(value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you need is a map to list-construct (if not many words, otherwise a 'Counter' would be fine):
Each list stands for a word class (number of characters). Map is checked whether word class ('3') found before. List is checked whether word ('had') found before.</p>
<pre><code>def get_word_len_dict(text):
    result_dict = {}
    for word in text.split():
        if not result_dict.get(str(len(word))): # add list to map?
            result_dict[str(len(word))] = []

        if not word in result_dict[str(len(word))]: # add word to list?
            result_dict[str(len(word))].append(word)

    return result_dict
</code></pre>
<p>--&gt;</p>
<pre><code>3 ['the', 'had', 'his']
2 ['he', 'an', 'on']
5 ['faith']
4 ['that', 'life']
6 ['affect']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>the problem here is you are <em>counting</em> the word by length, instead you want to <em>group</em> them. You can achieve this by storing a list instead of a int:</p>
<pre><code>def get_word_len_dict(text):
    result_dict = {}
    for word in text.split():
        if len(word) in result_dict:
            result_dict[len(word)].add(word)
        else:
            result_dict[len(word)] = {word} #using a set instead of list to avoid duplicates
    return result_dict
</code></pre>
<p>Other improvements:</p>
<ul>
<li>don't hardcode the key in the initialized <code>dict</code> but let it empty instead. Let the code add the new keys dynamically when necessary</li>
<li>you can use <code>int</code> as keys instead of strings, it will save you the conversion</li>
<li>use <code>set</code>s to avoid repetitions</li>
</ul>
<hr/>
<h2>Using <code>groupby</code></h2>
<p>Well, I'll try to propose something different: you can group by length using <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow"><code>groupby</code></a> from the python standard library</p>
<pre><code>import itertools
def get_word_len_dict(text):
    # split and group by length (you get a list if tuple(key, list of values)
    groups = itertools.groupby(sorted(text.split(), key=lambda x: len(x)), lambda x: len(x))
    # convert to a dictionary with sets 
    return {l: set(words) for l, words in groups}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You say you want the keys to be integers but then you convert them to strings before storing them as a key. There is no need to do this in Python; integers can be dictionary keys.</p>
<p>Regarding your question, simply initialize the values of the keys to empty lists instead of the number 0. Then, in the loop, append the word to the list stored under the appropriate key (the length of the word), like this:</p>
<pre><code>string = "the faith that he had had had had an affect on his life"

def get_word_len_dict(text):
    result_dict = {i : [] for i in range(1, 7)}
    for word in text.split():
        length = len(word)
        if length in result_dict:
            result_dict[length].append(word)
    return result_dict      
</code></pre>
<p>This results in the following:</p>
<pre><code>&gt;&gt;&gt; get_word_len_dict(string)
{1: [], 2: ['he', 'an', 'on'], 3: ['the', 'had', 'had', 'had', 'had', 'his'], 4: ['that', 'life'], 5: ['faith'], 6: ['affect']}
</code></pre>
<p>If you, as you mentioned, wish to remove the duplicate words when collecting your input string, it seems elegant to use a set and convert to a list as a final processing step, if this is needed. Also note the use of <code>defaultdict</code> so you don't have to manually initialize the dictionary keys and values as a default value <code>set()</code> (i.e. the empty set) gets inserted for each key that we try to access but not others:</p>
<pre><code>from collections import defaultdict

string = "the faith that he had had had had an affect on his life"

def get_word_len_dict(text):
    result_dict = defaultdict(set)
    for word in text.split():
        length = len(word)
        result_dict[length].add(word)
    return {k : list(v) for k, v in result_dict.items()}
</code></pre>
<p>This gives the following output:</p>
<pre><code>&gt;&gt;&gt; get_word_len_dict(string)
{2: ['he', 'on', 'an'], 3: ['his', 'had', 'the'], 4: ['life', 'that'], 5: ['faith'], 6: ['affect']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code is counting the occurrence of each word length - but not storing the words themselves.</p>
<p>In addition to capturing each word into a list of words with the same size, you also appear to want:</p>
<ol>
<li>If a word length is not represented, do not return an empty list for that length - just don't have a key for that length.</li>
<li>No duplicates in each word list</li>
<li>Each word list is sorted</li>
</ol>
<p>A set container is ideal for accumulating the words - sets naturally eliminate any duplicates added to them. </p>
<p>Using defaultdict(sets) will setup an empty dictionary of sets -- a dictionary key will only be created if it is referenced in our loop that examines each word.</p>
<pre><code>from collections import defaultdict 

def get_word_len_dict(text):

    #create empty dictionary of sets 
    d = defaultdict(set)

    # the key is the length of each word
    # The value is a growing set of words
    # sets automatically eliminate duplicates
    for word in text.split():
        d[len(word)].add(word)

    # the sets in the dictionary are unordered
    # so sort them into a new dictionary, which is returned
    # as a dictionary of lists

    return {i:sorted(d[i]) for i in d.keys()}
</code></pre>
<p>In your example string of </p>
<pre><code>a="the faith that he had had had had an affect on his life"
</code></pre>
<p>Calling the function like this:</p>
<pre><code>z=get_word_len_dict(a)
</code></pre>
<p>Returns the following list:</p>
<pre><code>print(z)
{2: ['an', 'he', 'on'], 3: ['had', 'his', 'the'], 4: ['life', 'that'], 5: ['faith'], 6: ['affect']}
</code></pre>
<p>The type of each value in the dictionary is "list".</p>
<pre><code>print(type(z[2]))
&lt;class 'list'&gt;
</code></pre>
</div>
<span class="comment-copy">Bingo! thanks for that. Any idea on how to remove the repeating word 'had'?</span>
<span class="comment-copy"><code>if str(len(word)) in result_dict and word not in result_dic[str(len(word))]:</code> . Of course this isn't the most efficient way to do it, but it seems to me you are more interested in getting it to work than on efficiency or readability. If you happen to care for those, look at <a href="https://docs.python.org/3/tutorial/errors.html" rel="nofollow noreferrer">this</a></span>
<span class="comment-copy">@Brian if you don't want words to be repeated, use a set.</span>
<span class="comment-copy">This is exactly what I'm looking for. THanks. One last question, how would I go about sorting the list items? Not sure where to use the ".sort()" function here.</span>
<span class="comment-copy">My pleasure ;) there are couple of ways to do it. First, make sure you know the <a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer">difference between</a> <code>.sort()</code> and <code>sorted()</code>. First one sorts list <b>in place</b>. What you can do here is for example add <code>result_dict[len(word)].sort()</code> line in <code>if statement</code> this will sort the list every time after it appends an element to it (not very elegant). Alternatively you can change <code>return</code> statement to another dict comprehension: <code>return { key : sorted(value) for (key,value) in result_dict.items() }</code> (note that this time we use <code>sorted()</code> function).</span>
<span class="comment-copy">In his desired output the values are lists, not sets, so you need another loop at the end to convert them all to lists.</span>
<span class="comment-copy">@PaulCornelius : I doubt that the user even knows the difference between <code>set</code> and <code>list</code>. <code>set</code> should suffice his requirement. Still updated the answer mentioning it</span>
