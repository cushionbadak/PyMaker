<div class="post-text" itemprop="text">
<p>I have a dictionary:</p>
<p>D = {1:[1,2,3], 2:[4,5], 3: [6,7]}</p>
<p>What I wish to do is to find all 3*2*2 combinations,</p>
<pre><code> [[1,4,6], [1,4,7],
 [1,5,6], [1,5,7],
 [2,4,6], [2,4,6],
 [2,5,6], [2,5,7],
 [3,4,6], [3,4,7],
 [3,5,6], [3,5,7] ]
</code></pre>
<p>Is there any way, just doing loop like</p>
<pre><code>for key in D:
   for num in D[key]:
     for xxxxx
</code></pre>
<p>and then carry out the all combination? Thanks! </p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.product"><strong><code>itertools.product</code></strong></a>:</p>
<pre><code>itertools.product(*D.values())
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; D = {1:[1,2,3], 2:[4,5], 3: [6,7]}
&gt;&gt;&gt; list(itertools.product(*D.values()))
[(1, 4, 6), (1, 4, 7), (1, 5, 6), (1, 5, 7), (2, 4, 6), (2, 4, 7),
 (2, 5, 6), (2, 5, 7), (3, 4, 6), (3, 4, 7), (3, 5, 6), (3, 5, 7)]
</code></pre>
</div>
<span class="comment-copy">This is a good answer. But I actually may need to know the loop structure. For example, consider now <code>D={1: {2}, 2: {1, 3}, 3: {2, 4}, 4: {3}}</code>. Note that in each element, I WON'T allow the repeat numbers. e.g. <code>(2,1,3,3)</code> is not allowed, so the only possible combination from D is <code>(2,1,4,3)</code>. This can avoid exponential usage in memory. Are there any further ways doing this?</span>
<span class="comment-copy">@Hsiang You can filter repeats like this: <code>[c for c in itertools.product(*D.values()) if len(c) == len(set(c))]</code>.</span>
<span class="comment-copy">Excellent!!!! Thanks a lot!</span>
<span class="comment-copy">@Hsiang The solution in orlp's comment avoids excessive memory usage, but it doesn't avoid excessive runtime, since it doesn't prune the tree at the earliest possible point.  E.g for <code>{1: [0,1], 2: [0], 3: range(1000), 4: range(1000)}</code> it will iterate over a million tuples starting with two zeros, although we know that none of them can be valid.  Depending on the nature of your data, you might be better off implementing this recursively and pruning all branches that already have a duplicate.</span>
