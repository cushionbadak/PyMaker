<div class="post-text" itemprop="text">
<p>I'm just starting to learn python and have a  textfile that looks like this:</p>
<pre><code>Hello

World


Hello
World
</code></pre>
<p>And I want to add the numbers '55' to the beggining and end of every string that starts with 'hello'</p>
<p>The numbers '66' to the beggining and every of every string that starts with 'World'</p>
<p>etc</p>
<p>So my final file should look like this:</p>
<pre><code>55Hello55

66World66


55Hello55
66World66
</code></pre>
<p>I'm reading the file in all at once, storing it in a string, and then trying to append accordingly</p>
<pre><code>fp = open("test.txt","r")
strHolder = fp.read()
print(strHolder)

if 'Hello' in strHolder:
    strHolder = '55' + strHolder + '55'
if 'World' in strHolder:
    strHolder = '66' + strHolder + '66'
print(strHolder)
fp.close()
</code></pre>
<p>However, my string values '55' and '66' are always being added to the front of the file and end of the file, not the front of a certain string and to the end of the string, where I get this output of the string:</p>
<pre><code>6655Hello

World


Hello
World
5566
</code></pre>
<p>Any help would be much appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are reading the whole file at once with <code>.read()</code>.</p>
<p>You can read it line by line in a <code>for</code> loop.</p>
<pre><code>new_file = []
fp = open("test.txt", "r")
for line in fp:
    line = line.rstrip("\n")  # The string ends in a newline
                              # str.rstrip("\n") removes newlines at the end
    if "Hello" in line:
        line = "55" + line + "55"
    if "World" in line:
        line = "66" + line + "66"
    new_file.append(line)
fp.close()
new_file = "\n".join(new_file)
print(new_file)
</code></pre>
<p>You could do it all at once, by reading the whole file and splitting by "\n" (newline)</p>
<pre><code>new_file = []
fp = open("text.txt")
fp_read = fp.read()
fp.close()
for line in fp_read.split("\n"):
    if "Hello" # ...
</code></pre>
<p>but this would load the whole file into memory at once, while the for loop only loads line by line (So this may not work for larger files).</p>
<p>The behaviour of this is that if the line has "Hello" in it, it will get "55" before and after it (even if the line is "   sieohfoiHellosdf  ") and the same for "World", and if it has both "Hello" and "World" (e.g. "Hello, World!" or "asdifhoasdfhHellosdjfhsodWorldosadh") it will get "6655" before and after it.</p>
<p>Just as a side note: You should use <code>with</code> to open a file as it makes sure that the file is closed later.</p>
<pre><code>new_file = []
with open("test.txt") as fp:  # "r" mode is default
    for line in fp:
        line = line.rstrip("\n")
        if "Hello" in line:
            line = "55" + line + "55"
        if "World" in line:
            line = "66" + line + "66"
        new_file.append(line)
new_file = "\n".join(new_file)
print(new_file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to iterate over each line of the file in order to get the desired result. In your code you are using <code>.read()</code>, instead use <code>.readlines()</code> to get list of all lines.</p>
<p>Below is the sample code:</p>
<pre><code>lines = []
with open("test.txt", "r") as f:
     for line in f.readlines():  # &lt; Iterate over each line
         if line.startswith("Hello"):  # &lt;-- check if line starts with "Hello"
             line = "55{}55".format(line)
         elif line.startswith("World"):
             line = "66{}66".format(line)
         lines.append(line)

print "\n".join(lines)
</code></pre>
<p>Why to use <code>with</code>? Check <a href="https://docs.python.org/3/whatsnew/2.6.html#pep-343-the-with-statement" rel="nofollow">Python doc</a>:</p>
<blockquote>
<p>The ‘with‘ statement clarifies code that previously would use try...finally blocks to ensure that clean-up code is executed. In this section, I’ll discuss the statement as it will commonly be used. In the next section, I’ll examine the implementation details and show how to write objects for use with this statement.</p>
<p>The ‘with‘ statement is a control-flow structure whose basic structure is:</p>
<p>with expression [as variable]: with-block</p>
<p>The expression is evaluated, and it should result in an object that supports the context management protocol (that is, has <strong>enter</strong>() and <strong>exit</strong>() methods).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>once you have read the file:</p>
<pre><code>read_file = read_file.replace('hello','55hello55')
</code></pre>
<p>It'll replace all hellos with 55hello55</p>
<p>and use <code>with open(text.txt, 'r' ) as file_hndler:</code></p>
</div>
<div class="post-text" itemprop="text">
<p>To read a <strong>text</strong> file, I recommend the following way which is compatible with Python 2 &amp; 3:</p>
<pre><code>import io

with io.open("test", mode="r", encoding="utf8") as fd:
    ...
</code></pre>
<p>Here, I make the assumption that your file use uft8 encoding.</p>
<p>Using a <code>with</code> statement make sure the file is closed at the end of reading even if a error occurs (an exception). To learn more about context manager, take a look at the <a href="https://docs.python.org/2/library/contextlib.html" rel="nofollow">Context Library</a>. </p>
<p>There are several ways to read a text file:</p>
<ul>
<li>read the whole file with: <code>fd.read()</code>, or</li>
<li>read line by line with a loop: <code>for line in fd</code>.</li>
</ul>
<p>If you read the whole file, you'll need to split the lines (see <a href="https://docs.python.org/2/library/stdtypes.html?highlight=splitlines#str.splitlines" rel="nofollow">str.splitlines</a>. Here are the two solutions:</p>
<pre><code>with io.open("test", mode="r", encoding="utf8") as fd:
    content = fd.read()
for line in content.splilines():
    if "Hello" in line:
        print("55" + line + "55")
    if "World" in line:
        print("66" + line + "66")
</code></pre>
<p>Or</p>
<pre><code>with io.open("test", mode="r", encoding="utf8") as fd:
    for line in content.splilines():
        line = line[:-1]
        if "Hello" in line:
            print("55" + line + "55")
        if "World" in line:
            print("66" + line + "66")
</code></pre>
<p>If you need to write the result in another file you can open the output file in write mode and use <code>print(thing, file=out)</code> as follow:</p>
<pre><code>with io.open("test", mode="r", encoding="utf8") as fd:
    with io.open("test", mode="w", encoding="utf8") as out:
        for line in content.splilines():
            line = line[:-1]
            if "Hello" in line:
                print("55" + line + "55", file=out)
            if "World" in line:
                print("66" + line + "66", file=out)
</code></pre>
<p>If you use Python 2, you'll need the following directive to use the print function:</p>
<pre><code>from __future__ import print_function
</code></pre>
</div>
<span class="comment-copy">Just one comment from initially looking at your code (and not necessarily the problem right now). Do not use <code>str</code> as a variable name. It shadows the built-in <code>str</code>, which will lead to very unexpected behaviour in your code.</span>
<span class="comment-copy">Sounds good, I'll change it.</span>
<span class="comment-copy">This: <code>fp.read().replace('\nHello','\n55Hello55').replace('\nWorld','\n66World66')</code>?</span>
<span class="comment-copy">is there a way to do this without reading it in line by line?</span>
<span class="comment-copy">Use rstrip in place of slicing</span>
<span class="comment-copy">Well <code>line.rstrip("\n")</code> would fix that issue which I doubt very much is likely.  Also by your own logic what happens if you did not have a newline after the last line? That would strip a character</span>
<span class="comment-copy">@PadraicCunningham Noted and edited. Thank you.</span>
