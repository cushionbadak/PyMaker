<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/10282674/difference-between-the-built-in-pow-and-math-pow-for-floats-in-python">Difference between the built-in pow() and math.pow() for floats, in Python?</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>According to <a href="https://stackoverflow.com/questions/20969773/exponentials-in-python-x-y-vs-math-powx-y">these</a> answers there is not difference between <code>pow(a,b)</code> and <code>a**b</code>. However, <code>math.pow(a,b)</code> returns a float value. Now, when running the following python code something strange happens:</p>
<pre><code>&gt;&gt;&gt;import math
&gt;&gt;&gt;math.pow(19,13)%2537
2296.0
&gt;&gt;&gt;pow(19,13)%2537
2299
</code></pre>
<p>These statements <strong>should</strong> give the same value but don't. Any clue as to why this happens?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>float</code> type looses precision. They are represented by the nearest binary fraction and from the docs <a href="https://docs.python.org/3/tutorial/floatingpoint.html#floating-point-arithmetic-issues-and-limitations" rel="nofollow">Floating Point Arithmetic: Issues and Limitations</a></p>
<blockquote>
<p>Interestingly, there are many different decimal numbers that share the
  same nearest approximate binary fraction.</p>
</blockquote>
<p>You can see the problem clearly with the result of <code>math.pow(19,13)</code> where multiple integers map to the same float.</p>
<pre><code>&gt;&gt;&gt; f = math.pow(19,13)
&gt;&gt;&gt; float(int(f)) == float(int(f) - 1)
True
&gt;&gt;&gt; float(int(f)) == float(int(f) - 2)
True
&gt;&gt;&gt; float(int(f)) == float(int(f) - 3)
True
&gt;&gt;&gt; float(int(f)) == float(int(f) - 4)
True
&gt;&gt;&gt; float(int(f)) == float(int(f) - 5)
False
</code></pre>
<p>Since python can handle very large integers, try to stay away from floats!</p>
</div>
<div class="post-text" itemprop="text">
<p>As you say <code>math.pow</code> returns a float value and <code>pow</code> does not.  Calling the modulo operator on a float will round it to an integer. Rounding floating point to integer will cause loss of precision.</p>
<pre><code>&gt;&gt;&gt; int(math.pow(19,13))
42052983462257056
&gt;&gt;&gt; pow(19,13)
42052983462257059
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>math.pow()</code> converts its arguments to <code>float</code>:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; import fractions
&gt;&gt;&gt; math.pow(fractions.Fraction(3, 2), 2)
2.25
</code></pre>
<p>but the built-in <code>pow</code> does not:</p>
<pre><code>&gt;&gt;&gt; pow(fractions.Fraction(3, 2), 2)
Fraction(9, 4)
</code></pre>
<p>Also check: <a href="https://stackoverflow.com/questions/10282674/difference-between-the-built-in-pow-and-math-pow-for-floats-in-python">Difference between the built-in pow() and math.pow() for floats, in Python?</a></p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/10282674/difference-between-the-built-in-pow-and-math-pow-for-floats-in-python" title="difference between the built in pow and math pow for floats in python">stackoverflow.com/questions/10282674/â€¦</a></span>
<span class="comment-copy"><code>pow(19,13)%2537</code> gives me <code>2299L</code> in Python 2.7, not 2599. Where's the extra 300 from?</span>
<span class="comment-copy">@roganjosh Sorry, my bad. It's a typo.</span>
<span class="comment-copy">@ZheHe 's link is quite informative but I don't think this question duplicates it. This question is partially about why the float value is significantly different than the integer value.</span>
