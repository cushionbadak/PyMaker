<div class="post-text" itemprop="text">
<p>Using the Python C/API, how do I create a normal Python class using the normal Python class-creation mechanism (i.e.: not an extension type)?</p>
<p>In other words, what is the Python C/API equivalent (in the sense that it does <em>exactly</em> the same in all cases) of a statement</p>
<pre><code>class X(bases):
    ...some methods/attributes here...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python you can get programmatically create a class by calling the <code>type</code> built in function. See <a href="https://stackoverflow.com/a/15247202/4657412">this answer</a> for example.</p>
<p>This takes three arguments: a name, a tuple of bases, and a dictionary.</p>
<p>You can get the Python <code>type</code> in the C api as <a href="https://docs.python.org/3/c-api/type.html#c.PyType_Type" rel="nofollow noreferrer"><code>PyType_Type</code></a>. You then just need to call it using <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_Call" rel="nofollow noreferrer">one of the standard methods for calling <code>PyObject*</code> callables</a>:</p>
<pre class="lang-c prettyprint-override"><code>// make a tuple of your bases
PyObject* bases = PyTuple_Pack(0); // assume no bases
// make a dictionary of member functions, etc
PyObject* dict = PyDict_New(); // empty for the sake of example 
PyObject* my_new_class = PyObject_CallFunction(&amp;PyType_Type,"sOO",
                                             "X", // class name
                                             bases,
                                             dict);
// check if null

// decref bases and dict
Py_CLEAR(bases);
Py_CLEAR(dict);
</code></pre>
<p>(Note that you have to do <code>&amp;PyType_Type</code> - the documentation implies that it's a <code>PyObject*</code> but it isn't!)</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure what you mean by "the normal Python class-creation mechanism", but...</p>
<p>There's a documentation page dedicated to this: <a href="https://docs.python.org/3/extending/newtypes.html" rel="nofollow">https://docs.python.org/3/extending/newtypes.html</a> -- it creates a new type in an extension module, which is equivalent to creating a new <code>class</code> in Python code.</p>
<p>The minimal example presented there is:</p>
<pre><code>#include &lt;Python.h&gt;

typedef struct {
    PyObject_HEAD
    /* Type-specific fields go here. */
} noddy_NoddyObject;

static PyTypeObject noddy_NoddyType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "noddy.Noddy",             /* tp_name */
    sizeof(noddy_NoddyObject), /* tp_basicsize */
    0,                         /* tp_itemsize */
    0,                         /* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_reserved */
    0,                         /* tp_repr */
    0,                         /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash  */
    0,                         /* tp_call */
    0,                         /* tp_str */
    0,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,        /* tp_flags */
    "Noddy objects",           /* tp_doc */
};

static PyModuleDef noddymodule = {
    PyModuleDef_HEAD_INIT,
    "noddy",
    "Example module that creates an extension type.",
    -1,
    NULL, NULL, NULL, NULL, NULL
};

PyMODINIT_FUNC
PyInit_noddy(void)
{
    PyObject* m;

    noddy_NoddyType.tp_new = PyType_GenericNew;
    if (PyType_Ready(&amp;noddy_NoddyType) &lt; 0)
        return NULL;

    m = PyModule_Create(&amp;noddymodule);
    if (m == NULL)
        return NULL;

    Py_INCREF(&amp;noddy_NoddyType);
    PyModule_AddObject(m, "Noddy", (PyObject *)&amp;noddy_NoddyType);
    return m;
}
</code></pre>
</div>
<span class="comment-copy">Thanks, that seems to work. Although I wonder if "class Derived(Base): pass" is really 100% equivalent to "Derived = type("Derived", (Base,), {})" if metaclasses are involved.</span>
<span class="comment-copy">I believe that if metaclasses are involved you should call <code>Derived = metaclass("Derived", (Base,), {})</code>. However, this is slightly beyond what I'm actually sure of...</span>
<span class="comment-copy">Just as an extra thing - have you seen this <a href="https://mail.python.org/pipermail/python-dev/2009-July/090921.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-dev/2009-July/090921.html</a>? There does look to be a second way of doing it involving allocating <code>PyTypeObject</code>s yourself (but no-one seems to like it...)</span>
<span class="comment-copy">This is exactly what I do NOT want. I do not want an extension type, but just a Python class created at runtime.</span>
<span class="comment-copy">@JeroenDemeyer: Your questions says "Python C/API equivalent of a statement like", so this is what I understood. Please consider rephrasing your question to be clearer.</span>
<span class="comment-copy">I mean "equivalent" in the most literal sense. I don't mean "similar", I really mean "exactly the same".</span>
