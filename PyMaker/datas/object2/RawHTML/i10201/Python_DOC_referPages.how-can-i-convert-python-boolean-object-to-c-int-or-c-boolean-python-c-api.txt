<div class="post-text" itemprop="text">
<p>I have a variable <code>PyObject</code> that I know is a Python bool. It either is <code>True</code> or <code>False</code> (eg. <code>Py_True</code> or <code>Py_False</code>). Now I would like to convert it to C++ somehow.</p>
<p>Doing this with strings isn't so hard, there is a helper function for that - <code>PyBytes_AsString</code> that converts python string into C string. Now I need something like that for boolean (or int as there is no <code>bool</code> in C).</p>
<p>Or if there isn't conversion, maybe some function that can compare with true or false? Something like <code>int PyBool_IsTrue(PyObject*)</code>?</p>
<p>Here is some example code for easier understanding of what I need:</p>
<pre><code>#include &lt;Python.h&gt;

int main()
{
    /* here I create Python boolean with value of True */
    PyObject *b = Py_RETURN_TRUE;
    /* now that I have it I would like to turn in into C type so that I can determine if it's True or False */
    /* something like */
    if (PyBool_IsTrue(b))
    { /* it's true! */ }
    else
    { /* it's false */ }
    return 0;
}
</code></pre>
<p>This obviously wouldn't work as there is no such function like <code>PyBool_IsTrue</code> :( how can I do that?</p>
<p>Snippet of Python header (boolobject.h):</p>
<pre><code>/* Boolean object interface */

#ifndef Py_BOOLOBJECT_H
#define Py_BOOLOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif


PyAPI_DATA(PyTypeObject) PyBool_Type;

#define PyBool_Check(x) (Py_TYPE(x) == &amp;PyBool_Type)

/* Py_False and Py_True are the only two bools in existence.
Don't forget to apply Py_INCREF() when returning either!!! */

/* Don't use these directly */
PyAPI_DATA(struct _longobject) _Py_FalseStruct, _Py_TrueStruct;

/* Use these macros */
#define Py_False ((PyObject *) &amp;_Py_FalseStruct)
#define Py_True ((PyObject *) &amp;_Py_TrueStruct)

/* Macros for returning Py_True or Py_False, respectively */
#define Py_RETURN_TRUE return Py_INCREF(Py_True), Py_True
#define Py_RETURN_FALSE return Py_INCREF(Py_False), Py_False

/* Function to return a bool from a C long */
PyAPI_FUNC(PyObject *) PyBool_FromLong(long);

#ifdef __cplusplus
}
#endif
#endif /* !Py_BOOLOBJECT_H */
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>Every</em> Python object can have its truthiness evaluated with <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_IsTrue" rel="nofollow noreferrer"><code>PyObject_IsTrue</code></a>, and you should use this in preference to direct <code>PyTrue</code>/<code>PyFalse</code> singleton checking unless you absolutely know, for certain, that the object is a <code>PyBool</code>.</p>
<p>Usage is:</p>
<pre><code>int truthy = PyObject_IsTrue(someobj);
if (truthy == -1) return APPROPRIATEERRORRETURN;

if (truthy)
{ /* it's true! */ }
else
{ /* it's false */ }
</code></pre>
<p>You can just test <code>someobj == Py_True</code> if you know it's definitely a bool, or use <a href="https://docs.python.org/3/c-api/number.html#c.PyNumber_AsSsize_t" rel="nofollow noreferrer"><code>PyNumber_AsSsize_t</code></a> to convert any logical integer type (anything implementing <code>__index__</code>, and <code>bool</code> is a subclass of <code>int</code>, so it's also logically an integer) to a signed <code>size_t</code> value (if <code>__index__</code> returns a number that doesn't fit in signed <code>size_t</code>, it will return -1 with exception set).</p>
<p>The reason not to do <code>someobj == Py_True</code> in general is because it's like doing <code>if someobj is True:</code> at the Python layer. If <code>someobj</code> is <code>1</code>, or an non-empty <code>str</code>, that will treat it as false, when Pythonic code is rarely concerned about being <code>True</code> or <code>False</code>, but rather, "truthiness" and "falsiness".</p>
<p>In addition, this:</p>
<pre><code>PyObject *b = Py_RETURN_TRUE;
</code></pre>
<p>is flat wrong. That will incref <code>PyTrue</code> and return it; none of the subsequent code will execute. You'd want:</p>
<pre><code>PyObject *b = Py_True;
</code></pre>
<p>for a borrowed reference, adding a subsequent:</p>
<pre><code>Py_INCREF(b);
</code></pre>
<p>to make it an owned reference if you intended to return it later (since it's a singleton that won't go away, using a borrowed reference is fine unless you know it will be <code>DECREF</code>ed later, e.g. because you returned it and passed ownership to a caller who can't know it's a borrowed reference).</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer is in Python headers but may not be obvious.</p>
<p>Python headers declare 2 somewhat static objects here, with couple of macros:</p>
<pre><code>/* Don't use these directly */
PyAPI_DATA(struct _longobject) _Py_FalseStruct, _Py_TrueStruct;

/* Use these macros */
#define Py_False ((PyObject *) &amp;_Py_FalseStruct)
#define Py_True ((PyObject *) &amp;_Py_TrueStruct)

/* Macros for returning Py_True or Py_False, respectively */
#define Py_RETURN_TRUE return Py_INCREF(Py_True), Py_True
#define Py_RETURN_FALSE return Py_INCREF(Py_False), Py_False
</code></pre>
<p>It seems that both <code>True</code> and <code>False</code> are in fact Python objects and all values in Python that are <code>True</code> or <code>False</code> are in fact references to these two global <code>Py_True</code> and <code>Py_False</code> objects. When such object is returned using <code>Py_RETURN_TRUE</code>, the reference count is incremented.</p>
<p>This means that every C pointer that points to PyObject of value <code>Py_True</code> in fact points to same memory address. Therefore checking if <code>PyObject</code> is true or false is as simple as:</p>
<pre><code>/* here I create Python boolean with value of True */
PyObject *b = Py_True;
Py_INCREF(b);
/* now we compare the address of pointer with address of Py_True */
if (b == Py_True)
{ /* it's true! */ }
else
{ /* it's false */ }
</code></pre>
<p>It's generally good idea to use <code>int PyBool_Check(PyObject*)</code> to verify if object in question is Python boolean.</p>
</div>
<span class="comment-copy">Reason for downvote?</span>
<span class="comment-copy">Will <code>PyObject *b = Py_RETURN_TRUE;</code> even compile?</span>
<span class="comment-copy">@MadPhysicist: Probably not, but I put nothing past a compiler running with warnings off in non-strict mode. :-)</span>
<span class="comment-copy">Not very good advice, and doesn't address some major issues in OP's approach.</span>
