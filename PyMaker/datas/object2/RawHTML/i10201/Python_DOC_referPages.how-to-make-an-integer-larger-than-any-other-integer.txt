<div class="post-text" itemprop="text">
<p>Note: while the accepted answer achieves the result I wanted, and @ecatmur answer provides a more comprehensive option, I feel it's very important to emphasize that my use case is a bad idea in the first place. This is explained very well in <a href="https://stackoverflow.com/a/39856605/336527">@Jason Orendorff answer below</a>.</p>
<p>Note: this question is not a duplicate of <a href="https://stackoverflow.com/questions/13795758/what-is-sys-maxint-in-python-3">the question about <code>sys.maxint</code></a>. It has nothing to do with <code>sys.maxint</code>; even in python 2 where <code>sys.maxint</code> is available, it does NOT represent largest integer (see the accepted answer).</p>
<p>I need to create an integer that's larger than any other integer, meaning an <code>int</code> object which returns <code>True</code> when compared to any other <code>int</code> object using <code>&gt;</code>. Use case: library function expects an integer, and the only easy way to force a certain behavior is to pass a very large integer.</p>
<p>In python 2, I can use <code>sys.maxint</code> (edit: I was wrong). In python 3, <code>math.inf</code> is the closest equivalent, but I can't convert it to <code>int</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since python integers are unbounded, you have to do this with a custom class:</p>
<pre><code>import functools

@functools.total_ordering
class NeverSmaller(object):
    def __le__(self, other):
        return False

class ReallyMaxInt(NeverSmaller, int):
    def __repr__(self):
        return 'ReallyMaxInt()'
</code></pre>
<p>Here I've used a mix-in class <code>NeverSmaller</code> rather than direct decoration of <code>ReallyMaxInt</code>, because on Python 3 the action of <code>functools.total_ordering</code> would have been prevented by existing ordering methods inherited from <code>int</code>.  </p>
<p>Usage demo:</p>
<pre><code>&gt;&gt;&gt; N = ReallyMaxInt()
&gt;&gt;&gt; N &gt; sys.maxsize
True
&gt;&gt;&gt; isinstance(N, int)
True
&gt;&gt;&gt; sorted([1, N, 0, 9999, sys.maxsize])
[0, 1, 9999, 9223372036854775807, ReallyMaxInt()]
</code></pre>
<p>Note that in python2, <code>sys.maxint + 1</code> is bigger than <code>sys.maxint</code>, so you can't rely on that.  </p>
<p><em>Disclaimer</em>: This is an integer in the <a href="https://en.wikipedia.org/wiki/Object-oriented_programming#Inheritance_and_behavioral_subtyping" rel="noreferrer">OO</a> sense, it is not an integer in the mathematical sense.  Consequently, arithmetic operations inherited from the parent class <code>int</code> may not behave sensibly.  If this causes any issues for your intended use case, then they can be disabled by implementing <code>__add__</code> and friends to just error out.</p>
</div>
<div class="post-text" itemprop="text">
<p>Konsta Vesterinen's <a href="https://github.com/kvesteri/infinity"><code>infinity.Infinity</code></a> would work (<a href="https://pypi.python.org/pypi/infinity/">pypi</a>), except that it doesn't inherit from <code>int</code>, but you can subclass it:</p>
<pre><code>from infinity import Infinity
class IntInfinity(Infinity, int):
    pass
assert isinstance(IntInfinity(), int)
assert IntInfinity() &gt; 1e100
</code></pre>
<p>Another package that implements "infinity" values is <a href="https://pypi.python.org/pypi/Extremes">Extremes</a>, which was salvaged from the rejected <a href="https://www.python.org/dev/peps/pep-0326/">PEP 326</a>; again, you'd need to subclass from <code>extremes.Max</code> and <code>int</code>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Use case: library function expects an integer, and the only easy way to force a certain behavior is to pass a very large integer.</p>
</blockquote>
<p>This sounds like a flaw in the library that should be fixed in its interface. Then all its users would benefit. What library is it?</p>
<p>Creating a magical int subclass with overridden comparison operators might work for you. It's brittle, though; you never know what the library is going to do with that object. Suppose it converts it to a string. What should happen? And data is naturally used in different ways as a library evolves; you may update the library one day to find that your trick doesn't work anymore.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems to me that this would be fundamentally impossible. Let's say you write a function that returns this RBI ("really big int"). If the computer is capable of storing it, then someone else could write a function that returns the same value. Is your RBI greater than itself?</p>
<p>Perhaps you can achieve the desired result with something like @wim's answer: Create an object that overrides the comparison operators to make "&lt;" always return false and "&gt;" always return true. (I haven't written a lot of Python. In most object-oriented languages, this would only work if the comparison puts your value first, IF RBI&gt;x. If someone writes the comparison the other way, IF x&gt;RBI, it will fail because the compiler doesn't know how to compare integers to a user-defined class.)</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>In Python 3.5, you can do:</strong></p>
<p><code>import math
  test = math.inf</code></p>
<p>And then:</p>
<p><code>test &gt; 1
  test &gt; 10000
  test &gt; x</code></p>
<p>Will always be true. Unless of course, as pointed out, x is also infinity or "nan" ("not a number").</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/7781260/how-can-i-represent-an-infinite-number-in-python">How can I represent an infinite number in Python?</a></p>
<p>Answered by @WilHall</p>
</div>
<div class="post-text" itemprop="text">
<p>You should not be inheriting from <code>int</code> unless you want both its <em>interface</em> and its <em>implementation</em>.  (Its implementation is an automatically-widening set of bits representing a finite number.  You clearly dont' want that.)  Since you only want the <em>interface</em>, then inherit from the ABC <code>Integral</code>.  Thanks to @ecatmur's answer, we can use <code>infinity</code> to deal with the nitty-gritty of infinity (including negation).  Here is how we could combine <code>infinity</code> with the ABC <code>Integral</code>:</p>
<pre><code>import pytest
from infinity import Infinity
from numbers import Integral


class IntegerInfinity(Infinity, Integral):

    def __and__(self, other):
        raise NotImplementedError

    def __ceil__(self):
        raise NotImplementedError

    def __floor__(self):
        raise NotImplementedError

    def __int__(self):
        raise NotImplementedError

    def __invert__(self, other):
        raise NotImplementedError

    def __lshift__(self, other):
        raise NotImplementedError

    def __mod__(self, other):
        raise NotImplementedError

    def __or__(self, other):
        raise NotImplementedError

    def __rand__(self, other):
        raise NotImplementedError

    def __rlshift__(self, other):
        raise NotImplementedError

    def __rmod__(self, other):
        raise NotImplementedError

    def __ror__(self, other):
        raise NotImplementedError

    def __round__(self):
        raise NotImplementedError

    def __rrshift__(self, other):
        raise NotImplementedError

    def __rshift__(self, other):
        raise NotImplementedError

    def __rxor__(self, other):
        raise NotImplementedError

    def __trunc__(self):
        raise NotImplementedError

    def __xor__(self, other):
        raise NotImplementedError

def test():
    x = IntegerInfinity()
    assert x &gt; 2
    assert not x &lt; 3
    assert x &gt;= 5
    assert not x &lt;= -10
    assert x == x
    assert not x &gt; x
    assert not x &lt; x
    assert x &gt;= x
    assert x &lt;= x
    assert -x == -x
    assert -x &lt;= -x
    assert -x &lt;= x
    assert -x &lt; x
    assert -x &lt; -1000
    assert not -x &lt; -x
    with pytest.raises(Exception):
        int(x)
    with pytest.raises(Exception):
        x | x
    with pytest.raises(Exception):
        ceil(x)
</code></pre>
<p>This can be run with <code>pytest</code> to verify the required invariants.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way to do this (very much inspired by wim's answer) might be an object that isn't infinite, but increases on the fly as needed. </p>
<p>Here's what I have in mind: </p>
<pre><code>from functools import wraps

class AlwaysBiggerDesc():
    '''A data descriptor that always returns a value bigger than instance._compare'''
    def __get__(self, instance, owner):
        try:
            return instance._compare + 1
        except AttributeError:
            return instance._val
    def __set__(self, instance, value):
        try:
            del instance._compare
        except AttributeError:
            pass
        instance._val = value

class BiggerThanYou(int):
    '''A class that behaves like an integer but that increases as needed so as to be 
    bigger than "other" values. Defaults to 1 so that instances are considered
    to be "truthy" for boolean comparisons.'''
    val = AlwaysBiggerDesc()
    def __getattribute__(self, name):
        f = super().__getattribute__(name)
        try:
            intf = getattr(int,name)
        except AttributeError:
            intf = None
        if f is intf:
            @wraps(f)
            def wrapper(*args):
                try:
                    self._compare = args[1]
                except IndexError:
                    self._compare = 0 # Note: 1 will be returned by val descriptor
                new_bigger = BiggerThanYou()
                try:
                    new_bigger.val = f(self.val, *args[1:])
                except IndexError:
                    new_bigger.val =  f(self.val)
                return new_bigger
            return wrapper
        else:
            return f            
    def __repr__(self):
        return 'BiggerThanYou()'
    def __str__(self):
        return '1000...'
</code></pre>
<p>Something like this might avoid a lot of weird behavior that one might not expect. Note that with this kind of approach, if two <code>BiggerThanYou</code> instances are involved in an operation, the LHS would be considered bigger than the RHS. </p>
<p>EDIT: currently this is not working- I'll fix it later. it seems I am being bitten by the <a href="https://stackoverflow.com/a/13063764/2437514">special method lookup functionality</a>. </p>
</div>
<span class="comment-copy">&gt;"library function expects an integer, and the only easy way to force a certain behavior is to pass a very large integer"  First thought, something has gone terribly wrong somewhere, and you need to fix that first....</span>
<span class="comment-copy"><code>int(float('Inf'))</code> leads to <code>OverflowError: cannot convert float infinity to integer</code>. There, I did it. I reached stackoverflow.</span>
<span class="comment-copy">Related questions: "How to make a boolean that's truer than <code>True</code>", "how to make a file with a filename that is an odor instead of text", "Need a rock that is heavier than itself", "negative size sets"</span>
<span class="comment-copy">I love Python. It makes it really easy to accomplish like 5/6 of what you want, even when what you want makes no sense whatsoever. :)</span>
<span class="comment-copy">The word "other" in "an integer that's larger than any <b>other</b> integer" means that this is not a contradiction, Bergi. Compare "The barber shaves all <b>other</b> men who do not shave themselves".</span>
<span class="comment-copy">Just quick note: as written something like <code>ReallyMaxInt() + 1</code> returns <code>1</code>, <code>ReallyMaxInt() * 1</code> returns <code>0</code>, etc etc. Which probably isn't expected.</span>
<span class="comment-copy">Well that's the thing, there is no "max value that can fit in a int".  You can make bigger int all day until you run out of memory.  This <i>is a</i> int in the OO sense, it's just a jacked-up int.  If you don't want the math operations to be permitted, you can define them to raise an exception or return <code>NotImplemented</code>.</span>
<span class="comment-copy">@RickTeachey Yes, that's an issue when subclassing built-ins. To obtain a "proper" subclass you have to implement all the special methods <b>and</b> the <code>__r*__</code> variants. In this case it should be quite easy since you can just always return <code>self</code>, so that <code>ReallyMaxInt()+1 == ReallyMaxInt()</code>. But you can automate that a bit with something like: <code>for name in ('add', 'mul', 'pow'): exec('__{0}__ = __r{0}__ = lambda self, other: self'.format(name))</code></span>
<span class="comment-copy">This would work if the "library" is a Python library. If it's a native library, you'll need the maximum value for whatever native type it expects.</span>
<span class="comment-copy">@max An <code>int</code>'s value is <i>unbounded</i> (except by available memory), which means there is no maximum, but <i>unbounded</i> is different from <i>infinite</i>.</span>
<span class="comment-copy">Nice solution, it gives saner maths e.g. <code>1/IntInfinity() == 0</code> is true.  If you make them fight, then <code>ReallyMaxInt() &gt; IntInfinity()</code> and vice versa ... let's call it a draw!</span>
<span class="comment-copy">Don't inherit from <code>int</code>; inherit from <code>numbers.Integral</code>.</span>
<span class="comment-copy">@neilg absolutely that would be correct in general, although in this case it seems the code being called is erroneously testing isinstance against int, not Integral (or Number). Thanks for pointing that out.</span>
<span class="comment-copy">@ecatmur We're on the same page.  They should file an issue on the project's tracker.  It's a bad idea to let one bug become two.</span>
<span class="comment-copy">I +1'd you, but I also added an answer that shows how to do this with the ABC.  Your solution does weird things when other methods are called, e.g., <code>__int__</code>.</span>
<span class="comment-copy">Very good point. I didn't think about the fact that I have no idea what else the library does with my integer besides comparison. I think the correct answer to my use case is, if there's no standard infinite integer (which the library presumably is aware of and tested with), there's no safe way to achieve what I want.</span>
<span class="comment-copy">@max You also said it's a GUI library, right? (You mentioned window size.) <code>sys.maxint</code> will be larger than any <i>sane</i> window size, even if it's not the largest possible integer in Python. Additionally, do you actually know anything about how the integer is represented in memory in the library? It could, for instance, include some components compiled in C that simply <i>assume</i> that the window size can fit into a <i>native</i> integer value, in which case passing anything larger than that will probably behave badly.</span>
<span class="comment-copy">@KyleStrand Agreed. It was a computational window (like rolling sum in an array) rather than GUI window, but they could still make the type of assumptions you describe to optimize code.</span>
<span class="comment-copy">@max Then it probably only needs to be bigger than the size of the data, right? If you don't have a bazillion data points then you can pass in a bazillion.</span>
<span class="comment-copy">Python was designed intentionally to allow for <i>subclasses</i> to override the behaviour from either side of the operation.  <a href="https://docs.python.org/3/reference/datamodel.html#object.__radd__" rel="nofollow noreferrer">From this section of the datamodel</a>:  "Note If the right operand’s type is a subclass of the left operand’s type and that subclass provides the reflected method for the operation, this method will be called before the left operand’s non-reflected method. This behavior allows subclasses to override their ancestors’ operations."</span>
<span class="comment-copy">@wim Cool. As I admitted, I've not done much python.</span>
<span class="comment-copy">@wim That brings to mind some questions about how Python works under the hood, but that would be a new question. :-)</span>
<span class="comment-copy">Unfortunately, won't work because the argument I'm passing needs to be an <code>int</code> (the library complains if it's not).</span>
<span class="comment-copy">@max: then submit a bug on the library's tracker.</span>
<span class="comment-copy">In Python, value of an integer can expand to the limit of the available memory.</span>
<span class="comment-copy"><code>isinstance(x, int)</code> still returns <code>False</code>, so this won't help the user.  They've explicitly mentioned that an integer is required, in the question and several times in the comments.  I thought you were going to show us a way to have that return True, without inheriting from <code>int</code>?</span>
<span class="comment-copy">@wim this is the <i>definition</i> of a Python integral type.  If the library explicitly checks <code>isinstance(x, int)</code> then the library is either broken or else they are relying on the representation of an integer in which case, there is no solution.</span>
<span class="comment-copy">Remember, practicality beats purity.</span>
<span class="comment-copy">@wim I've explained to you that your solution doesn't even satisfy the basic test bed I included.  You should at least be able to satisfy the first nine tests that don't do any negation or type conversion.</span>
<span class="comment-copy">The only test that matters here is whether it is accepted by the external library, and that's the one you've omitted. You're ignoring the context of the original problem, whilst becoming completely distracted by academic details..</span>
