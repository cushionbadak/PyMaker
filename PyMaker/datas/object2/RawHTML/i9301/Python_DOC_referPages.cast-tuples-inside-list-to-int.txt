<div class="post-text" itemprop="text">
<p>How would one go about turning a list with tuples inside it, in the form of,</p>
<pre><code>list = [(1, 9, 7), (1, 5, 6), (1, 7), (1, 4), (7, 4), (7,)]
</code></pre>
<p>into a list with ints in it, like,</p>
<pre><code>list = [197, 156, 17, 14, 74, 7]
</code></pre>
<p>in the most efficient way possible? I've tried with recursion but it's too memory expensive for large lists (thousands of tuples).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a> for converting every tuple:</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; l = [(1, 9, 7), (1, 5, 6), (1, 7), (1, 4), (7, 4), (7,)]
&gt;&gt;&gt; [reduce(lambda x,y: x*10+y, t) for t in l]
[197, 156, 17, 14, 74, 7]
</code></pre>
<p><strong>Update</strong> Since question was asking for efficient method here are measurements for suggested answers:</p>
<pre><code>import itertools as it
import functools

def conv_reduce(l):
    return [functools.reduce(lambda x,y: x*10+y, t) for t in l]

def conv_str(l):
    return [int("".join(map(str, item))) for item in l]

def conv_pow(l):
    return [sum(n*10**e for n, e in zip(reversed(item), it.count())) for item in l]

def conv_pow2(l):
    return [sum(t[-i-1]*(10**i) for i in range(len(t))) for t in l]

if __name__ == '__main__':
    import timeit
    print('reduce', timeit.timeit("conv_reduce(l)", setup="from __main__ import conv_reduce; l = [(1, 9, 7), (1, 5, 6), (1, 7), (1, 4), (7, 4), (7,)]"))
    print('str', timeit.timeit("conv_str(l)", setup="from __main__ import conv_str; l = [(1, 9, 7), (1, 5, 6), (1, 7), (1, 4), (7, 4), (7,)]"))
    print('pow', timeit.timeit("conv_pow(l)", setup="from __main__ import conv_pow; l = [(1, 9, 7), (1, 5, 6), (1, 7), (1, 4), (7, 4), (7,)]"))
    print('pow2', timeit.timeit("conv_pow2(l)", setup="from __main__ import conv_pow2; l = [(1, 9, 7), (1, 5, 6), (1, 7), (1, 4), (7, 4), (7,)]"))
</code></pre>
<p>Output:</p>
<pre><code>reduce 2.5965667460041004
str 5.068828338997264
pow 7.192991987001733
pow2 8.017168823003885
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way to approach the problem is to cast to string each of the integers in sublists, join and convert to <code>int</code>:</p>
<pre><code>In [1]: l = [(1, 9, 7), (1, 5, 6), (1, 7), (1, 4), (7, 4), (7,)]

In [2]: [int("".join(map(str, item))) for item in l]
Out[2]: [197, 156, 17, 14, 74, 7]
</code></pre>
<p>Or, using the power of tens (a variation of already posted answer by @AChampion):</p>
<pre><code>In [3]: [sum(10 ** index * value for index, value in enumerate(reversed(item))) 
         for item in l]
Out[3]: [197, 156, 17, 14, 74, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's relatively simple to convert a list of digits to a number. Convert them to strings <code>join()</code> and convert back to <code>int</code>. Or you can do it more mathematically:</p>
<pre><code>&gt;&gt;&gt; [sum(n*10**e for e, n in enumerate(reversed(item))) for item in l]
[197, 156, 17, 14, 74, 7]
</code></pre>
<p>Note: don't use <code>list</code> as a variable name as this will hide the python <code>list</code> type.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may also use little bit of mathematics to achieve this. Here I am multiplying the digits in tuple with power of <code>10</code> in reverse order to get the number. </p>
<pre><code>&gt;&gt;&gt; my_list = list = [(1, 9, 7), (1, 5, 6), (1, 7), (1, 4), (7, 4), (7,)]

#     v sum numbers based on their position at hundred, tens, ones place  
&gt;&gt;&gt; [sum(t[-i-1]*(10**i) for i in range(len(t))) for t in my_list]
[197, 156, 17, 14, 74, 7]
</code></pre>
</div>
<span class="comment-copy">It will be great if you could add the execution time of <a href="http://stackoverflow.com/a/41734122/2063361">my function</a>. Why to ignore one :P</span>
<span class="comment-copy">@MoinuddinQuadri Added your suggestion as pow2, I decided to initially exclude it because one of the other suggestions had the same principle so I didn't assume big difference in performance.</span>
<span class="comment-copy"><code>enumerate</code> is a much better option...</span>
<span class="comment-copy">@AChampion thanks, I'm pretty sure there is an efficient numpy solution there as well..</span>
