<div class="post-text" itemprop="text">
<p>I have a large number of pieces of text which I need to compare between themselves to check whether or not they are similar. Each piece is about 10000 words long.<br/>
Hence I'll pre-calculate a hash of each one and compare hashes. </p>
<p>The question is, which hash algorithm would be better for that? md5? sha1? sha256? Or perhaps base64?
Or maybe it doesn't even really matter?</p>
<p>I'm aware that even a single whitespace can change the value of a hash, that's ok with me.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use zlib.crc32 then do textual compare of texts with matching hashes to make sure.</p>
</div>
<div class="post-text" itemprop="text">
<h2>When does hashing work?</h2>
<p>What hashing does is reduce search space so that equivalent items can be found more quickly.  It works whenever there is a reliable way to produce a single <a href="https://en.wikipedia.org/wiki/Canonical_form" rel="nofollow noreferrer">canonical value</a> for all members of an <a href="https://en.wikipedia.org/wiki/Equivalence_class" rel="nofollow noreferrer">equivalence class</a>.</p>
<h2>Selecting a unique value among equivalent strings</h2>
<p>Before hashing, the strings need to be converted to a canonical value (one unique representation among all equivalent strings).</p>
<blockquote>
<p>I'm aware that even a single whitespace can change the value of a
  hash, that's ok with me.</p>
</blockquote>
<p>For your application, here is possible canonicalizing function that just removes whitespace:</p>
<pre><code>&gt;&gt;&gt; def canonical(s):
        return ''.join([c for c in s if not c.isspace()])

&gt;&gt;&gt; s = 'the   quick\nbrown\tfox jumped'
&gt;&gt;&gt; t = '  the\tquick   brown  fox  jumped'
&gt;&gt;&gt; canonical(s)
'thequickbrownfoxjumped'
&gt;&gt;&gt; canonical(t)
'thequickbrownfoxjumped'
</code></pre>
<h2>Applying a hash function</h2>
<p>A <a href="https://docs.python.org/3/library/hashlib.html#hash-algorithms" rel="nofollow noreferrer"><em>sha256()</em></a> is fast and has almost no chance of a false positive.</p>
<p>In Python 2, you can compute the sha256 directly from a string.  However, in Python 3, the string must first be encoded into bytes:</p>
<pre><code>&gt;&gt;&gt; from hashlib import sha256
&gt;&gt;&gt; sha256(canonical(s).encode()).hexdigest()
'2c31c202821431b015cb800ab6315289884e87f1ed023abc876915685c620919'
&gt;&gt;&gt; sha256(canonical(t).encode()).hexdigest()
'2c31c202821431b015cb800ab6315289884e87f1ed023abc876915685c620919'
</code></pre>
<h2>When won't hashing work?</h2>
<p>If you just want to group by <a href="https://stackoverflow.com/questions/8897593/similarity-between-two-text-documents">text similarity</a>, hashing doesn't work as well because there isn't a straight-forward way to choose a representative element and because similarity is isn't a <a href="https://en.wikipedia.org/wiki/Transitive_relation" rel="nofollow noreferrer">transitive relation</a> (<em>a</em> is close to <em>b</em> and <em>b</em> is close to <em>c</em> doesn't imply that <em>a</em> is close to <em>c</em>).</p>
</div>
<span class="comment-copy">What have you tried? A search for "text similarity" on google provides quite a lot of results...</span>
<span class="comment-copy">Hashing will only speed the process of finding <i>exact duplicates</i>. As you say, any minor change will produce a different hash code. Are you trying to find exact duplicates? If you're looking for similarity (rearranged paragraphs, a few changed words, slightly varying sentence structure, etc.), you'll need a much more involved algorithm.</span>
<span class="comment-copy">@JimMischel, learn to read.</span>
<span class="comment-copy">Rudeness is not required. <i>Your requirements are unclear.</i> You said that you want to "check whether or not they similar." My point is that "similar" is not necessarily "exact duplicate." I did acknowledge your comment about being okay with whitespace changing the value of a hash. You need to clarify whether you're looking for similarity (i.e. this text is somewhat like that other text) or <i>exact duplicate</i>.</span>
<span class="comment-copy">@JimMischel, required.</span>
<span class="comment-copy">......why that?</span>
<span class="comment-copy">The above would be a check for equality - including spaces, punctuation etc. I chose it because I have used it to compare millions of sequences of 4K bytes before to see if I chanced on even one case of  a single bit flip not being caught by the CRC - After getting a statistical value of how unlikely it would be of course.</span>
<span class="comment-copy">yes, how do you know it's better than base64, md5, sha1, etc, for this task?</span>
<span class="comment-copy">I don't know it is better. I think it will suffice however.</span>
