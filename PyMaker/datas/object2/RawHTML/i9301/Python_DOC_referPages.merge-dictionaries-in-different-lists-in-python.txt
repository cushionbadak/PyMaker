<div class="post-text" itemprop="text">
<p>I need to merge two lists with dictionaries in them:</p>
<pre><code>dict1 = [{'Count': '307', 'name': 'Other', 'Percentage': '7.7%'}, {'Count': '7,813', 'name': 'Other', 'Percentage': '6.8%'}...]
dict2 = [{'Place': 'Home'}, {'Place':'Forest'},...]
</code></pre>
<p>There are 56 elements in the first list (56 dictionaries) and 14 elements in the second list (dict2). What I want to do is inset first element from dict2 to first four elements of dict 1 and repeat the process until all 56 elements in dict1 have {Place:x}. </p>
<p>So eventually what I want to get is:</p>
<p><code>newdict = [{'Count': '307', 'name': 'Other', 'Percentage': '7.7%', 'Place': 'Home'}, {'Count': '7,813', 'name': 'Other', 'Percentage': '6.8%', 'Place':'Home'},{'Name': 'Other', 'Percentage': '6.6%', 'Place': 'Home', 'Count': '1,960'},{'Name': 'Other', 'Percentage': '7.6%', 'Place': 'Home', 'Count': '1,090'},{'Name': 'Other', 'Percentage': '7.6%', 'Place': 'Forest', 'Count': '1,090'} ]</code></p>
<p>and so on..</p>
<p>When <code>dict2</code> is exhausted, it should start from first element again.</p>
<p><strong>So I updated question. My first take on this problem was to increase number of same key:values in dict2 to:
     <code>dict2 = [{'Place': 'Home'}, {'Place':'Home'},{'Place':'Home'},{'Place':'Home'},{'Place':'Forest'},{'Place':'Forest'}...]</code>
and then use the same method mentioned below to merge dictionaries. But I believe there should be a way to do this without changing dict2.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>We'll use <code>zip</code> and <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle</code></a> to pair up elements from the two lists. </p>
<pre><code>from itertools import cycle

for a, b in zip(dict1, cycle(dict2)):
    a.update(b)
</code></pre>
<p>If you don't want to modify the original list, it's a little more complex.</p>
<pre><code>from itertools import cycle, chain

new_list = [{k:v for k, v in chain(a.items(), b.items())} for a, b in zip(dict1, cycle(dict2))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a>:</p>
<pre><code>res = []

for i, j in zip(dict1, dict2):
    res.append(i)
    res[-1].update(j)
</code></pre>
<p>If the number of items in your dicts are not the same, you can use <a href="https://docs.python.org/2/library/itertools.html#itertools.izip_longest" rel="nofollow noreferrer"><code>itertools.izip_longest()</code></a> with <code>fillvalue</code> param set to <code>{}</code>:</p>
<pre><code>res = []

for i, j in itertools.izip_longest(dict1, dict2, fillvalue={}):
    res.append(i)
    res[-1].update(j)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using modulo:</p>
<pre><code>new_list = []
x = len(dict2)
for v, item in enumerate(dict1):
    z = item.copy()
    z['Place'] = dict2[v % x]['Place']
    new_list.append(z)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about simply creating an empty dictionary called <code>result</code> and simply updating it with the list of existing dictionaries you want merged, for example:</p>
<pre><code>def merge_dicts(*dict_args):
    """
    Given any number of dicts, shallow copy and merge into a new dict,
    precedence goes to key value pairs in latter dicts.
    :param dict_args: a list of dictionaries
    :return: dict - the merged dictionary
    """
    result = {}
    for dictionary in dict_args:
        result.update(dictionary)
    return result
</code></pre>
</div>
<span class="comment-copy">What should happen for the fifteenth element of the first list, after the second list is exhausted?</span>
<span class="comment-copy">Your <code>dict2</code> has only 14 elements, what should happen when we process element 15 in `dict1?</span>
<span class="comment-copy">It should start from first element again (of dict2).</span>
<span class="comment-copy">have you tried anything?</span>
<span class="comment-copy"><code>dict1</code> and <code>dict2</code> are not good names for <code>list</code>s</span>
<span class="comment-copy">This alters the originally given dictionaries, I don't know if this is the wanted behavior. Nevertheless +1.</span>
<span class="comment-copy">@WillemVanOnsem see my edit</span>
<span class="comment-copy">If you want to build a new list... <code>[dict(a,**b) for a, b in zip(dict1, cycle(dict2))]</code></span>
<span class="comment-copy">@Chris_Rands even better!  I tried <code>dict(**a, **b)</code>, but that didn't work on the version of python i'm using so i gave up in favor of itertools</span>
<span class="comment-copy">@Extria Sure. It's  a dictionary comprehension, which is a way of building dictionaries from existing data. <code>items</code> is a method of dictionaries that returns the key, value pairs as a list of tuples.  <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>chain.from_iterable</code></a> takes an iterable of subiterables (here a list of lists) and yields all the elements of the first subiterable, then all the elements of the second subiterable.  Basically, what we're doing here is making a new dictionary by putting together the two dictionaries we already have.</span>
<span class="comment-copy">how about a list comprehension: <code>[dict(x,**y) for x,y in zip(dict1,dict2)]</code></span>
<span class="comment-copy">@Chris_Rands That's a great option!</span>
<span class="comment-copy">Thank you for answer, but this way I won't get the result I want. What I want is to update first dictionary from list dict2 to first four dictionaries in list dict1, then second dictionary from list dict2, to 4-8 dictionaries in list dict1 and so on.</span>
