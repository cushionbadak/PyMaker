<div class="post-text" itemprop="text">
<p>Daulat Ram is an affluent business man. After demonetization, IT raid was held at his accommodation in which all his money was seized. He is very eager to gain his money back, he started investing in certain ventures and earned out of them. On the first day, his income was Rs. X, followed by Rs. Y on the second day. Daulat Ram observed his growth as a function and wanted to calculate his income on the Nth day.</p>
<p>The function he found out was FN = FN-1 + FN-2 + FN-1×FN-2</p>
<p>Given his income on day 0 and day 1, calculate his income on the Nth day (yeah Its that simple).</p>
<p>INPUT:</p>
<p>The first line of input consists of a single integer T denoting number of test cases.</p>
<p>Each of the next T lines consists of three integers F0, F1 and N respectively.</p>
<p>OUTPUT:</p>
<p>For each test case, print a single integer FN, as the output can be large, calculate the answer modulo 109+7.</p>
<p>CONSTRAINTS:</p>
<p>1 ≤ T ≤ 105</p>
<p>0 ≤ F0, F1, N ≤ 109</p>
<pre><code>def function(x1):

 if x1==2:  return fnc__1+fnc__0*fnc__1+fnc__0
 elif x1==1: return fnc__1
 elif x1==0: return fnc__0

 return function(x1-1)+function(x1-2)*function(x1-1)+function(x1-2)


for i in range(int(input())):  #input() is the no of test cases
 rwINput = input().split()

 fnc__0 =int(rwINput[0])
 fnc__1 = int(rwINput[1])

 print(function(int(rwINput[2])))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>a simple way to optimize is to cache the results of your function. python provides a mechanism for just hat with its <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>lru_cache</code></a>. all you need to do is decorate your function with this:</p>
<pre><code>from functools import lru_cache

@lru_cache()
def function(n, F0=1, F1=2):

    if n == 0:
        return F0
    elif n == 1:
        return F1
    else:
        f1 = function(n-1, F0, F1)
        f2 = function(n-2, F0, F1)
        return f1+f2 + f1*f2
</code></pre>
<p>you can tweak <code>lru_cache</code> a bit for your needs. and it plays very nice with the python garbage collector as it stores <code>WeakRefs</code> to your objects only.</p>
<p>test cases:</p>
<pre><code>for i in range(7):
    print('{}: {:7d}'.format(i, function(i)))
</code></pre>
<p>prints:</p>
<pre><code>0:       1
1:       2
2:       5
3:      17
4:     107
5:    1943
6:  209951
</code></pre>
<p>to get your answer modulo an integer (not clear about the modulus in your question) you can do this:</p>
<pre><code>MOD = 10**9 + 7 # ???

@lru_cache()
def function(n, F0=1, F1=2):

    if n == 0:
        return F0
    elif n == 1:
        return F1
    else:
        f1 = function(n-1, F0, F1)
        f2 = function(n-2, F0, F1)
        return (f1+f2 + f1*f2) % MOD
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could just start execute the function and assign <code>f1</code> to <code>f0</code> and result to <code>f1</code>. Iterate over this <code>n</code> times and the desired result is in <code>f0</code>:</p>
<pre><code>MOD = 10**9 + 7

for _ in range(int(input())):
    f0, f1, n = (int(x) for x in input().split())
    for _ in range(n):
        f0, f1 = f1, (f0 + f1 + f0 * f1) % MOD

    print(f0)
</code></pre>
<p>Input:</p>
<pre><code>8
1 2 0
1 2 1
1 2 2
1 2 3
1 2 4
1 2 5
1 2 6
10 13 100
</code></pre>
<p>Output:</p>
<pre><code>1
2
5
17
107
1943
209951
276644752
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Someone gave this answer to me and it worked but i don't know how?Complexity O(logn)</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define mod 1000000007
long long int power(long long int,long long int);
void mult(long long int[2][2],long long int[2][2]);
int main()
{
    int test;
    scanf("%d",&amp;test);
    while(test--)
    {
        int n;
    int pp,p;
    scanf("%d%d%d",&amp;pp,&amp;p,&amp;n);
    long long int A[2][2] = {{1,1},{1,0}};
    n = n-1;
    long long int B[2][2] = {{1,0},{0,1}};
    while(n&gt;0)
    {
        if(n%2==1)
            mult(B,A);
        n = n/2;
        mult(A,A);
    }
   long long int result = ((power(pp+1,B[0][1])*power(p+1,B[0][0]))%mod - 1 + mod)%mod;
   printf("%lld\n",result);
   }



}

long long int power(long long int a,long long int b)
{
    long long int result = 1;
    while(b&gt;0)
    {
        if(b%2==1)
            result = (result*a)%mod;
        a = (a*a)%mod;
        b = b/2;
    }
    return result;

}
void mult(long long int A[2][2],long long int B[2][2])
{
    long long int C[2][2];
    C[0][0] = A[0][0]*B[0][0] + A[0][1]*B[1][0];
    C[0][1] = A[0][0]*B[0][1] + A[0][1]*B[1][1];
    C[1][0] = A[1][0]*B[0][0] + A[1][1]*B[1][0];
    C[1][1] = A[1][0]*B[0][1] + A[1][1]*B[1][1];
    A[0][0] = C[0][0]%(mod-1);
    A[0][1] = C[0][1]%(mod-1);
    A[1][0] = C[1][0]%(mod-1);
    A[1][1] = C[1][1]%(mod-1);
}
</code></pre>
</div>
<span class="comment-copy">@hiroprotagonist: actually memoization can be a form of easy (cheap) dynamic programming.</span>
<span class="comment-copy">@WillemVanOnsem: oh, right. thanks for the clarification!</span>
<span class="comment-copy">It didnot work . For example try 1 2 4 desired output is 117 but doing that gives 11 . explanation:F0=1  F1=2  F2=1 + 2 + 1×2 = 5  F3=2 + 5 + 2×5 = 17  F4=5 + 17 + 5×17 = 107</span>
<span class="comment-copy">@ShailabSingh: updated. you did not provide the starting conditions for your recursion. now with <code>F0 = 1, F1 = 2</code> everything is fine.</span>
<span class="comment-copy">Not working for all bigger inputs ....giving wrong results!!!</span>
<span class="comment-copy">@ShailabSingh: could you be more precise? when does it start to go wrong? how is it not working? what are you comparing the results to?</span>
<span class="comment-copy">@ShailabSingh Can you add the full problem statement to question? Quite often the sites ask you to give the result as modulus of some large number which might explain the issue with large input.</span>
<span class="comment-copy">time limit exceeded! btw dont ask me for the inputs just see the constraints!</span>
<span class="comment-copy">@ShailabSingh Updated answer based on your edits to questions. Exceeding time limit with previous answer was expected because size of the numbers weren't limited in any way. While Python integers don't have any limit operations get quite slow. I'm assuming that with modulo 109+7 you actually mean <code>10**9 + 7</code> since it's commonly used with this kind of problems,</span>
<span class="comment-copy">time limit exceeded again!!</span>
