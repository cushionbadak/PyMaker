<div class="post-text" itemprop="text">
<p>I am using <a href="https://docs.python.org/3.6/library/stdtypes.html?highlight=format_map#str.format_map" rel="nofollow noreferrer">str.format_map</a> to format some strings but I encounter a problem when this string contains quotes, even escaped. Here is the code:</p>
<pre><code>class __FormatDict(dict):
    def __missing__(self, key):
        return '{' + key + '}'

def format_dict(node, template_values):
    template_values = __FormatDict(template_values)
    for key, item in node.items():
        if isinstance(item, str):
            node[key] = item.format_map(template_values)
</code></pre>
<p>For reqular strings (that do not include brackets or quotes) it works, however for strings like <code>"{\"libraries\":[{\"file\": \"bonjour.so\", \"modules\":[{\"name\": \"hello\"}]}]}"</code> it crashes with the message <code>ValueError: Max string recursion exceeded</code>. </p>
<p>Escaping the quotes using <code>json.dumps(item)</code> before formatting it does not solve the issue. What should be done to fix this problem? I am modifying strings I get from JSON files and I would prefer to fix the Python code instead of updating the JSON documents I use.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't use your <code>__missing__</code> trick on JSON data. There are multiple problems. That's because the text within <code>{...}</code> replacement fields are <em>not just treated as strings</em>. Take a look at <a href="https://docs.python.org/3/library/string.html#formatstrings" rel="nofollow noreferrer">the syntax grammar</a>:</p>
<blockquote>
<pre><code>replacement_field ::=  "{" [field_name] ["!" conversion] [":" format_spec] "}"
field_name        ::=  arg_name ("." attribute_name | "[" element_index "]")*
</code></pre>
</blockquote>
<p>Within a replacement field, <code>!...</code> and <code>:...</code> have meaning too! What goes into those sections has strict limits as well.</p>
<p>The recursion error comes from the multiple nested <code>{...}</code> placeholders inside placeholders inside placeholders; <code>str.format()</code> and <code>str.format_map()</code> can't support a large number of levels of nesting:</p>
<pre><code>&gt;&gt;&gt; '{foo:{baz: {ham}}}'.format_map({'foo': 'bar', 'baz': 's', 'ham': 's'})
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: Max string recursion exceeded
</code></pre>
<p>but there are other problems here:</p>
<ul>
<li><p>The <code>:</code> colon denotes a <a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" rel="nofollow noreferrer">formatting specification</a>, which is then passed to the object (key) from the part before the <code>:</code>. You'd have to give your <code>__missing__</code> return values a wrapper object with <code>__format__</code> method if you wanted to recover those.</p></li>
<li><p>Field names with <code>.</code> or <code>[...]</code> in them have special meaning too; <code>"bonjour.so"</code> will be parsed as the <code>"bonjour</code> key, with a <code>so</code> attribute. Ditto for <code>[...]</code> in the field name, but for item lookups.</p></li>
</ul>
<p>Those last two can be <em>approached</em> by returning a wrapper object with <code>__format__</code> and <code>__getitem__</code> and <code>__getattr__</code> methods, but only in limited cases:</p>
<pre><code>&gt;&gt;&gt; class FormatWrapper:
...     def __init__(self, v):
...         self.v = v
...     def __format__(self, spec):
...         return '{{{}{}}}'.format(self.v, (':' + spec) if spec else '')
...     def __getitem__(self, key):
...         return FormatWrapper('{}[{}]'.format(self.v, key))
...     def __getattr__(self, attr):
...         return FormatWrapper('{}.{}'.format(self.v, attr))
...
&gt;&gt;&gt; class MissingDict(dict):
...     def __missing__(self, key):
...         return FormatWrapper(key)
...
&gt;&gt;&gt; '{"foo.com": "bar[baz]", "ham": "eggs"}'.format_map(MissingDict())
'{"foo.com": "bar[baz]", "ham": "eggs"}'
&gt;&gt;&gt; '{"foo  .com": "bar [ baz ]", "ham": "eggs"}'.format_map(MissingDict())
'{"foo  .com": "bar [ baz ]", "ham": "eggs"}'
</code></pre>
<p>This fails for 'empty' attributes:</p>
<pre><code>&gt;&gt;&gt; '{"foo...com": "bar[baz]", "ham": "eggs"}'.format_map(MissingDict())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: Empty attribute in format string
</code></pre>
<p>In short, the format makes too many assumptions about what is contained inside <code>{...}</code> curly braces, assumptions JSON data easily breaks.</p>
<p>I suggest you look at using the <a href="https://docs.python.org/3/library/string.html#template-strings" rel="nofollow noreferrer"><code>string.Template()</code> class</a> instead, a simpler templating system that can be subclassed; the default is to look for and replace <code>$identifier</code> strings. The <a href="https://docs.python.org/3/library/string.html#string.Template.safe_substitute" rel="nofollow noreferrer"><code>Template.safe_substitute()</code> method</a> does exactly what you want; replace known <code>$identifier</code> placeholders, but leave unknown names untouched.</p>
</div>
