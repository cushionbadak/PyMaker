<div class="post-text" itemprop="text">
<p>How can I use a context manager in a lambda? Hacks accepted. Defer opinions about this being a bad usage of lambdas.</p>
<p>I know I can do this:</p>
<pre><code>def f():
    with context():
        return "Foo"
</code></pre>
<p>But I would like to do something like this:</p>
<pre><code>lambda: with context(): "Foo"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't replace the work <code>with</code> does with an expression, no. There are no hacks to get you there either, because there is no way to handle exceptions and finalisation within an expression.</p>
<p>That's because you can only use <em>one expression</em> in a lambda. <code>with</code> is a <em>statement</em>, not an expression. You'd have to replace that with exception handling (<code>try..except..finally</code>) and calls to the <a href="https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers" rel="nofollow noreferrer"><code>__enter__</code> and <code>__exit__</code> methods</a> (storing the <code>__exit__</code> method <em>first</em>). However, exception handling can <em>only</em> be done with statements, because an exception ends the current expression immediately. See <a href="https://stackoverflow.com/questions/12451531/python-try-catch-block-inside-lambda">Python Try Catch Block inside lambda</a>.</p>
<p>Your <em>only option</em> is to stick to using a proper function instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>One possible workaround for getting lambdas working with a context manager is to make the context manager a <code>ContextDecorator</code>, then both <code>with</code> statements and <code>lambda</code> expressions will work because a lambda can use the decorator pattern instead.</p>
<h1><a href="https://gist.github.com/carlthome/31ba4093a6f7029053de02d70fc48ef1" rel="nofollow noreferrer">Example</a></h1>
<pre><code>from contextlib import ContextDecorator


def f(x):
     """Just prints the input, but this could be any arbitrary function."""
     print(x)


class mycontext(ContextDecorator):
    def __enter__(self):
        f('Starting')
        return self

    def __exit__(self, *exc):
        f('Finishing')
        return False

with mycontext():
    f('The bit in the middle')

mycontext()(lambda: f('The bit in the middle'))()
</code></pre>
</div>
<span class="comment-copy"><code>f</code> is not a variable in your <code>lambda</code>.</span>
<span class="comment-copy">Thanks, syntax mistake on my part. Fixed.</span>
<span class="comment-copy">What about ContextDecorator?</span>
<span class="comment-copy">Like <a href="https://gist.github.com/carlthome/31ba4093a6f7029053de02d70fc48ef1" rel="nofollow noreferrer">this</a> for example. Is there a problem with that in case of raised exceptions or something?</span>
<span class="comment-copy">Ah, I forgot about that one. <code>ContextDecorator</code> is not part of the lambda expression. It produces a new function object that contains the <code>with</code> statement, then calls the original function, and does all the exception handling. That's something different. And the context manager explicitly needs to support that use.</span>
<span class="comment-copy">I'd say making a context manager extend <code>ContextDecorator</code> instead of calling <code>contextmanager</code> is pretty trivial refactoring for getting lambdas to work with context managers though. In other words, there is an option. Are you aware of any downsides to this? Thanks for answering!</span>
<span class="comment-copy">@CarlThom√©: yes, you can't apply <code>ContextDecorator</code> to existing context manager objects, and you can't access whatever <code>__enter__</code> returns (what is assigned to <code>&lt;name&gt;</code> in <code>with &lt;contextmanager&gt; as &lt;name&gt;</code>). At that point you can either write a dedicated decorator function (and pass in the <code>as</code> result), or just write a function and use <code>with</code>.</span>
