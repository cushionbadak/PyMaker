<div class="post-text" itemprop="text">
<p>I'm using OrderDict to save color code as a key and a list as the value. I need to run on all the key and change their color code. I did the following:</p>
<pre><code>def new_increase_color(dict):

    for key in dict:
        color = str(key)
        color = (color.replace("b'", "", 1))
        color = (color.replace("'", ""))

        # create a list of two character for each index representing R-G-B
        n = 2
        rgb = ([str(color)[i:i + n] for i in range(0, len(str(color)), n)])

        # Getting the max value
        index, value = max(enumerate(rgb), key=operator.itemgetter(1))
        print ("value before: %s" %value)

        # Increasing the max value by 50%
        value = (0xFF - int(value,16)) // 2 + int(value,16)
        rgb[index] = hex(value).replace("0x", "", 1)

        # Join the list to a string again
        new_key = ''.join(rgb)

        # Updating the dict
        new_dict = ([(new_key, v) if k == key else (k, v) for k, v in dict.items()])

    return new_dict
</code></pre>
<p>When I run it, it's change only the last key:</p>
<pre><code>test_dict = {b'c31198': ['127', '840', '24'],b'c31193': ['127', '840', '24'],b'c31191': ['127', '840', '24']}

color = new_increase_color(test_dict)
print (color)

[(b'c31193', ['127', '840', '24']), (b'c31191', ['127', '840', '24']), ('e11198', ['127', '840', '24'])]
</code></pre>
<p>Here are some details on what the function does, even though i believe my mistake is more basic here.
I getting the key and convert it to a list with two character for each index (splitting to color code to red-green-blue). I then get the highest value and increase it. I then trying to save the new value as a new key in my dict.</p>
<p>Thanks in advance,
Yakir.</p>
</div>
<div class="post-text" itemprop="text">
<p>Without modifying too much your code, I think you were trying to do something like that:</p>
<pre><code>#!/usr/bin/env python3

import operator

def new_increase_color(color_dict):

    # First of all, create a copy
    new_dict = dict(color_dict)

    for key in color_dict:
        color = str(key)
        color = (color.replace("b'", "", 1))
        color = (color.replace("'", ""))

        # create a list of two character for each index representing R-G-B
        n = 2
        rgb = ([str(color)[i:i + n] for i in range(0, len(str(color)), n)])

        # Getting the max value
        index, value = max(enumerate(rgb), key=operator.itemgetter(1))
        print("value before: %s" %value)

        # Increasing the max value by 50%
        value = (0xFF - int(value,16)) // 2 + int(value,16)
        rgb[index] = hex(value).replace("0x", "", 1)

        # Join the list to a string again
        new_key = bytes(''.join(rgb), encoding='us-ascii')

        # Updating the dict
        new_dict[new_key] = new_dict[key]
        del new_dict[key]

    return new_dict

test_dict = {b'c31198': ['127', '840', '24'],b'c31193': ['127', '840', '24'],b'c31191': ['127', '840', '24']}

color = new_increase_color(test_dict)
print (color)
</code></pre>
<p>What I have done is:</p>
<ul>
<li>Make a copy of the dict outside of the loop</li>
<li>At the end of the loop:

<ul>
<li>Copy the content from the old key to the new one</li>
<li>Delete the old key</li>
</ul></li>
</ul>
<p>Also don't use <code>dict</code> as a local variable name because this name already exists as a <a href="https://docs.python.org/3/library/functions.html#func-dict" rel="nofollow noreferrer">builtin function</a>. You won't be able to call this function if needed. I have changed it in you code to <code>color_dict</code></p>
<p>Now, you could further simplify your code by taking advantage of fact that your seem to be converting characters to hexadecimal values back and forth in your code:</p>
<pre><code>#!/usr/bin/env python3

def new_increase_color(color_dict):

    # First of all, create a copy
    new_dict = dict(color_dict)

    for key in color_dict:
        color = str(key, encoding='us-ascii')
        rgb = bytearray.fromhex(color)

        # Getting the max value
        value = max(rgb)
        print("value before: {}".format(value))

        # Increasing the max value by 50% (?)
        new_value = (255 + value) // 2
        index = rgb.index(value)
        rgb[index] = new_value

        # Encode the new key
        new_key = bytes(bytes(rgb).hex(), encoding='us-ascii')

        # Updating the dict
        new_dict[new_key] = new_dict[key]
        del new_dict[key]

    return new_dict

test_dict = {b'c31198': ['127', '840', '24'],b'c31193': ['127', '840', '24'],b'c31191': ['127', '840', '24']}

color = new_increase_color(test_dict)
print (color)
</code></pre>
<p><strong>Edit:</strong> If you want to use <code>OrderedDict</code>s :</p>
<pre><code>#!/usr/bin/env python3

import collections

def new_increase_color(color_dict):

    # First of all, create a copy
    new_dict = collections.OrderedDict(color_dict)

    for key in color_dict:
        color = str(key, encoding='us-ascii')
        rgb = bytearray.fromhex(color)

        # Getting the max value
        value = max(rgb)
        print("value before: {}".format(value))

        # Increasing the max value by 50% (?)
        new_value = (255 + value) // 2
        index = rgb.index(value)
        rgb[index] = new_value

        # Join the list to a string again
        new_key = bytes(bytes(rgb).hex(), encoding='us-ascii')

        # Updating the dict
        new_dict[new_key] = new_dict[key]
        del new_dict[key]

    return new_dict

test_dict = collections.OrderedDict(((b'c31198', ['127', '840', '24']),
                                     (b'c31193', ['127', '840', '24']),
                                     (b'c31191', ['127', '840', '24'])))

color = new_increase_color(test_dict)
print (color)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As fukanchik said in the comments, the main problem with your code is that you are rewriting the whole new dictionary on each iteration of the <code>for</code> loop. Instead, you should create the new dictionary outside the loop and only modify the appropriate key in the loop.</p>
<p>Here's a repaired version of your code that will run on both Python 2 and Python 3. I've made a couple of minor changes, eg a better way of converting the <code>b</code> strings to plain strings. In Python 2, <code>b</code> strings <em>are</em> the same as normal strings, but in Python 3 normal strings are actually Unicode and <code>b</code> strings are literal <code>bytes</code> objects. FWIW, you probably don't <em>really</em> need to do that conversion, but I've done it anyway since you seem to want it. :) </p>
<p>I've also modified the input data slightly so that we can verify that each key in the new dictionary is getting associated with the correct list.</p>
<p>BTW, you should not use <code>dict</code> as a variable name because that shadows the built-in <code>dict</code> type. It will sometimes work ok, but when it doesn't it leads to mysterious bugs with cryptic error messages. Similarly, don't use <code>list</code>, <code>str</code>, <code>int</code>, <code>set</code>, etc as variable names.</p>
<pre><code>import operator

def new_increase_color(old_dict):
    new_dict = {}
    for key in old_dict:
        color = str(key.decode())

        # Split color string into pairs of hex digits
        rgb = [color[i:i + 2] for i in (0, 2, 4)]

        # Get the max value &amp; its index
        index, value = max(enumerate(rgb), key=operator.itemgetter(1))

        # Increase the max value by 50%
        value = int(value, 16)
        value = (0xFF - value) // 2 + value
        rgb[index] = format(value, '02x')

        # Convert the list back to a string
        new_key = ''.join(rgb)

        # Update the dict
        new_dict[new_key] = old_dict[key]
    return new_dict

test_dict = {
    b'c31198': ['127', '840', '26'],
    b'c31193': ['127', '840', '25'],
    b'c31191': ['127', '840', '24'],
}

new_dict = new_increase_color(test_dict)
print(new_dict)
</code></pre>
<p><strong>output</strong></p>
<pre><code>{'e11191': ['127', '840', '24'], 'e11193': ['127', '840', '25'], 'e11198': ['127', '840', '26']}
</code></pre>
<hr/>
<p>If you need to preserve the order of insertion in these dictionaries then you should use <code>OrderedDict</code> for both the input &amp; output dicts.</p>
<pre><code>import operator
from collections import OrderedDict
from pprint import pprint

def new_increase_color(old_dict):
    new_dict = OrderedDict()
    for key in old_dict:
        color = str(key.decode())

        # Split color string into pairs of hex digits
        rgb = [color[i:i + 2] for i in (0, 2, 4)]

        # Get the max value &amp; its index
        index, value = max(enumerate(rgb), key=operator.itemgetter(1))

        # Increase the max value by 50%
        value = int(value, 16)
        value = (0xFF - value) // 2 + value
        rgb[index] = format(value, '02x')

        # Convert the list back to a string
        new_key = ''.join(rgb)

        # Update the dict
        new_dict[new_key] = old_dict[key]
    return new_dict

test_dict = OrderedDict([
    (b'c31198', ['127', '840', '26']),
    (b'c31193', ['127', '840', '25']),
    (b'c31191', ['127', '840', '24']),
])

pprint(test_dict)

new_dict = new_increase_color(test_dict)
pprint(new_dict)
</code></pre>
<p><strong>output</strong></p>
<pre><code>OrderedDict([(b'c31198', ['127', '840', '26']),
             (b'c31193', ['127', '840', '25']),
             (b'c31191', ['127', '840', '24'])])
OrderedDict([('e11198', ['127', '840', '26']),
             ('e11193', ['127', '840', '25']),
             ('e11191', ['127', '840', '24'])])
</code></pre>
</div>
<span class="comment-copy">You have logic error: a new <code>new_dict</code> is created on each loop iteration replacing only one value from the old dict.</span>
<span class="comment-copy">Thank you very much! only thing left is to still use OrderDic so I can play with the dict without messing their order.  with your suggestions, i tried to make new_dict = OrderDict(color_dict) - but that didn't help so I also tried to make my test_dict as a OrderDict, which also didn't help - any ideas?</span>
<span class="comment-copy">I have updated my answer and added a case using OrderedDict</span>
<span class="comment-copy">The above seems like a solution as well. Thank you! As I asked in  EvensF answer- how can i use OrderDict to save the keys order?</span>
<span class="comment-copy">@YakirMordehay Easy! Just make both the input &amp; output dicts <code>OrderedDict</code>s. I'll add some more code to my answer.</span>
