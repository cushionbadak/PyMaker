<div class="post-text" itemprop="text">
<p>I am using asyncio client to connect and then disconnect from server. </p>
<ul>
<li><p>If I connect to server program on the same computer, <del>connection closes fine.</del> <strong>Add:</strong> When I started writing data to connection, this connection also started giving warnings <em>sometimes</em>. See second code version below.</p></li>
<li><p>If I connect to device on the local network, I get <code>ResourceWarning</code> for unclosed transport.</p></li>
</ul>
<p><strong>How do I close the connection correctly?</strong></p>
<p>I am using Python 3.6.0 (32-bit) on Windows 7 (64-bit).</p>
<h1>First attempt</h1>
<p>Relevant code:</p>
<pre><code>import asyncio
import logging
import warnings

class ClientConnection(asyncio.Protocol):
    def connection_made(self, transport):
        self.transport = transport
        transport.write_eof()  # Send EOF to close connection

    def connection_lost(self, exception):
        self.transport.close()
        super().connection_lost(exception)

def main():
    logging.basicConfig(level=logging.DEBUG)
    eventLoop = asyncio.get_event_loop()
    eventLoop.set_debug(True)
    warnings.simplefilter('always', ResourceWarning)  # enables ResourceWarning
    #co = eventLoop.create_connection(ClientConnection, '127.0.0.1', 7001)     # Works without warning
    co = eventLoop.create_connection(ClientConnection, '192.168.10.66', 7001)  # Gives warning
    try:
        eventLoop.run_until_complete(co)
    finally:
        eventLoop.close()

if __name__ == "__main__":
    main()
</code></pre>
<p>Console output:</p>
<pre><code>DEBUG:asyncio:Using selector: SelectSelector
DEBUG:asyncio:connect &lt;socket.socket fd=240, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6&gt; to ('19
2.168.10.66', 7001)
DEBUG:asyncio:poll took 0.000 ms: 1 events
DEBUG:asyncio:&lt;socket.socket fd=240, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('192.168
.10.62', 64587), raddr=('192.168.10.66', 7001)&gt; connected to 192.168.10.66:7001: (&lt;_SelectorSocketTransport fd=240 read=
polling write=&lt;idle, bufsize=0&gt;&gt;, &lt;__main__.ClientConnection object at 0x005EBD90&gt;)
DEBUG:asyncio:Close &lt;_WindowsSelectorEventLoop running=False closed=False debug=True&gt;
sys:1: ResourceWarning: unclosed &lt;socket.socket fd=240, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto
=6, laddr=('192.168.10.62', 64587), raddr=('192.168.10.66', 7001)&gt;
C:\Program Files (x86)\Python36-32\lib\asyncio\selector_events.py:631: ResourceWarning: unclosed transport &lt;_SelectorSoc
ketTransport fd=240&gt;
  source=self)
</code></pre>
<h1>Second attempt</h1>
<p>I did following changes to the code:</p>
<ul>
<li>Removed <code>transport.close()</code> from <code>connection_lost</code></li>
<li>Write some data to connection</li>
<li>Added <code>data_received</code> and  <code>eof_received</code> callbacks</li>
<li>Added more debug logs</li>
</ul>
<p>Observations:</p>
<ul>
<li>I tried adding <code>transport.close()</code> to <code>connection_made</code>, but it will always result in <code>OSError: [WinError 10038]</code>. <em>Note: This probably another problem, so let's ignore this for now, and assume I won't do this.</em></li>
<li>When writing some data to socket, localhost connection also started to give warnings, but not always.</li>
<li>When it gives warning, <code>connection_lost</code> is not called. Why?</li>
</ul>
<p>Modified code:</p>
<pre><code>import asyncio
import logging
import warnings

class ClientConnection(asyncio.Protocol):
    def connection_made(self, transport):
        logging.debug('connection_made')
        self.transport = transport
        transport.write(b'1234\r')
        transport.write_eof()  # Send EOF to close connection
        #transport.close()  # Cannot close here either, gives 'OSError: [WinError 10038]'

    def connection_lost(self, exception):
        logging.debug('connection_lost')
        super().connection_lost(exception)

    def data_received(self, data):
        logging.debug('received {} bytes'.format(len(data)))

    def eof_received(self):
        logging.debug('EOF received')
        self.transport.close()

def main():
    logging.basicConfig(level=logging.DEBUG)
    eventLoop = asyncio.get_event_loop()
    eventLoop.set_debug(True)
    warnings.simplefilter('always', ResourceWarning)  # enables ResourceWarning
    #co = eventLoop.create_connection(ClientConnection, '127.0.0.1', 7001)     # Works without warning
    co = eventLoop.create_connection(ClientConnection, '192.168.10.66', 7001)  # Gives warning
    try:
        eventLoop.run_until_complete(co)
        logging.debug('done')
    finally:
        eventLoop.close()

if __name__ == "__main__":
    main()
</code></pre>
<p>Output when it succeeds:</p>
<pre><code>...
DEBUG:root:EOF received
DEBUG:root:connection_lost
DEBUG:root:done
DEBUG:asyncio:Close &lt;_WindowsSelectorEventLoop running=False closed=False debug=True&gt;
</code></pre>
<p>Output when it fails (note the lack of <code>connection_lost</code>):</p>
<pre><code>...
DEBUG:root:EOF received
DEBUG:root:done
DEBUG:asyncio:Close &lt;_WindowsSelectorEventLoop running=False closed=False debug=True&gt;
sys:1: ResourceWarning: unclosed &lt;socket.socket fd=240, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto
=6, laddr=('127.0.0.1', 63858), raddr=('127.0.0.1', 7001)&gt;
C:\Program Files (x86)\Python36-32\lib\asyncio\selector_events.py:631: ResourceWarning: unclosed transport &lt;_SelectorSoc
ketTransport closing fd=240&gt;
  source=self)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Either wait for the server to close your connection, or use <code>transport.close()</code> to close the transport.  This will also trigger <code>connection_lost</code> (Don't call <code>transport.close()</code> from <code>connection_lost</code>!):</p>
<pre><code>class ClientConnection(asyncio.Protocol):
    def connection_made(self, transport):
        logging.debug("connection made, calling write eof")
        transport.write_eof()
        logging.debug("after calling write eof, calling close")
        transport.close()
        logging.debug("after calling close")

    def connection_lost(self, exception):
        logging.debug("connection lost")
        super().connection_lost(exception)
</code></pre>
<p>If you try a little more, you might get some <code>ResourceWarning</code>s for your local machine as well.  For example, try adding <code>transport.write(b'hello world!')</code> before <code>write_eof()</code> or make your local server respond slower.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try running the loop a little more.  Here is an example using <code>loop.run_forever()</code> and <code>loop.stop()</code>, assuming <a href="https://docs.python.org/3/library/asyncio-protocol.html#tcp-echo-server-protocol" rel="nofollow noreferrer">echo server</a>s on local and remote machines:</p>
<pre><code>import asyncio
import logging

import warnings


class ClientConnection(asyncio.Protocol):
    def connection_made(self, transport):
        logging.debug("connection made, sending and calling write eof")
        transport.write(b'hello')
        transport.write_eof()
        logging.debug("after calling write eof")

    def data_received(self, data):
        logging.debug("Got: {}".format(data))
        super().data_received(data)

    def connection_lost(self, exception):
        logging.debug("connection lost")
        super().connection_lost(exception)
        loop.stop()


def test_echo(ip, port):
    logging.debug("Creating connection: {}:{}".format(ip, port))
    co = loop.create_connection(ClientConnection, ip, port)
    logging.debug("Starting loop...")
    print(loop.run_until_complete(co))
    logging.debug("...create_connection done, running loop forever...")
    loop.run_forever()
    logging.debug("Loop stopped")

    logging.debug('----------------')


if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)
    warnings.simplefilter('always')  # enables ResourceWarning

    loop = asyncio.get_event_loop()
    loop.set_debug(True)

    test_echo('127.0.0.1', 7001)
    test_echo('54.175.103.105', 30000)

    logging.debug("done")
    loop.close()
</code></pre>
</div>
<span class="comment-copy">Cannot reproduce <code>WinError</code> on linux :-) transport.close() works fine.  Try adding <code>time.sleep(0.05)</code> before <code>.close()</code>.</span>
<span class="comment-copy">@Udi Timeout doesn't seem to help, Windows seems to be picky about something. I'll probably ask another question about that. <i>But</i>, using delay alone seems to prevent the original problem. I need to do some testing, but it may be that my program simply does everything too fast. Thank you for your help so far.</span>
<span class="comment-copy">Apparently under windows <code>write_eof</code> calls <code>close()</code>.  Also: Try running the loop forever and <code>stop()</code> it in <code>connection_lost</code>.</span>
<span class="comment-copy">You were right about sending data to localhost socket: It will trigger warning too. But I cannot close transport from <code>connection_made</code> either, I start getting OSErrors. I have amended the question.</span>
<span class="comment-copy">Posting this is a new question will make more sense</span>
<span class="comment-copy">OSError probably needs to go to another question (I'll make edit to exclude that), but this question still remains open: Sometimes <code>connection_lost</code> is not called, which gives the warning.</span>
<span class="comment-copy">Consider changing the subject to "connection_lost not called"</span>
