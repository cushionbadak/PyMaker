<div class="post-text" itemprop="text">
<p>I have two files:</p>
<p>1.csv</p>
<pre><code>1,2
3,4
</code></pre>
<p>2.csv</p>
<pre><code>1,2,4,5
5,6,7,8
</code></pre>
<p>The second column from 1.csv should be appended in the 2.csv last column as output.</p>
<p>Desired output is: </p>
<pre><code>1,2,4,5,2
5,6,7,8,4
</code></pre>
<p>The script is:</p>
<pre><code>import csv

d_1 = {}

with open('1.csv') as f_1:
    for row in csv.reader(f_1):
        d_1[row[0]] = row[1:]

with open('2.csv') as f_2, open('out.csv', 'wb') as f_out:
    csv_out = csv.writer(f_out)

    for row in csv.reader(f_2):
        if row[0] in d_1:
            row.extend(d_1[row[0]])

        csv_out.writerow(row)
</code></pre>
<p>but from this script it is not appending the second column from 1.csv to the output</p>
</div>
<div class="post-text" itemprop="text">
<p>You code was using the incorrect index, try this:</p>
<pre><code>import csv

d_1 = []
with open('1.csv') as f_1:
    for row in csv.reader(f_1):
        d_1.append(row[1:])

with open('2.csv') as f_2, open('out.csv', 'wb') as f_out:
    csv_out = csv.writer(f_out)

    for i, row in enumerate(csv.reader(f_2)):
        row.extend(d_1[i])    
        csv_out.writerow(row)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a pandas approach. Wait for other incoming answers if you don't want to use pandas:</p>
<pre><code>import pandas as pd

df1 = pd.read_csv(csv1, header=None)  #give the file path of csv1
df2 = pd.read_csv(csv2, header=None)  #give the file path of csv2

df2[df2.columns[-1]+1] = df1[1]
df2.to_csv('new_csv', header=None, index=None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You code fails, because it assumes that the first field on each file is a key - while it is not.</p>
<p>An easy fix would be to use a simple list in place of your dict:</p>
<pre><code>import csv

d_1 = []

with open('1.csv') as f_1:
    for row in csv.reader(f_1):
        d_1.append(row[1:])

with open('2.csv') as f_2, open('out.csv', 'wb') as f_out:
    csv_out = csv.writer(f_out)

    for i, row in enumerate(csv.reader(f_2)):
        row.extend(d_1[i])

        csv_out.writerow(row)
</code></pre>
<p>But you could also read one line from both input file and write the <em>concatenation</em> to output file on each iteration:</p>
<pre><code>with open("1.csv") as f_1, open("2.csv") as f_2, open("out.csv", 'wb') as f_out:
    csv_out = csv.writer(f_out)
    csv1 = csv.reader(f_1)
    csv2 = csv.reader(f_2)

    try:
        while True:
            row1 = next(csv1)
            row2 = next(csv2)
            row2.extend(row1[1:])
            csv_out.writerow(row2)
    except StopIteration:
        pass
</code></pre>
</div>
<span class="comment-copy">Print out the <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">dictionary</a> <code>d_1</code> and you will understand what's going on in your script.</span>
<span class="comment-copy">Why on earth have you removed the examples of input and output???</span>
