<div class="post-text" itemprop="text">
<p>To my knowledge, there are two types of overloading, one based on number of arguments, and one based on argument types</p>
<p>While overloading based on number of arguments has been covered <a href="https://stackoverflow.com/questions/6434482/python-function-overloading">here</a>, I can't seem to find guidelines on function overloading by argument type.</p>
<p>So since type checking with <code>type()</code> seems to be generally frowned upon, how do I do this in a pythonic way?</p>
<p>This seems less elegant than I would expect...</p>
<pre><code>def overloaded_func(arg):
    try:
        do_list_action(arg)
    except:
        try:
            do_dict_action(arg)
        except:
            pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Type checking with <code>type()</code> (or, better, <code>isinstance()</code>) isn't frowned upon <em>in general</em> in Python. What's frowned upon is <strong>using type as a proxy for behavior</strong> when you can get away with only checking the behavior. In other words, when you need an object to have some certain functionality, whereas in some other languages you would have to explicitly check whether its type supports that functionality, in Python you just assume the object does what you need it to do, and trust that an exception will be raised if that's not the case. But if you're choosing between different types of functionality, any of which will do the job for you, that's a different story.</p>
<p>For example, suppose you have some code that can use either lists or dicts to implement integer-indexed arrays.</p>
<pre><code>class Array:
    def __init__(self, keys_and_values):
        self.store = ... # either a list or a dict
</code></pre>
<p>Perhaps it uses a dict if only a few, very large indices have values assigned, and a list otherwise. If you want to access the element at an index, if there is one, then you just write <code>self.store[index]</code>.</p>
<pre><code>    def __getitem__(self, index):
        return self.store[index]
</code></pre>
<p>You don't bother to check whether it's a list or a dict first, because the <em>behavior</em> you want - the ability to be indexed by an integer - exists either way.</p>
<p>But if you want to <em>set</em> the element at an index, if it's a list, you need to extend it to the proper length first. Now, proper duck typing would probably suggest you do this:</p>
<pre><code>    def __setitem__(self, index, value):
        if index &gt;= len(self.store):
            try:
                self.store.extend([None] * (index - len(self.store) + 1))
            except AttributeError:
                pass
        self.store[index] = value
</code></pre>
<p>But I think most Python programmers would say <code>isinstance()</code> is better in this case. (No, really. It's okay.)</p>
<pre><code>    def __setitem__(self, index, value):
        if isinstance(self.store, list) and index &gt;= len(self.store):
            self.store.extend([None] * (index - len(self.store) + 1))
        self.store[index] = value
</code></pre>
<p>I would generally recommend this route when you've only got a few types to test.</p>
<p>If you have many more types to test, it's more practical to use a dispatcher pattern, which is a functional approach. You build a mapping of types to functions that handle that type, and choose which one to call based on the type of the object you get. In this example, that would play out like this:</p>
<pre><code>    def __setitem__dict(self, index, value):
        self.store[index] = value
    def __setitem__list(self, index, value):
        if index &gt;= len(self.store):
            self.store.extend([None] * (index - len(self.store) + 1))
        self.store[index] = value
    __setitem__dispatch = {list: __setitem__list, dict: __setitem__dict}
    def __setitem__(self, index, value):
        self.__setitem__dispatch[type(self.store)](index, value)
</code></pre>
<p>It's pretty silly to do this in this simple example, but in more complicated scenarios it can come in very handy. The pattern in general is</p>
<pre><code>dispatch = {list: handle_list, dict: handle_dict, ...}
def function(arg):
    return dispatch[type(arg)](arg)
</code></pre>
<p>It even lets you dynamically add handlers for new types later on. This is basically what <code>functools.singledispatch</code> does (as <a href="https://stackoverflow.com/a/41690596/56541">another answer</a> mentioned). That way just looks complicated because it hides the <code>dispatch</code> dictionary as an attribute of the original function itself.</p>
<p>It's impossible to say in general whether to use duck typing, type checking, dispatching, or something else, because it's somewhat subjective and depends on the details of your situation: how different is the code you need to handle different types? How many types are you dealing with? Do you need to be able to handle new types easily? And so on. You haven't given enough information in the question to allow anyone else to tell you which way seems best, but they all have their uses.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer"><code>functools.singledispatch</code></a>. It will dispatch based on the type of first parameter and uses the default implementation if type doesn't match with any of the registered functions:</p>
<pre><code>from functools import singledispatch

@singledispatch
def overloaded_func(arg):
    print('Default impl', arg)

@overloaded_func.register(list)
def do_list_action(lst):
    print('List action', lst)

@overloaded_func.register(dict)
def do_list_action(dct):
    print('Dict action', dct)

overloaded_func(['foobar'])
overloaded_func({'foo':'bar'})
overloaded_func('foobar')
</code></pre>
<p>Output:</p>
<pre><code>List action ['foobar']
Dict action {'foo': 'bar'}
Default impl foobar
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>isinstance</code>:</p>
<pre><code>def overloaded_func(arg):
    if isinstance(arg, list):
        do_list_action(arg)
    elif isinstance(arg, dict):
        do_dict_action(arg)
    else:
        do_default_action(arg)
</code></pre>
<p>Alternatively, you might consider checking other ways such as for the presence of <code>__getitem__</code> or <code>__iter__</code> etc.  This depends on the details of why you're overloading, which you haven't shared with us.  </p>
</div>
<span class="comment-copy">I think there's a multimethods implementation available, probably based on hiding type dispatch in decorators</span>
<span class="comment-copy">This seems much clumsier than other strongly typed languages... but seeing it's the best out of available answers, i'll accept this</span>
<span class="comment-copy">isn't <code>isinstance()</code> equally frowned down upon as <code>type()</code>? So what I'm getting is that I should check for the presence of all the functions I use in <code>do_list_action</code> and <code>do_dict_action</code> to determine which function to call?</span>
<span class="comment-copy">@Woofas: No, <code>isinstance</code> is not "frowned upon" other than perhaps by some idealogues.  You could do what you say--check if the features you need are present on the argument you receive.  AKA "duck typing."</span>
