<div class="post-text" itemprop="text">
<p>Simple question, when doing:</p>
<pre><code>[list comprehension here][start_index:end_index]
</code></pre>
<p>Does this create the entire list and then return the selected indexes?</p>
<p>If so, is there a way to only create the list from these indexes without creating the entire list?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Does this create the entire list and then return the selected indexes?</p>
</blockquote>
<p>Yes. We need a list for the slicing to slice.</p>
<blockquote>
<p>If so, is there a way to only create the list from these indexes without creating the entire list?</p>
</blockquote>
<p>Instead of building more list than you need and then slicing out the part you want, write your list comprehension to only generate the part you need. For example, instead of</p>
<pre><code>[x**2 for x in l][2:5]
</code></pre>
<p>write</p>
<pre><code>[x**2 for x in l[2:5]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, the first expression (the list comprehension) has to <em>complete</em> before the second expression can be applied to the result.</p>
<p>If your list comprehension only has a single loop and doesn't have any filters (no <code>if &lt;test&gt;</code> code after the loop), then you can trivially apply the slice to the object you are looping over, instead:</p>
<pre><code>[&lt;expression&gt; for &lt;name&gt; in sequence[start_index:end_index]]
</code></pre>
<p>If the object you are iterating over is not a sequence but an iterator instead, use the <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice()</code> object</a> to do the slicing:</p>
<pre><code>[&lt;expression&gt; for &lt;name&gt; in islice(sequence, start_index, end_index)]
</code></pre>
<p>For nested loops or loops with a filter, moving those into a list comprehension inside the <code>islice()</code> object could help:</p>
<pre><code>[&lt;expression&gt; for &lt;name&gt; in islice(
    (&lt;name&gt; for &lt;foo&gt; in outer for &lt;name&gt; in &lt;foo&gt;),
    start_index, end_index)]
</code></pre>
<p>Note: <code>islice()</code> still has to loop over <code>start_index</code> items of the first argument, it can't jump into the iteration sequence directly. This means that if that iterable is slow or <code>start_index</code> is very high, there is still a start-up cost. However, if the list comprehension <code>&lt;expression&gt;</code> is expensive or <code>end_index</code> is significantly reducing the number of items you'd have to iterate over that you later ignore again, <code>islice()</code> will still give you a win.</p>
</div>
<span class="comment-copy">Why don't you try it and see what happens?</span>
<span class="comment-copy">Thanks, exactly what I wanted.</span>
<span class="comment-copy">Thanks, thought so. Do you have an answer to the second question, or does list comprehension just always have to complete as you say?</span>
<span class="comment-copy">@shell: I was still editing. Yes, a list comprehension <i>has to complete</i> before any other expression can be applied to the result.</span>
<span class="comment-copy">Note that <code>itertools.islice</code> doesn't have any special ability to skip quickly through whatever you're islice-ing, so it has to slowly go through all the elements before <code>start_index</code> one by one before it can start producing output. It's easy to forget about this and get performance degradation when you try to <code>islice</code> deep into some iterable.</span>
<span class="comment-copy">@user2357112: absolutely. It does become really helpful when <code>&lt;expression&gt;</code> is expensive, or <code>end_index</code> reduces the number of iterations significantly.</span>
