<div class="post-text" itemprop="text">
<p>I'd like to go through all n-digit numbers such that second digit of the number is always lower or equal to the first, third is lower or equal to the second etc. I can get this by writing a horrible code such as:</p>
<pre><code>for i in range(10):
    for j in range(i+1):
        for k in range(j+1):
</code></pre>
<p>etc., but with 10-digit numbers my code starts looking horrible, and also that's a lot of writing, and indentation get horrible if I want to commend few of those. Is there a nice, concise way of getting this?</p>
<p>Edit: just so that people know why I'm bothering with this, <a href="https://projecteuler.net/problem=74">https://projecteuler.net/problem=74</a> has me check numbers from 1 to one milion. Unfortunately, It's not as straightforward as I thought -- numbers with leading zeros are treated differently than the ones with zeros inside, so some additional magic had to be performed. Anyway, thanks to all for insightful suggestions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Could use <code>itertools</code>:</p>
<pre><code>&gt;&gt;&gt; for comb in itertools.combinations_with_replacement(range(9, -1, -1), 3):
        print comb

(9, 9, 9)
(9, 9, 8)
(9, 9, 7)
(9, 9, 6)
...
(4, 0, 0)
(3, 3, 3)
(3, 3, 2)
(3, 3, 1)
(3, 3, 0)
(3, 2, 2)
(3, 2, 1)
(3, 2, 0)
(3, 1, 1)
(3, 1, 0)
(3, 0, 0)
(2, 2, 2)
(2, 2, 1)
(2, 2, 0)
(2, 1, 1)
(2, 1, 0)
(2, 0, 0)
(1, 1, 1)
(1, 1, 0)
(1, 0, 0)
(0, 0, 0)
</code></pre>
<hr/>
<p>Or recursively, appending more and more digits until enough, which can more directly produce <code>int</code> objects instead of digit tuples (not sure whether that's what you actually need):</p>
<pre><code>def build(enough, prefix=0):
    if prefix &gt;= enough:
        print(prefix)
        return
    for digit in range(prefix % 10 + 1) if prefix else range(1, 10):
        build(enough, prefix * 10 + digit)
</code></pre>
<p>Demo (note it leaves out "<code>000</code>", not sure whether you'd want that anyway):</p>
<pre><code>&gt;&gt;&gt; n = 3
&gt;&gt;&gt; build(10**(n-1))
100
110
111
200
210
211
220
221
222
300
310
311
320
321
322
330
331
332
333
400
410
411
420
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this an approach using <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" rel="nofollow noreferrer"><code>itertools</code></a>:</p>
<pre><code>from itertools import combinations_with_replacement

N = 3

for kji in combinations_with_replacement((str(i) for i in range(10)), N):
    print(''.join(reversed(kji)))
</code></pre>
<p>note that the order is not the same as in your original approach.</p>
<p>i recently had a <a href="https://stackoverflow.com/questions/41521725/iterating-over-multiple-indices-with-i-j-k-in-a-pythonic-way">simliar question</a>...</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple recursive approach:</p>
<pre><code>def ordered_digits_generator(numDigits,min=1,max=9):
    for first in range(min,max+1):
        if numDigits == 1:
             yield first
        else:
             addend = first*10**(numDigits-1)
             for rest in ordered_digits(numDigits-1,min=0,max=first):
                 yield addend+rest
</code></pre>
<p>Then called via:</p>
<pre><code>for number in ordered_digits_generator(10):
    print number
</code></pre>
<p>works as expected.</p>
<h2>The mathematician's approach</h2>
<p>The itertools package already has logic which essentially already implements this recursion. Presumably better than we can, with significant testing. So we can use it as follows:</p>
<pre><code>import itertools
def ordered_digits_combo(numDigits):
    exponent = [10**i for i in range(0,numDigits)]

    for subset in itertools.combinations(range(0,numDigits+9),numDigits):
        if subset[numDigits-1]&gt;numDigits-1:
            v = 0
            for i in range(0,numDigits):
                v += exponent[i]*(subset[i]-i)
            yield v
</code></pre>
<p>Given an ordered subset <code>a[0]&lt;a[1]&lt;...&lt;a[n-1]</code> of <code>{0,1,...,n+8}</code>, we pick the number with the i<sup>th</sup> digit from the right equal to <code>a[i]-i</code>. We have to exclude the case <code>a[n-1]==n-1</code> because that consists of he number with all zeros.</p>
</div>
<div class="post-text" itemprop="text">
<p>I implemented @iFlo's suggestion as commented originally. It's not hyper efficient but it certainly doesn't take ages.</p>
<pre><code>def digit_test(n):
    while n &gt; 9:
        if (n % 100 / 10) &lt; (n % 10): return False
        n /= 10
    return True

# under a second to construct a list of all numbers below 1000000 meeting the criteria
candidates = [x for x in xrange(1,1000000) if digit_test(x)]

# should be 8001 elements, consistent with other algorithms
print len(candidates)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would probably implement this recursively:</p>
<pre><code>def generate(max, digits):
    for d in range(max + 1):
        if digits == 1:
            yield d
        else:
            first = d * 10**(digits-1)
            for n in generate(d, digits - 1):
                yield first + n
</code></pre>
<p>The output:</p>
<pre><code>In : list(generate(3, 3))
Out:
[0,
 100,
 110,
 111,
 200,
 210,
 211,
 220,
 221,
 222,
 300,
 310,
 311,
 320,
 321,
 322,
 330,
 331,
 332,
 333]
</code></pre>
</div>
<span class="comment-copy">@iFlo some ancient beast that works by mysterious magic.</span>
<span class="comment-copy">Is the order of the numbers important?</span>
<span class="comment-copy">Actually, here the way you should proceed : Considerate your number, compare the two first digit. Then, call the function again but you have truncate the first digit. Then you are checking the 2nd and the 3rd digit, etc. You can stop either if there is no longer two digitis to compare or if the current comparison failed.</span>
<span class="comment-copy">@iFlo I don't think you understand. I don't want to check whether or not a given number obeys my rule, I want to run a function on ALL n-digit numbers obeying this rule, so it's quite crucial not to iterate on all n-digit numbers and just check if the rule is being obeyed because it would take ages.</span>
<span class="comment-copy">Not entirely related to your question: it's possible to combine multiple for loops into a single loop using <a href="http://codegolf.stackexchange.com/a/41217/34718">this trick</a>.</span>
<span class="comment-copy">This works exactly as I wanted it to. Thank you very much.</span>
<span class="comment-copy">Thank you Hiro, this works exactly the way I wanted, as Stefan pointed out above.</span>
<span class="comment-copy">@098799: yep, he beat me to the answer, and i like his treatment of the order of the indices better...</span>
<span class="comment-copy">@hiroprotagonist You could replace <code>range(10)</code> with <code>map(str, range(10)</code>. Would make the later usage simpler and faster.</span>
<span class="comment-copy">@StefanPochmann: thanks for the suggestion! updated. (i prefer the generator expression instead of <code>map</code>...)</span>
<span class="comment-copy">@hiroprotagonist Or <code>'0123456789'</code> :-). Shorter and clearer, though I don't quite like hardcoding stuff like that...</span>
