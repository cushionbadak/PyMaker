<div class="post-text" itemprop="text">
<p>I have a text file that follows this format. </p>
<blockquote>
<p>LESTER HOLT (00:00:01): Breaking News Tonight: A deadly mass shooting
  at the airport. A gunman opens fire at baggage claim in Fort
  Lauderdale, witnesses describing scenes of sheer horror. A silent
  killer shooting people in the head as they tried to run and hide.
  Tonight, a storm of questions. Why did he do it? The suspect, a
  passenger with a firearm in his checked bag. New concerns about
  airport security before the checkpoint.</p>
<p>(00:00:25): Also breaking tonight the new report from U.S.
  intelligence: Vladimir Putin himself ordered the effort to influence
  the election, aimed at hurting Clinton and helping Trump win. What the
  President-elect is saying after his top-secret briefing.</p>
<p>(00:00:39): And States of Emergency: Millions from coast to coast
  paralyzed by a massive winter storm.</p>
<p>(00:00:45): NIGHTLY NEWS begins right now.</p>
</blockquote>
<p>I am trying to parse this information into a Python Dictionary, where the speaker is a dictionary, of dictionaries, which has timecode keys, and the content is the value, I can't consistently split because of potential information before the timecode, (IE the first quote), as well as the fact that the split character <code>:</code> is also a character involved with the timecode itself <code>00:00:00</code>.</p>
<p>Trying to split according to the regex.</p>
<pre><code>for line in msg.get_payload().split('\n'):
    regex = r'\d{2}:\d{2}:\d{2}'
    test = re.split(regex, line)
    print(test)
    sleep(1)
</code></pre>
<p>Appears to work in splitting it properly, but it causes me to lose the value I am splitting on (timecode), which I intend to use as a key. How can I properly split the above content, get the speaker, and then get the timecode as a key, and the content as a value.It is possible he may be present later in the text as well, and it should append to the list of timecodes./ </p>
<p>The output format I am targeting is something along the lines of</p>
<pre><code>{speakers:{'Lester Holt': {'00:00:01':content..., '00:00:0025': content...},
'speaker2':{etc,etc,etc} }}
</code></pre>
<p>Ive tried using the split as mentioned above, but it removes my timecode variable. </p>
<p>Any thoughts and guidance is appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<p>Don't bother with <code>split</code>. You're trying to get 2-3 pieces of information out of each line, so try the following:</p>
<pre><code>for line in msg.get_payload().split('\n'):
    match = re.search(r'^\s*([^(]*?)\s*\((\d{2}:\d{2}:\d{2})\):\s*(.*)$', line)
    if match:
        (speaker, time, message) = match.groups()
</code></pre>
<p>Speaker will be an empty string if none was present on that line.</p>
<p>Regex explanation:</p>
<pre><code>^                    # Start of line
\s*                  # Drop leading whitespace
([^(]*?)             # Capture the speaker if present (non-paren characters)
\s*                  # Drop whitespace between name and time
\(                   # Drop literal open paren
(\d{2}:\d{2}:\d{2})  # Capture time
\):\s*               # Drop literal close paren, colon and whitespace
(.*)                 # Capture the rest of the line
$                    # End of line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Splitting message in lines when you need to split it in time-stamped paragraphs is a waste. <code>re.split</code> can easily save the tokens that it split on, if you only look at <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">the documentation</a>. Here's my solution:</p>
<pre><code>toks = re.split(r"\((\d\d:\d\d:\d\d)\):", msg.get_payload())[1:]
answer = dict(zip(toks[::2], toks[1::2]))
</code></pre>
<p>This creates a dictionary of timestamps and paragraphs. Feel free to use the same approach to split by speaker as well.</p>
<p>Result:
    {
        '00:00:01': ' Breaking News Tonight: A .....',
        '00:00:25': ' Also breaking tonight ......', ....
    }</p>
</div>
<span class="comment-copy">Before trying a regex solution, could you just split on <code>):</code>?</span>
<span class="comment-copy">@PatrickHaugh you're killing the regex fun :)</span>
<span class="comment-copy">Maybe something like <code>([\w\s]*?)(\(\d\d:\d\d:\d\d\)):(.*)(?:\n\n|$)</code> <a href="https://regex101.com/r/UZAnmW/2" rel="nofollow noreferrer">DEMO HERE</a></span>
<span class="comment-copy">I could, yes, but without being 100% sure that that ): does not exist in all txt files that may or may not include that in the content</span>
<span class="comment-copy">@Busturdust if you're not familiar with them already, I suggest looking up "capturing groups", which is a way of extracting text from text that matches the regex.</span>
<span class="comment-copy">Thank you for your answer, as I am new to regex, I am going to review the expression and test it out. However on a first run, it looks like it worked pretty cleanly. Thank you for your quick effort</span>
<span class="comment-copy">and then he updates it with the explanations, wonderful thank you!</span>
<span class="comment-copy">Is there some tool you're using to generate the explanation?</span>
<span class="comment-copy">@PatrickHaugh Nope, just did it by hand.</span>
<span class="comment-copy">This is pretty neat, allow me some time to review</span>
