<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/4477850/python-and-or-operators-return-value">python and / or operators return value [duplicate]</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>I'm a beginner and this is a relatively simple question but I'm having trouble trying to figure it out. When you type "True or 5" into python, it returns True, and when you type "5 or True" it returns 5. Why is this? Why don't they return the same answer? Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Basically what happens with <code>or</code> is it looks to the left <em>operand</em> and evaluates <code>bool(..)</code> on it. If that returns <code>True</code>, the left operand is returned. Otherwise the right operand is returned.</p>
<p>So</p>
<pre><code>a or b
</code></pre>
<p>Is equivalent with:</p>
<pre><code>if bool(a):
    return a
else:
    return b
</code></pre>
<p>And chaining results in a chain of <code>if</code> statements like:</p>
<pre><code>a or b or c or d
</code></pre>
<p>is equivalent to:</p>
<pre><code>if bool(a):
    return a
elif bool(b):
    return b
elif bool(c):
    return c
else:
    return d
</code></pre>
<p>As you might notice, if you do the math with booleans, you see <code>or</code> indeed behaves as a logical or operator. But it is more advanced in the sense that you can feed it all kinds of values.</p>
<p>For <code>bool(..)</code> the standard builtin <a href="https://docs.python.org/3/library/functions.html#bool" rel="nofollow noreferrer"><code>bool(..)</code></a> is used.</p>
<hr/>
<p>The same holds for <code>and</code> by the way:</p>
<pre><code>a and b
</code></pre>
<p>Is equivalent with:</p>
<pre><code>if not bool(a):
    return a
else:
    return b
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>or</code> operator short-circuits when the first value is truthy (i.e. evaluates to <code>True</code>). When that happens, that first value is returned.</p>
<p>So, <code>True or 5</code> short-circuits on the <code>True</code>, so it returns <code>True</code>. <code>5 or True</code> short-circuits on the <code>5</code> (because 5 is truthy, which is nonzero for integers), so it returns <code>5</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>or</code> returns the first operand that's truthy (or the last operand if they're both falsy). This can be used to check for the validity of data, and default if a value is, say, <code>None</code>.</p>
<pre><code>a = None
b = a or "some default"

b
'some default'
</code></pre>
<p>Especially in languages like JavaScript, this is a common idiom to give a function optional parameters.</p>
</div>
<span class="comment-copy">It returns first element which is true and <code>bool(5)</code> gives <code>True</code> so it returns <code>5</code></span>
<span class="comment-copy">Is the documentation not clear enough?</span>
<span class="comment-copy">If you're referring to if you put that into the IDE, you should probably clarify so.</span>
<span class="comment-copy">short circuit evaluation.</span>
<span class="comment-copy">Crucially: in both cases, the value it returns is truthy, so there's no difference if you do <code>if 5 or True:</code> vs <code>if True or 5:</code>.</span>
<span class="comment-copy">@StefanPochmann: well internally <code>bool(..)</code> <a href="http://stackoverflow.com/questions/8205558/defining-boolness-of-a-class-in-python">calls these functions</a>. So <code>bool(..)</code> is equivalent to your <code>__bool__()</code> in Python3 and guess what, even to <code>__nonzero__()</code> in Python2. This answer however is Python-version invariant and it says <i>equivalent</i>. Evidently things are more complicated under the interpreter hood.</span>
<span class="comment-copy">What do you mean with redefining <code>bool</code>. Yeah indeed if I write somewhere redefine let's say <code>list(..)</code> or <code>all(..)</code>, etc. that will indeed also alter a Python program. Evidently I mean the builtin <a href="https://docs.python.org/3/library/functions.html#bool" rel="nofollow noreferrer"><code>bool(..)</code></a> function.</span>
<span class="comment-copy">Furthermore if you query <code>dir(type([]))</code>, you will see that <b>a list has no <code>__bool__</code> function</b>. In that case <code>bool(..)</code> will query the <code>__len__</code> function and check if it is greater. So in fact <b><code>or</code> does not use <code>__bool__</code> since otherwise it could not work with lists</b>.</span>
<span class="comment-copy">@StefanPochmann: a list evaluates to <code>False</code> if it is empty as do all builtin collections. So <code>[] or [1]</code> will evaluate to <code>[1]</code> because <code>bool([])</code> is <code>False</code>. <a href="https://docs.python.org/3/library/stdtypes.html#truth" rel="nofollow noreferrer">This</a> is the specification for the <i>truth</i> test which is used by <code>and</code> and <code>or</code> as well. Whether they call <code>bool(..)</code> explicitly or hardwire it, is more an interpreter detail I think.</span>
<span class="comment-copy">@StefanPochmann: well since a list does not have a <code>__bool__</code>, but it has a <code>__len__</code> it means that somehow there must be logic in the <code>and</code>/<code>or</code> to check this and call this. If you write a custom class yourself and only implement the <code>__len__</code> that will work as well. So <code>and</code> and <code>or</code> do not directly call <code>__bool__</code> there is some magic that is at least <i>functionally</i> speaking equvalent to the builtin <code>bool(..)</code></span>
<span class="comment-copy">Similarly, if you try to do <code>print("one" and "two")</code> it will always print two, because that is the last value checked.</span>
<span class="comment-copy">There is no <code>null</code> in Python. Only <code>None</code>.</span>
<span class="comment-copy">@WillemVanOnsem Whoops, thanks.</span>
