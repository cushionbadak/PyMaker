<div class="post-text" itemprop="text">
<p>I am trying to segment a list of list into blocks based on the type of data in the sublist's second index (namely <code>NoneType</code> or <code>int</code>).</p>
<p>Example Data:</p>
<pre><code>arr = [
[81, None, None],
[82, None, None],
[83, None, None],
[84, None, None],
[85, 161, 360],
[86, 161, 360],
[87, 161, 360],
[88, 160, 360],
[89, 160, 360],
[90, 160, 360],
[91, 160, 360],
[92, 160, 360],
[93, None, None],
[94, None, None],
[95, None, None],
[96, 153, 359],
[97, 153, 359],
[98, 153, 359],
[99, 153, 359]]
</code></pre>
<p>This can be treated as a list of lists, as I said, or as a numpy array (i.e., <code>numpy.array(arr)</code>). Whichever is easier.</p>
<p>I am trying for something <em>like</em> this (doesn't need to be identical):</p>
<pre><code>[(81, 84, None),                   # or [[None, None], [None, None]...] ... either is fine.
 (85, 93, [[161, 360], [161, 360]]...),
 (93, 95, None),
 (96, 99, [[153, 359], [153, 359]]...)
]
</code></pre>
<p>Sloppy attempt:</p>
<pre><code>none_end = 0
none_start = False
blocks_loc = list()
for i in arr:
    if None in i:
        if not none_start:
            none_start = i[0]
        none_end = i[0]
    elif None not in i and none_start is not False:
        blocks_loc.append((none_start, none_end))
        none_start = False
        none_end = 0
</code></pre>
<p>Then I could simply pull out the data for based on <code>blocks_loc</code> (which now contains <code>[(81, 84, (93, 95)]</code>).</p>
<p>However, it is hard to put into words just how <em>terrible</em> and ugly that code is. Something better would be great.</p>
</div>
<div class="post-text" itemprop="text">
<p>I might use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>from itertools import groupby
groups = (list(g) for k,g in groupby(arr, key=lambda x: x[1]))
final = [(g[0][0], g[-1][0], [x[1:] for x in g]) for g in groups]
</code></pre>
<p>which gives me</p>
<pre><code>&gt;&gt;&gt; pprint.pprint(final)
[(81, 84, [[None, None], [None, None], [None, None], [None, None]]),
 (85, 87, [[161, 360], [161, 360], [161, 360]]),
 (88, 92, [[160, 360], [160, 360], [160, 360], [160, 360], [160, 360]]),
 (93, 95, [[None, None], [None, None], [None, None]]),
 (96, 99, [[153, 359], [153, 359], [153, 359], [153, 359]])]
</code></pre>
<p>.. and I just noticed that I was using <code>x[1]</code> as the index to group on, and you want <code>x[2]</code> instead.  Well, that's left as an exercise for the reader. ;-)</p>
<p>If you wanted finer control over the output (e.g. to handle the case where the start and end indices are the same), it'd be easier just to loop over the key/group pairs returned by <code>groupby</code> and yield whatever you like. </p>
<p>Also note that <code>groupby</code> finds <em>contiguous</em> groups.  If your data is not necessarily contiguous, you could sort first instead.</p>
</div>
<span class="comment-copy">not quite there, your grouping doesn't handle the int data case right, you need to change the groupby key lambda to  <code>key=lambda x: type(x[1])</code></span>
<span class="comment-copy">@f5r5e5d: sure, the OP can pick whatever condition he wants to use as a keyfunc.</span>
<span class="comment-copy">I did end up editing it a little, but it got me very close. Many thanks.</span>
