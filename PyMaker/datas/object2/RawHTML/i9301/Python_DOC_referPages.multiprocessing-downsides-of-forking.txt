<div class="post-text" itemprop="text">
<p>We are experiencing an issue with Python Celery (which uses multiprocessing) where large periodic (scheduled) tasks consume massive amounts of memory for short bursts of time, but because the worker process lives through the life of the pool (<code>MAX_TASKS_PER_CHILD=None</code>), the memory is not garbage collected (ie. it is being "high-water" reserved).</p>
<p>(This problem is further worsened by Heroku, which sees a large, constant amount of memory allocated and turns it into swap, which decreases performance.)</p>
<p>We have found that by setting <code>MAX_TASKS_PER_CHILD=1</code>, we fork a new process (Celery worker instance) after every task, and memory is properly garbage collected. Sweet!</p>
<p>However, there are plenty of articles that suggest the same solution, but I have not identified any downsides.
<strong>What are the potential downsides of forking a new process after every task?</strong></p>
<p>My guesses would be:<br/>
1. CPU overhead (but probably a <em>tiny</em> amount)<br/>
2. Potential errors when forking (but I can't find any documentation on this)</p>
</div>
<div class="post-text" itemprop="text">
<p>Aside from the obvious increase in CPU overhead from repeated forking (not a big deal if the workers do enough work per task), one possible downside would be if the parent process continues to grow in size. If so, it increases the size of all the child processes (which are forking a larger and larger parent). This wouldn't matter so much (presumably little of the memory will be written, and therefore little copying is required and actual memory use won't be a major issue), but IIRC, the Linux overcommit heuristics assume that the COW memory will eventually be copied, and you could invoke the OOM killer even if you're nowhere near <em>actually</em> exceeding the heuristic limit in terms of private pages.</p>
<p>On Python 3.4 and higher, you can avoid this issue by explicitly <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer">setting your <code>multiprocessing</code> start method to <code>forkserver</code></a> on program launch (before doing any work the workers don't rely on), which will fork workers from a separate server process that should not dramatically increase in size.</p>
</div>
