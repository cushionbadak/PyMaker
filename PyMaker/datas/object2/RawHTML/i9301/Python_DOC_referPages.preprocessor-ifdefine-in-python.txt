<div class="post-text" itemprop="text">
<p>How can I do something like in Python?</p>
<pre><code>#if defined(SOMETHING)
  method1(self);
  method2(self);
#elif defined(SOMETHING2)
  method3(self);
  method4(self);
#endif
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python does not contain a preprocessor like the C family of languages. However, as a scripting language, as long as every line makes syntactic sense, you don't need to worry about symbols (functions and all) not being defined. You can also <code>import</code> libraries inside blocks such as those in <code>if</code> statements, and the imported symbols will be available with normal scope rules.</p>
<p>One solution that I have used before is having the different parts in different files, I find it works great:</p>
<pre><code>if name == 'nt':  # Windows
    from .nt import get_free_space_mb
elif name == 'posix':  # Linux and OSX
    from .posix import get_free_space_mb
else:
    getLogger(__name__).fatal('Unknown os! %s', name)
    exit(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Short version: You can't.</p>
<p>At least not without rolling your own script wrapper that executes some sort of home rolled preprocessor. You can do normal runtime tests, and you can define methods conditionally (which is sort of like compile-time definitions), so the same name refers to different functionality depending on top-level configuration, but the closest thing Python has to a compile time preprocessor is <a href="https://docs.python.org/3/library/constants.html#__debug__" rel="nofollow noreferrer">the <code>__debug__</code> special variable</a>.</p>
<p><code>__debug__</code> is processed during bytecode compilation as a constant <code>True</code> or <code>False</code> depending on whether Python in running with "optimizations" turned on (passing <code>-O</code> when invoking Python has only two effects that I know of: making <code>__debug__</code> be <code>False</code>, and removing <code>assert</code> statements).</p>
</div>
<span class="comment-copy">Python is an interpreted language, those options are for a compiled language. There is no equivalent in Python</span>
<span class="comment-copy">Sounds like an <a href="http://meta.stackexchange.com/a/66378/317868">XY problem</a>. What do you want to achieve?</span>
<span class="comment-copy">Why not learn Python instead of trying to tweak C++ code enough that the Python interpreter can understand it?</span>
<span class="comment-copy">Considering that Python has nothing like <code>#define</code>, there's obviously going to be no way to check whether a macro is defined. What are you trying to do?</span>
<span class="comment-copy">You are limited to runtime checks. You should clarify why you want to do this and perhaps someone will be able to suggest an alternative.</span>
<span class="comment-copy">Conditional imports in the middle of a script are frowned upon as poor style.</span>
<span class="comment-copy">@TigerhawkT3 Yep, which is why I do that at the top, right after the unconditional imports. ;)</span>
<span class="comment-copy">what's does it have to do with <code>__debug__</code>? what I want isn't about debugging at all.</span>
<span class="comment-copy">@Jodooomi: <code>__debug__</code> is the only "preprocessor-like" thing Python offers as a built-in feature. It's not really about debugging, it's basically providing a single toggle that can be used to bypass code at compile time. It probably doesn't cover your case, but that's because the whole concept of the preprocessor isn't really a thing in Python.</span>
