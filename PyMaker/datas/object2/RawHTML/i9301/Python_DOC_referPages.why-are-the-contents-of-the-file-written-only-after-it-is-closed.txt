<div class="post-text" itemprop="text">
<p>I noticed that when writing to files in Python, the contents are written to the file once it is closed.</p>
<p>For example:</p>
<pre><code>with open('test.txt','w') as ffile:
    ffile.write("testing")
    time.sleep(20)
</code></pre>
<p>In this example "<em>testing</em>" will be written after waiting 20 seconds.</p>
<p>How and why does this happen? Why not just writing to the file simultaneously?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are seeing the effects of <em>buffering</em>.  Disk I/O uses buffers to improve performance, and you have not written enough data to the buffer for it to flush.</p>
<p>Write more data, or close the file, both cause the buffer to be flushed. Alternatively, set the buffer size to a very small number (the number of bytes the buffer will hold):</p>
<pre><code>with open('test.txt', 'w', 2) as ffile:
</code></pre>
<p>The options <code>0</code> and <code>1</code> have special meaning; <code>0</code> would disable buffering altogether (only available for <em>binary</em> mode files) and <code>1</code> is the default for text files (using <em>line buffering</em>, write a newline to flush).</p>
<p>That also means that if you have a text file, you could write a newline to trigger flush:</p>
<pre><code>ffile.write('\n')
</code></pre>
<p>Last but not least, you could flush explicitly by using the <a href="https://docs.python.org/3/library/io.html#io.IOBase.flush" rel="nofollow noreferrer"><code>file.flush()</code> method</a>:</p>
<pre><code>ffile.flush()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>with open('test.txt','w') as ffile:
    ffile.write("testing")
    ffile.flush() # This forces the buffer to be written to the file.
    time.sleep(20)
</code></pre>
</div>
<span class="comment-copy">please fix your indentation. The question has no sense like it is. buffered output does this.</span>
<span class="comment-copy">In short buffering: writing to a file is expensive (it takes a lot of time), thus the writing is postponed in the hope more content will arrive.</span>
<span class="comment-copy">Sorry, I fixed it.</span>
<span class="comment-copy">There is definately a duplicate for this question..</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/3167494/how-often-does-python-flush-to-a-file">How often does python flush to a file?</a></span>
<span class="comment-copy">Thank you,can you elaborate more on how the performance is improved, or at least link to a source?</span>
<span class="comment-copy">Maybe also explain what <code>2</code> does. The option you are using.</span>
<span class="comment-copy">@Ev.Kounis: set the buffer size to 2 bytes.</span>
<span class="comment-copy">@Ria: see the <a href="https://en.wikipedia.org/wiki/Data_buffer" rel="nofollow noreferrer">general info on data buffers</a>. I/O to a physical medium is <i>slow</i>, but has a large bandwidth. You can move a large amount of data to a file, but it takes a while to get there. You don't want your program to pay that waiting price for each individual write; better to collect data into a larger buffer and move stuff to the file in chunks.</span>
<span class="comment-copy">@MartijnPieters Is that why <code>file.write()</code> does not append a newline by defualt? Because it triggers flushing? And another thing, if one uses <code>print('something', file='my_file')</code> would it flush because <code>print</code> appends a newline?</span>
<span class="comment-copy">syntactically correct, but offers little explanation of why OP observes <i>contents are written to the file once it is closed</i>.   Can you add that to your answer?  (even a comment after the <code>flush</code> statement would be an improvement).</span>
<span class="comment-copy">@ryyker Thanks. Updated my answer.</span>
