<div class="post-text" itemprop="text">
<p>I have a test that passes in Python2 and fails in Python3, I'm trying to find out why. The test fails at the following line:</p>
<pre><code>self._timeseries[0].resource.__dict__
</code></pre>
<p>With the error:</p>
<pre><code>AttributeError: 'Resource' object has no attribute '__dict__'
</code></pre>
<p>If I debug the test, and print the object in the debugger, I can see the following:</p>
<pre><code>(Pdb) p self._timeseries[0].resource.__dict__
OrderedDict([('type', 'type_value'), ('labels', {'label1': 'value1', 'label2': 'value2', 'label3': 'value3'})])
</code></pre>
<p>If I do the same in Python3 debugger, I get this:</p>
<pre><code>(Pdb) p self._timeseries[0].resource.__dict__
*** AttributeError: 'Resource' object has no attribute '__dict__'
</code></pre>
<p>Any ideas why this might be happening? The object looks exactly the same if I print it in the debugger without the <code>.__dict__</code>, why is this failing for Python3?</p>
</div>
<div class="post-text" itemprop="text">
<p>So I found the answer after some digging, this indeed is a difference between Python2 and Python3, a nuisant one at that.</p>
<p>It turns out the type <code>Resource</code> in the code is actually a named tuple. In Python2, <code>.__dict__</code> is added as convenient property wrapper of <code>._asdict()</code>, but this isn't done in Python3:</p>
<p><a href="https://docs.python.org/2/library/collections.html#collections.somenamedtuple._asdict" rel="noreferrer">https://docs.python.org/2/library/collections.html#collections.somenamedtuple._asdict</a> (find <code>__dict__</code> here)
<a href="https://docs.python.org/3/library/collections.html#collections.somenamedtuple._asdict" rel="noreferrer">https://docs.python.org/3/library/collections.html#collections.somenamedtuple._asdict</a></p>
<p>So it looks like <code>._asdict</code> is in fact the source of truth, and should be used for portable 2to3 code.</p>
<p>It's worth mentioning that <code>vars</code> is also a wrapper that exists in Python2 only.</p>
</div>
<div class="post-text" itemprop="text">
<p>I wrote a little function, I'm probably missing a few edge cases but it satisfied the few little testcases I wrote (probably broken for multiple inheritance)</p>
<pre><code>class C(object):
    def __init__(self):
        self.x = 1
        self.y = 1


class D(object):
    __slots__ = ('x', 'y')
    def __init__(self):
        self.x = 1
        self.y = 1


class E(D):
    __slots__ = ()


class F(D):
    __slots__ = ('z',)
    def __init__(self):
        super(F, self).__init__()
        self.z = 1


def vars2(x):
    if hasattr(x, '__dict__'):
        return vars(x)
    else:
        ret = {slot: getattr(x, slot) for slot in x.__slots__}
        for cls in type(x).mro():
            spr = super(cls, x)
            if not hasattr(spr, '__slots__'):
                break
            for slot in spr.__slots__:
                ret[slot] = getattr(x, slot)
        return ret


def main():
    print(vars2(C()))
    print(vars2(D()))
    print(vars2(E()))
    print(vars2(F()))
    OUTPUT = '''\
{'y': 1, 'x': 1}
{'y': 1, 'x': 1}
{'y': 1, 'x': 1}
{'y': 1, 'x': 1, 'z': 1}
'''

if __name__ == '__main__':
    exit(main())
</code></pre>
</div>
<span class="comment-copy">Perhaps whatever library changed this type to a <code>__slots__</code> object in python3?  It's really impossible to know without seeing the class definition and more information.</span>
<span class="comment-copy">Is there a way of getting the dynamically defined properties in that case? Doing <code>.__slots__</code> returns just <code>()</code>.</span>
<span class="comment-copy">This is rather surprising. What is <code>self.timeseries[0].resource</code> exactly supposed to be? When I check the <code>__dict__</code> of an arbitrary object, in both Python 2 and 3, I get an object of <code>dict</code> type, not of <code>OrderedDict</code> type. My guess is, the way you get Python 2 to set to <code>resource</code> a <code>__dict__</code> attribute of <code>OrderedDict</code> type does not work in Python 3.</span>
<span class="comment-copy">@Rightleg You're right, that's interesting. I can't easily find out though, so I guess I'll never know how this ended up being the case.</span>
<span class="comment-copy">Surprising as it may sound, I was playing with named tuples, and I found some weird thing: when you create a named tuple and then instantiate it, that instance's <code>__dict__</code> is an <code>OrderedDict</code>. Could it be that your Python 2 test imports <code>collections</code>, while your Python 3 test forgets to do it?</span>
<span class="comment-copy">Neat!  I didn't know there used to be a <code>__dict__</code> on <code>namedtuple</code>, I'm glad they removed it :).  <code>vars</code> does exist in python3 as well</span>
<span class="comment-copy">I just commented something like that on your original question, just to see that you had already posted this answer. Great minds think alike :)</span>
<span class="comment-copy">Note: <code>vars</code> exists in Py2 and Py3, but it's basically a thin-wrapper that's equivalent to looking up <code>__dict__</code> on the argument given, so when they fixed the bug with <code>namedtuple</code>, it stopped working. User-defined classes that use <code>__slots__</code> throughout the inheritance hierarchy (none of which have a <code>__dict__</code> slot) will always have this problem, since they replace <code>__dict__</code> use with (effectively) a bunch of class level properties that access values stored in the C level object metadata that has no equivalent to <code>__dict__</code>.</span>
<span class="comment-copy">This is great, I do applaud the effort! This should work. However in my case I only needed to call <code>._asdict()</code>, please take a look at my answer below.</span>
