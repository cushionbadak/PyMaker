<div class="post-text" itemprop="text">
<p>I'm trying to create a new list of lists by removing the rows with a duplicated value within existing list of lists. </p>
<pre><code>fir = [['a35',1],['a35',2],['3r',6],['3r',8],[5,9]]
sec = []

for row in fir:
    if sec is None:
        sec.append(row)
    elif row[0] not in sec:
        sec.append(row)

print(sec)
</code></pre>
<p>Expected output:
    [['a35', 1], ['3r', 6], [5, 9]]</p>
<p>Actual output:
    [['a35', 1], ['a35', 2], ['3r', 6], ['3r', 8], [5, 9]]</p>
<p>I want create a list of lists in which the values of row[0] are unique and not duplicated (e.g. the row with 'a35' should be included only once)</p>
<p>How can I achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>you can simply save the unique value (the 1st data in the tuple), you're wrong because you compare the 1st tuple to all the data (comparing 'a35' to ['a35',1])</p>
<pre><code>fir = [['a35',1],['a35',2],['3r',6],['3r',8],[5,9]]
sec = []

index = []
for f in fir:
    if not f[0] in index:
        index.append(f[0])
        sec.append(f)

print(sec)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your current code fails because after the first iteration <code>sec</code> looks like this: <code>[['a35',1]]</code>. On the second iteration <code>row</code> has value of <code>['a35',2]</code> which can't be found from <code>sec</code> thus it gets appended there.</p>
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> to group the inner lists based on the first element. <code>groupby</code> returns iterable of <code>(key, it)</code> tuple where <code>key</code> is value returned by second parameter and <code>it</code> is iterable of elements in within the group:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; fir = [['a35',1],['a35',2],['3r',6],['3r',8],[5,9]]
&gt;&gt;&gt; [next(g) for _, g in groupby(fir, lambda x: x[0])]
[['a35', 1], ['3r', 6], [5, 9]]
</code></pre>
<p>Note that above assumes that lists with the same first element are next to each other in <code>seq</code>. If that's not the case you could sort <code>seq</code> before passing it to <code>groupby</code> but that only works if the first elements can be used as keys. With your data that's not the case since there are strings and ints which can't be compared on Python 3. You could collect the items to <code>OrderedDict</code> though:</p>
<pre><code>from collections import OrderedDict
fir = [['a35',1],['a35',2],['3r',6],['3r',8],[5,9],['a35',7]]

d = OrderedDict()
for x in fir:
    d.setdefault(*x)

print([list(x) for x in d.items()])
</code></pre>
<p>Output:</p>
<pre><code>[['a35', 1], ['3r', 6], [5, 9]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use List Comprehension to achieve this:</p>
<pre><code>sec=[i for i in fir if i[0] not in [fir[idx][0] for idx in xrange(0,fir.index(i))]]
</code></pre>
<p>This selects each item from <code>fir</code> and compare first element of the item with all the item from index <code>0</code> till the index of that item.</p>
<p>As you have only two items in the inner list and you don't want to have duplicates,</p>
<blockquote>
<p>Dictionary would have been the perfect data structure for your case.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I think when you loop the fir, you should add a list for recording which key you have put in the sec. </p>
</div>
<span class="comment-copy">I tried this and it worked!! thanks!!</span>
