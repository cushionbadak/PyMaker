<div class="post-text" itemprop="text">
<p>I have a database of badly formatted database of strings. The data looks like this:</p>
<pre><code>"street"=&gt;"\"\\u4e2d\\u534e\\u8def\""
</code></pre>
<p>when it should be like this:</p>
<pre><code>"street"=&gt;"中华路"
</code></pre>
<p>The problem I have is that when that doubly escaped strings comes from the database they are not being decoded to the chinese characters as they should be. So suppose I have this variable; <code>street="\"\\u4e2d\\u534e\\u8def\""</code> and if I print that <code>print(street)</code> the result is a string of codepoints <code>"\u4e2d\u534e\u8def"</code></p>
<p>What can I do at this point to convert <code>"\u4e2d\u534e\u8def"</code> to actual unicode characters ?</p>
</div>
<div class="post-text" itemprop="text">
<p>First encode this string as <code>utf8</code> and then decode it with <code>unicode-escape</code> which will handle the <code>\\</code> for you:</p>
<pre><code>&gt;&gt;&gt; line = "\"\\u4e2d\\u534e\\u8def\""
&gt;&gt;&gt; line.encode('utf8').decode('unicode-escape')
'"中华路"'
</code></pre>
<p>You can then strip the <code>"</code> if necessary</p>
</div>
<div class="post-text" itemprop="text">
<p>You could remove the quotation marks with <a href="https://docs.python.org/3/library/stdtypes.html#str.strip" rel="nofollow noreferrer"><code>strip</code></a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow noreferrer"><code>split</code></a> at every <code>'\\u'</code>. This would give you the characters as strings representing hex numbers. Then for each string you could convert it to <code>int</code> and back to string with <a href="https://docs.python.org/3.6/library/functions.html#chr" rel="nofollow noreferrer"><code>chr</code></a>:</p>
<pre><code>&gt;&gt;&gt; street = "\"\\u4e2d\\u534e\\u8def\""
&gt;&gt;&gt; ''.join(chr(int(x, 16)) for x in street.strip('"').split('\\u') if x)
'中华路' 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on what you wrote, the database appears to be storing an eval-uable ascii representation of a string with non-unicode chars.</p>
<pre><code>&gt;&gt;&gt; eval("\"\\u4e2d\\u534e\\u8def\"")
'中华路'
</code></pre>
<p>Python has a built-in function for this.</p>
<pre><code>&gt;&gt;&gt; ascii('中华路')
"'\\u4e2d\\u534e\\u8def'"
</code></pre>
<p>The only difference is the use of <code>\"</code> instead of <code>'</code> for the needed internal quote.</p>
</div>
<span class="comment-copy">Do you know how they got there? The answers below seem to be assuming that they're Python string literals (from eg <code>repr</code>) but they could just as well be JSON strings (use <code>json.loads</code>), or some other format that uses <code>\u</code> escapes but potentially has different edge cases. Picking the wrong format may result in more mangling.</span>
<span class="comment-copy">Just use the eval function: <code>eval("\"\\u4e2d\\u534e\\u8def\"")</code> is <code>'中华路'</code>.</span>
<span class="comment-copy">@TerryJanReedy You're absolutely right. I must have been thinking python 2, though I see the <code>python-3.5</code> tag now. This solution should work for either python 2 or 3 though which is nice (if not what OP was asking specifically)</span>
<span class="comment-copy">Just use the eval function: <code>eval("\"\\u4e2d\\u534e\\u8def\"")</code> is <code>'中华路'</code>.</span>
