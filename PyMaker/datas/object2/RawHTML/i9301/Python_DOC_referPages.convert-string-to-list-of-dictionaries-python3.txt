<div class="post-text" itemprop="text">
<p>Using Python 3.5.2, what is the best way to convert a string into a list of dictionaries? </p>
<p>I'm scraping a site, with the following being returned as a list of length 1:</p>
<p>(Formatted for readability) </p>
<pre><code>[
{"variation_id":573,"variation_is_visible":true,"variation_is_active":true,"is_purchasable":true,"display_price":1099,"display_regular_price":1099,"attributes":{"attribute_pa_size":"king"},"image_src":"","image_link":"","image_title":"","image_alt":"","image_caption":"","image_srcset":"","image_sizes":"","price_html":"&lt;span class=\"price\"&gt;&lt;span class=\"woocommerce-Price-amount amount\"&gt;&lt;span class=\"woocommerce-Price-currencySymbol\"&gt;&amp;#82;&lt;\/span&gt;1,099.00&lt;\/span&gt;&lt;\/span&gt;","availability_html":"&lt;p class=\"stock in-stock\"&gt;2 in stock&lt;\/p&gt;","sku":"6006239211693","weight":" kg","dimensions":"","min_qty":1,"max_qty":2,"backorders_allowed":false,"is_in_stock":true,"is_downloadable":false,"is_virtual":false,"is_sold_individually":"no","variation_description":""},

{"variation_id":574,"variation_is_visible":true,"variation_is_active":true,"is_purchasable":true,"display_price":989,"display_regular_price":989,"attributes":{"attribute_pa_size":"queen"},"image_src":"","image_link":"","image_title":"","image_alt":"","image_caption":"","image_srcset":"","image_sizes":"","price_html":"&lt;span class=\"price\"&gt;&lt;span class=\"woocommerce-Price-amount amount\"&gt;&lt;span class=\"woocommerce-Price-currencySymbol\"&gt;&amp;#82;&lt;\/span&gt;989.00&lt;\/span&gt;&lt;\/span&gt;","availability_html":"&lt;p class=\"stock in-stock\"&gt;2 in stock&lt;\/p&gt;","sku":"6006239211686","weight":" kg","dimensions":"","min_qty":1,"max_qty":2,"backorders_allowed":false,"is_in_stock":true,"is_downloadable":false,"is_virtual":false,"is_sold_individually":"no","variation_description":""},

{"variation_id":575,"variation_is_visible":true,"variation_is_active":true,"is_purchasable":true,"display_price":949,"display_regular_price":949,"attributes":{"attribute_pa_size":"double"},"image_src":"","image_link":"","image_title":"","image_alt":"","image_caption":"","image_srcset":"","image_sizes":"","price_html":"&lt;span class=\"price\"&gt;&lt;span class=\"woocommerce-Price-amount amount\"&gt;&lt;span class=\"woocommerce-Price-currencySymbol\"&gt;&amp;#82;&lt;\/span&gt;949.00&lt;\/span&gt;&lt;\/span&gt;","availability_html":"&lt;p class=\"stock in-stock\"&gt;2 in stock&lt;\/p&gt;","sku":"6006239211679","weight":" kg","dimensions":"","min_qty":1,"max_qty":2,"backorders_allowed":false,"is_in_stock":true,"is_downloadable":false,"is_virtual":false,"is_sold_individually":"no","variation_description":""}

]
</code></pre>
<p>I tried converting that to a str, assigning it to 's' and then using  json.loads(s), but that didn't work.</p>
<p>I'd like to have a list object whereby I can access values with something like:</p>
<pre><code>for item in form_data_returned:
    print item['variation_id']  # prints 573  574  575
</code></pre>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import defaultdict

# Set aliases for `true` and `false` in the output so
# we won't get NameError exceptions thrown.
true = True
false = False

raw = [
{"variation_id":573,"variation_is_visible":true,"variation_is_active":true,"is_purchasable":true,"display_price":1099,"display_regular_price":1099,"attributes":{"attribute_pa_size":"king"},"image_src":"","image_link":"","image_title":"","image_alt":"","image_caption":"","image_srcset":"","image_sizes":"","price_html":"&lt;span class=\"price\"&gt;&lt;span class=\"woocommerce-Price-amount amount\"&gt;&lt;span class=\"woocommerce-Price-currencySymbol\"&gt;&amp;#82;&lt;\/span&gt;1,099.00&lt;\/span&gt;&lt;\/span&gt;","availability_html":"&lt;p class=\"stock in-stock\"&gt;2 in stock&lt;\/p&gt;","sku":"6006239211693","weight":" kg","dimensions":"","min_qty":1,"max_qty":2,"backorders_allowed":false,"is_in_stock":true,"is_downloadable":false,"is_virtual":false,"is_sold_individually":"no","variation_description":""},

{"variation_id":574,"variation_is_visible":true,"variation_is_active":true,"is_purchasable":true,"display_price":989,"display_regular_price":989,"attributes":{"attribute_pa_size":"queen"},"image_src":"","image_link":"","image_title":"","image_alt":"","image_caption":"","image_srcset":"","image_sizes":"","price_html":"&lt;span class=\"price\"&gt;&lt;span class=\"woocommerce-Price-amount amount\"&gt;&lt;span class=\"woocommerce-Price-currencySymbol\"&gt;&amp;#82;&lt;\/span&gt;989.00&lt;\/span&gt;&lt;\/span&gt;","availability_html":"&lt;p class=\"stock in-stock\"&gt;2 in stock&lt;\/p&gt;","sku":"6006239211686","weight":" kg","dimensions":"","min_qty":1,"max_qty":2,"backorders_allowed":false,"is_in_stock":true,"is_downloadable":false,"is_virtual":false,"is_sold_individually":"no","variation_description":""},

{"variation_id":575,"variation_is_visible":true,"variation_is_active":true,"is_purchasable":true,"display_price":949,"display_regular_price":949,"attributes":{"attribute_pa_size":"double"},"image_src":"","image_link":"","image_title":"","image_alt":"","image_caption":"","image_srcset":"","image_sizes":"","price_html":"&lt;span class=\"price\"&gt;&lt;span class=\"woocommerce-Price-amount amount\"&gt;&lt;span class=\"woocommerce-Price-currencySymbol\"&gt;&amp;#82;&lt;\/span&gt;949.00&lt;\/span&gt;&lt;\/span&gt;","availability_html":"&lt;p class=\"stock in-stock\"&gt;2 in stock&lt;\/p&gt;","sku":"6006239211679","weight":" kg","dimensions":"","min_qty":1,"max_qty":2,"backorders_allowed":false,"is_in_stock":true,"is_downloadable":false,"is_virtual":false,"is_sold_individually":"no","variation_description":""}

]

# keys being a set ensures that every key occurs only once.
keys = set()

# Initializing form_data_returned as a defaultdict allows
# us to access keys that are not already in form_data_returned.
# For example form_data_returned['weight'].append('kg') would throw
# KeyError exception for an empty form_data_returned had we declared
# it as a normal dict().
form_data_returned = defaultdict(list)

for dictionary in raw:
    keys.update(dictionary.keys())
    for key in keys:
        form_data_returned[key].append(dictionary[key])
</code></pre>
<p>We can now retrieve data by key:</p>
<pre><code>print(form_data_returned['variation_id'])
&gt;&gt;&gt; [573, 574, 575]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/2/library/re.html" rel="nofollow noreferrer">re</a> module to preprocess the string, then use the <a href="https://docs.python.org/2/library/json.html" rel="nofollow noreferrer">json</a> module to parse it into a dictionary.</p>
<p>Assuming you have the data converted to a string, and you are know that certain rules apply to the content*, you can try the following:</p>
<pre><code>str = '...'

escaped = re.sub('(?&lt;=[^,:{}])(\\\")(?=[^,:{}])','\\"',str)

dict = json.loads(escaped)
</code></pre>
<p>The regular expression <code>(?&lt;=[^,:{}])(\\\")(?=[^,:{}])</code> will parse the string and identify all characters <code>"</code> that are not preceded by <code>',' , ':' , '{', '}'</code> or followed by the same, so that the <code>"</code> in the strings in the data can be escaped properly.</p>
<p>*by rules i mean, that you have to know, that the used regular expression finds the correct characters - if the data source can provide that consistency, the code above should work (extend the <code>(?&lt;=[^,:{}])</code> and <code>(?=[^,:{}])</code> parts with the necessary characters to match all data</p>
</div>
<span class="comment-copy"><code>ast.literal_eval(my_str)</code></span>
<span class="comment-copy">@inspectorG4dget I think <code>literal_eval</code> will choke on lowercase <code>true</code></span>
<span class="comment-copy">Can't you just parse this as <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer"><code>json</code></a>? How exactly did that not work? Aha, seems to choke on some escaped <code>\"</code>...</span>
