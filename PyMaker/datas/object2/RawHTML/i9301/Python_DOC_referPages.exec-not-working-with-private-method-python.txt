<div class="post-text" itemprop="text">
<p>I know that most of You stays for that <em>exec</em> shouldn't be used, but I have some problem.</p>
<p>Here is minimal example, which works:</p>
<pre><code>class A:
    def __init__(self):
        exec('self.a = self.funct()')
    def funct(self):
        return 1
    def ret(self):
        return self.a
&gt; obj = A()
&gt; obj.ret()
1
</code></pre>
<p>But, when I do:</p>
<pre><code>class A:
    def __init__(self):
        exec('self.a = self.__funct()')
    def __funct(self):
        return 1
    def ret(self):
        return self.a
&gt; obj = A()
AttributeError: 'A' has no attribute '__funct'
</code></pre>
<p>Does anybody know why is that difference?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__name</code> names are <em>class private</em>; such names are prefixed, at compile time, with another underscore and the class name. The purpose is to protect the names from accidental clashes with names used in subclasses. These names are <em>not</em> meant to be private to outside callers.</p>
<p>Quoting the <a href="https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers" rel="nofollow noreferrer"><em>Reserved classes of identifiers</em> section</a>:</p>
<blockquote>
<p><code>__*</code><br/>
  Class-private names. Names in this category, when used within the context of a class definition, are re-written to use a mangled form to help avoid name clashes between “private” attributes of base and derived classes.</p>
</blockquote>
<p>and the <a href="https://docs.python.org/3/reference/expressions.html#atom-identifiers" rel="nofollow noreferrer"><em>Identifiers (Names)</em> section</a>:</p>
<blockquote>
<p><strong>Private name mangling</strong>: When an identifier that textually occurs in a class definition begins with two or more underscore characters and does not end in two or more underscores, it is considered a private name of that class. Private names are transformed to a longer form before code is generated for them. The transformation inserts the class name, with leading underscores removed and a single underscore inserted, in front of the name. For example, the identifier <code>__spam</code> occurring in a class named <code>Ham</code> will be transformed to <code>_Ham__spam</code>. This transformation is independent of the syntactical context in which the identifier is used.</p>
</blockquote>
<p>What happens in your case is that <code>exec()</code> postpones compilation, effectively compiling that call <em>in isolation</em>. The class context is gone, so no mangling takes place.</p>
<p>As such, you need to apply the automatic prefixing manually:</p>
<pre><code>exec('self.a = self._A__funct()')
</code></pre>
<p>If you are using Python 3, you could use the <code>__class__</code> closure <a href="https://stackoverflow.com/questions/19608134/why-is-python-3-xs-super-magic">normally available for the <code>super()</code> function</a> to access the class name the current method is defined for:</p>
<pre><code>exec('self.a = self._{0.__name__}__funct()'.format(__class__))
</code></pre>
<p>Now, unless you actually plan for your class to be widely subclassed in third-party code that should not have to worry about accidentally clashing with internal implementation details, you should not be using double-underscore names at all. Stick with single-underscore names instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python private methods are "disguised" under a different identifier than the one specified in the code, you can access them like _classname__privateAttribute.</p>
<p>Posting this to be specific:</p>
<pre><code>class A:
    def __init__(self):
        exec('self.a = self._A__funct()')
    def __funct(self):
        print("Hello")
    def ret(self):
        return self.a

obj = A()
</code></pre>
<p>I put the print answer there to detect if it worked, and it did!</p>
</div>
<span class="comment-copy">Note that <code>__</code> names are <b>class</b> private. That's not the same thing as privacy models in other languages.</span>
