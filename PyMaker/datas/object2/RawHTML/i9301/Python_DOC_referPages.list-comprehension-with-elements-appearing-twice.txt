<div class="post-text" itemprop="text">
<p>Suppose I have list </p>
<pre><code>l = ['a', 'c', 'b']
</code></pre>
<p>and what I want is a list where those elements appear twice, one after the other, so</p>
<pre><code>['a', 'a', 'c', 'c', 'b', 'b']
</code></pre>
<p>and I want to do this in the most pythonic way possible.</p>
<p>My half solution is doing something like</p>
<pre><code>[[l[i], l[i]] for i in range(len(l))]
</code></pre>
<p>which yields</p>
<pre><code>[['a', 'a'], ['c', 'c'], ['b', 'b']]
</code></pre>
<p>From here, I'd have to parse (walk) the list to remove the inner lists and obtain a single flat list.</p>
<p>Anyone has a better idea to do this in one go? Obviously things like <code>l * 2</code> wouldn't help as it gives <code>['a', 'c', 'b', 'a', 'c', 'b']</code> and I want the same elements adjacent.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>l_2 = [item for item in l for i in range(n)]
</code></pre>
<p>Link to origin: <a href="https://stackoverflow.com/a/24225106/7384097">Stackoverflow: Repeating elements of a list n times</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Using only <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>, you can do:</p>
<pre><code>[i for j in my_list for i in [j]*2]
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt;&gt;&gt; my_list = ['a', 'c', 'b']
&gt;&gt;&gt; [i for j in my_list for i in [j]*2]
['a', 'a', 'c', 'c', 'b', 'b']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can <code>zip</code> the list against itself, then flatten it in a list comprehension.</p>
<pre><code>&gt;&gt;&gt; [i for j in zip(l,l) for i in j]
['a', 'a', 'c', 'c', 'b', 'b']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>zip</code> function </p>
<pre><code>l = ['a', 'c', 'b']
a = [i for j in zip(l,l) for i in j]
print(a)
</code></pre>
<p>Output </p>
<pre><code>['a', 'a', 'c', 'c', 'b', 'b']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>More general:</p>
<pre><code>def ntimes(iterable, times=2):
    for elt in iterable:
        for _ in range(times):
            yield elt
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a short solution without list comprehension, using the intuitive idea <code>l*2</code>:</p>
<pre><code>sorted(l*2, key=l.index)
#['a', 'a', 'c', 'c', 'b', 'b']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you like functional approaches, you can do this:</p>
<pre class="lang-py prettyprint-override"><code>from itertools import chain, tee

l = ['a', 'c', 'b']
n = 2

list(chain.from_iterable(zip(*tee(l, n))))
</code></pre>
<p>While this might not perform as fast as the other answers, it can easily be used for arbitrary iterables (especially when they are infite or when you don't know when they end) by omitting <code>list()</code>.</p>
<p>(Note that some of the other answers can also be adapted for arbitrary iterables by replacing their list comprehension by a generator expression.)</p>
</div>
<span class="comment-copy">Choosing this as it seems the more elegant one. Note that timing the execution of this gives <code>1000000 loops, best of 3: 1.49 µs per loop</code> as compared to @Yousaf 's answer which gives <code>The slowest run took 5.32 times longer than the fastest. This could mean that an intermediate result is being cached. 1000000 loops, best of 3: 1.12 µs per loop</code></span>
<span class="comment-copy">I reckon to use a longer list for timing. Three elements are so short that the time does not really matter. I also got 'The slowest run took 5.41 times longer than the fastest' for the code above.</span>
