<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_connection" rel="nofollow noreferrer">create_connection</a> function from Python 3's asyncio module takes as it's first parameter a protocol factory. The documentation has the following note:</p>
<blockquote>
<p>Note protocol_factory can be any kind of callable, not necessarily a class. For example, if you want to use a pre-created protocol instance, you can pass lambda: my_protocol.</p>
</blockquote>
<p>So you can pass in an instance using a <code>lambda</code> like so:</p>
<pre><code>create_connection(lambda: Protocol(a, b, c))
</code></pre>
<p>An alternative would be to define <code>__call__</code> to <code>return self</code> such that you could just pass the instance without defining a lambda.</p>
<pre><code>protocol = Protocol(a, b, c)
create_connection(protocol)
</code></pre>
<p>Is there any reason to use a lambda as the documentation suggests over defining <code>__call__</code> on the class?</p>
</div>
<div class="post-text" itemprop="text">
<p>Notice the difference between these two lines:</p>
<pre><code>loop.create_connection(MyProtocol, '127.0.0.1', 8888)    # Option #1
loop.create_connection(MyProtocol(), '127.0.0.1', 8888)  # Option #2
</code></pre>
<p>Here is the echo client example from asyncio docs, modified to work with the Option #1:</p>
<pre><code>class MyEchoClientProtocol(asyncio.Protocol):
    def connection_made(self, transport):
        message = "hello"
        transport.write(message.encode())
        print('Data sent: {!r}'.format(message))

    def data_received(self, data):
        print('Data received: {!r}'.format(data.decode()))

    def connection_lost(self, exc):
        print('The server closed the connection')
        print('Stop the event loop')
        loop.stop()


loop = asyncio.get_event_loop()
coro = loop.create_connection(MyEchoClientProtocol, '127.0.0.1', 8765)
loop.run_until_complete(coro)
loop.run_forever()
loop.close()
</code></pre>
<p>If you choose to use Option #2, you will need to implement <code>MyProtocol.__call__(self)</code> which works on <strong>instances</strong> of <code>MyProtocol</code>.</p>
<p>Although this might work OK for <code>create_connection</code>, since your <code>__call__</code> will be called only once, this does not work well for the <code>protocol_factory</code> parameter of <a href="https://docs.python.org/3/library/asyncio-protocol.html#tcp-echo-server-protocol" rel="nofollow noreferrer"><code>create_server</code></a>:</p>
<pre><code>...
# Each client connection will create a new protocol instance
coro = loop.create_server(EchoServerClientProtocol, '127.0.0.1', 8888)
...
</code></pre>
<p>Here <code>protocol_factory</code> is called multiple times to create new <code>Protocol</code> instances.  Using <code>EchoServerClientProtocol()</code> and defining <code>def __call__(self): return self</code> will reuse only one instance of <code>Protocol</code>!</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Short answer:</strong> </p>
<p>The lambda should be used in preference because it is more readable - it can be understood easily without having to scrutinise the Protocol class code. </p>
<p><strong>Explanation:</strong></p>
<p>BaseEventLoop.create_connection yields from BaseEventLoop._create_connection_transport <a href="https://github.com/python/cpython/blob/ee1a81b77444c6715cbe610e951c655b6adab88b/Lib/asyncio/base_events.py#L816" rel="nofollow noreferrer">ref</a>, which instantiates a protocol object from the Protocol class as follows:</p>
<pre><code>    protocol = protocol_factory()
</code></pre>
<p>We can present the problem in a simplified manner without the event loop code to demonstrate how the Protocol is being instantiated:</p>
<pre><code>class Prococol:
   pass

def create_connection(Protocol):
   protocol = Protocol()

create_connection(Protocol)
</code></pre>
<p>So, "protocol = Protocol()" needs to work with the parameters. This can be by using a lambda: </p>
<pre><code>class Protocol:
  def __init__(self, a):
     self.a = a

def create_connection(Protocol):
  protocol = Protocol()

create_connection(lambda: Protocol(1))
</code></pre>
<p>Or the alternate suggestion that the OP suggested would be making the object a callable:</p>
<pre><code>class Protocol:
  def __init__(self, a):
     self.a = a

  def __call__(self):
     return self

def create_connection(Protocol):
  protocol = Protocol()

create_connection(Protocol(1))
</code></pre>
<p>Functionally both will work, and thus it is a question of what is better practice. I would argue that the lambda approach is better, because looking the final line <code>create_connection(lambda: Protocol(1))</code> makes it clear that we are passing to the create_connection function that returns an object when called, whereas passing an a callable object makes the code less readable - because one needs to scrutinise the Protocol class for ascertain that the instantiated object is also a callable entity.</p>
<p>Udi answer to this question says that using <code>def __call__(self): return self</code>, will not work with <code>create_server</code> (which as an aside is not what the question asked) as it will reuse one instance of an instantiated object. This observation is correct, but what is omitted from that answer is that the callable can easily be adjusted to work with the <code>create_server</code>. For example:</p>
<pre><code>class Protocol:
  def __init__(self, a):
     self.a = a

  def __call__(self):
     return Protocol(self.a)
</code></pre>
<p>The bottom line is using <code>__call__</code> should work as will the lambda approach. The reason why lambda should be used in preference is for readability reasons.</p>
</div>
<span class="comment-copy">Great point about <code>create_server</code>. What about if you subclass <code>Protocol</code> and the server has authentication and you need to pass in credentials for example and not just host and port?</span>
<span class="comment-copy">How about writing a new question about this? :-)</span>
<span class="comment-copy">I believe <code>lambda: MyProtocol(a)</code> is much neater than <code>def __call__(self):  return MyProtocol(self.a)</code></span>
<span class="comment-copy">Yes, we are in agremeent, the lambda is the cleaner approach.</span>
