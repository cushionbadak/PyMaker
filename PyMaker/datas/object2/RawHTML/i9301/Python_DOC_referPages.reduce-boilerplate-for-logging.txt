<div class="post-text" itemprop="text">
<p>I read the docs of structlog: <a href="http://www.structlog.org/en/stable/configuration.html" rel="nofollow noreferrer">Configuration</a></p>
<blockquote>
<p>The goal is to reduce your per-file logging boilerplate to:</p>
<pre><code>from structlog import get_logger
logger = get_logger()
</code></pre>
</blockquote>
<p>Is there a way to even reduce this to <strong>one</strong> import line (without <code>;</code>)?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not possible to perform a call inside of an import statement.</p>
<p>From <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow noreferrer">Python's grammar</a>:</p>
<pre><code>import_stmt: import_name | import_from
import_name: 'import' dotted_as_names
import_from: ('from' (('.' | '...')* dotted_name | ('.' | '...')+)
              'import' ('*' | '(' import_as_names ')' | import_as_names))
import_as_name: NAME ['as' NAME]
dotted_as_name: dotted_name ['as' NAME]
import_as_names: import_as_name (',' import_as_name)* [',']
dotted_as_names: dotted_as_name (',' dotted_as_name)*
dotted_name: NAME ('.' NAME)*
</code></pre>
<p>The grammar does not specify a form for an import statement where a call is possible. In particular, the only form accepting parentheses is <code>'(' import_as_names ')'</code>, where <code>import_as_names</code> is defined as <code>NAME ['as' NAME]</code>, while a call to a function requires the use of <code>parameters</code>.</p>
<p>I recommend a thorough reading of the grammar specification for an in-depth understanding.</p>
<hr/>
<p>However, it is possible to accomplish what you are aiming at in one line. Here are three solutions.</p>
<p>The first one is what you mentioned in your question. The second one was evoked by <a href="https://stackoverflow.com/users/6260170/chris-rands">Chris_Rands</a> in comments (and later on in <a href="https://stackoverflow.com/a/41809015/7051394">an answer</a>). The third one is basically a cheat, that looks like a one-liner from the main file.</p>
<h3>With a semi-colon</h3>
<pre><code>from structlog import get_logger; logger = get_logger()
</code></pre>
<h3>By calling the underlying <a href="https://docs.python.org/3/library/functions.html#__import__" rel="nofollow noreferrer"><code>__import__</code></a> function</h3>
<pre><code>logger = __import__('structlog').get_logger()
</code></pre>
<p>Note that this is <strong>not</strong> an import statement, since it does not match any specified form of the above abstract.</p>
<h3>By using an intermediary file</h3>
<p>interface.py</p>
<pre><code>from structlog import get_logger
logger = get_logger()
</code></pre>
<p>main.py</p>
<pre><code>from interface import logger
</code></pre>
<p>This is more like cheating, but from the point of view of the main file, the import is a single line.</p>
<p>If you pick this method, I strongly recommend to create a fresh file for the <code>interface.py</code>. You could be tempted to add a <code>logger = get_logger()</code> at the end of <code>structlog.py</code>, but you could break the module, the most obvious situation being that some variable called <code>logger</code> already exists.</p>
<hr/>
<p>This said, having your code in two lines is absolutely fine. I understand that one can want to make one-liners as often as possible, since Python is pretty good at it (I won't link my posts about <code>lambda</code> expressions, but you can easily find some examples).</p>
<p>However, <code>get_logger</code> is actually referenced as <code>structlog.get_logger(*args, **kwargs)</code>, which means that it can receive arguments to initialize the logger it returns. The way these are used is documented in <a href="http://www.structlog.org/en/stable/_modules/structlog/_config.html#get_logger" rel="nofollow noreferrer"><code>get_logger</code>'s source</a>.</p>
<p>Now, suppose you have to perform some processing to produce these arguments. Your code will look something like:</p>
<pre><code>from structlog import get_logger

args = initialize_args()
kwargs = initialize_kwargs()

logger = get_logger(args, kwargs)
</code></pre>
<p>Well, you could still make it into a one-liner... But it would become unnecessarily long, and pretty much unreadable.</p>
</div>
<div class="post-text" itemprop="text">
<p>As I mentioned in my comment, to get a one liner, you could use <code>__import__()</code>:</p>
<p><code>logger = __import__('structlog').get_logger()</code></p>
<p>However, as stated in the <a href="https://docs.python.org/3/library/functions.html#__import__">documentation</a>, using <code>__import__()</code> is not generally recommended:</p>
<blockquote>
<p>Direct use of <a href="https://docs.python.org/3/library/functions.html#__import__">__import__()</a> is also
  discouraged in favor of <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module">importlib.import_module()</a>.</p>
</blockquote>
<p><code>importlib.import_module()</code> requires importing itself, adding another line via <code>import importlib</code>, unless you import <code>importlib</code> via <code>__import__()</code>, which seems like a bad idea.</p>
<p>Anyway, you don't need <code>__import__()</code> or <code>importlib.import_module()</code> in your case, which are normally used when you are importing dynamically from a variable that stores the module name as a string. I think you should keep the two lines you have, which are concise and readable in my opinion.</p>
</div>
<div class="post-text" itemprop="text">
<p>As stated by others, there is no clean way to do import and function call on the same line. However, there might be a different approach to this problem.</p>
<p>I assume you want to enforce DRY principle. If this is the case, you can place small file in your code base doing both:</p>
<pre><code># mylog.py
from structlog import get_logger
logger = get_logger() # or any other logic to get a compatible logger
</code></pre>
<p>Now, in all other places you can simply get logger instance directly:</p>
<pre><code>from mylog import logger
</code></pre>
</div>
<span class="comment-copy"><code>logger = __import__('structlog').get_logger()</code> (but not recommended really)</span>
<span class="comment-copy">@Chris_Rands thank you for your comment. I think this is a valid answer. Yes, I see it like you: I would not recommend this.</span>
<span class="comment-copy">You can add <code>logger = get_logger()</code> at the end of structlog.py and then just use <code>from structlog import logger</code> in your script. Quite unconventional but it works.</span>
