<div class="post-text" itemprop="text">
<p>We can (shallow) copy a <code>list</code> by using <code>[:]</code>:</p>
<pre><code>l = [1, 2, 3]
z1 = l[:]
</code></pre>
<p>We can also (shallow) copy it by using <code>[::]</code>:</p>
<pre><code>z2 = l[::]
</code></pre>
<p>and now <code>z1 == z2</code> will be <code>True</code>. I understand how these slices work after reading the answers in <a href="https://stackoverflow.com/questions/509211/explain-pythons-slice-notation">Explain Python's slice notation</a>.</p>
<p>But, my question is, is there any difference between these two internally? Is one more efficient than the other in copying or do they do exactly the same things?</p>
</div>
<div class="post-text" itemprop="text">
<p>Absolutely no difference between them, <em>at least in Python 3</em>. You can check the byte-code produced for each of these using <code>dis.dis</code> if you'd like: </p>
<pre><code>l = [1, 2, 3, 4]
</code></pre>
<p>Byte-code emitted for <code>l[:]</code>:</p>
<pre><code>from dis import dis
dis('l[:]')
  1           0 LOAD_NAME                0 (l)
              3 LOAD_CONST               0 (None)
              6 LOAD_CONST               0 (None)
              9 BUILD_SLICE              2
             12 BINARY_SUBSCR
             13 RETURN_VALUE
</code></pre>
<p>while, byte-code emitted for <code>l[::]</code>:</p>
<pre><code>dis('l[::]')
  1           0 LOAD_NAME                0 (l)
              3 LOAD_CONST               0 (None)
              6 LOAD_CONST               0 (None)
              9 BUILD_SLICE              2
             12 BINARY_SUBSCR
             13 RETURN_VALUE
</code></pre>
<p>as you can see, <em>they're exactly the same</em>. Both load some <code>None</code>'s (the two <code>LOAD_CONSTS</code>'s) for the values of <code>start</code> and <code>stop</code> used for building the slice (<code>BUILD_SLICE</code>) and apply it. <code>None</code>s are the default for these as stated in the docs for <code>slices</code> in the <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="noreferrer">Standard Type hierarchy</a>:</p>
<blockquote>
<p>Special read-only attributes: <code>start</code> is the <code>lower</code> bound; <code>stop</code> is the upper bound; <code>step</code> is the <code>step</code> value; each is <code>None</code> if omitted. These attributes can have any type.</p>
</blockquote>
<p>Use <code>[:]</code>, it's less key-strokes.</p>
<hr/>
<p>It's actually interesting to note that in Python <code>2.x</code> the byte code generated is different and, due to less commands for <code>l[:]</code> it might be <em>slightly</em> more performant:</p>
<pre><code>&gt;&gt;&gt; def foo():
...     l[:]
... 
&gt;&gt;&gt; dis(foo)
  2           0 LOAD_GLOBAL              0 (l)
              3 SLICE+0             
              4 POP_TOP             
              5 LOAD_CONST               0 (None)
              8 RETURN_VALUE 
</code></pre>
<p>While, for <code>l[::]</code>:</p>
<pre><code>&gt;&gt;&gt; def foo2():
...     l[::]
... 
&gt;&gt;&gt; dis(foo2)
  2           0 LOAD_GLOBAL              0 (l)
              3 LOAD_CONST               0 (None)
              6 LOAD_CONST               0 (None)
              9 LOAD_CONST               0 (None)
             12 BUILD_SLICE              3
             15 BINARY_SUBSCR       
             16 POP_TOP             
             17 LOAD_CONST               0 (None)
             20 RETURN_VALUE 
</code></pre>
<p>Even though I haven't timed these (and I won't, the difference should be tiny) it seems that, due to simply less instructions needed, <code>l[:]</code> might be slightly better.</p>
<hr/>
<p>This similarity doesn't of course exist <em>only for lists</em>; it applies to all Sequences in Python:</p>
<pre><code># Note: the Bytecode class exists in Py &gt; 3.4
&gt;&gt;&gt; from dis import Bytecode
&gt;&gt;&gt;
&gt;&gt;&gt; Bytecode('(1, 2, 3)[:]').dis() == Bytecode('(1, 2, 3)[::]').dis() 
True
&gt;&gt;&gt; Bytecode('"string"[:]').dis() == Bytecode('"string"[::]').dis() 
True
</code></pre>
<p>similarly for others.</p>
</div>
<div class="post-text" itemprop="text">
<p>Per the <a href="https://docs.python.org/3/reference/expressions.html#subscriptions" rel="nofollow noreferrer">Python language reference section 6.3.2, Subscriptions</a>, the inner expression for a sequence must evaluate to either an integer or a slice. Both these examples produce the same slice, and are therefore identical. There are also numerous other slices that have the same effect, by explicitly stating defaults (<code>start=0</code>, <code>stop=len(sequence)</code> or more, <code>step=1</code>). </p>
</div>
<span class="comment-copy">It's the first colon that makes it a slice, the second doesn't change anything. You could come up with various other options (<code>[0:]</code>, <code>[::1]</code>, ...) but they do the same thing.</span>
<span class="comment-copy">that question doesn't really answer my question, though, i know what makes slices i was just wandering if a difference exists betwen them</span>
<span class="comment-copy">While this question might be covered by <a href="http://stackoverflow.com/q/509211/674064">stackoverflow.com/q/509211/674064</a>, it is much more specific than <a href="http://stackoverflow.com/q/509211/674064">stackoverflow.com/q/509211/674064</a> and has merit of its own. Thus voting for re-opening.</span>
<span class="comment-copy">From <a href="http://stackoverflow.com/a/13005464/674064">stackoverflow.com/a/13005464/674064</a> I conclude that, no, there probably isn't any difference between <code>l[:]</code> and <code>l[::]</code>. But I'm not completely sure.</span>
