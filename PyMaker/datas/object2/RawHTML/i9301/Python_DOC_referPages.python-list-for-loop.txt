<div class="post-text" itemprop="text">
<p>This is a function that I saw to find the unique items in an array in order, I am new to python but this seemed very elegant.</p>
<pre><code>unique_in_order = lambda l: [z for i, z in enumerate(l) if i == 0 or l[i - 1] != z]
</code></pre>
<p>How does this for loop <em>exactly</em> work.</p>
<pre><code>z for i,z in enumerate(l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate(..)</code></a> is a builtin function that takes as input an iterable object (<code>l</code> here) and generates a sequence of tuples containing the <em>index</em> and the element for each element.</p>
<p>So <code>enumerate([1,4,2,5])</code> emits tuples like <code>(0,1)</code>, <code>(1,4)</code>, <code>(2,2)</code>, <code>(3,5)</code>. If you use a comma-separated list of identifiers in the head of the <code>for</code> loop, the tuple is untupled. So:</p>
<pre><code>for i,z in enumerate([1,4,2,5]):
    pass
</code></pre>
<p>will iterate four times, the first time <code>i</code> will be <code>0</code> and <code>z</code> 1; the next iteration <code>i</code> will be <code>1</code> and <code>z</code> 4; the next iteration <code>i</code> will be <code>2</code> and <code>z</code> 2; the next iteration <code>i</code> will be <code>3</code> and <code>z</code> 5.</p>
<p>Now your statement also contains some <em>list comprehension</em>, the first <code>z</code> in <code>z for i,z in enumerate(l)</code> means it will emit the <code>z</code> values. Notice furthermore that there is condition (the <code>if</code> part), so not all values will be emitted.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should start with concept of <a href="http://www.pythonforbeginners.com/basics/list-comprehensions-in-python" rel="nofollow noreferrer">list comprehensions</a> in python to understand what does this lambda function do. In short it creates list of <code>z</code> elements that meet a condition on right side of statement. 
Another important thing is builtin <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate</a> function that simply emits list of touples consisting of element and it's index.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2.3/whatsnew/section-enumerate.html" rel="nofollow noreferrer">enumerate()</a> helps you to iterate over both the indices and the items of sequences at once.</p>
<p>Here is an example :</p>
<pre><code>&gt;&gt;&gt; l=['a','b','c']
&gt;&gt;&gt; for index,value in enumerate(l):
    print (index,value)

0 a
1 b
2 c
</code></pre>
<p>The solution you've posted is wrong and doesn't return unique elements as it only checks for duplicates on the previous item only (<code>l[i-1]!=z</code>).</p>
<p>To elaborate on what I meant, here is a test run :</p>
<pre><code>&gt;&gt;&gt; unique_in_order = lambda l: [z for i, z in enumerate(l) if i == 0 or l[i - 1] != z]
&gt;&gt;&gt; l=[1,1,123,5,6,123]
&gt;&gt;&gt; unique_in_order(l)
[1, 123, 5, 6, 123]
</code></pre>
<p>You can see that <code>123</code> occurs twice because it was tested only against its previous element <code>6</code>.</p>
<p>Before I provide a simple solution, we need to be clear that we are finding unique items from a list in order or we are trying to get rid of duplicates entirely. </p>
<p>A simple and elegant solution would be to use <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer"><code>list.count</code></a> method. It returns the number of times an item occurs in the list.</p>
<pre><code>&gt;&gt;&gt; l=['a', 'a',2,5,6,'b', 'c', 'd', 'e','e',2,2,6]
&gt;&gt;&gt; [x for x in l if l.count(x)&lt;2]
[5, 'b', 'c', 'd']
</code></pre>
<p>If you did not meant to discard the duplicates entirely and instead wanted the list to have a single occurence of the duplicate items then you can do this :</p>
<pre><code>&gt;&gt;&gt; l=['a', 'a',2,5,6,'b', 'c', 'd', 'e','e',2,2,6]
&gt;&gt;&gt; dups=set()
&gt;&gt;&gt; [x for x in l if x not in dups and (dups.add(x) or True)]
['a', 2, 5, 6, 'b', 'c', 'd', 'e']
</code></pre>
</div>
<span class="comment-copy">TBH, that is not an elegant way to find unique items.</span>
<span class="comment-copy">FYI, <code>foo = lambda x: ...</code> is not considered a good idea in Python. Use <code>def foo(x): return ...</code> instead</span>
<span class="comment-copy">and it doesn't look as if it is returning the unique items. It returns <code>z</code> if the element before it is not <code>z</code>. <code>l</code> has to be ordered for that to work.</span>
<span class="comment-copy">elegance also means simple. This isn't simple. If you are new to python you should stay away from this sort of syntax.</span>
