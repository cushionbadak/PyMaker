<div class="post-text" itemprop="text">
<p>I have several functions that use tempfile.mkstemp() to create and use temporary files that stay on disk after the function has been called. Each of them repeats the same scaffolding code to clean up the file descriptor when the function exits. For example:</p>
<pre><code>import tempfile
import zipfile
import os

def write_zip(test_name: str) -&gt; str:
    """
    Given a test name, returns an archive (ZIP) of the files in that test.
    """

    try:
        fd, zip_path = tempfile.mkstemp(suffix='.zip')

        with zipfile.ZipFile(zip_path, 'w') as zf:
            for fpath in _list_files(test_name):  # _list_files() not shown
                zf.write(fpath, arcname=os.path.basename(fpath))
    finally:
        try:
            os.close(locals()['fd'])
        except KeyError:
            pass

    return zip_path
</code></pre>
<p>I'd like to pull this try-finally scaffolding out to a decorator. I tried writing one, but I'm a bit lost and it isn't working:</p>
<pre><code>def _persistent_temp_file(func):
    """
    Decorator for a function that uses a temporary file that should persist on disk after the function has exited.
    Closes the file descriptor in a try-finally block so the function doesn't have to. 
    """

    def scaffolding(suffix=None, prefix=None, dir=None, text=False):
        try:
            fd, temp_file = tempfile.mkstemp(suffix=suffix, prefix=prefix, dir=dir, text=text)
            func(temp_file)

        finally:
            try:
                os.close(locals()['fd'])
            except KeyError:
                pass

    return scaffolding


@_persistent_temp_file
def write_zip(test_name: str) -&gt; str:
    with zipfile.ZipFile(zip_path, 'w') as zf:
        for fpath in _list_files(test_name):  # _list_files() not shown
            zf.write(fpath, arcname=os.path.basename(fpath))

    return zip_path
</code></pre>
<p>I'm unsure of how to pass the <code>zip_file</code> parameter to this function (or any other decorated function). I'm not sure I know how to pass in the parameters needed by mkstemp(), either. (i.e. How do I specify the file suffix when calling the decorated function?)</p>
</div>
<div class="post-text" itemprop="text">
<p>Rather than use a decorator, you'd want to create a <a href="https://docs.python.org/3/library/stdtypes.html#typecontextmanager" rel="nofollow noreferrer"><em>context manager</em></a>. A context manager is told when a block of code (the context) exits, so you can clean up after yourself at that point.</p>
<p>Ironically, there is a decorator that makes it easy to write a context manager, called <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" rel="nofollow noreferrer"><code>@contextlib.contextmanager</code></a>:</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def _persistent_temp_file(suffix=None, prefix=None, dir=None, text=False):
    fd = None
    try:
        fd, temp_file = tempfile.mkstemp(suffix=suffix, prefix=prefix, dir=dir, text=text)
        yield temp_file
    finally:
        if fd is not None:
            os.close(fd)
</code></pre>
<p>Note the <code>yield temp_file</code> line; that's the point at which this function is paused, and the <code>temp_file</code> value is then returned from the resulting context manager <code>__enter__</code> method, and becomes available to the <code>as</code> clause.</p>
<p>Then use this in a <code>with</code> statement:</p>
<pre><code>def write_zip(test_name: str) -&gt; str:
    with _persistent_temp_file() as zip_path:
        with zipfile.ZipFile(zip_path, 'w') as zf:
            for fpath in _list_files(test_name):  # _list_files() not shown
                zf.write(fpath, arcname=os.path.basename(fpath))
    return zip_path
</code></pre>
<p>Not that you need to re-invent the persistent-temp-file wheel here. You could just use the <code>tempfile.NamedTempFile()</code> object here instead:</p>
<pre><code>from tempfile import NamedTempFile

def write_zip(test_name: str) -&gt; str:
    with NamedTempFile(delete=False) as temp_file:
        with zipfile.ZipFile(temp_file, 'w') as zf:
            for fpath in _list_files(test_name):  # _list_files() not shown
                zf.write(fpath, arcname=os.path.basename(fpath))
    return temp_file.name
</code></pre>
</div>
<span class="comment-copy"><code>try: locals['varname'] except KeyError:</code> is a <i>really ugly pattern</i>. I'd not use that. Just create <code>varname = None</code> at the top, or use a context manager.</span>
<span class="comment-copy"><code>NamedTempFile(delete=False)</code> Oh...of course. Still, I appreciate the tutorial on writing a context manager instead of a decorator!</span>
