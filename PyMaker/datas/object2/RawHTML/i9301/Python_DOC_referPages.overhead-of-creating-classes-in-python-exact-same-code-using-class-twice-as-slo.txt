<div class="post-text" itemprop="text">
<p>I created a Stack class as an exercise in Python, using all list functions. For example, Stack.push() is just list.append(), Stack.pop() is list.pop() and Stack.isEmpty() is just list == [ ].</p>
<p>I was using my Stack class to implement a decimal to binary converter, and what I noticed is that even though the two functions are completely equivalent beyond the wrapping of my Stack class for push(), pop() and isEmpty(), the implementation using the Stack class is twice as slow as the implementation using Python's list.</p>
<p>Is that because there's always an inherent overhead to using classes in Python? And if so, where does the overhead come from technically speaking ("under the hood")? Finally, if the overhead is so significant, isn't it better not to use classes unless you absolutely have to?</p>
<pre><code>def dectobin1(num):
    s = Stack()
    while num &gt; 0:
        s.push(num % 2)
        num = num // 2
    binnum = ''
    while not s.isEmpty():
        binnum = binnum + str(s.pop())
    return binnum

def dectobin2(num):
    l = []
    while num &gt; 0:
        l.append(num % 2)
        num = num // 2
    binnum = ''
    while not l == []:
        binnum = binnum + str(l.pop())
    return binnum


t1 = Timer('dectobin1(255)', 'from __main__ import dectobin1')
print(t1.timeit(number = 1000))

0.0211110115051

t2 = Timer('dectobin2(255)', 'from __main__ import dectobin2')
print(t2.timeit(number = 1000))

0.0094211101532
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First off, a warning: Function calls are rarely what limits you in speed. This is often an unnecessary micro-optimisation. Only do that, if it is what actually limits your performance. Do some good profiling before and have a look if there might be a better way to optimise.</p>
<p><strong>Make sure you don't sacrifice legibility for this tiny performance tweak!</strong></p>
<p>Classes in Python are a little bit of a hack.</p>
<p>The way it works is that each object has a <code>__dict__</code> field (a dict) which contains all attributes the object contains. Also each object has a <code>__class__</code> object which again contains a <code>__dict__</code> field (again a dict) which contains all class attributes.</p>
<p>So for example have a look at this:</p>
<pre><code>&gt;&gt;&gt; class X(): # I know this is an old-style class declaration, but this causes far less clutter for this demonstration
...     def y(self):
...             pass
...
&gt;&gt;&gt; x = X()
&gt;&gt;&gt; x.__class__.__dict__
{'y': &lt;function y at 0x6ffffe29938&gt;, '__module__': '__main__', '__doc__': None}
</code></pre>
<p>If you define a function dynamically (so not in the class declaration but after the object creation) the function does not go to the <code>x.__class__.__dict__</code> but instead to <code>x.__dict__</code>.</p>
<p>Also there are two dicts that hold all variables accessible from the current function. There is <code>globals()</code> and <code>locals()</code> which include all global and local variables.</p>
<p>So now let's say, you have an object <code>x</code> of class <code>X</code> with functions <code>y</code> and <code>z</code> that was declared in the class declaration and a second function <code>z</code>, which was defined dynamically. Let's say object <code>x</code> is defined in global space.
Also, for comparison, there are two functions <code>flocal()</code>, which was defined in local space and <code>fglobal()</code>, which was defined in global space.</p>
<p>Now I will show what happens if you call each of these functions:</p>
<pre><code>flocal():
    locals()["flocal"]()

fglobal():
    locals()["fglobal"] -&gt; not found
    globals()["fglobal"]()

x.y():
    locals()["x"] -&gt; not found
    globals()["x"].__dict__["y"] -&gt; not found, because y is in class space
                  .__class__.__dict__["y"]()

x.z():
    locals()["x"] -&gt; not found
    globals()["x"].__dict__["z"]() -&gt; found in object dict, ignoring z() in class space
</code></pre>
<p>So as you see, class space methods take a lot more time to lookup, object space methods are slow as well. The fastest option is a local function.</p>
<p>But you can get around that without sacrificing classes. Lets say, x.y() is called quite a lot and needs to be optimised.</p>
<pre><code>class X():
    def y(self):
        pass

x = X()
for i in range(100000):
    x.y() # slow

y = x.y # move the function lookup outside of loop
for i in range(100000):
    y() # faster
</code></pre>
<p>Similar things happen with member variables of objects. They are also slower than local variables. The effect also adds up, if you call a function or use a member variable that is in an object that is a member variable of a different object. So for example</p>
<pre><code>a.b.c.d.e.f()
</code></pre>
<p>would be a fair bit slower as each dot needs another dictionary lookup.</p>
<p>An official Python performance guide reccomends to avoid dots in performance critical parts of the code:
<a href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips" rel="noreferrer">https://wiki.python.org/moin/PythonSpeed/PerformanceTips</a></p>
</div>
<div class="post-text" itemprop="text">
<p>There is an inherent overhead using <em>functions</em> (where methods on an instance are just wrappers around functions to pass in <code>self</code>).</p>
<p>A function call requires the current function information (a <em>frame</em>) to be stored on a stack (the Python call stack), and a new frame to be created for the function being called. That all takes time and memory:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; def f(): pass
...
&gt;&gt;&gt; timeit(f, number=10**7)
0.8021022859902587
</code></pre>
<p>There is also a (smaller) cost of looking up the attribute (methods are attributes too), and creating the method object (each attribute lookup for a method name causes a new method object to be created):</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     bar = None
...     def baz(self): pass
...
&gt;&gt;&gt; timeit('instance.bar', 'from __main__ import Foo; instance = Foo()', number=10**7)
0.238075322995428
&gt;&gt;&gt; timeit('instance.baz', 'from __main__ import Foo; instance = Foo()', number=10**7)
0.3402297169959638
</code></pre>
<p>So the sum cost of attribute lookup, method object creation and call stack operations add up to the extra time requirements you observed.</p>
</div>
<span class="comment-copy">Thank you so much for taking the time to write this explanation, it clarified a lot of things for me. Can the last optimization example you gave ever work when a function takes arguments? For ex a function of your class takes 2 arguments, can you ever pass the function call to a variable similarly to the way you do y = x.y()? I tried doing that but I get an error message asking me to pass in the arguments.</span>
<span class="comment-copy">I am sorry, I had a typo in there. The function rebind should have been <code>y = x.y</code>, so without the brackets. This also works for methods that take parameters.</span>
<span class="comment-copy">Thank you, this is very helpful. EDIT: I just edited my comment; turns out it was an exception in timing (twice in a row).</span>
<span class="comment-copy">Thank you for your answer, I didn't know methods were a subset (I think that's what you're saying) of attributes. Would you have a recommendation for learning more about the system aspect of function behavior and the such in Python? I unfortunately don't have time right now to go through an entire systems programming book, but I'd really like to at least start to get some sense for what's happening with memory allocation, function frames, the python call stack etc...</span>
<span class="comment-copy">@jeremyradcliff: Function objects are <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>, so reading about those might be a good start (<code>property</code> objects and <code>classmethod</code> and <code>staticmethod</code> objects make use of the same protocol).</span>
<span class="comment-copy">That looks perfect, thank you.</span>
<span class="comment-copy">@jeremyradcliff: other than that, start with looking at Python bytecode disassemblies (the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code> module</a>), then look at the <a href="https://hg.python.org/cpython/file/3.6/Python/ceval.c" rel="nofollow noreferrer">interpreter loop</a> to see what actually happens for each bytecode.</span>
<span class="comment-copy">This is great, thanks again. I haven't been this excited to dive into something in a long time.</span>
