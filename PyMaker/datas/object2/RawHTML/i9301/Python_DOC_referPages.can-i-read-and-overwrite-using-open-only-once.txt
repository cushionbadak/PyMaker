<div class="post-text" itemprop="text">
<p>There are 1000 over html files.</p>
<p>I want to do:</p>
<ul>
<li>read file.</li>
<li>trim the specific line.</li>
<li>over write the file (not appending).</li>
</ul>
<p>following code worked. but I thought using 'open' twice was wasteful. Can I write more simply?</p>
<pre><code>for file_path in glob.glob(os.path.join(dir, '*.html')):
    with open(file_path, "r", encoding="utf-8") as reader:
        html_ = reader.read()
        replaced = html_.replace("&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;", "")
        with open(file_path, "w", encoding="utf-8") as writer:
            writer.write(replaced)
</code></pre>
<p>I tried:</p>
<ul>
<li><code>'r+'</code>: this is addition.</li>
<li><code>'w+'</code>: <code>read()</code> method returned <code>''</code>.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Yes, open the file in <code>'r+'</code> mode, and 'rewind' (<a href="https://docs.python.org/3/library/io.html#io.IOBase.seek" rel="nofollow noreferrer">seek</a> back to start) after reading:</p>
<pre><code>with open(file_path, "r+", encoding="utf-8") as f:
    html_ = f.read()
    f.seek(0)
    replaced = html_.replace("&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;", "")
    f.write(replaced)
    f.truncate()
</code></pre>
<p>I added a <a href="https://docs.python.org/3/library/io.html#io.IOBase.truncate" rel="nofollow noreferrer"><code>file.truncate()</code></a> call as well, because you are removing data from the file. Without that call, you would not replace <em>all</em> data in the file, you'd still have <code>len(removed_data)</code> bytes at the end.</p>
<p>Your attempts failed because you did not seek back to the start when using <code>'r+'</code> (so writing started at the point where reading stopped, i.e. the end of the file), and <code>'w+'</code> truncates the file <em>first</em> (so sets the length to 0, dropping the contents).</p>
<p>The alternative would be to use the <a href="https://docs.python.org/3/library/fileinput.html" rel="nofollow noreferrer"><code>fileinput</code> module</a>; it lets you replace file contents in-place with a somewhat simpler approach:</p>
<pre><code>import fileinput

with fileinput.input(file_path, inplace=True, openhook=fileinput.hook_encoded("utf-8")) as f:
    html_ = f.read()
    replaced = html_.replace("&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;", "")
    print(replaced, end='')
</code></pre>
<p>With <code>inplace=True</code>, the old file is moved aside to a <code>&lt;filename&gt;.bak</code> backup for you, and printing directs output to a new file opened in the original location.</p>
</div>
<span class="comment-copy">Regarding efficiency, wouldn't it better to use <code>FileInput</code> and change it in place?</span>
<span class="comment-copy">@JimFasarakis-Hilliard: <code>FileInput</code> would create a separate file and move it over the old location. That's not necessarily more efficient.</span>
<span class="comment-copy">Thank you. I see. I understood that when I call read(), the pointer progress. And when I call write(), writer start to write from that point. Thank you very much for your understandable explanations. I call truncate() also.</span>
<span class="comment-copy">@JimFasarakis-Hilliard: the biggest issue with the <code>fileinput</code> module is how obfuscated the open procedure is, which makes specifying an encoding and error handler much harder than it needs to be. Try opening a file object in an encoding other than <code>locale.getpreferredencoding()</code> (which almost always is <i>wrong</i> on Windows, often wrong on others). I <a href="http://www.zopatista.com/python/2013/11/26/inplace-file-rewriting/" rel="nofollow noreferrer">wrote a replacement implementation</a> once.</span>
<span class="comment-copy">@JimFasarakis-Hilliard: the module does have a helper function <a href="https://docs.python.org/3/library/fileinput.html#fileinput.hook_encoded" rel="nofollow noreferrer"><code>fileinput.hook_encoded()</code></a>, and but only as of Python 3.6 can you specify an error handler without having to write your own hook.</span>
