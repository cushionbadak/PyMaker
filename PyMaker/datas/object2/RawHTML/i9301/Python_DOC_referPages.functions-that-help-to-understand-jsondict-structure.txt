<div class="post-text" itemprop="text">
<p>I haven't found is there a way to do this.
Let's say I recieve a JSON object like this:</p>
<pre><code>{'1_data':{'4_data':[{'5_data':'hooray'}, {'3_data':'hooray2'}], '2_data':[]}}
</code></pre>
<p>It's hard to instantly say, how should I get value from <strong>3_data key</strong>: <code>data['1_data']['4_data'][1]['3_data']</code></p>
<p>I know about <code>pprint</code>, it helps to understand structure a bit.
But sometimes data is huge, and it takes time</p>
<p>Are there any methods that may help me with that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here are a family of recursive generators that can be used to search through an object composed of dicts and lists. <code>find_key</code> yields a tuple containing a list of the dictionary keys and list indices that lead to the key that you pass in; the tuple also contains the value associated with that key. Because it's a generator it will find all matching keys if the object contains multiple matching keys, if desired.</p>
<pre><code>def find_key(obj, key):
    if isinstance(obj, dict):
        yield from iter_dict(obj, key, [])
    elif isinstance(obj, list):
        yield from iter_list(obj, key, [])

def iter_dict(d, key, indices):
    for k, v in d.items():
        if k == key:
            yield indices + [k], v
        if isinstance(v, dict):
            yield from iter_dict(v, key, indices + [k])
        elif isinstance(v, list):
            yield from iter_list(v, key, indices + [k])

def iter_list(seq, key, indices):
    for k, v in enumerate(seq):
        if isinstance(v, dict):
            yield from iter_dict(v, key, indices + [k])
        elif isinstance(v, list):
            yield from iter_list(v, key, indices + [k])

# test

data = {
    '1_data': {
        '4_data': [
            {'5_data': 'hooray'},
            {'3_data': 'hooray2'}
        ], 
        '2_data': []
    }
}

for t in find_key(data, '3_data'):
    print(t)
</code></pre>
<p><strong>output</strong></p>
<pre><code>(['1_data', '4_data', 1, '3_data'], 'hooray2')
</code></pre>
<hr/>
<p>To get a single key list you can pass <code>find_key</code> to the <code>next</code> function. And if you want to use a key list to fetch the associated value you can use a simple <code>for</code> loop.</p>
<pre><code>seq, val = next(find_key(data, '3_data'))
print('seq:', seq, 'val:', val)

obj = data
for k in seq:
    obj = obj[k]
print('obj:', obj, obj == val)
</code></pre>
<p><strong>output</strong></p>
<pre><code>seq: ['1_data', '4_data', 1, '3_data'] val: hooray2
obj: hooray2 True
</code></pre>
<p>If the key may be missing, then give <code>next</code> an appropriate default tuple. Eg:</p>
<pre><code>seq, val = next(find_key(data, '6_data'), ([], None))
print('seq:', seq, 'val:', val)
if seq:
    obj = data
    for k in seq:
        obj = obj[k]
    print('obj:', obj, obj == val)
</code></pre>
<p><strong>output</strong></p>
<pre><code>seq: [] val: None
</code></pre>
<hr/>
<p>Note that this code is for Python 3. To run it on Python 2 you need to replace all the <code>yield from</code> statements, eg replace</p>
<pre><code>yield from iter_dict(obj, key, [])
</code></pre>
<p>with</p>
<pre><code>for u in iter_dict(obj, key, []):
    yield u
</code></pre>
<hr/>
<h3>How it works</h3>
<p>To understand how this code works you need to be familiar with <a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29" rel="nofollow noreferrer">recursion</a> and with Python <a href="https://docs.python.org/3/tutorial/classes.html#generators" rel="nofollow noreferrer">generators</a>. You may also find this page helpful: <a href="https://stackoverflow.com/q/1756096/4014959">Understanding Generators in Python</a>; there are also various Python generators tutorials available online.</p>
<p>The Python object returned by <code>json.load</code> or <code>json.loads</code> is generally a dict, but it can also be a list. We pass that object to the <code>find_key</code> generator as the <code>obj</code> arg, along with the <code>key</code> string that we want to locate. <code>find_key</code> then calls either <code>iter_dict</code> or <code>iter_list</code>, as appropriate, passing them the object, the key, and an empty list <code>indices</code>, which is used to collect the dict keys and list indices that lead to the key we want.</p>
<p><code>iter_dict</code> iterates over each (k, v) pair at the top level of its <code>d</code> dict arg. If <code>k</code> matches the key we're looking for then the current <code>indices</code> list is yielded with <code>k</code> appended to it, along with the associated value. Because <code>iter_dict</code> is recursive the yielded (indices list, value) pairs get passed up to the previous level of recursion, eventually making their way up to <code>find_key</code> and then to the code that called <code>find_key</code>. Note that this is the "base case" of our recursion: it's the part of the code that determines whether this recursion path leads to the key we want. If a recursion path never finds a key matching the key we're looking for then that recursion path won't add anything to <code>indices</code> and it will terminate without yielding anything.</p>
<p>If the current <code>v</code> is a dict, then we need to examine all the (key, value) pairs it contains. We do that by making a recursive call to <code>iter_dict</code>, passing that <code>v</code> is its starting object and the current <code>indices</code> list. If the current <code>v</code> is a list we instead call <code>iter_list</code>, passing it the same args.</p>
<p><code>iter_list</code> works similarly to <code>iter_dict</code> except that a list doesn't have any keys, it only contains values, so we don't perform the <code>k == key</code> test, we just recurse into any dicts or lists that the original list contains.</p>
<p>The end result of this process is that when we iterate over <code>find_key</code> we get pairs of (indices, value) where each <code>indices</code> list is the sequence of dict keys and list indices that succesfully terminate in a dict item with our desired key, and <code>value</code> is the value associated with that particular key.</p>
<p>If you'd like to see some other examples of this code in use please see <a href="https://stackoverflow.com/a/46701223/4014959">how to modify the key of a nested Json</a> and <a href="https://stackoverflow.com/a/47075972/4014959">How can I select deeply nested key:values from dictionary in python</a>. </p>
<p>Also take  look at my new, more streamlined <a href="https://stackoverflow.com/a/52414034/4014959"><code>show_indices</code></a> function.</p>
</div>
<span class="comment-copy">what if the key is present in several sub-dictionaries / while traversing the dicts? where to stop? You'd like to flatten your dict maybe.</span>
<span class="comment-copy">how do you get the json? Is it a file? Then e.g. a tool like <a href="https://stedolan.github.io/jq/" rel="nofollow noreferrer">jk</a> might good to get a first understanding of the file</span>
<span class="comment-copy">you have Python so use it and write some function to find key in structure.</span>
<span class="comment-copy">Thank you for the recursion function.I way able to execute find_key() but I get "TypeError: Can't convert 'list' object to str implicitly" in the yield from line in iter_dict(), trying to print the dictionary. Any solution?</span>
<span class="comment-copy">@Kaleab I need to see the code (with some data) that's causing the problem. So add it to <a href="https://stackoverflow.com/questions/47037281/how-can-i-select-deeply-nested-keyvalues-from-dictionary-in-python">your question</a> and I'll take a look at it shortly.</span>
<span class="comment-copy">Too bad I can't give you more than one up-vote. That was an excellent explanation and exactly what I was looking for. Thanks.</span>
<span class="comment-copy">I'm glad it helped you @ColinWu</span>
