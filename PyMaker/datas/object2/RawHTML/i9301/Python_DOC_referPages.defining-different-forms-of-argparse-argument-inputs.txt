<div class="post-text" itemprop="text">
<p>I have just started out in using <code>argparse</code>, my code works but I am trying to parse in different values as to how the user types in the argument.</p>
<p>Currently this is my code:</p>
<pre><code>def setup_args():
    """
    Set up args for the tool
    """
    parser = argparse.ArgumentParser(
        description=("Get all file versions of a status in a project"),
        formatter_class=argparse.RawDescriptionHelpFormatter)

    # Positional Arguments
    parser.add_argument('project',
                        type=str,
                        help='Name of the to look into')

    parser.add_argument('status',
                        type=str,
                        help='Define which status to look into')

    # Optional Arguments
    parser.add_argument('-o',
                        '--output',
                        action='store_true',
                        help='Write to output to text file if used')

if __name__ == "__main__":
    args = setup_args()

    # Check the status set
    status_list = ['Pending', 'Work in Progress', 'Approved', 'Rejected']
    if not args.status in site_list:
        raise ValueError("Please input one of the status : 'Pending', 'Work in Progress', 'Approved', 'Rejected'")

    output_query(args.project, status, args.client, args.output)
</code></pre>
<p>As you can see in my <code>main</code>.. It only register those case-sensitive status names that I have defined.
Are there any ways in which I can also make my code to register if they are typed in small caps - <code>'pending', 'work in progress', 'approved', 'rejected'</code> or in short forms - <code>'p', 'wip', 'a', 'r'</code>?</p>
<p>One of the way I can implement is using <code>if..elif..</code></p>
<pre><code>if args.client == ('pending' or 'p'):
    args.client = 'Pending'
elif args.client == ('work in progress' or 'wip'):
    args.client = 'Work in Progress'
elif args.client == ('approved' or 'a'):
    args.client = 'Approved'
elif args.client == ('rejected' or 'r'):
    args.client = 'Rejected'
</code></pre>
<p>Though it works, it looks a bit 'long-winded' to me. If I have multiple arguments, this would means I will need to put in a lot of <code>if...elif...</code> which may not be practical unless this is the only way.
Is there a better solution to get around this?</p>
<p>EDIT:</p>
<p>This is how I have been running my command : <code>python prog.py my_project Pending</code>
but I am thinking of scenarios where one could type it this way : <code>python prog.py my_project pending</code> or <code>python prog.py my_project p</code>, notice that the caps P has become small letter..</p>
</div>
<div class="post-text" itemprop="text">
<p>You could generalize the <code>status</code> check with <code>.lower()</code> and restricting the number of characters that you check.  </p>
<p>For example, if I define an abbreviated list of 'choices', I can test anything that looks like the big names with:</p>
<pre><code>In [239]: choices = ['pend', 'work', 'appr','reje']
In [240]: status_list = ['Pending', 'Work in Progress', 'Approved', 'Rejected']
In [241]: for wd in status_list:
     ...:     if wd.lower()[:4] in choices:
     ...:         print(wd)
     ...:         
Pending
Work in Progress
Approved
Rejected
</code></pre>
<p>You probably shouldn't expect your user to enter the full 'Work in Progress' string.  To do so would require quoting.  Otherwise the shell will break that into 3 strings.</p>
<p>A variation on this test uses <code>startswith</code>:</p>
<pre><code>for wd in status_list:
     if any([wd.lower().startswith(n) for n in choices]):
         print(wd)
</code></pre>
<p>You could also let the parser do value checking</p>
<pre><code>parser.add_argument('status',
                    # type=str,   # default, don't need to add it
                    choices = ['pending', 'work', 'approved', 'rejected'],
                    help='Define which status to look into')
</code></pre>
<p>That generates a nice error message if the string doesn't match.  And it incorporates the choices into the help.  Try it and see what happens.</p>
<p>The disadvantage is that it doesn't allow abbreviations or upper/lower case.  (A custom <code>type</code> function can get around those restrictions, but that's a more advanced technique).</p>
<p>==================</p>
<p>A way to use <code>type</code> is to define a little function:</p>
<pre><code>def abrev(astr):
    return astr.lower()[:4]
</code></pre>
<p>which works in the above test:</p>
<pre><code>for wd in status_list:
    if abrev(wd) in choices:
        print(wd)
</code></pre>
<p>In a parser it can be used as:</p>
<pre><code>In [253]: p = argparse.ArgumentParser()
In [254]: p.add_argument('status', type=abrev, choices=choices);

In [255]: p.print_help()
usage: ipython3 [-h] {pend,work,appr,reje}

positional arguments:
  {pend,work,appr,reje}

optional arguments:
  -h, --help            show this help message and exit
</code></pre>
<p>Sample calls:</p>
<pre><code>In [256]: p.parse_args(['Work'])
Out[256]: Namespace(status='work')

In [257]: p.parse_args(['status'])
usage: ipython3 [-h] {pend,work,appr,reje}
ipython3: error: argument status: invalid choice: 'stat' (choose from 'pend', 'work', 'appr', 'reje')
...

In [258]: p.parse_args(['reject'])
Out[258]: Namespace(status='reje')

In [259]: p.parse_args(['Pending'])
Out[259]: Namespace(status='pend')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Though I haven't tested it, looking at the <code>add_argument</code> function documentation, you should be able to add them as the first arguments to it.</p>
<blockquote>
<p>name or flags - Either a name or a list of option strings, e.g. foo or -f, --foo.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/argparse.html#the-add-argument-method" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#the-add-argument-method</a></p>
</div>
<span class="comment-copy">That's essentially how the output argument you have works, right? Can you just do it like that? put the short name first then the long version</span>
<span class="comment-copy">cool.. I had thought I can make it more versatile.. I guess I will need to think of some other ways to get around with it.. Else I will need to tell users to type in specific keywords</span>
<span class="comment-copy">Dictionaries are another useful tool for mapping from one set of strings to other strings, or better yet other objects.</span>
<span class="comment-copy">Okay, wasn't aware of using dictionary. Sounds like a viable option to use dictionary, rather than <code>if...elif...</code></span>
<span class="comment-copy">I have updated my thread with slightly more information.. correct me if I am wrong, but isn't <code>name or flags</code> where you type in the input, in my case I am focusing on name</span>
