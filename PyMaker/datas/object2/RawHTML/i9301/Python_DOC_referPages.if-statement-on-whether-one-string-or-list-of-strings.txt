<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2225038/determine-the-type-of-an-object">Determine the type of an object?</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
</ul>
</div>
<p>I have the following function. Ideally, I want to have either a single string or a list of strings passed as an input.  In either case, I need to use .upper on it.   But, when only a single string is passed, the iterator iterates through each character.  How can I have an if statement that tests whether a list of strings or a single string? (I can't seem to avoid the iterable nature of strings)</p>
<pre><code>def runthis(stringinput):

    for t in stringinput:
        t = t.upper()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check the type using <code>isinstance</code>.</p>
<pre><code>def runthis(stringinput):
    if isinstance(stringinput, list):
        for t in stringinput:
            t = t.upper()
            # Some other code should probably be here.
    elif isinstance(stringinput, basestring):
        t = t.upper()
        # Some other code perhaps as well.
    else:
        raise Exception("Unknown type.")
</code></pre>
<p>Use <code>str</code> instead of <code>basestring</code> for Python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>isinstance()</code> to check whether your function arg is of type <code>list</code> or not:</p>
<pre><code>def to_upper(arg):
    if isinstance(arg, list):
        return [item.upper() for item in arg]  # This is called list comprehension
    else:
        return arg.upper()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way would be to explicitly check if the argument is a list or a string and handle it differently within conditional clauses.</p>
<p>An alternative that I think might be nicer (if it's suitable for your use case) might be the following:</p>
<pre><code>def runthis(*stringinput):
    for t in stringinput:
        t = t.upper()
        print(t)
    print()

runthis("test") # TEST
runthis("another", "test")  # ANOTHER TEST
runthis(*["one", "final", "test"]) # ONE FINAL TEST
</code></pre>
<p>However, this approach isn't appropriate if calling code may provide lists without splatting it.</p>
<hr/>
<p>This approach relies on the usage of the <code>*</code> operator, which here is used in two different ways.</p>
<p><strong>In the function definition context</strong> (<code>*stringinput</code>), this operator essentially makes <code>stringinput</code> a <em>variadic</em> argument; that is, an argument that "scoops up" all arguments passed to the function into a tuple, which for the purposes of <code>runthis</code> acts like a list (it can be iterated over). If I were to make a call <code>runthis("foo", "bar", "baz")</code>, <code>stringinput</code> would have the value <code>("foo", "bar", "baz")</code>.</p>
<p>You can read more about variadic arguments <a href="https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists" rel="nofollow noreferrer">here</a>. </p>
<p><strong>In the function invocation context</strong> (<code>runthis(*["one", "final", "test"])</code>), this operator will "splat" or unpack each element of the list. Essentially, <code>runthis(*["one", "final", "test"])</code> is equivalent to <code>runthis("one", "final", "test")</code>.</p>
<p>You can read more about splatting <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <code>type()</code> function as so:</p>
<pre><code>if type(stringinput) is list:
    #Your list code
elif type(stringinput) is str:
    #Your string code
else:
    #stringinput isn't a list or a string, throw an error
</code></pre>
</div>
<span class="comment-copy">So, even if <code>stringinput</code> was a list of strings, your code wouldn't modify it.</span>
<span class="comment-copy">Seems nicer to always accept a list of strings, which may contain only a single string. What is the value in letting the caller pass you an un-listed string?</span>
<span class="comment-copy">thanks!  That worked well</span>
<span class="comment-copy">hi, thanks for that.  what does the "*" do?</span>
<span class="comment-copy">"*" is the splat operator. I'll edit my post to include more information about it.</span>
<span class="comment-copy">@keynesiancross I've edited those details in now.</span>
