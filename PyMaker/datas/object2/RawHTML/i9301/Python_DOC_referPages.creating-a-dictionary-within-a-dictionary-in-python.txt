<div class="post-text" itemprop="text">
<p>Person Node Value</p>
<pre><code>Bob    A    2
Bob    A    3
Bob    A    4
Bob    B    2
Bob    B    3
Jill   A    1
Jill   B    2
</code></pre>
<p>I am attempting to get the following into a data structure similar to this</p>
<pre><code>{ 'Bob': { 'A':[2,3,4],'B':[2,3], :'Jill':{'A':[1], 'B':[2]}
</code></pre>
<p>I know this might not be the best approach, but what I am trying to do with my data structure is the following:</p>
<ol>
<li>Dictionary whose key is a value and check if it a value.</li>
<li>Value of dictionary is another dictionary and need to check if key is already in the value. </li>
<li>Value of the second dictionary is a list which needs to be appended to if the list exists like in Bob's case.</li>
</ol>
<p>I have tried numerous approaches, but right now, my code is looking like this. </p>
<pre><code>names = {}


with open('impacts.csv', 'rb') as csvfile:
    namesreaders = csv.reader(csvfile, delimiter=' ', quotechar='|')
    for row in namesreaders:
        person, letter, value = row[0], row[1], row[2]
        if person not in names:
           names[person] = { letter: value}
        else:
            print 'Lost a bit'
            ### Lost here
print names
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>, where the default is a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> with a default <code>list</code>.  Then it's very easy to populate that dictionary</p>
<pre><code>from collections import defaultdict
d = defaultdict(lambda: defaultdict(list))
with open('impacts.csv', 'rb') as csvfile:
    namesreaders = csv.reader(csvfile, delimiter=' ', quotechar='|')
    for row in namesreader:
        person, letter, value = row[0], row[1], row[2]
        d[person][letter].append(value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use nested dictionaries by implementing the perl’s autovivification feature.</p>
<pre><code>class AutoVivification(dict):
    """Implementation of perl's autovivification feature."""
    def __getitem__(self, item):
        try:
            return dict.__getitem__(self, item)
        except KeyError:
            value = self[item] = type(self)()
            return value​

​# For your case
names = AutoVivification()

with open('impacts.csv', 'rb') as csvfile:
    namesreaders = csv.reader(csvfile, delimiter=' ', quotechar='|')
    for row in namesreaders:
        person, letter, value = row[0], row[1], row[2]
        if names[person][letter]:
            names[person][letter].append(value)
        else:
            names[person][letter] = [value]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would solve it like this. I am sure it could be shortened quite a bit if you make it more recursive and use comprehension. But to understand the principle and make it similar to your start (solution not tested for syntactic errors):</p>
<pre><code>names = {}

with open('impacts.csv', 'rb') as csvfile:
    namesreaders = csv.reader(csvfile, delimiter=' ', quotechar='|')
    for row in namesreaders:
       person, letter, value = row[0], row[1], row[2]
       if person not in names:
          names[person] = {}
       if letter not in names[person]:
           names[person][letter] = []
       names[person][letter].append(value)
 print names
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't let the code confuse you.  You defined pretty clearly what you need to do.  Now just take it slow and do it.</p>
<p>First, as you said: <em>value of second dictionary is a list</em>.  You don't want</p>
<pre><code>names[person] = { letter: value }
</code></pre>
<p>Instead you want:</p>
<pre><code>names[person] = { letter: [value] }
</code></pre>
<p>Now in your else, you know that person is already in names.  Is value?  If it is, add to the list, otherwise, create a new list:</p>
<pre><code>else:
    if letter in names[person]:
        names[person][letter].append(value)
    else:
        names[person][letter] = value
</code></pre>
<p>Now, you can probably go about this a whole lot cleaner using the <code>setdefault</code> method of a <a href="https://docs.python.org/2/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer">dict</a>.</p>
<p>This would do the same thing:</p>
<pre><code>names = {}

with open('impacts.csv', 'rb') as csvfile:
    namesreaders = csv.reader(csvfile, delimiter=' ', quotechar='|')
for row in namesreaders:
    person, letter, value = row[0], row[1], row[2]

    # Make sure that if person isn't in names, 
    # person is added to names as a dict
    names.setdefault(person, {})
    # Make sure that if letter isn't in the names[person] dict
    # letter is added as an empty list
    names[person].setdefault(letter, [])
    # At this point, names[person][letter] is an existing, possibly empty
    # list.  Simply add the new value
    names[person][letter].append(value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Quite a well known pythonic technique is to use <code>defaultdict()</code> to specify complex dictionary structures at initialization time.</p>
<p>Disclaimer: <em>I would highly recommend considering class structures to handle this data, as these kinds of nested dictionaries can lead to code smells rather quickly.</em></p>
<pre><code>import functools
from collections import defaultdict

d_inner = functools.partial(defaultdict, list)
d = defaultdict(d_inner)

# Do something with data here
for name, letter, number in row:
    d[name][letter].append(number)
</code></pre>
<p><strong>Sample Output:</strong></p>
<pre><code>defaultdict(&lt;functools.partial object at 0x109de71b0&gt;, {'Bob': defaultdict(&lt;type 'list'&gt;, {'A': [2, 3, 4], 'B': [2, 3]}), 'Jill': defaultdict(&lt;type 'list'&gt;, {'A': [1], 'B': [2]})})
</code></pre>
</div>
<span class="comment-copy">You want to have <i>lists</i> as values, and still, no list is created in your code snippet.</span>
<span class="comment-copy">Minor point, but your data structure example is missing a few curly braces to close up the second level dictionaries.</span>
<span class="comment-copy">Terrific way to do this and learned a lot from your answer. Thank you!</span>
