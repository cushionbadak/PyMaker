<div class="post-text" itemprop="text">
<p>I have a class with <code>__iter__</code> defined like below:</p>
<pre><code>class MyIterator:

    def __iter__(self):
        for value in self._iterator:
            if is_iterator(value):
                yield from value
            else:
                yield value
</code></pre>
<p>I want to do <code>next(my_iterator)</code> but I have to implement <code>__next__</code> to do so. But it would change this simple implementation to a fairly complicated one - or actually I don't know how to implement this instead of defining <code>__iter__</code> as a generator function.</p>
<p>Generally spealing, if <code>__iter__</code> is implemented as a generator fuction which might be difficult to be done without generator, how should I do if I want to use <code>__next__</code>?</p>
<p>Note: Apparently, <code>next(iter(my_iterator))</code> works, but I don't want to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your class is supposed to be an iterator, it should not have its <code>__iter__</code> method implemented as a generator function. That makes the class iterable, but not an iterator. An iterator's <code>__iter__</code> method is supposed to return itself.</p>
<p>If you really want your class to be an iterator, try something like this:</p>
<pre><code>class MyIterator:
    def __init__(self, iterator):
        self._iterator = iterator
        self._subiterator = None

    def __iter__(self):
        return self

    def __next__(self):
        while True:
            if self._subiterator is None:
                value = next(self._iterator) # may raise StopIteration

                try:  # could test is_iterator(value) here for LBYL style code
                    self._subiterator = iter(value)
                except TypeError:
                    return value

            try:
                return next(self._subiterator)
            except StopIteraton:
                self._subiterator = None
</code></pre>
<p>The <code>next(self._iterator)</code> call may raise <code>StopIteration</code>, which I deliberately do not catch. That exception is the signal we're finished iterating, so if we caught it we'd only have to raise it again.</p>
<p>This code uses a "Easier to Ask Forgiveness than Permission" (EAFP) approach to detecting iterable items within the iterator it's been given. It simply tries calling <code>iter</code> on each one and catches the <code>TypeError</code> that will be raised if they're not iterable. If you prefer to stick with the "Look Before You Leap" (LBYL) style and explicitly test with <code>is_iterator</code> (which is badly named, since it checks for any kind of iterable, not only iterators), you could replace the inner <code>try</code> with:</p>
<pre><code>if is_iterator(value):
    return value
else:
    self._subiterator = iter(value)
</code></pre>
<p>I usually prefer EAFP style to LBYL style in my Python code, but there are situations where either one can be better. Other times it's just a matter of style.</p>
</div>
<div class="post-text" itemprop="text">
<p>As @BrenBarm commented, the apparent answer was to return <code>next(iter(self))</code>, or <code>next(self._iter_self)</code> by keeping <code>self._iter_self = iter(self)</code>. I couldn't just come up with it.</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>an iterator is an object with a <code>__next__</code> method that returns values until finally raising <code>StopIteration</code>.</li>
<li>an iterable is an object with an <code>__iter__</code> method that returns an iterator.</li>
<li>a generator is a special iterable created by python when a function or method include the yield statement.</li>
</ul>
<p>In your example, <code>__iter__</code> has a yield so it is a generator. And that means it returns another iterable, not an iterator. That's why you have to do that strange <code>next(iter(my_iterator))</code> thing, and that doesn't work because it restarts the enumation each time.</p>
<p>How best to solve this problem depends on how you are using this class. You could create a generator function instead and then use <code>iter</code> to make iterators as needed:</p>
<pre><code>import collections.abc

def is_iterator(i):
    return isinstance(i, collections.abc.Iterable)

def MyIterator(iterable):
    for value in iterable:
        if is_iterator(value):
            yield from value
        else:
            yield value

test_this = [1,2, [3, 4, 5], [6], [], 7, 'foo']
my_iterator = iter(MyIterator(test_this))
try:
    while True:
        print(next(my_iterator))
except StopIteration:
    pass
</code></pre>
<p>Or you can implement <code>__next__</code> instead of <code>__iter__</code>. But you can't use <code>yield</code> and have to return a value on each call until the outer iterator completes and raises <code>StopIteration</code>.</p>
<pre><code>import collections.abc

class MyIterator:

    def __init__(self, iterable):
        self._iterator = iter(iterable)
        self._iterating = None

    def __next__(self):
        while True:
            if self._iterating is not None:
                try:
                    return next(self._iterating)
                except StopIteration:
                    self._iterating = None
            value = next(self._iterator)
            if isinstance(value, collections.abc.Iterable):
                self._iterating = iter(value)
            else:
                return value


test_this = [1,2, [3, 4, 5], [6], [], 7, 'foo']
my_iterator = MyIterator(test_this)
try:
    while True:
        print(next(my_iterator))
except StopIteration:
    pass
</code></pre>
</div>
<span class="comment-copy">You need to explain more about how you intend the iteration to work.  You could write a <code>__next__</code> that just returns <code>next(iter(self))</code>.  If that doesn't do what you want, then you need to explain what you want the actual behavior to be.  In particular, note that by calling <code>__iter__</code> multiple times, you can get multiple separate iterators, but if you intend to use <code>next</code> directly on your object, then you can really only have one iterator.</span>
<span class="comment-copy">Well, you've given me the answer. Thanks.</span>
<span class="comment-copy">It looks like you want something similar to <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer">itertools.chain.from_iterable</a>. If a value you iterate is also iterable, expand that before continuing. So, <code>[1, [2,3,4], 5]</code> becomes <code>[1,2,3,4,5]</code>. Is that right?</span>
<span class="comment-copy">I've learned so many from your post. Thanks.</span>
<span class="comment-copy">Why making <code>self._subiterator</code> an instance variable instead of a local variable of the <code>__next__</code> method?</span>
<span class="comment-copy">The <code>self</code> argument is a reference to the instance the method is being called on. So assigning to <code>self._subiterator</code> sets an attribute on the instance, rather than a local variable.</span>
<span class="comment-copy">Um, generator objects <i>are</i> iterators. And all iterators are required to be iterable. Every (correctly implemented) iterator should have an <code>__iter__</code> method that returns itself. The questioner's issue is that they've misunderstood what their class is. It's an iterable, but not an iterator. You'd get an iterator for it by calling <code>iter(some_instance)</code>, which will call the <code>__iter__</code> method and get the generator object (which is the iterator).</span>
