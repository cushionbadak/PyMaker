<div class="post-text" itemprop="text">
<p>I seem to have found a pitfall with using <code>.sum()</code> on <code>numpy</code> arrays but I'm unable to find an explanation. Essentially, if I try to sum a large array then I start getting nonsensical answers but this happens <em>silently</em> and I can't make sense of the output well enough to Google the cause.</p>
<p>For example, this works exactly as expected:</p>
<pre><code>a = sum(xrange(2000)) 
print('a is {}'.format(a))

b = np.arange(2000).sum()
print('b is {}'.format(b))
</code></pre>
<p>Giving the same output for both:</p>
<pre><code>a is 1999000
b is 1999000
</code></pre>
<p>However, this does not work:</p>
<pre><code>c = sum(xrange(200000)) 
print('c is {}'.format(c))

d = np.arange(200000).sum()
print('d is {}'.format(d))
</code></pre>
<p>Giving the following output:</p>
<pre><code>c is 19999900000
d is -1474936480
</code></pre>
<p>And on an even larger array, it's possible to get back a positive result. This is more insidious because I might not identify that something unusual was happening at all. For example this:</p>
<pre><code>e = sum(xrange(100000000))
print('e is {}'.format(e))

f = np.arange(100000000).sum()
print('f is {}'.format(f))
</code></pre>
<p>Gives this:</p>
<pre><code>e is 4999999950000000
f is 887459712
</code></pre>
<p>I <em>guessed</em> that this was to do with data types and indeed even using the python <code>float</code> seems to fix the problem:</p>
<pre><code>e = sum(xrange(100000000))
print('e is {}'.format(e))

f = np.arange(100000000, dtype=float).sum()
print('f is {}'.format(f))
</code></pre>
<p>Giving:</p>
<pre><code>e is 4999999950000000
f is 4.99999995e+15
</code></pre>
<p>I have no background in Comp. Sci. and found myself stuck (perhaps this is a dupe). Things I've tried:</p>
<ol>
<li><code>numpy</code> arrays have a fixed size. Nope; <a href="https://stackoverflow.com/questions/14525344/whats-the-maximum-size-of-a-numpy-array">this</a> seems to show I should hit a <code>MemoryError</code> first.</li>
<li>I might somehow have a 32-bit installation (probably not relevant); nope, I followed <a href="https://stackoverflow.com/questions/33553549/do-i-have-numpy-32-bit-or-64-bit">this</a> and confirmed I have 64-bit.</li>
<li>Other examples of weird <code>sum</code> behaviour; nope (<strong>?</strong>) I found <a href="https://stackoverflow.com/questions/30998305/weird-numpy-sum-behavior-when-adding-zeros">this</a> but I can't see how it applies.</li>
</ol>
<p>Can someone please explain briefly what I'm missing and tell me what I need to read up on? Also, other than  remembering to define a <code>dtype</code> each time, is there a way to stop this happening or give a warning? </p>
<p>Possibly relevant:</p>
<p>Windows 7</p>
<p><code>numpy</code> 1.11.3</p>
<p>Running out of Enthought Canopy on Python 2.7.9</p>
</div>
<div class="post-text" itemprop="text">
<p>This is clearly numpy's integer type overflowing 32-bits.  Normally you can configure numpy to fail in such situations using <code>np.seterr</code>:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.seterr(over='raise')
{'divide': 'warn', 'invalid': 'warn', 'over': 'warn', 'under': 'ignore'}
&gt;&gt;&gt; np.int8(127) + np.int8(2)
FloatingPointError: overflow encountered in byte_scalars
</code></pre>
<p>However, <code>sum</code> is explicitly documented with the behaviour "<strong>No error is raised on overflow</strong>", so you might be out of luck here.  Using numpy is often a trade-off of performance for convenience!  </p>
<p>You can however manually specify the dtype for the accumulator, like this:</p>
<pre><code>&gt;&gt;&gt; a = np.ones(129)
&gt;&gt;&gt; a.sum(dtype=np.int8)  # will overflow
-127
&gt;&gt;&gt; a.sum(dtype=np.int64)  # no overflow
129
</code></pre>
<p>Watch ticket <a href="https://github.com/numpy/numpy/issues/593" rel="nofollow noreferrer">#593</a>, because this is an open issue and it might be fixed by numpy devs sometime.  </p>
</div>
<div class="post-text" itemprop="text">
<p>On Windows (on 64-bit system too) the default integer NumPy uses if you convert from Python ints is 32-bit. On Linux and Mac it is 64-bit.</p>
<p>Specify a 64-bit integer and it will work:</p>
<pre><code>d = np.arange(200000, dtype=np.int64).sum()
print('d is {}'.format(d))
</code></pre>
<p>Output:</p>
<pre><code>c is 19999900000
d is 19999900000
</code></pre>
<p>While not most elegant, you can do some <a href="https://en.wikipedia.org/wiki/Monkey_patch" rel="nofollow noreferrer">monkey patching</a>, using <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a>:</p>
<pre><code>from functools import partial

np.arange = partial(np.arange, dtype=np.int64)
</code></pre>
<p>From now on <code>np.arange</code> works with 64-bit integers as default.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not a numpy expert, but can reproduce your <code>arange(200000)</code> result in pure Python:</p>
<pre><code>&gt;&gt;&gt; s = 0
&gt;&gt;&gt; for i in range(200000):
...     s += i
...     s &amp;= 0xffffffff
&gt;&gt;&gt; s
2820030816
&gt;&gt;&gt; s.bit_length()
32
&gt;&gt;&gt; s - 2**32  # adjust for that "the sign bit" is set
-1474936480
</code></pre>
<p>In other words, the result you're seeing is what I expect if <code>numpy</code> is doing its arithmetic on signed 2's-complement 32-bit integers.</p>
<p>Since I'm not a <code>numpy</code> expert, I can't suggest a good approach to never getting surprised (I would have left this as a comment, but I couldn't show nicely formatted code then).</p>
</div>
<div class="post-text" itemprop="text">
<p>Numpy's default integer type is the same as the C <code>long</code> type. Now, this isn't guaranteed to be 64-bits on a 64-bit platform. In fact, on Windows, <code>long</code> is <em>always</em> 32-bits.</p>
<p>As a result, the numpy sum is overflowing the value and looping back around.</p>
<p>Unfortunately, as far as I know, there is <em>no</em> way to change the default <code>dtype</code>. You'll have to specify it as <code>np.int64</code> every time.</p>
<p>You could try to create your own <code>arange</code>:</p>
<pre><code>def arange(*args, **kw):
    return np.arange(dtype=np.int64, *args, **kw)
</code></pre>
<p>and then use that version instead of numpy's.</p>
<p><strong>EDIT:</strong> <strong>If you want to flag this</strong>, you could just put something like this in the top of your code:</p>
<pre><code>assert np.array(0).dtype.name != 'int32', 'This needs to be run with 64-bit integers!'
</code></pre>
</div>
<span class="comment-copy">probably because <code>numpy</code> integers rely on C-type integers, whereas python has unlimited integer range. floats are ... floats. They can be very high.</span>
<span class="comment-copy">Check <code>np.arange(5).dtype</code>. It's probably using 32-bit integers instead of 64-bit. Also, make sure you're performing all these checks on the same Python installation.</span>
<span class="comment-copy">Looks like some kind of overflow... the sign of the integer seems to be overwritten as well which is might be the reason you get negative results sometimes.</span>
<span class="comment-copy">@user2357112 indeed it is printing <code>dtype('int32')</code></span>
<span class="comment-copy">Thanks a lot for including the ticket. I suspected it was an overflow but the lack of any warning made me question what was really happening. That, combined with not knowing that Windows automatically converts int to 32-bit left me confused.</span>
<span class="comment-copy">This makes sense to me but one of my key questions was whether there was a way to flag this. It's far too easy for this to fall under my radar when debugging; is there a way to identify that I missed this?</span>
<span class="comment-copy">Added a possible solution.</span>
<span class="comment-copy">Start by searching for "two's complement".  With various fixed bit widths (8, 16, 32, 64), that's the scheme virtually all computer hardware uses to represent signed integers.  In a low-level language like <code>C</code> (which CPython and numpy are coded in), native hardware types like that are the ones you work with.  It takes a lot of code under the covers to implement Python's illusion of infinitely-wide two's complement integers.</span>
<span class="comment-copy">Many thanks, I'm reading into it now. That "lot of code under the covers" has shielded me from a lot, thanks :) In this case, Wim has linked to an open ticket with <code>numpy</code> in his answer; it's been recognised that there is no overflow error in this particular case (which is what threw me) but it has been open for many years now :(</span>
