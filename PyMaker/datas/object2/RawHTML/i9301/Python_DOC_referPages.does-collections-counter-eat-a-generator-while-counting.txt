<div class="post-text" itemprop="text">
<p>I have been looking at <a href="https://docs.python.org/3/library/collections.html#counter-objects" rel="nofollow noreferrer">collections.Counter</a>.</p>
<p>I am using the following (simplified) code:</p>
<pre><code>choices = ['foo', 'bar']

def generator(n=100000000):
  yield random.choice(choices)

counts = collections.Counter(generator())
</code></pre>
<p>Now my question, in my implementation <code>Counter</code> takes a generator as input. To first convert the generator to a list would take way too much space in memory. </p>
<p>So I wonder if <code>collections.Counter</code> first converts the data to a list and then 'counts' or it 'eats' the generator while counting.</p>
<p>If it first converts the data to a list. How would I best go about implementing it without converting it to a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, the iterable you pass in (be it a generator or another iterable object) is <em>not</em> converted to a list.</p>
<p>There is no need to convert the iterable; counting is done as you iterate. The implementation is essentially the same as:</p>
<pre><code>counts = {}
for element in generator():
    if element in counts:
        counts[element] += 1
    else:
        counts[element] = 1
</code></pre>
<p>but a <code>Counter()</code> object does this much faster (the counting code is implemented in C).</p>
</div>
<span class="comment-copy">As far as I know the <code>Counter</code> eats the generator and counts meanwhile.</span>
<span class="comment-copy">There is no <code>itertools.Counter</code> only <code>collections.Counter</code></span>
<span class="comment-copy">You're right. I changed it</span>
