<div class="post-text" itemprop="text">
<p>I'm having a difficult time to debug a problem in which the float <code>nan</code> in a <code>list</code> and <code>nan</code> in a <code>numpy.array</code> are handled differently when these are used in <code>itertools.groupby</code>:</p>
<p>Given the following list and array:</p>
<pre><code>from itertools import groupby
import numpy as np

lst = [np.nan, np.nan, np.nan, 0.16, 1, 0.16, 0.9999, 0.0001, 0.16, 0.101, np.nan, 0.16]
arr = np.array(lst)
</code></pre>
<p>When I iterate over the list the contiguous <code>nan</code>s are grouped:</p>
<pre><code>&gt;&gt;&gt; for key, group in groupby(lst):
...     if np.isnan(key):
...         print(key, list(group), type(key))
nan [nan, nan, nan] &lt;class 'float'&gt;
nan [nan] &lt;class 'float'&gt;
</code></pre>
<p>However if I use the array it puts successive <code>nan</code>s in different groups:</p>
<pre><code>&gt;&gt;&gt; for key, group in groupby(arr):
...     if np.isnan(key):
...         print(key, list(group), type(key))
nan [nan] &lt;class 'numpy.float64'&gt;
nan [nan] &lt;class 'numpy.float64'&gt;
nan [nan] &lt;class 'numpy.float64'&gt;
nan [nan] &lt;class 'numpy.float64'&gt;
</code></pre>
<p>Even if I convert the array back to a list:</p>
<pre><code>&gt;&gt;&gt; for key, group in groupby(arr.tolist()):
...     if np.isnan(key):
...         print(key, list(group), type(key))
nan [nan] &lt;class 'float'&gt;
nan [nan] &lt;class 'float'&gt;
nan [nan] &lt;class 'float'&gt;
nan [nan] &lt;class 'float'&gt;
</code></pre>
<p>I'm using:</p>
<pre><code>numpy 1.11.3
python 3.5
</code></pre>
<p>I know that generally <code>nan != nan</code> so why do these operations give different results? And how is it possible that <code>groupby</code> can group <code>nan</code>s at all?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python lists are just arrays of pointers to objects in memory. In particular <code>lst</code> holds pointers to the object <code>np.nan</code>:</p>
<pre><code>&gt;&gt;&gt; [id(x) for x in lst]
[139832272211880, # nan
 139832272211880, # nan
 139832272211880, # nan
 139832133974296,
 139832270325408,
 139832133974296,
 139832133974464,
 139832133974320,
 139832133974296,
 139832133974440,
 139832272211880, # nan
 139832133974296]
</code></pre>
<p>(<code>np.nan</code> is at 139832272211880 on my computer.)</p>
<p>On the other hand, NumPy arrays are just contiguous regions of memory; they are regions of bits and bytes that are interpreted as a sequence of values (floats, ints, etc.) by NumPy.</p>
<p>The trouble is that when you ask Python to iterate over a NumPy array holding floating values (at a <code>for</code>-loop or <code>groupby</code> level), Python needs to box these bytes into a proper Python object. It creates a brand new Python object in memory for each single value in the array as it iterates.</p>
<p>For example, you can see that that distinct objects for each <code>nan</code> value are created when <code>.tolist()</code> is called:</p>
<pre><code>&gt;&gt;&gt; [id(x) for x in arr.tolist()]
[4355054616, # nan
 4355054640, # nan
 4355054664, # nan
 4355054688,
 4355054712,
 4355054736,
 4355054760,
 4355054784,
 4355054808,
 4355054832,
 4355054856, # nan
 4355054880]
</code></pre>
<p><code>itertools.groupby</code> is able to group on <code>np.nan</code> for the Python list because it checks for <em>identity</em> first when it compares Python objects. Because these pointers to <code>nan</code> all point at the same <code>np.nan</code> object, grouping is possible.</p>
<p>However, iteration over the NumPy array does not allow this initial identity check to succeed, so Python falls back to checking for equality and <code>nan != nan</code> as you say.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answers of <a href="https://stackoverflow.com/a/41724043/5393381">tobias_k</a> and <a href="https://stackoverflow.com/a/41724088/5393381">ajcr</a> are correct, it's because the <code>nan</code>s in the list have the same <code>id</code> while they have different ids when they are "iterated over" in the numpy-array.</p>
<p>This answer is meant as a supplement for these answers.</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; lst = [np.nan, np.nan, np.nan, 0.16, 1, 0.16, 0.9999, 0.0001, 0.16, 0.101, np.nan, 0.16]
&gt;&gt;&gt; arr = np.array(lst)

&gt;&gt;&gt; for key, group in groupby(lst):
...     if np.isnan(key):
...         print(key, id(key), [id(item) for item in group])
nan 1274500321192 [1274500321192, 1274500321192, 1274500321192]
nan 1274500321192 [1274500321192]

&gt;&gt;&gt; for key, group in groupby(arr):
...     if np.isnan(key):
...         print(key, id(key), [id(item) for item in group])
nan 1274537130480 [1274537130480]
nan 1274537130504 [1274537130504]
nan 1274537130480 [1274537130480]
nan 1274537130480 [1274537130480]  # same id as before but these are not consecutive

&gt;&gt;&gt; for key, group in groupby(arr.tolist()):
...     if np.isnan(key):
...         print(key, id(key), [id(item) for item in group])
nan 1274537130336 [1274537130336]
nan 1274537130408 [1274537130408]
nan 1274500320904 [1274500320904]
nan 1274537130168 [1274537130168]
</code></pre>
<p>The problem is that Python uses the <a href="https://docs.python.org/c-api/object.html#c.PyObject_RichCompare" rel="nofollow noreferrer"><code>PyObject_RichCompare</code></a>-operation when comparing values, which only tests for object identity if <code>==</code> fails because it's not implemented. <code>itertools.groupby</code> on the other hand uses <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool" rel="nofollow noreferrer"><code>PyObject_RichCompareBool</code></a> (see Source: <a href="https://github.com/python/cpython/blob/3.5/Modules/itertoolsmodule.c#L88" rel="nofollow noreferrer">1</a>, <a href="https://github.com/python/cpython/blob/3.5/Modules/itertoolsmodule.c#L318" rel="nofollow noreferrer">2</a>) which tests for object identity <strong>first and before <code>==</code> is tested</strong>.</p>
<p>This can be verified with a small cython snippet:</p>
<pre><code>%load_ext cython
%%cython

from cpython.object cimport PyObject_RichCompareBool, PyObject_RichCompare, Py_EQ

def compare(a, b):
    return PyObject_RichCompare(a, b, Py_EQ), PyObject_RichCompareBool(a, b, Py_EQ)

&gt;&gt;&gt; compare(np.nan, np.nan)
(False, True)
</code></pre>
<p>The source code for <code>PyObject_RichCompareBool</code> reads like this:</p>
<pre class="lang-c prettyprint-override"><code>/* Perform a rich comparison with object result.  This wraps do_richcompare()
   with a check for NULL arguments and a recursion check. */

/* Perform a rich comparison with integer result.  This wraps
   PyObject_RichCompare(), returning -1 for error, 0 for false, 1 for true. */
int
PyObject_RichCompareBool(PyObject *v, PyObject *w, int op)
{
    PyObject *res;
    int ok;

    /* Quick result when objects are the same.
       Guarantees that identity implies equality. */
    /**********************That's the difference!****************/
    if (v == w) {
        if (op == Py_EQ)
            return 1;
        else if (op == Py_NE)
            return 0;
    }

    res = PyObject_RichCompare(v, w, op);
    if (res == NULL)
        return -1;
    if (PyBool_Check(res))
        ok = (res == Py_True);
    else
        ok = PyObject_IsTrue(res);
    Py_DECREF(res);
    return ok;
}
</code></pre>
<p>The object identity test (<code>if (v == w)</code>) is indeed done before the normal python comparison <code>PyObject_RichCompare(v, w, op);</code> is used and mentioned in <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool" rel="nofollow noreferrer">its documentation</a>:</p>
<blockquote>
<p>Note :</p>
<p>If o1 and o2 are the same object, <code>PyObject_RichCompareBool()</code> will always return 1 for Py_EQ and 0 for Py_NE. </p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure whether this is the reason, but I just noticed this about the <code>nan</code> in <code>lst</code> and <code>arr</code>:</p>
<pre><code>&gt;&gt;&gt; lst[0] == lst[1], arr[0] == arr[1]
(False, False)
&gt;&gt;&gt; lst[0] is lst[1], arr[0] is arr[1]
(True, False)
</code></pre>
<p>I.e., while all <code>nan</code> are inequal, the regular <code>np.nan</code> (of type <code>float</code>) are all the <em>same</em> instance, while the <code>nan</code> in the <code>arr</code> are <em>different</em> instances of type <code>numpy.float64</code>). So my guess would be that if no <code>key</code> function is given, <code>groupby</code> will test for identity before doing the more expensive equality check.</p>
<p>This is also consistent with the observation that is does not group in <code>arr.tolist()</code> either, because even though those <code>nan</code> are now <code>float</code> again, they are no longer the same instance.</p>
<pre><code>&gt;&gt;&gt; atl = arr.tolist()
&gt;&gt;&gt; atl[0] is atl[1]
False
</code></pre>
</div>
<span class="comment-copy">Hm, I wonder what prompted this question. :)</span>
<span class="comment-copy">What exactly is the question here: Why <code>groupby</code> shown this inconsistent behaviour, or how to work around it? And in the latter case, do you want <code>nan</code>s grouped or not?</span>
<span class="comment-copy">Just if someone else is interested, the question was prompted when I tried to find out why <a href="http://stackoverflow.com/a/41722363/5393381">an answer</a> worked when applied to a list but not when applied to an <code>np.array</code>.</span>
<span class="comment-copy">@tobias_k I'm interested in an explanation why these differ.</span>
<span class="comment-copy"><code>groupby</code> applied to a float dtype array may be close to useless unless <code>np.isclose</code> is used as <code>key</code>.</span>
<span class="comment-copy">So <code>math.nan</code> is a singleton, and <code>np.nan</code> is a singleton, but accessing a <code>np.array</code> creates a temporary float that <i>isn't</i> a singleton? Mind blown.</span>
<span class="comment-copy">@MarkRansom not only <code>np.array.__getitem__</code> creates a different object for nan when you want to access it. But every time you manually create a <code>nan</code> (for example <code>float('nan')</code>) a new <i>not-singleton</i> nan is created. Fun fact: <code>np.nan is not math.nan</code>!</span>
