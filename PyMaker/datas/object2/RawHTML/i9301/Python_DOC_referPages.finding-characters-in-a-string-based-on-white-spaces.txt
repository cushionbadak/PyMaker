<div class="post-text" itemprop="text">
<p>So I am trying to get a function working that will return a new list of single characters that immediately follow two other given characters. Like so:</p>
<pre><code>def filter_possible_chars(corpus, last):
    """
    &gt;&gt;&gt; filter_possible_chars('lazy languid line', 'la')
    ['z', 'n']
    &gt;&gt;&gt; filter_possible_chars('pitter patter', 'tt')
    ['e', 'e']
    """
    char_list = []
    corpus_split = corpus.split()
    for word in corpus_split:
        if last in word:
            word_split = word.split(last)
            follows_last = word_split[1]
            char_list.append(follows_last[0])
    return char_list
</code></pre>
<p>This function works perfectly for the examples given in the docstring, however I need to include examples that include white space, e.g.:</p>
<pre><code>&gt;&gt;&gt; filter_possible_chars('when the goat jumped to the rock', ' t')
</code></pre>
<p>And it would return:</p>
<pre><code>['h', 'o', 'h']
</code></pre>
<p>But since my function is obviously deleting the white space I think I need to try an entirely different method here. I thought about not splitting the string into individual words and trying to index into it with the given letters, but I cannot think of a way to make that work for more than one instance in a string.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; pat="tt"
&gt;&gt;&gt; corpus="pitter patter"
&gt;&gt;&gt; print(re.findall("%s(.)"%pat,corpus))
['e', 'e']
&gt;&gt;&gt; corpus,pat = 'when the goat jumped to the rock', ' t'
&gt;&gt;&gt; re.findall("%s(.)"%pat,corpus)
['h', 'o', 'h']
&gt;&gt;&gt; corpus,pat = 'lazy languid line', 'la'
&gt;&gt;&gt; re.findall("%s(.)"%pat,corpus)
['z', 'n']
</code></pre>
<h3>Explanation</h3>
<ul>
<li><p><code>%</code> is the <a href="https://docs.python.org/3/library/stdtypes.html#old-string-formatting" rel="nofollow noreferrer">string formatting</a> operator, so for example <code>"%s(.)" % "la"</code> evaluates to <code>"la(.)"</code>.</p></li>
<li><p>In <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">regular expressions</a>, <code>.</code> is the pattern for "any character", and <code>()</code> define <em>groups</em> whose values can be retrieved later, e.g. using <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer"><code>findall</code></a>:</p>
<blockquote>
<p>If one or more groups are present in the pattern, return a list of groups</p>
</blockquote></li>
</ul>
<p>So, for example, the pattern <code>la(.)</code> means "search for <code>la</code> followed by any character, and capture that character".</p>
</div>
<div class="post-text" itemprop="text">
<p>Your idea how to solve this issue is perfectly fine. Instead of splitting sentence into words you should try to find all instances of <code>last</code> in full <code>corpus</code>. But hey, actually <code>split</code> function can do this for you.</p>
<pre class="lang-py prettyprint-override"><code>corpus = 'when the goat jumped to the rock'
spl = corpus.split(' t')
print spl
&gt;&gt; ['when', 'he goat jumped', 'o', 'he rock']
res = [x[0] for x in spl[1:] if len(x) &gt; 0]
print res
&gt;&gt; ['h', 'o', 'h']
</code></pre>
<p>So you can split <code>corpus</code> by <code>last</code> then get all strings from result of split without first one (as it does not start with <code>last</code>) and then get first letter from each such string.  </p>
</div>
<span class="comment-copy">OK nice that's fantastic. Could you explain what the <code>re.findall("%s(.)"%pat,corpus)</code> is doing exactly? I am familiar with the <code>re.findall(pattern, string, flags=0)</code> but am not sure exactly what your symbols are doing or what they mean in your pattern parameter.</span>
<span class="comment-copy">@RobertHemingway <code>re.findall()</code> searches for all non-overlapping matches of a regex pattern in a string. <code>'%s(.)' % pat</code> is saying "give me the first character after that regex pattern". The <code>(.)</code> denotes any single character except newline.</span>
<span class="comment-copy">I like the fact that you explained basics of regular expression you used (so upvote for your answer). But in general I think that it's better not to use regular expressions as long as you don't really need it.</span>
<span class="comment-copy">this is a very basic regex, there is no good reason to avoid it here.... but i do hear what your saying... but by that logic you never use regular expressions, because theres always more than one way to skin a cat...</span>
<span class="comment-copy">You are a god..</span>
