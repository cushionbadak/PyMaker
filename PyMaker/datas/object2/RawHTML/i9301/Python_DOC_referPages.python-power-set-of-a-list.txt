<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1482308/how-to-get-all-subsets-of-a-set-powerset">How to get all subsets of a set? (powerset)</a>
<span class="question-originals-answer-count">
                    13 answers
                </span>
</li>
</ul>
</div>
<p>I am trying to implement a function to generate the powerset of a list <code>xs</code>. </p>
<p>The general idea is that we walk through the elements of <code>xs</code> and choose whether to include <code>x</code> or not. The problem I'm facing is that <code>withX</code> ends up being equal to <code>[None]</code> (a singleton list with <code>None</code>) because (I think) <code>s.add(x)</code> returns <code>None</code>. </p>
<p>This isn't a homework assignment, it's an exercise in Cracking the Coding Interview.</p>
<pre><code>def powerSetBF(xs):
    powerSet = [] 
    powerSet.append(set([]))
    for x in xs:
        powerSetCopy = powerSet[:]
        withX = [s.add(x) for s in powerSetCopy] # add x to the list of sets 
        powerSet = powerSet.extend(withX) # append those entries
    return powerSet
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Take a look at the <code>powerset</code> example from the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer"><code>itertools</code> recipes</a>:</p>
<pre><code>from itertools import chain, combinations

def powerset(iterable):
    "list(powerset([1,2,3])) --&gt; [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))
</code></pre>
<p>For a <a href="https://docs.python.org/3/library/functions.html#func-range" rel="noreferrer"><code>range</code></a> of integers up to the length of the given list, make all possible <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="noreferrer"><code>combinations</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="noreferrer"><code>chain</code></a> them together as one object.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools

def powerset(L):
  pset = set()
  for n in xrange(len(L) + 1):
    for sset in itertools.combinations(L, n):
      pset.add(sset)
  return pset

powerset([1, 2, 3, 4])
</code></pre>
<p>result</p>
<pre><code>set([(1, 2), (1, 3), (1, 2, 3, 4), (1,), (2,), (3,), (1, 4), (4,), (), (2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (1, 2, 3), (3, 4), (2, 4)])
</code></pre>
<p>Source code for <code>itertools.combinations</code> can be found here which has a few neat optimizations:</p>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#itertools.combinations</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a recursive solution that does not use any modules:</p>
<pre><code>def pset(myset):
  if not myset: # Empty list -&gt; empty set
    return [set()]

  r = []
  for y in myset:
    sy = set((y,))
    for x in pset(myset - sy):
      if x not in r:
        r.extend([x, x|sy])
  return r

print(pset(set((1,2,3,4))))
#[set(), {1}, {2}, {1, 2}, {3}, {1, 3}, {2, 3}, {1, 2, 3}, {4}, 
# {1, 4}, {2, 4}, {1, 2, 4}, {3, 4}, {1, 3, 4}, {2, 3, 4}, {1, 2, 3, 4}]
</code></pre>
</div>
<span class="comment-copy">could you provide more context? exemplaric input and expected vs. actual output?</span>
<span class="comment-copy">capturing return value of <code>[s.add(x) for s in powerSetCopy]</code> definitely wrong. It will always be a list of <code>None</code>s. <code>s.add(x)</code> returns <code>None</code>.</span>
<span class="comment-copy">maybe related <a href="http://stackoverflow.com/questions/12632421/print-powerset-of-a-string">print powerset of a string</a></span>
<span class="comment-copy">@user2993016 there are quite a few mistakes in this code. e.g. <code>powerSet = powerSet.extend(withX)</code> will assign <code>None</code> to <code>powerSet</code>, as <code>extend</code> modifies in place and returns <code>None</code>. I recommend learning more about list manipulation in python.</span>
<span class="comment-copy">Note that that code in the docs is "roughly equivalent" to the source code of <code>itertools. combinations</code>, which is implemented in C, so it's more efficient than doing it in pure Python code.</span>
