<div class="post-text" itemprop="text">
<p>I have a simple Python class:</p>
<pre><code>class Car:
    self.dirty = False
    self.owner = 'Alice'
    self.wheels = []

    def __setattr__(self, name, value):
         self.dirty = True
         super(Car, self).__setattr__()
</code></pre>
<p>After some experimenting, I see <code>__setattr__</code> is called only when <em>setting</em> <code>owner</code> or <code>wheels</code>:</p>
<pre><code>car_instance.owner = 'Bob'
car_instance.wheels = []
</code></pre>
<p>It does not get called when <em>appending</em> to <code>wheels</code>:</p>
<pre><code>wheels.append(wheel_instance)
</code></pre>
<p>This does not surprise me, and I understand why it is not being called.</p>
<p><strong>I am just wondering how I would get it to be called for the 3 scenarios I listed:</strong></p>
<pre><code>car_instance.owner = 'Bob'     # SCENARIO 1
car_instance.wheels = []       # SCENARIO 2
wheels.append(wheel_instance)  # SCENARIO 3
</code></pre>
<p>I've experimented a bit with the different descriptors, but no luck. I ultimatley just want to set <code>dirty = True</code> when a class member is modified (set, reset, modified, appended to, etc.).</p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot do this using only descriptors. Full stop.</p>
<p>You have to provide a custom list class which does what you want. This is not too difficult if your custom list inherits <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer">collections.abc.MutableSequence</a>. As you can see, you can get away by "only" implementing <code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__len__</code>, <code>insert</code>—the others are filled in by the abstract base class <code>MutableSequence</code>.</p>
<p>Use a normal list as backing storage and implement the methods using that.</p>
<p>Note that the index argument to <code>__setitem__</code>, <code>__getitem__</code> and <code>__delitem__</code> can be a <a href="https://docs.python.org/3/reference/datamodel.html#index-64" rel="nofollow noreferrer">slice</a>, which are more tricky to implement than you’d expect. I recommend a tight test suite.</p>
<p>Once you have your list class, you use it as the type for your class’ attributes (you can control the type using <code>@property</code> or custom descriptors, by preventing the user from assigning any other type).</p>
</div>
<span class="comment-copy">I think you would need to put whatever side effect you want in a function that is called from both the <code>__get__</code> and <code>__set__</code> methods of the descriptor used for the attributes. However, there is no way (short of introspection on the code itself) to determine from inside <code>__get__</code> what is subsequently done with the object.</span>
