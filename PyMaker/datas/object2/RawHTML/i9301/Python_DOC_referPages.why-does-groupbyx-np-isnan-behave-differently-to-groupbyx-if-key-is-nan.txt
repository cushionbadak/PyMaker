<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/41723419/itertools-groupby-with-nans-gives-different-results-with-list-and-numpy-array">Since we're on the topic of peculiarities surrounding numpy's <code>nan</code></a>, I've discovered something that I don't understand either. I'm posting this question mainly as an extension of MSeifert's since it seems there might be a common reason for both of our observations.</p>
<p>Earlier on, <a href="https://stackoverflow.com/a/41722363/1636276">I posted a solution</a> that involves using <code>itertools.groupby</code> on a sequence containing <code>nan</code> values:</p>
<pre><code>return max((sum(1 for _ in group) for key, group in groupby(sequence) if key is nan), default=0)
</code></pre>
<p>However, I saw <a href="https://stackoverflow.com/a/41723561/1636276">this answer</a> on MSeifert's question linked above which shows an alternative way I might have formulated this algorithm:</p>
<pre><code>return max((sum(1 for _ in group) for key, group in groupby(sequence, np.isnan)), default=0)
</code></pre>
<p><strong>Experiment</strong></p>
<p>I've tested both of these variations with both lists and numpy arrays. The code and results are included below:</p>
<pre><code>from itertools import groupby

from numpy import nan
import numpy as np


def longest_nan_run(sequence):
    return max((sum(1 for _ in group) for key, group in groupby(sequence) if key is nan), default=0)


def longest_nan_run_2(sequence):
    return max((sum(1 for _ in group) for key, group in groupby(sequence, np.isnan)), default=0)


if __name__ == '__main__':
    nan_list = [nan, nan, nan, 0.16, 1, 0.16, 0.9999, 0.0001, 0.16, 0.101, nan, 0.16]
    nan_array = np.array(nan_list)

    print(longest_nan_run(nan_list))  # 3 - correct
    print(longest_nan_run_2(nan_list))  # 7 - incorrect
    print(longest_nan_run(nan_array))  # 0 - incorrect
    print(longest_nan_run_2(nan_array))  # 7 - incorrect
</code></pre>
<p><strong>Analysis</strong></p>
<ul>
<li>Of all four combinations, only checks against <strong>lists</strong> using the <strong>original</strong> function works as expected.</li>
<li>The <strong>modified</strong> function (using <code>np.isnan</code>) seems to work the <strong>same way</strong> for both lists and arrays.</li>
<li>The <strong>original</strong> function does not appear to find any <code>nan</code> values when checking <strong>arrays</strong>.</li>
</ul>
<p>Can anyone explain these results? Again, as this question is related to MSeifert's, it's possible that an explanation of his results would explain mine too (or vice versa).</p>
<hr/>
<p><strong>Further Investigation</strong></p>
<p>To get a better picture of what's happening, I tried printing out the groups generated by <code>groupby</code>:</p>
<pre><code>def longest_nan_run(sequence):
    print(list(list(group) for key, group in groupby(sequence) if key is nan))
    return max((sum(1 for _ in group) for key, group in groupby(sequence) if key is nan), default=0)


def longest_nan_run_2(sequence):
    print(list(list(group) for _, group in groupby(sequence, np.isnan)))
    return max((sum(1 for _ in group) for key, group in groupby(sequence, np.isnan)), default=0)
</code></pre>
<p>One fundamental difference (which in retrospect makes sense) is that the <strong>original</strong> function (using <code>if key is nan</code>) will filter out everything <em>except</em> <code>nan</code> values, so all generated groups will consist only of <code>nan</code> values, like this:</p>
<pre><code>[[nan, nan, nan], [nan]]
</code></pre>
<p>On the other hand, the <strong>modified</strong> function will group all non-<code>nan</code> values into their own groups, like this:</p>
<pre><code>[[nan, nan, nan], [0.16, 1.0, 0.16, 0.99990000000000001, 0.0001, 0.16, 0.10100000000000001], [nan], [0.16]]
</code></pre>
<p>This explains why the modified function returns <code>7</code> in both cases - it's considering values as either "<code>nan</code>" or "not <code>nan</code>" and returning the longest contiguous series of either.</p>
<p>This also means that I was wrong about my assumptions of how <code>groupby(sequence, keyfunc)</code> works, and that the modified function is not a viable alternative to the original.</p>
<p>I'm still not sure about the difference in results when running the original function on lists and arrays, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>Item access in numpy arrays behaves different than in lists:</p>
<pre><code>nan_list[0] == nan_list[1]
# False
nan_list[0] is nan_list[1]
# True

nan_array[0] == nan_array[1]
# False
nan_array[0] is nan_array[1]
# False

x = np.array([1])
x[0] == x[0]
# True
x[0] is x[0]
# False
</code></pre>
<p>While the list contains references to the same object, numpy arrays 'contain' only a region of memory and create new Python objects on the fly each time an element is accessed. (Thank you user2357112, for pointing out the inaccuracy in phrasing.)</p>
<p>Makes sense, right? Same object returned by the list, different objects returned by the array - obviously <code>groupby</code> internally uses <code>is</code> for comparison... But wait, it's not that easy! Why does <code>groupby(np.array([1, 1, 1, 2, 3]))</code> work correctly? </p>
<p>The answer is buried in the the <a href="http://svn.python.org/view/python/trunk/Modules/itertoolsmodule.c?view=markup" rel="nofollow noreferrer">itertools C source</a>, line 90 shows that the function <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool" rel="nofollow noreferrer"><code>PyObject_RichCompareBool</code></a> is used for comparing two keys.</p>
<pre><code>rcmp = PyObject_RichCompareBool(gbo-&gt;tgtkey, gbo-&gt;currkey, Py_EQ);
</code></pre>
<p>Although this is basically equivalent to using <code>==</code> in Python, the docs note one speciality:</p>
<blockquote>
<p><strong>Note</strong> If o1 and o2 are the same object, <code>PyObject_RichCompareBool()</code> will always return <code>1</code> for <code>Py_EQ</code> and <code>0</code> for <code>Py_NE</code>.</p>
</blockquote>
<p>This means that actually this comparison is performed (equivalent code):</p>
<pre><code>if o1 is o2:
    return True
else:
    return o1 == o2
</code></pre>
<p>So for lists, we have the same <code>nan</code> objects, which is identified as equal. In contrast, arrays give us different objects with value <code>nan</code>, which are compared with <code>==</code> - but <code>nan == nan</code> always evaluates as <code>False</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Alright, I think I've painted a clear enough picture for myself of what's going on.</p>
<p>There two factors at play here:</p>
<ul>
<li>My own misunderstanding of what the <code>keyfunc</code> argument did for <code>groupby</code>.</li>
<li>The (much more interesting) story of how Python represents <code>nan</code> values within arrays and lists, which is best explained in <a href="https://stackoverflow.com/a/41724043/1636276">this answer</a>.</li>
</ul>
<p><strong>Explaining the <code>keyfunc</code> factor</strong></p>
<p>From the <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">documentation on <code>groupby</code></a>:</p>
<blockquote>
<p>It generates a break or new group every time the value of the key function changes</p>
</blockquote>
<p>From the <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.isnan.html" rel="nofollow noreferrer">documentation on <code>np.isnan</code></a>:</p>
<blockquote>
<p>For scalar input, the result is a new boolean with value True if the input is NaN; otherwise the value is False.</p>
</blockquote>
<p>Based on these two things, we deduce that when we set <code>keyfunc</code> as <code>np.isnan</code>, each element in the sequence passed to <code>groupyby</code> will be mapped to either <code>True</code> or <code>False</code>, depending on whether it is a <code>nan</code> or not. This means that the key function will only change at the boundary between <code>nan</code> elements and non-<code>nan</code> elements, and therefore that <code>groupby</code> will only split the sequence into contiguous blocks of <code>nan</code> and non-<code>nan</code> elements.</p>
<p>In contrast, the <strong>original</strong> function (which used <code>groupby(sequence) if key is nan</code>) will use the <em>identity function</em> for <code>keyfunc</code> (its default value). This naturally leads into the nuances of <code>nan</code> identity which is explained below (and in the linked answer above), but the important point here is that the <code>if key is nan</code> will filter out all groups keyed on non-<code>nan</code> elements.</p>
<p><strong>Explaining nuances in <code>nan</code> identity</strong> </p>
<p>As better explained in the answer I linked above, all instances of <code>nan</code> that occur within Python's built-in lists seem to be <strong>one and the same instance</strong>. In other words, all occurrences of <code>nan</code> in lists point to the same place in memory. In contrast to this, <code>nan</code> elements are generated on the fly when using numpy arrays and so are all separate objects.</p>
<p>This is demonstrated using the code below:</p>
<pre><code>def longest_nan_run(sequence):
    print(id(nan))
    print([id(x) for x in sequence])
    return max((sum(1 for _ in group) for key, group in groupby(sequence) if key is nan), default=0)
</code></pre>
<p>When I run this using the <strong>list</strong> defined in the original question, I obtain this output (identical elements are highlighted):</p>
<pre>
<b>4436731128</b>
[<b>4436731128</b>, <b>44436731128</b>, <b>44436731128</b>, 4436730432, 4435753536, 4436730432, 4436730192, 4436730048, 4436730432, 4436730552, <b>44436731128</b>, 4436730432]
</pre>
<p>On the other hand, array elements seem to be handled in memory very differently:</p>
<pre>
4343850232
[<b>4357386696</b>, 4357386720, <b>4357386696</b>, 4357386720, <b>4357386696</b>, 4357386720, <b>4357386696</b>, 4357386720, <b>4357386696</b>,, 4357386720, <b>4357386696</b>, 4357386720]
</pre>
<p>The function seems to alternate between two separate locations in memory for storing these values. Notice that none of the elements are identical to the <code>nan</code> used in the filter condition.</p>
<h2>Case Studies</h2>
<p>We can now apply all this information we've gathered to the four separate cases used in the experiment to explain our observations.</p>
<p><strong>Original function with lists</strong></p>
<p>During this case, we use the default <code>identity</code> function as <code>keyfunc</code>, and we've seen that each occurrence of <code>nan</code> in lists are in fact all the same instance. The <code>nan</code> used in the filter conditional <code>if key is nan</code> is <em>also</em> identical to the <code>nan</code> elements in the list, causing <code>groupby</code> to break the list at appropriate places and only retain the groups containing <code>nan</code>. This is why this variant works and we obtain the correct result of <code>3</code>.</p>
<p><strong>Original function with arrays</strong></p>
<p>Again, we use the default <code>identity</code> function as <code>keyfunc</code>, but this time all <code>nan</code> occurrences - including the one in the filter conditional - point to different objects. This means that the conditional filter <code>if key is nan</code> will fail for <em>all</em> groups. Since we can't find the maximum of an empty collection, we fall back on the default value of <code>0</code>.</p>
<p><strong>Modified function with lists and arrays</strong></p>
<p>In both of these cases, we use <code>np.isnan</code> as <code>keyfunc</code>. This will cause <code>groupby</code> to split the sequence into contiguous sequences of <code>nan</code> and non-<code>nan</code> elements.</p>
<p>For the list/array we used for our experiment, the longest sequence of <code>nan</code> elements is <code>[nan, nan, nan]</code>, which has three elements, and the longest sequence of non-<code>nan</code> elements is <code>[0.16, 1, 0.16, 0.9999, 0.0001, 0.16, 0.101]</code>, which has 7 elements.</p>
<p><code>max</code> will select the longer of these two sequences and return <code>7</code> in both cases.</p>
</div>
<span class="comment-copy">"np.array contains different objects (with the same value)" - no, it doesn't contain objects at all. The objects are created on element access, so you'll even get False for <code>x[0] is x[0]</code>.</span>
<span class="comment-copy">@user2357112 that is correct.</span>
<span class="comment-copy">@kazemakase Thanks for your answer. :) I saw you post it as I was typing mine. Your answer provides details that mine doesn't and that I don't know about, so I'll be reading over it.</span>
<span class="comment-copy">@Tagc you are welcome. It was an interesting question to dig into. Don't forget to refresh the page - I have edited the answer to improve the narrative and to incorporate user23...'s comment.</span>
<span class="comment-copy">"all instances of nan that occur within Python's built-in lists seem to be one and the same instance" - nah, that's just because you used the specific <code>numpy.nan</code> object for all the nans in your list. If you'd, say, made separate <code>float('nan')</code> calls for each nan, you'd have gotten different objects.</span>
<span class="comment-copy">Also note that this already plays a role inside <code>groupby</code>. <code>list(groupby(nan_list))</code> gives different results than <code>list(groupby(nan_array))</code>.</span>
<span class="comment-copy">@user2357112 So it is correct to say that built-in lists will simply <i>point</i> to the objects used to construct them, whereas numpy arrays sort of treat them as "templates" and (e.g.) call <code>copy(x)</code> on each element 'x' as it accesses it?</span>
<span class="comment-copy">@Tagc: Lists always refer to the objects given as elements. NumPy arrays copy the numeric values directly into a non-object-oriented backing store and only construct objects to represent the elements if you try to retrieve them. (Unless you're using object arrays, which is usually a bad idea.)</span>
