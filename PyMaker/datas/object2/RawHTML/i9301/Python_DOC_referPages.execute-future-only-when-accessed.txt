<div class="post-text" itemprop="text">
<p>I would like to do something like the following:</p>
<pre><code>import asyncio

async def g():
    print('called g')
    return 'somevalue'

async def f():
    x = g()

loop = asyncio.get_event_loop()
loop.run_until_complete(f())
loop.close()
</code></pre>
<p>Where there is <em>no output</em>. Notice that I did not <code>await</code> the <code>g()</code>. This will generate a <code>g was not awaited</code> exception, but I'm looking for behaviour where <code>g</code> most definitely did <em>not</em> run.</p>
<p>This is useful for me where I have a long running operation with complex setup, but I only need its result in certain situations, so why bother running it when it is not needed. Kind of an 'on demand' situation.</p>
<p>How can I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>One option is to use simple flags to signal tasks:</p>
<pre><code>import asyncio

import random


async def g(info):
    print('&gt; called g')

    if not info['skip']:
        print('* running g', info['id'])
        await asyncio.sleep(random.uniform(1, 3))
    else:
        print('- skiping g', info['id'])

    print('&lt; done g', info['id'])

    return info['id']


async def main():
    data = [{
                'id': i,
                'skip': False
            } for i in range(10)]

    # schedule 10 tasks to run later
    tasks = [asyncio.ensure_future(g(info)) for info in data]

    # tell some tasks to skip processing
    data[2]['skip'] = True
    data[5]['skip'] = True
    data[6]['skip'] = True

    # wait for all results
    results = await asyncio.gather(*tasks)

    print(results)
    print("Done!")


loop = asyncio.get_event_loop()
loop.run_until_complete(main())
loop.close()
</code></pre>
<p>A different option would be using <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Future.cancel" rel="nofollow noreferrer"><code>task.cancel</code></a>:</p>
<pre><code>import asyncio


async def coro(x):
    print('coro', x)
    return x


async def main():
    task1 = asyncio.ensure_future(coro(1))
    task2 = asyncio.ensure_future(coro(2))
    task3 = asyncio.ensure_future(coro(3))

    task2.cancel()

    for task in asyncio.as_completed([task1, task2, task3]):
        try:
            result = await task
            print("success", result)
        except asyncio.CancelledError as e:
            print("cancelled", e)


loop = asyncio.get_event_loop()
loop.run_until_complete(main())
loop.close()
</code></pre>
</div>
<span class="comment-copy">Perhaps the person voting to close this could let me know what is unclear about the question. I want a future that does not start execution until accessed, and if I am using the wrong terminology it is a lack of knowledge not laziness ;)</span>
<span class="comment-copy">What about: <code>if condition: result = await x</code> ?</span>
<span class="comment-copy">Hi, it does work on windows. Not sure why you want to wait for <code>f</code> and not for <code>g</code>. If I were you, I would just return the "future" in that case, and cancel it when needed.</span>
<span class="comment-copy">I don't want to half-finish an operation (start and cancel it). I want to pass around a future, and then only when needed, run it. Sometimes it won't be needed at all, in which case I don't want it to even start.</span>
