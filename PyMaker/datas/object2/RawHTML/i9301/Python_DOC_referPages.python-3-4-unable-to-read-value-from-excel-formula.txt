<div class="post-text" itemprop="text">
<p>I try with Python 3.4 to get the value of cell C1 of an Excel file.
cell C1 is a formula:  =A1+B1.
Note: A1 and B1 value are changing, thus the return value in C1 has to change <strong>automatically</strong> accordingly.</p>
<p>In Python 3.4, I use following codes:</p>
<pre><code>import openpyxl
from openpyxl import Workbook

wb = openpyxl.load_workbook('test.xlsx')
sheet1 = wb['Sheet1']
C1Value = sheet1['C1'].value
print('C1: ', C1Value)
</code></pre>
<p>======</p>
<p>When running the python program, I obtain:
C1: =A1+B1</p>
<p>What I want to obtain is:</p>
<p>A1=1, B1=2 then 
C1: 3      (instead of C1: =A1+B1)</p>
<p>and
A1=10, B1=20 then automatically
C1: 30     (instead of C1: =A1+B1)</p>
<p>Any help, idea would be greatly appreciated. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>A very quick look on the <a href="https://openpyxl.readthedocs.io/en/default/" rel="nofollow noreferrer"><code>openpyxl</code> docs</a> and you might find <a href="https://openpyxl.readthedocs.io/en/default/usage.html#using-formulae" rel="nofollow noreferrer">this page</a> saying </p>
<blockquote>
<p>openpyxl never evaluates formula</p>
</blockquote>
<p>Before going any further, it should be noted that the possible duplicate links have answers pertaining to other modules, and these are usually the accepted answers. With those modules you don't have to implement your own parsing. Which can be anywhere from challenging to near impossible for more complex systems. </p>
<p>If you're doing pretty simple stuff, it's not terribly difficult with the <a href="https://openpyxl.readthedocs.io/en/default/formula.html#parsing-formulas" rel="nofollow noreferrer"><code>Tokenizer</code> class</a>. Usage:</p>
<pre><code>&gt;&gt;&gt; from openpyxl.formula import Tokenizer
&gt;&gt;&gt; tok = Tokenizer("""=IF($A$1,"then True",MAX(DEFAULT_VAL,'Sheet    2'!B1))""")
&gt;&gt;&gt; print("\n".join("%12s%11s%9s" % (t.value, t.type, t.subtype) for t in tok.items))
         IF(       FUNC     OPEN
        $A$1    OPERAND    RANGE
           ,        SEP      ARG
 "then True"    OPERAND     TEXT
           ,        SEP      ARG
        MAX(       FUNC     OPEN
 DEFAULT_VAL    OPERAND    RANGE
           ,        SEP      ARG
'Sheet 2'!B1    OPERAND    RANGE
           )       FUNC    CLOSE
           )       FUNC    CLOSE
</code></pre>
<p>Pay special attention, everything is a string, so evaluating formulas is best done with <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer"><code>eval()</code></a></p>
<p>So if you edited your code a bit (new/changed lines marked with <code>#</code>),</p>
<pre><code>import openpyxl
from openpyxl import Workbook
from openpyxl.formula import Tokenizer     #

wb = openpyxl.load_workbook('test.xlsx')
sheet1 = wb['Sheet1']
C1Formula = sheet1['C1'].value             #
C1Token = Tokenizer(C1Formula)             #
C1Value = handle_token(sheet1, C1Token)    #
print('C1: ', C1Value)
</code></pre>
<p>Where <code>handle_token()</code> is up to you for how complicated you wanted it. A couple simple and perhaps hack-y examples for <code>C1: =A1 + B1</code> and other binary operators: (<strong>these don't work for <code>^</code> as python uses that for bitwise <a href="https://en.wikipedia.org/wiki/Exclusive_or" rel="nofollow noreferrer">XOR</a></strong>)</p>
<pre><code>def handle_token(sheet, token):
    formula = ""
    for t in token.items:
        if t.type is 'OPERAND':
            formula += str(sheet[t.value])
        else:
            formula += str(t.value)
    return eval(formula)
</code></pre>
<p>Or if you prefer (this can be converted to a one-liner, not recommended) using a generator:</p>
<pre><code>def handle_token(sheet, token):
    parsed = str(sheet[t.value].value) if t.type is 'OPERAND' else t.value for t in token.items
    formula = "".join(parsed)
    return eval(formula)
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/q/28517508/1072229">Read Excel cell value and not the formula computing it -openpyxl</a></span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/41449712/openpyxl-error-could-not-convert-string-to-float">openpyxl error: "could not convert string to float"</a></span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/28517508/read-excel-cell-value-and-not-the-formula-computing-it-openpyxl">Read Excel cell value and not the formula computing it -openpyxl</a></span>
<span class="comment-copy">Many thanks Grisha..</span>
<span class="comment-copy">It work like a charm by using: wb = openpyxl.load_workbook('test.xlsx', data_only=True)</span>
