<div class="post-text" itemprop="text">
<p>Apologies as I'm sure this problem has come up before but none of the examples seem to apply.</p>
<p>I'm trying to create a 2D list (4 by 100) which assigns random values in different ranges in each row.</p>
<pre><code>import random
size_of_meadow = 100
no_of_flowers = 100
no_of_flower_types = 3

flower = [[0] * 5] * no_of_flowers

for row in range(no_of_flowers):
    flower[row][0] = random.randint(0, size_of_meadow - 1)  # x coord
    flower[row][1] = random.randint(0, size_of_meadow - 1)  # y coord
    flower[row][2] = random.randint(1, no_of_flower_types)
if random.randint(0, 100) &lt; 5:
    flower[row][3] = 1
else:
    flower[row][3] = 0

print(flower[0][0])
print(flower[0][1])
print(flower[0][2])
print(flower[0][3])
print(" ")
print(flower[1][0])
print(flower[1][1])
print(flower[1][2])
print(flower[1][3])
# Sorry the above isn't in a for loop
</code></pre>
<p>The outputs just show the same set of numbers for each row of the 2D list...</p>
<p>Output:</p>
<pre><code>29
21
2
0

29
21
2
0
</code></pre>
<p>I'm new to python and I know I must be missing something fundamental, but after a lot of umming and ahhing I haven't figured it out, any help is appreciated.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>You have one list that contains 100 times the same list</p>
<pre><code>a=[0,0,0]
flower=[a,a,a,a,...]
</code></pre>
<p>Better solution will be</p>
<pre><code>import random

size_of_meadow = 100
no_of_flowers = 100
no_of_flower_types = 3

flower = []

for row in range(no_of_flowers):
  flower.append([random.randint(0, size_of_meadow-1),
      random.randint(0, size_of_meadow-1),
      random.randint(1, no_of_flower_types),
      1 if random.randint(0, 100) &lt; 5 else 0])

print(flower[0][0])
print(flower[0][1])
print(flower[0][2])
print(flower[0][3])
print(" ")
print(flower[1][0])
print(flower[1][1])
print(flower[1][2])
print(flower[1][3])
# Sorry the above isn't in a for loop
</code></pre>
<p>However flower generator would be even better</p>
</div>
<div class="post-text" itemprop="text">
<p>By using <code>[[0] * 5] * no_of_flowers</code> you are creating 100 references to the same list. This means there is <strong>ONLY ONE ROW</strong> in the memory. </p>
<p>When you modify a row, if affects the row in memory, and since all other "rows" refer to it, they will simply use the list in memory which is up-to-date.</p>
<p><strong>To avoid this scenario, you could use:</strong></p>
<pre><code>flower = [[0 for _ in range(5)] for _ in range(no_of_flowers)]
</code></pre>
<p>===========================================================================</p>
<p>You could find an <a href="https://github.com/satwikkansal/wtfpython#-a-tic-tac-toe-where-x-wins-in-the-first-attempt" rel="nofollow noreferrer">example and explanation in wtfpython</a>:</p>
<pre><code># Let's initialize a row
row = [""]*3 #row i['', '', '']
# Let's make a board
board = [row]*3
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; board
[['', '', ''], ['', '', ''], ['', '', '']]
&gt;&gt;&gt; board[0]
['', '', '']
&gt;&gt;&gt; board[0][0]
''
&gt;&gt;&gt; board[0][0] = "X"
&gt;&gt;&gt; board
[['X', '', ''], ['X', '', ''], ['X', '', '']]
</code></pre>
<p><strong>Explanation:</strong></p>
<p>When we initialize <code>row</code> variable, this visualization explains what happens in the memory.</p>
<p><a href="https://i.stack.imgur.com/p0mv1.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/p0mv1.png"/></a></p>
<p>And when the <code>board</code> is initialized by multiplying the <code>row</code>, this is what happens inside the memory (each of the elements <code>board[0]</code>, <code>board[1]</code> and <code>board[2]</code> is a reference to the same list referred by <code>row</code>)</p>
<p><a href="https://i.stack.imgur.com/DNs8D.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/DNs8D.png"/></a></p>
<p>We can avoid this scenario here by not using <code>row</code> variable to generate <code>board</code>. (Asked in <a href="https://github.com/satwikkansal/wtfpython/issues/68" rel="nofollow noreferrer">this</a> issue).</p>
<pre><code>&gt;&gt;&gt; board = [['']*3 for _ in range(3)]
&gt;&gt;&gt; board[0][0] = "X"
&gt;&gt;&gt; board
[['X', '', ''], ['', '', ''], ['', '', '']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Hey @Lee has it correct but let me elaborate</p>
<pre><code>&gt;&gt;&gt; flower = [[0] * 5] * 100
&gt;&gt;&gt; flower[0]
[0, 0, 0, 0, 0]
&gt;&gt;&gt; flower[1]
[0, 0, 0, 0, 0]
&gt;&gt;&gt; id(flower[0])
4354853640
&gt;&gt;&gt; id(flower[1])
4354853640
</code></pre>
<p>Here you can see that each sub list will point to the same location in memory</p>
<p>I would use this method:</p>
<pre><code>flower = [[None for _ in range(5)] for _ in range(no_of_flowers)] 

&gt;&gt;&gt; id(flower[0])
4354853832
&gt;&gt;&gt; id(flower[1])
4354854600
</code></pre>
</div>
<span class="comment-copy"><code>print('\n'.join([''.join(['{} '.format(item) for item in row]) for row in flower]))</code> this might also be helpful</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/240178/list-of-lists-changes-reflected-across-sublists-unexpectedly">List of lists changes reflected across sublists unexpectedly</a></span>
<span class="comment-copy">This is great and produced the results I wanted. I'm still don't entirely understand the mistake I was making but will move forward using this method in future.</span>
<span class="comment-copy">That's what I was thinking, but why are all of them pointing to the same position? I actually expected [[0] * 5] * 100 to run the same way as your code.</span>
<span class="comment-copy">This answer produced the output I wanted from just changing the one line of code which is great.</span>
<span class="comment-copy">@epsilonmajorquezero when you run <code>[0] * 5</code> it creates one list <code>[0, 0, 0, 0, 0]</code> and then the <code>* 100</code> makes a list that has the sub list point to each 100 positions. The list comp actually re-runs in each iteration creating new elements</span>
<span class="comment-copy">@bison that made the problem really clear, thanks for the explanation</span>
<span class="comment-copy">Yeah, I see that's what it must be doing according to behaviour but then the behaviour is not really consistent: first [0] * 5 which creates a list of 5 zeroes (which are not the same location in memory) but then this list multiplied again does point to the same position.</span>
