<div class="post-text" itemprop="text">
<p>is there a way to get one level above or below directory from the one that is given?
For example '/a/b/c/' directory was entered in a function.</p>
<p>So function would return:</p>
<pre><code>lvl_down = '/a/b/'
lvl_up = '/a/b/c/d/'
</code></pre>
<p>I think you can do it using 're' module (at least with one level below directory), but maybe there is more simple and better way to do it without regex?</p>
</div>
<div class="post-text" itemprop="text">
<p>I have no idea, how the function should know, that you want to go in directory <em>d</em>:</p>
<pre><code>#!/usr/bin/python
import os.path

def lvl_down(path):
    return os.path.split(path)[0]

def lvl_up(path, up_dir):
    return os.path.join(path, up_dir)

print(lvl_down('a/b/c'))   # prints a/b
print(lvl_up('a/b/c','d')) # prints a/b/c/d
</code></pre>
<p>Note: Had another solution before, but os.path is a much better one.</p>
</div>
<div class="post-text" itemprop="text">
<p>Methods for manipulating paths can be found in the modules <code>os</code> and <code>os.path</code>.</p>
<p><a href="http://docs.python.org/3/library/os.path.html#os.path.join" rel="nofollow">os.path.join</a> - Join one or more path components intelligently.</p>
<p><a href="http://docs.python.org/3/library/os.path.html#os.path.split" rel="nofollow">os.path.split</a> - Split the pathname path into a pair, <code>(head, tail)</code> where <em>tail</em> is the last pathname component and <em>head</em> is everything leading up to that.</p>
<p><a href="http://docs.python.org/3/library/os.path.html#os.path.isdir" rel="nofollow">os.path.isdir</a> - Return <em>True</em> if path is an existing directory.</p>
<p><a href="http://docs.python.org/3/library/os.html#os.listdir" rel="nofollow">os.listdir</a> - Return a list containing the names of the entries in the directory given by <em>path</em>.</p>
<pre><code>def parentDir(dir):
    return os.path.split(dir)[0]

def childDirs(dir):
    possibleChildren = [os.path.join(dir, file) for file in os.listdir(dir)]
    return [file for file in possibleChildren if os.path.isdir(file)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all, if the path given ends in a slash, you should always remove it with a slice. With that said, here's how to get the parent directory of a path:</p>
<pre><code>&gt;&gt;&gt; import os.path
&gt;&gt;&gt; p = '/usr/local'
&gt;&gt;&gt; os.path.dirname(p)
'/usr'
</code></pre>
<p>To go down, just append the name to the variable like so:</p>
<pre><code>&gt;&gt;&gt; head = '/usr/local'
&gt;&gt;&gt; rest = 'include'
&gt;&gt;&gt; os.path.join(head, rest)
'/usr/local/include'
</code></pre>
</div>
<span class="comment-copy">Isn't there a choice of where to "<code>lvl_up</code>" (the child directories)?</span>
<span class="comment-copy">Wouldn't a solution involving the <code>os.path</code> module be a good idea?</span>
<span class="comment-copy">I thought the question was more about string operations.</span>
<span class="comment-copy">@SebastianWerk: yes, that's what <code>os.path</code> does.</span>
<span class="comment-copy">+1 for os.path; BTW Aren't your directions reverse? Up usually means parent directory</span>
<span class="comment-copy">Used the notation of the question. Thanks to Pedro and SilentGhost for os.path.</span>
<span class="comment-copy">Thanks for idea to remove last slash with slice (how I did not thought about that!:)). Anyway I tried it, but I don't get it why it still removes another slash too. I tried like this:      <code>a='/a/b/c/'      a=a[:-1]      print a      print os.path.split(a)[0]</code>  It returns: 'a/b'. Shouldn't it return 'a/b/'?</span>
<span class="comment-copy">I get it, so it always removes slash at the end. So I should add '/' after removing child directory? Or is there a better way to do that?</span>
<span class="comment-copy">Remove the slash once when taking input, if a slash exists. Call os.path.dirname() to get the parent directory. No need to add '/' if you use os.path.join() to join path segments. Read the Python online doc about these 2 methods.</span>
