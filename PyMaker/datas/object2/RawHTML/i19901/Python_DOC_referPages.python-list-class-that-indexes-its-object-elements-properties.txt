<div class="post-text" itemprop="text">
<p>I am looking for the best way to create a list in python that creates hashed indexes (dicts) for all the properties of the objects put into the list.</p>
<pre><code>&gt;&gt;&gt; foo = IndexingList([{ 'id': 1, 'name': 'cat' }, { 'id': 2, 'name': 'dog' }])
&gt;&gt;&gt; foo[0]
{'id': 1, 'name': 'cat'}

&gt;&gt;&gt; foo.findall('id', 2)
[{'id': 2, 'name': 'dog'}]

&gt;&gt;&gt; foo += {'id': 3, 'name': 'dog'}
&gt;&gt;&gt; foo.findall('name', 'dog')
[{'id': 2, 'name': 'dog'}, {'id': 3, 'name': 'dog'}]
</code></pre>
<p>I imagine the data structure of the IndexingList would then look like this:</p>
<pre><code>{
    'items': [
        { 'id': 1, 'name': 'cat' }, 
        { 'id': 2, 'name': 'dog' }
    ],
    'indexes': {
        'id': {
            1: [{ 'id': 1, 'name': 'cat' }],
            2: [{ 'id': 2, 'name': 'dog' }]
        },
        'name': {
            'cat': [{ 'id': 1, 'name': 'cat' }],
            'dog': [
                { 'id': 2, 'name': 'dog' },
                { 'id': 3, 'name': 'dog' }
            ]
        }
    }
}
</code></pre>
<p>where the objects within the 'indexes' nodes refer to the same objects in 'items'.</p>
<p>I think property values that are themselves objects could receive unique index-keys by using str(property) to obtain something to stick in 'indexes'.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is actually pretty easy to do using some <a href="http://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict()</code></a>s - although you might consider using an actual database if you are using this a lot.</p>
<pre><code>from collections import defaultdict
from functools import partial

class IndexingList:
    def __init__(self, items):
        self.items = []
        self.indices = defaultdict(partial(defaultdict, list))
        self.extend(items)

    def append(self, item):
        try:
            for index, value in item.items():
                self.indices[index][value].append(item)
        except AttributeError as e:
            raise ValueError("All children of an IndexingList must be "
                             "dict-like. '{0}' is not.".format(item)) from e
        self.items.append(item)

    def extend(self, iterable):
        for item in iterable:
            self.append(item)

    def __iadd__(self, other):
        self.extend(other)
        return self

    def __getitem__(self, item):
        return self.items[item]

    def __setitem__(self, item, value):
        self.items[item] = value

    def __delitem__(self, item):
        del self.items[item]
        for index, value in item.items():
            self.indices[index][value].remove(item)

    def find_all(self, index, value):
        return self.indices[index][value]

    def __repr__(self):
        return repr(self.items)
</code></pre>
<p>Used like so:</p>
<pre><code>&gt;&gt;&gt; foo = IndexingList([{ 'id': 1, 'name': 'cat' }, { 'id': 2, 'name': 'dog' }])
&gt;&gt;&gt; foo[0]
{'id': 1, 'name': 'cat'}
&gt;&gt;&gt; foo.find_all("id", 2)
[{'id': 2, 'name': 'dog'}]
&gt;&gt;&gt; foo += [{'id': 3, 'name': 'dog'}]
&gt;&gt;&gt; foo.find_all('name', 'dog')
[{'id': 2, 'name': 'dog'}, {'id': 3, 'name': 'dog'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I must say that Lattyware provides a really nice solution. I'll still provide my own quick and dirty approach, as when when indexing on unique items it's a simple one liner. Instead of building a nice wrapper container I sometimes create an index on a certain column:</p>
<pre><code>my_list = [('aap', 123), ('noot', 234), ('mies', 345), ('mies', 456)]
</code></pre>
<p>Provided the key in that column is unique and we don't add any new elements to the list nor modify the value we indexed on we may use:</p>
<pre><code>def mk_unique_index(data, col):
  g = ((elem[col], elem) for elem in data)
  return dict(g)
</code></pre>
<p>So we can use it like:</p>
<pre><code>&gt;&gt;&gt; idx = mk_unique_index(my_list, 1)
&gt;&gt;&gt; idx[123]
('aap', 123)
</code></pre>
<p>However, if we wish to index on the 0th column we must use a defaultdict</p>
<pre><code>from collections import defaultdict
def mk_index(data, col):
  d = defaultdict(list)
  for elem in data:
    d[elem[col]].append(elem)
  return d
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; idx = mk_index(my_list, 0)
&gt;&gt;&gt; idx['mies']
[('mies', 345), ('mies', 456)]
</code></pre>
<p>If instead of tuples you're using dictionaries or even named tuples (provided all elements have the field you're indexing on) you could just provide the field name for the column
Obviously one might also choose to use a temporary <a href="https://docs.python.org/2/library/sqlite3.html" rel="nofollow">sqlite</a> database in memory.</p>
</div>
<span class="comment-copy">Thank you for this beautiful simple code. Two follow up questions if you would not mind:   (1) Is there a specific reason you did not use a class signature of <code>class IndexingList(list)</code> and use e.g. <code>super(IndexingList, self).append(item)</code> instead of <code>self.items.append(item)</code>?   (2) Do you know of a way that modifications to the underlying properties of the contained elements could 'notify' the IndexingList to update its index accordingly? I actually don't need this for my use case, just curious if there is such a mechanism.  Apologies for this comment's lack of paragraph breaks.</span>
<span class="comment-copy">To the first, no particular reason, I just think this way is clearer and simpler - in Python we are not locked to a hard type hierarchy, so I don't see any real benefit to subclassing here (beyond speed, which isn't really a priority unless proven to be). As to the second, You could make your own dictionary object which did that notification, but you'd have to be careful about how it was used - I imagine it would remain somewhat fragile.</span>
