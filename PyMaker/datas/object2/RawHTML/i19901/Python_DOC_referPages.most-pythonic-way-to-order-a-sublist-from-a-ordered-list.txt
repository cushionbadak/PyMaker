<div class="post-text" itemprop="text">
<p>If I have sublist A: ['E','C', 'W'], what is the most pythonic way to order the sublist according to the order of master list M: ['C','B','W','E','K']</p>
<p>My solution is seems rather rudimentary. I am curious if there is a more 'pythonic' way to get the same result.</p>
<pre><code>ORDER = ['C','B','W','E','K']
possibilities = ['E','C', 'W']
possibilities_in_order = []

for x in ORDER:
    if x in possibilities: possibilities_in_order.append(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; order = ['C','B','W','E','K']
&gt;&gt;&gt; possibilities = ['E','C','W']
&gt;&gt;&gt; possibilities_in_order = sorted(possibilities, key=order.index)
&gt;&gt;&gt; possibilities_in_order
['C', 'W', 'E']
</code></pre>
<p>How this works: for each <code>element</code> in <code>possibilities</code>, <code>order.index(element)</code> is called, and the list is simply sorted by those respective positions.</p>
<p>More details: <a href="http://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer">Built-in Functions â†’ <code>sorted</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>possibilities.sort(key=lambda x : ORDER.index(x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a linear-time solution:</p>
<pre><code>posset = set(possibilities)
[letter for letter in order if letter in posset]
</code></pre>
<p>This filters the master list for only the members of the sublist. It's O(n) because it only traverses the master list once, and will perform well if the sublist is close in size to the master list.</p>
<p>This also assumes that <code>possibilities</code> has no duplicates. You can handle that if necessary, however, although it will make the code more complex.</p>
</div>
<span class="comment-copy">Man you guys are just too fast.</span>
<span class="comment-copy">Nice. This won't work if elements of <code>possibilities</code> can be repeated though. But I suppose they can't.</span>
