<div class="post-text" itemprop="text">
<p>I have a sample doctest like this one.</p>
<pre><code>"""
This is the "iniFileGenerator" module.
&gt;&gt;&gt; hintFile = "./tests/unit_test_files/hint.txt"
&gt;&gt;&gt; f = iniFileGenerator(hintFile)
&gt;&gt;&gt; print f.hintFilePath
./tests/unit_test_files/hint.txt
"""
class iniFileGenerator:
    def __init__(self, hintFilePath):
        self.hintFilePath = hintFilePath
    def hello(self):
        """
        &gt;&gt;&gt; f.hello()
        hello
        """
        print "hello"
if __name__ == "__main__":
    import doctest
    doctest.testmod()
</code></pre>
<p>When I execute this code, I got this error.</p>
<pre><code>Failed example:
    f.hello()
Exception raised:
    Traceback (most recent call last):
      File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/doctest.py", line 1254, in __run
        compileflags, 1) in test.globs
      File "&lt;doctest __main__.iniFileGenerator.hello[0]&gt;", line 1, in &lt;module&gt;
        f.hello()
    NameError: name 'f' is not defined
</code></pre>
<p>This error is caused by accessing 'f' which was not accessible when testing <code>hello()</code> method.</p>
<p>Is there any way to share the object which is created before? Without it, one need to create object all the time when it's necessary.</p>
<pre><code>def hello(self):
    """
    hintFile = "./tests/unit_test_files/hint.txt"
    &gt;&gt;&gt; f = iniFileGenerator(hintFile)
    &gt;&gt;&gt; f.hello()
    hello
    """
    print "hello"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>testmod(extraglobs={'f': initFileGenerator('')})</code> to define a reusable object globally.</p>
<p>As the <a href="http://docs.python.org/library/doctest.html#doctest.testmod" rel="noreferrer">doctest doc</a> says, </p>
<blockquote>
<p><em>extraglobs</em> gives a dict merged into the globals used to execute examples. This works like dict.update()</p>
</blockquote>
<p>But I used to test all methods in <code>__doc__</code> of class before all methods.</p>
<pre><code>class MyClass(object):
    """MyClass
    &gt;&gt;&gt; m = MyClass()
    &gt;&gt;&gt; m.hello()
    hello
    &gt;&gt;&gt; m.world()
    world
    """

    def hello(self):
        """method hello"""
        print 'hello'

    def world(self):
        """method world"""
        print 'world'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To obtain literate modules with tests that all use a shared execution context (i.e. individual tests that can share and re-use results), one has to look at the relevant part of <a href="https://docs.python.org/3/library/doctest.html#what-s-the-execution-context" rel="nofollow">documentation on the execution context</a>, which says:</p>
<blockquote>
<p>... each time <code>doctest</code> finds a docstring to test, it uses a <em>shallow</em> <strong>copy</strong> of <code>M</code>‘s globals, so that running tests doesn’t change the module’s real globals, and so that one test in <code>M</code> can’t leave behind crumbs that accidentally allow another test to work. </p>
<p>...</p>
<p>You can <strong>force use of <em>your own</em> dict</strong> as the execution context by passing <code>globs=your_dict</code> to <code>testmod()</code> or <code>testfile()</code> instead.</p>
</blockquote>
<p>Given this, <a href="https://gist.github.com/kernc/0dccae6542465d59a331" rel="nofollow">I managed to reverse-engineer</a> from <code>doctest</code> module that besides using copies (i.e. the <code>dict</code>'s <code>copy()</code> method), it also clears the globals dict (using <code>clear()</code>) after each test.</p>
<p>Thus, one can patch their own globals dictionary with something like:</p>
<pre><code>class Context(dict):
    def clear(self):
        pass
    def copy(self):
        return self 
</code></pre>
<p>and then use it as: </p>
<pre><code>import doctest
from importlib import import_module

module = import_module('some.module')
doctest.testmod(module,
                # Make a copy of globals so tests in this
                # module don't affect the tests in another
                glob=Context(module.__dict__.copy()))
</code></pre>
</div>
<span class="comment-copy"><a href="http://docs.python.org/library/doctest.html#what-s-the-execution-context" rel="nofollow noreferrer">docs.python.org/library/…</a></span>
<span class="comment-copy">just beat me to it, yep on extraglobs. Although I don't like the extraglobs approach, I like this answer less - some of the point of doctests are to document the methods, which you lose here.</span>
<span class="comment-copy">@Thomas After I checked the source code of some popular and well-documented projects, I think it is ok, <a href="http://nltk.org/_modules/nltk/align.html#Alignment" rel="nofollow noreferrer">nltk.org/_modules/nltk/align.html#Alignment</a></span>
<span class="comment-copy">Cool - I just like to see it in the docstrings so I can call help() on the method to see how it works instead of scrolling through the class docs.</span>
<span class="comment-copy">There may be <a href="http://stackoverflow.com/a/35242443/1090455">a more convenient approach</a>.</span>
