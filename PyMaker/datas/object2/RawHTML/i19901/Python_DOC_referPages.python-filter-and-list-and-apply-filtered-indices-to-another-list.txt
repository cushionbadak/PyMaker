<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Possible Duplicate:</strong><br/>
<a href="https://stackoverflow.com/questions/10274774/python-elegant-and-efficient-ways-to-mask-a-list">Python: Elegant and efficient ways to mask a list</a> </p>
</blockquote>
<p>I have two equal sized lists, something like:</p>
<pre><code>a=["alpha","beta","kappa","gamma","lambda"]
b=[1,2,None,3,4,5]
</code></pre>
<p>What I would like to do is identify and delete the none element in list [b] and then remove the corresponding element in list [a]. Here, for example, I would like to delete none and "kappa".</p>
<p>I am aware of:</p>
<p>filter(bool,b)</p>
<p>which would remove the None elements from [b], but, how do I go about deleting the corresponding entry in list[a]?</p>
<p>I tried zip, something like (the idea was to pack and unpack):</p>
<pre><code>a=["a","b","c","d","e"]
b=[1,2,None,3,4]
c=zip(a,b)
d=filter(bool,c)
</code></pre>
<p>..but this does not work. [d] still has the none elements.</p>
<p>I would appreciate any pythonic way to achieve this.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be done neatly with <a href="http://docs.python.org/3/library/itertools.html#itertools.compress" rel="noreferrer"><code>itertools.compress()</code></a> and a <a href="http://www.youtube.com/watch?v=pShL9DCSIUw" rel="noreferrer">list comprehension</a>:</p>
<pre><code>&gt;&gt;&gt; a=["a", "b", "c", "d", "e"]
&gt;&gt;&gt; b=[1, 2, None, 3, 4]
&gt;&gt;&gt; selectors = [x is not None for x in b]
&gt;&gt;&gt; list(itertools.compress(a, selectors))
['a', 'b', 'd', 'e']
&gt;&gt;&gt; list(itertools.compress(b, selectors))
[1, 2, 3, 4]
</code></pre>
<p>This method means you only generate the selectors once (and <code>itertools.compress()</code> should be nice and fast).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = [a[i] for i,v in enumerate(a) if b[i] is not None]
b = [x for x in b if x is not None]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just use a list comprehension and add that condition to the generator expression:</p>
<pre><code>&gt;&gt;&gt; a=["a","b","c","d","e"]
&gt;&gt;&gt; b=[1,2,None,3,4]

&gt;&gt;&gt; [x for x in zip(a,b) if x[1] is not None]
[('a', 1), ('b', 2), ('d', 3), ('e', 4)]

&gt;&gt;&gt; [x for x,m in zip(a,b) if m is not None]
['a', 'b', 'd', 'e']
</code></pre>
</div>
<span class="comment-copy">Actually, this answer does look more elegant - in that, the selector is generated only once and then reused twice.</span>
<span class="comment-copy">This is exactly what I was looking for. Very pythonic. So, now I use a=[a[i] for i,v in enumerate(a) if b[i] is not None] and b=filter(bool,b) which seems to yield the right result.</span>
<span class="comment-copy">Great! This is a basic solution, make sure you take the time to learn the tools mentioned in the other answers too, they are very powerful.</span>
<span class="comment-copy">@JamesW Note that <code>filter(bool, b)</code> will also remove any elements that evaluate to <code>False</code> - in your case, <code>0</code>, for example. As such, you are much better off with <code>[x for x in b if x is not None]</code> (which is also more readable), unless that is definitely the behavior your want.</span>
<span class="comment-copy">@Aesthete, Thanks again. I have another question: So, for [a] I use what you have suggested. But, for [b] I prefer to use the filter method. Do you think I should be using the filter method or the for loop as you have suggested: "b = [x for x in b if x is not None]"?</span>
<span class="comment-copy">@Lattyware, what you have said makes sense. How about if I use filter(None,b) - I think this is the same as [x for x in b if x is not None] right?</span>
<span class="comment-copy">I would argue it'd be nicer to unpack the tuple, rather than index on it.</span>
<span class="comment-copy">@Lattyware of course!</span>
