<div class="post-text" itemprop="text">
<p>I understand <code>str.join()</code>:</p>
<pre><code>&gt;&gt;&gt; '|'.join(['1','2','3'])
'1|2|3'
</code></pre>
<p>Is there something which outputs a list? Is there a function that will output:</p>
<pre><code>['1', '|', '2','|', '3']
</code></pre>
<p>That is, a <code>str.join()</code> for lists? (or any other iterable?)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>list('|'.join(['1','2','3']))
</code></pre>
<p>should do the trick where you are working with a list of chars.</p>
<p>A more generic solution, that works for all objects is:</p>
<pre><code>from itertools import izip_longest, chain

def intersperse(myiter, value):
    return list(
        chain.from_iterable(izip_longest(myiter, [], fillvalue=value))
    )[:-1]
</code></pre>
<p>I'm not aware of a built-in/std-library version of this function.</p>
<p>In action:</p>
<pre><code>print intersperse([1,2,3], '|')
</code></pre>
<p>outputs:</p>
<pre><code>[1, '|', 2, '|', 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this?</p>
<pre><code>&gt;&gt;&gt; list('|'.join(['1','2','3']))
['1', '|', '2', '|', '3']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = [1, 2, 'str', 'foo']
print [x for y in a for x in y, '|'][:-1]
# [1, '|', 2, '|', 'str', '|', 'foo']
</code></pre>
<p>For the general case, consider the <code>roundrobin</code> <a href="http://docs.python.org/2/library/itertools.html#recipes" rel="nofollow">itertools recipe</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This simple generator avoids building a list (faster, saves memory):</p>
<pre><code>def intersperse(iterable, element):
    iterable = iter(iterable)
    yield next(iterable)
    while True:
        next_from_iterable = next(iterable)
        yield element
        yield next_from_iterable
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; list(intersperse(['1', '2', '3'], '|'))
['1', '|', '2', '|', '3']
</code></pre>
</div>
<span class="comment-copy">The first only works if each string in the list is a single character. <code>list('|'.join(['ab', 'c'])) -&gt; 'a|b|c'</code> whereas <code>'ab|c'</code> makes more sense and is more consistent with <code>str.join</code>.</span>
<span class="comment-copy">@delnan good point, I've updated to reflect that</span>
<span class="comment-copy">@delnan, your first example actually produces <code>['a', 'b', '|', 'c']</code>, probably not what the OP wants either though</span>
<span class="comment-copy">I would argue that instead of <code>zip_longest()</code>, the clearer option is using <a href="http://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer"><code>itertools.repeat()</code></a> - <code>list(chain.from_iterable(zip(myiter, repeat(value))))[:-1]</code></span>
<span class="comment-copy">@Lattyware Sure, but if <code>myiter</code> is very large then the <code>izip</code> version would presumably use about half as much memory. Might be a little slower for reasonably-sized iterables though; probably not a huge difference either way.</span>
<span class="comment-copy">I assume he means something generic that works with any type of objects. obj0.join([obj1, obj2]) =&gt; [obj1, obj0, obj2]</span>
