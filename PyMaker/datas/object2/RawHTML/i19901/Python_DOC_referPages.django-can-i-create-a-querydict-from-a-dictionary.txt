<div class="post-text" itemprop="text">
<p>Imagine that I have a dictionary in my Django application:</p>
<pre><code>dict = {'a': 'one', 'b': 'two', }
</code></pre>
<p>Now I want to easily create an urlencoded list of GET parameters from this dictionary. Of course I could loop through the dictionary, urlencode keys and values and then concatenate the string by myself, but there must be an easier way. I would like to use a QueryDict instance. QueryDict is a subclass of dict, so it should be possible somehow.</p>
<pre><code>qdict = QueryDict(dict) # this does not actually work
print qdict.urlencode()
</code></pre>
<p>How would I make the second to last line work?</p>
</div>
<div class="post-text" itemprop="text">
<p>How about?</p>
<pre><code>from django.http import QueryDict
dict = {'a': 'one', 'b': 'two', }
qdict = QueryDict('', mutable=True)
qdict.update(dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python has a built in tool for encoding a dictionary (any mapping object) into a query string</p>
<pre><code>params = {'a': 'one', 'b': 'two', }

urllib.urlencode(params)

'a=one&amp;b=two'
</code></pre>
<p><a href="http://docs.python.org/2/library/urllib.html#urllib.urlencode" rel="nofollow noreferrer">http://docs.python.org/2/library/urllib.html#urllib.urlencode</a></p>
<p><code>QueryDict</code> takes a querystring as first param of its contstructor</p>
<p><code>def __init__(self, query_string, mutable=False, encoding=None):</code></p>
<p><code>q = QueryDict('a=1&amp;b=2')</code></p>
<p><a href="https://github.com/django/django/blob/master/django/http/request.py#L260" rel="nofollow noreferrer">https://github.com/django/django/blob/master/django/http/request.py#L260</a></p>
<p>Update: in <strong>Python3</strong>, urlencode has <a href="https://docs.python.org/3/library/urllib.parse.html" rel="nofollow noreferrer">moved to urllib.parse</a>:</p>
<pre><code>from urllib.parse import urlencode

params = {'a': 'one', 'b': 'two', }
urlencode(params)
'a=one&amp;b=two'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually a little indirect but more logical way to achieve this is using MultiValueDict.
This way multiple values per key can be stored in a QueryDict and .getlist method should then work fine.</p>
<pre><code>from django.http.request import QueryDict, MultiValueDict
dictionary = {'my_age': ['23'], 'my_girlfriend_age': ['25', '27'], }

qdict = QueryDict('', mutable=True)
qdict.update(MultiValueDict(dictionary))

print qdict.get('my_age')  # 23
print qdict['my_girlfriend_age']  # 27
print qdict.getlist('my_girlfriend_age')  # ['25', '27']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My solution works both for single and multiple key values:</p>
<pre><code>def dict_to_querydict(dictionary):
    from django.http import QueryDict
    from django.utils.datastructures import MultiValueDict

    qdict = QueryDict('', mutable=True)

    for key, value in dictionary.items():
        d = {key: value}
        qdict.update(MultiValueDict(d) if isinstance(value, list) else d)

    return qdict
</code></pre>
</div>
<span class="comment-copy">This does not work, because QueryDicts are immutable.</span>
<span class="comment-copy">Not according to the docs: <a href="https://docs.djangoproject.com/en/dev/ref/request-response/#django.http.QueryDict.update" rel="nofollow noreferrer">docs.djangoproject.com/en/dev/ref/request-response/â€¦</a></span>
<span class="comment-copy">should be <code>qdict = QueryDict('')</code>, and then this indeed works. Thank you.</span>
<span class="comment-copy">Thanx. Did not know the other approach. Cool.</span>
<span class="comment-copy">Instead of copying, you can create a mutable QueryDict straight away: <code>QueryDict('', mutable=True)</code></span>
<span class="comment-copy">m) it's so obvious in hindsight.</span>
<span class="comment-copy">Your answer is what I wanted, but not the exact answer for the question. Do you mind if accept the other answer, but create a new question where you can post this answer again?</span>
<span class="comment-copy">Hm..  Unlike the others, which only handle single values, this one requires value to be lists (it breaks strings into a list of characters).  Seems there's no simple way to handle both.</span>
