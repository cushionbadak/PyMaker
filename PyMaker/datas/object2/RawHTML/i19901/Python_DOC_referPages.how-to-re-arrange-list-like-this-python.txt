<div class="post-text" itemprop="text">
<p>For example, list <code>to_be</code> consists of: 3 of <code>"a"</code>, 4 of <code>"b"</code>, 3 of <code>"c"</code>, 5 of <code>"d"</code>...</p>
<pre><code>to_be = ["a", "a", "a", "b", "b", "b", "b", "c", "c", "c", "d", "d", "d", "d", "d", ...]
</code></pre>
<p>Now I want it to be like this:</p>
<pre><code>done = ["a", "b", "c", "d", ... , "a", "b", "c", "d", ... , "b", "d", ...] (notice: some items are more than others as in amounts, but they need to be still in a pre-defined order, alphabetically for example)
</code></pre>
<p>What's the fastest way to do this? </p>
</div>
<div class="post-text" itemprop="text">
<p>Presuming I am understanding what you want, it can be done relatively easily by combining <a href="http://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="noreferrer"><code>itertools.zip_longest</code></a>, <a href="http://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer"><code>itertools.groupby</code></a> and <a href="http://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>itertools.chain.from_iterable()</code></a>:</p>
<p>We first group the items into sets (the <code>"a"</code>s, the <code>"b"</code>s, etc...), we zip them up to get them in the order your want (one from each set), use chain to produce a single list, and then remove the <code>None</code> values introduced by the zipping.</p>
<pre><code>&gt;&gt;&gt; [item for item in itertools.chain.from_iterable(itertools.zip_longest(*[list(x) for _, x in itertools.groupby(to_be)])) if item]
['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'd', 'd']
</code></pre>
<p>You may want to separate out some of the <a href="http://www.youtube.com/watch?v=pShL9DCSIUw" rel="noreferrer">list comprehensions</a> to make it a bit more readable, however:</p>
<pre><code>&gt;&gt;&gt; groups = itertools.zip_longest(*[list(x) for _, x in itertools.groupby(to_be)])
&gt;&gt;&gt; [item for item in itertools.chain.from_iterable(groups) if item]
['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'd', 'd']
</code></pre>
<p>(The given version is for 3.x, for 2.x, you will want <a href="http://docs.python.org/2/library/itertools.html#itertools.izip_longest" rel="noreferrer"><code>izip_longest()</code></a>.)</p>
<p>As always, if you expect empty strings, 0, etc... then you will want to do <code>if item is not None</code>, and if you need to keep <code>None</code> values in tact, create a sentinel object and check for identity against that.</p>
<p>You could also use <a href="http://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer">the <code>roundrobin()</code> recipe</a> given in the docs, as an alternative to zipping, which makes it as simple as:</p>
<pre><code>&gt;&gt;&gt; list(roundrobin(*[list(x) for _, x in itertools.groupby(to_be)]))
['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'd', 'd']
</code></pre>
<p>As a final note, the observant might note me making lists from the <code>groupby()</code> generators, which may seem wasteful, the reason comes from <a href="http://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer">the docs</a>:</p>
<blockquote>
<p>The returned group is itself an iterator that shares the underlying
  iterable with groupby(). Because the source is shared, when the
  groupby() object is advanced, the previous group is no longer visible.
  So, if that data is needed later, it should be stored as a list.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>to_be = ["a", "a", "a", "b", "b", "b", "b", "c", "c", "c", "d", "d", "d", "d", "d"]
counts = collections.Counter(to_be)
answer = []
while counts:
    answer.extend(sorted(counts))
    for k in counts:
        counts[k] -= 1
    counts = {k:v for k,v in counts.iteritems() if v&gt;0}
</code></pre>
<p>Now, <code>answer</code> looks like this:</p>
<pre><code>['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'd', 'd']
</code></pre>
<p>Hope this helps</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure if this is fastest, but here's my stab at it:</p>
<pre><code>&gt;&gt;&gt; d = defaultdict(int)
&gt;&gt;&gt; def sort_key(a):
...     d[a] += 1
...     return d[a],a
...

&gt;&gt;&gt; sorted(to_be,key=sort_key)
['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'd', 'd']
</code></pre>
<p>wrapped up in a function:</p>
<pre><code>def weird_sort(x):
    d = defaultdict(int)
    def sort_key(a):
        d[a] += 1
        return (d[a],a)
    return sorted(x,key=sort_key)
</code></pre>
<p>Of course, this requires that the elements in your iterable be hashable.</p>
</div>
<div class="post-text" itemprop="text">
<p>A bit less elegant than Lattyware's:</p>
<pre><code>import collections
def rearrange(l):
    counts = collections.Counter(l)
    output = []
    while (sum([v for k,v in counts.items()]) &gt; 0):
        output.extend(sorted([k for k, v in counts.items() if v &gt; 0))
        for k in counts:
            counts[k] = counts[k] - 1 if counts[k] &gt; 0 else 0
    return counts
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Doing it "by hand and state machinne" should be way more efficient - 
but for relatively small lists (&lt;5000), you should have no problem taking vantage of 
Python goodies doing this:</p>
<pre><code>to_be = ["a", "a", "a", "b", "b", "b", "b", "c", "c", "c", "d", "d", "d", "d", "d","e", "e"]


def do_it(lst):
    lst = lst[:]
    result = []

    while True:
        group = set(lst)
        result.extend(sorted(group))
        for element in group:
            del lst[lst.index(element)]
        if not lst:
            break
    return result

done = do_it(to_be)
</code></pre>
<p>The "big O" complexity of the function above should be really BIG. I had not event ried to figure it out.</p>
</div>
<span class="comment-copy">You want to remove every item that is equal to his predecessor?</span>
<span class="comment-copy">Try the <code>Counter</code> <a href="http://docs.python.org/2/library/collections.html" rel="nofollow noreferrer">collection</a>.</span>
<span class="comment-copy">Way more elegant than my solution. Kudos!</span>
<span class="comment-copy">Those few moments in S.O. one wish it was possible to give more than one upvote to a single answer</span>
<span class="comment-copy">+1 for the roundrobin suggestion. That iterator recipes section in general is worth poring over.</span>
<span class="comment-copy"><code>itertools</code> answers roughly 90% of Python SO questions. Most questions have a relevant recipe somewhere in that list. And it's always nice when it's possible to pull out a (relatively) simple one or two line answer to a problem.</span>
