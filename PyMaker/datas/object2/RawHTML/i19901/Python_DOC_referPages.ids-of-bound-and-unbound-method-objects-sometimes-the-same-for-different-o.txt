<div class="post-text" itemprop="text">
<p>I've tried some code about bound and unbound methods. When we call them, I think both of them would return objects. But when I use <code>id()</code> for getting some information, it returns something I don't understand.</p>
<p>IDE: Eclipse</p>
<p>Plugin: pydev</p>
<pre><code>Class C(object):
    def foo(self):
        pass

cobj = C()

print id(C.foo)    #1
print id(cobj.foo) #2

a = C.foo
b = cobj.foo

print id(a)        #3
print id(b)        #4
</code></pre>
<p>And the output is...</p>
<pre><code>5671672

5671672

5671672

5669368
</code></pre>
<p>Why do #1 and #2 return the same id? Aren't they different objects? And if we assign <code>C.foo</code> and <code>conj.foo</code> to two variables, #3 and #4 return the different id.</p>
<p>I think #3 and #4 show that they are not the same object, but #1 and #2...</p>
<p>What is the difference between the id of bound method, and an unbound method?</p>
</div>
<div class="post-text" itemprop="text">
<p>Whenever you look up a method via <code>instance.name</code> (and in Python 2, <code>class.name</code>), the method object is created a-new. Python uses the <a href="http://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">descriptor protocol</a> to wrap the function in a method object each time.</p>
<p>So, when you look up <code>id(C.foo)</code>, a new method object is created, you retrieve its id (a memory address), then <em>discard the method object again</em>. Then you look up <code>id(cobj.foo)</code>, a new method object created that re-uses the now freed memory address and you see the same value. The method is then, again, discarded (garbage collected as the reference count drops to 0).</p>
<p>Next, you stored a reference to the <code>C.foo</code> unbound method in a variable. Now the memory address is not freed (the reference count is 1, instead of 0), and you create a <em>second</em> method instance by looking up <code>cobj.foo</code> which has to use a new memory location. Thus you get two different values.</p>
<p>See the <a href="http://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">documentation for <code>id()</code></a>:</p>
<blockquote>
<p>Return the “identity” of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. <strong><em>Two objects with non-overlapping lifetimes may have the same <code>id()</code> value</em></strong>.</p>
<p><strong>CPython implementation detail</strong>: This is the address of the object in memory.</p>
</blockquote>
<p>Emphasis mine.</p>
<p>You can re-create a method using a direct reference to the function via the <code>__dict__</code> attribute of the class, then calling the <a href="http://docs.python.org/2/reference/datamodel.html#object.__get__" rel="nofollow noreferrer"><code>__get__</code> descriptor method</a>:</p>
<pre><code>&gt;&gt;&gt; class C(object):
...     def foo(self):
...         pass
... 
&gt;&gt;&gt; C.foo
&lt;unbound method C.foo&gt;
&gt;&gt;&gt; C.__dict__['foo']
&lt;function foo at 0x1088cc488&gt;
&gt;&gt;&gt; C.__dict__['foo'].__get__(None, C)
&lt;unbound method C.foo&gt;
&gt;&gt;&gt; C.__dict__['foo'].__get__(C(), C)
&lt;bound method C.foo of &lt;__main__.C object at 0x1088d6f90&gt;&gt;
</code></pre>
<p>Note that in Python 3, the whole unbound / bound method distinction has been dropped; you get a function where before you'd get an unbound method, and a method otherwise, where a method is <em>always</em> bound:</p>
<pre><code>&gt;&gt;&gt; C.foo
&lt;function C.foo at 0x10bc48dd0&gt;
&gt;&gt;&gt; C.foo.__get__(None, C)
&lt;function C.foo at 0x10bc48dd0&gt;
&gt;&gt;&gt; C.foo.__get__(C(), C)
&lt;bound method C.foo of &lt;__main__.C object at 0x10bc65150&gt;&gt;
</code></pre>
<p>Furthermore, Python 3.7 adds a new <a href="https://docs.python.org/3.7/library/dis.html#opcode-LOAD_METHOD" rel="nofollow noreferrer"><code>LOAD_METHOD</code></a> - <a href="https://docs.python.org/3.7/library/dis.html#opcode-CALL_METHOD" rel="nofollow noreferrer"><code>CALL_METHOD</code></a> opcode pair that replaces the current <code>LOAD_ATTRIBUTE</code> - <code>CALL_FUNCTION</code> opcode pair precisely to avoid creating a new method object each time. This optimisation transforms the executon path for <code>instance.foo()</code> from <code>type(instance).__dict__['foo'].__get__(instance, type(instance))()</code> with <code>type(instance).__dict__['foo'](instance)</code>, so 'manually' passing in the instance directly to the function object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Adding to @Martijn Pieters's very good <a href="https://stackoverflow.com/a/13348193/846892">answer</a>:</p>
<pre><code>In [1]: class C(object):
   ...:     def foo(self):
   ...:         pass
   ...:

In [2]: c = C()

In [3]: id(c.foo), id(C.foo)
Out[3]: (149751844, 149751844)  # so 149751844 is current free memory address

In [4]: a = c.foo  # now 149751844 is assigned to a

In [5]: id(a)              
Out[5]: 149751844

# now python will allocate some different address to c.foo and C.foo     

In [6]: id(c.foo), id(C.foo)    # different address used this time, and
Out[6]: (149752284, 149752284)  # that address is freed after this step

# now 149752284 is again free, as it was not allocated to any variable

In [7]: b = C.foo  # now 149752284 is allocated to b    

In [8]: id(b)
Out[8]: 149752284                

In [9]: c.foo is C.foo  # better use `is` to compare objects, rather than id()
Out[9]: False
</code></pre>
</div>
<span class="comment-copy">+1 never knew about the memory address thing.</span>
<span class="comment-copy">@AshwiniChaudhary: It's an implementation detail of CPython; other python implementations probably use a different value for <code>id()</code>.</span>
<span class="comment-copy">@eryksun: My point was to illustrate <i>how</i> python creates the method in the first place; to show that it is not created once for a class then retrieved each time. Using <code>types.MethodType()</code> would defeat that purpose.</span>
<span class="comment-copy">@Vinny: because Python is highly dynamic. <code>instance.method()</code> can result to a completely different function object from one call to the next.</span>
<span class="comment-copy">@Vinny: Python 3.7 does now avoid actually creating the method object in the most common cases thanks to <a href="https://meta.stackoverflow.com/questions/365920/unable-to-recover-account-after-suspension-period">two new bytecodes</a>; this applies when there is an attribute lookup with a call directly following in the same expression. I already cover that in my answer here.</span>
