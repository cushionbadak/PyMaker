<div class="post-text" itemprop="text">
<p>I've been reading about magic methods in python, and I've found a lot of info about overriding them   and what purpose they serve, but I haven't been able to find where in the language specific operators and actions are mapped to those methods (<code>+</code> looks for <code>__add__</code>, <code>+=</code> looks for <code>__iadd__</code>, creating a new object from a class might call <code>__new__</code> and <code>__init__</code>, etc.)  Is there somewhere I can see what happens when the python interpreter (or whatever lower level mechanism) encounters a plus sign?  </p>
</div>
<div class="post-text" itemprop="text">
<p>Your question is a bit generic. There is a comprehensive <a href="http://docs.python.org/2/reference/datamodel.html#specialnames" rel="nofollow">list</a> of "special methods", even though it misses some stdlib specific methods(e.g. <code>__setstate__</code> and <code>__getstate__</code> used by <code>pickle</code> etc. But it's a protocol of the module <code>pickle</code> not a language protocol).</p>
<p>If you want to know exactly what the interpreter does you can use the <code>dis</code> module to disassemble the bytecode:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def my_func(a):
...     return a + 2
... 
&gt;&gt;&gt; dis.dis(my_func)
  2           0 LOAD_FAST                0 (a)
              3 LOAD_CONST               1 (2)
              6 BINARY_ADD          
              7 RETURN_VALUE   
</code></pre>
<p>You can see that the intereper executes a <code>BINARY_ADD</code> byte code when doing addition.
If you want to see exactly the operations that <code>BINARY_ADD</code> does you can download Python's source code and check the <code>ceval.c</code> file:</p>
<pre><code>    case BINARY_ADD:
        w = POP();
        v = TOP();
        if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
            /* INLINE: int + int */
            register long a, b, i;
            a = PyInt_AS_LONG(v);
            b = PyInt_AS_LONG(w);
            /* cast to avoid undefined behaviour
               on overflow */
            i = (long)((unsigned long)a + b);
            if ((i^a) &lt; 0 &amp;&amp; (i^b) &lt; 0)
                goto slow_add;
            x = PyInt_FromLong(i);
        }
        else if (PyString_CheckExact(v) &amp;&amp;
                 PyString_CheckExact(w)) {
            x = string_concatenate(v, w, f, next_instr);
            /* string_concatenate consumed the ref to v */
            goto skip_decref_vx;
        }
        else {
          slow_add:
            x = PyNumber_Add(v, w);
        }
        Py_DECREF(v);
      skip_decref_vx:
        Py_DECREF(w);
        SET_TOP(x);
        if (x != NULL) continue;
        break;
</code></pre>
<p>So here we can see that python special cases int and string additions, and eventually falls back to <code>PyNumber_Add</code>, which checks if the first operand implements <code>__add__</code> and calls it, eventually it tries <code>__radd__</code> of the right hand side and if nothing works raises a <code>TypeError</code>.</p>
<p>Note that the byte codes are version-specific, so <code>dis</code> will show different results on different versions:</p>
<pre><code># python2.7
&gt;&gt;&gt; def my_func():
...     return map((lambda x: x+1), range(5))
... 
&gt;&gt;&gt; dis.dis(my_func)
  2           0 LOAD_GLOBAL              0 (map)
              3 LOAD_CONST               1 (&lt;code object &lt;lambda&gt; at 0x16f8c30, file "&lt;stdin&gt;", line 2&gt;)
              6 MAKE_FUNCTION            0
              9 LOAD_GLOBAL              1 (range)
             12 LOAD_CONST               2 (5)
             15 CALL_FUNCTION            1
             18 CALL_FUNCTION            2
             21 RETURN_VALUE        
# python3
&gt;&gt;&gt; dis.dis(my_func)
  2           0 LOAD_GLOBAL              0 (map) 
              3 LOAD_CONST               1 (&lt;code object &lt;lambda&gt; at 0x7f1161a76930, file "&lt;stdin&gt;", line 2&gt;) 
              6 LOAD_CONST               2 ('my_func.&lt;locals&gt;.&lt;lambda&gt;') 
              9 MAKE_FUNCTION            0 
             12 LOAD_GLOBAL              1 (range) 
             15 LOAD_CONST               3 (5) 
             18 CALL_FUNCTION            1 (1 positional, 0 keyword pair) 
             21 CALL_FUNCTION            2 (2 positional, 0 keyword pair) 
             24 RETURN_VALUE  
</code></pre>
<p>Also the same byte code may be optimized in future versions, so even if the byte code is the same different versions of python will actually perform different instructions.</p>
<p>If you're interested in learning how python works behind the scenes I'd advise you to write some C extensions, following the tutorials and documentation that you can find on the official python's website.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/dis.html" rel="nofollow"><code>dis</code></a> module can somewhat help you on this:</p>
<p>let's take an example of simple list:</p>
<pre><code>In [12]: def func():
    lis=[1,2,3]
    for i in range(5):
        lis+=[i]
   ....:         

In [13]: def func1():
    lis=[1,2,3]
    for i in range(5):
        lis =lis + [i]
   ....:         

In [14]: dis.dis(func)
  2           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (2)
              6 LOAD_CONST               3 (3)

             #removed some lines of code

  4          34 LOAD_FAST                0 (lis)
             37 LOAD_FAST                1 (i)
             40 BUILD_LIST               1
             43 INPLACE_ADD                       # += means inplace add is used
                                                  #     i.e `__iadd()__`
             44 STORE_FAST               0 (lis)
             47 JUMP_ABSOLUTE           28
        &gt;&gt;   50 POP_BLOCK           
        &gt;&gt;   51 LOAD_CONST               0 (None)
             54 RETURN_VALUE        

In [15]: dis.dis(func1)
  2           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (2)
              6 LOAD_CONST               3 (3)
              9 BUILD_LIST               3
             12 STORE_FAST               0 (lis)
             #removed some lines of code    
  4          34 LOAD_FAST                0 (lis)
             37 LOAD_FAST                1 (i)
             40 BUILD_LIST               1
             43 BINARY_ADD                          #normal binary add was used
                                                    #i.e __add__
             44 STORE_FAST               0 (lis)
             47 JUMP_ABSOLUTE           28
        &gt;&gt;   50 POP_BLOCK           
        &gt;&gt;   51 LOAD_CONST               0 (None)
             54 RETURN_VALUE        
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's non-trivial to pinpoint the single place in CPython sources mapping operator <code>+</code> to special method <code>__add__</code> because of the levels of abstraction involved.</p>
<p>As other responded, <code>+</code> is implemented with the <code>BINARY_ADD</code> operand, which calls <code>PyNumber_Add</code> (except for some specially optimizedd cases). <code>PyNumber_Add</code>, on the other hand, looks at the <a href="http://docs.python.org/2.7/c-api/typeobj.html#tp_as_number" rel="nofollow"><code>tp_as_number</code> member</a> of the <a href="http://docs.python.org/2.7/c-api/typeobj.html" rel="nofollow">type object</a> to get to the <a href="http://docs.python.org/2.7/c-api/typeobj.html#number-object-structures" rel="nofollow"><code>PyNumberMethods</code></a> struct whose <code>nb_add</code> member points to the C function that implements addition.</p>
<p>This is all clear for built-in types which <a href="http://hg.python.org/cpython/file/13b74c0b040c/Objects/intobject.c#l457" rel="nofollow">define</a> <a href="http://hg.python.org/cpython/file/13b74c0b040c/Objects/floatobject.c#l626" rel="nofollow">their own</a> <code>nb_add</code>, but how does your <code>__add__</code>, defined in Python, translate to a function pointer stored in <code>nb_add</code>? This part is handled by <code>typeobject.c</code>: when you define a class that implements <code>__add__</code>, the machinery in <code>typeobject.c</code> <a href="http://hg.python.org/cpython/file/13b74c0b040c/Objects/typeobject.c#l6400" rel="nofollow">installs</a> into <code>object-&gt;type-&gt;tp_as_number-&gt;nb_add</code> a generic function that looks up <code>__add__</code> on the object and calls it to implement the addition. For the case of <code>__add__</code>, this generic function is called <code>slot_nb_add</code> and is <a href="http://hg.python.org/cpython/file/13b74c0b040c/Objects/typeobject.c#l5110" rel="nofollow">defined</a> using the <a href="http://hg.python.org/cpython/file/13b74c0b040c/Objects/typeobject.c#l4888" rel="nofollow"><code>SLOT1BIN</code> macro</a>.</p>
<p>As for <code>__new__</code> and <code>__init__</code>, they are invoked <a href="http://hg.python.org/cpython/file/13b74c0b040c/Objects/typeobject.c#l713" rel="nofollow">from the <code>__call__</code> operator of the <code>type</code> object</a> itself (<code>tp_call</code> in CPython-implementation lingo). This is only logical, since in Python you are calling the type to construct an object.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/dis.html" rel="nofollow">http://docs.python.org/2/library/dis.html</a></p>
<pre><code>class x:
     def __add__(self,other):
          return "asd"

def test():
     return x() + "aaaa"



import dis
dis.dis(test)
</code></pre>
<p>which returns something like </p>
<pre><code>  2           0 LOAD_GLOBAL              0 (x)
              3 CALL_FUNCTION            0
              6 LOAD_CONST               1 ('aaaa')
              9 BINARY_ADD
             10 RETURN_VALUE
</code></pre>
<p>thats the closest you will come to "low level"</p>
</div>
<div class="post-text" itemprop="text">
<p>You may want to check out this portion of the documentation:</p>
<p><a href="http://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow">http://docs.python.org/3/reference/datamodel.html#special-method-names</a></p>
</div>
<span class="comment-copy">hehe ... great minds think alike ;)</span>
<span class="comment-copy">Yes, but this is no way implies that <code>_iadd_</code> would be called for +=, the least I came across is <a href="http://www.python.org/dev/peps/pep-0203/" rel="nofollow noreferrer">PEP 203</a></span>
<span class="comment-copy">this is really cool to check out, but I guess I was hoping for the mapping of BINARY_ADD to <code>__add__</code></span>
<span class="comment-copy">@Abhijit <a href="http://stackoverflow.com/questions/9766387/different-behaviour-for-list-iadd-and-list-add" title="different behaviour for list iadd and list add">stackoverflow.com/questions/9766387/â€¦</a>, += is actually equivalent to <code>append()</code> in lists , which eventually calls <code>__iadd__()</code>.</span>
<span class="comment-copy">@AshwiniChaudhary: The accepted answer was quoted from PEP 203, which is what I said, the closest you can get. Dis, would not be helpful here</span>
