<div class="post-text" itemprop="text">
<p>Hi. I was wondering if there is a way to add items into a list recursively. The function is supposed to print the path names of the file that matches with fname. So fname is the name of the file and the path is the folder in which the file is located. If there are folders inside the path folder it will go inside and look for the fname file. so far I am able to find all the files. But I am not able to append the list recursively.</p>
<pre><code>def findAll(fname, path): 
 lst= []
 for item in os.listdir(path):
        n = os.path.join(path, item)
    try:
        if item == fname:
            lst.append(n)
    except:
        findAll(fname,n)
return lst
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Normally, I wouldn't give a full solution because this smells like homework (which is also why I'm avoiding <code>os.walk</code>), but since you have posted your attempt, here's an explanation and a solution:</p>
<p>For one thing, every time you call <code>findAll</code>, you initialize <code>lst</code>. Sure, you return it at the end, but you don't do anything with the return value, so the effect <code>lst.append</code> is contained within the recursion and is therefore not visible outside. Let me try to draw diagram to explain this (with one level of recursion):</p>
<pre><code>+--------------------------------------------------+
|Outer Level:                                      |
|                                                  |
|`lst = []`                                        |
|found file f1 with name fname                     |
|`lst.append(f1)`                                  |
|+------------------------------------------------+|
||Inner Level                                     ||
||                                                ||
||`lst=[]`                                        ||
||found file f2 with name fname                   ||
||`lst.append(f2)`                                ||
||`return lst`                                    ||
|+------------------------------------------------+|
|a list is returned from recursive call,           |
|but not assigned to a variable.                   |
|Therefore, `lst` remains unchanged                |
+--------------------------------------------------+
</code></pre>
<p>There are a couple of ways by which you can fix this:</p>
<ol>
<li>move <code>lst</code> to a scope outside <code>findAll</code> (personally, this is what I would do)</li>
<li>use the return value from the recursive call to modify <code>lst</code></li>
</ol>
<p><strong>move <code>lst</code> to a scope outside <code>findAll</code></strong></p>
<pre><code>lst= []
def findAll(fname, path): 
    global lst
    for item in os.listdir(path):
        n = os.path.join(path, item)
        try: # really though, you don't need to use try/except here
            if item == fname:
                lst.append(n)
            else:
                findAll(fname,n)
        except:
            pass
</code></pre>
<p>After <code>findAll</code> has terminated, <code>lst</code> will contain the values you want</p>
<p><strong>use the return value from the recursive call to modify <code>lst</code></strong></p>
<pre><code>def findAll(fname, path, answer=None):
    if answer == None:
        answer = []
    for item in os.listdir(path):
        n = os.path.join(path, item)
        try:
            if item == fname:
                answer += [n]
        except:
            findAll(fname,n, answer)
    return answer
</code></pre>
<p>Hope this helps</p>
<p>PS: of course, the non-homework way to do this would be to use <code>os.walk</code>:</p>
<pre><code>answer = []
def findAll(fname, dirpath):
    dirpath, dirnames, filenames = os.walk(dirpath)
    for filename in filenames:
        if filename == fname:
            answer.append(os.path.join(dirpath, filename))
    for dirname in dirnames:
        findAll(fname, os.path.join(dirpath, dirname))
# now, answer contains all the required filepaths
</code></pre>
<p><strong>EDIT</strong>: OP asked for a version that doesn't use global variables:</p>
<pre><code>def findAll(fname, root, answer=None):
    if answer == None:
        answer = []
     for entry in os.listdir(root):
         if os.path.isdir(os.path.join(root, entry)):
             answer += findAll(fname, os.path.join(root, entry))
         else:
             if entry == fname:
                 answer.append(os.path.join(root, entry))
     return answer
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you need to extend your list with your recursive call</p>
<pre><code>list.extend(findAll(fname,n))
</code></pre>
<p>also you can check if something is a directory with <code>os.path.isdir(n)</code></p>
<p>but I think you have more problems than that with your script</p>
<p>afaik <code>listdir</code> just returns names , not the path of the directory ....</p>
<p>so you will need to call  <code>findAll(fname,os.path.join(path,n))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Not related to the question <em>per se</em> but I believe that <code>os.walk</code> would help you out:</p>
<pre><code>allFiles = []
for root, dirs, files in os.walk(basedir):
    [allFiles.append(file) for file in files]
</code></pre>
<p>Check out <code>help(os.walk)</code>, it comes with a great example on how to use this function.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>try/except</code> is used incorrectly in your code. <code>except</code> clause is executed only if there is an error. Also you don't use the returned value from <code>findAll()</code>. You could skip creating a list inside the function and just yield found items lazily instead:</p>
<pre><code>import os

def findAll(filename, rootdir): 
    for item in os.listdir(rootdir):
        path = os.path.join(rootdir, item)
        if not os.path.isdir(path):
            if item == filename: # don't select dirs
                yield path
        else: # path is a dir
            try:
                for found_path in findAll(filename, path):
                    yield found_path
            except EnvironmentError:
                pass # ignore errors

print(list(findAll('python', '/usr')))
</code></pre>
<h3><a href="http://ideone.com/nen734" rel="nofollow">Output</a></h3>
<pre><code>['/usr/bin/python']
</code></pre>
<p>if it is not homework you could use <a href="http://docs.python.org/3/library/os#os.walk" rel="nofollow"><code>os.walk()</code></a> to find the files:</p>
<pre><code>import os

def find_all(filename, rootdir):
    for dirpath, dirs, files in os.walk(rootdir):
        for file in files:
            if file == filename:
                yield os.path.join(dirpath, file)


print(list(find_all('python', '/usr')))
</code></pre>
<h3><a href="http://ideone.com/nwdknc" rel="nofollow">Output</a></h3>
<pre><code>['/usr/bin/python']
</code></pre>
<p>It is the same output as expected.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're on a Unix based system you could use <code>find</code> with the <code>subprocess</code> module .. I would reckon this would be the fastest way to retrieve all paths matching a filename. You can then do a <code>split()</code> on the output to make it a list:</p>
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; lst = subprocess.check_output('find . -name "*rst"', shell=True)
&gt;&gt;&gt; print lst
    ./SphinxWorkspace/doc/chapter1.rst
    ./SphinxWorkspace/doc/index.rst
    ./SphinxWorkspace/doc/tables.rst
</code></pre>
<p>You can always split the command and avoid the <code>shell=True</code></p>
<p>Checkout: <a href="http://docs.python.org/2/library/subprocess.html#using-the-subprocess-module" rel="nofollow">http://docs.python.org/2/library/subprocess.html#using-the-subprocess-module</a>
.. Hope this helps!</p>
</div>
<span class="comment-copy">I'd take a look at <code>os.walk</code>.</span>
<span class="comment-copy"><code>findAll()</code> inside <code>except</code> won't be called under ordinary conditions (no recursive calls are made). Globals should be avoided in this case either pass <code>answer</code> as a parameter or <a href="http://stackoverflow.com/a/13206051/4279">use yield</a></span>
<span class="comment-copy">@J.F.Sebastian: Duly noted about the <code>except</code>. I didn't want to add yield given that this might be for homework and OP therefore might be at a very beginner level. I agree though, that <code>yield</code> should be used</span>
<span class="comment-copy">is there any way to not use a global variable/</span>
<span class="comment-copy">@brianChiem: Added a third solution that should work for you</span>
