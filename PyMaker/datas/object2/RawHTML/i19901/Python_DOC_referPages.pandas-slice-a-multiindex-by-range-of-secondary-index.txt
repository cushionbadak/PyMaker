<div class="post-text" itemprop="text">
<p>I have a series with a MultiIndex like this:</p>
<pre><code>import numpy as np
import pandas as pd

buckets = np.repeat(['a','b','c'], [3,5,1])
sequence = [0,1,5,0,1,2,4,50,0]

s = pd.Series(
    np.random.randn(len(sequence)), 
    index=pd.MultiIndex.from_tuples(zip(buckets, sequence))
)

# In [6]: s
# Out[6]: 
# a  0    -1.106047
#    1     1.665214
#    5     0.279190
# b  0     0.326364
#    1     0.900439
#    2    -0.653940
#    4     0.082270
#    50   -0.255482
# c  0    -0.091730
</code></pre>
<p>I'd like to get the s['b'] values where the second index ('<code>sequence</code>') is between 2 and 10.</p>
<p>Slicing on the first index works fine:</p>
<pre><code>s['a':'b']
# Out[109]: 
# bucket  value
# a       0        1.828176
#         1        0.160496
#         5        0.401985
# b       0       -1.514268
#         1       -0.973915
#         2        1.285553
#         4       -0.194625
#         5       -0.144112
</code></pre>
<p>But not on the second, at least by what seems to be the two most obvious ways:</p>
<p>1) This returns elements 1 through 4, with nothing to do with the index values</p>
<pre><code>s['b'][1:10]

# In [61]: s['b'][1:10]
# Out[61]: 
# 1     0.900439
# 2    -0.653940
# 4     0.082270
# 50   -0.255482
</code></pre>
<p>However, if I reverse the index and the first index is integer and the second index is a string, it works:</p>
<pre><code>In [26]: s
Out[26]: 
0   a   -0.126299
1   a    1.810928
5   a    0.571873
0   b   -0.116108
1   b   -0.712184
2   b   -1.771264
4   b    0.148961
50  b    0.089683
0   c   -0.582578

In [25]: s[0]['a':'b']
Out[25]: 
a   -0.126299
b   -0.116108
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/a/31490891/1240268">Robbie-Clarken answers</a>, since 0.14 you can pass a <a href="http://pandas.pydata.org/pandas-docs/stable/advanced.html#using-slicers" rel="noreferrer">slice in the tuple you pass to loc</a>:</p>
<pre><code>In [11]: s.loc[('b', slice(2, 10))]
Out[11]:
b  2   -0.65394
   4    0.08227
dtype: float64
</code></pre>
<p>Indeed, you can pass a slice for each level:</p>
<pre><code>In [12]: s.loc[(slice('a', 'b'), slice(2, 10))]
Out[12]:
a  5    0.27919
b  2   -0.65394
   4    0.08227
dtype: float64
</code></pre>
<p><em>Note: the slice is inclusive.</em></p>
<hr/>
<h3>Old answer:</h3>
<p>You can also do this using:</p>
<pre><code>s.ix[1:10, "b"]
</code></pre>
<p>(It's good practice to do in a single ix/loc/iloc since this version allows assignment.)</p>
<p>This answer was written prior to the <a href="https://github.com/pydata/pandas/pull/2922" rel="noreferrer">introduction of iloc</a> in early 2013, i.e. position/integer location - which may be preferred in this case. The reason it was created was to remove the ambiguity from integer-indexed pandas objects, and be more descriptive: "I'm slicing on position".</p>
<pre><code>s["b"].iloc[1:10]
</code></pre>
<p>That said, I kinda disagree with the docs that ix is:</p>
<blockquote>
<p>most robust and consistent way</p>
</blockquote>
<p>it's not, the most consistent way is to describe what you're doing:</p>
<ul>
<li>use loc for labels</li>
<li>use iloc for position</li>
<li>use ix for both (if you really have to)</li>
</ul>
<p>Remember the <a href="https://www.python.org/dev/peps/pep-0020/" rel="noreferrer">zen of python</a>:</p>
<blockquote>
<p>explicit is better than implicit</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>As of pandas 0.14.0 it is possible to <a href="http://pandas.pydata.org/pandas-docs/stable/advanced.html#using-slicers" rel="noreferrer">slice multi-indexed objects</a> by providing <code>.loc</code> a tuple containing <a href="https://docs.python.org/3/library/functions.html#slice" rel="noreferrer">slice</a> objects:</p>
<pre><code>In [2]: s.loc[('b', slice(2, 10))]
Out[2]:
b  2   -1.206052
   4   -0.735682
dtype: float64
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best way I can think of is to use 'select' in this case. Although it even says in the docs that "This method should be used only when there is no more direct way."</p>
<p><a href="http://pandas.pydata.org/pandas-docs/dev/indexing.html" rel="nofollow">Indexing and selecting data</a></p>
<pre><code>In [116]: s
Out[116]: 
a  0     1.724372
   1     0.305923
   5     1.780811
b  0    -0.556650
   1     0.207783
   4    -0.177901
   50    0.289365
   0     1.168115

In [117]: s.select(lambda x: x[0] == 'b' and 2 &lt;= x[1] &lt;= 10)
Out[117]: b  4   -0.177901
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>not sure if this is ideal but it works by creating a mask</p>
<pre><code>In [59]: s.index
Out[59]: 
MultiIndex
[('a', 0) ('a', 1) ('a', 5) ('b', 0) ('b', 1) ('b', 2) ('b', 4)
 ('b', 50) ('c', 0)]
In [77]: s[(tpl for tpl in s.index if 2&lt;=tpl[1]&lt;=10 and tpl[0]=='b')]                                                               
Out[77]: 
b  2   -0.586568
   4    1.559988
</code></pre>
<p><strong>EDIT :</strong> hayden's solution is the way to go</p>
</div>
<span class="comment-copy">To run this code with Python 3, need to modify: <code>index=pd.MultiIndex.from_tuples(list(zip(buckets, sequence)))</code> (note the new <code>list</code>)</span>
<span class="comment-copy">If you are interested in learning more about slicing and filtering multiindex DataFrames, please take a look at my post: <a href="https://stackoverflow.com/questions/53927460/how-do-i-slice-or-filter-multiindex-dataframe-levels">How do I slice or filter MultiIndex DataFrame levels?</a>. Thanks!</span>
<span class="comment-copy">It feels like there ought to be a way to do this in one pass (using loc / without chaining), however assignment (<code>s['b'].ix[1:10]</code>) works so I guess it's ok.</span>
<span class="comment-copy">Please @Andy-Hayden update you answer to comply with the new pandas API. as Robbie-Clarken shows: loc and slice indexing are recommended.</span>
<span class="comment-copy">@mithrado thanks for pointing that out, i have been meaning to go through all my pandas answers and update them. I need to write a script as there's too many to do manually. :/</span>
<span class="comment-copy">Something that is not said in the answer, but that was what I was actually looking for: "You can use <code>slice(None)</code> to select all the contents of that level. You do not need to specify all the deeper levels, they will be implied as <code>slice(None)</code>". Source: <a href="http://pandas.pydata.org/pandas-docs/stable/advanced.html#using-slicers" rel="nofollow noreferrer">Pandas docs</a>.</span>
<span class="comment-copy">Surprisingly (for me at least), although comparable for small Series, this starts to become slower than using <code>ix</code> when the Series is longer than 250. (Tested using <code>%timeit</code> in ipython.)</span>
