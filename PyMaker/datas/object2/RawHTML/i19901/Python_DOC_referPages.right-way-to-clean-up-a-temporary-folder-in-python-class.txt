<div class="post-text" itemprop="text">
<p>I am creating a class in which I want to generate a temporary workspace of folders that will persist for the life of the object and then be removed.  I am using tempfile.mkdtemp() in the def <strong>init</strong> to create the space, but I have read that I can't rely on <strong>del</strong> being called.</p>
<p>I am wanting something like this:</p>
<pre><code>class MyClass:
  def __init__(self):
    self.tempfolder = tempfile.mkdtemp()

  def ... #other stuff

  def __del__(self):
    if os.path.exists(self.tempfolder): shutil.rmtree(self.tempfolder)
</code></pre>
<p>Is there another/better way to handle this clean up?  I was reading about 'with' but it appears to only be helpful within a function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Caveat: you can never <em>guarantee</em> that the temp folder will be deleted, because the user could always hard kill your process and then it can't run anything else.</p>
<p>That said, do</p>
<pre><code>temp_dir = tempfile.mkdtemp()
try:
    &lt;some code&gt;
finally:
    shutil.rmtree(temp_dir)
</code></pre>
<hr/>
<p>Since this is a very common operation, Python has a special way to encapsulate "do something, execute code, clean up": a <em>context manager</em>. You can write your own as follows:</p>
<pre><code>@contextlib.contextmanager
def make_temp_directory():
    temp_dir = tempfile.mkdtemp()
    try:
        yield temp_dir
    finally:
        shutil.rmtree(temp_dir)
</code></pre>
<p>and use it as</p>
<pre><code>with make_temp_directory() as temp_dir:
    &lt;some code&gt;
</code></pre>
<p>(Note that this uses the <code>@contextlib.contextmanager</code> shortcut to make a context manager. If you want to implement one the original way, you need to make a custom class with <code>__enter__</code> and <code>__exit__</code> methods; the <code>__enter__</code> would create and return the temp directory and the <code>__exit__</code> delete it.</p>
</div>
<div class="post-text" itemprop="text">
<p>A nice way to deal with temporary files and directories is via a context manager. This is how you can use <a href="http://docs.python.org/2.7/library/tempfile.html#tempfile.TemporaryFile" rel="noreferrer">tempfile.TemporaryFile</a> or <a href="http://docs.python.org/2.7/library/tempfile.html#tempfile.NamedTemporaryFile" rel="noreferrer">tempfile.NamedTemporaryFile</a> -- once you've exited the <code>with</code> statement (via normal exit, return, exception, or anything else) the file/directory and it's contents will be removed from the filesystem.</p>
<p>For Python 3.2+, this is built in as <a href="http://docs.python.org/3.2/library/tempfile.html#tempfile.TemporaryDirectory" rel="noreferrer">tempfile.TemporaryDirectory</a>:</p>
<pre><code>import tempfile

with tempfile.TemporaryDirectory() as temp_dir:
    ... do stuff ...
</code></pre>
<p>For earlier Python versions you can easily create your own context manager to do exactly the same thing. The differences here from @katrielalex answer are the passing of args to <code>mkdtemp()</code> and the try/finally block to make sure the directory gets cleaned up if an exception is raised.</p>
<pre><code>import contextlib
import shutil

@contextlib.contextmanager
def temporary_directory(*args, **kwargs):
    d = tempfile.mkdtemp(*args, **kwargs)
    try:
        yield d
    finally:
        shutil.rmtree(d)


# use it
with temporary_directory() as temp_dir:
    ... do stuff ...
</code></pre>
<p>Note that if your process is hard-killed (eg. <code>kill -9</code>) then the directories won't get cleaned up.</p>
</div>
<div class="post-text" itemprop="text">
<p>As stated by <a href="https://stackoverflow.com/users/953022/bluewind">Bluewind</a> you have to make sure to wrap the yield portion of the context manager inside of a try: finally statement otherwise any exceptions will not really be handled correctly inside of the context manager.</p>
<p>From <a href="http://docs.python.org/2.7/library/tempfile.html" rel="nofollow noreferrer">Python 2.7 docs</a></p>
<blockquote>
<p>At the point where the generator yields, the block nested in the with statement is executed. The generator is then resumed after the block is exited. If an unhandled exception occurs in the block, it is reraised inside the generator at the point where the yield occurred. Thus, you can use a try...except...finally statement to trap the error (if any), or ensure that some cleanup takes place. If an exception is trapped merely in order to log it or to perform some action (rather than to suppress it entirely), the generator must reraise that exception. Otherwise the generator context manager will indicate to the with statement that the exception has been handled, and execution will resume with the statement immediately following the with statement.</p>
</blockquote>
<p>Also if you are using Python 3.2+ you should check out <a href="http://docs.python.org/3.2/library/tempfile.html" rel="nofollow noreferrer">this little gem</a> which has all of the above wrapped up nicely for you</p>
<blockquote>
<p>tempfile.TemporaryDirectory(suffix='', prefix='tmp', dir=None)</p>
<p>This function creates a temporary directory using mkdtemp() (the supplied arguments are passed directly to the underlying function). The resulting object can be used as a context manager (see With Statement Context Managers). On completion of the context (or destruction of the temporary directory object), the newly created temporary directory and all its contents are removed from the filesystem.</p>
<p>The directory name can be retrieved from the name attribute of the returned object.</p>
<p>The directory can be explicitly cleaned up by calling the cleanup() method.</p>
<p>New in version 3.2.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Another alternative using <code>contextlib</code> is to make your object closable, and use the <a href="https://docs.python.org/2/library/contextlib.html#contextlib.closing" rel="nofollow"><code>closing</code></a> context manager.</p>
<pre><code>class MyClass:
    def __init__(self):
        self.tempfolder = tempfile.mkdtemp()

    def do_stuff():
        pass

    def close(self):
        if os.path.exists(self.tempfolder):
            shutil.rmtree(self.tempfolder)
</code></pre>
<p>Then with the context manager:</p>
<pre><code>from contextlib import closing

with closing(MyClass()) as my_object:
    my_object.do_stuff()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Other answers have noted that you can use a contextmanager or require your users to explicitly call some type of clean up function. These are great to do if you can. However, sometimes there's no where to hook up this cleanup because you are inside a large application and you are nested multiple layers down, and no one above you has cleanup methods or context managers.</p>
<p>In that case, you can use atexit: <a href="https://docs.python.org/2/library/atexit.html" rel="nofollow noreferrer">https://docs.python.org/2/library/atexit.html</a></p>
<pre><code>import atexit

class MyClass:
  def __init__(self):
    self.tempfolder = tempfile.mkdtemp()
    atexit.register(shutil.rmtree, self.tempfolder)

  def ... #other stuff
</code></pre>
</div>
<span class="comment-copy">I think the only reliable solutions will always involve doing the clean-up explicitly. I don't think the <i>reliable automatic clean-up</i> solution you envisage in your question is possible.</span>
<span class="comment-copy">@PedroRomano false: Python's context managers are exactly for this purpose.</span>
<span class="comment-copy">@katrielalex: even context managers need to be explicitly entered.</span>
<span class="comment-copy">@PedroRomano yes -- but you <i>always</i> need to e.g. open a file. The point of a context manager is that it handles <i>cleaning up</i>.</span>
<span class="comment-copy">Can the context manager persist my temporary folder for the life of the object?  It looks like it would remove the folder once I leave the 'with' statement.  I guess I could pass the folder into my object as a parameter, but I was hoping to encapsulate the temporary folder within the class.</span>
<span class="comment-copy">The <i>definition</i> of the <code>with</code> statement is that it closes the object when you leave it. If you want your temp directory to close somewhere else, you need to close it explicitly there and handle exceptions yourself.</span>
<span class="comment-copy">The context manager works fine for me, but I had to add a try: finally: around the yield or otherwise it wouldn't clean up if the code using the temp dir raises an exception. Might be documented somewhere or might be different between python versions, but I thought I'd mention it.</span>
<span class="comment-copy">That behavior is <a href="http://docs.python.org/2/library/contextlib.html#contextlib.contextmanager" rel="nofollow noreferrer">documented</a>: "If an unhandled exception occurs in the block, it is reraised inside the generator at the point where the yield occurred. Thus, you can use a <code>try...except...finally</code> statement to trap the error (if any), or ensure that some cleanup takes place."</span>
<span class="comment-copy">Note that Python 3.2 added <code>tempfile.TemporaryDirectory()</code> which does the same thing that this answer shows.  For 3.2 and newer I would use the library module code; for older Python versions I would use this code, but I'd rename the function to <code>TemporaryDirectory()</code> and document that it is similar to the 3.2 code.  <a href="https://docs.python.org/3/library/tempfile.html" rel="nofollow noreferrer">docs.python.org/3/library/tempfile.html</a></span>
