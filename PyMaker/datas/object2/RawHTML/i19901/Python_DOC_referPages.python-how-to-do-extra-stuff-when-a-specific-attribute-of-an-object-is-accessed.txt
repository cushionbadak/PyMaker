<div class="post-text" itemprop="text">
<p>Let's say I have a class in Python:</p>
<pre><code>class Foo(object):
    a = 1
    b = 2
</code></pre>
<p>I'd like to do some extra stuff when I access 'a' but NOT 'b'. So, for example, let's assume that the extra stuff I'd like to do is to increment the value of the attribute:</p>
<pre><code>&gt; f = Foo()
&gt; f.a # Should output 2
&gt; f.a # Should output 3
&gt; f.a # Should output 4
&gt; f.b # Should output 2, since I want the extra behavior just on 'a'
</code></pre>
<p>It feels like there is a way through __getattr__ or __getattribute__, but I couldn't figure that out.</p>
<p>The extra thing can be anything, not necessarily related to the attribute (like print 'Hello world').</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you are looking for is a <a href="http://docs.python.org/3/library/functions.html#property" rel="nofollow">property</a>, which can be used nicely as a decorator:</p>
<pre><code>class Foo(object):
    _a = 2

    @property
    def a(self):
        Foo._a += 1
        return Foo._a - 1

    b = 2
</code></pre>
<p>The function is called whenever you try to access <code>foo_instance.a</code>, and the value returned is used as the value for the attribute. You can also define a <em>setter</em> too, which is called with the new value when the attribute is set.</p>
<p>This is presuming you want the odd set-up of class attributes you only ever access from instances. (<code>_a</code> and <code>b</code> here belong to the class - that is, there is only one variable shared by all instances - as in your question). A property, however, is always instance-owned. The most likely case is you actually want:</p>
<pre><code>class Foo(object):
    def __init__(self):
        self._a = 2
        self.b = 2

    @property
    def a(self):
        self._a += 1
        return self._a - 1
</code></pre>
<p>Where they are instance attributes.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really do want the equivalent of <code>@property</code> for a class variable, you have to build the <a href="http://docs.python.org/2/howto/descriptor.html" rel="nofollow">descriptor</a> yourself.</p>
<p>You almost certainly <em>don't</em> want to do this—see Lattyware's answer for how to make normal instance variables, and turn one of them into a <code>@property</code>.</p>
<p>But here's how you could do it:</p>
<pre><code>class IncrementOnGetDescriptor(object):
    def __init__(self, initval=None):
        self.val = initval
    def __get__(self, obj, objtype):
        self.val += 1
        return self.val - 1
    def __set__(self, obj, val):
        self.val = val

class Foo(object):
    a = IncrementOnGetDescriptor(2)
    b = 2
</code></pre>
<p>Now you can test it:</p>
<pre><code>&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.a
2
&gt;&gt;&gt; Foo.a
3
&gt;&gt;&gt;&gt; f.a
4
</code></pre>
<p>Turning this into a <code>@classproperty</code> decorator is left as an exercise for the reader.</p>
<p>PS, this <em>still</em> isn't exactly like a normal class variable. Setting <code>Foo.a = 10</code> will replace your magic auto-incrementing value with a normal <code>10</code>, while setting <code>foo.a = 10</code> will update the class with an auto-incrementing <code>10</code> instead of storing an instance variable in <code>f</code>. (I originally had the <code>__set__</code> method raise <code>AttributeError</code>, because normally you'd want an auto-incrementing magic variable be read-only, but I decided to show the more complex version just to show all the issues you have to deal with.)</p>
</div>
<span class="comment-copy">What does this have to do with Django?</span>
<span class="comment-copy">@abarnert It doesn't, I removed the tag.</span>
<span class="comment-copy">You've made <code>a</code> and <code>b</code> members of the class <code>Foo</code> rather than of each instance of <code>Foo</code>. This means that all instances share a single copy. Is that intentional? If so, it makes the problem much harder…</span>
<span class="comment-copy">It really doesn't make it harder - you just access and change the class variable from the property. The only issue is if you want the property to be accessible as <code>Foo.a</code>.</span>
<span class="comment-copy">@abarnert No that's not what it means. Attribute assignment on an instance creates/changes an instance attribute, regardless of a class attribute of the same name. Try your example. <code>f2.b</code> will be 2.</span>
<span class="comment-copy">Is the property body by change missing two instances of <code>self._</code>?</span>
<span class="comment-copy">You've made this an instance property, not a class property. (For example, what happens when you do <code>Foo.a</code>?)</span>
<span class="comment-copy">@delnan: Actually, <code>self</code> won't work, it has to be <code>Foo</code>. Also, <code>_a</code> is misspelled as <code>a</code>…</span>
<span class="comment-copy">@abarnert It's used as instance property in the example in the question. Chances are it's not intended to be a class property, which is a very exotic beast.</span>
<span class="comment-copy">Indeed I missed out <code>self._</code>, just me going a little too quick. given the example given was on an instance, I presumed the asker actually wanted this on an instance, but it is ambiguous.</span>
<span class="comment-copy">+1 for an informative post - just because the OP didn't want this doesn't mean someone else coming along won't.</span>
