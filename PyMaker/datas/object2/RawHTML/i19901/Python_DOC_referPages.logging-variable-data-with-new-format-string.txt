<div class="post-text" itemprop="text">
<p>I use logging facility for python 2.7.3. <a href="http://docs.python.org/2/howto/logging.html" rel="noreferrer">Documentation for this Python version say</a>:</p>
<blockquote>
<p>the logging package pre-dates newer formatting options such as str.format() and string.Template. These newer formatting options are supported...</p>
</blockquote>
<p>I like 'new' format with curly braces. So i'm trying to do something like:</p>
<pre><code> log = logging.getLogger("some.logger")
 log.debug("format this message {0}", 1)
</code></pre>
<p>And get error:</p>
<blockquote>
<p>TypeError: not all arguments converted during string formatting</p>
</blockquote>
<p>What I miss here?</p>
<p>P.S. I don't want to use </p>
<pre><code>log.debug("format this message {0}".format(1))
</code></pre>
<p>because in this case the message is always being formatted regardless of logger level.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>EDIT:</strong> take a look at the <a href="https://stackoverflow.com/a/24683360/4279"><code>StyleAdapter</code> approach in @Dunes' answer</a> unlike this answer; it allows to use alternative formatting styles without the boilerplate while calling logger's methods (debug(), info(), error(), etc).</p>
<hr/>
<p>From the docs â€” <a href="http://docs.python.org/3/howto/logging-cookbook.html#use-of-alternative-formatting-styles" rel="noreferrer">Use of alternative formatting styles</a>:</p>
<blockquote>
<p>Logging calls (logger.debug(), logger.info() etc.) only take
  positional parameters for the actual logging message itself, with
  keyword parameters used only for determining options for how to handle
  the actual logging call (e.g. the exc_info keyword parameter to
  indicate that traceback information should be logged, or the extra
  keyword parameter to indicate additional contextual information to be
  added to the log). So you cannot directly make logging calls using
  str.format() or string.Template syntax, because internally the logging
  package uses %-formatting to merge the format string and the variable
  arguments. There would no changing this while preserving backward
  compatibility, since all logging calls which are out there in existing
  code will be using %-format strings.</p>
</blockquote>
<p>And:</p>
<blockquote>
<p>There is, however, a way that you can use {}- and $- formatting to
  construct your individual log messages. Recall that for a message you
  can use an arbitrary object as a message format string, and that the
  logging package will call str() on that object to get the actual
  format string.</p>
</blockquote>
<p>Copy-paste this to <code>wherever</code> module:</p>
<pre><code>class BraceMessage(object):
    def __init__(self, fmt, *args, **kwargs):
        self.fmt = fmt
        self.args = args
        self.kwargs = kwargs

    def __str__(self):
        return self.fmt.format(*self.args, **self.kwargs)
</code></pre>
<p>Then:</p>
<pre><code>from wherever import BraceMessage as __

log.debug(__('Message with {0} {name}', 2, name='placeholders'))
</code></pre>
<p>Note: actual formatting is delayed until it is necessary e.g., if DEBUG messages are not logged then the formatting is not performed at all.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another option that does not have the keyword problems mentioned in Dunes' answer. It can only handle positional (<code>{0}</code>) arguments and not keyword (<code>{foo}</code>) arguments. It also does not require two calls to format (using the underscore). It does have the ick-factor of subclassing <code>str</code>:</p>
<pre class="lang-py prettyprint-override"><code>class BraceString(str):
    def __mod__(self, other):
        return self.format(*other)
    def __str__(self):
        return self


class StyleAdapter(logging.LoggerAdapter):

    def __init__(self, logger, extra=None):
        super(StyleAdapter, self).__init__(logger, extra)

    def process(self, msg, kwargs):
        if kwargs.pop('style', "%") == "{":  # optional
            msg = BraceString(msg)
        return msg, kwargs
</code></pre>
<p>You use it like this:</p>
<pre class="lang-py prettyprint-override"><code>logger = StyleAdapter(logging.getLogger(__name__))
logger.info("knights:{0}", "ni", style="{")
logger.info("knights:{}", "shrubbery", style="{")
</code></pre>
<p>Of course, you can remove the check noted with <code># optional</code> to force all messages through the adapter to use new-style formatting.</p>
<hr/>
<p><em>Note for anyone reading this answer years later</em>: Starting with <strong>Python 3.2</strong>, you can <a href="https://docs.python.org/3.2/howto/logging-cookbook.html#use-of-alternative-formatting-styles" rel="noreferrer">use the style parameter</a> with <code>Formatter</code> objects:</p>
<blockquote>
<p>Logging (as of 3.2) provides improved support for these two additional formatting styles. The 
  Formatter class been enhanced to take an additional, optional keyword parameter named <code>style</code>. This 
  defaults to <code>'%'</code>, but other possible values are <code>'{'</code> and <code>'$'</code>, which correspond to the other two 
  formatting styles. Backwards compatibility is maintained by default (as you would expect), but by 
  explicitly specifying a style parameter, you get the ability to specify format strings which work 
  with <a href="https://docs.python.org/3.2/library/stdtypes.html#str.format" rel="noreferrer"><code>str.format()</code></a> or 
  <a href="https://docs.python.org/3.2/library/string.html#string.Template" rel="noreferrer"><code>string.Template</code></a>. </p>
</blockquote>
<p>The docs provide the example
<code>logging.Formatter('{asctime} {name} {levelname:8s} {message}', style='{')</code></p>
<p>Note that in this case you still can't call the <code>logger</code> with the new format. I.e., the following still won't work:</p>
<pre class="lang-py prettyprint-override"><code>logger.info("knights:{say}", say="ni")  # Doesn't work!
logger.info("knights:{0}", "ni")  # Doesn't work either
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easier solution would be to use the <a href="http://packages.python.org/Logbook/" rel="noreferrer">excellent <code>logbook</code> module</a></p>
<pre><code>import logbook
import sys

logbook.StreamHandler(sys.stdout).push_application()
logbook.debug('Format this message {k}', k=1)
</code></pre>
<p>Or the more complete:</p>
<pre><code>&gt;&gt;&gt; import logbook
&gt;&gt;&gt; import sys
&gt;&gt;&gt; logbook.StreamHandler(sys.stdout).push_application()
&gt;&gt;&gt; log = logbook.Logger('MyLog')
&gt;&gt;&gt; log.debug('Format this message {k}', k=1)
[2017-05-06 21:46:52.578329] DEBUG: MyLog: Format this message 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This was my solution to the problem when I found logging only uses printf style formatting. It allows logging calls to remain the same -- no special syntax such as <code>log.info(__("val is {}", "x"))</code>. The change required to code is to wrap the logger in a <code>StyleAdapter</code>.</p>
<pre><code>from inspect import getargspec

class BraceMessage(object):
    def __init__(self, fmt, args, kwargs):
        self.fmt = fmt
        self.args = args
        self.kwargs = kwargs

    def __str__(self):
        return str(self.fmt).format(*self.args, **self.kwargs)

class StyleAdapter(logging.LoggerAdapter):
    def __init__(self, logger):
        self.logger = logger

    def log(self, level, msg, *args, **kwargs):
        if self.isEnabledFor(level):
            msg, log_kwargs = self.process(msg, kwargs)
            self.logger._log(level, BraceMessage(msg, args, kwargs), (), 
                    **log_kwargs)

    def process(self, msg, kwargs):
        return msg, {key: kwargs[key] 
                for key in getargspec(self.logger._log).args[1:] if key in kwargs}
</code></pre>
<p>Usage is:</p>
<pre><code>log = StyleAdapter(logging.getLogger(__name__))
log.info("a log message using {type} substiution", type="brace")
</code></pre>
<p>It's worth noting that this implementation has problems if key words used for brace substitution include <code>level</code>, <code>msg</code>, <code>args</code>, <code>exc_info</code>, <code>extra</code> or <code>stack_info</code>. These are argument names used by the <code>log</code> method of <code>Logger</code>. If you need to one of these names then modify <code>process</code> to exclude these names or just remove <code>log_kwargs</code> from the <code>_log</code> call. On a further note, this implementation also silently ignores misspelled keywords meant for the Logger (eg. <code>ectra</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>As other answers mention, the brace-style formatting <a href="https://docs.python.org/3/howto/logging-cookbook.html#use-of-alternative-formatting-styles" rel="noreferrer">introduced in Python 3.2</a> is only used on the format string, not the actual log messages.</p>
<p>As of Python 3.5, there is no nice way to use brace-style formatting to log messages.</p>
<p>However, as with most things in Python, there is a not-nice way.</p>
<p>The following monkey-patches the <code>logging</code> module to create a <code>get_logger</code> function that will return a logger that uses the new-style formatting for every log record that it handles.</p>
<pre><code>import functools
import logging
import types

def _get_message(record):
    """Replacement for logging.LogRecord.getMessage
    that uses the new-style string formatting for
    it's messages"""
    msg = str(record.msg)
    args = record.args
    if args:
        if not isinstance(args, tuple):
            args = (args,)
        msg = msg.format(*args)
    return msg

def _handle_wrap(fcn):
    """Wrap the handle function to replace the passed in
    record's getMessage function before calling handle"""
    @functools.wraps(fcn)
    def handle(record):
        record.getMessage = types.MethodType(_get_message, record)
        return fcn(record)
    return handle

def get_logger(name=None):
    """Get a logger instance that uses new-style string formatting"""
    log = logging.getLogger(name)
    if not hasattr(log, "_newstyle"):
        log.handle = _handle_wrap(log.handle)
    log._newstyle = True
    return log
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; log = get_logger()
&gt;&gt;&gt; log.warning("{!r}", log)
&lt;logging.RootLogger object at 0x4985a4d3987b&gt;
</code></pre>
<hr/>
<p>Notes:</p>
<ul>
<li>Will only affect specific loggers created by the <code>get_logger</code> function.</li>
<li>If the logger is accessed again from a normal <code>logging.getLogger()</code> call, the new-style formatting will still apply</li>
<li>kwargs are not supported</li>
<li>Performance hit should be minimal (rewriting a single function pointer for each log message)</li>
<li>The formatting of the message is delayed until it is output</li>
<li>Doesn't stop the args from being stored on <code>logging.LogRecord</code> objects (useful in certain cases)</li>
<li>From looking at the <a href="https://github.com/python/cpython/blob/master/Lib/logging/__init__.py" rel="noreferrer"><code>logging</code> module source code</a> it seems like it should work all the way back to Python 2.6 when <a href="https://docs.python.org/2.6/library/stdtypes.html#str.format" rel="noreferrer"><code>str.format</code></a> was introduced (but was only tested on Python 3.5).</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Try <code>logging.setLogRecordFactory</code> in Python 3.2+:</p>
<pre><code>import collections
import logging


class _LogRecord(logging.LogRecord):

    def getMessage(self):
        msg = str(self.msg)
        if self.args:
            if isinstance(self.args, collections.Mapping):
                msg = msg.format(**self.args)
            else:
                msg = msg.format(*self.args)
        return msg


logging.setLogRecordFactory(_LogRecord)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's something real simple that works:</p>
<pre><code>debug_logger: logging.Logger = logging.getLogger("app.debug")

def mydebuglog(msg: str, *args, **kwargs):
    if debug_logger.isEnabledFor(logging.DEBUG):
        debug_logger.debug(msg.format(*args, **kwargs))
</code></pre>
<p>Then:</p>
<pre><code>mydebuglog("hello {} {val}", "Python", val="World")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I created a custom Formatter, called <a href="https://pypi.org/project/out/" rel="nofollow noreferrer">ColorFormatter</a> that handles the problem like this:</p>
<pre><code>class ColorFormatter(logging.Formatter):

    def format(self, record):
        # previous stuff, copy from logging.pyâ€¦

        try:  # Allow {} style
            message = record.getMessage()  # printf
        except TypeError:
            message = record.msg.format(*record.args)

        # later stuffâ€¦
</code></pre>
<p>This keeps it compatible with various libraries.
The drawback is that it is probably not performant due to potentially attempting format of the string twice.</p>
</div>
<span class="comment-copy">I am guessing that it is <code>log.debug</code> and not <code>log.degug</code></span>
<span class="comment-copy">You can do this:  <code>log.debug("format this message%d" % 1)</code></span>
<span class="comment-copy">you need to configure the <a href="http://docs.python.org/3/howto/logging.html#formatters" rel="nofollow noreferrer"><code>Formatter</code></a> to use '{' as style</span>
<span class="comment-copy">@ronak Thanks for the advice but no. Please, see "p.s." section why. BTW log.debug("format this message%d", 1) - works fine.</span>
<span class="comment-copy">@mata How to configure it? Is there direct documentation of doing it?</span>
<span class="comment-copy">As of Python 3.6, you can use f-strings like so: <code>num = 2; name = 'placeholders'; log.debug(f'Message with {num} {name}')</code></span>
<span class="comment-copy">@P1h3r1e3d13 unlike the logging code in the answer, f''-strings perform formatting immediately.</span>
<span class="comment-copy">Right. They work here because they format and return a regular string before calling the log method. That may or may not be relevant to someone, so I think it's worth mentioning as an option.</span>
<span class="comment-copy">Your statement about Python 3 is incorrect. The style parameter only applies to the Formatter format string, not the individual log messages. The page you linked to explicitly says: "There would no changing this while preserving backward compatibility".</span>
<span class="comment-copy">Thanks for keeping me honest. The first part is less useful now, but I've rephrased it in terms of the <code>Formatter</code>, which is correct now (I think). The <code>StyleAdapter</code>  still works,</span>
<span class="comment-copy">Python 3.5 does "str(msg)" before the formatting, so this does unfortunately not work anymore, which is a shame.</span>
<span class="comment-copy">@falstro -- thanks for pointing that out. The updated version should now work. Since <code>BraceString</code> is a string subclass, it's safe to return itself from <code>__str__</code></span>
<span class="comment-copy">This looks great, but is there a way of having milliseconds rather than just seconds?</span>
<span class="comment-copy">@Jeff sure, logbook lets you define custom handlers with and use custom string formats.</span>
<span class="comment-copy">@Jeff Couple of years later - default time precision is milliseconds.</span>
<span class="comment-copy">This way is recommend by python doc, <a href="https://docs.python.org/3/howto/logging-cookbook.html#use-of-alternative-formatting-styles" rel="nofollow noreferrer">docs.python.org/3/howto/â€¦</a></span>
<span class="comment-copy">The only answer that consider that the debug string should only be computed if the debugger message is to be printed. Thanks!</span>
<span class="comment-copy">Did you actually test this? Doesn't seem to work.</span>
<span class="comment-copy">It does work but the problem is you break third party modules that are using <code>%</code> formatting as the record factory is global to the logging module.</span>
