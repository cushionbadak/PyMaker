<div class="post-text" itemprop="text">
<p>I currently have this code:</p>
<pre><code>class Generator(object):
    def __getattr__(self, name):    
        def f(self):
            return ("Result of"+name, self)
        f.__name__ = name
        return f

    def foo(self):
        pass

g = Generator()
print g.foo
print Generator.foo
print g.bar
print Generator.bar
</code></pre>
<p>Which gives:</p>
<pre class="lang-none prettyprint-override"><code>&lt;bound method Generator.foo of &lt;__main__.Generator object at 0x00B62D30&gt;&gt;
&lt;unbound method Generator.foo&gt;
&lt;function bar at 0x00A9DE70&gt;
AttributeError: type object 'Generator' has no attribute 'bar'
</code></pre>
<p>What do I have to do to make it give:</p>
<pre class="lang-none prettyprint-override"><code>&lt;bound method Generator.foo of &lt;__main__.Generator object at 0x00B62D30&gt;&gt;
&lt;unbound method Generator.foo&gt;
&lt;bound method Generator.bar of &lt;__main__.Generator object at 0x00B62D30&gt;&gt;
&lt;unbound method Generator.bar&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a metaclass that adds the <code>__getattr__</code> function from the class definition back to the metaclass itself. This avoids having to define the function in multiple places, or as a separate global function defined beforehand and added individually to the metaclass and class.</p>
<pre><code>class Meta(type):

    def __new__(mcls, name, bases, dikt):
        fgetattr = dikt.get('__getattr__')
        if fgetattr is not None:
            setattr(mcls, '__getattr__', fgetattr)
        return super(Meta, mcls).__new__(mcls, name, bases, dikt)

class Generator(object):
    __metaclass__ = Meta

    def __getattr__(obj, name):

        def f(self):
            return "Result of %s for %r" % (name, self)
        f.__name__ = name

        if isinstance(obj, type):
            setattr(obj, name, f)
        else:
            setattr(type(obj), name, f)
        return getattr(obj, name)
</code></pre>
<p>Rather than directly create the method via the dynamic function's <code>__get__</code> descriptor method, I think it's better to store the function in the class dict and rely on <code>getattr</code> to return the proper bound/unbound method. Subsequent attribute access will use the function from the class. Since the same <code>__getattr__</code> function is used for both the class and the instance, an <code>isinstance</code> check is required to ensure the dynamic function gets stored to the class and not the instance.</p>
<p>In Python 3, getting the function as an attribute of the class merely returns the function since unbound methods were removed from the language. Also, the <a href="http://docs.python.org/3/reference/datamodel.html#customizing-class-creation" rel="nofollow">metaclass syntax</a> has changed to a keyword argument in the class definition line.</p>
<p>Test:</p>
<pre><code>&gt;&gt;&gt; g = Generator()
&gt;&gt;&gt; g.foo
&lt;bound method Generator.foo of &lt;__main__.Generator object at 0xb7248c2c&gt;&gt;
&gt;&gt;&gt; Generator.foo
&lt;unbound method Generator.foo&gt;
&gt;&gt;&gt; g.bar
&lt;bound method Generator.bar of &lt;__main__.Generator object at 0xb7248c2c&gt;&gt;
&gt;&gt;&gt; Generator.bar
&lt;unbound method Generator.bar&gt;
&gt;&gt;&gt; g.foo()
'Result of foo for &lt;__main__.Generator object at 0xb7248c2c&gt;'
&gt;&gt;&gt; Generator.foo(g)
'Result of foo for &lt;__main__.Generator object at 0xb7248c2c&gt;'
&gt;&gt;&gt; 'foo' in vars(Generator), 'bar' in vars(Generator)
(True, True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>__getattr__()</code> only works on instances, you will need to make the function on a metaclass on <code>Generator</code> to get the behavior your want.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have two problems.</p>
<ol>
<li>You only set the dynamic function on the <em>instance</em> <code>g</code> (not the class <code>Generator</code>), so <code>Generator.bar</code> is not defined.</li>
<li>You don't wrap it in a <code>MethodType</code>, so you get a function instead of a method.</li>
</ol>
<hr/>
<p>For 1, if you always call <code>g.foo</code> before you call <code>Generator.foo</code>, you can just add the line</p>
<pre><code>setattr(self.__class__, name, f)
</code></pre>
<p>inside <code>__getattr__</code>, which will bind the name as a method on the class. Otherwise, you will need a custom <code>__getattr__</code> on the <em>type object</em>, which means that you have to make it an instance of a custom class i.e. write your own metaclass.</p>
<hr/>
<p>For 2, see @thg435's answer. Note that this is icky because of backwards compatibility in Python 2, and has been neatened considerably in Py3k -- now what you are doing would basically work. It's because of the automatic injection of <code>self</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>For the first case (g.bar), replace <code>return f</code> with <code>return MethodType(f, self)</code>.</p>
</div>
<span class="comment-copy"><code>mov_i</code>? Isn't that from some other code? Your code produces <code>AttributeError: type object 'Generator' has no attribute 'bar'</code> for me, which makes more sense.</span>
<span class="comment-copy">@LevLevitsky: Whoops, fixed.</span>
<span class="comment-copy">That only swaps which of <code>print g.bar</code> and <code>print Generator.bar</code> error. This still doesn't convert functions to bound/unbound methods</span>
<span class="comment-copy">@Eric You would need to have the function in both places to have as it work in your final case and the other cases. I missed the change from bound to function there, but that's now been answered by thg435, I believe.</span>
<span class="comment-copy">Edit: I'm not sure what you mean regarding Python 3. Unbound methods were removed, but binding regular methods wasn't changed.</span>
<span class="comment-copy">That outputs <code>&lt;bound method ?.bar of ...</code> rather than <code>&lt;bound method Generator.bar of ...</code> for some reason</span>
<span class="comment-copy"><code>MethodType(f, self, Generator)</code>, or <code>f.__get__(self, Generator)</code>. Replace <code>self</code> with <code>None</code> to make an <code>unbound method</code>.</span>
<span class="comment-copy">@eryksun: Any way I can write one <code>__getattr__</code> in the metaclass and have it apply to both classes and instances?</span>
<span class="comment-copy">@Eric: Yes, by overriding <code>type.__new__</code> and manually setting the <code>__getattr__</code> function in the <code>dict</code>. That way you'd only have to write it once. If <code>clself</code> is an instance of <code>type</code>, return an unbound method, else return a bound method.</span>
<span class="comment-copy">@eryksun: Put those two comments as an answer, and I'll accept it - thanks!</span>
