<div class="post-text" itemprop="text">
<p>Python have some great structures to model data.
Here are some :</p>
<pre><code>              +-------------------+-----------------------------------+
              | indexed by int    | no-indexed by int                 |
+-------------+-------------------+-----------------------------------+
| no-indexed  | [1, 2, 3]         | {1, 2, 3}                         |
| by key      | or                | or                                |
|             | [x+1 in range(3)] | {x+1 in range(3)}                 |
+-------------+-------------------+-----------------------------------+
| indexed     |                   | {'a': 97, 'c': 99, 'b': 98}       |
| by key      |                   | or                                |
|             |                   | {chr(x):x for x in range(97,100)} |
+-------------+-------------------+-----------------------------------+
</code></pre>
<p>Why python does not include by default a structure indexed by key+int (like a PHP Array) ? I know there is a library that emulate this object ( <a href="http://docs.python.org/3/library/collections.html#ordereddict-objects" rel="nofollow">http://docs.python.org/3/library/collections.html#ordereddict-objects</a>). But here is the representation of a "orderedDict" taken from the documentation :</p>
<pre><code>OrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])
</code></pre>
<p>Wouldn't it be better to have a native type that should logically be writen like this:</p>
<pre><code>['a': 97, 'b': 98, 'c': 99]
</code></pre>
<p>And same logic for orderedDict comprehension :</p>
<pre><code>[chr(x):x for x in range(97,100)]
</code></pre>
<p>Does it make sense to fill the table cell like this in the python design?
It is there any particular reason for this to not be implemented yet? </p>
</div>
<div class="post-text" itemprop="text">
<p>Python's dictionaries are implemented as hash tables. Those are inherently unordered data structures. While it is possible to add extra logic to keep track of the order (as is done in <a href="http://docs.python.org/3/library/collections.html#ordereddict-objects" rel="noreferrer"><code>collections.OrderedDict</code></a> in Python 2.7 and 3.1+), there's a non-trivial overhead involved.</p>
<p>For instance, <a href="http://code.activestate.com/recipes/576693/" rel="noreferrer">the recipe that the <code>collections</code> documentation suggest for use in Python 2.4-2.6</a> requires more than twice as much work to complete many basic dictionary operations (such as adding and removing values). This is because it must maintain a doubly-linked list to use for ordered iteration, and it needs an extra dictionary to help maintain the list. While its operations are still O(1), the constant terms are larger.</p>
<p>Since Python uses <code>dict</code> instances everywhere (for all variable lookups, for instance), they need to be very fast or every part of every program will suffer. Since ordered iteration is not needed very often, it makes sense to avoid the overhead it requires in the general case. If you need an ordered dictionary, use the one in the standard library (or the recipe it suggests, if you're using an earlier version of Python).</p>
</div>
<div class="post-text" itemprop="text">
<p>Your question appears to be "why does Python not have native PHP-style arrays with ordered keys?"</p>
<p>Python has three core non-scalar datatypes: list, dict, and tuple. Dicts and tuples are absolutely essential for implementing the language itself: they are used for assignment, argument unpacking, attribute lookup, etc. Although not really used for the core language semantics, lists are pretty essential for data and programs in Python. All three must be extremely lightweight, have very well-understood semantics, and be as fast as possible.</p>
<p>PHP-style arrays are none of these things. They are not fast or lightweight, have poorly defined runtime complexity, and they have confused semantics since they can be used for so many different things--look at the <a href="http://php.net/manual/en/ref.array.php" rel="nofollow">array functions</a>. They are actually a <em>terrible</em> datatype for almost every use case except the very narrow one for which they were created: representing <code>x-www-form-encoded</code> data. Even for this use case a failing is that earlier keys overwrite the value of later keys: in PHP <code>?a=1&amp;a=2</code> results in <code>array('a'=&gt;2)</code>. (A common structure for dealing with this in Python is the <a href="http://docs.webob.org/en/latest/#multidict" rel="nofollow">MultiDict</a>, which has ordered keys <em>and</em> values, and each key can have multiple values.)</p>
<p>PHP has one datatype that must be used for pretty much every use case without being great for any of them. Python has many different datatypes (some core, many more in external libraries) which excel at much more narrow use cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>Adding a new answer with updated information: As of <strong>C</strong>Python3.6, <strong><code>dicts</code> preserve order</strong>. Though still not index-accessible. Most likely because integer-based item-lookup is ambiguous since dict keys can be int's. (Some custom use cases exist.)</p>
<p>Unfortunately, the <a href="https://docs.python.org/3.6/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">documentation for <code>dict</code></a> hasn't been updated to reflect this (yet) and still says <em>"Keys and values are iterated over in an arbitrary order which is non-random"</em>. Ironically, the <a href="https://docs.python.org/3.6/library/collections.html#ordereddict-objects" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> docs mention the new behaviour:</p>
<blockquote>
<p><em>Changed in version 3.6</em>: With the acceptance of <a href="https://www.python.org/dev/peps/pep-0468" rel="nofollow noreferrer"><strong>PEP 468</strong></a>, order is retained for keyword arguments passed to the <a href="https://docs.python.org/3.6/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a> constructor and its <code>update()</code> method.</p>
</blockquote>
<p>And here's an article mentioning <a href="http://www.infoworld.com/article/3149782/application-development/python-36-is-packed-with-goodness.html" rel="nofollow noreferrer">some more details about it</a>:</p>
<blockquote>
<p>A minor but useful internal improvement: Python 3.6 preserves the order of elements for more structures. Keyword arguments passed to a function, attribute definitions in a class, and dictionaries all preserve the order of elements as they were defined.</p>
</blockquote>
<p>So if you're only writing code for Py36 onwards, you shouldn't need <code>collections.OrderedDict</code> unless you're using <a href="https://docs.python.org/3.6/library/collections.html#collections.OrderedDict.popitem" rel="nofollow noreferrer"><code>popitem</code></a>, <a href="https://docs.python.org/3.6/library/collections.html#collections.OrderedDict.move_to_end" rel="nofollow noreferrer"><code>move_to_end</code></a> or order-based equality.</p>
<p>Example, in Python 2.7:</p>
<pre><code>&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 0: None}
&gt;&gt;&gt; d
{'a': 1, 0: None, 'c': 3, 'b': 2, 'd': 4}
</code></pre>
<p>And in Python 3.6:</p>
<pre><code>&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 0: None}
&gt;&gt;&gt; d
{'a': 1, 'b': 2, 'c': 3, 'd': 4, 0: None}
&gt;&gt;&gt; d['new'] = 'really?'
&gt;&gt;&gt; d[None]= None
&gt;&gt;&gt; d
{'a': 1, 'b': 2, 'c': 3, 'd': 4, 0: None, 'new': 'really?', None: None}
&gt;&gt;&gt; d['a'] = 'aaa'
&gt;&gt;&gt; d
{'a': 'aaa', 'b': 2, 'c': 3, 'd': 4, 0: None, 'new': 'really?', None: None}
&gt;&gt;&gt; 
&gt;&gt;&gt; # equality is not order-based
&gt;&gt;&gt; d1 = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 0: None}
... d2 = {'b': 2, 'a': 1, 'd': 4, 'c': 3, 0: None}
&gt;&gt;&gt; d2
{'b': 2, 'a': 1, 'd': 4, 'c': 3, 0: None}
&gt;&gt;&gt; d1 == d2
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of python 3.7 this is now a default behavior for dictionaries, it was an implementation detail in 3.6 that was adopted as of June 2018 :')</p>
<blockquote>
<p>the insertion-order preservation nature of dict objects has been declared to be an official part of the Python language spec.</p>
</blockquote>
<p><a href="https://docs.python.org/3/whatsnew/3.7.html" rel="nofollow noreferrer">https://docs.python.org/3/whatsnew/3.7.html</a></p>
</div>
<span class="comment-copy">I looked at the source and it says <i>Big-O running times for all methods are the same as regular dictionaries.</i>. I'm not sure why they don't do this by default.</span>
<span class="comment-copy">A "list" is not an "ordered set"--sets have unique elements. An "ordered set" does not exist as a native datatype either.</span>
<span class="comment-copy"><code>set</code> : <code>list</code> :: <code>dict</code> : <code>list of tuples</code> (such that index-0 of the tuples is unique). But if you really want to avoid doing that (as I suspect any sane person would), then you should opt to <code>from collections import ordereddict; myOrderedDict = ordereddict()</code></span>
<span class="comment-copy">Dicts can be indexed by int--they can be indexed by any immutable type.  This table is not really a good model to think about Python datatypes.</span>
<span class="comment-copy">A simply syntax for ordered dicts would be nice though. However, I believe that the grammar fora  <code>[key:value, ..]</code>-style syntax (including ordereddict-comprehensions) would be non-trivial.</span>
<span class="comment-copy">I'm the last guy to defend PHP's poor design decisions, but claiming that ordered hashmaps are <i>"terrible"</i> choice for a core type of a dynamic language could use an example of "terribleness" more solid than "they don't act like Python's non-core MultiDict".</span>
<span class="comment-copy">@lafor I was actually giving a example of a use case where PHP's arrays are the <i>least</i> terrible. "For this one use case where PHP arrays are not too bad, they are almost as good as MultiDict." :)</span>
<span class="comment-copy">The CPython developers decided not to make the new orderedness of the normal <code>dict</code> part of the language definition, rather, it's just an implementation detail that other interpreters are not required to follow. The only places where the ordered behavior is now required are the dictionaries for <code>**kwargs</code> (which must be in the same order the keyword arguments were passed) and class attributes (which must be in the same order as the definitions in the <code>class</code> body. Other interpreters could use an <code>OrderedDict</code> for those cases, and keep their normal <code>dict</code>s unordered.</span>
