<div class="post-text" itemprop="text">
<p>It seems that since access to NumPy array data doesn't require calls into the Python interpreter, C extensions can manipulate these arrays after releasing the GIL. For instance, in <a href="https://stackoverflow.com/questions/8824739/global-interpreter-lock-and-access-to-data-eg-for-numpy-arrays">this thread</a>.</p>
<p>The built-in Python type bytearray supports the <a href="http://docs.python.org/3/c-api/buffer.html" rel="nofollow noreferrer">Buffer Protocol</a>, one member of which is</p>
<blockquote>
<p>void <strong>*buf</strong></p>
<p>A pointer to the start of the logical structure described by the
  buffer fields. [...]
  For contiguous arrays, the value points to the beginning of the memory
  block.</p>
</blockquote>
<p>My question is, can a C extension manipulate this <strong>buf</strong> after releasing the GIL (Py_BEGIN_ALLOW_THREADS) since accessing it no longer requires calls to the Python C API? Or does the nature of the Python garbage collector forbid this, since the bytearray, and its buf, might be moved during execution?</p>
</div>
<div class="post-text" itemprop="text">
<p>To clarify the short answer written as comment: you can access the *buf data without holding the GIL, provided you are sure that the Py_buffer struct is "owned" by the thread while it is running without the GIL.</p>
<p>For the sake of completeness, I should add that this may open the door to (very remote) crashes risks: if the GIL-less thread reads the data at *buf while at the same time another GIL-holding thread is running Python code that changes the same data (bytearray[index]=x) then the GIL-less thread can see unexpected changes of the data under its feet.  The opposite is true too, and even more annoying (but still theoretical): if the GIL-less thread changes the data at *buf, then other GIL-holding, Python-running threads might see strange results or even maybe crashes if doing some complex reading operations like bytearray.split().</p>
</div>
<span class="comment-copy">The <code>Py_buffer</code> struct holds a reference, and the <code>bytearray</code> can't be resized until all buffer exports have been released (i.e. while <code>ob_exports &gt; 0</code>).</span>
<span class="comment-copy">Thanks - and I take that to mean too that the buf won't be moved (as opposed to released) by the GC while the buffer is exported? Does Python even use a <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#Moving_vs._non-moving" rel="nofollow noreferrer">moving GC</a>?</span>
<span class="comment-copy">The <code>bytearray</code> is deallocated when the reference count reaches 0. Python's GC attempts to resolve reference cycles in container types (e.g. lists, classes).</span>
<span class="comment-copy">If you're interested in Python's memory allocation strategy for objects, the comments in <a href="http://hg.python.org/cpython/file/70274d53c1dd/Objects/obmalloc.c#l20" rel="nofollow noreferrer">obmalloc.c</a> cover it in some detail. Allocations larger than 256 bytes are punted to <code>malloc</code>. For small objects, memory is allocated out of 4 KiB pools. Each pool has a storage class (mutable as the pool gets reused), with block sizes ranging from 8 to 256 bytes in multiples of 8. Pools are allocated from the system in 256 KiB arenas.</span>
<span class="comment-copy">Also note that in <a href="http://hg.python.org/cpython/file/bd8afb90ebf2/Objects/obmalloc.c" rel="nofollow noreferrer">Python 3.3, obmalloc.c</a> has been updated to use anonymous <code>mmap</code> to allocate arenas in order to reduce heap fragmentation (see <a href="http://bugs.python.org/issue11849" rel="nofollow noreferrer">issue 11849</a>). Also the maximum block size was increased from 256 up to 512 bytes to better accommodate 64-bit systems (e.g. a dict object in a 64-bit system is 280 bytes, which before would have been allocated with <code>malloc</code>).</span>
