<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1132941/least-astonishment-and-the-mutable-default-argument">“Least Astonishment” and the Mutable Default Argument</a>
<span class="question-originals-answer-count">
                    32 answers
                </span>
</li>
</ul>
</div>
<p>The following code</p>
<pre><code>def f(x,l=[]):
    for i in range(x):
        l.append(i*i)
    print(l) 

f(2)
f(3)
</code></pre>
<p>outputs</p>
<blockquote>
<p>[0, 1]</p>
<p>[0, 1, 0, 1, 4]</p>
</blockquote>
<p>And not the trivial</p>
<blockquote>
<p>[0, 1]</p>
<p>[0, 1, 4]</p>
</blockquote>
<p>This means that the named argument <code>l</code> is actually a single consistent variable THAT DOESN'T GET RESET on new calls to <code>f</code>.</p>
<p>This is obviously not a bug, and is by design.</p>
<p>My question is <strong>why is this the desired behavior</strong>? To me it seems more confusing than helpful, and this would make me never want to use default values that are not immutable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Functions are defined once, so when using default args with mutable types, they use a single reference to that default arg (because it's again, defined once). This is why it is bad practice to use lists, dicts, etc as default args over immutable types like None, int, str, etc.</p>
<p>As an example:</p>
<pre class="lang-py prettyprint-override"><code>
def mutable_arg(x=[]):
    x.append(3)
    print(x)

def immutable_arg(x=None):
    x = x or []
    x.append(3)
    print(x)

mutable_arg() # prints [3]
mutable_arg() # prints [3,3]
immutable_arg() # prints [3]
immutable_arg() # prints [3]
</code></pre>
<p>In <code>immutable_arg</code>, it's creating a new list for each call, rather than re-using the same default as in <code>mutable_arg</code></p>
</div>
<span class="comment-copy">The default value could be something much more expensive to compute than an empty list literal, in which case you would only want to evaluate it <i>once</i>, when you define the function, rather than every single time you <i>call</i> the function.</span>
<span class="comment-copy">Plus, there's already a way to execute code on each call: put it in the body of the function.</span>
<span class="comment-copy">@chepner about your second comment - obviously putting code in the function body would execute it every call. But is putting a variable in the named arguments really the pythonic way to create a "static" variable?</span>
<span class="comment-copy">@Gulzar making a default arg an immutable type is pythonic. It does not force typing, though, if that's what you mean by <i>static</i>. That's why you can have <code>some_arg=None</code> and replace it with a different type</span>
<span class="comment-copy">@Gulzar The Pythonic way to create a C-style static variable would be to define a method of a class instead. But just because there's no strong or obvious use case for a mutable default argument doesn't mean there is compelling  reason to <i>disallow</i> it.</span>
<span class="comment-copy">I understand the mechanism by which this occurs. I also realize why it is bad practice, as explained in the question. I do not, however, understand WHY this is the design choice. Why allow this pitfall in the first place, rather that automatically re-initializing?</span>
<span class="comment-copy">See @chepner's comment, then. Why would you <i>want</i> to re-define an argument every time?</span>
