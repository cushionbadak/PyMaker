<div class="post-text" itemprop="text">
<p>I have some models and they are nested each others. I want to make a bulk create for 2 serializers , both have relations with other models. I looked at documentation on <a href="https://www.django-rest-framework.org/api-guide/serializers/#writable-nested-representations" rel="nofollow noreferrer">DRF</a> but could not implement it in my code.</p>
<p>I send my json data like this:</p>
<pre><code>{
  'status':true,
  'products':[
              {
               'painting':{'amount':10}, 
               'product':{'id':12, }
              },
              {
               'painting':{'amount':10}, 
               'product':{'id':12, }
              }
             ],
   'customer':{ 'name':'Adnan',
                'address':{'country':'Turkey'}
              },
    'total':111

}

</code></pre>
<pre class="lang-py prettyprint-override"><code>#models.py

class Address():
    ...
class Customer():
    address = models.ForeignKey(Address, ...)
class Painting():
    ...
class Product():
    ...
class Selling():
    customer = models.ForeignKey(Customer, ...)
    products = models.ManyToManyField(Product, through='SellingProduct')
class SellingProduct():
    selling = models.ForeignKey(Selling, ...)
    product = models.ForeignKey(Product, ...)
    painting = models.ForeignKey(Painting, ...)

</code></pre>
<p>Here is my <code>serializers.py</code></p>
<pre class="lang-py prettyprint-override"><code>class AddressSerializer():
    ...
class CustomerSerializer():
    address = AddressSerializer()
    ...
class PaintingSerializer():
    ...
class ProductSerializer():
    ...
class SellingProductSerializer():
    painting = PaintingSerializer()
    product = ProductSerializer()

class SellingSerializer():
    customer = CustomerSerializer()
    products = SellingProductSerializer(many=True)
    ...
    def create(self, validated_data):
        ...
</code></pre>
<p>If I write this:</p>
<pre class="lang-py prettyprint-override"><code>class SellingSerializer():
    ...
    def create(self, validated_data):
        customer_data = validated_data.pop('customer')
        products_data = validated_data.pop('products')
        selling = Selling.objects.create(**validated_data) #i didn't pass customer here
        for product_data in products_data:
            SellingProducts.objects.create(selling=selling, **product_data)
        return selling
</code></pre>
<p>I'm getting this error:</p>
<pre class="lang-sh prettyprint-override"><code>django.db.utils.IntegrityError: (1048, "Column 'customer_id' cannot be null")
</code></pre>
<p>If I write this:</p>
<pre class="lang-py prettyprint-override"><code>class SellingSerializer():
    ...
    def create(self, validated_data):        
        selling = Selling.objects.create(**validated_data) #i didn't pass customer here        
        return selling
</code></pre>
<p>I'm getting this error:</p>
<pre class="lang-sh prettyprint-override"><code>ValueError: Cannot assign "OrderedDict...
..Selling.customer must be a "Customer" instance
</code></pre>
<ul>
<li>I don't know how to extract or access data if its type is OrderedDict. How can I do this also?</li>
</ul>
<h3>I want to create a record for Selling and SellingProduct, Painting and I DON'T want to create Customer, Address, Product records in every request and I will use existence(in front-end selected) datas.</h3>
<p>Thank you all in advance for any help!</p>
</div>
<div class="post-text" itemprop="text">
<p>Your first approach should work, if you make a few modifications. Your Selling model is dependent on on a Customer, so you first need to create a Customer. Then, your SellingProduct model is dependent on a Product and Painting, so you first need to create a Product and Painting, then create a SellingProduct with instances of those, like this:</p>
<pre><code>class SellingSerializer():
    ...
    def create(self, validated_data):
        customer_data = validated_data.pop('customer')
        selling_products_data = validated_data.pop('products')

        customer = Customer.objects.create(**customer_data)
        selling = Selling.objects.create(customer=customer, **validated_data)

        for selling_product_data in selling_products_data :
            product_data = selling_product_data.pop('product')
            product = Product.objects.create(**product_data)

            painting_data = selling_product_data.pop('painting')
            painting = Painting.objects.create(**painting_data)

            SellingProducts.objects.create(selling=selling, product=product, painting=painting)

        return selling
</code></pre>
<p>Of course, this approach creates a new Customer, Products and Paintings for each request. Is this really what you want? If you do not want to create new Product and Painting instances for each request, but use references to existing instances, you can define them as <strong>PrimaryKeyRelatedField</strong> fields in the SellingSerializer and SellingProductSerializer. Then, you can change your create function to this:</p>
<pre><code>def create(self, validated_data):
    customer = validated_data.pop('customer')
    selling_products_data = validated_data.pop('products')

    selling = Selling.objects.create(customer=customer, **validated_data)

    for selling_product_data in selling_products_data :
        SellingProducts.objects.create(selling=selling, **selling_product_data )

    return selling
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to use your <code>CustomerSerializer</code> to create a customer object and database row before you can create a <code>Selling</code> object with a foreign key to it. You are trying either not passing anything or are passing the JSON (that turns into the <code>OrderedDict</code> in your error message).</p>
<pre><code>class SellingSerializer():
    ...
    def create(self, validated_data):
        customer_data = validated_data.pop('customer')
        products_data = validated_data.pop('products')
        customer = CustomerSerializer.save(**customer_data)
        selling = Selling.objects.create(customer=customer, **validated_data)
        for product_data in products_data:
            SellingProducts.objects.create(selling=selling, **product_data)
        return selling
</code></pre>
<p>Maybe reread the <a href="https://www.django-rest-framework.org/api-guide/serializers/#writable-nested-representations" rel="nofollow noreferrer">documentation</a> on this issue. </p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>SellingSerializer is related with CustomerSerializerh, ProductSerializer</p></li>
<li><p>Before creating Selling object, we can validate each serializer and create</p></li>
<li><p>update validated data</p></li>
<li><p>the process many to many </p></li>
</ol>
<p><em>You would  not be just creating customer object product object.Data has to be validated and can use CustomerSerializer and ProductSerializer. Before creating them serialize your data with CustomerSerializer and ProductSerializer, then is valid create object else raise exception.</em></p>
<pre class="lang-py prettyprint-override"><code>class SellingSerializer():
    ...

    def create(self, validated_data):
        # First Let's handle Customer data
        customer_data = validated_data.pop('customer')
        customer_serializer = CustomerSerializer(data=customer_data)
        customer_serializer.is_valid(raise_exception=True)
        customer = customer_serializer.save()
        validated_data.update({'customer':customer})  ## update our validated data with customer instance

        # Create Selling object
        selling = Selling.objects.create(**validated_data)  # will receive customer instance as well

        # Handle Products related Data
        products_data = validated_data.pop('products')
        for product_data in products_data:
            product_serializer = ProductSerializer(data=product_data)
            product_serializer.is_valid(raise_exception=True)
            product = product_serializer.save()
            SellingProducts.objects.create(selling=selling, product=product)

        return selling
</code></pre>
</div>
<span class="comment-copy">Perhaps look at <a href="https://stackoverflow.com/questions/22590895/circular-dependency-in-serializers/22591742" title="circular dependency in serializers">stackoverflow.com/questions/22590895/â€¦</a></span>
<span class="comment-copy">Can you be more specific about the problem you are experiencing?  You should be able to unpack the values in create() and persist instances directly, as per the DRF docs</span>
<span class="comment-copy">@MatthewHegarty I edited it.</span>
