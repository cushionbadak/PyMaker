<div class="post-text" itemprop="text">
<p>I am trying to use this <a href="https://stackoverflow.com/questions/2407126/python-urllib2-basic-auth-problem">Python urllib2 Basic Auth Problem</a> bit of code to download a webpage content from an URL which requires authentication. The code I am trying is:</p>
<pre><code> import urllib2, base64

request = urllib2.Request("http://api.foursquare.com/v1/user")
base64string = base64.encodestring('%s:%s' % (username, password)).replace('\n', '')
request.add_header("Authorization", "Basic %s" % base64string)   
result = urllib2.urlopen(request)
</code></pre>
<p>It's showing me:</p>
<pre><code>./xx.py: line 1: import: command not found
./xx.py: line 3: syntax error near unexpected token `('
./xx.py: line 3: `request = urllib2.Request("http://api.foursquare.com/v1/user")'
</code></pre>
<p>I am wondering what I am doing wrong? I am using <code>Python 2.7.5</code>. How can I download file contents from an URL which requires authentication?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not an issue related to authentication at the first step. Your <code>import</code> is not working. So, try writing this on first line:</p>
<pre><code>#!/usr/bin/python
</code></pre>
<p>and for the time being run using </p>
<pre><code>python xx.py
</code></pre>
<p>For you here is one explanation:</p>
<pre><code>&gt;&gt;&gt; abc = "Hei Buddy"
&gt;&gt;&gt; print "%s" %abc
Hei Buddy
&gt;&gt;&gt; 

&gt;&gt;&gt; print "%s" %xyz

Traceback (most recent call last):
  File "&lt;pyshell#6&gt;", line 1, in &lt;module&gt;
    print "%s" %xyz
NameError: name 'xyz' is not defined
</code></pre>
<p>At first, I initialized abc variable and it works fine. On the otherhand, xyz doesn't work as it is not initialized!</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you using a UNIX based OS such as Linux? If so, add a <strong><a href="https://stackoverflow.com/questions/2429511/why-do-people-write-usr-bin-env-python-on-the-first-line-of-a-python-script">shebang</a></strong> line to the very top of your script:</p>
<pre><code>#!/usr/bin/python
</code></pre>
<p>Underneath which you would have the rest of the code (<code>xx.py</code> in your case) that you already have. Then run that same command at the terminal:</p>
<pre><code>$ python xx.py
</code></pre>
<p>This should then work fine, as it is now interpreting this as Python code. However when running from the terminal this does not matter as <code>python</code> tells how to interpret it here. What it does allow you to do is execute it outside the terminal, i.e. executing it from a file browser.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you see "import: command not found" on the very first import, it is caused by the parser not using the character encoding matching your py file.  Especially when you are not using ASCII encoding in your py file.</p>
<p>The way to get it right is to specify the correct encoding on top of your py file to match your file character encoding.</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you run a script directly e.g., <code>./xx.py</code> and your script has no shebang such as <code>#!/usr/bin/env python</code> at the very top then your shell may execute it as a shell script. <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_09_01_01" rel="nofollow">POSIX says</a>:</p>
<blockquote>
<p>If the execl() function fails due to an error equivalent to the
  [ENOEXEC] error defined in the System Interfaces volume of
  POSIX.1-2008, the shell shall execute a command equivalent to having a
  shell invoked with the pathname resulting from the search as its first
  operand, with any remaining arguments passed to the new shell, except
  that the value of "$0" in the new shell may be set to the command
  name. If the executable file is not a text file, the shell may bypass
  this command execution. In this case, it shall write an error message,
  and shall return an exit status of 126.</p>
</blockquote>
<p>Note: you may get <code>ENOEXEC</code> if your text file has no shebang.</p>
<p>Without the shebang, you shell tries to run your Python script as a shell script that leads to the error: <code>import: command not found</code>.</p>
<p>Also, if you run your script as <code>python xx.py</code> then you do not need the shebang. You don't even need it to be executable (<code>+x</code>). Your script is interpreted by <code>python</code> in this case. </p>
<p>On Windows, shebang is not used unless <a href="https://bitbucket.org/vinay.sajip/pylauncher" rel="nofollow">pylauncher is installed</a>. It is <a href="http://docs.python.org/3/using/windows.html?#launcher" rel="nofollow">included in Python 3.3+</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've experienced the same problem and now I just found my solution to this issue.</p>
<pre><code>#!/usr/bin/python

import sys
import os

os.system('meld "%s" "%s"' % (sys.argv[2], sys.argv[5]))
</code></pre>
<p>This is the code[1] for my case. When I tried this script I received error message like :</p>
<blockquote>
<p>import: command not found</p>
</blockquote>
<p>I found people talks about the shebang. As you see there is the shebang in my python code above.
I tried these and those trials but didn't find a good solution.</p>
<p>I finally tried to type the shebang my self.</p>
<pre><code>#!/usr/bin/python
</code></pre>
<p>and removed the copied one.</p>
<p>And my problem solved!!!</p>
<p>I copied the code from the internet[1].</p>
<p>And I guess there had been some unseeable(?) unseen special characters in the original copied shebang statement.</p>
<p>I use vim, sometimes I experience similar problems.. Especially when I copied some code snippet from the internet this kind of problems happen.. Web pages have some virus special characters!! I doubt. :-)</p>
<p>Journeyer</p>
<p>PS) I copied the code in Windows 7 - host OS - into the Windows clipboard and pasted it into my vim in Ubuntu - guest OS. VM is Oracle Virtual Machine.</p>
<p>[1] <a href="http://nathanhoad.net/how-to-meld-for-git-diffs-in-ubuntu-hardy" rel="nofollow">http://nathanhoad.net/how-to-meld-for-git-diffs-in-ubuntu-hardy</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It's about <a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29" rel="nofollow">Shebang</a></p>
<pre><code>#!usr/bin/python
</code></pre>
<p>This will tell which interpreter to wake up to run the code written in file.</p>
</div>
<span class="comment-copy">If import is not found then it is not related to authentication.  Can you try to run python and then enter each command one by one?</span>
<span class="comment-copy">to avoid the <code>.replace()</code> call, use <code>base64.b64encode()</code> instead of <code>encodestring()</code></span>
<span class="comment-copy">You either need 1.) The shebang <code>#!/usr/bin/env python</code> on the first line along with executable flag on the script file to be able to run the script with <code>./xx.py</code> OR 2.) you have to run the script with the <code>python xx.py</code> command. In the second case you don't need the shebang and the executable flag.</span>
<span class="comment-copy">@pasztorpisti ...that said, if the goal is to define a command, the shebang and +x flag are the Right Approach (and the script probably shouldn't have a <code>.py</code> extension at all; see <a href="https://www.talisman.org/~erlkonig/documents/commandname-extensions-considered-harmful" rel="nofollow noreferrer">talisman.org/~erlkonig/documents/â€¦</a> for more discussion on that point).</span>
<span class="comment-copy">@pasztorpisti ...not just not needed, but actively harmful, as it means you can't reimplement in a different language without either needing to modify all callers or keeping it there with a now-misleading extension. And also, as we put it to people in #bash, "do you run <code>ls.elf</code>?"</span>
<span class="comment-copy">When I runned my script with your command then it shows: <code>base64string = base64.encodestring('%s:%s' % (abc, xyz)).replace('\n', '') NameError: name 'abc' is not defined</code></span>
<span class="comment-copy">You are replacing %s with a variable called abc, so you need to initialize that first!</span>
<span class="comment-copy">Because <code>abc</code> is probably not instantiated. Don't get ahead of yourself. Instantiate your variables ahead of using them.</span>
<span class="comment-copy">It's not necessary to <b>both</b> add the shebang and explicitly invoke an interpreter. As such, I'm not sure this really constitutes good advice.</span>
<span class="comment-copy">Also, the discussion of the unrelated variable initialization issues distract from the on-topic response to the actual question. Better to ask the questioner to file a separate Q than to make something that's less useful to other people.</span>
<span class="comment-copy">I know, that's obvious. I was just making the question more applicable to new users that may stumble across this post with the same problem, thank you. That way, when they read my post they know that if they are using UNIX it will be applicable to them.</span>
<span class="comment-copy">When I runned my script with your command then it shows: <code>base64string = base64.encodestring('%s:%s' % (abc, xyz)).replace('\n', '') NameError: name 'abc' is not defined</code></span>
<span class="comment-copy">@user2481422 That cannot be, as the line that it is saying is incorrect is not in the code that you have posted. Post the full code. But anyway, Python is saying that it cannot find a variable named <code>abc</code>. Try declaring it first with <code>abc = 'some_value'</code>. But this is a separate issue, so I won't discuss it here. If the problem persists, ask a different question. The issue that you have posted in the question is solved with my answer.</span>
<span class="comment-copy">Upvoted your answer</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/22275721/4279">you do not need the shebang if you run it as <code>python xx.py</code></a></span>
<span class="comment-copy">this should be helpful since utf-8 is the most popular encoding nowadays, even on Python source code</span>
