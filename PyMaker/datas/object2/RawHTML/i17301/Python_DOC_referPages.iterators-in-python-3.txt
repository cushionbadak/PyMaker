<div class="post-text" itemprop="text">
<p>In Python 3 a lot of functions (now classes) that returned lists now return iterables, the most popular example being <code>range</code>. In this case range was made an iterable in Python 3 to improve performance, and memory efficiency (since you don't have to build a list anymore). </p>
<p>Other "new" iterables are <code>map</code>, <code>enumerate</code>, <code>zip</code> and the output of the dictionary operations <code>dict.keys()</code>, <code>dict.values()</code> and <code>dict.items()</code>. (There are probably more, but I don't know them).</p>
<p>Some of them (<code>enumerate</code> and <code>map</code>) have become probably more memory efficient by converting them into iterables. In Python 2.7 the others simply created lists of objects which were already in memory, so they would have been memory efficient.</p>
<p>Why then turn them into iterables which you have to convert to lists every time you want to sort them, etc.?</p>
</div>
<div class="post-text" itemprop="text">
<p>Several reasons:</p>
<ol>
<li><p>The dictionary operations now return <a href="http://docs.python.org/3/library/stdtypes.html#dictionary-view-objects">dictionary view objects</a>; these act as sets as well, giving you a far richer object to work with in your code. In Python 2 you'd have to use the <code>dict.view*()</code> methods to do the same.</p></li>
<li><p>The dictionary operations in Python 2 produced a new list object; that list object takes up memory too, even if the indices reference existing objects. There is another side effect here; the list indices increment the reference counts on all those dictionary contents, which impacts performance as well (and potentially flush the CPU cache).</p></li>
<li><p><code>zip()</code> and <code>map()</code> could always work on any iterables, including generators, but would pull everything into a big list when applied. By turning them into generators in Python 3 they no longer auto-consume such iterables.</p></li>
</ol>
<p>Note that <code>enumerate()</code> in Python 2 never returned a list, it has always returned an iterator.</p>
<p>You can always get the old Python 2 behaviour simply by applying <code>list()</code> on such objects. If you needed sorted items, you'd call <code>sorted()</code> on the iterable. But you now have the <em>choice</em> rather than have the list object forced on you.</p>
<p>And for <em>most</em> use cases in Python, you never really needed to have a whole list to begin with. You usually iterate over such results. Sorting them is not the most common use case, indexing them isn't either. So for most use cases, the change is a win, giving programmers the tools to produce more efficient code with just the standard functions and types.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to sort them, the iterable needs to be turned into a list (which <code>sorted</code> will handle for you)... but how often are you going to sort an <code>enumerate</code> object, compared to how often you're going to just iterate over it? What about sorting the <code>items</code> of a dict, compared to just iterating over them?</p>
<p>If your API produces a lazy iterator or other lazy iterable, you can turn that into a list with roughly the same amount of effort it would have taken to skip the iterator and produce a list directly. On the other hand, if your API produces a list, there's no way to avoid holding all the items in memory at once. The iterator is more flexible.</p>
</div>
<span class="comment-copy"><code>enumerate()</code> was an iterable in Python 2 already.</span>
<span class="comment-copy">Creating a list object is not memory efficient; the <code>list</code> object is  a new object right there.</span>
<span class="comment-copy">Also, building a view requires incrementing the refcount on the dict, while building a list means incrementing the refcounts on all the objects. With a big dict, that's an effective way of flushing the CPU cache.</span>
<span class="comment-copy">@larsmans: thanks, added that too.</span>
<span class="comment-copy">"By turning them into "generators" -- make that "iterators" for <code>map</code>, <code>filter</code>, and <code>zip</code>. FYI to the OP, <code>range</code> is a sequence, not just an iterable.</span>
<span class="comment-copy"><code>sorted()</code> would also do if you wanted a sorted copy.</span>
<span class="comment-copy">@MartijnPieters: I probably ought to make it clearer that by "you need to create a list", I mean "a list will need to be made", rather than "you need to call <code>list</code> on it".</span>
