<div class="post-text" itemprop="text">
<p>I'm trying to a program that executes a piece of code in such a way that the user can stop its execution at any time without stopping the main program. I thought I could do this using threading.Thread, but then I ran the following code in IDLE (Python 3.3):</p>
<pre><code>from threading import *
import math
def f():
    eval("math.factorial(1000000000)")
t = Thread(target = f)
t.start()
</code></pre>
<p>The last line doesn't return: I eventually restarted the shell. Is this a consequence of the Global Interpreter Lock, or am I doing something wrong? I didn't see anything specific to this problem in the threading documentation (<a href="http://docs.python.org/3/library/threading.html" rel="nofollow">http://docs.python.org/3/library/threading.html</a>)</p>
<p>I tried to do the same thing using a process:</p>
<pre><code>from multiprocessing import *
import math
def f():
    eval("math.factorial(1000000000)")

p = Process(target = f)
p.start()
p.is_alive()
</code></pre>
<p>The last line returns False, even though I ran it only a few seconds after I started the process! Based on my processor usage, I am forced to conclude that the process never started in the first place. Can somebody please explain what I am doing wrong here?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Thread.start() never returns! Could this have something to do with the C implementation of the math library?      </p>
</blockquote>
<p>As <a href="https://stackoverflow.com/questions/22138190/python-threading-thread-start-doesnt-return-control-to-main-thread#comment33634685_22138509">@eryksun</a> pointed out in the comment: <a href="http://hg.python.org/cpython/file/d37f963394aa/Modules/mathmodule.c#l1087" rel="nofollow noreferrer">math.factorial() is implemented as a C function</a> that doesn't release GIL so no other Python code may run until it returns. </p>
<p>Note: <code>multiprocessing</code> version should work as is: each Python process has its own GIL.</p>
<hr/>
<p><code>factorial(1000000000)</code> has hundreds millions of digits. Try <code>import time; time.sleep(10)</code> as dummy calculation instead.</p>
<p>If you have issues with multithreaded code in IDLE then try the same code from the command line, to make sure that the error persists.</p>
<p>If <code>p.is_alive()</code> returns <code>False</code> after <code>p.start()</code> is already called then it might mean that there is an error in <code>f()</code> function e.g., <code>MemoryError</code>.</p>
<p>On my machine, <code>p.is_alive()</code> returns <code>True</code> and one of cpus is at 100% if I paste your code from the question into Python shell.</p>
<p>Unrelated: remove wildcard imports such as <code>from multiprocessing import *</code>. They may shadow other names in your code so that you can't be sure what a given name means e.g., <code>threading</code> could define <code>eval</code> function (it doesn't but it could) with a similar but different semantics that might break your code silently.</p>
<blockquote>
<p>I want my program to be able to handle ridiculous inputs from the user gracefully</p>
</blockquote>
<p>If you pass user input directly to <code>eval()</code> then the user can do <em>anything</em>. </p>
<blockquote>
<p>Is there any way to get a process to print, say, an error message without constructing a pipe or other similar structure?</p>
</blockquote>
<p>It is an ordinary Python code:</p>
<pre><code>print(message) # works
</code></pre>
<p>The difference is that if several processes run <code>print()</code> then the output might be garbled. You could use a lock to synchronize <code>print()</code> calls.  </p>
</div>
<span class="comment-copy">Your suggestion about time.sleep() returns as I would expect. However, I chose an absurd calculation like factorial(1000000000) because I want my program to be able to handle ridiculous inputs from the user gracefully. This code performs exactly the same way in the shell. Is there any way to get a process to print, say, an error message without constructing a pipe or other similar structure?</span>
<span class="comment-copy">@user3372045: I've answered your questions from the comment. Also your multiprocessing code works on my machine as expected (<code>p.is_alive() is True</code>)</span>
<span class="comment-copy">I'm not sure what you mean by "the user can do anything". My plan was to handle the eval() statement in a separate thread of control, leaving the main thread unharmed if something goes wrong there. This doesn't work if Thread.start() never returns! Could this have something to do with the C implementation of the math library? If so, I could rewrite operations like factorial in pure Python. Much slower, but worth it if I can interrupt the operation.</span>
