<div class="post-text" itemprop="text">
<p>I'm trying to read from an originally empty file, after a write, before closing it. Is this possible in Python?</p>
<pre><code>with open("outfile1.txt", 'r+') as f:
    f.write("foobar")
    f.flush()
    print("File contents:", f.read())
</code></pre>
<p>Flushing with <code>f.flush()</code> doesn't seem to work, as the final <code>f.read()</code> still returns nothing.</p>
<p>Is there any way to read the "foobar" from the file besides re-opening it?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to reset the file object's index to the first position, using <a href="https://docs.python.org/3/library/io.html#io.IOBase.seek" rel="nofollow noreferrer"><code>seek()</code></a>:</p>
<pre><code>with open("outfile1.txt", 'r+') as f:
    f.write("foobar")
    f.flush()

    # "reset" fd to the beginning of the file
    f.seek(0)
    print("File contents:", f.read())
</code></pre>
<p>which will make the file available for reading from it.</p>
</div>
<div class="post-text" itemprop="text">
<p>File objects keep track of current position in the file. You can get it with <code>f.tell()</code> and set it with <code>f.seek(position)</code>. </p>
<p>To start reading from the beginning again, you have to set the position to the beginning with <code>f.seek(0)</code>.</p>
<p><a href="http://docs.python.org/2/library/stdtypes.html#file.seek" rel="nofollow">http://docs.python.org/2/library/stdtypes.html#file.seek</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Seek back to the start of the file before reading:</p>
<pre><code>f.seek(0)
print f.read()
</code></pre>
</div>
<span class="comment-copy">Why <code>read()</code> doesn't <code>seek(0)</code> automagically? Or at least there should be magic method for careless reading.</span>
<span class="comment-copy">We could find multiple reasons as for why. In the current case, python only follows the system's specification, and the behaviour you'll find in other languages (like C). The original specification is I believe based on POSIX, which follows the KISS principle, i.e. a READ only reads bytes from a file descriptor, SEEK moves the current position, FLUSH syncs the changes on the driveâ€¦</span>
<span class="comment-copy">And those actions I believe are very close to the way things actually are implemented at a system's level.</span>
<span class="comment-copy">Thanks for resources. But is it wrong concept to implement extra high-level methods in Python standard? I think e.g. Python sockets do some magic out of the box.</span>
<span class="comment-copy">It is not, because it is following the rule of least surprise. When most languages follow that protocol (that a <code>.read()</code> is reading bytes in position, and <code>.read(2)</code> will read two bytes at given position), having python doing differently will create more confusion than the other way around.</span>
