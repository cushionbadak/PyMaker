<div class="post-text" itemprop="text">
<p>I have written a Python solution here which solves the following problem: how can a given amount of money <code>n</code> be made with the least number of coins of given the denominations <code>d</code>?</p>
<pre><code>def min_coin_change(n, d):
    mini = float("inf")
    for den in d:
        diff = n - den
        if diff == 0:
            ans = 1
        elif diff &lt; 0:
            ans = float("inf")
        else:
            ans = 1 + min_coin_change(n - den, d)
        mini = min(mini, ans)
    return mini
</code></pre>
<p>While my solution works, it takes a very long time when <code>n</code> is larger than 50 or when the length of <code>d</code> is larger than 5. How can I speed up my code so it will work for considerably larger inputs? Am I missing a trick or something which would drastically speed up my code?</p>
</div>
<div class="post-text" itemprop="text">
<p>Can we assume that the coin denominations are sensible?  The general case of this problem would allow for strange coin denominations like <code>[100, 90, 1]</code> and a simple "greedy" algorithm won't find optimal solutions (e.g. for 180 the optimal solution is two 90-cent pieces, while the simple greedy algorithm would suggest one 100-cent piece and 80 pennies).</p>
<p>If we can assume sensible currency (like any real currency) then I suggest you use a combination of integer division and modulus to find how many of each coin to use.</p>
<p>If we cannot assume sensible currency, then this problem is ideal for a dynamic programming solution.  In dynamic programming, you build a table that memoizes intermediate results, which saves a lot of time compared to the simple recursive solution.</p>
<p>There is a nice explanation of dynamic programming in the Skiena book <em>The Alogorithm Design Manual</em>.</p>
<p><a href="http://www.algorist.com/" rel="nofollow">http://www.algorist.com/</a></p>
<p>Here are some links I found online:</p>
<p><a href="http://www.avatar.se/molbioinfo2001/dynprog/dynamic.html" rel="nofollow">http://www.avatar.se/molbioinfo2001/dynprog/dynamic.html</a></p>
<p><a href="http://www.codechef.com/wiki/tutorial-dynamic-programming" rel="nofollow">http://www.codechef.com/wiki/tutorial-dynamic-programming</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Note that you should set up your function to start with the largest coin, loop through for the maximum possible number of largest coins, then repeat with the next largest coin.</p>
<p>Thus den should be sorted in decreasing order</p>
<pre><code>def changecoin(d, denval)
  count = 0
  while d &gt; denval:
    d -= denval
    count += 1
  return count, d
</code></pre>
<p>now call the recursion with the next lowest value of denval and the new d valueand increment the count appropriately.</p>
<pre><code>newcount = 0
for denval in den:
    count, d = changecoin(d, denval)
    newcount += count
</code></pre>
<p>Actually, looking at the code, the changecoin function can be somewhat fixed by eliminating the while so that the inline code can be written</p>
<pre><code>count = 0
for denval in den
  count += d//denval
  d = d % denval
</code></pre>
<p>This returns the count and whatever value is left in d. If d is less than denval, the count increment would be 0 and the remaining d is unchanged. While the for loop is unbroken when d becomes 0, there are few enough entries in den that the test can be left out</p>
<pre><code>  if d &lt; 1:
    break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is because it is recursive </p>
<p>Read this <a href="https://stackoverflow.com/questions/1988804/what-is-memoization-and-how-can-i-use-it-in-python">What is memoization and how can I use it in Python?</a>  (and the top 2 answers)</p>
<p>"memoization"  remembers things you have calculated already (eg 10 cents) so you don't recalculate them an exponential number of times. </p>
<p>You can copy the Mwmoize class as is, 
and just "decorate" your function, as explained in the second answer</p>
<hr/>
<p>FOR THE LAZY </p>
<pre><code>class Memoize:
    def __init__(self, f):
        self.f = f
        self.memo = {}
    def __call__(self, *args):
        if not args in self.memo:
            self.memo[args] = self.f(*args)
        return self.memo[args]
</code></pre>
<p>then add the decorator before the definition</p>
<pre><code>@Memoize
def min_coin_change(n,d)......
</code></pre>
<p>the rest of the function is the same</p>
<p>then you call it </p>
<pre><code>min_coin_change(30,(25,10,5,1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a faster version of your program. I've changed two things:</p>
<ul>
<li><p>Implementation detail: all recursive programs can be re-written as equivalent iterative programs (in this case, using a <code>for</code> and a <code>while</code> loop). In most languages, the iterative version is faster as there is no need to maintain a stack.</p></li>
<li><p>Algorithm: I am using a greedy algorithm that starts off with the largest-value coins first, and then tries the smaller coins. This is not guaranteed to be optimal, as pointed out in other answers, but runs very fast (linear in the number of coins in the returned solution). Have a look at <a href="http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/" rel="nofollow">this page</a> for an optimal (but slower) dynamic programming solution.</p></li>
</ul>
<pre>
def min_coin_change2(n, d):
    current_amount = 0
    used_coins = []

    for coin_value in sorted(d, reverse=True):
        while n - current_amount &gt;= coin_value:
            current_amount += coin_value
            used_coins.append(coin_value)

    excuse = '' if current_amount == n else ', but that is not what you asked for'
    return 'I can get to %d using %s%s' % (current_amount, used_coins, excuse)

</pre>
<p>Let's try it out:</p>
<pre><code>print min_coin_change2(101, [50, 20, 10, 1])
Out[25]: 'I can get to 101 using [50, 50, 1]'
</code></pre>
<p>and again, when it is impossible to get the desired amount</p>
<pre><code>print min_coin_change2(101, [50, 20, 10])
Out[26]: 'I can get to 100 using [50, 50], but that is not what you asked for'
</code></pre>
<p>and again, when the greedy algorithm finds a sub-optimal solution</p>
<pre><code>print min_coin_change2(180, [100, 90, 20])
Out[2]: 'I can get to 180 using [100, 20, 20, 20, 20]'
</code></pre>
<p>but the optimal solution would have been <code>[90, 90]</code></p>
</div>
<span class="comment-copy">I just added an even simpler method replacing the loop with integer division and modulo. This makes it two lines in the main coinage loop and does not require any recursion.</span>
<span class="comment-copy">is 25,10,1 sensible? not all real currencies have the feature that any coin is divisible by all smaller denominations .</span>
<span class="comment-copy">No, <code>[25, 10, 1]</code> is not sensible.  My definition of "sensible" is "will the simple greedy algorithm work" and if you try to make optimal change for 30 cents you need to use 3 10-cent pieces, while greedy would suggest 1 25-cent piece and 5 pennies.  But the real currencies I have seen tend to have a 5-cent piece which would make this "sensible" again.  I think the important thing is not which coins are divisible by other coins, but whether there is a smooth continuum of smaller coins to keep making change the greedy way.</span>
<span class="comment-copy">you do realize though that algorithms should be tailored to fit input and not the other way around</span>
<span class="comment-copy">so for 30cents (with no nickels) you would take a quarter and five pennies ?</span>
<span class="comment-copy">@vish Why would you specify no nickels? However, if that is what you speify, then that would be the correct answer.</span>
<span class="comment-copy">no, the correct answer would be 3 dimes.   i was giving a counter example. that is why</span>
<span class="comment-copy">@vish good point. The algoritm needs to be redone then to allow for it. perhaps set up a check for that type of case</span>
<span class="comment-copy">@vish of course, the real world situation does have the 5 as a valid value. An example of a real world case can be Israel where the coinage is [1000, 500, 100, 50, 25, 10, 5, 1]</span>
<span class="comment-copy">In Python 3.2 and newer, you can use <code>functools.lru_cache</code> which is a memoizing decorator.  <a href="http://docs.python.org/3/library/functools#functools.lru_cache" rel="nofollow noreferrer">docs.python.org/3/library/functools#functools.lru_cache</a></span>
