<div class="post-text" itemprop="text">
<p>I have a base class that defines a class attribute and some child classes that depend on it, e.g.</p>
<pre><code>class Base(object):
    assignment = dict(a=1, b=2, c=3)
</code></pre>
<p>I want to unittest this class with different <em>assignments</em>, e.g. empty dictionary, single item, etc. This is extremely simplified of course, it's not a matter of refactoring my classes or tests</p>
<p>The (pytest) tests I have come up with, eventually, that work are</p>
<pre><code>from .base import Base

def test_empty(self):
    with mock.patch("base.Base.assignment") as a:
        a.__get__ = mock.Mock(return_value={})
        assert len(Base().assignment.values()) == 0

def test_single(self):
    with mock.patch("base.Base.assignment") as a:
        a.__get__ = mock.Mock(return_value={'a':1})
        assert len(Base().assignment.values()) == 1
</code></pre>
<p>This feels rather complicated and hacky - I don't even fully understand why it works (I am familiar with descriptors though). Does mock automagically transform class attributes into descriptors?</p>
<p>A solution that would feel more logical does not work:</p>
<pre><code>def test_single(self):
    with mock.patch("base.Base") as a:
        a.assignment = mock.PropertyMock(return_value={'a':1})
        assert len(Base().assignment.values()) == 1
</code></pre>
<p>or just</p>
<pre><code>def test_single(self):
    with mock.patch("base.Base") as a:
        a.assignment = {'a':1}
        assert len(Base().assignment.values()) == 1
</code></pre>
<p>Other variants that I've tried don't work either (assignments remains unchanged in the test). </p>
<p>What's the proper way to mock a class attribute? Is there a better / more understandable way than the one above?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>base.Base.assignment</code> is simply replaced with a <code>Mock</code> object. You <em>made</em> it a descriptor by adding a <code>__get__</code> method.</p>
<p>It's a little verbose and a little unnecessary; you could simply set <code>base.Base.assignment</code> directly:</p>
<pre><code>def test_empty(self):
    Base.assignment = {}
    assert len(Base().assignment.values()) == 0
</code></pre>
<p>This isn't too safe when using test concurrency, of course.</p>
<p>To use a <code>PropertyMock</code>, I'd use:</p>
<pre><code>with patch('base.Base.assignment', new_callable=PropertyMock) as a:
    a.return_value = {'a': 1}
</code></pre>
<p>or even:</p>
<pre><code>with patch('base.Base.assignment', new_callable=PropertyMock, 
           return_value={'a': 1}):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To improve readability you can use the <code>@patch</code> decorator:</p>
<pre><code>from mock import patch
from unittest import TestCase

from base import Base

class MyTest(TestCase):
    @patch('base.Base.assignment')
    def test_empty(self, mock_assignment):
        # The `mock_assignment` is a MagicMock instance,
        # you can do whatever you want to it.
        mock_assignment.__get__.return_value = {}

        self.assertEqual(len(Base().assignment.values()), 0)
        # ... and so on
</code></pre>
<p>You can find more details at <a href="http://www.voidspace.org.uk/python/mock/patch.html#mock.patch" rel="noreferrer">http://www.voidspace.org.uk/python/mock/patch.html#mock.patch</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your class (Queue for example) in <em>already imported</em> inside your test - and you want to patch <strong>MAX_RETRY</strong> attr - you can use <strong><a href="https://docs.python.org/3/library/unittest.mock.html#patch-object" rel="nofollow noreferrer">@patch.object</a></strong> or simply better <strong><a href="https://docs.python.org/3/library/unittest.mock.html#patch-multiple" rel="nofollow noreferrer">@patch.multiple</a></strong> </p>
<pre><code>from mock import patch, PropertyMock, Mock
from somewhere import Queue

@patch.multiple(Queue, MAX_RETRY=1, some_class_method=Mock)
def test_something(self):
    do_something()


@patch.object(Queue, 'MAX_RETRY', return_value=1, new_callable=PropertyMock)
def test_something(self, _mocked):
    do_something()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps I'm missing something, but isn't this possible without using <code>PropertyMock</code>?</p>
<pre><code>with mock.patch.object(Base, 'assignment', {'bucket': 'head'}):
   # do stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is an example how to unit-test your <code>Base</code> class:</p>
<ul>
<li>mocking <em>multiple class attributes</em> of different types (ie: <code>dict</code> and <code>int</code>)   </li>
<li>using the <code>@patch</code> decorator and <code>pytest</code> framework with  with <code>python 2.7+</code> or <code>3+</code>.</li>
</ul>
<hr/>
<pre><code># -*- coding: utf-8 -*-
try: #python 3
    from unittest.mock import patch, PropertyMock
except ImportError as e: #python 2
    from mock import patch, PropertyMock 

from base import Base

@patch('base.Base.assign_dict', new_callable=PropertyMock, return_value=dict(a=1, b=2, c=3))
@patch('base.Base.assign_int',  new_callable=PropertyMock, return_value=9765)
def test_type(mock_dict, mock_int):
    """Test if mocked class attributes have correct types"""
    assert isinstance(Base().assign_dict, dict)
    assert isinstance(Base().assign_int , int)
</code></pre>
</div>
<span class="comment-copy">Bar.assignment.__get__ = lambda: {1:1} wouldn't have worked here (just tried), so mock injects/mocks a descriptor. Also, mock takes care of restoring the 'old' definition which avoids nasty side effects when modifying globally this way. I can do some old school hacking around like you suggest (and I use to) but I want to learn the 'mock' way :)</span>
<span class="comment-copy">@IvovanderWijk: With <code>Bar.assignment</code> being a mock?</span>
<span class="comment-copy">@IvovanderWijk: I am surprised that <code>PropertyMock</code> didn't work though.</span>
<span class="comment-copy">Either by partially mocking Bar or by only mocking the 'assignment' attribute, whatever the mock module provides.</span>
<span class="comment-copy">new_callable is a good suggestion. PropertyMock(return_value={'a':1}) makes it even better :) (no need for the 'as a' or further assignment anymore)</span>
<span class="comment-copy">Good point. Didn't get the decorated to work with pytest at first (it conflicted with pytest's fixture argument 'injection') but it turns out to be a matter of proper argument order (patches go first)</span>
<span class="comment-copy">It seems that since mock-1.0.1 it isn't an issue anymore:  <a href="https://bitbucket.org/hpk42/pytest/issue/217/mockpatch-decorator-and-test-fixtures-don" rel="nofollow noreferrer">bitbucket.org/hpk42/pytest/issue/217/â€¦</a></span>
