<div class="post-text" itemprop="text">
<p>I am trying to write a Django view that will return a PDF of a URL.</p>
<p>I'm using PyQt webview.print to create the PDF but I am unsure how to pass the pdf to the Django response, I've tried QBuffer but I can't seem to get it right.</p>
<p>Here is my view so far:</p>
<pre><code>def pdf(request):
    app = QApplication(sys.argv)

    bufferPdf = QBuffer()
    bufferPdf.open(QBuffer.ReadWrite)

    web = QWebView()
    web.load(QUrl("http://www.google.com")) #the desired url. 

    printer = QPrinter()
    printer.setPageSize(QPrinter.Letter)
    printer.setOrientation(QPrinter.Landscape);
    printer.setOutputFormat(QPrinter.PdfFormat)
    printer.setOutputFileName("file.pdf")

    def convertIt():
        web.print_(printer)
        print "Pdf generated"
        QApplication.exit()

    QObject.connect(web, SIGNAL("loadFinished(bool)"), convertIt)

    bufferPdf.seek(0)
    result = bufferPdf.readData(0)
    bufferPdf.close()

    sys.exit(app.exec_())

    response =  HttpResponse(result, mimetype='application/pdf')
    response['Content-Disposition'] = 'attachment; filename=coupon.pdf'
    return response
</code></pre>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>The accepted solution from ekhumoro is incorrect. He provides you code that will run from the command line, but can never ever work within a Django view.</p>
<p>Many people have noted that it's not easy and possibly outright impossible to combine Django with a QT threaded application. The error that you are seeing is a classic example of what you will see when you attempt to do so.</p>
<p>In my own projects I tried many different permutations of organizing and grouping the code, and never did find a solution. The issue seems to be (I am not a QT expert, so if anyone has more information please correct me) that event driven QT applications (anything WebKit uses the QT event model) are built around what is effectively a singleton "QApplication". You cannot control when this sub application will quit and when it's various resources are reaped. As a result any multi-threaded applications using the library will need to very carefully manage it's resources - something that you have zero control over during the process of handling various web applications.</p>
<p>One possible (messy and unprofessional) solution would be to create a script that accepts command line arguments and then invoke said script from within Django as an official sub-process. You would use temporary files for output and then load that into your application. After whatever read event you'd just purge the file on disk. Messy, but effective.</p>
<p>I personally would love to hear from anyone who definitively knows either why this is so hard, or a proper solution - there are literally dozens of threads here on Stackoverflow with incorrect or incomplete explanations of how to approach this problem... </p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a re-write of your example that should do what you want:</p>
<pre><code>import sys
from PyQt4 import QtCore, QtGui, QtWebKit

class WebPage(QtWebKit.QWebPage):
    def __init__(self):
        QtWebKit.QWebPage.__init__(self)
        self.printer = QtGui.QPrinter()
        self.printer.setPageSize(QtGui.QPrinter.Letter)
        self.printer.setOrientation(QtGui.QPrinter.Landscape);
        self.printer.setOutputFormat(QtGui.QPrinter.PdfFormat)
        self.mainFrame().loadFinished.connect(self.handleLoadFinished)

    def start(self, url):
        self.mainFrame().load(QtCore.QUrl(url))
        QtGui.qApp.exec_()

    def handleLoadFinished(self):
        temp = QtCore.QTemporaryFile(
            QtCore.QDir.temp().filePath('webpage.XXXXXX.pdf'))
        # must open the file to get the filename.
        # file will be automatically deleted later
        temp.open()
        self.printer.setOutputFileName(temp.fileName())
        # ensure that the file can be written to
        temp.close()
        self.mainFrame().print_(self.printer)
        temp.open()
        self.pdf = temp.readAll().data()
        QtGui.qApp.quit()

def webpage2pdf(url):
    if not hasattr(WebPage, 'app'):
        # can only have one QApplication, and it must be created first
        WebPage.app = QtGui.QApplication(sys.argv)
    webpage = WebPage()
    webpage.start(url)
    return webpage.pdf

if __name__ == '__main__':

    if len(sys.argv) &gt; 1:
        url = sys.argv[1]
    else:
        url = 'http://www.google.com'

    result = webpage2pdf(url)

    response =  HttpResponse(result, mimetype='application/pdf')
    response['Content-Disposition'] = 'attachment; filename=coupon.pdf'
    # do stuff with response...
</code></pre>
</div>
<span class="comment-copy">I don't understand why you think my solution is incorrect: the OP confirmed that it worked for them, which is why they accepted the answer. Their only complaint was that it only converts one page at a time. But as I said in my comment, that's all the question asked for, so that's all my demo script attempts to do - it's just a simple re-write of the code in the question, not an attempt at a general solution.</span>
<span class="comment-copy">It's pretty clear what the poster was asking for. He wants to use QT within his multithreaded Django application. Your solution is not a correct response to his question, although it seems the poster didn't understand that when he accepted the solution. Literally your solution can never work beyond 1 single request, it's inherently broken, and it fails to indicate this within the original post. A correct response would indicate that using QT in any multithreaded environment can never succeed, and what he is trying to do is effectively impossible.</span>
<span class="comment-copy">I'm not trying to get into an argument with you, but your description is unfair. The question specifically asks about how to create a pdf using PyQt, and pass the result to a http response. It does not mention multi-threading, and the given example does not even contain any django-specific code. My answer clearly states at the beginning that it is "a re-write of your example", and in those terms it does exactly what the OP asked for. If there are issues regarding multi-threading, they belong in a separate question, since they are clearly beyond the scope of the original question.</span>
<span class="comment-copy">To answer the question about multi-threading: the most obvious solution would be to bypass this issue altogether by using <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="nofollow noreferrer">multiprocessing</a> instead.</span>
<span class="comment-copy">@kamelkev was right. The "rewrite" would only work once.  I ended up doing what kamelkev suggests. I used a subpross (popen) to call a command to do the conversion, save the pdf in /tmp, then serve it.  I went through so many quirky HTML to PDF tools and non of them worked well.  I finally found an acceptable one <a href="http://phantomjs.org/" rel="nofollow noreferrer">phantomjs</a></span>
<span class="comment-copy">Ok just realized this: It creates and downloads the pdf no problem the first time the code runs, but when it runs again it throws an error saying "webpage object has no attribute pdf" originating on the return statement of def webpage2pdf().  In the console there is message stating "QApplicaiton::exec: Must be called from the main thread."  Any ideas what's going on?</span>
<span class="comment-copy">@user3396662. It's just a simple demo script, and is only designed to convert one webpage at a time (which is all your original question asked for). As it stands, it cannot be used to covert webpages in a loop, because the loading of urls happens asynchronously - a different design would be required for that.</span>
