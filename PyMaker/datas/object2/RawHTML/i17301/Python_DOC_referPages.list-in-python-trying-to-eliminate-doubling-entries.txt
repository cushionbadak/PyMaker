<div class="post-text" itemprop="text">
<p>I have a question that I didn't find answer anywhere on the internet (it's on python) :</p>
<p>I have a class named Pion and is described like this :</p>
<pre><code>class Pion():
    def __init__(self,x,y):
        self.x = x
        self.y = y
</code></pre>
<p>in the main function, I'm creating a List of Pion :</p>
<pre><code>PionList = []
</code></pre>
<p>I'm adding these values to this list : </p>
<pre><code>PionList.append(Pion(3,4))
PionList.append(Pion(4,6))
PionList.append(Pion(3,4))
PionList.append(Pion(2,9))
PionList.append(Pion(4,6))
</code></pre>
<p>Now, I would like to find a way to clean up the list and only have unique combination x and y properties for each element of the list so at the end, my list will have 3 elements and not 5 (I want to eliminate the doubling entries (3,4) and (4,6) and only have one element with <code>Pion(3,4)</code>, one element with <code>Pion(4,6)</code> and one element with <code>Pion(2,9)</code></p>
<p>I've tried to implement it in my code and I'm not able to visualize how I'll have to procede.</p>
<p>Any clues or possible solutions for this problematic?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="http://docs.python.org/3/library/stdtypes.html#set" rel="nofollow"><code>set</code></a>:</p>
<pre><code>class Pion():
    def __init__(self,x,y):
        self.x = x
        self.y = y
    def __repr__(self):
        return 'Pion({0.x},{0.y})'.format(self)

lst = [Pion(3,4), Pion(4,6), Pion(3,4), Pion(2,9), Pion(4,6)]

seen = set()
newlst = []
for pion in lst:
    key = pion.x, pion.y
    if key in seen:
        continue
    seen.add(key)
    newlst.append(pion)

print(newlst)
</code></pre>
<p>output:</p>
<pre><code>[Pion(3,4), Pion(4,6), Pion(2,9)]
</code></pre>
<p>If you define <code>__hash__</code> and <code>__eq__</code>, you can do it simpler way (The order of element is not guaranteed).</p>
<pre><code>&gt;&gt;&gt; class Pion():
...     def __init__(self,x,y):
...         self.x = x
...         self.y = y
...     def __repr__(self):
...         return 'Pion({0.x},{0.y})'.format(self)
...     def __hash__(self):
...         return hash((self.x, self.y))
...     def __eq__(self, other):
...         return self.x == other.x and self.y == other.y
...
&gt;&gt;&gt; lst = [Pion(3,4), Pion(4,6), Pion(3,4), Pion(2,9), Pion(4,6)]
&gt;&gt;&gt;
&gt;&gt;&gt; list(set(lst))
[Pion(3,4), Pion(4,6), Pion(2,9)]
</code></pre>
<p>Alternatively you can use <code>OrderedDict.fromkeys</code> (Orders are preserved):</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; list(OrderedDict.fromkeys(lst))
[Pion(3,4), Pion(4,6), Pion(2,9)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is easily solved using sets. You simply have to make your Pion hash able and then you can do this:</p>
<pre><code>class Pion():
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __key(self):
        return (self.x, self.y)

    def __hash__(self):
        return hash(self.__key())

    def __eq__(self, other):
        return self.__key() == other.__key()

PionSet = {Pion(3, 4),
           Pion(4, 6),
           Pion(3, 4),
           Pion(2, 9),
           Pion(4, 6)}
</code></pre>
<p>You can use the <code>add</code> method to add more programattically.</p>
</div>
<span class="comment-copy">The whole point of sets is not to have to check if the element is in the set - the way you've implemented it you may as well have made <code>seen</code> a list.</span>
<span class="comment-copy">@chthonicdaemon: The point here is to make containment checking fast. With a list, containment checking would run in time proportional to the size of the list.</span>
<span class="comment-copy">@chthonicdaemon, Using list, the time complexity become O(n^2).</span>
<span class="comment-copy">@chthonicdaemon, See <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">TimeComplexity - Python Wiki page</a>.</span>
<span class="comment-copy">If order is important, the standard recipe is <code>OrderedDict.fromkeys(l).keys()</code>.</span>
<span class="comment-copy">You also need <code>__eq__</code>.</span>
<span class="comment-copy"><code>PionSet</code> does contains 5 items. As  user2357112 commented, you need to implement <code>__eq__</code>, too.</span>
<span class="comment-copy">Thanks for your comments - added this properly now.</span>
