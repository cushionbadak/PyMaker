<div class="post-text" itemprop="text">
<p>If I have a function like:</p>
<pre><code>def f(a,b,c,d):
    print a,b,c,d
</code></pre>
<p>Then why does this works:</p>
<pre><code>f(1,2,3,4)
f(*[1,2,3,4])
</code></pre>
<p>But not this:</p>
<pre><code>f(*[1,2] , *[3,4])
    f(*[1,2] , *[3,4])
               ^
SyntaxError: invalid syntax
</code></pre>
<p>?</p>
<p><strong>EDIT</strong> :
For information, the original problem was to replace one of the argument in a function wrapper. I wanted to replace a given member of the inputted *args and tried something like:</p>
<pre><code>def vectorize_pos(f,n=0):
    '''
    Decorator, vectorize the processing of the nth argument
    :param f: function that dont accept a list as nth argument
    '''
    def vectorizedFunction(*args,**kwargs):
        if isinstance(args[n],list):
            return map(lambda x : f( *(args[:n]) , x , *(args[n+1,:]), **kwargs),args[n])
        else:
            return f(*args,**kwargs)
    return vectorizedFunction
</code></pre>
<p>That's where the question arose from. And I know there is other way do do the same thing but only wanted to understand why unpacking one sequence worked but not for more.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because, as per the <a href="http://docs.python.org/3/reference/expressions.html#calls">Function call syntax</a>, this is how the argument list is defined</p>
<pre><code>argument_list ::=  positional_arguments ["," keyword_arguments]
                     ["," "*" expression] ["," keyword_arguments]
                     ["," "**" expression]
                   | keyword_arguments ["," "*" expression]
                     ["," keyword_arguments] ["," "**" expression]
                   | "*" expression ["," keyword_arguments] ["," "**" expression]
                   | "**" expression
</code></pre>
<p>So, you can pass only one <code>* expression</code> per function call.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Starting in Python 3.5, this</strong> <strong><em>does</em></strong> <strong>work</strong>.</p>
<p><a href="http://legacy.python.org/dev/peps/pep-0448/" rel="noreferrer">PEP 448</a> was implemented in Python 3.5.  Quoting from the PEP, it allows, among other things:</p>
<blockquote>
<p>Arbitrarily positioned unpacking operators:</p>
<pre><code>&gt;&gt;&gt; print(*[1], *[2], 3)
1 2 3
&gt;&gt;&gt; dict(**{'x': 1}, y=2, **{'z': 3})
{'x': 1, 'y': 2, 'z': 3}
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This <em>would</em> work instead. </p>
<pre><code>&gt;&gt;&gt;def f(a,b,c,d):
         print('hello') #or whatever you wanna do. 
&gt;&gt;&gt;f(1,2,*[3,4])
hello
</code></pre>
<p>The reason that doesn't work is that Python implement this using <a href="http://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists">this</a></p>
<p>One list unpacks, and following the semantics, any argument after that must be a named keyword argument( <em>or a dictonary passing named keyword arguments through</em>**)</p>
<p>By constrast, this would work. </p>
<pre><code>&gt;&gt;&gt;def f(a,b,c,k):
       pass
&gt;&gt;&gt;f(1,*[2,3],k=4)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can concatenate lists:</p>
<pre><code>&gt;&gt;&gt; f(*[1,2]+[3,4])
1 2 3 4
</code></pre>
<p>or use <code>itertools.chain</code>:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; f(*chain([1,2], [3,4]))
1 2 3 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't work because it's invalid syntax - that is to say, it isn't actually Python although it looks like it.</p>
<p>Only one starred parameter is allowed in Python 2 function signatures, and it must follow any positional parameters and precede any keyword parameters. Similarly only one double-starred argument is allowed, and it must follow all keyword parameters in the signature. If you have multiple lists of arguments you would like to submit you will indeed have to create a single list from them first.</p>
<p>In Python 3 it is also possible to use a star on its own to indicate that any following parameters are so-called keyword-only parameters, but I don't think we need get into that just yet.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>*</code> here isn't acting as an operator. It's more like part of the syntax of function calls, and it only allows for certain limited possibilities. It would have been possible to define the language so that you could do what you want (I've done it!), but that wasn't the choice that was made.</p>
</div>
<div class="post-text" itemprop="text">
<p>These may help. Note that the analogy is to a variable number of arguments in other languages. This means that once you say you are going to use a variable number of arguments, all following arguments are part of that list (analogy to C or C++ use of varargs).</p>
<p>for example
    f = [1,2,3,4,5]</p>
<pre><code>def func(a, b, c, d)
  print a, b, c, d

func(f) # Error 1 argument, 4 required

func(*f) # Error 5 arguments 4 required
</code></pre>
<p><a href="http://www.python-course.eu/passing_arguments.php" rel="nofollow">http://www.python-course.eu/passing_arguments.php</a></p>
<blockquote>
<p>Variable Length of Parameters<br/>
  We will introduce now functions, which
  can take an arbitrary number of arguments. Those who have some
  programming background in C or C++ know this from the varargs feature
  of these languages. The asterisk "*" is used in Python to define a
  variable number of arguments. The asterisk character has to precede a
  variable identifier in the parameter list.</p>
<pre><code>&gt;&gt;&gt; def varpafu(*x): print(x)
... 
&gt;&gt;&gt; varpafu()
()
&gt;&gt;&gt; varpafu(34,"Do you like Python?", "Of course")
(34, 'Do you like Python?', 'Of course')
&gt;&gt;&gt; 
</code></pre>
<p>We learn from the previous example, that the arguments passed to the
  function call of varpafu() are collected in a tuple, which can be
  accessed as a "normal" variable x within the body of the function. If
  the function is called without any arguments, the value of x is an
  empty tuple.</p>
<p>Sometimes, it's necessary to use positional parameters followed by an
  arbitrary number of parameters in a function definition. This is
  possible, but the positional parameters always have to precede the
  arbitrary parameters. In the following example, we have a positional
  parameter "city", - the main location, - which always have to be
  given, followed by an arbitrary number of other locations:</p>
<pre><code>&gt;&gt;&gt; def locations(city, *other_cities): print(city, other_cities)
... 
&gt;&gt;&gt; locations("Paris")
('Paris', ())
&gt;&gt;&gt; locations("Paris", "Strasbourg", "Lyon", "Dijon", "Bordeaux", "Marseille")
('Paris', ('Strasbourg', 'Lyon', 'Dijon', 'Bordeaux', 'Marseille'))
&gt;&gt;&gt;
</code></pre>
</blockquote>
<p><a href="http://docs.python.org/2.7/reference/expressions.html" rel="nofollow">http://docs.python.org/2.7/reference/expressions.html</a></p>
<blockquote>
<p>If the syntax *expression appears in the function call, expression
  must evaluate to an iterable. Elements from this iterable are treated
  as if they were additional positional arguments; if there are
  positional arguments x1, ..., xN, and expression evaluates to a
  sequence y1, ..., yM, this is equivalent to a call with M+N positional
  arguments x1, ..., xN, y1, ..., yM.</p>
<p>A consequence of this is that although the *expression syntax may
  appear after some keyword arguments, it is processed before the
  keyword arguments (and the **expression argument, if any â€“ see below).
  So:</p>
<blockquote>
<blockquote>
<p>&gt;</p>
</blockquote>
</blockquote>
<pre><code>&gt;&gt;&gt; def f(a, b): ...  print a, b ...
&gt;&gt;&gt; f(b=1, *(2,)) 2 1
&gt;&gt;&gt; f(a=1, *(2,)) Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in ? TypeError: f() got multiple values for keyword argument
'a'
&gt;&gt;&gt; f(1, *(2,)) 1 2
</code></pre>
<p>It is unusual for both keyword arguments and the *expression syntax to
  be used in the same call, so in practice this confusion does not
  arise.</p>
<p>If the syntax **expression appears in the function call, expression
  must evaluate to a mapping, the contents of which are treated as
  additional keyword arguments. In the case of a keyword appearing in
  both expression and as an explicit keyword argument, a TypeError
  exception is raised.</p>
</blockquote>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/10564801/how-to-unpack-multiple-tuples-in-function-call">How to unpack multiple tuples in function call</a></span>
<span class="comment-copy">Maybe what you really wanted was <code>f((a,b), (c,d))</code>? I have never seen this before, but I can't imagine any case where I'd want to pass in multiple anonymous arguments this way, and making the argument itself a tuple wouldn't be more appropriate.</span>
<span class="comment-copy">Not a duplicate. The focus of that question was how to make it work. This is asking the reasoning behind <i>why</i> it doesn't work. It's subtle but I think worth it's own question.</span>
<span class="comment-copy">@CorleyBrigman He probably was bored and programming for leisure and came across something he thought should work, and this puzzled him.</span>
<span class="comment-copy">@thefourtheye Accurate and very good answer. I don't know why I bothered posting. +1</span>
<span class="comment-copy">What's surprising about that is that something nasty like <code>f(5, *[1], c=3, **{'d':5})</code> actually works. I didn't know that, I always thought you'd have to write <code>*</code> and <code>**</code> pseudoarguments right next to each other.</span>
<span class="comment-copy">@NiklasB. nope. The only rule is named arguments after <code>*</code> arguments.</span>
<span class="comment-copy">@Sabyasachi: That's not true, you can do <code>f(b=1,c=2,d=3,*[1])</code> according to the syntax that is just above this comment</span>
<span class="comment-copy">@NiklasB. I ran that code now, <code>f(a=1,b=2,*[3,4])</code> with four arguments, and it raises a <code>TypeError</code>. What version are you using?</span>
<span class="comment-copy">It's nice you've added this here, after a comment already pointed out to a discussion which includes a reference to this PEP, but this is absolutely not an answer to the question.</span>
<span class="comment-copy">@Bach I didn't see a comment referencing this PEP.  Whereas I agree that it is not technically an answer to the question, I think it is sufficiently relevant to be posted as one.  I'll let the community decide (personally, I think it should still be an answer, and not a comment).</span>
<span class="comment-copy">It's marked as Final for 3.5 when I just checked here: <a href="https://www.python.org/dev/peps/pep-0448/" rel="nofollow noreferrer">python.org/dev/peps/pep-0448</a></span>
<span class="comment-copy">his question is why it doesn't work. Although you answered <i>how</i> to make it work. +1 for that.</span>
<span class="comment-copy">nowhere did he mention that the thought <code>*</code> was working as an operator. Answer not on topic, and doesn't address OP's question. -1</span>
<span class="comment-copy">@Sabyasachi: I think OPs usage of the * implies that he/she thinks it in fact <i>is</i> some kind of operator, while it's not. I think this answer is valid and correct</span>
<span class="comment-copy">@NiklasB. That's fair enough. It's just our opinions. Whatever the community decides as a whole. Some people seem to think downvotes as personal, it isn't though. :)</span>
<span class="comment-copy">@NiklasB. also tiny nitpick. The docs to call it an operator. <i>checkmate</i></span>
<span class="comment-copy">good but maybe a little too much for (what i assume to be) someone comparatively new to python. Don't you think?</span>
