<div class="post-text" itemprop="text">
<p>I read out of the XML-files their category and I rename and save them with the year.
So, file "XYZ.xml" is now "News_2014.xml".</p>
<p>The Problem is that there are several XML-files with the category "News" from 2014. With my code, I delete all other files and I can save only 1 file.
What can I do in order that every file is saved? For example, if there are 2 files with the category "News" and the Year 2014, there file-names should be: "News_2014_01.xml" and "News_2014_02.xml".</p>
<p>Since there are other categories, I can not simply implement an increasing integer, i.e. another file with the category "History" should still have the Name "History_2014_01.xml" (and not ...03.xml).</p>
<p>Actually, I have the following code:</p>
<pre><code>for text, key in enumerate(d):
     #print key, d[key]
     name = d[key][(d[key].find("__")+2):(d[key].rfind("__"))]
     year = d[key][(d[key].find("*")+1):(d[key].rfind("*"))]
     cat = d[key][(d[key].rfind("*")+1):]
         os.rename(name, cat+"_"+year+'.xml') 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Once you have figured out the “correct” name for the file, e.g. <code>News_2014.xml</code>, you could make a loop that checks whether the file exists and adds an incrementing suffix to it while that’s the case:</p>
<pre><code>import os
fileName = 'News_2014.xml'
baseName, extension = os.path.splitext(fileName)
suffix = 0

while os.path.exists(os.path.join(directory, fileName)):
    suffix += 1
    fileName = '{}_{:02}.{}'.format(baseName, suffix, extension)

print(fileName)
os.rename(originalName, fileName)
</code></pre>
<p>You can put that into a function, so it’s easier to use:</p>
<pre><code>def getIncrementedFileName (fileName):
    baseName, extension = os.path.splitext(fileName)
    suffix = 0

    while os.path.exists(os.path.join(directory, fileName)):
        suffix += 1
        fileName = '{}_{:02}.{}'.format(baseName, suffix, extension)
    return fileName
</code></pre>
<p>And then use that in your code:</p>
<pre><code>for key, item in d.items():
    name = item[item.find("__")+2:item.rfind("__")]
    year = item[item.find("*")+1:item.rfind("*")]
    cat = item[item.rfind("*")+1:]

    fileName = getIncrementedFileName(cat + '_' + year + '.xml')
    os.rename(name, fileName)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>[EDIT] @poke solution is much more elegant, let alone he posted it earlier</p>
<p>You can check if target filename already exists, and if it does, modify filename.
The easiest solution for me would be to always start with adding 'counter' to file name, so you start with News_2014_000.xml (maybe better be prepared for more than 100 files?).</p>
<p>Later you loop until you find filename, that does not exist:</p>
<pre><code>def versioned_filename(candidate):
    target = candidate
    while os.path.exists(target):
        fname, ext = target.rsplit('.', 1)
        head, tail = fname.rsplit('_', 1)
        count = int(tail)
                     #:03d formats as 3-digit with leading zero
        target = "{}_{:03d}.{}".format(head, count+1, ext) 
    return target
</code></pre>
<p>So, if you want to save as 'News_2014_###.xml' file you can create name as usual, but call <code>os.rename(sourcename, versioned_filename(targetname))</code>.
If you want more efficient solution, you can parse output of <code>glob.glob()</code> to find highest count, you will save on multiple calling to os.path.exists, but it makes sense only if you expect hundreds or thousands of files.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a dictionary to keep track of the count. That way, there is no need to modify file names after you've renamed them. The downside is that every filename will have a number in it, even if the max number for that category ends up being <code>1</code>.</p>
<pre><code>cat_count = {}
for text, key in enumerate(d):
    name = d[key][(d[key].find("__")+2):(d[key].rfind("__"))]
    year = d[key][(d[key].find("*")+1):(d[key].rfind("*"))]
    cat = d[key][(d[key].rfind("*")+1):]

    cat_count[cat] = cat_count[cat] + 1 if cat in cat_count else 1

    os.rename(name, "%s_%s_%02d.xml" % (cat, year, cat_count[cat]))
</code></pre>
</div>
<span class="comment-copy">One additional question: How should I use csv-files? What I'd like to do, additionally, is to save the Content of all the files in 1 csv-file, beginning with the article-number + "," + year + text. Can I simply save all the Content in a list and then write the Output in a file ending in ".csv"? Thanks for any help! :)</span>
<span class="comment-copy">Yes, a CSV file, is a file ending in <code>.csv</code>, however, it must also have some sort of field delimiter (usually <code>,</code>, hence Comma Separated Values -- CSV). Check out <a href="http://docs.python.org/2/library/csv.html#writer-objects" rel="nofollow noreferrer"><code>csv.Writer</code></a>. You can see examples of how to use it <a href="http://docs.python.org/2/library/csv.html#examples" rel="nofollow noreferrer">in the docs</a>.</span>
<span class="comment-copy">Check out the <a href="http://docs.python.org/3/library/csv.html" rel="nofollow noreferrer">csv</a> module. You can use a writer’s <a href="http://docs.python.org/3/library/csv.html#csv.csvwriter.writerow" rel="nofollow noreferrer"><code>writerow</code></a> to write a line into a CSV file without having to care about separators, escaping and stuff.</span>
<span class="comment-copy">Yes, this is exactly what I looked for! :))</span>
<span class="comment-copy">Thanks a loooot! :)</span>
<span class="comment-copy">I added an additional question... :)</span>
<span class="comment-copy">I also tried your Version - it works, too! :) Thanks a lot for this proposal!! :)</span>
<span class="comment-copy">I added an additional question... :)</span>
<span class="comment-copy">Thanks a lot for your proposal! I will use this one in an other file - thanks a lot! :)</span>
<span class="comment-copy">I added an additional question... :)</span>
