<div class="post-text" itemprop="text">
<p>I am using tkinter in Python and came across the following code:</p>
<pre><code>for row_number, row in enumerate(cursor):
</code></pre>
<p>I was wondering whether anyone could explain what enumerate means in this context?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/2/library/functions.html#enumerate" rel="noreferrer"><code>enumerate()</code> function</a> adds a counter to an iterable.</p>
<p>So for each element in <code>cursor</code>, a tuple is produced with <code>(counter, element)</code>; the <code>for</code> loop binds that to <code>row_number</code> and <code>row</code>, respectively.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; elements = ('foo', 'bar', 'baz')
&gt;&gt;&gt; for elem in elements:
...     print elem
... 
foo
bar
baz
&gt;&gt;&gt; for count, elem in enumerate(elements):
...     print count, elem
... 
0 foo
1 bar
2 baz
</code></pre>
<p>By default, <code>enumerate()</code> starts counting at <code>0</code> but if you give it a second integer argument, it'll start from that number instead:</p>
<pre><code>&gt;&gt;&gt; for count, elem in enumerate(elements, 42):
...     print count, elem
... 
42 foo
43 bar
44 baz
</code></pre>
<p>If you were to re-implement <code>enumerate()</code> in Python, here are two ways of achieving that; one using <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="noreferrer"><code>itertools.count()</code></a> to do the counting, the other manually counting in a <a href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do">generator function</a>:</p>
<pre><code>from itertools import count

def enumerate(it, start=0):
    # return an iterator that adds a counter to each element of it
    return zip(count(start), it)
</code></pre>
<p>and</p>
<pre><code>def enumerate(it, start=0):
    count = start
    for elem in it:
        yield (count, elem)
        count += 1
</code></pre>
<p>The <a href="https://github.com/python/cpython/blob/master/Objects/enumobject.c" rel="noreferrer">actual implementation in C</a> is closer to the latter, with optimisations to reuse a single tuple object for the common <code>for i, ...</code> unpacking case and using a standard C integer value for the counter until the counter becomes too large to avoid using a Python integer object (which is unbounded).</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a builtin generator function, see <a href="http://docs.python.org/2/library/functions.html#enumerate" rel="noreferrer">http://docs.python.org/2/library/functions.html#enumerate</a> .</p>
<p>In short, it yields the elements of an iterator, as well as an index number:</p>
<pre><code>for item in enumerate(["a", "b", "c"]):
    print item
</code></pre>
<p>prints</p>
<pre><code>(0, "a")
(1, "b")
(2, "c")
</code></pre>
<p>It's helpful if you want to loop over an interator, and also want to have an index counter available. If you want the counter to start from some other value (usually 1), you can give that as second argument to <code>enumerate</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am reading a book (<em>'Effective Python'</em>) by Brett Slatkin and he shows another way to iterate over a list and also know the index of the current item in the list. 
BUT suggests to not use it and use <code>enumerate</code> instead. 
I know you asked what enumerate means, but when I understood the following, I also understood how <code>enumerate</code> makes iterating over a list while knowing the index of the current item easier (and more readable). </p>
<pre><code>list_of_letters = ['a', 'b', 'c']
for i in range(len(list_of_letters)):
    letter = list_of_letters[i]
    print (i, letter)
</code></pre>
<p>The output is:</p>
<pre><code>0 a
1 b
2 c
</code></pre>
<p>I also used to do something, even sillier before I read about the <code>enumerate</code> function. </p>
<pre><code>i = 0
for n in list_of_letters:
    print (i, n)
    i = i +1
</code></pre>
<p>It produces the same output. </p>
<p>But with <code>enumerate</code> I just have to write:</p>
<pre><code>list_of_letters = ['a', 'b', 'c']
for i, letter in enumerate(list_of_letters):
    print (i, letter)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As other users have mentioned, <code>enumerate</code> is a generator that adds an incremental index next to each item of an iterable.</p>
<p>So if you have a list say <code>l = ["test_1", "test_2", "test_3"]</code>, the <code>list(enumerate(l))</code> will give you something like this: <code>[(0, 'test_1'), (1, 'test_2'), (2, 'test_3')]</code>.</p>
<p><strong>Now, when this is useful?</strong> A possible use case is when you want to iterate over items, and you want to skip a specific item that you only know its index in the list but not its value (because its value is not known at the time).</p>
<pre><code>for index, value in enumerate(joint_values):
   if index == 3:
       continue

   # Do something with the other `value`
</code></pre>
<p>So your code reads better because you could also do a regular for loop with <code>range</code> but then to access the items you need to index them (i.e., <code>joint_values[i]</code>).</p>
<p>Although another user mentioned an implementation of <code>enumerate</code> using <code>zip</code>, I think a more pure (but slightly more complex) way without using <code>itertools</code> is the following:</p>
<pre><code>def enumerate(l, start=0):
    return zip(range(start, len(l) + start), l)
</code></pre>
<p>Example:</p>
<pre><code>l = ["test_1", "test_2", "test_3"]
enumerate(l)
enumerate(l, 10)
</code></pre>
<p>Output:</p>
<blockquote>
<p>[(0, 'test_1'), (1, 'test_2'), (2, 'test_3')]</p>
<p>[(10, 'test_1'), (11, 'test_2'), (12, 'test_3')]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The enumerate function works as follows:</p>
<pre><code>doc = """I like movie. But I don't like the cast. The story is very nice"""
doc1 = doc.split('.')
for i in enumerate(doc1):
     print(i)
</code></pre>
<p>The output is</p>
<pre><code>(0, 'I like movie')
(1, " But I don't like the cast")
(2, ' The story is very nice')
</code></pre>
</div>
<span class="comment-copy"><a href="http://docs.python.org/2/library/functions.html#enumerate" rel="nofollow noreferrer">docs.python.org/2/library/functions.html#enumerate</a></span>
<span class="comment-copy">I think you're missing a <code>]</code> in your first line of code.</span>
<span class="comment-copy">if you add a second variable to <code>item</code> then you can remove the parenthesis :D</span>
<span class="comment-copy">Pedantic: It's a function returning an iterator, not a generator. <a href="https://stackoverflow.com/q/52970099/364696">Generators are a specific class of user-defined functions</a> (using <code>yield</code>/<code>yield from</code>, or generator expressions, which implicitly <code>yield</code>); <code>enumerate</code> isn't a generator. For all duck-typing related purposes there is no difference, but explicit type checking and the Python language docs only uses the term "generator" for one purpose, which doesn't cover <code>enumerate</code>.</span>
<span class="comment-copy">The reason the other answer mentions <code>itertools</code> is that your <code>range</code> approach only works with containers. <code>enumerate</code> works with arbitrary iterables; if you want to iterate a file, <code>for lineno, line in enumerate(myfile):</code> works, but you couldn't do <code>range(len(myfile))</code> because the length isn't known until you reach EOF.</span>
<span class="comment-copy">@ShadowRanger I see. That's interesting and thanks for letting me know!</span>
