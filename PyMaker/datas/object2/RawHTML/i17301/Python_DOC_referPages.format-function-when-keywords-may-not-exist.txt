<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/20248355/how-to-get-python-to-gracefully-format-none-and-non-existing-fields">How to get Python to gracefully format None and non-existing fields [duplicate]</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>Is there a way to use python string.format such that no exception is thrown when an index is missing, instead an empty string is inserted.</p>
<pre><code>result = "i am an {error} example string {error2}".format(hello=2,error2="success")
</code></pre>
<p>here,result should be :</p>
<pre><code>"i am an   example string success"
</code></pre>
<p>Right now, python throws a keyerror and stops formatting. Is it possible to change this behavior ?</p>
<p>Thanks</p>
<p>Edit: </p>
<p>There exists Template.safe_substitute (even that leaves the pattern intact instead of inserting an empty string) , but couldn't something similar for string.format</p>
<p>The desired behavior would be similar to string substitution in php.</p>
<pre><code>class Formatter(string.Formatter):
  def get_value(self,key,args,kwargs):
    try:
        if hasattr(key,"__mod__"):
            return args[key]
        else:
            return kwargs[key]
    except:
        return ""
</code></pre>
<p>This seems to provide the desired behavior.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>str.format()</code> doesn't expect a mapping object. Try this:</p>
<pre><code>from collections import defaultdict

d = defaultdict(str)
d['error2'] = "success"
s = "i am an {0[error]} example string {0[error2]}"
print s.format(d)
</code></pre>
<p>You make a defaultdict with a <code>str()</code> factory that returns "". Then you make one key for the defaultdict. In the format string, you access keys of the first object passed. This has the advantage of allowing you to pass other keys and values, as long as your defaultdict is the first argument to <code>format()</code>.</p>
<p>Also, see <a href="http://bugs.python.org/issue6081" rel="noreferrer">http://bugs.python.org/issue6081</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The official solution (<a href="http://docs.python.org/3/library/stdtypes.html#str.format_map" rel="nofollow noreferrer">Python 3 Docs</a>) for strings in format mappings is to subclass the <code>dict</code> class and to define the magic-method <code>__missing__()</code>. This method is called whenever a key is missing, and what it returns is used for the string formatting instead:</p>
<pre><code>class format_dict(dict):
    def __missing__(self, key):
        return "..."

d = format_dict({"foo": "name"})

print("My %(foo)s is %(bar)s" % d) # "My name is ..."

print("My {foo} is {bar}".format(**d)) # "My name is ..."
</code></pre>
<p><strong>Edit:</strong> the second print() works in Python 3.5.3, but it does not in e.g. 3.7.2: <code>KeyError: 'bar'</code> is raised and I couldn't find a way to catch it.</p>
<p>After some experiments, I found a difference in Python's behavior. In v3.5.3, the calls are <code>__getitem__(self, "foo")</code> which succeeds and <code>__getitem__(self, "bar")</code> which can not find the key <code>"bar"</code>, therefore it calls <code>__missing__(self, "bar")</code> to handle the missing key without throwing a KeyError. In v3.7.2, <code>__getattribute__(self, "keys")</code> is called internally. The built-in <code>keys()</code> method is used to return an iterator over the keys, which yields "foo", <code>__getitem__("foo")</code> succeeds, then the iterator is exhausted. For <code>{bar}</code> from the format string there is no key <code>"bar"</code>. <code>__getitem__()</code> and hence <code>__missing_()</code> are not called to handle the situation. Instead, the KeyError is thrown. I don't know how one could catch it, if at all.</p>
<p><strong>In Python 3.2+ you should use <code>format_map()</code> instead</strong> (also see <a href="https://bugs.python.org/issue6081" rel="nofollow noreferrer">Python Bug Tracker - Issue 6081</a>):</p>
<pre><code>from collections import defaultdict

d = defaultdict(lambda: "...")
d.update({"foo": "name"})

print("My {foo} is {bar}".format_map(d)) // "My name is ..."
</code></pre>
<p>If you want to <strong>keep the placeholders</strong>, you can do:</p>
<pre><code>class Default(dict):
    def __missing__(self, key): 
        return key.join("{}")

d = Default({"foo": "name"})

print("My {foo} is {bar}".format_map(d)) // "My name is {bar}"
</code></pre>
<p>As you can see, <code>format_map()</code> does call <code>__missing__()</code>.</p>
<p>The following appears to be the most compatible solution as it also works in older Python versions including 2.x (I tested v2.7.15):</p>
<pre><code>class Default(dict):
    def __missing__(self, key):
        return key.join("{}")

d = Default({"foo": "name"})

import string
print(string.Formatter().vformat("My {foo} is {bar}", (), d)) // "My name is {bar}"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately, no, there is no such way to do by default. However you can provide it defaultdict or object with overridden <code>__getattr__</code>, and use like this:</p>
<pre><code>class SafeFormat(object):
    def __init__(self, **kw):
        self.__dict = kw

    def __getattr__(self, name):
        if not name.startswith('__'):
            return self.__dict.get(name, '')

print "i am an {0.error} example string {0.error2}".format(SafeFormat(hello=2,error2="success"))
i am an  example string success
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I made a version that does work similarly to Daniel's method but without the {0.x} attribute access.</p>
<pre><code>import string    
class SafeFormat(object):
    def __init__(self, **kw):
        self.__dict = kw

    def __getitem__(self, name):
        return self.__dict.get(name, '{%s}' % name)



string.Formatter().vformat('{what} {man}', [], SafeFormat(man=2))
</code></pre>
<p>prints out</p>
<pre><code>'{what} 2'
</code></pre>
</div>
<span class="comment-copy">You can also use <code>str.format_map()</code> as described in <a href="http://stackoverflow.com/a/17215533/877069">this answer</a>.</span>
<span class="comment-copy">Could this be improved by using a formatter object (idea frm the bug report link) instead of a defaultdict ? that way, no change wud be reqd to the format variable. Thanks</span>
<span class="comment-copy">class Formatter(string.Formatter):     def get_value(self,key,args,kwargs):         try:             if hasattr(key,"<b>mod</b>"):                 return args[key]             else:                 return kwargs[key]         except:             return ""  This works for me. The advantage is that there's no need to create an extra defaultdict.</span>
<span class="comment-copy">Yeah, that works well. I'm not sure how to compare the penalty of an extra defaultdict against the penalty of an extra Formatter class+object, but in some situations it might be better, especially if it makes the code clearer.</span>
<span class="comment-copy">To return an arbitrary string, you may use a lambda expression, because defaultdict requires a callable: <code>"Hello {name}!".format(**defaultdict(lambda: "World"))</code> (Result: <code>Hello World!</code>)</span>
<span class="comment-copy">I just tried that and you can do : 'some{thing}'.format(format_dict('your': arguments))  It effectively silence the KeyError and replace the tag by whatever return the <b>missing</b> magic function.</span>
<span class="comment-copy"><code>.format(**format_dict({"foo": "name"}))</code> can be used too of course. Your snippet will fail however, because of a syntax error. The dict unpacking <code>**</code> is mandatory for <code>.format()</code>, is does not accept dicts directly.</span>
<span class="comment-copy">Consider returning <code>'{' + key + '}'</code>instead of <code>...</code> from <code>__missing__</code> for cases where you want to leave text inside braces unchanged if it's not a valid key in the substitution dict.  A good example is HTML template substitution where the template contains &lt;style&gt; tags with rulesets in curly braces that you want to leave unmolested.</span>
<span class="comment-copy">I tried this but didn't work. I think you meant to use format_map() instead of format()</span>
<span class="comment-copy">@santileortiz I added additional solutions and an explanation why my original answer no longer works in recent Python versions. I also added an example which keeps the placeholders in the string similar to what MikeEllis suggested.</span>
<span class="comment-copy">Thanks. Its userful, but as Fabian mentioned, doesn't handle mapping objects other than dict</span>
