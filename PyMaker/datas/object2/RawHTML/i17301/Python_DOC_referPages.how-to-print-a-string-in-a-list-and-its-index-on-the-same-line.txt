<div class="post-text" itemprop="text">
<p>This probably has a very simple solution, but I'm just a beginner.</p>
<p>What I have is:</p>
<pre><code>def content(L):  
    for i in range(len(L)):  
        print (i), (L[i])
</code></pre>
<p>Right now it only prints the index and not the string. I'm not entirely sure what the issue is, but when I switch the ordering in the last line so that (L[i]) comes first then it prints the string but not the index. I want to print both on the same line.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.x, <a href="http://docs.python.org/3/library/functions.html#print" rel="nofollow noreferrer"><code>print</code></a> is not a statement as in Python 2.x, but rather a function. You can use it like this:</p>
<pre><code>print(i, L[i])
</code></pre>
<p>Additionally, <a href="http://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> is great for what you're trying to do:</p>
<pre><code>for i, c in enumerate(L):
    print(i, c)
</code></pre>
<p>Note that you can use <code>print</code> as a Python 3.x-style function in Python 2 if you import it from the <code>__future__</code> package (for Python 2.6 and up):</p>
<pre><code>from __future__ import print_function
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.x, <code>print</code> is a function. So, you have to pass both the values as parameters like this</p>
<pre><code>print (i, L[i])
</code></pre>
<p>When you say </p>
<pre><code>print (i), (L[i])
</code></pre>
<p>Python 3.x, accepts <code>i</code> as the parameter to <code>print</code> and considers <code>(L[i])</code> as a separate expression and evaluates it, but that doesn't get passed to the <code>print</code> function. That is why always the first element is getting printed.</p>
<p>Apart from that, your entire statement gets evaluated to the following tuple</p>
<pre><code>(None, L[i])
</code></pre>
<p>To understand that, try something like this, in the Python REPL</p>
<pre><code>&gt;&gt;&gt; print (1), (2)
1
(None, 2)
</code></pre>
<p>When the inner <code>print</code> with <code>1</code> getting executed, it will return <code>None</code> and the next element is <code>2</code>. In Python, when you write two expressions separated by comma, in parenthesis, they will become a tuple.</p>
<p>You can confirm the same with Python's generated bytecodes, like this</p>
<pre><code>from dis import dis
code1 = compile("print (1), (2)", "&lt;string&gt;", "exec")
dis(code1)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>  1           0 LOAD_NAME                0 (print) 
              3 LOAD_CONST               0 (1) 
              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair) 
              9 LOAD_CONST               1 (2) 
             12 BUILD_TUPLE              2 
             15 POP_TOP              
             16 LOAD_CONST               2 (None) 
             19 RETURN_VALUE         
</code></pre>
<p><code>BUILD_TUPLE</code> corresponds to the tuple construction and as we don't use it, it gets discarded immediately.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def content(L):  
    for ind, val in enumerate(L):  
        print (ind, val)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As others said, <code>print</code> is now a function, so what python is doing is interpreting the line:
<code>print(i), (L[i])</code> as a tuple. Do <code>print(i, L[i])</code> instead.</p>
<p>You'll also want to use enumerate:</p>
<pre><code>for i,line in enumerate(L):
    print(i, line)
</code></pre>
</div>
<span class="comment-copy">I had a feeling it was something simple like that. Thanks!</span>
