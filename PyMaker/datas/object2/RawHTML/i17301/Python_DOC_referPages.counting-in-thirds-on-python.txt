<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/21351275/split-a-string-to-even-sized-chunks">Split a string to even sized chunks</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>Out of curiousity, is there a way on Python that the computer/program can count in thirds without using range, but instead with slices and indices? For example, what if you had a codon like 'CAGCAGCAT'. Could python divide that string into thirds like this: CAG CAG CAT? I tried to, but I failed. If there's a way, show me how. I'm curious </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import textwrap
textwrap.wrap('CAGCAGCAT' ,3)
</code></pre>
<p>returns</p>
<pre><code>['CAG', 'CAG', 'CAT']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="http://docs.python.org/2/library/itertools.html#itertools.izip" rel="nofollow">grouper recipe</a>, <code>zip(*[iterator]*n)</code>, to collect items without using <code>range</code>. </p>
<pre><code>In [96]: data = 'CAGCAGCAT'

In [97]: [''.join(grp) for grp in zip(*[iter(data)]*3)]
Out[97]: ['CAG', 'CAG', 'CAT']
</code></pre>
<p>If <code>len(data)</code> is not a multiple of 3, then the above chops off the remainder. To prevent that, use <a href="http://docs.python.org/2/library/itertools.html#itertools.izip_longest" rel="nofollow">itertools.izip_longest</a>:</p>
<pre><code>In [102]: import itertools as IT
In [108]: [''.join(grp) for grp in IT.izip_longest(*[iter('CAGCAGCATCA')]*3, fillvalue='')]
Out[108]: ['CAG', 'CAG', 'CAT', 'CA']
</code></pre>
<hr/>
<p>By the way, grouper recipe works with <em>any</em> iterator. <code>textwrap.wrap</code> works only with strings. Moreover, the grouper recipe is faster:</p>
<pre><code>In [100]: %timeit textwrap.wrap(data, 3)
10000 loops, best of 3: 17.7 µs per loop

In [101]: %timeit [''.join(grp) for grp in zip(*[iter(data)]*3)]
100000 loops, best of 3: 1.78 µs per loop
</code></pre>
<p>Also note that <code>textwrap.wrap</code> may not group your string into groups of 3 characters if the string contains spaces:</p>
<pre><code>In [42]: textwrap.wrap('I am a hat', 3)
Out[42]: ['I', 'am', 'a', 'hat']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the list comprehension, the third parameter of range is a step:</p>
<pre><code>&gt;&gt;&gt; s = "CAGCAGCAT"
&gt;&gt;&gt; [s[i:i+3] for i in range(0, len(s), 3)]
['CAG', 'CAG', 'CAT']
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>grouper</code> <a href="http://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertools</code> recipe</a>:</p>
<pre><code>&gt;&gt;&gt; s = 'CAGCAGCAT'
&gt;&gt;&gt; list(grouper(s, 3))
[('C', 'A', 'G'), ('C', 'A', 'G'), ('C', 'A', 'T')]
</code></pre>
<p>Or in your case, you can also use simple slices:</p>
<pre><code>&gt;&gt;&gt; [s[i:i+3] for i in range(0, len(s), 3)]
['CAG', 'CAG', 'CAT']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def chunker(seq, size):
    return (seq[pos:pos + size] for pos in xrange(0, len(seq), size))
</code></pre>
<p>Stolen from <a href="https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks">What is the most "pythonic" way to iterate over a list in chunks?</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; s = 'CAGCAGCAT'
&gt;&gt;&gt; [''.join(g) for g in zip(s[::3], s[1::3], s[2::3])]
['CAG', 'CAG', 'CAT']
</code></pre>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks-in-python" title="how do you split a list into evenly sized chunks in python">stackoverflow.com/questions/312443/…</a> is related.</span>
<span class="comment-copy">It's funny how the he specifically said "no range" and 4 out of 6 below use range. :)</span>
<span class="comment-copy">Oh funny, I didn’t even read that. Wonder where that requirement comes from…</span>
<span class="comment-copy">Even though you didn't ask for. Maybe you are interested in <a href="http://biopython.org/DIST/docs/tutorial/Tutorial.html" rel="nofollow noreferrer">Biopython</a>: Biopython is a set of freely available tools for biological computation written in Python by an international team of developers.</span>
<span class="comment-copy">No range, impressive!</span>
<span class="comment-copy">this is my favorite way to do it (although it can leave off some end items if the length is not <code>0 (mod n)</code></span>
<span class="comment-copy">@JoranBeasley: True; in that case, use <code>itertools.izip_longest</code>.</span>
<span class="comment-copy">+1 lol I never thought of that I usually just tack on <code>+ data[-len(data)%n:]</code></span>
