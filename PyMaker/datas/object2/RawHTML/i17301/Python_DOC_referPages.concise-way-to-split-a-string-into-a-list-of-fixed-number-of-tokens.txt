<div class="post-text" itemprop="text">
<p>I am writing a piece of code that needs to split a hyphen delimited string into at most three tokens. If there are less than three tokens after splitting, it should append sufficient number of empty strings in order to make three tokens.</p>
<p>For example, <code>'foo-bar-baz'</code> should be split to <code>['foo', 'bar', 'baz']</code>, but <code>foo-bar</code> should be split to <code>['foo', 'bar', '']</code>.</p>
<p>Here is the code I wrote.</p>
<pre><code>def three_tokens(s):
    tokens = s.split('-', 2)
    if len(tokens) == 1:
        tokens.append('')
        tokens.append('')
    elif len(tokens) == 2:
        tokens.append('')
    return tokens

print(three_tokens(''))
print(three_tokens('foo'))
print(three_tokens('foo-bar'))
print(three_tokens('foo-bar-baz'))
print(three_tokens('foo-bar-baz-qux'))
</code></pre>
<p>Here is the output:</p>
<pre><code>['', '', '']
['foo', '', '']
['foo', 'bar', '']
['foo', 'bar', 'baz']
['foo', 'bar', 'baz-qux']
</code></pre>
<p>My question is that the <code>three_tokens</code> function I have written seems to be too verbose for this little task. Is there a Pythonic way to write this, or is there some Python function or class meant especially to do this kind of task that makes the code more concise?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a simple <code>while</code> loop:</p>
<pre><code>def three_tokens(s):
    tokens = s.split('-', 2)
    while len(tokens) &lt; 3:
        tokens.append('')
    return tokens
</code></pre>
<p>or extend the list with a calculated number of empty strings:</p>
<pre><code>def three_tokens(s):
    tokens = s.split('-', 2)
    tokens.extend([''] * (3 - len(tokens)))
    return tokens
</code></pre>
<p>or use concatenation so you can put it in the return statement:</p>
<pre><code>def three_tokens(s):
    tokens = s.split('-', 2)
    return tokens + [''] * (3 - len(tokens))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It might be overkill, but you could use a few methods from <code>itertools</code>.</p>
<pre><code>list(itertools.islice(itertools.chain(s.split('-', 2), itertools.repeat('')), 3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="http://docs.python.org/3/library/stdtypes.html#str.partition" rel="nofollow"><code>str.partition</code></a>:</p>
<pre><code>def three_tokens(s):
    t1, unused, t2 = s.partition('-')
    t2, unused, t3 = t2.partition('-')
    return [t1, t2, t3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This could work.</p>
<pre><code>tokens = s.split('-', 2)
tokens += [''] * max(0, 3 - len(tokens))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; n = 3
&gt;&gt;&gt; a = '123-abc'
&gt;&gt;&gt; b = a.split('-', n)
&gt;&gt;&gt; if len(b) &lt; n-1:
...     b = b + ['']*(n-len(b))
...
&gt;&gt;&gt; b
['123', 'abc', '']
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def three_tokens(s):
    tokens = s.split('-', 2)
    return [tokens.pop(0) if len(tokens) else '' for _ in range(0, 3)]
</code></pre>
<p>...yields</p>
<pre><code>&gt;&gt;&gt; three_tokens('foo')
['foo', '', '']

&gt;&gt;&gt; three_tokens('foo-bar')
['foo', 'bar', '']

&gt;&gt;&gt; three_tokens('foo-bar-baz')
['foo', 'bar', 'baz']

&gt;&gt;&gt; three_tokens('foo-bar-baz-buzz')
['foo', 'bar', 'baz-buzz']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this?</p>
<pre><code>def three_tokens(s):
    output = ['', '', '']
    tokens = s.split('-', 2)
    output[0:len(tokens)] = tokens
    return output
</code></pre>
<p>One more oneliner:</p>
<pre><code>three_tokens = lambda s: (s.split('-', 2) + ['', ''])[:3]
</code></pre>
<p>BTW, I don't find anything un-pythonic with your solution. It is a bit verbose but the intent is very clear.</p>
<p>One more:</p>
<pre><code>def three_tokens(s):
   it = iter(s.split('-', 2))
   return [ next(it, '') for _ in range(3) ]
</code></pre>
</div>
<span class="comment-copy">No need for <code>max()</code>; the limit on <code>s.split()</code> makes sure there never are more than 3 elements in <code>tokens</code> in any case.</span>
<span class="comment-copy">Besides, multiplying a list by a negative number results in an empty list as well; the <code>max()</code> is entirely overkill here.</span>
<span class="comment-copy">Why the <code>if</code> statement and the <code>b[:]</code> copy? <code>[''] * 0</code> is an empty list, and the list-copy-by-slice is entirely redundant and a waste of cycles.</span>
<span class="comment-copy">Yes. b[:] is not required. b+['']*max(1,2-len(b)) should do the trick.</span>
<span class="comment-copy">See my <a href="http://stackoverflow.com/questions/22308761/concise-way-to-split-a-string-into-a-list-of-fixed-number-of-tokens/22308969#comment33898474_22308930">comment on another answer to this question</a>, you don't need <code>max()</code>.</span>
