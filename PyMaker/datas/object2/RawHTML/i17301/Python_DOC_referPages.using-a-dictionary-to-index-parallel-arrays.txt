<div class="post-text" itemprop="text">
<p>I have 4 parallel arrays based on a table representing attributes of a map. Each array has approx. 500 values, but all have the same number of values.</p>
<p>The arrays are:</p>
<p><code>start</code> = location of the endpoint with the smaller flow accumulation,</p>
<p><code>end</code> = location of the other endpoint (with the larger flow accumulation),</p>
<p><code>length</code> = segment length, and; </p>
<p><code>shape</code> = actual shape, oriented to run from start to end.</p>
<p>I am attempting to create a data structure from which I can use a recursive function on to determine the start and end points every 2000m along the length.</p>
<p>The following question and answer describe what I am attempting to accomplish:</p>
<p><a href="https://gis.stackexchange.com/questions/87649/select-points-approx-2000-metres-from-another-point-along-a-river">https://gis.stackexchange.com/questions/87649/select-points-approx-2000-metres-from-another-point-along-a-river</a></p>
<p>How do I store these 4 parallel arrays in a dictionary keyed by start?</p>
<p>I am new to writing functions, dictionaries and using arrays in dictionaries. I am attempting to do this task in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to do things a little bit more <em>Python</em>-esque, you can use <code>enumerate</code>:</p>
<pre><code>d = {}
for (i,st) in enumerate(start):
    d[st] = (shape[i],length[i],end[i])
</code></pre>
<p>or even better - <code>zip</code>:</p>
<pre><code>d = {}
for (st,sh,le,en) in zip(start,shape,length,end):
    d[st] = (sh,le,en)
</code></pre>
<p>Note that you can leave out the parantheses around the first part of the <code>for</code> loops (i.e. between the <code>for</code> and <code>in</code> keywords). I used them solely for enhanced code readability.</p>
<p>As with <a href="https://stackoverflow.com/a/22172958/1278792">WeaselFox's answer</a>, <code>d[some_start_value]</code> will now hold the corresponding <code>shape</code>, <code>length</code> and <code>end</code> values.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this is what you mean:</p>
<pre><code>d = {}
for i in range(len(start)):
   d[start[i]] = (shape[i],length[i],end[i])
</code></pre>
<p>so now <code>d[some_start_value]</code> will hold the corresponding shape length and end values.</p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the above answers, I would recommend using <code>namedtuple</code> to simplify accesses:</p>
<pre><code>from collections import namedtuple

# This creates a namedtuple called GISData. Name of the object and name in the first argument 
# should be the same. 
GISData = namedtuple('GISData', 'start shape length end')

# zip creates 1 list of 4-tuples from 4 single lists
# There are other ways to write this; this is just the shortest for me.
# Note that if you need this ordered, you should use an OrderedDict,
# which is in the collections module in python 2.7+, or you can find
# backported versions for python 2.6+. In those, the keys preserve ordering,
# so can still be searched as a list, which is useful if you need to find e.g.
# 479, which is not in the dictionary, but 400 and 500 are and you have to interpolate etc.

GISDict = dict((x[0], GISData(*x)) for x in zip(start, shape, length, end))

# The dictionary for any given start value
# Access the 4 individual pieces by name, or by index
GISDict[start_lookup].shape
</code></pre>
<p>etc. </p>
</div>
<span class="comment-copy">Although it isn't necessarily required here, it may be useful to create a <a href="http://docs.python.org/3/tutorial/classes.html#a-first-look-at-classes" rel="nofollow noreferrer">class</a> that has start/end/length/shape attributes. That way, you could have a single list of <code>RiverSegment</code> objects (or whatever you want to call them) instead of four lists of attributes.</span>
