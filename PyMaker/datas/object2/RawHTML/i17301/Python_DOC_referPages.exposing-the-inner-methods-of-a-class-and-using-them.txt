<div class="post-text" itemprop="text">
<p>Let's say I have a class like so:</p>
<pre><code>class Shell:
  def cat(self, file):
    try:
      with open(file, 'r') as f:
        print f.read()
     except IOError:
      raise IOError('invalid file location: {}'.format(f))
   def echo(self, message):
     print message
   def ls(self, path):
     print os.listdir(path)
</code></pre>
<p>In a javascript context, you might be able to do something like <code>"Class"[method_name]()</code>, depending on how things were structured. I am looking for something similar in python to make this a "simulated operating system". EG:</p>
<pre><code>import os
def runShell(user_name):
  user_input = None
  shell = Shell()
  while(user_input != 'exit' or user_input != 'quit'):
    user_input = raw_input('$'+ user_name + ': ')
    ...
</code></pre>
<p>now, the idea is they can type in something like this...</p>
<pre><code>$crow: cat ../my_text
</code></pre>
<p>... and behind the scenes, we get this:</p>
<pre><code>shell.cat('../my_text')
</code></pre>
<p>Similarly, I would like to be able to print all method definitions that exist within that class when they type <code>help</code>. EG:</p>
<pre><code>$crow: help\n
&gt; cat (file)
&gt; echo (message)
&gt; ls (path)
</code></pre>
<p>is such a thing achievable in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the built-in function <a href="http://docs.python.org/3/library/functions.html#vars" rel="nofollow"><code>vars</code></a> to expose all the members of an object. That's maybe the simplest way to list those for your users. If you're only planning to print to <code>stdout</code>, you could also just call <code>help(shell)</code>, which will print your class members along with docstrings and so on. <code>help</code> is really only intended for the interactive interpreter, though, so you'd likely be better off writing your own help-outputter using <code>vars</code> and the <code>__doc__</code> attribute that's magically added to objects with docstrings. For example:</p>
<pre><code>class Shell(object):
    def m(self):
        '''Docstring of C#m.'''
        return 1
    def t(self, a):
        '''Docstring of C#t'''
        return 2

for name, obj in dict(vars(Shell)).items():
    if not name.startswith('__'): #filter builtins
        print(name, '::', obj.__doc__)
</code></pre>
<hr/>
<p>To pick out and execute a particular method of your object, you can use <a href="http://docs.python.org/3/library/functions.html#getattr" rel="nofollow"><code>getattr</code></a>, which grabs an attribute (if it exists) from an object, by name. For example, to select and run a simple function with no arguments:</p>
<pre><code>fname = raw_input()
if hasattr(shell, fname):
    func = getattr(shell, fname)
    result = func()
else:
    print('That function is not defined.')
</code></pre>
<p>Of course you could first tokenize the user input to pass arguments to your function as needed, like for your <code>cat</code> example:</p>
<pre><code>user_input = raw_input().split() # tokenize
fname, *args = user_input #This use of *args syntax is not available prior to Py3
if hasattr(shell, fname):
    func = getattr(shell, fname)
    result = func(*args) #The *args syntax here is available back to at least 2.6
else:
    print('That function is not defined.')
</code></pre>
</div>
<span class="comment-copy">you, sir, are very helpful. Thank you for the help.</span>
