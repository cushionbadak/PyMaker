<div class="post-text" itemprop="text">
<p>In order to avoid a circular import, I've been forced to define a function that looks like:</p>
<pre><code># do_something.py

def do_it():
    from .helpers import do_it_helper
    # do stuff
</code></pre>
<p>Now I'd like to be able to test this function, with <code>do_it_helper</code> patched over. If the import were a top level import,</p>
<pre><code>class Test_do_it(unittest.TestCase):
    def test_do_it(self):
        with patch('do_something.do_it_helper') as helper_mock:
            helper_mock.return_value = 12
            # test things
</code></pre>
<p>would work fine. However, the code above gives me:</p>
<pre><code>AttributeError: &lt;module 'do_something'&gt; does not have the attribute 'do_it_helper'
</code></pre>
<p>On a whim, I also tried changing the patch statement to:</p>
<pre><code>with patch('do_something.do_it.do_it_helper') as helper_mock:
</code></pre>
<p>But that produced a similar error. Is there any way to mock this function, given the fact that I'm forced into importing it within the function where it's used?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should mock out <code>helpers.do_it_helper</code>:</p>
<pre><code>class Test_do_it(unittest.TestCase):
    def test_do_it(self):
        with patch('helpers.do_it_helper') as helper_mock:
            helper_mock.return_value = 12
            # test things
</code></pre>
<p>Here's an example using mock on <code>os.getcwd()</code>:</p>
<pre><code>import unittest
from mock import patch


def get_cwd():
    from os import getcwd
    return getcwd()


class MyTestCase(unittest.TestCase):
    @patch('os.getcwd')
    def test_mocked(self, mock_function):
        mock_function.return_value = 'test'
        self.assertEqual(get_cwd(), 'test')
</code></pre>
<p>Hope that helps.</p>
</div>
<span class="comment-copy">That totally works! Where to patch has always been confusing for me. The rule of thumb from the docs is "patch where an object is looked up, which is not necessarily the same place as where it is defined." In this case, though, you patch where it is defined. Why is that?</span>
<span class="comment-copy">@Wilduck well, pay attention to that <code>necessarily</code> word - sounds a bit "two-edged" :)</span>
<span class="comment-copy">@alecxe sorry for bumping this question again after so many years. I basically have the same question as OP that why the object is looked up in its original file not in the new file? I tried to google it, but every one just touched it lightly - claim it is binded to the local scope and that's all.</span>
<span class="comment-copy">In Python, when you import something, it becomes part of the module's scope. Python's docs explains it: "The import statement combines two operations; it searches for the named module, then it binds the results of that search to a name in the local scope." (<a href="https://docs.python.org/3/reference/import.html" rel="nofollow noreferrer">docs.python.org/3/reference/import.html</a>)</span>
