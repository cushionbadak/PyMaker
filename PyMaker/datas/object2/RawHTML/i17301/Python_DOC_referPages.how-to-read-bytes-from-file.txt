<div class="post-text" itemprop="text">
<p>I'm trying to read the length of some metadata from a .lrf file. (Used with the program LoLReplay)</p>
<p>There's not really documentation on these files, but I have already figured out how to do this in C++. I'm trying to re-write the project in python for multiple reasons, but I come across an error.</p>
<p>To first explain, the .lrf file has metadata immediately at the start of the file in this format:</p>
<ul>
<li><p>first 4 bytes are for something I have no clue about.</p></li>
<li><p>next 4 bytes store the length of the metadata in hexidecimal, up until the end of the metadata, which after is the actual contents of the replay.</p></li>
<li><p>bytes after the initial 8 bytes are the metadata in json format</p></li>
</ul>
<p>The problem I'm having is actually reading the metadata length. This is the current function I have:</p>
<pre><code>def getMetaLength(self):
    try:
        file = open(self.file,"r")
    except IOError:
        print ("Failed to open file.")
        file.close()
    #We need to skip the first 4 bytes.
    file.read(4)
    mdlength = file.read(4)
    print(hex(mdlength))
    file.close()
</code></pre>
<p>When I call this function, the shell returns a traceback stating:</p>
<pre><code>    Traceback (most recent call last):
    File "C:\Users\Donald\python\lolcogs\lolcogs_main.py", line 6, in &lt;module&gt;
    lolcogs.getMetaLength()
    File "C:\Users\Donald\python\lolcogs\LoLCogs.py", line 20, in getMetaLength
    file.read(4)
    File "C:\Python32\lib\encodings\cp1252.py", line 23, in decode
    return codecs.charmap_decode(input,self.errors,decoding_table)[0]
    UnicodeDecodeError: 'charmap' codec can't decode byte 0x81 in position 3648:       character maps to &lt;undefined&gt;
</code></pre>
<p>My best guess is that read() is trying to read characters that are encoded in some unicode format, but these are definitely just bytes that I am attempting to read. Is there a way to read these as bytes? Also, is there a better way to skip bytes when you are attempting to read a file?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3 files are opened in text mode with the system's encoding by default. You need to open your file in binary mode:</p>
<pre><code>file = open(self.file, 'rb')
</code></pre>
<p>Another problem you will run into is that <code>file.read(4)</code> will give you a string of 4 bytes (which the <code>hex</code> function doesn't understand). And you possibly want an integer. For that, refer to <a href="http://docs.python.org/3/library/stdtypes.html#int.from_bytes" rel="nofollow"><code>int.from_bytes</code></a>, or, more generally, to the <a href="http://docs.python.org/3/library/struct.html" rel="nofollow"><em>struct</em> module</a>. Then you can print that number in hexadecimal format as so:</p>
<pre><code>mdlength = int.from_bytes(file.read(4), byteorder='big')
print(hex(mdlength))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Binary files should be handled in binary mode:</p>
<pre><code>f = open(filename, 'rb')
</code></pre>
<p>For skipping bytes, I typically use file <code>seek</code> (SEEK_CUR or SEEK_SET) or I just do arbitrary <code>file.read(n)</code> if I didn't want to bother with formality. Only time I really use seeking is if I wanted to jump to a specific position.</p>
<p>Interpreting binary data I just stick to the unpack method provided by the <code>struct</code> module, which makes it easy to define whether you want to interpret a sequence of bytes as an int, float, char, etc. That's how I've been doing it for years so maybe there are more efficient approaches like the <code>from_bytes</code> method described in other answers.</p>
<p>With the struct module you can do things like</p>
<pre><code>struct.unpack("3I", f.read(12))
</code></pre>
<p>To read in 3 (unsigned) integers at once. So for example given the format you've reversed engineered I would probably just say</p>
<pre><code>unk, size = struct.unpack("2I", f.read(8))
data = f.read(size)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should open the file in binary mode: <code>open(filename, 'rb')</code>.</p>
</div>
<span class="comment-copy">Try opening the file in <i>binary mode</i>: <code>f = open(self.file,"rb")</code>. Also, don't name it <code>file</code> since it will conflict with built in <code>file</code> type name.</span>
<span class="comment-copy">@PauloBu There seems to be no such type anymore, though...</span>
<span class="comment-copy">In Python2.7 it is defined. In Python3 no. But reading the OP's code he's probably using Python 3 so ignore my comment :)</span>
<span class="comment-copy">@PauloBu Thanks, I used "rb" instead of just "r" and now I get the error "TypeError: 'bytes' object cannot be interpreted as an integer" but the c++ version had to do some tricky stuff so I already have a general idea of what to do to fix this.</span>
<span class="comment-copy">Amazing! The int.from_bytes() function is exactly what I needed. In c++ I don't know if there is an equivalent function but I had to do this manually in c++ and was about to do it manually in python until I read your comment! Thanks!</span>
