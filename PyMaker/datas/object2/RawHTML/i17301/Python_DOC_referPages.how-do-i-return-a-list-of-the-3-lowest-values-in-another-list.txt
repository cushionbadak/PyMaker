<div class="post-text" itemprop="text">
<p>How do I return a list of the 3 lowest values in another list.  For example I want to get the 3 lowest values of this list:</p>
<pre><code>in_list = [1, 2, 3, 4, 5, 6]
input: function(in_list, 3)
output: [1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/3/library/heapq.html#heapq.nsmallest" rel="noreferrer"><code>heapq.nsmallest</code></a>:</p>
<pre><code>&gt;&gt;&gt; from heapq import nsmallest
&gt;&gt;&gt; in_list = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; nsmallest(3, in_list)
[1, 2, 3]
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you could sort,you can get frst 3 elements as below:</p>
<pre><code> alist=[6, 4, 3, 2, 5, 1]
 sorted(alist)[:3]
</code></pre>
<p>Output:</p>
<pre><code> [1,2,3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>even simpler without modules imported:</p>
<pre><code>l =[3,8,9,10,2,4,1]
l1 = sorted(l)[:3]
</code></pre>
<p>hope this helps</p>
</div>
<div class="post-text" itemprop="text">
<p>If your lists are long, the most efficient way of doing this is via <a href="http://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.partition.html" rel="nofollow"><code>numpy.partition</code></a>:</p>
<pre><code>&gt;&gt;&gt; def lowest(a, n): return numpy.partition(a, n-1)[:n]
&gt;&gt;&gt; in_list = [6, 4, 3, 2, 5, 1]
&gt;&gt;&gt; lowest(in_list, 3)
array([1, 2, 3])
</code></pre>
<p>This executes in O(N) time, unlike a full sort which would operate in O(NlogN) time. The time savings come from not performing a full sort, but only the minimal amount needed to ensure that the <code>n</code> lowest elements are first. Hence the output is not necessarily sorted.</p>
<p>If you need them to be sorted, you can do that afterwards (<code>numpy.sort(lowest(in_list,3)) =&gt; array([1,2,3])</code>). For a large array this will still be faster than sorting the whole thing first.</p>
<p>Edit: Here is a comparison of the speed of <code>numpy.partition</code>, <code>heapq.nsmallest</code> and <code>sorted</code>:</p>
<pre><code>&gt;&gt;&gt; a = numpy.random.permutation(np.arange(1000000))
&gt;&gt;&gt; timeit numpy.partition(a, 2)[:3]
100 loops, best of 3: 3.32 ms per loop
&gt;&gt;&gt; timeit heapq.nsmallest(3,a)
1 loops, best of 3: 220 ms per loop
&gt;&gt;&gt; timeit sorted(a)[:3]
1 loops, best of 3: 1.18 s per loop
</code></pre>
<p>So <code>numpy.partition</code> is 66 times faster than <code>heapq.nsmallest</code> for an array with a million elements, and it is 355 times faster than <code>sorted</code>. This doesn't mean that you should never use <code>heapq.nsmallest</code> (which is very flexible), but it demonstrates how important it is to avoid plain lists when speed is important.</p>
</div>
<span class="comment-copy">There can be many ways.  What approach did you come up with?</span>
<span class="comment-copy">This does transform the original list into a <code>np.array()</code> object.</span>
<span class="comment-copy">Note that <code>heapq.nsmallest()</code> does the same thing, plus the sort, in roughly the same order of complexity; it takes O(NlogK) time, where K is the number of elements to be returned. Both <code>numpy.partition()</code> and <code>heapq</code> are backed by C code. The fact that <code>heapq</code> then returns a Python list could be seen as an advantage over <code>numpy.partition()</code>.</span>
<span class="comment-copy">Yes. But then, if your lists are long you want to be using arrays instead of lists anyway, since they are so much faster and use much less memory. If you want the output to be a plain list, just do <code>list(lowest(in_list,3))</code>.</span>
<span class="comment-copy">What about an iterable? The <code>heapq.nsmallest()</code> function doesn't require all values to be in memory in a list. You can process a large file efficiently finding the longest 3 lines with <code>heapq.nlargest(3, fileobj, key=len)</code>, and you never need more memory than 4 lines plus a read-ahead buffer.</span>
<span class="comment-copy">Yes, iterables are flexible and can save a lot of memory. But they aren't very fast, since the iteration happens in python. I have updated my answer with a small benchmark to illustrate my point.</span>
