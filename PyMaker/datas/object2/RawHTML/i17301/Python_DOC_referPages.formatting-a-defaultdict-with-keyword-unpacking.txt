<div class="post-text" itemprop="text">
<p>I want to format and print data from a dictionary with the keyword unpacking operator <code>**</code>.</p>
<p>The format string possibly refers to many keywords and the dictionary may not have all the required keys. For the missing keys, I would like to use the string 'N/A' as a default value.</p>
<p>I would like a clever solution for this default-ing problem, possibly using a <code>defaultdict</code>.</p>
<p>Here is a first solution using a regular <code>dict</code>.</p>
<pre><code># Cumbersome solution with dict
format_str = '{date} {version} {comment}'
data       = dict()

data['date']    = 'today'
data['version'] = 'v1'
data['comment'] = 'N/A'  # I want to avoid this

print format_str.format(**data)
# prints: today v1 N/A
</code></pre>
<p>I would like to avoid the explicit assignment of 'N/A' for missing keys.</p>
<p>The following solution also uses a regular <code>dict</code> and analyzes the format string to build the list of keywords:</p>
<pre><code># Another solutions with handmade defaults for missing keys
format_str = '{date} {version} {comment}'
data       = dict()

data['date']    = 'today'
data['version'] = 'v1'

import re
for k in re.findall('{(\w+)}', format_str):
    if k not in data:
        data[k] = 'N/A'

print format_str.format(**data)
# prints: today v1 N/A
</code></pre>
<p>This solution with <code>re.findall</code> is not really elegant nor robust since the syntax of format string is much more complex than the above <code>{(\w+)}</code>.</p>
<p>The following solution would be my favorite one… if it did not fail for an obvious reason.</p>
<pre><code># Failed attempt with defaultdict
from collections import defaultdict
format_str = '{date} {version} {comment}'
data       = defaultdict(lambda x:'N/A')

data['date']    = 'today'
data['version'] = 'v1'

print format_str.format(**data)
# raises KeyError: 'comment'
</code></pre>
<p>The problem here is that <code>**</code> actually unpacks the keywords in <code>data</code>, so <code>format</code> does not search <code>data</code> for the requested keywords and thus does not give <code>data</code> the opportunity to provide its default value.</p>
<p>Is there a solution to this ?
Eg is there an alternative <code>format</code> function which would actually call <code>data.get(kwd)</code> and thus get the <code>N/A</code>s?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/2/library/string.html#string.Formatter.vformat" rel="nofollow"><code>string.Formatter.vformat()</code></a> and pass the <code>defaultdict</code> to that.</p>
<pre><code>from collections import defaultdict
from string import Formatter

fmtr = Formatter()
format_str = '{date} {version} {comment}'
data = defaultdict(lambda: 'N/A')

data['date'] = 'today'
data['version'] = 'v1'

print fmtr.vformat(format_str, (), data)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Good solution using formatter is already given</p>
<p>However you are not benefiting from keyword unpacking in this case. You are forced to specify keys you wanted to print in the format string. </p>
<pre><code>format_str = '{date} {version} {comment}'
</code></pre>
<p>And dict as intended already maintains the Keyword-Value mapping</p>
<p>so for dict like this</p>
<pre><code>&gt;&gt;&gt; d
{'version': 'v1', 'date': 'today'}
</code></pre>
<p>using default value to dict.get()</p>
<pre><code>&gt;&gt;&gt; print '{} {} {}'.format(d['date'],d['version'],d.get('comment','n/a'))
today v1 n/a
</code></pre>
<p>if you want Key Word management in one place (as you did with format string), I would try something like this</p>
<pre><code>&gt;&gt;&gt; f=lambda x: (x.get('date'),x.get('version'),x.get('comment','N/A'))
&gt;&gt;&gt; print '{} {} {}'.format(*f(d))
today v1 N/A
</code></pre>
<p>or this</p>
<pre><code>&gt;&gt;&gt; f=lambda x: '{} {} {}'.format(x['date'],x['version'],x.get('comment','N/A'))
&gt;&gt;&gt; print f(d)
today v1 N/A
</code></pre>
<p>the benefit is, Less imports</p>
</div>
<span class="comment-copy">In Python 3, they added exactly the method you're looking for: <a href="http://docs.python.org/3/library/stdtypes.html#str.format_map" rel="nofollow noreferrer"><code>str.format_map</code></a></span>
<span class="comment-copy">I think what you're after is <a href="http://stackoverflow.com/questions/19799609/leaving-values-blank-if-not-passed-in-str-format/" title="leaving values blank if not passed in str format">stackoverflow.com/questions/19799609/…</a> - dawg's answer will also allow you to set a default other than blank ("N/A") for instance...</span>
<span class="comment-copy">@user2357112 now that I know format_map, I found this <a href="http://stackoverflow.com/questions/17215400/python-format-string-unused-named-arguments" title="python format string unused named arguments">stackoverflow.com/questions/17215400/…</a> which addresses both Python 2 and Python 3.</span>
<span class="comment-copy">There is no such function.</span>
<span class="comment-copy">Sorry, I meant: <a href="http://docs.python.org/2/library/string.html#string.Formatter.vformat" rel="nofollow noreferrer">docs.python.org/2/library/string.html#string.Formatter.vformat</a></span>
