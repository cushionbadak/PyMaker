<div class="post-text" itemprop="text">
<p>What is the most elegant way to open a file such that</p>
<ul>
<li>the file gets created if it does not exist,</li>
<li>the file won't be truncated if it does exist and</li>
<li>it is possible to write any part of the file (after seeking), not just the end?</li>
</ul>
<p>As far as I can tell, <a href="http://docs.python.org/3/library/functions.html#open" rel="noreferrer">the <code>open</code> builtin</a> doesn't seem up to the task: it provides various modes, but every one I tried fails to satisfy at least one of my requirements:</p>
<ul>
<li><code>r+</code> fails if the file does not exist.</li>
<li><code>w+</code> will truncate the file, losing any existing content.</li>
<li><code>a+</code> will force all writes to go to the end of the file, at least on my OS X.</li>
</ul>
<p>Checking for the existence prior to opening the file feels bad since it leaves room for race conditions. The same holds for retrying the open with a different mode from within an exception handler. I hope there is a better way.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to use <a href="http://docs.python.org/3/library/os.html#os.open"><code>os.open()</code></a> to open it at a lower level in the OS than <code>open()</code> allows. In particular, passing <code>os.RDWR | os.O_CREAT</code> as <code>flags</code> should do what you want. See the <code>open(2)</code> man page for details. You can then pass the returned FD to <a href="http://docs.python.org/3/library/os.html#os.fdopen"><code>os.fdopen()</code></a> to get a file object from it.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using Python 3.3+, you can use <code>x</code> mode (exclusive creation mode):</p>
<pre><code>try:
    f = open('/path/to/file', 'x+')
except FileExistsError:
    f = open('/path/to/file', 'r+')
</code></pre>
<p>It raises <code>FileExistsError</code> if the file already exists.</p>
</div>
<div class="post-text" itemprop="text">
<p>I might be wrong, but I don't suppose there is going to be a race condition if there are not multiple threads, and the <code>try</code> and <code>except</code> blocks are the same thread? (Is it actually possible to do multiple threads?)</p>
<p>This should be up to the task.</p>
<pre><code>&gt;&gt;&gt;try: 
      f=open('myfile.txt','r')
   except OSError:
      f=open('myfile.txt','w')
   finally:
      #whatever file I/O you need.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I was having a similar problem when trying to dump items to a file as a dictionary. However, I imported json, <a href="http://docs.python.org/2/library/json.html" rel="nofollow">http://docs.python.org/2/library/json.html</a> check this out, maybe very helpful. Remember to import json. This will provide the foundation to dump and load data whenever you need to. In this case I am dumping and loading information into an empty dictionary. The try and except method is very useful when you want to use an empty dictionary. I find "r+" most useful since it will read and write the file. </p>
<pre><code>def dump_data():
    j = json.dumps(file.text, indent=4)
    with open("database.txt", "w") as f:
        f.write(j)

def load_data():
    try:
        with open("file.txt", "r+") as f:
            return json.load(fp=f)
    except IOError:
            return {}
</code></pre>
</div>
<span class="comment-copy">If your goal is to write to the middle of the file, I doubt there is a very clean way.</span>
<span class="comment-copy">Particularly in combination with <code>os.fdopen</code> this looks very good. I just found abot <a href="http://stackoverflow.com/a/10352231/1468366">this answer</a> in the related links, which suggests the same. Thanks!</span>
<span class="comment-copy">I'm concerned about multiple applications, some perhaps using different code.</span>
<span class="comment-copy">"The same holds for retrying the open with a different mode from within an exception handler." And the race condition can happen with other programs regardless of the use of threading in the Python script.</span>
<span class="comment-copy">@IgnacioVazquez-Abrams I don't follow, other programs are trying to access the file? Then shouldn't the checking be done in <i>that</i> program and not the Python script? I might be missing something embarrassingly obvious.</span>
<span class="comment-copy">@IgnacioVazquez-Abrams Anyway your answer seems to have covered it. +1</span>
<span class="comment-copy">An exploit can attempt to take advantage of the small time between <code>open()</code> calls to e.g. link in a system file, destroying it in the process.</span>
<span class="comment-copy">Right now I'm writing items in response to interactive activity, and flushing the modifications to disk after every such write, so nothing will get lost in case of a serious crash or power outage. Writing the whole data anew after every modification feels rather inefficient in this setup.</span>
