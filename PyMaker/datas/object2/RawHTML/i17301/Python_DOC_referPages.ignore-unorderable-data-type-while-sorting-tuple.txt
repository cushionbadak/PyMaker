<div class="post-text" itemprop="text">
<p>I'm teaching myself Python from a book and I'm stuck on a programming exercise. The aim of the exercise is to make a list of objects, and then sort those objects based on some object attribute.</p>
<p>The author of my textbook says that using a key to call a class method for every comparison during sorting can slow down sort time for large datasets and that building a 'decorated' list by calling the class method just once for each object as you build the list can make subsequent sorting more efficient. The programming problem stipulates that, instead of a key, I should make a series of tuples, wherein tuple element 0 is the literal value of an object attribute, and tuple element 1 is the object itself. After I have my decorated list, I can use a built-in list sort method (e.g. "sorted()" or ".sort()", etc.) to put it all in order.</p>
<p>I get an error when two objects have an identical sort attribute value. This example code will reproduce the error:</p>
<pre><code>class Shrubber:
    def __init__(self, age):
        self.name = 'Roger'
        self.age = age

    def getAge(self):
        return self.age

def main():
    rogerAges = [30, 21, 21, 25]
    rogers = []
    for rAge in rogerAges:
        newShr = Shrubber(rAge)
        rogers.append((newShr.getAge(), newShr))
    rogers.sort()
    print(rogers)

main()
</code></pre>
<p>I would like the program to print something like this:</p>
<pre><code>[(21, &lt;__main__.Shrubber object at XxXEX&gt;), (21, &lt;__main__.Shrubber object at YxYEY&gt;), (25, &lt;__main__.Shrubber object at ZxZEZ&gt;), (30, &lt;__main__.Shrubber object at QxQEQ&gt;)]
</code></pre>
<p>...but instead, it gives me a TypeError:</p>
<pre><code>TypeError: unorderable types: Shrubber() &lt; Shrubber()
</code></pre>
<p>I'm sure I'm getting the error because, after Python encounters two identical values for two tuple elements 0, it looks to elements 1 and finds an unorderable data type (an object). However, the limitation that two Shrubbers can't be the same age makes it seem like I'm missing something.</p>
<p>My question: Can I stably sort my tuple list by tuple element 0 and ignore my unorderable tuple element 1?</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know a way to make it ignore the second element in these cases. An alternative is to add a method to the object's class that will return the needed information. Doing so will avoid needing to pass<code>sort()</code>a <code>key=</code> function. Here's an example of what I mean:</p>
<pre><code>class Shrubber:
    def __init__(self, age):
        self.name = 'Roger'
        self.age = age

    def getAge(self):
        return self.age

    def __lt__(self, other):  # added comparison method
        return self.age &lt; other.age

def main():
    rogerAges = [30, 21, 21, 25]
    rogers = []
    for rAge in rogerAges:
        newShr = Shrubber(rAge)
        rogers.append((newShr.getAge(), newShr))
    rogers.sort()
    print(rogers)

if __name__ == '__main__':
    main()
</code></pre>
<p>Output (wrapped for readability):</p>
<pre class="lang-none prettyprint-override"><code>[(21, &lt;__main__.Shrubber object at 0x00C1D830&gt;),
 (21, &lt;__main__.Shrubber object at 0x00C1D9D0&gt;),
 (25, &lt;__main__.Shrubber object at 0x00C1DA30&gt;),
 (30, &lt;__main__.Shrubber object at 0x00C1D9F0&gt;)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You do not have to implement a <code>__lt__</code> function if you make sure the comparison never gets through to the Shrubber objects. One way to do that is inserting another integer into that tuple:</p>
<pre><code>def main():
    rogerAges = [30, 21, 21, 25]
    rogers = list()
    for i, rAge in enumerate(rogerAges):
        newShr = Shrubber(rAge)
        rogers.append((newShr.getAge(), i, newShr))
    rogers.sort()
    print(rogers)
</code></pre>
<p>However, this is from all points of view wrong, you should use a <code>key=</code> function. This is harder to read and according to my measurements, it is about four times slower. Still, using <code>__lt__</code> (or the deprecated <code>cmp=</code>) is even worse, about two more times slower.</p>
<p>As a final note, appending to a list this way is not the Pythonic way. You can do this:</p>
<pre><code>def main():
    rogerAges = [30, 21, 21, 25]
    rogers = [(rAge, i, Shrubber(rAge)) for (i, rAge) in enumerate(rogerAges)]
    rogers.sort()
    print(rogers)
</code></pre>
</div>
<span class="comment-copy">Instead of a <i>key</i>? Are you sure it doesn't talk about a <i>comparator</i>? One of the reasons key functions were introduced was to optimize exactly what you're talking about.</span>
<span class="comment-copy">Python version?</span>
<span class="comment-copy">Works for me on python 2.7</span>
<span class="comment-copy">Yeah, he said not to use a key, but to create tuples with the literal value of the orderable attribute as element 0 for each 2-element tuple. He doesn't cover comparators in the book, insofar as they haven't been introduced yet and there's no entry in the textbook index. Using Python 3.3.</span>
<span class="comment-copy">That... doesn't make sense. The key function is only evaluated once for every list item. It's just like if you had used decorate-sort-undecorate, but faster and cleaner. The only case I can think of where it might be faster to use a decorated list is if you're going to be modifying and re-sorting the list repeatedly, but even then, if the key function just fetches an attribute, the cost should be trivial.</span>
<span class="comment-copy">Thanks! That is quite clear, in terms of how I write the code, but I'll have to learn a little more about how "<b>lt</b>" and similar functions work.</span>
<span class="comment-copy">The <a href="https://docs.python.org/3/library/stdtypes.html?highlight=sort#list.sort" rel="nofollow noreferrer">documentation</a> for the <code>list.sort()</code> method says it sorts the list using only <code>&lt;</code> comparisons which corresponds to a class' <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__lt__#object.__lt__" rel="nofollow noreferrer"><code>__lt__</code> method</a>. The code in my answer simply adds such a method to the <code>Shubber</code> class, that was written so it only compares the data attributes of interest.</span>
<span class="comment-copy">Yep, I get that now. I had never heard of rich comparisons before asking this question, but the documentation is very straightforward, and made sense as soon as I realized 1) rich comparison methods aren't called explicitly, but implicitly when an object is compared and 2) rich comparisons are only called when an object is on the appropriate side of the appropriate operator (ie <code>__lt__</code> is only called when the object is on the left of <code>&lt;</code>, as you said). Super useful. Thanks again for pointing me toward those.</span>
<span class="comment-copy">Thanks emu. It makes sense that I would add code to count instances of similar objects - I didn't think of that.</span>
<span class="comment-copy">It gets around the rich comparison or lambda functions that weren't covered at that point in the book. Not that it's correct or Pythonic to get around lambda or rich comparisons, I just wanted to know how I could. I'd upvote you, but my mere 13 credibilities do not afford me that priviledge. Parenthetically, the SO reputation system seems a lot like Bart Simpson's rules of the playground to me, so it's also the reason I no longer contribute to SO.</span>
<span class="comment-copy">yeah, the rules feel like a weird role-playing game. It is funny at times, but I'm quite sure I can live without these upvote points :)</span>
