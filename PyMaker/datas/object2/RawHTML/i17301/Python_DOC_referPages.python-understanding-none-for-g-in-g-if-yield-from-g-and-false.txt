<div class="post-text" itemprop="text">
<p>James Powell, in his short description for an upcoming presentation, says he is the proud inventor of one of the gnarliest Python one-liners:</p>
<pre><code>(None for g in g if (yield from g) and False)
</code></pre>
<p>I am trying to figure out this generator, and since I live with Python 2.7.x, I'm also tripping over the <code>(yield from g)</code> expression.</p>
<p>How do I read this, and what would be the python 2.7.x analog?</p>
<hr/>
<p>What a great discussion below! I want to check if I have this correct in the main.</p>
<pre><code>&gt;&gt;&gt; l = [10, 11, iter(xrange(5)), 12, 13]
&gt;&gt;&gt; g = iter(l)
&gt;&gt;&gt; flat_g = (None for g in g if (yield from g) and False)
&gt;&gt;&gt; list(flat_g)
[10, 11, 0, 1, 2, 3, 4, 12, 13]
</code></pre>
<p>Is that about right?</p>
</div>
<div class="post-text" itemprop="text">
<p>This expression seems to be a code-golf way of writing:</p>
<pre><code>(a for b in g for a in b)
</code></pre>
<p>((Or maybe the motivation be taking advantage of generator delegations, but IMHO readability really suffers.))</p>
<p>For example:</p>
<pre><code>#! /usr/bin/python3.3

g = ['abc', 'def', 'ghi']

a = (None for g in g if (yield from g) and False)
for x in a: print (x)

b = (a for b in g for a in b)
for x in b: print (x)
</code></pre>
<p>Prints twice the flattened list.</p>
<p>I think it becomes more legible if you use different variable names:</p>
<pre><code>(None for sublist in g if (yield from sublist) and False)
</code></pre>
<p>Which is the same as </p>
<pre><code>(42 for sublist in g if (yield from sublist) and False)
</code></pre>
<p>as due to the <code>something and False</code> the outer generator doesn't yield anything, while the inner generator yields all elements of all sublists (subgenerators, subiterables).</p>
<p>Maybe this clarifies a bit how it works:</p>
<pre><code>('Sublist {}'.format(idx) for idx, sublist in enumerate(g) if (yield from sublist) or True)
</code></pre>
<hr/>
<p>Apparently the original generator can be simplified to this, omitting the last <code>and False</code>:</p>
<pre><code>(None for sublist in g if (yield from sublist) )
</code></pre>
<hr/>
<p><strong>Revision:</strong></p>
<p>Thanks to Martijn Pieters fighting my stubbornness, I managed to see that <code>(None for sublist in g if (yield from sublist) and False)</code> and <code>(None for sublist in g if (yield from sublist) )</code> are <strong>not equivalent</strong>. Here an example of a <code>g</code> which makes a difference:</p>
<pre><code>def f():
    yield 1
    return 2

def g():
    yield f()

a = (None for sublist in g() if (yield from sublist) )
for x in a: print(x)
a = (None for sublist in g() if (yield from sublist) and False)
for x in a: print(x)
</code></pre>
<p>This prints:</p>
<pre><code>1
None
1
</code></pre>
</div>
<span class="comment-copy">That is indeed gnarly. The full equivalence of <code>yield from g</code> in Python can be found in the <a href="http://legacy.python.org/dev/peps/pep-0380/" rel="nofollow noreferrer">generator delegation PEP</a> and it's perhaps a little longer than needed here.</span>
<span class="comment-copy">I wonder whether using <code>yield from</code> in a generator expression was actually intended.</span>
<span class="comment-copy">@JonasWielicki: it was absolutely intended. <code>yield from</code> is an <i>expression</i>. It returns a value; that of the <code>StopIteration()</code> exception raised by the generator that was delegated to.</span>
<span class="comment-copy">I doubt that this behaviour can be recreated fully in Python 2.7. You can flatten the generator but not take advantage of the generator delegation optimizations that the new syntax allows for.</span>
<span class="comment-copy">one final question (off topic): does <code>yield from g</code> yield a single item from <code>g</code>, or yield all items from <code>g</code> before continuing?</span>
<span class="comment-copy">aka <code>itertools.chain</code>â€¦</span>
<span class="comment-copy">@thefourtheye Looks like. The question is why should it evaluate to anything Truey, if it doesn't "return" anything.</span>
<span class="comment-copy">@thefourtheye it evaluates to <code>None</code> I suppose.</span>
<span class="comment-copy">@Hyperboreus: so <code>def foo(): yield 1; return True</code> would be an example.</span>
<span class="comment-copy">@Hyperboreus: See <a href="http://docs.python.org/3/reference/expressions.html#yield-expressions" rel="nofollow noreferrer">docs.python.org/3/reference/expressions.html#yield-expressions</a>; <i>When the underlying iterator is complete, the value attribute of the raised <code>StopIteration</code> instance becomes the value of the yield expression. It can be either set explicitly when raising <code>StopIteration</code>, or automatically when the sub-iterator is a generator (by returning a value from the sub-generator).</i></span>
