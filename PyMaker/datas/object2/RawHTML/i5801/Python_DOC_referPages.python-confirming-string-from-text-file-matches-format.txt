<div class="post-text" itemprop="text">
<p>I've got a program that needs to take a text file as input and do a few things with each line of code. </p>
<p>Before i can do anything with the text file though, i need to ensure that every line matches a specific format which in this case, would be city name (which could be any string, it wouldn't need to be a real city name) followed by a ',' followed by a number.</p>
<p>a typical line would look like this:</p>
<blockquote>
<p>towna,2.43</p>
</blockquote>
<p>This is what I have at the moment, it works in terms of making the program function but it doesn't verify that the data is correct, so if its wrong (and it will be from time to time) its going to give me an error. I read some stuff about re.match, but I don't understand how to use it.</p>
<pre><code>def read_file(fileName):
    weatherFile = open(fileName)
    for line in weatherFile:
        stripped =  line.replace(' ','')
        pass #add data validation for file
        town, rain  = stripped.split(",")
        if checkIfExists(town):
            dataList.append({"city":town, "average_rainfall":float(rain.rstrip())})
        else:
            print("It looks like {0} is on the list twice.  Please ensure all towns in {1}  only appear once and try again." .format(town, fileName))
            break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Before I answer, I just have to point out that you are messing with the data before the validation even starts.</p>
<p>What if the user enters <code>Saint Jose,23.0</code>? Then this line <code>stripped =  line.replace(' ','')</code> in your code will replace it with <code>SaintJose,23.0</code>.</p>
<p>Anyways, to solve this, it is simple and can be done with a bit of regex.</p>
<pre><code>import re #python regex

def read_file(fileName):
    pattern = re.compile(r'(.*?),([-+]?(?:\d+\.\d*|\.?\d+)(?:[eE][-+]?\d+)?)')
    with open(fileName) as weatherFile:
        for line in weatherFile:
            if not pattern.fullmatch(line.strip()):
                continue
            town, rain  = line.split(",")
            if checkIfExists(town):
                dataList.append({"city":town, "average_rainfall":float(rain.rstrip())})
            else:
                print("It looks like {0} is on the list twice.  Please ensure all towns in {1}  only appear once and try again." .format(town, fileName))
                break
</code></pre>
<p>You can make it even shorter with generator expressions:</p>
<pre><code>def read_file(fileName):
    pattern = re.compile(r'(.*?),([-+]?(?:\d+\.\d*|\.?\d+)(?:[eE][-+]?\d+)?)')
    with open(fileName) as weatherFile:
        for town, rain in (line.split(",") for line in weatherFile if pattern.fullmatch(line.strip()))
            if checkIfExists(town):
                dataList.append({"city":town, "average_rainfall":float(rain.rstrip())})
            else:
                print("It looks like {0} is on the list twice.  Please ensure all towns in {1}  only appear once and try again." .format(town, fileName))
                break
</code></pre>
<p>This line:</p>
<pre><code>pattern = re.compile(r'(.*?),([-+]?(?:\d+\.\d*|\.?\d+)(?:[eE][-+]?\d+)?)')
</code></pre>
<p>Compiles a regex for reuse. This is often more efficient for complex regex expressions so that the regex engine does not have to re-evaluate and rebuild it's internal state each time the regex is used for matching.</p>
<p>The equivalent for matching without pre-compiling the regex would be:</p>
<pre><code>re.fullmatch(your_string_expression, r'(.*?),([-+]?(?:\d+\.\d*|\.?\d+)(?:[eE][-+]?\d+)?)')
</code></pre>
<p>The scary looking regular expression you see (this one <code>([-+]?(?:\d+\.\d*|\.?\d+)(?:[eE][-+]?\d+)?)</code>) is used for matching ints or floats, and this is why it is soo long. Python has some defined <a href="https://docs.python.org/3/library/re.html#simulating-scanf" rel="nofollow noreferrer">here</a>. The one I used here combines matching ints and floats, and you can see an example of it's use <a href="https://gist.github.com/smac89/bfefc0303c2aab6cac0b08055e195c55" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. (Jamie Zawinski)</p>
</blockquote>
<p>Compare the <code>(.*?),([-+]?(?:\d+\.\d*|\.?\d+)(?:[eE][-+]?\d+)?)</code> regular expression to the following validation definition proposed below:</p>
<pre><code>validators = {
    'City Name': [
        UniqueValidator()
    ],
    'Average Rainfall': [
        FloatValidator()
    ]
}
</code></pre>
<p><a href="https://blog.codinghorror.com/regular-expressions-now-you-have-two-problems/" rel="nofollow noreferrer">Regular Expressions: Now You Have Two Problems</a></p>
<hr/>
<p>I would treat the file as a CSV file which would allow us to use a <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code> module</a> to read it and also use a CSV schema validation package like <a href="https://github.com/di/vladiate" rel="nofollow noreferrer"><code>vladiate</code></a>. You don't have to use a third-party for this problem, but it provides a nice separation of concerns and allows for a nice validation logic definition.</p>
<p>For example, if you would have a <code>cities.csv</code> file with the following content (note the <code>invalid_value</code> in the "Average Rainfall" column):</p>
<pre><code>City Name,Average Rainfall
towna,2.43
townb,1.01
townc,invalid_value
</code></pre>
<p>And, execute the following code (note how we define a unique "City Name" value requirement and a float value validator for the "Average Rainfall"):</p>
<pre><code>import csv

from vladiate import Vlad
from vladiate.validators import UniqueValidator, FloatValidator
from vladiate.inputs import LocalFile


class CityValidator(Vlad):
    validators = {
        'City Name': [
            UniqueValidator()
        ],
        'Average Rainfall': [
            FloatValidator()
        ]
    }


def read_file(file_name):
    CityValidator(source=LocalFile(file_name)).validate()

    with open(file_name) as weather_file:
        reader = csv.reader(weather_file)
        for city_name, average_rainfall in reader:
            print(city_name, average_rainfall)


read_file("cities.csv")
</code></pre>
<p>You would see printed:</p>
<pre><code>City Name Average Rainfall
towna 2.43
townb 1.01
townc invalid_value

Validating CityValidator(source=LocalFile('cities.csv'))
Failed :(
  FloatValidator failed 1 time(s) (33.3%) on field: 'Average Rainfall'
    Invalid fields: ['invalid_value']
</code></pre>
</div>
<span class="comment-copy">Thanks, any chance you can give a quick explanation of what the pattern = re.compile line means?</span>
<span class="comment-copy">@Mick, I added an explanation</span>
<span class="comment-copy">Sorry, I probably should have added, this is part of a test so it does have a requirement that it is read from a text file.</span>
<span class="comment-copy">@Mick not a problem, you can still use the idea. For instance, <code>from vladiate.inputs import String</code> would allow you to validate a string and not a file..</span>
