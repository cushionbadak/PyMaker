<div class="post-text" itemprop="text">
<p>I'm starting to learn type hints in Python to ease the future porting of code from Python to C. I am wondering what the difference is, if any, between using types directly in type hints vs. using the classes defined in the <code>typing</code> module.</p>
<p>For example, the difference between</p>
<pre><code>def somefn(a: list[int]) -&gt; tuple[str, int]:
    ...
</code></pre>
<p>and</p>
<pre><code>from typing import List, Tuple

def somefn(a: List[int]) -&gt; Tuple[str, int]:
    ...
</code></pre>
<p>It seems like some classes like <code>Union</code>, <code>Any</code>, <code>Callable</code>, and <code>Iterable</code> would be useful, but the utility of classes for data types that already exist as keywords in python is unclear to me.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's useful for writing annotations that can be legally evaluated; <code>list[int]</code> will explode if you try to actually run it, while <code>typing.List[int]</code> returns a new generic type that knows the type of both container and contents. This is particularly important in the case of <a href="https://docs.python.org/3/library/typing.html#type-aliases" rel="nofollow noreferrer">type aliases</a>, where a specialized version of a generic is defined at the top level, then reused as annotation further on:</p>
<pre><code>Vector = List[float]
def scale(scalar: float, vector: Vector) -&gt; Vector:
     ...
</code></pre>
<p>is legal, while:</p>
<pre><code>Vector = list[float]
def scale(scalar: float, vector: Vector) -&gt; Vector:
     ...
</code></pre>
<p>blows up in your face. You'll note that non-container/generic types typically don't have a <code>typing</code> type (exceptions like <code>Text</code> are for porting concerns), because type aliases would only use them as "leaf" type, not root or branch types.</p>
</div>
