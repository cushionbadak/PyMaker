<div class="post-text" itemprop="text">
<p>
Hi, I want to merge two lists into one dictionary. Suppose I have two lists such as below</p>
<p>list_one = ['a', 'a', 'c', 'd']</p>
<p>list_two = [1,2,3,4]</p>
<p>and I want my dictionary to be like this</p>
<pre><code>{'a': 1, 'a': 2, 'c': 3, 'd': 4}
</code></pre>
<p>As of right now, I have this following code</p>
<pre><code>print dict(zip(['a', 'a', 'c', 'd'], [1,2,3,4]))
</code></pre>
<p>But the output from above code is this</p>
<pre><code>{'a': 2, 'c': 3, 'd': 4}
</code></pre>
<p>
How can I make it to this output?</p>
<pre><code>{'a': 1, 'a': 2, 'c': 3, 'd': 4}
</code></pre>
<p>
Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>A defining characteristic of <code>dict</code>s is that each key is unique. Thus, you can't have two <code>'a'</code> keys. Otherwise, what would <code>my_dict['a']</code> return?</p>
</div>
<div class="post-text" itemprop="text">
<p>Dictionaries must have unique keys, so you would have to change your requirement. How about a list of tuples as a workaround?</p>
<pre><code>l = list(zip(['a', 'a', 'c', 'd'],[1,2,3,4]))
print(l)
</code></pre>
<p>With the resulting being:</p>
<pre><code>[('a', 1), ('a', 2), ('c', 3), ('d', 4)]
</code></pre>
<p>You can easily iterate over and unpack like so:</p>
<pre><code>for k, v in l:
    print("%s: %s" % (k, v))
</code></pre>
<p>which produces:</p>
<pre><code>a: 1
a: 2
c: 3
d: 4
</code></pre>
<p>If you want it hashable, you can create a tuple of tuples like so:</p>
<pre><code>l = tuple(zip(['a', 'a', 'c', 'd'],[1,2,3,4]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since keys in dictionaries are unique, getting <code>{'a': 1, 'a': 2, 'c': 3, 'd': 4}</code> is impossible here for regular python dictionaries, since the key <code>'a'</code> can only occur once. You can however have a key mapped to multiple values stored in a list, such as <code>{'a': [1, 2], 'c': [3], 'd': [4]}</code>. </p>
<p>One option is to create a <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> to do this easily for you:</p>
<pre><code>from collections import defaultdict

list_one = ['a', 'a', 'c', 'd']

list_two = [1, 2, 3, 4]

d = defaultdict(list)
for key, value in zip(list_one, list_two):
    d[key].append(value)

print(dict(d))
</code></pre>
<p>Which outputs:</p>
<pre><code>{'a': [1, 2], 'c': [3], 'd': [4]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">documentation for dictionaries</a>:</p>
<blockquote>
<p>It is best to think of a dictionary as an unordered set of key: value pairs, <strong>with the requirement that the keys are unique (within one dictionary)</strong>. A pair of braces creates an empty dictionary: {}. Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Dictionary has unique keys. If you need the value of 'a' separately store the zipped data in a list or you can use list in values part of the dict and store the values as:
{'a': [1,2],'c': [3], 'd': [4]}</p>
</div>
<div class="post-text" itemprop="text">
<p>As other answers have pointed out, dictionaries have unique keys, however, it is possible to create a structure to mimic the behavior you are looking for:</p>
<pre><code>class NewDict:
   def __init__(self, *values):
       self.values = list(zip(*values))
   def __getitem__(self, key):
        return [b for a, b in sorted(self.values, key=lambda x:x[0]) if a == key]
   def __repr__(self):
       return "{}({})".format(self.__class__.__name__, "{"+', '.join("{}:{}".format(*i) for i in sorted(self.values, key=lambda x:x[0]))+"}")

list_one = ['a', 'a', 'c', 'd']
list_two = [1,2,3,4]
d = NewDict(list_one, list_two)
print(d['a'])
print(d)
</code></pre>
<p>Output:</p>
<pre><code>[1, 2]
NewDict({a:1, a:2, c:3, d:4})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have two options :</p>
<p>either you use tuple :</p>
<pre><code>list_one = ['a', 'a', 'c', 'd']

list_two = [1,2,3,4]



print(list(map(lambda x,y:(x,y),list_one,list_two)))
</code></pre>
<p>output:</p>
<pre><code>[('a', 1), ('a', 2), ('c', 3), ('d', 4)]
</code></pre>
<p>Second option is use this pattern:</p>
<pre><code>dict_1={}

for key,value in zip(list_one,list_two):
    if key not in dict_1:
        dict_1[key]=[value]
    else:
        dict_1[key].append(value)

print(dict_1)
</code></pre>
<p>output:</p>
<pre><code>{'a': [1, 2], 'd': [4], 'c': [3]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The keys in dictionary should be unique.</p>
<p>According to python documentation:</p>
<blockquote>
<p>It is best to think of a dictionary as an unordered set of key: value pairs, with the requirement that the keys are unique (within one dictionary).</p>
</blockquote>
<p><a href="https://docs.python.org/2/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">link</a>
to the documentation</p>
</div>
<span class="comment-copy">This is simply impossible.</span>
<span class="comment-copy">@Julien Maybe not in Python with its dictionaries, but dictionaries with duplicate entries for the same key are possible. Balanced trees like Red-Black can handle it and provide range queries, like find the lowest or highest duplicate key, etc.</span>
<span class="comment-copy">@Kaz, maybe but here OP is talking about python dict...</span>
<span class="comment-copy">@Julien I see, so is there any way in python that I can do a mapping function to get my desired ouput like above?</span>
<span class="comment-copy">This simply is impossible because your question makes no sense: as said by @Sebastian what is the mapping of <code>'a'</code>??? <code>1</code> or <code>2</code>? or should it be <code>[1,2]</code>? you need to clarify...</span>
<span class="comment-copy">The question "what would <code>my_dict['a']</code> return" actually has some reasonable answers. A requirement can be given in this area, for a dictionary that is intended to support multiple entries. C++ has a <code>std::multiset</code> dictionary type which supports a <code>find</code> function and <code>[]</code> indexing. Basically these return one of the duplicate keys; it is not specified which. There is a reliable way to iterate over the whole range of duplicate keys. I.e. a rhetorical question suggesting that a requirement is not reasonable isn't really the answer; it's just not the way a <code>dict</code> is in Python, that's all.</span>
<span class="comment-copy">Ah I see, so then this would be impossible to do right?</span>
<span class="comment-copy">@IqbalPratama  Impossible <i>directly</i>. However, the Python <code>dict</code> certainly can be used to write code which associates multiple values with the same key. Just associate keys with lists of values rather than values. Concretely speaking, <code>{'a': [1, 2], 'c': [3], 'd': [4]}</code>.</span>
<span class="comment-copy">@IqbalPratama depends on what you would want <code>my_dict['a']</code> to return.</span>
<span class="comment-copy">@Kaz alright cheers man!</span>
<span class="comment-copy">it's getting an error -&gt; TypeError: unhashable type: 'list'</span>
<span class="comment-copy">I updated my answer to show how to create a tuple of tuples.</span>
<span class="comment-copy">Wow. +1 for this awesome creativity.</span>
