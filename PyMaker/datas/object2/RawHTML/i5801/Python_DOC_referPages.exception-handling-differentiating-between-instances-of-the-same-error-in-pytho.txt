<div class="post-text" itemprop="text">
<p>What is the recommended way of separately handling exceptions of <em>the same type</em> based on differences in what caused the exception?</p>
<p>Let's say one desire to handle the following two instances of <code>AttributeError</code> differently:</p>
<ul>
<li><code>'str' object has no attribute 'append'</code> </li>
<li><code>'float' object has no attribute 'append'</code></li>
</ul>
<p>At the same time, we don't want to handle other attribute errors.</p>
<p>Are there any generalizable answers that work for all exception types? Can I interrogate the exception object for details using some method or function on the exception object?</p>
<pre><code>Try:
    blah
Except AttributeError as exc:
    if exc.baz('foo') is bar:
         handle 'str' object has no attribute 'append'
    elif plugh(exc):
         handle 'float' object has no attribute 'append'
    else:
         raise exc
</code></pre>
<p>I assume that the obvious answer is to refactor. My question specifically regards the cases where that would be inefficient or simply not possible (if there are any such cases at all). </p>
</div>
<div class="post-text" itemprop="text">
<p>You can see what methods and attributes an object has by using <a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow noreferrer"><code>dir</code></a>.</p>
<p>In Python 3.6, from:</p>
<pre><code>a = 'hello'
try:
    a.append(2)
except AttributeError as e:
    print(dir(e))
</code></pre>
<p>You get:</p>
<pre><code>['__cause__', '__class__', '__context__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__suppress_context__', '__traceback__', 'args', 'with_traceback']
</code></pre>
<p>That narrows down the things we can test since we don't want a dunder, leaving only <code>args</code> and <code>with_traceback</code>. It seems then that the best you could get is to use <code>args</code> which returns the string in a tuple:</p>
<pre><code>a = 'hello'
try:
    a.append(2)
except AttributeError as e:
    if 'str' in e.args[0]:
        print('Need to handle string')
    elif 'float' in e.args[0]:
        print('Need to handle float')
</code></pre>
</div>
<span class="comment-copy">That's what I feared. I tried to play around with the available attributes earlier. I know it is discouraged to use the string from <code>.args</code> since it is version dependent and may change in the future. One, perhaps, naive question @roganjosh: why can't you manually call the dunder methods? Also, I will accept your answer soon, but I want to wait just a little longer in case someone comes up with something else.</span>
<span class="comment-copy">@Lucubrator the dunder methods are really provided to override if you wish to, if you subclass the exception. I started exploring this myself but then realised that I was trying to make a self-handling exception by packaging the <code>if</code>/<code>elif</code> inside a custom exception, and that seems nonsensical (not to mention that I couldn't find a way to access the <code>args</code> string). Try <code>print(e.__cause__)</code>. No worries about waiting, I found the question interesting so I used it for my learning too :)</span>
<span class="comment-copy">@Lucubrator and you can call dunder methods manually if you wish. I meant <code>print(e.__cause__())</code> in my last comment but I can't edit it now. In REPL, you could do <code>a = 'hello'</code> and then <code>a.__str__()</code>, for example, which is like calling <code>print(a)</code>.</span>
