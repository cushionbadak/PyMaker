<div class="post-text" itemprop="text">
<p>What is the recommended structure to write validate functions with many conditions? See these two examples. The first looks ugly, the second isn't very common, perhaps because <code>assert</code> is generally used to rule out unexpected behaviour. Are there better alternatives?</p>
<pre><code>def validate(val):
  if cond1(val):
    return False
  if cond2(val):
    return False
  if cond3(val)
    return False
  return True
</code></pre>
<p>Or</p>
<pre><code>def validate(val):
  try:
    assert cond1(val)
    assert cond2(val)
    assert cond3(val)
    return True
  except AssertionError:
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A compact way to write that function is to use <code>any</code> and a generator expression:</p>
<pre><code>def validate(val):
    conditions = (cond1, cond2, cond3)
    return not any(cond(val) for cond in conditions)
</code></pre>
<p>The <code>any</code> and <code>all</code> functions short-circuit, so they'll stop testing as soon as they have a definite result, i.e., <code>any</code> stops as soon as it hits a True-ish value, <code>all</code> stops as soon as it hits a False-ish value, so this form of testing is quite efficient.</p>
<p>I should also mention that it's <em>much</em> more efficient to pass a generator expression like this to <code>all</code> / <code>any</code> than a list comprehension. Because <code>all</code> / <code>any</code> stop testing as soon as they get a valid result, if you feed them from a generator then the generator will stop too, thus in the above code if <code>cond(val)</code> evaluates to a True-ish value no further conditions will be tested. But if you pass <code>all</code> / <code>any</code>  a list comprehension, eg <code>any([cond(val) for cond in conditions])</code> the whole list has to be be built before <code>all</code> / <code>any</code> can even start testing.</p>
<hr/>
<p>You haven't shown us the internal structure of your <code>cond</code> functions, but you did mention <code>assert</code> in your question, so I feel that the following remarks are in order here.</p>
<p>As I mentioned in the comments, <code>assert</code> should not be used to validate data, it's used to validate program logic. (Also, assertion-handling can be disabled via an -O command line option). The correct Exception to use for data with invalid values is <code>ValueError</code>, and for objects that are the wrong type, use <code>TypeError</code>. But bear in mind that exceptions are designed to handle situations that are exceptional. </p>
<p>If you expect a lot of malformed data then it's generally more efficient to use <code>if</code> based logic than exceptions. Python exception-handling is quite fast if the exception isn't actually raised, in fact it's faster than the equivalent <code>if</code> based code. However, if the exception is raised say more than 5-10% of the time, then the <code>try...except</code> based code will be noticeably slower than the <code>if</code> based equivalent.</p>
<p>Of course, sometimes using exceptions is the only sensible option, even though the situation isn't all that exceptional. A classic example is when you're converting a collection of numeric strings to actual numeric objects, so that strings that represent integers get converted to integer objects, other numeric strings get converted to floats, and other strings get left as strings. The standard way to do this in Python involves using exceptions. <a href="https://stackoverflow.com/a/5609191/4014959">For example</a>:</p>
<pre><code>def convert(s):
    ''' Convert s to int or float, if possible '''
    try:
        return int(s)
    except ValueError:
        try:
            return float(s)
        except ValueError:
            return s

data = ['42', 'spam', '2.99792458E8']
out = [convert(u) for u in data]
print(out)
print([type(u) for u in out])
</code></pre>
<h3>output</h3>
<pre><code>[42, 'spam', 299792458.0]
[&lt;class 'int'&gt;, &lt;class 'str'&gt;, &lt;class 'float'&gt;]
</code></pre>
<p>Using <a href="https://docs.python.org/3/glossary.html#term-lbyl" rel="noreferrer">"Look Before You Leap"</a> logic here is <em>possible</em> here, but it makes the code more complicated because you need to deal with possible minus signs and scientific notation.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def valid(value):
    return (is_this(value)
            and that(value)
            and other(value))
</code></pre>
<p><code>and</code> operator exhibits "short-circuit" behavior in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>The first way is much better. It can be prettified a little bit using <code>any()</code>:<br/></p>
<pre><code>def validate_conditions(value):
    return not any((condition(value) for condition in conditions))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Depending on your intent I find the cleanest way is to return the result of <code>and</code> or ''or'' checks on each of your conditions.</p>
<pre><code>def validate(val):
    return (cond1 and cond2 and cond3)
</code></pre>
<p>Or, to reverse this (as in your example):</p>
<pre><code>def validate(val):
    return not (cond1 and cond2 and cond3)
</code></pre>
</div>
<span class="comment-copy">You should <b>not</b> use <code>assert</code> to validate data! It's used to validate the logic of your program: you use it to test for conditions which should <i>never</i> happen if your program logic is correct. If a program raises <code>AssertionError</code> that means your code is wrong &amp; it needs debugging.</span>
<span class="comment-copy">@PM2Ring Also, if code is optimised <a href="https://stackoverflow.com/questions/1273211/disable-assertions-in-python">assert statements are removed</a>.</span>
<span class="comment-copy">@PeterWood Indeed! I actually added that info to my answer before I saw your comment. ;)</span>
<span class="comment-copy">If you are writing code that will be maintained by others I would use the first as it is eminently readable. Poetry in code is intellectually satisfying and shows a sharp mind but may come back to haunt.</span>
<span class="comment-copy">@copper.hat "Everyone knows that debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it?" â€” Brian Kernighan, <i>The Elements of Programming Style</i>, 2nd edition, chapter 2.</span>
<span class="comment-copy">Of course, these are not fully equivalent, because you don't short-circuit. If <code>cond1</code> is <code>not xs</code> and <code>cond2</code> is <code>xs[0] == 'bad'</code>, then passing <code>[]</code> for <code>xs</code> will result in an error.</span>
<span class="comment-copy"><code>any</code> might short-circuit, but the conditions are already evaluated when constructing the tuple, so it doesn't really short-circuit the evaluation like usual logic</span>
<span class="comment-copy"><code>cond1</code> , <code>cond2</code>, and <code>cond3</code> are functions. This code is equivalent to the original in terms of which functions will be called.</span>
<span class="comment-copy">@wchargin Look closer. First of all, <code>any</code> and <code>all</code> <i>do</i> both short-circuit. Second, the tuple contains the <i>functions</i>, not the results of calling those functions. Additionally, the argument passed to <code>any</code> is a generator. The functions are not invoked until they is reached by iterating through the generator, and the generator is advanced internally by the <code>any</code> and <code>all</code> functions (which stop advancing as soon as they return).</span>
<span class="comment-copy">@jpmc26 (cont) OTOH, there's <a href="https://stackoverflow.com/a/35451912/4014959">this <code>timeit</code> test</a> which compares the speed of <code>in</code> vs <code>get</code> for updating a dict used as a cache. <code>get</code> works by catching the <code>KeyError</code> exception, but it's doing it "under the hood", so it can work a little more efficiently than pure Python code.</span>
<span class="comment-copy">This will return <code>True</code> when <code>all</code> conditions evaluate as <code>True</code>. But it should return <code>False</code> if <code>any</code> conditions evaluate <code>True</code>.</span>
<span class="comment-copy">@PeterWood yes, this is the intent. the conditions are reversed (look at the names). To use OP's conditions and names: <code>return not (cond1(val) or cond2(val) or cond3(val))</code> I find my variant more readable.</span>
<span class="comment-copy">Okay, that wasn't really clear from the answer.</span>
<span class="comment-copy">This will return <code>True</code> when <code>all</code> conditions evaluate as <code>True</code>. But it should return <code>False</code> if <code>any</code> conditions evaluate <code>True</code>.</span>
<span class="comment-copy">What Peter said. Also, it's <i>much</i> more efficient to pass a generator expression to <code>all</code> / <code>any</code> than a list comprehension. <code>all</code> / <code>any</code> stop testing as soon as they get a valid result, so if you feed them from a generator then the generator will stop too. But if you pass them a list comp, the whole list has to be be built before  <code>all</code> / <code>any</code> can even start testing.</span>
<span class="comment-copy">Thank you for clarifying</span>
<span class="comment-copy">Also, generator expressions are one of the few things where being less implicit is encouraged in Python. <code>((...))</code> can be replaced by <code>(...)</code>, or in other words you don't need the braces if a generator expression is the only argument.</span>
<span class="comment-copy">But this doesn't evaluate the conditions</span>
<span class="comment-copy">you might mean: <code>not (cond1(val) or cond2(val) or cond3(val))</code></span>
<span class="comment-copy">@jfs That would work for the question, yes. I was trying to address the design pattern part rather than the actual implementation. I've edited my answer to include the use of ''or''.</span>
<span class="comment-copy">Even after the edit, both solutions proposed above are <i>not</i> equivalent to the OP code.</span>
