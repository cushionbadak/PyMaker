<div class="post-text" itemprop="text">
<p>I am trying to create a simple callback that can be registered to an object from another thread. The initial object that calls the callback is running on its own thread in this case.</p>
<p>This is best illustrated through the following example:</p>
<pre class="lang-python prettyprint-override"><code>from pprint import pprint
import sys
import weakref
import threading
import time

class DummyController(object):

  def __init__(self):
    self.name = "fortytwo"

  def callback(self):
    print("I am number : " + self.name)

class SomeThread(threading.Thread):

  def __init__(self, listener):
    threading.Thread.__init__(self)
    self.listener = listener

  def run(self):
    time.sleep(1)
    dummy = DummyController()
    self.listener.register_callback(dummy.callback)
    time.sleep(5)
    del dummy



class Listener(threading.Thread):

  def __init__(self):
    threading.Thread.__init__(self)
    self.runner = weakref.WeakMethod(self.default_callback)
    self.counter = 20

  def default_callback(self):
    print("Not implemented")

  def register_callback(self, function):
    self.runner = weakref.WeakMethod(function)

  def run(self):
    while self.counter:
      try:
        self.runner()()
      except Exception as e:
        pprint(e)

      self.counter -= 1
      time.sleep(1)



listen = Listener()
some = SomeThread(listen)

listen.start()
some.start()
</code></pre>
<p>Now the above code works just fine. But I am concerned about thread-safety here. Reading through <a href="https://docs.python.org/3/library/weakref.html" rel="nofollow noreferrer">weakref docs</a>, it isn't very clear if weakref is really thread safe or not, except for the line:</p>
<blockquote>
<p>Changed in version 3.2: Added support for thread.lock, threading.Lock, and code objects.</p>
</blockquote>
<p>I might be simply not reading that right. Do I need to add locking, or is everything actually fine and pretty thread safe?</p>
<p>Many thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>OK, I understand. This is not a problem about thread safe, but just a problem about <code>weak reference</code>.</p>
<p>There is an executable example:</p>
<pre><code>from pprint import pprint
import sys
import weakref
import threading
import time
import gc

class SomeThread(threading.Thread):

    def __init__(self, listener):
        threading.Thread.__init__(self)
        self.listener = listener

    def run(self):
        class test:    # simplify this example.
            def callback(self, count):
                print(count)
        time.sleep(1)
        dummy = test()
        self.listener.register_callback(dummy.callback)
        time.sleep(5)
        del dummy
        gc.collect()  # add this line to do garbage collecting.


class Listener(threading.Thread):

    def __init__(self):
        threading.Thread.__init__(self)
        self.runner = weakref.WeakMethod(self.default_callback)
        self.counter = 20

    def default_callback(self):
        print("Not implemented")

    def register_callback(self, function):
        self.runner = weakref.WeakMethod(function)

    def run(self):
        while self.counter:
            try:
                self.runner()(self.counter)
            except Exception as e:
                pprint(e)

            self.counter -= 1
            time.sleep(1)


listen = Listener()
some = SomeThread(listen)

listen.start()
some.start()
</code></pre>
<p>output:</p>
<pre><code>TypeError('default_callback() takes 1 positional argument but 2 were given',)
TypeError('default_callback() takes 1 positional argument but 2 were given',)
18
17
16
15
TypeError("'NoneType' object is not callable",)
TypeError("'NoneType' object is not callable",)
TypeError("'NoneType' object is not callable",)
</code></pre>
<p>If you explicitly call <code>gc.collect()</code>, <code>callback</code> loses its last strong reference and then it becomes <code>None</code>. As you will never know when will <code>gc</code> collect garbage, there is a potential issue.</p>
<p>It is no matter you use thread or not, just a normal behave of <code>weak reference</code>.</p>
<p>BTW, be careful that exiting <code>SomeThread.run</code> will also implicitly <code>del dummy</code>, you can test it by removing <code>del dummy</code> and moving <code>gc.collect()</code> into <code>try</code> block. </p>
</div>
<span class="comment-copy">The doc means in version 3.2 you can make a weak reference to thread.lock, threading.Lock and code objects but doesn't mean there is an internal lock. And I don't understand which part could be unsafe? Could you give an example to explain?</span>
<span class="comment-copy">My worries come from the fact that the <code>Listener</code> runs the callback of the object function, but another thread (<code>SomeThread</code>) then deletes the object. Since it's using the <code>weakref.WeakMethod</code> the object should be immediatelly removed from memory without the involvement of a garbage collector so I am wondering if when deleting the callback function object would cause a racing condition if both the object is being deleted and the function being called at the same time. Is that a little clearer?</span>
<span class="comment-copy">Yeah, it is one of the reasons why I am using the wakref, since I "need" the callback lose its last strong reference. Hence the exception capturing, however I was worrying about the fact that such a thing where the strong reference is destroyed in another thread would create a race condition.  Many thanks for the answer</span>
