<div class="post-text" itemprop="text">
<p>I want to open a file, decode the format of data (from base64 to ASCII), rewrite or save the decoded string, either back to the same file, or new one.</p>
<p>I have it opening, reading, decoding (and printing as a test) the decoded base64 string into readable format (ASCII I believe)</p>
<p>My goal is to now save this output to: either a "newfile.txt" document or back to the original "test.mcz" file ready for the next steps of my mission...</p>
<p>I know there are great online base64 decoders and they do work well for what I am doing - I use them often, but my goal is to write my own program as a learning exercise more than anything (also when my internet plays up I need an offline program)</p>
<p>Here's where I am so far (the original file is .mcz format it is a game save)</p>
<pre><code># PYTHON 3
import base64

f = open('test.mcz', 'r')
f_read = f.read()
# print(f_read) # was just as a test

new_f_read = base64.b64decode(f_read)
print (new_f_read)
</code></pre>
<p>This prints a butt-load of readable code that is what I need, but I don't want to have to just copy and paste this output from the Python shell into another editor, I want to save it to a file...for convenience. </p>
<p>Either back into the same test.mcz (I will be re-encoding to base64 again later on anyway) or to a new file - thus leaving my original as it was. </p>
<p>problem arises when I want to save/write this decoded output that is stored within the new_f_read variable...it's just been a headache, before I started I could visualise how it needed to be written, I got tripped up when I had to switch it all over to Python3 for some reason (Don't ask...) and I have tried so many variations from online examples - I wouldn't know where to start explaining what I've tried so far. I can't open the original file as both "r" AND "w" together so once Ive opened and decoded I cant reopen the original file as "w" because it just wipes the contents (which are still encoded anyway) - </p>
<p>I think I need to write functions to handle: 
1. Open, read, save string to a variable
2. Manipulate string - decode
3. Write the new string to new or existing file</p>
<p>Sounds easy I know, but I am stuck...so here I am. If anyone shows examples, please take the time to explain what is going on, it seems pointless to me having code I don't understand. Apologies if this seems like a simple thing, help would be appreciated..Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you can absolutely open a file for both reading and writing without truncating the contents.  That's what the <code>r+</code> mode is for (see <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#open</a>).  If you do this, the model is (a) open the file, (b) read it, (c) seek back to the beginning with e.g. <code>f.seek(0)</code>, (d) write it.</p>
<p>Secondly, you can simply open the file, read it, then close the file, and then reopen it, write it, and close it again, like this:</p>
<pre><code># open the file for reading, read the data, then close the file
with open('test.mcz', 'rb') as f:
    f_read = f.read()

new_f_read = base64.b64decode(f_read)

# open the file for writing, write the data, then close the file
with open('test.mcz', 'wb') as f:
    f.write(new_f_read)
</code></pre>
<p>This is probably the easiest solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest thing is to open first a read file handle, close it then open a write handle. Read/Write handles are complicated because they have to have a pointer to where in the file you are and it add overhead that you don't need to use. You could do it if you wanted, but its a waste of time here. </p>
<p>Using the with operator to open files is recommended since the file will automatically close when you leave the with block. </p>
<pre><code>import base64

with open('test.mcz', 'r') as f:
    encode = base64.b64decode(f.read())

with open('test.mcz', 'wb') as f:
    f.write(encode)
</code></pre>
<p>This is the same as </p>
<p>import base64</p>
<pre><code>f = open('test.mcz', 'r'):
encode = base64.b64decode(f.read()) 
f.close()
f = open('test.mcz', 'wb'):
f.write(encode)
f.close()
</code></pre>
</div>
<span class="comment-copy">when a file is opened for writing it is assumed you mean to override the contents of an existing file, hence the contents being erased.  Also, keep in mind that unless you explicitly <code>.close()</code> the file (or use a <code>with</code> statement) it isn't guaranteed to write data to the actual disk, so doing <code>with open(FILE, "w") as f:</code> when you want to write data is the first thing you want to try.</span>
<span class="comment-copy">Thank you - makes sense</span>
<span class="comment-copy">Thank you - I will have a play around with this now - didn't think to use 'with open'</span>
<span class="comment-copy">This example returns this for me:                                                           Traceback (most recent call last):   File "/home/raser/Desktop/MY PYTHON PROJECTS/Base64_Decoders/py3_decode_base64.py", line 22, in &lt;module&gt;     f.write(new_f_read) TypeError: must be str, not bytes</span>
<span class="comment-copy">Then add a <code>b</code> onto your modes (<code>open('test.mcz', 'wb')</code>). This opens the file in binary mode, which expects byte rather than strings.  I've updated the example.</span>
<span class="comment-copy">That did it - thank you so much</span>
