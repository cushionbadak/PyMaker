<div class="post-text" itemprop="text">
<p>See the following ipython session:</p>
<pre><code>$ ipython --no-banner

In [1]: class foo(object):
   ...:     def __new__(self, *args, **kwargs):
   ...:         print 'in superclass __new__'
   ...:         return self
   ...: 
   ...: class bar(foo):
   ...:     def __init__(self, *args, **kwargs):
   ...:         print 'in subclass __init__'
   ...:         self.val = 42
   ...:         

In [2]: b = bar()
in superclass __new__

In [3]: b.val
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-4-c55d38c9d4d9&gt; in &lt;module&gt;()
----&gt; 1 b.val

AttributeError: type object 'bar' has no attribute 'val'
</code></pre>
<p>What is going on here? Why does defining <code>__new__</code> in <code>foo</code> prevent the <code>__init__</code> from running in <code>bar</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are returning an invalid value from <code>__new__</code>.  Quoting <a href="https://docs.python.org/2/reference/datamodel.html#basic-customization" rel="nofollow noreferrer">the documentation</a>:</p>
<blockquote>
<p>If <code>__new__()</code> returns an instance of <em>cls</em>, then the new instance’s <code>__init__()</code> method will be invoked ... If <code>__new__()</code> does not return an instance of <em>cls</em>, then the new instance’s <code>__init__()</code> method will not be invoked.</p>
</blockquote>
<p>Note that the first argument to <code>__new__</code> is a class, not an object. <code>__new__</code>'s job is to allocate the object, often by calling <code>super().__new__</code>.</p>
<p>Try this:</p>
<pre><code>class foo(object):
    def __new__(cls, *args, **kwargs):
        print 'in superclass __new__'
        return super(foo, cls).__new__(cls, *args, **kwargs)

class bar(foo):
    def __init__(self, *args, **kwargs):
        print 'in subclass __init__'
        self.val = 42

b = bar()
print b
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">datamodel</a> documentation:</p>
<blockquote>
<p>If <code>__new__()</code> does not return an instance of <code>cls</code>, then the new instance’s <code>__init__()</code> method will not be invoked.</p>
</blockquote>
<p>So, try again like this:</p>
<pre><code>class foo(object):
    def __new__(cls, *args, **kwargs):
        print 'in superclass __new__'
        return super(foo, cls).__new__(cls, *args, **kwargs)

class bar(foo):
    def __init__(self, *args, **kwargs):
        print 'in subclass __init__'
        self.val = 42
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>__new__</code> function signature implies you don't quite understand what is going on. The first argument to <code>__new__</code> will be the <em>class</em>, calling it <code>self</code> which is conventionally used for the <em>instance</em> should be a warning: <code>__new__</code> is a constructor, the instance <em>doesn't exist yet</em>. So what happens is you are returning an object that isn't the same type as the class, (it <em>is</em> the class in fact, so it is of type <code>type</code>) thus, <code>__init__</code> is skipped! You want something like this:</p>
<pre><code>In [4]: class Foo(object):
   ...:     def __new__(cls, *args, **kwargs):
   ...:         print 'in superclass __new__'
   ...:         return super(Foo, cls).__new__(cls, *args, **kwargs)
   ...:
   ...: class Bar(Foo):
   ...:     def __init__(self, *args, **kwargs):
   ...:         print 'in subclass __init__'
   ...:         self.val = 42
   ...:

In [5]: b = Bar()
in superclass __new__
in subclass __init__
</code></pre>
</div>
<span class="comment-copy">maybe you gotta call <code>object.__new__</code></span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__new__</a> “If <code>__new__()</code> does not return an instance of <i>cls</i>, then the new instance’s <code>__init__()</code> method will not be invoked.”</span>
<span class="comment-copy">Just a conceptual misconception: <code>__new__</code> doesn't take a <code>self</code>, because <code>self</code> doesnt exist at this point. <code>self</code> is what's going to be returned by <code>__new__</code>, which will then be passed on to <code>__init__</code> for initialization</span>
<span class="comment-copy"><code>__new__</code> is special-cased to be a class method without having to decorate it as such. The first argument (conventionally) should be <code>cls</code>, because <code>foo.__new__</code> gets <code>foo</code> as its first argument, not an instance of <code>foo</code>.</span>
<span class="comment-copy">Oh, oops. Will accept when it lets me</span>
