<div class="post-text" itemprop="text">
<p>I have a vocabulary of phrases and I want to replace words of another file by these words. For example, I have the following vocabulary:</p>
<p>United States,
New York</p>
<p>and I want to replace the following file:</p>
<p>"I work for New York but I don't even live at the United States"</p>
<p>To this:</p>
<p>"I work for New_York but I don't even live at the United_States"</p>
<p>Currently I'm doing at this way:</p>
<pre><code>import os

def _check_files_and_write_phrases(docs, worker_num):
    print("worker ", worker_num," started!")
    for i, file in enumerate(docs):
        file_path = DOCS_FOLDER + file
        with open(file_path) as f:
            text = f.read()
            for phrase in phrases:
                text = text.replace(phrase, phrase.replace(' ','_'))
            new_doc = PHRASES_DOCS_FOLDER + file[:-4] + '_phrases.txt'
            with open(new_doc, 'w') as nf:
                nf.write(text)

    print("job done on worker ", worker_num)


docs = os.listdir(DOCS_FOLDER)

import threading

threads = []
for i in range(1, 11):
    print(i)
    start = int((len(docs)/10) * (i - 1))
    end = int((len(docs)/10) * (i))
    print(start,end)
    if i != 10:
        t = threading.Thread(target=_check_files_and_write_phrases, args=(docs[start:end], i, ))
    else:
        t = threading.Thread(target=_check_files_and_write_phrases, args=(docs[start:], i, ))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print("all workers finished!")
</code></pre>
<p>But it's way too slow! I thought that threads would do the job but I was wrong...</p>
<p>Is there another <strong>efficient</strong> way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>All of the phrases could be replaced using a single <code>re.sub()</code> call which could be pre-compiled to further speed things up a bit:</p>
<pre><code>import re

phrases = {"United States":"United_States", "New York":"New_York"}
re_replace = re.compile(r'\b({})\b'.format('|'.join(re.escape(phrase) for phrase in phrases.keys())))

def _check_files_and_write_phrases(docs, worker_num):
    print("worker {} started!".format(worker_num))

    for i, filename in enumerate(docs):
        file_path = DOCS_FOLDER + filename

        with open(file_path) as f:
            text = f.read()
            text = re_replace.sub(lambda x: phrases[x.group(1)], text)
            new_doc = PHRASES_DOCS_FOLDER + filename[:-4] + '_phrases.txt'

            with open(new_doc, 'w') as nf:
                nf.write(text)

    print("job done on worker ", worker_num)
</code></pre>
<p>This first creates a regular expression to search on as follows based on a dictionary of phrases:</p>
<pre><code>\b(United\ States|New\ York)\b
</code></pre>
<p>The <code>re.sub()</code> function then uses the <code>phrases</code> dictionary to look up the required phrase replacement. It takes two parameters, the replacement and the original text. The replacement can either be a fixed string, or in this case a function is used. The function takes a single argument being the matched object, and returns the replacement text. A <code>lambda</code> function is used to do this, it simply looks up the match object in <code>phrases</code> dictionary.</p>
<p>Instead of doing a dictionary lookup, it could just use a <code>replace()</code> here but the pre-calculated replacement text should be faster. The <code>\b</code> is added to only make replacements which are on word boundaries, so for example <code>MYNew York</code> would be skipped. Adding <code>flags=re.I</code> to the <code>re.compile()</code> could be used to make the search case insensitive if needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try to change the <code>for</code> loop to replace only phrases that exist in the text:</p>
<pre><code>for phrase in set(phrases).intersection(text.split()):
...
</code></pre>
<p>Try it with and without the threading.</p>
</div>
<span class="comment-copy">If you import re, it has specific abilities to search for phrases. Read up on the regular expressions operators here: <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">docs.python.org/3/library/re.html</a></span>
<span class="comment-copy">@DeathPox I don't think the problem is the str.replace() function but it's the way I'm using it. Still, I will test re.replace with a few files and compare the processing time. Thanks for the suggestion.</span>
<span class="comment-copy">Because of dreaded the <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">GIL</a>, your code doesn't execute in parallel (except for the loading files part). Use <a href="https://docs.python.org/2/library/multiprocessing.html" rel="nofollow noreferrer"><code>multiprocessing</code></a> instead, but only if the bottleneck is the processing (i.e. the input file or a list of phrases is huge). Also, in dependence of which is bigger, the file or the phrases list, it might be faster to read the file line by line and go over all phrases per line, than to load up the whole file in memory and replace the matched phrases in it.</span>
<span class="comment-copy">@zwer thanks, improved a lot the performance.</span>
<span class="comment-copy">could you please explain what 'phrases[x.group(1)]' does?</span>
<span class="comment-copy"><code>x.group(1)</code> - <code>x</code> is a match object, with <code>group(1)</code> being the text that was found. <code>phrases[]</code> is the dictionary of phrases, so in effect it looks up some text in the dictionary and gets back the text to replace with.</span>
<span class="comment-copy">I didn't find a great gain of performance on using your method, but I merged with the @zwer comment about using multiprocessing instead of threading and now it's processing much more faster. Thanks anyway.</span>
