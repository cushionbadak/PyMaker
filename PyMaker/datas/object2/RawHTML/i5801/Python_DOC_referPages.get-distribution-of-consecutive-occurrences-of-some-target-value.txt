<div class="post-text" itemprop="text">
<p>Lets say I am given the following list</p>
<p><code>x = ['A','A','B','A','A','A', 'C', 'C', 'A', 'A']</code></p>
<p>What would be the best and most efficient way to generate the following output</p>
<pre><code># key = number of consecutives
# val = number of occurrences
&gt;&gt;&gt; func(x, 'A')
{2:2, 3:1}

&gt;&gt;&gt; func(x, 'B')
{1:1}

&gt;&gt;&gt; func(x, 'C')
{2:1}
</code></pre>
<p>We may assume that the list is all strings. Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>The following will work, making use of <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>from itertools import groupby
from collections import Counter

def func(lst, elmnt):
    return Counter(len(list(g)) for k, g in groupby(lst) if k == elmnt)

&gt;&gt;&gt; func(x, 'A')
Counter({2: 1, 3: 1})
</code></pre>
<p>While this will probably not be bested for single calls, you would be better off building an intermediate data structure that collects counts for groups of all different elements in a single go-around so that subsequent calls for individual elements won't have to iterate the entire list again:</p>
<pre><code>from collections import defaultdict

def func(lst):
    c = Counter((k, len(list(g))) for k, g in groupby(lst))
    d = defaultdict(dict)
    for (k, length), count in c.items():
        d[k][length] = count
    return d.get

&gt;&gt;&gt; f = func(x)  # builds intermediate structure (O(N)), returns function to query it
&gt;&gt;&gt; f('A')  # these calls are now all O(1)
{2: 1, 3: 1}
&gt;&gt;&gt; f('B')
{1: 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should work:</p>
<pre><code>from collections import defaultdict
def f(x, t):
    n = 0
    result = defaultdict(int)
    for c in x:
        if c == t:
            n += 1
        else:
            result[n] += 1
            n = 0
    result[n] += 1
    del result[0]
    return result
</code></pre>
<p>whether it is the best is totally opinion based. IMO it is the best because I wrote it and, in my own opinion, I am the best.</p>
<p>On a more objective note: @schwobaseggl 's solution is more concise but a quick <code>%timeit</code> experiment tells me mine is 5x faster on your example and possibly a lot more on other examples... So 'best' really depends on what you value most. (even 'efficient' is rather vague: are you considering processing time, memory usage, .. ?)</p>
</div>
<span class="comment-copy">While I disagree with 'unclear' vote, you should provide your own attempt.</span>
<span class="comment-copy">Above all it is opinion based</span>
