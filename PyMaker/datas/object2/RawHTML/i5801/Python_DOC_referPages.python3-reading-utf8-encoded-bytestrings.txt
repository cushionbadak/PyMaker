<div class="post-text" itemprop="text">
<p>My program uses the output from "iwlist scan" to generate a report.
It works fine except when the network name (ESSID) contains non-Ascii characters.<br/>
IEEE802.11 state that ESSID may contain UTF8 characters. However these essid are reported by iwlist as an encoded bytestring. Example:<br/>
      ESSID:"f\xC3\xAAte"<br/>
\xC3\xAA is effectively the UTF-8 encoding of "ê"<br/>
I can't find a way to specify to 'open' that these bytestrings should be automatically converted into UTF-8 characters.<br/>
Question: what is the most pythonic way to solve my problem?</p>
<p>PS: as a test case, I put the following line in a file (say xx):<br/>
<em>ESSID:"f\xC3\xAAte"</em><br/>
and I execute:<br/>
<em>open( 'xx','rb').read().decode('UTF-8')</em><br/>
and my result is:<br/>
<em>'ESSID:"f\xC3\xAAte"\n'</em> </p>
</div>
<div class="post-text" itemprop="text">
<p>This is actually a two-step process: convert the <code>\xNN</code> codes to the equivalent byte value, then convert those bytes from UTF-8 to Unicode characters. Python provides a <code>unicode_escape</code> codec to make the process simpler. Unfortunately you need an extra step - it won't convert the <code>\xNN</code> to bytes, it converts them to characters and you need to convert <em>those</em> back to the equivalent bytes.</p>
<p>So you end up with a 3-step conversion. Encoding to <code>latin1</code> is a hack to convert characters to bytes. It works because Unicode uses the Latin-1 encoding for its first 256 codepoints giving you a 1:1 mapping.</p>
<pre><code>with open(filename, 'rb') as f:
    essid_raw = f.read()
    essid = essid_raw.decode('unicode_escape').encode('latin1').decode('utf-8')


&gt;&gt;&gt; essid_raw = b'ESSID:"f\xC3\xAAte"'
&gt;&gt;&gt; essid = essid_raw.decode('unicode_escape').encode('latin1').decode('utf-8')
&gt;&gt;&gt; print(essid)
ESSID:"fête"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As far as I understood your problem:</p>
<p>Looks like your file doesn't have Unicode characters at all, but instead, it has an escaped string. So instead of one <code>ê</code> symbol you actually have 8 characters — <code>\xC3\xAA</code>. So instead of decoding from Unicode with <code>.decode("utf-8")</code> you should decode from unicode escape characters (<code>.decode('unicode_escape')</code>.</p>
<p>To try this I made a file with a string:</p>
<p><code>ESSID:"f\xC3\xAAte"</code></p>
<p>then this script prints the following:</p>
<pre><code>&gt;&gt;&gt; open( 'file','rb').read().decode('UTF-8')
ESSID:"f\xC3\xAAte"
</code></pre>
<p>And if you use unicode_escape instead, you will get</p>
<pre><code>&gt;&gt;&gt; open( 'file','rb').read().decode('unicode_escape')
ESSID:"fÃªte"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm answering to myself.<br/>
Cannot find a python solution so I developed mine.<br/>
Method is to remove '\x' and convert 2 hex characters to a byte. Repeat for each \x.</p>
<pre><code>def adapt( tb):
  # this function converts the weird UTF8 escaping used by 'iwlist scan'
  # iwlist outputs "f\xC3\xAAte" instead of "fête"
  # caution : input is not sanitized 
  i = 0
  while True:
    # suppress \x and replace the following 2 characters by their hex value 
    i = tb.find( b'\\\x', i)
    if i &lt; 0: break
    tb = tb[:i] + bytes( [int( tb[ i+2:i+4], 16)]) + tb[i+4:]
    i += 1     # skip the preceding sequence
  return tb
</code></pre>
<p>Usage:</p>
<pre><code>txt = adapt( open( 'xx','rb').read()).decode()
print( txt)
ESSID:"fête"  
</code></pre>
<p>It is an ugly hack but it works fine. I would gladly like a nicer solution.<br/>
Thanks for your answers.</p>
</div>
<span class="comment-copy">Is <code>b"f\xC3\xAAte".decode("utf-8")</code> what you want?</span>
<span class="comment-copy">@stepan: yes and no. Please look at the added test case.</span>
<span class="comment-copy">Your test case is not representative of your actual problem, unless the string returned has the 4-byte sequence <code>\xC3</code> in it.</span>
<span class="comment-copy">I'm not sure your test case is of any use. You have actual quotes and backslashes in there, which means you'll have to call <code>eval()</code> on it or something like that.</span>
<span class="comment-copy">If the quotes and backslashes are actually part of the data, then <code>eval()</code> is a simple, but risky solution, as you say. The <a href="https://docs.python.org/3/library/codecs.html#python-specific-encodings" rel="nofollow noreferrer"><i>unicode_escape</i> codec</a> helps you with the <code>\xNN</code> escapes (<code>"\xC3".decode('unicode_escape')</code>), but for the quotes you'll probably have to write a regex.</span>
<span class="comment-copy">thank you for your answer. You're right when you say that the file is not Unicode. I'm trying to decode the output of iwlist; when the network name contains UTF-8, iwlist generate escaped characters that are difficult to decode. What you propose do not generate the right answer (the right answer is fête, 4 characters long).</span>
<span class="comment-copy">@user3435121 try <code>essid.decode('unicode_escape').encode('latin1').decode('utf8')</code>.</span>
<span class="comment-copy">@MarkRansom: you're the king mark! That's the kind of statement I was searching for. It's a very convoluted statement but it works fine. If you repost as an answer, I will show my gratitude.</span>
<span class="comment-copy">disregard this solution. The one from markRansom and shadowRanger is better and work fine.</span>
