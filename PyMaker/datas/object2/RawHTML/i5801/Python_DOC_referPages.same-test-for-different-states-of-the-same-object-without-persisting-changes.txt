<div class="post-text" itemprop="text">
<p>I am trying to run the same exact test on a single <code>obj</code> which is a <code>models.Model</code> instance and has some relations with other models. I do not want to persist changes in that instance, so effectively I want the same effect of the <code>tearDown</code> method which rollbacks transactions.</p>
<p>To illustrate this:</p>
<pre><code>class MyTestCase(django.test.TestCase):

    def test():
        # main test that calls the same test using all 
        # different states of `obj` that need to be tested

        # different values of data that update the state of `obj`
        # with state I simply mean the values of `obj`'s attributes and relationships
        data = [state1, state2, state3]
        for state in data:
            obj = Obj.objects.get(pk=self.pk)  # gets that SINGLE object from the test db
            # applies the state data to `obj` to change its state
            obj.update(state)
            # performs the actual test on `obj` with this particular state
            self._test_obj(obj)

    def _test_obj(self, obj):
        self.assertEqual(len(obj.vals), 10)
        self.assertLess(obj.threshold, 99)
        # more assert statements...
</code></pre>
<p>This <em>design</em> has two problems:</p>
<ul>
<li><p>The changes on <code>obj</code> persist on the test database, so on the next iteration the data would be <em>tainted</em>. I would want to rollback those changes and get a <em>fresh</em> instance of <code>obj</code> as if the <code>test</code> method was just called and we are getting the data straight from the fixtures.</p></li>
<li><p>If an assert statement fails I will be able to see which one it it, but I won't be able to determine <strong>what</strong> case (state) failed because of the <code>for</code> loop. I can <code>try-except</code> the <code>_test_obj_</code> call in the <code>test</code> method but then I wouldn't be able to tell <strong>what</strong> assert failed.</p></li>
</ul>
<p>Does <code>django.test</code> provide any tool to run the same test for different states of the same model? If it doesn't, how can I do what I am trying to do while solving both points mentioned above?</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>Simply rollback after you're done with the object.</p></li>
<li><p>You can use the new <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.subTest" rel="nofollow noreferrer">subTest</a> in python 3.4+</p></li>
</ol>
<hr/>
<p>Here's how your code should look:</p>
<pre><code>class TestProductApp(TestCase):
    def setUp(self):
        self.product1 = ...

    def test_multistate(self):
        state1 = dict(name='p1')
        state2 = dict(name='p2')

        data = [state1, state2]

        for i, state in enumerate(data):
            with self.subTest(i=i):
                try:
                    with transaction.atomic():
                        product = Product.objects.get(id=self.product1.id)
                        product.name = state['name']
                        product.save()
                        self.assertEqual(len(product.name), 2)
                        raise DatabaseError #forces a rollback
                except DatabaseError:
                    pass
                print(Product.objects.get(id=self.product1.id)) #prints data created in setUp/fixture
</code></pre>
</div>
