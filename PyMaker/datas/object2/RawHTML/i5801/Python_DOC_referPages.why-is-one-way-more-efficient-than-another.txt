<div class="post-text" itemprop="text">
<p>I was trying out hackerrank, and I came across a problem which I tried to solve using python3.
The problem was
"A kidnapper wrote a ransom note but is worried it will be traced back to him. He found a magazine and wants to know if he can cut out whole words from it and use them to create an untraceable replica of his ransom note. The words in his note are case-sensitive and he must use whole words available in the magazine, meaning he cannot use substrings or concatenation to create the words he needs.</p>
<p>Given the words in the magazine and the words in the ransom note, print Yes if he can replicate his ransom note exactly using whole words from the magazine; otherwise, print No."</p>
<p>I tried using the following approach,</p>
<pre><code>def ransom_note(magazine, ransom):

# comparing based on the number of times word occurred in the list
for word in set(ransom):
    if ransom.count(word) &gt; magazine.count(word):
        return False
return True    
</code></pre>
<p>This did work, I got 18 out of 20 test cases right.
But the other two cases were timing out, so I had to get the best cost effective way of doing this.
I tried to store the words as a dictionary by using the word as the key and count of the word as the value. Still not getting those two cases, when i looked into the cases there was 30000 words for both the inputs and the output expected was "Yes".</p>
<p>I saw the discussion's page and found a piece of code that got me through.</p>
<pre><code>    from collections import Counter

def ransom_note(magazine, ransom):
    return not (Counter(ransom) - Counter(magazine))
</code></pre>
<p>Can someone explain why this was more efficient than my method?
Thanks in advance :)</p>
</div>
<div class="post-text" itemprop="text">
<p>As I understand it, in your second attempt at the problem, both <code>ransom</code> and <code>magazine</code> were dictionaries, so theoretically your code was as fast as it could be.</p>
<p>The Python <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter</a> collection is designed specifically to work with simple integer counts, and optimized to perform common operations very quickly. It turns out that seeing if there are enough things in one list to satisfy the requests from another list is a really common operation. So they spent time optimizing <code>Counter</code> do that operation very quickly.</p>
</div>
<span class="comment-copy">Why do things over and over as compared to doing it once and referring it? i.e.<code>ransom.count(word)</code> and <code>magazine.count</code> in a <code>for</code> loop as compared to having a dictionary and storing the counts against it once.</span>
<span class="comment-copy">Your approach is a naive <code>O(N^2)</code> algorithm, while Counter class uses multiset to optimize counting process</span>
