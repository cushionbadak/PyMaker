<div class="post-text" itemprop="text">
<p>I'm reading Raymond Hettinger's <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="noreferrer">Pythonâ€™s super() considered super!</a>  About a page in, there's this example:</p>
<pre><code>class Shape:
    def __init__(self, shapename, **kwds):
        self.shapename = shapename
        super().__init__(**kwds)        

class ColoredShape(Shape):
    def __init__(self, color, **kwds):
        self.color = color
        super().__init__(**kwds)

cs = ColoredShape(color='red', shapename='circle')
</code></pre>
<p>Why is it necessary to call <code>super()</code> in <code>Shape</code> here?  My understanding is that this calls <code>object.__init__(**kwds)</code> since <code>Shape</code> implicitly inherits from <code>object</code>.  </p>
<p>Even without that statement, we've already</p>
<ul>
<li>established <code>shapename</code> already in the parent's <code>__init__</code>,</li>
<li>established the child class's <code>color</code> in an explicit method override,</li>
<li>then invoked the parent's <code>__init__</code> with <code>super()</code> in <code>ColoredShape</code>.</li>
</ul>
<p>As far as I can tell, dropping this line produces the same behavior &amp; functionality:</p>
<pre><code>class Shape:  # (object)
    def __init__(self, shapename, **kwds):
        self.shapename = shapename
        # super().__init__(**kwds)

class ColoredShape(Shape):
    def __init__(self, color, **kwds):
        self.color = color
        super().__init__(**kwds)
    def check(self):
        print(self.color)
        print(self.shapename)

cs = ColoredShape(color='red', shapename='circle')

cs.check()
# red
# circle
</code></pre>
<p>What is the purpose of <code>super()</code> within <code>Shape</code> here?</p>
</div>
<div class="post-text" itemprop="text">
<p>I see that @user2357112 has already provided a correct answer. I was working on an example that I'd though I'd leave here because it's pretty much what user2357112 is describing.  Consider a mixin class like this:</p>
<pre><code>class PositionMixin:
    def __init__(self, x=0, y=0, **kwds):
        super().__init__(**kwds)
        self.x = x
        self.y = y
</code></pre>
<p>Let's say you apply that to your <code>ColoredShape</code> class:</p>
<pre><code>class ColoredShape(Shape, PositionMixin):
    def __init__(self, color, **kwds):
        self.color = color
        super().__init__(**kwds)
</code></pre>
<p>If <code>Shape</code> doesn't call <code>super.__init__</code>, then when you do this:</p>
<pre><code>myshape = ColoredShape('red', shapename='circle', x=1, y=1)
print(myshape.x, myshape.y)
</code></pre>
<p>You get:</p>
<pre><code>Traceback (most recent call last):
  File "supertest.py", line 18, in &lt;module&gt;
    print (myshape.x, myshape.y)
AttributeError: 'ColoredShape' object has no attribute 'x'
</code></pre>
<p>The call to <code>super.__init__</code> in shape is necessary to call the <code>__init__</code> method on <code>PositionMixin</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The point is cooperative multiple inheritance. The point of the whole entire article is cooperative multiple inheritance, really.</p>
<p>You look at <code>Shape</code> and you don't see any parents besides <code>object</code>. Sure, but that doesn't mean there aren't any siblings, or anything else on the MRO after <code>Shape</code>. <code>super()</code> isn't just for superclasses; it searches for the next implementation of the method in the <a href="https://www.python.org/download/releases/2.3/mro/" rel="noreferrer">method resolution order</a>. For example, one of the later classes in the article is</p>
<pre><code>class MovableColoredShape(ColoredShape, MoveableAdapter):
    pass
</code></pre>
<p>In this case, <code>Shape.__init__</code> needs to call <code>super().__init__</code>, or <code>MoveableAdapter.__init__</code> and all further <code>__init__</code> calls will be skipped.</p>
</div>
<span class="comment-copy">I think it is only example how to send arguments from one class to other using <code>**kwds</code> and remove <code>shapename</code> from  <code>**kwds</code> - and <code>Shape</code> parent is not important in this example. Maybe <code>Shape</code> should have parent but it is not main element in all example.</span>
<span class="comment-copy">Thanks, reading up on <a href="https://docs.python.org/3/whatsnew/2.2.html#multiple-inheritance-the-diamond-rule" rel="nofollow noreferrer">diamond rule</a>.  Is it easy to explain why <code>super().__init__()</code> in <code>shape</code> knows to reference <code>PositionMixin</code> (sibling) rather than <code>object</code>'s (parent) <code>__init__()</code>?  Or should I just take this as is and acknowledge I don't know MRO very well at all?</span>
<span class="comment-copy">I don't have a good answer for you.  I mean, the short answer is that <code>Shape</code> doesn't "know" anything; the call to <code>super()</code> returns a proxy object pointing at the appropriate class higher up in the MRO, and <code>Shape</code> is just operating on that.  But that's a little handy wavy, and I don't know the gritty details of how Python objects are constructed to provide a better answer.</span>
