<div class="post-text" itemprop="text">
<p>I have a function that I want to use multiple times, on every use I want a variable outside of the function to increment. Along the lines of - </p>
<pre><code>def funtion1(mylists,x):
    row=1
    for elm in mylists:
        ws.write(row,x,elm)
        row+=1
    x += 1

col=0
function1(mylist1,col)
function1(mylist2,col)
function1(mylist3,col)
</code></pre>
<p>etc</p>
<p>I thought col would increment on every use, but it stays at 0. Should I be returning a value from the function?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are incrementing a temporary variable <code>x</code> in the function namespace, therefore <code>col</code> is not modified. If you want to change <code>col</code> you can:</p>
<ul>
<li>use a <code>class</code> with a <a href="https://docs.python.org/3/library/functions.html?highlight=classmethod#classmethod" rel="nofollow noreferrer"><code>classmethod</code></a> and a class attribute</li>
<li>use a decorator as in Paul Panzer's <a href="https://stackoverflow.com/a/47680849/1388292">answer</a></li>
<li>return the value of <code>x</code> and affect it to <code>col</code></li>
<li>use a <a href="https://docs.python.org/3.6/reference/simple_stmts.html#the-global-statement" rel="nofollow noreferrer"><code>global</code></a> statement.</li>
</ul>
<p>If you are unfamiliar with namespace check <a href="https://www.programiz.com/python-programming/namespace" rel="nofollow noreferrer">this link</a></p>
<p>First using a <code>class</code> with a <a href="https://docs.python.org/3/library/functions.html?highlight=classmethod#classmethod" rel="nofollow noreferrer"><code>classmethod</code></a> and a class attribute:</p>
<pre><code>class functions:
    col = 0

    @classmethod
    def function1(cls, mylists):
        row=1
        for elm in mylists:
            ws.write(row, cls.col,elm)
            row+=1
        cls.col += 1

functions.function1(mylist1)
functions.function1(mylist2)
functions.function1(mylist3)
</code></pre>
<p>This would be my preferred option as the namespaces are not polluted and the code is cleaner than with returning a value.</p>
<p>Now returning a value:</p>
<pre><code>def funtion1(mylists,x):
    row=1
    for elm in whichlist:
        ws.write(row,x,elm)
        row=row+1
    return x + 1

col = 0
col = function1(mylist1,col)
col = function1(mylist2,col)
col = function1(mylist3,col)
</code></pre>
<p>Or with a <code>global</code>:</p>
<pre><code>def function1(mylists):
    global col
    row=1
    for elm in mylists:
        ws.write(row,col,elm)
        row+=1
    col += 1

col=0
function1(mylist1)
function1(mylist2)
function1(mylist3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could create a function attribute to hold the counter. Here is a decorator that does this:</p>
<pre><code>import functools as ft

def I_can_count(f):
    @ft.wraps(f)
    def wrapper(*args, **kwds):
        wrapper.times_called += 1
        return f(*args, **kwds)
    wrapper.times_called = 0
    return wrapper

@I_can_count
def f(x):
    print x

print(f.times_called)
f(100)
print(f.times_called)
f(100)
print(f.times_called)

# 0
# 100
# 1
# 100
# 2
</code></pre>
<p>Please note that the purpose of the decorator here is twofold: (1) it adds convenience; but more importantly (2) it protects the namespace where the function or rather its wrapper finds itself. Without that the following accident can happen:</p>
<pre><code>def f(x)
    f.times_called += 1
    print(x)
f.times_called = 0

f(100)
# 100
f.times_called
# 1
g = f
del f
g(100)
# Traceback (most recent call last):
#   File "&lt;stdin&gt;", line 1, in &lt;module&gt;
#   File "&lt;stdin&gt;", line 2, in f
# NameError: name 'f' is not defined
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Two options, pure functions which don't modify anything outside their scope, Most recommended</p>
<p>as our friend Jacques Gaudin has added: <a href="https://stackoverflow.com/a/47680265/7579116">https://stackoverflow.com/a/47680265/7579116</a></p>
<p>the other one, less fancy, and not recommended but is what you asked for is to declare x as global</p>
<pre><code>x = 0
def funtion1(mylists,x):
    global x
    row=1
    for elm in whichlist:
        ws.write(row,x,elm)
        row=row+1
    x += 1

function1(mylist1,col)
function1(mylist2,col)
function1(mylist3,col)
</code></pre>
</div>
<span class="comment-copy">When passing immutable data types, such as integers, they follow similar semantics to "pass-by-value". i.e. <code>x</code> is local to the function, and changing it does not affect the value of <code>col</code>. If it was a mutable object, and you changed a member value within the function - you would see your expected behaviour.</span>
<span class="comment-copy">you could define the variable as global or return the value</span>
<span class="comment-copy"><a href="http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html" rel="nofollow noreferrer">good resource</a></span>
<span class="comment-copy">Good approach, but you could also do     return x + 1 instead of doing x+=1 return x in two lines</span>
<span class="comment-copy">@ShailynOrtiz Thanks, amended accordingly</span>
<span class="comment-copy">thanks, swear I'd tried this.. I thought it wouldn't remain as a local variable if you are using a variable from outside the function</span>
<span class="comment-copy">@PTerm2 I added another option with a classmethod. I think that's a better way to achieve what you want.</span>
<span class="comment-copy">I like that solution. Out of curiosity what advantage does it have over class encapsulation?</span>
<span class="comment-copy">@JacquesGaudin I wouldn't insist on that it's better. It's a bit shorter; I'd guess a bit more light weight (I may be wrong there). OTOH the class approach tends to be a bit more readable especially when there are additional parameters (like a starting value for the counter). The point of decorators is of course that they are reusable - just add a single line before any function def and your function has the new features. In your class solution you have to retype the incrementing for each new function, or if subclassing at least call super. Finally, decorators can be created using classes.</span>
