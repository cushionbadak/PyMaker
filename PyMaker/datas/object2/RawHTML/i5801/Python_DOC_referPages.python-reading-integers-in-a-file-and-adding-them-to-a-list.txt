<div class="post-text" itemprop="text">
<p>
I am trying to create a function that takes an open file as an argument, reads the integers in the file which are all on their own line, then creates a list of those integers. The function should stop reading the file when there is an empty line. This is what I am stuck on.
</p>
<pre><code>def load_ints(file):
    lst = []
    x = 1
    while x == 1:
        for line in file:
            if len(line.strip()) != 0:
                load = line.split()
                load = [int(i) for i in load]
                lst = lst + load
            else:
                x = 2
        x = 2
    return lst
</code></pre>
<p>the file I am testing it with looks like this:</p>
<pre><code>  1
  0
  -12
  53
  1078

  Should not be read by load_ints!
</code></pre>
<pre><code>len(line.strip()) != 0:  
</code></pre>
<p>is not working,

it currently gives me a ValueError: invalid literal for int() with base 10: 'Should'</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to put a <code>break</code> after the <code>x = 2</code></p>
<pre><code>        else:
            x = 2
            break
</code></pre>
<p>Otherwise, the <code>for</code> loop will keep iterating over the file. It has read the blank line, executed the <code>else</code> condition, then carried on processing lines. So it tries to process the 'Should...' line, and fails because 'Should...' is not an integer.</p>
<p>Also, I don't see why you have the <code>while</code> statement. The <code>for</code> loop should be enough to iterate over the file and process each line, and the <code>break</code> I've suggested will exit the loop when you hit the blank line.</p>
</div>
<div class="post-text" itemprop="text">
<p>Other answers already point out the issue: you have to stop parsing the integers when encoutering the blank line.</p>
<p>Here's a one-liner using <a href="https://docs.python.org/3/library/itertools.html#itertools.takewhile" rel="nofollow noreferrer"><code>itertools.takewhile</code></a>, stopping when stripping the line yields an empty line &amp; converting to integer:</p>
<pre><code>import itertools

def load_ints(file):
    return [int(x) for x in itertools.takewhile(str.strip,file)]
</code></pre>
<p>result:</p>
<pre><code>[1, 0, -12, 53, 1078]
</code></pre>
<p>So <code>itertools.takewhile</code> iterates on the <code>file</code> lines, and applies <code>strip</code> on each line. If the result is an empty string, it stops the iteration. Otherwise it continues so the line is converted to integer and added to the list comprehension.</p>
<p>The less lines you're writing in those cases, the less bugs you'll create with auxiliary variables &amp; states.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think it is not necessary the while.</p>
<pre><code>def load_ints(file):
    lst = []
    for line in file:
        if len(line.strip()) != 0:
            load = line.split()
            load = [int(i) for i in load]
            lst.append(load)
        else:
            break

    return lst
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you read a file you get a generator. Instead of reading it all to memory we could use the while loop to feed us with 1 row at a time and break when condition is met (row is blank). This should be the most efficient solution.</p>
<pre><code>data = """\
1
2
-10
1241

Empty line above"""

with open("test.txt","w") as f:
    f.write(data)

with open("test.txt") as f:
    data = []
    while True:
        row = next(f).strip()
        try:
            data.append(int(row))
        # Break if ValueError is raised (for instance blank line or string)
        except ValueError:
            break

data
</code></pre>
<p>Returns:</p>
<pre><code>[1, 2, -10, 1241]
</code></pre>
<p>If you want a compact solution we could use takewhile from itertools. But this won't handle any error.</p>
<pre><code>from itertools import takewhile

with open("test.txt") as f:
    data = list(map(int,takewhile(lambda x: x.strip(), f)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to stop reading the file when the line is empty, you have to break the <code>for</code> loop :</p>
<pre><code>def load_ints(file):
    lst = []
    for line in file:
        if len(line.strip()) != 0:
            load = line.split()
            load = [int(i) for i in load]
            lst = lst + load
        else:
            break
    return lst
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <code>re</code> module:</p>
<pre><code>import re
def load_ints(my_file):
    return list(map(int, re.findall('-?\d', my_file.read())))
</code></pre>
</div>
<span class="comment-copy">Thanks. I also put this as an option but your params were smarter.</span>
<span class="comment-copy">@AntonvBR thanks. Always try listcomp &amp; avoid <code>map</code> &amp; <code>lambda</code> when possible, specially if a list is the final result.</span>
<span class="comment-copy">That's what I mean. I'm stuck with lambda in my head. However I thought map was efficient. list(map(..)) over a list comprehension. no?</span>
<span class="comment-copy">if you have to use <code>lambda</code> then it kills the interest for <code>map</code>. But <code>list(map(int,...))</code> is also good since <code>int</code> is already a function. Besides, if the data is iterated upon, OP may not need to convert to <code>list</code>. So bar what I said about <code>map</code> in that case.</span>
<span class="comment-copy">Yep, but although I like the takewhile approach I still think it is better to read row by row using next() and try to add int and handle exceptions as my answer shows.</span>
<span class="comment-copy">Your <code>break</code> statement breaks out of the <code>for</code> loop. The <code>while</code> loop then checks for the given condition and skips entering the <code>for</code> loop an additional time. A bit of semantics, but I would probably not describe your code as breaking the while loop ... rather it breaks the <code>for</code> loop. Hope this helps.</span>
<span class="comment-copy">You are right, I miss readed the code. And in fact, after reading it in more detail, the <code>while</code> loop is unuseful ...</span>
