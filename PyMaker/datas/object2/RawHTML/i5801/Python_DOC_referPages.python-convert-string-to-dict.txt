<div class="post-text" itemprop="text">
<p>I have a string : </p>
<pre><code>'{tomatoes : 5 , livestock :{cow : 5 , sheep :2 }}' 
</code></pre>
<p>and would like to convert it to </p>
<pre><code>{
  "tomatoes" : "5" , 
  "livestock" :"{"cow" : "5" , "sheep" :"2" }"
}
</code></pre>
<p>Any ideas ?</p>
</div>
<div class="post-text" itemprop="text">
<p>This has been settled in <a href="https://stackoverflow.com/a/988251/3926440">988251</a> 
In short; use the python <code>ast</code> library's <code>literal_eval()</code> function.</p>
<pre><code>import ast
my_string = "{'key':'val','key2':2}"
my_dict = ast.literal_eval(my_string)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What u have is a JSON formatted string which u want to convert to python dictionary.</p>
<h3>Using the JSON library :</h3>
<pre><code>import json
with open("your file", "r") as f:
    dictionary =  json.loads(f.read());
</code></pre>
<p>Now dictionary contains the data structure which ur looking for. </p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your input string is that it's actually not a valid JSON because your keys are not declared as strings, otherwise you could just use the <code>json</code> module to load it and be done with it. </p>
<p>A simple and dirty way to get what you want is to first turn it into a valid JSON by adding quotation marks around everything that's not a whitespace or a syntax character:</p>
<pre><code>source = '{tomatoes : 5 , livestock :{cow : 5 , sheep :2 }}'

output = ""
quoting = False
for char in source:
    if char.isalnum():
        if not quoting:
            output += '"'
            quoting = True
    elif quoting:
        output += '"'
        quoting = False
    output += char

print(output)  #  {"tomatoes" : "5" , "livestock" :{"cow" : "5" , "sheep" :"2" }}
</code></pre>
<p>This gives you a valid JSON so now you can easily parse it to a Python <code>dict</code> using the <code>json</code> module:</p>
<pre><code>import json

parsed = json.loads(output)
# {'livestock': {'sheep': '2', 'cow': '5'}, 'tomatoes': '5'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my answer:</p>
<pre><code>dict_str = '{tomatoes: 5, livestock: {cow: 5, sheep: 2}}'

def dict_from_str(dict_str):    

    while True:

        try:
            dict_ = eval(dict_str)
        except NameError as e:
            key = e.message.split("'")[1]
            dict_str = dict_str.replace(key, "'{}'".format(key))
        else:
            return dict_


print dict_from_str(dict_str)
</code></pre>
<p>My strategy is to convert the dictionary <code>str</code> to a <code>dict</code> by <code>eval</code>. However, I first have to deal with the fact that your dictionary keys are not enclosed in quotes. I do that by evaluating it anyway and catching the error. From the error message, I extract the key that was interpreted as an unknown variable, and enclose it with quotes.</p>
</div>
<span class="comment-copy">Is there a reason you want the numbers to be captured as strings?</span>
<span class="comment-copy">Not necessarily , I figured it might be easier that way.</span>
<span class="comment-copy">That's kind of paradox. You can't really change a string to a dictionary type... It's not like you can change the type to a <code>dict</code>.  That's pretty interesting, I'd like to find out how this plays out... JSON is a usefull way to do it, but how about a brute force hard code way?</span>
<span class="comment-copy">That's a weirdly formatted dictionary. Where did it come from?</span>
<span class="comment-copy">This came from an Mac app. I need to convert it to a real python dict for a faster access.</span>
<span class="comment-copy">Note the OPs string is not valid JSON.</span>
<span class="comment-copy">the keys and values aren't declared as strings</span>
<span class="comment-copy">Why json? Why not just <code>parsed = eval(output)</code>?</span>
<span class="comment-copy">@innisfree - Because no sane person should ever use <code>eval</code>. And even the insane should think twice before using it... and then use <code>ast.literal_eval()</code> instead if they really, really cannot find any way around it. Besides, it's <b>much</b> slower than <code>json.loads()</code> anyway.</span>
<span class="comment-copy">OK. Why would no sane person use it?</span>
<span class="comment-copy">@innisfree - start with <a href="https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow noreferrer">Eval really is dangerous</a>, then do a search with words <code>eval</code> and <code>dangerous</code>, <code>bad practice</code>, <code>slow</code> and such right here on SO and you'll get more than a mouthful of reasons why should you not use it. In short - in 99.999% of possible use cases, there is a faster, better and safer solution without exposing your system to the dangers of running arbitrary code using <code>eval()</code>.</span>
<span class="comment-copy">@innisfree - that's just an example, the OP already converted that string into whatever he wanted by typing out the question. It's safe to assume that it will be used on arbitrary strings outside of the OP's control (otherwise he/she could impose the format most suitable for them) and you don't want <code>eval()</code> ever touching arbitrary strings (which is why most people would want to use <code>eval()</code> anyway).</span>
<span class="comment-copy">I'm not sure whether hacking the error message is stupid or smart :D</span>
<span class="comment-copy">People tend to be touchy about using <code>eval</code>, bear in mind there is a function in the <code>ast</code> module called <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>literal_eval</code></a>, which has a much reduced scope for evaluation and hence is more secure.</span>
<span class="comment-copy">@paul haha yes, I noticed that ;)</span>
