<div class="post-text" itemprop="text">
<p>In my code I have:</p>
<pre><code>def testcode(args):
    try:
        function()
    except Exception as e:
        print(e)
</code></pre>
<p>and in my testcase it contains:</p>
<pre><code>with patch('module.function') as mock_func:
    mock_func.side_effect = _exception()
self.assertRaises(_exception(), testcode, args)
</code></pre>
<p>when I run the self.assertRaises it gets to the except block and does the print(e) but doesn't raise the exception. I can't add a raise after the print statement because I don't want to end the script. How can I raise the exception?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to either re-<code>raise</code> the exception, or accept that callers of your method (including your test) won't ever see the exception <em>because you handle that exception in your method</em>.</p>
<p>The point of exceptions is that you can walk up the stack to the nearest <code>except</code> block, allowing any given caller to insulate its own callers from exceptions that it shouldn't have to know about. That means that, as your function is written, it may be working as intended: You've made it so that the call to <code>function()</code> can be done even if it throws an exception, and you recover by printing that exception and moving on. That would imply your test and specs need to change, not your production code.</p>
<pre><code>def try_something_dangerous():
    try:
        do_dangerous_thing()
        return True   # The thing succeeded.
    except SomeImplementationDetailException:
        return False  # The thing failed in a way we were prepared for.
                      # Hide the failure from the outside world.
</code></pre>
<p>However, sometimes you need to intervene and still throw an exception: You might want to log the exception (as you're doing via <code>print</code>), inspect the exception to see whether to re-throw it, or wrap the exception in a different one that carries additional useful information (what data were you processing?) or abstraction (HighLevelException happened, because of LowLevelException).</p>
<p>Python has a simple syntax for re-raising an exception from within an <code>except</code> block: <a href="https://docs.python.org/3/tutorial/errors.html#raising-exceptions" rel="nofollow noreferrer">Just call <code>raise</code> without an instance.</a></p>
<blockquote>
<p>If you need to determine whether an exception was raised but donâ€™t intend to handle it, a simpler form of the raise statement allows you to re-raise the exception:</p>
<pre><code>&gt;&gt;&gt; try:
...     raise NameError('HiThere')
... except NameError:
...     print 'An exception flew by!'
...     raise
...
An exception flew by!
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
NameError: HiThere
</code></pre>
</blockquote>
<p>So if you want to re-raise your exception, do so here:</p>
<pre><code>def testcode(args):
    try:
        function()
    except Exception as e:
        print(e)
        raise
</code></pre>
<p>...but be careful: This can make your code confusing or frustrating, because you have unconditionally logged that an exception happened without handling it. If the caller handles the exception, they may not want your additional logging, and if they don't, the program ends anyway and your log may not help. There is no way for the caller to disable your <code>print</code> statement. Instead, consider wrapping the exception before re-throwing, or <em>not handling the exception at all</em> and letting the calling code be responsible for handling it.</p>
</div>
