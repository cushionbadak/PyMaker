<div class="post-text" itemprop="text">
<p>I've tried time.sleep(), but its accuracy is total garbage. Consider this loop, for instance:</p>
<pre><code>for i in range(10000000):
    print(i)
    sleep(.334)
</code></pre>
<p>Watch the numbers it prints. If it's anything like my computer, it's not even remotely regular. Is this function supposed to be accurate? Have I found a bug somewhere in my system?</p>
<p>If this function is not supposed to be accurate, what function would be more accurate?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're just looking at the output, buffering might make it appear slightly jittery. You could try to explicitly flush the output, but then you're also at the mercy of whatever is displaying the output. I might even hazard a guess that you're using Jupyter Notebook in your browser, which will also have a bunch of buffering/latency as it updates.</p>
<p>Another issue is that if you expect to be running every 1/3 of a second, is that you will suffer from accumulated errors. It will take a little time to run the loop, print a value (printing will take orders of magnitude more time than the other parts), then start to sleep again. A way to bypass this would be that after you finish doing whatever you want to do (I assume something more interesting than count), compute the time until the next 1/3rd of a second and sleep for that amount of time. Something like:</p>
<pre><code>import random
import time

sleep_until = time.monotonic() + 1/3

for n in range(100):
    print(time.monotonic() % 100, n)
    time.sleep(random.random() / 4) # some "work"

    now = time.monotonic()
    if sleep_until &gt; now:
        time.sleep(sleep_until - now)
    else:
        pass
        #print('task took too long')
    sleep_until += 1/3
</code></pre>
<p>For me it gives something like:</p>
<pre><code>48.34696656104643 0
48.68041984003503 1
49.08346292399801 2
49.41925806296058 3
49.72542790300213 4
50.07280854298733 5
50.41882419097237 6
50.74827564903535 7
51.08352101803757 8
51.41813271504361 9
51.75208444998134 10
52.08399672002997 11
52.41870043799281 12
</code></pre>
<p>So it bounces around a bit (I'm also running this in Jupyter, which may contribute), but won't stack up error as it runs.</p>
<p>The real question though is <em>what are you trying to do</em>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>print</code> statement in Python takes time to run.  If I need a Python program to sleep for a more exact amount of time, I use <code>datetime.timedelta</code> with a <code>while</code> loop instead of <code>time.sleep</code>.  Here is my code:</p>
<pre><code>from datetime import datetime, timedelta

startTime = datetime.now()
sleepTime = timedelta(seconds = 5)

# run code here

while startTime+sleepTime &gt; datetime.now():
    pass
</code></pre>
<p>Also, if you don't mind putting all of your code in funtions you can use a decorator function:</p>
<pre><code>from datetime import datetime, timedelta

def sleep(time):
    def outer_wrap(func):
        def wrap(*args, **kwargs):
            startTime = datetime.now()
            sleepTime = timedelta(seconds = time)
            while startTime+sleepTime &gt; datetime.now():
                pass
            func(*args, **kwargs)
        return wrap
    return outer_wrap

@sleep(5)
def c():
    # code goes here
    pass

c()
</code></pre>
<p>I would reccomend the first method because it can be very inefficient to put all your code in functions.</p>
<p>Note: This will not work if the code you are executing taes longer that the time you are trying to wait.  It should work in your case because <code>print</code> shouldn't take longer than 0.334 seconds.</p>
</div>
<div class="post-text" itemprop="text">
<p>OK, this time I have really figured this out. It wasn't IO buffering, nor was it the time it takes to call print() or some spooky OS-specific scheduling voodoo. <em>It was my terminal all along.</em> (...m. night shyamalan twist...) Specifically, <code>xfce4-terminal</code>, though after trying about seven other terminals, I found <code>lxterminal</code> has the exact same problem. They're both VTE-based, but there are other VTE-based emulators that <em>don't</em> have the problem, like <code>terminator</code> and <code>gnome-terminal</code>. Anyway, I changed terminals, and the problem is fixed.</p>
<p>I bet those of you who weren't using either of the two problematic terminals were wondering what the hell I was talking about.</p>
</div>
<span class="comment-copy">What numbers did you see being printed? What numbers did you expect instead?</span>
<span class="comment-copy">What number does it print ? I didn't notice any problem when I ran it</span>
<span class="comment-copy">Are you trying to sleep 1/3 of a second? Documentation says why it'll take longer or shorter. <a href="https://docs.python.org/3/library/time.html#time.sleep" rel="nofollow noreferrer">docs.python.org/3/library/time.html#time.sleep</a></span>
<span class="comment-copy">Are you more concerned with something occurring accurately at specific intervals (e.g. precisely every 1/3 second after the program begins) or more concerned with waiting some amount of time after something occurs (e.g. wait 1/3 a second after something happens)?</span>
<span class="comment-copy">On most "normal" computers you cannot expect operations to take a precise amount of time because the operating system has the power to preempt your application whenever it wants. Not only that but <code>print()</code> takes time, as doe the <code>for</code> loop, which you can't easily account for (by design). If you care about precise timings you probably need a <a href="https://en.wikipedia.org/wiki/Real-time_computing" rel="nofollow noreferrer">real-time computer</a>, but it's much more likely you're trying to solve <a href="https://meta.stackexchange.com/q/66377/147573">some other problem</a> - try asking <i>that</i> question instead.</span>
<span class="comment-copy">The terminal I am using (xfce4-terminal) and all terminals like it buffer on newlines, so that's not an issue. These terminals are pretty good for displaying data in real time as it is received.</span>
<span class="comment-copy">print executes almost instantly, or at least well under 50ms. That's not the problem.</span>
