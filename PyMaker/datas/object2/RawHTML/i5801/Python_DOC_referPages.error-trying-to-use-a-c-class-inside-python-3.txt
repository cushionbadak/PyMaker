<div class="post-text" itemprop="text">
<p>I'm trying to use a class I declared and implemented on C++, inside Python.<br/>
Even though I successfully declare my class in a Python wrapper, when I try to use the class's functions or even when I try to create an instance of this class I get:  </p>
<pre><code>[andre@atlantis mcasta]$ python TimedInputWrapper.py
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc
Aborted (core dumped)
</code></pre>
<p>Here's my C++ file (input_timeout.cpp):  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;string&gt;

class TimedInput {
    std::condition_variable cv;
    std::string prompt, input_string;
    long int li_time_limit;
    std::chrono::seconds time_limit;
public:
    TimedInput(std::string prompt_str, long int time) : prompt{prompt_str}, li_time_limit{time} { }

    void read_string() {
        std::cin &gt;&gt; input_string;
        cv.notify_one();
    }

    std::string return_input() {
        std::cout &lt;&lt; "Time limit for input = " &lt;&lt; li_time_limit &lt;&lt; " seconds!\n" &lt;&lt; prompt &lt;&lt; "\n";
        std::thread th(&amp;TimedInput::read_string, this);

        std::mutex mtx;
        std::unique_lock&lt;std::mutex&gt; lck(mtx);
        time_limit = (std::chrono::seconds) li_time_limit;

        while ((cv.wait_for(lck, time_limit) != std::cv_status::timeout) and (input_string.empty())) { }

        th.detach();
        return input_string;
    }
};

extern "C" {
    TimedInput* TimedInput_new(std::string prompt, long int time_limit) { return new TimedInput(prompt, time_limit); }
    void TimedInput_read_string(TimedInput* timed_input) { timed_input-&gt;read_string(); }
    std::string TimedInput_return_input(TimedInput* timed_input) { timed_input-&gt;return_input(); }
}
</code></pre>
<p>I created a shared library with these commands:  </p>
<pre><code>g++ -c -fPIC -pthread input_timeout.cpp -o input_timeout.o
g++ -shared -Wl,-soname,libTimedInput.so -o libTimedInput.so  input_timeout.o
</code></pre>
<p>And this is my Python Wrapper/test(TimedInputWrapper.py): </p>
<pre><code>import ctypes

lib = ctypes.cdll.LoadLibrary('./libTimedInput.so')


class TimedInput(object):
    def __init__(self, prompt, time_limit):
        self.prompt = prompt
        self.time_limit = time_limit
        self.obj = lib.TimedInput_new(self.prompt, self.time_limit)

    def read_string(self):
        lib.TimedInput_read_string(self.obj)

    def return_input(self):
        lib.TimedInput_return_input(self.obj)

prompt = ctypes.c_wchar_p("What's your name?")
time_limit = ctypes.c_long(10)

TimedInput(prompt, time_limit).return_input()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python <code>ctypes</code> does not work with C++ types, such as <code>std::string</code>. However, <code>ctypes</code> does work with C language types, such as <code>const char*</code>.</p>
<p>See <a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow noreferrer">Fundamental Data Types</a> in the Python <code>ctypes</code> documentation.</p>
</div>
<span class="comment-copy">The locks looked wrong, so I was going to try calling those functions in c++, before worrying about python. However, the compiler has multiple issues with your code so I couldn't even do that.</span>
<span class="comment-copy">I have never tried to use C++ methods in Python like in your example - I am not sure if it is correct approach. However, it seems that for your purpose <code>boost::python</code> or <code>pybind11</code> might work just fine.</span>
<span class="comment-copy"><code>ctypes</code> does not understand <code>std::string</code>.  <code>TimedInput_new</code> should take a <code>const char*</code> instead and you should pass the string as a byte string from Python.  <code>ctypes</code> will have a problem with <code>return_input()</code> returning <code>std::string</code> as well.</span>
