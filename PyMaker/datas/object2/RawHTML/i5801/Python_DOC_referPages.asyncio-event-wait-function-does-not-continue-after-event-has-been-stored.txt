<div class="post-text" itemprop="text">
<p>I'm working on a function that should continue after a response has been given through a websocket. In order to achieve this I use an asyncio event which will be set after the response has been given.</p>
<p>Three functions are involved:</p>
<pre><code>async def send(self, message):
    await self.channel(message.toJSON())
    if (message.method == 'get' or message.method == 'post'):
        event = asyncio.Event()
        self._queueMessage(message, event)
        await event.wait()
    print('continue')

def _queueMessage(self, message, event):
    self.queue.append([message, event])

def _process_response_message(self, message):
    for entry in self.queue:
        if (message['_id'] == entry[0]._id):
            print(entry[1])
            entry[1].set()
            print(entry[1])
            return
</code></pre>
<p>Returns: </p>
<pre><code>&lt;asyncio.locks.Event object at 0x7f3a1ff20da0 [unset,waiters:1]&gt;
&lt;asyncio.locks.Event object at 0x7f3a1ff20da0 [set,waiters:1]&gt;
</code></pre>
<p>In this example, the print('continue') function is never called and I do not why because the .set() function is actually called and .set() does seem to work fine if I use it before I call await event.wait().</p>
<p>Is there something I'm missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on message you get <code>_process_response_message</code> seems to be running in another thread. <code>asyncio.Event</code> is not thread-safe object you <a href="https://docs.python.org/3/library/asyncio-dev.html#asyncio-multithreading" rel="nofollow noreferrer">should use</a> <code>loop.call_soon_threadsafe</code> function to call it's methods from other thread. Try to change your code like this:</p>
<pre><code>async def send(self, message):
    await self.channel(message.toJSON())
    if (message.method == 'get' or message.method == 'post'):
        loop = asyncio.get_event_loop()
        event = asyncio.Event()
        self._queueMessage(message, loop, event)
        await event.wait()
    print('continue')

def _queueMessage(self, message, loop, event):
    self.queue.append([message, loop, event])

def _process_response_message(self, message):
    for entry in self.queue:
        qmsg, loop, event = entry
        if (message['_id'] == qmsg._id):
            loop.call_soon_threadsafe(event.set)
            return
</code></pre>
</div>
<span class="comment-copy">Are you sure control would be returned to asyncio's event loop after <code>_process_response_message</code> finished?</span>
<span class="comment-copy">@MikhailGerasimov I assume that something like that is going wrong. I assumed that the event.set() would communicate the change to the asyncio's event loop but you are saying that is not necessarily the case?</span>
<span class="comment-copy">@MikhailGerasimov I just added the line asyncio.get_event_loop() to the _process_response_message function and I got the message:  There is no current event loop in thread 'Dummy-1'. So I think you are indeed correct with your question.</span>
<span class="comment-copy">Thanks! learned something and you saved me a lot of time =)</span>
