<div class="post-text" itemprop="text">
<p>The following is an illustration. I'd like to understand in general whether there is a reason for defining a custom iterator class when a generator function can be defined instead.</p>
<p>I need to iterate over a sequence converting every element to int, e.g.</p>
<pre><code># seq is a sequence of strings or in general anything convertible to int
def f(seq):
    # ...
    g(int_iter(seq))

# iseq is a numeric sequence
def g(iseq):
    it = iter(iseq)
    # ...
</code></pre>
<p>I can use either a custom iterator class:</p>
<pre><code># iterator converting elements it iterates over to int
class int_iter:
    def __init__(self, iterable):
        self.it = iter(iterable)

    def __iter__(self):
        return self

    def __next__(self):
        return int(next(self.it))
</code></pre>
<p>or a generator function:</p>
<pre><code>def int_iter(seq):
    return (int(i) for i in seq)
</code></pre>
<p>Are these solutions always interchangeable?<br/>
Are they equivalently efficient (time- and space-wise)?<br/>
Stylistically, is any of them considered better?  </p>
<p>Thanks! </p>
</div>
<div class="post-text" itemprop="text">
<p>If I'm going to write it as an answer then lets add some examples to demonstrate the difference. Say we have a simple iterable like:</p>
<pre><code>source_list = list(range(10))  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>If you want to turn it into a string list, there are a plethora of ways apart from the already mentioned <code>map()</code> which is designed for that purpose - you can do a simple generator:</p>
<pre><code>def gen_str(iterable):  # this is equivalent to returning an in-line generator
    for element in iterable:
        yield str(element)

test_gen = gen_str(source_list)
for element in test_gen:
    print(repr(element), end=" ")
# '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 
</code></pre>
<p>Or you can write a full iterator class:</p>
<pre><code>class iter_str(object):

    def __init__(self, iterable):
        self._iterable = iterable
        self._iterator = self._get_iter(self._iterable)

    def __iter__(self):
        return self

    def __next__(self):
        return str(next(self._iterator))

    @staticmethod
    def _get_iter(iterable):  # a generator for forward iteration
        for element in iterable:
            yield element

test_iter = iter_str(source_list)
for element in test_iter:
    print(repr(element), end=" ")
# '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 
</code></pre>
<p>So far, they are the same - but what happens if you want to skip a few elements while iterating? You cannot instruct a generator to do so and in order to skip elements you need to add skipping-by-exhaustion logic within your iterating code itself, i.e.:</p>
<pre><code>test_gen = gen_str(source_list)
for element in test_gen:
    if element == "5":
        for _ in range(3):
            next(test_gen)
        continue
    print(repr(element), end=" ")
# '0' '1' '2' '3' '4' '9' 
</code></pre>
<p>On the other hand, with an iterator class you can encapsulate your control by adding a simple <code>skip()</code> method like:</p>
<pre><code>def skip(self, elements=1):
    for _ in range(elements):
        next(self._iterator)
</code></pre>
<p>And then you can elegantly do the same as:</p>
<pre><code>test_iter = iter_str(source_list)
for element in test_iter:
    if element == "5":
        element = test_iter.skip(3)
        continue
    print(repr(element), end=" ")
# '0' '1' '2' '3' '4' '9' 
</code></pre>
<p>But that's just the tip of the iceberg - what happens if you want to stop producing strings mid way through the iteration and use the original data? There is no way to inform the generator to do so (unless you've built it by passing some external control variable), while a simple change to the iterator class allows you to do exactly that:</p>
<pre><code>class iter_str(object):

    def __init__(self, iterable, string_mode=True):
        self._iterable = iterable
        self.string_mode = string_mode
        self._iterator = self._get_iter(self._iterable)

    def __iter__(self):
        return self

    def __next__(self):
        element = next(self._iterator)
        if self.string_mode:
            return str(element)
        return element

    @staticmethod
    def _get_iter(iterable):  # a generator for forward iteration
        for element in iterable:
            yield element

test_iter = iter_str(source_list)
for element in test_iter:
    if element == "4":
        test_iter.string_mode = False
    print(repr(element), end=" ")
# '0' '1' '2' '3' '4' 5 6 7 8 9 
</code></pre>
<p>This way you can add any arbitrary control over your iteration, including reversal, recurring iteration, even switching the iterator source mid-way through the iteration, etc. Simple generators do not allow you to do any of that without some major hassle.</p>
<p>As to efficiency, it's obvious from this example that the generator is more efficient as we're relying on an internal generator anyway, but the performance penalty will quickly evaporate if you need to control the life cycle of your iterable where you'd have to add more complex checks and generally make your life miserable trying to work around generator limits.</p>
<p>I won't comment on style but I'd claim that, in general, it's best to use the best tool for a job - if you don't need life-cycle control of your iterable, go ahead and use a generator, if you do - an iterator class is a way to go.</p>
</div>
<div class="post-text" itemprop="text">
<p>It all depends on the functionality that you expect from your object. If you just want a one-shot iterable as the result, which is optimized in terms of memory and not a container like list, tuple, etc., the best way is using a generator expression. If you want your object to be iterable for multiple times you should go with a list comprehension or other equivalents (set comprehension, etc.).</p>
<p>If you want more functionalities that a container or a generator can't satisfy, you should go with the custom object and add your expected functionalities as different methods to the class.</p>
</div>
<span class="comment-copy">... or you can, you know, use a function designed for that: <code>map(int, seq)</code>.</span>
<span class="comment-copy">@zwer simple and cool. I need to check whether <code>map</code> creates the full sequence upfront, which I'd like to avoid</span>
<span class="comment-copy">In Python 3.x <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map()</code></a> produces an iterator. In Python 2.x it was creating a full sequence.</span>
<span class="comment-copy">But even in Python 2.3+ there's <code>itertools.imap</code>, which produces a mapping iterator.</span>
<span class="comment-copy">For your example, <code>map()</code> is the way to go, in general, tho - custom iterator class allows you to control the whole life cycle of your iterable, including reversing, skipping and generally adding custom controls. Generators are more restricted in that way as you can't really instruct them to change their behavior mid-way (unless you pass them a 'control' variable during the creation but that's a bit hackish).</span>
<span class="comment-copy">great answer, thanks! One small question - why do you use a custom <code>_get_iter</code> function instead of the built-in <code>self._iterator = iter(self._iterable)</code>?</span>
<span class="comment-copy">@davka - in this particular instance, there is practically no difference, more of a preference for self-controlled iteration and a few perks that come with it. For example, if you wanted to add a cycled iteration all you'd have to do is place the <code>_get_iter()</code> innards in a <code>while True</code> loop and be done with it while if you've used an iterator you'd have to do more complex checks. In fact, I planned to post turn cycling on/off and cycle a set amount of times as an additional control to show the power of a custom iterator class over a generator but decided against it for brevity sake.</span>
