<div class="post-text" itemprop="text">
<p>In reference to <a href="https://stackoverflow.com/questions/47680897/python-calculate-orthographic-similarity-between-words-of-a-list?noredirect=1#comment82394894_47680897">this</a> question of mine, I realized that the corpus is too big and needs be split up in multiple mini-lists before going through the levenshtein calculations. The following code is my simple attempt, but I was wondering if there's a more elegant way to do it:</p>
<pre><code>import csv#, StringIO
import itertools, Levenshtein

# open the newline-separated list of words
path = '/Users/path/'
file = path + 'wordlist.txt'
output1 = path + 'ortho1.csv'
output2 = path + 'ortho2.csv'
output3 = path + 'ortho3.csv'
output4 = path + 'ortho4.csv'
output5 = path + 'ortho5.csv'
output6 = path + 'ortho6.csv'

words = sorted(set(s.strip() for s in open(file)))

# words is a list with 16349, so I split it in to 6 mini lists
verbs1 = words[:3269]
verbs2 = words[3269:13080]
verbs3 = words[13081:9811]
verbs4 = words[9812:6542]
verbs5 = words[6543:3273]
verbs6 = words[3274:len(words)]
</code></pre>
<p>For each of the above lists, I then compute the following loop:</p>
<pre><code>with open(output1, 'wb') as f:  
   writer = csv.writer(f, delimiter=",", lineterminator="\n")   
   for a, b in itertools.product(verbs1, words):        
       if (a &lt; b and Levenshtein.distance(a,b) &lt;= 5):
                    writer.writerow([a, b, Levenshtein.distance(a,b)])
</code></pre>
<p>Again, everything works, but I was wondering there's a more elegant way to code a single loop for each of the mini-lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few problems with your code, and other points you could improve:</p>
<ul>
<li>instead of having six different variables for <code>verbs</code> and <code>output</code> each, use two lists; this way you can more easily adapt the "splitting points" or number of sublists, and you do not have to copy-paste the code block for comparing the words six times; just use another loop</li>
<li>the sublist <code>words[13081:9811]</code> is empty, and also any others where the second index is smaller than the first</li>
<li>with <code>verbs1 = words[:3269]</code> and <code>verbs2 = words[3269:13080]</code>, <code>words[3269]</code> will be in <em>neither</em> of the sublists, as the second index is <em>exclusive</em>; same for the following lists</li>
<li>just in case this was your intention, splitting the list will <em>not</em> reduce the complexity or the running time, as you still have to compare each of the words; <code>a*x + b*x + c*x</code> is the same as <code>(a+b+c) * x</code></li>
<li>instead of checking <code>a &lt; b</code> and dismissing half of the <code>product</code>, use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>combinations</code></a> instead (but this only works when <em>not</em> splitting the list)</li>
<li>if you are only interested in pairs with an edit distance <code>&lt;= 5</code>, you could do a few other checks first, like comparing the length of the two words, or the set difference of contained characters; both of those checks will be faster then the actual edit distance check, which is O(n²), and might rule out many combinations</li>
<li>for the same reason, do not calculate the edit distance twice, once in the check and again for writing it to the file, but just once and store it in a temporary variable</li>
<li>if you split the file so that the output file does not become too large for Excel to handle (as I understood one of your comments), your approach might not work, as the size of the output file can vary drastically, depending on how many matches there are in that sublist</li>
</ul>
<p>Combining the above, you could try something like this (not tested):</p>
<pre><code>path = '/Users/path/'
with open(path + 'wordlist.txt') as infile:
    words = set(s.strip() for s in infile)

combs = itertools.combinations(words, 2)
max_count = 10**6 # or whatever Excel can handle
for i, chunk in enumerate(chunks(combs, max_count)):
    with open("%sortho%d.csv" % (path, i), "w") as outfile:
        writer = csv.writer(outfile, delimiter=",", lineterminator="\n")   
        for a, b in chunk:
            if might_be_close(a, b, 5):
                d = Levenshtein.distance(a,b)
                if d &lt;= 5:
                    writer.writerow([a, b, d])
</code></pre>
<p>Here, <code>chunks</code> is a function to <a href="https://stackoverflow.com/a/24527424/1639625">split an iterator into chunks</a> and <code>might_be_close</code> is a helper function comparing e.g. the length, or sets of contained letters, as described above. The size of the <code>output</code> file might still vary, but will never exceed <code>max_count</code>.</p>
<p>Or try this, to get output files with <em>exactly</em> <code>max_count</code> entries:</p>
<pre><code>max_count = 10**6 # or whatever Excel can handle
matches = filter_matches(itertools.combinations(words, 2), 5)
for i, chunk in enumerate(chunks(matches, max_count)):
    with open("%sortho%d.csv" % (path, i), "w") as outfile:
        writer = csv.writer(outfile, delimiter=",", lineterminator="\n")   
        for a, b, d in chunk:
            writer.writerow([a, b, d])

def filter_matches(combs, max_dist):
    for a, b in combs:
        if might_be_close(a, b, max_dist):
            d = Levenshtein.distance(a,b)
            if d &lt;= max_dist:
                yield a, b, d
</code></pre>
<p>Here, the <code>filter_matches</code> generator pre-filters the combinations and we are chunking those to the right size.</p>
</div>
<div class="post-text" itemprop="text">
<p>Put the verbs in a list:</p>
<pre><code>verbs = [words[:3269],words[3269:13080],words[13081:9811],words[9812:6542],
         words[6543:3273],words[3274:len(words)]]
</code></pre>
<p>And then use the length of that list to create a loop with same length. By using the index we can create the path and access the correct element in verbs.</p>
<pre><code>for i in range(len(verbs)):
    output = '{}ortho{}.csv'.format(path,i+1)
    with open(output, 'wb') as f:  
        writer = csv.writer(f, delimiter=",", lineterminator="\n")   
        for a, b in itertools.product(verbs[i], words):        
            if (a &lt; b and Levenshtein.distance(a,b) &lt;= 5):
               writer.writerow([a, b, Levenshtein.distance(a,b)])
</code></pre>
</div>
<span class="comment-copy"><code>words[13081:9811]</code> Did you try this? Won't this just be an empty list, since the "to" index is lower than the "from" index? Also, you should probably use lists instead of 6 individual variables.</span>
<span class="comment-copy">you can split the verbs into a dictionary of lists, your first code section is funcy, the rest is fine.</span>
<span class="comment-copy">Also, I don't see how splitting the list helps you at all, if you do the product for them all. <code>a*x + b*x + c*x</code> is the same as <code>(a+b+c) * x</code>.</span>
<span class="comment-copy">@tobias_k: You're right! I messed up the indices. I wasn't clear completely clear in my question - excel can't open a single file so I'm trying to split a single csv in multiple csv's. But I don't seem to succeed at all - any hint?</span>
<span class="comment-copy">There are certainly many optimizations you could do, if you are only interested in levelsthein distances &lt;= 5. Calculating the edit distance if O(n²), so before doing this, you could first check whether the difference in length in &lt;= 5, and whether the difference in the sets of used letters is &lt;= 5. Both will be much faster, and can probably rule out many combinations before computing the edit distance.</span>
<span class="comment-copy">All good points. I have no idea what <code>combinations</code> are.</span>
<span class="comment-copy">I understand, but I'd need some help here. How do I use <code>itertools.combinations(iterable, r)</code> here?</span>
<span class="comment-copy">@RobertP. Well, <code>combinations</code> would only work if you do not split the list, as it only accepts one iterable and the number of elements per combination (2 in your case)</span>
<span class="comment-copy">Right - that was why I was perplexed. So, I guess there's no way I can use <code>combinations</code> if I need to split up the list in multiple mini-lists (and that is, I think, the only way to make me able to see all the data on excel).</span>
<span class="comment-copy">@RobertP. Did you read the answer? You have to provide that function yourself, doing the pre-checks I mentioned. Or just leave it and check the edit distance for each combination.</span>
<span class="comment-copy">Your "and then" part is wrong. This will write the same results into each output file. You also have to make a <code>verbs</code> list and use that in the loop.</span>
<span class="comment-copy">Yup, that's what I just realized.</span>
<span class="comment-copy">@tobias_k yep, you are right. fixed it.</span>
<span class="comment-copy">But as seen below there are other issues to deal with. This however answers the question: How do i loop this.</span>
<span class="comment-copy">Yes - thank you!</span>
