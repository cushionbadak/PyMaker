<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6893968/how-to-get-the-return-value-from-a-thread-in-python">how to get the return value from a thread in python?</a>
<span class="question-originals-answer-count">
                    21 answers
                </span>
</li>
</ul>
</div>
<p>I have written this sample code that generate random numbers using multiple threads.</p>
<p>I can print each random number without any problems. But what I am trying to achieve is, I want to collect all the returned integers into <code>generated_numbers</code> array.</p>
<pre class="lang-py prettyprint-override"><code>from random import randint
from threading import Thread
import time


def generate_random_number(n):
    time.sleep(randint(0, 99)*0.01)
    random_number = randint(0, 99)
    print(str(n) + 'th random number: ' + str(random_number))
    return random_number


generated_numbers = []

for i in range(1, 100):
    thread = Thread(target=generate_random_number, args=(i,))
    thread.start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest using <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">multiprocessing</a> instead of <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">threading</a>, with the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool" rel="nofollow noreferrer">Pool</a> class you can map a function <code>generate_random_number</code> to an iterable <code>range(1,100)</code>.</p>
<p>Here is an example that does what you want:</p>
<p><em>N.B. 100 threads is a little overkill for such a small iterable.</em></p>
<pre><code>import multiprocessing
from random import randint


def generate_random_number(n):
    random_number = randint(0, 99)
    return f'{n}th random number: {random_number}'


if __name__ == '__main__':
    pool = multiprocessing.Pool(100)
    generated_numbers = pool.map(generate_random_number, range(100))
    print(generated_numbers)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do something like </p>
<pre><code>from random import randint
from threading import Thread
import time


def generate_random_number(n):
    global generated_numbers
    time.sleep(randint(0, 99)*0.01)
    random_number = randint(0, 99)
    print(str(n) + 'th random number: ' + str(random_number))
    generated_numbers.append(random_number)
    return random_number


generated_numbers = []

threads = [Thread(target=generate_random_number, args=(i,)) for i in range(100)]
for thread in threads:
    thread.start()

[t.join() for t in threads]
print generated_numbers
</code></pre>
<p>t.join() will wait for thread to execute, we are doing this by using list comprehension as thread.join() would resolve once last thread has completed which could happen before all of the started threads run.</p>
</div>
<span class="comment-copy">This helped! thanks :) Of course it's an overkill, this was just a dummy code used only for the question.</span>
<span class="comment-copy">I am not so sure about this solution, it works. but is modifying a global list from multiple threads safe?</span>
<span class="comment-copy">Not sure if its safe to be honest, alternative is using queue with multitheading @nipunasudha</span>
<span class="comment-copy">I guess it depends. In CPython it would be safe because of the global interpreter lock (GIL) which runs only one thread at a time. If you are using multiple processes which can run code in parallel then it won't be of course.</span>
