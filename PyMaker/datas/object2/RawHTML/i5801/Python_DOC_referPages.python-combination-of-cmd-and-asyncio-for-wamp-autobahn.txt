<div class="post-text" itemprop="text">
<h2>Overview</h2>
<p>I am trying to implement a simple command-line interface for a WAMP application.</p>
<p>For the WAMP implementation, the <a href="https://github.com/crossbario/autobahn-python" rel="nofollow noreferrer"><code>autobahn</code></a> python package is used.</p>
<p>I would like to have an interactive shell so I decided to use the <a href="https://docs.python.org/3/library/cmd.html" rel="nofollow noreferrer"><code>cmd</code></a> module to parse the input. Unfortunately, I have not been able to combine the <code>asyncio</code> nature of <code>autobahn</code> with the <code>cmd</code> loop.</p>
<h2>Code</h2>
<p>So in general what I would like to have is something similar to this:</p>
<pre><code>import argparse
import autobahn.asyncio.wamp as wamp
import cmd

class Shell(cmd.Cmd):
    intro = 'Interactive WAMP shell. Type help or ? to list commands.\n'
    prompt = '&gt;&gt; '

    def __init__(self, caller, *args):
        super().__init__(*args)
        self.caller = caller

    def do_add(self, arg):
        'Add two integers'
        a, b = arg.split(' ')
        res = self.caller(u'com.example.add2', int(a), int(b))
        res = res.result() # this cannot work and yields an InvalidStateError
        print('call result: {}'.format(res))

class Session(wamp.ApplicationSession):
    async def onJoin(self, details):
        Shell(self.call).cmdloop()

def main(args):
    url = 'ws://{0}:{1}/ws'.format(args.host, args.port)
    print('Attempting connection to "{0}"'.format(url))

    try:
        runner = wamp.ApplicationRunner(url=url, realm=args.realm)
        runner.run(Session)
    except OSError as err:
        print("OS error: {0}".format(err))

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('realm', type=str)
    parser.add_argument('host', type=str)
    parser.add_argument('port', type=int)

    main(parser.parse_args())
</code></pre>
<p>This obviously can not work since the result is not ready when <code>result()</code> is called on the future, but I can not use await since the Shell is not <code>async</code> itself.</p>
<h2>Solution Attempts</h2>
<p>I have found <a href="https://pypi.python.org/pypi/asynccmd/0.2.4" rel="nofollow noreferrer"><code>asynccmd</code></a> but I could not work out how to use it with <code>autobahn</code> and I am in general still a bit overwhelmed by the internals of <code>asyncio</code>.</p>
<p>Using a simple loop</p>
<pre><code>try:
    while(True):
        a = int(input('a:'))
        b = int(input('b:'))
        res = await self.call(u'com.example.add2', a, b)
        print('call result: {}'.format(res))
except Exception as e:
    print('call error: {0}'.format(e))
</code></pre>
<p>inside the <code>onJoin</code> function works perfectly fine, so I feel like there has to be a simple and lean solution for my problem as well.</p>
<p>Any suggestions would be much appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>It turns out that there already is a solution for this problem.</p>
<p><code>autobahn</code> has two versions, one using <code>aysncio</code> and one using asynchronous callbacks from <a href="https://twistedmatrix.com" rel="nofollow noreferrer"><code>twisted</code></a>.</p>
<p>The package <a href="https://github.com/itamarst/crochet" rel="nofollow noreferrer"><code>crochet</code></a> allows the usage of <code>twisted</code>-callbacks from a synchronous context and therefore offers a solution.</p>
<h2>Simple Solution</h2>
<p>The package <a href="https://pypi.python.org/pypi/autobahn-sync/" rel="nofollow noreferrer"><code>autobahn-sync</code></a> is a <code>crochet</code>-wrapper for autobahn and makes calling an RCP from within <code>cmd.Cmd</code> (or anywhere else) trivial:</p>
<pre><code>import autobahn_sync

autobahn_sync.run(url='example.com', realm='myrealm')
autobahn_sync.call(u'com.example.add2', a, b)
</code></pre>
</div>
