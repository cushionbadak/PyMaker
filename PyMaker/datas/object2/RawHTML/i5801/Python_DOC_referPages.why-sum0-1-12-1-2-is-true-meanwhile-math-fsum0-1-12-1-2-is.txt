<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a>
<span class="question-originals-answer-count">
                    28 answers
                </span>
</li>
</ul>
</div>
<p>When study the python built-in float function, I read <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow noreferrer">the floating point doc</a>. And got some understanding.</p>
<ul>
<li>Float's real value is different with their demonstration value, like <code>0.1</code>'s real value is <code>'0.1000000000000000055511151231257827021181583404541015625'</code></li>
<li>Any float in python has a fixed value using IEEE-754 </li>
<li>math.fsum give us the closest exactly representable value to the exact mathematical sum of the inputs</li>
</ul>
<p>But after doing a bunch of experiments, I still encounter some unsolved doubts.</p>
<h3>Doubt1</h3>
<p>In the tutorial doc I mentioned in the first paragraph, it gave us an example:</p>
<pre><code>&gt;&gt;&gt; sum([0.1] * 10) == 1.0
False
&gt;&gt;&gt; math.fsum([0.1] * 10) == 1.0
True
</code></pre>
<p>With the doc's instructions, I got an impression that <code>math.fsum</code> will give us a more accurate result when doing float summation.</p>
<p>But I found a special case within the <code>range(20)</code> where <code>sum([0.1] * 12) == 1.2</code> evals True, meanwhile <code>math.fsum([0.1] * 12) == 1.2</code> evals False. Which makes me perplexed.  </p>
<p>Why this happened?<br/>
And what's the mechanism of <code>sum</code> when doing float summation?</p>
<h3>Doubt2</h3>
<p>I found for some float computation, plus operation has the same effect as its equivalent multiply operation. Such as <code>0.1+0.1+0.1+0.1+0.1</code> is equal to <code>0.1*5</code>. But on some cases, there are not equivalent, like adding up <code>0.1</code> 12 times is not equal to <code>0.1*12</code>. This makes me really confused. As per float is a fixed value calculated by IEEE-754 standard. According to math principle, such kind of addition should be equal to its equivalent multiplication. The only explanation is that python didn't fully applied math principle here, some tricky stuff happens. </p>
<p>But what's the mechanism and details of this tricky stuff?</p>
<pre><code>In [64]: z = 0
In [64]: z = 0

In [65]: 0.1*12 == 1.2
Out[65]: False

In [66]: for i in range(12):
    ...:     z += 0.1
    ...:

In [67]: z == 1.2
Out[67]: True


In [71]: 0.1*5 == 0.5
Out[71]: True

In [72]: z = 0

In [73]: for i in range(5):
    ...:     z += 0.1
    ...:

In [74]: z == 0.5
Out[74]: True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When .1 is converted to 64-bit binary IEEE-754 floating-point, the result is exactly 0.1000000000000000055511151231257827021181583404541015625. When you add this individually 12 times, various rounding errors occur during the additions, and the final sum is exactly 1.1999999999999999555910790149937383830547332763671875.</p>
<p>Coincidentally, when 1.2 is converted to floating-point, the result is also exactly 1.1999999999999999555910790149937383830547332763671875. This is a coincidence because some of the rounding errors in adding .1 rounded up and some rounded down, with the net result that 1.1999999999999999555910790149937383830547332763671875 was produced.</p>
<p>However, if .1 is converted to floating-point and then added 12 times using exact mathematics, the result is exactly 1.20000000000000006661338147750939242541790008544921875. Python’s <code>math.fsum</code> may produce this value internally, but it does not fit in 64-bit binary floating-point, so it is rounded to 1.20000000000000017763568394002504646778106689453125.</p>
<p>As you can see, the more accurate value 1.20000000000000017763568394002504646778106689453125 differs from the result of converting 1.2 directly to floating-point, 1.1999999999999999555910790149937383830547332763671875, so the comparison reports they are unequal.</p>
<p>In <a href="https://stackoverflow.com/a/47367873/298225">this answer</a>, I step through several additions of .1 to examine the rounding errors in detail.</p>
</div>
<span class="comment-copy">I think this  may due to the floating point, take reference like this: <a href="https://stackoverflow.com/questions/2100490/floating-point-inaccuracy-examples" title="floating point inaccuracy examples">stackoverflow.com/questions/2100490/…</a>, if you wanna avoid inaccuracy like this, you could try decimal data type.</span>
<span class="comment-copy">As you have already discovered floating numbers are inaccurate, so never expect <code>==</code> to work even if the math tells you it should, and even if sometime it does work ("by chance")</span>
<span class="comment-copy">@Julien, yes, the thing which bothers me is that addition on floats doesn't equals to its equivalent multiplication. Which really confused me. Could you give me some hints why this happened. Was it because when each time doing the addition, the intermediate float result was rounded? Like when add 0.1 up 12 times, it was rounded 12times, meanwhile <code>0.1*12</code> only been rounded once?</span>
<span class="comment-copy">@Zen there is "no" reason why multiplication should give the same result as its repeated addition "equivalent" because they follow 2 different paths / algorithms. While x*y "is" x+x+x... y times for integer values, this interpretation makes no sense for non integer floats, and as such that's not how the values are computed.</span>
<span class="comment-copy">I probably shouldn't be doing this but check out something like <code>for i in range(100): for j in (0.1, math.pi, math.e): assert i*j==math.fsum(i*[j])</code> :-]</span>
