<div class="post-text" itemprop="text">
<p>I've written a basic client/server interface using Python socket (quoted only relevant part of code, for full script: (SERVER: <a href="https://github.com/mydomo/ble-presence/blob/master/server.py" rel="nofollow noreferrer">https://github.com/mydomo/ble-presence/blob/master/server.py</a>)
(CLIENT: <a href="https://github.com/mydomo/ble-presence/blob/master/clients/DOMOTICZ/ble-presence/plugin.py" rel="nofollow noreferrer">https://github.com/mydomo/ble-presence/blob/master/clients/DOMOTICZ/ble-presence/plugin.py</a>)</p>
<p>The issue is when the script run from some hours and the result list is getting bigger sometimes the reply is exactly as it should be, other times it's cutted, not complete... it's random, like if the socket closed for no reason earlier or the reply is not fully read.</p>
<p>Can you please help me?</p>
<p>SERVER: </p>
<pre><code>def client_thread(conn, ip, port, MAX_BUFFER_SIZE = 32768):
    # the input is in bytes, so decode it
    input_from_client_bytes = conn.recv(MAX_BUFFER_SIZE)

    # MAX_BUFFER_SIZE is how big the message can be
    # this is test if it's too big
    siz = sys.getsizeof(input_from_client_bytes)
    if  siz &gt;= MAX_BUFFER_SIZE:
        print("The length of input is probably too long: {}".format(siz))

    # decode input and strip the end of line
    input_from_client = input_from_client_bytes.decode("utf8").rstrip()

    res = socket_input_process(input_from_client)
    #print("Result of processing {} is: {}".format(input_from_client, res))

    vysl = res.encode("utf8")  # encode the result string
    conn.sendall(vysl)  # send it to client
    conn.close()  # close connection
##########- END FUNCTION THAT HANDLE SOCKET'S TRANSMISSION -##########

def start_server():
    global soc
    soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # this is for easy starting/killing the app
    soc.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    #print('Socket created')
    try:
        soc.bind((socket_ip, socket_port))
    #    print('Socket bind complete')
    except socket.error as msg:
    #    print('Bind failed. Error : ' + str(sys.exc_info()))
        sys.exit()


    #Start listening on socket
    soc.listen(10)
    #print('Socket now listening')

    # for handling task in separate jobs we need threading
    #from threading import Thread

    # this will make an infinite loop needed for
    # not reseting server for every client
    while (not killer.kill_now):
        conn, addr = soc.accept()
        ip, port = str(addr[0]), str(addr[1])
        #print('Accepting connection from ' + ip + ':' + port)
        try:
            Thread(target=client_thread, args=(conn, ip, port)).start()
        except:
            print("Terible error!")
            import traceback
            traceback.print_exc()
soc.close()
</code></pre>
<p>CLIENT:</p>
<pre><code>soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
SERV_ADDR = str(Parameters["Address"])
SERV_PORT = int(Parameters["Port"])
soc.connect((SERV_ADDR, SERV_PORT))

if BATTERY_REQUEST == True:
    clients_input = str(BATTERY_DEVICE_REQUEST)
else:
    clients_input = "beacon_data"

soc.send(clients_input.encode()) # we must encode the string to bytes  
result_bytes = soc.recv(32768) # the number means how the response can be in bytes  
result_string = result_bytes.decode("utf8") # the return will be in bytes, so decode
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Method <a href="https://docs.python.org/3/library/socket.html#socket.socket.recv" rel="nofollow noreferrer"><code>recv()</code></a> does not guaranty receiving the full message in the first call so you have to try getting the full message by calling recv() multiple times.<br/>
If recv() does return an empty string, connection is closed in the client side.</p>
<p>Using this while loop you can get full stream from client into <code>data</code>:</p>
<pre><code>data = b''  # recv() does return bytes
while True:
    try:
        chunk = conn.recv(4096)  # some 2^n number
        if not chunk:  # chunk == ''
            break

        data += chunk

    except socket.error:
        conn.close()
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>TCP is a streaming protocol, meaning it has no concept of what constitutes a complete message.  You have to implement your own message protocol layer on top of TCP to make sure you send and receive complete messages.  You are responsible for buffering data received until you have a complete message, and you have to define what a complete message is. Some options:</p>
<ol>
<li>Send fixed length messages.</li>
<li>Send a fixed number of bytes representing the length of the message, then the message.</li>
<li>Separate messages with a sentinel byte.</li>
</ol>
<p>Then, call <code>recv</code> and accumulate the results until you have a complete message in the buffer.</p>
</div>
<span class="comment-copy">You are making wrong use of <code>sys.getsizeof()</code> method. Use <code>len(input_from_client_bytes)</code> to get length of <code>input_from_client_bytes</code></span>
<span class="comment-copy">Use the same while loop to recv stream from server in client side.</span>
<span class="comment-copy">Just closing connection in client side is sufficient for 1, 2, 3.</span>
<span class="comment-copy">@Elis It is not sufficient if multiple messages can be sent.</span>
<span class="comment-copy">You have to use an existing <a href="https://en.wikipedia.org/wiki/Application_layer" rel="nofollow noreferrer">application layer</a> or implement a simple one by yourself to be able to send/receive multiple messages. In this case 1, 2, 3 are good points to start.</span>
<span class="comment-copy">@Elis Isn't that what I just said?</span>
<span class="comment-copy">You were not talking about multiple messages in a single TCP connection.</span>
