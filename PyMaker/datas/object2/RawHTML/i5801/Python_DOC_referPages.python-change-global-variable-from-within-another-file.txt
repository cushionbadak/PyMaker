<div class="post-text" itemprop="text">
<p>In my main class I use a global variable ADDRESS that is defined in another file called config.py.
I want to change the value of ADDRESS from within my main class, by calling a function in config.py.</p>
<p>In my main class I have:</p>
<pre><code>from config import ADDRESS, change_address
change_address("192.168.10.100")
print("new address " + ADDRESS)
</code></pre>
<p>In my config file I have the following:</p>
<pre><code>ADDRESS = "0.0.0.0"

def change_address(address):
    global ADDRESS
    ADDRESS = address
    print("changed address to: " + ADDRESS)
</code></pre>
<p>The print statement in my config file correctly prints the new address of 192.168.10.100.
However, the print statement in my main class prints 0.0.0.0.
What am I missing here?</p>
</div>
<div class="post-text" itemprop="text">
<p>All that <code>from config import ADDRESS, change_address</code> does is take <code>ADDRESS</code> and <code>change_address</code> from your <code>config</code> module's namespace and dumps it into your current module's name-space. Now, if you reassign the value of <code>ADDRESS</code> in <code>config</code>'s namespace, it won't be seen by the current module - that's how name-spaces work. It is like doing the following:</p>
<pre><code>&gt;&gt;&gt; some_namespace = {'a':1}
&gt;&gt;&gt; globals().update(some_namespace)
&gt;&gt;&gt; a
1
&gt;&gt;&gt; some_namespace
{'a': 1}
&gt;&gt;&gt; some_namespace['a'] = 99
&gt;&gt;&gt; a
1
&gt;&gt;&gt; some_namespace
{'a': 99}
</code></pre>
<p>The simplest solution? Don't clobber name-spaces:</p>
<pre><code>import config
config.change_address("192.168.10.100")
print("new address " + config.ADDRESS)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would recommend that you try not to change the global state in a module. Instead, I would re-write the code such that <code>ADDRESS</code> in config.py doesn't change. If the configuration for your application can change from invocation to invocation I would change config to be something like:</p>
<pre><code>ADDRESS = '0.0.0.0'

def get_default_config():
    return {'address': ADDRESS, 'some_other_config_value': 'foo'}
</code></pre>
<p>Then in main I would do:</p>
<pre><code>app_config = config.get_default_config()
app_config = "192.168.10.100"
print("new address " + app_config['address']
</code></pre>
<p>As a general rule it isn't a good idea to change the value of variables/constants in other modules.</p>
<p>NOTE: You could also create a config class as well, so that you could access configuration values like config.address.</p>
<p>I recommend that you read the stackexchange post <a href="https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil">Why is Global State so Evil?</a></p>
</div>
<span class="comment-copy">Your <code>import</code> binds a new local variable <code>ADDRESS</code> to the string that the <code>ADDRESS</code> variable in config refers to. When you call <code>change_address()</code> the <code>ADDRESS</code> variable in config now refers to a different string. Your own local variable still refers to the original string.</span>
<span class="comment-copy">You were quicker ;) I just wanted to add this link, since it describes this common problem: <a href="https://docs.python.org/3/faq/programming.html#how-do-i-share-global-variables-across-modules" rel="nofollow noreferrer">docs.python.org/3/faq/…</a></span>
<span class="comment-copy">worked perfectly :) thank you @gonczor. Although not a duplicate question I believe, I found same solution here: <a href="https://stackoverflow.com/questions/3536620/how-to-change-a-module-variable-from-another-module" title="how to change a module variable from another module">stackoverflow.com/questions/3536620/…</a></span>
