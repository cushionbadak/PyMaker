<div class="post-text" itemprop="text">
<p>I want to sum values of the same key: <code>H, C, O, N, S</code> according to dictionary <code>composition</code> for the string input which is a combination of letter <code>A, C, D, E</code>. </p>
<pre><code>composition = {
    'A':  {'H': 5, 'C': 3, 'O': 1, 'N': 1},
    'C':  {'H': 5, 'C': 3, 'O': 1, 'N': 1, 'S': 1},
    'D':  {'H': 5, 'C': 4, 'O': 3, 'N': 1},
    'E':  {'H': 7, 'C': 5, 'O': 3, 'N': 1},
}

string_input = ['ACDE', 'CCCDA']
</code></pre>
<p>The expected result should be</p>
<pre><code>out = {
    'ACDE' : {'H': 22, 'C': 15, 'O': 8, 'N': 4, 'S': 1},
    'CCCDA' : {'H': 15, 'C': 9, 'O': 3, 'N': 3, 'S': 3},
}
</code></pre>
<p>I am trying to use <code>Counter</code> but stuck at <code>unsupported operand type(s) for +: 'int' and 'Counter'</code></p>
<pre><code>from collections import Counter

for each in string_input:
  out = sum(Counter(composition[aa]) for aa in each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>sum()</code> has a <em>starting value</em>, from which it starts the sum. This also provides a default if there are no values to sum in the first argument. That starting value is <code>0</code>, an integer.</p>
<p>From the <a href="https://docs.python.org/3/library/functions.html#sum" rel="noreferrer"><code>sum()</code> function documentation</a>:</p>
<blockquote>
<p><code>sum(iterable[, start])</code></p>
<p>Sums <em>start</em> and the items of an <em>iterable</em> from left to right and returns the total. <em>start</em> defaults to <code>0</code>.</p>
</blockquote>
<p>When summing <code>Counter</code> objects, give it an empty <code>Counter()</code> to start off with:</p>
<pre><code>sum((Counter(composition[aa]) for aa in each), Counter())
</code></pre>
<p>If you then assign the result to a <em>key</em> in a <em>dictionary</em> assigned to <code>out</code> you get your expected result as <code>Counter</code> instances:</p>
<pre><code>&gt;&gt;&gt; out = {}
&gt;&gt;&gt; for each in string_input:
...     out[each] = sum((Counter(composition[aa]) for aa in each), Counter())
...
&gt;&gt;&gt; out
{'ACDE': Counter({'H': 22, 'C': 15, 'O': 8, 'N': 4, 'S': 1}), 'CCCDA': Counter({'H': 25, 'C': 16, 'O': 7, 'N': 5, 'S': 3})}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Three nested for loops should do the work.</p>
<pre><code>out = {}
for x in string_input: # for each string in list
    current = out[x] = {}
    for char in x: # for each character in the string
        cur_composition=composition[char]
        for val in cur_composition: # for all the entry in the composition dictionary for that character
            current[char]= cur_composition[val] if val not in current[char] else cur_composition[val]+current[char]
</code></pre>
</div>
<span class="comment-copy">How does <code>'CCCDA</code> map to <code>'CCC</code> in the output?</span>
<span class="comment-copy">You can remove the <code>(...)</code> parentheses in the <code>composition</code> value definitions, they are entirely redundant.</span>
<span class="comment-copy">you should do this <code>out[each] = sum((Counter(composition[aa]) for aa in each), Counter())</code></span>
<span class="comment-copy">@MartijnPieters the key, in fact, aren't important but I just want to show what key each composition is calculated from. I will update the question.</span>
