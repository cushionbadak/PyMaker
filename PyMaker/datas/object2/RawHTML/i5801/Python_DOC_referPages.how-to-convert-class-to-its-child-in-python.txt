<div class="post-text" itemprop="text">
<p>I have a class called <code>class_A</code> I do some work with it and store it with <code>pickle</code>. 
I have another class <code>class_B</code> wich is a child of <code>class_A</code> but has some additional methods and properties. I want to load data from my pickled file as <code>class_B</code> and work with it. How can I do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could override the unpickler's <code>find_class</code> function, like so:</p>
<pre><code>import pickle

# Set up class_A and class_B as in the question
class class_A:
    def __init__(self):
        self.a = 1
    def method_a(self): pass
class class_B(class_A):
    def __init__(self):
        super().__init__()
        self.b = 1
    def method_b(self): pass

# Create an pickle a class_A object
a = class_A()
with open('pickle', 'wb') as f:
    pickle.dump(a, f)

# Create an unpickler that lies about class types
class MyUnpickler(pickle.Unpickler):
    def find_class(self, module, name):
        if (module, name) == ('__main__', 'class_A'):
            name = 'class_B'
        return pickle.Unpickler.find_class(self, module, name)

# Unpickle with the transmorgifying unpickler
with open('pickle', 'rb') as f:
    new_b = MyUnpickler(f).load()

# Verify that the returned object is a `class_B`
assert isinstance(new_b, class_B)
assert hasattr(new_b, 'method_a')
assert hasattr(new_b, 'method_b')
assert hasattr(new_b, 'a')

# Sadly, new_b.__init__ never ran, so no `new_b.b`
assert not hasattr(new_b, 'b')
</code></pre>
<p>Reference: <a href="https://docs.python.org/3/library/pickle.html#pickle.Unpickler.find_class" rel="nofollow noreferrer">https://docs.python.org/3/library/pickle.html#pickle.Unpickler.find_class</a></p>
</div>
<div class="post-text" itemprop="text">
<p>More details around your exact use case are needed to be certain, but  one of these abstract approaches may work for you.</p>
<pre><code>b = Class_B()
b.__dict__ = pickled_data
</code></pre>
<p>Or</p>
<pre><code>b = Class_B(**pickled_data)
</code></pre>
<p>Or</p>
<pre><code>a = Class_A()
b = Class_B()
b.__dict__ = a.__dict__
</code></pre>
<p>I'd recommend crating a class method to do what you need.</p>
<pre><code>b = B.from_a(class_a, *args, **kwargs)
</code></pre>
</div>
<span class="comment-copy">Some code as an example of what you're trying to achieve wouldn't hurt. Generally speaking, you can <i>update</i> your <code>class_B</code> instance's <code>__dict__</code> with the one from an unpickled <code>class_A</code> but that won't work at all times and is generally a bad practice. You should just make <code>class_B</code> recognize <code>class_A</code> as an input and handle the update itself.</span>
<span class="comment-copy">There is probably no general way, and you'll have to cook something up yourself. More details would be helpful to formulating an answer. Also - <i>always</i> use the generic Python tag, and a version-specific tag optionally.</span>
<span class="comment-copy">deep magic here.</span>
<span class="comment-copy">Not too deep. <a href="https://docs.python.org/3/library/pickle.html#pickle.Unpickler.find_class" rel="nofollow noreferrer">It's documented.</a></span>
<span class="comment-copy">don't use ``` to format blocks of code. stackoverflow has better mechanisms. Just type your code normally, then select it all and click on the <code>{}</code> button to indent the entire block. <a href="https://meta.stackoverflow.com/questions/251361/how-do-i-format-my-code-blocks" title="how do i format my code blocks">meta.stackoverflow.com/questions/251361/â€¦</a></span>
<span class="comment-copy">@brianoakley I'm on my phone.  Those tools are not available.</span>
