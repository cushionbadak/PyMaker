<div class="post-text" itemprop="text">
<p>I have a list of objects, and for each object, I need to do some async work on it. I am not sure if I construct it right:</p>
<pre><code>def run(tasks):
    async def async_wrapper():
        async def update_task():
            updated_task = await task_manager.async_get_task_status(session, task)
            # do some works with updated_task

        workers = []
        resolver = aiohttp.AsyncResolver()
        connector = aiohttp.TCPConnector(resolver=resolver, family=socket.AF_INET)
        async with aiohttp.ClientSession(connector=connector) as session:
            for local_task in tasks: # tasks is a list of object
                await update_ocr_task()

    loop = asyncio.get_event_loop()
    loop.run_until_complete(aysnc_wrapper())
</code></pre>
<p>I think the for loop is sync and will totally block the progress, am I right? If I am, how to construct it?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def run(tasks):
    # ...

    loop = asyncio.get_event_loop()
    loop.run_until_complete(aysnc_wrapper())
</code></pre>
<p>Usually it's not how people write async programs: event loop should be global and be started as main entry point of whole script. Doing like you do (running event loop inside single function <code>run</code>) makes unable for upper code to run other coroutines in same event loop.</p>
<p>If you understand this and all you want is blocking <code>run</code> function that can't be used alongside with other async stuff, read further.</p>
<hr/>
<p>Problem with your <code>async_wrapper</code> is that it awaits next <code>update_ocr_task()</code> coroutine only after previous one been done. For loop is not what we call "blocking", but it's just not concurrent - it doesn't use benefits provided by asynchronous paradigm.</p>
<p>To achieve benefits of using asyncio you should run multiple coroutines concurrently. Common way to do it is to use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="nofollow noreferrer">asyncio.gather()</a>:</p>
<pre><code>async def async_wrapper():

    async def process_single_task(task):
        resolver = aiohttp.AsyncResolver()
        connector = aiohttp.TCPConnector(resolver=resolver, family=socket.AF_INET)
        async with aiohttp.ClientSession(connector=connector) as session:
            await session.get(...) # do all job for *single* local task here.

    # Run multiple task processing coroutines concurrently:
    await asyncio.gather(
        *[process_single_task(t) for t in tasks]
    )
</code></pre>
<p>If you want you can also read <a href="https://stackoverflow.com/a/33399896/1113207">this</a> little answer about asyncio in general.</p>
</div>
<span class="comment-copy">Oh, I think I have noticed what's wrong. <code>await update_ocr_task()</code> is concurrent with other coroutines such as <code>await task_manager.async_get_task_status(session, task)</code>, but not itself. <code>gather</code> makes all <code>update_ocr_task</code> concurrent. That is the point. BTW, the reason why I wrap the whole loop into a function is that I want to run async event loop in a separate thread/process as my main thread is a sync task.</span>
<span class="comment-copy">A little additional question, could I just replace <code>for</code> with <code>async for</code> to accomplish the same behave?</span>
<span class="comment-copy">@Sraw no. <code>async for</code> uses to iterate by asynchronous generator. It's absolutely different thing.</span>
<span class="comment-copy">Thanks for answer, I have understood coroutine much more.</span>
