<div class="post-text" itemprop="text">
<p>I have this <code>data</code> (Small Example) that i import into a script.</p>
<pre><code>LastName    StartTime   EndTime Duration  Period    TeamAbbrev  Position
Bouwmeester     0:00    0:37    0:37         1         STL         D
Schwartz        0:00    0:40    0:40         1         STL         W
Foligno         0:00    0:40    0:40         1         MIN         W
Pietrangelo     0:00    0:48    0:48         1         STL         D
Suter           0:00    0:40    0:40         1         MIN         D
Staal           0:00    0:40    0:40         1         MIN         C
Niederreiter    0:00    0:40    0:40         1         MIN         W
Allen           0:00    20:00   20:00        1         STL         G
Steen           0:00    0:30    0:30         1         STL         W
Tarasenko       0:30    1:27    0:57         1         STL         W
Parayko         0:37    1:43    1:06         1         STL         D
</code></pre>
<p>This is the script</p>
<pre><code>import csv
from itertools import combinations, product

#Header = LastName  StartTime  EndTime  Duration Period TeamAbbrev Position

#Import Game
with open('2017020397.csv', newline='') as f:
    next(f)
    skaters = '\n'.join(' '.join(row) for row in csv.reader(f))
    data = skaters.splitlines()

def to_secs(ms):
    ''' Convert a mm:ss string to seconds '''
    m, s = map(int, ms.split(':'))
    return 60 * m + s

# Store a list of (start, end) times for each player
players = {}
for row in data:
    name, start, end = row.split(None, 3)[:3]
    times = to_secs(start), to_secs(end)
    players.setdefault(name, []).append(times)

for t in players.items():
    print(t)
print()

# Determine the amount of overlapping time for each combination of players
for p1, p2, p3 in combinations(sorted(players), 3):
    total = 0
    # Check each pair of times for this pair of players
    for t1, t2, t3 in product(players[p1], players[p2], players[p3]):
        # Compute the overlap in this pair of times and
        # add it to the total for this pair of players
        start, end = zip(t1, t2, t3)
        total += max(0, min(end) - max(start))
    if total:
        print(p1, p2, p3, total)
</code></pre>
<p>Output:</p>
<pre><code>Allen Niederreiter Pietrangelo 5481
Allen Niederreiter Prosser 2088
Allen Niederreiter Reilly 1464
</code></pre>
<p>The Purpose of this is to see what Team Mate played with each other. From the <code>Output</code> we can see that <code>Allen</code> from <code>STL</code> is Paired up with <code>Niederreiter</code> from <code>MIN</code>. I only want like team <code>combinations</code> to combine. The <code>TeamAbbrev</code> is how that can be identified. The other stipulation is that the <code>TeamAbbrev</code> will change game by game depending on what teams are playing that night. Open to any and all suggestions, Thanks!</p>
<p>Edit: If an <code>int()</code> is easier than a <code>str()</code> for <code>TeamAbbrev</code> I can scrape the <code>teamId</code> instead which is a number. </p>
</div>
<div class="post-text" itemprop="text">
<p>Add after your ʼfor row in dataʼ...</p>
<pre><code>teams = row.split()[4]
# if the number of occurrences of the first item (which is a team)... is equal to the length of the list of teams, then, all the players are from the same team. 
if teams.count(teams[0]) == len(teams):
    #same lines, but one indentation block due to the `if` condition. 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your question is not easy to answer but I will try. I made a few assumptions:</p>
<ul>
<li>I supposed that the overlap will happen only if they play in the same period</li>
<li>If the times recorded in the files is not in a format with one or two digits, it will consider it being zero (you may want to treat this case differently)</li>
<li>I supposed that a player may play more than one time in a period</li>
<li>I supposed that the period is a single digit and that I can compare the string value instead of the numerical value.</li>
</ul>
<p>Now the two files:</p>
<p><strong>2017020397.csv</strong></p>
<pre><code>LastName,StartTime,EndTime,Duration,Period,TeamAbbrev,Position
Bouwmeester,0:00,0:37,0:37,1,STL,D
Schwartz,0:00,0:40,0:40,1,STL,W
Foligno,0:00,0:40,0:40,1,MIN,W
Pietrangelo,0:00,0:48,0:48,1,STL,D
Suter,0:00,0:40,0:40,1,MIN,D
Staal,0:00,0:40,0:40,1,MIN,C
Niederreiter,0:00,0:40,0:40,1,MIN,W
Allen,0:00,20:00,20:00,1,STL,G
Steen,0:00,0:30,0:30,1,STL,W
Tarasenko,0:30,1:27,0:57,1,STL,W
Parayko,0:37,1:43,1:06,1,STL,D
</code></pre>
<p><strong>solution.py</strong></p>
<pre><code>import csv
import re
import itertools

pattern_time = r"(\d{1,2}):(\d{1,2})"
time_tester = re.compile(pattern_time)

def convert_to_seconds(time_string):
    ''' Convert a mm:ss string to seconds '''
    pattern_found = time_tester.match(time_string)
    if pattern_found:
        time_string_separated = pattern_found.group(1, 2)
        minutes, seconds = map(int, time_string_separated)
        return 60 * minutes + seconds
    else:
        # We have a problem
        return 0

file_name = '2017020397.csv'
teams = {}
number_of_players_to_compare = 3

with open(file_name, newline='') as source_file:
    csv_file = csv.DictReader(source_file)
    for row in csv_file:
        if row['TeamAbbrev'] not in teams:
            teams[row['TeamAbbrev']] = {}

        current_team = teams[row['TeamAbbrev']]
        if row['Period'] not in current_team:
            current_team[row['Period']] = {}

        current_team_period = current_team[row['Period']]
        if row['LastName'] not in current_team_period:
            current_team_period[row['LastName']] = []

        current_skater = current_team_period[row['LastName']]
        times_recorded = {'StartTime': convert_to_seconds(row['StartTime']), 
                          'EndTime': convert_to_seconds(row['EndTime'])}
        current_skater.append(times_recorded)

for (current_team_to_show, current_periods) in teams.items():
    current_periods_sorted = sorted(current_periods)
    for current_period_name in current_periods_sorted:
        print("\nFor team", current_team_to_show, "in period", current_period_name, ":")

        current_period = current_periods[current_period_name] 
        current_players = sorted(current_period)
        for current_player_combination in itertools.combinations(current_players, number_of_players_to_compare):
            total = 0
            for times_this_combination in itertools.product(*(current_period[x] for x in current_player_combination)):
                start_times = (x['StartTime'] for x in times_this_combination)
                end_times = (x['EndTime'] for x in times_this_combination)
                total += max(0, min(end_times) - max(start_times))

            print(" ".join(current_player_combination), total)
</code></pre>
<p>Here's some comment about how I did it:</p>
<ul>
<li>I have used a <a href="https://docs.python.org/3/library/csv.html#csv.DictReader" rel="nofollow noreferrer"><code>DictReader</code></a> so that I don't have to skip the first line and the be able to get each part of a row by its column name.</li>
<li>I have used a nested dictionary data structure to be able to recall the data. It a list of dictionary of recorded times inside a dictionary of players inside a dictionary of periods inside a dictionary of teams.</li>
</ul>
<p>If you have questions, don't hesitate to ask.</p>
</div>
<span class="comment-copy">You basically want the program to just <b>print</b> the multiple different players by their name , and by team ? Like, one line meaning one team ?</span>
<span class="comment-copy">I figured the <code>Output</code> would be the same, except the script would not pair opposing players together like the example of <code>Allen</code> and <code>Niederreiter</code>.</span>
<span class="comment-copy">Add after players.setdefaults another one players.setdefaults and append to the same list that above the row.split() but to the index [4] this time, and then compare each players teamAbbrev.  You can add on your line start, end, teamAbbrev = zip(t1, t2, t3).  You would have access to every teamAbbrev by then. Does that help you enough ?  You would then modify your if total:  to have one or more added condition to check the matching of the teamAbbrev.</span>
<span class="comment-copy">Is it possible for you to edit the code the way you are describing? I follow to a degree but I had a lot of help writing the main functionality of this script and I don't quite understand fully.</span>
<span class="comment-copy">I was just giving you a hint. I'm coding on my phone right now, and it appears to be difficult lol. I'll try give me a minute</span>
<span class="comment-copy"><code>teams = row.split(None, 3)[4] IndexError: list index out of range</code></span>
<span class="comment-copy">Yeah, sorry. I update. It's 6am here &lt;&lt;</span>
<span class="comment-copy">No worries, I appreciate the help!</span>
<span class="comment-copy">If I made another syntaxe error I&amp;#39;m sorry I&amp;#39;m tired I&amp;#39;m going to sleep, but you have essence of my ideas in the comment and in the example. I specify : these are 2 different methods. Especially with the comments haha</span>
<span class="comment-copy">Yeah that didn't do it either, thanks for trying!</span>
