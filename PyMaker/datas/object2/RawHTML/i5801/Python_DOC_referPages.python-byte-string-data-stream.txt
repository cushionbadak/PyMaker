<div class="post-text" itemprop="text">
<p>I am working in Python(3) on a Raspberry Pi 3.  My application is data acquisition and logging.  My question has to do with properly splitting and interpreting serial data received as byte strings:</p>
<p>Raw data continuously accumulated in and read from an input buffer over two or more non-queried (USB) serial ports are received in the following general form in my application.  The string tends to be much longer, but the following should be sufficient for an example:</p>
<blockquote>
<p><strong>b'+00000\r\n-00210\r\n+00360\r\n+00300\r\n-00163\r\n+00399\r\n'</strong></p>
</blockquote>
<p>I am using <strong>serial.read(serial.in_waiting)</strong> to receive the data.  I find this to be the best method, as my independent data sources are asynchronous, continuously spitting-out their values (approximately 50 samples per second) and have slightly differing data-broadcast rates (just enough to be a nuisance).</p>
<p>I have found that I cannot reliably use "readline()" to simplify my task for a few reasons, including - <em>and please do comment on this point if you have any insights on this</em> - the fact that, for whatever reason, the "in_waiting" value is not reset to zero on my system after a "readline()".</p>
<p>Unfortunately, the "in_waiting" approach often produces data, not so neatly terminated as shown above.  Possible variants, representing what might make it over the serial port on a given read attempt include:</p>
<blockquote>
<p><strong>b'+00000\r\n-00210\r\n+00360\r\n+00300\r\n-00163\r\n+003'</strong></p>
</blockquote>
<p>or</p>
<blockquote>
<p><strong>b'+00000\r\n-00210\r\n+00360\r\n+00300\r\n-00163\r'</strong></p>
</blockquote>
<p>or</p>
<blockquote>
<p><strong>b'+00000\r\n-00210\r\n+00360\r\n+00300\r\n-00163'</strong></p>
</blockquote>
<p>or</p>
<blockquote>
<p><strong>b'+00000\r\n-00210\r\n+00360\r\n+00300\r\n-'</strong></p>
</blockquote>
<p>That is, not all terminal data are fully-formed when they are read.</p>
<p>I have been attempting to use "decode" and "split" and "list" and "map" functions to interpret all available, <em>complete</em> data (those data that are properly terminated with \r\n) in order that I may do additional work with the numerical values on the fly. All the while, my intent is to retain any partial data that may have been received on the end of the read, so that they can be appended on the next read cycle.</p>
<p>My attempts have not met with success for all cases above, and that is why I am appealing to members more familiar with the Python programming language than I am for guidance.</p>
<p>Please kindly consider commenting on what would be the most efficient way (in Python) to:</p>
<p><strong>1.</strong> Get from data such as I show above into a list of integer values.</p>
<p><strong>2.</strong> Exclude incomplete, trailing data from the conversion, if it is not properly terminated.</p>
<p><strong>3.</strong> Retain any incomplete trailing data for appending on subsequent read.</p>
<p>If you have dealt with a circumstance like mine in the past, I am hoping to learn from your experience, as I continue exploring the matter on my own.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>[This is not an answer, but it was too long for a comment]</strong></p>
<p>Take everything I say with a grain of salt, I'm no expert, I'm just throwing some ideas around!</p>
<p>Are all <em>complete</em> values the same lenght? In that case you could dump it all into a <code>io.BytesIO</code> streams (<a href="https://docs.python.org/3/library/io.html#binary-i-o" rel="nofollow noreferrer">https://docs.python.org/3/library/io.html#binary-i-o</a>) and grab the next n bytes (where n = len(complete_value))?</p>
<p>You say you've tried solving this with <code>decode</code>, <code>split</code>, <code>list</code>, and <code>map</code>. Could you explain what you did exactly? Because I don't see what's wrong with something like:</p>
<pre><code>incomplete_value = b''
my_ints = []
while &lt;there_is_data&gt;:
    tmp = incomplete_value + get_my_data() # get a new batch of data and append it
    tmp_split = tmp.split(b'\r\n') # split the data on newlines
    complete_data = tmp_split[:-1] # get all but the last item
    incomplete_value = tmp_split[-1] # save the last item
    my_ints += [int.from_bytes(x) for x in complete_data] # creates a list of ints
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I will preface this "answer" to my own question with two things: <strong>(1)</strong> I am not 100% sure it's considered proper etiquette for me to do so.  If not, I ask others' pardon. And <strong>(2)</strong>, the solution I will post is still formative.  That is, it works, but I would really like to grasp a better, more concise and/or efficient method than my own.</p>
<p>That said, here's what I have done, stripped-down to the germane details and just a little contextual fluff:</p>
<p>For the benefit of the visitor to this little topic, I am reading data from a plurality of serial devices (<em>9600, 8N1 - not important</em>) in chunks having identical lengths - at least when they are complete, properly terminated.  The OP contains representative samples of the format.</p>
<p>To read and store the data, I am currently using :</p>
<pre><code>#ACQUIRE MOST-RECENT DATA
MRD1 = ser1.read(ser1.in_waiting)

#LOG RAW DATA IMMDEDIATELY
fil1.write(MRD1)
</code></pre>
<p>And, recall, originally I had assumed that reading full "lines" rather than strings of bytes would have been the preferred method, in order to avoid split entries, all the overhead, etc.  But no. There are all sorts of things to smack-down that naive assumption.  One of them is that "readline()" isn't clearing the "in_waiting" count in my case. No idea why. The other is that there seems to be no way to get the port or the connected device to report how many fully-terminated lines are in the queue. Is that even true? No idea.  Just haven't found a way.  So, <em>bytes</em> it is. Fine, I just want my doggone data, however I can get it, and to know that none of it will go AWOL.</p>
<p>So, I am doing the following with what I'm reading-in from the serial port to cope with all that I've murmured about:</p>
<pre><code>###        CONDITION FIRST CHANNEL BYTE-STRING DATA FOR ANALYSIS

#Decode to asii 
MRDs1 = MRD1.decode('ascii')

#Add previous non-terminated 'orphan' data to the recent chunk of data
S1 = orphan1 + MRDs1

#Normalize non-numeric characters to * delimiter. What a mess...
SD1 = S1.replace("\r\n","*").replace("\r","").replace("\n","").split("*")

#Assess data stream for new non-terminated entry
orphan1 = ""
if len(SD1[len(SD1)-1]) == 0:
    del SD1[len(SD1)-1]
elif len(SD1[len(SD1)-1]) &lt;6: #this '6' is only for my particular case.
    orphan1 = SD1.pop() #Is this the best way to knock-off orphan bytes?

#Check for meaningless/null leading data (might not even be necessary)
if len(SD1[0])&lt;6: #Same drill as above, but on the front end.
    del SD1[0] #Is this really how it's best done in python?

#Extract numerical integer value list
ND1 = list(map(int,SD1))
</code></pre>
<p>All inside of a main loop, of course.  From there, ND1 ("channel-1 new data" - I have up to four channels) gets shipped-off to a ring buffer for FFT (not what we're about here, but a great topic on its own).</p>
<p>So, what I'd really find instructive and what I'd surely appreciate, as will, I hope, other readers of this little topic, is if experienced community members can offer insights or suggestions in relation to what I've pasted-in above.  Criticisms absolutely appreciated as well. Throw tomatoes, as long as they're spherical. I'm a physicist.  Not a <em>real</em> coder. To be clear, yes, the approach is <em>working</em> now.  It never misses a data point. Sure, but is it optimal?  I have no idea.  Probably not.  Nothing I do is optimal.  Is it as fast as possible with Python?  I doubt it. Recall, I'm on a Raspberry Pi-3, so I am on a quest for efficiency. The same concern haunts my use of FFT (I'm using numpy rfft. Is that even good?) and my plot updates (Geez, my FFT plots in matplotlib seem slow.). At any rate, I think my Python skills are ripe for improvement.  Thanks, if you can help me do that.  In any event, I intend to post my/our complete code, for better or worse, at the conclusion of this thread, in the hopes of helping the next <em>unbeliever</em> get off of dead-center, where I endlessly dwell.  I'll give it a few days...</p>
</div>
<span class="comment-copy">I would expect you to have one layer which reads whatever is there, and another layer which gets complete lines. But I was thinking more of a character by character parser which appends bytes to the current line until it ends in '\r\n' then put it on a list of complete lines to be yielded.</span>
<span class="comment-copy">orangelnk, I appreciate the attention you've given and must apologize for a delay in coming back to my own question here.  Let me speak to your question.  Yes, all of the data coming through the serial stream are identical in length.  I find that useful, albeit inefficient. There is a sign character (+ or -) followed by five digits padded with zeroes where appropriate and there are what I interpret as two separate control sequences; '\r' and '\n'. I will post my own current solution as an "answer," which is evidently something distinct from a "comment."  Thank you, once again.</span>
