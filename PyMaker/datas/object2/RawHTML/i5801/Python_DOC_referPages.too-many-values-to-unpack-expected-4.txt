<div class="post-text" itemprop="text">
<p>I have this piece of basic code just trying to split a file into 4 lists. The .txt file is formatted as shown underneath the code, with spaces delimiting each number. The error appearing is 'ValueError: too many values to unpack (expected 4)'.</p>
<pre><code>file = open("myfreefall.txt","r")
for line in file:
     if not line.startswith('#'):
         v,a,t,y= line.split(' ')


#v  a  t  y
-0.10 -9.81 0.01 5500.00
-0.20 -9.81 0.02 5500.00
-0.29 -9.81 0.03 5500.00
-0.39 -9.81 0.04 5499.99
-0.49 -9.81 0.05 5499.99
-0.59 -9.81 0.06 5499.99
-0.69 -9.81 0.07 5499.98
-0.78 -9.81 0.08 5499.97
...
</code></pre>
<p>However I changed the code to be as shown below to test how many variables it was expecting, and the error changed to 'not enough values to unpack (expected 5, got 4)'. This doesn't make sense as now the code is unpacking the four variables I wanted! Any solutions/pointers would be much appreciated.</p>
<pre><code>file = open("myfreefall.txt","r")
for line in file:
     if not line.startswith('#'):
         v,a,t,y,test= line.split(' ')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As commenters have suggested, try printing the line to see the line that's actually causing a problem (but be sure to insert the print before the <code>line.split</code>). </p>
<p>The most likely problem is a blank line at the end, which is read as a newline character. If so the easiest solution is probably to tack on another condition to the if statement:</p>
<pre><code>file = open("myfreefall.txt","r")
for line in file:
     if not line.startswith('#') and line != '\n':
     # or, more robust:
     if not line.startswith('#') and len(line) == 4:
         v,a,t,y= line.split(' ')
</code></pre>
<p>Or with a try/except:</p>
<pre><code>file = open("myfreefall.txt","r")
for line in file:
    try:
       v,a,t,y= line.split(' ')
    except ValueError:
       continue
       # Skip over this line if the extraction fails
</code></pre>
<p>The second if-statement is more robust because it will only try to extract your four variables if there are exactly four list entries to work with. Any other case (more or fewer entries to extract from) will be ignored. You can tailor it a bit more to your needs, e.g. by changing it to 'len(line) &gt;= 4' if you wanted to allow longer lines to be read as well.</p>
<p>To be honest, I can't think of a particular advantage for the try/except variant, but since I just wrote it out I might as well leave it in. It might be a bit too robust, in fact, because it would also skip lines that cause ValueErrors for reasons <em>other</em> than there being too few entries to work with.</p>
<p>Your second attempt failing as you describe makes perfect sense. 
You're telling python to split a list of four entries into five variables, v, a, t, y and test. That's what the error is referring to when it says, 'expected 5, got 4'. The behaviour of your error probably changed because the code fails a lot sooner now. Before it was working for all lines except the last one, where there's only one list entry to use. With your change to five variables it's causing an error with the very first line, where there are four entries but now you're asking for five.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>The second error is correct</strong> since you're unpacking 5 values as per this line:</p>
<pre><code>v,a,t,y,test = line.split(' ')
#       ^^^^
</code></pre>
<p>Since each line when split will return 4 elements, a 5th value is non-existent, hence the error. Note that using unpacking this way can be problematic in the long run, particularly with many elements. It may be worth examining doing an explicit check on the length of the split line.</p>
<p>For your original problem, try using <code>line.split()</code> since this automatically splits on whitespace - i.e. it's possible that the space may be a tab, or one of the blank unicode characters (see: <a href="http://jkorpela.fi/chars/spaces.html" rel="nofollow noreferrer">http://jkorpela.fi/chars/spaces.html</a>).</p>
<p>Or, one could use a regex on the line which could simplify parsing the text:</p>
<pre><code>import re

regex = re.compile('([-+]?[0-9]*\.[0-9]+|[0-9]+)')  # regex for floating-point numbers
matches = regex.findall(line)  # `matches` will return a list
</code></pre>
</div>
<span class="comment-copy">why not just print line.split() to see how many you get?</span>
<span class="comment-copy">What line is it choking on? Try printing the line to see.</span>
<span class="comment-copy">Your text file is just not formatted consistently the way you think.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/errors.html#handling-exceptions" rel="nofollow noreferrer">Catch the error</a> and inspect/print relevant data in the except suite- like<code>line</code>. This should give you an idea of what is happening.</span>
