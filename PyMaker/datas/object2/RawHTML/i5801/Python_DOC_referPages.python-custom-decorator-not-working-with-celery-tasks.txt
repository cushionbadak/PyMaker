<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/13492603/celery-task-with-multiple-decorators-not-auto-registering-task-name">Celery task with multiple decorators not auto registering task name</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I'm having a bit of trouble with Python decorators. I've got a scenario set up like so:</p>
<pre><code>def decorated(func):
    def call_and_update(*args, **kwargs):
        # do some stuff here
        output = func(*args, **kwargs)
        # do more stuff here
        return output
    return call_and_update

@celery.task
@decorated
def testA():
    return "Test A"

@celery.task
@decorated
def testB():
    return "Test B"
</code></pre>
<p>For some reason, whichever function I call first seems to be persisted as the <code>func</code> in the decorator.</p>
<p>So for instance, if I start up a shell and run:</p>
<pre><code>&gt;&gt;&gt; testA()
Test A
&gt;&gt;&gt; testB()
Test A
</code></pre>
<p>or, if I restart the shell and start with the second test:</p>
<pre><code>&gt;&gt;&gt; testB()
Test B
&gt;&gt;&gt;&gt; testA()
Test B
</code></pre>
<p>I found <a href="https://stackoverflow.com/questions/6393879/celery-task-and-customize-decorator?noredirect=1&amp;lq=1">this question with a similar issue</a>, but the few answers revolved around using extended classes for the task methods instead.</p>
<p>If I specifically want to do this via decorators and functions, is there a trick to getting that to work?</p>
<p>Note that <em>without</em> the <code>@celery.task</code> decorator, the functions work as normal. It's specifically the combination of the two decorators that's causing an issue.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Each task needs to have a unique name <a href="http://docs.celeryproject.org/en/latest/userguide/tasks.html#names" rel="nofollow noreferrer">celery docs</a>, since it's not provided it is using the name of your wrapper function.</p>
<pre><code>@celery.task(name='test-A')
@decorated
def testA():
    return 'test A'

@celery.task(name='test-B')
@decorated
def testB():
    return 'test B'
</code></pre>
</div>
<span class="comment-copy">Are you seeing this behavior only when you use the celery-task decorator?</span>
<span class="comment-copy">@juanpa.arrivillaga correct. without the celery.task decorator, the functions work as normal.  (I'll make a note of this in the question)</span>
<span class="comment-copy">This is a duplicate. TLDR: use <code>functools.wraps()</code> so that the celery task can record the correct function name (otherwise all your tasks are named <code>call_and_update</code>).</span>
<span class="comment-copy">@MartijnPieters awesome, thanks! That works as well, and makes things even easier.</span>
<span class="comment-copy">Yep, that did it! Forgot about this - seems like it naturally defaults to the function name, but when the functions are surrounded by the extra <code>@decorated</code> decorator, they were all defaulting to that decorator function name instead. Thanks!</span>
<span class="comment-copy">@CaptainPlanet: You can also just use <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps</code></a> inside of your <code>decorated</code> function. This will make your decorated function "look" like the original by updating its name.</span>
