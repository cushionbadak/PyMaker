<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.pytest.org/en/latest/parametrize.html#pytest-mark-parametrize-parametrizing-test-functions" rel="nofollow noreferrer">pytest documentation</a>, I can generate combinations of multiple parametrized arguments as follows:</p>
<pre><code>@pytest.mark.parametrize("x", [0, 1])
@pytest.mark.parametrize("y", [2, 3])
def test_foo(x, y):
    pass
</code></pre>
<p>I can also apply marks to individual parameters as such:</p>
<pre><code>@pytest.mark.parametrize("test_input,expected", [
("3+5", 8),
("2+4", 6),
pytest.param("6*9", 42,
             marks=pytest.mark.xfail),
])
def test_eval(test_input, expected):
    assert eval(test_input) == expected
</code></pre>
<p>Is there a reasonable way to combine the two methodologies and apply a mark to a particular combination of parameters? For instance, can I apply a <code>pytest.mark.xfail</code> ONLY to the <code>test_foo</code> instance that gets generated with <code>x==0</code> and <code>y==2</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The approach I prefer is to generate my arguments through a simple helper function. Have a look at the following example:</p>
<pre><code>import pytest

def __get_param_xy__(x = [], y = [], xfail = []): # ugly demonstrator ...
    out_list = []
    for xx in x: # this could be a clever list comprehension ...
        for yy in y: # this one, too ...
            out_tup = (xx, yy)
            if out_tup in xfail: # the ones you expect to fail
                out_tup = pytest.param(*out_tup, marks = pytest.mark.xfail)
            out_list.append(out_tup)
    return out_list

@pytest.mark.parametrize('x,y', __get_param_xy__(
    x = [0, 1],
    y = [2, 3],
    xfail = [(0, 2)]
    ))
def test_foo(x, y):
    assert not (x == 0 and y == 2)
</code></pre>
<p>It still uses a single <code>parametrize</code> decorator, but it comes fairly close to what you want and is easy to read and understand.</p>
<hr/>
<p>EDIT (1): You can actually implement the helper function as a generator. The following works just fine:</p>
<pre><code>def __get_param_xy__(x = [], y = [], xfail = []): # ugly generator ...
    for xx in x: # this could be a clever list comprehension ...
        for yy in y: # this one, too ...
            out_tup = (xx, yy)
            if out_tup in xfail: # the ones you expect to fail
                out_tup = pytest.param(*out_tup, marks = pytest.mark.xfail)
            yield out_tup
</code></pre>
<hr/>
<p>EDIT (2): Since it has been asked in the comments, this can actually be generalized for an arbitrary number of parameters and does not conflict with fixtures. Check the following example:</p>
<pre><code>import pytest

class __mock_fixture_class__:
    def __init__(self):
        self.vector = []
    def do_something(self, parameter):
        assert parameter != (0, 2)
        self.vector.append(parameter)
    def fin(self):
        self.vector.clear()

@pytest.fixture(scope = 'function')
def mock_fixture(request):
    mock_fixture_object = __mock_fixture_class__()
    def __finalizer__():
        mock_fixture_object.fin()
    request.addfinalizer(__finalizer__)
    return mock_fixture_object

def __get_param_general_generator__(*_, **kwargs):
    xfail = kwargs.pop('xfail') if 'xfail' in kwargs.keys() else []
    arg_names = sorted(kwargs.keys())
    def _build_args_(in_tup = (), arg_index = 0):
        for val in kwargs[arg_names[arg_index]]:
            out_tup = (*in_tup, val)
            if arg_index &lt; len(arg_names) - 1:
                yield from _build_args_(out_tup, arg_index + 1)
            else:
                if out_tup in xfail:
                    out_tup = pytest.param(*out_tup, marks = pytest.mark.xfail)
                yield out_tup
    return ','.join(arg_names), _build_args_()

@pytest.mark.parametrize(*__get_param_general_generator__(
    x = [0, 1],
    y = [2, 3],
    xfail = [(0, 2)]
    ))
def test_foo_xy(mock_fixture, x, y):
    mock_fixture.do_something((x, y))

@pytest.mark.parametrize(*__get_param_general_generator__(
    x = [0, 1],
    y = [2, 3],
    z = [0, 1, 2],
    xfail = [(0, 2, 1)]
    ))
def test_bar_xyz(x, y, z):
    assert not (x == 0 and y == 2 and z == 1)
</code></pre>
<p><em>(Thanks to <code>yield from</code>, this is <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow noreferrer">Python 3.3 and above only</a>.)</em></p>
</div>
<span class="comment-copy">Thanks @s-m-e. This could work for the use case described, although the downside is it's not generalizable, say in the case that a fixture for "z" gets added</span>
<span class="comment-copy">@WillAyd Do you think so ;) ? See edit 2.</span>
