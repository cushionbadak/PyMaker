<div class="post-text" itemprop="text">
<p>I used to believe that <code>in</code> operator in Python checks the presence of element in some collection using equality checking <code>==</code>, so <code>element in some_list</code> is roughly equivalent to <code>any(x == element for x in some_list)</code>. For example:</p>
<pre><code>True in [1, 2, 3]
# True because True == 1
</code></pre>
<p>or</p>
<pre><code>1 in [1., 2., 3.]
# also True because 1 == 1.
</code></pre>
<p>However, it is well-known that <code>NaN</code> is not equal to itself. So I expected that <code>float("NaN") in [float("NaN")]</code> is <code>False</code>. And it is <code>False</code> indeed.</p>
<p>However, if we use <code>numpy.nan</code> instead of <code>float("NaN")</code>, the situation is quite different:</p>
<pre><code>import numpy as np
np.nan in [np.nan, 1, 2]
# True
</code></pre>
<p>But <code>np.nan == np.nan</code> still gives <code>False</code>!</p>
<p>How is it possible? What's the difference between <code>np.nan</code> and <code>float("NaN")</code>? How does <code>in</code> deal with <code>np.nan</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>To check if the item is in the list, Python tests for object identity <em>first</em>, and then tests for equality only if the objects are different.<sup>1</sup></p>
<p><code>float("NaN") in [float("NaN")]</code> is False because two <em>different</em> <code>NaN</code>  objects are involved in the comparison. The test for identity therefore returns False, and then the test for equality also returns False since <code>NaN != NaN</code>.</p>
<p><code>np.nan in [np.nan, 1, 2]</code> however is True because the <em>same</em> <code>NaN</code> object is involved in the comparison. The test for object identity returns True and so Python immediately recognises the item as being in the list.</p>
<p>The <code>__contains__</code> method (invoked using <code>in</code>) for many of Python's other builtin Container types, such as tuples and sets, is implemented using the same check. </p>
<hr/>
<p><sup>1</sup> At least this is true in CPython. Object identity here means that the objects are found at the same memory address: the <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c#L397-L407" rel="noreferrer">contains method for lists</a> is performed using <a href="https://github.com/python/cpython/blob/master/Objects/object.c#L710-L736" rel="noreferrer"><code>PyObject_RichCompareBool</code></a> which quickly compares object pointers before a potentially more complicated object comparison. Other Python implementations may differ.</p>
</div>
<div class="post-text" itemprop="text">
<p>One thing worth mentioning is that numpy arrays do behave as expected:</p>
<pre><code>a = np.array((np.nan,))
a[0] in a
# False
</code></pre>
<p>Variations of the theme:</p>
<pre><code>[np.nan]==[np.nan]
# True
[float('nan')]==[float('nan')]
# False
{np.nan: 0}[np.nan]
# 0
{float('nan'): 0}[float('nan')]
# Traceback (most recent call last):
#   File "&lt;stdin&gt;", line 1, in &lt;module&gt;
# KeyError: nan
</code></pre>
<p>Everything else is covered in @AlexRiley's excellent answer.</p>
</div>
<span class="comment-copy">Yupp. <code>nan = float("NaN"); nan in [nan]</code> gives <code>True</code>. Thanks!</span>
<span class="comment-copy">Is there any benefit of doing this (first identity then equality). Why not check equality directly? I am asking this because I always thought nan is the only object for which x is x holds true but x!=x. Seeing this I am wondering if there are others?</span>
<span class="comment-copy">@ayhan - Checking identity is a relatively cheap operation (just compare memory addresses). Checking equality may be arbitrarily expensive.</span>
<span class="comment-copy">@John A professor of mine used to say if it doesn't have to be correct I can make it arbitrarily fast. <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow noreferrer">The documentation</a> says for <code>x in s</code>: <code>True if an item of s is equal to x, else False</code>. Seems like a bug - whether documentation or implementation is up for debate. Considering the consequences, it should probably just be documented what the <code>in</code> operator actually does.</span>
<span class="comment-copy">@Voo since <code>nan</code> is the only thing that breaks this it is apparently not considered important enough. See the  <a href="https://www.python.org/dev/peps/pep-0754/#rejection-notice" rel="nofollow noreferrer">rejection notice</a> to PEP 754 <i>This PEP has been rejected. After sitting open for four years, it has failed to generate sufficient community interest.</i></span>
<span class="comment-copy">Interseting, that it works as expected even for <code>dtype=object</code>.</span>
<span class="comment-copy"><code>in</code> for NumPy arrays is <a href="https://github.com/numpy/numpy/blob/master/numpy/core/src/multiarray/sequence.c#L28-L46" rel="nofollow noreferrer">implemented</a> as <code>(array == item).any()</code> as your answer shows. I guess the developers were forced to chose this approach since NumPy arrays are not internally collections of references to objects and so ids cannot be compared.</span>
<span class="comment-copy">Yep, numpy appears to always compare by value: <code>a = np.array([None,[np.nan]]); a[1] in a</code> is also <code>False</code>.</span>
<span class="comment-copy">@AlexRiley actually, in the example I just gave we have <code>a[1] == [np.nan]</code> -&gt; <code>True</code> but <code>a == [np.nan]</code> -&gt; <code>array([False, False], dtype=bool)</code> which I do find puzzling. Can you explain that?</span>
<span class="comment-copy">As I said I think it's a bug. When arr==item is evaluated (item being [5]) then [5] is broadcast to something like (conceptually) [5, 5, 5] so the list-ness is lost in translation. I've opened an issue at the numpy tracker.</span>
