<div class="post-text" itemprop="text">
<p>I’m a student who is (trying) to write a python implementation the A* Algorithm. I know this question has been asked 100 times before, but there are some specifics of my situation I’m not fully understanding. </p>
<p>I have a weighted, non-directed graph with 10 nodes. My actual graph will have many more nodes. The graph is sorted as a 3 dimensional list. I’m pasting in some output of the program we wrote to generate the graph. </p>
<pre><code>Node 1 : [[8, 3], [9, 11], [2, 12], [3, 12], [7, 6]]
Node 2 : [[5, 6], [4, 3], [1, 12], [8, 11], [7, 1]]
Node 3 : [[6, 2], [1, 12], [5, 7], [9, 1]]
Node 4 : [[2, 3], [8, 2], [10, 5], [5, 10], [7, 4]]
Node 5 : [[2, 6], [4, 10], [3, 7], [7, 8]]
Node 6 : [[3, 2], [9, 10]]
Node 7 : [[2, 1], [4, 4], [5, 8], [1, 6], [8, 3]]
Node 8 : [[1, 3], [2, 11], [4, 2], [7, 3], [10, 4]]
Node 9 : [[1, 11], [6, 10], [3, 1]]
Node 10 : [[4, 5], [8, 4]]
</code></pre>
<p>In less readable format, the graph is stored as a 3 dimensional list. So for example, at index 0, there are connections to node 8,9,2,3 and 7. And the weight between node 8 and 0 is 3. The weight between node 0 and 9 and 11. I think you get the idea. </p>
<pre><code>myGraph = [[[8, 3], [9, 11], [2, 12], [3, 12], [7, 6]], [[5, 6], [4, 3], [1, 12], [8, 11], [7, 1]], [[6, 2], [1, 12], [5, 7], [9, 1]], [[2, 3], [8, 2], [10, 5], [5, 10], [7, 4]], [[2, 6], [4, 10], [3, 7], [7, 8]], [[3, 2], [9, 10]], [[2, 1], [4, 4], [5, 8], [1, 6], [8, 3]], [[1, 3], [2, 11], [4, 2], [7, 3], [10, 4]], [[1, 11], [6, 10], [3, 1]], [[4, 5], [8, 4]]]
</code></pre>
<p>So the challenge is finding a python implementation of A* that will accept a list as input, and output the optimal route. It seems like most graphs are built around a dictionary data type, but that isn’t my situation. </p>
<p>I’ve started to try to write my own version of A*, using the 3D list, but not had luck, as it’s a bit complex for me. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is untested pseudo-code to add detail to what @Luai Ghunim said.</p>
<p>First you can find a priority queue implementation already in the Python standard library as <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer">https://docs.python.org/3/library/heapq.html</a>.  That will store your <code>todo</code> list.</p>
<p>Second, the things that go into that queue need to sort nicely.  A trick for that is to use tuples with the first field being what you want the sorted on.  Like this:</p>
<pre><code>[estimated_total, node, cost]
</code></pre>
<p>You can make them look nice using <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">https://docs.python.org/3/library/collections.html#collections.namedtuple</a> to give the fields those names.  Let's assume that you haven't, but that's a personal choice.</p>
<p>Third you need to have a function to estimate from any node how far it will be to the end.  Let's call that <code>estimator(node)</code>.</p>
<p>And last we'll want a dictionary named something like <code>from_node</code> of how we got to a particular node.  It's entries will look like:</p>
<pre><code>node: {"from": prev_node, "cost": 6}
</code></pre>
<p>With that in mind, it should work something like this:</p>
<pre><code># Start with node 0 in our lookup.
from_node = {0: {"from_node": None, "cost": 0.0}}
# And in our todo.
todo = [[estimator(0), 0, 0.0]]
while 0 &lt; len(todo):
    (estimated_cost, node, cost) = heapq.heappop(todo)
    if cost == from_node[node]["cost"]:
        if node == target_node:
            # We have our answer and know that it is best.
            break
        else:
            for (next_node, next_cost) in my_graph[node]:
                total_cost = cost + next_cost
                if next_node in from_node:
                    if from_node[next_node]["cost"] &lt;= total_cost:
                        # We have a better path.
                        continue
                from_node[next_node] = {"from": node, "cost": total_cost}
                heapq.heappush(todo,
                    [total_cost + estimator(next_node), next_node, total_cost])
if target_node in from_node:
    reversed_path = []
    node = target_node
    while node is not None:
        reversed_path.append(node)
        node = from_node[node]["from"]
    # AND NOW reversed(reversed_path) IS YOUR ANSWER
else:
    # THERE IS NO ANSWER
</code></pre>
</div>
<span class="comment-copy">Use MinPriority queue . First insert all the succesors of the source node into queue. del min and then insert all his succesor,keep doing this until you find a solution , a while loop is better in this case.</span>
