<div class="post-text" itemprop="text">
<p>I've a class <code>CustomArray</code> similar to <code>numpy.ndarray</code>. It overloads a bunch of arithmetic operators like <code>__add__</code>, <code>__mul__</code> etc. Since people will most likely use it in conjunction with numpy I'm afraid that from time to time <code>numpy.ndarray</code> operators will be called instead of <code>CustomArray</code>. Worst thing is that they actually work and produce some unwanted result.</p>
<pre><code>a = np.array([1, 2, 3])
b = CustomArray([1, 2, 3])
c = a + b  # np.ndarray.__add__ will be called!
</code></pre>
<p>Is there a way to prevent that? So interpreter will either raise an error or will always prefer <code>CustomArray</code> operator overloads.</p>
</div>
<div class="post-text" itemprop="text">
<p>In NumPy 1.13, there's the new <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.classes.html#numpy.class.__array_ufunc__" rel="nofollow noreferrer"><code>__array_ufunc__</code> API</a>. This API is <strong>provisional</strong>, and backward compatibility is not yet guaranteed.</p>
<p><code>numpy.ndarray</code> delegates to NumPy ufuncs for its operators, and NumPy ufuncs will delegate to <code>__array_ufunc__</code> to implement ufunc behavior, if they find it. The rules for this skip <code>numpy.ndarray.__array_ufunc__</code>, so if you implement your own <code>__array_ufunc__</code>, it will always take priority when using your instances with NumPy arrays.</p>
<p>If you want to disable all ufuncs on your objects, you can set <code>__array_ufunc__ = None</code> on your class:</p>
<pre><code>class CustomArray(...):
    __array_ufunc__ = None
</code></pre>
<p>Alternatively, if you want to implement it, the signature is</p>
<pre><code>def __array_ufunc__(self, ufunc, method, *inputs, **kwargs)
</code></pre>
<p>where for the case you're interested in,</p>
<ul>
<li><code>ufunc</code> is the ufunc object (for example, <code>numpy.add</code> for <code>+</code>),</li>
<li><code>method</code> is <code>"__call__"</code>,</li>
<li><code>inputs</code> is the tuple <code>(left operand, right operand)</code>, and</li>
<li><code>kwargs</code> is empty.</li>
</ul>
<p>For more advanced cases, <code>method</code>, <code>inputs</code>, and <code>kwargs</code> may be different, so <code>return NotImplemented</code> if you don't want to deal with those cases.</p>
<p>As an example, if you want to overload <code>+</code> with NumPy arrays, you could write</p>
<pre><code>def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
    if ufunc is not numpy.add:
        return NotImplemented
    if method != "__call__":
        return NotImplemented
    if kwargs:
        return NotImplemented
    return my_addition_logic(*inputs)
</code></pre>
<p>You will also still need to implement <code>__add__</code>.</p>
</div>
<span class="comment-copy">Similar recent question (but no answers): <a href="https://stackoverflow.com/questions/47600049/can-binary-operator-methods-of-numpy-arrays-be-overridden-by-the-right-operand" title="can binary operator methods of numpy arrays be overridden by the right operand">stackoverflow.com/questions/47600049/â€¦</a></span>
<span class="comment-copy">No, there isn't. If the left-hand operand implements the method, it gets executed first.</span>
<span class="comment-copy">@jonrsharpe mb there is a way to modify <code>CustomArray</code> so that numpy will produce some reasonable error message.</span>
<span class="comment-copy">It's unclear what you'd consider <i>"some reasonable error message"</i>. Unless it is <a href="https://docs.python.org/3/library/constants.html#NotImplemented" rel="nofollow noreferrer"><code>NotImplemented</code></a> the other methods won't be called.</span>
<span class="comment-copy">Can't get it to work for some reason, does it work only if I subclass from np.ndarray?</span>
<span class="comment-copy">@DikobrAz: No, subclassing <code>numpy.ndarray</code> is specifically not a requirement.</span>
<span class="comment-copy">Got it working, thanks!</span>
