<div class="post-text" itemprop="text">
<p>This code pings various machines. Could you please help me change this code so if a process of pinging hangs for more then 7 seconds it shuts down and returns some flag?</p>
<p>(I'd like to pull various data from machines using WMI. For that I'll change ping function to something else. The issue is on some machines WMI is corrupted and process of pulling data hangs indefinitely. Timeout is needed.)</p>
<pre><code>import multiprocessing.dummy
import subprocess
import numpy as np
import time

start_time = time.time()

def ping(ipadd):
    try:
        response = subprocess.check_output(['ping', ipadd])
        return True
    except subprocess.CalledProcessError as e:
        return False
#print(ping('10.25.59.20'))
machine_names = \
'''
ya.ru
microsoft.com
www.google.com
www.amazon.com
www.nasa.com
'''.split()

np_machine_names = np.array(machine_names)
p = multiprocessing.dummy.Pool(7)
ping_status = p.map(ping, machine_names)
np_ping_status = np.fromiter(ping_status, dtype=bool)
print(*np_machine_names[np_ping_status], sep = '\n')


run_time = time.time() - start_time
print(f'Runtime: {run_time:.0f}')
</code></pre>
<p><strong>UPDATE</strong>:
While I appreciate for the tip on adding timeout to subprocess the question remains. How do I shutdown hanged function? Let's say I've changed pinging to pulling WMI data from a machine (this one pulls list of installed software from Windows machine). There is no subprocess to set timer on:</p>
<pre><code>#pip install pypiwin32
import win32com.client 
strComputer = "." 
objWMIService = win32com.client.Dispatch("WbemScripting.SWbemLocator") 
objSWbemServices = objWMIService.ConnectServer(strComputer,"root\cimv2") 
colItems = objSWbemServices.ExecQuery("Select * from Win32_Product") 
for objItem in colItems: 
    print( "Caption: ", objItem.Caption )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are several ways to tackle long running executions. Each way has its benefits and drawbacks.</p>
<p><strong>APIs</strong></p>
<p>As already suggested, the simplest ways is to rely on the APIs timeouts. Modules such as <code>subprocess</code>, <code>socket</code>, <code>requests</code> etc... expose timeout parameters within their APIs.</p>
<p>This is the preferable approach whenever feasible. </p>
<p><strong>Threads</strong></p>
<p>The long-running/hanging logic is executed within a separate thread. The main loop can continue undisturbed and ignore the hanging execution.</p>
<pre><code>import threading

TIMEOUT = 60

def hanging_function():
    hang_here()

thread = threading.Tread(target=hanging_function)
thread.daemon = True
thread.start()

thread.join(TIMEOUT)
if thread.is_alive():
    print("Function is hanging!")
</code></pre>
<p>One of the issue with this approach is that the hanging thread will continue to execute in the background consuming resources.</p>
<p>Another limitation is due to the fact that threads share memory. If your your function happens to crash badly it might affect your main execution as well.</p>
<p><strong>Processes</strong></p>
<p>My favourite approach is to execute the problematic logic in a separate process using the <code>multiprocessing</code> facilities. As processes do not share memory, whatever happens in the problematic function remains limited to the child process which you can terminate at any point in time.</p>
<pre><code>import multiprocessing

TIMEOUT = 60

def hanging_function():
    hang_here()

process = multiprocessing.Process(target=hanging_function)
process.daemon = True
process.start()

process.join(TIMEOUT)
if process.is_alive():
    print("Function is hanging!")
    process.terminate()
    print("Kidding, just terminated!")
</code></pre>
<p>The <a href="https://pypi.python.org/pypi/Pebble" rel="nofollow noreferrer">pebble</a> library was built on top of this principle. Allowing to easily separate problematic code and deal with failures and catastrophes. </p>
<p>The drawback of using processes is that they are a bit heavier than the other two approaches. Moreover, as memory between processes is isolated, it's a bit more complicated to share data. </p>
</div>
<div class="post-text" itemprop="text">
<p>use asyncio it's available in python since 3.5.4</p>
<p><a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio-task.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p><code>Popen</code> is a default choice when it comes to using <code>subprocess</code> module. It allows you to create a process and then read its stdout and stderr with specified timeout:</p>
<pre><code>def ping(ipadd):
    process = subprocess.Popen(['ping', ipadd])
    try:
        response, stderr_response = process.communicate(timeout=10)
        return True
    except subprocess.TimeoutExpired:
        return False
    finally:
        process.kill()
</code></pre>
<p>Also, beware that <code>ping</code> on a linux or osx may never exit and continue to ping so this is going to return false on these OSes:</p>
<pre><code>&gt;&gt;&gt; ping('127.0.0.1')
PING 127.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.058 ms
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.033 ms
...
64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.064 ms
64 bytes from 127.0.0.1: icmp_seq=9 ttl=64 time=0.031 ms
False
</code></pre>
</div>
<span class="comment-copy">Add <code>timeout</code> to your <code>subprocess.check_output</code> call, i.e. <code>response = subprocess.check_output(['ping', ipadd], timeout=7)</code>. Read more on <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer"><code>subprocess.check_output</code></a> in the official docs.</span>
<span class="comment-copy">@zwer: thanks! But Is there another way?</span>
<span class="comment-copy">Yes <a href="https://stackoverflow.com/a/44522570">there is</a>.</span>
<span class="comment-copy">another solution: <a href="https://stackoverflow.com/a/29495039/2978216">How can I abort a task in a multiprocessing.Pool after a timeout?</a></span>
<span class="comment-copy">Still, some questions remain. How do I get results and store them in a numPy array?</span>
<span class="comment-copy">In case of processes, you can see <a href="https://docs.python.org/3.6/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">how to share data between processes</a>. The link in your second comment points to this answer.</span>
<span class="comment-copy">I'm beginner and there are gaps in my knowledge of Python. No way I can understand that kinda doc</span>
<span class="comment-copy">managing subprocesses is complex.  and subtle.  pinging (or otherwise) servers has ethical and performance considerations.  it often necessary to throttle requests, so as not to be banned.</span>
<span class="comment-copy">I've added ping as an example. I don't want actually ping remote machines but to read their registry, pull WMI data, create shortcuts on desktop etc. To do this fast multiprocessing or asyncio module is needed. But killing process is considered to be a bad practice. I still haven't found an example how to do it on timeout</span>
<span class="comment-copy">Very nice tip. Thank you! :D But question remains.</span>
<span class="comment-copy">@user2978216 If you're talking about getting rid of a hanged process, well, <code>process.kill()</code> is doing exactly that thing.</span>
<span class="comment-copy">I'm sorry that I wasn't clear. I've added UPDATE section to my question. What if ping function were to change to something else and there is no subprocess in it?</span>
<span class="comment-copy">@user2978216 wow, that's another question entirely. In this case you should (a) look for timeouts in WMI calls, or (b) have separate timer threads in your child processes that will kill the process, or (c) give up using process pool and call <code>process.join(timeout)</code> on individual child processes.</span>
<span class="comment-copy">regarding (a) timeouts in WMI calls: if WMI on a remote machine is corrupted timeout doesn't trigger and call hangs indefinitely.</span>
