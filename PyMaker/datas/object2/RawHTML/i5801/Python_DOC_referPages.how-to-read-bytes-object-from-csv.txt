<div class="post-text" itemprop="text">
<p>I have used tweepy to store the text of tweets in a csv file using Python <code>csv.writer(</code>), but I had to encode the text in utf-8 before storing, otherwise tweepy throws a weird error.</p>
<p>Now, the text data is stored like this:</p>
<pre><code>"b'Lorem Ipsum\xc2\xa0Assignment '"
</code></pre>
<p>I tried to decode this using this code (there is more data in other columns, text is in 3rd column):</p>
<pre><code>with open('data.csv','rt',encoding='utf-8') as f:
    reader = csv.reader(f,delimiter=',')
    for row in reader:
        print(row[3])
</code></pre>
<p>But, it doesn't decode the text. I cannot use <code>.decode('utf-8')</code> as the csv reader reads data as strings i.e. <code>type(row[3])</code> is <code>'str'</code> and I can't seem to convert it into <code>bytes</code>, the data gets encoded once more!</p>
<p>How can I decode the text data? </p>
<p>Edit: Here's a sample line from the csv file:</p>
<pre class="lang-none prettyprint-override"><code>67783591545656656999,3415844,1450443669.0,b'Virginia School District Closes After Backlash Over Arabic Assignment: The Augusta County school district in\xe2\x80\xa6  | @abcde',52,18
</code></pre>
<p>Note: If the solution is in the encoding process, please note that I cannot afford to download the entire data again.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your input file really contains strings with Python syntax <code>b</code> prefixes on them, one way to workaround it (even though it's not really a valid format for csv data to contain) would be to use Python's <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a> function @Ryan mentioned although I would use it in a slightly different way, as shown below. </p>
<p>This will provide a safe way to parse any strings that are in the file that have had the <code>b'</code> byte-string prefix added to them. The rest of the fields will be passed through unchanged.</p>
<pre><code>import ast
import csv


def _parse_bytes(field):
    """ Convert string represented in Python byte-string literal syntax into a
    decoded character string. Other field types returned unchanged.
    """
    result = field
    try:
        result = ast.literal_eval(field)
    finally:
        return result.decode() if isinstance(result, bytes) else field

def fix_bytes(filename, delimiter=','):
    with open(filename, 'rt') as f:
        yield from (delimiter.join(_parse_bytes(field)
                                        for field in line.split(delimiter))
                                            for line in f)

filename = 'bytes_data.csv'
reader = csv.reader(fix_bytes(filename))
for row in reader:
    print(row[3])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a> to convert the incorrect fields back to bytes safely:</p>
<pre><code>import ast


def _parse_bytes(bytes_repr):
    result = ast.literal_eval(bytes_repr)

    if not isinstance(result, bytes):
        raise ValueError("Malformed bytes repr")

    return result
</code></pre>
</div>
<span class="comment-copy">Please show at least one complete line from your file exactly as it appears if you open that file in a text editor. We can't reproduce your problem without both your code and your data.</span>
<span class="comment-copy">I'm sorry. I have added an example. Save that line in a file with .csv extension.</span>
<span class="comment-copy">So the csv file literally has strings in it which are represented with a <code>b</code> prefix on them, like the <code>b'Virginia...'</code>?</span>
<span class="comment-copy">Whatever produced that CSV is broken and should be repaired.</span>
<span class="comment-copy">Thank you. This does solve the case above, but I don't feel comfortable using eval().  It even fails on my file, as it has header strings.</span>
<span class="comment-copy">gitmorty: I think @Ryan's idea of using <code>ast.literal_eval()</code> instead of <code>eval()</code> is a good one and have incorporated the basic idea into my own answerâ€”which I think addresses both the issues you mentioned in your comment.</span>
