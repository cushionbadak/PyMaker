<div class="post-text" itemprop="text">
<p>I have a CSV file which has a date column with some dirty data i.e. dates stored in different formats (US and UK). I'd like to create another CSV file with the dates converted so they are consistently stored in the UK format enabling me to import correctly into my SQL database. <a href="https://i.stack.imgur.com/4xo8d.png" rel="nofollow noreferrer"><img alt="CSV with 'Date' column to be converted" src="https://i.stack.imgur.com/4xo8d.png"/></a></p>
<p>I'd like the dates to be converted to the following format:</p>
<p>'05-12-2017'
'07-11-2017'
'24-04-1999'
'28-01-1987'..</p>
<p>I tried the following code:</p>
<pre><code>df = F.pd.read_csv('Book1.csv', parse_dates = [0], dayfirst = True)
df['Date'] = df['Date'].apply(F.pd.to_datetime, format = '%m/%d/%Y')
df['date_eu'] = df['Date'].dt.strftime('%m-%d-%Y')
df
</code></pre>
<p>, but it throws an error while trying to convert the US dates</p>
<blockquote>
<pre><code>ValueError: time data '20/01/2018' does not match format '%m/%d/%Y' (match)
</code></pre>
</blockquote>
<p>Can someone please help?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a Try-Parse-Else-Approach:</p>
<pre><code>from datetime import datetime

def normalizeDateString(ds):
``` normalizes a date of format "d / d / dddd " to "dd/dd/dddd" ```
    sp = ds.replace(" ","").split("/")
    if len(sp[0])==1:
        sp[0]="0"+sp[0]
    if len(sp[1])==1:
        sp[1]="0"+sp[1]

    return sp[0]+"/"+sp[1]+"/"+sp[2]

def parseDT(dateString):
''' parses "dd/dd/yyyy" as US (month/day/year). Fallback to (day/month/year) on error'''
    try:
        repl =  normalizeDateString(dateString)        
        return datetime.strptime(repl, "%m/%d/%Y").date()
    except:
        return datetime.strptime(repl, "%d/%m/%Y").date()


print(parseDT("14/12/2018"))
print(parseDT("2/5/2018")) # ok for US
print(parseDT("22/5/2018")) # not ok for US
print(parseDT("12/2/2018"))
print(parseDT("2/1/2018"))
</code></pre>
<p>Output:</p>
<pre><code>2018-12-14
2018-02-05  # US ok
2018-05-22  # EN by except
2018-12-02
2018-02-01
</code></pre>
<p>HTH</p>
</div>
<span class="comment-copy">"it throws an error" -- is there a stack trace that you can <a href="https://stackoverflow.com/posts/47654716/edit">add</a> to your question?</span>
<span class="comment-copy">If your input data is mixed format dates - how do you know when it's one format or another to start with?</span>
<span class="comment-copy">4/24/1999 is unique, but what about 05/12/2017  that could be 5th Dec or 12th Mai - not unique. The error probably stems from trying to parse 4/24/1999 with %m - %m needs zero padded months, see <a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior" rel="nofollow noreferrer">python3ref:strptime</a></span>
<span class="comment-copy">You need to use additional information from table (if there's so) to define to what country date belongs to. Because what about such cases 01/01/2017?</span>
<span class="comment-copy">The error is: <code>ValueError: time data '20/01/2018' does not match format '%m/%d/%Y' (match)</code>. I agree with the comments..the error stems from trying to convert the American date formats since the month falls out of range. There isn't any additional info in the table to determine which region the date belongs to. I was hoping that I could somehow use Python to apply a rule which would try to interpret dates in the UK format dd/mm/yyyy by default (eg. '05/12/2017' should be interpreted as 5th Dec 2017)</span>
<span class="comment-copy">This works exactly as I need! Thanks a lot!</span>
<span class="comment-copy">One quick question though, how can I apply this function to a date column in a dataframe. When I do the following I get an error that <b>'Series' object has no attribute 'split'</b> <code>df = pd.read_csv('Book1.csv') df['Date'] = parseDT(df['Date'])</code></span>
<span class="comment-copy">I am not much into df - but this line <code>df['Date'].apply(F.pd.to_datetime, format = '%m/%d/%Y')</code> looks as if you apply a function to each value in the series , does replacing <code>F.pd.to_datetime</code> by <code>parseDT</code> and omitting <code>format = ... </code> work?</span>
<span class="comment-copy">@V.Asher see comment before &amp;&amp; <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html" rel="nofollow noreferrer">pandas.pydata.org/pandas-docs/stable/generated/â€¦</a>   - try <code>df['Date'].apply(parseDT)</code></span>
<span class="comment-copy">Thanks, this works. I had to make a small tweak in the <code>normalizeDateString()</code> and <code>parseDT()</code> functions to account for nulls (missing dates) and then apply the function to the dataframe column as <code>df['Date'].apply(parseDT)</code>. Thanks!</span>
