<div class="post-text" itemprop="text">
<p>I am trying to find the nearest points in a dictionary to every other point. In this dict, the keys are point coordinates, which look like this </p>
<pre><code>print d1
{(1, 1): 0, (2, 1): 1, (3, 1): 2, (10, 41):3}
</code></pre>
<p>The output here should be another dictionary with the keys as each position and the values being a list of nearby points. A nearby point is defined as being <code>+/- 1</code> away from any other point (if there are no nearby points, then something like "nan" can be set as a value).</p>
<p>For example, the output here should look like this:</p>
<pre><code>{(1, 1): [(2,1)], (2, 1): [(1,1), (3,1)], (3, 1): [(2,1)], (10, 41): nan}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use list comprehension to iterate over the keys and values of the original dictionary and search for similar keys in the dictionary. Lasting, simple filtering will create <code>"nan"</code> if no result is found for any key:</p>
<pre><code>d = {(1, 1): 0, (2, 1): 1, (3, 1): 2, (10, 41):3}
new_d = {a:[c for c, b in d.items() if any(abs(i-a[0]) == 1 or abs(i-a[-1])==1 for i in c) and c != a] for a, h in d.items()}
final_d = {a:"nan" if not b else b for a, b in new_d.items()}
</code></pre>
<p>Alternative solution with <code>math.hypot()</code>:</p>
<pre><code>import math
new_d = {a:[c for c, b in d.items() if math.hypot(a[0]-c[0], a[1]-c[1])&lt;= 1 and c != a] for a, h in d.items()}
final_d = {a:"nan" if not b else b for a, b in new_d.items()}
</code></pre>
<p>Output:</p>
<pre><code>{(3, 1): [(2, 1)], (10, 41): 'nan', (1, 1): [(2, 1)], (2, 1): [(3, 1), (1, 1)]}
</code></pre>
</div>
<span class="comment-copy">Welcome to Stack Overflow! You seem to be asking for someone to write some code for you. Stack Overflow is a question and answer site, not a code-writing service. Please <a href="http://stackoverflow.com/help/how-to-ask">see here</a> to learn how to write effective questions.</span>
<span class="comment-copy">Can't seem to get your output. Result I get is the following:   <code>{(1, 1): [(3, 1), (10, 41), (2, 1)],  (2, 1): [(3, 1), (10, 41), (1, 1)],  (3, 1): [(10, 41), (1, 1), (2, 1)],  (10, 41): [(3, 1), (1, 1), (2, 1)]}</code></span>
<span class="comment-copy">Aside from you answering a very poor question, your answer doesn't make sense. If the keys are point coordinates, seems like one would need to use something like <a href="https://docs.python.org/3/library/math.html#math.hypot" rel="nofollow noreferrer"><code>math.hypot()</code></a> to determine the Euclidean distances between them (which would necessary for determining "nearness").</span>
<span class="comment-copy">@user3067923 that is odd, I did not receive <code>{(1, 1): [(3, 1), (10, 41), (2, 1)], (2, 1): [(3, 1), (10, 41), (1, 1)], (3, 1): [(10, 41), (1, 1), (2, 1)], (10, 41): [(3, 1), (1, 1), (2, 1)]}</code> when I ran this code. Did you run exactly the code posted above?</span>
<span class="comment-copy">@martineau good idea regarding <code>math.hypot</code>. I overlooked the notion of Euclidean distance in the OP's post. Please see my recent edit.</span>
<span class="comment-copy">Somewhat of an improvement, however the math is wrong. You need to pass it the difference in x values and y values of each pair of points. I.E. the distance between points <code>p1</code> and <code>p2</code> would be <code>hypot(p2[0]-p1[0], p2[1]-p1[1])</code>. You  also don't need all those <code>abs()</code> calls because the distances returned will always be non-negative values due to the <code>sqrt()</code> involved (within <code>math.hypot()</code>.</span>
