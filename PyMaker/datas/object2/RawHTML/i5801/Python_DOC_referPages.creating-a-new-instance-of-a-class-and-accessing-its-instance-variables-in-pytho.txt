<div class="post-text" itemprop="text">
<p>So, I'm building a turing machine in Python, and I've gotten to a point where I need to instantiate my Turing Machine class inside of my parser, but I can't seem to get the syntax right. </p>
<p>Here is the way I'm  defining my TM:</p>
<pre><code>class TM(object):
def __init__(self, states, start, accept, reject, alpha, tAlpa, tape, 
transition, head):
    self.states = []
    self.start = start
    self.accept = accept
    self.reject = reject
    self.alpha = []
    self.tAlpha =[]
    self.tape = LinkedList(tape)
    self.transitions = []
    self.head = head
    return;
</code></pre>
<p>So I need to create an instance in my Parser class:
for example: </p>
<pre><code>class Parser:
*some other logic*

tm = TM()
tm.states.append(something)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Very quick example to show you the effect of required positional arguments:</p>
<pre><code>&gt;&gt;&gt; class Temp:
    def __init__(self, **kwargs):
        if kwargs:
            self.temp = kwargs['temp']


&gt;&gt;&gt; t = Temp()
&gt;&gt;&gt; class Temp2:
    def __init__(self, opt1 = None, opt2 = None):
        self.opt1 = opt1
        self.opt2 = opt2


&gt;&gt;&gt; t2 = Temp2()
&gt;&gt;&gt; class Temp3:
    def __init__(self, req, opt1 = None, opt2 = None):
        self.req = req
        self.opt1 = opt1
        self.opt2 = opt2


&gt;&gt;&gt; t3 = Temp3()
Traceback (most recent call last):
  File "&lt;pyshell#16&gt;", line 1, in &lt;module&gt;
    t3 = Temp3()
TypeError: __init__() missing 1 required positional argument: 'req'
&gt;&gt;&gt; 
</code></pre>
<p>In the first class, <code>**kwargs</code> allows me to instantiate and pass any keyword arguments I want. This is a week example, but gets the point across that you can do some initialization checks for existance and then subchecks for key names.</p>
<p>In the second class, by using <code>... = None</code> I default the parameter if it isnt supplied. So again, the interpreter is happy because all the parameters received a value!</p>
<p>In the last class, we see the error. Notice that <code>req</code> is not defined with a default value. Thus the interpreter demands it receive one to instantiate it. When I dont supply it, you get the <code>TypeError</code> telling you so. </p>
<p>In short, without properly instantiating a class, you wont be able to access any of its attributes or use its member functions!</p>
<p><strong>Edit:</strong> Wanted to explain it in more detail</p>
<p>Further, in OOP/D, try to find ways to steer clear of long <code>__init__()</code> function headers. Try something like this instead:</p>
<pre><code>&gt;&gt;&gt; class TM:
    def __init__(self, **kwargs):
        init_args = {'states': [],
                 'start': None,
                 'accept': None,
                 'reject': None,
                 'alpha': [],
                 'tAlpha': [],
                 'tape': None, # make later
                 'transitions': [],
                 'head': None}
        for arg, default in init_args.items():
            setattr(self, arg, kwargs.get(arg, default))


&gt;&gt;&gt; tm = TM()
</code></pre>
<p>Again, using the <code>**kwargs</code> to determine when I want to supply values to the object at initialization, but I default it using a pre-defined listing! Breaking it down some:</p>
<p><code>init_args</code> is a ready made dictionary (just like <code>kwargs</code>. Dont let the <code>**</code> scare you, its just the dictionaries <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">unpacking operator</a>. Lists have one as well, its literally one <code>*</code>.</p>
<p><code>for arg, default ... setattr(self, arg, kwargs.get(arg, default))</code> iterates over our pre-defined arguments container, and then creates a <code>self.[insert_arg]</code> attribute with the value from <code>kwargs.get()</code>. It looks for <code>arg</code> and if it doesnt find it, uses <code>default</code> which we already have!</p>
<p>So later when you want to do you single attribute accessing in your <code>Parser</code> class:</p>
<pre><code>&gt;&gt;&gt; class TM:
    def __init__(self, **kwargs):
        init_args = {'states': [],
                 'start': None,
                 'accept': None,
                 'reject': None,
                 'alpha': [],
                 'tAlpha': [],
                 'tape': None, # make later
                 'transitions': [],
                 'head': None}
        for arg, default in init_args.items():
            setattr(self, arg, kwargs.get(arg, default))


&gt;&gt;&gt; tm = TM()
&gt;&gt;&gt; tm.states.append('it works!')
&gt;&gt;&gt; tm.states
['it works!']
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">What code do you have thus far, and what errors is Python throwing?</span>
<span class="comment-copy">When I try and instantiate it like the above example, it asks for arguments to it, but all I need is to be able to access the instance variables of the TM class.</span>
<span class="comment-copy">You've defined a heck of a lot of <b><i>required</i></b> parameters in your <code>__init__()</code>. So of course when you dont supply them, you cant instantiate the object!</span>
<span class="comment-copy">It just clicked... I've been looking at it wrong. Thank you!</span>
