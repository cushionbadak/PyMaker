<div class="post-text" itemprop="text">
<p>
I want to store an array of epoch time as numpy array of dtype32. I expect to lose accuracy, but not 30 seconds difference!</p>
<pre><code>np.float64(np.float32((time.time()))) - time.time()
</code></pre>
<p>
Can someone explain what is happening? How can I store epoch time as float32 without losing accuracy?</p>
</div>
<div class="post-text" itemprop="text">
<p>Seconds since epoch is a big number. Currently, it's about 1.5e9. You get precision errors that are in the 10s at this range.</p>
<p>First off, you're calling <code>time.time()</code> twice, which is exacerbating the time difference---the methods obviously take time to call. The better way to see your error would be to store the time:</p>
<pre><code>&gt;&gt;&gt; import time
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; t = time.time()
&gt;&gt;&gt; np.float32(t) - t
62.610707998275757
</code></pre>
<p>You can see the actual decimal number stored by getting the string representation from numpy:</p>
<pre><code>&gt;&gt;&gt; t
1512746305.389292
&gt;&gt;&gt; np.float32(t).astype(str)
'1512746368.0'
</code></pre>
<p>Remember, a digit is not a bit---just 0s and 1s are bits. In a 32-bit float, you're storing the number in scientific notation, but in binary. This kills the accuracy. The range of values expressible as a 32-bit float is -3.4e38 to +3.4e38. There are 2^32 numbers expressible with 32 bits...so clearly, you're missing a ton of (infinitely many...) possible numbers in the 32-bit float range.</p>
<p>There are two super easy solutions. </p>
<p>First, if you don't care about sub-seconds...then just store it as an integer. Epoch time won't even hit 32-bit max until 2038. (Hello to SO users in 2037 worried about the <a href="https://en.wikipedia.org/wiki/Year_2038_problem" rel="nofollow noreferrer">Year 2038 Problem</a>. Is Wikipedia still a thing?)</p>
<pre><code>&gt;&gt;&gt; np.int32(t) - t
-0.38929200172424316
</code></pre>
<p>Of course if you want some more decimal precision...multiply by 10, or 100, or 1000 before casting as an int. Well, you can accumulate errors doing this but with 64-bit floats you should be okay.</p>
<p>The second way to deal with this is to just store a new epoch time, and take the difference with the times you want to save in the array. The error with these smaller numbers will be far into the decimal range.</p>
<pre><code>&gt;&gt;&gt; new_epoch = time.time()
&gt;&gt;&gt; t = time.time() - new_epoch
&gt;&gt;&gt; np.float32(t) - t
-2.384185791015625e-07
</code></pre>
<p>Then just save <code>new_epoch</code> in 64-bit glory along with your 32-bit float array of times so you know how to convert back.</p>
<p>However, do note that, from the <a href="https://docs.python.org/3/library/time.html#time.time" rel="nofollow noreferrer">Python <code>time</code> module docs</a>:</p>
<blockquote>
<p>even though the time is always returned as a floating point number, not all systems provide time with a better precision than 1 second.</p>
</blockquote>
<p>Also I do highly recommend David Goldberg's famous article <a href="https://orion.math.iastate.edu/alex/502/doc/p5-goldberg.pdf" rel="nofollow noreferrer">What every computer scientist should know about floating-point arithmetic</a>. Even just the first few pages give a great overview on floating-point arithmetic and how to calculate the size of your approximation errors!</p>
</div>
<span class="comment-copy">How exactly do you expect to store a 32-bit Integer in a 32-bit float without losing precision?</span>
<span class="comment-copy">Is there anyway I can retain accuracy at the seconds level? I don't mind losing precision in the sub-seconds (decimals). Also, the number is around 1.5e9, I thought this could be stored accurately in a float32?</span>
<span class="comment-copy">There's plenty of numbers that floats just CAN NOT store with full precision, even before you get into the realm of serious inaccuracy.  Not to mention the fact you're comparing two different calls of <code>time.time()</code>, which are already going to have some sub-second differences just due to execution order.</span>
<span class="comment-copy">@Zinki <code>time.time()</code> returns a 64-bit float, not a 32-bit int, btw. <code>type(time.time()) = &lt;class 'float'&gt;</code></span>
<span class="comment-copy">"Also, the number is around 1.5e9, I thought this could be stored accurately in a float32?" who gave you that idea? You can't store 1/3 accurately in a float! If you don't care about subseconds, then why not just use integers?</span>
