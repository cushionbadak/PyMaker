<div class="post-text" itemprop="text">
<p>To begin with, I am working to a get a desired output like this:</p>
<pre><code>*********************************************************************
                                 hello
********************************************************************* 
</code></pre>
<p>To achieve this I have assigned the <strong>desired output to a variable with multiline string</strong> and printing the same with <em>format</em>.</p>
<pre><code>$ cat varibale.py 
decorator = """ **********************************************************************
                               {}
            ********************************************************************** """
print(decorator.format("hello"))
</code></pre>
<p>Output:</p>
<pre><code>**********************************************************************
                               hello
            **********************************************************************
</code></pre>
<p>The issue with above approach is the <strong>extra spaces in the third line of output</strong> which is looking odd.</p>
<p><strong>I am able to achieve this in the following way</strong>:</p>
<pre><code>$ cat varibale.py 
decorator = """ **********************************************************************
                             {}
********************************************************************* 
"""
print(decorator.format("hello"))
</code></pre>
<p>Output: </p>
<pre><code> **********************************************************************
                             hello
********************************************************************* 
</code></pre>
<p>But this way my code doesn't look good, as it is not following the indentation.</p>
<p>Please suggest the right way to achieve the desired output.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to make multi-line literal strings look good is to use a backslash to escape the newline, like this:</p>
<pre><code>s = '''\
*********************************************************************
                                 hello
*********************************************************************
'''
print(s)
</code></pre>
<p><strong>output</strong></p>
<pre><code>*********************************************************************
                                 hello
*********************************************************************
</code></pre>
<p>However, PEP-008 discourages backslash usage like that. It's too fragile:  if there's a space between the backslash and the newline then the newline won't get escaped, and the backslash will get printed.</p>
<p>A more versatile approach is to use a function which calculates the amount of padding required to centre the text, and applies it via a nested formatting specifier. For example:</p>
<pre><code>def banner(s, width=69):
    stars = '*' * width
    pad = (width + len(s)) // 2
    return '{0}\n{1:&gt;{2}}\n{0}'.format(stars, s, pad)

print(banner('hello'))
print(banner('Hello, world', width=16))
</code></pre>
<p><strong>output</strong></p>
<pre><code>*********************************************************************
                                hello
*********************************************************************
****************
  Hello, world
****************
</code></pre>
<hr/>
<h3>How it works</h3>
<p>That format string is a little dense, so I guess I should try to explain it. ;) For full information on this topic please see <a href="https://docs.python.org/3/library/string.html#format-string-syntax" rel="noreferrer">Format String Syntax</a> in the docs. The explanation below borrows from &amp; paraphrases those docs.</p>
<pre><code>'{0}\n{1:&gt;{2}}\n{0}'.format(stars, s, pad)
</code></pre>
<p>The stuff enclosed in <code>{}</code> in a format string is called a "replacement field". The first item in a replacement field is the optional field name. This lets us identify which arg of <code>.format</code> goes with this replacement field. There are a couple of possible variations for field names, this format string uses numeric names, so it identifies the <code>.format</code> args by their position. That is, 0 corresponds to <code>stars</code>, 1 corresponds to <code>s</code> and 2 corresponds to <code>pad</code>. </p>
<p>If no field names are given they get automatically filled by the numbers 0, 1, 2, ... etc (unless you're using Python 2.6, where field names are mandatory). That's quite useful most of the time, so most format strings don't bother using field names.</p>
<p>After the field name we can give a "format specifier" or "format spec" which describes how the value is to be presented. A colon <code>:</code> separates the field name from the format spec. If you don't supply a format spec then you get a default one, and most of the time that's adequate. But here we do want a little more control, so we need to supply a format spec.</p>
<p>In a form spec the <code>&gt;</code> sign forces the field to be right-aligned within the available space. After the alignment sign we can provide a number to specify the minimum field width; the field will automatically be made larger if necessary. </p>
<p>For example, <code>'{0:&gt;6}'.format('test')</code> says to put argument 0 ('test') in a space that's at least 6 chars wide, aligned to the right. Which results in the string <code>'  test'</code>.</p>
<p>But a format spec can actually contain a whole new replacement field! This allows us to supply a variable to control the field width. So in my format string <code>{1:&gt;{2}}</code> says to put arg 1 here (<code>s</code>), right aligned in a field with a width given by arg 2 (<code>pad</code>). Only one level of replacement field nesting is permitted, but it's hard to think of a situation where you'd actually want deeper nesting.</p>
<p>So putting it all together: <code>'{0}\n{1:&gt;{2}}\n{0}'</code> tells <code>.format</code> to build a string that starts with arg 0 (<code>stars</code>) using the default format spec, followed by a newline, followed by arg 1 (<code>s</code>) right aligned in a field of width <code>pad</code>, followed by another newline, finally followed by arg 0 (<code>stars</code>) again.</p>
<p>I hope that made enough sense. :)</p>
<hr/>
<p>In Python 3.6+, we could use an f-string:</p>
<pre><code>def banner(s, width=69):
    stars = '*' * width
    pad = (width + len(s)) // 2
    return f'{stars}\n{s:&gt;{pad}}\n{stars}'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you could proceed for example as:</p>
<pre><code>print('*'*80)
print('{msg:^80s}'.format(msg = 'HELLO')) #^ centers the message
print('*'*80)
</code></pre>
<p>or if you want to have the text-width dynamic:</p>
<pre><code>def fn(msg, w = 80):
    delim = '*'*w
    fmt = '{msg:^%ds}'%w

    print(delim)
    print(fmt.format(msg=msg))
    print(delim)

fn('hello')
</code></pre>
<p>or slightly generalized version should you need to write to a file:</p>
<pre><code>import sys

def fn(msg, w = 80, F = sys.stdout):
    delim = '*'*w
    fmt = '{delim:s}\n{msg:^%ds}\n{delim:s}\n'%w
    F.write(fmt.format(delim = delim, msg = msg))

fn('hello')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe :</p>
<pre><code>print '*' * 80 + '\n' + ' ' * 38 + 'hello' + '\n' + '*' *80
</code></pre>
<p>OR
If it is python3</p>
<pre><code>a = lambda x,c,mess: print(c*x + ('\n' if not mess else mess))
a(80, '*', None)
a(38, ' ', 'Hello')
a(80, '*', None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way would be to use the <a href="https://docs.python.org/3.1/library/textwrap.html" rel="nofollow noreferrer">textwrap</a> module</p>
<pre><code>import textwrap

decorator = """\
            ****
            {0}
            ****"""

print(textwrap.dedent(decorator.format("hello")))
</code></pre>
</div>
<span class="comment-copy">could you please explain the logic used here " {0}\n{1:&gt;{2}}\n{0}"</span>
<span class="comment-copy">@Here_2_learn Sure. Please see my update.</span>
<span class="comment-copy">Thanks for detailed explanation , sumthing new I learnt..</span>
<span class="comment-copy">Neat and simple. I like it.</span>
<span class="comment-copy">first solution won't be good if I need to write the same to a file.</span>
<span class="comment-copy">@MatiasCicero thanks for the code correction, missed that one... :)</span>
<span class="comment-copy">@Here_2_learn The idea is the same. Just change the <code>print</code> statements to a <code>f.write</code> and add a line break at the end</span>
<span class="comment-copy">Tried your solution, but the output is not the desired one.</span>
