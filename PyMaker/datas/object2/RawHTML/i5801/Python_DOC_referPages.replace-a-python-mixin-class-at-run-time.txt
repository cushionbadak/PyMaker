<div class="post-text" itemprop="text">
<p>I have a data access class which fetches the data from database. It is implemented as a mixin i.e. ReferenceData i want swap this class with MockReferenceData class so in unit test i do not have to access the DB. But is not working.</p>
<p>*Note: I can not use the dependency injection. As team does not want to use it considering it will be very big code change. So i am looking to replace mixin at runtime.</p>
<pre><code>class MockReferenceData(object):
  def dbName(self):
    return 'mock'

  def totalNumberOfSeats(self):
    return '10'

class ReferenceData(object):
  def dbName(self):
    return 'real DB'

  def totalNumberOfSeats(self):
    return 'Fetch from DB'

class Car(ReferenceData):
  def showNumberOfSeats(self):
    print self.totalNumberOfSeats()


class Train(ReferenceData):
  def showNumberOfSeats(self):
    print self.totalNumberOfSeats()

c = Car()
c.showNumberOfSeats()
t = Train()
t.showNumberOfSeats()

def extend_instance(obj, cls):
    """Apply mixins to a class instance after creation"""
    base_cls = obj.__class__
    base_cls_name = obj.__class__.__name__
    obj.__class__ = type(base_cls_name, (base_cls, cls),{})

extend_instance(c, MockReferenceData)
c.showNumberOfSeats() // output now should be 10
</code></pre>
<p><strong>Out put is:</strong></p>
<pre><code>Fetch from DB
Fetch from DB
Fetch from DB
</code></pre>
<p>I was hoping as i have used <strong>extend_instance</strong> method to point to new mocked class output will be:</p>
<pre><code>Fetch from DB
Fetch from DB
10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you look at the <a href="https://docs.python.org/3/glossary.html#term-method-resolution-order" rel="nofollow noreferrer">MRO</a> of the class <code>Car</code> you can see:</p>
<pre><code>&gt;&gt;&gt; Car.__mro__
(&lt;class '__main__.Car'&gt;, &lt;class '__main__.ReferenceData'&gt;, &lt;type 'object'&gt;)
</code></pre>
<p>So methods are looked up first on <code>Car</code>, then on <code>ReferenceData</code> and finally on <code>object</code>.</p>
<p>Compare this to the MRO of your new class (I use <code>NewCar</code> as name for clarity):</p>
<pre><code>&gt;&gt;&gt; type('NewCar', (Car, MockReferenceData), {}).__mro__
(&lt;class '__main__.NewCar'&gt;, &lt;class '__main__.Car'&gt;, &lt;class '__main__.ReferenceData'&gt;, &lt;class '__main__.MockReferenceData'&gt;, &lt;type 'object'&gt;)
</code></pre>
<p>This contains the MRO of the <code>Car</code> class. Methods here are still looked up first on <code>Car</code> and then on <code>ReferenceData</code>, so as <code>totalNumberOfSeats</code> is found on <code>ReferenceData</code> the implementation from <code>MockReferenceData</code> is not used.</p>
<p>What you could do is to insert your mock class in the MRO <em>before</em> the <code>Car</code> class:</p>
<pre><code>&gt;&gt;&gt; type('NewCar', (MockReferenceData, Car), {}).__mro__
(&lt;class '__main__.NewCar'&gt;, &lt;class '__main__.MockReferenceData'&gt;, &lt;class '__main__.Car'&gt;, &lt;class '__main__.ReferenceData'&gt;, &lt;type 'object'&gt;)
</code></pre>
<p>Now methods will befirst looked up in the <code>MockReferenceData</code> class and if they do not exist there fall back to the previous version. So this <code>extend_instance</code> method should work for this simple case:</p>
<pre><code>def extend_instance(obj, cls):
    """Apply mixins to a class instance after creation"""
    obj.__class__ = type(obj.__class__.__name__, (cls, obj.__class__),{})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't use inheritance. It's a overused abstraction in many cases, and this is an example. By using dependency-injection, you can easily default to the actual DB, but replace your backend with a mocked one.</p>
<pre><code>class MockReferenceData(object):
  def dbName(self):
    return 'mock'

  def totalNumberOfSeats(self):
    return '10'

class ReferenceData(object):
  def dbName(self):
    return 'real DB'

  def totalNumberOfSeats(self):
    return 'Fetch from DB'

class Car(object):

    def __init__(self, datasource_class=ReferenceData):
        self._datasource = datasource_class() # instead of creation here, you could also pass in an

    def showNumberOfSeats(self):
        print(self._datasource.totalNumberOfSeats())


real_car = Car()
real_car.showNumberOfSeats()

mocked_car = Car(datasource_class=MockReferenceData)
mocked_car.showNumberOfSeats()
</code></pre>
<p>Also please follow PEP8 for coding-conventions in Python. You use the "wrong" indentation depth of 2, resulting in editing problems for fellow developers like me. Same goes for method-names.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks @mata i also did the same i changed the order and it worked.</p>
<pre><code>def extend_instance(obj, cls):
    """Apply mixins to a class instance after creation"""
    base_cls = obj.__class__
    base_cls_name = obj.__class__.__name__
    obj.__class__ = type(base_cls_name, (cls, base_cls),{})
</code></pre>
</div>
<span class="comment-copy">Hi Deets, problem is code base is very old and very large. I have asked to used DI but team is unwilling to use it. So i am trying to change mixin at run time. Is it possible?</span>
<span class="comment-copy">@Rahul as you've seen, it is possible. I would still not do it. Modifying your classes like this sets you up for all kind of difficult to debug problems. If your team insists, they insist on doing something bad. Another option to solve your issue would be to create a subclass of car that inherits from both the mixin and the original car. This is safer, because it creates an explicit class instead of modifying global interpreter state.</span>
<span class="comment-copy">Thanks @deets, i agree it is not the cleanest way. But if team does not want then i have no options. Also if we extend the class like this in unit test I think it will not have any impact as we are creating object in setup and destroying in teardown. What do you think?</span>
<span class="comment-copy">@Rahul I think you then don't write unit tests, but integration tests ;) And your team would be well advised to invest into decoupling and provent test-patterns, instead of pointing more guns at their feet, ready to shoot themselves. But that's beyond the scope of this question I agree. Good luck!</span>
<span class="comment-copy">I completely agree our team writes integration tests this is why i am trying to  remove interaction with DB. It will take a long time for us to get to pure unit tests. We need to do it slowly as code base is huge. Agree DI is the best way but as team pointed out we can not invest in this now so have to find alternative for now.</span>
