<div class="post-text" itemprop="text">
<p>I have a list of signals (representing consecutive mesures) :</p>
<pre><code>signals = [0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]
</code></pre>
<p>I consider a signal valid only if equal to the previous n mesures.</p>
<p>Eg. if we consider only 2 mesures for validation <code>(n=2)</code>, the first time signals turns from 0 to 1 we consider it still 0 but the next mesure, if it's 1 again then we consider it is still valid and make it 1. Then we would need 2 mesures of 0 to turn it to 0 again, etc... Here signals are 0 and 1 for simplification but in my application they can be other integers.</p>
<p>Desired output :</p>
<pre><code># For n = 2:
valid_s = [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]

# For n = 3:
valid_s = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0]

# For n = 4:
valid_s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0]
</code></pre>
<p>I was looking of a pythonesque one-liner way of doing it but can't seem to find the desired output. I tried something along the lines :</p>
<pre><code>S = signals

# For n = 2
[S[i] if S[i] == S[i-1] else S[i-2] for i, _ in enumerate(S)]
# gives [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]

# For n = 3
[S[i] if S[i] == S[i-1] == S[i-2] else S[i-3] for i, _ in enumerate(S)]
# gives [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]
</code></pre>
<p>Edit : I'm open to <code>numpy</code> if it makes it easier as it's already imported.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think there is a good way to make this a one-liner / list comprehension. While you could use <code>all</code> with a slice of the list to see whether the value is the same as the <code>n</code> values before, I don't see a good way to determine which should be the last valid value in case it is not.</p>
<p>Instead, you could use a good-old "many-lines" for loop:</p>
<pre><code>signals = [0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]
n = 3

last_valid = 0
current = None
repeated = 0
res = []
for s in signals:
    if s == current:
        repeated += 1
    else:
        repeated = 1
        current = s
    if repeated &gt;= n:
        last_valid = s
    res.append(last_valid)
</code></pre>
<p>Afterwards, <code>res</code> is <code>[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0]</code></p>
<hr/>
<p>Alternatively, a bit shorter, using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer"><code>itertools.groupby</code></a>; result is the same:</p>
<pre><code>last_valid = 0
res = []
for k, g in itertools.groupby(signals):
    m = len(list(g))
    if m &gt;= n:
        res.extend([last_valid] * (n-1) + [k] * (m-n+1))
        last_valid = k
    else:
        res.extend([last_valid] * m)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>signal = [0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]

def each(signal, n):
  p = 0
  ring = [ signal[0] ] * (n-1)
  v = None
  for x in signal:
    if v is None or all(q == x for q in ring):
      v = x
    yield v
    ring[p] = x
    p = (p+1) % (n-1)

list(each(signal, 2))
[0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]
</code></pre>
<p>But I reconsidered this and think that a pure iterative (less Pythonic) approach is probably more efficient.  After completing my new approach I now think that it is the same idea as @tobias_k already implemented in his answer:</p>
<pre><code>def each(signal, n):
  current = signal[0]
  next = None
  for v in signal:
    if v != current:
      if v == next:
        next_count += 1
      else:
        next_count = 1
        next = v
      if next_count &gt;= n:
        current = v
    yield current
</code></pre>
</div>
<span class="comment-copy">Is your desired output for n=2 correct? Do you base your output only on the measured values or on the already "corrected" previous values?</span>
<span class="comment-copy">Yes, for n=2 I need two consecutive 1 or 0 to consider switching to 1 or 0. If I don't have two consecutive, then I keep the previously already validated value. Hence the desired output for n=2.</span>
<span class="comment-copy">Addendum: And as always, if you want a one-line solution, just make it a function. ;-)</span>
<span class="comment-copy">Bit shorter and maybe simpler: <a href="https://ideone.com/vtjVUW" rel="nofollow noreferrer">ideone.com/vtjVUW</a></span>
<span class="comment-copy">Oh, <i>much</i> shorter/simpler: <a href="https://ideone.com/cgEnpu" rel="nofollow noreferrer">ideone.com/cgEnpu</a></span>
<span class="comment-copy">@StefanPochmann Yes, that last one is also nice, but I still prefer my own using list multiplication instead of another nested loop. :-)</span>
<span class="comment-copy">Man, this is one of those problems... I wrote like a dozen different solutions by now... here's one you'll maybe like, it multiplies and it doesn't need <code>last_valid</code> (and thus also doesn't have a hard-coded initial value): <a href="https://ideone.com/RWkdwq" rel="nofollow noreferrer">ideone.com/RWkdwq</a></span>
<span class="comment-copy">Why the <code>ring</code>? Why not just a slice of the list?</span>
<span class="comment-copy">Because creating slices is probably more costly than using a ringbuffer.  Depends on implementation which I don't want to rely on.</span>
<span class="comment-copy">Valid point, but the overall complexity is still <code>O(len(lst)*n)</code></span>
<span class="comment-copy">Not sure if this is true.  You only have to do n comparisons it the first n-1 are all true all the time.  This cannot be I think.</span>
<span class="comment-copy">Right, did not think of <code>all</code> short circuiting. But still, the more "ordered" the signal is, the worse the running time. Anyway, +1 for a nice, working solution.</span>
