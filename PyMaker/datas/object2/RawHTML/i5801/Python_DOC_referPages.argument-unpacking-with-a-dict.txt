<div class="post-text" itemprop="text">
<p>I have a CSV file I'd like to parse as a Dict, so that the first item with the key of "key" can be unpacked to a variable, then the rest of the values as a list of keyed languages. Is there a nice, clean way of doing this?</p>
<p>My CSV is like so:</p>
<pre><code>key,english,spanish
wanna_play_a_game,"Wanna play a game?","¿Quiero jugar a un juego?"
something_else,"Hello!","hola!"
</code></pre>
<p>Dict object as such:</p>
<pre><code>[{'key': 'wanna_play_a_game', 'english': 'Wanna play a game?', 'spanish': '¿Quiero jugar a un juego?'}, {'key': 'something_else', 'english': 'Hello', 'spanish': 'hola!'}]
</code></pre>
<p>I did have a go but then realised that unpacking isn't the same with dicts (I assume) because they're not ordered like with lists. Am I overcomplicating things and should just saved the <code>row['key']</code> to a variable and then remove it from the dict? Python isn't my bread &amp; butter language so I'm not that knowledgable on the more magicky bits of the syntax.</p>
<p>This is what I was kinda getting at before realising I'm lost:</p>
<pre><code>import csv
class Translate:

    def __init__(self):
        self.translations = self.readCSV('translations.csv')

    def readCSV(self, filename):
        with open(filename, 'rt') as csvfile:
            reader = csv.DictReader(csvfile)
            return [dict(d) for d in reader]

    def parse(self, line):
        # for t_key, *langs in self.translations:
        # for k, (t_key, *langs) in self.translations:
        # ... some magic function?
</code></pre>
<p>The basic thing I'm trying to get is <code>t_key</code> to be <code>"wanna_play_a_game"</code> and <code>langs</code> to be <code>('english': 'Wanna play a game?', 'spanish': '¿Quiero jugar a un juego?')</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Your question is tagged Python 3.6, and in 3.6, <a href="https://docs.python.org/3/library/csv.html#csv.DictReader" rel="nofollow noreferrer"><code>DictReader</code></a> returns <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a> instances, so unpacking should actually not be a problem, if you just change <code>return [dict(d) for d in reader]</code> to <code>return list(reader)</code>, otherwise you are converting those <code>OrderedDict</code> back to regular unordered <code>dict</code>.</p>
<p>Tested with the <a href="https://www.python.org/shell/" rel="nofollow noreferrer">online interactive Python shell</a> as I'm stuck with 3.5 here:</p>
<pre><code>&gt;&gt;&gt; text = '''key,english,spanish
... wanna_play_a_game,"Wanna play a game?","¿Quiero jugar a un juego?"
... something_else,"Hello!","hola!"'''
&gt;&gt;&gt; r = csv.DictReader(io.StringIO(text))
&gt;&gt;&gt; ds = list(r)
&gt;&gt;&gt; key, eng, esp = ds[0].values()
&gt;&gt;&gt; key, eng, esp
('wanna_play_a_game', 'Wanna play a game?', '¿Quiero jugar a un juego?')
</code></pre>
<p>Or if the number of languages is not known, <code>*</code> unpack to a list:</p>
<pre><code>&gt;&gt;&gt; key, *langs = ds[1].values()
&gt;&gt;&gt; key, langs
('something_else', ['Hello!', 'hola!'])
</code></pre>
<p>In your case, you probably need this (also remember to <code>return list(reader)</code>):</p>
<pre><code>for d in self.translations:
    key, *langs = d.values()
    # do stuff with key and langs
</code></pre>
<hr/>
<p>Alternatively, you could also use a dict-comprehension to create a dictionary mapping the value of the <code>"key"</code> key to an <code>OrderedDict</code> of the translations for the different languages:</p>
<pre><code>&gt;&gt;&gt; {d.pop("key"): d for d in ds}
{'wanna_play_a_game': OrderedDict([('english', 'Wanna play a game?'), ('spanish', '¿Quiero jugar a un juego?')]),
 'something_else': OrderedDict([('english', 'Hello!'), ('spanish', 'hola!')])}
</code></pre>
<p>Note, however, that this <em>modifies</em> the dicts in the list as you create the dictionary comprehension, which can be considered bad practice, but in this case, and considering that you do not keep a reference to the original dicts in the first place, I think this can be used.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unpacking is not what you want here. You should just pop <code>t_key</code> from the dict and then iterate over the rest.</p>
<pre><code>t_key = langs.pop('key')
for key, value in langs.items():
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try something like this using the split() method :</p>
<pre><code>final_list=[]
with open('file.txt','r') as f:


    for line_no,data in enumerate(f):
        if line_no==0:
            pass
        else:
            dict_1 = {}

            key,english,spanish=data.split(',')
            dict_1['key'] = key
            dict_1['English'] = english


            dict_1['Spanish']=spanish.strip('\n')

            final_list.append(dict_1)

print(final_list)
</code></pre>
<p>output:</p>
<pre><code>[{'English': '"Wanna play a game?"', 'key': 'wanna_play_a_game', 'Spanish': '"¿Quiero jugar a un juego?"'}, {'English': '"Hello!"', 'key': 'something_else', 'Spanish': '"hola!"'}]
</code></pre>
</div>
<span class="comment-copy">What exactly is your code doing wrong?</span>
<span class="comment-copy">Your question is tagged Python 3.6. In 3.6, <a href="https://docs.python.org/3/library/csv.html#csv.DictReader" rel="nofollow noreferrer"><code>DictReader</code></a> should actually return <code>OrderedDict</code> instances, so unpacking should not be a problem if you just change <code>return [dict(d) for d in reader]</code> to <code>return list(reader)</code>.</span>
<span class="comment-copy">Ok so you're trying to build a nested dictionary? Something like <code>[{'t_key':'wanna_play_a_game','langs':{'english':'Wanna play a game?','spanish':'¿Quiero jugar a un juego?'},...]</code></span>
<span class="comment-copy">@glibdud I'm asking if there's a way of doing argument unpacking-like shorthand syntax, like you might with a list, but with a dict. I don't think the question is off-topic, broad or unclear (personally at least)</span>
<span class="comment-copy">The nested dictionary might be nice, either really. I come from JS/Node mainly and am mildly baffled by things like <code>OrderedDict</code>, which I've never seen before. Also seemed that <code>list()</code> was doing something different to people using py2 and py3.6</span>
<span class="comment-copy">Thank you so much, I think this is putting me on the right track. However, I'm getting <code>'list' object has no attribute 'values'</code> when using <code>for key, *langs in self.translations.values():</code></span>
<span class="comment-copy">I changed the <code>readCSV</code> method to use <code>return list(reader)</code> as you mentioned above ^^^</span>
<span class="comment-copy">@MattFletcher Note that you are doing <code>self.translations.values()</code>, whereas my code would correspond to <code>self.translations[0].values()</code>, i.e. get the <code>values</code> from the dicts <i>inside</i> the list, not the list itself. Of course, in your case you should probably use a loop like <code>for d in self.translations: key, *lang = d.values()</code></span>
<span class="comment-copy">YES! That's the one. Ah, I feel stupid now that I was trying to run a dict function on a list... But yes, the code works and is exactly what I asked for, super clean and lovely. Thanks a bunch. I think I get those chimera <code>OrderedDict</code>-s a bit more now</span>
<span class="comment-copy">Ah, I was trying to do something like that (as a non-shorthandy way), but I think perhaps my dict was still being passed as reference? Or something to do with popping it made it break on the next loop. It seems that it was being mutated, but could also possibly be a dud row with an empty key</span>
<span class="comment-copy">How does this solve OPs problem? You are just replacing the tested and proven <code>csv.DictReader</code> with your own implementation.</span>
<span class="comment-copy">Also in the comments on the question, we go through a lot of the requirements, such as not specifying the keys of the languages, and having something short and elegant.</span>
<span class="comment-copy">@tobias_k if i don't want to use csv and created my own logic , is it wrong ? its giving same result as OP shown as expected output.</span>
