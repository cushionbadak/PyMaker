<div class="post-text" itemprop="text">
<p>A Python list</p>
<pre><code>f = [x0, x1, x2]
</code></pre>
<p>may be seen as an efficient representation of a mapping from <code>[0, 1, ..., len(f) - 1]</code> to the set of its elements. By "efficient" I mean that <code>f[i]</code> returns the element associated with <code>i</code> in O(1) time.</p>
<p>The inverse mapping may be defined as follows:</p>
<pre><code>class Inverse:
    def __init__(self, f):
        self.f = f

    def __getitem__(self, x):
        return self.f.index(x)
</code></pre>
<p>This works, but <code>Inverse(f)[x]</code> <a href="http://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">takes O(n) time on average</a>.</p>
<p>Alternatively, one may use a <code>dict</code>:</p>
<pre><code>f_inv = {x: i for i, x in enumerate(f)}
</code></pre>
<p>This has O(1) average time complexity, but it requires the objects in the list to be <a href="https://docs.python.org/3/glossary.html#term" rel="nofollow noreferrer">hashable</a>.</p>
<p>Is there a way to define an inverse mapping that provides equality-based lookups, in O(1) average time, with <em>unhashable</em> objects?</p>
<p><strong>Edit</strong>: sample input and expected output:</p>
<pre><code>&gt;&gt;&gt; f = [x0, x1, x2]
&gt;&gt;&gt; f_inv = Inverse(f)  # this is to be defined
&gt;&gt;&gt; f_inv[x0]  # in O(1) time
0
&gt;&gt;&gt; f_inv[x2]  # in O(1) time
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create an associated dictionary mapping the object ID's back to the list index.</p>
<p>The obvious disadvantage is that you will have to search the index for the identity object, not for on eobject that is merely equal.</p>
<p>On the upside, by creating a custom MutableSequence class using <code>collections.abc</code>, you can, with minimal code, write a class that keeps your data both as a sequence and as the reverse dictionary.  </p>
<pre><code>from collections.abc import MutableSequence
from threading import RLock


class MD(dict):
    # No need for a full MutableMapping subclass, as the use is limited
    def __getitem__(self, key):
        return super().__getitem__(id(key))


class Reversible(MutableSequence):
    def __init__(self, args):
        self.seq = list()
        self.reverse = MD()
        self.lock = RLock()
        for element in args:
            self.append(element)

    def __getitem__(self, index):
        return self.seq[index]

    def __setitem__(self, index, value):
        with self.lock:
            del self.reverse[id(self.seq[index])]
            self.seq[index] = value
            self.reverse[id(value)] = index

    def __delitem__(self, index):
        if index &lt; 0:
            index += len(self)
        with self.lock:
            # Increase all mapped indexes
            for obj in self.seq[index:]:
                self.reverse[obj] -= 1
            del self.reverse[id(self.seq[index])]
            del self.seq[index]

    def __len__(self):
        return len(self.seq)

    def insert(self, index, value):
        if index &lt; 0:
            index += len(self)
        with self.lock:
            # Increase all mapped indexes
            for obj in self.seq[index:]:
                self.reverse[obj] += 1
            self.seq.insert(index, value)
            self.reverse[id(value)] = index
</code></pre>
<p>And voilá: just use this object in place of your list, and the public attribute "reverse" to get the index of identity objects. 
Perceive you can augment the "intelligence" of the "MD" class by trying to use different strategies, like to use the objects themselves, if they are hashable, and only resort to id, or other custom key based on other object attributes, when needed. That way you could mitigate the need for the search to be for the same object. </p>
<p>So, for ordinary operations on the list, this class maintain the reverted dictionary synchronized. There is no support for slice indexing, though.
For more information, check the docs at <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer">https://docs.python.org/3/library/collections.abc.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately you're stuck with an algorithm limitation here. Fast lookup structures, like hash tables or binary trees, are efficient because they put objects in particular buckets or order them based on their values. This requires them to be hashable or comparable <em>consistently</em> for the entire time you are storing them in this structure, otherwise a lookup is very likely to fail.</p>
<p>If the objects you need are mutable (usually the reason they are not hashable) then any time an object you are tracking changes you need to update the data structure. The safest way to do this is to create immutable objects. If you need to change an object, then create a new one, remove the old one from the dictionary, and insert the new object as a key with the same value.</p>
<p>The operations here are still O(1) with respect to the size of the dictionary, you just need to consider whether the cost of copying objects on every change is worth it.</p>
</div>
<span class="comment-copy">Make them hashable? What kind of values are they?</span>
<span class="comment-copy">Making mutable objects hashable seems to be a very efficient way of shooting oneself in the foot: <a href="http://www.asmeurer.com/blog/posts/what-happens-when-you-mess-with-hashing-in-python/" rel="nofollow noreferrer">asmeurer.com/blog/posts/…</a></span>
<span class="comment-copy">Depends on what your data is and what you want to do with it. Maybe it's mutable/unhashable for no good reason.</span>
<span class="comment-copy">It's for a general-purpose graph (in the mathematical sense) library. The values are the node labels, and they could really be anything.</span>
<span class="comment-copy">Do you want to perform this lookup by object identity (<code>is</code>) or by equality (<code>==</code>)?</span>
<span class="comment-copy">Thanks, this is the same idea that I had started to toy with. I think your accesses to <code>self.reverse</code> should not use <code>id()</code> though; <code>self.reverse[id(self.seq[index])]</code> should be <code>self.reverse[self.seq[index]]</code>.</span>
