<div class="post-text" itemprop="text">
<p>There are more than a million subreddits on Reddit, according to <a href="http://redditmetrics.com/history" rel="noreferrer">redditmetrics.com</a>.</p>
<p>I wrote a script that repeatedly queries <a href="https://www.reddit.com/reddits.json" rel="noreferrer">this Reddit API endpoint</a> until all the subreddits are stored in an array, <code>all_subs</code>:</p>
<pre><code>all_subs = []
for sub in &lt;repeated request here&gt;:
    all_subs.append({"name": display_name, "subscribers": subscriber_count})
</code></pre>
<p>The script has been running for close to ten hours, and it's about halfway done (it gets rate-limited every three or four requests). When it's finished, I expect an array like this:</p>
<pre><code>[
    { "name": "AskReddit", "subscribers", 16751677 },
    { "name": "news", "subscribers", 13860169 },
    { "name": "politics", "subscribers", 3350326 },
    ... # plus one million more entries
]
</code></pre>
<p><strong>Approximately how much space in memory will this list take up?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>This depends on your Python version and your system, but I will give you a hand figuring out about how much memory it will take. First thing is first, <a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="noreferrer"><code>sys.getsizeof</code></a> only returns the memory use of the <em>object</em> representing the container, not all the elements in the container.</p>
<blockquote>
<p>Only the memory consumption directly attributed to the object is
  accounted for, not the memory consumption of objects it refers to.</p>
<p>If given, default will be returned if the object does not provide
  means to retrieve the size. Otherwise a TypeError will be raised.</p>
<p><code>getsizeof()</code> calls the objectâ€™s <code>__sizeof__</code> method and adds an
  additional garbage collector overhead if the object is managed by the
  garbage collector.</p>
<p>See <a href="https://code.activestate.com/recipes/577504/" rel="noreferrer">recursive sizeof recipe</a> for an example of using <code>getsizeof()</code>
  recursively to find the size of containers and all their contents.</p>
</blockquote>
<p>So, I've loaded up that recipe in an interactive interpreter session:</p>
<p>So, a CPython <em>list</em> is actually a heterogenous, resizable arraylist. The underlying array only contains pointers to Py_Objects. So, a pointer takes up a machine word worth of memory. On a 64-bit system, this is 64 bits, so 8 bytes. So, <em>just for the container</em> a list of size 1,000,000 will take up roughly 8 million bytes, or 8 megabytes. Building a list with 1000000 entries bears that out:</p>
<pre><code>In [6]: for i in range(1000000):
   ...:     x.append([])
   ...:

In [7]: import sys

In [8]: sys.getsizeof(x)
Out[8]: 8697464
</code></pre>
<p>The extra memory is accounted for by the overhead of a python object, and the extra space that a the underlying array leaves at the end to allow for efficient <code>.append</code> operations.</p>
<p>Now, a dictionary is rather heavy-weight in Python. Just the container:</p>
<pre><code>In [10]: sys.getsizeof({})
Out[10]: 288
</code></pre>
<p>So a <em>lower bound</em> on the size of 1 million dicts is: 288000000 bytes. So, a rough lower bound:</p>
<pre><code>In [12]: 1000000*288 + 1000000*8
Out[12]: 296000000

In [13]: 296000000 * 1e-9 # gigabytes
Out[13]: 0.29600000000000004
</code></pre>
<p>So you can expect about about 0.3 gigabytes worth of memory. Using the recipie and a more realistic <code>dict</code>:</p>
<pre><code>In [16]: x = []
    ...: for i in range(1000000):
    ...:     x.append(dict(name="my name is what", subscribers=23456644))
    ...:

In [17]: total_size(x)
Out[17]: 296697669

In [18]:
</code></pre>
<p>So, about 0.3 gigs. Now, that's not a lot on a modern system. But if you wanted to save space, you should use a <code>tuple</code> or even better, a <code>namedtuple</code>:</p>
<pre><code>In [24]: from collections import namedtuple

In [25]: Record = namedtuple('Record', "name subscribers")

In [26]: x = []
    ...: for i in range(1000000):
    ...:     x.append(Record(name="my name is what", subscribers=23456644))
    ...:

In [27]: total_size(x)
Out[27]: 72697556
</code></pre>
<p>Or, in gigabytes:</p>
<pre><code>In [29]: total_size(x)*1e-9
Out[29]: 0.07269755600000001
</code></pre>
<p><code>namedtuple</code> works just like a <code>tuple</code>, but you can access the fields with <em>names</em>:</p>
<pre><code>In [30]: r = x[0]

In [31]: r.name
Out[31]: 'my name is what'

In [32]: r.subscribers
Out[32]: 23456644
</code></pre>
</div>
<span class="comment-copy">That is not an array, that is a <i>list</i>.</span>
<span class="comment-copy">Which version of Python? CPython (the "standard" implementation from python.org)? Version 2 or 3?</span>
<span class="comment-copy">Also, 32-bit or 64-bit version of Python?</span>
<span class="comment-copy">@juanpa.arrivillaga fixed it :-) And its 64-bit version 2 of Python.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python">How do I determine the size of an object in Python?</a></span>
<span class="comment-copy">Thanks, very thorough!</span>
