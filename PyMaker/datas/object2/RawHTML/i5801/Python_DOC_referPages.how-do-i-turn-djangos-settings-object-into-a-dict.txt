<div class="post-text" itemprop="text">
<p>What I have:</p>
<pre><code>from django.conf import settings

def settings_to_dict(settings)
    cfg = {
        'BOTO3_ACCESS_KEY': settings.BOTO3_ACCESS_KEY,
        'BOTO3_SECRET_KEY': settings.BOTO3_SECRET_KEY,
        # repeat ad nauseum
    }
    return cfg

instance = SomeClassInstantiatedWithADict(**settings_to_dict(settings))
</code></pre>
<p>What I'd like (using Django 1.11):</p>
<pre><code>from django.conf import settings

instance = SomeClassInstantiatedWithADict(**settings.to_dict())
</code></pre>
<p>I've tried:</p>
<pre><code>from django.conf import settings

instance = SomeClassInstantiatedWithADict(**settings.__dict__)
</code></pre>
<p>which is close, but <code>__dict__</code> only gets a small subset of the settings, which I assume are hard coded ones as opposed to added attributes. Thanks for any help!</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the following code:</p>
<pre><code>from django.conf import settings
instance = settings.__dict__['_wrapped'].__dict__
</code></pre>
<p>Then you will have the whole settings dict in <code>instance</code> as dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>This turns the entire settings object into a dictionary:</p>
<pre><code>In [12]: settings_dict = {}

In [13]: for st in dir(settings):
    ...:     if st.startswith('_'):
    ...:         continue
    ...:     settings_dict[st] = getattr(settings, st)
    ...:
    ...:

In [14]: settings_dict
</code></pre>
<p>This is very exhaustive and it contains all possible attributes of settings.</p>
<p><code>dir()</code> is a Python builtin. Read about it <a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow noreferrer">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Check <code>settings.__dict__['_wrapped'].__dict__</code> in your shell. It seems there is everything inside. Not sure however if it's the right way to access this.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; from django.conf import settings
&gt;&gt;&gt; settings_dict = vars(settings._wrapped)
&gt;&gt;&gt; print(settings_dict)
{'ABSOLUTE_URL_OVERRIDES': {}, 'ADMINS': [], 'ALLOWED_HOSTS': ['127.0.0.1', 'localhost', 'www.tetricoins.com', 'api.tetricoins.com'], 'APPEND_SLASH': True, ...
</code></pre>
</div>
<span class="comment-copy">What is the use case for this? <code>settings.__dict__</code> only contains settings that have already been accessed</span>
<span class="comment-copy">Well, there is dictionnaries in your settings and maybe other types of data structures, what do you plan on doing with them ?</span>
<span class="comment-copy">What Django version?</span>
<span class="comment-copy">@IainShelvington The use case is that I have a controller class (wrapping the AWS API to spin instances up and down, attach EFS drives, etc) that I originally developed within a Flask app. To <i>_init__() the class, I simply pass flask's app.config object (which behaves as a dict), picking up on the BOTO3</i>* config variables and other keys required.  I'm now building the wider app in django, but want to continue using the same classes for django and for various associated flask micro services, with minimal modification of the class.</span>
<span class="comment-copy">@wim, updated question (Django 1.11)</span>
<span class="comment-copy">Thanks @akimul, accepted answer as this is working nicely, plus you included the complete import and assignment.</span>
<span class="comment-copy">Thankyou @David, that works very nicely :)</span>
