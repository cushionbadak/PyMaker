<div class="post-text" itemprop="text">
<p>So I am trying to create a very simple RSA encryption/decryption program where I only encrypt/decrypt int numbers. All works fine except for one problem. Sometimes my decrypted number (message) does not match my original number (the message I needed to encrypt and decrypt). This seems to happen whenever my inputted number (message) is close to my the number in my 'n' variable (n=p*q where p and q are prime numbers). I have browsed Stackoverflow a bit now and have found out that RSA algoritms cannot properly decrypt messages that are greater than 'n'. But in my case it fails to decrypt messages that are close to 'n'. If n=35 and my input number (the number to encrypt/decrypt) is 32, the program does not properly decrypt it back to 32 despite 32 being lower than 35 (works for 31, 30 ... though). Why?</p>
<p>Code:</p>
<pre><code>import math

def isPrime(n):
    if n&gt;=2:
        for m in range(2, int(math.sqrt(n)+1)):
            if n%m == 0:
                return False
        return True
    else:
        return False   

def gcd(x, y):
    while y != 0:
        (x, y) = (y, x % y)
    return x


def phi(n):
    amount = 0
    for k in range(1, n + 1):
        if gcd(n, k) == 1:
            amount += 1
    return amount

def findPubE(n, phiN):
    for e in range(3, n, 2):
        if gcd(e,phiN)==1:
            return e
    else:
        raise AssertionError("cannot find 'e'")


def multiplicative_inverse(a, b):
    """Returns a tuple (r, i, j) such that r = gcd(a, b) = ia + jb
    """
    # r = gcd(a,b) i = multiplicitive inverse of a mod b
    #      or      j = multiplicitive inverse of b mod a
    # Neg return values for i or j are made positive mod b or a respectively
    # Iterateive Version is faster and uses much less stack space
    x = 0
    y = 1
    lx = 1
    ly = 0
    oa = a  # Remember original a/b to remove
    ob = b  # negative values from return results
    while b != 0:
        q = a // b
        (a, b) = (b, a % b)
        (x, lx) = ((lx - (q * x)), x)
        (y, ly) = ((ly - (q * y)), y)
    if lx &lt; 0:
        lx += ob  # If neg wrap modulo orignal b
    if ly &lt; 0:
        ly += oa  # If neg wrap modulo orignal a
    # return a , lx, ly  # Return only positive values
    return lx

def encrypt(m,e,n):
    return (m^(e)) % n

def decrypt(M, d):
    return M^(d)




def main():
    p=int(input("Input first prime number (p): "))
    q=int(input("Input second prime number (q): "))
    n=p*q
    print("n = ",n)
    msg= int(input("Input message: "))
    assert msg &lt; n
    phiN=(p-1)*(q-1)
    e = findPubE(n,phiN)
    d = multiplicative_inverse(e,phiN)
    encryptedMsg = encrypt(msg,e,n)
    decryptedMsg = decrypt(encryptedMsg,d)



    assert isPrime(p) and isPrime(q)

    print("phi(n) = ",phiN)
    print("e = ",e)
    print("d = ",d)
    print("Encrypted message: ",encryptedMsg)
    print("Decrypted message: ",decryptedMsg)


main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Solved it! I made two little mistakes in my code. First one was that I assumed that the "^" symbol meant "to the power of" in Python (the correct symbol is "**") and the second one was that I forgot to add "mod n" to the line in my decrypt() function (so <code>return M**(d) % n</code> instead of <code>return M^(d)</code>).</p>
</div>
<span class="comment-copy"><code>^</code> is <i>not</i> the exponentiation operator in python, <code>**</code> is. In any event, modular exponentiation should simply use the three-argument version of the builtin <a href="https://docs.python.org/3/library/functions.html#pow" rel="nofollow noreferrer">pow</a> function. <code>^</code> is the exclusive-or operator. It's just a hilarious coincidence that (32^5)%35 is equal to pow(32, 5, 35).</span>
<span class="comment-copy">Ah, haha. Ok. Its been a long time since I used Python so I just assumed that '^' was "to the power of" symbol. But the rest of the code looks fine, right?</span>
<span class="comment-copy">no, not really. If you have an <code>encrypt(m, e, n)</code> method then your decrypt method should look something like <code>decrypt(M, d, n)</code>.</span>
<span class="comment-copy">@JamesKPolk Why do I need to add 'n' as a parameter in my decrypt method? The decrypted message is M^d (where M is my encrypted message). Full definition of a decrypted message is: M^d = m^(ed) = m mod n (where  M is my encrypted message, m is the original message).</span>
<span class="comment-copy">The decrypted message is not M^d, it's M^d mod n.</span>
