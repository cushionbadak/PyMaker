<div class="post-text" itemprop="text">
<p>How to continue to next loop when awaiting? For example:</p>
<pre><code>async def get_message():
    # async get message from queue
    return message

async process_message(message):
    # make some changes on message
    return message

async def deal_with_message(message):
    # async update some network resource with given message

async def main():
    while True:
        message = await get_message()
        message = await process_message(message)
        await deal_with_message(message)

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</code></pre>
<p>How can I make the <code>while True</code> loop concurrent? If it is awaiting <code>deal_with_message</code>, it can go to the next loop and run <code>get_message</code>?</p>
<h1>Edited</h1>
<p>I think I have found a solution:</p>
<pre><code>async def main():
    asyncio.ensure_future(main())
    message = await get_message()
    message = await process_message(message)
    await deal_with_message(message)

loop = asyncio.get_event_loop()
asyncio.ensure_future(main())
loop.run_forever()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your solution will work, however I see problem with it.</p>
<pre><code>async def main():
    asyncio.ensure_future(main())
    # task finishing
</code></pre>
<p>As soon as <code>main</code> started it creates new task and it happens immediately (<code>ensure_future</code> creates task immediately) unlike actual finishing of this task that takes time. I guess it can potentially lead to creating enormous amount of tasks which can drain your RAM.</p>
<p>Besides that it means that potentially any enormous amount of tasks can be ran concurrently. It can drain your network throughput or amount of sockets that can be opened same time (just imagine you're tying to download 1 000 000 urls parallely - nothing good will happen).</p>
<p>In concurrent world this problem usually <a href="https://quentin.pradet.me/blog/how-do-you-limit-memory-usage-with-asyncio.html" rel="nofollow noreferrer">can be solved</a> by limiting amount of things that can be ran concurrently with some sensible value using something like <a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore" rel="nofollow noreferrer">Semaphore</a>. In your case however I think it's more convenient to track amount of running tasks manually and populate it manually:</p>
<pre><code>import asyncio
from random import randint


async def get_message():
    message = randint(0, 1_000)
    print(f'{message} got')
    return message


async def process_message(message):
    await asyncio.sleep(randint(1, 5))
    print(f'{message} processed')
    return message


async def deal_with_message(message):
    await asyncio.sleep(randint(1, 5))
    print(f'{message} dealt')


async def utilize_message():
    message = await get_message()
    message = await process_message(message)
    await deal_with_message(message)


parallel_max = 5  # don't utilize more than 5 msgs parallely
parallel_now = 0


def populate_tasks():
    global parallel_now
    for _ in range(parallel_max - parallel_now):
        parallel_now += 1
        task = asyncio.ensure_future(utilize_message())
        task.add_done_callback(on_utilized)


def on_utilized(_):
    global parallel_now
    parallel_now -= 1
    populate_tasks()


if __name__ ==  '__main__':
    loop = asyncio.get_event_loop()
    try:
        populate_tasks()
        loop.run_forever()
    finally:
        loop.run_until_complete(loop.shutdown_asyncgens())
        loop.close()
</code></pre>
<p>Output will be like:</p>
<pre><code>939 got
816 got
737 got
257 got
528 got
939 processed
816 processed
528 processed
816 dealt
589 got
939 dealt
528 dealt
712 got
263 got
737 processed
257 processed
263 processed
712 processed
263 dealt
712 dealt
386 got
708 got
589 processed
257 dealt
386 processed
708 processed
711 got
711 processed
</code></pre>
<p>Important part here is how we got next message to be utilized only after amount of running tasks decreased to less than five.</p>
<p><strong>Upd:</strong></p>
<p>Yes, semaphore seems to be more convenient if you don't need to change max running number dynamically.</p>
<pre><code>sem = asyncio.Semaphore(5)


async def main():
    async with sem:
        asyncio.ensure_future(main())
        await utilize_message()


if __name__ ==  '__main__':
    loop = asyncio.get_event_loop()
    try:
        asyncio.ensure_future(main())
        loop.run_forever()
    finally:
        loop.run_until_complete(loop.shutdown_asyncgens())
        loop.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest solution is <code>asyncio.ensure_future</code>.</p>
<pre><code>async def main():
    tasks = []
    while running:
        message = await get_message()
        message = await process_message(message)
        coroutine = deal_with_message(message)
        task = asyncio.ensure_future(coroutine) # starts running coroutine
        tasks.append(task)
    await asyncio.wait(tasks)
</code></pre>
<p>Keeping track of the tasks yourself is optional if all your tasks can be awaited at the end.</p>
<pre><code>async def main():
    while running:
        message = await get_message()
        message = await process_message(message)
        coroutine = deal_with_message(message)
        asyncio.ensure_future(coroutine)
    tasks = asyncio.Task.all_tasks()
    await asyncio.wait(tasks)
</code></pre>
</div>
<span class="comment-copy">Although I find it works as I expect, I think it is not a pythonical way, is there a better way? This solution is just the same as <code>process.nextTick()</code> in nodejs.</span>
<span class="comment-copy">Thanks a lot. I have read your answer carefully, and I think it will be more convenient if using Semaphore. I just need to acquire at the beginning of <code>main</code>, and release at the end of <code>main</code>. Do I understand it right?</span>
<span class="comment-copy">@Sraw yes, once you wrote it I understood <code>Semaphore</code> is better than first version I proposed. I updated answer with example of using it: instead of manual acquiring/freeing you can use <code>async with</code>.</span>
<span class="comment-copy">* you have to use async with</span>
<span class="comment-copy">See my update. And I don't think this will work as <code>while running</code> will also block the whole progress and <code>await asyncio.wait(tasks)</code> will never run.</span>
<span class="comment-copy"><code>asyncio.ensure_future(coroutine)</code> starts the task running, just as with your update. <code>asyncio.wait(tasks)</code> just ensures that all your tasks have stopped before your program exits.</span>
<span class="comment-copy">Yep, I have realized that.</span>
