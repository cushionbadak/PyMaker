<div class="post-text" itemprop="text">
<p>I want to create code that initialize variable only when I really need it. But initializing in the regular way:</p>
<pre><code>var = None

if var is None:
    var = factory()
var2 = var
</code></pre>
<p>Make too much noise in the code.</p>
<p>I tried to create fast solution but I feel there is better option. This is my solution that is fast but can't get parameters and use defaultdict for this.</p>
<pre><code>def lazy_variable(factory):
    data = defaultdict(factory)
    return lambda: data['']

var = lazy_variable(a_factory)
var2 = var()
</code></pre>
<p>More questions:</p>
<ul>
<li>is there fast python container that holds only one variable?</li>
<li>is there a way to return value without calling the function with parenthesis?</li>
</ul>
<p>EDIT:</p>
<p>Please consider performance. I know i can create a class that can have this behavior, but it slower then the simple solution and also the default dict solution.</p>
<p>trying some of the solutions:</p>
<p>define:</p>
<pre><code>import cachetools.func
import random

@cachetools.func.lru_cache(None)
def factory(i):
    return random.random()
</code></pre>
<p>and run:</p>
<pre><code>%%timeit

for i in xrange(100):
    q = factory(i)
    q = factory(i)
</code></pre>
<p>got:</p>
<pre><code>100 loops, best of 3: 2.63 ms per loop
</code></pre>
<p>naive:</p>
<pre><code>%%timeit

for i in xrange(100):
    a = None
    if a is None:
        a = random.random()
    q = a
    q = a
</code></pre>
<p>got:</p>
<pre><code>The slowest run took 4.71 times longer than the fastest. This could mean that an intermediate result is being cached.
100000 loops, best of 3: 14.8 µs per loop
</code></pre>
<p>I'm not sure what was cached</p>
<p>defaultdict solution:</p>
<pre><code>%%timeit

for i in xrange(100):
    a = lazy_variable(random.random)
    q = a()
    q = a()
</code></pre>
<p>got:</p>
<pre><code>The slowest run took 4.11 times longer than the fastest. This could mean that an intermediate result is being cached.
10000 loops, best of 3: 76.3 µs per loop
</code></pre>
<p>Tnx!</p>
</div>
<div class="post-text" itemprop="text">
<p>If we're talking about instance variables, then yes - you can write your own wrapper and have it behave the way you want:</p>
<pre><code>class LazyVar(object):

    def __init__(self, factory, *args, **kwargs):
        self.id = "__value_" + str(id(self))  # internal store
        self.factory = factory
        self.args = args
        self.kwargs = kwargs

    def __get__(self, instance, owner):
        if instance is None:
            return self
        else:
            try:
                return getattr(instance, self.id)
            except AttributeError:
                value = self.factory(*self.args, **self.kwargs)
                setattr(instance, self.id, value)
                return value


def factory(name):
    print("Factory called, initializing: " + name)
    return name.upper()  # just for giggles


class TestClass(object):

    foo = LazyVar(factory, "foo")
    bar = LazyVar(factory, "bar")
</code></pre>
<p>You can test it as:</p>
<pre><code>test = TestClass()
print("Foo will get initialized the moment we mention it")
print("Foo's value is:", test.foo)
print("It will also work for referencing, so even tho bar is not initialized...")
another_bar = test.bar
print("It gets initialized the moment we set its value to some other variable")
print("They, of course, have the same value: `{}` vs `{}`".format(test.bar, another_bar))
</code></pre>
<p>Which will print:</p>
<pre>Foo will get initialized the moment we mention it
Factory called, initializing: foo
Foo's value is: FOO
It will also work for referencing, so even tho bar is not initialized...
Factory called, initializing: bar
It gets initialized the moment we set its value to some other variable
They, of course, have the same value: `BAR` vs `BAR`</pre>
<p>Unfortunately, you cannot use the same trick for globally declared variables  as <code>__get__()</code> gets called only when accessed as instance vars.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand you correctly then some of the functionality you are interested in is provided by <code>functools.lru_cache</code>:</p>
<pre><code>import functools as ft

@ft.lru_cache(None)
def lazy():
    print("I'm working soo hard")
    return sum(range(1000))

lazy() # 1st time factory is called
# I'm working soo hard
# 499500
lazy() # afterwards cached result is used
# 499500
</code></pre>
<p>The decorated factory may also take parameters:</p>
<pre><code>@ft.lru_cache(None)
def lazy_with_args(x):
    print("I'm working so hard")
    return sum((x+i)**2 for i in range(100))

lazy_with_args(3.4)
# I'm working so hard
# 363165.99999999994
lazy_with_args(3.4)
# 363165.99999999994
# new parametes, factory is used to compute new value
lazy_with_args(-1.2)
# I'm working so hard
# 316614.00000000006
lazy_with_args(-1.2)
# 316614.00000000006
# old value stays in cache
lazy_with_args(3.4)
# 363165.99999999994 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple container (but which needs the parentheses nevertheless) can be done e.g. like this:</p>
<pre><code>class Container:
    UNDEF = object()

    def __init__(self, factory):
        self.data = Container.UNDEF
        self.factory = factory

    def __call__(self):
        if self.data is Container.UNDEF:
            self.data = self.factory()

        return self.data

# Test:

var = Container(lambda: 5)

print(var())
print(var())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well you <em>could</em> simply access <code>locals()</code> or <code>globals()</code> and type</p>
<pre><code>var2 = locals().get('var', factory())
</code></pre>
<p>but I have never been in a situation where that would be useful, so you should probably evaluate why you want to do what you want to do.</p>
</div>
<div class="post-text" itemprop="text">
<p>Ok, I think i found a nice and fast solution using generators:</p>
<pre><code>def create_and_generate(creator):
    value = creator()
    while True:
        yield value    


def lazy_variable(creator):
    generator_instance = create_and_generate(creator)
    return lambda: next(generator_instance)
</code></pre>
<p>another fast solution is:</p>
<pre><code>def lazy_variable(factory):
    data = []
    def f():
        if not data:
            data.extend((factory(),))
        return data[0]
    return f
</code></pre>
<p>but I thing the generator is more clear.</p>
</div>
<span class="comment-copy">I am not sure if this fits your requirements, but take a look at <a href="https://docs.python.org/3/howto/descriptor.html#descriptor-example" rel="nofollow noreferrer"><code>descriptors</code></a>.</span>
<span class="comment-copy">That's help, but when i tried to use classes for the solution it wasn't fast as the solution iv'e found. class creation is slow and i need solution that's fits long for loops</span>
