<div class="post-text" itemprop="text">
<p>I come across this code from one of my friends. It is a test for overiding comparison methods in Python. When i ran the code i got this: </p>
<p>True</p>
<p>True</p>
<p>True</p>
<p>and this: "TypeError: '&lt;' not supported between instances of 'A' and 'B'"</p>
<p>If that is the case, why the same error did not happen with "a1 == b1"? </p>
<pre><code>class A:
    def __init__(self, x):
        self.x = x
class B:
    def __init__(self, x):
        A.__init__(self, x)
    def __eq__(self, other):
        return self.x == other.x
    def __lt__(self, other):
        return self.x &lt; other.x
a1 = A(1)
b1 = B(1)
print(b1 == a1)
print(a1 == b1)

a2 = A(2)
b2 = B(1)
print(b2 &lt; a2)

a3 = A(1)
b3 = B(2)
print(a3 &lt; b3)    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to implement <code>__lt__</code> on <code>A</code> if comparison doesn't make sense for <code>A</code> normally; <code>B</code> can do all the heavy lifting for comparisons between <code>A</code> and <code>B</code>, but you need to implement the reflected comparison operators for this to work.</p>
<p>The problem here is that <code>A</code> doesn't implement <code>__lt__</code>, so Python will execute <code>a3 &lt; b3</code> by using the reflected operator from <code>B</code>, making the line test <code>b3 &gt; a3</code>. But you didn't implement <code>__gt__</code> in <code>B</code>, so there is no way to reflect the operation.</p>
<p>The simplest fix (recommended in general if you implement any of the comparison operations) is to <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow noreferrer">use <code>functools.total_ordering</code></a> to expand the single implemented operator to the whole rich comparison suite:</p>
<pre><code>from functools import total_ordering

@total_ordering
class B:
     ... rest of B unchanged ...
</code></pre>
<p>That's it; your code will just work, as that decoration will ensure <code>__gt__</code> is defined in terms of <code>__lt__</code>/<code>__eq__</code>, so the attempt to flip the comparison will succeed.</p>
<p>You could equivalently define each of the operations one by one, e.g.:</p>
<pre><code>class B:
    ... rest of class ...
    def __gt__(self, other):
        return self.x &gt; other.x
    def __le__(self, other):
        return self.x &lt;= other.x
    def __ge__(self, other):
        return self.x &gt;= other.x
</code></pre>
<p>but that's tedious and error-prone; use <code>functools.total_ordering</code>.</p>
<p>The <code>==</code> test worked just fine because equality is reflexive, so the same overload works in either direction when the other operand doesn't implement it; Python tries <code>a.__eq__(b)</code> and finds it doesn't work, so it tries <code>b.__eq__(a)</code>, since <code>a == b</code> is logically equivalent to <code>b == a</code>. It's only rich comparisons where the reflected operation uses a different method.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to define <code>__lt__</code> in class <code>A</code> too:</p>
<pre class="lang-python prettyprint-override"><code>class A:
    def __init__(self, x):
        self.x = x
    def __lt__(self, other):
        return self.x &lt; other.x
class B(A):
    def __init__(self, x):
        A.__init__(self, x)
    def __eq__(self, other):
        return self.x == other.x
    def __lt__(self, other):
        return self.x &lt; other.x
a1 = A(1)
b1 = B(1)
print(b1 == a1)
print(a1 == b1)

a2 = A(2)
b2 = B(1)
print(b2 &lt; a2)

a3 = A(1)
b3 = B(2)
print(a3 &lt; b3)
</code></pre>
<p>And, of course, the same will remain true for the rest of operators. The reason of why that happens is because in <code>b &lt; a</code> the method called is <code>B.__lt__</code> and in <code>a &lt; b</code> the method called is <code>A.__lt__</code>. The former method is defined but not the latter.</p>
<p>Btw, you were calling <code>A</code>'s contructor in <code>B</code>'s constructor. I assume that you want a <code>B</code> to be also an <code>A</code>, so <code>B</code> inherits from <code>A</code>. Thats the reason why my code says <code>class B(A)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>So I changed you code to add <code>print</code> statements to the <code>__eq__</code> method, like so:</p>
<pre><code>class A:
    def __init__(self, x):
        self.x = x
class B:
    def __init__(self, x):
        A.__init__(self, x)
    def __eq__(self, other):
        print('type(self) =', type(self))
        print('type(other) =', type(other))
        return self.x == other.x
    def __lt__(self, other):
        return self.x &lt; other.x
</code></pre>
<p>and the results were this:</p>
<pre><code>type(self) = &lt;class '__main__.B'&gt;
type(other) = &lt;class '__main__.A'&gt;
True
type(self) = &lt;class '__main__.B'&gt;
type(other) = &lt;class '__main__.A'&gt;
True
True
Traceback (most recent call last):
  File "/home/chrx/Dropbox/Documents/Programming/questions/SO_question.py", line 25, in &lt;module&gt;
    print(a3 &lt; b3)
TypeError: unorderable types: A() &lt; B()
</code></pre>
<p>So even though you only wrote a <code>__eq__</code> method for the <code>B</code> class, it was used when comparing in the reversed order, <code>a == b</code>. This (I believe) is a feature of the Python language that assumes equality operators are reflexive, i.e. <code>a == b</code> and <code>b == a</code> should have the same result.</p>
<p>However, this property does not apply to the <code>__lt__</code> operator in this case, because <code>a &lt; b</code> is different from <code>b &lt; a</code>.</p>
</div>
<span class="comment-copy">Did you forget to say <code>class B(A)</code> so that an instance of <code>B</code> is also an instance of <code>A</code>?</span>
<span class="comment-copy">Thanks a lot pal! Really clear answer!</span>
<span class="comment-copy">Please also comment on the inheritance from  class A in class B <code>class B(A):</code> which the OP forgot in his/her code</span>
<span class="comment-copy">Is it really necessary to implement <code>__lt__</code> twice, if B inherits from A?</span>
<span class="comment-copy">@Bazingaa. Inheritance is not necessary here. Calling <code>A.__init__</code> in <code>B.__init__</code> may look weird, but is not in any way illegal.</span>
<span class="comment-copy">@Kevin: No. <code>__lt__</code>'s definition could be removed from <code>B</code> if it's implemented correctly in the superclass.</span>
<span class="comment-copy">Calling <code>A.__init__</code> in <code>B.__init__</code> may not be illegal, but it's a pattern that you should never use</span>
<span class="comment-copy">This property applies to <code>__lt__</code>, it's just that it flips to follow the logic; if <code>a.__lt__(b)</code> (<code>a &lt; b</code>) isn't implemented, Python tries <code>b.__gt__(a)</code> (<code>b &gt; a</code>). <a href="https://stackoverflow.com/a/53841231/364696">My answer</a> covers fixing this properly without modifying <code>A</code>.</span>
<span class="comment-copy">@ShadowRanger modified for correctness, thanks</span>
