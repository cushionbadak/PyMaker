<div class="post-text" itemprop="text">
<p>I have some code that should find the position of any <code>0</code> items in a list and move it to the back whilst preserving the order of the other elements.</p>
<pre><code>def test2(array):
    try:
        for n in range(len(array)):
            array.append(array.pop(array.index(0)))
        return array
    except ValueError:
        return array
</code></pre>
<p>This code works fine for any list apart from one with <code>False</code> in. I think this is because the <code>.index(0)</code>: will also return the position of any False in the list. Any way to get around this?</p>
<p>For example if <code>array = [0,1,None,2,False,1,0]</code> then the output should be <code>[1,None,2,False,1,0,0]</code></p>
<p>With that same input my code produces: <code>[1, None, 2, 1, False, 0, 0]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>This is a consequence of the fact that <code>bool</code> is a subclass of <code>int</code> in python, so searching for the first index of <code>0</code> will return the index of <code>False</code>, if it is in the list before a <code>0</code> because <code>False == 0</code>.</p>
<p>What you can do is check whether a list element is an instance of <code>int</code>, and at the same time, <em>not</em> an instance of <code>bool</code>. This way, you avoid matching other falsey values (like empty containers and <code>None</code>).</p>
<pre><code>def is_zero(v):
    # return is instance(v, int) and v is not False and not v
    # return isinstance(v, int) and not isinstance(v, bool) and not v
    return type(v) in (int, float) and not v
</code></pre>
<p>You can then iterate over <code>lst</code> in reverse and update in-place.</p>
<pre><code>lst = [1, 0, None, False, 0, 3, True] # For example.

for i in reversed(range(len(lst))):
    if is_zero(lst[i]):
        lst.append(lst.pop(i))

print(lst)
# [1, None, False, 3, True, 0, 0]
</code></pre>
<p>This is amortised linear time complexity, if I'm not mistaken.</p>
</div>
<div class="post-text" itemprop="text">
<p>If creating another list is of no concern, you can use list-comprehensions:</p>
<pre><code>def test2(array):
    la = len(array)
    return ([x for x in array if not isinstance(x,int) or x]+[0]*la)[:la]
</code></pre>
<p>The first part filters out any 0 integerbut lets any non-int pass. The second part adds (too many) zeros and trims the result back down to the original lenght.</p>
<p><strong>Caveat:</strong> This will create up to twice the original list-length in data - so not good for "big" lists or lists with few 0.</p>
<p>Usage:</p>
<pre><code>k = [1,2,3,0,4,5,False,92,-3,0,1,0,0,True,[],None,True]
print(k)
print(test2(k))
</code></pre>
<p>Output:</p>
<pre><code>[1, 2, 3, 0, 4, 5, False, 92, -3, 0, 1, 0, 0, True, [], None, True]
[1, 2, 3, 4, 5, 92, -3, 1, True, True, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<p>Doku:</p>
<ul>
<li>(related) <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">Truth-testing</a> - there are other values that are "False" as well.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>A variation of @coldspeed's solution:</p>
<pre><code>array = [0, 1, None, 2, False, 1, 0]
nonzero = [x for x in array if x or x is None or isinstance(x,bool)]
nonzero + [0] * (len(array) - len(nonzero))
# [1, None, 2, False, 1, 0, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a wrapper with a custom <code>__eq__</code>:</p>
<pre><code>class Typed:
    def __init__(self, val):
        self.val = val
    def __hash__(self):
        return hash(self.val)
    def __eq__(self, other):
        if isinstance(other, Typed):
            other = other.val
        return type(self.val) is type(other) and self.val == other
</code></pre>
<p>Then replace <code>array.index(0)</code> with <code>array.index(Typed(0))</code> - you don't need to use this within the array itself.</p>
<p>Extending this to containers (so that <code>(0, 1)</code> and <code>(False, True)</code> won't be equal) is left as an exercise for the reader.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this is as concise as this can be. Thanks for the help everyone</p>
<pre><code>l = [i for i in array if isinstance(i, bool) or i!=0]
return l+[0]*(len(array)-len(l))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow noreferrer">guarantees</a> <code>True</code> and <code>False</code> are the only instances of <code>bool</code>, so you can use <code>is</code> to distinguish <code>False</code> from <code>0</code>.</p>
<pre><code>z = []
return [e for e in array if e is False or e != 0 or z.append(e)] + z
</code></pre>
<p>This will preserve the order of the various non-<code>False</code> zeros (<code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code>),  that may be in the list.</p>
</div>
<span class="comment-copy"><code>0 == False</code>. Booleans do that in Python.</span>
<span class="comment-copy">@user2357112 So is there a different way I can do this then?</span>
<span class="comment-copy">You just need to handle the <code>0 == False</code> is <code>True</code> in Python, that is main reason you are not able to get correct ans.   More details please refer to: <a href="https://stackoverflow.com/questions/2764017/is-false-0-and-true-1-in-python-an-implementation-detail-or-is-it-guarante" title="is false 0 and true 1 in python an implementation detail or is it guarante">stackoverflow.com/questions/2764017/â€¦</a></span>
<span class="comment-copy">Just curious, instead of checking <code>isinstance</code>, is it safe in python to simply check <code>v is not False</code>?</span>
<span class="comment-copy">@MarkMeyer I would be <i>very</i> careful of using <code>is</code> for anything besides reference checks.</span>
<span class="comment-copy">I guess that's what I was asking: does python make any guarantees here. Seems like the answer is no. Thanks.</span>
<span class="comment-copy">@MarkMeyer I believe True and False values are interned (cached), so with cpython the reference <i>should</i> be the same... but it is an implementation detail and in general you should not rely on it. :-)</span>
<span class="comment-copy">@coldspeed Thanks! I got there anyway before I read your hint ;)</span>
