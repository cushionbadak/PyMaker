<div class="post-text" itemprop="text">
<p>Just went through list, dictionary, set comprehensions and understood lambda expressions but I'm unable to use them to capture the number of occurrences of integers in a nested list as illustrated in the example below. So, is there a solution with comprehensions or lambda expressions to compute it or is it beyond the capability of such constructs? If it's not possible, then what's  the intuition for why it cannot be achieved with comprehensions/lambda expressions?</p>
<pre><code>lst = [[0,1],[1,2],[3,4],[0,5]]
result = {0:2, 1:2, 2:1, 3:1, 4:1, 5:1}
</code></pre>
<p>I'm currently using a double for loop to do the computation.</p>
</div>
<div class="post-text" itemprop="text">
<p>The constructs of generator expressions, list comprehensions, etc. are good for individually mapping the items in a sequence. They are not at all meant for aggregation, which is what you are trying to do here, i.e. combining the values of several items.</p>
<p>For your purpose you can use the <code>collections.Counter</code> (which does the aggregation of counting items) with a generator expression that flattens the nested lists instead:</p>
<pre><code>from collections import Counter
dict(Counter(i for s in lst for i in s))
</code></pre>
<p>This returns:</p>
<pre><code>{0: 2, 1: 2, 2: 1, 3: 1, 4: 1, 5: 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can utilize <code>itertools.chain</code> and the <code>Counter</code> object to get these results.</p>
<pre><code>from itertools import chain
from collections import Counter

result = Counter(chain(*lst))
</code></pre>
<p>Calling <code>chain</code> will flatten your lists and <code>Counter</code> will provide the frequency counts of each value in the flattened list.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can flatten your nested lists to get a single list using <code>sum</code> and then  apply <a href="https://docs.python.org/2/library/collections.html#counter-objects" rel="nofollow noreferrer">Counter</a> to get the frequency of occurrence of each element </p>
<pre><code>from collections import Counter

lst = [[0,1],[1,2],[3,4],[0,5]]
flat = sum(lst, [])
print (flat)
# [0, 1, 1, 2, 3, 4, 0, 5]

Counter(flat)

# Counter({0: 2, 1: 2, 2: 1, 3: 1, 4: 1, 5: 1})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could count each element in the sub-lists (using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter</a>) and <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer">sum</a> the counts:</p>
<pre><code>from collections import Counter

lst = [[0, 1], [1, 2], [3, 4], [0, 5]]

result = sum(map(Counter, lst), Counter())
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>Counter({0: 2, 1: 2, 2: 1, 3: 1, 4: 1, 5: 1})
</code></pre>
</div>
<span class="comment-copy">In what way are you "unable to use [lambda expressions]" for this? Can you show us what you tried?</span>
<span class="comment-copy">for instance, using <code>map(lambda x:sum(x), lst)</code>  which come close but not quite what I am looking for.</span>
<span class="comment-copy">Is there any natural way to avoid importing extra libraries?</span>
<span class="comment-copy">Thanks for showing how to flatten the list in one line but I'm curious as to how it works.</span>
<span class="comment-copy">It simply maps the sum function to individual sublists. So <code>[]</code> tells it to sum all the objects of type <code>[]</code> (list). In python if you have two lists <code>a=[1,2,3]</code> and <code>b = [4,5,6]</code> then <code>a+b</code> becomes <code>[1,2,3,4,5,6]</code></span>
<span class="comment-copy">So, it doesn't work for arbitrarily nested lists of integers.</span>
<span class="comment-copy">@aak318: It will work for any arbitrary nested list. For example, [1,2,3] and [4,5] and [6] will work too to get [1,2,3,4,5,6]</span>
<span class="comment-copy">No by arbitrary nesting, I meant for example <code>lst=[[0,1],[[2],[3]],[5]]</code> and the like.</span>
