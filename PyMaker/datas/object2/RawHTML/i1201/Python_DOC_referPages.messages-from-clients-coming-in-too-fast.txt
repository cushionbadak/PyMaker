<div class="post-text" itemprop="text">
<p>I am writing a Python TCP/IP server that accepts messages from one client. Once, I receive the message, I parse the TCP message and generate a response based on its message type and send the generated response to the Client.</p>
<p>My applications works very well, until you have multiple messages coming in very quickly. My server seems to be blocking I/O while it is in the middle of processing a message.
For example, while I am processing the 3rd message, the 4th message will never be accepted by my server, since, I am still processing the 3rd one. Therefore, the 4th message gets lost in space.</p>
<p>I was thinking about handling this issue using threading. <code>Thread1</code> can sit there and only accept the incoming messages from the client and put them into the Queue, while <code>Thread2</code> will read the request message from <code>Thread1</code> and generate a response to be sent to the client. After it sends the message, <code>Thread2</code> will pop the message from the <code>Thread1</code>'s Queue.</p>
<p>Is this the right away to go about this issue?</p>
<p>EDIT:
After some more testing, I realized that I am always receiving the Client's messages; however, the Client times out after 5-10 seconds if it does not receive a response message.
I need to speed up the message processing because my server thinks everything is fine because it actually receives all of the messages and does not lose any messages as I thought before. The problem is that the client is impatient.
Any tips on how to speed up performance? A process per request that runs in parallel so the work is divided equally? The only issue I see with that is, that it is rare that a message comes in while I'm processing another message.</p>
</div>
<div class="post-text" itemprop="text">
<p>The threading solution should work but if you're using version 3.4 or later, you might prefer to look into using <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a>, which uses coroutines rather than threads, and is easier to use in my opinion. However this will also depend on what server library you're using.</p>
<p>Asyncio works well with <a href="https://sanic.readthedocs.io/en/latest/" rel="nofollow noreferrer">Sanic</a> but not with CherryPy. It all depends on your tools.</p>
</div>
<span class="comment-copy">That's how you could do it.</span>
<span class="comment-copy">Why will the 4th message get lost? You'll just process it after you finish processing the 3rd message.</span>
<span class="comment-copy">@Barmar It seems as if the Socket is in a block I/O</span>
<span class="comment-copy">TCP has built-in flow control. If messages are coming in faster than the application can read them from the kernel's socket buffer, the TCP window closes and the senders slow down.</span>
<span class="comment-copy">TCP isn't message-based.  It is a stream I/O.  If you <code>send(b'abc')</code> and <code>send(b'def')</code>, you could <code>recv(1024)</code> and get <code>b'abcdef'</code>.  Check that this isn't occurring.  You can buffer your receives and extract only complete messages.  You'll need a protocol to define what a complete message is.</span>
