<div class="post-text" itemprop="text">
<p>This is sort of a ridiculous and weird use case but bear with me, I have this list comprehension:</p>
<pre><code>"reading_types": [
    {
        "name": rt.reading_type,
        "value": rt.reading_type_id,
    }
    for unit in item.units
    for rt in unit.reading_types
],
</code></pre>
<p>in a backend api call. It works great <em>except</em> that there will almost always be duplicates in the end result. How can I ensure that no duplicates are returned? </p>
<p>This is actually happening inside another list comprehension, and I can't reference the list at any point to remove duplicates so I must do so within the list comprehension itself.</p>
<p>I've tried using a <code>set</code>:</p>
<pre><code>set([
    {
        "name": rt.reading_type,
        "value": rt.reading_type_id,
    }
    for unit in item.units
    for rt in unit.reading_types
])
</code></pre>
<p>but this results in the error: <code>unhashable type: dict</code></p>
</div>
<div class="post-text" itemprop="text">
<p>the idea is to make your structures <em>hashable</em> without destroying them too much so you can restore them back as how they were.</p>
<p>You could convert your dictionaries to <code>dict_items</code> then to <code>tuples</code> (now we can put that in a <code>set</code> because data is hashable), apply a <code>set</code> on that, and convert back to dictionary:</p>
<pre><code>input_list = [{"name":"name1","id":"id1"},{"name":"name2","id":"id2"},
{"name":"name1","id":"id1"}]

output_list = [dict(items) for items in {tuple(a.items()) for a in input_list}]
</code></pre>
<p>This works because values of the sub-dicts are hashable (strings). If they were dictionaries, we'd have to convert them too.</p>
<p>result:</p>
<pre><code>[{'id': 'id1', 'name': 'name1'}, {'id': 'id2', 'name': 'name2'}]
</code></pre>
<p>another solution (by Jon Clements) that doesn't use a <code>set</code> but builds a dictionary (using a dictionary comprehension) &amp; uses key unicity to clobber duplicates, then extract only values:</p>
<pre><code>list({tuple(d.items()):d for d in input_list}.values())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a> instead of a dictionary inside the <code>set</code>.  As immutable objects, <code>namedtuple</code>s are hashable, which dictionaries are not. You can also use a set comprehension directly:</p>
<pre><code>from collections import namedtuple

reading_type = namedtuple("reading_type", ["name", "value"])

{reading_type(rt.reading_type, rt.reading_type_id) 
    for unit in item.units
    for rt in unit.reading_types}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This isn't a list comprehension, but you can use the <code>itertools</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>unique_everseen</code> recipe</a>, also available in 3rd party libraries, e.g. <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_everseen" rel="nofollow noreferrer"><code>more_itertools.unique_everseen</code></a>:</p>
<pre><code>from more_itertools import unique_everseen

input_list = [{"name":"name1","id":"id1"},{"name":"name2","id":"id2"},
              {"name":"name1","id":"id1"}]

res = list(unique_everseen(input_list, key=lambda d: tuple(sorted(d.items()))))

print(res)

[{'name': 'name1', 'id': 'id1'}, {'name': 'name2', 'id': 'id2'}]
</code></pre>
<p>The trick is to make sure you can hash your dictionaries, which we perform by converting each dictionary to a tuple of sorted tuples. Internally, the algorithm works by maintaining a "seen" <code>set</code> of values and yielding only values which do not appear in the <code>set</code>, adding them otherwise.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can wrap your entire list in another comprehension to <code>repr</code> each entry, and use <code>set</code> on that:</p>
<pre><code>set([repr(val) for val in [...]])
</code></pre>
</div>
<span class="comment-copy">wow this works great! I have a million questions though, not super familiar with python, why tuples? Why wrap them in brackets? And what is the <code>:d for d</code> syntax with the colon? If you could explain any of this further I would really appreciate it!</span>
<span class="comment-copy">Python 3.6 has a new (IMHO better) syntax for named tuple, even tho the old ones still work. <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="nofollow noreferrer">docs.python.org/3/library/typing.html#typing.NamedTuple</a></span>
<span class="comment-copy">edit: actually this isn't great since <code>repr</code> seems to just return stringified objects and I don't want that</span>
