<div class="post-text" itemprop="text">
<p>I'm currently building a Discord bot that uploads a file to Google Drive when a command is used. However, the command methods are Asynchronous and the files().create() method is Synchronous, and calling it simply causes the bot to get stuck.</p>
<pre><code>@bot.command(pass_context = True)
@commands.has_role(name = 'Archivist')
async def archivechannel(ctx, channel : discord.Channel, filename):
await bot.say("Archiving....")
try:
    with open("{}.txt".format(filename), "w") as openfile:
        lines = []
        async for message in bot.logs_from(channel, limit=500, reverse=True):
            if not (message.author.bot or message.content.startswith("]")):
                print ("&lt;{}&gt; {}#{}: {}".format(message.timestamp, message.author.name, message.author.discriminator, message.content))
                lines.append("&lt;{}&gt; {}#{}: {}\n".format(message.timestamp, message.author.name, message.author.discriminator, message.content))
        openfile.writelines(lines)
        await bot.say("Archive Complete!")
except IOError:
    await bot.say("Error: IOException")
await bot.say("Uploading....")
metadata = {'name' : "{}.txt".format(filename), 'mimetype' : 'application/vnd.google.apps.document', 'parents' : folderID}
media = MediaFileUpload('{}.txt'.format(filename), mimetype='text/plain')
res = service.files().create(body=metadata, media_body=media).execute()
print(res)
</code></pre>
<p>The line causing the problem is:</p>
<pre><code>res = service.files().create(body=metadata, media_body=media).execute()
</code></pre>
<p>The bot just gets stuck after saying "Uploading...." and doesn't upload anything.</p>
<p>Does anyone know how I can fix this?</p>
<p><strong>Edit:</strong> Using a ThreadPoolExecutor, nor a DefaultExecutor has worked, nor has setting up a synchronous function that runs the create and execute methods, taking in the metadata and media parameters</p>
<p><strong>Edit 2:</strong> After doing some more screwing around, it turns out the problem is now in the following line:</p>
<pre><code>media = MediaFileUpload('{}.txt'.format(filename), mimetype='text/plain')
</code></pre>
<p>However from my testing, for the question I asked, Patrick is correct and I have marked the question as answered.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can run your blocking operation in another thread, while your asynchronous code waits for it to complete without blocking the event loop.</p>
<p>We'll create a new <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" rel="nofollow noreferrer"><code>ThreadPoolExecutor</code></a>, then use <a href="https://docs.python.org/3/library/asyncio-eventloop.html#executing-code-in-thread-or-process-pools" rel="nofollow noreferrer"><code>run_in_executor</code></a> to use it to run the task.</p>
<pre><code>from concurrent.futures import ThreadPoolExecutor

def upload_file(metadata, media):
    return service.files().create(body=metadata, media_body=media).execute()

@bot.command(pass_context = True)
@commands.has_role(name = 'Archivist')
async def archivechannel(ctx, channel : discord.Channel, filename):
    await bot.say("Archiving....")
    try:
        with open("{}.txt".format(filename), "w") as openfile:
            lines = []
            async for message in bot.logs_from(channel, limit=500, reverse=True):
                if not (message.author.bot or message.content.startswith("]")):
                    print ("&lt;{}&gt; {}#{}: {}".format(message.timestamp, message.author.name, message.author.discriminator, message.content))
                    lines.append("&lt;{}&gt; {}#{}: {}\n".format(message.timestamp, message.author.name, message.author.discriminator, message.content))
            openfile.writelines(lines)
            await bot.say("Archive Complete!")
    except IOError:
        await bot.say("Error: IOException")
    await bot.say("Uploading....")
    metadata = {filename : "{}.txt".format(filename), 'mimetype' : 'application/vnd.google.apps.document', 'parents' : folderID}
    media = MediaFileUpload('{}.txt'.format(filename), mimetype='text/plain')
    with ThreadPoolExecutor() as pool:
        res = await bot.loop.run_in_executor(
               pool, upload_file, metadata, media
              )
    print(res)
</code></pre>
<p>You may also be able to use the default executor by removing the context manager and passing <code>None</code> instead of <code>pool</code>.  I'm having trouble finding information about the default executor though, so you may want to experiment.  </p>
</div>
<span class="comment-copy">The ThreadPoolExecutor as you have it in the code, and setting it to None, did not work, so the problem may lie with the create() method. I tried making a synchronous function that runs both the create and execute methods, taking in metadata and media as parameters, but that didn't work either. Should I be running that function inside of the Executor block?</span>
<span class="comment-copy">@DerpDerpius See the edit I just made.  We stick the blocking operation in another function, then pass that function to <code>run_in_executor</code>, passing its arguments separately.</span>
