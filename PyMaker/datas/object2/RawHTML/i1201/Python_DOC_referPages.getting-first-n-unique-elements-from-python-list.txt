<div class="post-text" itemprop="text">
<p>I have a python list where elements can repeat.</p>
<pre><code>&gt;&gt;&gt; a = [1,2,2,3,3,4,5,6]
</code></pre>
<p>I want to get the first <code>n</code> unique elements from the list.
So, in this case, if i want the first 5 unique elements, they would be:</p>
<pre><code>[1,2,3,4,5]
</code></pre>
<p>I have come up with a solution using generators:</p>
<pre><code>def iterate(itr, upper=5):

    count = 0
    for index, element in enumerate(itr):
        if index==0:
            count += 1
            yield element

        elif element not in itr[:index] and count&lt;upper:
            count += 1
            yield element
</code></pre>
<p>In use:</p>
<pre><code>&gt;&gt;&gt; i = iterate(a, 5)
&gt;&gt;&gt; [e for e in i]
[1,2,3,4,5]
</code></pre>
<p>I have doubts on this being the most optimal solution. Is there an alternative strategy that i can implement to write it in a more pythonic and efficient 
way?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use a <code>set</code> to remember what was seen and return from the generator when you have <code>seen</code> enough:</p>
<pre><code>a = [1,2,2,3,3,4,5,6]

def get_unique_N(iterable, N):
    """Yields (in order) the first N unique elements of iterable. 
    Might yield less if data too short."""
    seen = set()
    for e in iterable:
        if e in seen:
            continue
        seen.add(e)
        yield e
        if len(seen) == N:
            return

k = get_unique_N([1,2,2,3,3,4,5,6], 4)
print(list(k))
</code></pre>
<p>Output:</p>
<pre><code>[1,2,3,4]
</code></pre>
<hr/>
<p>According to <a href="https://www.python.org/dev/peps/pep-0479/" rel="nofollow noreferrer">PEP-479</a> you should <code>return</code> from generators, not <code>raise StopIteration</code> - thanks to <a href="https://stackoverflow.com/users/3890632/khelwood">@khelwood</a> &amp; <a href="https://stackoverflow.com/users/5958455/ibug">@iBug</a> for that piece of comment - one never learns out. </p>
<p>With 3.6 you get a deprecated warning, with 3.7 it gives RuntimeErrors: <a href="https://www.python.org/dev/peps/pep-0479/#transition-plan" rel="nofollow noreferrer">Transition Plan</a> if still using <code>raise StopIteration</code></p>
<hr/>
<p>Your solution using <code>elif element not in itr[:index] and count&lt;upper:</code> uses <code>O(k)</code> lookups - with <code>k</code> being the length of the slice - using a set reduces this to <code>O(1)</code> lookups but uses  more memory because the set has to be kept as well. It is a speed vs. memory tradeoff - what is better is application/data dependend.</p>
<p>Consider <code>[1,2,3,4,4,4,4,5]</code> vs <code>[1]*1000+[2]*1000+[3]*1000+[4]*1000+[5]*1000+[6]</code>:</p>
<p>For 6 uniques (in longer list):</p>
<ul>
<li>you would have lookups of <code>O(1)+O(2)+...+O(5001)</code></li>
<li>mine would have <code>5001*O(1)</code> lookup + memory for <code>set( {1,2,3,4,5,6})</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can adapt the popular <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer"><code>itertools</code> <code>unique_everseen</code> recipe</a>:</p>
<pre><code>def unique_everseen_limit(iterable, limit=5):
    seen = set()
    seen_add = seen.add
    for element in iterable:
        if element not in seen:
            seen_add(element)
            yield element
        if len(seen) == limit:
            break

a = [1,2,2,3,3,4,5,6]

res = list(unique_everseen_limit(a))  # [1, 2, 3, 4, 5]
</code></pre>
<p>Alternatively, as suggested by @Chris_Rands, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="noreferrer"><code>itertools.islice</code></a> to extract a fixed number of values from a non-limited generator:</p>
<pre><code>from itertools import islice

def unique_everseen(iterable):
    seen = set()
    seen_add = seen.add
    for element in iterable:
        if element not in seen:
            seen_add(element)
            yield element

res = list(islice(unique_everseen(a), 5))  # [1, 2, 3, 4, 5]
</code></pre>
<p>Note the <code>unique_everseen</code> recipe is available in 3rd party libraries via <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_everseen" rel="noreferrer"><code>more_itertools.unique_everseen</code></a> or <a href="https://toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.unique" rel="noreferrer"><code>toolz.unique</code></a>, so you could use:</p>
<pre><code>from itertools import islice
from more_itertools import unique_everseen
from toolz import unique

res = list(islice(unique_everseen(a), 5))  # [1, 2, 3, 4, 5]
res = list(islice(unique(a), 5))           # [1, 2, 3, 4, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your objects are <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="noreferrer">hashable</a> (<code>int</code>s are hashable) you can write utility function using <a href="https://docs.python.org/3/library/stdtypes.html#dict.fromkeys" rel="noreferrer"><code>fromkeys</code> method</a> of <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="noreferrer"><code>collections.OrderedDict</code> class</a> (or starting from <em>Python3.7</em> a plain <code>dict</code>, since they became <a href="https://docs.python.org/3/whatsnew/3.7.html" rel="noreferrer">officially</a> ordered) like</p>
<pre><code>from collections import OrderedDict


def nub(iterable):
    """Returns unique elements preserving order."""
    return OrderedDict.fromkeys(iterable).keys()
</code></pre>
<p>and then implementation of <code>iterate</code> can be simplified to</p>
<pre><code>from itertools import islice


def iterate(itr, upper=5):
    return islice(nub(itr), upper)
</code></pre>
<p>or if you want always a <code>list</code> as an output</p>
<pre><code>def iterate(itr, upper=5):
    return list(nub(itr))[:upper]
</code></pre>
<h1>Improvements</h1>
<p>As @Chris_Rands mentioned this solution walks through entire collection and we can improve this by writing <code>nub</code> utility in a form of <a href="https://docs.python.org/3/glossary.html#term-generator" rel="noreferrer">generator</a> like others already did:</p>
<pre><code>def nub(iterable):
    seen = set()
    add_seen = seen.add
    for element in iterable:
        if element in seen:
            continue
        yield element
        add_seen(element)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>OrderedDict</code> or, since Python 3.7, an ordinary <code>dict</code>, since they are implemented to preserve the insertion order. Note that this won't work with sets.</p>
<pre><code>N = 3
a = [1, 2, 2, 3, 3, 3, 4]
d = {x: True for x in a}
list(d.keys())[:N]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a Pythonic approach using <code>itertools.takewhile()</code>:</p>
<pre><code>In [95]: from itertools import takewhile

In [96]: seen = set()

In [97]: set(takewhile(lambda x: seen.add(x) or len(seen) &lt;= 4, a))
Out[97]: {1, 2, 3, 4}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are really amazing answers for this question, which are fast, compact and brilliant! The reason I am putting here this code is that I believe there are plenty of cases when you don't care about 1 microsecond time loose nor you want additional libraries in your code for one-time solving a simple task.</p>
<pre><code>a = [1,2,2,3,3,4,5,6]
res = []
for x in a:
    if x not in res:  # yes, not optimal, but doesnt need additional dict
        res.append(x)
        if len(res) == 5:
            break
print(res)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming the elements are ordered as shown, this is an opportunity to have fun with the <code>groupby</code> function in itertools:</p>
<pre><code>from itertools import groupby, islice

def first_unique(data, upper):
    return islice((key for (key, _) in groupby(data)), 0, upper)

a = [1, 2, 2, 3, 3, 4, 5, 6]

print(list(first_unique(a, 5)))
</code></pre>
<p>Updated to use <code>islice</code> instead of <code>enumerate</code> per @juanpa.arrivillaga.  You don't even need a <code>set</code> to keep track of duplicates.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>set</code> with <code>sorted+ key</code> </p>
<pre><code>sorted(set(a), key=list(a).index)[:5]
Out[136]: [1, 2, 3, 4, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Given</strong></p>
<pre><code>import itertools as it


a = [1, 2, 2, 3, 3, 4, 5, 6]
</code></pre>
<p><strong>Code</strong></p>
<p>A simple list comprehension (similar to @cdlane's answer).</p>
<pre><code>[k for k, _ in it.groupby(a)][:5]
# [1, 2, 3, 4, 5]
</code></pre>
<p>Alternatively, in Python 3.6+:</p>
<pre><code>list(dict.fromkeys(a))[:5]
# [1, 2, 3, 4, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not use something like this? </p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 2, 3, 3, 4, 5, 6]
&gt;&gt;&gt; list(set(a))[:5]
[1, 2, 3, 4, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Example list:</h1>
<pre><code>a = [1, 2, 2, 3, 3, 4, 5, 6]
</code></pre>
<h1>Function returns all or count of unique items needed from list</h1>
<p>1st argument - list to work with, 2nd argument (optional) - count of unique items (by default - None - it means that all unique elements will be returned)</p>
<pre><code>def unique_elements(lst, number_of_elements=None):
    return list(dict.fromkeys(lst))[:number_of_elements]
</code></pre>
<p>Here is example how it works. List name is "a", and we need to get 2 unique elements: </p>
<pre><code>print(unique_elements(a, 2))
</code></pre>
<h1>Output:</h1>
<p><a href="https://i.stack.imgur.com/KZ1J7.png" rel="nofollow noreferrer"><img alt="output" src="https://i.stack.imgur.com/KZ1J7.png"/></a></p>
</div>
<span class="comment-copy">Try: <code>set(a)[:n]</code></span>
<span class="comment-copy">@TonyPellerin does not guarantee you get the first 5 elements</span>
<span class="comment-copy">Your code is Pythonic enough, it is just inefficient. <code>element not in itr[:index]</code> is not efficient, use a set</span>
<span class="comment-copy">Is the list always sorted?</span>
<span class="comment-copy">for the future: if your code works and you need to improve it, it is better to post it on <a href="https://codereview.stackexchange.com">codereview.stackexchange.com</a></span>
<span class="comment-copy">Instead of <code>if e in seen: continue</code>, <code>yield e</code> and <code>return</code>, you could also just <code>return list(seen)</code> at the end.</span>
<span class="comment-copy">@mkrieger1 That would not guarantee that the items returned would be in the same order they were encountered.</span>
<span class="comment-copy">yielding in order :) list(set) not</span>
<span class="comment-copy">Isn't there something like an ordered set?</span>
<span class="comment-copy">@mkrieger1 yeah, sure, but no built-in ones. You can always use an <code>OrderedDict</code> like a set, or just a plain <code>dict</code> in Python 3.7+</span>
<span class="comment-copy">The alternative would be creating an infinite generator and then <code>itertools.islice(gen, limit)</code></span>
<span class="comment-copy">Why not drop line 3 in you first block of code and do <code>seen.add(element)</code> instead?</span>
<span class="comment-copy">@jorijnsmit, It's an optimosation. One less lookup in each iteration of the for loop. You should notice the difference in very large loops.</span>
<span class="comment-copy">I was thinking of this, definitely short, but it is O(N)</span>
<span class="comment-copy">@Chris_Rands: updated</span>
<span class="comment-copy">In 3.6 order-preserving <code>dict</code>s were an implementation detail (in the reference implementation... not sure how alternative interpreters handled it). It wasn't official until 3.7.</span>
<span class="comment-copy">I think <code>d = dict.fromkeys(a)</code> would be better.</span>
<span class="comment-copy">By which definition is this abuse of the <code>or</code> operator considered <i>Pythonic</i>?</span>
<span class="comment-copy">@cdlane  By the definition in which this use of <code>or</code> is misuse.</span>
<span class="comment-copy">I think a proper function should be used instead of a lambda. Here the <code>seen.add</code> is not returning a boolean value, and still being used for truth checking. Your implementation saves us writing a generator function, which is welcome suggestion. But the <code>predicate</code> function should be more explicit.</span>
<span class="comment-copy">We've different concepts of <i>Pythonic</i>: <a href="https://blog.startifact.com/posts/older/what-is-pythonic.html" rel="nofollow noreferrer">To be Pythonic is to use the Python constructs and data structures with clean, readable idioms.</a></span>
<span class="comment-copy">I disagree this is Pythonic, <code>seen.add or len(seen) &lt;= 4</code> shouldn't be used in a function like <code>takewhile</code>, for the smae reasons you wouldn't use it in <code>map</code> or <code>filter</code></span>
<span class="comment-copy">Use <code>set</code> rather than <code>list</code> for O(1) lookup.</span>
<span class="comment-copy">@teng ... inefficient.</span>
<span class="comment-copy">@teng similarly inefficient.</span>
<span class="comment-copy"><code>in []</code> is no easier to read than <code>in {}</code>, bad justification</span>
<span class="comment-copy">@grapes but this is time-inefficient. Also, who cares about the line numbers? Do you suffer from a lack of lines? Didn'tsee your response to me. Yes, I agree, this implementation would work and is at least correct. I didn't downvote, btw.</span>
<span class="comment-copy">You might as well use <code>islice</code></span>
<span class="comment-copy">So <code>groupby</code> retains order, nice, but is it an implementation detail or a feature?</span>
<span class="comment-copy">@kubanczyk, yes <code>groupby</code> is mostly used with sorted data, where it becomes an aggregator.  If the OP's data weren't sorted, <code>groupby</code> wouldn't work for this problem.  However, <code>groupy</code> can be used with unsorted data to solve some other problems.  In that case it can be used to detect when data changes.</span>
<span class="comment-copy">This is inefficient.</span>
<span class="comment-copy">@xssChauhan this <i>will</i> return it in order, but this is inefficient O(n^2 * log n) I believe. You can do this in O(N)</span>
<span class="comment-copy">If order is not a strict requirement, then this works.   Keep in mind, sets are unordered.</span>
<span class="comment-copy">This is wrong as it may or may not return the <i>first</i> five unique elements.</span>
