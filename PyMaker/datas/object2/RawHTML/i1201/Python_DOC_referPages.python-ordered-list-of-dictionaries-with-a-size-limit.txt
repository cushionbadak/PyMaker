<div class="post-text" itemprop="text">
<p>This is a requirement for a chat application project that I'm creating with Python, Flask, Socketio, and Javascript:</p>
<p>"Messages View: Once a channel is selected, the user should see any messages that have already been sent in that channel, up to a maximum of 100 messages. Your app should only store the 100 most recent messages per channel in server-side memory."</p>
<p>So, what I think I should be doing is creating a list of dictionaries. Like this:</p>
<pre><code>messages = [ {"user":"Dave", "message":"Hello", "time":"12-24-2018"}, {"user":"John", "message":"Test", "time":"12-21-2018"} ]
</code></pre>
<p>My questions are..</p>
<ol>
<li>How do I append to/access a list of dictionaries like this?</li>
<li>How do I limit the size of the list, and replace the oldest element with the second oldest element as I add to it?</li>
<li>Is this the best practice for storing a fixed size of data server side?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>One possible solution is to use the double-ended queue implemented in the standard library's <a href="https://docs.python.org/3/library/collections.html#module-collections" rel="nofollow noreferrer">collections</a> package - <a href="https://docs.python.org/3/library/collections.html#deque-objects" rel="nofollow noreferrer"><code>collections.deque</code></a>.</p>
<p>Deques are similar to lists, but support efficient appending and popping from both ends, are threadsafe, and can be specified to have a maximum length.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; dq = collections.deque(maxlen=5)
&gt;&gt;&gt; for i, x in enumerate('abcde'):
...    dq.append({x: i})
... 
&gt;&gt;&gt; dq
deque([{'a': 0}, {'b': 1}, {'c': 2}, {'d': 3}, {'e': 4}], maxlen=5)
</code></pre>
<p>If you add an element to a deque which has <em>maxlen</em> set, and which is already at maximum size, an element is removed from the other end of the deque:</p>
<pre><code>&gt;&gt;&gt; dq.append({'f': 5})
&gt;&gt;&gt; dq
deque([{'b': 1}, {'c': 2}, {'d': 3}, {'e': 4}, {'f': 5}], maxlen=5)

&gt;&gt;&gt; dq.appendleft({'z': 25})   
&gt;&gt;&gt; dq
deque([{'z': 25}, {'b': 1}, {'c': 2}, {'d': 3}, {'e': 4}], maxlen=5)
</code></pre>
<p>It's worth noting that Python's json module doesn't handle deques, so if you want to dump the deque to json you'll need to provide a function that converts the deque to a list:</p>
<pre><code>&gt;&gt;&gt; json.dumps(dq)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  ...
TypeError: Object of type deque is not JSON serializable
&gt;&gt;&gt; def jdq(o):
...     return list(o)
... 
&gt;&gt;&gt; json.dumps(dq, default=jdq)
'[{"z": 25}, {"b": 1}, {"c": 2}, {"d": 3}, {"e": 4}]'
</code></pre>
<p>To recreate the deque from a json array, just pass the deserialised list to a new deque:</p>
<pre><code>&gt;&gt;&gt; L = json.loads('[{"z": 25}, {"b": 1}, {"c": 2}, {"d": 3}, {"e": 4}]')
&gt;&gt;&gt; dq = collections.deque(L, maxlen=5)
&gt;&gt;&gt; dq
deque([{'z': 25}, {'b': 1}, {'c': 2}, {'d': 3}, {'e': 4}], maxlen=5)
</code></pre>
</div>
<span class="comment-copy">You'll want to use a <code>threading.Lock</code>, <code>list.append</code>, and <code>list.pop</code>. The requirements seem to infer that you'll just store this list in memory, so I don't understand your third point</span>
<span class="comment-copy">1. appending to list of dictionaries is simple. Create a new dictionary of single message like <code>msg = {"user":"Dave", "message":"Hello", "time":"12-24-2018"}</code> and then <code>messages.append(msg)</code> to add the message to the list.  2. Limiting the size of the list: Slice the list of messages as: <code>messages = messages[-100:]</code>  3. This point is unclear, can you explain a little more?</span>
