<div class="post-text" itemprop="text">
<p>I am writing a syscall wrapper for python(just as a fun project to get me used to the API),<br/> and when I came upon implementing read(), I am perplexed as to how I can modify a python buffer that is sent to my function.</p>
<p>The function is a simple cpython wrapper around the read() syscall.<br/>
It takes an integer (the file descriptor), a buffer, and the maximum you want to read, then returns the amount read.</p>
<p>I have everything working except for the modification of the buffer:</p>
<pre><code>py_obj py_read(py_obj self, py_obj args){
    char* buff;
    int fd;
    int len;

    if(!PyArg_ParseTuple(args, "isi", &amp;fd, &amp;buff, &amp;len)){
        return NULL;
    }

    return Py_BuildValue("i", read(fd, buff, len));
}
</code></pre>
<p>After loading the module, then calling read:</p>
<pre><code>&gt;&gt; from syscalls import read
&gt;&gt; STDIN = 1
&gt;&gt; s = ""
&gt;&gt; read(STDIN,s, 256)
napkin
7
&gt;&gt; s
""
</code></pre>
<p>Though this is what I expected (and is what should happen, since I did not have an actual reference to the argument), I would like to know how to get a reference to the parameter.</p>
<p><strong>EDIT</strong>:
After using @user2357112, it still does not modify the value</p>
<pre><code>&gt;&gt;&gt; b = memoryview(b"")
&gt;&gt;&gt; from syscalls import *
&gt;&gt;&gt; read(1, b, 10)
test
5
&gt;&gt;&gt; b
&lt;memory at 0x7fa060628408&gt;
&gt;&gt;&gt; b.tolist()
[]
&gt;&gt;&gt;
</code></pre>
<p><strong>EDIT 2</strong>:
But it does work with bytearray, if I size it correctly
Thank you  @user2357112</p>
</div>
<div class="post-text" itemprop="text">
<p>You <em>have</em> a reference to the argument. You may have just corrupted the argument object or the memory surrounding it, in fact. You don't have a reference to the caller's <code>s</code> variable, but variables and references don't work like that in Python anyway; references always refer to objects.</p>
<p>Python string objects aren't appropriate for use as mutable buffers. They're supposed to be immutable, after all. Also, they're Unicode, and <code>read</code> reads bytes. Instead, use an appropriately-sized <a href="https://docs.python.org/3/library/stdtypes.html#bytearray" rel="nofollow noreferrer"><code>bytearray</code></a> and view its contents through a <a href="https://docs.python.org/3/c-api/buffer.html#c.Py_buffer" rel="nofollow noreferrer"><code>Py_buffer</code></a> structure with the <code>y*</code> format code.</p>
<p>Also, since <code>read</code> returns <code>ssize_t</code> rather than <code>int</code>, you should use the <code>n</code> format code rather than <code>i</code>. <code>n</code> corresponds to <code>Py_ssize_t</code>, which is intended to match <code>ssize_t</code> when <code>ssize_t</code> exists.</p>
<pre><code>PyObject *my_read(PyObject *self, PyObject *args){
    Py_buffer buff;
    int fd;
    int len;

    if(!PyArg_ParseTuple(args, "iy*i", &amp;fd, &amp;buff, &amp;len)){
        return NULL;
    }

    ssize_t read_count = read(fd, buff.buf, len);
    PyBuffer_Release(&amp;buff);

    return Py_BuildValue("n", read_count);
}
</code></pre>
</div>
<span class="comment-copy">This question is way too broad. It isn't clear what you've tried, what your desired outcome is or what the problem is! Please consult <a href="https://stackoverflow.com/help/how-to-ask">stackoverflow.com/help/how-to-ask</a> and <a href="https://stackoverflow.com/help/mcve">stackoverflow.com/help/mcve</a>.</span>
<span class="comment-copy">Thank you @Karl for notifying me!  I realize it way too unclear.   Now knowing that I have updated the question and provided examples to clarify.</span>
<span class="comment-copy">read() does not except a Py_buffer as the second param</span>
<span class="comment-copy">@Mememyselfandaverycreepy: I could've sworn I had the <code>.buf</code>. Fixing...</span>
<span class="comment-copy">@Mememyselfandaverycreepy: I don't know what you mean by "memoryviewer". Did you size the bytearray appropriately?</span>
<span class="comment-copy">@Mememyselfandaverycreepy: Yes, but you should consider your design objectives first. If your goal is to have a very direct translation between the Python interface and the C <code>read</code> function, then you should require the user to provide an appropriately-sized buffer, just like what the C interface requires. If you want a convenient Python interface, then why have the user provide a buffer at all? You could just make your own bytearray - or you could just use the existing <a href="https://docs.python.org/3/library/os.html#os.read" rel="nofollow noreferrer"><code>os.read</code></a>, or you could just use a file object the usual way.</span>
<span class="comment-copy">You could technically use other objects that expose the buffer interface, but a bytearray is probably the most appropriate.</span>
