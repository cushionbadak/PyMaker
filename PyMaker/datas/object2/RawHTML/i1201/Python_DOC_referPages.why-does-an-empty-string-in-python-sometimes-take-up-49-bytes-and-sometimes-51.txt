<div class="post-text" itemprop="text">
<p>I tested <code>sys.getsize('')</code> and <code>sys.getsize(' ')</code> in three environments, and in two of them <code>sys.getsize('')</code> gives me 51 bytes (one byte more than the second) instead of 49 bytes:</p>
<p>Screenshots:</p>
<p>Win8 + Spyder + CPython 3.6:</p>
<p><a href="https://i.stack.imgur.com/wfnbD.png" rel="noreferrer"><img alt="sys.getsizeof('') == 49 and sys.getsizeof(' ') == 50" src="https://i.stack.imgur.com/wfnbD.png"/></a></p>
<p>Win8 + Spyder + IPython 3.6:</p>
<p><a href="https://i.stack.imgur.com/PDD8i.png" rel="noreferrer"><img alt="sys.getsizeof('') == 51 and sys.getsizeof(' ') == 50" src="https://i.stack.imgur.com/PDD8i.png"/></a></p>
<p>Win10 (VPN remote) + PyCharm + CPython 3.7:</p>
<p><a href="https://i.stack.imgur.com/JYvR8.png" rel="noreferrer"><img alt="sys.getsizeof('') == 51 and sys.getsizeof(' ') == 50" src="https://i.stack.imgur.com/JYvR8.png"/></a></p>
<p><strong>First edit</strong></p>
<p>I did a second test in Python.exe instead of Spyder and PyCharm (These two are still showing 51), and everything seems to be good. Apparently I don't have the expertise to solve this problem so I'll leave it to you guys :)</p>
<p>Win10 + Python 3.7 console versus PyCharm using same interpreter:</p>
<p><a href="https://i.stack.imgur.com/c7Boq.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/c7Boq.png"/></a></p>
<p>Win8 + IPython 3.6 + Spyder using same interpreter:</p>
<p><a href="https://i.stack.imgur.com/GhOfC.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/GhOfC.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>This sounds like something is retrieving the wchar representation of the string object. As of CPython 3.7, the way the CPython Unicode representation works out, an empty string is normally stored in "compact ASCII" representation, and the base data and padding for a compact ASCII string on a 64-bit build works out to 48 bytes, plus one byte of string data (just the null terminator). You can see the relevant header file <a href="https://github.com/python/cpython/blob/v3.7.0/Include/unicodeobject.h#L198" rel="noreferrer">here</a>.</p>
<p>For now (this is <a href="https://docs.python.org/3/c-api/unicode.html#deprecated-py-unicode-apis" rel="noreferrer">scheduled for removal</a> in 4.0), there is also an option to retrieve a wchar_t representation of a string. On a platform with 2-byte wchar_t, the wchar representation of an empty string is 2 bytes (just the null terminator again). The wchar representation is cached on the string on first access, and <code>str.__sizeof__</code> accounts for this extra data when it exists, resulting in a 51-byte total.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3.5/library/sys.html#sys.getsizeof" rel="nofollow noreferrer">https://docs.python.org/3.5/library/sys.html#sys.getsizeof</a> </p>
<p><code>sys</code> is system specific so it can easily differ. This is often overlooked by everyone. All system specific stuff in python has been dumped in the <code>sys</code> package for years. For e.g <code>sys.getwindowsversion()</code> is not portable by definition but it's there. It like the bottomless pit of rejects in the perfect world of cross platform coding. What you see is one of the interesting nuggets of Python.</p>
<p>from <code>getsizeof</code> docs:</p>
<blockquote>
<p>Only the memory consumption directly attributed to the object is accounted for, not the memory consumption of objects it refers to.
  <code>getsizeof()</code> calls the objectâ€™s <code>__sizeof__</code> method and adds an additional garbage collector overhead if the object is managed by the garbage collector.</p>
</blockquote>
<p>When Garbage collection is in use the OS will add those extra bits. If you read Python and GC Q &amp; A <a href="https://stackoverflow.com/questions/9449489/when-are-objects-garbage-collected-in-python">When are objects garbage collected in python?</a> the folks have gone into excruciating detail expounding the GC and how it will affect the memory/refcount and bits blah blah.</p>
<p>I hope that explains where this coming from. If you don't use <code>system</code> level attributes but more pythonic attributes then you will get consistent sizes.</p>
</div>
<span class="comment-copy">My burning question is "why does it matter?". But anyway, Spyder will also be throwing that into a shared namespace</span>
<span class="comment-copy">@roganjosh Actually I think it doesn't matter because my job as a data analyst doesn't ask me to dig deep into the object model, but I'm scratching my head to understand the why behind this. I wish I have other OS e.g. Linux to test this. BTW does this have something to do with the "shared namespace" you said?</span>
<span class="comment-copy">My job is also data scientist/data analyst. This behaviour is inconsequential, but I don't want to invalidate your question (curiosity is fine). Spyder has a complex namespace, you must have observed how things are available in the console from your main scripts...</span>
<span class="comment-copy">@AndreyTyukin No I just want to see if someone else has encountered this weird thing before, and more importantly, if an empty string does have 1 more byte than a string with one char, it means that my understanding of the string object could be totally wrong. If you think this is normal, then sorry, because I'm not professional software developer and this is indeed weird to me. For now I'm settled with this issue as a second test with Python.exe console shows 49.</span>
<span class="comment-copy">The most likely candidate seems to be that strings cache a version encoded with UTF-8 when first required.</span>
<span class="comment-copy">the getsizeof() does refer to <code>__sizeof__</code> internally. This is the correct answer</span>
<span class="comment-copy">Thanks! Although I don't get the full pic this seems to explain the source of 51-byte. Just curious, why does Spyder with CPython give me 49-byte but shows 51-byte for IPython on the same PC? I figured from your answer that it has something to do with the size of wchar, and in turn the IDEs get 2 bytes because it's OS-specified, but I think it should be the same for all interpreters? Anyway I may misunderstand your answer...</span>
<span class="comment-copy">@NicholasHumphrey: Something is retrieving the wchar representation in your IPython tests. (Also, your IPython tests are also using CPython; CPython is the interpreter implementation IPython runs on.)</span>
<span class="comment-copy">This is largely unrelated to the question, but seeing a reference to a "[Python] 4.0" is giving me anxiety...</span>
<span class="comment-copy">@MikeCaron and others: fear not.  References to '4.0' means 'some future release after 2.7 support ends (2020 Jan).   Some post-deprecation removals have been delayed to make migration easier for those who prefer smaller steps.  Things deprecated in 3.3, about 6 years ago, might otherwise have gone away in 3.5.  We no longer allow new references to a fictional '4.0'.  I just suggested in <a href="https://bugs.python.org/issue35616" rel="nofollow noreferrer">bugs.python.org/issue35616</a> that we 'backport' this policy to older notices, precisely to avoid 'anxieties' that no one needs.</span>
<span class="comment-copy">It's not GC data. String objects are never tracked by the GC; they don't have that data. Also, the same objects would have GC data on all the configurations the questioner tested.</span>
<span class="comment-copy">Then I stand to be corrected. it may not be GC. However the difference in representation still applies and is system specific. It could be OS+runtime</span>
