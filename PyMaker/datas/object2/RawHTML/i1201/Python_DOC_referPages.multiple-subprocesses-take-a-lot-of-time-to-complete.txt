<div class="post-text" itemprop="text">
<p>I have a single process that is run using <code>subprocess</code> module's <code>Popen</code>:</p>
<pre><code>result = subprocess.Popen(['tesseract','mypic.png','myop'])
st = time()
while result.poll() is None:
    sleep(0.001)
en = time()

print('Took :'+str(en-st))
</code></pre>
<p>Which results in: </p>
<pre><code>Took :0.44703030586242676
</code></pre>
<p>Here, a <code>tesseract</code> call is made to process an image <code>mypic.png</code>(attached) and output the OCR's result to <code>myop.txt</code>.</p>
<p><a href="https://i.stack.imgur.com/NJM1Z.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/NJM1Z.png"/></a></p>
<p>Now I want this to happen on multiple processes on behalf of <a href="https://stackoverflow.com/questions/13606867/what-is-the-difference-between-multiprocessing-and-subprocess/13606946?noredirect=1#comment94493006_13606946">this comment</a>  (or see <a href="https://stackoverflow.com/questions/16071866/non-blocking-subprocess-call">this directly</a>), so the code is here:</p>
<pre><code>lst = []
for i in range(4):
    lst.append(subprocess.Popen(['tesseract','mypic.png','myop'+str(i)]))

i=0
l = len(lst)
val = 0 
while(val!=(1&lt;&lt;l)-1):
    if(lst[i].poll() is None):
        print('Waiting for :'+str(i))
        sleep(0.01)
    else:
        temp = val
        val = val or (1&lt;&lt;(i))
        if(val!=temp):
            print('Completed for :'+temp)
    i = (i+1) %l
</code></pre>
<p>What this code does is make 4 calls to <code>tesseract</code>, save the process objects in a list <code>lst</code>, iterate through all of these objects until <strong>all</strong> of them are completed. Explanation for the implementation of the infinite loop is given at the bottom. </p>
<p>The problem here is that the latter program is taking a hell lot of time to complete. It is continuously waiting for the processes to complete using <code>poll()</code> function, which is <code>None</code> until the process has not been completed. This should not have happened. It should have taken a little more than 0.44s only. Not something like 10 minutes! Why is this happening?</p>
<p>I came to this specific error by digging into <code>pytesseract</code>, which was taking a lot of time when run parallely using <code>multiprocessing</code> or <code>pathos</code>. So this is a scaled down version of a much bigger issue. My question on that can be found <a href="https://stackoverflow.com/questions/53468446/pytesseract-call-working-very-slow-when-used-along-with-multiprocessing">here</a>.</p>
<hr/>
<p>Explanation for the infinite loop:
<code>val</code> is 0 initially. It is ORed with the <code>2^i</code> when the ith process completes. So, if there are 3 processes, then if the first process(i=0) is completed then <code>2^0 = 1</code> is OR'ed with <code>val</code> making it 1. With second and third processes being completed, <code>val</code> becomes <code>2^0</code> | <code>2^1</code> | <code>2^2</code> = 7. And <code>2^3-1</code> is also 7. So the loop works until <code>val</code> equals <code>2^{number of processes}-1</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Per <a href="https://github.com/tesseract-ocr/tesseract/wiki/FAQ#can-i-increase-speed-of-ocr" rel="nofollow noreferrer">the faq</a> (with my emphasis):</p>
<blockquote>
<p>Tesseract 4 also uses up to four CPU threads while processing a page, so it will be faster than Tesseract 3 for a single page.</p>
<p>If your computer has only two CPU cores, then running four threads will slow down things significantly and it would be better to use a single thread or maybe a maximum of two threads! <strong>Using a single thread eliminates the computation overhead of multithreading and is also the best solution for processing lots of images by running one Tesseract process per CPU core</strong>.</p>
<p>Set the maximum number of threads using the environment variable OMP_THREAD_LIMIT.</p>
<p>To disable multithreading, use OMP_THREAD_LIMIT=1.</p>
</blockquote>
<p>Therefore, if you wish to run multiple tesseract processes concurrently, you may wish to decrease (or experiment with) OMP_THREAD_LIMIT.
The optimal value depends on how many threads your machine can support concurrently.</p>
<p>For example, on my machine:</p>
<pre><code>import subprocess
import time
import os 

t = time.perf_counter()    
tasks = [('mypic.png', 'myop{}'.format(i)) for i in range(4)]
procs = [subprocess.Popen(['tesseract', infile, outfile], env={'OMP_THREAD_LIMIT':'1'})
         for infile, outfile in tasks]
for proc in procs:
    proc.wait()
print('{} s'.format(time.perf_counter()-t))
</code></pre>
<p>completes in 0.220 seconds, whereas the same code without <code>env={'OMP_THREAD_LIMIT':'1'}</code>
typically takes between 3.1 -- 5.1 seconds, with a lot of variation between runs.</p>
<hr/>
<p>To get your code working, use the <a href="https://docs.python.org/3/reference/expressions.html#binary-bitwise-operations" rel="nofollow noreferrer">binary bitwise or operator, <code>|</code></a> instead of the <a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="nofollow noreferrer">logical or operator, <code>or</code></a>:</p>
<pre><code>val = val | (1 &lt;&lt; (i))
</code></pre>
<p>For example,</p>
<pre><code>import time
import subprocess
lst = []
for i in range(4):
    lst.append(subprocess.Popen(['tesseract', 'mypic.png', 'myop'+str(i)]))

i = 0
l = len(lst)
val = 0
counter = 0
while(val != (1 &lt;&lt; l)-1):
    if(lst[i].poll() is None):
        time.sleep(0.001)
    else:
        temp = val
        val = val | (1 &lt;&lt; (i))
        if(val != temp):
            print('Completed for : {}'.format(i))
    i = (i+1) % l

    counter += 1
print('{} iterations'.format(counter))
</code></pre>
<p>prints output like</p>
<pre><code>Completed for : 1
Completed for : 2
Completed for : 3
Completed for : 0
6121 iterations
</code></pre>
<p>Notice the loop still iterates thousands of times, mainly while <code>lst[i].poll()</code> returns <code>None</code>,
but also because <code>i = (i+1) % l</code> can revisit the same value multiple times.
If one iteration takes 0.001s, then 6121 iterations will take 6.121s. So the <code>while</code> loop is complicated and not very fast.</p>
</div>
<span class="comment-copy">You might want to have a look <a href="https://stackoverflow.com/questions/28866651/python-concurrent-futures-using-subprocess-with-a-callback">here</a>, how to run multiple subprocesses easily in parallel.</span>
<span class="comment-copy">Beautiful! Thanks!</span>
<span class="comment-copy">For anyone looking for the exact command: <code>OMP_THREAD_LIMIT=1 tesseract &lt;image-name&gt; &lt;output-file/stream&gt; &lt;optional-configurations&gt;</code></span>
