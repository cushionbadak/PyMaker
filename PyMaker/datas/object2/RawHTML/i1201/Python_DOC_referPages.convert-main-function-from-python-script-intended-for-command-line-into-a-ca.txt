<div class="post-text" itemprop="text">
<p>I am working with someone's GitHub code that is designed to be called from the command line like so:</p>
<pre><code>&gt; python this_script.py -u &lt;username&gt; -p &lt;password&gt; -i &lt;id_num&gt; ...
</code></pre>
<p>This produces an output text file after parsing the inputs in such a manner within <code>this_script.py</code>:</p>
<pre><code>if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='get data', add_help=False, usage='this_script.py -u username -p password [options]')
    parser.add_argument('-u', metavar='&lt;STR&gt;', type=str, help='username')
    parser.add_argument('-p', metavar='&lt;STR&gt;', type=str, help='password')
    parser.add_argument('-i', metavar='&lt;STR&gt;', nargs='+', type=str, help='List of IDs')
    ...
</code></pre>
<p>I want to use many of these text files within my own set of code, so it would be much more convenient for me to convert this from a command line script to a callable function, with syntax something like this:</p>
<pre><code>def this_script(password, username, *args):
    ...
</code></pre>
<p>Is there a simple way to do this, without have to mess around too much with the inner workings of the <code>__main__</code> block as currently defined?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, the simple way is to use stdlib <a href="https://docs.python.org/3/library/runpy.html" rel="nofollow noreferrer"><code>runpy</code></a>.</p>
<pre><code>import runpy

runpy.run_module(mod_name, init_globals=None, run_name=None, alter_sys=False)
</code></pre>
<p>And, please make a mental note never to write your own scripts like that.  There should only ever be a single line under the conditional, and it should be a call to a function with no arguments, like this:</p>
<pre><code>if __name__ == "__main__":
    main()
</code></pre>
<p>Anything more is too much.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about:</p>
<pre><code>def do_stuff(args):
    print(args.u)
    print(args.p)


def main(args_list=None):
    parser = argparse.ArgumentParser(description='get data', add_help=False, usage='this_script.py -u username -p password [options]')
    parser.add_argument('-u', metavar='&lt;STR&gt;', type=str, help='username')
    parser.add_argument('-p', metavar='&lt;STR&gt;', type=str, help='password')
    parser.add_argument('-i', metavar='&lt;STR&gt;', nargs='+', type=str, help='List of IDs')
    ...

    if args_list:
        args= parser.parse_args(args_list)
    else:
        args = parser.parse_args()

    do_stuff(args)


if __name__ == "__main__":
    main()
</code></pre>
<p>This way, you can call the script from command line, or from somewhere whithin your code e.g. with:</p>
<pre><code>main(['-u', 'my_username', '-p', 'my_password'])
</code></pre>
</div>
<span class="comment-copy">I don't see any function called <code>main</code> in your examples? It completely depends on the code... Usually you can just put everything into a function and be done, but this is not the case if the code relies on globals&amp;stuff. And how to refactor that completely depends on the specific code. Your question as stated is too broad. You should provide a concrete example, your attempt and what is wrong with it.</span>
<span class="comment-copy">The quick&amp;dirty solution would be to assign to <code>sys.argv</code> and then run that code unchanged: <code>sys.argv = ['blah', '-u', username, '-p', password] + args</code></span>
<span class="comment-copy">@Bakuriu I thought I showed the <b>main</b> code here? As far as I understand, that is the function that is called when the script is run from the command line, right?</span>
<span class="comment-copy">By convention, inside <code>__main__</code> block is usually a call to a function named <code>main</code>.  Likely your wording was misleading, so have edited it to avoid the confusion. If, after the arguments are parsed, the script then calls a worker function with parsed arguments, then it's possibly you can just call that worker function directly - which is what Bakuriu was getting at. Regardless, the author of the script has put the argument parsing in the wrong place.</span>
<span class="comment-copy">@wim Unfortunately there is not any worker function in this case. It leads into <code>args = parser.parse_args()</code> and then <code>args.u</code>, <code>args.p</code>, etc. are used throughout the function. Would it then be necessary for me to design my own function to get all these inputs? I want to leave as much code as I can untouched.</span>
<span class="comment-copy">So I've moved all the code from under <code>if __name__ == "__main__":</code> to its own method <code>main()</code>, but now I'm not sure how I can pass it any inputs, given that it has no arguments. What would be the standard procedure for this?</span>
<span class="comment-copy">Standard procedure is for <code>main</code> to parse the arguments from CLI, and <i>then</i> it calls some other function <code>do_stuff(...)</code> and it's passing in the <i>parsed</i> arguments.  In your case, you would call <code>do_stuff</code> directly since you presumably don't need to parse username/password from CLI but instead are reading them from a file or whatever.</span>
<span class="comment-copy">Ah I see. So I'm now thinking I need to refactor all the following code where <code>args.i</code>, 'args.u<code>, and </code>args.p` etc. are called, by assigning them proper variable names which will be arguments to my <code>do_stuff()</code> function, like <code>def do_stuff(var_i=None, var_u=None, var_p=None, ...)</code>. Although, there are like 15-20 variables here; is there an easier way to do that? This would require me doing <code>var_i = args.i; var_p = args.p; ...</code> inside <code>main()</code> in order to call it within that function. Is that just the price of admission here?</span>
<span class="comment-copy">Yes. Once the arguments are parsed, you shouldn't really be passing around the argparse namespace object itself.  It's just a simple container for the convenience of having one object returned by parser.parse_args().</span>
<span class="comment-copy">That makes sense to me I am curious, however, why the <code>parse_args()</code> method returns a <code>Namespace</code> object. What is the advantage of this over a simple <code>dict</code>?</span>
