<div class="post-text" itemprop="text">
<p>I've a follow list below. I'd like to transfer each item from list to different variables individually without to know its length</p>
<p>For example, consider the following list:</p>
<pre><code>list1 = ['item1', 'item2', 'item3', 'item4']
</code></pre>
<p>The result expected is:</p>
<pre><code>var1 = 'item1'
var2 = 'item2'
var3 = 'item3'
var4 = 'item4'
</code></pre>
<p>The real objective is avoid "out of range" error. Because I won't know the list length, and it can vary.</p>
<p>In another moment, for example, the list could be:</p>
<pre><code>list1 = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7']
</code></pre>
<p>In this case, the result expected would be:</p>
<pre><code>var1 = 'item1'
var2 = 'item2'
var3 = 'item3'
var4 = 'item4'
var5 = 'item5'
var6 = 'item6'
var7 = 'item7'
</code></pre>
<p>Let me give you a real case. My script connect to a firewall and execute the following command:</p>
<blockquote>
<p>nameif = net_connect.send_command("show nameif")</p>
</blockquote>
<pre><code>MM1MDA-VRJRAE-SM01/act# show nameif
Interface                Name                     Security
Management0/0            mgmt                      99
TenGigabitEthernet1/7    dmzncl                    75
Port-channel1.279        dmz3                      80
Port-channel1.291        dmz5                      50
Port-channel1.293        dmz4                      70
Port-channel1.295        dmzvdi                    60
Port-channel1.2021       dmzvdi1                   60
</code></pre>
<p>The output from this command can vary, depending how many interfaces there is on device. There are cases that it can have 3 interfaces, 4 interfaces or much more... So,  I filter to a list: </p>
<blockquote>
<p>nameif_entry = nameif.split()</p>
</blockquote>
<p>After I remove other information that it doesn't matter:</p>
<blockquote>
<p>del nameif_entry[0:4]</p>
<p>nameif_edited = nameif_entry[::3]</p>
<p>print (nameif_edited)</p>
<p>['mgmt', 'dmzncl', 'dmz3', 'dmz5', 'dmz4', 'dmzvdi', 'dmzvdi1']</p>
</blockquote>
<p>After I run the following lines and send to many lists as below:</p>
<blockquote>
<p>int_0 = net_connect.send_command("show route %s %s" %(nameif_edited[0],src_ip))</p>
<p>int_1 = net_connect.send_command("show route %s %s" %(nameif_edited[1],src_ip))</p>
<p>int_2 = net_connect.send_command("show route %s %s" %(nameif_edited[2],src_ip))</p>
<p>int_3 = net_connect.send_command("show route %s %s" %(nameif_edited[3],src_ip))</p>
<p>int_4 = net_connect.send_command("show route %s %s" %(nameif_edited[4],src_ip))</p>
<p>int_5 = net_connect.send_command("show route %s %s" %(nameif_edited[5],src_ip))</p>
<p>int_6 = net_connect.send_command("show route %s %s" %(nameif_edited[6],src_ip))</p>
<p>int_7 = net_connect.send_command("show route %s %s" %(nameif_edited[7],src_ip))</p>
<p>int_8 = net_connect.send_command("show route %s %s" %(nameif_edited[8],src_ip))</p>
<p>int_9 = net_connect.send_command("show route %s %s" %(nameif_edited[9],src_ip))</p>
<p>int_10 = net_connect.send_command("show route %s %s" %(nameif_edited[10], src_ip))</p>
</blockquote>
<p>So it's here where the problem occurs. I receive a following error:</p>
<blockquote>
<p>int_7 = net_connect.send_command("show route %s %s"
  %(nameif_edited[7], src_ip)) IndexError: list index out of range</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>If you do not know how long the list is beforehand, how do you plan to put enough variables into your source code to hold them?</p>
<p>Generally speaking if you have a list </p>
<pre><code>list1 = ['item1', 'item2', 'item3', 'item4']
</code></pre>
<p>and you want to do something with each element, you would do:</p>
<pre><code>for elem in list1:
    print(elem)  # this prints each element on a new line
</code></pre>
<p>You do not need an index <em>at all</em> (80+% of the time). If you need the index as well, use <code>enumerate()</code>:</p>
<pre><code>for index,elem in enumerate(list1):
    print(index, elem)    
</code></pre>
<p>Output:</p>
<pre><code>0 item1
1 item2
2 item3
3 item4
</code></pre>
<hr/>
<p>If you have an upper bound for your elements and "harmless" defaults you can cheat a bit:</p>
<pre><code>a,b,c,d,e,f,g,h,i,k, *_ = list1 + [""]* 11  
</code></pre>
<p>In this case the letters will be filled with the elements of list1 and any "non-present" element will take one of the empty strings. <code>*_</code> will consume the rest of the list.</p>
<p>This only works for small ranges though - f.e. if you get 3-8 strings, and want to have "" for any that is not provided. I might use that if I need several of those strings together at once and not after one another.</p>
<p>Example:</p>
<pre><code>list1 = ['item1', 'item2', 'item3','item4']
a,b,c,d,e,f,g,h,i,k, *_ = list1 + [""]* 11    # extract into 11 vars

for elem in [a,b,c,d,e,f,g,h,i,k,_]:    # stuff all of them back into a list to print
    print(elem)                         # using less code - lists are cool
</code></pre>
<p>Output:</p>
<pre><code>item1  # a
item2  # b
item3  # c
item4  # d
       # e
       # f
       # g
       # h
       # i
       # k
['', '', '', '', '']  # _
</code></pre>
<p>Doku:</p>
<ul>
<li><a href="https://docs.python.org/3/tutorial/controlflow.html#for-statements" rel="nofollow noreferrer">for loops</a></li>
<li><a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate()</a></li>
<li><a href="https://docs.python.org/3/library/functions.html" rel="nofollow noreferrer">list of built in functions</a></li>
</ul>
<hr/>
<p>Example for using the list decomposition (and a smarter way to do it - there almost always is a better way then resorting to the "cheaty" list decomposition with default values).</p>
<p><strong>Task:</strong> calculate   <code>f(x) = k_0 + k_1*x +k_2*x**2 + ...</code> for up to <code>x**5</code> from a user inputted list, that has 1 to 6 elements:</p>
<pre><code>def calc_f(my_coeff, x):
    # padd list with enough 0 (neutral in our case) to avoid indexerrors
    """Using decomposition"""
    padded_list =  my_coeff + [0] * 6
    # extract into vars
    a,b,c,d,e,f,*_ = padded_list
    return a + b*x +c*x**2 + d*x**3 + e*x**4 + f*x**5  

def calc_f_loop_1(my_coeff,x):
    """Using simple loop and manual sum"""
    s = 0
    idx = 0
    # basic approach without enumerate
    for elem in my_coeff:
        s += elem*x**idx
        idx+=1
    return s

def calc_f_loop_2(my_coeff,x):
    """Using better loop, still manual sum"""
    s = 0
    for idx, elem in enumerate(my_coeff):
        s += elem*x**idx
        idx+=1
    return s
</code></pre>
<p>all of those work ... but this is smarter (and more conceise):</p>
<pre><code>calc_f_smarter = lambda l,x: sum( pl*x**idx for idx,pl in enumerate(l) )
</code></pre>
<p><strong>Test:</strong></p>
<pre><code>list1 = [5, 3, 3, 4] # variable input - max. 6 numbers
for method, f in (
          ("calc_f",calc_f),
          ("calc_f_loop_1",calc_f_loop_1),
          ("calc_f_loop_2",calc_f_loop_2),
          ("calc_f_smarter",calc_f_smarter)):

    print(f"{method:&lt;15}:", [f(list1,x) for x in range(-5,5)])
</code></pre>
<p>Outputs:</p>
<pre><code>calc_f         : [-435, -215, -85, -21, 1, 5, 15, 55, 149, 321]
calc_f_loop_1  : [-435, -215, -85, -21, 1, 5, 15, 55, 149, 321]
calc_f_loop_2  : [-435, -215, -85, -21, 1, 5, 15, 55, 149, 321]
calc_f_smarter : [-435, -215, -85, -21, 1, 5, 15, 55, 149, 321]
</code></pre>
</div>
<span class="comment-copy">How are you planning on referring to these variables outside of a collection when you don't know how many there are going to be?</span>
<span class="comment-copy"><i>"The real objective is avoid "out of range" error."</i> - Your approach won't fix that. And since checking the length of a list is trivial this also seems to create a problem where none exists</span>
<span class="comment-copy">Just use the list. Creating numbered variables is going to give you more problems, not less.</span>
<span class="comment-copy">While this question is misguided, I'm upvoting it because it does state <i>a</i> problem clearly, although a self-induced one, and has a straightforward answer (don't do this; use a <code>for</code> loop or <code>len</code>) and it's a common mistake. A Q&amp;A can be used as a signpost / canonical for future questions.</span>
