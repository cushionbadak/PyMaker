<div class="post-text" itemprop="text">
<p>I want to use RegEx to find the first sequence within a string where a set of words appears, by any order.</p>
<p>For example, if looking for the words <code>hello</code>, <code>my</code> and <code>world</code>, then:</p>
<ul>
<li>for <code>hello my sweet world</code> the expression would match <code>hello my sweet world</code>;</li>
<li>for <code>oh my, hello world</code> it would match <code>my, hello world</code>;</li>
<li>for <code>oh my world, hello world</code> it would match <code>my world, hello</code>;</li>
<li>for <code>hello world</code> there would be no match.</li>
</ul>
<p>After some research, I tried the expression <code>(?=.*?\bhello\b)(?=.*?\bmy\b)(?=.*?\bworld\b).*</code>, which does not solve my problem, as it matches the whole string if all words are present, as in:</p>
<ul>
<li>for <code>oh my world, hello world</code> it matches <code>oh my world, hello world</code></li>
</ul>
<p>What would be the apropriate expression to achieve what I described?</p>
<p>(Although RegEx is the preferred method for my program, if you think is not the way to go, any other python solution is welcome.)</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this task best gets done with some programming logic and regex wouldn't be easy and efficient. But here is a regex that seems to be doing your job and doesn't matter whether you have repeating words (hello my world) present or not,</p>
<pre><code>\b(hello|my|world)\b.*?((?!\1)\b(?:hello|my|world)\b).*?(?:(?!\1)(?!\2)\b(?:hello|my|world)\b)
</code></pre>
<p>The idea here is,</p>
<ol>
<li>Make an alternation group <code>\b(hello|my|world)\b</code> and put it in group1</li>
<li>Then optionally it can have zero or more any characters following it.</li>
<li>Then it must be followed by any of the remaining two words and not the one that got matched in first group which is why I have used <code>((?!\1)\b(?:hello|my|world)\b)</code> and this second match is then put in group 2.</li>
<li>Then again it can have optionally zero or more any characters following it.</li>
<li>Then again we apply the same logic where the third word should be the one that wasn't captured in either group1 or group2, hence this regex <code>(?:(?!\1)(?!\2)\b(?:hello|my|world)\b)</code></li>
</ol>
<p><strong><a href="https://regex101.com/r/ZvFhmr/1" rel="nofollow noreferrer">Here is a Demo</a></strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Unified iterative <em>pythonic</em> approach by using <a href="https://docs.python.org/3/library/re.html#re.Pattern.finditer" rel="nofollow noreferrer">Pattern.finditer()</a> function and <a href="https://docs.python.org/3.6/library/stdtypes.html#set" rel="nofollow noreferrer">Set</a> object:</p>
<pre><code>import re

test_str = '''The introduction here for our novel. 
Oh, hello my friend. This world is full of beauty and mystery, let's say hello to universe ...'''

words_set = {'my', 'hello', 'world'}    # a set of search words
words_set_copy = set(words_set)
pat = re.compile(r'\b(my|hello|world)\b', re.I)
start_pos = None
first_sequence = ''

for m in pat.finditer(test_str):        
    if start_pos is None:
        start_pos = m.start()           # start position of the 1st match object
    words_set_copy.discard(m.group())   # discard found unique match 

    if not words_set_copy:              # all the search words found
        first_sequence += test_str[start_pos: m.end()]
        break

print(first_sequence)
</code></pre>
<p>The output:</p>
<pre><code>hello my friend. This world
</code></pre>
<hr/>
<p>You may transform the above approach into a function to make it reusable.</p>
</div>
<span class="comment-copy">Why would you want a regex to solve this task?</span>
<span class="comment-copy">@YassinHajaj other suggestions are welcome, although it would be easier to fit a regex cleanly in the program im working on, as i already use regex for other search tasks in the same method</span>
<span class="comment-copy">@CertainPerformance python, will edit</span>
<span class="comment-copy">If repeating patterns are not allowed then try <a href="https://regex101.com/r/s7dk7y/1" rel="nofollow noreferrer">this</a>. What you need is in first capturing group of each successful match.</span>
<span class="comment-copy">You could do <a href="https://regex101.com/r/s7dk7y/2" rel="nofollow noreferrer">this too</a> with <code>regex</code> module if it supports references to relative captured groups.</span>
<span class="comment-copy">this seems perfect! will check it as correct after some testing. thank you very much.</span>
<span class="comment-copy">thought you might find this interesting: i made a program that generates that expression with variable words for my project here: <a href="https://pyfiddle.io/fiddle/03bfbfa3-53f3-437a-a7dc-ce9630e3a46d/?i=true" rel="nofollow noreferrer">pyfiddle.io/fiddle/03bfbfa3-53f3-437a-a7dc-ce9630e3a46d/?i=true</a></span>
<span class="comment-copy">@JocaPinto: That's pretty good. Yes the regex is pretty systematic and logical which enables one to generate it through code and you did it :)</span>
<span class="comment-copy">this is super smart, nice one. would you mind explaining the re.I as the second argument in re.compile?</span>
<span class="comment-copy">@Datanovice, welcome, <code>re.I</code> is shortcut for <code>re.IGNORECASE</code> option</span>
<span class="comment-copy">thank you sir, you are a true gent.</span>
