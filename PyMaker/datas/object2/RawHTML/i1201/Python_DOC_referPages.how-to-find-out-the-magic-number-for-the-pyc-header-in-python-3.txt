<div class="post-text" itemprop="text">
<p>Python bytecode (.pyc) files have a header that starts with a magic number that changes between Python versions. How can I (programmatically) find out that number for the current Python version in order to generate a valid header? I'm currently hard-coding the one for Python 3.7.1, but that means I now depend on a specific Python version.</p>
<p><a href="https://stackoverflow.com/a/8628185/149392">This answer</a> does exactly what I want using <code>py_compile.MAGIC</code>, but that does not seem to exist anymore in Python 3. How can I do the equivalent in Python 3?</p>
<p>Here's an example of what I'm trying to do:</p>
<pre><code>import dis
import marshal

PYC_HEADER = b'\x42\x0d\x0d\x0a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'

def f():
    print('Hello World')

with open('test.pyc', 'wb') as pyc:
    pyc.write(PYC_HEADER)
    marshal.dump(dis.Bytecode(f).codeobj, pyc)
</code></pre>
<p>This should create a file <code>test.pyc</code>, which can then be run, using the same Python interpreter as the script, and should print "Hello World!". And it does, but only when using Python 3.7. I'm looking for a way that generates the header for whichever version of Python 3 is used to run the script, rather than hard-coding 3.7.</p>
<p>For context:</p>
<p>I'm compiling a simple programming language to different bytecode formats (LLVM, Java bytecode, Web Assembly and now Python bytecode) as part of a planned tutorial series on compiler construction.</p>
<p>I can generate the Python bytecode using <a href="https://github.com/zachariahreed/byteasm" rel="noreferrer">the byteasm library</a>, which gives me a function as a result. But in order to write the contents to a <code>.pyc</code> file, I need a valid header. By hard-coding the header, the code will only work if the people following the tutorial are running the same version of Python 3 as I am (3.7) or they'd have to manually find out the magic number for their version.</p>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.4 there is the <a href="https://docs.python.org/3/library/importlib.html#importlib.util.MAGIC_NUMBER" rel="noreferrer"><code>importlib.util.MAGIC_NUMBER</code></a> in the module <code>importlib</code>:</p>
<pre><code>&gt;&gt;&gt; import importlib
&gt;&gt;&gt; importlib.util.MAGIC_NUMBER.hex()
'420d0d0a'
</code></pre>
<p>Another solution for Python &lt; 3.4 or Python2 is the <a href="https://docs.python.org/3/library/imp.html#imp.get_magic" rel="noreferrer"><code>get_magic</code> method of the <code>imp</code> module</a>.</p>
<pre><code>&gt;&gt;&gt; import imp
&gt;&gt;&gt; imp.get_magic().hex()
'420d0d0a'
</code></pre>
<p>Note, that while this still works in Python 3.7, it is deprecated since Python 3.4</p>
</div>
<div class="post-text" itemprop="text">
<p>It moved!<sup><a href="https://github.com/python/cpython/commit/14581d5dc4e4f9117e62b3a1bc62c4ba935be048" rel="nofollow noreferrer">1</a></sup></p>
<pre><code>&gt;&gt;&gt; import importlib.util
&gt;&gt;&gt; importlib.util.MAGIC_NUMBER
b'3\r\r\n'
</code></pre>
<p><a href="https://docs.python.org/3/library/importlib.html#module-importlib.util" rel="nofollow noreferrer">New in version 3.4.</a></p>
<p>Probably simplest to wrap this in a try/except to fall back to <code>py_compile</code>.</p>
</div>
<span class="comment-copy">Thank you, that's exactly what I needed (minus the <code>.hex()</code> since it should go into the file as bytes, not a hexstring).</span>
<span class="comment-copy">I think you mean "try/except" instead of "try/catch" ;)</span>
<span class="comment-copy">Hah, too much javascript</span>
