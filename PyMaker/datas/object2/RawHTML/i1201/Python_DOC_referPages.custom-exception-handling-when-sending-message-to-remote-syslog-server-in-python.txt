<div class="post-text" itemprop="text">
<p>At the moment i am writing a syslog client that will send messages to a remote syslog server. So far this is working pretty ok but i am running into the following problem.</p>
<p>When the syslog server goes down for some reason i need to catch this so the program will stop sending syslog messages and we can investigate the problem.</p>
<p>Unfortunately, the program continues running and doesn't see that the TCP socket is closed and raise an exception.</p>
<p>I only receive a traceback in my terminal:</p>
<pre><code>--- Logging error --- Traceback (most recent call last):
File "C:\Users\Administrator\AppData\Local\Programs\Python\Python37\lib\logging\handlers.py", line 941, in emit
    self.socket.sendall(msg) ConnectionAbortedError: [WinError 10053]  Call stack:
File "c:\Users\Administrator\.vscode\extensions\ms-python.python-2018.12.1\pythonFiles\ptvsd_launcher.py", line 45, in &lt;module&gt;
    main(ptvsdArgs)
File "c:\Users\Administrator\.vscode\extensions\ms-python.python-2018.12.1\pythonFiles\lib\python\ptvsd\__main__.py", line 265, in main
    wait=args.wait)
File "c:\Users\Administrator\.vscode\extensions\ms-python.python-2018.12.1\pythonFiles\lib\python\ptvsd\__main__.py", line 258, in handle_args
    debug_main(addr, name, kind, *extra, **kwargs)
File "c:\Users\Administrator\.vscode\extensions\ms-python.python-2018.12.1\pythonFiles\lib\python\ptvsd\_local.py", line 45, in debug_main
    run_file(address, name, *extra, **kwargs)
File "c:\Users\Administrator\.vscode\extensions\ms-python.python-2018.12.1\pythonFiles\lib\python\ptvsd\_local.py", line 79, in run_file
    run(argv, addr, **kwargs)
File "c:\Users\Administrator\.vscode\extensions\ms-python.python-2018.12.1\pythonFiles\lib\python\ptvsd\_local.py", line 140, in _run
    _pydevd.main()
File "c:\Users\Administrator\.vscode\extensions\ms-python.python-2018.12.1\pythonFiles\lib\python\ptvsd\_vendored\pydevd\pydevd.py", line 1925, in main
    debugger.connect(host, port)
File "c:\Users\Administrator\.vscode\extensions\ms-python.python-2018.12.1\pythonFiles\lib\python\ptvsd\_vendored\pydevd\pydevd.py", line 1283, in run
    return self._exec(is_module, entry_point_fn, module_name, file, globals, locals)
File "c:\Users\Administrator\.vscode\extensions\ms-python.python-2018.12.1\pythonFiles\lib\python\ptvsd\_vendored\pydevd\pydevd.py", line 1290, in _exec
    pydev_imports.execfile(file, globals, locals)  # execute the script       
File "c:\Users\Administrator\.vscode\extensions\ms-python.python-2018.12.1\pythonFiles\lib\python\ptvsd\_vendored\pydevd\_pydev_imps\_pydev_execfile.py", line 25, in execfile
    exec(compile(contents+"\n", file, 'exec'), glob, loc)
File "c:\Users\Administrator\OneDrive\Documents\Python Scripts\testlogger.py", line 71, in &lt;module&gt;
    my_logger.info(i) Message: 'test4' Arguments: ()
</code></pre>
<p>Relevant code:</p>
<pre><code>my_logger = logging.getLogger('MyLogger')
my_logger.setLevel(logging.ERROR)
my_logger.setLevel(logging.INFO)
my_logger.setLevel(logging.DEBUG)
try:
    handler = logging.handlers.SysLogHandler(('IP ADDRESS HOST', 514), socktype=socket.SOCK_STREAM)
    my_logger.addHandler(handler)
except Exception as e:
    print (e)

list1 = ['test','test2','test3','test4','test5','test6','test7','test8']


for i in list1:
    try:
        my_logger.info(i) #here i expected that an exception would be raised when the TCP socket is not alive anymore
    except Exception as e:
        print (e)
</code></pre>
<p>How can i make sure that the program stops and i can do the appropriate exception handling?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>The default behavior of the <a href="https://docs.python.org/3/library/logging.handlers.html#sysloghandler" rel="nofollow noreferrer">SysLogHandler</a> class (and all the ones who are using TCP) is to retry a connection, this is explained in the docs of the <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler.createSocket" rel="nofollow noreferrer"><code>createSocket()</code></a> method:</p>
<blockquote>
<p>Tries to create a socket; on failure, uses an exponential back-off
  algorithm. On initial failure, the handler will drop the message it
  was trying to send. When subsequent messages are handled by the same
  instance, it will not try connecting until some time has passed. The
  default parameters are such that the initial delay is one second, and
  if after that delay the connection still canâ€™t be made, the handler
  will double the delay each time up to a maximum of 30 seconds.</p>
<p>This behaviour is controlled by the following handler attributes:</p>
<pre><code>retryStart (initial delay, defaulting to 1.0 seconds).
retryFactor (multiplier, defaulting to 2.0).
retryMax (maximum delay, defaulting to 30.0 seconds).
</code></pre>
</blockquote>
<p>As it doesn't seem to have an option for the behavior of "not retrying" which you seem to want, so if you really want that you can create your own handler by subclassing it and overriding the createSocket() method with something like:</p>
<pre><code>class MySysLogHandler(logging.handlers.SysLogHandler):
    def createSocket(self):
        try:
            self.sock = self.makeSocket()
        except OSError:
            # do your own error handling here ...
</code></pre>
<p>You can dig a bit more by looking at <a href="https://github.com/python/cpython/blob/d77d97c9a1f593fe161afab97e2a3e2292ab88b9/Lib/logging/handlers.py#L537-L563" rel="nofollow noreferrer">the source code of <code>createSocket()</code> in CPython Github repo</a> (beware, this is from master branch and might not be the exact version of Python you're using)</p>
</div>
<div class="post-text" itemprop="text">
<p>I switched to another solution and stopped using the SyslogHandler class.</p>
<p>I now use the following class were i wrote my own syslog sender through a socket.</p>
<pre><code>class Syslog:
  def __init__(self,host="localhost",port=514,facility=Facility.DAEMON):
    self.host = host
    self.port = port
    self.facility = facility
    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

  def connect(self):
    try:
        self.socket.connect((self.host, self.port))
    except Exception as e:
        print("failed setting up connection")


  def send(self, message,level):
    data = "&lt;%d&gt;%s" % (level + self.facility*8, message + "\n")
    try:
        self.socket.sendall(data.encode('utf-8'))
    except Exception as e:
        print("send failed")

#if __name__ == '__main__':
syslog1 = Syslog(host='HOSTIPADDRESS-NAME')
syslog1.connect()
messages = ["test1","test2","test3","test4","test5","test6","test7"]

for message in messages:
    syslog1.send(message,Level.WARNING)
</code></pre>
<p>This is working quite well and runs into an exception when the syslog server goes down unexpectedly. The only problem now i discovered while debugging is the following:</p>
<p>When i shut down the syslog server it throws not immediatly an exception when i try to send a message.</p>
<p>Please see example below:</p>
<p>1.) the syslog server is started, i send the first message "test1" from the for loop, successfull.</p>
<p>2.) i shutdown the syslog server, now i send the second message "test2" from the for loop. Nothing happens, no exception!</p>
<p>3.) i send the third message "test3", now an exception is thrown.</p>
<p>How is this possible?</p>
</div>
<span class="comment-copy">Do you want the program to stop when an exception is caught?</span>
