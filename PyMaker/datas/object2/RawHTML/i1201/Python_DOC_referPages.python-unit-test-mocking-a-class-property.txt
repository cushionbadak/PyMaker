<div class="post-text" itemprop="text">
<p>I'm coming from a java background and new to python. In Java, if a class initializes its own property like (this is bad for unit testing):</p>
<pre><code>class TestMe {
    Logger logger;
    public TestMe() {
        this.logger = new Logger();
    }

    //...stuff
}
</code></pre>
<p>I'd refactor it so I can provide a mocked dependency and test the class without creating a real instance of Logger:</p>
<pre><code>class TestMe {
    Logger logger;
    public TestMe(ILogger logger) {
        this.logger = logger;
    }

    //...stuff
}
</code></pre>
<p>But python is a very different language and there may be a way to mock that property without refactoring:</p>
<pre><code>import Logger

class TestMe:
    def __init__(self):
        self.logger = Logger()

    # stuff
</code></pre>
<p>is there a way to mock Logger in above python class without a refactor?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, there is. You can just reassign the logger member variable to be whatever you want. Note that there is no concept of private and public in Python, so you can do this.</p>
<p>In particular, you could assign it to be a <code>Mock</code> or <code>MagicMock</code> object, which are special objects that you can do some introspection on (like making sure <code>self.logger</code> was called/used in some particular fashion), as well as a clean way to do "faking" (you don't have to implement <code>Logger</code>s interface to use them)</p>
<pre><code>from unittest.mock import MagicMock
t = TestMe()
t.logger = MagicMock()
# run some tests that use t (and maybe the Logger)
</code></pre>
<p>You can read more about mocking in Python <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">here</a>.</p>
<p>HTH.</p>
</div>
