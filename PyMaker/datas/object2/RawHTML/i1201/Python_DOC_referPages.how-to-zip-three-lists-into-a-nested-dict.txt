<div class="post-text" itemprop="text">
<p>I have three lists as:</p>
<pre><code>z1 = ['A', 'A', 'B', 'B']
z2 = ['k1', 'k2', 'k1', 'k2']
z3 = ['v1', 'v2', 'v3', 'v4']
</code></pre>
<p>and when I write:</p>
<pre><code>print(dict(zip(z2, z3)))
</code></pre>
<p>this is my output:</p>
<pre><code>{'k2': 'v4', 'k1': 'v3'}
</code></pre>
<p>And I expect this:</p>
<pre><code>{'A':{'k1': 'v1', 'k2': 'v2'} , 'B':{'k1': 'v3', 'k2': 'v4'}}
</code></pre>
<p>Could you please tell me how can I get my expected result?</p>
</div>
<div class="post-text" itemprop="text">
<p>The function <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> can accept more than two iterables. So you can use <code>zip(z1, z2, z3)</code> instead of <code>zip(z2, z3)</code>. However, you still need to group the items since simply wrapping <code>dict()</code> will not work as it can't handle nested dictionaries needed for the 3-tuples.  </p>
<p>To group the items correctly, I would use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict()</code></a>:</p>
<pre><code>from collections import defaultdict

z1 = ['A', 'A', 'B', 'B']
z2 = ['k1', 'k2', 'k1', 'k2']
z3 = ['v1', 'v2', 'v3', 'v4']

d = defaultdict(dict)
for x, y, z in zip(z1, z2, z3):
    d[x][y] = z

print(d)
# defaultdict(&lt;class 'dict'&gt;, {'A': {'k1': 'v1', 'k2': 'v2'}, 'B': {'k1': 'v3', 'k2': 'v4'}})
</code></pre>
<p>The above works because <code>defaultdict(dict)</code> initializes a dictionary for non-existent keys. It handles the dictionary creation for keys for you. </p>
<p>Additionally, If you wrap the end result with <code>dict</code>:</p>
<pre><code>print(dict(d))
# {'A': {'k1': 'v1', 'k2': 'v2'}, 'B': {'k1': 'v3', 'k2': 'v4'}}
</code></pre>
<p><strong>Note:</strong> <code>defaultdict</code> is just a subclass of <code>dict</code>, so you can treat it the same as a normal dictionary. </p>
</div>
<div class="post-text" itemprop="text">
<p>For the sake of completeness, you can use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault</code></a>, avoiding the import at the cost of a tiny overhead of creating and returning an empty dictionary at each iteration.</p>
<pre><code>d = {}
for x, y, z in zip(z1, z2, z3):
    d.setdefault(x,{})[y] = z

print(d)
# {'A': {'k1': 'v1', 'k2': 'v2'}, 'B': {'k1': 'v3', 'k2': 'v4'}}
</code></pre>
<hr/>
<p>Another solution (not recommended) is using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>d = {}
for k, g in groupby(enumerate(zip(z2, z3)), key=lambda x: z1[x[0]]):
    _, b = zip(*g)
    d[k] = dict(b)

print(d)
# {'A': {'k1': 'v1', 'k2': 'v2'}, 'B': {'k1': 'v3', 'k2': 'v4'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a one-liner using <code>itertools.groupby</code>, but aside from being a single expression, it doesn't really provide any benefit over the default-dict solution provided by RoadRunner.</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; keyf = itemgetter(0)
&gt;&gt;&gt; dict((k, dict(v2 for _,v2 in v)) for k, v in groupby(zip(z1, zip(z2,z3)), key=keyf))
{'A': {'k2': 'v2', 'k1': 'v1'}, 'B': {'k2': 'v4', 'k1': 'v3'}}
</code></pre>
<p>This is only as short as it is because it takes advantage of the fact that <code>z1</code> is already sorted. If it isn't, you'll need to sort the output of <code>zip</code> using the same key function before passing it to <code>groupby</code>.</p>
<pre><code>dict((k, dict(v2 for _,v2 in v))
       for k, v in groupby(sorted(zip(z1, zip(z2,z3)),
                                  key=keyf),
                           key=keyf))
</code></pre>
<p>Breaking down how it works...</p>
<ol>
<li><p><code>zip(z1, zip(z2, ze))</code> creates the key-value pairs for the outer dict:</p>
<pre><code>[('A', ('k1', 'v1')),
 ('A', ('k2', 'v2')),
 ('B', ('k1', 'v3')),
 ('B', ('k2', 'v4'))]
</code></pre></li>
<li><p><code>groupby</code> effectively pairs each key (<code>A</code> or <code>B</code>) with its tuples:</p>
<pre><code>[('A', &lt;itertools._grouper object at 0x100f656d0&gt;),
 ('B', &lt;itertools._grouper object at 0x100f655d0&gt;)]
</code></pre>
<p>Each <code>_grouper</code> is an iterable containing all the key/value pairs with the same key. </p></li>
<li><p><code>dict(v2 for _,v2 in v)</code> extracts just the key/value pairs from the <code>_grouper</code>s, leaving behind the key, which we can already get from the first element of the tuples returned by <code>groupby</code>.</p></li>
</ol>
</div>
<span class="comment-copy">@akozi I would guess it's because OP's "attempt" isn't really an attempt at a solution.</span>
<span class="comment-copy">Is your question "why does <code>dict(zip(z2, z3))</code> not produce the desired output" or "how to produce the desired output"?</span>
<span class="comment-copy">The question is pretty obviously spelled out in the last line. I'm willing to stretch to assume the OP knows that the lists can be zipped together in some fashion to create a dict, but cannot figure out how to deal with the nesting aspects.</span>
<span class="comment-copy">if it's a duplicate it will be very difficult to find.</span>
<span class="comment-copy">@chepner Yes exactly I knew I can zip lists but I just thought it's applicable only on 2 lists.</span>
<span class="comment-copy">someone is having a bad day probably. If this person feels that this is a dupe and should not be answered, they should speak out, I'll close</span>
<span class="comment-copy">Good old <code>dict.setdefault()</code>, forgot about that one.</span>
<span class="comment-copy">@RoadRunner Thanks, although I do prefer defaultdict (even if it does need the import...!)</span>
<span class="comment-copy">Doesn't d.setdefault just return the value? Why are you able to operate on the returned value and have it save to the dictionary? I think I lack the underlying structure to understand why this works.  Is this a case of mutable vs immutable python types.</span>
<span class="comment-copy">@akozi It returns the value (a dictionary) if it exists. But either way, it creates an empty dict and then checks whether the key exists before returning the actual value. Hence the mention of "tiny overhead". Either way, a dictionary is returned and you can assign key-values to it.</span>
