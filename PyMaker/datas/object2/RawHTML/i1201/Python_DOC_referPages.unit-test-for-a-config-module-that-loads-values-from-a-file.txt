<div class="post-text" itemprop="text">
<p>New to Unit testing (using pytest) and trying to workout how I can test a config module which loads its values from an ini file in a way that isolates it from its environment. </p>
<p>I want to test that the values in the file are the same as what was loaded to the Configuration instance.</p>
<p>As shown the ini file is hardcoded in the module but don't want to be tied to config.ini when its potentially unavailable.</p>
<p>This is a simplied version of the config module:</p>
<pre><code>from configparser import ConfigParser

class Configuration():
    def __init__(self, ini_file):
        parser = ConfigParser()
        parser.read(ini_file)

        for section_name in parser.sections():
            self.__dict__.update(parser.items(section_name))

config = Configuration('config.ini')
</code></pre>
<p>I access the config values like this:</p>
<pre><code>from config import config

print(config.port)
</code></pre>
<p>Any help much appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You write:</p>
<blockquote>
<p>how I can test a config module [...] in a way that isolates it from its environment.</p>
</blockquote>
<p>but also</p>
<blockquote>
<p>I want to test that the values in the file are the same as what was loaded to the Configuration instance.</p>
</blockquote>
<p>Which I understand in the following way: You want to test the chain "configuration input data" -&gt; <code>ConfigParser</code> -&gt; <code>Configuration</code> to check if the "configuration input data" will be found in the <code>Configuration</code> in the expected way.  This is, btw., rather an integration-test scenario than a unit-test scenario.</p>
<p>With respect to the isolation you mentioned, I understand it such that you don't want to use 'config.ini' as the data source, but something that is under your control.  You have already provided the name of the configuration file as an argument to your constructor.  This is a good step, since it gives you some control from the testing side, namely giving you the option to specify the file to be used from the test.</p>
<p>However, you can even take this further: The <code>ConfigParser</code> class can read from a string instead of a file (the method is <code>read_string</code>, new in Python 3.2: <a href="https://docs.python.org/3/library/configparser.html" rel="nofollow noreferrer">https://docs.python.org/3/library/configparser.html</a>).  If you change your code such that the test can control whether <code>Configuration</code> instructs the <code>ConfigParser</code> to read from a file or from a string, you can create your integration tests by providing strings as inputs, which isolates you from the file system.</p>
<p>There are many ways to change the code such that tests can make it parse from a string instead of from a file: One simple approach is, to make the <code>ConfigParser</code> object itself an argument to the function.  That way, you would from the outside create the ConfigParser and either have it read from a file or from a string.  Another option is, to do the reading from a helper method, which you can override in your test.</p>
</div>
<span class="comment-copy">Excellent! Thank you, that makes perfect sense! I was considering mocking the file or building a file object itself but this is much better.</span>
