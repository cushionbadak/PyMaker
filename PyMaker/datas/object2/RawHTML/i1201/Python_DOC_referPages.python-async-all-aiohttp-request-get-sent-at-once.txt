<div class="post-text" itemprop="text">
<p>Im working with python 3.7 and <a href="https://github.com/aio-libs/aiohttp" rel="nofollow noreferrer">aiohttp</a>, trying to send async http requests from a client to a server.
This is the server code:</p>
<pre><code>import asyncio
from aiohttp import web


async def hello(request):
    print('Got request')
    await asyncio.sleep(2)
    headers = {"content_type": "text/html"}
    response = web.Response(body='Hello', headers=headers)
    return response

app = web.Application()
app.router.add_route("GET", "/", hello)
web.run_app(app)
</code></pre>
<p>and this is the client code:  </p>
<pre><code>import asyncio
from aiohttp import ClientSession
import time


async def fetch(url, session):
    print('Starting request')
    # some blocking calculation
    time.sleep(0.3)
    async with session.get(url) as response:
        print('Finished request')


async def run(r):
    url = "http://localhost:8080"
    tasks = []
    start = time.time()
    async with ClientSession() as session:
        for i in range(r):
            task = asyncio.create_task(fetch(url, session))
            tasks.append(task)

        responses = await asyncio.gather(*tasks)
    print(time.time()-start)

asyncio.run(run(10))
</code></pre>
<p>However I have an issue where it looks like all of the requests are being 'prepared' one at a time but then sent all at once.</p>
<p>This is how the output is printed where the "blocking calculation" is inside of the for "fetch" func: <a href="https://giant.gfycat.com/FantasticMarvelousJaeger.webm" rel="nofollow noreferrer">gif1</a> </p>
<p>And this is how it looks where the "blocking calculation" is done inside of the for loop: <a href="https://giant.gfycat.com/FrighteningSafeChinesecrocodilelizard.webm" rel="nofollow noreferrer">gif2</a></p>
<p>I have two questions.<br/>
1. What causes this difference in behaviour between gif1 and 2?<br/>
2. Why do all the requests get send at once? I Would excpected a output similat to this:</p>
<p>Starting request<br/>
Starting request<br/>
Starting request<br/>
Finished request<br/>
Finished request<br/>
Starting request<br/>
Finished request<br/>
...  </p>
</div>
<div class="post-text" itemprop="text">
<p>The issue is that blocking code such as a call to <code>time.sleep(0.3)</code> cannot be executed in parallel by asyncio because it blocks the whole event loop thread. Replace it with <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.sleep" rel="nofollow noreferrer"><code>await asyncio.sleep(0.3)</code></a> and the issue will go away.</p>
<p>If you have actual blocking code that you must run inside the coroutine (e.g. a numpy computation), use <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" rel="nofollow noreferrer"><code>await loop.run_in_executor(None, blocking_function)</code></a> to run the calculation in a side thread and safely await the result, allowing other coroutines to make progress while waiting.</p>
</div>
<span class="comment-copy">But what progress do other coroutines need to do? I would like to send the http request and only then release control of the coroutine. The "progress" is just waiting for the server to answer after 2 seconds</span>
<span class="comment-copy">@RonSerruya For one, the progress is actually getting to start execute any of them. Note how in <code>gif1</code> you have 0.3s pauses between "Start requests" printouts - that is because each coroutine blocks the event loop before starting to execute the next one. <code>time.sleep()</code> is not an asyncio function so it doesn't suspend the coroutine, nor does it allow asyncio to be aware of the sleep and parallelize the sleeps into a single one. Since the coroutines are effectively executing in series, they are also sending their requests in series.</span>
<span class="comment-copy">The other thing is, the event loop itself has to get a chance to run to pick up the data, which won't happen if it is stuck in <code>time.sleep()</code>.</span>
<span class="comment-copy">Ok, so I have a client that needs to do a blocking calculation, send the request to a server which will return the answer after a few seconds. While I'm waiting for the answer I want to calculate more stuff and send more requests. Would I need to put all of the calculation in <code>run_in_excecutor</code>? I mean, <code>print</code> and <code>append</code> are not async but they are still fine? @user4815162342</span>
<span class="comment-copy">@RonSerruya Yes, anything that can take considerable time should be off-loaded to a thread/process pool with <code>run_in_executor</code>. What constitutes <i>considerable time</i> is not precisely defined, but it is generally understood that "trivial" stuff like <code>append</code> is safe to execute immediately. Use your discretion and treat your coroutine the way you would treat a Twisted (or other async framework's) callback. If some sync operation doesn't look like it belongs in an async callback, wrap it in <code>run_in_executor</code> - or refactor it to be async, such as when changing <code>time.sleep</code> to <code>asyncio.sleep</code>.</span>
