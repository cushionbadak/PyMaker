<div class="post-text" itemprop="text">
<p>I have a dataset in this format with each set of data consisting of a unique id (left) and a supplier (right)</p>
<pre><code> [('SPE8ES18V1039', '3G1W3'), ('SPE8ES18V5065', '3G1W3'), ('SPE8ES19P0173', '3MCV6'), 
  ('SPE8ES19P0661', '0AY99'), ('SPE8ES18TTT9', '3G1W3'), ('SPE8ES18V1039', '3G1W3'), 
  ('SPE8ES19P0173', '3MCV6'), ('SPE8ES19P0661', '0AY99')] 
</code></pre>
<p>I want to remove the duplicate set and get a count for each supplier. So the output after the duplicates have been removed would look like this:</p>
<pre><code>3G1W3  ..... 3 
3MCV6  ...... 1 
0AY99 ....... 1
</code></pre>
<p>how could I loop through each data set and remove duplicates and get a count for each supplier id?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code></a> after converting your list of tuples to a dictionary, which will get rid of the duplicate ids for you. This is because dictionaries can't have duplicate keys. Then you can just count the dictionaries <a href="https://docs.python.org/3/library/stdtypes.html#dict.values" rel="nofollow noreferrer"><code>values()</code></a>. </p>
<p><strong>Implementation using dictionary:</strong></p>
<pre><code>from collections import Counter

l = [
    ("SPE8ES18V1039", "3G1W3"),
    ("SPE8ES18V5065", "3G1W3"),
    ("SPE8ES19P0173", "3MCV6"),
    ("SPE8ES19P0661", "0AY99"),
    ("SPE8ES18TTT9", "3G1W3"),
    ("SPE8ES18V1039", "3G1W3"),
    ("SPE8ES19P0173", "3MCV6"),
    ("SPE8ES19P0661", "0AY99"),
]

print(Counter(dict(l).values()))
# Counter({'3G1W3': 3, '3MCV6': 1, '0AY99': 1})
</code></pre>
<p>You could also remove duplicates by using <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer"><code>set</code></a> or <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer"><code>frozenset</code></a>, since tuples are hashable and smaller than dictionaries.</p>
<p><strong>Implementation using sets:</strong></p>
<pre><code>print(Counter(y for _, y in frozenset(l)))
# Counter({'3G1W3': 3, '0AY99': 1, '3MCV6': 1})

print(Counter(y for _, y in set(l)))
# Counter({'3G1W3': 3, '0AY99': 1, '3MCV6': 1})
</code></pre>
<p>Which can also be written nicely with <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer"><code>operator.itemgetter()</code></a> and <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map()</code></a>:</p>
<pre><code>from operator import itemgetter

print(Counter(map(itemgetter(1), frozenset(l))))
# Counter({'3G1W3': 3, '0AY99': 1, '3MCV6': 1})

print(Counter(map(itemgetter(1), set(l))))
# Counter({'3G1W3': 3, '0AY99': 1, '3MCV6': 1})
</code></pre>
<p><strong>Note:</strong> The key difference between is that <code>frozenset</code> is immutable, and <code>set</code> is mutable. This means that the contents of frozensets cannot be altered after creation, whereas you can alter sets after creation. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can just do this</p>
<pre><code> l = [
        ("SPE8ES18V1039", "3G1W3"),
        ("SPE8ES18V5065", "3G1W3"),
        ("SPE8ES19P0173", "3MCV6"),
        ("SPE8ES19P0661", "0AY99"),
        ("SPE8ES18TTT9", "3G1W3"),
        ("SPE8ES18V1039", "3G1W3"),
        ("SPE8ES19P0173", "3MCV6"),
        ("SPE8ES19P0661", "0AY99"),
    ]

unique = {}
for i in l:
  if i[0] in unique:
    unique[i[0]].append(i[1])
  else:
    unique[i[0]] = [i[1]]
</code></pre>
<p>By doing this you will get one dict with all your values mapped. For finding count you just need this</p>
<pre><code>for j, k in unique.iteritems():
  print "Element %s: %s Count" % (j, len(k))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For Counting Dulpicates:<br/>You can do that using count:</p>
<pre><code>MyList = ['a','b','c','a','a','c','c'] #YOURDATA
my_dict = {i:MyList.count(i) for i in set(MyList)}
print my_dict     #or print(my_dict) in python-3.x
</code></pre>
<p><br/></p>
<pre><code> Output : {'a': 3, 'c': 3, 'b': 1}
</code></pre>
<p>For Removing Duplicates:<br/></p>
<pre><code>MyList = ['a','b','c','a','a','c','c'] #YOURDATA
MySet = set(MyList)
MyList = list(MySet)
print(MyList)
</code></pre>
<p><br/></p>
<pre><code>  Output : ['a','b','c']
</code></pre>
<p>You can first count duplicates and then remove duplicates using these methods :)</p>
</div>
<span class="comment-copy">What did you try? <i>(hint: dictionary)</i></span>
<span class="comment-copy">why so many downvotes?</span>
<span class="comment-copy">Possible reasons (non exhaustive list) for downvotes: [<i>bad formatting</i> ,  <i>unclear questions</i>, <i>not trying to solve it yourself</i> ,...]. SO fixes code, we are no codewriting service.  I fixed your bad formatting for you, can't help with the other reasons. Read about <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a> .. step 0 is research and trying to solve it yourself - adding your (evtl erroneous) <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> does also help getting uv instead of dv.</span>
<span class="comment-copy">i want to first remove the duplicates before counting</span>
<span class="comment-copy">this is good but myList is in this format ['A':3, 'B':4, 'C':5, 'A':2]</span>
<span class="comment-copy">This will work similar for your list. Just change "MyList" to YourData</span>
<span class="comment-copy">@learner101 read here: <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer">datatructures</a> ..your <code>0['A':3, 'B':4, 'C':5, 'A':2]</code> is invalid python - its most probably a <code>{'A':3, 'B':4, 'C':5, 'A':2}</code> which would be a <code>dict</code> - not a <code>list</code>. What you showed in your question was a list of tuples <code>[(1,2),(2,3),(3,4)]</code> - getting datastructures straight is important for communication and performance reasons. You find most of them below the tutorial link given</span>
<span class="comment-copy"><code>{i:MyList.count(i) for i in MyList}</code> will count <code>a</code> and <code>c</code> twice. Using <code>collections.Counter</code> would be better because it traverses the whole list once to get all the counts. You could do <code>{i:MyList.count(i) for i in set(MyList)}</code> to avoid double-counting - but you still would traverse the whole list <code>len(set(MyList))</code> times which is worse then Counter</span>
