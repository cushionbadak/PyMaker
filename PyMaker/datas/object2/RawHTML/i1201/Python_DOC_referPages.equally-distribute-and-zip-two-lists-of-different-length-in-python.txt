<div class="post-text" itemprop="text">
<p>I have two lists:</p>
<pre><code>A = ["a","b","c","d","e","f","g","h","i"]
B = [1,2,3]
</code></pre>
<p>A is 3 times longer than B and so I'd like to match them together using that, as below:</p>
<pre><code>C = [("a",1"),("b",1"),("c",1"),
     ("d",2),("e",2),("f",2),
     ("g",3),("h",3),("i",3)]
</code></pre>
<p>So the first 3 elements of A are matched with the first element of B, the next 3 elements of A are matched with the second element of B and so on.</p>
<p>Futhermore, this is a very simplistic example. I'd also be interested in how to best fairly distribute the elements when the one list is bigger than the other by a number which is not a whole number. For example, my two lists are 10001 and 511 elements long, so the first is ~19.57 bigger than the second. Preferably I'd like to use every element in both lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>I will assume here that first list is the longer.</p>
<p>Here is is simple way:</p>
<pre><code>rep = len(A) // len(B)
ia = iter(A)
C = [(next(ia), b) for b in B for i in range(rep)]
C.extend((a, B[-1]) for a in ia)         # in case len(A) is not an exact multiple of len(B)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming the length of <code>A</code> is a multiple of <code>B</code>, you can easily do</p>
<pre><code>&gt;&gt;&gt; scale = len(A) // len(B)
&gt;&gt;&gt; [(a, B[i // scale]) for i, a in enumerate(A)] 
[('a', 1),
 ('b', 1),
 ('c', 1),
 ('d', 2),
 ('e', 2),
 ('f', 2),
 ('g', 3),
 ('h', 3),
 ('i', 3)]
</code></pre>
<p>How it works:</p>
<ol>
<li>Determine the value of <code>k</code> such that <code>len(A) == k * len(B)</code></li>
<li>Iterate over <code>A</code>, and use <code>k</code> to determine which value of <code>B</code> to pick by dividing the current index by it, accordingly </li>
</ol>
<p>If the lengths are not multiples, then it will throw a </p>
<pre><code>IndexError: list index out of range
</code></pre>
<p>You can circumvent this by computing <code>scale</code> to be</p>
<pre><code>scale = len(A) // len(B) * len(B)
</code></pre>
<p>For example,</p>
<pre><code>A = ["a", "b", "c", "d", "e", "f", "g", "h"]
B = [1, 2, 3]
</code></pre>
<p></p>
<pre><code>&gt;&gt;&gt; scale = len(A) // len(B) * len(B)
&gt;&gt;&gt; [(a, B[i // scale]) for i, a in enumerate(A)] 
[('a', 1),
 ('b', 1),
 ('c', 1),
 ('d', 1),
 ('e', 1),
 ('f', 1),
 ('g', 2),
 ('h', 2)]
</code></pre>
<hr/>
<p>Here's a functional approach using <code>itertools</code> <code>repeat</code> and <code>chain.from_iterable</code>.</p>
<pre><code>&gt;&gt;&gt; from itertools import repeat, chain
&gt;&gt;&gt; list(zip(A, chain.from_iterable(zip(*repeat(B, scale)))))
[('a', 1),
 ('b', 1),
 ('c', 1),
 ('d', 2),
 ('e', 2),
 ('f', 2),
 ('g', 3),
 ('h', 3),
 ('i', 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>grouper</code> <a href="https://docs.python.org/3.7/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipe</a> from the <code>itertools</code> docs (or import it from <a href="https://pypi.org/project/more-itertools/" rel="nofollow noreferrer"><code>more_itertools</code></a>).</p>
<p>Recipe:</p>
<pre><code>from itertools import zip_longest

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
<p>Application:</p>
<pre><code>&gt;&gt;&gt; from more_itertools import grouper                                                               
&gt;&gt;&gt; A = ["a","b","c","d","e","f","g","h","i"]                                                                          
&gt;&gt;&gt; B = [1,2,3]                                                                                                        
&gt;&gt;&gt; [(x, i) for vals, i in zip(grouper(A, len(B)), B) for x in vals]                                                   
[('a', 1),
 ('b', 1),
 ('c', 1),
 ('d', 2),
 ('e', 2),
 ('f', 2),
 ('g', 3),
 ('h', 3),
 ('i', 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also try using <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> and repeat <code>B</code> with your own list comprehension:</p>
<pre><code>&gt;&gt;&gt; A = ["a","b","c","d","e","f","g","h","i"]
&gt;&gt;&gt; B = [1,2,3]
&gt;&gt;&gt; list(zip(A, (y for x in B for y in len(B) * [x])))
[('a', 1), ('b', 1), ('c', 1), ('d', 2), ('e', 2), ('f', 2), ('g', 3), ('h', 3), ('i', 3)]
</code></pre>
<p>It's also recommended not to hardcode <code>len(B) * 3</code>, and use <code>scale = len(A) // len(B)</code> to get the proportional distribution, as shown in <a href="https://stackoverflow.com/questions/53872517/equally-distribute-and-zip-two-lists-of-different-length-in-python/53872544#53872544">@coldspeed's</a> answer</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also group <code>A</code> into a list of sublists, each sublist the length of <code>B</code>:</p>
<pre><code>A = ["a","b","c","d","e","f","g","h","i"]
B = [1,2,3]
_b = len(B)
new_a = [A[i:i+_b] for i in range(0, len(A), _b)]
final_result = [(c, i) for a, i in zip(new_a, B) for c in a]
</code></pre>
<p>Output:</p>
<pre><code>[('a', 1), ('b', 1), ('c', 1), ('d', 2), ('e', 2), ('f', 2), ('g', 3), ('h', 3), ('i', 3)]
</code></pre>
</div>
<span class="comment-copy">What exactly is your question for us? Do you want us to write code for you, give an algorithm, give a hint, or something else? Can you show us an attempt?</span>
