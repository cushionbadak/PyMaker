<div class="post-text" itemprop="text">
<p>I have a list with numbers that are an integer: <code>candidates = [1, 2 ,3, 4 , 5, 16, 20]</code>. This list can contain &gt; 1 million items.</p>
<p>I have a dictionary <code>number_ranges</code> that has as key an integer, with a list as value that contains object with a minimum and maximum range. This dictionary consists now of about 500k keys.</p>
<pre><code>{
    {5: [{"start": 0, "end": 9}]},
    {16: [{"start": 15, "end": 20}, {"start": 16, "end": 18}]}
}
</code></pre>
<p>I am now looping through the list:</p>
<pre><code>for candidate in candidates:
    number = search_in_range(candidate, number_ranges)
</code></pre>
<p>where I check if there is a match of a number of <code>candidates</code> in the ranges of <code>number_ranges</code>, and if so, I return the key which will be used further on. </p>
<pre><code>def search_in_range(candidate, number_ranges):
    for number_range_key in number_ranges:
        for number in number_ranges[number_range_key]:
            if int(number['start']) &lt;= candidate &lt;= int(number['end']):
                return {"key": number_range_key, "candidate": candidate}
</code></pre>
<p>When I run this, I see that it takes about 40 seconds to process 1000 numbers from the list. This means that if I have 1 million numbers, I need more than 11 hours to process.</p>
<pre><code>('2018-12-19 16:22:47', 'Read', 1000)
('2018-12-19 16:23:30', 'Read', 2000)
('2018-12-19 16:24:10', 'Read', 3000)
('2018-12-19 16:24:46', 'Read', 4000)
('2018-12-19 16:25:26', 'Read', 5000)
('2018-12-19 16:25:59', 'Read', 6000)
('2018-12-19 16:26:39', 'Read', 7000)
('2018-12-19 16:27:28', 'Read', 8000)
('2018-12-19 16:28:15', 'Read', 9000)
('2018-12-19 16:28:57', 'Read', 10000)
</code></pre>
<p>The expected output is returning the keys from <code>number_ranges</code> that are matching within the range and the <code>candidate</code> number used to find that key, i.e. <code>return {"key": number_range_key, "candidate": candidate}</code> in function <code>search_in_range</code>. </p>
<p>What are the recommended ways in Python to optimize this algorithm?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your list of <code>candidates</code> is sorted, so do the opposite: Loop the dictionaries in <code>number_ranges</code> and use <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code></a> to binary-search the matching candidates. This will reduce the complexity from <code>O(n*m)</code> to <code>O(n*logm*k)</code> for <code>n</code> dictionaries, <code>m</code> candidates, and <code>k</code> matching candidates on average.</p>
<p>(Note: I changed the format of your <code>number_ranges</code> from a <code>set</code> of <code>dict</code> with just a single element each to just a <code>dict</code>, which makes much more sense.)</p>
<pre><code>candidates = [1, 2, 3, 4, 5, 16, 20]
number_ranges = {
    5: [{"start": 0, "end": 9}],
    16: [{"start": 15, "end": 20}, {"start": 16, "end": 18}]
}

import bisect

for key, values in number_ranges.items():
    for value in values:
        start, end = value["start"], value["end"]
        lower = bisect.bisect_left(candidates, start)
        upper = bisect.bisect_right(candidates, end)
        for cand in range(lower, upper):
            res = {"key": key, "candidate": candidates[cand]}
            print(value, res)
</code></pre>
<p>Output:</p>
<pre><code>{'start': 0, 'end': 9} {'key': 5, 'candidate': 1}
{'start': 0, 'end': 9} {'key': 5, 'candidate': 2}
{'start': 0, 'end': 9} {'key': 5, 'candidate': 3}
{'start': 0, 'end': 9} {'key': 5, 'candidate': 4}
{'start': 0, 'end': 9} {'key': 5, 'candidate': 5}
{'start': 15, 'end': 20} {'key': 16, 'candidate': 16}
{'start': 15, 'end': 20} {'key': 16, 'candidate': 20}
{'start': 16, 'end': 18} {'key': 16, 'candidate': 16}
</code></pre>
<p>If the <code>candidates</code> are not sorted in reality, or if you want the results to be sorted by candidate instead of by dictionary, you can just sort either as a pre- or post-processing step.</p>
</div>
<div class="post-text" itemprop="text">
<p>With a little bit of reorganisation, your code becomes a classic interval tree problem.</p>
<p>Have a look at this package <a href="https://pypi.org/project/intervaltree/" rel="nofollow noreferrer">https://pypi.org/project/intervaltree/</a></p>
<p>The only divergence from a normal interval tree is that you have some items that cover multiple intervals, however it would be easy enough to break them into individual intervals, e.g. {16.1: {"start": 15, "end": 20}, 16.2: {"start": 16, "end": 18}}</p>
<p>By using the intervaltree package, a balanced binary search tree is created which is much more efficient than using nested for loops. This solution is O(logn) for searching each candidate, whereas a for loop is O(n). If there are 1MM+ candidates, the intervaltree package is going to be considerably faster than the accepted nested for loop answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Even though this question has an accepted answer, i would add for the sake of others that this type of scenario really justifies creating a reverse lookup. It is a 1 time headache that will save a lot of practical time as candidate list grows longer. Dictionary lookups are O(1) and if you need to perform multiple lookups, you should consider creating a reverse mapping as well.</p>
<pre><code>number_ranges = [
    {5: [{"start": 0, "end": 9}]},
    {16: [{"start": 15, "end": 20}, {"start": 16, "end": 18}]}
]

from collections import defaultdict

reversed_number_ranges = defaultdict(set) #returns an empty set, avoiding key errors.


for number in number_ranges:
    for k,v in number.items(): 
        ranges = set() #create a set of values which fall within range
        for range_dict in v:
            ranges.update(range(range_dict["start"], range_dict["end"] + 1)) #assuming "end" is included. remove the +1 for right exclusive.
        for i in ranges:
            reversed_number_ranges[i].add(k) #add the key for each location in a range.


candidates = [1, 2 ,3, 4 , 5, 16, 20]

for candidate in candidates:
    print(candidate, reversed_number_ranges[candidate])
</code></pre>
<p>Output:</p>
<pre><code>1 {5}
2 {5}
3 {5}
4 {5}
5 {5}
16 {16}
20 {16}
</code></pre>
</div>
<span class="comment-copy">Can you please edit this question to show your expected output (for the given data) and explain how you get it?</span>
<span class="comment-copy">Maybe preprocess the dictionary, to hold non-overlapping cases only. Like in your example for <code>key:16</code> only one check if it is 15 to 20 should be enough. Also if you have cases 15 to 18, 18 to 25 in one key stitch them to 15 to 25.</span>
<span class="comment-copy">Your formats don't seem to line up. Are you sure number_ranges is a dict? You have written it as if it was a list of dicts and treated it in your code as a list ("for number_range_key in number_ranges" rather than "for number_range_key in number_ranges.keys()")</span>
<span class="comment-copy">@StuartBuckingham iterating over <code>dict</code> objects directly iterates over the keys. Indeed, in Python 2, <code>for key in my_dict.keys()</code> is an <i>antipattern</i>, and I still consider it redundant in Python 3</span>
<span class="comment-copy">@juanpa.arrivillaga you're right. I think <code>for number_range_key, number_range_value in number_ranges.items():</code> is probably preferable though as it removes another O(1) lookup.</span>
<span class="comment-copy">Good, but big problem if difference between start and end is huge. Better combine with bisect.</span>
