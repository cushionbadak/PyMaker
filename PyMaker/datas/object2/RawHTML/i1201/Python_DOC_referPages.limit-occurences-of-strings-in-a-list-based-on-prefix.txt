<div class="post-text" itemprop="text">
<p>So the code that I am working on is for an IRC bot, and I want to implement a way to limit channels based on the <code>CHANLIMIT</code> server option. </p>
<p>The <code>CHANLIMIT</code> option is a list of limits with the prefix and limit seperated by <code>:</code>, but if there is nothing after the <code>:</code> then there is no limit.</p>
<p>The solution below works, but I am looking for any improvements on it.</p>
<pre><code>result = ['#+:2', '&amp;:']
channels = ['#test1', '#test2', '+test3', '&amp;test4']

prefix_groups = [(prefix, []) for prefix in result]
channel_groups = {k: v for (k, v) in prefix_groups}
for channel in channels:
    for group in prefix_groups:
        if channel[0] in group[0]:
            channel_groups[group[0]].append(channel)
            break

for prefix, channels in channel_groups.items():
    limit = prefix.split(':')[1]
    if limit:
        if len(channels) &gt; int(limit):
            channel_groups[prefix] = channels[:int(limit)]

channels = [
    channel for chanlist in channel_groups.values() for channel in chanlist]

print(channels)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can go further :</p>
<p><strong>Solution 2</strong></p>
<pre><code>import itertools

results = ['#+:2', '&amp;:']
channels_to_test = ['#test1', '#test2', '+test3', '&amp;test4',
                    '#test5', '!test5', '&amp;test6', '&amp;test7',
                    '+test8', '#test9']

channel_groups = {group: [channel for channel in channels_to_test
                                  if channel[0] in group]
                  for group in results}

limit = lambda prefix: prefix.split(':')[1]

modified_channel_groups = {prefix: channels[:int(limit(prefix))]
                           for (prefix, channels) in channel_groups.items()
                           if limit(prefix)}

channel_groups.update(modified_channel_groups)

result_channels = list(itertools.chain.from_iterable(channel_groups.values()))

print(result_channels)
</code></pre>
<p>But here I have to make an assumption: I supposed that a channel can match at most one element of <code>results</code>. In other words, no two elements of <code>results</code> will match the same channel. Tell me if this is not true for your situation.</p>
<p>Here are the changes that I have made: </p>
<ul>
<li>I have created <code>channel_groups</code> using a dictionnary comprehension where every element's value is a list comprehension</li>
<li>I have created <code>modified_channel_groups</code> which contains the elements of <code>channel_groups</code> that have been shortened</li>
<li>I <a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow noreferrer">updated</a> the elements of <code>channel_groups</code> with those of <code>modified_channel_groups</code></li>
<li>I created a <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow noreferrer">lambda expression</a> so that I could include it in <code>modified_channel_groups</code>'s definition.</li>
<li>I have extracted <code>result_channels</code> using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable()</code></a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>There are many ways to approach this problem. Doing some minimal simplifications you could have something like that:</p>
<p><strong>Solution 1</strong></p>
<pre><code>results = ['#+:2', '&amp;:']
channels_to_test = ['#test1', '#test2', '+test3', '&amp;test4',
                    '#test5', '!test5', '&amp;test6', '&amp;test7',
                    '+test8', '#test9']

channel_groups = {k: [] for k in results}
for channel in channels_to_test:
    for group in results:
        if channel[0] in group:
            channel_groups[group].append(channel)
            break

for prefix, channels in channel_groups.items():
    limit = prefix.split(':')[1]
    if limit:
        limit = int(limit)
        channel_groups[prefix] = channels[:limit]

result_channels = [
    channel for chanlist in channel_groups.values() for channel in chanlist]

print(result_channels)
</code></pre>
<p>Here are the changes that I have made: </p>
<ul>
<li>I created <code>channel_groups</code> directly instead of creating a list of tuples (<code>prefix_groups</code>) and then using that to create <code>channel_groups</code></li>
<li>I iterated <code>group</code> over <code>results</code> instead of iterating over <code>prefix_groups</code></li>
<li>I didn't checked to see if <code>len(channels) &gt; int(limit)</code> because even if the length of <code>channels</code> is lower than or equal to <code>limit</code>, <code>channels[:limit]</code> will return all of <code>channels</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can even further so that you create your answer <code>channel_groups</code> directly but it becomes more difficult to read. So I don't recommend it:</p>
<p><strong>Solution 2a</strong></p>
<pre><code>import itertools

results = ['#+:2', '&amp;:']
channels_to_test = ['#test1', '#test2', '+test3', '&amp;test4',
                    '#test5', '!test5', '&amp;test6', '&amp;test7',
                    '+test8', '#test9']

limit = lambda prefix: prefix.split(':')[1]

channel_groups = {group: [channel for channel in channels_to_test if channel[0] in group][:int(limit(group)) if limit(group) else None]
                  for group in results}

result_channels = list(itertools.chain.from_iterable(channel_groups.values()))

print(result_channels)
</code></pre>
<p>Just a few things to note:</p>
<ul>
<li><code>channel_groups</code> is created like in <strong>Solution 2</strong> but each value of the dictionnary is a list (obtained from a comprehension) that is sliced with the integer value of the current <code>group</code> or <code>None</code> which will mean to take all the values.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>When I have to extract some information from strings, I tend to use <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">regular expressions</a>. So extending <strong>Solution 2</strong> we can get:</p>
<p><strong>Solution 3</strong></p>
<pre><code>import re
import itertools

results = ['#+:2', '&amp;:']
channels_to_test = ['#test1', '#test2', '+test3', '&amp;test4',
                    '#test5', '!test5', '&amp;test6', '&amp;test7',
                    '+test8', '#test9']

prefix_pattern = re.compile(r'^(.*):(\d+)?$')
prefix_matches = (prefix_pattern.match(x) for x in results)
prefix_split = (x.groups() for x in prefix_matches)
channel_groups = {group: [channel for channel in channels_to_test
                                  if channel[0] in group[0]]
                  for group in prefix_split}

prefix_existing_limit = ((x, int(x[1])) for x in channel_groups
                         if x[1] is not None)
modified_channel_groups = {prefix_group: channel_groups[prefix_group][:limit]
                           for (prefix_group, limit) in prefix_existing_limit}

channel_groups.update(modified_channel_groups)

result_channels = list(itertools.chain.from_iterable(channel_groups.values()))

print(result_channels)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>But let's backup a little. If I understand correctly, in the end you want a list of the elements of <code>channels_to_test</code> that matches the prefixes and doesn't exceed the limit of a prefix if there's one. You could implement this filtering behaviour in a <a href="https://docs.python.org/3/tutorial/classes.html#generators" rel="nofollow noreferrer">generator</a>:</p>
<p><strong>Solution 4</strong></p>
<pre><code>import re

results = ['#+:2', '&amp;:']
channels_to_test = ['#test1', '#test2', '+test3', '&amp;test4',
                    '#test5', '!test5', '&amp;test6', '&amp;test7',
                    '+test8', '#test9']

def filter_channel_list(prefixes_to_match, input_channel_list):
    prefix_pattern = re.compile(r'^(.*):(\d+)?$')
    prefix_matches = (prefix_pattern.match(x) for x in prefixes_to_match)
    prefix_split = (x.groups() for x in prefix_matches)
    prefixes_remaining = {x: (int(y) if y is not None else None)
                          for (x, y) in prefix_split}

    for current_channel in input_channel_list:
        for (prefix, nb_left) in prefixes_remaining.items():
            if current_channel[0] in prefix:
                if nb_left is None:
                    yield current_channel
                    break
                else:
                    if nb_left &gt; 0:
                        prefixes_remaining[prefix] -= 1
                        yield current_channel
                        break
                    else:
                        continue

result_channels = list(filter_channel_list(results, channels_to_test))

print(result_channels)
</code></pre>
<p>Here are some comments:</p>
<ul>
<li>In this solution, I have put back the requirement that an element of <code>channels_to_test</code> will match only one element of <code>results</code>. It's because of the <code>break</code> statements placed in the generator.</li>
<li>What we do is having a dictionnary with the initial limits for each <code>results</code> and decrement each time we encounter a match with an element of <code>channels_to_test</code>. If that value become 0, the generator will skip to the next value. This is what the (optional in this case) <code>continue</code> statement does.</li>
</ul>
</div>
<span class="comment-copy"><i>The solution below should work</i>... can you clarify whether it does or doesn't do what you want?</span>
<span class="comment-copy">Just made the edit, the solution does work, but I feel like there should be a better way to do this.</span>
<span class="comment-copy">Considering what you said in another comment: Would you consider <a href="https://stackoverflow.com/help/someone-answers">accepting this answer</a></span>
<span class="comment-copy">I think that solution 2 looks like the cleaner of a lot of the solutions, so in this case would regexes provide much benefit or would this just be more your style?</span>
<span class="comment-copy">Well you could say it's my style and that in this case it may be a little overkill. You only split a string on <code>:</code> to get your information. But if you have more precise requirements to extract your groups, regexes could come handy (for example in the case your results described differently) Regexes makes finding patterns in text so much easier. But it's up to you to do what suits you.</span>
<span class="comment-copy">First off I want to say you did amazing with all these answers, more than I expexted from anybody. Now, you are right in the assumption that the channels will only match one of the results, since a channel can only have a single prefix, but with the application of this it would always be called to produce a list, so would using a generator like this have any benefits over the other solutions you have given?</span>
<span class="comment-copy">Thanks! I would say that, in general, using a generator provide a way to decouple how you figure out on what values a <code>for</code> loop from what you do with them.   In your particular case one advantage could be that you iterate only one time over <code>channels_to_test</code> instead of creating a dictionnary containing lists that you have to flatten eventually to extract your answer,   But what is more important is that you pick a solution you'll be able to understand in six months whe you come back to this code</span>
