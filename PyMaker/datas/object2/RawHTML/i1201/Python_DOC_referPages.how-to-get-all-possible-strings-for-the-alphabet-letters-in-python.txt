<div class="post-text" itemprop="text">
<p>For example, given the alphabet = 'abcd', how I can get this output in Python:</p>
<pre><code>a
aa
b
bb
ab
ba
(...)
</code></pre>
<p>iteration by iteration.</p>
<p>I already tried the powerset() function that is found here on stackoverflow,
but that doesn't repeat letters in the same string.</p>
<p>Also, if I want to set a minimum and maximum limit that the string can have, how can I?</p>
<p>For example min=3 and max=4,  <code>abc, aaa, aba, ..., aaaa, abca, abcb, ...</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3.5/library/itertools.html#itertools.product" rel="nofollow noreferrer">product function of itertools</a> with varying lengths. The result differs in order from the example you give, but this may be what you want. This results in a generator that you can use to get all your desired strings. This code lets you set a minimum and a maximum length of the returned strings. If you do not specify a value for parameter <code>maxlen</code> then the generator is infinite. Be sure you have a way to stop it or you will get an infinite loop.</p>
<pre><code>import itertools

def allcombinations(alphabet, minlen=1, maxlen=None):
    thislen = minlen
    while maxlen is None or thislen &lt;= maxlen:
        for prod in itertools.product(alphabet, repeat=thislen):
            yield ''.join(prod)
        thislen += 1

for c in allcombinations('abcd', minlen=1, maxlen=2):
    print(c)
</code></pre>
<p>This example gives the printout which is similar to your first example, though in a different order.</p>
<pre><code>a
b
c
d
aa
ab
ac
ad
ba
bb
bc
bd
ca
cb
cc
cd
da
db
dc
dd
</code></pre>
<p>If you really want a full list, just use</p>
<pre><code>list(allcombinations('abcd', minlen=1, maxlen=2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>combinations_with_replacement</code> from itertools (<a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" rel="nofollow noreferrer">docs</a>). The function <code>combinations_with_replacement</code> takes an iterable object as its first argument (e.g. your alphabet) and the desired length of the combinations to generate. Since you want strings of different lengths, you can loop over each desired length.</p>
<p>For example:</p>
<pre><code>from itertools import combinations_with_replacement

def get_all_poss_strings(alphabet, min_length, max_length):
    poss_strings = []

    for r in range(min_length, max_length + 1):
        poss_strings += combinations_with_replacement(alphabet, r)

    return ["".join(s) for s in poss_strings] # combinations_with_replacement returns tuples, so join them into individual strings
</code></pre>
<p>Sample:</p>
<pre><code>alphabet = "abcd"
min_length = 3
max_length = 4
get_all_poss_strings(alphabet, min_length, max_length)
</code></pre>
<p>Output:</p>
<pre><code>['aaa', 'aab', 'aac', 'aad', 'abb', 'abc', 'abd', 'acc', 'acd', 'add', 'bbb', 'bbc', 'bbd', 'bcc', 'bcd', 'bdd', 'ccc', 'ccd', 'cdd', 'ddd', 'aaaa', 'aaab', 'aaac', 'aaad', 'aabb', 'aabc', 'aabd', 'aacc', 'aacd', 'aadd', 'abbb', 'abbc', 'abbd', 'abcc', 'abcd', 'abdd', 'accc', 'accd', 'acdd', 'addd', 'bbbb', 'bbbc', 'bbbd', 'bbcc', 'bbcd', 'bbdd', 'bccc', 'bccd', 'bcdd', 'bddd', 'cccc', 'cccd', 'ccdd', 'cddd', 'dddd']
</code></pre>
<p><strong>Edit:</strong></p>
<p>If order also matters for your strings (as indicated by having <code>"ab"</code> and <code>"ba"</code>), you can use the following function to get all permutations of all lengths in a given range:</p>
<pre><code>from itertools import combinations_with_replacement, permutations

def get_all_poss_strings(alphabet, min_length, max_length):
    poss_strings = []
    for r in range(min_length, max_length + 1):
        combos = combinations_with_replacement(alphabet, r)
        perms_of_combos = []
        for combo in combos:
            perms_of_combos += permutations(combo)
        poss_strings += perms_of_combos

    return list(set(["".join(s) for s in poss_strings]))
</code></pre>
<p>Sample:</p>
<pre><code>alphabet = "abcd"
min_length = 1
max_length = 2
get_all_poss_strings(alphabet, min_length, max_length)
</code></pre>
<p>Output:</p>
<pre><code>['a', 'aa', 'ab', 'ac', 'ad', 'b', 'ba', 'bb', 'bc', 'bd', 'c', 'ca', 'cb', 'cc', 'cd', 'd', 'da', 'db', 'dc', 'dd']
</code></pre>
</div>
<span class="comment-copy">Well if you don't set a maximum length the result is infinite. What do you intend to do with this list of strings?</span>
<span class="comment-copy">Welcome to StackOverflow. Does the output need to follow the order of your example <code>a aa b bb ab ba</code>? If so, what is the rationale behind that order?</span>
<span class="comment-copy">You have not answered my question about the order. I do see a logical basis for the order of your first example (lengths 1 through 2), but that basis does not apply to your second example (lengths 3 through 4). The order of your first example is also more difficult to implement than the code I showed in my answer. Let me know if the order does matter.</span>
<span class="comment-copy">yea. the order was not important to me. the important thing was that all the sequences were there. Your response was simple and perfect for me. thanks and I hope one day to be brilliant as you as a programmer.</span>
