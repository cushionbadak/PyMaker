<div class="post-text" itemprop="text">
<p>I've made an iterable Squares object in 4 way. The classical class, generator style and just for fun a closure style and an improved(?) closure style. </p>
<p><strong>class</strong></p>
<pre><code>class Squares:
    def __init__(self, n):
        self.n = n

    def __iter__(self):
        return self.SquaresIterator(self.n)

    class SquaresIterator:
        def __init__(self, n):
            self.n = n
            self.i = 0

        def __iter__(self):
            return self

        def __next__(self):
            if self.i &gt;= self.n:
                raise StopIteration

            result = self.i ** 2
            self.i += 1
            return result
</code></pre>
<p>It works as expected</p>
<pre><code>sq_class = Squares(5)
list(sq_class)
[0, 1, 4, 9, 16]
# calling again will create a new iterator
list(sq_class)
[0, 1, 4, 9, 16]
</code></pre>
<p><strong>generator</strong></p>
<pre><code>def squares(n):
    for i in range(n):
        yield i ** 2

sq_gen = squares(5)
list(sq_gen)
[0, 1, 4, 9, 16]
# calling again will return empty [] is OK, generator exhausted.
list(sq_gen)
[]
</code></pre>
<p><strong>closure</strong></p>
<pre><code>def Squares(n):
    def inner():
        return squares_gen(n)

    def squares_gen(n):
        for i in range(n):
            yield i ** 2

    return inner

sq_closure = Squares(5)
list(sq_closure())
[0, 1, 4, 9, 16]
# calling again the inner will create a new generator so it is not exhausted
list(sq_closure())
[0, 1, 4, 9, 16]
</code></pre>
<p><strong>improved(?) closure</strong></p>
<pre><code>def Squares(n):
    def inner():
        return squares_gen(n)

    def squares_gen(n):
        for i in range(n):
            yield i ** 2

    inner.__iter__ = lambda : squares_gen(n)
    return inner

sq_closure = Squares(5)
list(sq_closure)

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-13-beb02e61ccfb&gt; in &lt;module&gt;
----&gt; 1 for i in sq:
      2     print(i)

TypeError: 'function' object is not iterable
</code></pre>
<p>What I wanted to try is attach the <code>__iter__</code> function to the inner function object and return a generator and I can leave the ()-s and I can use the returned inner as an iterable object. 
What is the exact definition of the iterable protocol? It seems, only the presence of the <code>__iter__</code> function is not enough. </p>
</div>
<div class="post-text" itemprop="text">
<p>The "exact definition of the iterable protocol" <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow noreferrer">is in the documentation</a>: </p>
<blockquote>
<p>iterable:
  An object capable of returning its members one at a time. Examples of iterables include (...) objects of any classes you define with an <code>__iter__()</code> method or with a <code>__getitem__()</code> method that implements Sequence semantics.</p>
</blockquote>
<p>BUT: <code>__magicmethods__</code> are <a href="https://stackoverflow.com/questions/38133096/assigning-instead-of-defining-a-getitem-magic-method-breaks-indexing">only invoked when defined on the class</a> - you cannot override them on a per-instance basis (well you can but they won't be invoked).</p>
</div>
<span class="comment-copy">Magicmethods are only invoked when they are class attributes - you cannot set them as instance attributes (well you can but they wont be invoked &lt;g&gt;).</span>
<span class="comment-copy">Possible duplicate: <a href="https://stackoverflow.com/questions/38133096/assigning-instead-of-defining-a-getitem-magic-method-breaks-indexing" title="assigning instead of defining a getitem magic method breaks indexing">stackoverflow.com/questions/38133096/â€¦</a></span>
<span class="comment-copy">Thx bruno for the answer +1.</span>
<span class="comment-copy">You missed the simplest way, which is to just use the built-in tools for generating infinite sequences: <code>squares = map(lambda x: x*x, itertools.count())</code> or <code>squares  = (x*x for x in itertools.count())</code>. Use <code>islice</code> to take a finite prefix of the sequence: <code>list(itertools.islice(squares, 5)) == [0,1,4,9,16]</code></span>
