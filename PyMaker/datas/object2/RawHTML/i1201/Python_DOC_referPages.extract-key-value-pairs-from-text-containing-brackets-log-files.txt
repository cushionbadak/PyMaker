<div class="post-text" itemprop="text">
<p>Assume this string:</p>
<pre><code>[aaa   ] some text here [bbbb3 ] some other text here [cc    ] more text
</code></pre>
<p>I'd like to and up with a key, value pair like this:</p>
<pre><code>Key      Value
aaa      some text here  
bbbb3    some other text here  
cc       more text
</code></pre>
<p>or a pandas DataFrame like this</p>
<pre><code>aaa            | bbbb3                |cc
-------------------------------------------------
some text here | some other text here | more text
next line      | .....                | .....
</code></pre>
<p>I tried a regex like: <code>r'\[(.{6})\]\s(.*?)\s\['</code> but this doesn't work.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>re.findall</code>, and extract regions of interest into columns. You can then strip out spaces as necessary. </p>
<p>Since you mentioned you are open to reading this into a DataFrame, you can leave that job to pandas.</p>
<pre><code>import re
matches = re.findall(r'\[(.*?)\](.*?)(?=\[|$)', text)

df = (pd.DataFrame(matches, columns=['Key', 'Value'])
        .apply(lambda x: x.str.strip()))
</code></pre>
<p></p>
<pre><code>df
     Key                 Value
0    aaa        some text here
1  bbbb3  some other text here
2     cc             more text
</code></pre>
<p>Or (Re: edit),</p>
<pre><code>df = (pd.DataFrame(matches, columns=['Key', 'Value'])
        .apply(lambda x: x.str.strip())
        .set_index('Key')
        .transpose())

Key               aaa                 bbbb3         cc
Value  some text here  some other text here  more text
</code></pre>
<p>The pattern matches the text inside braces, followed by the text outside upto the next opening brace.</p>
<pre><code>\[      # Opening square brace 
(.*?)   # First capture group
\]      # Closing brace
(.*?)   # Second capture group
(?=     # Look-ahead 
   \[   # Next brace,
   |    # Or,
   $    # EOL
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this regex which captures your key and value in named group captures.</p>
<pre><code>\[\s*(?P&lt;key&gt;\w+)+\s*]\s*(?P&lt;value&gt;[^[]*\s*)
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>\[</code> --&gt; Since <code>[</code> has a special meaning which defines character set, hence it needs to be escaped and it matches a literal <code>[</code></li>
<li><code>\s*</code> --&gt; Consumes any preceding space before the intended key that doesn't need to part of key</li>
<li><code>(?P&lt;key&gt;\w+)+</code> --&gt; Forms a <code>key</code> named group capturing one or more word [a-zA-Z0-9_] characters. I have used <code>\w</code> to keep it simple as the OP's string only contains alphanumeric characters, otherwise one should use <code>[^]]</code> character set to capture everything within square bracket as key.</li>
<li><code>\s*</code> --&gt; Consumes any following space after the intended key capture that doesn't need to part of key</li>
<li><code>]</code> --&gt; Matches a literal <code>]</code> which doesn't need escaping</li>
<li><code>\s*</code> --&gt; Consumes any preceding space that doesn't need to be part of value</li>
<li><code>(?P&lt;value&gt;[^[]*\s*)</code> --&gt; Forms a <code>value</code> named group capturing any character exception <code>[</code> at which point it stops capturing and groups the captured value in named group <code>value</code>.</li>
</ul>
<p><strong><a href="https://regex101.com/r/mFWcwW/1" rel="nofollow noreferrer">Demo</a></strong></p>
<p>Python code,</p>
<pre><code>import re
s = '[aaa   ] some text here [bbbb3 ] some other text here [cc    ] more text'

arr = re.findall(r'\[\s*(?P&lt;key&gt;\w+)+\s*]\s*(?P&lt;value&gt;[^[]*\s*)', s)
print(arr)
</code></pre>
<p>Outputs,</p>
<pre><code>[('aaa', 'some text here '), ('bbbb3', 'some other text here '), ('cc', 'more text')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could minimize the regex needed by using <code>re.split()</code> and output to a dictionary. For example:</p>
<pre><code>import re

text = '[aaa   ] some text here [bbbb3 ] some other text here [cc    ] more text'

# split text on "[" or "]" and slice off the first empty list item
items = re.split(r'[\[\]]', text)[1:]

# loop over consecutive pairs in the list to create a dict
d = {items[i].strip(): items[i+1].strip() for i in range(0, len(items) - 1, 2)}

print(d)
# {'aaa': 'some text here', 'bbbb3': 'some other text here', 'cc': 'more text'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Regex is not really needed here - simple string split does the job:</p>
<pre><code>s = "[aaa   ] some text here [bbbb3 ] some other text here [cc    ] more text"    

parts = s.split("[")  # parts looks like: ['', 
                      #                    'aaa   ] some text here ',
                      #                    'bbbb3 ] some other text here ', 
                      #                    'cc    ] more text'] 
d = {}
# split parts further
for p in parts:
    if p.strip():
        key,value = p.split("]")            # split each part at ] and strip spaces
        d[key.strip()] = value.strip()      # put into dict

# Output:
form = "{:10} {}"
print( form.format("Key","Value"))

for i in d.items():
      print(form.format(*i))
</code></pre>
<p>Output:</p>
<pre><code>Key        Value
cc         more text
aaa        some text here
bbbb3      some other text here
</code></pre>
<p>Doku for format'ing:</p>
<ul>
<li><a href="https://docs.python.org/3/library/string.html#custom-string-formatting" rel="nofollow noreferrer">custom string formating</a></li>
<li><a href="https://docs.python.org/3/library/string.html#formatspec" rel="nofollow noreferrer">string format mini language</a></li>
</ul>
<hr/>
<p>As almost 1-liner: </p>
<pre><code>d = {hh[0].strip():hh[1].strip() for hh in (k.split("]") for k in s.split("[") if k)}  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow noreferrer">finditer</a>:</p>
<pre><code>import re

s = '[aaa   ] some text here [bbbb3 ] some other text here [cc    ] more text'

pattern = re.compile('\[(\S+?)\s+\]([\s\w]+)')
result = [(match.group(1).strip(), match.group(2).strip()) for match in pattern.finditer(s)]
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[('aaa', 'some text here'), ('bbbb3', 'some other text here'), ('cc', 'more text')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With a RegEx, you can find <code>key,value</code> pairs, store them in a dictionary, and print them out:</p>
<pre><code>import re

mystr = "[aaa   ] some text here [bbbb3 ] some other text here [cc    ] more text"

a = dict(re.findall(r"\[([A-Za-z0-9_\s]+)\]([A-Za-z0-9_\s]+(?=\[|$))", mystr))

for key, value in a.items():
    print key, value

# OUTPUT: 
# aaa     some text here 
# cc      more text
# bbbb3   some other text here 
</code></pre>
<p>The RegEx matches 2 groups:<br/>
The first group is <em>all the characters, numbers and spaces inside enclosed in squared brackets</em> and the second is <em>all the characters, numbers and spaces preceded by a closed square bracket and followed by an open square brackets or end of the line</em></p>
<p>First group: <code>\[([A-Za-z0-9_\s]+)\]</code><br/>
Second group: <code>([A-Za-z0-9_\s]+(?=\[|$))</code></p>
<p>Note that in the second group we have a <a href="https://www.regular-expressions.info/lookaround.html" rel="nofollow noreferrer">positive lookahead</a>: <code>(?=\[|$)</code>. Without the positive lookahead, the character would be consumed, and the next group won't find the starting square bracket.</p>
<p>findall returns then a list of tuple: <code>[(key1,value1), (key2,value2), (key3,value3),...]</code>.<br/>
A list of tuple can be immediately converted into a dictionary: dict(my_tuple_list).</p>
<p>Once you have your dict, you can do what you want with your key/value pairs :)</p>
</div>
<span class="comment-copy">Try <code>r'\[([^][]*?)\s*]\s*(.*?)(?=\s*\[|$)'</code>, see <a href="https://regex101.com/r/EUxFSY/1" rel="nofollow noreferrer">this demo</a>.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/26660654/how-do-i-print-the-key-value-pairs-of-a-dictionary-in-python" title="how do i print the key value pairs of a dictionary in python">stackoverflow.com/questions/26660654/â€¦</a> check this out first.</span>
<span class="comment-copy">Is this to go into a pandas DataFrame?</span>
<span class="comment-copy">@K.Madden: This isn't answering my question. I Need to regex to capture or split my string.</span>
<span class="comment-copy">@PatrickArtner: Sorry typo, updated sample</span>
<span class="comment-copy">Many thanks, also for the regex explanation ! Is it possible to use the key as column name ?</span>
<span class="comment-copy">@JohnDoe Re:edit, <code>pd.DataFrame(matches, columns=['Key', 'Value']).apply(...).set_index('Key').T</code></span>
<span class="comment-copy">This is not what I mean. I will try to explain it better. Now the columns are <code>Key</code>and <code>Value</code> and I would like to see <code>column=['aaa', 'bbbb3','cc']</code> from the first captured group and the values from the second captured group. The key value thing is confusing here. I just mentioned here to end up with a dictionary and potentialy end up with a DataFrame</span>
<span class="comment-copy">@JohnDoe Yes, figured it out. See my edit showing how to load it in that format. The columns are the keys once you transpose.</span>
<span class="comment-copy">Ok thanks. A bit confusing to me because I still saw the key value as indexes</span>
<span class="comment-copy">See the better <code>str.split()</code> based approach in the answer from @PatrickArtner (no regex needed).</span>
<span class="comment-copy">The last result seems incorrect?</span>
<span class="comment-copy">@coldspeed Updated the answer!</span>
