<div class="post-text" itemprop="text">
<p>i am having a simple app example here:</p>
<p>say i have this piece of code which handles requests from user to get a list of books stored in a database.</p>
<pre><code>from .handlers import all_books

@apps.route('/show/all', methods=['GET'])
@jwt_required
def show_books():
    user_name = get_jwt_identity()['user_name']
    all_books(user_name=user_name)
</code></pre>
<p>and in <code>handlers.py</code> i have :</p>
<pre><code>def all_books(user_name):
        db = get_db('books')
        books = []
        for book in db.books.find():
            books.append(book)
        return books
</code></pre>
<p>but while writing unit tests i realised if i use <code>get_db()</code> inside <code>all_books()</code> it would be harder to unit test the method.
so i thought this would be the good way.</p>
<pre><code>from .handlers import all_books

@apps.route('/show/all', methods=['GET'])
@jwt_required
def show_books():
    user_name = get_jwt_identity()['user_name']
    db = get_db('books')
    collection = db.books
    all_books(collection=collection)

def all_books(collection):
        books = []
        for book in collection.find():
            books.append(book)
        return books
</code></pre>
<p>i want to know what is the good design to use?
have all code doing one thing at one place like the first example or the second example is good.</p>
<p>To me first one seems more clear as it has all related logic at one place. but its easier to pass a fake collection in second case to unit test it.</p>
</div>
<div class="post-text" itemprop="text">
<p>you should probably use the mock library  see: <a href="https://docs.python.org/3/library/unittest.mock.html#quick-guide" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#quick-guide</a></p>
<p>(if you use python2 you will need <code>pip install mock</code>)</p>
<pre><code>def test_it():
    from unittest.mock import Mock,patch
    with patch.object(get_db,'function',Mock(return_value=Mock(books=[1,2,3]))) as mocked_db:
         x = get_db("ASDASD")
         console.log(x.books) 
         # you can also do cool stuff like this
         assert mocked_db.calledwith("ASDASD")
</code></pre>
<p>of coarse for yours you will have to construct a slightly more complex object</p>
<pre><code>my_mocked_get_db = Mock(return_value=Mock(books=Mock(find=[1,2,3,4])))
with patch.object(get_db,'function',my_mocked_get_db) as mocked_db:
         x = get_db("ASDASD")
         print(x.books.find())
</code></pre>
</div>
<span class="comment-copy">first function is much cleaner right?</span>
<span class="comment-copy">im making no calls to your judgement, there may be other reasons not to do get_db inside the function ... but unit tests isnt really a great one (decoupling of code might be... i cannot say for sure)</span>
<span class="comment-copy">in your second code , <code>find</code> is something like a variable but its being used as a callable in the code below. is this specific to the <code>Mock</code> ?</span>
