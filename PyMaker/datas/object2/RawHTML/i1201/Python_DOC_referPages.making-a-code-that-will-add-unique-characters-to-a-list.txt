<div class="post-text" itemprop="text">
<p>so the below code should be talking the unique characters in msg and the unique characters and making a list containing two sublists. An example would be </p>
<pre><code>crack_the_code('hello there', 'abccd eabfb') 
</code></pre>
<p>should return                </p>
<pre><code>[['h', 'e', 'l', 'o', 't', 'r'], ['a', 'b', 'c', 'd', 'e', 'f']].
</code></pre>
<p>What I have tried to do below is made three lists and then ran a for loop to check if i is in the new list (unique) if not adds it to the list, same was done for unique_code. </p>
<p>Then finally put the two lists together and returned but when I print I get none. Any help would be appreciated. </p>
<pre><code>def crack_the_code(msg, code):
    unique = []
    unique_code = []
    cracked = []
    for i in msg:
        if i not in unique:
            unique.extend(i)
    for item in code:
        if item not in unique_code:
            unique_code.extend(item)
    cracked = unique.append(unique_code)
    return cracked

print(crack_the_code('hello there', 'abcd eabfb'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You get <code>None</code>, because <code>unique.append(unique_code)</code> mutates <code>unique</code> and does not return a modified list, but <code>None</code> (as all functions mutating the input should). You can do <code>return [unique, unique_code]</code> instead.</p>
<hr/>
<p>After having fixed your return, you should use a better algorithm. Whenever you check <code>if i not in unique</code>, this linearly checks the list <code>unique</code> for the value <code>i</code>, making it <code>O(n^2)</code> in total.</p>
<p>This is using the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> recipe <code>unique_everseen</code></a>, which keeps the original order and is <code>O(n)</code>, because it uses a <code>set</code> to keep track of already seen letters:</p>
<pre><code>from itertools import filterfalse

def unique_everseen(iterable):
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D
    seen = set()
    seen_add = seen.add

    for element in filterfalse(seen.__contains__, iterable):
        seen_add(element)
        yield element

def crack_the_code(msg, code):
    return [list(unique_everseen(msg)), list(unique_everseen(code))]
</code></pre>
<p>If you cannot use <code>itertools</code>, you can also write it yourself (probably slightly slower):</p>
<pre><code>def unique_everseen(iterable):
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D
    seen = set()
    seen_add = seen.add

    for element in iterable:
        if element not in seen:
            seen_add(element)
            yield element
</code></pre>
<p>And if you don't care about the order, just use <code>set</code>:</p>
<pre><code>def crack_the_code(msg, code):
    return [list(set(msg)), list(set(code))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Swap your extend with append and your append with extend. I think you got them confused in terms of functionality.</p>
<p>You append an element to a list.
You extend a list to another list.</p>
<p>Also, you used [item] in the second for loop but you were adding [i] into the list. Change that to [item] then below code works:</p>
<pre><code>def crack_the_code(msg, code):
    unique = []
    unique_code = []
    cracked = []
    for i in msg:
        if i not in unique:
            unique.append(i)

    for item in code:
        if item not in unique_code:
            unique_code.append(item)        

    cracked = unique + unique_code

    return cracked

print(crack_the_code('hello there', 'abcd eabfb'))
</code></pre>
</div>
<span class="comment-copy">I unfortunately have not learned how to use the itertools yet, and thus would not be able to answer the question with it, however the over solution you offered works! Thanks a lot.</span>
<span class="comment-copy">@Meliodus123: Added an implementation of <code>unique_everseen</code> without using <code>itertools</code>.</span>
<span class="comment-copy">By some slight weirdness in the OP's code it does not matter that they confused the two. When fixing the return like I did it works, because in <code>unique.extend(i)</code>, <code>i</code> is a single character, but strings are iterable...</span>
