<div class="post-text" itemprop="text">
<p>Let's say I have 3 folders named "Grégory MM", "Loïc RR" and "Danièle RR" (spaces and accented letters). </p>
<p>Then I use the following code to get all the names with only the first letter capitalized:</p>
<pre><code>import glob
names = [ x.title() for x in glob.glob('*') ]
</code></pre>
<p>If the folders were created with <code>mkdir</code> from a Terminal I have the expected result:</p>
<pre><code>&gt;&gt;&gt; names
['Loïc Rr', 'Danièle Rr', 'Grégory Mm']
</code></pre>
<p>If the folders were created from the Finder, I get:</p>
<pre><code>&gt;&gt;&gt; names
['LoïC Rr', 'DanièLe Rr', 'GréGory Mm']
</code></pre>
<p>The first letter after each accented letter is capitalized. Is that a known behavior? How can I avoid it?</p>
<p>Python version 3.7.0<br/>
System: macOS Mojave 10.14.1<br/>
and <code>sys.getfilesystemencoding()</code> returns 'utf-8'</p>
</div>
<div class="post-text" itemprop="text">
<p>This is most likely a matter of whether the accented letters use combining accent characters or single accented code points. I don't know what file names you actually have on your system, but putting the names in NFC form (with single accented code points):</p>
<pre><code>&gt;&gt;&gt; x = 'Loïc Rr'
&gt;&gt;&gt; unicodedata.normalize('NFC', x).title()
'Loïc Rr'
</code></pre>
<p>we get no capital after the accent, while in NFD form (with combining accent characters):</p>
<pre><code>&gt;&gt;&gt; unicodedata.normalize('NFD', x).title()
'Loi\u0308C Rr'
</code></pre>
<p>we get the capital.</p>
<p>It looks like <code>title()</code> thinks the combining character marks a word boundary. NFC normalization can help somewhat, but not for weird accent combinations for which a dedicated code point doesn't exist. For more robust handling, you may want to look for a more powerful Unicode handling library than Python's built-in string methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>We actually have two different strings:</p>
<pre><code>In [1]: 'Loïc Rr'.encode()
Out[1]: b'Lo\xc3\xafc Rr'

In [2]: 'Loïc Rr'.encode()
Out[2]: b'Loi\xcc\x88c Rr'
</code></pre>
<p><code>\xc3\xaf</code> is <code>ï</code> and <code>\xcc\x88</code> is <code>̈</code>, </p>
<p><code>\xcc\x88</code> is recognized as punctuation, so that's the reason why <code>title()</code> capitalizes your letter.</p>
<p>You can normalize your string with <a href="https://docs.python.org/3/library/unicodedata.html#module-unicodedata" rel="nofollow noreferrer"><code>unicodedata.normalize()</code></a>:</p>
<pre><code>In [1]: import unicodedata

In [2]: 'Loïc Rr' == 'Loïc Rr'
Out[2]: False

In [3]: unicodedata.normalize('NFC','Loïc Rr') == unicodedata.normalize('NFC','Loïc Rr')
Out[3]: True

In [4]: unicodedata.normalize('NFD','Loïc Rr') == unicodedata.normalize('NFD','Loïc Rr')
Out[4]: True

In [5]: unicodedata.normalize('NFD','Loïc Rr').title() == unicodedata.normalize('NFD','Loïc Rr').title()
Out[5]: True

In [6]: unicodedata.normalize('NFD','Loïc Rr').title() == unicodedata.normalize('NFD','Loïc Rr').title()
Out[6]: True
</code></pre>
</div>
<span class="comment-copy"><code>unicodedata.normalize</code> helps somewhat, but it won't do anything for accent combinations that don't have a dedicated code point.</span>
