<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1373164/how-do-i-create-a-variable-number-of-variables">How do I create a variable number of variables?</a>
<span class="question-originals-answer-count">
                    16 answers
                </span>
</li>
</ul>
</div>
<p>just a stupid question out of curiosity.</p>
<p>Lets say there's a list with elements as</p>
<pre><code>fruits_lst = ['apples','oranges','bananas','guavas']
</code></pre>
<p>Now is it possible to create separate separate dictionaries but with the names as the names of elements in the list?</p>
<p>desired result:</p>
<pre><code>apples=dict()
oranges=dict()
bananas=dict()
guavas=dict()
</code></pre>
<p>I know one could easily do it by looking at the names of the elements, but what i want to achieve is somehow the program picks up the element names while iterating through it and then creates empty dictionaries with the same names. Is it possible? Kindly guide me through..</p>
</div>
<div class="post-text" itemprop="text">
<h3>Use <code>dict</code> instead of <code>globals</code></h3>
<p>Use of global variables is not recommended practice. Much cleaner and easily maintainable is a dictionary of dictionaries. For example, using a <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="noreferrer">dictionary comprehension</a>:</p>
<pre><code>fruits_lst = ['apples', 'oranges', 'bananas', 'guavas']

d = {fruit: {} for fruit in fruits_lst}
</code></pre>
<p>Then access a particular inner dictionary via <code>d['apples']</code>, <code>d['oranges']</code>, etc.</p>
<p>See <a href="https://stackoverflow.com/a/38972761/9209546">this answer</a> for an explanation why this is useful, and <a href="https://stackoverflow.com/a/1373185/9209546">here</a> for another example.</p>
</div>
<div class="post-text" itemprop="text">
<p>Evrythin in python is a dictionary!, even the scope.
You can use <a href="https://docs.python.org/3/library/functions.html#globals" rel="nofollow noreferrer"><code>globals()</code></a> for it:</p>
<pre><code>fruits_lst = ['apples','oranges','bananas','guavas']
globals().update({name : dict() for name in fruits_lst})
apples["foo"] = 10
print(apples)
</code></pre>
<p>Results on :</p>
<pre><code>{'foo': 10}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a short way, but let me warn you this isn't a good way to defining variables.</p>
<pre><code>fruits_lst = ['apples','oranges','bananas','guavas']

for fruit in fruits_lst:
    globals()[fruit] = dict()
</code></pre>
<p>Now you can access them directly,</p>
<pre><code>&gt;&gt;&gt; apples
{}
&gt;&gt;&gt; oranges
{}
</code></pre>
<p>and so on...</p>
</div>
<span class="comment-copy">People often ask here how to create variables named from strings, and it is perfectly possible. But it's nearly always not helpful.</span>
<span class="comment-copy">@khelwood oh but why do you say so? Pardon me, but I'd like to know more. Could you guide through as to why is that not helpful?</span>
<span class="comment-copy">@AmanSingh Makes the code unreadable and hard to debug.</span>
<span class="comment-copy">@AmanSingh Because variables names are there for you to refer to variables in the code. Either you know them when you're writing the code, in which case you can create them explicitly; or you don't, in which case you'll find it difficult to make use of them when you have created them.</span>
<span class="comment-copy">I tried this but then I had to access each of the fruit as d['apples'] which is also correct but i was wondering if there was any way to access apples directly as a dictionary. But thanks for the help</span>
<span class="comment-copy">@AmanSingh, No, use <code>d['apples']</code>. It may seem cumbersome to a new programmer, but you shouldn't see this as inefficient or undesirable. Experienced programmers know that large numbers of variables are harder to maintain and more likely to lead to errors.</span>
<span class="comment-copy">This is the reasonable approach to this problem. The data has a structure, it is reflected here as the similar dicts are grouped together, which allows to treat them together, rather than having a bunch of globals mixed among the others.</span>
<span class="comment-copy">While technically correct, this answer is actually what one should NOT do (cf khelwood's comment on the question).</span>
<span class="comment-copy">wow! this is something new that I learned today. Will explore more on this globals() now.Thanks for the help</span>
<span class="comment-copy">While technically correct, this answer is actually what one should NOT do (cf khelwood's comment on the question).</span>
