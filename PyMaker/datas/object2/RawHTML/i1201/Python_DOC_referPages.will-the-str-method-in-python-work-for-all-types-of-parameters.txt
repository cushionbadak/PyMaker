<div class="post-text" itemprop="text">
<p>I am trying to raise error messages using the the following line of code:</p>
<pre><code>def raise_error(value):
    error = "The value " + str(value) + " does not satisfy the given conditions."
    # Other stuff
</code></pre>
<p>The value is basically user input obtained from a JSON API, so I am trying to consider all possibilities. Can the method above itself cause an exception in my system if the value given cannot be turned into a string using the <code>str()</code> method? If yes, then what are such values that would create the exception?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>str</code> method will always produce an output, it just might not be meaningful. As noted in the <a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow noreferrer">docs here</a> it's calling either <code>__str__</code> or <code>__repr__</code> depending on what is defined. For all of the basic types like int, float, bool, etc you'll get a nice output. For a custom class though you'll probably get some garbage like:</p>
<pre><code>class test:
    pass

print(str(test()))

&gt;&gt;&gt; &lt;__main__.test object at 0x107f2ba20&gt;
</code></pre>
<p>Now if you define a <code>__str__</code> method you'll get something nice like so</p>
<pre><code>class test:
    def __str__(self):
        return "A test object"

print(str(test()))
&gt;&gt;&gt; 'A test object'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Short answer: you don't have to worry about it. The string is generated by the <code>__str__</code> or <code>__repr__</code> functions, and one or both of these will automatically be created on all new objects and primitives.</p>
<hr/>
<p>But technically there are a few scenarios where developers can do dumb stuff.</p>
<p><br/></p>
<p><strong>Scenario A)</strong> The <code>__str__</code> function does not return a string:</p>
<pre><code>class Test():
    def __str__(value):
        return

raise_error(Test())
</code></pre>
<p>This results in the error</p>
<pre><code>TypeError: __str__ returned non-string (type NoneType)
</code></pre>
<p><br/></p>
<p><strong>Scenario B)</strong> The <code>__str__</code> function has the wrong amount of arguments:</p>
<pre><code>class Test():
    def __str__():
        return 0

raise_error(Test())
</code></pre>
<p>This results in the error</p>
<pre><code>TypeError: __str__() takes 0 positional arguments but 1 was given
</code></pre>
<p><br/></p>
<p>Obviously in all three of these scenarios the fault lies with whatever developer was creating the bad <code>__str__</code> functions. I think we can all agree that these are not cases your code should have to handle.</p>
</div>
<span class="comment-copy">All data types valid in a JSON have a <code>str</code> representation.</span>
<span class="comment-copy"><code>&lt;__main__.test object at 0x107f2ba20&gt;</code> is not garbage. It is what is being defined in the <code>__repr__</code> method because <code>str()</code> will look for <code>repr</code> if <code>__str__</code> is not defined.</span>
<span class="comment-copy">@ycx yes, I know this. However, for most people <code>&lt;__main__.test object at 0x107f2ba20&gt;</code> is not quite what they're going for when they call <code>str</code> on something, especially in an error message.</span>
<span class="comment-copy">The <code>AttributeError: __str__</code> comes from the attempt to delete <code>__str__</code>, not from the <code>str</code> call.</span>
<span class="comment-copy">@ user2357112 you're right. I've removed that scenario.</span>
