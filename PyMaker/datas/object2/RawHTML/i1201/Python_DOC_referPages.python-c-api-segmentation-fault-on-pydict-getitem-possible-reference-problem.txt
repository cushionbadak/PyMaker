<div class="post-text" itemprop="text">
<p>I have a reference in C to a Python list of dictionaries. I am writing a function to calculate the dot product between two members of the list:</p>
<pre><code>PyObject *handle; // reference to a list of dictionaries
virtual float dot_product () (unsigned i, unsigned j) const {
    // dot product of handle[i] and handle[j]
    PyObject *a = (PyObject*)PyList_GetItem(handle, (Py_ssize_t)i);
    PyObject *b = (PyObject*)PyList_GetItem(handle, (Py_ssize_t)j);
    PyObject *key, *a_value;
    Py_ssize_t pos = 0;
    double dot_product = 0;
    while (PyDict_Next(a, &amp;pos, &amp;key, &amp;a_value)) {
        PyObject* b_value = PyDict_GetItem(b, key);
        if (b_value != NULL){
            dot_product += PyFloat_AsDouble(a_value) * PyFloat_AsDouble(b_value);
        }
    }
    return dot_product;
}
</code></pre>
<p>This results in a segmentation fault. Using gdb to debug, it appears that the segmentation fault is being caused by PyDict_GetItem(b, key). This makes me suspect there's something wrong with my reference counts.</p>
<p>After reading the documentation on <a href="https://docs.python.org/3/extending/extending.html#ownership-rules" rel="nofollow noreferrer">Reference Counts</a>, it seems that all of the references in the above code are borrowed, so I assumed there was no need to use Py_INCREF or Py_DECREF...but I could easily be wrong.  Is there a place in the above code that I need to use Py_INCREF or Py_DECREF?</p>
<p>Edit: I should note that I have already done checks to make sure a and b are not null, and also checks to ensure i and j do not exceed the size of the list. I removed these checks from the code in my question to keep it simpler. â€“</p>
</div>
<div class="post-text" itemprop="text">
<p>Check your return values. Both <code>a</code> and <code>b</code> can be <code>NULL</code> if <code>i</code> and <code>j</code> respectively exceed the length of the <code>list</code> referenced by <code>handle</code>. <code>PyDict_GetItem</code> <em>assumes</em> the <code>dict</code> passed is not a <code>NULL</code> pointer, dereferencing it without confirming that assumption, which would cause an immediate segfault.</p>
<p>You main problem is determining how to report an error. A C++ exception would work for C++, but Python won't understand it unless you catch it and convert it to a Python level exception. In any event, until you figure that out, returns <code>NaN</code> to indicate failure:</p>
<pre><code>#include &lt;cmath&gt;

PyObject *handle; // reference to a list of dictionaries
virtual float dot_product () (unsigned i, unsigned j) const {
    // dot product of handle[i] and handle[j]
    PyObject *key, *a_value;
    Py_ssize_t pos = 0;
    double dot_product = 0;

    // Check both indices are valid
    PyObject *a = (PyObject*)PyList_GetItem(handle, (Py_ssize_t)i);
    if (!a) return NAN;

    PyObject *b = (PyObject*)PyList_GetItem(handle, (Py_ssize_t)j);
    if (!b) return NAN;

    // Test if you actually got dicts
    if (!PyDict_Check(a) || !PyDict_Check(b)) return NAN;

    while (PyDict_Next(a, &amp;pos, &amp;key, &amp;a_value)) {
        PyObject* b_value = PyDict_GetItem(b, key);
        if (b_value != NULL){
            // Check that both values are really Python floats and extract C double
            double a_val = PyFloat_AsDouble(a_value);
            if (a_val == -1.0 &amp;&amp; PyErr_Occurred()) return NAN;

            double b_val = PyFloat_AsDouble(b_value);
            if (b_val == -1.0 &amp;&amp; PyErr_Occurred()) return NAN;

            dot_product += a_val * b_val;
        }
    }
    return dot_product;
}
</code></pre>
</div>
<span class="comment-copy">Are there any threads, at all, involved in this program? Are the keys of the <code>dict</code>s Python built-ins, or some custom class? By not holding owned references, it's possible the <code>__hash__</code> or <code>__eq__</code> methods of your keys either directly change the <code>list</code>s or <code>dict</code>s you're working with, or invoke Python code that allows for GIL handoff, allowing some other thread to begin running and do the same thing.</span>
<span class="comment-copy">Beyond that, you aren't checking return values; <code>a</code> and <code>b</code> could easily be <code>NULL</code> if <code>j</code> is greater than the length of the <code>list</code> stored in <code>handle</code>, and if you don't check the return values, you'll end up trying to deference null pointers. <code>PyDict_GetItem</code> suppresses the exception for a missing key, but it doesn't try to guard against a <code>NULL</code> value for the <code>dict</code> itself.</span>
<span class="comment-copy">The keys of the dict are integers, so Python built-ins. You might be onto something with threads: the encompassing program is multi-threaded, and so dot_product may be called simultaneously. I will try a single-threaded version and see if that fixes things.</span>
<span class="comment-copy">It also depends on whether your <code>dot_product()</code> call is wrapped directly under a Python call or not. Python function calls increment the ref count implicitly for you, but if you are actively calling your dot_product from C++ you need to do that by yourself.</span>
<span class="comment-copy">I should have said this in my question, but I've already done null checking and making sure i and j do not exceed the size of the list. I removed the checking from the code in my question to keep it simpler.</span>
