<div class="post-text" itemprop="text">
<p>How can I list all files of a directory in Python and add them to a <code>list</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/os.html#os.listdir" rel="noreferrer" title="os.listdir"><code>os.listdir()</code></a> will get you everything that's in a directory - files and directories.</p>
<p>If you want <em>just</em> files, you could either filter this down using <a href="https://docs.python.org/2/library/os.path.html#module-os.path" rel="noreferrer"><code>os.path</code></a>:</p>
<pre><code>from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]
</code></pre>
<p>or you could use <a href="https://docs.python.org/2/library/os.html#os.walk" rel="noreferrer" title="os.walk"><code>os.walk()</code></a> which will yield two lists for each directory it visits - splitting into files and dirs for you. If you only want the top directory you can just break the first time it yields</p>
<pre><code>from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break
</code></pre>
<p>And lastly, as that example shows, adding one list to another you can either use <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="noreferrer"><code>.extend()</code></a> or </p>
<pre><code>&gt;&gt;&gt; q = [1, 2, 3]
&gt;&gt;&gt; w = [4, 5, 6]
&gt;&gt;&gt; q = q + w
&gt;&gt;&gt; q
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>Personally, I prefer <code>.extend()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I prefer using the <a href="https://docs.python.org/library/glob.html" rel="noreferrer"><code>glob</code></a> module, as it does pattern matching and expansion.</p>
<pre><code>import glob
print(glob.glob("/home/adam/*.txt"))
</code></pre>
<p>It will return a list with the queried files:</p>
<pre><code>['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
os.listdir("somedirectory")
</code></pre>
<p>will return a list of all files and directories in "somedirectory".</p>
</div>
<div class="post-text" itemprop="text">
<h1>Get a list of files with Python 2 and 3</h1>
<hr/>
<p>I have also made a short video here: <em><a href="http://pythonprogramming.altervista.org/how-to-get-all-the-file-in-a-directory/" rel="noreferrer"><img src="https://i.stack.imgur.com/WJeCC.png" width="20"> Python: how to get a list of file in a directory</img></a></em></p>
<hr/>
<p><strong>os.listdir()</strong></p>
<p><em>or..... how to get all the files (and directories) in the current directory (Python 3)</em></p>
<p>The simplest way to have the file in the current directory in Python 3 is this. It's really simple; use the <code>os</code> module and the <code>listdir()</code> function and you'll have the file in that directory (and eventual folders that are in the directory, but you will not have the file in the subdirectory, for that you can use walk - I will talk about it later).</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; arr = os.listdir()
&gt;&gt;&gt; arr
['$RECYCLE.BIN', 'work.txt', '3ebooks.txt', 'documents']
</code></pre>
<hr/>
<p><strong>Using glob</strong></p>
<p><em>I found glob easier to select the file of the same type or with something in common. Look at the following example:</em></p>
<pre><code>import glob

txtfiles = []
for file in glob.glob("*.txt"):
    txtfiles.append(file)
</code></pre>
<p><em>Using list comprehension</em></p>
<pre><code>import glob

mylist = [f for f in glob.glob("*.txt")]
</code></pre>
<h3>Getting the full path name with os.path.abspath</h3>
<p>As you noticed, you don't have the full path of the file in the code above. If you need to have the absolute path, you can use another function of the <code>os.path</code> module called <code>_getfullpathname</code>, putting the file that you get from <code>os.listdir()</code> as an argument. There are other ways to have the full path, as we will check later (I replaced, as suggested by mexmex, _getfullpathname with <code>abspath</code>).</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; files_path = [os.path.abspath(x) for x in os.listdir()]
&gt;&gt;&gt; files_path
['F:\\documenti\applications.txt', 'F:\\documenti\collections.txt']
</code></pre>
<hr/>
<h3>Get the full path name of a type of file into all subdirectories with <code>walk</code></h3>
<p>I find this very useful to find stuff in many directories, and it helped me find a file about which I didn't remember the name:</p>
<pre><code>import os

# Getting the current work directory (cwd)
thisdir = os.getcwd()

# r=root, d=directories, f = files
for r, d, f in os.walk(thisdir):
    for file in f:
        if ".docx" in file:
            print(os.path.join(r, file))
</code></pre>
<p><strong>os.listdir(): get files in the current directory (Python 2)</strong></p>
<p>In Python 2 you, if you want the list of the files in the current directory, you have to give the argument as '.' or os.getcwd() in the os.listdir method.</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; arr = os.listdir('.')
&gt;&gt;&gt; arr
['$RECYCLE.BIN', 'work.txt', '3ebooks.txt', 'documents']
</code></pre>
<h3>To go up in the directory tree</h3>
<pre><code>&gt;&gt;&gt; # Method 1
&gt;&gt;&gt; x = os.listdir('..')

# Method 2
&gt;&gt;&gt; x= os.listdir('/')
</code></pre>
<h3>Get files: os.listdir() in a particular directory (Python 2 and 3)</h3>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; arr = os.listdir('F:\\python')
&gt;&gt;&gt; arr
['$RECYCLE.BIN', 'work.txt', '3ebooks.txt', 'documents']
</code></pre>
<h3>Get files of a particular subdirectory with os.listdir()</h3>
<pre><code>import os

x = os.listdir("./content")
</code></pre>
<h3>os.walk('.') - current directory</h3>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; arr = next(os.walk('.'))[2]
&gt;&gt;&gt; arr
['5bs_Turismo1.pdf', '5bs_Turismo1.pptx', 'esperienza.txt']
</code></pre>
<h3>glob module - all files</h3>
<pre><code>import glob
print(glob.glob("*"))

out:['content', 'start.py']
</code></pre>
<h3>next(os.walk('.')) and os.path.join('dir','file')</h3>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; arr = []
&gt;&gt;&gt; for d,r,f in next(os.walk("F:\_python")):
&gt;&gt;&gt;     for file in f:
&gt;&gt;&gt;         arr.append(os.path.join(r,file))
...
&gt;&gt;&gt; for f in arr:
&gt;&gt;&gt;     print(files)

&gt;output

F:\\_python\\dict_class.py
F:\\_python\\programmi.txt
</code></pre>
<h3>next(os.walk('F:\') - get the full path - list comprehension</h3>
<pre><code>&gt;&gt;&gt; [os.path.join(r,file) for r,d,f in next(os.walk("F:\\_python")) for file in f]
['F:\\_python\\dict_class.py', 'F:\\_python\\programmi.txt']
</code></pre>
<p><strong>os.walk - get full path - all files in sub dirs</strong></p>
<pre><code>x = [os.path.join(r,file) for r,d,f in os.walk("F:\\_python") for file in f]

&gt;&gt;&gt;x
['F:\\_python\\dict.py', 'F:\\_python\\progr.txt', 'F:\\_python\\readl.py']
</code></pre>
<h3>os.listdir() - get only txt files</h3>
<pre><code>&gt;&gt;&gt; arr_txt = [x for x in os.listdir() if x.endswith(".txt")]
&gt;&gt;&gt; print(arr_txt)
['work.txt', '3ebooks.txt']
</code></pre>
<h3>glob - get only txt files</h3>
<pre><code>&gt;&gt;&gt; import glob
&gt;&gt;&gt; x = glob.glob("*.txt")
&gt;&gt;&gt; x
['ale.txt', 'alunni2015.txt', 'assenze.text.txt', 'text2.txt', 'untitled.txt']
</code></pre>
<h3>Using glob to get the full path of the files</h3>
<p>If I should need the absolute path of the files:</p>
<pre><code>&gt;&gt;&gt; from path import path
&gt;&gt;&gt; from glob import glob
&gt;&gt;&gt; x = [path(f).abspath() for f in glob("F:\*.txt")]
&gt;&gt;&gt; for f in x:
...  print(f)
...
F:\acquistionline.txt
F:\acquisti_2018.txt
F:\bootstrap_jquery_ecc.txt
</code></pre>
<h3>Other use of glob</h3>
<p>If I want all the files in the directory:</p>
<pre><code>&gt;&gt;&gt; x = glob.glob("*")
</code></pre>
<h3>Using os.path.isfile to avoid directories in the list</h3>
<pre><code>import os.path
listOfFiles = [f for f in os.listdir() if os.path.isfile(f)]
print(listOfFiles)

&gt; output

['a simple game.py', 'data.txt', 'decorator.py']
</code></pre>
<h3>Using pathlib from (Python 3.4)</h3>
<pre><code>import pathlib

&gt;&gt;&gt; flist = []
&gt;&gt;&gt; for p in pathlib.Path('.').iterdir():
...  if p.is_file():
...   print(p)
...   flist.append(p)
...
error.PNG
exemaker.bat
guiprova.mp3
setup.py
speak_gui2.py
thumb.PNG
</code></pre>
<p>If you want to use list comprehension</p>
<pre><code>&gt;&gt;&gt; flist = [p for p in pathlib.Path('.').iterdir() if p.is_file()]
</code></pre>
<p>*You can use also just pathlib.Path() instead of pathlib.Path(".")</p>
<h2>Use glob method in pathlib.Path()</h2>
<pre><code>import pathlib

py = pathlib.Path().glob("*.py")
for file in py:
    print(file)
</code></pre>
<p>output:</p>
<pre><code>stack_overflow_list.py
stack_overflow_list_tkinter.py
</code></pre>
<h3>Get all and only files with os.walk</h3>
<pre><code>import os
x = [i[2] for i in os.walk('.')]
y=[]
for t in x:
    for f in t:
        y.append(f)

&gt;&gt;&gt; y
['append_to_list.py', 'data.txt', 'data1.txt', 'data2.txt', 'data_180617', 'os_walk.py', 'READ2.py', 'read_data.py', 'somma_defaltdic.py', 'substitute_words.py', 'sum_data.py', 'data.txt', 'data1.txt', 'data_180617']
</code></pre>
<h3>Get only files with next and walk in a directory</h3>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; x = next(os.walk('F://python'))[2]
&gt;&gt;&gt; x
['calculator.bat','calculator.py']
</code></pre>
<h3>Get only directories with next and walk in a directory</h3>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; next(os.walk('F://python'))[1] # for the current dir use ('.')
['python3','others']
</code></pre>
<h3>Get all the subdir names with <code>walk</code></h3>
<pre><code>&gt;&gt;&gt; for r,d,f in os.walk("F:\_python"):
...  for dirs in d:
...   print(dirs)
...
.vscode
pyexcel
pyschool.py
subtitles
_metaprogramming
.ipynb_checkpoints
</code></pre>
<h3>os.scandir() from Python 3.5 on</h3>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; x = [f.name for f in os.scandir() if f.is_file()]
&gt;&gt;&gt; x
['calculator.bat','calculator.py']

# Another example with scandir (a little variation from docs.python.org)
# This one is more efficient than os.listdir.
# In this case, it shows the files only in the current directory
# where the script is executed.

&gt;&gt;&gt; import os
&gt;&gt;&gt; with os.scandir() as i:
...  for entry in i:
...   if entry.is_file():
...    print(entry.name)
...
ebookmaker.py
error.PNG
exemaker.bat
guiprova.mp3
setup.py
speakgui4.py
speak_gui2.py
speak_gui3.py
thumb.PNG
&gt;&gt;&gt;
</code></pre>
<hr/>
<h2>Ex. 1: How many files are there in the subdirectories?</h2>
<p>In this example, we look for the number of files that are included in all the directory and its subdirectories.</p>
<pre><code>import os

def count(dir, counter=0):
    "returns number of files in dir and subdirs"
    for pack in os.walk(dir):
        for f in pack[2]:
            counter += 1
    return dir + " : " + str(counter) + "files"

print(count("F:\\python"))

&gt; output

&gt;'F:\\\python' : 12057 files'
</code></pre>
<h2>Ex.2: How to copy all files from a directory to another?</h2>
<p>A script to make order in your computer finding all files of a type (default: pptx) and copying them in a new folder.</p>
<pre><code>import os
import shutil
from path import path

destination = "F:\\file_copied"
# os.makedirs(destination)

def copyfile(dir, filetype='pptx', counter=0):
    "Searches for pptx (or other - pptx is the default) files and copies them"
    for pack in os.walk(dir):
        for f in pack[2]:
            if f.endswith(filetype):
                fullpath = pack[0] + "\\" + f
                print(fullpath)
                shutil.copy(fullpath, destination)
                counter += 1
    if counter &gt; 0:
        print("------------------------")
        print("\t==&gt; Found in: `" + dir + "` : " + str(counter) + " files\n")

for dir in os.listdir():
    "searches for folders that starts with `_`"
    if dir[0] == '_':
        # copyfile(dir, filetype='pdf')
        copyfile(dir, filetype='txt')


&gt; Output

_compiti18\Compito Contabilità 1\conti.txt
_compiti18\Compito Contabilità 1\modula4.txt
_compiti18\Compito Contabilità 1\moduloa4.txt
------------------------
==&gt; Found in: `_compiti18` : 3 files
</code></pre>
<h2>Ex. 3: How to get all the files in a txt file</h2>
<p>In case you want to create a txt file with all the file names:</p>
<pre><code>import os
mylist = ""
with open("filelist.txt", "w", encoding="utf-8") as file:
    for eachfile in os.listdir():
        mylist += eachfile + "\n"
    file.write(mylist)
</code></pre>
<h3>Example: txt with all the files of an hard drive</h3>
<pre><code>"""We are going to save a txt file with all the files in your directory.
We will use the function walk()

"""

import os

# see all the methods of os
# print(*dir(os), sep=", ")
listafile = []
percorso = []
with open("lista_file.txt", "w", encoding='utf-8') as testo:
    for root, dirs, files in os.walk("D:\\"):
        for file in files:
            listafile.append(file)
            percorso.append(root + "\\" + file)
            testo.write(file + "\n")
listafile.sort()
print("N. of files", len(listafile))
with open("lista_file_ordinata.txt", "w", encoding="utf-8") as testo_ordinato:
    for file in listafile:
        testo_ordinato.write(file + "\n")

with open("percorso.txt", "w", encoding="utf-8") as file_percorso:
    for file in percorso:
        file_percorso.write(file + "\n")

os.system("lista_file.txt")
os.system("lista_file_ordinata.txt")
os.system("percorso.txt")
</code></pre>
<h3>All the file of C:\\ in one text file</h3>
<p>This is a shorter version of the previous code. Change the folder where to start finding the files if you need to start from another position. This code generate a 50 mb on text file on my computer with something less then 500.000 lines with files with the complete path.</p>
<pre><code>import os

with open("file.txt", "w", encoding="utf-8") as filewrite:
    for r, d, f in os.walk("C:\\"):
        for file in f:
            filewrite.write(f"{r + file}\n")    
</code></pre>
<h2>A function to search for a certain type of file</h2>
<pre><code>import os

def searchfiles(extension='.ttf'):
    "Create a txt file with all the file of a type"
    with open("file.txt", "w", encoding="utf-8") as filewrite:
        for r, d, f in os.walk("C:\\"):
            for file in f:
                if file.endswith(extension):
                    filewrite.write(f"{r + file}\n")

# looking for ttf file (fonts)
searchfiles('ttf')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A one-line solution to get <strong>only list of files</strong> (no subdirectories):</p>
<pre><code>filenames = next(os.walk(path))[2]
</code></pre>
<p>or absolute pathnames:</p>
<pre><code>paths = [os.path.join(path,fn) for fn in next(os.walk(path))[2]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Getting Full File Paths From a Directory and All Its Subdirectories</strong></p>
<pre><code>import os

def get_filepaths(directory):
    """
    This function will generate the file names in a directory 
    tree by walking the tree either top-down or bottom-up. For each 
    directory in the tree rooted at directory top (including top itself), 
    it yields a 3-tuple (dirpath, dirnames, filenames).
    """
    file_paths = []  # List which will store all of the full filepaths.

    # Walk the tree.
    for root, directories, files in os.walk(directory):
        for filename in files:
            # Join the two strings in order to form the full filepath.
            filepath = os.path.join(root, filename)
            file_paths.append(filepath)  # Add it to the list.

    return file_paths  # Self-explanatory.

# Run the above function and store its results in a variable.   
full_file_paths = get_filepaths("/Users/johnny/Desktop/TEST")
</code></pre>
<hr/>
<ul>
<li>The path I provided in the above function contained 3 files— two of them in the root directory, and another in a subfolder called "SUBFOLDER."  You can now do things like:</li>
<li><p><code>print full_file_paths</code> which will print the list:</p>
<ul>
<li><code>['/Users/johnny/Desktop/TEST/file1.txt', '/Users/johnny/Desktop/TEST/file2.txt', '/Users/johnny/Desktop/TEST/SUBFOLDER/file3.dat']</code></li>
</ul></li>
</ul>
<p>If you'd like, you can open and read the contents, or focus only on files with the extension ".dat" like in the code below:</p>
<pre><code>for f in full_file_paths:
  if f.endswith(".dat"):
    print f
</code></pre>
<p><code>/Users/johnny/Desktop/TEST/SUBFOLDER/file3.dat</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Since version 3.4 there are builtin <em>iterators</em> for this which are a lot more efficient than <a href="http://docs.python.org/3/library/os.html#os.listdir" rel="noreferrer"><code>os.listdir()</code></a>:</p>
<p><a href="http://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a>: <em>New in version 3.4.</em></p>
<pre><code>&gt;&gt;&gt; import pathlib
&gt;&gt;&gt; [p for p in pathlib.Path('.').iterdir() if p.is_file()]
</code></pre>
<p>According to <a href="http://www.python.org/dev/peps/pep-0428/" rel="noreferrer">PEP 428</a>, the aim of the <a href="http://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a> library is to provide a simple hierarchy of classes to handle filesystem paths and the common operations users do over them.</p>
<p><a href="http://docs.python.org/3/library/os.html#os.scandir" rel="noreferrer"><code>os.scandir()</code></a>: <em>New in version 3.5.</em></p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; [entry for entry in os.scandir('.') if entry.is_file()]
</code></pre>
<p>Note that <a href="http://docs.python.org/3/library/os.html#os.walk" rel="noreferrer"><code>os.walk()</code></a> uses <a href="http://docs.python.org/3/library/os.html#os.scandir" rel="noreferrer"><code>os.scandir()</code></a> instead of <a href="http://docs.python.org/3/library/os.html#os.listdir" rel="noreferrer"><code>os.listdir()</code></a> from version 3.5, and its speed got increased by 2-20 times according to <a href="http://www.python.org/dev/peps/pep-0471/" rel="noreferrer">PEP 471</a>.</p>
<p>Let me also recommend reading ShadowRanger's comment below.</p>
</div>
<div class="post-text" itemprop="text">
<p>I really liked <a href="https://stackoverflow.com/a/3215392/901641">adamk's answer</a>, suggesting that you use <code>glob()</code>, from the module of the same name. This allows you to have pattern matching with <code>*</code>s.</p>
<p>But as other people pointed out in the comments, <code>glob()</code> can get tripped up over inconsistent slash directions. To help with that, I suggest you use the <code>join()</code> and <code>expanduser()</code> functions in the <code>os.path</code> module, and perhaps the <code>getcwd()</code> function in the <code>os</code> module, as well.</p>
<p>As examples:</p>
<pre><code>from glob import glob

# Return everything under C:\Users\admin that contains a folder called wlp.
glob('C:\Users\admin\*\wlp')
</code></pre>
<p>The above is terrible - the path has been hardcoded and will only ever work on Windows between the drive name and the <code>\</code>s being hardcoded into the path.</p>
<pre><code>from glob    import glob
from os.path import join

# Return everything under Users, admin, that contains a folder called wlp.
glob(join('Users', 'admin', '*', 'wlp'))
</code></pre>
<p>The above works better, but it relies on the folder name <code>Users</code> which is often found on Windows and not so often found on other OSs. It also relies on the user having a specific name, <code>admin</code>.</p>
<pre><code>from glob    import glob
from os.path import expanduser, join

# Return everything under the user directory that contains a folder called wlp.
glob(join(expanduser('~'), '*', 'wlp'))
</code></pre>
<p>This works perfectly across all platforms.</p>
<p>Another great example that works perfectly across platforms and does something a bit different:</p>
<pre><code>from glob    import glob
from os      import getcwd
from os.path import join

# Return everything under the current directory that contains a folder called wlp.
glob(join(getcwd(), '*', 'wlp'))
</code></pre>
<p>Hope these examples help you see the power of a few of the functions you can find in the standard Python library modules.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Preliminary notes</h2>
<ul>
<li>Although there's a clear differentiation between <em>file</em> and <em>directory</em> terms in the question text, some may argue that directories are actually special files</li>
<li>The statement: "<em>all files of a directory</em>" can be interpreted in two ways:

<ol>
<li>All <strong>direct</strong> (or level 1) descendants <strong>only</strong></li>
<li>All descendants in the whole directory tree (including the ones in sub-directories)</li>
</ol></li>
<li><p>When the question was asked, I imagine that <em>Python <strong>2</strong></em>, was the <em>LTS</em> version, however the code samples will be run by <em>Python <strong>3</strong>(<strong>.5</strong>)</em> (I'll keep them as <em>Python 2</em> compliant as possible; also, any code belonging to <em>Python</em> that I'm going to post, is from <strong>v3.5.4</strong> - unless otherwise specified). That has consequences related to another keyword in the question: "<em>add them into a <strong>list</strong></em></p></li></ul></div>
<div class="post-text" itemprop="text">
<pre><code>def list_files(path):
    # returns a list of names (with extension, without full path) of all files 
    # in folder path
    files = []
    for name in os.listdir(path):
        if os.path.isfile(os.path.join(path, name)):
            files.append(name)
    return files 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are looking for a Python implementation of <strong>find</strong>, this is a recipe I use rather frequently:</p>
<pre><code>from findtools.find_files import (find_files, Match)

# Recursively find all *.sh files in **/usr/bin**
sh_files_pattern = Match(filetype='f', name='*.sh')
found_files = find_files(path='/usr/bin', match=sh_files_pattern)

for found_file in found_files:
    print found_file
</code></pre>
<p>So I made a PyPI <a href="https://pypi.python.org/pypi/findtools/" rel="nofollow noreferrer">package</a> out of it and there is also a <a href="https://github.com/ewiger/findtools" rel="nofollow noreferrer">GitHub repository</a>. I hope that someone finds it potentially useful for this code.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Returning a list of absolute filepaths, does not recurse into subdirectories</strong></p>
<pre><code>L = [os.path.join(os.getcwd(),f) for f in os.listdir('.') if os.path.isfile(os.path.join(os.getcwd(),f))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
import os.path


def get_files(target_dir):
    item_list = os.listdir(target_dir)

    file_list = list()
    for item in item_list:
        item_dir = os.path.join(target_dir,item)
        if os.path.isdir(item_dir):
            file_list += get_files(item_dir)
        else:
            file_list.append(item_dir)
    return file_list
</code></pre>
<p>Here I use a recursive structure.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>For greater results, you can use <code>listdir()</code> method of the <code>os</code> module along with a generator (a generator is a powerful iterator that keeps its state, remember?). The following code works fine with both versions: Python 2 and Python 3.</p>
</blockquote>
<p>Here's a code:</p>
<pre><code>import os

def files(path):  
    for file in os.listdir(path):
        if os.path.isfile(os.path.join(path, file)):
            yield file

for file in files("."):  
    print (file)
</code></pre>
<p>The <code>listdir()</code> method returns the list of entries for the given directory. The method <code>os.path.isfile()</code> returns <code>True</code> if the given entry is a file. And the <code>yield</code> operator quits the func but keeps its current state, and it returns only the name of the entry detected as a file. All the above allows us to loop over the generator function.</p>
<p>Hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am assuming that all your files are of <code>*.txt</code> format, and are stored inside a directory with path <code>data/</code>.</p>
<p>One can use <a href="https://docs.python.org/3/library/glob.html" rel="nofollow noreferrer">glob</a> module of <code>python</code> to list all files of the directory, and add them to a list named <code>fnames</code>, in the following manner:</p>
<pre><code>import glob

fnames = glob.glob("data/*.txt")  #fnames: list data type
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code># -** coding: utf-8 -*-
import os
import traceback

print '\n\n'

def start():
    address = "/home/ubuntu/Desktop"
    try:
        Folders = []
        Id = 1
        for item in os.listdir(address):
            endaddress = address + "/" + item
            Folders.append({'Id': Id, 'TopId': 0, 'Name': item, 'Address': endaddress })
            Id += 1         

            state = 0
            for item2 in os.listdir(endaddress):
                state = 1
            if state == 1: 
                Id = FolderToList(endaddress, Id, Id - 1, Folders)
        return Folders
    except:
        print "___________________________ ERROR ___________________________\n" + traceback.format_exc()

def FolderToList(address, Id, TopId, Folders):
    for item in os.listdir(address):
        endaddress = address + "/" + item
        Folders.append({'Id': Id, 'TopId': TopId, 'Name': item, 'Address': endaddress })
        Id += 1

        state = 0
        for item in os.listdir(endaddress):
            state = 1
        if state == 1: 
            Id = FolderToList(endaddress, Id, Id - 1, Folders)
    return Id

print start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using generators</p>
<pre><code>import os
def get_files(search_path):
     for (dirpath, _, filenames) in os.walk(search_path):
         for filename in filenames:
             yield os.path.join(dirpath, filename)
list_files = get_files('.')
for filename in list_files:
    print(filename)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use this code, for get iterator that run all over the full path of files (Directories + file name). </p>
<pre><code>import os

def get_iterator_all_files_name(dir_path):
    for (dirpath, dirnames, filenames) in os.walk(dir_path):
        for f in filenames:
            yield os.path.join(dirpath, f)
</code></pre>
<p>Or use that, for get it in list.</p>
<pre><code>import os

def get_list_all_files_name(dir_path):
    all_files_path = []

    for (dirpath, dirnames, filenames) in os.walk(dir_path):
        for f in filenames:
            all_files_path.append(os.path.join(dirpath, f))

    return all_files_path
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import dircache
list = dircache.listdir(pathname)
i = 0
check = len(list[0])
temp = []
count = len(list)
while count != 0:
  if len(list[i]) != check:
     temp.append(list[i-1])
     check = len(list[i])
  else:
    i = i + 1
    count = count - 1

print temp
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use this function if you want to use a different file type or get the full directory:</p>
<pre><code>import os

def createList(foldername, fulldir = True, suffix=".jpg"):
    file_list_tmp = os.listdir(foldername)
    #print len(file_list_tmp)
    file_list = []
    if fulldir:
        for item in file_list_tmp:
            if item.endswith(suffix):
                file_list.append(os.path.join(foldername, item))
    else:
        for item in file_list_tmp:
            if item.endswith(suffix):
                file_list.append(item)
    return file_list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another very readable variant for Python 3.4+ is using pathlib.Path.glob:</p>
<pre><code>from pathlib import Path
folder = '/foo'
[f for f in Path(folder).glob('*') if f.is_file()]
</code></pre>
<p>It is simple to make more specific, e.g. only look for Python source files which are not symbolic links, also in all subdirectories:</p>
<pre><code>[f for f in Path(folder).glob('**/*.py') if not f.is_symlink()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A wise teacher told me once that:</p>
<blockquote>
<p>When there are several established ways to do something, none of them is good for all cases.</p>
</blockquote>
<p>I will thus add a solution for a <strong>subset</strong> of the problem: quite often, we only want to check whether a file matches a start string and an end string, without going into subdirectories. We would thus like a function that returns a list of filenames, like:</p>
<pre><code>filenames = dir_filter('foo/baz', radical='radical', extension='.txt')
</code></pre>
<p>If you care to first declare two functions, this can be done:</p>
<pre><code>def file_filter(filename, radical='', extension=''):
    "Check if a filename matches a radical and extension"
    if not filename:
        return False
    filename = filename.strip()
    return(filename.startswith(radical) and filename.endswith(extension))

def dir_filter(dirname='', radical='', extension=''):
    "Filter filenames in directory according to radical and extension"
    if not dirname:
        dirname = '.'
    return [filename for filename in os.listdir(dirname)
                if file_filter(filename, radical, extension)]
</code></pre>
<p>This solution could be easily generalized with regular expressions (and you might want to add a <code>pattern</code> argument, if you do not want your patterns to always stick to the start or end of the filename).</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's my general-purpose function for this.  It returns a list of file paths rather than filenames since I found that to be more useful.  It has a few optional arguments that make it versatile.  For instance, I often use it with arguments like <code>pattern='*.txt'</code> or <code>subfolders=True</code>.</p>
<pre><code>import os
import fnmatch

def list_paths(folder='.', pattern='*', case_sensitive=False, subfolders=False):
    """Return a list of the file paths matching the pattern in the specified 
    folder, optionally including files inside subfolders.
    """
    match = fnmatch.fnmatchcase if case_sensitive else fnmatch.fnmatch
    walked = os.walk(folder) if subfolders else [next(os.walk(folder))]
    return [os.path.join(root, f)
            for root, dirnames, filenames in walked
            for f in filenames if match(f, pattern)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For python2:
pip install rglob</p>
<pre><code>import rglob
file_list=rglob.rglob("/home/base/dir/", "*")
print file_list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I will provide a sample one liner where sourcepath and file type can be provided as input. The code returns a list of filenames with csv extension. Use <em>.</em> in case all files needs to be returned. This will also recursively scans the subdirectories. </p>
<p><code>[y for x in os.walk(sourcePath) for y in glob(os.path.join(x[0], '*.csv'))]</code></p>
<p>Modify file extensions and source path as needed. </p>
</div>
<div class="post-text" itemprop="text">
<p>To get all files from a specified folder (including subdirectories as well).</p>
<pre><code>import glob
import os

print([entry for entry in glob.iglob("{}/**".format("FILE_PATH"), recursive=True) if os.path.isfile(entry) == True])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>to display full path and filter with an extension, use,</p>
<pre><code>import os
onlyfiles = [f for f in os.listdir(file) if len(f) &gt;= 5 and  f[-5:] == ".json" and isfile(join(file, f))]
</code></pre>
<p>change number 5 based on the '.' + 'characters in extension/type of file'</p>
</div>
<span class="comment-copy">Related to <a href="http://stackoverflow.com/questions/973473/getting-a-list-of-all-subdirectories-in-the-current-directory">How to get a list of subdirectories</a></span>
<span class="comment-copy"><code>os.listdir(path)</code> returns a list of strings of filenames and subdirectories from the given path, or current if omitted.  (Putting this here for people from Google to see because the currently top answer doesn't answer the question.)</span>
<span class="comment-copy">All files only? Do you want to list subdirectories?</span>
<span class="comment-copy">This works nicely (top answer below): <code>from os import listdir</code> <code>from os.path import isfile, join</code> <code>files = [f for f in listdir(mypath) if isfile(join(mypath, f))]</code> Note: you need to assign a string to the directory path where the files are stored (ex: <code>mypath = "users/name/desktop/"</code>).</span>
<span class="comment-copy">Do you mean files as: Ordinary files that aren't sub-directories or links, or all files, including sub-directories and links?</span>
<span class="comment-copy">A bit simpler: <code>(_, _, filenames) = walk(mypath).next()</code>  (if you are confident that the walk will return at least one value, which it should.)</span>
<span class="comment-copy">Slight modification to store full paths: for (dirpath, dirnames, filenames) in os.walk(mypath):         checksum_files.extend(os.path.join(dirpath, filename) for filename in filenames)         break</span>
<span class="comment-copy"><code>f.extend(filenames)</code> is not actually equivalent to <code>f = f + filenames</code>. <code>extend</code> will modify <code>f</code> in-place, whereas adding creates a new list in a new memory location. This means <code>extend</code> is generally more efficient than <code>+</code>, but it can sometimes lead to confusion if multiple objects hold references to the list. Lastly, it's worth noting that <code>f += filenames</code> is equivalent to <code>f.extend(filenames)</code>, <i>not</i> <code>f = f + filenames</code>.</span>
<span class="comment-copy">@misterbee, your solution is the best, just one small improvement: <code>_, _, filenames = next(walk(mypath), (None, None, []))</code></span>
<span class="comment-copy">in python 3.x use <code>(_, _, filenames) = next(os.walk(mypath))</code></span>
<span class="comment-copy">that's a shortcut for listdir+fnmatch <a href="http://docs.python.org/library/fnmatch.html#fnmatch.fnmatch" rel="nofollow noreferrer">docs.python.org/library/fnmatch.html#fnmatch.fnmatch</a></span>
<span class="comment-copy">to clarify, this does <i>not</i> return the "full path"; it simply returns the expansion of the glob, whatever it may be. E.g., given <code>/home/user/foo/bar/hello.txt</code>, then, if running in directory <code>foo</code>, the <code>glob("bar/*.txt")</code> will return <code>bar/hello.txt</code>. There are cases when you do in fact want the full (i.e., absolute) path; for those cases, see <a href="http://stackoverflow.com/questions/51520/how-to-get-an-absolute-file-path-in-python" title="how to get an absolute file path in python">stackoverflow.com/questions/51520/…</a></span>
<span class="comment-copy">Related: find files recursively with glob: <a href="https://stackoverflow.com/a/2186565/4561887">stackoverflow.com/a/2186565/4561887</a></span>
<span class="comment-copy">This returns the relative path of the files, as compared with the full path returned by <code>glob.glob</code></span>
<span class="comment-copy">@JIXiang: <code>os.listdir()</code> always returns <i>mere filenames</i> (not relative paths). What <code>glob.glob()</code> returns is driven by the path format of the input pattern.</span>
<span class="comment-copy">os.listdir() - &gt; It always list the dir and file inside the provided location . Is there any way to list only directory not files ?</span>
<span class="comment-copy">You should include the path argument to listdir.</span>
<span class="comment-copy">It's definitely encouraged to include some context/explanation for code as that makes the answer more useful.</span>
<span class="comment-copy">I agree, but I did not notice something also, that python2 requires the argument whilst python3 is optional, If you improve the answer for both python versions would be great :)</span>
<span class="comment-copy">Ok, I went into Python 2 and find the differences and I edited the post.</span>
<span class="comment-copy">Well.......... This is an example of examples... Which to me is good.. After all there is never just one way to do something with programming and this shows of why python is such a good language and powerful at the same time. +1 from me for the effort of this post over time.</span>
<span class="comment-copy">Only a one-liner if you've already <code>import os</code>. Seems less concise than <code>glob()</code> to me.</span>
<span class="comment-copy">problem with glob is that a folder called 'something.something' would be returned by glob('/home/adam/*.*')</span>
<span class="comment-copy">On OS X, there's something called a bundle. It's a directory which should generally be treated as a file (like a .tar). Would you want those treated as a file or a directory? Using <code>glob()</code> would treat it as a file. Your method would treat it as a directory.</span>
<span class="comment-copy">Thanks! I think it is the only solution not returning directly a <code>list</code>. Could use <code>p.name</code> instead of the first <code>p</code> alternatively if preferred.</span>
<span class="comment-copy">Welcome! I would prefer generating <code>pathlib.Path()</code> instances since they have many useful methods I would not want to waste waste. You can also call <code>str(p)</code> on them for path names.</span>
<span class="comment-copy">Note: The <code>os.scandir</code> solution is going to be more efficient than <code>os.listdir</code> with an <code>os.path.is_file</code> check or the like, even if you need a <code>list</code> (so you don't benefit from lazy iteration), because <code>os.scandir</code> uses OS provided APIs that give you the <code>is_file</code> information for free as it iterates, no per-file round trip to the disk to <code>stat</code> them at all (on Windows, the <code>DirEntry</code>s get you complete <code>stat</code> info for free, on *NIX systems it needs to <code>stat</code> for info beyond <code>is_file</code>, <code>is_dir</code>, etc., but <code>DirEntry</code> caches on first <code>stat</code> for convenience).</span>
<span class="comment-copy">I've found this to be the most helpful solution (using <code>pathlib</code>). I can easily get specific extension types and absolute paths. Thank you!</span>
<span class="comment-copy">You can also use <code>entry.name</code> to get only the file name, or <code>entry.path</code> to get its full path. No more os.path.join() all over the place.</span>
<span class="comment-copy">Extra glob fun: starting in Python 3.5, <code>**</code> works as long as you set <code>recursive = True</code>. See the docs here: <a href="https://docs.python.org/3.5/library/glob.html#glob.glob" rel="nofollow noreferrer">docs.python.org/3.5/library/glob.html#glob.glob</a></span>
<span class="comment-copy">You had posted it, but I had cleaned it up once I had read it :-)</span>
<span class="comment-copy">maybe bit longer but v clear what it is doing</span>
<span class="comment-copy">Note: <code>os.path.abspath(f)</code> would be a somewhat cheaper substitute for <code>os.path.join(os.getcwd(),f)</code>.</span>
<span class="comment-copy">I'd be more efficient still if you started with <code>cwd = os.path.abspath('.')</code>, then used <code>cwd</code> instead of <code>'.'</code> and <code>os.getcwd()</code> throughout to avoid loads of redundant system calls.</span>
<span class="comment-copy">This is too specific for an isolated usecase and not generally useful, especially since there is no explanation whatsoever what the code is doing. The blanket <code>except</code> handling is also a bad example of how to handle exceptions in general.</span>
<span class="comment-copy">How is it different from other answers explaining about <code>os.walk</code>?</span>
<span class="comment-copy"><a href="http://docs.python.org/release/2.6.7/library/dircache.html" rel="nofollow noreferrer">dirchache</a> is  "Deprecated since version 2.6: The dircache module has been removed in Python 3.0."</span>
<span class="comment-copy">You can decide to use <code>os.path.join()</code> <i>inside</i> the loop rather than double up your looping and filtering code. This answer doesn't really add anything over existing answers other than the <code>fulldir</code> flag, so you'd really want to do a better job of the implementation. I'd use <code>def files_list(p, fulldir=True, suffix=None):</code> (indent), <code>names = os.listdir(p)</code>, <code>if suffix is not None: names = (f.endswith(suffix) for f in names)</code>,  return [os.path.join(p, f) if fullname else f for f in names]` to at least keep it compact and efficient.</span>
<span class="comment-copy">Could you point out which part is a double loop? Thanks.</span>
<span class="comment-copy">You have two <code>for ... if ... append</code> constructs in your function, only different in what is appended each time. That’s a lot of needless code duplication.</span>
<span class="comment-copy">If you are going to use <code>glob</code>, then just use <code>glob('**/*.csv', recursive=True)</code>. No need to combine this with <code>os.walk()</code> to recurse (<code>recursive</code> and <code>**</code> are supported since Python 3.5).</span>
