<div class="post-text" itemprop="text">
<p>I have a dataframe with two columns containing lists. I want to combine these columns into a single column and merge the lists into a single list. Also this list should only contain unique values from the original lists.</p>
<p>I've tried merging them using <code>df['E']=df[['B','C']].values.tolist()</code>.</p>
<p>However this creates a single column with values comprising two lists.</p>
<p>The dataframe looks something like this:</p>
<pre><code>A       B       C       D
a1      [b1,b2] [c1,b1] d1
a2      [b1,b1] [b3]    d2
a3      [b2]    [b2,b2] d3
</code></pre>
<p>The final dataframe should look like this:</p>
<pre><code>A       B       C       D       E
a1      [b1,b2] [c1,b1] d1      [b1,b2,c1]
a2      [b1,b1] [b3]    d2      [b1,b3]
a3      [b2]    [b2,b2] d3      [b2]
</code></pre>
<p>Edit: The values within the lists of the dataframe are strings.</p>
</div>
<div class="post-text" itemprop="text">
<p>IIUC</p>
<pre><code>df['E']=(df.B+df.C).map(set).map(list)
df
Out[81]: 
    A         B         C   D             E
0  a1  [b1, b2]  [c1, b1]  d1  [b2, b1, c1]
1  a2  [b1, b1]      [b3]  d2      [b3, b1]
2  a3      [b2]  [b2, b2]  d3          [b2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> with <a href="https://docs.python.org/3/library/stdtypes.html?highlight=dict#dict.fromkeys" rel="nofollow noreferrer"><code>dict.fromkeys</code></a> within a list comprehension. Note by your choice of lists within series you are losing all vectorisation benefits.</p>
<pre><code>from itertools import chain

df = pd.DataFrame({'A': ['a1', 'a2', 'a3'],
                   'B': [['b1', 'b2'], ['b1', 'b1'], ['b2']],
                   'C': [['c1', 'b1'], ['b3'], ['b2', 'b2']],
                   'D': ['d1', 'd2', 'd3']})

df['E'] = [list(dict.fromkeys(chain(x, y))) for x, y in zip(df['B'], df['C'])]

print(df)

    A         B         C   D             E
0  a1  [b1, b2]  [c1, b1]  d1  [b1, b2, c1]
1  a2  [b1, b1]      [b3]  d2      [b1, b3]
2  a3      [b2]  [b2, b2]  d3          [b2]
</code></pre>
<p>The benefit of this method in Python v3.7+ (and unofficially in v3.6 as a CPython implementation detail) is ordering is preserved, as dictionaries are insertion-ordered.</p>
</div>
<div class="post-text" itemprop="text">
<p>If order does not matter, <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">set</a> will do the job:</p>
<pre><code>import pandas as pd

data = [['a1', ['b1', 'b2'], ['c1', 'b1'], 'd1'],
        ['a2', ['b1', 'b1'], ['b3'], 'd2'],
        ['a3', ['b2'], ['b2', 'b2'], 'd3']]

df = pd.DataFrame(data=data, columns=['A', 'B', 'C', 'D'])


def uniques(xs):
    return list(set(xi for x in xs for xi in x))


df['E'] = df[['B', 'C']].apply(uniques, axis=1)

print(df)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>    A         B         C   D             E
0  a1  [b1, b2]  [c1, b1]  d1  [b1, b2, c1]
1  a2  [b1, b1]      [b3]  d2      [b1, b3]
2  a3      [b2]  [b2, b2]  d3          [b2]
</code></pre>
<p>If order does matter use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a>:</p>
<pre><code>import pandas as pd
from collections import OrderedDict

data = [['a1', ['b1', 'b2'], ['c1', 'b1'], 'd1'],
        ['a2', ['b1', 'b1'], ['b3'], 'd2'],
        ['a3', ['b2'], ['b2', 'b2'], 'd3']]

df = pd.DataFrame(data=data, columns=['A', 'B', 'C', 'D'])


def uniques(xs):
    return list(OrderedDict().fromkeys(xi for x in xs for xi in x))


df['E'] = df[['B', 'C']].apply(uniques, axis=1)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>    A         B         C   D             E
0  a1  [b1, b2]  [c1, b1]  d1  [b1, b2, c1]
1  a2  [b1, b1]      [b3]  d2      [b1, b3]
2  a3      [b2]  [b2, b2]  d3          [b2]
</code></pre>
</div>
<span class="comment-copy">look into <code>set</code></span>
<span class="comment-copy">@jpp I've added a clarification to the question. The lists within the dataframe are strings and hence the provided solutions were not working. How can I solve this?</span>
<span class="comment-copy">@jpp I got it working. However do you know of a way to show the dataframe without empty list in column. I'm looking for something like: df = df[df['E']!=[]]</span>
<span class="comment-copy"><code>df.E=df.E.where(df.E.astype(bool),'')</code> @Mohnish</span>
<span class="comment-copy">Do you know how I can drop a particular value from a list within the datafame cell?</span>
<span class="comment-copy">@Mohnish this is another question , you may check list.remove</span>
<span class="comment-copy">Sure, the lists within your example dataframe also contain strings. If your dataframe is different, <a href="https://stackoverflow.com/questions/ask">post a new question defining your dataframe precisely</a>.</span>
<span class="comment-copy">Neat....I like the idea of using a function. Thanks mate!</span>
