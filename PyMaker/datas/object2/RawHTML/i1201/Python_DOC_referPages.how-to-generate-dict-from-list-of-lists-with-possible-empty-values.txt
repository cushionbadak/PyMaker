<div class="post-text" itemprop="text">
<p>I have list of lists: <code>dep = [['ArithmeticError'], ['ZeroDivisionError', 'ArithmeticError'], ['OSError'], ['FileNotFoundError', 'OSError']]</code> and I need to convert it to dict like: <code>dep = {'ArithmeticError': None, 'ZeroDivisionError': 'ArithmeticError', 'OSError': None, 'FileNotFoundError': 'OSError'}</code>. Also it possible to have list of strings as value with  some names of errors.
I saw variants with dict(), but it doesn't work for me because empty values is possible.
I tried to use <code>dep = dict(dep)</code>, but I have error: "dictionary update sequence element #0 has length 1; 2 is required".</p>
</div>
<div class="post-text" itemprop="text">
<p>You could add <code>None</code> to the end of each sublist, then take the first two items.</p>
<pre><code>dep = dict((sublist + [None])[:2] for sublist in dep)
</code></pre>
<p>e.g. using <a href="https://docs.python.org/3/library/pprint.html" rel="nofollow noreferrer"><strong><code>pprint</code></strong></a> to print nicely</p>
<pre><code>&gt;&gt;&gt; dep = [['ArithmeticError'],
...        ['ZeroDivisionError', 'ArithmeticError'],
...        ['OSError'],
...        ['FileNotFoundError', 'OSError']]

&gt;&gt;&gt; from pprint import pprint

&gt;&gt;&gt; result = dict((sublist + [None])[:2] for sublist in dep)

&gt;&gt;&gt; pprint(result)
{'ArithmeticError': None,
 'FileNotFoundError': 'OSError',
 'OSError': None,
 'ZeroDivisionError': 'ArithmeticError'}
</code></pre>
<p>edit: To perhaps be clearer we could also use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><strong><code>itemgetter</code></strong></a> to give a name to what we're returning:</p>
<pre><code>&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; first_two = itemgetter(0, 1)

&gt;&gt;&gt; first_two(['ZeroDivisionError', 'ArithmeticError', None])
('ZeroDivisionError', 'ArithmeticError')
</code></pre>
<p>Then the above solution becomes:</p>
<pre><code>&gt;&gt;&gt; result = dict(first_two(sublist + [None]) for sublist in dep)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this:</p>
<pre><code>dep = [['ArithmeticError'], ['ZeroDivisionError', 'ArithmeticError'],
   ['OSError'], ['FileNotFoundError', 'OSError']]

dep_dict = {}

for val in dep:
    if len(val) == 1:
        dep_dict[val[0]] = None
    else:
        dep_dict[val[0]] = val[1]
</code></pre>
<p>This works by making the dictionary <code>dep_dict</code> and assigning it's keys to be the values of <code>dep</code> and their values to either <code>None</code> or the second item in the corresponding list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just a small check and a generator</p>
<pre><code>dep = dict((a[0],a[1]) if len(a)&gt;1 else (a[0],None) for a in dep)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a generator with basic conditional. </p>
<pre><code>dep_dict = {i[0]: None if len(i) == 1 else i[1]   for i in dep}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are probably easier ways, but you can use:</p>
<pre><code>dep = [['ArithmeticError'], ['ZeroDivisionError', 'ArithmeticError'], ['OSError'], ['FileNotFoundError', 'OSError']]

d={}
for x in dep:
    if len(x) == 1:
        d[x[0]] = None
    elif len(x) == 2:
        d[x[0]] = x[1]

print(d)
</code></pre>
<hr/>
<p><strong>Output:</strong></p>
<pre><code>{'ArithmeticError': None, 'ZeroDivisionError': 'ArithmeticError', 'OSError': None, 'FileNotFoundError': 'OSError'}
</code></pre>
</div>
<span class="comment-copy">What have you tried, and what precisely is the problem with it?</span>
<span class="comment-copy">Is what you're really after: <code>{'ArithmeticError': ['ZeroDivisionError'], 'OSError': ['FileNotFoundError']}</code> ? That's straight forward if only two deep - otherwise, you're after what looks like a dependency graph...</span>
<span class="comment-copy">@JonClements, yes, I think</span>
<span class="comment-copy">Best answer, well done.</span>
<span class="comment-copy">I try to be uniform.</span>
<span class="comment-copy">Liked your clever answer but in terms of readability I always found a slicing a bit more time to understand when skimming over a code snippet.</span>
<span class="comment-copy">@M.A.K.Simanto I've updated with an example using <code>itemgetter</code> which is perhaps more readable.</span>
<span class="comment-copy">Great, easier to read than a generator now, will definitely try this.</span>
