<div class="post-text" itemprop="text">
<p>I'm using <code>zipfile</code> to create an archive of all files in a directory (recursively, while preserving directory structure including empty folders) and want the process to skip the filenames specified in a list.</p>
<p>This is the basic function that os.walks through a directory and adds all the containing files and directories to an archive.</p>
<pre><code>def zip_dir(path):
    zipname = str(path.rsplit('/')[-1]) + '.zip'
    with zipfile.ZipFile(zipname, 'w', zipfile.ZIP_DEFLATED) as zf:
        if os.path.isdir(path):
            for root, dirs, files in os.walk(path):
                for file_or_dir in files + dirs:
                    zf.write(os.path.join(root, file_or_dir),
                            os.path.relpath(os.path.join(root, file_or_dir),
                            os.path.join(path, os.path.pardir)))
        elif os.path.isfile(filepath):
            zf.write(os.path.basename(filepath))
    zf.printdir()
    zf.close()
</code></pre>
<p>We can see the code should also have the ability to handle single files but it is mainly the part concerning directories that we are interested in.</p>
<p>Now let's say we have a list of filenames that we want to exclude from being added to the zip archive.</p>
<pre><code>skiplist = ['.DS_Store', 'tempfile.tmp']
</code></pre>
<p>What is the best and cleanest way to achieve this?  </p>
<p>I tried using <code>zip</code> which was somewhat successful but causes it to exclude empty folders for some reason (empty folders should be included). I'm not sure why this happens.</p>
<pre><code>skiplist = ['.DS_Store', 'tempfile.tmp']
for root, dirs, files in os.walk(path):
    for (file_or_dir, skipname) in zip(files + dirs, skiplist):
        if skipname not in file_or_dir:
            zf.write(os.path.join(root, file_or_dir),
                    os.path.relpath(os.path.join(root, file_or_dir),
                    os.path.join(path, os.path.pardir)))
</code></pre>
<p>It would also be interesting to see if anyone has a clever idea for adding the ability to skip specific file extensions, perhaps something like <code>.endswith('.png')</code> but I'm not entirely sure of how to incorporate it together with the existing skiplist.</p>
<p>I would also appreciate any other general comments regarding the function and if it indeed works as expected without surprises, as well as any suggestions for optimizations or improvements.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simply check if the file is not in <code>skiplist</code>:</p>
<pre><code>skiplist = {'.DS_Store', 'tempfile.tmp'}

for root, dirs, files in os.walk(path):
    for file in files + dirs:
        if file not in skiplist:
            zf.write(os.path.join(root, file),
                     os.path.relpath(os.path.join(root, file),
                     os.path.join(path, os.path.pardir)))
</code></pre>
<p>This will ensure that files in <code>skiplist</code> won't be added to the archive. </p>
<p>Another optimization is to make <code>skiplist</code> a set, just in case it gets very large, and you want constant time O(1) lookup instead of linear O(N) lookup from using a list. </p>
<p>You can research this more at <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">TimeComplexity</a>, which shows the time complexities of various Python operations on data structures. </p>
<p>As for extensions, you can use <a href="https://docs.python.org/3/library/os.path.html#os.path.splitext" rel="nofollow noreferrer"><code>os.path.splitext()</code></a> to extract the extension and use the same logic as above:</p>
<pre><code>from os.path import splitext

extensions = {'.png', '.txt'}

for root, dirs, files in os.walk(path):
    for file in files:
        _, extension = splitext(file)
        if extension not in extensions:
            zf.write(os.path.join(root, file),
                     os.path.relpath(os.path.join(root, file),
                     os.path.join(path, os.path.pardir)))
</code></pre>
<p>If you want to combine the above features, then you can handle the logic for files and directories separately:</p>
<pre><code>from os.path import splitext

extensions = {'.png', '.txt'}
skiplist = {'.DS_Store', 'tempfile.tmp'}

for root, dirs, files in os.walk(path):
    for file in files:
        _, extension = splitext(file)
        if file not in skiplist and extension not in extensions:
            zf.write(os.path.join(root, file),
                     os.path.relpath(os.path.join(root, file),
                     os.path.join(path, os.path.pardir)))

    for directory in dirs:
        if directory not in skiplist:
            zf.write(os.path.join(root, directory),
                     os.path.relpath(os.path.join(root, directory),
                     os.path.join(path, os.path.pardir))) 
</code></pre>
<p><strong>Note:</strong> The above code snippets won't work by themselves, and you will need to weave in your current code to use these ideas.  </p>
</div>
<span class="comment-copy">This is exactly what I was looking for, thank you!</span>
<span class="comment-copy">@noob No worries, glad I could help.</span>
<span class="comment-copy">I'm however not sure I fully understand what you mean by "Another optimization is to make skiplist a list, just in case it gets very large, and you want constant time O(1) lookup instead of linear O(N) lookup from using a list.", could you expand on that please?</span>
<span class="comment-copy">@noob That was a type on my part, I've edited the answer. Do you know Big O Notation time complexity? It basically means that when you use a <code>set</code>, you can hash directly to the item you want, which is O(1). If you use a list, the underlying code has to iterate through the whole list to check if it exists. I've added a link in the answer to where these time complexities are documented. It might be worth studying Big O notation before looking at this though. Basically, anything that is O(1) is more efficient than O(N).</span>
<span class="comment-copy">@noob Yes the curly brackets is a set. You can also use <code>set()</code> to define it. Sets are <i>unordered</i>, so if you need to maintain order, then using a list is the better option, since lists are <i>ordered</i>. For this question, since you only need to do lookups to check files/extensions to skip, then using a set is the better option. But for other scenarios, that might not be the case. It really depends on what problem your solving.</span>
