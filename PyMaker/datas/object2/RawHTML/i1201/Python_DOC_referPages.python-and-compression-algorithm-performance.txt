<div class="post-text" itemprop="text">
<p>I'm interessed to this compression algorithm (check the link)</p>
<p><a href="https://github.com/bright-tools/varints" rel="nofollow noreferrer">https://github.com/bright-tools/varints</a></p>
<p>In particular the problem is that the memory overhead for bytearray objects in Python does the compression useless.
There is a solution that consider only the size of encoding and NOT the size of data structure?
For example:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; list = []
&gt;&gt;&gt; sys.getsizeof(list)
    64
</code></pre>
<p>But i would have something like "0" and not 64</p>
<p>How can i avoid the memory overhead?
Some come please?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python is not the language you want to use if you're trying to create tiny datastructures. As the README for the project you link notes, you can use byte arrays (not lists) to reduce storage overhead if you can pack a lot of data into a single byte array. But you have to deal with the fact that byte arrays are immutable; you cannot do things like add another element or change an existing one without creating a entire new byte array. And even byte arrays (like strings) come at a cost: a 64-bit CPython install -- that is, the standard python you will get with an x86 Linux install -- uses at least 33 bytes overhead for each byte array. (I say "at least" because Python has no way of measuring memory allocation overhead.) And then there is the computation cost of deserialising the byte stream into the original objects, if you need to use them for something other than a hashtable key.</p>
<p>Since the linked page produces smaller objects, I conclude that its tests must have been done on a 32-bit Python install, probably on Windows. So that's one way you can cut down on storage usage.</p>
<p>If you have Python3.3 or later (and if you don't, just install it :-) ), then you can use the <code>array</code> module, which will probably be a lot more convenient than a byte array, in part because you can make an array of the size you need. You can also modify elements in an array, which might or might not be useful. See <a href="https://docs.python.org/3/library/array.html?highlight=array#module-array" rel="nofollow noreferrer">the Python manual</a> for details. If you build an <code>array.array</code> using the <code>b</code> or <code>B</code> type modifiers, it will use only one byte per value. If you use <code>h</code> or <code>H</code>, you can store 16-bit integers (signed or unsigned), each one in two bytes. The overhead of an <code>array.array</code> is 64 bytes, just like a list, but the actual elements are much more compact.</p>
<p>Personally, I wouldn't bother with stuff like this, but I suppose it has its uses. In fact, the reference README page underestimates the storage consumption of a Python list of integers, because it doesn't take into account the size of the integers themselves, which is considerable.</p>
<p>The size of a list revealed by <code>sys.getsizeof</code> is only the size of the list itself. It does not include the objects in the list, only a references to the object (eight bytes each on a standard Linux Python install). It also includes the memory used by the list's object description, which is 64 bytes on the same standard Python install. (That's the 64 bytes shown in your test.)</p>
<p>Finally, it <em>might</em> include some extra space at the end, in order to allow appending items to the list without having to reallocate and copy the list. The number of such extra objects depends on a lot of factors, including the precise way the list was constructed, but it appears that you can reduce this particular overhead to zero by copying the list with a slice: <code>a[:]</code>.</p>
<p>In Python, integers are full-blown objects, and they use a surprising amount of space. Or maybe it is not so surprising when you consider that Python integers are bignums, so they have no artificial size limit. According to <code>getsizeof</code>, integers whose absolute value is less than 2<sup>30</sup> occupy 28 bytes, and each additional 30 bits (or part) cost another four bytes. (In fact, you could bit-pack a large vector of small integers into a single bignum, taking advantage of the fact that left- and right-shift operations are reasonably fast, and thereby shave a few more bytes off of each list. But <code>array.array</code> is almost certainly easier.)</p>
<hr/>
<p>Some experiments with <code>getsizeof</code>, for reference:</p>
<pre><code>&gt;&gt;&gt; from sys import getsizeof
&gt;&gt;&gt; # Strings occupy 48 bytes plus the length of the string plus one byte (presumably for a NUL)
&gt;&gt;&gt; getsizeof("")   # 48 + 0 + 1
49
&gt;&gt;&gt; getsizeof("a")  # 48 + 1 + 1
50
&gt;&gt;&gt; getsizeof("abcdefghijklmnopqrstuvwxyz") # 48 + 26 + 1
75
&gt;&gt;&gt; getsizeof("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") # 48 + 52 + 1
101
&gt;&gt;&gt; But that's not counted in the size of a list. All the lists are the same size:
&gt;&gt;&gt; getsizeof([""])
72
&gt;&gt;&gt; getsizeof(["a"])
72
&gt;&gt;&gt; getsizeof(["abcdefghijklmnopqrstuvwxyz"])
72
&gt;&gt;&gt; getsizeof(["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"])
72
&gt;&gt;&gt; # Same for a list containing a single number
&gt;&gt;&gt; getsizeof([0])
72
&gt;&gt;&gt; # Lists need 64 bytes plus 8 bytes per element (a pointer to the element):
&gt;&gt;&gt; getsizeof([0,1])
80
&gt;&gt;&gt; getsizeof([0,1,2])
88
&gt;&gt;&gt; getsizeof([0,1,2,3])
96
&gt;&gt;&gt; # When you append to a list, Python leaves some extra space for the next appends
&gt;&gt;&gt; a = [0,1,2,3]
&gt;&gt;&gt; getsizeof(a)
96
&gt;&gt;&gt; # As above, 64 + 4 * 8 bytes. But when we add a single element,
&gt;&gt;&gt; # we get enough room for four elements, so the next three appends
&gt;&gt;&gt; # don't require more space:
&gt;&gt;&gt; a.append(4)
&gt;&gt;&gt; getsizeof(a)
128                 
&gt;&gt;&gt; a.append(5)
&gt;&gt;&gt; getsizeof(a)
128
&gt;&gt;&gt; a.append(6)
&gt;&gt;&gt; getsizeof(a)
128
&gt;&gt;&gt; a.append(7)
&gt;&gt;&gt; getsizeof(a)
128
&gt;&gt;&gt; # When we append the 9th element, we get room for another four
&gt;&gt;&gt; a.append(8)
&gt;&gt;&gt; getsizeof(a)
192
</code></pre>
<p>You could save a few bytes by using tuples instead of lists: a tuple, like a byte array, is immutable but if you can live with not being able to modify the object, you can save 16 bytes by using a tuple instead of a list:</p>
<pre><code>&gt;&gt;&gt; getsizeof( (1,2,3) )
72
&gt;&gt;&gt; getsizeof( [1,2,3] )
88
</code></pre>
</div>
