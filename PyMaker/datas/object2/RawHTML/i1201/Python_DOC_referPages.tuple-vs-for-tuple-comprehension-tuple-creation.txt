<div class="post-text" itemprop="text">
<p>I understand I can create a tuple by these two methods:</p>
<pre><code>tuple([1, 2, 3])
(1, 2, 3)
</code></pre>
<p>I'm trying to understand what exactly is happening here:</p>
<pre><code>tuple( (x, x*x) for x in [1, 2, 3] )
</code></pre>
<p>the tuple constructor seems to want a list, but it doesn't seem like the following would produce a list</p>
<pre><code>(x, x*x) for x in [1, 2, 3]
</code></pre>
<p>Also I'm wondering why this doesn't work:</p>
<pre><code>( (x, x*x) for x in [1, 2, 3] )
</code></pre>
<p>With dictionaries it seems I can use either:</p>
<pre><code>my_dict = dict()
my_dict = {}
</code></pre>
<p>but now I'm wondering if, like tuples, there's a difference.  Is <code>():tuple()</code> a different <code>::</code> relationship than <code>{}:dict()</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's break down what's happening here. You're not wrong that the tuple constructor seems to want a list, but it would be more precise to say that the tuple constructor seems to want a list-like object. (to be specific, any iterable works)</p>
<p>This is a philosophy called as <a href="https://devopedia.org/duck-typing" rel="nofollow noreferrer">Duck Typing</a>. </p>
<p>The saying goes as follows:</p>
<blockquote>
<p>If it walks like a duck, swims like a duck, and quacks like a duck,
  then it probably is a duck.</p>
</blockquote>
<p>So then, a list works</p>
<pre><code>a = [1, 2, 3, 2]
tuple(a) #Output: (1, 2, 3, 2)
</code></pre>
<p>but so does a different iterable, such as a set</p>
<pre><code>tuple(set(a)) #Output: (1, 2, 3)
</code></pre>
<p>So, tuple does not care whether the object it receives is a list, just that it should be able to iterate and get values from the object.</p>
<p>Now, The second part of the magic comes from something called list comprehension/generator expressions. They are iterables you can create which make it easy to write 1 liners that create a list or a generator expression respectively. More on the generator later, for now, it is sufficient to see how a list comprehension works.</p>
<p>A simple example of <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a></p>
<pre><code>[a for a in range(4)] #Output: [0, 1, 2, 3]
[a*a for a in range(4)] #output: [0, 1, 4, 9]
</code></pre>
<p>We see that they produce lists. So, can we feed them to a tuple constructor? Why not!</p>
<pre><code>tuple([a for a in range(4)]) #Output: (0, 1, 2, 3)
tuple([a*a for a in range(4)]) #output: (0, 1, 4, 9)
</code></pre>
<p>Now, what about using the same expression but wrapping it in curved brackets instead?</p>
<pre><code>(a for a in range(4)) #Output: &lt;generator object &lt;genexpr&gt; at 0x000000FA4FDBE728&gt;
</code></pre>
<p>You just created a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a></p>
<p>They are essentially memory efficient on-demand iterables. (to be jargon specific, they have a yield and next , and only yield values as needed). Let's see it in action.</p>
<pre><code>my_generator = (a for a in range(4)) #generator created. 
next(my_generator) #Outputs 0
next(my_generator) #Outputs 1
next(my_generator) #outputs 2
next(my_generator) #outputs 3
next(my_generator) #Raises StopIteration Error. The generator is exhausted.
</code></pre>
<p>We can see that we receive the same values as with our list comprehension. 
So, does a tuple accept something like a generator? Well, duck typing to the rescue! Absolutely!</p>
<pre><code>tuple((a for a in range(4))) #Output: (0, 1, 2, 3)
</code></pre>
<p>Do i need the redundant parenthesis? Nope!</p>
<pre><code>tuple(a for a in range(4)) #Output: (0, 1, 2, 3)
tuple(a*a for a in range(4)) #Output: (0, 1, 4, 9)
</code></pre>
<p>Now, what does this produce? <code>(x, x*x) for x in [1, 2, 3]</code></p>
<p>Well, it is an expression, but let's get an idea of how it would look in a list comprehension instead</p>
<pre><code>[(x, x*x) for x in [1, 2, 3]] #Output: [(1, 1), (2, 4), (3, 9)]
</code></pre>
<p>Ah, its a list of tuples? Can a generator do the same?</p>
<pre><code>my_generator = ((x, x*x) for x in [1, 2, 3]) #&lt;generator object &lt;genexpr&gt; at 0x000000FA4FD2DCA8&gt;
next(my_generator) #Output: (1, 1)
next(my_generator) #Output: (2, 4)
next(my_generator) #Output: (3, 9)
next(my_generator) #Raises StopIteration
</code></pre>
<p>Yep, looks good. So its a generator, but its an iterable. Behaves like a duck anyways, doesn't it? So, the tuple constructor should work just fine!</p>
<pre><code>tuple((x, x*x) for x in [1, 2, 3]) #Output: ((1, 1), (2, 4), (3, 9))
</code></pre>
<p>So, that wraps up everything. The parenthesis do not imply a tuple all the time, () are not reserved for tuples. We see here that they can be used for generator expressions as well! Similarly, the {} do not have to be tied to dictionaries always, something similar to list comprehension actually exists for dictionaries too! (Known as <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">dict comprehension</a>) </p>
<p>I highly recommend going through the links for a more thorough explanation of the individual pieces that are working together here. Hope this helps!</p>
</div>
<span class="comment-copy">check <a href="https://stackoverflow.com/questions/16940293/why-is-there-no-tuple-comprehension-in-python" title="why is there no tuple comprehension in python">stackoverflow.com/questions/16940293/â€¦</a> for some info</span>
<span class="comment-copy">You got it wrong, Parenthesis have <b>nothing</b> to do with tuples. It's the <b>commas</b> that create tuples. <code>1,2,3</code> is the same as <code>(1,2,3)</code>. the outer parenthesis are just for grouping. The only case where you need parenthesis is the empty tuple <code>()</code>. The <code>tuple</code> constructor takes any iterable not just lists.</span>
<span class="comment-copy">And you are feeding a generator expression which is iterable to the tuple() constructor. if you <code>print( ((x, x*x) for x in [1, 2, 3]) )</code> - you'll get somiething along <code>&lt;generator object &lt;genexpr&gt; at 0x7f847eccc0f8&gt;</code> - putting this as iterable into <code>tuple(iterable)</code>creates the tuple by iterating the generator</span>
<span class="comment-copy">There's no tuple comprehension, ((x, x*x) for x in [1, 2, 3]) this code is a generator comprehension. generator is a iterable object, i.e. range(5) is a generator.</span>
<span class="comment-copy">Just to add to @Bakuriu comment. In a empty tuple the parentheses are the essential elements however this is not the case for one-element tuples and multiple-element tuples which can be defined like <code>1,</code> and <code>1,2,3</code>.</span>
