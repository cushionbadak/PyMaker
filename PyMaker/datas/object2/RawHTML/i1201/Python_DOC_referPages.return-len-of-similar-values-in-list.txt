<div class="post-text" itemprop="text">
<p>I have two lists which I want to return len() of similar values in a list.</p>
<pre><code>A = [1,1,2,2]
B = [3,3,3,3,7,7,7]
</code></pre>
<p>In first list there are twice number 1 and 2, I want to use len of number values in the list, to see how many times number 1 repeats in first list. in that case will be 2 and 2 for number 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>Quick one single line solution that doesn't use collections counter. </p>
<pre><code>A=[3,4,4,4,3,5,6,8,4,3]
duplicates=dict(set((x,A.count(x)) for x in filter(lambda rec : A.count(rec)&gt;1,A)))
output:
{3: 3, 4: 4} 
</code></pre>
<p>This solution doesn't account for "stretches" however</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a job for <code>collections.Counter</code></p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; Counter([1,1,2,2])
Counter({1: 2, 2: 2})
&gt;&gt;&gt; Counter([3,3,3,3,7,7,7])
Counter({3: 4, 7: 3})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply iterate over your numbers and count identical ones - or use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a>:</p>
<pre><code>def count_em(l):
    """Returns a list of lenghts of consecutive equal numbers as list. 
    Example: [1,2,3,4,4,4,3,3] ==&gt; [1,1,1,3,2]"""
    if not isinstance(l,list):
        return None

    def count():
        """Counts equal elements, yields each count"""
        # set the first elem as current
        curr = [l[0]]

        # for the rest of elements
        for elem in l[1:]:
            if elem == curr[-1]:
                # append as long as the element is same as last one in curr 
                curr.append(elem)
            else:
                # yield the number
                yield len(curr)
                # reset curr to count the new ones
                curr = [elem]
        # yield last group
        yield len(curr)

    # get all yields and return them as list
    return list(count())


def using_groupby(l):
    """Uses itertools.groupby and a list comp to get the lenghts."""
    from itertools import groupby
    grp = groupby(l) # this groups by the elems themselfs
    # count the grouped items and return as list
    return [ sum(1 for _ in items) for g,items in grp] 
</code></pre>
<p>Test:            </p>
<pre><code>A = [1,1,2,2]
B = [3,3,3,3,7,7,7]
C = [1,1,2,2,2,1,1,1,1,1,6,6]

for e in [A,B,C]:
    print(count_em(e),  using_groupby(e))
</code></pre>
<p>Output:</p>
<pre><code># count_em     using_groupby    Input
[2, 2]         [2, 2]         # [1,1,2,2]
[4, 3]         [4, 3]         # [3,3,3,3,7,7,7]
[2, 3, 5, 2]   [2, 3, 5, 2]   # [1,1,2,2,2,1,1,1,1,1,6,6]
</code></pre>
</div>
<span class="comment-copy">What have you tried, and what exactly is the problem with it?</span>
<span class="comment-copy">I have tried for loop and len function, which does not work.</span>
<span class="comment-copy">What <i>exactly</i> have you tried? Show the code, not vague references to concepts you used in the code.</span>
<span class="comment-copy">I understand I would update my code</span>
<span class="comment-copy">For <code>B</code>, would you want a result like <code>[4,3]</code>, since there are four 3s and three 7s?</span>
<span class="comment-copy">Your answer is short and simple :) Thanks</span>
<span class="comment-copy">I just timed it and <code>collections.Counter</code> is over 100% faster @100,000 iterations each.</span>
<span class="comment-copy">@nicholishen collections.counter has its time and place, and is clearly very effective for this situation. I edited post as it might have been misleading for this particular post. There are times when collections.counter is very slow and a creative solution could lead to better efficiency. <a href="https://stackoverflow.com/questions/43485195/python-collections-counter-efficiency">As seen in last answer here</a> I wanted to allude that there are times it is not the most effective solution, but might've overstepped the boundary of this post in doing so</span>
<span class="comment-copy">@LarrBear Ironically, the reason your solution is slower than the <code>Counter</code> solution is the same reason that the <code>Counter</code> solution you linked to is slow.  Your solution is roughly quadratic, iterating over <code>A</code> multiple times for each element in <code>A</code>.  By contrast, building a <code>Counter</code> only iterates over <code>A</code> once.  That single iteration is more expensive than any one of the other iterations, but it's markedly more efficient than all of them taken together.</span>
<span class="comment-copy">only if you do not care about "stretches":  [1,1,1,2,2,2,3,3,2,2,2,2,2,2] will give only 1 number for 2s</span>
<span class="comment-copy">Yeah, that's the point.</span>
<span class="comment-copy">Thanks.. Quick reply, but it gives back as dic. So I need  one more for-loop key and value to sort for exampel number 4 for 3 or 3 for 7.</span>
<span class="comment-copy">No just access the dict using the key directly. <code>&gt;&gt;&gt; number_of_threes = Counter([3,3,3,3,7,7,7])[3]</code> ... <code>4</code></span>
<span class="comment-copy">Thanks for your professional answer. I appreciate and no doubt it would be useful.</span>
