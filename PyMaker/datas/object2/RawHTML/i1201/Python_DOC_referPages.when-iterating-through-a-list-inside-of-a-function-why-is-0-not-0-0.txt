<div class="post-text" itemprop="text">
<p>I am trying to solve a problem in which I have to remove the zeroes (both <code>0</code> and <code>0.0</code>) from a list and add them to the end of the list (the zero that is appended can be a <code>0</code>, doesn't have to be <code>0.0</code>). But the catch is that I must not remove <code>False</code>. I thought I finally figured out my problem by using <code>is</code> instead of <code>==</code> but for some reason it's not working:</p>
<pre><code>arr = [9,0.0,0,9,1,2,0,1,0,1,0.0,3,0,1,9,0,0,0,0,9]
def move_zeros(array):
    temp = array.copy()
    j = 0
    for p, i in enumerate(array):
        if i is 0 or i is 0.0:
            del temp[p - j]
            j += 1
            temp.append(0)
    return temp

print(move_zeros(arr))
</code></pre>
<p>I've tried putting parentheses at the <code>if</code> statement but the result is the same. It removes all the <code>0</code> but for some reason it won't remove <code>0.0</code>. Result:</p>
<pre><code>[9, 0.0, 9, 1, 2, 1, 1, 0.0, 3, 1, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<p>I rewrote the function but outside of the function and for some reason it works:</p>
<pre><code>array = [1, 0, 2, False, 0.0, 4]
for p, i in enumerate(array):
    if i is 0 or i is 0.0:
        del temp[p - j]
        j += 1
        temp.append(0)
</code></pre>
<p>And here the result is how I would expect it:</p>
<pre><code>[1, 2, False, 4, 0, 0]
</code></pre>
<p>Why is the floating point zero being removed when executed outside of the function, but when the function <code>move_zeros</code> is called, the floating points are not recognized in the <code>if</code> statement?</p>
</div>
<div class="post-text" itemprop="text">
<p>You only handle <code>floats</code> and <code>ints</code> - so you can construct a new list from your input if the value is not 0:</p>
<pre><code>arr = [9,0.0,0,9,1,2,0,1,0,1,0.0,3,0,1,9,0,0,0,0,9]

def move_zeros(array):
    len_arr = len(array)
    return ([ x for x in array if x != 0.0]+[0]*len_arr)[:len_arr]

# equivalent non-listcomprehension but simple for loop
def m_z(arr):
    k = []
    tmp = []
    for e in arr:
        if e/1.0 != 0.0:
            k.append(e)
        else:
            tmp.append(0)
    return k+tmp

    print(move_zeros(arr))
</code></pre>
<p>Output:</p>
<pre><code>[9, 9, 1, 2, 1, 1, 3, 1, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<p>If <code>x</code> is an integer  only <code>0</code> and <code>-0</code> can lead to <code>0.0</code>  - if <code>x</code> is a float, only <code>0.0</code> and <code>-0.0</code> can lead to 0.0 - simply do not put them into the output. <code>.copy()</code> is not needed because the list comprehension copies already for you.</p>
<p>The check for intergers and <code>is</code> works because python caches integers from -5 to 256 or so - they all get the same <code>id()</code> and hence <code>is</code> "seems" to work. </p>
<p>Only use <code>is</code> for <code>None</code> checks or if you know what you do, never for numbers.</p>
<p>If you want to leave non (<code>Ã¬nt,float</code>) untouched you can check for that too:</p>
<pre><code>arr = [9,0.0,0,False,9,1,2,0,1,0,1,0.0,3,0,1,9,0,0,0,0,9]

def move_zeros(array):
    len_arr = len(array)
    return ([ x for x in array if type(x) not in {int,float} or 
             x != 0.0]+[0]*len_arr)[:len_arr]

# [9, False, 9, 1, 2, 1, 1, 3, 1, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<hr/>
<p>Read more:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/15171695/whats-with-the-integer-cache-inside-python">What's with the Integer Cache inside Python?</a></li>
<li><a href="https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python">Is there a difference between `==` and `is` in Python?</a></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">thruthyness: why <code>False is 0</code> - Part 1</a></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#boolean-values" rel="nofollow noreferrer">why <code>False is 0</code> - Part 2</a></li>
</ul>
<hr/>
<p>Small sanity check:</p>
<pre><code>k = 365
i = 365 // 5 * 5  # if you do i = 365 only, they are ==/is True, this way: they are not

for elem in [0,False,k]:
    for olem in [0,False,i]:     
        print(f"{str(elem):&gt;8} is {str(olem):&lt;10}:   {str(elem is olem):&lt;10} ")
        print(f"{str(elem):&gt;8} == {str(olem):&lt;10}:   {str(elem == olem):&lt;10} ")
</code></pre>
<p>Output:</p>
<pre><code>       0 is 0         :   True       
       0 == 0         :   True       
       0 is False     :   False      
       0 == False     :   True       
       0 is 365       :   False      
       0 == 365       :   False      
   False is 0         :   False      
   False == 0         :   True       
   False is False     :   True       
   False == False     :   True       
   False is 365       :   False      
   False == 365       :   False      
     365 is 0         :   False      
     365 == 0         :   False      
     365 is False     :   False      
     365 == False     :   False      
     365 is 365       :   False      # k is i
     365 == 365       :   True       # k == i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use <code>==</code>, not <code>is</code>. <code>is</code> is for comparing identity (two "things" occupying the same space in memory, essentially), <code>==</code> is for equality (do two things have the same defining properties). Furthermore, with floats it is often useful to check whether things are "close enough", e.g. 
<code>is_equal = a-b &lt; 0.00001</code></p>
</div>
<span class="comment-copy">Thank you for the solution! But could you point out in the question why is the <code>if</code> statement inside of the function not recognizing <code>0.0</code> and outside of it (in the second example) it is recognizing it.</span>
<span class="comment-copy">What's the purpose of the division by <code>1.0</code>?</span>
<span class="comment-copy">But why bother? <code>0</code> is already equal to <code>0.0</code>.</span>
<span class="comment-copy">Yes, of course. But why bother dividing by <code>1.0</code> at all? It makes no difference to the returned result, and just makes the code more confusing. Your solution would work just fine without the divisions. That is, <code>x / 1.0 != 0.0</code> could be replaced with <code>x != 0.0</code> with no change in behaviour.</span>
<span class="comment-copy">@MarkDickinson ermm .... yes ... edited</span>
<span class="comment-copy">Also, in CPython, at least, small ints are cached, floats are not, which explains why <code>0 is 0</code> can be (but isn't required to be) true.</span>
<span class="comment-copy">OP states they used <code>is</code> to avoid catching <code>False</code> in the function, <code>False==0.0</code> evaluates to True</span>
<span class="comment-copy">I understand I can put a check before the <code>if</code> statement that checks if the element is <code>False</code> and do what you said with <code>==</code>. The thing I don't understand is the behavour inside and outside the function.</span>
