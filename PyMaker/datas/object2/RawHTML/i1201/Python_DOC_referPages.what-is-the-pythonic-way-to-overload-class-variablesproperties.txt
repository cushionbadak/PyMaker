<div class="post-text" itemprop="text">
<p><strong>Hello!</strong></p>
<p>I need each child class to has own set of constants. I've found a "proper" way with properties and overloading setter methods, but:</p>
<ol>
<li>I need to define constructor in child classes (which I don't need) and assign values in constructor;</li>
<li>Every instance of class will have copy of this constants in memory (senseless resource consumption);</li>
<li>It looks weird when you define setter, getter and property at all just to use it as constant.</li>
</ol>
<p>I've done something like this:</p>
<pre><code>class BaseClass:
    def get_a(self):
        raise NotImplementedError("Oooops")

    def get_b(self):
        raise NotImplementedError("Oooops")

class FirstClass(BaseClass):
    def get_a(self):
        return "a"

    def get_b(self):
        return "b"

class SecondClass(BaseClass)
    def get_a(self):
        return "A"

    def get_b(self):
        return "B"

class SomeClass:
    def some_method(self, class_param):
        return "{}-{}".format(class_param.get_a, class_param.get_b)
</code></pre>
<p>This method also doesn't solve problems of method with properties (except last), just more compact. There's other way, which I find not good:</p>
<pre><code>class BaseClass:
    pass

class FirstClass(BaseClass):
    A_CONST = "a"
    B_CONST = "b"

class SecondClass(BaseClass)
    A_CONST = "A"
    B_CONST = "B"

class SomeClass:
    def some_method(self, class_param):
        return "{}-{}".format(class_param.A_CONST, class_param.B_CONST)
</code></pre>
<p>In fact, it solve all problems and pretty compact, BUT it violates rule of inheritance (<em>isn't it?</em>).</p>
<p><strong>Question</strong>:
What is the proper way to do this?</p>
<p><em>P.S. Provided code is simplified example, base class contains methods which I use in child class, please don't write me that base class is useless here.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>If you want your base class to indicate that it needs to be subclassed with certain attributes, you can make it an <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">abstract base class</a>.</p>
<pre><code>from abc import ABC, abstractmethod

class Base(ABC):
    @property
    @abstractmethod
    def a(self):
        raise NotImplementedError
    @property
    @abstractmethod
    def b(self):
        raise NotImplementedError
</code></pre>
<p>You will then not be allowed to instantiate <code>Base</code> or its subclasses unless they override the abstract methods.  You can do either</p>
<pre><code>class First(Base):
    a = 1
    b = 2
</code></pre>
<p>to assign class attributes with those names, or </p>
<pre><code>class Second(Base):
    @Base.a.getter
    def a(self):
        return 3
    @Base.b.getter
    def b(self):
        return 4
</code></pre>
<p>The benefit of the second approach is that it will raise an error if you try to assign to the property </p>
<pre><code>Second().a = 5  # AttributeError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>your second version looks fine to meâ€¦  each language has their own conventions around what a "class" or "object" means, and this looks reasonably "Pythonic"</p>
<p>one minor comment about the first version, is that Python doesn't care about "overloading", you don't need to include:</p>
<pre><code>class BaseClass:
    def get_a(self):
        raise NotImplementedError("Oooops")
</code></pre>
<p>at all, i.e. it's fine to have:</p>
<pre><code>class BaseClass:
    pass
</code></pre>
<p>as well in your first version.</p>
<p>another potentially useful tool here is the <code>property</code> decorator, e.g:</p>
<pre><code>class FirstClass(BaseClass):
    @property
    def a(self):
        return "a"

print(FirstClass().a)
</code></pre>
<p>would output "<code>a</code>"</p>
</div>
<div class="post-text" itemprop="text">
<p>If the <code>key_name : [A_CONST, B_CONST]</code> remains same for <code>child</code> classes, <code>super()</code> will take care of all your concerns (<code>1., 2., 3.</code>). </p>
<p>A 'pythonic' solution would include, to remove duplication's, of any, <code>setter</code> and <code>getter</code> in <code>child</code> classes and let <code>BaseClass()</code> handle these common-tasks.</p>
<pre><code>class BaseClass(object):
    def __init__(self, a, b):
        self._a_const = a
        self._b_const = b
    @property
    def A_CONST(self):
      return self._a_const
    @property
    def B_CONST(self):
      return self._b_const

class FirstClass(BaseClass):
    def __init__(self, _aconst, _bconst):
        # Let Base class object hold my constants but FirstClass Constructor
        # is setting the value. Look SecondClass
        super(FirstClass, self).__init__(_aconst, _bconst)

class SecondClass(BaseClass):
    def __init__(self, _aconst, _bconst):
        # Magic happens here
        super(SecondClass, self).__init__(_aconst, _bconst)

class SomeClass():
    def some_method(self, class_param):
        return "{}-{}".format(class_param.A_CONST, class_param.B_CONST)

firstobj  = FirstClass("a", "b")
secondobj = SecondClass("A", "B")

print(SomeClass().some_method(firstobj))
print(SomeClass().some_method(secondobj))
</code></pre>
</div>
<span class="comment-copy">Exactly what is the rule you think you are violating?</span>
<span class="comment-copy">@khelwood , I'm not an expert in Python, but, in common, I'll provide instances of different child classes as parameter in method, which will work with BaseClass description. Or it's ok to do like this in dynamically typed languages?</span>
<span class="comment-copy">+1 for pointing out ABCs, I've not come across the need for them yet, but they look like a potentially useful tool!</span>
<span class="comment-copy">@PatrickHaugh, Will every instance of class handle own copy of constants in memory by using your method?</span>
<span class="comment-copy">In both scenarios, the constants are handled at the class level. For <code>First</code>, they are attributes of the object <code>First</code>.  When you try to access <code>First().a</code>, it can't find the attribute in the <code>__dict__</code> of that object, so it checks the <code>__dict__</code> of the parent class, where it finds <code>a</code>.  For <code>Second</code>, the constants are stored in the descriptors attached to the <code>Second</code> class.</span>
<span class="comment-copy">@PatrickHaugh, thanks. It seems like best solution!</span>
<span class="comment-copy">could you please explain me what this "magic" construction do <code>super(FirstClass, self).__init__(_aconst, _bconst)</code> ?</span>
<span class="comment-copy">@OlvinRoght The <code>super()</code> function does is to create the <code>BaseClass</code> objects from the  child classes <code>FirstClass</code> &amp; <code>SecondClass</code>.  Take a look at experts on this <a href="https://www.youtube.com/watch?v=EiOglTERPEo" rel="nofollow noreferrer">Super Considered Super</a></span>
