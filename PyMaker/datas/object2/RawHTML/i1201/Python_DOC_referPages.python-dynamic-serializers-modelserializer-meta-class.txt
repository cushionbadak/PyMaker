<div class="post-text" itemprop="text">
<p>I would like to create and instance this way.</p>
<pre><code>from app.controller.Serializer import Serializer
from app.models import Stocks,Stocks2

stocks = Stocks.objects.all()
stocks2 = Stocks2.objects.all()

churchserzer = Serializer(Stocks, ('field1','field2'),stocks, many=True)
churchserzer2 = Serializer(Stocks2, ('field1','field2'),stocks2, many=True)
</code></pre>
<p>But Im confused on how should I populate the 1st and 2nd Serializer params values to its Meta class variables before creating an instance of Serializer.
Then call the parent class contructor method.
Im thinkin of implementing Serializer class this this way, but I dont know how to set Meta Class variables value from <strong>init</strong> .</p>
<pre><code>class Serializer(serializers.ModelSerializer):

    def __init__(self, model,fields, objects, **kwargs):
       self.model = model
       self.fields = fields

       # kwargs ( many=True )
       super().__init__(objects,kwargs)

    class Meta:
       model = self.model     
       fields = self.fields
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer">type</a> to dynamically instantiate a class in python.</p>
<p>But I'm not sure i would recommend it, as I've tried to do the same and the result where really underwhelming. I guess it depends on your specific needs.</p>
<p>However, It's a good exercise to learn how to use the type builtin.</p>
<p>Here's an example:</p>
<pre><code>from rest_framework import serializers
from track.models import Track

Meta = type('Meta', (object,), dict(model=Track, fields=('band', 'link')))
TrackSerializer = type('TrackSerializer', (serializers.ModelSerializer,), dict(Meta=Meta))


In [2]: TrackSerializer()
Out[2]:
Serializer():
    band = PrimaryKeyRelatedField(queryset=Band.objects.all())
    link = CharField(max_length=511)
</code></pre>
</div>
<span class="comment-copy">What do you want to base the inclusion or exclusion of fields on?</span>
<span class="comment-copy">@saad I have updated my question.</span>
<span class="comment-copy">I have updated my question to make it clear a little bit.</span>
<span class="comment-copy">Thanks @Taek, I might get an idea from you code. Im waiting.</span>
<span class="comment-copy">You can pretty much use <code>self.Meta = type(...)</code> in your <code>__init__</code> method, it should do the trick.</span>
<span class="comment-copy">I have updated my serializer this way..   class Serializer:      def __init__(self, model, fields, objects, **kwargs):         Meta = type('Meta', (object,), dict(model=model, fields=fields))         modelserializer = type('Serializer', (serializers.ModelSerializer,), dict(Meta=Meta))         self.modelserializer = modelserializer(objects, kwargs)      def getData(self):         return self.modelserializer.data;</span>
<span class="comment-copy">But Im getting an error like this  When a serializer is passed a <code>data</code> keyword argument you must call <code>.is_valid()</code> before attempting to access the serialized <code>.data</code> representation. You should either call <code>.is_valid()</code> first, or access <code>.initial_data</code> instead.</span>
