<div class="post-text" itemprop="text">
<p>I have the following code which I'm using to infer the field separator and line terminator in a csv file:</p>
<pre><code>first_line = b'132605,1\r\n'
dialect = csv.Sniffer().sniff(first_line)
</code></pre>
<p>From the above, I'd expect the csv Sniffer to be able to infer the separator is <code>,</code> and the line-terminator is <code>\r\n</code>. However it returns the following error:</p>
<blockquote>
<p>TypeError: cannot use a string pattern on a bytes-like object</p>
</blockquote>
<p>What would be the best way to fix this?</p>
<p>Note, the reason I'm opening it in <code>b</code> mode is so that I can see all characters, for example:</p>
<pre><code>&gt;&gt;&gt; open('10_no_headers.csv','r+b').read()[:10]
b'132605,1\r\n'

&gt;&gt;&gt; open('10_no_headers.csv','r').read()[:10]
'132605,1\n1' # doesn't show the \r
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Open in 'r' mode and supply <code>newline=''</code>:</p>
<pre><code>import csv

with open('foo.txt', 'w') as f:
    f.write('132605,1\r\n')

with open('foo.txt', 'r') as f:
    print(repr(next(f)))

with open('foo.txt', 'rb') as f:
    print(repr(next(f)))

with open('foo.txt', 'r', newline='') as f:
    line = next(f)
    dialect = csv.Sniffer().sniff(line)
    print(repr(line))
    print ('FIELED:', repr(dialect.delimiter), 'LINE:', repr(dialect.lineterminator))
</code></pre>
<p>output</p>
<pre><code>'132605,1\n'
b'132605,1\r\n'
'132605,1\r\n'
FIELED: ',' LINE: '\r\n'
</code></pre>
<p><a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">from the docs</a>:</p>
<blockquote>
<p>newline controls how universal newlines mode works (it only applies to text mode). It can be None, '', '\n', '\r', and '\r\n'. It works as follows:</p>
<ul>
<li>When reading input from the stream, if newline is None, universal newlines mode is enabled. Lines in the input can end in '\n', '\r', or '\r\n', and these are translated into '\n' before being returned to the caller. <strong>If it is '', universal newlines mode is enabled, but line endings are returned to the caller untranslated.</strong> If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</li>
<li>When writing output to the stream, if newline is None, any '\n' characters written are translated to the system default line separator, os.linesep. If newline is '' or '\n', no translation takes place. If newline is any of the other legal values, any '\n' characters written are translated to the given string.</li>
</ul>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>One possible option would be to decode it before passing it to the <code>Sniffer</code>. For example:</p>
<pre><code>import csv

first_line = b'132605,1\r\n'
dialect = csv.Sniffer().sniff(first_line.decode('utf-8'))

print ('FIELED:', repr(dialect.delimiter), 'LINE:', repr(dialect.lineterminator))
FIELED: ',' LINE: '\r\n'
</code></pre>
</div>
<span class="comment-copy">it looks like you open the file in 'rb' mode, why?</span>
<span class="comment-copy">@buran modified question above.</span>
<span class="comment-copy">you can open in 'r' mode and supply <code>newline=''</code>. Check <a href="https://pythonconquerstheuniverse.wordpress.com/2011/05/08/newline-conversion-in-python-3/" rel="nofollow noreferrer">pythonconquerstheuniverse.wordpress.com/2011/05/08/â€¦</a></span>
<span class="comment-copy">yes, that's exactly what I was looking for. Thank you!</span>
