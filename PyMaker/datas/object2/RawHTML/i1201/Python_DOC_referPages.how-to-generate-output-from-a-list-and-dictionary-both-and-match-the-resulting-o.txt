<div class="post-text" itemprop="text">
<p>This is sort of an assignment or 'homework' problem as you people say and I clarify it in the beginning only. I am new to Python and I really get confused with this kind of problems.</p>
<p>The problem stated is :
Care hospital wants to know the medical speciality visited by the maximum number of patients. Assume that the patient id of the patient along with the medical speciality visited by the patient is stored in a list. The details of the medical specialities are stored in a dictionary as follows:
{
"P":"Pediatrics",
"O":"Orthopedics",
"E":"ENT
} </p>
<p>Write a function to find the medical speciality visited by the maximum number of patients and return the name of the speciality.</p>
<p>Code I attempted:</p>
<pre><code>def max_visited_speciality(patient_medical_speciality_list,medical_speciality):
    speciality_list=[]
    for words in patient_medical_speciality_list:
        if words in medical_speciality:
                speciality_list.append(words)
                speciality=max(speciality_list)
                return speciality

#provide different values in the list and test your program
patient_medical_speciality_list=[301,'P',302, 'P' ,305, 'P' ,401, 'E' ,656, 'E']
medical_speciality={"P":"Pediatrics","O":"Orthopedics","E":"ENT"}
speciality = max_visited_speciality(patient_medical_speciality_list,medical_speciality)
print(speciality)
</code></pre>
<p>Sample Input  :   [101,P,102,O,302,P,305,P]</p>
<p>Expected Output : Pediatrics</p>
<p>Output I am getting : P</p>
</div>
<div class="post-text" itemprop="text">
<p>This should do it:</p>
<pre><code>def max_visited_speciality(patient_medical_speciality_list, medical_speciality):

    # count each speciality patients
    counts = {}
    for _, speciality in zip(patient_medical_speciality_list[::2], patient_medical_speciality_list[1::2]):
        counts[speciality] = counts.get(speciality, 0) + 1

    # get most visited speciality by count of it's patients
    most_visited_speciality = max(medical_speciality, key=lambda e: counts.get(e, 0))

    # return value of most visited speciality
    return medical_speciality[most_visited_speciality]


# provide different values in the list and test your program
patient_medical_speciality_list = [301, 'P', 302, 'P', 305, 'P', 401, 'E', 656, 'E']
medical_speciality = {"P": "Pediatrics", "O": "Orthopedics", "E": "ENT"}
speciality = max_visited_speciality(patient_medical_speciality_list, medical_speciality)
print(speciality)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>Pediatrics
</code></pre>
<p>First you need to count each patient by speciality:</p>
<pre><code># count each speciality patients
    counts = {}
    for _, speciality in zip(patient_medical_speciality_list[::2], patient_medical_speciality_list[1::2]):
        counts[speciality] = counts.get(speciality, 0) + 1
</code></pre>
<p>After that <code>counts = {'E': 2, 'P': 3}</code>, because there are 3 patients that visited 'P' and 2 that visited 'E'. Then use those values as keys in max:</p>
<pre><code>most_visited_speciality = max(medical_speciality, key=lambda e: counts.get(e, 0))
</code></pre>
<p>This returns <code>'P'</code> the most visited speciality, then return the value of <code>'P'</code> in the <code>medical_speciality</code> dictionary,</p>
<pre><code>return medical_speciality[most_visited_speciality]
</code></pre>
<p>in this case: <code>'Pediatrics'</code>.</p>
<p><strong>Further</strong></p>
<ol>
<li>The documentation to <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow noreferrer">max</a>.</li>
<li>The documentation on the <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer">get</a> method of dict.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If you're restricted with requirement <em>"keep patient id of the patient along with the medical speciality visited by the patient is stored in a <strong>list</strong>"</em>, use the following optimized and unified approach:</p>
<pre><code>from collections import Counter


class MedicalSpecialityError(Exception):
    pass


medical_speciality_map = {"P": "Pediatrics", "O": "Orthopedics", "E": "ENT"}
patient_medical_speciality_list = [301, 'P', 302, 'P', 305, 'P', 401, 'E', 656, 'E']


def max_visited_speciality(patient_medical_speciality_list: list):
    counts = Counter(s for s in patient_medical_speciality_list if str(s).isalpha())
    try:
        med_spec = medical_speciality_map[counts.most_common()[0][0]]
    except IndexError:
        raise MedicalSpecialityError('Bad "patient_medical_speciality_list"')
    except KeyError:
        raise MedicalSpecialityError('Unknown medical speciality key')

    return med_spec


print(max_visited_speciality(patient_medical_speciality_list))
</code></pre>
<p>The output:</p>
<pre><code>Pediatrics
</code></pre>
<hr/>
<p>P.S. Make a habit of "good practices".</p>
</div>
<div class="post-text" itemprop="text">
<p>You're almost there.</p>
<p>in your <code>for</code> loop, <code>words</code> is holding the string <code>P</code>, or <code>E</code>. Now you just need to use that to call the key in your dictionary:</p>
<p>example: when <code>word</code> is 'P', to get the value, you'd use <code>medical_speciality['P']</code> to get the value <code>Pediatrics</code>. So we'll just include that in your function.</p>
<p>Next, <code>max</code> doesn't work as you're thinking here. You'll need a way to count up the number of times a 'P' or 'E' show up, then you really just want that max value.</p>
<p>I would also move your part of</p>
<pre><code>speciality=max(speciality_list)
return speciality`
</code></pre>
<p>outside the <code>for</code> loop, as you want the max of that full list, where as it's currently doing <code>max</code> and <code>return</code> after each iteration, which isn't needed.</p>
<pre><code>def max_visited_speciality(patient_medical_speciality_list,medical_speciality):
    speciality_list=[]
    for words in patient_medical_speciality_list:
        if words in medical_speciality:
                speciality_list.append(words)

    counts = dict(map(lambda x  : (x , speciality_list.count(x)) , speciality_list))
    most_visited_speciality = max(counts, key=lambda e: counts.get(e, 0))
    return medical_speciality[most_visited_speciality]

#provide different values in the list and test your program
patient_medical_speciality_list=[301,'P',302, 'P' ,305, 'P' ,401, 'E' ,656, 'E']
medical_speciality={"P":"Pediatrics","O":"Orthopedics","E":"ENT"}
speciality = max_visited_speciality(patient_medical_speciality_list,medical_speciality)
print(speciality)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt;&gt;&gt; print(speciality)
&gt;&gt;&gt; Pediatrics
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def max_visited_speciality(patient_medical_speciality_list,medical_speciality):
    # write your logic here
    a=len(patient_medical_speciality_list)
    b=patient_medical_speciality_list[1:a:2]
    c=[]
    d=[]
    for key in medical_speciality:
        c.append(key)
    #print(c)
    for i in c:
        d.append(b.count(i))
    #print(d)
    x=d.index(max(d))
    #print(x)
    return medical_speciality[c[x]]



#return speciality


patient_medical_speciality_list=[301,'P',302, 'P' ,305, 'P' ,401, 'E' ,656, 'E']
medical_speciality={"P":"Pediatrics","O":"Orthopedics","E":"ENT"}
speciality=max_visited_speciality(patient_medical_speciality_list,medical_speciality)
print(speciality)
</code></pre>
</div>
<span class="comment-copy">you should better use dictionary</span>
<span class="comment-copy">Thanks for the answer. It cleared my confusions.</span>
<span class="comment-copy">This answer was good but the system I am doing my assignments in doesn't permit to use packages by importing them. Otherwise, your answer was really good.</span>
<span class="comment-copy">@ArijeetAcharyya, <code>collections</code> is a builtin python library. If you can't import it, make sure that you have a proper python installation. There's nothing extraordinary in my approach</span>
<span class="comment-copy">There's nothing wrong with your approach, it's totally correct. It is actually the restrictions on doing this particular assignment in the specified system which does not permit the use of other pyhton built-in packages.</span>
<span class="comment-copy">I already ran your code in the compiler in my computer and it's working fine.</span>
<span class="comment-copy">Thanks for explaining it in a really nice way and highlighting where I need to do the corrections.</span>
<span class="comment-copy">Please, add some comments, explanation to your code, not just clear code snippet. Thank you!</span>
