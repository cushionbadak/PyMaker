<div class="post-text" itemprop="text">
<p>I was wondering if it's possible to create an SQLite database where I can <code>select</code> rows by <code>rowid</code> with O(1).</p>
<p>I started using sqlite database in one of my projects and discovered that <code>select</code>ing rows from bigger databased takes longer than <code>select</code>ing rows from smaller databases. I started searching online and stumbled upon  <a href="https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-indexes-indexes-c4e175f3c346" rel="nofollow noreferrer">this article</a>. Apparently, when <code>select</code>ing by <code>rowid</code>, instead of going straight to the <code>rowid</code>, SQLite performs a binary search to get to the requested <code>rowid</code>. This is a very logical solution, because we can delete rows from the database and in this case, going straight to the <code>rowid</code> won't work.
But in my case - I have an "immutable" database, after creating the database I'm not changing it; Thus, all the <code>rowid</code> are present and in the correct order.</p>
<p>So I was wandering if it's possible to either create a special database or use a specific query command which tells SQLite to select by accessing the <code>rowid</code> without any binary search.</p>
<p>If there are other alternatives to SQLite that can perform better for my case please inform me about them (though, for in my project I can't load the db into memory and the access to different db's simultaneously should be instantaneous)</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you do not need the full power of SQLite, you could a simple hashing algorithm with the <code>dbm</code> module. It uses hashing and could perform better than an ISAM index. But you will lose ordering (among other features like SQL...)</p>
</div>
<div class="post-text" itemprop="text">
<p>I ended up using <a href="https://docs.python.org/3/library/mmap.html" rel="nofollow noreferrer">mmap</a>. Because I had millions of lines of the same length I just saved those lines to a binary file with mmap. Then to access k line I simply asked mmap to read from <code>k * (length_of_line)</code> point. </p>
<p>I used the snippet code from the answer <a href="https://stackoverflow.com/questions/4999340/python-random-access-file">here</a> to test the solution quickly, though I believe it can be optimized further than this simple code.</p>
</div>
<span class="comment-copy">Have you tried a WITHOUT ROWID table? - <a href="https://www.sqlite.org/withoutrowid.html" rel="nofollow noreferrer">sqlite.org/withoutrowid.html</a></span>
<span class="comment-copy">"I have an "immutable" database, after creating the database I'm not changing it; "... Yes but how should the database (SQLite) know that and optimize that.. It's not only SQLite, MySQL also uses more <a href="https://dev.mysql.com/doc/refman/8.0/en/estimating-performance.html" rel="nofollow noreferrer">seeks</a> when data gets larger in de indexes (using B-tree).. "If there are other alternatives to SQLite that can perform better for my case" So it's pretty likely other RDBMS also work in that way when using B-tree indexes...</span>
<span class="comment-copy">"If there are other alternatives to SQLite that can perform better for my case" For what case you didn't provide table structures, example data and or a query you are running i advice you to read <a href="https://meta.stackoverflow.com/questions/333952/why-should-i-provide-an-mcve-for-what-seems-to-me-to-be-a-very-simple-sql-query">this</a> and provide us with text formatted example data, a <code>CREATE TABLE</code> statement and text formatted expected results... Besides you should also tell us how many users are connected to the SQLite database and how the pyhon application works more or less</span>
<span class="comment-copy">@RaymondNijland, I chose SQLite based on the suggestions I got in this thread <a href="https://stackoverflow.com/questions/53483493/instant-access-to-line-from-a-large-file-without-loading-the-file" title="instant access to line from a large file without loading the file">stackoverflow.com/questions/53483493/â€¦</a> I needed to get instant access to a line from a file without loading it. Now that I got a suggestion about dbm, I might investigate this option.</span>
<span class="comment-copy">Sqlite rowid tables use B*-trees and thus have O(n) lookup times. You can't change this.</span>
<span class="comment-copy">All I need is a file with instant access to lines by line number without storing anything in memory... maybe I will check dbm. In my previous post I asked a similar question and by popular opinion SQLite won.</span>
<span class="comment-copy">@artembus: SQLite is very fast and nicely interfaced from Python, so it is often a natural choice. But if you really need high performance, you could even considere a dedicated direct access file which will ensure O(1) access times...</span>
<span class="comment-copy">@artembus: after reading your previous post, I really think that what you need is to build an index file with the offset + length of each line.</span>
<span class="comment-copy">Thanks for the suggestions. I thought about creating an index file but I couldn't find any good documentation about that, probably because I searched the wrong terminology. Can you give me a few hints for what packages/frameworks/methods I should look into? I don't want to rebuild the wheel from 0 and I'm sure someone already created some code/repo I can use as a base.</span>
<span class="comment-copy">@artembus: I tried to google for it but did not find anything. It is not a so common use case because databases are the standard. Maybe you could have a look at NoSQL solutions which use direct key/value hashing. Not as efficient as a direct line_number/line access, but O(1) anyway.</span>
