<div class="post-text" itemprop="text">
<p>The code is as follows:</p>
<pre><code>from random import *

numStars = int(input("Number of stars: ").strip())

planetTypeDict = {'O':0, 'B':0, 'A':0, 'F':0, 'G':0, 'K':0, 'M':0}

for star in range (numStars):
    planetTypeChanceNum =  uniform (0, 100)

    if planetTypeChanceNum &lt; 76.45:
        planetType = 'M'
        planetTypeDict['M'] += 1

    elif planetTypeChanceNum &lt; 12.1:
        planetType = 'K'
        planetTypeDict['K'] += 1

    elif planetTypeChanceNum &lt; 7.6:
        planetType = 'G'
        planetTypeDict['G'] += 1

    elif planetTypeChanceNum &lt; 3:
        planetType = 'F'
        planetTypeDict['F'] += 1

    elif planetTypeChanceNum &lt; 0.6:
        planetType = 'A'
        planetTypeDict['A'] += 1

    elif planetTypeChanceNum &lt; 0.13:
        planetType = 'B'
        planetTypeDict['B'] += 1

    elif planetTypeChanceNum &lt; 0.0003:
        planetType = 'O'
        planetTypeDict['O'] += 1

print(planetTypeDict)
</code></pre>
<p>The problem is that the code outputs that there are about 75% 'M' stars and nothing else besides. For example, when i use 1000 as the value for numStars, I get a result of about:</p>
<pre><code>{'O': 241, 'B': 0, 'A': 0, 'F': 0, 'G': 0, 'K': 0, 'M': 759}
</code></pre>
<p>I have tried as much as I can to fix this error, including changing the logic to:</p>
<pre><code>if planetTypeChanceNum &gt; 100 - 'chance here':
    # stuff
</code></pre>
<p>Please help!</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python 3, use <code>random.choices</code> as shown by Patrick Artner.</p>
<p>Otherwise, just reverse the order of the checks:</p>
<pre><code>if planetTypeChanceNum &lt; 0.0003:
    planetType = 'O'
elif planetTypeChanceNum &lt; 0.13:
    planetType = 'B'
elif planetTypeChanceNum &lt; 0.6:
    planetType = 'A'
elif planetTypeChanceNum &lt; 3:
    planetType = 'F'
elif planetTypeChanceNum &lt; 7.6:
    planetType = 'G'
elif planetTypeChanceNum &lt; 12.1:
    planetType = 'K'
elif planetTypeChanceNum &lt; 76.45:
    planetType = 'M'

planetTypeDict[planetType] += 1
</code></pre>
<p>If the first check fails, <code>planetTypeChanceNum</code> can still be less than 0.13 (and it is implied that <code>0.0003 &lt;= planetTypeChanceNum</code>).</p>
<p>However, what's the planet type if <code>planetTypeChanceNum &gt;= 76.45</code>? You're missing an <code>else</code> clause, or perhaps an initial <code>if</code> statement to continue the loop early if there is no planet at all in that case.</p>
<pre><code>if planetTypeChanceNum &lt; 0.0003:
    planetType = 'O'
elif planetTypeChanceNum &lt; 0.13:
    planetType = 'B'
elif planetTypeChanceNum &lt; 0.6:
    planetType = 'A'
elif planetTypeChanceNum &lt; 3:
    planetType = 'F'
elif planetTypeChanceNum &lt; 7.6:
    planetType = 'G'
elif planetTypeChanceNum &lt; 12.1:
    planetType = 'K'
elif planetTypeChanceNum &lt; 76.45:
    planetType = 'M'
else:
    planetType = ???
</code></pre>
<p>or</p>
<pre><code>if planetType &gt;= 76.45:
    # No planet at all
    continue
elif planetTypeChanceNum &lt; 0.0003:
    planetType = 'O'
elif planetTypeChanceNum &lt; 0.13:
    planetType = 'B'
elif planetTypeChanceNum &lt; 0.6:
    planetType = 'A'
elif planetTypeChanceNum &lt; 3:
    planetType = 'F'
elif planetTypeChanceNum &lt; 7.6:
    planetType = 'G'
elif planetTypeChanceNum &lt; 12.1:
    planetType = 'K'
elif planetTypeChanceNum &lt; 76.45:
    planetType = 'M'
</code></pre>
<p>Both of these will exhaustively cover the  interval [0, 100).</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what you want:</p>
<pre><code>if planetTypeChanceNum &lt; 0.0003:
    planetType = 'O'
    planetTypeDict['O'] += 1
elif planetTypeChanceNum &lt; 0.13:
    planetType = 'B'
    planetTypeDict['B'] += 1
elif planetTypeChanceNum &lt; 0.6:
    planetType = 'A'
    planetTypeDict['A'] += 1
elif planetTypeChanceNum &lt; 3:
    planetType = 'F'
    planetTypeDict['F'] += 1
elif planetTypeChanceNum &lt; 12.1:
    planetType = 'K'
    planetTypeDict['K'] += 1
elif planetTypeChanceNum &lt; 76.45:
    planetType = 'M'
    planetTypeDict['M'] += 1
</code></pre>
<p>What I want to know is how you were getting any 'O's with your original code...</p>
</div>
<div class="post-text" itemprop="text">
<p>You do not get results because the later tests never can be true -the earlier would have matched already:</p>
<pre><code>if a &lt; 10:
    pass  # this eats up a=0,1,2,3,4,...,9  
elif a &lt; 5:
    pass  # never gonna happen.
</code></pre>
<hr/>
<p>Beside that you can make your creation far easier by using <code>random.choices()</code> supplying a weight for each choice and use <code>Counter</code> to count them:</p>
<pre><code>from random import choices
from collections import Counter

numStars = int(input("Number of stars: ").strip())

planetTypeDict = Counter({'O':0, 'B':0, 'A':0, 'F':0, 'G':0, 'K':0, 'M':0})

# https://docs.python.org/3/library/random.html#random.choices

# these weights are relative weights, meaning:
# M: 76.45 %
# K: 12.10 %
# G:  7.60 %
# F:  3.00 %
# A:  0.60 %
# B:  0.13 %
# O:  0.0003 %
# others - the rest of planet types (as the former do not add up to 100%)

types = [ "M","K","G","F","A","B","O", "other"] 
w     = [ 764500, 121000, 76000, 30000, 6000, 1300, 3, 
          1000000-sum( [764500, 121000, 76000, 30000, 6000, 1300, 3])]

planetTypeDict.update(choices(types,weights=w,k=numStars))
print(planetTypeDict.most_common()) 
</code></pre>
<p>Output (for 1 million stars):</p>
<pre><code>Number of stars: [('M', 763764), ('K', 121696), ('G', 75998), ('F', 29970), 
                  ('A', 6147), ('B', 1247), ('other', 1175), ('O', 3)]
</code></pre>
<p>Doku:</p>
<ul>
<li><a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer">random.choices(...) - with weighted probability</a></li>
<li><a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collections.Counter - special dict to count things</a></li>
</ul>
<hr/>
<p>@Chepner marked that your weights are probably already cumulative-considering the structure of your <code>if</code>'s:</p>
<pre><code>print(Counter(choices("OBAFGKMX", cum_weights=[0.0003 ,0.13 ,0.6 ,3 ,7.6 ,12.1,
                                               76.45 ,100], k=1000000)))
</code></pre>
<p>Leads to: </p>
<pre><code>Counter({'M': 643289, 'X': 235341, 'G': 45979, 'K': 45262, 'F': 24032, 'A': 4768, 'B': 1324, 'O': 5})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are misusing <code>elif</code></p>
<p>None of your cases aside from M will ever fire, since once they 'qualify' at the M if block, they then skip over the elifs.</p>
<p>To get the functionality you want, you need to bound your if statements, rather than having them one-sided.</p>
<p>Example:</p>
<pre><code>if 12.1 &lt; planetTypeChanceNum &lt; 76.45:
        planetType = 'M'
        planetTypeDict['M'] += 1
elif 7.6 &lt; planetTypeChanceNum &lt; 12.1:
        planetType = 'K'
        planetTypeDict['K'] += 1
</code></pre>
<p>There are more efficient ways to do this, but I think at this point you just need to understand if/elif functionality.</p>
</div>
<span class="comment-copy">If a number isn't less than 76.45, how could it be less than 12.1?</span>
<span class="comment-copy">This is really something you can work out if you go through your own logic step by step with pen and paper.</span>
<span class="comment-copy">And same thing phrased differently, a number less than 12.1 is ALWAYS less than 76.45. Why should it not belong in M if the conditions are arranged in that order?</span>
<span class="comment-copy">Just reverse the order of your statements</span>
<span class="comment-copy">You need to make your checks in reverse order: if it's less than 0.0003, it's type O. <i>Otherwise</i>, it might still be less than 0.13, in which case it's type B, etc.</span>
<span class="comment-copy">or you use random.choices() with weights and Counter to make it somewhat smarter :)</span>
<span class="comment-copy">Ah, I haven't really started using Python 3 much (I know, I know, the clock's ticking)  and didn't realize <code>choices</code> took weights now.</span>
<span class="comment-copy">(Oh, <code>choices</code> is new and distinct from <code>choice</code>, but still.)</span>
<span class="comment-copy">Yeah, I'm just going to refer to your answer.</span>
<span class="comment-copy">And what I don;t understand is why you are still using <code>planetType = 'O'</code>, <code>planetType = 'B'</code> and so on without making any use of them</span>
<span class="comment-copy">I think you want <code>cum_weights</code>, not <code>weights</code> (that's what the OP appears to have).</span>
<span class="comment-copy">@chepner relative weights (which I gave) get recalculated to cumulative weights - I could avoid that step by providing them as cum_weights directly, but then the cohesion between the numbers from the OP and my is gone... or do you think that the % for M is the one for M+K together ... so M is less likely then K ?</span>
<span class="comment-copy">The OP is generating a random number between 0 and 100, but the ones between 0 and 12.1 won't produce a type M planet, so the weight for type M is just 76.45 - 12.1 = 64.35. I <i>think</i> <code>choices("OBAFGKMX", cum_weights=[0.0003, 0.013, ..., 12.1, 76.45, 100], k=numStars)</code> would produce a set of planet types according to the original distribution.</span>
<span class="comment-copy">I think the OP has the cumulative weights already (at least, the original code is treating them as such), so there's no need to compute them yourself. Also, you don't have to scale the values up to integer values; <code>weights</code> and <code>cum_weights</code> can be <code>float</code>s. <code>M</code>, at least, looks too high (should be around 640,000).</span>
<span class="comment-copy">That's my confusion; the structure implies they are cumulative and just got the order  wrong, but they  do sum to a number close enough to 1 that they could be relative (plus assuming they are relative gets rid of the whole "what about the other 24%" problem).</span>
<span class="comment-copy"><code>elif</code> is fine, as long as you make your checks in the appropriate order.</span>
<span class="comment-copy">also fine if you do it as I described. not fine if used as OP did</span>
<span class="comment-copy">If the conditions are exhaustive, you could be making redundant comparisons.</span>
<span class="comment-copy">I’m not sure that OP is really at that level, or if minimizing compute or time are part of his question</span>
