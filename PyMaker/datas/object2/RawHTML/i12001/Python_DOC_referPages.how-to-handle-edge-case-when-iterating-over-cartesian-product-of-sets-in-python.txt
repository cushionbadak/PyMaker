<div class="post-text" itemprop="text">
<p>I have a function on zero or more <a href="https://software.sandia.gov/trac/pyomo/browser/pyomo/trunk/pyomo/core/base/sets.py" rel="nofollow">Pyomo sets</a>:</p>
<pre><code>def myfunc(*sets):
    if len(sets) == 0:
         return # Do something else that is irrelevant here
    indices = reduce(lambda x, y: x * y, sets)  # Cartesian product of sets
    for i in indices:
        call_some_other_function(*i)
</code></pre>
<p>This fails when I pass it a single set of integers, like</p>
<pre><code>import pyomo.environ
myset = pyomo.environ.Set(initialize=[1, 2])
myfunc(*myset)
</code></pre>
<p>because then I'm evaluating <code>*i</code> on an integer. What's an elegant way of handling this situation?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can always check if it is an <code>collections.Iterable</code> to catch cases where it is not iterable (lists, sets, etc. are iterables - integer aren't):</p>
<pre><code>from collections import Iterable
a = 1
isinstance(a, Iterable) # returns False
a = [1,2,3]
isinstance(a, Iterable) # returns True
</code></pre>
<p>so just do a check before you pass it into the function:</p>
<pre><code>if isinstance(myset, Iterable):
    myfunc(*myset)
else:
    # something else
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you're making things harder by implementing your own Cartesian product.  Python's provided <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a> since 2.6, and it works with any number of input sets.</p>
<pre><code>import itertools


def args(*args):
    return repr(args)


def for_each_index(*sets):
    if not sets:
         print('No sets given.  Doing something else.')
         return
    for index in itertools.product(*sets):
        print('Do something with ' + args(*index) + '...')
    return
</code></pre>
<p>I added the <code>args</code> function solely to show the exact result of expanding <code>*args</code>.  You don't need it, except maybe for debugging.</p>
<p>Note also that there is no need to call <code>len</code> to test if a tuple is non-empty.  <code>if not sets:</code> will do.</p>
</div>
<span class="comment-copy"><code>myset</code> isn't a list of sets, it's just a set. You have to pass in an iterable of sets, so something like <code>myset = [set([1, 2])]</code> or just <code>myset = [{1, 2}]</code>.</span>
<span class="comment-copy">Please note that <i>"If you can think of a better one and have permissions to change it, go ahead"</i> applies <b>all the time</b>. Also @Blender is right, this isn't so much an edge case as invalid input, you should be calling <code>myfunc(myset)</code> if <code>myset</code> doesn't itself contain sets.</span>
<span class="comment-copy">How is <code>set_a * set_b</code> legal?  I get <code>TypeError: unsupported operand type(s) for *: 'set' and 'set'</code>.  Are you using some other class with a <code>__mul__</code> method instead of the built-in <code>set</code>?</span>
<span class="comment-copy">@KevinJ.Chase Yes, it appears that I am. Apologies for that. I'll revise the question accordingly.</span>
