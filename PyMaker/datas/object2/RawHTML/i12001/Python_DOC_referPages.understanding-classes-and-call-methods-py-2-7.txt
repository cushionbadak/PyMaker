<div class="post-text" itemprop="text">
<p>Okay I have been running my forehead into some code and I have determined I am just taking shots in the dark at this point.  For some reason getting classes to click has been a real pain in the butt and I'm thinking if I used my own personal code it might make sense.  So here is a little script game I wrote up to experiment. (Its pretty rough I'm fairly new): <a href="https://github.com/Villagesmithy/Zombies-.git" rel="nofollow">https://github.com/Villagesmithy/Zombies-.git</a></p>
<p>I feel that to understand what I'm doing wrong I have to have it pointed out to me in my own code.  There are plenty of questions similar to mine I'm sure but they were going over my head sadly.</p>
<p>The error I'm getting is this:</p>
<pre><code>Attribute Error: Combat instance has no __Call__ method
</code></pre>
<p>And here is the class that I think is the problem:</p>
<pre><code>class Combat:

    def battle(self): 

        print start.player, " has: ", hp, "."
        print "The zombie has: ", zombie.zom_health()
        time.sleep(1)

        if haf == True:

            total_damage = hero_attacks * hero_damage
            zombie.zom_health() - total_damage
            print "You strike the zombie for %d damage!" %(total_damage)
            print "The zombie's health is %d" %zombie.zom_health()
            return zombie.zom_health()              
            time.sleep(3)

        elif haf == False:
            total_damage = zombie.zom_damage()- hero.hero_armor()
            if total_damage &gt; 0:
                total_damage - hp
                return hp
                print "A zombie shambles through the baricade and damages you!"
                print "You lost %d hp!  Your hp is now: %d" %(total_damage, hp)
                combat_loop()
                time.sleep(3)

            elif total_damage &lt;= 0:
                print "A zombie lurches at you but misses!"
                time.sleep(3)
                combat_loop()

        else:
            z.zom_killed()

    def initv(battle):
        bat = battle()

        hero_init = random.randint(1,20)
        zom_init = random.randint(1,20)


        if hero_init &gt;= zom_init:
            #global haf Ignoring for now
            haf = True
            print "You attack first!"
            bat.battle()
        elif hero_init &lt; zom_init:
            #global haf
            haf = False
            print "The zombie attacks!"
            bat.battle()

    def start():  #The only fucking code that works
        global zombies
        zombies = random.randint(20,30)
        arm = random.sample(armor,1)
        wea = random.sample(weapon, 1)

        player = raw_input("What is your name?")
        print player, ",\n" 
        print "Your colony is under attack by %s zombies!" %(zombies)
        print "Hold them off so the others can escape."
        print "You are wearing an ", arm,  "and weilding a", wea
        time.sleep(3)



    def combat_loop():
        combat_call = Combat()

        while zombies &gt; 0:
            combat_call.initv()

        if zombies &lt;= 0:
            print "You held off the zombies off long enough to escape!"
            print "With the way clear you grab your belongings and follow suit."
            print "The end!"
            sys.exit()  
</code></pre>
<p>Now if you are saying Gee this kiddo has no clue what he is doing you would be correct!  I'm just hoping you guys can assist me in making this click.  The whole program might need to be burned at the stake I don't know.  Any help you can give would be very helpful.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming <code>initv</code> is actually a method of <code>Combat</code>, but you forgot to have it take <code>self</code> as a parameter, giving it a parameter named <code>battle</code> instead.</p>
<p>When you call <code>bat.initv()</code>, it's passing <code>self</code> as <code>battle</code> (<code>self</code> is a name of convention; the first positional parameter of a method is <code>self</code> whatever you decide to call it). So when you do <code>bat = battle()</code> in <code>initv</code>, it's the same thing as doing <code>self()</code>, that is, trying to treat an instance of your class as a callable.</p>
<p>From what I can tell, the real goal is to call the <code>battle</code> method, so the definition and first line of <code>initv</code> should be:</p>
<pre><code>def initv(self):
    bat = self.battle()
</code></pre>
<p>which passes <code>self</code> under the standard name, then calls the <code>battle</code> method on it. It's a little unclear what the <code>battle</code> method returns (it seems to return <code>None</code> implicitly on two code paths, and whatever <code>zombie.zom_health()</code> returns on the third code path, which has a <code>sleep</code> in it that never happens thanks to the <code>return</code> preempting it), but this code has a number of issues, and it's quite hard to identify what "correct" behavior would be.</p>
<p>For the record, the error almost certainly complained about the lack of a <code>__call__</code> method, not <code>__Call__</code>; <a href="https://docs.python.org/3/reference/datamodel.html#object.__call__" rel="nofollow">the special method that lets instances of a class act as callables themselves is all lower case.</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In <code>combat_loop</code> you define <code>combat_call</code> as <code>Combat()</code>.  Right now <code>combat_call</code> is an instance of <code>Combat</code>.  Then in your <code>while</code> loop, you say <code>combat_call.initv()</code>.  Since <code>combat_call</code> is an instance of <code>Combat</code>, that is a shortcut for <code>Combat.initv(combat_call)</code>.  That is, <code>combat_call</code> is the only argument given to <code>initv()</code>.  In <code>initv()</code>, you take one argument: <code>battle</code>.  In this case, <code>battle</code> is the same thing as <code>combat_call</code> which is an instance of <code>Combat</code>.  You then say <code>bat = battle()</code>.  <code>battle</code> is already an instance of <code>Combat</code>, so you are trying to call an instance.  Some instances can be called, but to do that, they need to define a <code>__call__</code> method.  Your class did not, so there is an error.  I think that instead of taking <code>battle</code> as an argument, take <code>self</code>.  Then define <code>bat</code> as <code>self.battle()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>One more thing, I don't think the <code>zombie.zom_health() - total_damage</code> line will work unless you implement the <code>__sub__</code> method in your <code>Zombie</code> class.  Even then I think it would only work if Zombie and Hero each had the same parent class say: '<code>Human</code>'.  But I hope not.  'Someone' would have to test that...I need some sleep first before I test more fixes for your Hero class. :) Perhaps <code>Zombie - Hero</code> might work.  This example re-worked from your Zombie class works fine when the objects (ie <code>Z1</code> and <code>Z2</code>) are both from the Zombie class.  So...Hero.total_damage() might work just as well.  I don't know for sure yet.</p>
<pre><code>import random

class Zombie:

    def __init__(self, zom_health=None):
        self.__zom_health = None
        if zom_health:
            self.__zom_health = zom_health
        else:
            self.randomize_zom_health()
        self.__zom_damage = 0

    def randomize_zom_health(self):
        zom_hp = random.randint(20,35)
        if zom_hp &lt;= 0:
            print zom_killed
            self.__zom_health = 0
        else:
            self.__zom_health = zom_hp

    def __sub__(self, Other):
        self.__zom_health -= Other.zom_damage() #or Other.total_damage()?

    def zom_health(self):
        return self.__zom_health

    def zom_damage(self, damage=None):
        if damage: self.__zom_damage = damage
        return self.__zom_damage
</code></pre>
<hr/>
<pre><code>&gt;&gt;&gt; reload(Zombie)
&gt;&gt;&gt; z1 = Zombie.Zombie(20)
&gt;&gt;&gt; z2 = Zombie.Zombie(zom_health=30)
&gt;&gt;&gt; z1.zom_health()
20
&gt;&gt;&gt; z2.zom_health()
30
&gt;&gt;&gt; z2.zom_damage(z2.zom_health())
30
&gt;&gt;&gt; z1 - z2
&gt;&gt;&gt; z1.zom_health()
-10
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">Would you please provide the full traceback in your question.</span>
<span class="comment-copy">Is your indentation right? It seems like <code>Combat</code> is a class without anything inside it...</span>
<span class="comment-copy"><code>initv</code> needs to inherit self. A good IDE will catch these kinds of errors for you, I recommend you try something like PyCharm.</span>
<span class="comment-copy">@MSeifert: Based on usage, at least <code>battle</code> and <code>initv</code> are methods of <code>Combat</code>. No idea if <code>start</code> or <code>combat</code> loop are intended to be part of the <code>class</code>, not clues either way.</span>
