<div class="post-text" itemprop="text">
<p>I have the following dictionaries:</p>
<pre><code>input_processed = {'units' : {'g' : 'g',
                              'dx' : 'cm',
                              'po' : 'bar',
                              'muo' : 'mPas'},
                   'g' : 1.0,
                   'dx' : [10.0, 20.0, 10.0],
                   'muo' : {'po' : [0.0, 1.0],
                            'muo' : [32.7, 32.7]},
                   'phi' : 0.05}

commands_variables = {'units' : [],
                      'g' : ['g'],
                      'dx' : ['dx'],
                      'muo' : ['po', 'muo'],
                      'phi' : ['phi']}

conversion_factors = {'g' : 9.81,
                      'cm' : 0.01,
                      'bar' : 10**5,
                      'mPas' : 10**-3}
</code></pre>
<p>My aim is to multiply each float in <code>input_processed</code> by a factor defined in <code>conversion_factors</code> for some variables. Since a command (highest level keys in <code>input_processed</code> can define multiple variables, these are mapped in <code>commands_variables</code>.</p>
<p>So first I need to check, if the variable is contained in <code>input_processed['units']</code>, since <code>phi</code> has no unit. Then for each variable in every command I need to get the unit. In the next step I get the conversion factor depending on the unit from <code>conversion_factors</code>. Since the values of the highest level keys in <code>input_processed</code> can be of the type float, list or dict, I wrote a different method for each case. This is put into a function and called in a loop over <code>input_processed</code>.</p>
<pre><code>def convert_unit(data, command, parameter):
    for it in commands_variables[command]:
        if it in data['units']:
            variable = it
        else:
            continue

        unit = data['units'][variable]
        conversion_factor = conversion_factors[unit]

        if type(parameter) is float:
            converted = parameter*conversion_factor
        elif type(parameter) is list:
            converted = [parameter[it]*conversion_factor
                         for it in range(len(parameter))]
        elif type(parameter) is OrderedDict:
            for key, value in parameter.items():
                value = parameter[key]
                converted = [value[it]*conversion_factor
                             for it in range(len(value))]

        return converted

input_converted = {}
for key, value in input_processed.items():
    input_converted[key] = convert_unit(input_processed, key, value)
</code></pre>
<p>The desired output is for the function</p>
<pre><code>9.81
[0.1, 0.2, 0.1]
{'po' : [0.0, 100000.0], 'muo' : [0.0327, 0.0327]}
0.05
</code></pre>
<p>and for the main program</p>
<pre><code>input_processed = {'units' : {'g' : 'g',
                              'dx' : 'cm',
                              'po' : 'bar',
                              'muo' : 'mPas'},
                   'g' : 9.81,
                   'dx' : [0.1, 0.2, 0.1],
                   'muo' : {'po' : [0.0, 100000.0],
                            'muo' : [0.0327, 0.0327]},
                   'phi' : 0.05}
</code></pre>
<p>I managed to convert floats and lists but no dictionaries. In this shortened problem statement, I had the error that the local variable 'converted' is referenced before the assignment.</p>
<p>If somebody has an easier way to convert the quantities, I would appreciate that.    </p>
</div>
<div class="post-text" itemprop="text">
<p>The main issue with your existing code is that your</p>
<pre><code>for key, value in parameter.items():
</code></pre>
<p>loop doesn't accumulated the changed items in the nested dictionary, so the <code>converted</code> produced by that part of the code will only be the converted last <code>item</code> in <code>parameter</code>; also that section only handles nested dictionary items that are lists, it will fail on plain floats.</p>
<p>FWIW, your <code>return converted</code> at the bottom of the main <code>for</code> loop looks a bit suspicious: an unconditional <code>return</code> inside a loop will cause the function to return at the end of the first loop iteration. That's actually ok here, since we <em>do</em> want to exit the loop after we get a successful match <code>it in data['units']</code>, but it still makes it a bit tricky for someone reading your code. :)</p>
<p>A minor issue is the use of <code>type</code> for type testing. It's recommended to use <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer"><code>isinstance</code></a> instead. See <a href="https://stackoverflow.com/q/1549801/4014959">Differences between isinstance() and type() in python</a> for details. As the answers there mention it's best to avoid <code>type</code> checking in Python as much as possible, since that interferes with duck typing.</p>
<p>Anyway, here's a modified version of your function. My code was tested on Python 2.6.6, but it <em>should</em> perform correctly on Python 3... I think. :)</p>
<pre><code>from pprint import pprint

conversion_factors = {
    'g' : 9.81,
    'cm' : 0.01,
    'bar' : 10**5,
    'mPas' : 10**-3
}

input_processed = {
    'units' : {
        'g' : 'g',
        'dx' : 'cm',
        'po' : 'bar',
        'muo' : 'mPas'
    },
    'g' : 1.0,
    'dx' : [10.0, 20.0, 10.0],
    'muo' : {
        'po' : [0.0, 1.0],
        'muo' : [32.7, 32.7]
    },
    'phi' : 0.05
}

def convert_dict(indata):
    units = indata['units']

    def convert(key, item):
        factor = conversion_factors.get(units.get(key))
        if factor is not None:
            if isinstance(item, list):
                item = [u * factor for u in item]
            else:
                item *= factor
        return item

    outdata = {'units': units.copy()}
    for k, v in indata.items():
        if k == 'units':
            continue
        if isinstance(v, dict):
            outdata[k] = newd = {}
            for k1, v1 in v.items():
                newd[k1] = convert(k1, v1)
        else:
            outdata[k] = convert(k, v)

    return outdata

input_converted = convert_dict(input_processed)
pprint(input_converted)
</code></pre>
<p><strong>output</strong></p>
<pre><code>{'dx': [0.10000000000000001, 0.20000000000000001, 0.10000000000000001],
 'g': 9.8100000000000005,
 'muo': {'muo': [0.032700000000000007, 0.032700000000000007],
         'po': [0.0, 100000.0]},
 'phi': 0.050000000000000003,
 'units': {'dx': 'cm', 'g': 'g', 'muo': 'mPas', 'po': 'bar'}}
</code></pre>
<p>FWIW, although <code>pprint.pprint</code> is ok for displaying dictionaries, you can get prettier output using <code>json.dumps</code>.</p>
</div>
<span class="comment-copy">it would be much easier if your input data had an easier structure. the problem with the 'referenced before assignment' error can be solved by using <code>dict</code> instead of <code>OrderedDict</code> in your code.</span>
<span class="comment-copy">Thank you very much :) This works fine with Python 3.5.1.</span>
<span class="comment-copy">@jseelig: My pleasure! And thanks for the feedback re:  Python 3.5.1.</span>
