<div class="post-text" itemprop="text">
<p>The answer to Javascript regex question <a href="https://stackoverflow.com/questions/17793423/return-the-part-of-the-regex-that-matched">Return the part of the regex that matched</a> is "No, because compilation destroys the relationship between the regex text and the matching logic."</p>
<p>But Python preserves <a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow noreferrer">Match Objects</a>, and <code>re.groups()</code> returns the specific group(s) that triggered a match.  It should be simple to preserve the regex text of each group as part of a Match Object and return it, but there doesn't appear to be a call to do so.</p>
<pre><code>import re

pat = "(^\d+$)|(^\w+$)|(^\W+$)"
test = ['a', 'c3', '36d', '51', '29.5', '#$%&amp;']
for t in test:
    m = re.search(pat, t)
    s = (m.lastindex, m.groups()) if m else ''
    print(str(bool(m)), s)
</code></pre>
<p>This returns:</p>
<pre><code>True (2, (None, 'a', None))
True (2, (None, 'c3', None))
True (1, ('51', None, None))
False
True (3, (None, None, '#$%&amp;'))
</code></pre>
<p>The compiler obviously knows that there are three groups in this pattern.  Is there a way to extract the subpattern in each group in a regex, with something like:</p>
<pre><code>&gt;&gt;&gt; print(m.regex_group_text)

('^\d+$', '^\w+$', '^\W+$')
</code></pre>
<p>Yes, it would be possible to write a custom pattern parser, for example to split on '|' for this particular pattern.  But it would be far easier and more reliable to use the re compiler's understanding of the text in each group.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the indices are not sufficient and you absolutely need to know the exact <em>part of the regex</em>, there is probably no other possibility but to parse the expression's groups on your own.</p>
<p>All in all, this is no big deal, since you can simply count opening and closing brackets and log their indices:</p>
<pre><code>def locateBraces(inp):
    bracePositions = []
    braceStack = []
    depth = 0
    for i in range(len(inp)):
        if inp[i] == '(':
            braceStack.append(i)
            depth += 1
        if inp[i] == ')':
            bracePositions.append((braceStack.pop(), i))
            depth -= 1
            if depth &lt; 0:
                raise SyntaxError('Too many closing braces.')
    if depth != 0:
        raise SyntaxError('Too many opening braces.')
    return bracePositions
</code></pre>
<blockquote>
<p><strong>Edited:</strong> This dumb implementation only counts opening and closing braces. However, regexes may contain escaped braces, e.g. <code>\(</code>, which are
  counted as regular group-defining braces using this method. You may
  want to adapt it to omit braces that have an uneven number of
  backslashes right before them. I leave this issue as a task for you ;)</p>
</blockquote>
<p>With this function, your example becomes:</p>
<pre><code>pat = "(^\d+$)|(^\w+$)|(^\W+$)"
bloc = locateBraces(pat)

test = ['a', 'c3', '36d', '51', '29.5', '#$%&amp;']
for t in test:
    m = re.search(pat, t)
    print(str(bool(m)), end='')
    if m:
        h = bloc[m.lastindex - 1]
        print(' %s' % (pat[h[0]:h[1] + 1]))
    else:
        print()
</code></pre>
<p>Which returns:</p>
<pre><code>True (^\w+$)
True (^\w+$)
True (^\w+$)
True (^\d+$)
False
True (^\W+$)
</code></pre>
<blockquote>
<p><strong>Edited:</strong> To get the list of your groups, of course a simple comprehension would do:</p>
<pre><code>gtxt = [pat[b[0]:b[1] + 1] for b in bloc]
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This may or may not be helpful depending on the problem that you are actually trying to solve ... But python lets you name the groups:</p>
<pre><code>r = re.compile('(?P&lt;int&gt;^\d+$)|(?P&lt;word&gt;^\w+$)')
</code></pre>
<p>From there, when you have a match, you can inspect the <code>groupdict</code> to see which groups are present:</p>
<pre><code>r.match('foo').groupdict()  # {'int': None, 'word': 'foo'}
r.match('10').groupdict()  # {'int': '10', 'word': None}
</code></pre>
<p>Of course, this doesn't tell you the exact regular expression associated with the match -- You'd need to keep track of that yourself based on the group name.</p>
<p>If you really want to go beyond this, you probably want something a little more sophisticated than simple regular expression parsing.  In that case, I might suggest something like <a href="https://pyparsing.wikispaces.com/" rel="nofollow"><code>pyparsing</code></a>.  Don't let the old-school styling on the website fool you (or the lack of a PEP-8 compliant API) -- the library is actually quite powerful once you get used to it.</p>
</div>
<div class="post-text" itemprop="text">
<p>It will remain up to you to track what regular expressions you are feeding into <code>re.search</code>. Something like:</p>
<pre><code>import re

patts = {
  'a': '\d+',
  'b': '^\w+',
  'c': '\W+'
}

pat = '^' + '|'.join('({})'.format(x) for x in patts.values()) + '$'
test = ['a', 'c3', '36d', '51', '29.5', '#$%&amp;']
for t in test:
    m = re.search(pat, t)
    if m:
      for g in m.groups():
        for key, regex in patts.iteritems():
          if g and re.search(regex, g):
            print "t={} matched regex={} ({})".format(t, key, regex)
            break
</code></pre>
</div>
<span class="comment-copy">Yes, this completely answers the question if it will work for all regexes.   I didn't think the parser would be that simple.  Thanks!</span>
<span class="comment-copy">There is one flaw: If the regex contains an escaped brace, e.g. <code>\(</code>, then this dumb parser would assume it as a regular group-defining brace. Tracking the number of backslashes before each brace makes it a bit less handy...</span>
<span class="comment-copy">Great idea.  Build the big regex from a dict of {group_name: group_re} in the first place.  I looked in <code>sre_parse.py</code>, <code>sre_compile.py</code> etc but ran with my tail between my legs ... horrible code in there</span>
<span class="comment-copy">Thanks, but it is just as easy to keep track of the expression for positional (non-named) groups if you're writing the expression yourself.   My question is more along the lines of "read a pattern, return the expressions for groups in that pattern" - named groups don't make that any easier.</span>
<span class="comment-copy">@wim -- I looked at the public interface on the regex objects before I came up with this idea.  There might be something non-public that you could use, but I'm not about to suggest relying on module internal implementation details in an answer ;-)</span>
<span class="comment-copy">I wound up matching each of the individual patterns separately in a loop.  In the problem that motivated this question I know what they are and don't need to parse a big pattern to extract them.  I haven't measured the speed difference between three small searches and one large one - if it's 3:1 then doing the join at the beginning would definitely be a better approach than looping.</span>
