<div class="post-text" itemprop="text">
<p>This is my code i am able to print each line but when blank line appears it prints ; because of CSV file format, so i want to skip when blank line appears</p>
<pre><code>import csv
import time

ifile = open ("C:\Users\BKA4ABT\Desktop\Test_Specification\RDBI.csv", "rb")
for line in csv.reader(ifile): 
    if not line: 
        empty_lines += 1 
        continue
    print line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to skip all whitespace lines, you should use this test: <code>'   '.isspace()</code>. </p>
<p>Since you may want to do something more complicated than just printing the non-blank lines to the console(no need to use CSV module for that), here is an example that involves a DictReader:</p>
<pre><code>#!/usr/bin/env python
# Tested with Python 2.7

# I prefer this style of importing - hides the csv module
# in case you do from this_file.py import * inside of __init__.py
import csv as _csv


# Real comments are more complicated ...
def is_comment(line):
    return line.startswith('#')


# Kind of sily wrapper
def is_whitespace(line):
    return line.isspace()


def iter_filtered(in_file, *filters):
    for line in in_file:
        if not any(fltr(line) for fltr in filters):
            yield line


# A dis-advantage of this approach is that it requires storing rows in RAM
# However, the largest CSV files I worked with were all under 100 Mb
def read_and_filter_csv(csv_path, *filters):
    with open(csv_path, 'rb') as fin:
        iter_clean_lines = iter_filtered(fin, *filters)
        reader = _csv.DictReader(iter_clean_lines, delimiter=';')
        return [row for row in reader]


# Stores all processed lines in RAM
def main_v1(csv_path):
    for row in read_and_filter_csv(csv_path, is_comment, is_whitespace):
        print(row)  # Or do something else with it


# Simpler, less refactored version, does not use with
def main_v2(csv_path):
    try:
        fin = open(csv_path, 'rb')
        reader = _csv.DictReader((line for line in fin if not
                                  line.startswith('#') and not line.isspace()),
                                  delimiter=';')
        for row in reader:
            print(row)  # Or do something else with it
    finally:
        fin.close()


if __name__ == '__main__':
    csv_path = "C:\Users\BKA4ABT\Desktop\Test_Specification\RDBI.csv"
    main_v1(csv_path)
    print('\n'*3)
    main_v2(csv_path)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of </p>
<pre><code>if not line:
</code></pre>
<p>This should work:</p>
<pre><code>if not ''.join(line).strip():
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can strip leading and trailing whitespace, and if the length is zero after that the line is empty.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import csv

with open('userlist.csv') as f:

    reader = csv.reader(f)
    user_header = next(reader)       # Add this line if there the header is

    user_list = []                   # Create a  new user list for input
    for row in reader:
        if any(row):                 # Pick up the non-blank row of list
            print (row)              # Just for verification
            user_list.append(row)    # Compose all the rest data into the list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import csv
ifile=csv.reader(open('C:\Users\BKA4ABT\Desktop\Test_Specification\RDBI.csv', 'rb'),delimiter=';')
for line in ifile:
    if set(line).pop()=='':
        pass
    else:
        for cell_value in line:
            print cell_value
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>my suggestion would be to just use the csv reader who can delimite the file into rows. Like this you can just check whether the row is empty and if so just continue.</p>
<pre><code>import csv

with open('some.csv', 'r') as csvfile:

    # the delimiter depends on how your CSV seperates values
    csvReader = csv.reader(csvfile, delimiter = '\t')

    for row in csvReader:
        # check if row is empty
        if not (row):    
            continue
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This example just prints the data in array form while skipping the empty lines:</p>
<pre><code>import csv

file = open("data.csv", "r")
data = csv.reader(file)

for line in data:
    if line: print line

file.close()
</code></pre>
<p>I find it much clearer than the other provided examples.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can always check for the number of comma separated values. It seems to be much more productive and efficient.</p>
<p>When reading the lines iteratively, as these are a list of comma separated values you would be getting a list object. So if there is no element (blank link), then we can make it skip.</p>
<pre><code>        with open(filename) as csv_file:
          csv_reader = csv.reader(csv_file, delimiter=",")
          for row in csv_reader:
            if len(row) == 0:
                continue
</code></pre>
</div>
<span class="comment-copy">Why do you open your file in binary mode? Regardless of that, you should iterate over your lines in <code>data</code> variable. That assignation to <code>empty_lines</code> is incorrect without declaring it first and you have a typo in the <code>for</code> with an extra closing parentheses.</span>
<span class="comment-copy">That code does not print anything because the file is consumed into <code>data</code> before the <code>for</code> loop.</span>
<span class="comment-copy">Janne  yes you are right it does not print anything, but actually i have tried to print individual cell thats why i have stored in an array.</span>
<span class="comment-copy">@Birei: "Why do you open your file in binary mode?"  Because that's the right portable way to open files to pass to <code>csv.reader</code> in Python 2, as mentioned in the <a href="http://docs.python.org/2/library/csv.html#csv.reader" rel="nofollow noreferrer">docs</a>.</span>
<span class="comment-copy">You may use filter or generator approach similar to this answer: <a href="http://stackoverflow.com/a/14158869/1317713">stackoverflow.com/a/14158869/1317713</a> I recommend re-factoring some of the logic into <code>def is_empty_line(line): ...</code> for readability, say if you want to skip a line containing all white-space. It can also be a good idea to skip both comments and empty lines - more reason to re-factor into separate functions.</span>
<span class="comment-copy">Beware: This method is likely to clobber files having newlines inside quoted fields. In this case the number of lines in the file is not comparable to the number of delimited records. See <a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow noreferrer">CSV module docs</a>, with explanation at the <a href="https://docs.python.org/3/library/csv.html#id3" rel="nofollow noreferrer">bottom of the page</a>.</span>
<span class="comment-copy">... by saying <code>if not line.strip():</code> :)</span>
<span class="comment-copy"><code>next(reader)</code>  is enough, no need to assign a variable to it.</span>
<span class="comment-copy">Not pythonic. Apart from that: <code>set("\n").pop() == '\n'</code>, so a blank line with a newline at the end will still be printed.</span>
<span class="comment-copy">@srinu j thank dude, i can skip  blank line but after that how an i access individual cell value, i know if i can store file in 'list' then i can access but problem is then i get blank line also.</span>
<span class="comment-copy">when u iterating line in file it will give a list you can access line[0] to get first value of the list.</span>
<span class="comment-copy">@Srinu J, i did but get individual full Column output, i want to access individual cell value when i iterate line.</span>
<span class="comment-copy">iterate line print the cell values.</span>
