<div class="post-text" itemprop="text">
<p>It seems python (python 3) queue will be stuck by large data, see the following example:</p>
<pre><code>import multiprocessing as mp
import numpy as np

class Tester:
    data = None
    def __init__(self):
        self.data = np.zeros((1000,1000))

    def __str__(self):
        return '%f %s' % (self.num, self.name)

def mod(test, out_queue):
    test.num = np.random.randn()
    out_queue.put(test)

if __name__ == '__main__':
    num = 10
    out_queue = mp.Queue()
    tests = []
    for it in range(num):
        tests.append(Tester())
    workers = [ mp.Process(target=mod, args=(test, out_queue)) for test in tests]
    for work in workers: work.start()
    for work in workers: work.join()
    res_lst = []
    for j in range(len(workers)):
        res_lst.append(out_queue.get())
</code></pre>
<p>The above code will cause deadlock on my machine and changing <code>1000</code> to <code>10</code> will solve the problem.</p>
<p>What is happening here?</p>
</div>
<div class="post-text" itemprop="text">
<p>Joining the child processes before consuming all the data off the queue can result in deadlock because the child will wait for all data to be removed from the queue before it can terminate. Meanwhile the parent will be blocked waiting for the child to terminate - which can't happen because the parent is not consuming the child's data from the queue.</p>
<p>The solution is to join the child processes <em>after</em> the parent has consumed <em>all</em> data from the queue. That includes data that has not been enqueued yet. So just move</p>
<pre><code>for work in workers: work.join()
</code></pre>
<p>to the end of the file and it will work.</p>
<p>This is not perfect because you need to make sure that all of the data from the child is removed from the queue. But fortunately it's OK in your case because there is a single <code>Queue.put()</code> in each child. If there is more than one large "put", the parent process will not collect the second and subsequent "puts" and the deadlock condition will occur.</p>
<p>This is explained along with an example in the multiprocessing <a href="https://docs.python.org/3/library/multiprocessing.html#programming-guidelines" rel="nofollow">programming guidelines</a> in the section <em>"Joining processes that use queues"</em>.</p>
</div>
<span class="comment-copy">Oh, so I misunderstood the problem. I will edit the question in case of misleading.</span>
