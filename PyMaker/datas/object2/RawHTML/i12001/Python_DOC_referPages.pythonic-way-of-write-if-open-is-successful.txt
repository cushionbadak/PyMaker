<div class="post-text" itemprop="text">
<p>I am looking for a pythonic way to create and write to file if opening it was successful or else return an error if not (e.g. permission denied).  </p>
<p>I was reading here <a href="https://stackoverflow.com/questions/8404856/whats-the-pythonic-way-of-conditional-variable-initialization/8405005#8405005">What's the pythonic way of conditional variable initialization?</a>. Although I'm not sure this method works as I have attempted to test it.</p>
<pre><code>os.write(fd,String) if (fd = os.open(str("/var/www/file.js"),os.O_RDWR)) else return HttpResponse("error on write")
</code></pre>
<p>It's supposed to be a one-liner.</p>
<p>When I do the above I get a syntax error as such:</p>
<pre><code>    os.write(fd,String) if (fd = os.open(str("/var/www/file.js"),os.O_RDWR)) else return HttpResponse("error on write")
                               ^
SyntaxError: invalid syntax `
</code></pre>
<p>Is there a more and correct pythonic one-line or two-liner to be able to achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd do something like this :</p>
<pre><code>try:
    with open('filename.ext', 'w+') as f:
        f.write("Hello world!")
except IOError as e:
    print("Couldn't open or write to file (%s)." % e)
</code></pre>
<p><em>edits along the comments, thank you for your input!</em></p>
</div>
<div class="post-text" itemprop="text">
<p>Since you're asking about what the Pythonic was of doing something, I think that you should consider the <a href="https://stackoverflow.com/questions/12265451/ask-forgiveness-not-permission-explain">Ask Forgiveness, Not Permission</a> paradigm. Namely, just perform the operation, and catch the appropriate exception if it didn't work.</p>
<p>For example, </p>
<pre><code>In [1]: open('/usr/tmp.txt', 'w').write('hello')
---------------------------------------------------------------------------
IOError                                   Traceback (most recent call last)
&lt;ipython-input-1-cc55d7c8e6f9&gt; in &lt;module&gt;()
----&gt; 1 open('/usr/tmp.txt', 'w').write('hello')

IOError: [Errno 13] Permission denied: '/usr/tmp.txt'
</code></pre>
<p>If there was no permission to do the op, an <code>IOError</code> will be thrown. Just catch it, then.</p>
<pre><code>try:
    open('/usr/tmp.txt', 'w').write('hello')
except IOError:
    ...
</code></pre>
<hr/>
<p>Alex Martelli once talked about this, and described some inherent fallacies about checking permissions. There's an inherent race in these matters. You could always have permission to write when you opened the file, but not later when you attempted to write. You'll have to deal with exceptions anyway, so you might as well just build with them.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of nesting the try and with statements (and missing the IOError on the way if the inner code raises one), I highly suggest this syntax. It causes one less nesting and makes sure that the IOError occurred because of the open. That way, you have no chance of catching an unwanted exception, and you have much more control.</p>
<pre><code>f = None
try:
    f = open('file', 'w+')
except IOError:
    print("Couldn't open the file")
else:
    f.write('You are opened')
finally:
    if f: f.close()
</code></pre>
<p>There is no real pythonic way for doing it as a one liner, and it's generally a good idea to avoid long one liners.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to be Pythonic, always go for readability when designing your code. To be honest, there is absolutely nothing wrong with wrapping something in a <code>try/except</code> and controlling your logic accordingly.</p>
<p>AKA, <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow">EAFP</a> -&gt; Easier to Ask for Forgiveness than Permission. </p>
<p>Furthermore, when you are writing to a file, you are always better off using a context manager. </p>
<p>So, this can easily translate in to something like this: </p>
<pre><code>try:
    with open('your_file', 'w') as f:
        f.write(your_data)
except (OSError, IOError) as exc:
    print("Your file could not be written to, your exception details are: {}".format(exc))
</code></pre>
</div>
<span class="comment-copy">The Python ternary operator is <code>value1 if condition else value2</code>. It is not <code>statement1 if condition else statement2</code>. A return statement is not a value, so it can't be used in the ternary operator.</span>
<span class="comment-copy">Use a <a href="http://stackoverflow.com/questions/3012488/what-is-the-python-with-statement-designed-for"><code>with</code></a> statement.</span>
<span class="comment-copy">Maybe just <code>try: with open(...) except: print("Leapt and failed. No regrets!")</code> unless you're only looking for ternary operator solutions.</span>
<span class="comment-copy">Gaaah! No bare <code>except:</code>s!  Please use <code>except Exception:</code> if you intend to do a catch-all. But otherwise, top marks for using <code>with</code> and file as a context manager.</span>
<span class="comment-copy">That would be <code>IOError</code>, iirc. You shouldn't just catch all Exceptions, only the one you meant.</span>
<span class="comment-copy">You should <i>really</i> be more explicit with your exceptions. It <i>really</i> should be IOError in this case. Keeping it at the base <code>Exception</code> is not the best choice.</span>
<span class="comment-copy">So I get <code>with</code> executes the <code>__enter__</code> and <code>__exit__</code> methods of open. However, why is it better than just <code>try : f =open('filename.txt','w+') f.write("hello world") except IOError as e ...</code> since the exception is already being caught and cleaning up. Is there something important the <b>enter</b> and <b>exit</b> methods of open are doing? In addition, I keep seeing <code>context manager</code> what is that? Don't wanna just use something without understanding it :).</span>
<span class="comment-copy">@dylan7 <code>open</code> acts as a context manger, which does stuff on enter and exit. The important thing for <code>open</code> is what it does on <code>__exit__</code> â€” closing the file.</span>
<span class="comment-copy">I think that this is problematic. On a minor note, your <code>print</code> states the reason as being "open or write", but it is only open. More fundamentally, the <code>open</code> could succeed, but the <code>write</code> fail. Finally, if explicit closing is needed, <code>with</code> (inside the <code>try</code>) would be better.</span>
<span class="comment-copy">@AmiTavory Thanks, fixed. Regarding the write, failing to write and failing to open are two different things. Using a with inside a try makes it a bit harder to separate the error, don't you think?</span>
<span class="comment-copy">Not crazy about it, but maybe it's a matter of taste. Am upvoting as it does raise some different considerations than the other answers.</span>
<span class="comment-copy">isn't it more pythonic to put the try in the with ?</span>
<span class="comment-copy">@B.M. What will happen if that file does not exist? It will raise. The one thing that you saying this brought to my attention though is that the exception that would raise for that would be a <code>FileNotFoundError</code>. So you would want to catch that and IOError.</span>
<span class="comment-copy">thanks, understood. IMHO, for writing, FileNotFoundError is not possible  because the file doesn't allready exist. Nevertheless, open(1, 'w')  raise a OSerror.</span>
<span class="comment-copy">FileNotFoundError inherits from OSError: <code>class FileNotFoundError(OSError):</code>. It <i>might</i> be better to get OSError for any other type of OSError that could come up, however.</span>
