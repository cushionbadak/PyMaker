<div class="post-text" itemprop="text">
<p>I have read many of the questions posted on variable referencing in Python, but things are still happening as I play with code that I would not expect and its getting quite frustrating. Take this piece of code:</p>
<pre><code>class MyClass(object) :

    class_var = "original message" # same for all objects

    def __init__(self, instance_var) :
        self.instance_var = instance_var #particular to the object

my_object = MyClass("my instance variable")
untouched_object = MyClass("another instance_var")

# Values of class_var and instance_var as expected

MyClass.class_var = "changed message"

# attribute class_var has changed for both objects

# This changes attribute class_var for my_object only
my_object.class_var = "I am my_object"

# THIS ONLY CHANGES ATTRIBUTE CLASS_VAR FOR UNTOUCHED_OBJECT ONLY!
MyClass.class_var = "Last message"

print MyClass.class_var #prints Last Message
print my_object.class_var #prints I am my_object ???
print untouched_object.class_var #prints Last Message
</code></pre>
<p>What is going on here? When I create an object of some class with a class variable, it seems that <code>object.class_attribute</code> originally contains a pointer to <code>Class.class_var</code> and I can change the attribute for all objects by assigning to <code>Class.class_var</code>. But if I explicitly assign <code>object.class</code> attribute to some other value, the pointer disappears and altering <code>Class.class_var</code> no longer has an effect on that particular object changing, only all other instances. Is this whats going on here? Further, why would we be able to access and change a class attribute in this way and potentially lose access to a value that the Python Documentation purports is known to all instances? </p>
</div>
<div class="post-text" itemprop="text">
<p>When you do </p>
<pre><code>my_object.class_var = "I am my_object"
</code></pre>
<p>you create an <em>instance</em> attribute <code>my_object.class_var</code> that shadows the class attribute <code>MyClass.class_var</code>, so it appears that the subsequent assignment to <code>MyClass.class_var</code> has no effect on <code>my_object</code>.  </p>
<p>It can be misleading to try and understand Python's data model in terms of concepts from other languages, eg references and pointers. Try to think in terms of names, and the binding of objects to names. </p>
<p>So in your example, <code>MyClass.class_var</code> and <code>my_object.class_var</code> are originally both names bound to the class attribute, but the assignment binds a new string object to the name <code>my_object.class_var</code>. </p>
<p>I find that it helps to think of (name, object) pairs as (key, value) pairs in a dictionary. In some cases that's actually what's happening "under the hood" (eg with normal classes you create yourself), but in other cases (like Python's built-in types) things are implemented a little differently for reasons of efficiency.</p>
<p>You may find this article helpful: <a href="http://nedbatchelder.com/text/names.html" rel="nofollow">Facts and myths about Python names and values</a>, which was written by SO veteran Ned Batchelder.</p>
</div>
<div class="post-text" itemprop="text">
<p>Every object has a variable named <code>__dict__</code> that stores the values of its member variables, indexed by name.  Every class also has a variable named <code>__dict__</code> that stores the values of its class variables, indexed by name.  When you access a variable v of an instance a with the a.v syntax, Python first looks for <code>a.__dict__['v']</code>.  If there is no such element, it looks in the class dictionary, i.e., <code>a.__class__.__dict__['v']</code>.  That's how class variables become visible to each instance of that class.</p>
<p>But when you assign to a variable the process is different.  A statement like <code>a.v = 12</code> causes Python to perform <code>a.__dict__['v'] = 12</code>.  It doesn't touch the class dictionary.  So other instances of the class are unaffected, as you would expect.  Now when you access a.v you get the value 12, the instance-specific value you just set, rather than the value of the class variable.  And you can no longer change a.v by messing with the class variable since <code>a</code> now has its own variable named 'v'.</p>
<p>The upshot of this is that you should use class variables mostly for setting "constants," similar to the way you use an enum or a #define in C.  It's a value that you don't intend to change.  If you restrict class variables to that style of usage, they are quite handy and easy to understand.</p>
</div>
<span class="comment-copy">Thank you, this is starting to make sense. One thing though, I see a lot of code referencing class variables within the class as <code>self.class_var</code>.  Why would they not use 'Class.class_var' ?</span>
<span class="comment-copy">Well, <code>self.class_var</code> does what you want when you're just reading from the class attribute. And <code>self</code> is easier to type than <code>MyClass</code> :) I guess the convention is to only explicitly use <code>MyClass.class_var</code> on the rare occasions when you actually <i>do</i> want to modify the class attribute.</span>
<span class="comment-copy">Nice answer. But not every class has a <code>__dict__</code>, some have <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><code>__slots__</code></a></span>
<span class="comment-copy">True, but I didn't want to complicate the explanation too much.</span>
