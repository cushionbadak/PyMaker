<div class="post-text" itemprop="text">
<p>How can I find out if a function or method is a normal function or an async function? I would like my code to automatically support normal or async callbacks and need a way to test what type of function is passed.</p>
<pre><code>async def exampleAsyncCb():
    pass

def exampleNomralCb():
    pass

def isAsync(someFunc):
    #do cool dynamic python stuff on the function
    return True/False

async def callCallback(cb, arg):
    if isAsync(cb):
        await cb(arg)
    else:
        cb(arg)
</code></pre>
<p>And depending on what type of function gets passed it should either run it normally or with await. I tried various things but have no idea how to implement <code>isAsync()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/inspect.html">inspect</a> module of Python.</p>
<p><code>inspect.iscoroutinefunction(object)</code></p>
<blockquote>
<p>Return true if the object is a coroutine function (a function defined with an async def syntax).</p>
</blockquote>
<p>This function is available since Python 3.5.
The module is available for Python 2 with lesser functionalities and certainly without the one you are looking for: <a href="https://docs.python.org/2/library/inspect.html">inspect</a></p>
<p>Inspect module as the name suggests is useful to inspect a whole lot of thing. The documentation says</p>
<blockquote>
<p>The inspect module provides several useful functions to help get information about live objects such as modules, classes, methods, functions, tracebacks, frame objects, and code objects. For example, it can help you examine the contents of a class, retrieve the source code of a method, extract and format the argument list for a function, or get all the information you need to display a detailed traceback.</p>
<p>There are four main kinds of services provided by this module: type checking, getting source code, inspecting classes and functions, and examining the interpreter stack.</p>
</blockquote>
<p>Some basic capabilities of this module are:</p>
<pre><code>inspect.ismodule(object)
inspect.isclass(object)
inspect.ismethod(object)
inspect.isfunction(object)
</code></pre>
<p>It also packs capability to retrieve the source code</p>
<pre><code>inspect.getdoc(object)
inspect.getcomments(object)
inspect.getfile(object) 
inspect.getmodule(object)
</code></pre>
<p>Methods are named intuitively. Description if needed can be found in documentation.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to introduce another import with <code>inspect</code>, <code>iscoroutine</code> is also available inside <code>asyncio</code>. </p>
<pre><code>import asyncio

def isAsync(someFunc):
    return asyncio.iscoroutinefunction(someFunc)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Co-routines have the <code>COROUTINE</code> flag set, bit 6 in the code flags:</p>
<pre><code>&gt;&gt;&gt; async def foo(): pass
&gt;&gt;&gt; foo.__code__.co_flags &amp; (2 &lt;&lt; 6)
128   # not 0, so the flag is set.
</code></pre>
<p>The value 128 is stored as a constant in the <code>inspect</code> module:</p>
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; inspect.CO_COROUTINE
128
&gt;&gt;&gt; foo.__code__.co_flags &amp; inspect.CO_COROUTINE
128
</code></pre>
<p>The <a href="https://docs.python.org/3/library/inspect.html#inspect.iscoroutinefunction" rel="noreferrer"><code>inspect.iscoroutinefunction()</code> function</a> does just that; test if the object is a function or method (to ensure there is a <code>__code__</code> attribute) and test for that flag. See the <a href="https://hg.python.org/cpython/file/v3.5.1/Lib/inspect.py#l180" rel="noreferrer">source code</a>.</p>
<p>Of course, using <code>inspect.iscoroutinefunction()</code> is the most readable and guaranteed to continue to work if ever the code flags were to change:</p>
<pre><code>&gt;&gt;&gt; inspect.iscoroutinefunction(foo)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Solutions above will work for simple cases, when you pass coroutine function. In some cases you may like to pass <em>awaitable object</em> function that acts like coroutine function, but is not coroutine function. Two examples is <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Future" rel="noreferrer">Future</a> class or <em>Future-like object</em> class (class that <a href="https://www.python.org/dev/peps/pep-0492/#await-expression" rel="noreferrer">implements</a> <code>__await__</code> magic method). In this cases <code>iscoroutinefunction</code> will return <code>False</code>, what is not you need.</p>
<p>It's easier to understand on non-async example with passing non-function callable as callback:</p>
<pre><code>class SmartCallback:
    def __init__(self):
        print('SmartCallback is not function, but can be used as function')

await callCallback(SmartCallback)  # Should work, right?
</code></pre>
<p>Back to async world, a similar situation:</p>
<pre><code>class AsyncSmartCallback:
    def __await__(self):
        return self._coro().__await__()

    async def _coro(self):
        print('AsyncSmartCallback is not coroutine function, but can be used as coroutine function')
        await asyncio.sleep(1)

await callCallback(AsyncSmartCallback)  # Should work, but oops! iscoroutinefunction(AsyncSmartCallback) == False
</code></pre>
<p>Way to solve it not to use <code>iscoroutine</code> or <code>iscoroutinefunction</code>, but use <code>inspect.isawaitable</code> instead. It works with ready object so you must create it first. In other words, solution I would advise to use:</p>
<pre><code>async def callCallback(cb, arg):
    if callable(cb):
        res = cb()  # here's result of regular func or awaitable
        if inspect.isawaitable(res):
            res = await res  # await if awaitable
        return res  # return final result
    else:
        raise ValueError('cb is not callable')
</code></pre>
<p>It's more universal (and I'm sure logically correct) solution.</p>
</div>
<span class="comment-copy">But... but <code>True/False</code> is dividing by <code>0</code>! :O</span>
<span class="comment-copy">Is there a practical difference between <code>inspect.iscoroutinefunction()</code> and <code>asyncio.iscoroutinefunction()</code>?</span>
<span class="comment-copy">@M.I.Wright - no, it is not. Based on the source code of Python 3.6, <code>asyncio</code> version is just a reimport from <code>inspect</code> module.</span>
<span class="comment-copy">The <code>asyncio.iscoroutinefunction()</code> function does <i>two</i> tests; it uses <code>inspect.iscoroutinefunction()</code> first, and if that test fails tests if the function is a function with the <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.coroutine" rel="nofollow noreferrer"><code>@acyncio.coroutine</code> decorator</a> applied. Take this into account!</span>
<span class="comment-copy">Thank you for providing a source level insight.</span>
<span class="comment-copy">But would't that change behavior if a normal function is passed as callback that happens to return an awaitable object, in that case the returned object would also get awaited/executed. Like <code>def testcb(): return AsyncSmartCallback</code></span>
<span class="comment-copy">@Ecko in case you'll pass this <code>testcb</code>, result you'll got is <code>AsyncSmartCallback</code> as it should be, nothing would be awaited. It happens because <code>AsyncSmartCallback</code> is <i>not</i> awaitable object, it's class that returns awaitable object: <code>AsyncSmartCallback()</code> - this is awaitable object. In case your function <code>def testcb(): return AsyncSmartCallback()</code>, this object would be awaited. But I see nothing wrong with it: imagine you pass <code>def testcb(): return Callback()</code> - in that case <code>Callback()</code> would also be executed.</span>
