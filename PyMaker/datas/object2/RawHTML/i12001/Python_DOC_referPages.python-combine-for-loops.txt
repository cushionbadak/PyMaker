<div class="post-text" itemprop="text">
<p>I am using python-docx to manipulate word documents. Here is what I currently have to modify text in normal paragraphs:</p>
<pre><code>doc = Document('idk.docx')
for paragraph in doc.paragraphs:
    if "oldtext1" in paragraph.text:
        paragraph.replace("oldtext1","Something")
    if "oldtext2" in paragraph.text:
        paragraph.replace("oldtext2","Somethingelse")
</code></pre>
<p>If I want to modify the text in a table, I need to do the following</p>
<pre><code>tables = doc.tables
for table in tables:
    for row in table.rows:
        for cell in row.cells:
            for paragraph in cell.paragraphs:
                if "oldtext1" in paragraph.text:
                    paragraph.replace("oldtext1","Something")
                if "oldtext2" in paragraph.text:
                    paragraph.replace("oldtext2","Somethingelse")
</code></pre>
<p>The code works fine and the text is replaced but the problem is that I am trying to replace ALL instances of the text in the document and I do not want to have 2 separate loops (1 for normal text in paragraphs and another for text in tables)</p>
<p>Is there an easy way to combine these loops so I do not have to have the same if-statements in 2 different loops?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would just use a generator comprehension:</p>
<pre><code>from itertools import chain

for paragraph in chain(doc.paragraphs, (paragraph for table in doc.tables for row in table.rows for cell in row.cells for paragraph in cell.paragraphs)):
    paragraph.replace("oldtext1","Something")
    paragraph.replace("oldtext2","Somethingelse")
</code></pre>
<p>Taking note that you don't need to do the lookahead check for <code>paragraph.replace()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>While a generator comprehension works fine, it might be cleaner to delegate this task to it's own function. It's a good amount more readable.</p>
<pre><code># Python 2.X
def get_all_paragraphs(document):
    for paragraph in document.paragraphs:
        yield paragraph

    for table in document.tables:
        for row in table.rows:
            for cell in row.cells:
                for paragraph in cell.paragraphs:
                    yield paragraph
</code></pre>
<p>This can be cleaned up some in Python 3.X by using the <code>yield from</code> construct.</p>
<pre><code># Python 3.X
def get_all_paragraphs(document):
    yield from document.paragraphs

    for table in document.tables:
        for row in table.rows:
            for cell in row.cells:
                yield from cell.paragraphs
</code></pre>
<p>I can't think of a way to get around the "for row in rows... for cell in row..." pattern however.</p>
<p>The usage is:</p>
<pre><code>for paragraph in get_all_paragraphs(doc):
    paragraph.replace("oldtext1","Something")
    paragraph.replace("oldtext2","Somethingelse")
</code></pre>
</div>
<span class="comment-copy">You are looping over different things, so I don't see anything wrong with this code</span>
<span class="comment-copy">@cricket_007 I agree, although I would recommend putting the per-paragraph processing in a function to avoid code repetition</span>
<span class="comment-copy">@HumphreyTriscuit - I was going to say that, but that's a personal preference and I wasn't sure both blocks would be the same</span>
<span class="comment-copy">@cricket_007: The code I currently have is fine but there are going to be a lot more if statements and i don't want them to exist in both sets of loops since they will be identical</span>
<span class="comment-copy">@Bijan cricket is correct, though; your loops are fine. If you want fewer <code>if</code> statements then put that logic in a function and call it from each of your loops.</span>
<span class="comment-copy">So does this first go through all the paragraphs and then go through all the text in cells?</span>
<span class="comment-copy">@Bijan Yes, but if you switch the order of addition it will do the opposite</span>
<span class="comment-copy">Note: Using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> and changing the listcomp to a genexpr would allow you to iterate lazily, instead of creating 2 potentially huge temporary <code>list</code>s up front. Also need to reverse order of loops. <code>from itertools import chain</code>, <code>for paragraph in chain(doc.paragraphs, (para for table in doc.tables for row in table.rows for cell in row.cells for para in cell.paragraphs)):</code> will get the same results (unless early loop mutates one of the values in <code>doc.tables</code>), but produce initial results faster with lower peak memory.</span>
<span class="comment-copy">@HumphreyTriscuit: I kinda glossed over it in my last comment, but you have the order of the loops in your listcomp backwards. The leftmost, not rightmost, <code>for</code> should be over <code>docs.tables</code>, then <code>table.rows</code>, etc.</span>
<span class="comment-copy">@ShadowRanger You're right, thanks! Fixed it up. Also completely agree on using <code>itertools.chain()</code>, I'll add that to my answer. Thanks again</span>
