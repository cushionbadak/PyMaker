<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a>
<span class="question-originals-answer-count">
                    28 answers
                </span>
</li>
</ul>
</div>
<p>This a exercise from Udacity's Deep learning course. </p>
<p>Can anyone explain why the final answer is not 1.0?</p>
<pre><code>v1 = 1e9
v2 = 1e-6
for i in range(int(1e6)):
    v1 = v1 + v2
print 'answer is', v1 - 1e9
# answer is 0.953674316406
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's check what <code>v1</code> sees of <code>v2</code> in the floating point addition:</p>
<pre><code>&gt;&gt;&gt; v3 = (v1+v2)-v1
&gt;&gt;&gt; print "%.25f %.25f" % (v3,1e6*v3)
0.0000009536743164062500000 0.9536743164062500000000000
</code></pre>
<p>What happens is that all but the leading <code>1</code> get shifted out of the binary mantissa of <code>1e-6</code> while equalizing the exponent with <code>1e9</code>. This means that the final value is <code>10**6 * 2**(-20) = (1.024)**(-2)</code>, which gives exactly the observed value</p>
<pre><code>&gt;&gt;&gt; print "%.17f" % (1.024)**(-2)
0.95367431640625000
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>1e-6</code> cannot be represented exactly as floating point value:</p>
<pre><code>print("{:.75f}".format(1e-6))
'0.000000999999999999999954748111825886258685613938723690807819366455078125000'
</code></pre>
<p>If you use a number that can be represented exactly such as <code>v2 = 1.0/(2**20)</code> and change iteration count to <code>2**20</code> you will get <code>0</code>. However as @user2357112 pointed out even this property holds only if all of the intermediate results can be represented exactly using floating point value.</p>
<p>Check Python tutorial for more details: <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow">https://docs.python.org/3/tutorial/floatingpoint.html</a></p>
</div>
<span class="comment-copy">"If you use a number that can be represented exactly for <code>v2</code> (e.g. <code>v2 = 1.0/(2**20)</code>) the result of running the program will be 0." - no, the result is still about 0.95, as it should be, since we don't subtract out the million multiples of v2. Also, exact representability of the value used for v2 isn't sufficient; we also need exactness of the intermediate sums to be guaranteed an exactly correct final result. For example, using <code>v2 = 1000.0 / 2**30</code> still produces rounding error in the intermediate values, despite the initial value being unrounded.</span>
<span class="comment-copy">Indeed, you would need a number that is exactly expressible with 1+3 mantissa bits. 1000 = binary(1111101000) needs 1+6 mantissa bits.</span>
<span class="comment-copy">@user2357112, thanks for the correction. Indeed I didn't account  for the loss of precision and the fact that number of iterations must be changed. I will update the answer to be more precise.</span>
