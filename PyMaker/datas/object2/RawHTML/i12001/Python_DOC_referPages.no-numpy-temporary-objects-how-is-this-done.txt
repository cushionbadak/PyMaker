<div class="post-text" itemprop="text">
<p>I'm running the following code in a Cython function:</p>
<pre><code>a = np.zeros((3,3,))
b = np.ones((3,3,))

for i in range(1000000):
    a += b * i

return a
</code></pre>
<p>In this code, there are only two numpy array allocations. I would expect there to be 1,000,002 of them. When I replace the numpy arrays with my own class, I see its <code>__mul__</code> function being called 1,000,000 times, resulting in 1,000,000 object allocations.</p>
<p>How does numpy know it doesn't need to allocate temporary objects for storing b * i each iteration?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you look at the code generated by cython the key line I think is</p>
<pre><code>__pyx_t_1 = PyNumber_Multiply(__pyx_v_b, __pyx_v_i); // some error checking follows
</code></pre>
<p><code>PyNumber_Multiply</code> is <a href="https://docs.python.org/3/c-api/number.html" rel="nofollow">the standard c-api function to call the multiplication operator</a> so there's no reason to believe that it doesn't just act the same way as a normal multiplication call. However, we can easily check the type of the intermediate.... I took the compiled C file and inserted the line </p>
<pre><code>if (__Pyx_PrintOne(0, ((PyObject *)Py_TYPE(__pyx_t_1))) &lt; 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
</code></pre>
<p>(this was just obtained by looking at the code generated by <code>print(type(a))</code> and changing a variable name. Note that I haven't changed the Python code, so I don't believe that this generates a variable where one didn't exist before). I then compiled the file manually (<code>gcc -shared -pthread -fPIC -fwrapv -O2 -Wall -fno-strict-aliasing \   -I/usr/include/python3.4m -o filename.so filename.c</code> on linux).</p>
<p>This prints</p>
<blockquote>
<p><code>&lt;class 'numpy.ndarray'&gt;</code></p>
</blockquote>
<p>which really suggests that it has generated a normal numpy array object as a temporary, as you might expect. Nothing magic is going on.</p>
<hr/>
<p>As an interesting side note, I believe that recent versions of <a href="http://numba.pydata.org/" rel="nofollow">Numba</a> can actually eliminate the temporary and do the whole operation genuinely in place. However, actually proving this can happen for the example you've given is slightly beyond me (you can kind of see it by calling <code>inspect_asm()</code> on the function generated, and noticing there's a lot of add/multiply instructions, but not obvious function call).</p>
</div>
<span class="comment-copy">Not enough information to reproduce.</span>
<span class="comment-copy">I rephrased the question.</span>
<span class="comment-copy"><code>a</code> is mutable; <code>a+=...</code> changes the values of <code>a</code> without creating a new object or reassigning the variable.</span>
<span class="comment-copy">What leads you to believe that numpy is not doing 1000000 allocations?</span>
<span class="comment-copy">numpy.core.multiarray.array is not called.</span>
