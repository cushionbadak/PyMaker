<div class="post-text" itemprop="text">
<p>I have a JSON data as:</p>
<pre><code>{
    "persons": [
        {
            "city": "Seattle", 
            "name": "Brian"
            "dob" : "19-03-1980"
        }, 
        {
            "city": "Amsterdam", 
            "name": "David"
            "dob" : "19-09-1979"
        } 
       {
            "city": "London", 
            "name": "Joe"
            "dob" : "19-01-1980"
        }
        {
            "city": "Kathmandu", 
            "name": "Brian"
            "dob" : "19-03-1980"
        }
   ]
}
</code></pre>
<p>How can I count the individual elements, like, number of person born in Jan-Dec (0 if none were born) and born in given year using python in one single iteration. Also the number of unique names registered in each month
Like: </p>
<pre><code>1980 :3
--Jan:1
--Mar:2
1979 :1
--Sep:1
</code></pre>
<p>Names:</p>
<pre><code>Mar 1980: 1 #Brian is same for both cities 
Jan 1980: 1
Sep 1979: 1
</code></pre>
<p>counters_mon is the counter that has values for specific months of year</p>
<pre><code>for k_mon,v_mon in counters_mon.items():
    print('{}={}'.format(k_mon,v_mon))  
</code></pre>
<p>But I want details too to be printed. How can I achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import json    

f = open('/path/to/your/json', 'r')
persons = json.load(f)
years_months = {}
years_months_names = {}

for person in persons['persons']:
    year = person['dob'][-4:]
    month = person['dob'][3:5]
    month_year = month + ' ' + year
    name = person['name']

    if year not in years_months.keys():
        years_months[year] = { 'count': 1, 'months' : {} }
        if month not in years_months[year]['months'].keys():
            years_months[year]['months'][month] = 1
        else:
            years_months[year]['months'][month] += 1
    else:
        years_months[year]['count'] += 1
        if month not in years_months[year]['months'].keys():
            years_months[year]['months'][month] = 1
        else:
            years_months[year]['months'][month] += 1

    if month_year not in years_months_names.keys():
        years_months_names[month_year] = set([name])
    else:
        years_months_names[month_year].add(name)

for k, v in years_months.items():
    print(k + ': ' + str(v['count']))
    for month, count in v['months'].items():
        print("-- " + str(month) + ": " + str(count))
for k, v in years_months_names.items():
    print(k + ": " + str(len(v)))
</code></pre>
<p>I'm assuming that you have the path to your json. I also tested my answer on the JSON that you've posted, and be careful to make sure that your JSON is structured correctly.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a good case for using defaultdicts (<a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow">https://docs.python.org/3/library/collections.html#collections.defaultdict</a>).</p>
<pre><code>data   # assume you have your data in a var called data

from collections import defaultdict
from calendar import month_abbr

# slightly strange construction here but we want a 2 levels of defaultdict followed by lists
aggregate = defaultdict(lambda:defaultdict(list))

# then the population is super simple - you'll end up with something like
# aggregate[year][month] = [name1, name2]
for person in data['persons']:
    day, month, year = map(int, person['dob'].split('-'))
    aggregate[year][month].append(person['name'])


# I'm sorting in chronological order for printing
for year, months in sorted(aggregate.items()):
    print('{}: {}'.format(year, sum(len(names) for names in months.values())))
    for month, names in sorted(months.items()):
        print('--{}: {}'.format(month_abbr[month], len(names)))

for year, months in sorted(aggregate.items()):
    for month, names in sorted(months.items()):
        print('{} {}: {}'.format(month_abbr[month], year, len(set(names))))
</code></pre>
<p>Depending on how the data was going to be used I'd actually consider not having the complex nesting in the aggregation and instead opt for something like <code>aggregate[(year, month)] = [name1, name2,...]</code>. I find that the more nested my data, the more confusing it is to work with.</p>
<p>EDIT Alternatively you can create several structures on the first pass so the printing step is simplified. Again, I'm using <code>defaultdict</code> to clean up all the provisioning.</p>
<pre><code>agg_years = defaultdict(lambda:defaultdict(int))   # [year][month] = counter
agg_years_total = defaultdict(int)   # [year] = counter
agg_months_names = defaultdict(set)   # [(year, month)] = set(name1, name2...)

for person in data['persons']:
    day, month, year = map(int, person['dob'].split('-'))

    agg_years[year][month] += 1
    agg_years_total[year] += 1
    agg_months_names[(year, month)].add(person['name'])


for year, months in sorted(agg_years.items()):
    print('{}: {}'.format(year, agg_years_total[year]))
    for month, quant in sorted(months.items()):
        print('--{}: {}'.format(month_abbr[month], quant))

for (year, month), names in sorted(agg_months_names.items()):
    print('{} {}: {}'.format(month_abbr[month], year, len(names)))
</code></pre>
</div>
<span class="comment-copy">For one, your json isn't valid (<a href="http://jsonlint.com/" rel="nofollow noreferrer">jsonlint.com</a>) and since you're able to call <code>counters_mon.items()</code>, you're probably working with dictionaries.</span>
<span class="comment-copy">Right, first I extracted the values and added them in a list, and then performed actions on them.</span>
<span class="comment-copy">~ Thanks for the answer, I shall give a try from the office system, and get back if there is something.</span>
<span class="comment-copy">~  Accepted the answer, but it is not showing the count of September in 1979 and gives March count as 1 but its actually 2 for 1980.</span>
<span class="comment-copy">Check how your JSON is structured. I just tested it again with the code above and the output is correct. I'm also running Python 3.</span>
<span class="comment-copy">It will also show the month number and not the month name.</span>
<span class="comment-copy">1979: 1 1980: 3 -- 03: 1 -- 01: 1 03 1980: 1 09 1979: 1 01 1980: 1  This is the output I am getting...</span>
