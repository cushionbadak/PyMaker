<div class="post-text" itemprop="text">
<p>How would you iterate through a list of lists, such as:</p>
<pre><code>[[1,2,3,4], [5,6], [7,8,9]]
</code></pre>
<p>and construct a new list by grabbing the first item of each list, then the second, etc. So the above becomes this:</p>
<pre><code>[1, 5, 7, 2, 6, 8, 3, 9, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a list comprehension along with <a href="https://docs.python.org/2/library/itertools.html#itertools.izip_longest" rel="nofollow"><code>itertools.izip_longest</code></a> (or <code>zip_longest</code> in Python 3)</p>
<pre><code>from itertools import izip_longest
a = [[1,2,3,4], [5,6], [7,8,9]]
[i for sublist in izip_longest(*a) for i in sublist if i is not None]
# [1, 5, 7, 2, 6, 8, 3, 9, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As long as you know that <code>None</code> will not appear, you can take advantage of how <code>map()</code> works with no function:</p>
<pre><code>outlist = [y for sub in map(None, *inlist) for y in sub if not y is None]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>DRY: <code>itertools</code> has a recipe that sounds right for this task: <code>roundrobin</code></p>
<pre><code>from itertools import cycle, islice

def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).next for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))

l = [[1,2,3,4], [5,6], [7,8,9]]

print (list(roundrobin(*l)))
#[1, 5, 7, 2, 6, 8, 3, 9, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it manually without using any import if you don't want to.</p>
<p>Keep N different counters where n is the number of lists in your list and increment them whenever you add a new element from that sublists. While adding them you should control that respective sets counter must be the minimum of all other counters if all lists have remaining elements.When you add the last element of list you can increment its counter to something like 9999 to protect our minimum rule.</p>
<p>This will be harder to implement and I do not suggest you to implement in this way but this is also a possibility if you do not want to import anything or want to have a programming challenge for your level.</p>
</div>
<div class="post-text" itemprop="text">
<p>Solutions that filter out <code>None</code> won't work if <code>None</code> is a value from the sublists that you would like to keep. To fix this, you can do a list comprehension that iterates over the indices of the longest sublist, and only adds sublist items if the index is in range.</p>
<pre><code>a = [[1,2,3,4],[5,6,None],[7,8,9]]
range_longest = range(max(map(len, a)))
[sublist[i] for i in range_longest for sublist in a if i &lt; len(sublist)]
# [1, 5, 7, 2, 6, 8, 3, None, 9, 4]
</code></pre>
</div>
<span class="comment-copy">You will lose any 0's, you should check for None</span>
<span class="comment-copy">Your example would be even better if you renamed <code>j</code> in a more readable way, like <code>result_with_holes</code> or something.</span>
<span class="comment-copy">@PadraicCunningham Right, corrected that.</span>
<span class="comment-copy">In Python 3 the name has changed to <code>zip_longest</code>.</span>
<span class="comment-copy">If you want to be fancy, this is equivalent to <code>list(filter(lambda x: x is not None, chain(*zip_longest(*a))))</code></span>
<span class="comment-copy">Note: This will not work in Python 3.</span>
<span class="comment-copy">@pp_: Good point.  I wonder why they would take that out.</span>
<span class="comment-copy">This is for Python 2 only, the Python 3 version can be found <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">You are right, @pp_, python 2 uses the attribute <code>next</code> and python 3 uses <code>__next__</code>.</span>
<span class="comment-copy">I think <code>next(iter(it))</code> would work for both, right?</span>
<span class="comment-copy">@Paul: Yes, but then you'd need to use <code>functools.partial</code> or a lambda, in this code.</span>
