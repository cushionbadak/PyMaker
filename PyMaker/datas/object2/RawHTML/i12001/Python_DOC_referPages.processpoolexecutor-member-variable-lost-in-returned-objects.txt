<div class="post-text" itemprop="text">
<p>I've a class like this based on <code>defaultdict</code>, which also has a member variable that is a defaultdict (my guess: this is where the problem lies?):</p>
<pre><code>from collections import defaultdict
class A(defaultdict):
  def __init__(self):
    super(A, self).__init__(int)
    self.B = defaultdict(int)

  def methodA(self, id):
    # update values in self.B and self[key], for example:
    # self[id] = 1000
    # self[1] = 1
    # self.B[id] = 2000
    # self.B[2] = 2

  def get_B(self):
    return self.B.iteritems()
  def get_dict(self):
    return self.iteritems()
</code></pre>
<p>I'm using <code>concurrent.futures</code> to create different instances of <code>A</code> like this:</p>
<pre><code>from concurrent.futures import ProcessPoolExecutor, as_completed

futures = []
num_processes = 2 #some integer value

def process_parallel(id):
  A_1 = A()
  A_1.methodA(id)
  return A_1

with ProcessPoolExecutor() as exec:
  for p in range(num_processes):
    futures.append(exec.submit(process_parallel, p))

for f in as_completed(futures):
  A_instance = f.result()
  # iterate over A_instance.get_dict() and A_instance.get_B
  # A_instance[1] can be accessed, but A_instance.B is empty
</code></pre>
<p>The problem is after the futures have completed and returned their results, the <code>B</code> member variable contains nothing. To check, I make sure that <code>B</code> is non-empty and can even print its elements at the end of the <code>methodA</code>, but once back in the main process, suddenly <code>B</code> seems to be gone.</p>
<p>Should <code>B</code> be initialized separately? What is the right way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think what's happening here is that the ProcessPoolExecutor is using <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow">pickle</a> to serialize and deserialize your class instances, and the contents of the  defaultdict that is the 'B' attribute of your instances are not preserved.  </p>
<p>You can verify this by creating and updating instances of your class in the interpreter, pickling and unpickling them and examining the results.</p>
<p>If you create a container class to hold both defaultdicts they both survive pickling and with their contents intact, so this is probably the best approach.  For example (assuming python3):</p>
<pre><code>class A:

    def __init__(self):
        self.foo = defaultdict(int)
        self.bar = defaultdict(int)

    def baz(self, value):
        # update defaultdicts
</code></pre>
</div>
