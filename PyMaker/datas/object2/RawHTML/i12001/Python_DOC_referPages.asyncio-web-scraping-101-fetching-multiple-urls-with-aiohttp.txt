<div class="post-text" itemprop="text">
<p>In earlier question, one of authors of <code>aiohttp</code> kindly suggested way to <a href="https://stackoverflow.com/q/35879769/">fetch multiple urls with aiohttp</a> using the new <code>async with</code> syntax from <code>Python 3.5</code>:</p>
<pre><code>import aiohttp
import asyncio

async def fetch(session, url):
    with aiohttp.Timeout(10):
        async with session.get(url) as response:
            return await response.text()

async def fetch_all(session, urls, loop):
    results = await asyncio.wait([loop.create_task(fetch(session, url))
                                  for url in urls])
    return results

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    # breaks because of the first url
    urls = ['http://SDFKHSKHGKLHSKLJHGSDFKSJH.com',
            'http://google.com',
            'http://twitter.com']
    with aiohttp.ClientSession(loop=loop) as session:
        the_results = loop.run_until_complete(
            fetch_all(session, urls, loop))
        # do something with the the_results
</code></pre>
<p>However when one of the <code>session.get(url)</code> requests breaks (as above because of <code>http://SDFKHSKHGKLHSKLJHGSDFKSJH.com</code>) the error is not handled and the whole thing breaks.</p>
<p>I looked for ways to insert tests about the result of <code>session.get(url)</code>, for instance looking for places for a <code>try ... except ...</code>, or for a <code>if response.status != 200:</code> but I am just not understanding how to work with <code>async with</code>, <code>await</code> and the various objects.</p>
<p>Since <code>async with</code> is still very new there are not many examples. It would be very helpful to many people if an <code>asyncio</code> wizard could show how to do this. After all one of the first things most people will want to test with <code>asyncio</code> is getting multiple resources concurrently.</p>
<p><strong>Goal</strong></p>
<p>The goal is that we can inspect <code>the_results</code> and quickly see either: </p>
<ul>
<li>this url failed (and why: status code, maybe exception name),  or</li>
<li>this url worked, and here is a useful response object</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I would use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather"><code>gather</code></a> instead of <code>wait</code>, which can return exceptions as objects, without raising them. Then you can check each result, if it is instance of some exception.</p>
<pre><code>import aiohttp
import asyncio

async def fetch(session, url):
    with aiohttp.Timeout(10):
        async with session.get(url) as response:
            return await response.text()

async def fetch_all(session, urls, loop):
    results = await asyncio.gather(
        *[fetch(session, url) for url in urls],
        return_exceptions=True  # default is false, that would raise
    )

    # for testing purposes only
    # gather returns results in the order of coros
    for idx, url in enumerate(urls):
        print('{}: {}'.format(url, 'ERR' if isinstance(results[idx], Exception) else 'OK'))
    return results

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    # breaks because of the first url
    urls = [
        'http://SDFKHSKHGKLHSKLJHGSDFKSJH.com',
        'http://google.com',
        'http://twitter.com']
    with aiohttp.ClientSession(loop=loop) as session:
        the_results = loop.run_until_complete(
            fetch_all(session, urls, loop))
</code></pre>
<p>Tests:</p>
<pre><code>$python test.py 
http://SDFKHSKHGKLHSKLJHGSDFKSJH.com: ERR
http://google.com: OK
http://twitter.com: OK
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am far from an asyncio expert but you want to catch the  error you need to catch a socket error:</p>
<pre><code>async def fetch(session, url):
    with aiohttp.Timeout(10):
        try:
            async with session.get(url) as response:
                print(response.status == 200)
                return await response.text()
        except socket.error as e:
            print(e.strerror)
</code></pre>
<p>Running the code and printing <em>the_results</em>:</p>
<pre><code>Cannot connect to host sdfkhskhgklhskljhgsdfksjh.com:80 ssl:False [Can not connect to sdfkhskhgklhskljhgsdfksjh.com:80 [Name or service not known]]
True
True
({&lt;Task finished coro=&lt;fetch() done, defined at &lt;ipython-input-7-535a26aaaefe&gt;:5&gt; result='&lt;!DOCTYPE ht...y&gt;\n&lt;/html&gt;\n'&gt;, &lt;Task finished coro=&lt;fetch() done, defined at &lt;ipython-input-7-535a26aaaefe&gt;:5&gt; result=None&gt;, &lt;Task finished coro=&lt;fetch() done, defined at &lt;ipython-input-7-535a26aaaefe&gt;:5&gt; result='&lt;!doctype ht.../body&gt;&lt;/html&gt;'&gt;}, set())
</code></pre>
<p>You can see we get catch the error  and the further calls are still successful returning the  html.</p>
<p>We should probably really be catching an <em>OSError</em> as socket.error is   <a href="https://docs.python.org/3.5/library/socket.html#socket.error" rel="nofollow">A deprecated alias of OSError</a> since python 3.3:</p>
<pre><code>async def fetch(session, url):
    with aiohttp.Timeout(10):
        try:
            async with session.get(url) as response:
                return await response.text()
        except OSError as e:
            print(e)
</code></pre>
<p>If you want to also check the response is 200, put your if in the try too and you can use the reason attribute to get more info:</p>
<pre><code>async def fetch(session, url):
    with aiohttp.Timeout(10):
        try:
            async with session.get(url) as response:
                if response.status != 200:
                    print(response.reason)
                return await response.text()
        except OSError as e:
            print(e.strerror)
</code></pre>
</div>
<span class="comment-copy">Terrific, thank you so much! I'll need to digest this, but after playing around with it a bit it seems to be quite flexible. +1, accept. :)</span>
<span class="comment-copy">Great answer. One thing I am curious about, since you immediately iterate over the results after doing <code>asyncio.gather</code> wouldn't it be better to do <code>asyncio.as_completed</code> on the list of <code>fetch</code>es? This way you can iterate over the completed ones immediately versus waiting for them all to finish?</span>
<span class="comment-copy">@dalanmiller: it requires exceptions handling, like in Padraic Cunningham answer. But if you need result for each Future immediately then this is the way.</span>
<span class="comment-copy">Thank you so much! Two great answers, I wish I could select both. Picking @kwarunek 's because it works out of the box, but +1 and I'll go find two of your best answers to upvote. :)</span>
