<div class="post-text" itemprop="text">
<p>As a complete beginner to programming, I am trying to understand the basic concepts of opening and closing files. One exercise I am doing is creating a script that allows me to copy the contents from one file to another. </p>
<pre><code>in_file = open(from_file)
indata = in_file.read()

out_file = open(to_file, 'w')
out_file.write(indata)

out_file.close()
in_file.close()
</code></pre>
<p>I have tried to shorten this code and came up with this:</p>
<pre><code>indata = open(from_file).read()
open(to_file, 'w').write(indata)
</code></pre>
<p>This works and looks a bit more efficient to me. However, this is also where I get confused. I think I left out the references to the opened files; there was no need for the in_file and out_file variables. However, does this leave me with two files that are open, but have nothing referring to them? How do I close these, or is there no need to?</p>
<p>Any help that sheds some light on this topic is much appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You asked about the "basic concepts", so let's take it from the top: When you open a file, your program gains access to <strong>a system resource,</strong> that is, to something outside the program's own memory space. This is basically a bit of magic provided by the operating system (a <em>system call,</em> in Unix terminology). Hidden inside the file object is a reference to a "file descriptor", the actual OS resource associated with the open file. Closing the file tells the system to release this resource.</p>
<p>As an OS resource, <strong>the number of files a process can keep open is limited:</strong> Long ago the per-process limit was about 20 on Unix. Right now my OS X box imposes a limit of 256 open files (though this is an imposed limit, and can be raised). Other systems might set limits of <a href="https://stackoverflow.com/q/870173/699305">a few thousand</a>, or in the <a href="http://www.cyberciti.biz/faq/linux-increase-the-maximum-number-of-open-files/" rel="nofollow noreferrer">tens of thousands</a> (per user, not per process in this case). When your program ends, all resources are automatically released. So if your program opens a few files, does something with them and exits, you can be sloppy and you'll never know the difference. But if your program will be opening thousands of files, you'll do well to release open files to avoid exceeding OS limits.</p>
<p>There's another benefit to closing files before your process exits: If you opened a file for writing, <strong>closing it will first "flush its output buffer".</strong> This means that i/o libraries optimize disk use by collecting ("buffering") what you write out, and saving it to disk in batches.  If you write text to a file and immediately try to reopen and read it without first closing the output handle, you'll find that not everything has been written out. Also, if your program is closed too abruptly (with a signal, or occasionally even through normal exit), the output might never be flushed. </p>
<p>There's already plenty of other answers on how to release files, so here's just a brief list of the approaches:</p>
<ol>
<li><p>Explicitly with <code>close()</code>. (Note for python newbies: Don't forget the parens! My students like to write <code>in_file.close</code>, which does nothing.)</p></li>
<li><p><strong>Recommended:</strong> Implicitly, by opening files with the <code>with</code> statement. The <code>close()</code> method will be called when the end of the <code>with</code> block is reached, even in the event of abnormal termination (from an exception).</p>
<pre><code>with open("data.txt") as in_file:
    data = in_file.read()
</code></pre></li>
<li><p>Implicitly by the reference manager or garbage collector, if your python engine implements it. This is not recommended since it's not entirely portable; see the other answers for details. That's why the <code>with</code> statement was added to python. </p></li>
<li><p>Implicitly, when your program ends. If a file is open for output, this may run a risk of the program exiting before everything has been flushed to disk.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The pythonic way to deal with this is to use the <a href="https://docs.python.org/2.7/reference/compound_stmts.html#the-with-statement"><code>with</code> context manager</a>:</p>
<pre><code>with open(from_file) as in_file, open(to_file, 'w') as out_file:
    indata = in_file.read()
    out_file.write(indata)
</code></pre>
<p>Used with files like this, <code>with</code> will ensure all the necessary cleanup is done for you, even if <code>read()</code> or <code>write()</code> throw errors.</p>
</div>
<div class="post-text" itemprop="text">
<p>The default python interpeter, CPython, uses reference counting. This means that once there are no references to an object, it gets garbage collected, i.e. cleaned up.</p>
<p>In your case, doing</p>
<pre><code>open(to_file, 'w').write(indata)
</code></pre>
<p>will create a file object for <code>to_file</code>, but not asign it to a name - this means there is no reference to it. You cannot possibly manipulate the object after this line.</p>
<p>CPython will detect this, and clean up the object after it has been used. In the case of a file, this means closing it automatically. In principle, this is fine, and your program won't leak memory.</p>
<p>The "problem" is this mechanism is an implementation detail of the CPython interpreter. The language standard <em>explicitly</em> gives no guarantee for it! If you are using an alternate interpreter such as pypy, automatic closing of files may be delayed <em>indefinitely</em>. This includes other implicit actions such as flushing writes on close.</p>
<p>This problem also applies to other resources, e.g. network sockets. It is good practice to <em>always</em> explicitly handle such external resources. Since python 2.6, the <code>with</code> statement makes this elegant:</p>
<pre><code>with open(to_file, 'w') as out_file:
    out_file.write(in_data)
</code></pre>
<hr/>
<p>TLDR: It works, but please don't do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is good practice to use the <strong><code>with</code></strong> keyword when dealing with file objects. This has the advantage that the file is properly closed after its suite finishes, even if an exception is raised on the way. It is also much shorter than writing equivalent try-finally blocks:</p>
<pre><code>&gt;&gt;&gt; with open('workfile', 'r') as f:
...     read_data = f.read()
&gt;&gt;&gt; f.closed
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answers so far are absolutely correct <em>when working in python</em>. You should use the <code>with open()</code> context manager. It's a great built-in feature, and helps shortcut a common programming task (opening and closing a file).</p>
<p>However, since you are a beginner and won't have access to <a href="https://stackoverflow.com/a/36046243/2348587">context managers</a>
 and <a href="https://stackoverflow.com/a/36047108/2348587">automated reference counting</a> for the entirety of your career, I'll address the question from a <em>general programming</em> stance.</p>
<p>The first version of your code is perfectly fine. You open a file, save the reference, read from the file, then close it. This is how a lot of code is written when the language doesn't provide a shortcut for the task. The only thing I would improve is to move <code>close()</code> to where you are opening and reading the file. Once you open and read the file, you have the contents in memory and no longer need the file to be open.</p>
<pre><code>in_file = open(from_file)
indata = in_file.read()
out_file.close() 

out_file = open(to_file, 'w')
out_file.write(indata)
in_file.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A safe way to open files without having to worry that you didn't close them is like this:</p>
<pre><code>with open(from_file, 'r') as in_file:
    in_data = in_file.read()

with open(to_file, 'w') as out_file:
    outfile.write(in_data)
</code></pre>
</div>
<span class="comment-copy">Side-note: What you're doing is subject to memory issues for large input files; I'd suggest taking a look at <a href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobj" rel="nofollow noreferrer"><code>shutil.copyfileobj</code></a> and related methods for doing this (which explicitly copy block by block, so peak memory consumption is fixed, not dependent on the size of the input file).</span>
<span class="comment-copy">There's a good discussion of this at <a href="http://stackoverflow.com/questions/7395542/is-explicitly-closing-files-important" title="is explicitly closing files important">stackoverflow.com/questions/7395542/â€¦</a></span>
<span class="comment-copy">What do you mean by "looks a bit more efficient"? If you mean the source code is shorter, well, that's certainly true. But it's not generally considered a priority to make the code as short as possible in Python. Much more important is readability. If you mean you think it will execute more efficiently, I'd say it probably won't make enough difference to matter, though to be sure you always want to measure. Why it shouldn't make much difference is that creating and assigning variables is cheap. In Python, all assignment amounts to setting a pointer.</span>
<span class="comment-copy">@JohnY - That is an excellent question. I think I had the assumption that "shorter" or "involving less intermediate steps" or "less variables" is good. You make a good point that it is actually readability that is more important (especially in a script with more code than my simple exercise). When you say assigning variables is cheap, I assume that means it will not cost much memory?</span>
<span class="comment-copy">@RoyCrielaard indeed - a "variable" is just a reference to data that must <i>already exist</i> in memory, it is the size of a memory pointer. Assignment is cheap both in terms of <i>size</i> and <i>speed</i>. Be aware that even in your first example you have file handle leak issues - if the writing crashes, for example, nothing will be closed.</span>
<span class="comment-copy"><i>"the number of files a process can keep open is limited (long ago the limit was about 20 on Unix"</i> I can hardly see this as an issue since on any modern Unix-like, the limit is so high the system will run out of memory or CPU time before the limit is reached.</span>
<span class="comment-copy">Thanks... I looked quickly but didn't find any hard numbers, so I went from memory. Added a little research now. (While the <i>hard</i> limits may be astronomical or unlimited, the number is usually limited with <code>ulimit</code> and the like.)</span>
<span class="comment-copy">Note: In the CPython reference interpreter, <code>open</code>ing and immediately <code>read</code>ing/<code>write</code>-ing to the returned file object (without storing a reference to the open file object) happens to be predictable and safe, but that is not the case on most other interpreters, and it's not a contractual guarantee of the language (just a side-effect of CPython reference counting). Using <code>with</code> is more scalable, portable, and predictable, so always use it, even if it seems like it works fine without it.</span>
<span class="comment-copy">Are you saying that <code>open(foo).read()</code> isn't reliable on other implementations? That's horrifying; which ones behave so?</span>
<span class="comment-copy">@RussellBorogove: Probably all the big ones; I don't know of any non-CPython implementations that do refcounting. A quick search shows <a href="http://pypy.org/compat.html" rel="nofollow noreferrer">official PyPy documentation</a> warning that <code>open("filename", "w").write("stuff")</code> will only write to the file once the GC runs a collection, which is a pretty similar case. (If by "isn't reliable", you mean something like "might crash" or "might give wrong results" rather than "might leak file handles", <code>open(foo).read()</code> isn't any more prone to that than <code>with open(foo) as f: contents = f.read()</code>.)</span>
<span class="comment-copy">@RussellBorogove <code>open(foo).read()</code> should be 'safe', as during the execution of <code>read()</code> the file object will still be referenced. But there's no guarantee about when (or in what order) the closes will happen when you have multiple file operations, just that it will be "some time after the file objects are not referenced". This means writes can be arbitrarily delayed (or possibly even lost if objects still referenced when the program exits don't have their finalizers run, which not even CPython absolutely guarantees: <a href="https://docs.python.org/2/reference/datamodel.html#object.__del__" rel="nofollow noreferrer">docs.python.org/2/reference/datamodel.html#object.__del__</a>)</span>
<span class="comment-copy">@jared You only need the <code>__future__</code> import in 2.5. 2.6 had <code>with</code> statements with a single context, 2.7 backported multiple contexts, as seen above, from version 3.1. Prior to 2.5, you're out of luck, however.</span>
<span class="comment-copy">Not just <i>closing</i> - <i>writing</i>! Buffers won't be flushed until the file is closed...</span>
<span class="comment-copy">Thanks, I've included it in the answer.</span>
<span class="comment-copy">@BoristheSpider Unless the file was opened with the <code>O_DIRECT</code> flag - kinda uncommon, though.</span>
<span class="comment-copy">@black: <code>O_DIRECT</code> does not provide guarantees of any kind; see <a href="http://linux.die.net/man/2/open" rel="nofollow noreferrer"><code>open(2)</code></a>.  You need <code>O_SYNC</code>/<code>O_DSYNC</code>.</span>
