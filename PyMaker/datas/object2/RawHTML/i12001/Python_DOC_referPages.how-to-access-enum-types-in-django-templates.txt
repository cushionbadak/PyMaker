<div class="post-text" itemprop="text">
<p>I was having an issue where no matter what I did I couldn't access an IntEnum (from the enum34 lib) in my Django template.</p>
<p>I was able to get around it by converting it to a dict:</p>
<pre><code>def get_context_data(self, **kwargs):
    context = super(MyView, self).get_context_data(**kwargs)
    # Django templates don't play nice with Enums
    context['DEMOS'] = {d.name: d for d in DEMOS}
    # `context['DEMOS'] = DEMOS` doesn't work
    return context
</code></pre>
<p>These don't work when DEMO is an IntEnum, but do when DEMO is converted to a dict:</p>
<pre><code>{{ DEMO.FOO }}  # outputs nothing
{{ DEMO.FOO|default_if_none:'foo' }}  # outputs nothing
{{ DEMO.FOO.value }}  # outputs nothing
{% if DEMO.FOO == 1 %}  # no matter what I compare to, always False
</code></pre>
<p>Any ideas why? Is this a known issue?</p>
</div>
<div class="post-text" itemprop="text">
<p>A little more digging and I found the answer.</p>
<p>From <a href="https://docs.djangoproject.com/en/1.7/topics/templates/" rel="noreferrer">the website</a>:</p>
<blockquote>
<p>Technically, when the template system encounters a dot, it tries the following lookups, in this order:</p>
<p>Dictionary lookup</p>
<p>Attribute or method lookup</p>
<p>Numeric index lookup</p>
<p>If the resulting value is callable, it is called with no arguments. The result of the call becomes the template value.</p>
</blockquote>
<p>That last line should say:</p>
<blockquote>
<p>If any of the resulting/intermediate values is callable, ...</p>
</blockquote>
<p>Stepping through that process:</p>
<ul>
<li><p>lookup <code>'DEMOS'</code> in the <code>context</code>, get <code>&lt;enum 'DEMOS'&gt;</code></p></li>
<li><p>check if it is callable (it is)</p></li>
<li><p>call it with no arguments</p></li>
<li><p>get a <code>TypeError</code></p></li>
</ul>
<p>So the problem is that an <code>Enum</code> class is callable, and the templating system will try to call it, which will raise an error and abort (returning an empty string: <code>''</code>).</p>
<p>However, there is a way around that problem.
<code>django.templates.base</code>'s calling code contains the following
guard condition:</p>
<pre><code>if getattr(current, 'do_not_call_in_templates', False):
    pass
</code></pre>
<p>The code checks for an attribute called <code>do_not_call_in_templates</code>, and if <code>True</code> then it will skip the call portion, which should solve the problem.</p>
<p>Using Python's <code>Enum</code> (or the <a href="https://pypi.python.org/pypi/enum34" rel="noreferrer"><code>enum34</code> backport</a>) the simplest way will be to use a decorator.  If Django doesn't already have one for this purpose, you can roll your own easily enough:</p>
<pre><code>def forDjango(cls):
    cls.do_not_call_in_templates = True
    return cls
</code></pre>
<p>and then decorate your <code>Enum</code>:</p>
<pre><code>@forDjango
class DEMOS(Enum):
    eggs = 'runny'
    spam = 'hard'
    cheese = 'smelly'
</code></pre>
<p>The additional attribute does not interfere with your set of 
Enum constants, because Enums are fixed once defined.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using Django's <code>Enum</code> you can use <code>__members__</code> property:</p>
<pre><code>context['DEMOS'] = DEMOS.__members__
</code></pre>
<p><a href="https://docs.python.org/3/library/enum.html#iteration" rel="nofollow noreferrer">Reference</a></p>
</div>
<span class="comment-copy">I just updated my question with a clarification.</span>
<span class="comment-copy">@Se√°nHayes: Found answer, updated question.</span>
<span class="comment-copy">@EthanFurman What if you want to <code>DEMOS.eggs.name</code> ?  It seems that Django tries to call with the next <code>.</code> ?</span>
<span class="comment-copy">Never mind to previous question, it works as expected.  Thanks for the answer.</span>
