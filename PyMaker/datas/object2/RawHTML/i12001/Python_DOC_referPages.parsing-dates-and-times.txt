<div class="post-text" itemprop="text">
<p>I'm trying to tokenize strings like <code>month/year/day T hour:minute</code> to <code>['month', '/', 'year', '/', 'day', ' T ', 'hour', ':', 'minute']</code>, but have no luck with the regex I am trying. Could anyone please shed some light on this and let me know what's wrong?</p>
<pre><code>&gt;&gt;&gt; _tokenize_regex = 'year|month|day|hour|minute|second|.+'
&gt;&gt;&gt; re.findall(_tokenize_regex, 'month/year/day T hour:minute')
['month', '/year/day T hour:minute']
</code></pre>
<p>The last option <code>.+</code> finds the 2nd <code>findall</code>-result item, but I would have thought these options are ranked, so that <code>.+</code> only matches if none of the others do...</p>
<p>More examples:</p>
<pre><code>'month.year somestring' -&gt; ['month', '.', 'year', ' somestring']
'year-month-day hour:minute.second' -&gt; ['year', '-', 'month', '-', 'day', ' ', 'hour', ':', 'minute', '.', 'second']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about using <code>\w+</code> to match words, and <code>[^\w\s]+</code> to match non-word, non-space characters?</p>
<pre><code>&gt;&gt;&gt; re.findall(r'\w+|[^\w\s]+', 'month/year/day T hour:minute')
['month', '/', 'year', '/', 'day', 'T', 'hour', ':', 'minute']
</code></pre>
<hr/>
<p><code>/</code> matches none of <code>year</code>, <code>month</code>, ... <code>second</code>, but matches <code>.</code>. <code>.+</code> matches up to the end of the string.</p>
<p><strong>UPDATE</strong></p>
<p>alternative approach using <code>re.split</code> with captured group to preserve separtors:</p>
<pre><code>list(filter(None,
    re.split(r'(month|year|day|hour|minute|second|[^\w\s]+)', text)
))
</code></pre>
<p>exmaple:</p>
<pre><code>&gt;&gt;&gt; import re 
&gt;&gt;&gt; def tokenize(text):
...     tokens = re.split(r'(month|year|day|hour|minute|second|[^\w\s]+)', text)
...     return list(filter(None, tokens))
... 
&gt;&gt;&gt; tokenize('month/year/day T hour:minute') 
['month', '/', 'year', '/', 'day', ' T ', 'hour', ':', 'minute']
&gt;&gt;&gt; tokenize('month.year somestring') 
['month', '.', 'year', ' somestring']
&gt;&gt;&gt; tokenize('year-month-day hour:minute.second') 
['year', '-', 'month', '-', 'day', ' ', 'hour', ':', 'minute', '.', 'second']
</code></pre>
<p><strong>UPDATE 2</strong></p>
<p><code>re.findall</code> with <a href="http://www.regular-expressions.info/lookaround.html" rel="nofollow">negative look-ahead assertion</a>:</p>
<pre><code>re.findall(
    r'[^\w\s]+|\s+(?!(?:month|year|day|hour|minute|second))\w*\s*|\s+|\w+',
    text
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem in your regular expression is the <code>.+</code>. In particular, after <code>month</code> is matched, the remaining string is matched against <code>year|month|day|hour|minute|second|.+</code>. The only expression that matches the remaining string is <code>.+</code>. But since this is greedy, it matches the rest of the string.</p>
<p>Based on what I think you're trying to do, you should swap the <code>.</code> out for <code>[/ T:]</code>.</p>
<p>Also, if you're actually trying to match timestamp strings, you should consider using <code>strptime</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not everything is best done in one line with a messy regex in python. You could try doing this in steps</p>
<pre><code>&gt;&gt;&gt; s = 'month/year/day T hour:minute'
&gt;&gt;&gt; date,t,time = s.partition(' T ')
&gt;&gt;&gt; month, year, day = date.split('/')
&gt;&gt;&gt; hours, minutes = time.split(':')
&gt;&gt;&gt; month, year, day, hours, minutes
('month', 'year', 'day', 'hour', 'minute')
</code></pre>
<p>For consistency with your expected output you can define separators and use those instead of strings in the partition and split functions.</p>
<pre><code>dateSeparator = '/'
timeSeparator = ':'
tSeperator = ' T '
</code></pre>
<p>Variable names are nicer to work with than list indices and <em>self-documenting</em> for the next person who looks at your code. You can always form the list yourself.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are working with real dates you may need to check whether it is a real date o just a combination of digits. I can recommend use special <code>datetime</code> module which can parse dates and check them. Like this:</p>
<pre><code>    &gt;&gt;&gt; import datetime
    &gt;&gt;&gt; s='16/2016/03 T 23:52'
    &gt;&gt;&gt; d = datetime.datetime.strptime(s, '%d/%Y/%m T %H:%M')
    &gt;&gt;&gt; type(d)
    &lt;class 'datetime.datetime'&gt;
    &gt;&gt;&gt; print(d)
    2016-03-16 23:52:00
</code></pre>
<p>Here you get special datetime object which is very comfortable for operations with dates. More info and examples are here: <a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior" rel="nofollow">https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior</a></p>
</div>
<span class="comment-copy">Consider <a href="https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior" rel="nofollow noreferrer">datetime.strptime</a> for all your datetime parsing needs.</span>
<span class="comment-copy">@msw: The format is given as the above grammar, not in the format <code>datetime.strptime</code> requires.</span>
<span class="comment-copy">You do not provide a possibility for the <code>/</code> to match, so everything is eaten up by the <code>.+</code> at the end. As it is greedy by default, this is why after <code>month</code> everything is in just one group, see <a href="https://regex101.com/r/vG4hA6/1" rel="nofollow noreferrer">here for a demonstration.</a></span>
<span class="comment-copy">But what about <code>.+</code>? Wouldn't that "eat" <code>/</code>? (nice site, btw.)</span>
<span class="comment-copy">@orange: It does and this is exactly the problem. At <code>/</code>, the engine does not find an appropriate alternative and thus takes <code>.+</code>. This expression is greedy by default and takes <b>the rest of string</b> (remember, the <code>.</code> matches any character except newlines, so there is no need to look for an alternative here). Solution: provide something for the backslash that only matches these (e.g. <code>[/]</code>) or use <code>str.split()</code>.</span>
<span class="comment-copy">I'd expect <code>' T '</code> to be returned as 6nd item (1-based counting), but your result returns <code>'T'</code> without the spaces. Unfortunately, your approach wouldn't work if you have arbitrary words (not year, month...) in the string that are combined with non-words as they wouldn't be returned as one string.</span>
<span class="comment-copy">@orange, You can use this regular expression, then: <code>r'\w+|\s+T\s+|[^\w\s]+'</code> or <code>r'\w+|\s+[A-Z]\s+|[^\w\s]+'</code></span>
<span class="comment-copy">@orange, Could you present another example with expected result? I will come up with different approach according to the example. Thank you for your feedback.</span>
<span class="comment-copy">I've added some more test cases.</span>
<span class="comment-copy">@orange, I updated the answer with different approach. Please check it out.</span>
<span class="comment-copy">I missed the comment below your code. Since you already noticed that it's the <code>.+</code> that's the problem, I'll put the emphasis on the greedy part. You could change this to <code>.+?</code> to make it not greedy, but then it would only ever match a single character at a time, so that also doesn't do what you want.</span>
<span class="comment-copy">Thanks. <code>.+?</code> is the closest to the desired outcome so far.</span>
