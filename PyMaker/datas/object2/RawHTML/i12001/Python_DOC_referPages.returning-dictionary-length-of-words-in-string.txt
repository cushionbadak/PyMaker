<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/35967547/adding-more-than-one-value-to-dictionary-when-looping-through-string">Adding more than one value to dictionary when looping through string</a>
<span class="question-originals-answer-count">
                    7 answers
                </span>
</li>
</ul>
</div>
<p>I need to build a function that takes as input a string and returns a dictionary.<br/>
The keys are numbers and the values are lists that contain the unique words that have a number of letters equal to the keys.<br/>
For example, if the input function is as follows:</p>
<pre><code>n_letter_dictionary("The way you see people is the way you treat them and the Way you treat them is what they become")
</code></pre>
<p>The function should return:</p>
<pre><code>{2: ['is'], 3: ['and', 'see', 'the', 'way', 'you'], 4: ['them', 'they', 'what'], 5: ['treat'], 6: ['become', 'people']}
</code></pre>
<p>The code that I have written is as follows:</p>
<pre><code>def n_letter_dictionary(my_string):
    my_string=my_string.lower().split()
    sample_dictionary={}
    for word in my_string:
        words=len(word)
        sample_dictionary[words]=word
    print(sample_dictionary)
    return sample_dictionary
</code></pre>
<p>The function is returning a dictionary as follows:</p>
<pre><code>{2: 'is', 3: 'you', 4: 'they', 5: 'treat', 6: 'become'}
</code></pre>
<p>The dictionary does not contain all the words with the same number of letters but is returning only the last one in the string.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you only want to store unique values in your <code>list</code>s, it actually makes more sense to use a <code>set</code>. Your code is almost right, you just need to make sure that you create a <code>set</code> if <code>words</code> isn't already a key in your dictionary, but that you add to the <code>set</code> if <code>words</code> is already a key in your dictionary. The following displays this:</p>
<pre><code>def n_letter_dictionary(my_string):
    my_string=my_string.lower().split()
    sample_dictionary={}
    for word in my_string:
        words=len(word)
        if words in sample_dictionary:
            sample_dictionary[words].add(word)
        else:
            sample_dictionary[words] = {word}
    print(sample_dictionary)
    return sample_dictionary

n_letter_dictionary("The way you see people is the way you treat them and the Way you treat them is what they become")
</code></pre>
<p><strong>Output</strong></p>
<pre><code>{2: set(['is']), 3: set(['and', 'the', 'see', 'you', 'way']), 
 4: set(['them', 'what', 'they']), 5: set(['treat']), 6: set(['become', 'people'])}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your code is that you just put the latest word into the dictionary. Instead, you have to add that word to some collection of words that have the same length. In your example, that is a <code>list</code>, but a <code>set</code> seems to be more appropriate, assuming order is not important.</p>
<pre><code>def n_letter_dictionary(my_string):
    my_string=my_string.lower().split()
    sample_dictionary={}
    for word in my_string:
        if len(word) not in sample_dictionary:
            sample_dictionary[len(word)] = set()
        sample_dictionary[len(word)].add(word)
    return sample_dictionary
</code></pre>
<p>You can make this a bit shorter by using a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict(set)</code></a>:</p>
<pre><code>    my_string=my_string.lower().split()
    sample_dictionary=collections.defaultdict(set)
    for word in my_string:
        sample_dictionary[len(word)].add(word)
    return dict(sample_dictionary)
</code></pre>
<p>Or use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a>, but for this you have to sort by length, first:</p>
<pre><code>    words_sorted = sorted(my_string.lower().split(), key=len)
    return {k: set(g) for k, g in itertools.groupby(words_sorted, key=len)}
</code></pre>
<p>Example (same result for each of the three implementations):</p>
<pre><code>&gt;&gt;&gt; n_letter_dictionary("The way you see people is the way you treat them and the Way you treat them is what they become")
{2: {'is'}, 3: {'way', 'the', 'you', 'see', 'and'}, 4: {'what', 'them', 'they'}, 5: {'treat'}, 6: {'become', 'people'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With <code>sample_dictionary[words]=word</code> you overwrite the current contents which you have put there so far. You need a list, and to that you can append.</p>
<p>Instead of that you need:</p>
<pre><code>if words in sample_dictionary.keys():
    sample_dictionary[words].append(word)
else:
    sample_dictionary[words]=[word]
</code></pre>
<p>So if there is a value to this key, I append to it, and else create a new list. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <code>defaultdict</code> found in the <code>collections</code> library. You can use it to create a default type for the value portion of your dictionary, in this case a list, and just append to it based on the length of your word.</p>
<pre><code>from collections import defaultdict

def n_letter_dictionary(my_string):
    my_dict = defaultdict(list)
    for word in my_string.split():
        my_dict[len(word)].append(word)

    return my_dict
</code></pre>
<p>You could still do this without defaultdict's, but would just be a little longer in length.</p>
<pre><code>def n_letter_dictionary(my_string):
    my_dict = {}
    for word in my_string.split():
        word_length = len(word)
        if word_length in my_dict:
            my_dict[word_length].append(word)
        else:
            my_dict[word_length] = [word]

    return my_dict
</code></pre>
<p>To ensure no duplicated in the values list, without using <code>set()</code>. Be warned though, if your value lists are large, and your input data is fairly unique, you'll experience a performance setback as checking if the value already exists in the list will only early exit once it is encountered.</p>
<pre><code>from collections import defaultdict

def n_letter_dictionary(my_string):
    my_dict = defaultdict(list)
    for word in my_string.split():
        if word not in my_dict[len(word)]:
            my_dict[len(word)].append(word)

    return my_dict

# without defaultdicts
def n_letter_dictionary(my_string):
    my_dict = {}                                  # Init an empty dict
    for word in my_string.split():                # Split the string and iterate over it
        word_length = len(word)                   # Get the length, also the key
        if word_length in my_dict:                # Check if the length is in the dict
            if word not in my_dict[word_length]:  # If the length exists as a key, but the word doesn't exist in the value list
                my_dict[word_length].append(word) # Add the word
        else:
            my_dict[word_length] = [word]         # The length/key doesn't exist, so you can safely add it without checking for its existence
</code></pre>
<p>So if you have a high frequency of duplicates and a short list of words to scan through, this approach would be acceptable. If you had for example a list of randomly generated words with just permutations of alphabetic characters, causing the value list to bloat, scanning through them will become expensive.</p>
</div>
<div class="post-text" itemprop="text">
<p>The shortest solution I came up with uses a <code>defaultdict</code>:</p>
<pre><code>from collections import defaultdict

sentence = ("The way you see people is the way you treat them"
            " and the Way you treat them is what they become")
</code></pre>
<p>Now the algorithm:</p>
<pre><code>wordsOfLength = defaultdict(list)
for word in sentence.split():
    wordsOfLength[len(word)].append(word)
</code></pre>
<p>Now <code>wordsOfLength</code> will hold the desired dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>itertools groupby</code> is the perfect tools for this.</p>
<pre><code>from itertools import groupby
def n_letter_dictionary(string):
    result = {}
    for key, group in groupby(sorted(string.split(), key = lambda x: len(x)), lambda x: len(x)):
        result[key] = list(group)
    return result
</code></pre>
<p>print n_letter_dictionary("The way you see people is the way you treat them and the Way you treat them is what they become")</p>
<pre><code># {2: ['is', 'is'], 3: ['The', 'way', 'you', 'see', 'the', 'way', 'you', 'and', 'the', 'Way', 'you'], 4: ['them', 'them', 'what', 'they'], 5: ['treat', 'treat'], 6: ['people', 'become']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>my_string="a aa bb ccc a bb".lower().split()
sample_dictionary={}
for word in my_string:
    words=len(word)
    if words not in sample_dictionary:
        sample_dictionary[words] = []
    sample_dictionary[words].append(word)
print(sample_dictionary)
</code></pre>
</div>
<span class="comment-copy">oh, this is better, our other solutions will raise KeyError...</span>
<span class="comment-copy">how to sort the list ['the', 'way', 'you', 'see', 'the', 'way', 'you', 'and', 'the', 'way', 'you']</span>
<span class="comment-copy">just do <code>some_list.sort()</code> if you want to have it alphabetically</span>
<span class="comment-copy">Quite right, of course it makes more sense to remove duplicates!</span>
<span class="comment-copy">Yup, and you don't actually require the <code>.keys()</code></span>
<span class="comment-copy">Hi, Thanks a lot for the help. Still, i am getting repeating values for keys already present in the dictionary. Do you know a way to prevent repeating words without using set()?</span>
<span class="comment-copy">Why don't you want to use the set()? Well, there is a way, of course. Replace the <code>else:</code> by <code>elif word not in sample_dictionary[words]:</code> -- then it will check this condition</span>
<span class="comment-copy">Thanks a lot, still i am getting repeating values for keys already present in the dictionary. Is there a way to remove repeating words without using set()?</span>
<span class="comment-copy">I added a section on ensuring no duplicates without using <code>set()</code>.</span>
<span class="comment-copy">I am trying to do it using your 1st method without the defaultdict's, by adding an 'if word not in my_dict' after 'for word in my_string.split():', but i am still getting the same output with repeating words. Could you help me with your the method without the defaultdict's?</span>
<span class="comment-copy">I have added an example without <code>defaultdict</code> but with unique results in the list without using <code>set()</code>. If you had <code>if word not in my_dict</code> that would always return <code>True</code> as <code>word</code> is in the value and your statement is only checking the keys of <code>my_dict</code>.</span>
<span class="comment-copy">Indeed, let me correct that swiftly.</span>
<span class="comment-copy">Also, <code>key = lambda x: len(x)</code> is the same as just <code>key=len</code> ;-)</span>
<span class="comment-copy">Yes, noticed that, Thanks !</span>
<span class="comment-copy">Sorting the things is unnecessary effort just to please <code>groupby</code>.  Reconsider that aspect.</span>
<span class="comment-copy">Reconsider the name of the variable <code>words</code>.  It's rather a <code>wordLength</code> or similar.</span>
