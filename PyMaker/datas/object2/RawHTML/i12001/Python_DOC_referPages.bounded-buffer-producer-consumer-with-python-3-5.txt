<div class="post-text" itemprop="text">
<p>I'm writing the classic producer/consumer problem in Python 3.5 using a deque as buff and 2 process that should work in parallel but unfortunately only the producer works, while the consumer doesn't "consume".. where am I wrong? This is my code:</p>
<pre><code>from time import sleep
import random
from collections import deque
import multiprocessing

MAX_LEN = 10
buff = deque(maxlen=MAX_LEN)

class producer:
    while True:
        if len(buff) == MAX_LEN:
            print("Producer: The buff is full, waiting...")
            sleep(10)
        buff.append(random.randint(1,9))


class consumer:
    while True:
        print("Consumer: hi")
        if len(buff) == 0:
            print("Consumer: The buff is empty, waiting...")
            sleep(10)
        buff.pop()



if __name__ == '__main__':
    multiprocessing.Process(target=producer).start().join()
    multiprocessing.Process(target=consumer).start().join()
</code></pre>
<p>and the result of this is: </p>
<pre><code>Producer: The buff is full, waiting...
Producer: The buff is full, waiting...
Producer: The buff is full, waiting...
Producer: The buff is full, waiting...
Producer: The buff is full, waiting...
Producer: The buff is full, waiting...
^CTraceback (most recent call last):
  File "./boundedbuffer.py", line 9, in &lt;module&gt;
    class producer:
  File "./boundedbuffer.py", line 13, in producer
    sleep(10)
KeyboardInterrupt
</code></pre>
<p>Just for now I want to implement in this way, as an exercise, just to see if I understand the argument, although I know that it is not the most correct and that I should use semaphores or monitors. Maybe later I will try to implement it differently.
Thank you all in advance for your help and good evening :)</p>
</div>
<div class="post-text" itemprop="text">
<p>You have defined classes with <code>while True:</code> loops in their bodies.</p>
<p>The interpreter will execute the first while loop in your file forever.</p>
<p><code>multiprocessing.Process</code> expects a callable as its target argument, so if you change the producer and consumer classes to functions the <code>if __ name __ == __ main __ :</code> block will be executed (though you still may not get the outcome that you expect).</p>
<pre><code>def producer():
    while True:
        if len(buff) == MAX_LEN:
            print("Producer: The buff is full, waiting...")
            sleep(10)
        buff.append(random.randint(1,9))


def consumer():
    while True:
        print("Consumer: hi")
        if len(buff) == 0:
            print("Consumer: The buff is empty, waiting...")
            sleep(10)
        buff.pop()
</code></pre>
</div>
<span class="comment-copy">Unfortunately doesn't work.. I have the same problem.. what's wrong?</span>
<span class="comment-copy">You can make a class a callable by defining a __ call __ method.  You can't share a deque between processes - see <a href="http://stackoverflow.com/questions/27345332/process-vs-thread-with-regards-to-using-queue-deque-and-class-variable-for" title="process vs thread with regards to using queue deque and class variable for">stackoverflow.com/questions/27345332/…</a>.  Also read the multiprocessing documentation on shared state: <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">docs.python.org/3/library/…</a>.</span>
<span class="comment-copy">ok.. and how can i do it? I must use an Array?</span>
