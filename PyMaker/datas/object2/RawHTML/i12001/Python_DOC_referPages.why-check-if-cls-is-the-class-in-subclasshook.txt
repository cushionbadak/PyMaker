<div class="post-text" itemprop="text">
<p>In the <a href="https://docs.python.org/3/library/abc.html#abc.ABCMeta.__subclasshook__" rel="noreferrer">Python standard library documentation</a>, the example implementation of <code>__subclasshook__</code> is:</p>
<pre><code>class MyIterable(metaclass=ABCMeta):

[...]

@classmethod
def __subclasshook__(cls, C):
    if cls is MyIterable:
        if any("__iter__" in B.__dict__ for B in C.__mro__):
            return True
    return NotImplemented
</code></pre>
<p>CPython's implementation of <code>collections.abc</code> indeed follows this format for most of the <code>__subclasshook__</code> member functions it defines.
What is the purpose of explicitly checking the <code>cls</code> argument?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__subclasshook__</code> is inherited. The <code>cls is MyIterable</code> check ensures that concrete subclasses of <code>MyIterable</code> use the regular <code>issubclass</code> logic instead of checking for an <code>__iter__</code> method. Otherwise, for a class <code>MyConcreteIterable(MyIterable)</code>, you would have <code>issubclass(list, MyConcreteIterable)</code> returning <code>True</code>.</p>
</div>
<span class="comment-copy">Just to make sure, is this paraphrasing correct? The most likely case where <code>cls</code> is not the class is for a class deriving from the ABC which already cannot create instances of itself without providing implementations of the abstract methods, so in that case there's no reason for <code>__subclasshook__</code> to check for the methods.</span>
<span class="comment-copy">@Praxeolitic: No. If you had a class <code>MyConcreteIterable</code> subclassing <code>MyIterable</code>, and that <code>cls is MyIterable</code> check wasn't there, then <code>issubclass(list, MyConcreteIterable)</code> would return <code>True</code>.</span>
