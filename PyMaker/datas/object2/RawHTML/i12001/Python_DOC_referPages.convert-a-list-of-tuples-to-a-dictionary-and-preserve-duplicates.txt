<div class="post-text" itemprop="text">
<p>I'm trying to convert my list of tuples into a dict which contains the values at that location, joined into a list. <code>dict</code> does what I want, except it removes the duplicates, which is what I don't want!</p>
<p>Here's what happens:</p>
<pre><code>&gt;&gt;&gt; vals
[(5, u'3'), (5, u'3'), (8, u'1'), (8, u'1')]
&gt;&gt;&gt; dict(vals)
{8: u'1', 5: u'3'}
</code></pre>
<p>Here's what I want to happen</p>
<pre><code>&gt;&gt;&gt; vals
[(5, u'3'), (5, u'3'), (8, u'1'), (8, u'1')]
&gt;&gt;&gt; foo(vals)
{8: [u'1',u'1'], 5: [u'3',u'3']}
</code></pre>
<p>Is there some other python function (<code>foo</code> in the above case) that does this?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is easily done using <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow"><code>setdefault</code></a>:</p>
<pre><code>def foo(some_list):
    result = {}
    for k, v in some_list:
        result.setdefault(k, []).append(v)

    return result     
</code></pre>
<p>(Using <code>setdefault</code> is more efficient than using a <code>get(k, []) + [v]</code> as we do the append in place)</p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest the popular module collections and <strong>defaultdict</strong> in this matter.</p>
<pre><code>from collections import defaultdict
vals = [(5, u'3'), (5, u'3'), (8, u'1'), (8, u'1')]
def foo(lst):
    d = defaultdict(list)
    for key, value in lst:
        d[key].append(value)
    return d
print foo(vals)
# defaultdict(&lt;type 'list'&gt;, {8: [u'1', u'1'], 5: [u'3', u'3']})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The values of the <code>dict</code> should be lists,  which you allocate when the key does not exist, and which you append to if the key already exist.</p>
<pre><code>def foo(some_list):
  result = {}
  for k,v in some_list:
    if k in result:
      result[k].append(v)
    else:
      result[k] = [ v ]
  return result     
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <code>defaultdict</code>:</p>
<pre><code>from collections import defaultdict

vals = [(5, u'3'), (5, u'3'), (8, u'1'), (8, u'1')]

d = defaultdict(list)
for key, value in vals:
    d[key].append(value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this:</p>
<pre><code>def foo(vals):
    x = {}
    for k, v in vals:
        x[k] = x.get(k, []) + [v]
    return x
</code></pre>
<p>I use <code>x.get(k, [])</code> so that if <code>k</code> is already in <code>x</code>, we will add put <code>v</code> at the end of it, but if it is not, we will put <code>v</code> at the end of <code>[]</code> and use that for <code>x[k]</code>.  A longer, but faster way would be to check first if is there, and if it is, append to it.  This is faster because we don't create a new list each time:</p>
<pre><code>def foo(vals):
    x = {}
    for k, v in vals:
        if k in x:
            x[k].append(v)
        else:
            x[k] = [v]
</code></pre>
<p>You could also do it with a <code>try-except</code> block:</p>
<pre><code>def foo(vals):
    x = {}
    for k, v in vals:
        try:
            x[k].append(v)
        except KeyError:
            x[k] = [v]
</code></pre>
</div>
<span class="comment-copy">I must admit that this is better than my answer by a long shot. +1</span>
<span class="comment-copy">This approach is very inefficient if you're processing large lists as on every iteration you create a new list for the key by copying the old one.</span>
<span class="comment-copy">@donkopotamus: Okay; I edited. How's that?</span>
<span class="comment-copy">Much better :-).  The reason <code>setdefault</code> is still better for this sort of task (as opposed to your improved version) is that key lookup only needs to occur once.</span>
<span class="comment-copy">@donkopotamus: I definitely see that, and I agree; but I don't think it would be fair for me to steal your answer ;)</span>
