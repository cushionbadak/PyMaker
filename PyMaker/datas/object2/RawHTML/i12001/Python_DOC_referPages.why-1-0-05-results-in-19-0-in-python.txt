<div class="post-text" itemprop="text">
<p>I'm a new to python and I found a confusing result when using Python3.5.1 on my mac, I simply ran this command in my terminal </p>
<pre><code>    1 // 0.05
</code></pre>
<p>However, it printed 19.0 on my screen. From my point of view, it should be 20. Can someone explain what's happening here? I've already known that the '//' is similar to the math.floor() function. But I still can't get across to this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because the Python floating-point literal <code>0.05</code> represents a number very slightly larger than the mathematical value 0.05.</p>
<pre><code>&gt;&gt;&gt; '%.60f' % 0.05
'0.050000000000000002775557561562891351059079170227050781250000'
</code></pre>
<p><code>//</code> is floor division, meaning that the result is the largest integer <code>n</code> such that <code>n</code> times the divisor is less than or equal to the dividend. Since 20 times 0.05000000000000000277555756156289135105907917022705078125 is larger than 1, this means the correct result is 19.</p>
<p>As for <em>why</em> the Python literal <code>0.05</code> doesn't represent the number 0.05, as well as many other things about floating point, see <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="nofollow">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a></p>
</div>
<div class="post-text" itemprop="text">
<p>0.05 is not exactly representable in floating point. <code>"%0.20f" % 0.05</code> shows that 0.05 is stored as a value very slightly greater than the exact value:</p>
<pre><code>&gt;&gt;&gt; print "%0.20f" % 0.05
0.05000000000000000278
</code></pre>
<p>On the other hand <code>1/0.05</code> does appear to be exactly 20:</p>
<pre><code>&gt;&gt;&gt; print "%0.20f" % (1/0.05)
20.00000000000000000000
</code></pre>
<p>However all floating point values are rounded to double when stored but calculations are done to a higher precision. In this case it seems the floor operation performed by <code>1//0.05</code> is done at full internal precision hence it is rounded down.</p>
</div>
<div class="post-text" itemprop="text">
<p>As the previous answerers have correctly pointed out, the fraction 0.05 = 1/20 cannot be exactly represented with a finite number of base-two digits.  It works out to the repeating fraction 0.0000 1100 1100 1100... (much like 1/3 = 0.333... in familiar base-ten).</p>
<p>But this is not quite a complete answer to your question, because there's another bit of weirdness going on here:</p>
<pre><code>&gt;&gt;&gt; 1 / 0.05
20.0
&gt;&gt;&gt; 1 // 0.05
19.0
</code></pre>
<p>Using the “true division” operator <code>/</code> happens to give the expected answer <code>20.0</code>. You got lucky here: The rounding error in the division exactly cancels out the error in representing the value 0.05 itself.</p>
<p>But how come <code>1 // 0.05</code> returns 19?  Isn't <code>a // b</code> supposed to be the same as <code>math.floor(a /b)</code>?  Why the inconsistency between <code>/</code> and <code>//</code>?</p>
<p>Note that the <code>divmod</code> function is consistent with the <code>//</code> operator:</p>
<pre><code>&gt;&gt;&gt; divmod(1, 0.05)
(19.0, 0.04999999999999995)
</code></pre>
<p>This behavior can be explained by performing computing the floating-point division with exact rational arithmetic.  When you write the literal <code>0.05</code> in Python (on an IEEE 754-compliant platform), the actual value represented is 3602879701896397 / 72057594037927936 = 0.05000000000000000277555756156289135105907917022705078125.  This value happens to be slightly <strong>more</strong> than the intended 0.05, which means that its reciprocal will be slightly <strong>less</strong>.</p>
<p>To be precise, 72057594037927936 / 3602879701896397 = 19.999999999999998889776975374843521206126552300723564152465244707437044687...</p>
<p>So, <code>//</code> and <code>divmod</code> see an integer quotient of 19.  The remainder works out to 0.04999999999999994726440633030506432987749576568603515625, which is rounded for display as <code>0.04999999999999995</code>.  So, the <code>divmod</code> answer above is in fact good to 53-bit accuracy, given the original incorrect value of <code>0.05</code>.</p>
<p>But what about <code>/</code>?  Well, the true quotient 72057594037927936 / 3602879701896397 isn't representable as a <code>float</code>, so it must be rounded, either down to <code>20-2**-48</code> (an error of about 2.44e-15) or up to <code>20.0</code> (an error of about 1.11e-15).  And Python correctly picks the more accurate choice, <code>20.0</code>.</p>
<p>So, it seems that Python's floating-point division is internally done with high enough precision to know that <code>1 / 0.05</code> (that's the <code>float</code> literal <code>0.05</code>, not the exact decimal fraction 0.05), is actually <strong>less</strong> than 20, but the <code>float</code> type in itself is incapable of representing the difference.</p>
<p>At this point you may be thinking “So what?  I don't care that Python is giving a correct reciprocal to an incorrect value.  I want to know how to get the correct value in the first place.”  And the answer to that is either:</p>
<ul>
<li><a href="https://docs.python.org/3/library/decimal.html" rel="nofollow"><code>decimal.Decimal('0.05')</code></a> (and don't forget the quotes!)</li>
<li><a href="https://docs.python.org/3/library/fractions.html" rel="nofollow"><code>fractions.Fraction('0.05')</code></a> (Of course, you may also use the numerator-denominator arguments as <code>Fraction(1, 20)</code>, which is useful if you need to deal with non-decimal fractions like 1/3.)</li>
</ul>
</div>
<span class="comment-copy">It divides then rounds down. That is about it.</span>
<span class="comment-copy">@MarkyPython: There's more to it than that.  On my machine, <code>1 / 0.05</code> is <code>20.0</code>, but <code>1 // 0.05</code> is <code>19.0</code>.</span>
<span class="comment-copy">Long story short: don't <i>expect</i> any particular result when dealing with floating point numbers.</span>
<span class="comment-copy">Why was this reopened? IMO <a href="http://stackoverflow.com/q/588004/2301450">Is floating point math broken?</a> was a good dupe target.</span>
<span class="comment-copy">@vaultah I reopened it because I don't consider it to be a duplicate of <a href="http://stackoverflow.com/q/588004/2301450">stackoverflow.com/q/588004/2301450</a> . This question is specifically about how the floor division operator works. It's not a generic question about why floating point math is imprecise.</span>
<span class="comment-copy">Also, it does not return an <i>integer</i> in this case, but float.</span>
<span class="comment-copy">@AnttiHaapala: I did wonder whether I'd get away with that terminology. It returns a floating-point value that represents an integer. What it doesn't return, is the Python type <code>int</code> (or <code>long</code>), but I'm using the word "integer" here to mean the mathematical concept of an integer, not the Python type called <code>int</code>.</span>
<span class="comment-copy">@SteveJessop Thanks for your help, I really should have been careful with floating-point value in programming.</span>
