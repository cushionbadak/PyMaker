<div class="post-text" itemprop="text">
<p>I always thought that if I use a for loop like this:</p>
<pre><code>for line in lines:
    dosomething()
</code></pre>
<p>I will never make my list index out of range. However, I am wrong..</p>
<p>The purpose of my code is to output all subsets of the input set.</p>
<p>Example:</p>
<p>Input:</p>
<pre><code>[2,1,3]
</code></pre>
<p>Output:</p>
<pre><code>[[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
</code></pre>
<p>Here is the code:</p>
<pre><code>def bin_list(bit_len, list_len):
# To get a binary numbers list like this: 
# ['000', '001', '010', '011', '100', '101', '110', '111']
    list_Bin = [None] * list_len

    for i in range(list_len):
        extra_d = bit_len-len(bin(i)[2:])
        list_Bin[i] = '0'*extra_d + bin(i)[2:]

    return list_Bin

def subsets(nums):
    nums.sort()
    max_element = len(nums)
    size_subset = 2 ** max_element

    list_Bin = bin_list(max_element, size_subset)

    list_Result = [[None]*max_element for i in range(size_subset)]

    for i, Bin in enumerate(list_Bin):
        for j in range(max_element):
            if Bin[j] == '1':
                #1 list_Result[i][j] = nums[i]
                #2 list_Result[i].append(nums[i])

    print(list_Result)


nums = [1,2,3]
subsets(nums)
</code></pre>
<p>So my core concept is use a binary list to create the subset list.</p>
<p>For example, when I read 001 in Binary list. I will </p>
<h1>keep 3 due to the third bit being 1</h1>
<h1>remove 1, 2 due to the first and second bits being 0.</h1>
<p>So if I use 0-7 (Binary == 000-111) I can get all subset of [1,2,3].  </p>
<p>But I always get <code>IndexError: list index out of range</code>. No matter if I use </p>
<pre><code>#1 list_Result[i][j] = nums[i]
</code></pre>
<p>or</p>
<pre><code>#2 list_Result[i].append(nums[i])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The cause of your <code>IndexError</code> is that you got your indices mixed up. In your nested <code>for</code> loops in the <code>subsets</code> function <code>i</code> ranges over the number of subsets and <code>j</code> ranges over the number of elements in the <code>nums</code> set. But you attempt to access <code>nums[i]</code> when you <em>should</em> be doing <code>nums[j]</code>, so when <code>i</code> is greater than or equal to <code>len(nums)</code> you will be attempting to access beyond the end of the <code>nums</code> list, hence the <code>IndexError</code>. </p>
<hr/>
<p>Your code can be simplified a fair bit. There's no need to muck around with the <code>bin</code> function: you can tell <code>format</code> to format an integer in binary, with the desired length.</p>
<pre><code>def bin_list(bit_len):
    list_len = 2 ** bit_len
    return ['{0:0{1}b}'.format(i, bit_len) for i in range(list_len)]

def subsets(seq):
    all_subsets = []
    for bits in bin_list(len(seq)):
        s = [seq[i] for i, b in enumerate(bits) if b == '1']
        all_subsets.append(s)
    return all_subsets

print(subsets([1,2,3]))
print(subsets('ABCD'))
</code></pre>
<p><strong>output</strong></p>
<pre><code>[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
[[], ['D'], ['C'], ['C', 'D'], ['B'], ['B', 'D'], ['B', 'C'], ['B', 'C', 'D'], ['A'], ['A', 'D'], ['A', 'C'], ['A', 'C', 'D'], ['A', 'B'], ['A', 'B', 'D'], ['A', 'B', 'C'], ['A', 'B', 'C', 'D']]
</code></pre>
<p>I admit that <code>'{0:0{1}b}'.format(i, bit_len)</code> is a bit cryptic, so I'll try to explain it as simply as I can, freely quoting from the official Python 3 documentation for the <a href="https://docs.python.org/3/library/string.html#format-string-syntax" rel="nofollow">Format String Syntax</a>.</p>
<p>The expression <code>'{0:0{1}b}'.format(i, bit_len)</code> creates a string containing the binary representation of <code>i</code>. The created string is <code>bit_len</code> characters wide, padded on the left with zeroes, if necessary.</p>
<p>The <code>'{0:0{1}b}'</code> part is known as a format string. Format strings contain “replacement fields” surrounded by curly braces <code>{}</code>. This is a complicated example because it has a replacement field nested inside another replacement field.   </p>
<p>In a replacement field the item immediately following the <code>{</code> is called the field_name. It's used to specify which argument to <code>.format</code> is associated with this replacement field. The field_name can be the argument's name, its position, or it can be omitted (in Python 2.7 and later) and Python will just use the <code>.format</code> arguments in numerical order when its matching them up with replacement fields.</p>
<p>The field_name is optionally followed by a conversion field, which is preceded by an exclamation point <code>!</code>, and a format_spec (format specification), which is preceded by a colon <code>:</code>. These specify a non-default format for the replacement value. This particular format string doesn't have a conversion field, so the default conversion is used. </p>
<p>A format_spec ends in a letter which specifies the type of formatting we want. Our format_spec end in a <code>b</code> which says that we want to format an integer as binary. The number immediately preceding the <code>b</code> specifies how wide the resulting bit string should be; by putting a zero in front of that we're saying that we want the string to be padded with zeroes rather than with blank spaces. So a format_spec of <code>08b</code> would give us bit strings that are 8 chars wide (or wider if necessary to properly represent the argument), with short bit strings padded with zeroes. </p>
<p>But we need something fancier than that because we don't have a fixed bit string width - we want our bit strings to be <code>bit_len</code> characters wide. But that's ok, because the format syntax allows us to put a replacement field inside another replacement field! So instead of <code>08b</code> we have <code>0{1}b</code> and now the value of the argument in position 1 is used as the bit string width.</p>
<p>I mentioned earlier that the field_name can be the argument's name, so our original format expression can also be written as:</p>
<pre><code>'{val:0{width}b}'.format(val=i, width=bit_len)
</code></pre>
<p>I guess this form is a bit more readable than the original. :)</p>
<p>I also mentioned that the field_name can be omitted (in Python 2.7 and later), which would look like this:</p>
<pre><code>'{:0{}b}'.format(i, bit_len)
</code></pre>
<p>but I don't recommend doing that because although it's shorter it's even more cryptic than the original, IMHO.</p>
<hr/>
<p>However, we don't really need the bit strings in <code>bin_list</code>: we can just use bitwise operators on the subset's index.</p>
<pre><code>def subsets(seq):
    bit_len = len(seq)
    bitrange = range(bit_len)
    all_subsets = []
    for j in range(1 &lt;&lt; bit_len):
        s = [seq[i] for i in bitrange if j &amp; (1&lt;&lt;i)]
        all_subsets.append(s)
    return all_subsets

print(subsets([1,2,3]))
print(subsets('ABCD'))  
</code></pre>
<p><strong>output</strong></p>
<pre><code>[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
[[], ['A'], ['B'], ['A', 'B'], ['C'], ['A', 'C'], ['B', 'C'], ['A', 'B', 'C'], ['D'], ['A', 'D'], ['B', 'D'], ['A', 'B', 'D'], ['C', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]
</code></pre>
<p>This does produce the subsets in a different order, but it's not too hard to change that, and I think this order is more natural.</p>
<p>We can make the last version even more compact by using a nested list comprehension:</p>
<pre><code>def subsets(seq):
    bit_len = len(seq)
    bitrange = range(bit_len)
    return [[seq[i] for i in bitrange if j &amp; (1&lt;&lt;i)]
        for j in range(1 &lt;&lt; bit_len)]
</code></pre>
<hr/>
<p>FWIW, here's another way to make subsets. It's a bit inefficient, but it's ok for small input sequences. It generates the subsets in the same order as the previous version.</p>
<pre><code>def subsets(seq):
    z = [[]]
    for x in seq:
        z += [y + [x] for y in z]
    return z
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are getting an error because of the following:</p>
<ol>
<li><code>len(nums) == 3</code></li>
<li><code>size_subset == 2**3 == 8</code></li>
<li><code>nums[3]</code> is being accessed in the loop where <code>i</code> goes from <code>0</code> to <code>len[list_Bin]</code>.</li>
</ol>
<p>The solution is probably to access <code>nums[j]</code> instead of <code>nums[i]</code> since <code>j</code> goes from <code>0</code> to <code>len(nums)</code>.</p>
</div>
<span class="comment-copy">@MadPhysicist What do you mean?</span>
<span class="comment-copy">Seriously though, how have you debugged this thing?</span>
<span class="comment-copy">I have printed list_Bin to make sure the list is perfect and print Bin[j] which is also perfect. Besides, I print('*') in if Bin[j] == '1': to count the number is right</span>
<span class="comment-copy">Haha, sorry. I am not native speaker, so I though I might have make some stupid mistakes...</span>
<span class="comment-copy">You are mixing up variable i and j in your loops, try <code>list_Result[i][j] = nums[j]</code> to get a little closer.   <code>i</code> can be more than 3, which is the length of your list, therefore the indexerrorr.</span>
<span class="comment-copy">I am still understanding your code. This really help be become a better programmer!</span>
<span class="comment-copy">Can I ask you what   '{0:0{1}b}'.format(i, bit_len)  means? I really cannot understand what it is. Thank you :)</span>
<span class="comment-copy">@MarsLee: Sure! I've added some more info to my answer.</span>
<span class="comment-copy">This is super clear! Really thank you for spend extra time explaining this for me. I learn a lots! Thank you :)</span>
