<div class="post-text" itemprop="text">
<p>I've been writing a <a href="https://en.wikipedia.org/wiki/MUD" rel="nofollow">MUD</a> in python, using asyncio.Protocol, however I have a problem with when users close their client (typically a terminal, since you connect via telnet) without disconnecting properly.  </p>
<p>The server doesn't recognize the user as disconnected, and they remain in the game.  </p>
<p>The problem only occurs when the client is connected remotely (for some reason, maybe someone can explain...) it doesn't happen when connecting from the localhost.  </p>
<p>Is there a neat way to check a user is still actually connected (without additional software client-side), or on failing that how do I incorporate a timeout?  </p>
<p>My Protocol looks something like this currently:  </p>
<pre><code>class User(Protocol):

    def connection_made(self, transport):
        self.transport = transport
        self.addr = transport.get_extra_info('peername')
        self.authd = False
        self.name = None
        self.admin = False
        self.room = None
        self.table = None
        self.db = None

        self.flags = []

        print("Connected: {}".format(self.addr))
        server.connected.append(self)

        actions['help'](self, ['welcome'])
        self.get_prompt()

    def data_received(self, data):
        msg = data.decode().strip()
        args = msg.split()

        if self.authd is False:
            actions['login'](self, args)
            return

        if msg:
            if args[0] in self.db.aliases:
                args[0] = str(self.db.aliases[args[0]])
                msg = ' '.join(args)
                args = msg.split()

            if msg[0] in server.channels:
                ch = db.session.query(db.models.Channel).get(msg[0])
                if msg[1] =='@':
                    channels.send_to_channel(self, ch, msg[2:], do_emote=True)
                else:
                    channels.send_to_channel(self, ch, msg[1:])
                self.get_prompt()
                return

            if args[0] in actions:
                if self.is_frozen():
                    self.send_to_self("You're frozen solid!")
                else:
                    actions[args[0]](self, args[1:] if len(args) &gt; 1 else None)
                self.get_prompt()
                return
            self.send_to_self("Huh?")
        else:
            if self.table is not None:
                actions['table'](self, None)
            elif self.room is not None:
                actions['look'](self, None)

    def send_to_self(self, msg):
        msg = "\r\n" + msg
        msg = colourify(msg)
        self.transport.write(msg.encode())

    @staticmethod
    def send_to_user(user, msg):
        msg = "\r\n"+msg
        msg = colourify(msg)
        user.transport.write(msg.encode())

    @staticmethod
    def send_to_users(users, msg):
        msg = "\r\n"+msg
        msg = colourify(msg)
        for user in users:
            user.transport.write(msg.encode())

    def connection_lost(self, ex):
        print("Disconnected: {}".format(self.addr))
        server.connected.remove(self)

        if self.authd:
            self.save()
            server.users.remove(self)
            self.room.occupants.remove(self)
</code></pre>
<p><em>Note: I've chopped a lot of superfluous stuff out. If you want the full code, it's <a href="https://github.com/NixonInnes/mtgmud/blob/master/app/mud/user.py" rel="nofollow">here.</a></em></p>
</div>
<div class="post-text" itemprop="text">
<p>You may schedule a new timeout handler on every <code>data_received()</code> call (with cancelling previous timeout handler, sure). I found the approach too cumbersome.</p>
<p>Or, as an option, switch to <a href="https://docs.python.org/3/library/asyncio-stream.html" rel="nofollow">asyncio streams</a> -- you may use <code>asyncio.wait_for</code> or brand new not released yet <code>asyncio.timeout</code>.</p>
</div>
<span class="comment-copy">It seems that <code>asyncio.timeout</code> was cancelled — see <a href="https://mail.python.org/pipermail/async-sig/2016-June/000033.html" rel="nofollow noreferrer">Async-sig asyncio.timeout() is not portable</a> and <a href="https://github.com/python/asyncio/issues/392" rel="nofollow noreferrer">Resurrect asyncio.timeout() context manager · Issue #392 · python/asyncio</a></span>
<span class="comment-copy"><code>asyncio.timeout</code> was extracted into <code>async_timeout</code> library. It doesn't work with tornado because tornado is not fully compatible with asyncio (there are plans to fix it in tornado 5)</span>
