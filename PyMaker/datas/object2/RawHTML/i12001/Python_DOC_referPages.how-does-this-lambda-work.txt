<div class="post-text" itemprop="text">
<pre><code>garbled = "IXXX aXXmX aXXXnXoXXXXXtXhXeXXXXrX sXXXXeXcXXXrXeXt mXXeXsXXXsXaXXXXXXgXeX!XX"
message = filter(lambda x: x != "X",garbled)
print message

I am another secret message!
</code></pre>
<p>How in the world does this work ? help me understand</p>
<pre><code>list = range(1,101)    
print filter(lambda x:x&gt;30 and x&lt;70, list)

[31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69]
</code></pre>
<p>I understand how this works , but not the first one.</p>
</div>
<div class="post-text" itemprop="text">
<p>Considering that you <em>do</em> understand the second example, but <em>not</em> the first example that is effectively identical, I think the source of your confusion is that you don't realize that strings can be iterated over in Python in exactly the same way as lists can.</p>
<p>Here's a simple example:</p>
<pre><code>&gt;&gt;&gt; for character in 'Hello': print('-&gt;', character, '&lt;-')
... 
-&gt; H &lt;-
-&gt; e &lt;-
-&gt; l &lt;-
-&gt; l &lt;-
-&gt; o &lt;-
</code></pre>
<p>Think of strings in Python as a "string of characters" or a "list of characters" (the difference being that strings are immutable, to "tuple of characters" would actually be more appropriate, but doesn't sound as nice).</p>
<p>See the <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow">the documentation</a> for more information.</p>
<p>Whether this is a <em>feature</em> or a <em>bug</em> is somewhat controversial in the Python community, by the way, and many people proposed to change this for Python 3. The problem is that this can really bite you, consider:</p>
<pre><code>def my_function(list_expected):
    for item in list:
        do_something(item)
</code></pre>
<p>This is a common enough pattern, and you're expected to call it as `my_function(['Hello', 'World']).</p>
<p>But what if I forgot that this function expects a list? And I call it as <code>my_function('Hello')</code>? Depending on what <code>do_something(item)</code> does, you either get an error or some subtly wrong behaviour. Be on the lookout for this.</p>
<p>Personally, I don't like this Python feature much and would have preferred to loop <em>explicitly</em>...</p>
</div>
<div class="post-text" itemprop="text">
<p>You just have to break it down a bit. First you have <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow"><code>filter</code></a> which takes a function and an iterable and applies the function to each element in the iterable and drops anything the function returns <code>False</code> for.</p>
<p>In this case the function is the lambda which is just <code>x != "X"</code> which is equivalent to:</p>
<pre><code>def foo(x):
    return x != "X"
</code></pre>
<p>so any element in the iterable, which in this case is your input string <code>garbled</code>, that is equal to "X" will get removed.</p>
</div>
<span class="comment-copy">It filters out any character that's <code>X</code>...!?</span>
<span class="comment-copy">I think the source of your confusion is maybe that you don't realize that strings can be iterated over in Python in exactly the same way as lists can. Try running: <code>for character in "Hello": print(character)</code> and see what you get ;-)</span>
<span class="comment-copy">@deceze shouldn't it be checking if the first element IXXX != X and so on, then return empty set?</span>
<span class="comment-copy">@Carpetsmoker I see. It goes letter by letter rather than word by word. I get it now.</span>
<span class="comment-copy">It prints every char from <code>garbled</code> except <code>X</code>s.</span>
