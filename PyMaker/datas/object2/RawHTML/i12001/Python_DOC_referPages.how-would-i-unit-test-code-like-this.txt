<div class="post-text" itemprop="text">
<p>I have the following class and am currently testing it via running a file which calls the methods in this file. I then use a mixture of print statements and checking the blog to make sure the code has worked.</p>
<p>I'd really like to write some pytest unit tests for this and automate it all, but how can I do this? Also, if authentication doesn't exist or had become invalid it opens the browser and prompts the user to input the auth code. Later on this will be handled by a gui form. Pytest doesn't take user input, and rightly so; it wouldn't be automated.</p>
<pre><code>class BloggerInterface(object):
    """Connects to blogger api and authorises client."""

    def get_credentials(self):
        """Gets google api credentials, or generates new credentials
        if they don't exist or are invalid."""
        scope = 'https://www.googleapis.com/auth/blogger'

        flow = oauth2client.client.flow_from_clientsecrets(
                'client_secret.json', scope,
                redirect_uri='urn:ietf:wg:oauth:2.0:oob')

        storage = oauth2client.file.Storage('credentials.dat')
        credentials = storage.get()

        if not credentials or credentials.invalid:
            auth_uri = flow.step1_get_authorize_url()
            webbrowser.open(auth_uri)

            auth_code = input('Enter the auth code: ')
            credentials = flow.step2_exchange(auth_code)

            storage.put(credentials)

        return credentials

    def get_service(self):
        """Returns an authorised blogger api service."""
        credentials = self.get_credentials()
        http = httplib2.Http()
        http = credentials.authorize(http)
        service = apiclient.discovery.build('blogger', 'v3', http=http)

        return service

    def get_blog(self, blog_id):
        """Gets the details ofthe blog withthe id blog_id"""
        BlogDetails = collections.namedtuple('BlogDetails', 'blog_id, name, desc, url')

        conn = self.get_service()
        request = conn.blogs().get(blogId=blog_id, view='ADMIN')
        response = request.execute()

        name = response.get('name')
        desc = response.get('description')
        url = response.get('url')

        blog = BlogDetails(blog_id=blog_id, name=name, desc=desc, url=url)

        return blog

    def get_posts(self, blog_id, status='live'):
        """Gets all posts from the blog with the id blog_id"""
        posts = []

        conn = self.get_service()
        request = conn.posts().list(blogId=blog_id, view='ADMIN',
        status=status)

        #Responses are paginated, so a paging loop is required.
        while request:

            response = request.execute()

            for post in response.get('items', []):
                post_id = post.get('id')
                title = post.get('title')
                url = post.get('url')
                status = post.get('status')
                content = post.get('content')

                posts.append({'post_id':post_id, 'title':title, 'url':url,
                    'status':status, 'content':content})

            request = conn.posts().list_next(request, response)

        return posts

    def add_post(self, blog_id, post, is_draft=True):
        """Adds a new post to the blog with the id blog_id"""
        conn = self.get_service()

        #post is in the form {title, content, (labels), author_name, author_id.
        title, content, author_name, author_id, labels = post

        data = {
                'kind': 'blogger#post',
                'title': title,
                'content': content,
                'labels': labels,
                'author': {'displayName':author_name, 'id':author_id}
                }

        request = conn.posts().insert(blogId=blog_id, body=data,
                isDraft=is_draft)
        response = request.execute()
        post_id = response.get('id')

        return post_id
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't test the <code>oauth2client</code> or <code>webbrowser</code> projects. Test how <em>your code</em> reacts to input and output from other parts. Those are black boxes, which you replace with your own mocks, so you can see how your code responds to different return values.</p>
<p>Use the <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>unittest.mock</code> module</a> to produce the mocks. If you are using Python &lt; 3.3, install the <a href="https://pypi.python.org/pypi/mock" rel="nofollow noreferrer">backport <code>mock</code> project</a> to do so.</p>
<p>For example, for <code>BloggerInterface.get_credentials()</code>, you mock out <code>oauth2client.client.flow_from_clientsecrets()</code>, <code>oauth2client.file.Storage()</code>, <code>webbrowser.open()</code> and <code>input</code>. You can then play with the response from <code>storage.get()</code> to force your code to use <code>webbrowser.open()</code>, and test if your code correctly tried to open a webbrowser, and then called <code>storage.put()</code> to store the credentials:</p>
<pre><code>with mock.patch('oauth2client.client.flow_from_clientsecrets') as mockflow, \
        mock.patch('oauth2client.file.Storage') as MockStorage, \
        mock.patch('webbrowser.open') as mockwbopen, \
        mock.patch('yourmodule.input') as mockinput:
    # set the credentials to invalid
    storage = MockStorage.return_value
    credentials = storage.get.return_value
    credentials.invalid = True

    # run the method and see if we get what we want
    result = BloggerInterface().get_credentials()

    # check that the flow was initialised correctly
    mockflow.assert_called_with(
        'client_secret.json', 'https://www.googleapis.com/auth/blogger',
        redirect_uri='urn:ietf:wg:oauth:2.0:oob')
    MockStorage.assert_called_with('credentials.dat')

    # With invalid credentials, the code should obtain a auth url from the
    # flow, pass it to the browser. Then the authentication code should be taken
    # from input and passed back to the flow for exchange. Test these
    # interactions took place:
    flow.step1_get_authorize_url.assert_called_once_with()
    mockwbopen.assert_called_once_with(flow.step1_get_authorize_url.return_value)
    flow.step2_exchange.assert_called_once_with(mockinput.return_value)
    storage.put(flow.step2_exchange.return_value)
    assert result == flow.step2_exchange.return_value
</code></pre>
</div>
<span class="comment-copy">Ahhh, I see. I have a lot to learn about testing, this is interesting. Thank you. So only test what my code has direct control over, right?</span>
<span class="comment-copy">@JamalMoir: exactly. I added a sample test to my answer; the test asserts that the code executes the right steps; note that the return values are all abstract, you don't <i>care</i> what the real <code>oauth2client</code> code produces, nor does your code, you just pass on those values to something else.</span>
<span class="comment-copy">@JamalMoir: the mocks make this easy; you can assert that <code>flow.step1_get_authorize_url</code> was called, that its return value was given to <code>webbrowser.open()</code>, that whatever <code>input()</code> returned was given to <code>flow.step2_exchange()</code> and that the result of <i>that</i> call ends up in <code>storage.put()</code> and is returned.</span>
<span class="comment-copy">@JamalMoir: other, separate tests can then be added to test what happens if the user just hit enter and <code>input()</code> returns an empty string, etc.</span>
<span class="comment-copy">Oh wow, thank you so much.  I see, so this is how you do it. I've always wondered how to test these sorts of things. Brilliant.</span>
