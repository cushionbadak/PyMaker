<div class="post-text" itemprop="text">
<p>This is my project structure (Python 3.5.1.):</p>
<pre><code>a
├── b.py
└── __init__.py
</code></pre>
<h2>Case 1</h2>
<ul>
<li><p>File <code>b.py</code> is empty.</p></li>
<li><p>File <code>__init__.py</code> is:</p>
<pre><code>print(b)
</code></pre></li>
</ul>
<p>If we run <code>import a</code>, the output is:</p>
<pre><code>NameError: name 'b' is not defined
</code></pre>
<h2>Case 2</h2>
<ul>
<li><p>File <code>b.py</code> is empty.</p></li>
<li><p>File <code>__init__.py</code> is:</p>
<pre><code>import a.b
print(b)
</code></pre></li>
</ul>
<p>If we run <code>import a</code>, the output is:</p>
<pre><code>&lt;module 'a.b' from '/tmp/a/b.py'&gt;
</code></pre>
<h2>Question</h2>
<p>Why doesn't the program fail in Case 2?</p>
<p>Usually if we run <code>import a.b</code> then we can only reference it by <code>a.b</code>, not <code>b</code>. Hopefully somebody can help explain what's happening to the namespace in Case 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python adds modules as globals to the parent package after import.</p>
<p>So when you imported <code>a.b</code>, the name <code>b</code> was added as a global to the <code>a</code> module, created by <code>a/__init__.py</code>.</p>
<p>From the <a href="https://docs.python.org/3/reference/import.html#submodules" rel="nofollow">Python 3 <em>import system</em> documentation</a>:</p>
<blockquote>
<p>When a submodule is loaded using any mechanism (e.g. importlib APIs, the import or import-from statements, or built-in <code>__import__()</code>) a <strong>binding is placed in the parent module’s namespace to the submodule object</strong>. For example, if package <code>spam</code> has a submodule <code>foo</code>, after importing <code>spam.foo</code>, <code>spam</code> will have an attribute <code>foo</code> which is bound to the submodule.</p>
</blockquote>
<p>Bold emphasis mine. Note that the same applies to Python 2, but Python 3 made the process more explicit.</p>
</div>
<div class="post-text" itemprop="text">
<p>An <code>import</code> statement brings a module into scope. You imported <code>b</code>, so there it is, a module object.</p>
<p>Read the documentation for <a href="https://docs.python.org/3/reference/simple_stmts.html#import" rel="nofollow"><code>import</code></a>:</p>
<blockquote>
<p>The basic import statement (no from clause) is executed in two steps:</p>
<ul>
<li>find a module, loading and initializing it if necessary</li>
<li>define a name or names in the local namespace for the scope where the import statement occurs.</li>
</ul>
</blockquote>
<p>You didn't import <code>b</code> in the first case.</p>
</div>
<span class="comment-copy">I think it's probably because <code>b</code> is introduced to the namespace of <code>a</code> by the <code>import a.b</code> statement. But I'm not sure about the details. Nor do I know whether it's an explicitly supported feature.</span>
<span class="comment-copy">@shx2 Both <code>a</code> and <code>b</code>. <code>a</code> should be there. But why is <code>b</code> also there? The most logical thing I can guess is: <code>a</code> is introduced into the current scope, then <code>b</code> is introduced into the scope of <code>a</code>. But the current scope is the same as the scope of <code>a</code> when executing <code>a/__init__.py</code>. Need confirmation.</span>
<span class="comment-copy">@shx2: yes, that's the <i>point</i> of the question. Why is <code>b</code> there <i>too</i>? It was never explicitly imported. <code>import a.b</code> only adds <code>a</code>, normally.</span>
<span class="comment-copy">I wouldn't be very suprised if Case 1 fails. If you run <code>import a.b; print(b)</code> in a <code>__main__</code> script then it will fail. But it doesn't fail in Case 2 here.</span>
<span class="comment-copy">Because you wrote <code>import a.b</code> in Case 2...</span>
<span class="comment-copy">@BarryTheHatchet: <code>import a.b</code> binds the name <code>a</code> in a namespace. What is special here is that <code>b</code> is a submodule of <code>a</code> and thus the import internals set the name <code>b</code> in the namespace of <code>a</code>. That results in a global <code>b</code> in that the namespace of <code>a</code>, i.e. <code>__init__.py</code>. If this was <i>any other module</i> the name <code>b</code> would not have appeared like this.</span>
<span class="comment-copy">@BarryTheHatchet: In other words, <i>they didn't import <code>b</code> in the second case either</i>, but it was added <i>anyway</i>.</span>
