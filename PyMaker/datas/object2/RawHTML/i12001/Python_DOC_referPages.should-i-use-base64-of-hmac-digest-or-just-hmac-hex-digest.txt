<div class="post-text" itemprop="text">
<p><strong>Legend</strong></p>
<p>I expose an API which requires client to sign requests by sending two headers:</p>
<pre><code>Authorization: MyCompany access_key:&lt;signature&gt;
Unix-TimeStamp: &lt;unix utc timestamp in seconds&gt;
</code></pre>
<p>To create a signature part, the client should use a secret key issued by my API service.</p>
<p>In Python (Py3k) it could look like:</p>
<pre><code>import base64
import hmac
from hashlib import sha256
from datetime import datetime

UTF8 = 'utf-8'
AUTH_HEADER_PREFIX = 'MyCompany'

def create_signature(access_key, secret_key, message):
    new_hmac = hmac.new(bytes(secret_key, UTF8), digestmod=sha256)
    new_hmac.update(bytes(message, UTF8))
    signature_base64 = base64.b64encode(new_hmac.digest())
    return '{prefix} {access_key}:{signature}'.format(
        prefix=AUTH_HEADER_PREFIX,
        access_key=access_key,
        signature=str(signature_base64, UTF8).strip()
    )


if __name__ == '__main__':
    message = str(datetime.utcnow().timestamp())
    signature = create_signature('my access key', 'my secret key',  message)
    print(
        'Request headers are',
        'Authorization: {}'.format(signature),
        'Unix-Timestamp: {}'.format(message),
        sep='\n'
    )
    # For message='1457369891.672671', 
    # access_key='my access key' 
    # and secret_key='my secret key' will ouput:
    #
    # Request headers are
    # Authorization: MyCompany my access key:CUfIjOFtB43eSire0f5GJ2Q6N4dX3Mw0KMGVaf6plUI=
    # Unix-Timestamp: 1457369891.672671
</code></pre>
<p>I wondered if I could avoid dealing with encoding digest of bytes to Base64 and just use <a href="https://docs.python.org/3/library/hmac.html#hmac.HMAC.hexdigest" rel="nofollow"><code>HMAC.hexdigest()</code></a> to retrieve a string.
So that my function will change to:</p>
<pre><code>def create_signature(access_key, secret_key, message):
    new_hmac = hmac.new(bytes(secret_key, UTF8), digestmod=sha256)
    new_hmac.update(bytes(message, UTF8))
    signature = new_hmac.hexdigest()
    return '{prefix} {access_key}:{signature}'.format(
        prefix=AUTH_HEADER_PREFIX,
        access_key=access_key,
        signature=signature
    )
</code></pre>
<p>But then I found that <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html#ConstructingTheAuthenticationHeader" rel="nofollow">Amazon uses similar approach</a> as in my first code snippet:</p>
<pre><code>Authorization = "AWS" + " " + AWSAccessKeyId + ":" + Signature;

Signature = Base64( HMAC-SHA1( YourSecretAccessKeyID, UTF-8-Encoding-Of( StringToSign ) ) );
</code></pre>
<p>Seeing that Amazon doesn't use hex digest I stopped myself to move forward with it because maybe they know something I don't.</p>
<hr/>
<p><strong>Update</strong></p>
<p>I've measured a performance and found hex digest to be faster:</p>
<pre><code>import base64
import hmac
import string
from hashlib import sha256


UTF8 = 'utf-8'
MESSAGE = '1457369891.672671'
SECRET_KEY = 'my secret key'
NEW_HMAC = create_hmac()


def create_hmac():
    new_hmac = hmac.new(bytes(SECRET_KEY, UTF8), digestmod=sha256)
    new_hmac.update(bytes(MESSAGE, UTF8))
    return new_hmac


def base64_digest():
    return base64.b64encode(NEW_HMAC.digest())


def hex_digest():
    return NEW_HMAC.hexdigest()



if __name__ == '__main__':
    from timeit import timeit

    print(timeit('base64_digest()', number=1000000,
                  setup='from __main__ import base64_digest'))
    print(timeit('hex_digest()', number=1000000,
                 setup='from __main__ import hex_digest'))
</code></pre>
<p>Results with:</p>
<pre><code>3.136568891000934
2.3460130329913227
</code></pre>
<hr/>
<p><strong>Question #1</strong></p>
<p>Does someone know why do they stick to Base64 of bytes digest and don't use just hex digest? Is there some solid reason to keep using this approach over hex digest?</p>
<p><strong>Question #2</strong></p>
<p>According to <a href="https://tools.ietf.org/html/rfc2617#section-2" rel="nofollow">RFC2716</a> the format of <code>Authorization</code> header value when using Basic Authentication
is:</p>
<pre><code>Authorization: Base64(username:password)
</code></pre>
<p>So basically you wrap with Base64 two values (user's id and password) seprated by colon.</p>
<p>As you can see in my code snippet and in Amazon's documentation nor me, nor Amazon do that for own custom value of the <code>Authorization</code> header.
Would it be a better style to wrap the whole pair as <code>Base64(access_key:signature)</code> to stick closer to this RFC or it doesn't matter at all?</p>
</div>
<div class="post-text" itemprop="text">
<p>Amazon <strong>does</strong> use the hex digest in Signature Version 4.</p>
<blockquote>
<p><code>Authorization: AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20150830/us-east-1/iam/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=5d672d79c15b13162d9279b0855cfba6789a8edb4c82c400e06b5924a6f2b5d7</code></p>
<p><a href="http://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html" rel="nofollow">http://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html</a></p>
</blockquote>
<p>Your example is from Signature Version 2, the older algorithm, which does use Base-64 encoding for the signature (and which also is not supported in the newest AWS regions).</p>
<p>So, your concern that AWS knows something you don't is misplaced, since their newer algorithm uses it.</p>
<p>In the <code>Authorization:</code> header, it really doesn't make a difference other than a few extra octets.  </p>
<p>Where Base-64 gets messy is when the signature is passed in the query string, because <code>+</code> and (depending on who you ask) <code>/</code> and <code>=</code> require special handling -- they need to be url-escaped ("percent-encoded") as <code>%2B</code>, <code>%2F</code>, and <code>%3D</code> respectively... or you have to make accommodations for the possible variations on the server... or you have to require the use of a non-standard Base-64 alphabet, where <code>+</code> <code>/</code> <code>=</code> becomes <code>-</code> <code>_</code> <code>~</code> <a href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-canned-policy.html" rel="nofollow">the way CloudFront does it</a>.  (Personally, I find CloudFront's solution brilliant, but I digress... and this particular non-standard alphabet is only one of multiple non-standard options, all "solving" the same problem of magic characters in URLs with Base-64).</p>
<p>Go with hex-encoding.  </p>
<p>You will almost inevitably find would-be consumers of your API that find Base-64 to be "difficult." </p>
</div>
<span class="comment-copy">Base64 strings will be much shorter than hex, 44 vs. 64 characters in this case. If you control both sides of the transaction then either one should work.</span>
<span class="comment-copy">Thanks, @MarkRansom. Good point. Though I've just measured a performance and it looks like hexdigest is faster (see an Update section in the question).</span>
<span class="comment-copy">The encoding time is negligible compared to the HMAC itself.</span>
<span class="comment-copy">@kichik I'm totally agreed. Though it's about 30% of CPU time saving on this operation for each request on the client and on the server. :)</span>
<span class="comment-copy">That's 15% and on my machine I see 9%. I can't explain the big difference here. I would not expect it. Either way, that's just for the HMAC part. I wouldn't make decisions based on such a minor difference especially since you're talking about a network operation here.</span>
<span class="comment-copy">Ah, actually forgot to say about the url encoding in my question. Good point. This is one more thing that's pushing me to use hex so the client could easily sign the request in query string as well.</span>
<span class="comment-copy">So I went with the hex digest and published the code to help the civilization. :) <a href="https://pypi.python.org/pypi/signit/0.1.0" rel="nofollow noreferrer">pypi.python.org/pypi/signit/0.1.0</a></span>
