<div class="post-text" itemprop="text">
<p>What is the cleanest way to obtain the numeric prefix of a string in Python? </p>
<p>By "clean" I mean simple, short, readable. I couldn't care less about performance, and I suppose that it is hardly measurable in Python anyway.</p>
<p>For example:</p>
<p>Given the string <code>'123abc456def'</code>, what is the cleanest way to obtain the string <code>'123'</code>?</p>
<p>The code below obtains <code>'123456'</code>:</p>
<pre><code>input = '123abc456def'
output = ''.join(c for c in input if c in '0123456789')
</code></pre>
<p>So I am basically looking for some way to replace the <code>if</code> with a <code>while</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.takewhile"><code>itertools.takewhile</code></a> which will iterate over your string (the iterable argument) until it encounters the first item which returns <code>False</code> (by passing to predictor function): </p>
<pre><code>&gt;&gt;&gt; from itertools import takewhile
&gt;&gt;&gt; input = '123abc456def'
&gt;&gt;&gt; ''.join(takewhile(str.isdigit, input))
'123'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the simplest way to extract a list of numbers from a string:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; input = '123abc456def'
&gt;&gt;&gt; re.findall('\d+', s)
['123','456']
</code></pre>
<p>If you need a list of int's then you might use the following code:</p>
<pre><code>   &gt;&gt;&gt; map(int, re.findall('\d+', input ))
   [123,456]
</code></pre>
<p>And now you can access the first element [0] from the above list </p>
</div>
<div class="post-text" itemprop="text">
<p>Simpler version (leaving the other answer as there's some interesting debate about which approach is better)</p>
<pre><code>input[:-len(input.lstrip("0123456789"))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>input[:len(input) - len(input.lstrip("0123456789"))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is <em>my</em> way:</p>
<pre><code>output = input[:next((i for i,v in enumerate(input) if not v.isdigit()),None)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way, but not very efficient since it works through the whole string without <code>break</code> would be:</p>
<pre><code>input_string = '123abc456def'
[input_string[:c] for c in range(len(input_string)) if input_string[:c].isdigit()][-1]
</code></pre>
<p>This appends each substring with increasing size if it is a digit and then appends it. So the last element is the one you look for. Because it is the longest startstring that is still a digit.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use regex</p>
<pre><code>import re
initialNumber = re.match(r'(?P&lt;number&gt;\d+)', yourInput).group('number')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another regexp version strips away everything starting with the first non-digit:</p>
<pre><code>import re
output = re.sub('\D.*', '', input)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>input = '123abc456def'
output = re.findall(r'^\d+', input)
</code></pre>
<p>Will return <code>['123']</code> too.</p>
</div>
<span class="comment-copy">would regexp be an option?</span>
<span class="comment-copy">@MaxU: I was hoping that there would be a simple "string operation" that could save me the burden of regular expression, but if you think that there is no other alternative then yes.</span>
<span class="comment-copy">Are all of the prefixes 3 characters or does it vary?</span>
<span class="comment-copy">@AIG: No, it varies (otherwise, I would have just used <code>input[0:3]</code>).</span>
<span class="comment-copy">@ForceBru: Thank you. Here below there is an answer more suitable to my question than the accepted answer in the question that you have suggested as duplicate (i.e., the answer below is "cleaner"), so I will accept it here.</span>
<span class="comment-copy">Please vote to reopen this question. There are two suggested duplicates. One is a different question (!!!), and the other one is closed by itself, and in addition, the answer here matches my question better than the accepted answer to that (closed) question, since it addresses my requirement for the cleanest possible solution. Thank you.</span>
<span class="comment-copy">@barakmanos I just did that before I read your comment ;)</span>
<span class="comment-copy">Thank you very much. Can you please have a look at the solution proposed by @demented hedgehog below? It seems to be very "clean", though I would hate to unaccept your answer.</span>
<span class="comment-copy">@barakmanos I left a comment there. It's shorter but is not optimum in terms of memory use. It also used an indexing and two <code>len</code> function.</span>
<span class="comment-copy">I'll upvote any solution that looks like Haskell. This is definitely the "cleanest" solution in my opinion.</span>
<span class="comment-copy">That's a bold statement.  Though I think it's a good solution.</span>
<span class="comment-copy">Perhaps <code>match()</code> would be more suitable, since OP needs only the starting digits.</span>
<span class="comment-copy">This one is pythonic ;), but as I said <code>takewhile()</code> is more optimized in terms of memory use.</span>
<span class="comment-copy">That is true.  I'll have to take a second look at itertools.. I hadn't heard about takewhile till now.</span>
<span class="comment-copy">This is not an optimized approach in terms of memory use (specially when you are dealing with larger strings). Because you are creating a stripped string from the main string and load it in memory.</span>
<span class="comment-copy">Yes.  It's not particularly efficient but the post specifically doesn't care about performance and it is simple and in practice the performance won't usually matter.  You'd have to be using big strings to care.  There's overhead for example in compiling regular expressions too.  If you really care about speed do it in c.</span>
<span class="comment-copy">Also depends on what portion of the string is the prefix.. if it's a million digits followed by "x" your approach is going to be slow too.  Possibly slower cause you've got the copy as well as a bunch of function call overhead?  I'd be interested to see a timing comparison of our two approaches vs string length and prefix length.</span>
