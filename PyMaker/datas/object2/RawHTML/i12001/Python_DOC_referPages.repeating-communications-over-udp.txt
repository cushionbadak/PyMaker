<div class="post-text" itemprop="text">
<p>When creating a <a href="https://docs.python.org/3/library/socketserver.html#socketserver.TCPServer" rel="nofollow"><code>TCPServer</code></a> from the <a href="https://docs.python.org/3/library/socketserver.html#module-socketserver" rel="nofollow"><code>socketserver</code></a> module, a connection can be made and used continually for communication until one side execute a <a href="https://docs.python.org/3/library/socket.html#socket.socket.shutdown" rel="nofollow"><code>shutdown</code></a> command. Having written the following programs, it is unclear to me how to continue communicating with the server if (for various reasons) a <a href="https://docs.python.org/3/library/socketserver.html#socketserver.UDPServer" rel="nofollow"><code>UDPServer</code></a> is required for use. Should the client keep running the <a href="https://docs.python.org/3/library/socket.html#socket.socket.sendto" rel="nofollow"><code>sendto</code></a> and <a href="https://docs.python.org/3/library/socket.html#socket.socket.recv" rel="nofollow"><code>recv</code></a> methods as needed and pretend that the server will receive the message and return a reply?</p>
<hr/>
<p><strong>Client</strong></p>
<pre><code>import socket
import sys


def main():
    host, port = 'localhost', 10000
    data = ' '.join(sys.argv[1:])
    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    client.sendto(data.encode(), (host, port))
    received = client.recv(1 &lt;&lt; 12).decode()
    print('Sent:    ', data)
    print('Received:', received)


if __name__ == '__main__':
    main()
</code></pre>
<hr/>
<p><strong>Server</strong></p>
<pre><code>import socketserver


def main():
    host, port = 'localhost', 10000
    server = socketserver.UDPServer((host, port), UDPHandler)
    server.serve_forever()


class UDPHandler(socketserver.DatagramRequestHandler):

    def handle(self):
        data = self.rfile.read().strip()
        client, port = self.client_address
        print(client, 'wrote:', data)
        self.wfile.write(data.upper())


if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since no guaranteed connection exists when using datagrams, the client may continue sending messages to the server and attempt to receive replies. There is nothing special to do in terms of connecting, shutting down, or closing the socket. The server should use an appropriately written handler as before to receive and send client communications. The following examples demonstrate how to write such programs and include a command-line interface for specifying their parameters.</p>
<hr/>
<p><strong>UDPClient.py</strong></p>
<pre><code>#! /usr/bin/env python3
import argparse
import socket


def main():
    parser = argparse.ArgumentParser(description='Execute a UDP client demo.')
    parser.add_argument('host', type=str, help='computer where data is sent')
    parser.add_argument('port', type=int, help='location where server listens')
    arguments = parser.parse_args()
    address = arguments.host, arguments.port
    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    for _ in range(5):
        message = input('&gt;&gt;&gt; ').encode('ascii')
        client.sendto(message, address)
        response = client.recv(1 &lt;&lt; 12).decode('ascii')
        print(response)


if __name__ == '__main__':
    main()
</code></pre>
<hr/>
<p><strong>UDPServer.py</strong></p>
<pre><code>#! /usr/bin/env python3
import argparse
import socketserver


def main():
    parser = argparse.ArgumentParser(description='Execute a UDP server demo.')
    parser.add_argument('port', type=int, help='where the server will listen')
    arguments = parser.parse_args()
    host = socketserver.socket.gethostbyname(socketserver.socket.gethostname())
    address = host, arguments.port
    server = socketserver.ThreadingUDPServer(address, ClientRequestHandler)
    server.serve_forever()


class ClientRequestHandler(socketserver.DatagramRequestHandler):

    def handle(self):
        message = self.rfile.read().decode('ascii')
        print('Received:', message)
        response = 'Received: {}'.format(message).encode('ascii')
        self.wfile.write(response)


if __name__ == '__main__':
    main()
</code></pre>
</div>
