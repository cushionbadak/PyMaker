<div class="post-text" itemprop="text">
<p>So, I'm trying to speed up one routine by using the Multiprocessing module in Python. I want to be able to read several .csv files by splitting the job among several cores, for that I have:</p>
<pre><code>def csvreader(string):

  from numpy import genfromtxt;

  time,signal=np.genfromtxt(string, delimiter=',',unpack="true") 
  return time,signal
</code></pre>
<p>Then I call this function by saying:</p>
<pre><code>if __name__ == '__main__':
     for i in range(0,2):
        p = multiprocessing.Process(target=CSVReader.csvreader, args=(string_array[i],))
        p.start()
</code></pre>
<p>The thing is that this doesn't store any output. I have read all the forums online and seen that there might be a way with multiprocessing.queue but I don't understand it quite well.
Is there any simple and straightforward method?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your best bet are <code>multiprocessing.Queue</code> or <code>multiprocessing.Pipe</code>, which are designed exactly for this problem. They allow you to send data between processes in a safe and easy way.</p>
<p>If you'd like to return the output of your <code>csvreader</code> function, you should pass another argument to it, which is the <code>multiprocessing.Queue</code> through which the data will be sent back to the main process. Instead of <code>return</code>ing the values, place them on the queue, and the main process will retrieve them at some point later. If they're not ready when the process tries to get them, by default it will just block (wait) until they are available</p>
<p>Your function would now look like this:</p>
<pre><code>def cvsreader(string, q):
    q.put(np.genfromtxt(string, delimiter=',', unpack="true"))
</code></pre>
<p>The main routine would be:</p>
<pre><code>if __name__ == '__main__'
    q = multiprocessing.Queue()
    for i in range(2):
        p = multiprocessing.Process(target=csvreader, args=(string_array[i], q,))
        p.start()

# Do anything else you need in here

time=np.empty(2,dtype='object')
signal=np.empty(2,dtype='object')
for i in range(2):
    time[i], signal[i] = q.get() # Returns output or blocks until ready
    # Process my output
</code></pre>
<p>Note that you have to call <code>Queue.get()</code> for <em>each</em> item you want to return.</p>
<p>Have a look at the documentation on the <a href="https://docs.python.org/3/library/multiprocessing.html?highlight=multiprocessing#exchanging-objects-between-processes" rel="nofollow"><code>multiprocessing</code> module</a> for more examples and information.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using the example from <a href="https://docs.python.org/2/library/multiprocessing.html#introduction" rel="nofollow">the introduction to the documentation</a>:</p>
<pre><code>if __name__ == '__main__':
    pool = Pool(2)
    results = pool.map(CSVReader.csvreader, string_array[:2])
    print(results)
</code></pre>
</div>
<span class="comment-copy">Have you looked at <a href="https://docs.python.org/2/library/multiprocessing.html#introduction" rel="nofollow noreferrer">the introduction to the documentation</a>?</span>
<span class="comment-copy">Indeed I have. Call me dense but I was unable to fix my program up with that info.</span>
<span class="comment-copy">There's gotta be something missing in there, because everytime I run it, it gets stuck</span>
<span class="comment-copy">You're right, see my edit. You have to call the process's <code>start()</code> method.</span>
<span class="comment-copy">Actually now is stuck on an infinte loop because the items in the queue are not being consumed, any suggestion?</span>
<span class="comment-copy">Yep, I made another mistake. The <code>Queue</code> needs to be created outside the first loop.</span>
<span class="comment-copy">I have been scratching my head for two hours because of that hahaha. I made some minor changes to the code, which now should be perfect for anyone else. Thanks again!</span>
