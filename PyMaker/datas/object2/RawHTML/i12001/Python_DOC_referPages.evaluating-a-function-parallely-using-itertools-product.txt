<div class="post-text" itemprop="text">
<p>I have to evaluate a function (let's call it my_func()) that takes 8 parameters as input and returns a scalar upon different matrix computations. Since I don't have any constrains on my_func(), I have no choice but to brute force all possibilities which amounts to 8^8 = 16777216. I started off using itertools's product functions and passed the generated sequences to the my_func() sequentially. Kindly take a look at the sample of my code below, </p>
<p><strong>So far.....</strong></p>
<pre><code>from itertools import product
import numpy as np

def my_func(a,b,c,d,e,f,g,h): #Function that I have to evaluate
    #do some matrix computations and return some scalar q# 
    return q

def Evaluate():
    Range = [x for x in np.arange(0,3.60,0.5)] # A list that contains 8 elements
    it = itertools.product(Range, repeat=8) #Generate all possiblities
    Max = 0
    for i in it:
        Sum = my_func(*i)
        if Sum &gt; Max:
            Max = present
    return Max

Result = Evaluate() #Output
</code></pre>
<p><strong>Pitfalls...</strong></p>
<p>Unfortunately, executing the above code sequentially takes ages to produce the output. This is because my_func is quite heavy. I have no choice but to somehow parallelize this code so that I can take advantage of multiple processors available to run my code. </p>
<p><strong>Questions:</strong></p>
<p>Since itertools.product is a generator I cannot parallelize this to evaluate my_func() simultaneously for different sets of parameters. 
Is there any way I can parallelize the code? if no is the asnswer, should I abondon the idea of using itertools and try someting else?</p>
<p>Kindly help me find a solution.</p>
<p>Thanks for suggesting any ideas.</p>
<p>Cheers!!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can parallelize a generator ! You can use the <code>multiprocessing</code> library, which offers the <code>Pool</code> class which does exactly what you want. <a href="https://docs.python.org/3/library/multiprocessing.html#using-a-pool-of-workers" rel="nofollow" title="multiprocessing">Here</a> you can get more ample documentation, but essentially, what you want to do is :</p>
<pre><code>with Pool(processes=4) as pool:
  pool.map(my_func, itertools.product(Range, repeat=8))
</code></pre>
<p>You should look into the alternatives to <code>pool.map</code> to find the one which suits you most.</p>
</div>
<div class="post-text" itemprop="text">
<p>The number of cores you'll use is probably much smaller than  <em>8<sup>8</sup></em> .</p>
<p>This leads to the following parallallelization scheme. Call <a href="https://docs.python.org/2/library/multiprocessing.html#using-a-pool-of-workers" rel="nofollow"><code>multiprocessing.Pool.map</code></a> on</p>
<pre><code>itertools.product(&lt;all-combinations-of-first-2-or-3-parameters&gt;)
</code></pre>
<p>Within each process, perform the parallellization on the remaining parameters, and return only a single result - the best tuple of parameters found.</p>
<p>This will be much more efficient anyway than passing each of the <em>8<sup>8</sup></em> combinations. There's an overhead to these things.</p>
<p><strong>Example</strong></p>
<p>Say you decide to map over the first three parameters. Then your <code>product</code> is a sequence of triplets: <code>..., (1, 3, 2), ...</code>. You use something like <code>multiprocessing.Pool.map</code> on each such triplet, so let's consider it from the point of view of the function:</p>
<pre><code>def find_best_for_triplet(xyz):
    x, y, z = xyz[0], xyz[1], xyz[2]

    for ... in itertools.product(&lt;all-combinations-of-last-5-parameters&gt;)
        # Here you have all 8 of your parameters: x, y, z, and the last 5

    return xyz + (last-five-parameters) of the min
</code></pre>
<hr/>
<p>On a separate matter - in practice, the <a href="https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method" rel="nofollow">Nelder Mead method</a> works well on optimizing high-dimensional problems, and is much cheaper than brute force. You might wish to give an implementation of it a try.</p>
</div>
<span class="comment-copy">is the function that returns the scalar symmetric under index permutations? if I do f(1,0,0...,0) does it return the same as f(0,0,...,1)?</span>
<span class="comment-copy">Unfortunately, the scalar is not symmetric under permutations, I wish it would have been. The function returns different values for different sets of arguments.</span>
<span class="comment-copy">Your code appears to be missing a line, eg <code>for i in it:</code>. BTW, <code>my_func(*i)</code> is more compact than your call. Also consider <code>Range = [i/2 for i in range(8)]</code>; make that <code>i/2.</code> if your on Python 2 and not using <code>from __future__ import division</code>.</span>
<span class="comment-copy">@PM 2Ring thanks for the suggestions.  I have added that missing line to my code. cheers!!</span>
<span class="comment-copy">Thanks for the quick reply.  I noticed that by mapping  itertools.product(Range, repeat=8) to my_func, soon runs out of memory. I think all the 8^8 possibilities are generated, stored  and  then passed as chunks to different processors. Any workarounds?</span>
<span class="comment-copy">You may want to look into the answers given here : <a href="http://stackoverflow.com/questions/5318936/python-multiprocessing-pool-lazy-iteration" title="python multiprocessing pool lazy iteration">stackoverflow.com/questions/5318936/…</a> and here : <a href="http://stackoverflow.com/questions/14677287/multiprocessing-with-large-data" title="multiprocessing with large data">stackoverflow.com/questions/14677287/…</a></span>
<span class="comment-copy">Hello Dr. Tavory, Thanks for the help. Certainly passing 8^8 combinations  is a lot of overhead, in fact number of parameters will even go up to 10, then I have to brute-force 10^10 which is awful lot.  I read your answer several times but couldn't get my head around it. Are you suggesting to evaluate the function with only a subset of parameters (keeping the rest const) in a single process? Could you kindly explain a bit further in your answer?</span>
<span class="comment-copy">@Prdeep_nitro I've added a clarification/explanation. Let me know if you need something further.</span>
