<div class="post-text" itemprop="text">
<p>I am attempting to wrap an API with the following function. The API has end points that look similar to this:</p>
<pre><code>/users/{ids}
/users/{ids}/permissions
</code></pre>
<p>The idea is that I'll be able to pass a dictionary to my function that contains a list of <code>ids</code> and those will be formatted as the API expects:</p>
<pre><code>users = {'ids': [1, 2, 3, 5]}
call_api('/users/{ids}/permissions', users)
</code></pre>
<p>Then in <code>call_api</code>, I currently do something like this</p>
<pre><code>def call_api(url, data):
    for k, value in data.items():
        if "{" + key + "}" in url:      
            url = url.replace("{"+k+"}", ';'.join(str(x) for x in value))
            data.pop(k, None)
</code></pre>
<p>This works, but I can't imagine that <code>if</code> statement is efficient. </p>
<p>How can I improve it and have it work in both Python 2.7 and Python 3.5?</p>
<p>I've also been told that changing the dictionary while iterating is bad, but in my tests I've never had an issue. I am <code>pop</code>ing the value, because I later check if there are unexpected parameters (ie. anything left in <code>data</code>). Is what I'm doing now the right way?</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of modifying a dictionary as you iterate over it, creating another object to hold the unused keys is probably the way to go. In Python 3.4+, at least, removing keys during iteration will raise a 
<code>RuntimeError: dictionary changed size during iteration</code>.</p>
<pre><code>def call_api(url, data):
    unused_keys = set()
    for k, value in data.items():
        key_pattern = "{" + k + "}"
        if key_pattern in url:
            formatted_value = ';'.join(map(str, value))     
            url = url.replace(key_pattern, formatted_value)
        else:
            unused_keys.add(k)
</code></pre>
<p>Also, if you think that you're more likely to run into an unused key, reversing the conditions might be the way to go.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is the way to do it. First, the string is parsed for the keys. It then remembers all keys not used in the url and saves it in the side. Lastly, it formats the url with the given parameters of the dict. The function returns the unused variables and the formatted url. If you wish you can remove the unused variables from the dict by iterating over them and deleting from the dict.
Here's some documentation with examples regarding the <a href="https://docs.python.org/3.5/library/string.html#format-examples" rel="nofollow">format syntax</a>.</p>
<pre><code>import string

users = {'ids': [1, 2, 3, 5]}

def call_api(url, data):
    data_set = set(data)
    formatter = string.Formatter()
    used_set = {f[1] for f in formatter.parse(url) if f[1] is not None}
    unused_set = data_set - used_set
    formatted = url.format(**{k: ";".join(str(x) for x in v) 
                              for k, v in data.items()})
    return unused_set, formatted

print(call_api('/users/{ids}/permissions', users))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="http://docs.python.org/3/library/re.html#re.subn" rel="nofollow">re.subn</a> which returns the number of replacements made:</p>
<pre><code>import re

def call_api(url, data):
    for k, value in list(data.items()):
        url, n = re.subn(r'\{%s\}' % k, ';'.join(str(x) for x in value), url)
        if n:
            del data[k]
</code></pre>
<p>Note that for compatibilty with both python2 and python3, it is also necessary to create a copy of the list of items when destructively iterating over the <code>dict</code>.</p>
<p><strong>EDIT</strong>:</p>
<p>It seems the main bottleneck is checking that the key is in the url. The <code>in</code> operator is easily the most efficient way to do this, and is much faster than a regex for the simple pattern that is being used here. Recording the unused keys separately is also more efficient than destructive iteration, but it doesn't make as much difference (relatively speaking).</p>
<p>So: there's not much wrong with the original solution, but the one given by @wegry is the most efficient.</p>
</div>
<div class="post-text" itemprop="text">
<p>The formatting keys can be found with a RegEx and then compared to the keys in the dictionary. Your string is already setup to use <code>str.format</code>, so you apply a transformation to the values in data, and then apply that transformation.</p>
<pre><code>import re
from toolz import valmap

def call_api(url, data):
    unused = set(data) - set(re.findall('\{(\w+)\}', url))
    url = url.format_map(valmap(lambda v: ';'.join(map(str, v)), data))
    return url, unused
</code></pre>
<p>The usage looks like:</p>
<pre><code>users = {'ids': [1, 2, 3, 5], 'unused_key': 'value'}
print(call_api('/users/{ids}/permissions', users))
# ('/users/1;2;3;5/permissions', {'unused_key'})
</code></pre>
<p>This isn't going to time that well, but it's concise. As noted in one of the comments, it seems unlikely that this method is be a bottleneck.</p>
</div>
<span class="comment-copy">The if statement seems fine for what are likely to be relatively few keys. You could try to "determine" the value by using a regex to extract whatever is between { and }, but if your <code>data</code> only has a few keys, don't bother. And I don't see any reason for you to modify the <code>data</code> values at all. Why are you popping?</span>
<span class="comment-copy">I didn't show the full function @AustinHastings, but later in the function I need to see if that are "unknown" keys - those that haven't been popped. I have additional logic for doing something with the remaining keys/values.</span>
<span class="comment-copy">There are about 10 keys total</span>
<span class="comment-copy">For 10 keys, be as inefficient as you want. You're about to call a web API, this code is NOT going to be your performance bottleneck. ;-)</span>
<span class="comment-copy">What are you using to serve this service? If it's django it has methods for handling those arguments. Flask also has that option.</span>
<span class="comment-copy">This solution breaks the OPs code, because it removes items from the data when the url <b><i>doesn't</i></b> contain the key. An <code>if</code> check is necessary because the OP wants to detect unexpected parameters.</span>
<span class="comment-copy">I have fixed the code. The solution will now detect unexpected parameters, and will substitute all that exist.</span>
<span class="comment-copy">Keep in mind the OP wants to track which words were not converted.</span>
<span class="comment-copy">@Bharel I have updated the answer accordingly.</span>
