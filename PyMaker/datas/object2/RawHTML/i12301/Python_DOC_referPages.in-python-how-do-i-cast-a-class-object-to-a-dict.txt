<div class="post-text" itemprop="text">
<p>Let's say I've got a simple class in python</p>
<pre><code>class Wharrgarbl(object):
    def __init__(self, a, b, c, sum, version='old'):
        self.a = a
        self.b = b
        self.c = c
        self.sum = 6
        self.version = version

    def __int__(self):
        return self.sum + 9000

    def __what_goes_here__(self):
        return {'a': self.a, 'b': self.b, 'c': self.c}
</code></pre>
<p>I can cast it to an integer very easily</p>
<pre><code>&gt;&gt;&gt; w = Wharrgarbl('one', 'two', 'three', 6)
&gt;&gt;&gt; int(w)
9006
</code></pre>
<p>Which is great! But, now I want to cast it to a dict in a similar fashion</p>
<pre><code>&gt;&gt;&gt; w = Wharrgarbl('one', 'two', 'three', 6)
&gt;&gt;&gt; dict(w)
{'a': 'one', 'c': 'three', 'b': 'two'}
</code></pre>
<p>What do I need to define for this to work? I tried substituting both <code>__dict__</code> and <code>dict</code> for <code>__what_goes_here__</code>, but <code>dict(w)</code> resulted in a <code>TypeError: Wharrgarbl object is not iterable</code> in both cases. I don't think simply making the class iterable will solve the problem. I also attempted many googles with as many different wordings of "python cast object to dict" as I could think of but couldn't find anything relevant :{</p>
<p>Also! Notice how calling <code>w.__dict__</code> won't do what I want because it's going to contain <code>w.version</code> and <code>w.sum</code>. I want to customize the cast to <code>dict</code> in the same way that I can customize the cast to <code>int</code> by using <code>def int(self)</code>.</p>
<p>I know that I could just do something like this</p>
<pre><code>&gt;&gt;&gt; w.__what_goes_here__()
{'a': 'one', 'c': 'three', 'b': 'two'}
</code></pre>
<p>But I am assuming there is a pythonic way to make <code>dict(w)</code> work since it is the same type of thing as <code>int(w)</code> or <code>str(w)</code>. If there isn't a more pythonic way, that's fine too, just figured I'd ask. Oh! I guess since it matters, this is for python 2.7, but super bonus points for a 2.4 old and busted solution as well.</p>
<p>There is another question <a href="https://stackoverflow.com/questions/23252370/overloading-dict-on-python-class">Overloading __dict__() on python class</a> that is similar to this one but may be different enough to warrant this not being a duplicate. I believe that OP is asking how to cast all the data in his class objects as dictionaries. I'm looking for a more customized approach in that I don't want everything in <code>__dict__</code> included in the dictionary returned by <code>dict()</code>. Something like public vs private variables may suffice to explain what I'm looking for. The objects will be storing some values used in calculations and such that I don't need/want to show up in the resulting dictionaries.</p>
<p>UPDATE:
I've chosen to go with the <code>asdict</code> route suggested but it was a tough choice selecting what I wanted to be the answer to the question. Both @RickTeachey and @jpmc26 provided the answer I'm going to roll with but the former had more info and options and landed on the same result as well and was upvoted more so I went with it. Upvotes all around though and thanks for the help. I've lurked long and hard on stackoverflow and I'm trying to get my toes in the water more.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are at least five ways. The preferred way depends on what your use case is.</p>
<p><strong>Option 1:</strong> Simply add an <code>asdict()</code> method.</p>
<p>Based on the problem description I would very much consider the <code>asdict</code> way of doing things suggested by other answers. This is because it does not appear that your object is really much of a collection:</p>
<pre><code>class Wharrgarbl(object):

    ...

    def asdict(self):
        return {'a': self.a, 'b': self.b, 'c': self.c}
</code></pre>
<p>Using the other options below could be confusing for others unless it is very obvious exactly which object members would and would not be iterated or specified as key-value pairs.</p>
<p><strong>Option 2:</strong> Override <code>' __iter__'</code>.</p>
<p>Like this, for example:</p>
<pre><code>def __iter__(self):
    yield 'a', self.a
    yield 'b', self.b
    yield 'c', self.c
</code></pre>
<p>Now you can just do: </p>
<pre><code>dict(my_object)
</code></pre>
<p>This works because the <code>dict()</code> constructor accepts an iterable of <code>(key, value)</code> pairs to construct a dictionary. Before doing this, ask yourself the question whether iterating the object as a series of key,value pairs in this manner- while convenient for creating a <code>dict</code>- might actually be surprising behavior in other contexts. E.g., ask yourself the question "what should the behavior of <code>list(my_object)</code> be...?"</p>
<p>Additionally, note that accessing values directly using the get item <code>obj["a"]</code> syntax will not work, and keyword argument unpacking won't work. For those, you'd need to implement the mapping protocol.</p>
<p><strong>Option 3:</strong> <a href="https://stackoverflow.com/questions/19775685/how-to-correctly-implement-the-mapping-protocol-in-python">Implement</a> the <a href="https://docs.python.org/3/c-api/mapping.html" rel="nofollow noreferrer">mapping protocol</a>. This allows access-by-key behavior, casting to a <code>dict</code> without using <code>__iter__</code>, and also provides keyword unpacking behavior.</p>
<p>The mapping protocol requires that you provide (at minimum) two methods together: <code>keys()</code> and <code>__getitem__</code>.</p>
<pre><code>class MyKwargUnpackable:
    def keys(self):
        return list("abc")
    def __getitem__(self, key):
        return dict(zip("abc", "one two three".split()))[key]
</code></pre>
<p>Now you can do things like:</p>
<pre><code>&gt;&gt;&gt; m=MyKwargUnpackable()
&gt;&gt;&gt; m["a"]
'one'
&gt;&gt;&gt; dict(m)  # cast to dict directly
{'a': 'one', 'b': 'two', 'c': 'three'}
&gt;&gt;&gt; dict(**m)  # unpack as kwargs
{'a': 'one', 'b': 'two', 'c': 'three'}
</code></pre>
<p>Note that the mapping protocol <em>takes precedence over</em> the <code>__iter__</code> method when casting an object to a <code>dict</code> directly (without using kwarg unpacking, i.e. <code>dict(m)</code>). So it is possible- and sometimes convenient- to cause the object to have different behavior when used as an iterable (e.g., <code>list(m)</code>) vs. when cast to a <code>dict</code> (<code>dict(m)</code>).</p>
<p><strong><em>EMPHASIZED</em></strong>: Just because you CAN use the mapping protocol, <em>does NOT mean that you <strong>SHOULD</strong> do so</em>. Does it actually <em>make sense</em> for your object to be passed around as a set of keyword arguments? Does accessing it by key- just like a dictionary- really make sense?</p>
<p>If the answer to these questions is <em>yes</em>, it's probably a good idea to consider the next option.</p>
<p><strong>Option 4:</strong> Look into using the <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer"><code>'collections.abc</code>' module</a>.</p>
<p>Inheriting your class from <code>'collections.abc.Mapping</code> or <code>'collections.abc.MutableMapping</code> signals to other users that, for all intents and purposes, your class <em>is a mapping</em> * and can be expected to behave that way.</p>
<p>You can still cast your object to a <code>dict</code> just as you require, but there would probably be little reason to do so. Because of <a href="https://stackoverflow.com/questions/4205130/what-is-duck-typing">duck typing</a>, bothering to cast your mapping object to a <code>dict</code> would just be an additional unnecessary step the majority of the time.</p>
<p><a href="https://stackoverflow.com/a/27803404/2437514">This answer</a> might also be helpful.</p>
<p>As noted in the comments below: it's worth mentioning that doing this the abc way essentially turns your object class into a <code>dict</code>-like class (assuming you use <code>MutableMapping</code> and not the read-only <code>Mapping</code> base class). Everything you would be able to do with <code>dict</code>, you could do with your own class object. This may be, or may not be, desirable.</p>
<p>Also consider looking at the numerical abcs in the <code>numbers</code> module:</p>
<p><a href="https://docs.python.org/3/library/numbers.html" rel="nofollow noreferrer">https://docs.python.org/3/library/numbers.html</a></p>
<p>Since you're also casting your object to an <code>int</code>, it might make more sense to essentially turn your class into a full fledged <code>int</code> so that casting isn't necessary. </p>
<p><strong>Option 5:</strong> Look into using the <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer"><code>dataclasses</code> module</a> (Python 3.7 only).</p>
<pre><code>from dataclasses import dataclass, asdict, field, InitVar

@dataclass
class Wharrgarbl(object):
    a: int
    b: int
    c: int
    sum: InitVar[int]
    version: InitVar[str] = "old"

    def __post_init__(self, sum, version):
        self.sum = 6  # this looks like an OP mistake?
        self.version = str(version)
</code></pre>
<p>Now you can do this:</p>
<pre><code>    &gt;&gt;&gt; asdict(Wharrgarbl(1,2,3,4,"X"))
    {'a': 1, 'b': 2, 'c': 3}
</code></pre>
<hr/>
<p>* "Mapping" has become the standard "name" of the <code>dict</code>-like duck type</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no magic method that will do what you want. The answer is simply name it appropriately. <code>asdict</code> is a reasonable choice for a plain conversion to <code>dict</code>, inspired primarily by <code>namedtuple</code>. However, your method will obviously contain special logic that might not be immediately obvious from that name; you are returning only a subset of the class' state. If you can come up with with a slightly more verbose name that communicates the concepts clearly, all the better.</p>
<p>Other answers suggest using <code>__iter__</code>, but unless your object is truly iterable (represents a series of elements), this really makes little sense and constitutes an awkward abuse of the method. The fact that you want to filter out some of the class' state makes this approach even more dubious.</p>
</div>
<div class="post-text" itemprop="text">
<p>something like this would probably work</p>
<pre><code>class MyClass:
    def __init__(self,x,y,z):
       self.x = x
       self.y = y
       self.z = z
    def __iter__(self): #overridding this to return tuples of (key,value)
       return iter([('x',self.x),('y',self.y),('z',self.z)])

dict(MyClass(5,6,7)) # because dict knows how to deal with tuples of (key,value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think this will work for you.  </p>
<pre><code>class A(object):
    def __init__(self, a, b, c, sum, version='old'):
        self.a = a
        self.b = b
        self.c = c
        self.sum = 6
        self.version = version

    def __int__(self):
        return self.sum + 9000

    def __iter__(self):
        return self.__dict__.iteritems()

a = A(1,2,3,4,5)
print dict(a)
</code></pre>
<h2>Output</h2>
<p>{'a': 1, 'c': 3, 'b': 2, 'sum': 6, 'version': 5}</p>
</div>
<div class="post-text" itemprop="text">
<p>It's hard to say without knowing the whole context of the problem, but I would not override <code>__iter__</code>.</p>
<p>I would implement <code>__what_goes_here__</code> on the class.</p>
<pre><code>as_dict(self:
    d = {...whatever you need...}
    return d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Like many others, I would suggest implementing a to_dict() function rather than (or in addition to) allowing casting to a dictionary. I think it makes it more obvious that the class supports that kind of functionality. You could easily implement such a method like this:</p>
<pre><code>def to_dict(self):
    class_vars = vars(MyClass)  # get any "default" attrs defined at the class level
    inst_vars = vars(self)  # get any attrs defined on the instance (self)
    all_vars = dict(class_vars)
    all_vars.update(inst_vars)
    # filter out private attributes
    public_vars = {k: v for k, v in all_vars.items() if not k.startswith('_')}
    return public_vars
</code></pre>
</div>
<span class="comment-copy">have you seen this already? <a href="https://docs.python.org/3/reference/datamodel.html?emulating-container-types#emulating-container-types" rel="nofollow noreferrer">docs.python.org/3/reference/â€¦</a></span>
<span class="comment-copy">@GarrettR It's helpful, but it doesn't really reveal a lot of insight into this particular issue.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/23252370/overloading-dict-on-python-class">Overloading __dict__() on python class</a></span>
<span class="comment-copy">@RickTeachey it certainly is similar to the Overloading... question, although I am looking for a more customizable dict representation. For example the object may be storing things I don't care to see in the dict.</span>
<span class="comment-copy">@JoranBeasley While this may be technically a correct answer, it is not at all specific.  It is not clear what one should override <code>__iter__</code> with.</span>
<span class="comment-copy">@zondo It has an example that yields a set of tuples. What's wrong with it?</span>
<span class="comment-copy">@zondo Patience is a virtue. ;)</span>
<span class="comment-copy">@Zizouz212 he just added it ... but yeah</span>
<span class="comment-copy">@Zizouz212 Joran Beasley is correct.  At the time of my comment, that example was not there.</span>
<span class="comment-copy">yes, returning a subset of the class's whole state, the values of relevance, is what I'm trying to achieve. I've got some "hidden" values stored that make things quicker for calculations/comparisons etc, but they are nothing that a human would want to see or play with and they also don't really represent the object itself.</span>
<span class="comment-copy">@tr3buchet In your example code, those values are <i>passed in to the initializer</i>. Is that the way it is in your real code? It seems odd that cached calculations would be passed in as arguments.</span>
<span class="comment-copy">not at all, I was just doing it to provide an example</span>
<span class="comment-copy">Just want to note that the <a href="https://docs.python.org/2/reference/datamodel.html#object.__iter__" rel="nofollow noreferrer">docs</a> seem to condone using <code>__iter__</code> as other answers have suggested: "For mappings, it should iterate over the keys of the container, and should also be made available as the method iterkeys()."</span>
<span class="comment-copy">@dbenton That is not what the OP is doing or what the other answers are recommending. The OP's object is not a "container," which in this context is basically being used as a synonym of collection. The OP's object is also not what is usually meant by mapping. A mapping would be something that has an arbitrary number of keys and values and should extend the <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping" rel="nofollow noreferrer"><code>Mapping</code></a> base class. An object that has specific named attributes does not fall into this category.</span>
<span class="comment-copy">oh interesting! an iterable of the tuples, I didn't consider this. I'll do a quick test</span>
<span class="comment-copy">Also, returning an iter of a list of tuples snapshots all the values of x, y, and z into the list on which the iter is based. In the case if the 3 yield statements, it is possible (a tiny window, but there nonetheless) that running this in a threaded environment could  result in another thread modifying the y attribute or the z attribute such that the reported x, y, and z are not consistent.</span>
<span class="comment-copy">@PaulMcGuire: does CPython guarante that they'll all be consistent even with Joran's code? I would have thought that another thread could be scheduled, for example, after the first tuple with <code>x</code> is created, but before the second tuple with <code>y</code>. Am I wrong, and actually the list comprehension is atomic with respect to thread scheduling?</span>
<span class="comment-copy">Now that you ask, I realize that even the list comprehension is not guaranteed atomic, as Python's thread switcher does so at the bytecode level, not the source level. But your exposure is only for the duration of creating the list - once the list has been created, then any updates to the the properties won't matter (unless the property values are mutable objects). Best to use the <code>dis</code> module to view the actual bytecodes.</span>
<span class="comment-copy">what happened to sum and version? how is this any different than just accessing <code>__dict__</code> like the other answer suggested ?</span>
<span class="comment-copy">it's not dict.  the call to iteritems returns a iterator</span>
<span class="comment-copy">I like this answer ... but it needs a little more work before it meets the OP's requirements ...</span>
<span class="comment-copy">this answer is really no different from @JoranBeasley. The difference is that his is selective whereas your grabs the whole <code>self.__dict__</code> which contains items I don't want to have in the dictionary version of the object.</span>
<span class="comment-copy">Nope, that's what the variables are stored in.</span>
<span class="comment-copy">I specifically pointed out that <code>w.__dict__</code> doesn't do what I need.</span>
<span class="comment-copy">But <code>__dict__</code> could be overridden, could it not?</span>
<span class="comment-copy">@noisewaterphd no it is a magic method (maybe you could override it but there implications are scary to say the least)</span>
<span class="comment-copy">Why not inherit from dict, or perhaps better yet, just create a method on the class to return it as a dict.</span>
