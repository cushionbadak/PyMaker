<div class="post-text" itemprop="text">
<p>Here's a scenario which simulates running an older version of a Python program against a shelve database written by a newer version. Ideally, the User object would still be parsed and read in; the favouritePet attribute would be ignored. Understandably, it throws an error complaining that the tuple doesn't match.</p>
<p>Is there a good way of making this scenario work with namedtuples, or better to switch to storing a dictionary or class if this sort of flexibility is required?</p>
<pre><code>import shelve
from collections import namedtuple

shelf = shelve.open("objectshelf", flag='n')

User = namedtuple("User", ("username", "password", "firstname", "surname", "favouritePet"))
shelf["namedtupleAndrew"] = User("andrew@example.com", "mypassword", "Andrew", "Smith", "cat")

# Redefine User to simulate a previous version of the User object that didn't record favouritePet;
# someone using an old version of the program against a database written to by a new version
User = namedtuple("User", ("username", "password", "firstname", "surname"))
# Throws error "takes 5 positional arguments but 6 were given"
namedTupleRead = shelf["namedtupleAndrew"]

print(namedTupleRead.username)
</code></pre>
<p><strong>Edit</strong>: For completeness here's the same idea using a class:</p>
<pre><code>import shelve

shelf = shelve.open("objectshelf", flag='n')

class User:

    def __init__(self, username, password, firstname, surname, favouritePet):
        self.username = username
        self.password = password
        self.firstname = firstname
        self.surname = surname
        self.favouritePet = favouritePet

shelf["objectAndrew"] = User("andrew@example.com", "mypassword", "Andrew", "Smith", "cat")

# Redefine User to simulate a previous version of the User object that didn't record favouritePet;
# someone using an old version of the program against a database written to by a new version
class User:

    def __init__(self, username, password, firstname, surname):
        self.username = username
        self.password = password
        self.firstname = firstname
        self.surname = surname

objectRead = shelf["objectAndrew"]

print(objectRead.username)
# favouritePet is still there; it's just a dictionary, after all.
print(objectRead.favouritePet)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would advise to use a dict or custom class.</p>
<p>A named tuple needs exactly as many arguments as it has fields, so to make this work with a named tuple directly yout'd have to change the class' <code>__new__</code> method to use <code>*args</code> and <code>**kwargs</code> instead of a fixed list of arguments. If you have a look at the definition of your <code>User</code> class (by adding the <code>verbose=True</code> argument), you'll see how the class is defined:</p>
<pre><code>...
class User(tuple):
    'User(username, password, firstname, surname, favouritePet)'

    __slots__ = ()

    _fields = ('username', 'password', 'firstname', 'surname', 'favouritePet')

    def __new__(_cls, username, password, firstname, surname, favouritePet):
        'Create new instance of User(username, password, firstname, surname, favouritePet)'
        return _tuple.__new__(_cls, (username, password, firstname, surname, favouritePet))
...
</code></pre>
<p><code>__new__</code> would have to become <code>__new__(_cls, *args, **kwargs)</code>, and then correctly parse <code>args</code> and <code>kwargs</code> (you'll still want to be able to use <code>User('a', 'b', 'c', ...)</code> as well as <code>User('a', password='b', firstname='c', ...)</code> but not <code>User('a', username='A', ...)</code> to remain consistent with namedtuple), and then use the resulting sequence with <code>tuple.__new__</code>. It's probably better to use a dedicated class instead of modifying the behaviour of a namedtuple in such a way.</p>
<p>It would be easier to change the way the <code>User</code> namedtuple is pickled by using the <a href="https://docs.python.org/3/library/pickle.html#object.__reduce__" rel="nofollow"><code>__reduce__</code></a> protocol (or <a href="https://docs.python.org/3/library/copyreg.html#copyreg.pickle" rel="nofollow"><code>copyreg.pickle()</code></a>) by using a custom constructor function, e.g:</p>
<pre><code>from collections import namedtuple
import shelve
import copyreg

shelf = shelve.open("test")

User = namedtuple("User", ("username", "password", "firstname", "surname", "favouritePet"))

User.__reduce__ = lambda user: (construct_user, tuple(user))
# or: copyreg.pickle(User, lambda user: (construct_user, tuple(user)))

def construct_user(*args):
    print('creating new user:', args)       # for debugging
    return User(*args[:len(User._fields)])


user = User("andrew@example.com", "mypassword", "Andrew", "Smith", "cat")
print(user)
shelf["namedtupleAndrew"] = user

# redefine User
User = namedtuple("User", ("username", "password", "firstname", "surname"))

print(shelf["namedtupleAndrew"])
</code></pre>
<p>This will work as long as the <code>construct_user</code> function is available in all compatible versions, but as said initially, I would still recommend to use a different data structure.</p>
</div>
<span class="comment-copy">With the class example, is there a good way to get rid of the self.username = username lines while still allowing the parameters to be listed in <b>init</b> ?</span>
