<div class="post-text" itemprop="text">
<p>I am trying to extend the python asyncio HTTP server example that uses a streaming reader/writer (<a href="https://docs.python.org/3.4/library/asyncio-stream.html#tcp-echo-server-using-streams" rel="nofollow">code</a>). If I understand it correctly, the example handler read 100 bytes from the reader and echoes it back to the client through the writer. I am trying to read more than 100 bytes... reading until there is nothing more to read would be nice.</p>
<p>I have tried letting the read() function read as much as possible,</p>
<pre><code>data = yield from reader.read()
</code></pre>
<p>but that seems to block forever. So I tried reading chunks until the EOF is reached,</p>
<pre><code>while not reader.at_eof():
    data += yield from reader.read(100)
</code></pre>
<p>and while this retrieves more of the data, it to seems to block on the read call instead of exiting the while loop.</p>
<p>How can I get the entire message from the client using the stream reader?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should check if <a href="https://docs.python.org/3.4/library/asyncio-stream.html#asyncio.StreamReader.read" rel="nofollow"><code>StreamReader.read</code></a> returned an empty bytes object to signal an EOF:</p>
<pre><code>data = bytearray()
while True:
    chunk = yield from reader.read(100)
    if not chunk:
        break
    data += chunk
</code></pre>
<p>Also, consider using <a href="http://aiohttp.readthedocs.org/" rel="nofollow"><code>aiohttp</code></a> if you need a fully functional HTTP client.</p>
</div>
<div class="post-text" itemprop="text">
<p>Like so:</p>
<pre><code>empty_bytes = b''
result = empty_bytes

while True:
    chunk = await response.content.read(8)

    if chunk == empty_bytes:
        break

    result += chunk
</code></pre>
<p>To determine the EOF use</p>
<pre><code>if chunk == empty_bytes:
</code></pre>
<p>in stead of</p>
<pre><code>if not chunk:
</code></pre>
<p>See the docs (<a href="https://docs.aiohttp.org/en/stable/streams.html#aiohttp.StreamReader" rel="nofollow noreferrer">aiohttp</a>): the <em>read</em> returns an empty byte string</p>
<pre><code>b''
</code></pre>
<p>on EOF, so check for that explicitly.</p>
<p><strong>Note:</strong> If you would like to read until the end of the chunk as it was delivered from the server, checkout</p>
<pre><code>StreamReader.readchunk()
</code></pre>
<p>(Didn't test it, though.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Use feed_eof before at_eof.</p>
<pre><code>request_text = b''
while True:
    request_text += yield from self.reader.read(1024)
    self.reader.feed_eof()
    if self.reader.at_eof():
        break
</code></pre>
</div>
<span class="comment-copy">I tried that too without success. Thank you.</span>
<span class="comment-copy">Are you sending <code>HTTP/1.1</code> or <code>HTTP/1.0</code> request/responses? Could you post a complete example?</span>
<span class="comment-copy">So I did a little digging into the asyncio implementation and it seems that calling read() on the stream is not the way to go in this case because an EOF is never going to be injected into the stream unless the client actively closes the connection. The example you provided is essentially what asyncio is trying to do itself, but the problem is that data coming from the HTTP request contains bytes with line endings of the form b'\r\n' so that the 'if not chunk' conditional is never true, even if the data only the line ending.</span>
<span class="comment-copy">To work around this I am using the readline() function and strip the result before testing 'if not chunk' and this works fine.</span>
<span class="comment-copy">I was just trying to point out that the reason your code hangs is because you are not determining the request length (or EOF) properly. For example, in <code>HTTP/1.1</code> the connection is by default <code>keep-alive</code>, so you can have multiple requests per connection. To determine when the request ends you must look at the <code>Content-Length</code> header or if the request is chunked. There are many other caveats, so if you want to do this from scratch with asyncio, I'd recommend reading the HTTP RFC. Also, the example you have linked to is about a <i>TCP</i> echo server, not a <i>HTTP</i> one.</span>
<span class="comment-copy">There is no difference between <code>if not chunk</code> and <code>if chunk == b''</code>, because <code>bool(b'')</code> evaluates to <code>False</code> anyway.</span>
<span class="comment-copy">Perhaps I don't understand, but doesn't this assume that the reader has received all of the data before the feed_eof function is called?</span>
<span class="comment-copy">See the docs <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader.at_eof" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a>  "Return True if the buffer is empty and feed_eof() was called."</span>
<span class="comment-copy">See this example <a href="https://github.com/carlosmaniero/asyncio_server/blob/master/server.py" rel="nofollow noreferrer">github.com/carlosmaniero/asyncio_server/blob/master/server.py</a> on line 80.</span>
<span class="comment-copy">Sure, but you are streaming so the readers buffer can be empty without the message being complete. By feeding the EOF to the reader, you are effectively saying that the message is complete, but you cannot know that unless a terminator in the message protocol indicates that. The example you've provided does not contain any logic to that effect that I can see. The 1024 byte read may also be acting to mask that issue because it lessens the chance of it occurring.</span>
<span class="comment-copy">I changed the example to read 2 bytes.   <a href="https://github.com/python/asyncio/blob/master/asyncio/streams.py#L398" rel="nofollow noreferrer">github.com/python/asyncio/blob/master/asyncio/streams.py#L398</a>  The feed_eof will be set self._eof = True and will be call the _wakeup_waiter.  The _wakeup_waiter, will be "wakeup read*() functions waiting for data or EOF". The at_eof, will be return True if self._eof is True and not have more buffer (self._buffer).   If you don't have more buffer and your self._eof is False, this will be yield self._wait_for_data and will be block the read function.</span>
