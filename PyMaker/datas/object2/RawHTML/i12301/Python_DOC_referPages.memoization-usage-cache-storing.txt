<div class="post-text" itemprop="text">
<p>I am writing a program that calculates the Pascal Identity of two variables, hard coded into the program, as I am new into Python and trying out caching and memoization. Here is what I have so far: </p>
<pre><code>counter = 0

call_cacheK = {}
   def callTest(n, k):
   global counter

   if n in call_cacheK:
       return call_cacheK[n]  
   if k == 0:
       return 1
   elif k == n:
       return 1 
   elif (1 &lt;= k) and (k &lt;= (n-1)):
       counter += 1
       #call_cacheK[n] = result
       result = ((callTest(n-1, k) + callTest(n-1, k-1)))
   print(result)
   return result

callTest(20, 11)
#167,960
</code></pre>
<p>My function will output the final real answer with what it has now, but with a lot of outputted answers. I cannot seem to get how to properly store the values to be used in the cache.</p>
<p>How do I properly use <code>call_cacheK</code> to store the <code>result</code> values I have already used?</p>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Lets see. First, you have a function of two variables, but store result in cache only by one parameter. So <code>callTest(20, 11)</code>, <code>callTest(20, 10)</code>, <code>callTest(20, 9)</code> will have one result in your cache. Lets rewrite your function a little:</p>
<pre><code>call_cacheK = {}

def callTest(n, k):
    if (n, k) in call_cacheK:
        return call_cacheK[(n, k)]  
    if k == 0:
        return 1
    elif k == n:
        return 1 
    elif (1 &lt;= k) and (k &lt;= (n-1)):
        result = ((callTest(n-1, k) + callTest(n-1, k-1)))
        call_cacheK[(n, k)] = result
    print(result)
    return result
</code></pre>
<p>Yes there is no counter variable because I didn't realize why do you need it :)</p>
<p>Also, as far as I can judge by the use of <code>print(result)</code>, you probably use the Python3.x. If so, you can use <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow">standard cache implementing</a>:</p>
<pre><code>from functools import lru_cache

@lru_cache(maxsize=None)
def callTest2(n, k):  
    if k == 0:
        return 1
    elif k == n:
        return 1 
    elif (1 &lt;= k) and (k &lt;= (n-1)):
        result = ((callTest2(n-1, k) + callTest2(n-1, k-1)))
    print(result)
    return result
</code></pre>
<p>Good luck! :)</p>
</div>
<span class="comment-copy">The canonical method for memoization is with a decorator, I suggest you look into that. As for this, you don't seem to be <i>trying</i> to put anything into the cache.</span>
<span class="comment-copy">Thank you. After you pointed out the single variable issue it become clear my mistake. This was a great solution to the problem.</span>
<span class="comment-copy">@user3194722 You're welcome :) You can also mark an answer as correct if it was helpful for you.</span>
