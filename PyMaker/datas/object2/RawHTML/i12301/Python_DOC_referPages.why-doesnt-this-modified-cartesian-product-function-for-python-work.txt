<div class="post-text" itemprop="text">
<p>Ideally, the input is [1,2], and the output is all combinations [[1,1], [2,2], [1,2], [2,1]]. Basically, print all possible combinations with replacement.</p>
<pre><code>def cart(lst):
   if lst == []:
      return [[]]

   return [x[i:] + [lst[0]] + x[:i] for x in cart(lst[1:]) for i in range(len(x)) ]

l = [1,2,3] 
print cart(l)
</code></pre>
<p>Returns</p>
<blockquote>
<p>[]</p>
</blockquote>
<p>In more human-readable form, the code basically says:</p>
<pre><code>for x in cart(lst[1:]):
   for i in range(len(x)):
      return x[i:] + [lst[0]] + x[:i]
</code></pre>
<p>And if we assume the recursive case with input <code>[1,2,3]</code>, then
<code>cart([2,3])</code> should produce <code>[[2,3], [3,2], [2,2], [3,3]]</code>, and so for the recursive step we would want to insert <code>1</code> in every possible location. (This code might be missing the <code>111</code> case.)</p>
<p>The code appears logically correct, but outputs an empty string.</p>
<p>Is there something missing or am I approaching the problem incorrectly?</p>
<p><strong>Edit</strong></p>
<p>Actually, I realize the code would be slightly more complicated:</p>
<pre><code>def cart(lst):
    if len(lst) &lt;= 1:
        return lst
    else:
        return [x[i:] + [lst[j]] + x[:i] for x in cart(lst[1:]) for j in range(len(lst)) for i in range(len(x))]
</code></pre>
<p>Although this still strangely returns an empty list. My hunch is that I am missing a base case.</p>
<p><strong>Edit</strong></p>
<p>It was something to do with my base case. Revised code:</p>
<pre><code>def cart(lst):
    if len(lst) &lt;= 1:
        return [lst]
    else:
        return [x[i:] + [lst[j]] + x[:i] for x in cart(lst[1:]) for j in range(len(lst)) for i in range(len(x))]

l = [1,2,3]
print cart(l)
</code></pre>
<p>But now returns</p>
<blockquote>
<p>[[3, 2, 1], [2, 1, 3], [3, 2, 2], [2, 2, 3], [3, 2, 3], [2, 3, 3], [3, 3, 1
  ], [3, 1, 3], [3, 3, 2], [3, 2, 3], [3, 3, 3], [3, 3, 3]]</p>
</blockquote>
<p>Better now, although the output is missing sets. Seems like a base case issue again.</p>
</div>
<div class="post-text" itemprop="text">
<p>Found the answer here 
<a href="https://stackoverflow.com/questions/21228156/algorithm-for-recursive-function-for-permutations-with-replacement-in-python">Algorithm for recursive function for permutations with replacement in python</a></p>
<pre><code>def permutations_with_replacement(k,n):
         # special case (not part of recursion)
         if k == 0:
            return []

         if k == 1:
            return [[n[i]] for i in range(len(n))]

         else:
            # Make the list by sticking the k-1 permutations onto each number 
            # we can select here at level k    
            result = []
            # Only call the k-1 case once, though we need it's output n times.
            k_take_one_permutations = permutations_with_replacement(k-1,n)  

            for i in range(len(n)):
                for permutation in k_take_one_permutations:
                    result.append([n[i]]+permutation)   
            return result

         print permutations_with_replacement(3,2)

print permutations_with_replacement(3, [1,2,3])
</code></pre>
<p>It appears I was trying to take the recursive case of the list itself, rather than the size of the combinations.</p>
<p>I'm wondering whether or not the solution would be do-able by recurring on the list, rather than the size of the combinations.</p>
</div>
<span class="comment-copy">If you found the answer to your question, then post it as such and accept it. It benefits to everyone.</span>
<span class="comment-copy">so you want to implement itertools.product?</span>
<span class="comment-copy">@Copperfield Yes!</span>
<span class="comment-copy">in that case you can study the one in the <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">documentation</a>, there is a pure python version there, you can use that or some variation of it that fit your taste</span>
