<div class="post-text" itemprop="text">
<p>Say I have two IPs: <code>startip = '63.223.64.0'</code> and <code>endip   = '63.223.127.255'</code></p>
<p>I understand that in python <code>netaddr.iprange_to_cidrs(startip, endip)</code> will give you a list of CIDR subnets that fit exactly between the boundaries.  However, I was hoping to go for <strong>one</strong> CIDR subnet that covers it all even if it gives a few more IPs.  </p>
<p>I prefer a function that does it, but I would also welcome any math/logic to calculate it and eventually turn it into code. </p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like <a href="http://pythonhosted.org/netaddr/api.html#netaddr.spanning_cidr" rel="nofollow"><code>netaddr.spanning_cidr</code></a> does the trick:</p>
<pre><code>In [5]: netaddr.spanning_cidr(['63.223.64.0', '63.223.127.255'])
Out[5]: IPNetwork('63.223.64.0/18')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have you tried the <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow">ipaddress</a> module? It comes with Python 3, but is installable for Python 2. </p>
<pre><code>import ipaddress
startip = ipaddress.IPv4Address('63.223.64.0')
endip = ipaddress.IPv4Address('63.223.127.255')
# summarize_address_range produces a generator, so force the results
networks = [n for n in ipaddress.summarize_address_range(startip, endip)]
print(networks)
# [IPv4Network('63.223.64.0/18')] 
</code></pre>
</div>
<span class="comment-copy">perfect! thank you.</span>
<span class="comment-copy">Issue is I have python 2.6.6 and no way of installing new modules.  but I'll give it a shot.  thanks.</span>
