<div class="post-text" itemprop="text">
<p>I am writing a python method to dump the entire contents of a MySQL table. However, this table contains personally-identifiable information (PII). I have a requirement that this data must be GPG-encrypted. Additionally the requirement is that none of this data is allowed to be written to disk in unencrypted form (even if that is just a temporary file that is later removed)</p>
<p>I have temporarily solved this problem as follows by using the <code>subprocess.Popen()</code> and piping the output of the <code>mysql</code> executable directly to the <code>gpg</code> executable and then piping that output to stdout:</p>
<pre><code>    p1 = subprocess.Popen(
        'mysql -h127.0.0.1 -Dmydbinstance -umyuser -pmyPassword -e "select * from my_table"',
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
    )

    p2 = subprocess.Popen(
        "gpg --encrypt -r myemail@gmail.com",
        stdin=p1.stdout,
        stdout=subprocess.PIPE
    )

    p1.stdout.close()
    print p2.communicate()[0]
</code></pre>
<p>It works, but this seems to me like a terrible hack. It feels very wrong to fork shell processes to do this. </p>
<p>So I want to do this natively in python (without <code>popen()</code>). I have a MySQLdb connection to the database. And the <code>python-gnupg</code> module can do the encryption on a file stream. But how can I convert the output of MySQLdb's fetchall() to a file stream? So far, all I have is this:</p>
<pre><code>import MySQLdb
import gpg

DBConn = MySQLdb.Connect(host='127.0.0.1', user='myuser', passwd='myPassword', db='mydbinstance', port=3306, charset='utf8')
DBConn.autocommit(True)
cur = DBConn.cursor(MySQLdb.cursors.DictCursor)
cur.execute("select * from my_table")
if cur.rowcount &gt;= 1:
    rows = cur.fetchall()
else
    rows = []
for i in rows:
    print i

# WHAT DO I NEED TO DO HERE TO TURN THE DB OUTPUT INTO A FILE STREAM?

encrypted_ascii_data = gpg.encrypt_file(stream, recipient_fingerprint)
</code></pre>
<p>How can I turn the output of fetchall() to a file stream so that I can send it to <code>gpg.encrypt_file()</code> without writing a temporary file to disk that is unencrypted? There could be millions of rows of data. So reading it all into memory at once is not a viable solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a file-like object similiar to <code>io.StringIO</code> or <code>io.BytesIO</code> from the <a href="https://docs.python.org/3/library/io.html" rel="nofollow">io module</a>. </p>
<p>Looking at the latest <a href="https://github.com/isislovecruft/python-gnupg/blob/5895997554787ca956c9e0508eb86c3943134a2d/gnupg/gnupg.py#L885" rel="nofollow">source code</a> there is no <code>encrypt_file</code> anymore, instead <code>encrypt</code> <a href="https://github.com/isislovecruft/python-gnupg/blob/5895997554787ca956c9e0508eb86c3943134a2d/gnupg/gnupg.py#L972" rel="nofollow">wraps the data in a binary stream</a> using <a href="https://github.com/isislovecruft/python-gnupg/blob/5895997554787ca956c9e0508eb86c3943134a2d/gnupg/_util.py#L534" rel="nofollow">StringIO or BytesIO depending on the Python Version</a></p>
<p>So nothing actually stops you from using <code>encrypt</code> directly, if you want more control on how the data is encrypted you can implement a dummy file-object or just write your data to an <code>io.BytesIO</code> object.</p>
</div>
<span class="comment-copy">why can't you just use <code>encrypt</code> instead of <code>encrypt_file</code>?</span>
<span class="comment-copy">ah sorry, I get it now. performance reason</span>
