<div class="post-text" itemprop="text">
<p>I'm learning some list/dict comprehension and I'm stuck!!!</p>
<p>I really don't understand the following...</p>
<p>I have this program:</p>
<pre><code>def histogram_for(word):
    adict = dict()
    for c in word:
        adict[c] = adict.get(c, 0) + 1
    print adict
    return adict

def histogram_dc(word):
    adict = dict()
    adict = {c: (adict.get(c, 0) + 1) for c in word}
    print adict
    return adict

def histogram_lc(word):
    adict = dict()
    adict = dict([(c, (adict.get(c, 0) + 1)) for c in word])
    print adict
    return adict


word = "Football"
histogram_for(word.lower())
histogram_dc(word.lower())
histogram_lc(word.lower())
</code></pre>
<p>And i get these results:</p>
<pre><code>{'a': 1, 'b': 1, 'f': 1, 'l': 2, 'o': 2, 't': 1}
{'a': 1, 'b': 1, 'f': 1, 'l': 1, 'o': 1, 't': 1}
{'a': 1, 'b': 1, 'f': 1, 'l': 1, 'o': 1, 't': 1}
</code></pre>
<p>Why the only working one is the "for" method?</p>
</div>
<div class="post-text" itemprop="text">
<p>Quite simply because while the processing is happening in <code>_dc</code> and <code>_lc</code> <code>adict</code> is empty, while in <code>_for</code> it's being updated on each turn of the <code>for</code> loop.  A comprehension can be de-sugared into a <code>for</code> loop of its own:</p>
<pre><code>adict = dict()
adict = {c: (adict.get(c, 0) + 1) for c in word}
</code></pre>
<p>becomes:</p>
<pre><code>adict = dict()
# Handwaving for what Python actually does
$newdict = {}
for c in word:
    $newdict[c] = adict.get(c, 0) + 1
adict = $newdict
</code></pre>
<p>Use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a> (or the for-loop version) if you need to keep track of a set of keys and counts of occurrences.</p>
</div>
<div class="post-text" itemprop="text">
<p>As Sean Vieira said, the class <a href="https://docs.python.org/2.7/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a> and its method <code>most_common</code> are the best solution to your need.</p>
<p>But, if you really want to keep list/dict comprehension, I suggest using <a href="https://docs.python.org/2/library/stdtypes.html#set" rel="nofollow"><code>set</code></a> and <a href="https://docs.python.org/2/library/string.html?highlight=count%20string#string.count" rel="nofollow"><code>count</code></a> : </p>
<pre><code>def histogram_dc(word):
  adict = dict()
  adict = {c: word.count(c) for c in set(word)}
  print adict
  return adict

def histogram_lc(word):
  adict = dict()
  adict = dict([(c, word.count(c)) for c in set(word)])
  print adict
  return adict
</code></pre>
</div>
<span class="comment-copy">Consider using <code>collections.Counter</code> instead of writing your own histogram-generating functions.</span>
<span class="comment-copy">So i can't use comprehension for this purpose?</span>
<span class="comment-copy">So my gut reaction when I saw <code>$newdict</code> was that you must've been coding in PHP or Perl all day and made an error when you posted here.  Then I realized that now all your variables use the <code>$</code>, so it must be on purpose.  But I haven't run across that notation before, and I can't find a reference to it.  What does it indicate?</span>
<span class="comment-copy">@Doug - it's meant to indicate that the variable is a stand in for what the compiler actually does (e. g. "imagine that the compiler inserts another variable here")  I'll add a comment :-)</span>
<span class="comment-copy">@SeanVieira - <b>whew!</b>  Thanks!  I thought there was a major gap in my Python.</span>
<span class="comment-copy">List comprehension loops, but it populates a different (anonymous) dictionary instance - and then <i>after that dictionary is populated</i> it assigns the final dictionary to <code>adict</code>.  So throughout the loop, <code>adict</code> is an empty dictionary and <i>after</i> the loop it now points at the anonymous dictionary that was populated (in a loop) by the comprehension.</span>
