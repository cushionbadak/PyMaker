<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6203995/python-empty-class-object">python empty class object</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p><a href="http://www.aaronsw.com/2002/html2text/html2text.py" rel="nofollow">html2txt</a> contains the following code:</p>
<pre><code>class Storage: pass
options = Storage()
options.google_doc = False
options.ul_item_mark = '*'
</code></pre>
<p>I've not seen such an approach before. What's the benefit/use of this approach over setting up the attributes in <code>__init__()</code>, and is a class even necessary here?</p>
</div>
<div class="post-text" itemprop="text">
<p>Suppose you want to store some collection of named data. You could use a <code>dict</code> but you like the look of dotted attributes in a class object. Just create the most boring class possible and use python's native attribute assignment to do the trick. It is usually a question of aesthetics.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you know the attributes ahead of time you can use namedtuples for this kind of functionality. </p>
<p>From the python <a href="https://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow">docs</a>:</p>
<pre><code>EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, paygrade')
</code></pre>
</div>
<span class="comment-copy">Given the name it appears to be used an 'ad-hoc class': a bag of properties, for some localized meaning, without explicitly using a Dictionary. This avoids having to use proper values (eg. strings) for keys. Ruby has <code>ostruct</code> and JavaScript objects implicitly act as such.</span>
<span class="comment-copy">Other use cases include dynamically overriding object methods/attributes or creating mock objects (duck-typing).</span>
<span class="comment-copy"><i>It is usually a question of aesthetics</i> - I thought as much.</span>
<span class="comment-copy">...if you know all of the information in advance and nothing changes.</span>
<span class="comment-copy">@tdelaney Not sure what you mean. You can dynamically add to a namedtuple as well. I could loop through a set of attribute names and attach attributes e.g. EmployeeRecord.home_address = '123 Main St.' Anyway, in OP's post the information IS known ahead of time.</span>
<span class="comment-copy">No, you can't (re your reply to @tdelaney). You can <i>if</i> you subclass <code>namedtuple</code>, but that's not how <code>namedtuple</code> is supposed to be used. You are not using it as a tuple, just as any old namespace. Use <code>SimpleNamespace</code> for that case, new in Python 3.3: <a href="https://docs.python.org/3/library/types.html#additional-utility-classes-and-functions" rel="nofollow noreferrer">doc</a></span>
<span class="comment-copy">No, you cannot add anything dynamcally... its a <code>tuple</code> after all. You get one shot to create the objects by supplying the values to the constructor. No changes, no additions.</span>
<span class="comment-copy">@alexhb <code>type(namedtuple)</code> is <code>&lt;class 'function'&gt;</code> meaning only that it is a factory function. How about actually trying it? ` Foo=namedtuple('Foo', 'a b c');foo=Foo(1,2,3);foo.a=2` results in <code>AttributeError: can't set attribute</code>.</span>
