<div class="post-text" itemprop="text">
<p>I wanted to assign the inputs, to the related fields with respect to their <code>len()</code>s. The problem is that the fields also have conditions.</p>
<p>1st to 10th fields, allow &lt; 25 characters. 11th to 20th fields allow &lt;100 characters. </p>
<p>What I want is, the below code to take the <code>user_input[i]</code>, check the <code>len()</code>, and if the <code>len(user_input[i])</code> is &lt; 25 characters, assign that to 1st field, then move onto the next input; but also start with the 2nd field when checking its <code>len()</code>. </p>
<p>When the entered input is between 25 and 100 characters long, it should be assigned to the 11th - 20th fields. Just like above, it should start with the 12th field once the 11th is filled. </p>
<p>Please note that I want the script to check the &lt; 25 condition first. And if the &lt; 25 fields are filled, it can assign the inputs to the &lt; 100 inputs. </p>
<p>The code below, is not complete, and far from being true, that's all I could have done :)</p>
<pre><code>import csv
import os

user_input = []
def getting_text(entered_text):
        if entered_text == "done":
            print "entering the texts are done!"
        elif entered_text == "":
            getting_text(raw_input("you've entered an empty text, please try again\n"))
        else:
                user_input.append(entered_text)
                getting_text(raw_input("Enter the text or write done to finish entering\n"))                
getting_text(raw_input("Enter the first text\n"))

with open("trial.csv", "w") as csvfile:
    fieldnames = ["1st field", "2nd field", "3rd field", "4th field", "5th field", "6th field", "7th field", "8th field", "9th field", "10th field", "11th field", "12th field", "13th field", "14th field", "15th field", "16th field", "17th field", "18th field", "19th field", "20th field"]

    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

    writer.writeheader()
    for i in range(0, len(user_input)):

        writer.writerow({"1st field": user_input[i], "2nd field": "input will be here", "3rd field": "input will be here", "4th field": "input will be here", "5th field": "input will be here", "6th field": "input will be here"}) #and so on :)

os.startfile("trial.csv")
</code></pre>
<blockquote>
<p>This is the continuation of this question, so please consider that
  you're talking to a newly started here :)
  <a href="https://stackoverflow.com/questions/35359009/python-list-order">Python list order</a></p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>For each "bucket" of indices, you could create an iterator. Then, use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow"><code>itertools.chain</code></a> to chain those iterators together. Once one bucket is depleted, it will automatically use the next bucket, and since the underlying iterators are shared, no index is used twice. For the buckets, you can just use <code>range</code> (or <code>xrange</code> for Python 2.x), and if the last bucket is open-ended, use <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow"><code>itertools.count</code></a>.</p>
<pre><code>bucket1 = iter(range(0, 10))
bucket2 = iter(range(10, 20))
bucket3 = iter(itertools.count(20)) # or another range with upper bound

sub25 = itertools.chain(bucket1, bucket2, bucket3)
from25to100 = itertools.chain(bucket2, bucket3)
allOther = bucket3
</code></pre>
<p>Example (using just random numbers, no files and user input and strings with different lengths):</p>
<pre><code>target = [None] * 100
for _ in range(70):
    n = random.randint(0, 150)
    if n &lt; 25:
        i = next(sub25)
    elif n &lt; 100:
        i = next(from25to100)
    else:
        i = next(allOther)

    print(n, "goes to position", i)
    target[i] = n
</code></pre>
<p>Afterwards, the <code>target</code> list ends up as (broken down by "buckets"):</p>
<pre><code>[0, 13, 22, 13, 6, 4, 21, 9, 6, None,
 43, 51, 25, 41, 93, 98, 41, 43, 33, 68,
 145, 121, 138, 103, 145, 124, 133, 127, 110, 109, 106, 116, 132, 77, 109, 25, 35, 43, 67, 46, 53, 28, 103, 129, 143, 112, 76, 66, 47, 125, 86, 86, 71, 73, 112, 113, 126, 89, 57, 26, 51, 107, 33, 115, 51, 54, 70, 50, 44, 91, 30, ...]
</code></pre>
<p>Note how some buckets are not 100% full, because not enough numbers for that bucket were rolled, and some numbers end up in a higher bucket than their value would suggest, because they were rolled when their proper bucket was already full.</p>
<hr/>
<p>Update: There are two problems in your <a href="http://paste.ubuntu.com/15090656/" rel="nofollow">updated code</a>:</p>
<ul>
<li>Either loop over <code>range(len(user_input))</code>, or better, loop <code>user_input</code> directly</li>
<li>You are mixing up the positions where to put the item <code>i</code> and where it came from <code>var</code></li>
</ul>
<p>Try changing your loop to this:</p>
<pre><code>for inp in user_input:
    n = len(inp)
    ...
    print(inp, "goes to position", i)
</code></pre>
</div>
<span class="comment-copy">So you want to place user input into the first unoccupied field that is long enough to hold that input. What is your question?</span>
<span class="comment-copy">I couldn't figure out how to do that. I assume I have to assign a variable for each field and set them as 25 / 100; then in a forloop, it'll check the len(user_input[i]) and assign it to the related field? I'm lost.</span>
<span class="comment-copy">Why the downvote? Did I misunderstand the question, or is there a case when this will not work? If so, I'd like to know so I can improve my answer.</span>
<span class="comment-copy">Would <code>xrange</code>s be "better" than <code>range</code>s here? Though I doubt that's what the down-voter had in mind.</span>
<span class="comment-copy">@das-g Agreed, did not see the Python 2.7 tag. But with just a few dozen indices, using <code>range</code> should not be a problem either.</span>
<span class="comment-copy">I'm still reading the docs.python to fully understand the itertools. But as far as I understand, this is going to be the solution, and as soon as I am able to implement it :) Wasn't me who downvoted, that's a great answer for me.</span>
<span class="comment-copy">I've tried to implement your solution, but for some reason when one enters an input &gt; 25 characters, i get an error. <a href="http://paste.ubuntu.com/15090764/" rel="nofollow noreferrer">paste.ubuntu.com/15090764</a> I can't seem to understand why this happens, any ideas what I'm doing wrong? Also please let me know if i should paste the code into the question.</span>
