<div class="post-text" itemprop="text">
<p>currently going through a bin file full of hex data to process, however currently a match I'm using to try and find a group of 3 hex bytes in the file aren't working correctly. The values are identical however it is not printing my string I've currently got set to confirm that its a match, at present I'm trying to just match the first 3 bytes so we know it works etc. the code is as follows: </p>
<pre><code>match1 = "\\x00\\n\\x00"
print ("match1 ="+match1)

if byteData == match1:
    print ("Byte string 030791 found!")
elif byteData == match1:
    print ("Byte string 050791 found!")
exit()
</code></pre>
<p>The value of byteData is currently '\x00\n\x00' however the script ignores this and just moves to the exit statement. The file is being opened as follows :</p>
<pre><code>file = open('file.bin', 'rb')
while True:
byte = file.read(3)
</code></pre>
<p>When printing the value of byte it reports as "\x00\n\x00" does anyone have any ideas as to why the match isn't working properly?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>match1</code> does not contain 3 bytes. It contains 10:</p>
<pre><code>&gt;&gt;&gt; match1 = "\\x00\\n\\x00"
&gt;&gt;&gt; len(match1)
10
</code></pre>
<p>You escaped the escape sequences, so <code>\\x00</code> is <em>four bytes</em>, the <code>\</code> backslash, then the letter <code>x</code> followed by two <code>0</code> digits.</p>
<p>Remove the backslash escapes:</p>
<pre><code>match1 = "\x00\n\x00"
</code></pre>
<p>Don't try to print this directly; terminals generally won't make nulls visible, so you just get an extra newline. Use the <a href="https://docs.python.org/3/library/functions.html#repr" rel="nofollow"><code>repr()</code> function</a> to produce debug output that looks just like a Python string so you can reproduce that value in your code or the interactive interpreter:</p>
<pre><code>print ("match1 =", repr(match1))
</code></pre>
<p>This is also how the interactive interpreter shows you expression results (unless they produced <code>None</code>):</p>
<pre><code>&gt;&gt;&gt; match1 = "\x00\n\x00"
&gt;&gt;&gt; len(match1)
3
&gt;&gt;&gt; match1
'\x00\n\x00'
&gt;&gt;&gt; print("match1 =", repr(match1))
match1 = '\x00\n\x00'
</code></pre>
<p>Next, if you are using Python 3, you'll still won't have a match because you opened the file in binary mode and are thus getting <a href="https://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow"><em><code>bytes</code></em> objects</a>, but your <code>match1</code> variable is a <a href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str" rel="nofollow"><code>str</code> text sequence</a>. If you want the two types to match you'll either have to convert (encode the text or decode the bytes), or make <code>match1</code> a <code>bytes</code> object to start with:</p>
<pre><code>match1 = b'\x00\n\x00'
</code></pre>
<p>The <code>b</code> prefix makes that a <code>bytes</code> literal.</p>
</div>
<div class="post-text" itemprop="text">
<p>Look:</p>
<pre><code>&gt;&gt;&gt; match1 = "\\x00\\n\\x00"
&gt;&gt;&gt; byteData = '\x00\n\x00'
&gt;&gt;&gt; byteData == match1
False
</code></pre>
<p>They are different.</p>
</div>
<span class="comment-copy"><code>\\x00</code> will never be equal to an actual null byte. You created a sequence of a backslash, the character <code>x</code>, and two <code>0</code> characters. Your actual data probably contains an <i>actual null byte</i>.</span>
<span class="comment-copy">When I had it set to match1 = "\x00\n\x00" match 1 would report as being totally empty. The only way I could get it to print the value of match1 it was with the escapes, which is why I did that.  Thanks for the repr(match1)) to print it out though :)  Just added that now, thanks that works, it still doesn't seem to want to match and print my statements out to confirm the match however :/</span>
<span class="comment-copy">@TrueSlawter: so what does <code>print(repr(byte))</code> show you is the actual value read from the file? You haven't shown us anything about the file, so I can't help you debug that part.</span>
<span class="comment-copy">Sorry, yeah the print (repr(byte)) shows "\x00\n\x00" the value of match1  when using repr is also "\x00\n\x00"  then just using "if byteData == match1: print ("Blah") " isn't returning anything at all but it is using the exit statement at the end of the function I'm using for matching part.  The contents of the file is a string of hex with data in there using defined start points so we are looking for them then processing the data to remove the filler. Currently it's just not confirming matches it seems.</span>
<span class="comment-copy">@TrueSlawter: So what happens when you remove the <code>sys.exit()</code>? You are in an infinite loop you insta-exit. If the equals test doesn't return true, then the values really are not equal. Are you certain that you have the same <i>type</i> of object, for example? In Python 3, I'd expect you to have a <code>b'\x00\n\x00'</code> byte string, for example, while <code>match1</code> is a <i>unicode string</i>. Prepend the literal with a <code>b</code> if you are trying to match bytes.</span>
<span class="comment-copy">Removing the exit (I was using break but it didn't want to work) and would loop through the whole file in byte chunks of 3 (500mb file so lots of data).  I've just pre-appended the match string with b'..' and it still doesn't print out the result of the if statement :/  Edit- messed around with it all now working. Thanks for the help :)</span>
