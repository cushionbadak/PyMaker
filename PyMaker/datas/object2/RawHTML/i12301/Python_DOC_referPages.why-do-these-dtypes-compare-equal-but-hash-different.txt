<div class="post-text" itemprop="text">
<pre><code>In [30]: import numpy as np

In [31]: d = np.dtype(np.float64)

In [32]: d
Out[32]: dtype('float64')

In [33]: d == np.float64
Out[33]: True

In [34]: hash(np.float64)
Out[34]: -9223372036575774449

In [35]: hash(d)
Out[35]: 880835502155208439
</code></pre>
<p>Why do these dtypes compare equal but hash different?</p>
<p>Note that Python does promise that:</p>
<blockquote>
<p>The only required property is that objects which compare equal have
  the same hash valueâ€¦</p>
</blockquote>
<p>My workaround for this problem is to call <code>np.dtype</code> on everything, after which hash values and comparisons are consistent.</p>
</div>
<div class="post-text" itemprop="text">
<p>They <em>shouldn't</em> behave this way, but <code>__eq__</code> and <code>__hash__</code> for <code>numpy.dtype</code> objects are broken on an essentially unfixable design level. I'll be pulling heavily from njsmith's comments on a <a href="https://github.com/numpy/numpy/issues/5345" rel="nofollow noreferrer">dtype-related bug report</a> for this answer.</p>
<p><code>np.float64</code> isn't actually a dtype. It's a type, in the ordinary sense of the Python type system. Specifically, if you retrieve a scalar from an array of float64 dtype, <code>np.float64</code> is the type of the resulting scalar.</p>
<p><code>np.dtype(np.float64)</code> is a dtype, an instance of <code>numpy.dtype</code>. dtypes are how NumPy records the structure of the contents of a NumPy array. They are particularly important for <a href="https://docs.scipy.org/doc/numpy/user/basics.rec.html" rel="nofollow noreferrer">structured arrays</a>, which can have very complex dtypes. While ordinary Python types could have filled much of the role of dtypes, creating new types on the fly for new structured arrays would be highly awkward, and it would probably have been impossible in the days before type-class unification.</p>
<p><code>numpy.dtype</code> implements <code>__eq__</code> basically like this:</p>
<pre><code>def __eq__(self, other):
    if isinstance(other, numpy.dtype):
        return regular_comparison(self, other)
    return self == numpy.dtype(other)
</code></pre>
<p>which is pretty broken. Among other problems, it's not transitive, it raises <code>TypeError</code> when it should return <code>NotImplemented</code>, and its output is really bizarre at times because of how dtype coercion works:</p>
<pre><code>&gt;&gt;&gt; x = numpy.dtype(numpy.float64)
&gt;&gt;&gt; x == None
True
</code></pre>
<p><code>numpy.dtype.__hash__</code> isn't any better. It makes no attempt to be consistent with the <code>__hash__</code> methods of all the other types <code>numpy.dtype.__eq__</code> accepts (and with so many incompatible types to deal with, how could it?). Heck, it shouldn't even exist, because dtype objects are mutable! Not just mutable like modules or file objects, where it's okay because <code>__eq__</code> and <code>__hash__</code> work by identity. dtype objects are mutable in ways that will actually change their hash value:</p>
<pre><code>&gt;&gt;&gt; x = numpy.dtype([('f1', float)])
&gt;&gt;&gt; hash(x)
-405377605
&gt;&gt;&gt; x.names = ['f2']
&gt;&gt;&gt; hash(x)
1908240630
</code></pre>
<p>When you try to compare <code>d == np.float64</code>, <code>d.__eq__</code> builds a dtype out of <code>np.float64</code> and finds that <code>d == np.dtype(np.float64)</code> is True. When you take their hashes, though, <code>np.float64</code> uses the regular (identity-based) hash for type objects and <code>d</code> uses the hash for dtype objects. Normally, equal objects of different types should have equal hashes, but the dtype implementation doesn't care about that.</p>
<p>Unfortunately, it's impossible to fix the problems with dtype <code>__eq__</code> and <code>__hash__</code> without breaking APIs people are relying on. People are counting on things like <code>x.dtype == 'float64'</code> or <code>x.dtype == np.float64</code>, and fixing dtypes would break that.</p>
</div>
<div class="post-text" itemprop="text">
<p>As <code>tttthomasssss</code> notes, the <code>type</code> (class) for <code>np.float64</code> and <code>d</code> are different.  They are different kinds of things:</p>
<pre><code>In [435]: type(np.float64)
Out[435]: type
</code></pre>
<p>Type <code>type</code> means (usually) that it is a function, so it can be used as:</p>
<pre><code>In [436]: np.float64(0)
Out[436]: 0.0

In [437]: type(_)
Out[437]: numpy.float64
</code></pre>
<p>creating a numeric object.  Actually that looks more like a class definition.  But since <code>numpy</code> uses a lot of compiled code, and its <code>ndarray</code> uses its own <code>__new__</code>, I wouldn't be surprised if it straddles the line.</p>
<pre><code>In [438]: np.float64.__hash__??
Type:       wrapper_descriptor
String Form:&lt;slot wrapper '__hash__' of 'float' objects&gt;
Docstring:  x.__hash__() &lt;==&gt; hash(x)
</code></pre>
<p>I was thinking this would the <code>hash(np.float64)</code>, but it might actually be the hash for an object of that type, e.g. <code>hash(np.float64(0))</code>.  In that case <code>hash(np.float64)</code> just uses the default <code>type.__hash__</code> method.</p>
<p>Moving on to the <code>dtype</code>:</p>
<pre><code>In [439]: d=np.dtype(np.float64)

In [440]: type(d)
Out[440]: numpy.dtype
</code></pre>
<p><code>d</code> is not a function or class:</p>
<pre><code>In [441]: d(0)
...
TypeError: 'numpy.dtype' object is not callable

In [442]: d.__hash__??
Type:       method-wrapper
String Form:&lt;method-wrapper '__hash__' of numpy.dtype object at 0xb60f8a60&gt;
Docstring:  x.__hash__() &lt;==&gt; hash(x)
</code></pre>
<p>Looks like <code>np.dtype</code> does not define any special <code>__hash__</code> method, it just inherits from <code>object</code>.</p>
<p>Further illustrating the difference between <code>float64</code> and <code>d</code>, look at the class inheritance stack</p>
<pre><code>In [443]: np.float64.__mro__
Out[443]: 
(numpy.float64,
 numpy.floating,
 numpy.inexact,
 numpy.number,
 numpy.generic,
 float,
 object)

In [444]: d.__mro__
...
AttributeError: 'numpy.dtype' object has no attribute '__mro__'

In [445]: np.dtype.__mro__
Out[445]: (numpy.dtype, object)
</code></pre>
<p>So <code>np.float64</code> doesn't define a hash either, it just inherits from <code>float</code>.  <code>d</code> doesn't have an <code>__mro__</code> because it's an object, not a class.</p>
<p><code>numpy</code> has enough compiled code, and a long history of its own, that you can't count on Python documentation always applying.</p>
<p><code>np.dtype</code> and <code>np.float64</code> evidently have <code>__eq__</code> methods that allow them to be compared with each other, but <code>numpy</code> developers did not put any effort into making sure that the <code>__hash__</code> methods comply.  Most likely because they don't need to use either as a dictionary key.</p>
<p>I've never seen code like:</p>
<pre><code>In [453]: dd={np.float64:12,d:34}

In [454]: dd
Out[454]: {dtype('float64'): 34, numpy.float64: 12}

In [455]: dd[np.float64]
Out[455]: 12

In [456]: dd[d]
Out[456]: 34
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>They are not the same thing, while <code>np.float64</code> is a <code>type</code>, <code>d</code> is an <em>instance</em> of <code>numpy.dtype</code>, hence they hash to different values, but all instances of <code>d</code> created the same way will hash to the same value because they are identical (which of course does not necessarily mean they point to the same memory location).</p>
<p><strong>Edit:</strong></p>
<p>Given your code above you can try the following:</p>
<pre><code>In [72]: type(d)
Out[72]: numpy.dtype

In [74]: type(np.float64)
Out[74]: type
</code></pre>
<p>which shows you that the two are of different type and hence will hash to different values. Showing that different instances of <code>numpy.dtype</code> can be shown by the following example:</p>
<pre><code>In [77]: import copy
In [78]: dd = copy.deepcopy(d) # Try copying

In [79]: dd
Out[79]: dtype('float64')

In [80]: hash(dd)
Out[80]: -6584369718629170405

In [81]: hash(d) # original d
Out[81]: -6584369718629170405

In [82]: ddd = np.dtype(np.float64) # new instance
In [83]: hash(ddd)
Out[83]: -6584369718629170405

# If using CPython, id returns the address in memory (see: https://docs.python.org/3/library/functions.html#id)
In [84]: id(ddd)
Out[84]: 4376165768

In [85]: id(dd)
Out[85]: 4459249168

In [86]: id(d)
Out[86]: 4376165768
</code></pre>
<p>Its nice to see that <code>ddd</code> (the instance created the same way as <code>d</code>), and <code>d</code> itself share the same object in memory, but <code>dd</code> (the copied object) uses a different address.</p>
<p>The equality checks evaluate as you would expect, given the hashes above:</p>
<pre><code>In [87]: dd == np.float64
Out[87]: True
In [88]: d == np.float64
Out[88]: True
In [89]: ddd == np.float64
Out[89]: True
In [90]: d == dd
Out[90]: True
In [91]: d == ddd
Out[91]: True
In [92]: dd == ddd
Out[92]: True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's because you're hashing a <code>type</code> against a <code>dtype</code> object.</p>
<p>Although the values compare equal (as evidences by <code>d == np.float64</code>, their types are different:</p>
<pre><code>print type(d)
print type(np.float64)
</code></pre>
<p>Produces</p>
<blockquote>
<p>&lt;type 'numpy.dtype'&gt;</p>
<p>&lt;type 'type'&gt;</p>
</blockquote>
<p>According to the <a href="https://docs.python.org/2/library/functions.html#hash" rel="nofollow">Python docs</a>:</p>
<blockquote>
<p><code>hash</code>(object)</p>
<p>Return the hash value of the object (if it has one). Hash values are integers. They are used to quickly compare dictionary keys during a dictionary lookup. Numeric values that compare equal have the same hash value (even if they are of different types, as is the case for 1 and 1.0).</p>
</blockquote>
<p>And since a <code>dtype</code> is not a numeric type, there is no guarantee that such and object will result in the same hash as a <code>type</code> that compares equal.</p>
<hr/>
<p>EDIT:
From the <a href="https://docs.python.org/3.5/reference/datamodel.html#object.__hash__" rel="nofollow">Python 3.5 docs</a>:</p>
<blockquote>
<p><code>object.__hash__(self)</code></p>
<p>Called by built-in function hash() and for operations on members of hashed collections including set, frozenset, and dict. <strong>hash</strong>() should return an integer. The only required property is that objects which compare equal have the same hash value; it is advised to somehow mix together (e.g. using exclusive or) the hash values for the components of the object that also play a part in comparison of objects.</p>
</blockquote>
<p>Which appears to imply that <code>hash(d) == hash(np.float64)</code> should return <code>True</code> in your case.</p>
<p>I did notice that there is a note right after that states:</p>
<blockquote>
<p><code>hash()</code> truncates the value returned from an objectâ€™s custom <strong>hash</strong>() method to the size of a Py_ssize_t. This is typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.</p>
</blockquote>
<p>However, I wasn't able to determine that the size of the objects returned from the hash functions were in fact different; they appear the same (I used <code>sys.getsizeof</code>)</p>
</div>
<span class="comment-copy">Actually <code>type(d) == type(np.float64)</code> is <code>False</code>. And Python says that only " Numeric values that compare equal have the same hash value".</span>
<span class="comment-copy">If you instead say <code>d = np.float64</code>, then the hashes are equivalent.</span>
<span class="comment-copy">@AndyG Sure, but that's because they're the same object then.  Python does promise that they should hash equal if they compare equal.</span>
<span class="comment-copy">Only for numeric types</span>
<span class="comment-copy">@AndyG: See <code>__hash__</code> here: <a href="https://docs.python.org/3.5/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">docs.python.org/3.5/reference/datamodel.html#object.__hash__</a>   Is that only for numeric types?  Seems to me that invariant should hold for tuples and strings too.</span>
<span class="comment-copy">Thanks for your answer.   However, it's not impossible to fix these problems.  They can deprecate some of the poor design choices, and then after a few years replace the mechanism.  E.g., supporting <code>x.dtype == 'float64'</code> was not a good idea.</span>
<span class="comment-copy">This is exactly what I was looking for.  Thank you!</span>
<span class="comment-copy">dtype objects actually do have a custom <code>__hash__</code> implementation, but it's hard to spot, because the <code>tp_hash</code> field of the <code>PyTypeObject</code> is set in a <a href="https://github.com/numpy/numpy/blob/d4eaa2c01801ca2ce46b0c8b345367a54c8dde4b/numpy/core/src/multiarray/multiarraymodule.c#L4599" rel="nofollow noreferrer">really weird location</a>. You can see the implementation <a href="https://github.com/numpy/numpy/blob/c11628abd820a1f44b052ea87af810f8f00cf2e4/numpy/core/src/multiarray/hashdescr.c#L297" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">This looks like the right answer, but can you expand on it a little bit please?</span>
<span class="comment-copy">@NeilG I've updated my answer, I hope its what you were looking for ;)</span>
<span class="comment-copy">Please see my updated question.  I quoted another part of the docs.</span>
