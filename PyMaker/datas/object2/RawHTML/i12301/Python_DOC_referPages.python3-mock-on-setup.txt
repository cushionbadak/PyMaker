<div class="post-text" itemprop="text">
<p>I am trying to mock some 3rd part library on setup so i can pretend it works as expected on my code.</p>
<p>I was able to mock it locally on which i configure all the returns on the function itself</p>
<pre><code>    class MockConnecton:
        def __init__(self):
            self._ch = Mock()

        def channel(self):
            return self._ch

    class QEmiterTest(unittest.TestCase):
        @patch('task_queues.queue.pika.BlockingConnection')
        @patch('task_queues.queue.pika.ConnectionParameters')
        def test_emiter(self,mock_params,mock_block):
            config = {
                'host':'mq',
                'exchange':'test'
            }
            params =  {"FOO":"BAR"}
            mock_params.return_value = params
            conn = MockConnecton()
            mock_conn = Mock(wraps=conn)
            mock_block.return_value = mock_conn
            emitter = QEmitter(config['host'],config['exchange'])
            mock_params.assert_called_with(config['host'])
            mock_block.assert_called_with(params)
            mock_conn.channel.assert_called_with()
            conn._ch.exchange_declare.assert_called_with(exchange=config['exchange'],type='topic')
</code></pre>
<p>But when i try to move from this approach to a cleaner one with the <a href="https://docs.python.org/3.3/library/unittest.mock.html#patch-methods-start-and-stop" rel="nofollow">mock start/stop</a> i receive an error on the assertion:</p>
<blockquote>
<p>AttributeError: '_patch' object has no attribute 'assert_called_with'</p>
</blockquote>
<p>I am trying to port it like this </p>
<pre><code>    class QEmiterTest(unittest.TestCase):
        def setUp(self):
            mock_params = patch('task_queues.queue.pika.ConnectionParameters')
            mock_block = patch('task_queues.queue.pika.BlockingConnection')
            self.params_ret =  {"FOO":"BAR"}
            mock_params.return_value = self.params_ret
            conn = MockConnecton()
            self.mock_conn = Mock(wraps=conn)
            mock_block.return_value = self.mock_conn
            self.patch_params = mock_params
            self.patch_block = mock_block
            self.patch_params.start()
            self.patch_block.start()

        def test_emiter(self):
            config = {
                'host':'mq',
                'exchange':'test'
            }
            emitter = QEmitter(config['host'],config['exchange'])
            self.patch_params.assert_called_with(config['host'])
            self.patch_block.assert_called_with(self.params_ret)
            self.mock_conn.channel.assert_called_with()
            self.mock_conn._ch.exchange_declare.assert_called_with(exchange=config['exchange'],type='topic')

        def tearDown(self):
            self.patch_params.stop()
            self.patch_block.stop()
</code></pre>
<p>I may not fully understand the start and stop, i was under the assumpton that on setup it would apply the patch and by it's reference i would be able to make assertions . I also welcome any suggestons on how to make several mocks cleaner </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow"><code>patch</code></a> object are patch and not mock. <code>mock</code> framework have two main duties: </p>
<ol>
<li>Mock object used to record the call and follow your screenplay </li>
<li>Patch methods and object used to replace reference by something that you can use to sensor or simulate some behaviors </li>
</ol>
<p>A lot of time we can use patch to install mocks... but patch are not mock.</p>
<p><a href="https://docs.python.org/3/library/unittest.mock.html#patch-methods-start-and-stop" rel="nofollow"><code>patch.start()</code></a> return the new reference (often a mock) used to patch the original one.</p>
<pre><code>def setUp(self):
            self.params_ret =  {"FOO":"BAR"}
            self.mock_conn = Mock(wraps=conn)
            self.patch_params = patch('task_queues.queue.pika.ConnectionParameters', return_value = self.params_ret)
            self.patch_block = patch('task_queues.queue.pika.BlockingConnection', return_value=self.mock_conn)
            mock_params = self.patch_params.start()
            mock_block = self.patch_block.start()
</code></pre>
</div>
