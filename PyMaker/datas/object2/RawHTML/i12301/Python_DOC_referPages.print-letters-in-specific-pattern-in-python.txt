<div class="post-text" itemprop="text">
<p>I have the follwing string and I split it:</p>
<pre><code>&gt;&gt;&gt; st = '%2g%k%3p'
&gt;&gt;&gt; l = filter(None, st.split('%'))
&gt;&gt;&gt; print l
['2g', 'k', '3p']
</code></pre>
<p>Now I want to print the g letter two times, the k letter one time and the p letter three times:</p>
<pre><code>ggkppp
</code></pre>
<p>How is it possible?</p>
</div>
<div class="post-text" itemprop="text">
<h2>LATE FOR THE SHOW BUT READY TO GO</h2>
<p>Another way, is to define your function which converts nC into CCCC...C (ntimes), then pass it to a <code>map</code> to apply it on every element of the list <code>l</code> coming from the <code>split</code> over <code>%</code>, the finally <code>join</code> them all, as follows:</p>
<pre><code>&gt;&gt;&gt; def f(s):
        x = 0
        if s:
            if len(s) == 1:
                out = s
            else:
                for i in s:
                    if i.isdigit():
                        x = x*10 + int(i)
                out = x*s[-1]

        else:
            out = ''
        return out

&gt;&gt;&gt; st
'%4g%10k%p'
&gt;&gt;&gt; ''.join(map(f, st.split('%')))
'ggggkkkkkkkkkkp'
&gt;&gt;&gt; st = '%2g%k%3p'
&gt;&gt;&gt; ''.join(map(f, st.split('%')))
'ggkppp'
</code></pre>
<p>Or if you want to put all of these into one single function definition:</p>
<pre><code>&gt;&gt;&gt; def f(s):
        out = ''
        if s:
            l = filter(None, s.split('%'))
            for item in l:
                x = 0
                    if len(item) == 1:
                        repl = item
                    else:
                        for c in item:
                            if c.isdigit():
                                x = x*10 + int(c)
                        repl = x*item[-1]
                    out += repl

        return out

&gt;&gt;&gt; st
'%2g%k%3p'
&gt;&gt;&gt; f(st)
'ggkppp'
&gt;&gt;&gt; 
&gt;&gt;&gt; st = '%4g%10k%p'
&gt;&gt;&gt; 
&gt;&gt;&gt; f(st)
'ggggkkkkkkkkkkp'
&gt;&gt;&gt; st = '%4g%101k%2p'
&gt;&gt;&gt; f(st)
'ggggkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkpp'
&gt;&gt;&gt; len(f(st))
107
</code></pre>
<p><strong>EDIT :</strong></p>
<p>In case of the presence of <code>_</code> where the OP does not want this character to be repeated, then the best way in my opinion is to go with <a href="https://docs.python.org/3/library/re.html?highlight=re#re.sub" rel="nofollow"><code>re.sub</code></a>, it will make things easier, this way:</p>
<pre><code>&gt;&gt;&gt; def f(s):
        pat = re.compile(r'%(\d*)([a-zA-Z]+)')
        out = pat.sub(lambda m:int(m.group(1))*m.group(2) if m.group(1) else m.group(2), s)
        return out

&gt;&gt;&gt; st = '%4g_%12k%p__%m'
&gt;&gt;&gt; f(st)
'gggg_kkkkkkkkkkkkp__m'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>generator</code> with <code>isdigit()</code> to check wheter your first symbol is digit or not and then return following string with appropriate count. Then you could use <code>join</code> to get your output:</p>
<pre><code>''.join(i[1:]*int(i[0]) if i[0].isdigit() else i for i in l)
</code></pre>
<p>Demonstration:</p>
<pre><code>In [70]: [i[1:]*int(i[0]) if i[0].isdigit() else i for i in l ]
Out[70]: ['gg', 'k', 'ppp']

In [71]: ''.join(i[1:]*int(i[0]) if i[0].isdigit() else i for i in l)
Out[71]: 'ggkppp'
</code></pre>
<p><strong>EDIT</strong></p>
<p>Using <code>re</code> module when first number is with several digits:</p>
<pre><code>''.join(re.search('(\d+)(\w+)', i).group(2)*int(re.search('(\d+)(\w+)', i).group(1)) if re.search('(\d+)(\w+)', i) else i for i in l)
</code></pre>
<p>Example:</p>
<pre><code>In [144]: l = ['12g', '2kd', 'h', '3p']

In [145]: ''.join(re.search('(\d+)(\w+)', i).group(2)*int(re.search('(\d+)(\w+)', i).group(1)) if re.search('(\d+)(\w+)', i) else i for i in l)
Out[145]: 'ggggggggggggkdkdhppp'
</code></pre>
<p><strong>EDIT2</strong></p>
<p>For your input like:</p>
<pre><code>st = '%2g_%3k%3p'
</code></pre>
<p>You could replace <code>_</code> with empty string and then add <code>_</code> to the end if the work from list endswith the <code>_</code> symbol:</p>
<pre><code>st = '%2g_%3k%3p'
l = list(filter(None, st.split('%')))
''.join((re.search('(\d+)(\w+)', i).group(2)*int(re.search('(\d+)(\w+)', i).group(1))).replace("_", "") + '_' * i.endswith('_') if re.search('(\d+)(\w+)', i) else i for i in l)
</code></pre>
<p>Output:</p>
<pre><code>'gg_kkkppp'
</code></pre>
<p><strong>EDIT3</strong></p>
<p>Solution without <code>re</code> module but with usual loops working for 2 digits. You could define functions:</p>
<pre><code>def add_str(ind, st):
    if not st.endswith('_'):
        return st[ind:] * int(st[:ind])
    else:
        return st[ind:-1] * int(st[:ind]) + '_'

def collect(l):
    final_str = ''
    for i in l:
        if i[0].isdigit():
            if i[1].isdigit():
                final_str += add_str(2, i)
            else:
                final_str += add_str(1, i)
        else:
            final_str += i
    return final_str
</code></pre>
<p>And then use them as:</p>
<pre><code>l = ['12g_', '3k', '3p']

print(collect(l))
gggggggggggg_kkkppp
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One-liner Regex way:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; st = '%2g%k%3p'
&gt;&gt;&gt; re.sub(r'%|(\d*)(\w+)', lambda m: int(m.group(1))*m.group(2) if m.group(1) else m.group(2), st)
'ggkppp'
</code></pre>
<p><code>%|(\d*)(\w+)</code> regex matches all <code>%</code> and captures zero or moredigit present before any word character into one group and the following word characters into another group. On replacement all the matched chars should be replaced with the value given in the replacement part. So this should loose <code>%</code> character.</p>
<p>or</p>
<pre><code>&gt;&gt;&gt; re.sub(r'%(\d*)(\w+)', lambda m: int(m.group(1))*m.group(2) if m.group(1) else m.group(2), st)
'ggkppp'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assumes you are always printing single letter, but preceding number may be longer than single digit in base 10.</p>
<pre><code>seq = ['2g', 'k', '3p']
result = ''.join(int(s[:-1] or 1) * s[-1] for s in seq)
assert result == "ggkppp"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Loop the list, check first entry for number, and then append the second digit onwards:</p>
<pre><code>string=''
l = ['2g', 'k', '3p']
for entry in l:
    if len(entry) ==1:
        string += (entry)
    else:
        number = int(entry[0])
        for i in range(number):
            string += (entry[1:])
</code></pre>
</div>
<span class="comment-copy">Is this coming from html code?</span>
<span class="comment-copy">Will the number before the letter ever be more than a single digit? Will the number ever be zero?</span>
<span class="comment-copy">@Irano No this isnt ..</span>
<span class="comment-copy">@PM Yes it may be mor than one digit...</span>
<span class="comment-copy">You need a more formal/flushed out specification of the input language. What exactly does the <code>%</code> mean, what values for the number are valid, and what values for the "string to print" are valid? For example, what would <code>%234</code> mean? Would it mean "print <code>34</code> twice," or is it invalid since no letter follows, or something else? What about <code>%55a5</code>? Print <code>a5</code> fifty five times, maybe, or print <code>5a5</code> five times, or print <code>5</code> five times and then print <code>a5</code>? There are a ton of cases you haven't specified here.</span>
<span class="comment-copy">good, But if I say <code>st = %2g_%12k%3p</code> result is not <code>gg__kkkkkkkkkkkkkppp</code> ....</span>
<span class="comment-copy">@MLSC...what's your expected output in this case? <code>gg_kkkkkkkkkkkkkppp</code> ?</span>
<span class="comment-copy">Pardon I meant: <code>But if I say st = %2g_%12k%3p result is not </code>gg_kkkkkkkkkkkkkppp` or even when <code>st = %2g___%12k%3p</code> result must be <code>gg___kkkkkkkkkkkkkppp</code></span>
<span class="comment-copy">Thank you... Complete answer...</span>
<span class="comment-copy">@MLSC .. no pblm .. :)</span>
<span class="comment-copy">What happens when there are more than 9 of a letter?</span>
<span class="comment-copy">Then you could use <code>i[1:]</code>, edited for that</span>
<span class="comment-copy"><code>''.join(i[1:]*int(i[0]) if i[0].isdigit() else i for i in ['12g', 'k', '3p'])</code> = <code>'2gkppp'</code></span>
<span class="comment-copy">@MLSC do you need that behavior only for <code>_</code> sign?</span>
<span class="comment-copy">@MLSC try edited version. You could extend it to what you like</span>
<span class="comment-copy">can u explain why you used <code>\b</code> ?...because I think it's not necessary?</span>
<span class="comment-copy">Test: <code>re.sub(r'%(\d*)(\w*)', '-RE-',st)</code> ---&gt; <code>'-RE--RE--RE-'</code></span>
<span class="comment-copy">@IronFist ya, here it's not necessary..</span>
<span class="comment-copy">For lowercase letters only <code>r'%(\d*)([a-z]+)'</code></span>
<span class="comment-copy">Or as a one-liner: <code>result = ''.join([int(s[:-1] or 1) * s[-1] for s in st.split('%') if s])</code>. You <i>can</i> give <code>.join</code> a generator expression but it's actually more efficient to give it a list comp. <code>.join</code> has to parse its input twice: the 1st pass determines the size of the output string, the 2nd pass builds the output. So if you give <code>.join</code> a gen exp it has to run the generator and build a list from it before it can start doing the actual joining.</span>
<span class="comment-copy"><code>string</code> isn't a great variable name since it's the name of a standard Python module. Also, this answer won't work properly if a number has more than 1 digit.</span>
