<div class="post-text" itemprop="text">
<pre><code>class Card:
    def __init__(self, suit):
        self.suit = SUITS[suit]
    SUITS = ("HEARTS", "SPADES", "DIAMONDS", "CLUBS")
</code></pre>
<p>Is there anyway to directly access only one of these four values from the tuple and store it? so that i can make a new object of type Card and then set its suit, only to one of the four values in the tuple. </p>
<p>i would like to take a string as the input parameter e.g myCard = Card(HEARTS) </p>
</div>
<div class="post-text" itemprop="text">
<p>You can validate against SUITS.
If invalid suit given, may you raise a <code>ValueError</code></p>
<pre><code>class Card:
    SUITS = ("HEARTS", "SPADES", "DIAMONDS", "CLUBS")
    def __init__(self, suit):
        if suit not in self.SUITS:
             raise ValueError('invalid argument suit. must be: {}'.format(
                  ', '.join(self.SUITS)
             ))
        self.suit = suit
</code></pre>
<p>One can now create an instance by</p>
<pre><code>burp = Card('SPADES')
</code></pre>
<p>Another way could be to use <a href="https://docs.python.org/3/library/enum.html" rel="nofollow">Enum's</a> here:</p>
<pre><code>from enum import Enum
class Suits(Enum):
    HEARTS = 0
    SPADES = 1
    DIAMONDS = 2
    CLUBS = 3

class Card:
    def __init__(self, suit):
        assert(type(suit) is Suits)
        self.suit = suit

snurz = Card(Suits.CLUBS)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Within your class you need to prefix <code>SUITS</code> with <code>Card</code> (or <code>self</code>) like this:</p>
<pre><code>class Card:
    def __init__(self, suit):
        self.suit = Card.SUITS[suit]    # N.B. specify the class
    SUITS = ("HEARTS", "SPADES", "DIAMONDS", "CLUBS")

&gt;&gt;&gt; for i in range(len(Card.SUITS)):
...     c = Card(i)
...     print(c.suit)
HEARTS
SPADES
DIAMONDS
CLUBS
</code></pre>
<p>I wouldn't bother with validating the <code>suit</code> argument; if an invalid value is supplied <code>Card.SUITS[suit]</code> will raise <code>IndexError</code> if it is out of range, or <code>TypeError</code> if a non-integer argument is supplied. You could catch either exception and raise your own, if you wanted.</p>
</div>
<div class="post-text" itemprop="text">
<p>In case you want to assign <code>self.suit</code> to the given name if the value is among the acceptable ones and otherwise assign it to a default value</p>
<pre><code>&gt;&gt;&gt; class Card:
...     SUITS = {"HEARTS", "SPADES", "DIAMONDS", "CLUBS"} # you can still use the tuple if you prefer
...     def __init__(self, suit):
...         self.suit = suit if suit in self.SUITS else 'HEARTS' # default_value
... 
&gt;&gt;&gt; c=Card('abc')
&gt;&gt;&gt; c.suit
'HEARTS'
&gt;&gt;&gt; c=Card('DIAMONDS')
&gt;&gt;&gt; c.suit
'DIAMONDS'
</code></pre>
<p>Note: I agree with @keksnicoh's approach (upvoted), which raises an exception.</p>
<p>Another way can be to pass the default value as a parameter as well (explicit is better than implicit, remember?)</p>
<pre><code>&gt;&gt;&gt; class Card:
...     SUITS = ("HEARTS", "SPADES", "DIAMONDS", "CLUBS")
...     def __init__(self, suit, default='HEARTS'):
...         self.suit = suit if suit in self.SUITS else default
... 
&gt;&gt;&gt; c=Card('abc')
&gt;&gt;&gt; c.suit
'HEARTS'
&gt;&gt;&gt; c=Card('abc', 'DIAMONDS')
&gt;&gt;&gt; c.suit
'DIAMONDS'
</code></pre>
<p>However, you should still check if the default values is among the possible values and at that point raise and exception (or add it to them, depending on your goals)</p>
</div>
<span class="comment-copy">You mean like, <code>SUITS[2]</code> <code>SUITS[3]</code> or something else?</span>
<span class="comment-copy">yes but i would like to take a string as the input parameter e.g myCard = Card(HEARTS)</span>
<span class="comment-copy">You should have mentioned that you want to accept strings in your <code>__init__()</code>, or you should have provided an example usage.</span>
<span class="comment-copy">AWESOME THANK YOU!</span>
<span class="comment-copy">is there any other way without throwing an error? e.g not specifying but by default python will throw it?</span>
<span class="comment-copy">I prefer this, because I can define clean messages, so developers (including myself) get some hints whats going on when something went wrong (what valid values are available). I don't know if one can force python directly to raise an exception if an element is not in a list. You could do something like this: <code>self.suit = dict({k:True for k in self.SUITS})[self.suit]</code> but its kinda crypto and the error could be misleading.</span>
<span class="comment-copy">You can use assert. Watch my second example. Also you can use that in first example: <code>assert(suit in self.SUITS)</code></span>
<span class="comment-copy">class Card:         def __init__(self, suit):             self.suit = Card.SUITS[suit]    # N.B. specify the class         SUITS = ("HEARTS", "SPADES", "DIAMONDS", "CLUBS")      for i in range(len(Card.SUITS)):         c = Card("SPADES")         print(c.suit)  im not sure but its not working   could u give me an example</span>
<span class="comment-copy">OP has specified in a comment that <code>__init__()</code> should accept strings representing suit, invalidating this answer.</span>
<span class="comment-copy">@Mark: the for loop is the example usage. But, as I said in previous comment, this answer is invalidated by the additional string argument requirement.</span>
