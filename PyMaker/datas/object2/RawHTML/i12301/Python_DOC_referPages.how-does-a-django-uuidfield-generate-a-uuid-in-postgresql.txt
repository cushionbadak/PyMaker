<div class="post-text" itemprop="text">
<p>After reading this blog post <a href="https://blog.starkandwayne.com/2015/05/23/uuid-primary-keys-in-postgresql/" rel="noreferrer">https://blog.starkandwayne.com/2015/05/23/uuid-primary-keys-in-postgresql/</a></p>
<p>I wanted to know more about how Django generates uuid because I am using them as my pk. Well, according to the docs, <a href="https://docs.djangoproject.com/es/1.9/ref/models/fields/#uuidfield" rel="noreferrer">https://docs.djangoproject.com/es/1.9/ref/models/fields/#uuidfield</a>, Django is relying on the Python UUID module <a href="https://docs.python.org/3/library/uuid.html#uuid.UUID" rel="noreferrer">https://docs.python.org/3/library/uuid.html#uuid.UUID</a>. But there are many kinds of UUID, and it is not at all clear to me which one is being generated in Django, or how to chose, assuming a choice is available. </p>
<p>Finally, given the fragmentation issue pointed out in the blog post, and assuming <code>uuid_generate_v1mc</code> is not available directly in Python or Django, is there a way to force them to use it? </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<ul>
<li><p>How does Django and or Python generate a UUID in Postgresql?</p></li>
<li><p>But there are many kinds of UUID, and it is not at all clear to me which one is being generated in Django</p></li>
</ul>
</blockquote>
<p><strong>When you use <code>UUIDField</code> as a primary key in Django, it doesn't generate a UUID one for you, you generate it yourself before you save the object</strong></p>
<p>I don't know if things have changed since, but last time I have used a <code>UUIDField</code>, you had to specify the UUID value yourself (e.g. when you create the object, Django won't let you save an object with a blank UUID and have the database generate one). Looking at the Django documentation samples reinforces my thought, because they provide a <code>default=uuid.uuid4()</code> e.g. in the primary key.</p>
<pre><code>class MyUUIDModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
                                                    ^
                                                    |__ calls uuid.uuid4() 
</code></pre>
<h2>Which UUID version to choose</h2>
<p>For a comparison of the properties of the different UUID versions please see this question: <a href="https://stackoverflow.com/questions/20342058/which-uuid-version-to-use">Which UUID version to use?
</a></p>
<p><strong>For a lot of applications, UUID4 is just fine</strong></p>
<p>If you just want just want to generate a UUID and get on with your life, <code>uuid.uuid4()</code> like the snippet above is just fine. UUID4 is a random UUID and the chances of a collision are so remote that you don't really need to worry about, especially if you're not generating a ton of them per second.</p>
<blockquote>
<p>Finally, given the fragmentation issue pointed out in the blog post, and assuming <code>uuid_generate_v1mc</code> is not available directly in Python or Django, is there a way to force them to use it?</p>
</blockquote>
<p><strong>A Python UUID1 with random MAC address, like <code>uuid-ossp</code>'s <code>uuid_generate_v1mc</code></strong></p>
<p>The blog you linked mentions the use of UUID1. Python's <code>uuid.uuid1()</code> takes a parameter that is used instead of the default real hardware MAC address (48 bits). Because these random bits are the end of the UUID1, the first bits of the UUID1 can be sequential/timestamp-based to limit the index fragmentation.</p>
<p>So </p>
<pre><code>uuid.uuid1(random_48_bits)
</code></pre>
<p>Should get you similar results as <a href="http://www.postgresql.org/docs/9.4/static/uuid-ossp.html" rel="noreferrer"><code>uuid_generate_v1mc</code></a>, which is a UUID1 with a random MAC address.</p>
<p>To generate a random 48 bits, as a dummy example we can use:</p>
<pre><code>import random
random_48_bits = random.randint(0, 2**48 - 1)
</code></pre>
<p>Try it:</p>
<pre><code>&gt;&gt;&gt; import uuid
&gt;&gt;&gt; import random
&gt;&gt;&gt; 2 ** 48 - 1
281474976710655
&gt;&gt;&gt; uuid.uuid1(random.randint(0, 281474976710655))
UUID('c5ecbde1-cbf4-11e5-a759-6096cb89d9a5')
</code></pre>
<p>Now make a function out of it, and use it as the <code>default</code> for your Django <code>UUIDField</code></p>
<p><strong>Custom UUIDs, and an example from Instagram</strong></p>
<p>Note that it's totally fine to come up with your custom UUID scheme, and use the available bits to encode information that can be useful to your application.</p>
<p>E.g. you may use a few bits to encode the country of a given user, a few bits with a timestamp, some bits for randomness etc.</p>
<p>You may want to read how <a href="http://instagram-engineering.tumblr.com/post/10853187575/sharding-ids-at-instagram" rel="noreferrer">Instagram (built on Django and PostgreSQL) cooked up their own UUID scheme to help with sharding</a>.</p>
</div>
<span class="comment-copy">RE: Twitter Snowflake: "We have retired the initial release of Snowflake and working on open sourcing the next version based on Twitter-server, in a form that can run anywhere without requiring Twitter's own infrastructure services." <a href="https://github.com/twitter/snowflake" rel="nofollow noreferrer">github.com/twitter/snowflake</a></span>
<span class="comment-copy">What about the fragmentation issue?</span>
<span class="comment-copy">@MalikA.Rumi Added a snippet how to generate a UUID1 with random 48 bits MAC address, just like the <code>uuid_generate_v1mc</code> suggest by the blog to limit the index fragmentation.</span>
<span class="comment-copy">thanks, a very thorough answer. I look forward to whatever is coming with Twitter Snowflake, and I will try your approach to making a custom uuid. Also, note that today I came across this SO answer about performance:  <a href="http://stackoverflow.com/questions/29880083/postgresql-uuid-type-performance" title="postgresql uuid type performance">stackoverflow.com/questions/29880083/â€¦</a>.</span>
<span class="comment-copy">What if I am generating a ton of uuid's per second? For example, I'm adding a UUIDField to a model containing 93,000 records. When I run the migration, I keep getting an IntegrityError - the uuid's are colliding. Is there any way to guarantee the generating uuid is unique?</span>
