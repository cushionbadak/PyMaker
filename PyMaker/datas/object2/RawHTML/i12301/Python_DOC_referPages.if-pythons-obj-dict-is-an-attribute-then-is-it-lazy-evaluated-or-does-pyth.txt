<div class="post-text" itemprop="text">
<p>I just read the Python's <code>__dict__</code> is actually an attribute, not a method.  And <code>vars(obj)</code> is the same as <code>obj.__dict__</code>.</p>
<p>If <code>__dict__</code> is an attribute, then does Python actively maintain it (seems unlikely), or lazily compose it -- and how?</p>
</div>
<div class="post-text" itemprop="text">
<p>The way I picture it is that an object stores it's attributes in a dictionary, which you can access via</p>
<pre><code>obj.__dict__
</code></pre>
<p>That is a dictionary, not a string.  It is <code>print(obj.__dict__)</code> or <code>str(obj.__dict__)</code> that creates a string from a dictionary.</p>
<p>The attributes can also be accessed by name, which is translated into a method call, and (effectively) dictionary access.</p>
<pre><code>obj.a =&gt; obj.__getattr__('a') &lt;=&gt; obj.__dict__['a'] 
</code></pre>
<p>And as you note <code>vars(obj)</code> is another way of fetching this dictionary.</p>
<p>The interpreter maintains a large number of dictionaries, including one attached to each object (with a few exceptions).  But don't confuse maintaining a dictionary with the act of displaying it.  The dictionary exists whether you print it or not.</p>
<p>And as discussed in the comments, one object's dictionary can contain pointers to other objects, each of which will have their own dictionary of attributes.</p>
</div>
<span class="comment-copy">Why does it seem unlikely that <code>__dict__</code> exists non-lazily as an ordinary dict?</span>
<span class="comment-copy">because if an object has 25 attributes, does that mean Python has to compose the string busily to put into <code>__dict__</code> and that it might never even get used? (for example, if one integer value in the object changes, now Python has to run through all 25 attributes to compose <code>__dict__</code>?  What if one attribute in the object is an array (a list) with 100,000 elements?)</span>
<span class="comment-copy">The dict does not store <i>copies</i> of the attributes.  It stores references to their values.  If an object has an attribute that is an array with 100,000 elements, the array itself will of course take up memory, but storing it in the <code>__dict__</code> takes up (almost) no additional memory.</span>
<span class="comment-copy">Remark: <code>__dict__</code> is not an attribute as those are stored into <code>__dict__</code> which would create a reference loop for each object. Rather it is a <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">descriptor</a> that exposes the underlying dict of the object. You can have objects without their own dict if you set the <code>__slots__</code> class attribute.</span>
