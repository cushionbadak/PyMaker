<div class="post-text" itemprop="text">
<p>I have two lists <code>list1</code> and <code>list2</code> of numbers, and I want to iterate over them with the same instructions. Like this:</p>
<pre><code>for item in list1:
  print(item.amount)
  print(item.total_amount)

for item in list2:
  print(item.amount)
  print(item.total_amount)
</code></pre>
<p>But that feels redundant. I know I can write <code>for item in list1 + list2:</code>, but it has a price of running-time.</p>
<p>Is there a way do that without loose time?</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be done with <strong><a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain</code></a></strong>:</p>
<pre><code>import itertools

l1 = [1, 2, 3, 4]
l2 = [5, 6, 7, 8]

for i in itertools.chain(l1, l2):
    print(i, end=" ")
</code></pre>
<p>Which will print:</p>
<pre><code>1 2 3 4 5 6 7 8 
</code></pre>
<p>As per the documentation, <code>chain</code> does the following:</p>
<blockquote>
<p>Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the iterables are exhausted.</p>
</blockquote>
<p>If you have your lists in a list, <strong><a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>itertools.chain.from_iterable</code></a></strong> is available:</p>
<pre><code>l = [l1, l2]
for i in itertools.chain.from_iterable(l):
    print(i, end=" ")
</code></pre>
<p>Which yields the same result.</p>
<p>If you don't want to import a module for this, writing a function for it is pretty straight-forward:</p>
<pre><code>def custom_chain(*it):
    for iterab in it:
        yield from iterab
</code></pre>
<p>This requires Python 3, for Python 2, just <code>yield</code> them back using a loop:</p>
<pre><code>def custom_chain(*it):
    for iterab in it:
        for val in iterab:
            yield val
</code></pre>
<p>In addition to the previous, Python <code>3.5</code> with its extended unpacking generalizations, also allows unpacking in the list literal:</p>
<pre><code>for i in [*l1, *l2]:
    print(i, end=" ")
</code></pre>
<p>though this is slightly faster than <code>l1 + l2</code> it still constructs a list which is then tossed; only go for it as a final solution.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>chain</code> works, but if you feel that it's overkill to import a module just to call a single function once, you can replicate its behavior inline:</p>
<pre><code>for seq in (list1, list2):
  for item in seq:
    print(item.amount)
    print(item.total_amount)
</code></pre>
<p>Creating the (list1, list2) tuple is O(1) with respect to list length, so it should perform favorably in comparison to concatenating the lists together.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>for item in list1 + list2:
    print(item.amount)
    print(item.total_amount)
</code></pre>
<p>Only 3 lines</p>
</div>
<span class="comment-copy">If i will add 'if' condition with 'break' inside loop and it would be trigger in first list, the second one will not run, right?</span>
