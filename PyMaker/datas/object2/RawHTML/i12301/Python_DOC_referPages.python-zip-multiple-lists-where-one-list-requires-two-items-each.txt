<div class="post-text" itemprop="text">
<p>I have the following lists as an example:</p>
<pre><code>a = ['#12908069', '#12906115', '#12904949', '#12904654', '#12904288', '#12903553']    
b = ['85028,', '83646,', '77015,', '90011,', '91902,', '80203,']    
c = ['9.09', '9.09', '1.81', '3.62', '1.81', '1.81', '9.09', '9.09', '1.81', '3.62', '1.81', '1.81']    
d = ['Zone 3', 'Zone 3', 'Zone 2']
</code></pre>
<p>What I'd like to achieve as an output, the first item set zipped as an example:</p>
<pre><code>[('#12908069', '85028', (9.09, 9.09), 'Zone 3'), ...]
</code></pre>
<p>How do I get <code>zip()</code> to add an extra item for each tuple from list <code>c</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>you can use list slices with a step of 2, see <a href="https://stackoverflow.com/a/509295/1176601">Explain Python's slice notation</a>:</p>
<pre><code>list(zip(a,b,zip(c[0::2],c[1::2]),d))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>using <em>an idiom for clustering a data series into n-length groups</em> from the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow">zip documentation</a>:</p>
<pre><code>&gt;&gt;&gt; gr = [iter(c)]*2
&gt;&gt;&gt; list(zip(a, b, zip(*gr), d))
[('#12908069', '85028,', ('9.09', '9.09'), 'Zone 3'),
 ('#12906115', '83646,', ('1.81', '3.62'), 'Zone 3'),
 ('#12904949', '77015,', ('1.81', '1.81'), 'Zone 2')]
</code></pre>
<p>essentially, in order to get two consecutive elements from list <code>c</code> we put the same iterator on it in the <code>gr</code> list, which is made of two elements.</p>
<p>Then we pass those same iterators to zip (unpacking the list, as if we had passed the two iterators as two separate arguments to it).</p>
<p>That has the effect of collecting each two consecutive elements from list <code>c</code>.</p>
<p>We then pass such zip and the other lists to zip again to scan and pair the whole lot.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using one of the <a href="https://docs.python.org/3.5/library/itertools.html#itertools-recipes" rel="nofollow">recipes</a> from <a href="https://docs.python.org/3.5/library/itertools.html" rel="nofollow"><code>itertools</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import zip_longest
&gt;&gt;&gt; 
&gt;&gt;&gt; def grouper(iterable, n, fillvalue=None):
...     "Collect data into fixed-length chunks or blocks"
...     # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
...     args = [iter(iterable)] * n
...     return zip_longest(*args, fillvalue=fillvalue)
... 
&gt;&gt;&gt; list(zip(a, b, grouper(c, 2), d))
[('#12908069', '85028,', ('9.09', '9.09'), 'Zone 3'), ('#12906115', '83646,', ('1.81', '3.62'), 'Zone 3'), ('#12904949', '77015,', ('1.81', '1.81'), 'Zone 2')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try the following code:</p>
<pre><code>a = ['#12908069', '#12906115', '#12904949', '#12904654', '#12904288', '#12903553']
b = ['85028,', '83646,', '77015,', '90011,', '91902,', '80203,']
c = ['9.09', '9.09', '1.81', '3.62', '1.81', '1.81', '9.09', '9.09', '1.81', '3.62', '1.81', '1.81']
d = ['Zone 3', 'Zone 3', 'Zone 2']

result = list(zip(a, b, [(c[i*2],c[i*2+1]) for i in range(len(c)//2)], d))
print(result)
</code></pre>
</div>
<span class="comment-copy">Simplest answer, thanks!</span>
<span class="comment-copy">this is clever, but very un-maintainable IMO, I had to wrap my head around 2 copies of a reference to the same iterator</span>
<span class="comment-copy">@Aprillion such idiom is quite common for clustering a data series into n-length groups</span>
<span class="comment-copy">hmm, looks like it's been added to the documentation - <a href="https://bugs.python.org/issue23695" rel="nofollow noreferrer">bugs.python.org/issue23695</a> - I will just have to get used to it :)</span>
<span class="comment-copy">@Aprillion BTW, note how it does not create any new list (at least in python 3), whereas slicing does.</span>
<span class="comment-copy"><code>result = list(zip(...</code> will do. No need for <code>i,j,m,n</code></span>
<span class="comment-copy">@Pynchia Thanks for pointing this out, I have modified it.</span>
