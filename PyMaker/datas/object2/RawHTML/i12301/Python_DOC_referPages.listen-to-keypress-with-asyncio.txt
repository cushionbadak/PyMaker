<div class="post-text" itemprop="text">
<p>Can somebody provide a sample of code which listen to keypress in nonblocking manner with asynio and put the keycode in console on every click?</p>
<p>It's not a question about some graphical toolkit</p>
</div>
<div class="post-text" itemprop="text">
<p>So the link provided by Andrea Corbellini is a clever and thorough solution to the problem, but also quite complicated.  If all you want to do is prompt your user to enter some input (or simulate raw_input), I prefer to use the much simpler solution:</p>
<pre><code>import sys
import functools
import asyncio as aio

class Prompt:
    def __init__(self, loop=None):
        self.loop = loop or aio.get_event_loop()
        self.q = aio.Queue(loop=self.loop)
        self.loop.add_reader(sys.stdin, self.got_input)

    def got_input(self):
        aio.ensure_future(self.q.put(sys.stdin.readline()), loop=self.loop)

    async def __call__(self, msg, end='\n', flush=False):
        print(msg, end=end, flush=flush)
        return (await self.q.get()).rstrip('\n')

prompt = Prompt()
raw_input = functools.partial(prompt, end='', flush=True)

async def main():
    # wait for user to press enter
    await prompt("press enter to continue")

    # simulate raw_input
    print(await raw_input('enter something:'))

loop = aio.get_event_loop()
loop.run_until_complete(main())
loop.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternative to using queues would be to make the command line an asyn generator, and process the commands as they come in, like so:</p>
<pre><code>import asyncio
import sys

class UserInterface(object):

def __init__(self, task, loop):
    self.task = task
    self.loop = loop

    def get_ui(self):
        return asyncio.ensure_future(self._ui_task())

    async def _ui_cmd(self):
        while True:
            cmd = sys.stdin.readline()
            cmd = cmd.strip()
            if cmd == 'exit':
                self.loop.stop()
                return
            yield cmd

    async def _ui_task(self):
        async for cmd in self._ui_cmd():
            if cmd == 'stop_t':
                self.task.stop()
            elif cmd == 'start_t':
                self.task.start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wrote something similar as part of a package called <a href="https://github.com/vxgmichel/aioconsole" rel="nofollow noreferrer">aioconsole</a>. </p>
<p>It provides a coroutine called <code>get_standard_streams</code> that returns two <a href="https://docs.python.org/3/library/asyncio-stream.html#streams-coroutine-based-api" rel="nofollow noreferrer">asyncio streams</a> corresponding to <code>stdin</code> and <code>stdout</code>. </p>
<p>Here's an example:</p>
<pre><code>import asyncio
import aioconsole

async def echo():
    stdin, stdout = await aioconsole.get_standard_streams()
    async for line in stdin:
        stdout.write(line)

loop = asyncio.get_event_loop()
loop.run_until_complete(echo())
</code></pre>
<p>It also includes an asynchronous equivalent to <code>input</code>:</p>
<pre><code>something = await aioconsole.ainput('Entrer something: ') 
</code></pre>
<p>It should work for both file and non-file streams. See the implementation <a href="https://github.com/vxgmichel/apython/blob/master/aioconsole/stream.py" rel="nofollow noreferrer">here</a>.</p>
</div>
<span class="comment-copy">Do you want to wait for data on standard input, or is your question about a graphical toolkit? In the latter case, what graphical toolkit?</span>
<span class="comment-copy">no graphical toolkit just a console application</span>
<span class="comment-copy">Here you can find an example for reading from stdin an writing to stdout: <a href="https://gist.github.com/nathan-hoad/8966377" rel="nofollow noreferrer">gist.github.com/nathan-hoad/8966377</a> -- In that example, stdin is line-buffered (i.e. you read line-by-line). You want an unbuffered stdin (so that you can read char-by-char)</span>
<span class="comment-copy">thanks! I guess it is similar to the thing which I'm looking for</span>
<span class="comment-copy">@AndreaCorbellini consider posting an answer</span>
<span class="comment-copy">Does not work for me on Windows. :)</span>
<span class="comment-copy">@wolfdawn, unfortunately windows does not support reading from <code>stdin</code> in an asychronous way, see (<a href="https://stackoverflow.com/questions/31510190/aysncio-cannot-read-stdin-on-windows" title="aysncio cannot read stdin on windows">stackoverflow.com/questions/31510190/â€¦</a>) for more info</span>
