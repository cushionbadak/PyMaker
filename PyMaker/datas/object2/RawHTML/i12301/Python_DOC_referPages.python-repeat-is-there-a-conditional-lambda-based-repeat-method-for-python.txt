<div class="post-text" itemprop="text">
<p>I have the following function</p>
<pre><code>def handle(x):
    if is_odd(x):
        return x * 3 + 1
    return x // 2
</code></pre>
<p>and I want to run it repetively feeding the value returned from handle(x) into itself until it returns 1</p>
<p>i.e. handle(...handle(handle(handle(x)))...) until one of them in the chain returns a 1</p>
<pre><code>repeat(handle(x), lambda x: x != 1)
</code></pre>
<p>I want to write something like this:</p>
<pre><code>(let n = handle(x) until n != 1)
</code></pre>
<p>well basically I want to store the output of handle until I get 1.</p>
<pre><code>expression(handle(10)) = [5,
                         16,
                         8,
                         4,
                         2,
                         1]
</code></pre>
<p>Is there a generator expression equivalent of this? or a functools.repeat method I could use for this?</p>
<p>Just to be clear, I would like to avoid directly using a for loop with a yield or recursion. I would like to use python in built features to solve this excluding the for loop/recursion.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>itertools.accumulate</code> and <code>itertools.takewhile</code>, I guess:</p>
<pre><code>from itertools import accumulate, takewhile, repeat

def collatz(n):
    seq = accumulate(repeat(n), lambda x,_: handle(x))
    return list(takewhile(lambda x: x!=1, seq)) + [1]
</code></pre>
<p>which gives</p>
<pre><code>&gt;&gt;&gt; collatz(5)
[5, 16, 8, 4, 2, 1]
&gt;&gt;&gt; collatz(17)
[17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
</code></pre>
<p>but I share the common view that I don't see the point here.  Even the official documentation lists a lot of <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">recipes</a> which are handy for working with iterables which aren't built-in; I don't see why you couldn't just define something like</p>
<pre><code>def repeat_until(fn, x, cond):
    while True:
        yield x
        if cond(x): break
        x = fn(x)
</code></pre>
<p>and get on with your day.  I know you've said you don't want to use <code>yield</code> explicitly for some reason, but just because you say you want something doesn't mean that what you want makes any sense. :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>You do not need no magical methods for working with Collatz Conjecture, just write a regular loop</p>
<pre><code>def expression(n):
  result = [n]
  while n &gt; 1:
    n = handle(n)
    result.append(n)
  return result
</code></pre>
<p>in particular you can make it a generator</p>
<pre><code>def expression_gen(n):
  yield n
  while n &gt; 1:
    n = handle(n)
    yield n
</code></pre>
<p>and obviously you can parametrize it through</p>
<pre><code>def expression_gen(n, handle, end):
  yield n
  while not end(n):
    n = handle(n)
    yield n
</code></pre>
<p>and you can call it with lambda expression as handle/end.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, here's what I think is the canonical approach using a generator and a while loop.</p>
<pre><code>def handle(x):
    while x != 1:
        x = x*3 + 1 if x%2 else x//2
        yield x
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; list(handle(10))
[5, 16, 8, 4, 2, 1]
</code></pre>
<p>The other option which comes close to what you are looking for is to use recursion and the <code>yield from</code> syntax, if your Python version supports it:</p>
<pre><code>def handle(x):
    if x!= 1:
        x = x*3 + 1 if x%2 else x//2
        yield x
        yield from handle(x)
</code></pre>
<p>There's a problem with this approach, though, which is blowing up the stack:</p>
<pre><code>&gt;&gt;&gt; for x in handle(1E1000): pass
[...]
RecursionError: maximum recursion depth exceeded in comparison
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use while loop :</p>
<pre><code>def handle(num):
    while num &gt; 1:
        if num % 2 == 0:
            num //= 2
            print(num)
        else:
            num = 3 * num + 1
            print(num)


if __name__ == '__main__':
    handle(10)
</code></pre>
</div>
<span class="comment-copy">what is the desired output? <code>handle</code> does not have side effects and the ultimate return value <code>1</code> is known up front... also, the for loops, yield and recursion are all built-in features of python...</span>
<span class="comment-copy">I think I know what you want, can you give the output you expect for, say, handle(10)?</span>
<span class="comment-copy">yes ill clarify the answer</span>
<span class="comment-copy">Is your built-in restriction for the sake of speed? I don't see how calling lambdas in a repeat-like-function-with-an-exit-condition would save you any time compared to using a while loop.</span>
<span class="comment-copy">I suppose what you wanted might be Haskell's <code>let n = 10:map handle (tail n)</code></span>
<span class="comment-copy">hahaha :) "but just because you say you want something doesn't mean that what you want makes any sense" :) yes but this is what I was looking for Thanks alot!</span>
<span class="comment-copy">it looks like there is already "right" answer:)</span>
