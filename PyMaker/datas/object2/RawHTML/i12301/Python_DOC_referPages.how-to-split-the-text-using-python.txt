<div class="post-text" itemprop="text">
<pre><code>f_output.write('\n{}, {}\n'.format(filename, summary))
</code></pre>
<p>I am printing the output as the name of the file. I am getting the output as VCALogParser_output_ARW.log, VCALogParser_output_CZC.log and so on. but I am interested only in printing ARW, CZC and so on. So please someone can tell me how to split this text ?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are only interested in <code>CZC</code> and <code>ARW</code> without the <code>.log</code> then, you can do it with <a href="https://docs.python.org/3/library/re.html?highlight=re#re.search" rel="nofollow"><code>re.search</code></a> method:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; s1 = 'VCALogParser_output_ARW.log'
&gt;&gt;&gt; s2 = 'VCALogParser_output_CZC.log'
&gt;&gt;&gt; re.search(r'.*_(.*)\.log', s1).group(1)
'ARW'
&gt;&gt;&gt; re.search(r'.*_(.*)\.log', s2).group(1)
'CZC'
</code></pre>
<p>Or better maker your patten <code>p</code> then call its <code>search</code> method when formatting your string:</p>
<pre><code>&gt;&gt;&gt; p = re.compile(r'.*_(.*)\.log')
&gt;&gt;&gt; 
&gt;&gt;&gt; '\n{}, {}\n'.format(p.search(s1).group(1), p.search(s2).group(1))
'\nARW, CZC\n'
</code></pre>
<p>Also, it might be helpful using <a href="https://docs.python.org/3/library/re.html?highlight=re#re.sub" rel="nofollow"><code>re.sub</code></a> with positive look ahead and group naming:</p>
<pre><code>&gt;&gt;&gt; p = re.compile(r'.*(?&lt;=_)(?P&lt;mystr&gt;[a-zA-Z0-9]+)\.log$')
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; p.sub('\g&lt;mystr&gt;', s1)
'ARW'
&gt;&gt;&gt; p.sub('\g&lt;mystr&gt;', s2)
'CZC'
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; '\n{}, {}\n'.format(p.sub('\g&lt;mystr&gt;', s1), p.sub('\g&lt;mystr&gt;', s2))
'\nARW, CZC\n'
</code></pre>
<p>In case, you are not able or you don't want to use <code>re</code> module, then you can define lengths of strings that you don't need and index your string variables with them:</p>
<pre><code>&gt;&gt;&gt; i1 = len('VCALogParser_output_')
&gt;&gt;&gt; i2 = len ('.log')
&gt;&gt;&gt; 
&gt;&gt;&gt; '\n{}, {}\n'.format(s1[i1:-i2], s2[i1:-i2])
'\nARW, CZC\n'
</code></pre>
<p>But keep in mind that the above is valid as long as you have those common strings in all of your string variables.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>filename.split('_')[-1].split('.')[0]
</code></pre>
<p>this will give you : 'ARW'</p>
<pre><code>summary.split('_')[-1].split('.')[0]
</code></pre>
<p>and this will give you: 'CZC'</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>fname.split('_')[-1] 
</code></pre>
<p>is rought but this will give you 'CZC.log', 'ARW.log' and so on, assuming that all files have the same underscore-delimited format.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the format of the file is always such that it ends with <code>_ARW.log</code> or <code>_CZC.log</code> this is really easy to do just using the standard string <code>split()</code> method, with two consecutive splits:</p>
<pre><code>shortname = filename.split("_")[-1].split('.')[0]
</code></pre>
<p>Or, to make it (arguably) a bit more readable, we can use the <code>os</code> module:</p>
<pre><code>shortname = os.path.splitext(filename)[0].split("_")[-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also try:</p>
<pre><code>&gt;&gt;&gt; s1 = 'VCALogParser_output_ARW.log'
&gt;&gt;&gt; s2 = 'VCALogParser_output_CZC.log'
&gt;&gt;&gt; s1.split('_')[2].split('.')[0]
ARW
&gt;&gt;&gt; s2.split('_')[2].split('.')[0]
CZC
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>Parse file name correctly, so basically my guess is that you wanna to strip file extension <code>.log</code> and prefix <code>VCALogParser_output_</code> to do that it's enough to use <a href="https://docs.python.org/2/library/stdtypes.html#str.replace" rel="nofollow">str.replace</a> rather than using <strong>str.split</strong></li>
<li>Use <a href="https://docs.python.org/2/library/os.html#os.linesep" rel="nofollow"><strong>os.linesep</strong></a> when you writing to file to have cross-browser</li>
</ol>
<p>Code below would perform desired result(after applying steps listed above):</p>
<pre><code>    import os

    filename = 'VCALogParser_output_SOME_NAME.log'
    summary = 'some summary'
    fname = filename.replace('VCALogParser_output_', '').replace('.log', '')
    linesep = os.linesep

    f_output.write('{linesep}{fname}, {summary}{linesep}'
                   .format(fname=fname, summary=summary, linesep=linesep))

    # or if vars in execution scope strictly controlled pass locals() into format
    f_output.write('{linesep}{fname}, {summary}{linesep}'.format(**locals()))
</code></pre>
</div>
<span class="comment-copy">You can use a regular expression.</span>
<span class="comment-copy">Is it without <code>.log</code> as well ?</span>
