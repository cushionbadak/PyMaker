<div class="post-text" itemprop="text">
<p>some device returns data (hex bytes) in the form of </p>
<pre><code>data = b'\x07\x89\x00\x00\x12\x34'
</code></pre>
<p>How can I convert this to something in the form of the following?</p>
<pre><code>['0x0789', '0x0000', '0x1234']
</code></pre>
<p>I already tried compositions of hexlify. I am using Python 3.5.</p>
</div>
<div class="post-text" itemprop="text">
<p>Take groups of two from your <code>bytes</code> object. Multiply the first value from each group with 16**2. Add the two values. Use <code>hex</code> on the result to convert it to its string representation.</p>
<pre><code>&gt;&gt;&gt; [hex(data[i]*16**2 + data[i+1]) for i in range(0,len(data),2)]
['0x789', '0x0', '0x1234']
</code></pre>
<p>I assume that you don't need your strings padded with useless zeros for now.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/2/library/struct.html" rel="nofollow">struct</a> module; it has <code>unpack</code> function which allows to specify the chunk size size (byte, 2-byte, 4-bytes) and endianess in the data. If what you have is big-endian half-word sized data chunks, then the right format key is "&gt;H".</p>
<p>To parse all data at one, add count in the format specifier: for example "&gt;3H" for you input array. You can also write the number of fields dynamically.</p>
<p>Full example:</p>
<pre><code>import struct
data = b'\x07\x89\x00\x00\x12\x34'
d = struct.unpack("&gt;{}H".format(len(data) // 2), data) # extract fields
result = [hex(x) for x in d] # convert to strings
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are two steps:</p>
<ol>
<li>Chunk the input bytestring into 2-byte sequences</li>
<li>Display the sequences as hex literals.</li>
</ol>
<p>You could <a href="https://docs.python.org/3/library/array.html" rel="nofollow noreferrer">use <code>array</code> module from stdlib</a>:</p>
<pre><code>import sys
from array import array

a = array('H', data)
if sys.byteorder != 'big':
    a.byteswap() # use big-endian order
result = ['0x%04X' % i for i in a]
# -&gt; ['0x0789', '0x0000', '0x1234']
</code></pre>
<p>It is efficient, <a href="https://stackoverflow.com/a/5805696/4279">especially if you need to read data from a file</a>.</p>
</div>
<span class="comment-copy">I think your question title is a little misleading. What you actually want is to convert \xAB\xCD to \xABCD for a sequence of bytes and get the string representation. Can you come up with a better title?</span>
<span class="comment-copy">also: <code>'0x%02X%02X' % tuple(data[i:i+2])</code></span>
<span class="comment-copy">@J.F.Sebastian I don't get your comment, can you elaborate?</span>
<span class="comment-copy"><code>['0x%02X%02X' % tuple(data[i:i+2]) for i in range(0,len(data),2)]</code></span>
<span class="comment-copy">Returns  <code>struct.error: bad char in struct format</code></span>
<span class="comment-copy">@PatrickBateman My mistake, should have noticed this  is Python 3. You should also tag the question with <code>python-3</code> tag. The difference is that <code>/</code> is always floating-point division in Py3, should use <code>//</code> instead.</span>
