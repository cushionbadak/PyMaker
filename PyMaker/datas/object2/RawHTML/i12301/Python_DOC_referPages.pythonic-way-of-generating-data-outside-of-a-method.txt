<div class="post-text" itemprop="text">
<p>A silly question, but this is bugging me (regardless of downvotes for my imbecility!): I think I have picked up a nonsensical fear of generating data outside of a method that method uses (without changing), but I am unsure if this is the case.</p>
<p>Let's say I have a method <code>myfx</code>, that will need some dictionary <code>datadex</code> that requires a lengthy operation to make, but will be common to all the calls during that session. The simplest, but not doable, way is:</p>
<pre><code>def myfx(x,foo):
    datadex={f:42 for f in foo} #initialise
    mungeddata=datadex[x]+1  #munge
    return mungeddata
</code></pre>
<p>but that will waste too much time. So the best thing would be to make it in the main scope once as one does with class variables:</p>
<pre><code>datadex={f:42 for f in foo} #initialise
def myfx(x):
    mungeddata=datadex[x]+1  #munge
    return mungeddata
</code></pre>
<p>However, I do not know why, but I go to great lengths to avoid this. It is inelegant, but I don't think that is the case. I generally resort to closures:</p>
<pre><code>def initialise(foo):
    datadex={f:42 for f in foo} #initialise
    def myfx(x):
        mungeddata=datadex[x]+1  #munge
        return mungeddata
    return myfx
</code></pre>
<p>Or worse making a class. I code nearly exclusively in Python and JS. My best guess is it is a throwback from my Perl coding days —Subconsciously I somethinge find myself writing variables first alla Pascal, so I think some habits linger as shadows—, but that would not explain the class or closure way as OO-Perl is completely different.</p>
</div>
<div class="post-text" itemprop="text">
<p>A class is the right way to encapsulate this behavior. You have some data that is shared by multiple function calls.</p>
<pre><code>class MungedData(object):

    def __init__(self, foo):
        self.datadex = {f:42 for f in foo}

    def myfx(self, x):
        return self.datadex[x] + 1

md = MungedData(somefoo)
print(md.myfx(arg1))
print(md.myfx(arg2))
</code></pre>
<p>While there are certainly other alternatives, this is going to be the most common and straightforward method in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python functions are objects and can have attributes, if you don't want to have your function inside a class you can do something like this:</p>
<pre><code>def myfx(x):
    mungeddata=myfx.datadex[x]+1  #munge
    return mungeddata
myfx.datadex={f:42 for f in foo} #initialise
</code></pre>
<p>I guess that what you are trying to avoid is having a global variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>if you really just want to avoid object oriented programming you can do the following to create a map where the <code>get_dict()</code> uses a generator to store the dict.</p>
<pre><code>def get_dict():
  d = {f:42 for f in foo}
  while True:
    yield d

def myfx(x):
  datadex = get_dict()
  return datadex[x]+1 #munge

return myfx
</code></pre>
</div>
<span class="comment-copy">Yeah, that <code>initialise</code> method is basically doing partial function application.  There's a helper for just that in <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer">functools</a> called <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer">partial</a></span>
<span class="comment-copy">It sounds like this is a reflex you've brought over from JS, where polluting the global namespace is a bad idea - but from my admittedly much more limited experience with python I'd say it's not a major concern in that language?</span>
<span class="comment-copy"><i>Or worse making a class</i>.  What is so bad about using classes? Especially in cases where all the methods inside the class are sharing the same data.  That would be preferable to using global variables within a module, no?  And far better than using closures, which limits your external interface to a single function.</span>
<span class="comment-copy">I think it's just a matter of learning and familiarizing yourself with good Object-Oriented design patterns.  Perl and javascript both have hacky forms of OO, which aren't that much different than closures, which might explain your hesitance to use OO, and use of closure-style "classes" (a la JS) in python.</span>
<span class="comment-copy">@MatteoFerla What makes a class overkill? Surely if you came from a Java background you wouldn't see it that way ;)</span>
<span class="comment-copy">To me this looks like trying to solve the problem using "a hacky form of OO" as @Brendan Abel called it in the comments above. That makes sense when proper OO isn't available, such as in JS, but why limit yourself to that in Python?</span>
<span class="comment-copy">The fact that functions can take attributes is more of an accident of how Python is designed, rather than a feature to take advantage of. I'm not sure I've ever seen it used.</span>
<span class="comment-copy">@Nico JS doesn't have "proper OO"? I didn't know, everything I've read about it must be wrong. Python is multiparadigm, it doesn't force any style on developers, and there is nothing wrong with free functions.</span>
<span class="comment-copy">It's also a little fragile: if <code>myfx</code> is rebound, then the body of this function will try to access <code>datadex</code> on the <i>new</i> object, not the function itself.</span>
<span class="comment-copy">Name lookups in the body occur when the function is called, so <code>myfx</code> doesn't specifically refer to whatever the current <code>def</code> statement will bind to <code>myfx</code>. It's a corner case, for sure, but something to watch out for. Instance methods are a much safer way to associate functions and data.</span>
