<div class="post-text" itemprop="text">
<p>The objective of my assignment is to produce list elements indefinitely.
So I did this: </p>
<pre><code>SERVERS = ['APP1', 'APP2', 'APP3']
#SERVERS = ['APP1', 'APP2', 'APP3', 'APP4', 'APP5', 'APP6']
length = len(SERVERS)

def get_server():
    current_server = SERVERS.pop(0)
    SERVERS.append(current_server)
    return current_server

if __name__ == '__main__':
    for i in range(9):
        print get_server()
</code></pre>
<p>The solution has something like this: </p>
<pre><code>SERVERS = ['APP1', 'APP2', 'APP3']
#SERVERS = ['APP1', 'APP2', 'APP3', 'APP4', 'APP5', 'APP6']

def get_server():
    def f():
        while True:
            i = SERVERS.pop(0)
            SERVERS.append(i)
            yield i
    return next(f())

if __name__ == '__main__':
    for i in range(9):
        print get_server()
</code></pre>
<p>The output although is same in both the cases:</p>
<pre><code>codewingx@CodeLair:~/repo/python$ python load_balancer.py
APP1
APP2
APP3
APP1
APP2
APP3
APP1
APP2
APP3
</code></pre>
<p>So how is generator function beneficial?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Use <code>itertools.cycle()</code></h2>
<p>The generator does not add anything useful here. I would try to avoid <code>pop(0)</code> as it triggers a rebuild of the whole server list each time. </p>
<p>I would recommend <a href="https://docs.python.org/3/library/itertools.html?highlight=cycle#itertools.cycle" rel="nofollow">itertools.cycle()</a>:</p>
<pre><code>from __future__ import print_function

from itertools import cycle

SERVERS = ['APP1', 'APP2', 'APP3']

servers = cycle(SERVERS)

for i in range(9):
    print(next(servers))
</code></pre>
<p>Output:</p>
<pre><code>APP1
APP2
APP3
APP1
APP2
APP3
APP1
APP2
APP3
</code></pre>
<p>Our wrapped in a function to match your usage:</p>
<pre><code>def make_get_server():
    servers = cycle(SERVERS)
    def get_server():
        return next(servers)
    return get_server

get_server = make_get_server()

for i in range(9):
    print(get_server())
</code></pre>
<p>Output: </p>
<pre><code>APP1
APP2
APP3
APP1
APP2
APP3
APP1
APP2
APP3
</code></pre>
<h2>Write you own generator function</h2>
<p>To make the point for a generator, a variation that takes advantage of its ability to store stet might more useful:</p>
<pre><code>def gen():
    index = 0
    end = len(SERVERS)
    while True:
        yield SERVERS[index]
        index += 1
        if index &gt;= end:
            index = 0
</code></pre>
<p>While this illustrates nicely that you have state working with <code>index</code>, the same can be achieved more easily with:</p>
<pre><code>def gen():
    while True:
        for server in SERVERS:
            yield server

g = gen()

def get_server():
    return next(g)
</code></pre>
<p>This avoids modifying the list of <code>SERVERS</code>. The result is the same:</p>
<pre><code>for i in range(9):
    print(get_server())
</code></pre>
<p>Output: </p>
<pre><code>APP1
APP2
APP3
APP1
APP2
APP3
APP1
APP2
APP3
</code></pre>
<h2>How a generator works</h2>
<p>A simple generator function:</p>
<pre><code>&gt;&gt;&gt; def gen():
...     print('start')
...     yield 1
...     print('after 1')
...     yield 2
...     print('after 2')
...
</code></pre>
<p>Make an instance:</p>
<pre><code>&gt;&gt;&gt; g = gen()
</code></pre>
<p>Use <code>next</code> to get the next value returned by <code>yield</code>:</p>
<pre><code>&gt;&gt;&gt; next(g)
start
1
</code></pre>
<p>Keep going:</p>
<pre><code>&gt;&gt;&gt; next(g)
after 1
2
</code></pre>
<p>Now it is exhausted:</p>
<pre><code>&gt;&gt;&gt; next(g)
after 2

StopIteration  next(g)
</code></pre>
<p>You may think of cursor that moves along in the generator function. Every time you call <code>next()</code> it moves to the next <code>yield</code>. So putting the <code>yield</code> in a <code>while True</code> loop makes an infinite generator. As long as you don't call <code>close()</code> on it, it gives you a new value with <code>yield</code>. Also, you have state inside the generator. This means you can do things like incrementing counters between calls to <code>next()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A list is its own generator in this context:</p>
<pre><code>for i in SERVERS:
    do_something_with_element(i)
</code></pre>
<p>If you want an infinite generator, @MikeMüller's <code>itertools.cycle</code> is preferred for not-reinventing-the-wheel. If you must do your own:</p>
<pre><code>def my_cycle(s):
    while True:
        for i in s:
             yield i
</code></pre>
<p>but don't, it is less efficient and asks more of the code reader's memory.</p>
</div>
<span class="comment-copy">That's an unpythonic code sample in a few ways. Find a better tutorial. <a href="https://wiki.python.org/moin/BeginnersGuide/NonProgrammers" rel="nofollow noreferrer">wiki.python.org/moin/BeginnersGuide/NonProgrammers</a> <a href="https://wiki.python.org/moin/BeginnersGuide/Programmers" rel="nofollow noreferrer">wiki.python.org/moin/BeginnersGuide/Programmers</a></span>
<span class="comment-copy">I am still struggling to understand a yield. The docs say yield is the point where the execution stops and resumes right from this point when the call to function is made again. I liked the create your own generator method.</span>
<span class="comment-copy">@AmreshVenugopal I like to thing of generator as a virtual list that contain everything that it produce, but unlike list, it have its own syntax, is one use only and can have infinity elements but it have none until you ask for one, in that moment the generator is execute until the first yield and stay there until you ask for the next element and it execute until the next yield, and so on</span>
<span class="comment-copy">@Mike Müller, your edit was great help in understanding. I now completely understand what yield and next have to do with generators.</span>
<span class="comment-copy">I'm glad that it helped.</span>
<span class="comment-copy">@Copperfield It was hard to wrap my head around this new concept. I am just learning and this was an interesting concept altogether. Realising that a list may have a lot of data brings the true use of a virtual list.</span>
