<div class="post-text" itemprop="text">
<p>What is the fastest way of getting the filename of a specific file in a directory with python (without having to load the entire list of files first)?</p>
<p>I have directories with thousands of files in, and need to access specific files in these directories. Specifically, I need the file that is e.g. the 1000th in the file list. I want to do this without reading in all files and then selecting the one I want. Is there a way of specifying the index of the file (e.g. the 1000th one listed in the directory) and making python (or OS) return the name of only that particular file?</p>
<p>I need to do this again and again for different files in different directories, and therefore do not want to load all files in each directory as it will take too long.</p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't reach the thousandth file without iterating through the first 999, though you don't need to iterate the whole directory if you have Python 3.5 which adds <a href="https://docs.python.org/3/library/os.html#os.scandir" rel="nofollow"><code>os.scandir</code></a> (or you install the <code>scandir</code> third party package for older Python).</p>
<p>Combine with <code>islice</code>, and you'll easily skip the first 999 entries:</p>
<pre><code>import itertools
import os

# Will raise StopIteration if you don't have 1000 files
file1000 = next(itertools.islice(os.scandir(somedir), 999, None)).path
</code></pre>
<p>Note that directory ordering of files is not necessarily meaningfully ordered by timestamp, name, etc., so odds are, the 1000th entry is not predictable. You probably want to find some way of identifying the correct file by name, rather than scanning for it by arbitrary listing order.</p>
<p>If you do need the Xth entry in some order other than natural iteration order, you'll need to iterate the whole thing to sort it, but <code>os.scandir</code> could still save you some work; it's generally faster than <code>os.listdir</code> and depending on OS may give you some of the stat information "for free", avoiding per-file <code>stat</code>-ing; for example as you mentioned in your comments, you want to order by timestamp, and it's possible you want to skip directories and only count files:</p>
<pre><code>from operator import methodcaller

# Only count files for finding entry #1000
filesonly = filter(methodcaller('is_file'), os.scandir(somedir))

# Sort by time, and keep the thousandth
# On Windows, you may want st_ctime instead of st_mtime
# Raises IndexError if &lt; 1000 files in dir
file1000 = sorted(filesonly, key=lambda x: x.stat().st_mtime)[999].path
</code></pre>
<p>You can reduce the peak memory cost a bit by replacing <code>sorted</code> with <a href="https://docs.python.org/3/library/heapq.html#heapq.nsmallest" rel="nofollow"><code>heapq.nsmallest</code></a>; it's a little slower if the number to retrieve is a significant fraction of the total inputs, but it caps memory usage (and can be faster if the directory contains millions of files, and you only want #1000):</p>
<pre><code>from heapq import nsmallest

# Get the 1000th file never storing info on more than 1000 at a time
file1000 = nsmallest(1000, filesonly, key=lambda x: x.stat().st_mtime)[999].path
</code></pre>
<p>You can't avoiding some processing here, but it can potentially reduce memory overhead and per-file <code>stat</code>ing overhead a lot vs. non-<code>scandir</code> based solutions.</p>
<p>Per your comments, it seems like you really want the 1000th file alphabetically, not by modification time or directory order (the <code>ls</code> command sorts alphabetically automatically, you only see true directory order running <code>/bin/ls -U</code>). You also seem to only care about files ending in <code>.fits</code>, and want only files, not directories. In that case, the complete solution is just:</p>
<pre><code>from operator import attrgetter

# Keep only files with matching extension
filesonly = (e for e in os.scandir(somedir) if e.is_file() and e.name.endswith('.fits'))

# Keep the "smallest" 1000 entries sorted alphabetically by name
# then pull off the 1000th entry
# End with .name instead of .path if you don't need the whole path
file1000 = nsmallest(1000, filesonly, key=attrgetter('name'))[999].path
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it in this way by using <code>subprocess</code> if you have <strong>Python 3</strong>. It works only for <em>linux</em>.</p>
<pre><code>import subprocess

my_dir = r"/foo/bar"  #Assign your directory path here
extension = r'*.fits' #File extension to be searched for
nth_file = str('1000')  #nth file in the directory order

#If you want the files sorted in the timestamp order, you can replace 'ls -1U' with 'ls -tU'
cmd1 = r'ls -1U '+my_dir+extension # ls -1U /foo/bar/*.fits
cmd2 = r'sed "'+nth_file+'q;d"' # sed "1000q;d"

ls_output = subprocess.Popen(cmd1, shell=True,universal_newlines=True, stdout=subprocess.PIPE)
final_output = subprocess.Popen(cmd2, shell=True, universal_newlines=True, stdin=ls_output.stdout, stdout=subprocess.PIPE)
req_file_path = final_output.communicate()[0]

#Retrieving only filename from full path
index = req_file_path.rfind('/')
file_name = req_file_path[index+1:]

print(file_name)
</code></pre>
</div>
<span class="comment-copy">Are files always in a specific order in your directories?</span>
<span class="comment-copy">Yes, they are ordered with timestamps. However, I do not know the exact timestamps themselves (they are different for different directories). What I want is to take the e.g. the 1000th one from each directory (these will all be close enough in time for my purpose). Thanks.</span>
<span class="comment-copy">Thanks! This is really useful. I'm running python 2.7 so I've installed scandir and it seems to be quite a lot faster than my original attempt. One more question: the files I want are specifically .fits files (there are other files with different extensions in the directories too). So specifically, I want the e.g. 1000th .fits file. Is there a way to specify finding only .fits files?</span>
<span class="comment-copy">@gpce: Just replace <code>filesonly = filter(methodcaller('is_file'), os.scandir(somedir))</code> with <code>fileonly = (e for e in os.scandir(somedir) if e.is_file() and e.name.endswith('.fits'))</code>.</span>
<span class="comment-copy">thanks. The two methods you suggest (using sorted() and nsmallest() with the 'fileonly' you specified in your comment) are both much faster than I was originally doing (commands.getoutput('ls *.fits').split('\n')[999]) but they do not give the same results. Nor actually do they give the same results as each other. Do you know why this is?</span>
<span class="comment-copy">I need a method to consistently get the 1000th file <i>as it is listed in the directory</i> because I also compare this to the 1000th element in an array whose elements correspond to data from each file (in order of how they are listed in the directory). In case it is helpful the .fits files are named 'procIMAGE*.fits' where * is a number of increasing value. If you have any suggestions that would be great. Thanks again for the help so far!</span>
<span class="comment-copy">@gpce: "As it is listed in the directory" is going to differ by the tool you use for listing. The output from <code>ls</code> and <code>dir</code> isn't typically in directory order (the order the entries are stored in in the file system raw data), they usually sort alphabetically unless you pass switches to disable that (to see the "true" directory order on *NIX, run <code>/bin/ls -U -1</code>). So your <code>commands.getoutput('ls *.fits').split('\n')[999]</code> is actually getting the 1000th file alphabetically, not by modification time.</span>
<span class="comment-copy">Thanks, your method works well. It takes about the same time as my original method of using commands.getoutput() (but is more sophisticated) and @ShadowRanger's methods above.</span>
<span class="comment-copy">@gpce If this helped you, reward me by giving an upvote. So, other people may consider looking at this in the future.</span>
<span class="comment-copy">Yes, it was helpful - I tried upvoting already but apparently I need to earn a total of 15 reputation before my votes change the publicly displayed post score. Sorry. Let me know if I missed something...</span>
