<div class="post-text" itemprop="text">
<p>I am trying to implement the following pseudo-code (partly inspired from what would be possible with the <a href="https://msdn.microsoft.com/en-us/library/dd449174%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" rel="nofollow"><code>TaskCompletionSource&lt;T&gt;</code></a> in .NET), where the objective is to wait for a particular event to be received to continue execution (or throw a <code>TimeoutError</code>):</p>
<pre><code>from axel import Event

def _wait_for_provider_up(self, data_provider: Provider, ms_timeout: int) -&gt; bool:
    if provider.State == ProviderState.Connected: return True
    if provider.State == ProviderState.Faulted: return False
    taskCompletion = TaskCompletionSource&lt;bool&gt;()

    def onStateChanged(sender, e: ProviderStateChangedEventArgs):
        if e.State == ProviderState.Connected:
            taskCompletion.TrySetResult(True)
        elif e.State == ProviderState.Faulted:
            taskCompletion.TrySetResult(False)

    provider.StateChanged += onStateChanged
    try:
        if provider.State == ProviderState.Connected: return True
        elif provider.State == ProviderState.Faulted: return False
        if not taskCompletion.Task.Wait(ms_timeout) or not taskCompletion.Task.Result or provider.State != ProviderState.Connected:
            return False
    finally:
        provider.StateChanged -= onStateChanged
    return True
</code></pre>
<p>What would be a recommended pythonic (or .NET-ish but python-compatible) way to achieve that?</p>
</div>
<div class="post-text" itemprop="text">
<p>I've tried to rewrite your code in <code>asyncio</code> way but please pay attention: function <code>_wait_for_provider_up</code> has been changed to <code>coroutine</code>: </p>
<pre><code>from axel import Event

async def _wait_for_provider_up(self, data_provider: Provider, ms_timeout: int) -&gt; bool:
    if provider.State == ProviderState.Connected: 
        return True
    if provider.State == ProviderState.Faulted: 
        return False
    taskCompletion = asyncio.Future()

    def onStateChanged(sender, e: ProviderStateChangedEventArgs):
        if e.State == ProviderState.Connected:
            taskCompletion.set_result(True)
        elif e.State == ProviderState.Faulted:
            taskCompletion.set_result(False)

    provider.StateChanged += onStateChanged
    try:
        if provider.State == ProviderState.Connected: 
            return True
        elif provider.State == ProviderState.Faulted: 
            return False
        try:
            result = await asyncio.wait_for(taskCompletion, timeout=ms_timeout/1000)
            if not result or provider.State != ProviderState.Connected:
                return False
        except asyncio.TimeoutError:
            return False  
    finally:
        provider.StateChanged -= onStateChanged
    return True
</code></pre>
<p>The code is still not very pythonic but I hope you'll get my point.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming the provider is a python thread. 
You can use the join(timeout) method which waits for the thread to compete or the timeout. 
join() always returns None so to check if the thread is still alive you need to use isAlive(). 
Here is one option in implementing the taskCompletion</p>
<pre><code>def taskCompletion(thread,timeout): 
   thread.join(timeout) 
   return isAlive()  
</code></pre>
</div>
<span class="comment-copy">What is the equivalent of a Task in Python? TaskCompletionSource wasn't created to implement timeouts, it was created to support Tasks. Check  <a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow noreferrer">Couroutines and Tasks</a></span>
<span class="comment-copy">I could not find a drop-in replacement of Task either (asyncio is pretty limited compared to the TPL)... Here this could also be done with ManualResetEvents, or other low level logic, but I am interested in the best possible abstraction.</span>
<span class="comment-copy">Thanks, in asyncio doc, they recommend never to instantiate a <code>Future</code> directly, do you think it is safe? Why did you need to convert the function to a coroutine with async (since there is no await inside)?</span>
<span class="comment-copy">Sorry, I've missed <code>await</code> before <code>wait_for</code>.  Usually you don't need to instantiate <code>Future</code> but use a coroutine that returns a future object from very deep guts.  In your case using future is fine because <code>onStateChanged</code> actually doesn't perform IO but sets future value immediately.</span>
<span class="comment-copy">Is it possible to <code>wait_for</code> without <code>await</code>, like <code>Task.Result</code> or <code>Task.Wait()</code> in .NET? The purpose of the function is to wait, so it would be better not to have to return an awaitable...</span>
<span class="comment-copy">Nope. Unlike .NET Python has no implicit event loop inside.  That's design decision which dictates the asyncio poison rule: if your function need <code>await</code> calls it should be <code>async def</code>. Every call of async functions should be <code>async def</code> too -- up to coping with asyncio loop functions.</span>
<span class="comment-copy">Noted, then to make a function calling <code>_wait_for_provider_up</code> to actually wait for it (with a blocking call) rather than awaiting it, should it create its own event loop and call <code>loop.run_until_complete(just_print_messages())</code>?</span>
<span class="comment-copy">The provider thread runs an infinite loop, so here the idea is to use a signaling logic (or the timeout if the signal has not been set).</span>
