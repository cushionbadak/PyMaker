<div class="post-text" itemprop="text">
<p>I have some directories which I want to delete but one of the directory has a sub-directory that I want to keep.</p>
<p>Example:</p>
<blockquote>
<p>Files</p>
<blockquote>
<p>pictures</p>
<blockquote>
<p>cat.png</p>
<p>icon.png</p>
</blockquote>
<p>Music</p>
<blockquote>
<p>song.mp3</p>
</blockquote>
</blockquote>
<p>Movies</p>
<blockquote>
<p>First.mp4</p>
</blockquote>
</blockquote>
<p>I want to delete everything (directories and sub-directories) except the sub-directory pictures for example.</p>
<p>Right now I have this:</p>
<pre><code>def Destroy_Path(path):
    shutil.rmtree(path, ignore_errors=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution. <strong><em>UNTESTED!</em></strong></p>
<p>Note the use of <code>os.walk()</code>'s ability to change <code>dirnames</code> in-place to tell it not to recurse into a sub-directory, and the avoidance of using <code>topdown=False</code> which would break this feature:</p>
<blockquote>
<p>When <em>topdown</em> is <code>True</code>, the caller can modify the dirnames list in-place
  (perhaps using <code>del</code> or slice assignment), and <code>walk()</code> will only recurse
  into the subdirectories whose names remain in <em>dirnames</em>; this can be
  used to prune the search, [...]
  Modifying <em>dirnames</em> when <em>topdown</em> is <code>False</code> has no effect on the behavior of the walk, because in bottom-up mode the directories in <em>dirnames</em> are generated before <em>dirpath</em> itself is generated.</p>
</blockquote>
<p>See <a href="https://docs.python.org/3.5/library/os.html#os.walk" rel="nofollow">the docs</a> for more information.</p>
<p>Also notable is the use of <code>os.path.samefile()</code> for path comparisons. This is <a href="https://docs.python.org/3/library/os.path.html#os.path.samefile" rel="nofollow">available on Windows since version 3.2</a>.</p>
<p><em>THIS IS UNTESTED!</em></p>
<p><strong>USE AT YOUR OWN RISK!!</strong></p>
<p><strong><em>SERIOUSLY, BE CAREFUL!!!</em></strong></p>
<pre><code>import os

def gen_dir_paths_except(base_path, exceptions):
    # behave like os.walk(): return nothing if the given path isn't a directory
    if not os.path.isdir(base_path):
        return

    # keep only existing paths in exceptions, so that os.path.samefile() works
    exceptions = list(filter(os.path.exists, exceptions))

    # don't forget the base directory
    if any(os.path.samefile(base_path, x) for x in exceptions):
        return
    yield base_path

    for curr_dirpath, dirnames, filenames in os.walk(base_path):    
        # skip directories mentioned in exceptions
        dirnames_to_skip = []
        for dir_name in dirnames:
            dir_path = os.path.join(curr_dirpath, dir_name)
            if any(os.path.samefile(dir_path, x) for x in exceptions):
                dirnames_to_skip.append(dir_name)
            else:
                yield dir_path
        for dir_name in dirnames_to_skip:
            dirnames.remove(dir_name)

def rmtree_except(path, exceptions):
    # Check that the path is actually a directory. This is needed here
    # because os.walk() will silently return nothing for a non-directory.
    if not os.path.isdir(path):
        if not os.path.exists(path):
            raise OSError("No such directory: " + path)
        else:
            raise OSError("Not a directory: " + path)

    # keep only existing paths in exceptions, so that os.path.samefile() works
    exceptions = list(filter(os.path.exists, exceptions))

    dirs = list(gen_dir_paths_except(path, exceptions))
    # iterate through directories in bottom-up order
    for dir_path in reversed(dirs):
        filenames = [
            x for x in os.listdir(dir_path)
            if not os.path.isdir(os.path.join(dir_path, x))
        ]
        for file_name in filenames:
            # skip files mentioned in exceptions
            file_path = os.path.join(dir_path, file_name)
            if not any(os.path.samefile(file_path, x) for x in exceptions):
                os.remove(file_path)

        try:
            os.rmdir(dir_path)
        except OSError: # directory not empty
            pass # just leave the directory
</code></pre>
</div>
<span class="comment-copy">Move <code>pictures</code> to somewhere else, delete everything, move it back.</span>
<span class="comment-copy">Would you accept any standard *nix tool e.g. <code>find</code> based solution?</span>
<span class="comment-copy">@Selcuk Moving, deleting and moving back would not work since intermediate directories would have been deleted in the meantime. One could re-create the required directory structure for each file/folder to be kept, but the meta-data for the intermediate directories (such as permissions and modification dates) would have been lost.</span>
<span class="comment-copy">This seems like way overkill. Just define a small function that protects every single folder you're interested in by moving it from the current path to a temp directory, use shutil.rmtree, and then move it back  Or, better yet, open up Nautilus.</span>
<span class="comment-copy">@AlexanderHuszagh Moving, deleting and moving back would not work since intermediate directories would have been deleted in the meantime. One could re-create the required directory structure for each "protected" item, but the meta-data for these directories (such as permissions and modification dates) would have been lost.</span>
<span class="comment-copy">It's a great solution for a complex, comprehensive problem. But unless if it's a highly unusual circumstance (like a remote log, where someone needs write access to a dir but no read access and read access to the parent but no write), simplicity will work just as well in every other case. If they needed to match a given file name, which might be at any level in the directory hierarchy, then a walk approach is great.</span>
<span class="comment-copy">@AlexanderHuszagh A "simple" solution as you suggest would not actually be significantly simpler: At a minimum, it would have to check if each exception actually exists, move it to a temporary directory, call <code>rmtree()</code>, and re-create any intermediate directories <i>for each protected item</i> before moving it back.</span>
