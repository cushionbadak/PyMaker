<div class="post-text" itemprop="text">
<p>Please explain to me the following. If I execute this:</p>
<pre><code>class Base1:
    def foo(self):
        print('in Base1.foo')

b1 = Base1()
b1.foo()


class Base2:
    def foo(self):
        print('in Base2.foo')

b2 = Base2()
b2.foo()

class Child1(Base1, Base2):
    def foo(self):
        super(Child1,self).foo()

c1 =  Child1()
c1.foo()

class Child2(Base1, Base2):
    def foo(self):
        super(Base1,self).foo()

c2 =  Child2()
c2.foo()
</code></pre>
<p>I get this:</p>
<pre><code>in Base1.foo
in Base2.foo
in Base1.foo
in Base2.foo
</code></pre>
<p>I understand the first three lines of the output. But why do I have to give the name of the first base class to <code>super()</code> in order to get the method of the second base class?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are mucking with the <a href="https://www.python.org/download/releases/2.3/mro/" rel="nofollow"><em>Method Resolution Order</em></a>, or <em>MRO</em>. Python class inheritance hierarchies are <em>linearised</em>, given a specific order, according to a system called the <a href="https://en.wikipedia.org/wiki/C3_linearization" rel="nofollow"><em>C3 linearisation</em></a>.</p>
<p><code>super()</code> uses that order to find the <em>next</em> attribute (including methods) in that ordering. Given a current instance, and a class, it'll search the order for an attribute <strong>past</strong> the given class. For both <code>Child*</code> classes, the MRO lists the <code>Child*</code> class first, followed by <code>Base1</code> and <code>Base2</code>. In your last example you told <code>super()</code> to go looking in that MRO starting from the next class after <code>Base1</code>, so only <code>Base2.foo()</code> remains to be found.</p>
<p>You can ask any class for its MRO by calling the <a href="https://docs.python.org/3/library/stdtypes.html#class.mro" rel="nofollow"><code>class.mro()</code> method</a>:</p>
<pre><code>&gt;&gt;&gt; Child2.mro()
[&lt;class '__main__.Child2'&gt;, &lt;class '__main__.Base1'&gt;, &lt;class '__main__.Base2'&gt;, &lt;class 'object'&gt;]
</code></pre>
<p><code>super()</code> can be used <em>outside</em> methods too; you can then easily see what happens when you pick different starting points for the search:</p>
<pre><code>&gt;&gt;&gt; super(Child2, Child2()).foo
&lt;bound method Base1.foo of &lt;__main__.Child2 object at 0x10f40ff98&gt;&gt;
&gt;&gt;&gt; super(Base1, Child2()).foo
&lt;bound method Base2.foo of &lt;__main__.Child2 object at 0x10f40ffd0&gt;&gt;
&gt;&gt;&gt; super(Base2, Child2()).foo
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'super' object has no attribute 'foo'
</code></pre>
</div>
<span class="comment-copy">I was aware of the the method resolution order, but I didn't know that super() gets the "next" base class in line... thanks</span>
