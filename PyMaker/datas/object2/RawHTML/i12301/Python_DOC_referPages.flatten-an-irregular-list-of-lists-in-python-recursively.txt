<div class="post-text" itemprop="text">
<p>I searched and found question with same heading is also (<a href="https://stackoverflow.com/questions/406121/flattening-a-shallow-list-in-python">here</a> <a href="https://stackoverflow.com/questions/10632111/how-to-flatten-a-hetrogenous-list-of-list-into-a-single-list-in-python">here</a> <a href="https://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python">here</a> <a href="https://stackoverflow.com/questions/2158395/flatten-an-irregular-list-of-lists-in-python">here</a> <a href="https://stackoverflow.com/questions/12472338/flattening-a-list-recursively">here</a>) but I am not asking that. I came across the problem:</p>
<p>To write a function to flatten a list. The list contains other lists, strings, or ints.</p>
<p>And my code for the same is</p>
<pre><code>t=[]
def flatten(aList):
    for i in aList:
        if type(i) !=list:
             t.append(i)
        else:
             flatten(i)

    return t     
</code></pre>
<p>But when I check the code for test cases:</p>
<ol>
<li><code>flatten([[1], [1]])</code> : The checker tells me the output is<code>[1, 1, 1, 1]</code> but in codeskulptor I get the correct output which is <code>[1, 1]</code>    .    </li>
<li><code>flatten([[[1]], [[[5]]]])</code>: The checker tells the output is <code>[1, 1, 1, 1, 1, 2, 3, 3, 2, 1, 0, 4, 5, 6, 7, 1, 5]</code> but in codeskulptor tells <code>[1, 5]</code>.    </li>
</ol>
<p>This problem exists with many test cases.
Then I checked my code in python tutor and found out that after the if statement is executed each time the list <code>t</code> is returned and at-last when the function comes to halt it returns the last edited list <code>t</code>.</p>
<p>How can I resolve this issue please help me with this and yes I am new to python and do not know anything about itertools, lambda function usage, generators etc. so please tell me in the context in which I can understand.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code is relying on a global; if the checker calls your function twice, it'll receive a longer list than expected:</p>
<pre><code>&gt;&gt;&gt; t = []
&gt;&gt;&gt; def flatten(aList):
...     for i in aList:
...         if type(i) !=list:
...              t.append(i)
...         else:
...              flatten(i)
...     return t
...
&gt;&gt;&gt; flatten([1, 1])
[1, 1]
&gt;&gt;&gt; flatten([1, 1])
[1, 1, 1, 1]
&gt;&gt;&gt; t  # your global, still holding all those values:
[1, 1, 1, 1]
</code></pre>
<p>Don't use globals. Use a local list, and and extend it with the result of recursive calls:</p>
<pre><code>def flatten(aList):
    t = []
    for i in aList:
        if not isinstance(i, list):
             t.append(i)
        else:
             t.extend(flatten(i))
    return t
</code></pre>
<p>Note that I switched to using <code>isinstance()</code> to test for the type. This version doesn't suffer from shared state leaking into the next call:</p>
<pre><code>&gt;&gt;&gt; def flatten(aList):
...     t = []
...     for i in aList:
...         if not isinstance(i, list):
...              t.append(i)
...         else:
...              t.extend(flatten(i))
...     return t
...
&gt;&gt;&gt; flatten([1, 1])
[1, 1]
&gt;&gt;&gt; flatten([1, 1])
[1, 1]
&gt;&gt;&gt; flatten([[[1]], [[[5]]]])
[1, 5]
&gt;&gt;&gt; flatten([1, 1, [42, 81]])
[1, 1, 42, 81]
</code></pre>
</div>
<span class="comment-copy">The second link you have gives a working example of this function.</span>
<span class="comment-copy">@Morgan Thrapp that code also does not solve my real problem</span>
<span class="comment-copy">Just for code styling: You should use <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer"><code>isinstance()</code></a> instead of using <code>type(&lt;var&gt;) == type(&lt;var&gt;)</code>.</span>
<span class="comment-copy">Why not? It works for both of your test cases. If this question doesn't actually ask about your problem, you should ask a new question.</span>
<span class="comment-copy">@MorganThrapp: that question doesn't explain what is wrong with the code in this question. Sometimes it is <i>okay</i> to ask a question about a specific piece of code that doesn't work, if the OP is trying has made a good-faith attempt to figure this out on their own. Closing this as a dupe will not answer this question.</span>
<span class="comment-copy">@MorganThrapp: it is fine to ask about a good attempt to implement that. They are asking <b>why</b> their attempt doesn't work.</span>
<span class="comment-copy">@MorganThrapp: in other words, find a good dupe where the answer is "don't use a global because your state now leaks into future calls" and I'll gladly vote to close too.</span>
<span class="comment-copy">@johnsmith: because you don't want to discard the result produced by the recursive call. A recursive function call is like any other function call, if that function returns a result, don't ignore it.</span>
<span class="comment-copy">@johnsmith: try it out. Replace the <code>t.extend(flatten(i))</code> call with <code>flatten(i)</code>, and call your function with <code>flatten([1, [2, [3]])</code>. What happens?</span>
<span class="comment-copy">@johnsmith: or do something different: create a series of identical <code>flattenN()</code> functions, where <code>N</code> is a number. <code>flatten1()</code>, <code>flatten2()</code>, etc. Each function N calls N + 1. You can extend the series as far as you need to; for a list with 3 levels of nesting you only need to go to <code>flatten3()</code>. What do you think will happen when you use <code>t.extend(flatten2(i))</code> in <code>flatten1()</code>, and what do you think happens when you use just <code>flatten2(i)</code>?</span>
