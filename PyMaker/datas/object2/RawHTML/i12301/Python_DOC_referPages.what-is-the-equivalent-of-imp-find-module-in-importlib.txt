<div class="post-text" itemprop="text">
<p>Some of my code use the now deprecated <em>imp</em> package to find a module</p>
<pre><code>toolboxFile, toolboxPath, toolboxDescription = imp.find_module("Tools")
</code></pre>
<p>What is the equivalent function or code to get the same results with package <em>importlib</em> ?</p>
</div>
<div class="post-text" itemprop="text">
<h3>Same folder</h3>
<p>If the module is in your working directory, <a href="http://docs.python.org/3.6/library/importlib.html#importlib.util.find_spec" rel="nofollow noreferrer"><code>importlib.util.find_spec</code></a> probably suffices for your purposes. </p>
<p>For example if you just want to load the module, you can use:</p>
<ul>
<li><p><strong>deprecated in Python 3.5 and higher:</strong></p>
<pre><code>toolbox_specs = importlib.util.find_spec("Tools")
toolbox = toolbox_specs.loader.load_module()
</code></pre></li>
<li><p><strong>introduced in Python 3.5 and higher:</strong></p>
<pre><code>toolbox_specs = importlib.util.find_spec("Tools")
toolbox = importlib.util.module_from_spec(toolbox_specs)
toolbox_specs.loader.exec_module(toolbox)
</code></pre>
<p><em>Caveat: I haven’t tested this, but it’s straight from the <a href="http://docs.python.org/3.6/library/importlib.html#examples" rel="nofollow noreferrer">documentation</a>, so I suppose it works.</em></p></li>
</ul>
<p>You can assess several other properties with the <code>toolbox_specs</code> object.
However, e.g., a corresponding file object is not amongst them.
If you really need this in Python 3, you probably have to obtain the file’s path and open it with other methods.</p>
<h3>Different folder</h3>
<p>To find a module in a different folder, you have to work with a <a href="http://docs.python.org/3/library/importlib.html#importlib.machinery.FileFinder" rel="nofollow noreferrer"><code>FileFinder</code></a>, which in turn needs to know the module’s type. For example, if your module is an extension, you can find the specs as follows:</p>
<pre><code>loader_details = (
    importlib.machinery.ExtensionFileLoader,
    importlib.machinery.EXTENSION_SUFFIXES
    )

toolsfinder = importlib.machinery.FileFinder("Folder_of_Tools", loader_details)
toolbox_specs = toolsfinder.find_spec("Tools")
</code></pre>
<p>You can then process <code>toolbox_specs</code> as described above.</p>
</div>
<div class="post-text" itemprop="text">
<p>I found this worked as a replacement for imp.find_module()</p>
<pre><code>importlib.machinery.PathFinder().find_spec(modName, modDirList)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to Python official documentation in this page <a href="https://docs.python.org/3/library/imp.html#imp.find_module" rel="nofollow">imp</a></p>
<p><code>find_module</code> Deprecated since version 3.3 Use <code>importlib.util.find_spec()</code> instead unless Python 3.3 compatibility is required, in which case use <code>importlib.find_loader()</code>.</p>
<p>Use  <code>importlib.util.find_spec("Tools")</code> for find spec for more information you can see this <a href="https://docs.python.org/3/library/importlib.html#importlib.util.find_spec" rel="nofollow">link</a>.</p>
<p>And use  <code>importlib.find_loader("Tools")</code> for find loader <a href="https://docs.python.org/3/library/importlib.html#importlib.find_loader" rel="nofollow">more information</a></p>
<p><strong>EDIT:</strong></p>
<p>sample code</p>
<pre><code>import importlib
import importlib.util
import sys

    name="test"
    moduledir="d:\\dirtest"
# this is optional set that if you what load from specific directory
    try:
        spec = importlib.util.find_spec(name,moduledir)
        if spec is None:
            print("Import error 0: " + " module not found")
            sys.exit(0)
        toolbox = spec.loader.load_module()
    except (ValueError, ImportError) as msg:
        print("Import error 3: "+str(msg))
        sys.exit(0)

    print("load module")
</code></pre>
</div>
<span class="comment-copy">If <code>Tools</code> does an implicit sibling import (e.g. <code>import foo</code> and there is a <code>foo.py</code> file along side <code>Tools.py</code>), this solution yields <code>ModuleNotFoundError: No module named 'foo'</code>. Any way to address this?</span>
<span class="comment-copy">@PedroCattori: I am not entirely sure what your situation is, let allone how to address it. I suggest you ask a separate question on this.</span>
<span class="comment-copy">fair enough. here it is: <a href="http://stackoverflow.com/q/41861427/1490091">stackoverflow.com/q/41861427/1490091</a></span>
<span class="comment-copy">Can you address whether and how any of these commands allows you to find modules in a different path than the working path?</span>
<span class="comment-copy">@Wrzlprmft I edited the post</span>
<span class="comment-copy">Your example code does not work for me if <code>moduledir</code> is not the current directory (also the indentation is broken), even if there is a module in that directory that would be found otherwise. Does it work for you? If yes, we may have found a bug. If no, we either have a bug or misunderstood how it works.</span>
<span class="comment-copy">Yes it works for me version test with python version 3.4.4</span>
<span class="comment-copy">As it stands, this code does not work and is not intended to do so. <a href="http://docs.python.org/3/library/importlib.html#importlib.util.find_spec" rel="nofollow noreferrer"><code>find_spec</code></a> does not take a directory as second argument. The variant with <code>find_loader</code> should not have worked either, as this takes a list of directiories and not a directory as an argument.</span>
