<div class="post-text" itemprop="text">
<p>I wanted to use the built-in range function for floats, but apparently it doesn't work and from a quick research, i understood that there isn't a built in option for that and that I'll need to code my own function for this. So I did:</p>
<pre><code>def fltrange(mini, maxi, step):
lst = []
while mini &lt; maxi:
    lst.append(mini)
    mini += step
return lst
 rang = fltrange(-20.0, 20.1, 0.1)
 print(rang)
 input()
</code></pre>
<p>but this is what I get:
<a href="http://i.stack.imgur.com/8mK4Q.png" rel="nofollow">result</a></p>
<p>the step should be just 0.1000000..., but instead it's about (sometimes it changes) 0.100000000000001.</p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Fun fact: 1/10 can't be exactly represented by floating point numbers. The closest you can get is <code>0.1000000000000000055511151231257827021181583404541015625</code>. The rightmost digits usually get left out when you print them, but they're still there. This explains the accumulation of errors as you continually add more 0.1s to the sum.</p>
<p>You can eliminate <em>some</em> inaccuracy (but not all of it) by using a multiplication approach instead of a cumulative sum:</p>
<pre><code>def fltrange(mini, maxi, step):
    lst = []
    width = maxi - mini
    num_steps = int(width/step)
    for i in range(num_steps):
        lst.append(mini + i*step)
    return lst
rang = fltrange(-20.0, 20.1, 0.1)
print(rang)
</code></pre>
<p>Result (newlines added by me for clarity):</p>
<pre><code>[-20.0, -19.9, -19.8, -19.7, -19.6, -19.5, -19.4, -19.3, -19.2, -19.1, 
-19.0, -18.9, -18.8, -18.7, -18.6, -18.5, -18.4, -18.3, -18.2, -18.1, 
-18.0, -17.9, -17.8, -17.7, -17.6, -17.5, -17.4, -17.3, -17.2, -17.1, 
-17.0, -16.9, -16.8, -16.7, -16.6, -16.5, -16.4, -16.3, -16.2, -16.1, 
-16.0, -15.899999999999999, -15.8, -15.7, -15.6, -15.5, -15.399999999999999, -15.3, -15.2, -15.1, -15.0,
...
19.1, 19.200000000000003, 19.300000000000004, 19.400000000000006, 19.5, 19.6, 19.700000000000003, 19.800000000000004, 19.900000000000006, 20.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>numpy</code> for it. There are a few functions for your needs.</p>
<pre><code>import numpy as np  # of course :)
</code></pre>
<p><a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.linspace.html" rel="nofollow">linspace</a> :</p>
<pre><code>np.linspace(1, 10, num=200)
array([  1.        ,   1.04522613,   1.09045226,   1.13567839,
         1.18090452,   1.22613065,   1.27135678,   1.31658291,
         ...
         9.68341709,   9.72864322,   9.77386935,   9.81909548,
         9.86432161,   9.90954774,   9.95477387,  10.        ])
</code></pre>
<p><a href="http://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.arange.html" rel="nofollow">arange</a> :</p>
<pre><code>np.arange(1., 10., 0.1)
array([ 1. ,  1.1,  1.2,  1.3,  1.4,  1.5,  1.6,  1.7,  1.8,  1.9,  2. ,
        2.1,  2.2,  2.3,  2.4,  2.5,  2.6,  2.7,  2.8,  2.9,  3. ,  3.1,
        ...
        8.7,  8.8,  8.9,  9. ,  9.1,  9.2,  9.3,  9.4,  9.5,  9.6,  9.7,
        9.8,  9.9])
</code></pre>
<p>P.S. However, it's not technically a generator, which is a <a href="https://docs.python.org/3/library/functions.html#func-range" rel="nofollow">range</a> in Python3 (xrange for Python2.x).</p>
</div>
<span class="comment-copy"><code>numpy.arange</code> works with floats. The <code>0.1</code> not being exact is just how representing floating point values in computers works (there's a really good article I've seen around about it but can't find it right now).</span>
<span class="comment-copy">+1 for <code>numpy.arange</code>, and I would add that if you roll your own, it might save memory if you use <code>yield</code>.  <code>while mini &lt; maxi: yield mini; mini += step</code>, as this means you're not storing the entire list (which may or may not be used when it's called on) but rather generating values as they're needed.</span>
<span class="comment-copy">This isn't what I was thinking of but will work: <a href="http://0.30000000000000004.com/" rel="nofollow noreferrer">0.30000000000000004.com</a></span>
<span class="comment-copy">The Wikipedia article on <a href="https://en.wikipedia.org/wiki/Floating_point" rel="nofollow noreferrer">floating point</a> is quite good, but I guess it can be a bit overwhelming. It does have a link to <i>the</i> definitive article on floating point: <a href="http://www.validlab.com/goldberg/paper.pdf" rel="nofollow noreferrer">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a> by David Goldberg, which is possibly the article daveydave400 was thinking of.</span>
<span class="comment-copy">BTW, you should fix the indentation of the code in your question; correct indentation is vital in Python. Also, it's customary to put a blank line (or 2) after function definitions to make the code easier to read.</span>
<span class="comment-copy">You can get even better accuracy if you can supply <code>step</code> as a pair of integers representing a fraction, so you can do <code>mini + i*p/q</code> (with <code>/</code> being true division), but that's not always practical.</span>
<span class="comment-copy">@PM2Ring the <a href="https://docs.python.org/2/library/fractions.html" rel="nofollow noreferrer"><code>fractions</code> module</a> can be used to derive a suitable multiplier and divisor quite easily. You would probably want to use <a href="https://docs.python.org/2/library/fractions.html#fractions.Fraction.limit_denominator" rel="nofollow noreferrer"><code>limit_denominator</code></a>.</span>
