<div class="post-text" itemprop="text">
<p>I have a list that looks like this:</p>
<pre><code>[
  {u'self': u'https://jr.com/Option/134', u'id': u'134', u'value': u'AI'},
  {u'self': u'https://jr.com/Option/135', u'id': u'135', u'value': u'E'}
]
</code></pre>
<p>Is there a way to come up with a comma-delimited "values" as: <code>AI, E</code>
I think I can do something like:</p>
<pre><code>l = []
for x in l:
    val = x['value']
    l.append(val)
print l
final_l = ','.join(l)
</code></pre>
<p>but was wondering if I can do it in less code.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can save a few lines thanks to <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">comprehension</a>:</p>
<pre><code>values = ','.join(item['value'] for item in lst)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; lst = [
...   {u'self': u'https://jr.com/Option/134', u'id': u'134', u'value': u'AI'},
...   {u'self': u'https://jr.com/Option/135', u'id': u'135', u'value': u'E'}
... ]
&gt;&gt;&gt; values = ','.join(item['value'] for item in lst)
&gt;&gt;&gt; values
u'AI,E'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [1]: foo = [
   ...: {u'self': u'https://jr.com/Option/134', u'id': u'134', u'value': u'AI'},   {u'self': u'https://jr.com/Option/135', u'id': u'135', u'value': u'E'}
   ...: ]

In [2]: ", ".join([x.get('value') for x in foo])
Out[2]: u'AI, E'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This comprehension does it easily:</p>
<pre><code>&gt;&gt;&gt; s = [
... {u'self': u'https://jr.com/Option/134', u'id': u'134', u'value': u'AI'},   {u'self': u'https://jr.com/Option/135', u'id': u'135', u'value': u'E'}
... ]
&gt;&gt;&gt; ', '.join(x['value'] for x in s)
u'AI, E'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>','.join(['1','2','3','4'])
</code></pre>
<p>is one way to create a comma-delimited sequence based on an input list/tuple of strings. In this case the result is <code>'1,2,3,4'</code></p>
<p>In your case, your command might look like this (assuming you want to join 'values' of each dictionary element:</p>
<pre><code>','.join([x['value'] for x in l])
</code></pre>
</div>
<span class="comment-copy">what if item doesn't have 'value' key? It'll give you KeyError.</span>
<span class="comment-copy">@minitoto: silencing exceptions with no reason is never a good idea. The exception that you suppress now may cause unexpected behavior later. In that case you're not preventing any error, you're just delaying it, making it harder to debug, or maybe introducing serious security bugs.</span>
<span class="comment-copy">it means a code snippet you gave with a potential error, i recommend to do it like this ','.join(item['value'] for item in lst if item.get('value'))</span>
<span class="comment-copy">Andrea is right. This principle has a name and is known as "fail fast": <a href="https://en.wikipedia.org/wiki/Fail-fast" rel="nofollow noreferrer">en.wikipedia.org/wiki/Fail-fast</a> . It may seem a contradiction, but fail-fast systems are the most robust.</span>
<span class="comment-copy">@minitoto: the error is there, whether you suppress it or not. I would be <i>very</i> surprised to have a list of 5 items and a string with just 3 values. I prefer an exception to stop the process, rather than let the error propagate (possibly causing more problems)</span>
<span class="comment-copy">@minitoto Cheers. "Assume nothing about your inputs" :o)</span>
<span class="comment-copy"><code>.get()</code> defaults to <code>None</code>. You should provide a string as a default value if you really want to suppress exceptions. (Even though <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">errors should never pass silently</a>, which is an important principle)</span>
<span class="comment-copy">Fair comment @AndreaCorbellini :o) <code>.get('value, '')</code> would be better for situations that don't fail loudly, yeah</span>
