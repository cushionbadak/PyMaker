<div class="post-text" itemprop="text">
<p>Suppose that in Python I have 3 lists: <code>a, b, c</code> of variable lengths. For example : </p>
<pre><code>a=[1,2,3]
b=[4,5,6]
c=[7,8]
</code></pre>
<p>I would like to get every unique combination of TWO elements of the 3 lists above, i. e. </p>
<p><code>[1,4],[1,5],[1,6],[1,7],[1,8],[2,4],[2,5]...</code> and NOT unique combinations of the 3 lists (such as <code>[1,4,7],[1,4,8],...</code>).</p>
<p>I have looked at the <a href="https://stackoverflow.com/questions/8242832/python-all-possible-pairs-of-2-list-elements-and-getting-the-index-of-that-pair">solution here</a> using <code>itertools</code> that is perfectly fine for 2 lists ; however, this solution does not work anymore when including a <code>n</code>th list because the unique combinations are of length <code>n</code>.</p>
<p>Here is what I have tried:</p>
<pre><code>import itertools

a=[1,2,3]
b=[4,5,6]
c=[7,8]

d=list(itertools.product(a,b,c))

[(1, 4, 7), (1, 4, 8), (1, 5, 7), (1, 5, 8), (1, 6, 7), (1, 6, 8), (2, 4, 7), (2, 4, 8), (2, 5, 7), (2, 5, 8), (2, 6, 7), (2, 6, 8), (3, 4, 7), (3, 4, 8), (3, 5, 7), (3, 5, 8), (3, 6, 7), (3, 6, 8)]
</code></pre>
<hr/>
<p>Note: Above is just an example and the solution should work for <code>n</code> lists of variable length and with possibly the same value being in different lists... Any idea of how I could do would be greatly appreciated! :)</p>
<hr/>
<p>EDIT: as asked by @SirParselot, the elements have to come from different lists</p>
</div>
<div class="post-text" itemprop="text">
<p>You want the <a href="https://en.wikipedia.org/wiki/Cartesian_product" rel="nofollow">Cartesian product</a> of each pair of lists in <code>(a, b, c)</code>, so first you need <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow"><code>itertools.combinations</code></a> to generate the pairs of lists, and then <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a> to create the desired output tuples.</p>
<pre><code>from itertools import combinations, product

def pairs(*lists):
    for t in combinations(lists, 2):
        for pair in product(*t):
            yield pair

a = [1, 2, 3]
b = [4, 5, 6]
c = [7, 8]

for pair in pairs(a, b, c):
    print(pair)
</code></pre>
<p><strong>output</strong></p>
<pre><code>(1, 4)
(1, 5)
(1, 6)
(2, 4)
(2, 5)
(2, 6)
(3, 4)
(3, 5)
(3, 6)
(1, 7)
(1, 8)
(2, 7)
(2, 8)
(3, 7)
(3, 8)
(4, 7)
(4, 8)
(5, 7)
(5, 8)
(6, 7)
(6, 8)
</code></pre>
<hr/>
<p>Here's a new version that handles repeated elements. It does not return a tuple if the two items in the tuple equal each other, and it also eliminates duplicated tuples in the output by feeding the output from <code>pairs</code> into a set. This is reasonably efficient since <code>pairs</code> is a generator, so duplicates are eliminated as they are found.</p>
<pre><code>from itertools import combinations, product

def pairs(*lists):
    for t in combinations(lists, 2):
        for pair in product(*t):
            #Don't output pairs containing duplicated elements 
            if pair[0] != pair[1]:
                yield pair

a = [1, 2, 3]
b = [3, 4, 5]
c = [5, 6]

#Feed the output of `pairs` into a set to eliminate duplicate tuples
output = set(pairs(a, b, c))
for pair in sorted(output):
    print(pair)
</code></pre>
<p><strong>output</strong></p>
<pre><code>(1, 3)
(1, 4)
(1, 5)
(1, 6)
(2, 3)
(2, 4)
(2, 5)
(2, 6)
(3, 4)
(3, 5)
(3, 6)
(4, 5)
(4, 6)
(5, 6)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I guess what you should do is use your working solution for two lists to do it with <code>n</code> lists. Basically, you could transform your input into a list of lists, and do:</p>
<pre><code>for index, left_list in enumerate(list_of_lists):
        other_lists = (list_of_lists[0:index] + list_of_lists[index+1:])
        right_list = [i for sublist in other_lists for i in sublist]
        print(list(itertools.product(left_list, right_list)))
</code></pre>
</div>
<span class="comment-copy">And what have you tried?</span>
<span class="comment-copy">do the combinations have to be between different lists?</span>
<span class="comment-copy">@SirParselot yes!</span>
<span class="comment-copy">FWIW, my answer works for the original question, with any number of input lists. But what exactly do you mean by "redundant elements"?</span>
<span class="comment-copy">@tlorin: Pynchia is doing <code>import itertools as it</code> at the top of the script. I'll add some code to my answer.</span>
<span class="comment-copy">sorry to bother you again: what if I have a list of lists of an UNKNOWN size <code>n</code> (in your solution, size is 3 and we know it is 3 from the beginning)? If I have for instance a list of lists (with <code>n</code> lists) as a dictionary value, I would like to do something like <code>output = set(pairs(dict[value]))</code> but this seems not to work... For instance: <code>dict = {'value': [[2,1],[3,3]]};output = set(pairs(dict['value']));output</code> gives: <code>set([])</code>. I thought that this is related to your solution so I ask it here as a comment but I can make a new post if you prefer :)</span>
<span class="comment-copy">My <code>pairs</code> function will cope with <i>any</i> number of input lists (or tuples), eg you can do <code>output = set(pairs(a,b,c,d,e))</code>, where <code>a</code>, <code>b</code>, etc, are simple lists or tuples. If you want to pass it a list of lists (or a tuple of tuples, etc) you need to use the <code>*</code> "splat" operator, which converts a list (or tuple) into separate arguments. Eg: <code>mylists=[[2,1],[3,3]];output = set(pairs(*mylists))</code>. Or using your example, <code>output = set(pairs(*dct['value']))</code>. (I changed the name of your dict to <code>dct</code>, because it's bad practice to use <code>dict</code>, <code>list</code>, <code>str</code>, etc as variable names).</span>
<span class="comment-copy">I was missing the <code>*</code>! Very handy, I did not know this one! Well, thanks a lot again :)</span>
<span class="comment-copy">Not a problem! Splat is very handy. There's also double splat <code>**</code> that does a similar thing for dictionaries. See <a href="http://stackoverflow.com/q/36901/4014959">stackoverflow.com/q/36901/4014959</a></span>
<span class="comment-copy">Use yield/yield from as needed to put this algorithm into a subfunction.</span>
