<div class="post-text" itemprop="text">
<p>I came across "unqualified on right hand side" phrase while reading oops concept in python for usage like self._customer = customer. What that phrase trying to explain? 
Complete statement is</p>
<blockquote>
<p>For example, the command, <code>self._customer = customer</code>, assigns the instance variable <code>self._customer</code> to the parameter <code>customer</code>; note that because <code>customer</code> is unqualified on the right-hand side, it refers to the parameter in the local namespace. --<a href="http://multimedia.ucc.ie/Public/training/cycle1/algorithms-in-python.pdf" rel="nofollow">Data Structures and Algorithms in Python</a> p. 72</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/3/glossary.html" rel="nofollow">Python docs</a></p>
<blockquote>
<p>qualified name</p>
<p>A dotted name showing the “path” from a module’s global scope to a class, function or method defined in that module, as defined in PEP 3155. For top-level functions and classes, the qualified name is the same as the object’s name:</p>
<p>...</p>
<p>When used to refer to modules, the fully qualified name means the entire dotted path to the module, including any parent packages, e.g. email.mime.text:</p>
</blockquote>
<p>Put more simply, qualifying a name in Python means that you explicitly define its scope. Thus <code>self._customer</code> is a qualified name (it identifies the instance variable <code>customer</code> for the enclosing class) whereas the bare <code>customer</code>reference does <strong>not</strong> specify any scope qualifications.</p>
<p>When a name is unqualified, Python applies <em>Lexical Scoping</em> rules to try and find the variable, searching (in order)</p>
<ul>
<li>Local variables (including function parameters)</li>
<li>Variables local to any outer functions, if we're dealing with a nested function definition</li>
<li>Global variables</li>
<li>Built-in variables</li>
</ul>
</div>
<span class="comment-copy">The statement is obviously wrong, so I would disregard it.</span>
<span class="comment-copy">And the bit which is wrong is that the command assigns the value of the unqualified RHS to the instance variable - not the other way round as the statement suggests</span>
<span class="comment-copy">since I learned a new (useless) term: +1</span>
<span class="comment-copy">@Adam I'm not sure your edit is completely correct. I agree with removing the space from <code>self. customer</code> .. but not with replacing it with an underscore. The question makes more sense when the statement is <code>self.customer = customer</code> as the qualification is more relevant then (<code>_customer</code> and <code>customer</code> being different identifiers)</span>
<span class="comment-copy">Yep, when I looked again at the edit I realised you hadn't changed the <code>_customer</code> in the initial paragraph.</span>
<span class="comment-copy">"Dynamic scoping" is a specific form of variable lookup where you look through the call stack for the most deeply nested function call that has a definition for the variable. Almost nobody does it, because it turns out it's a horrible idea. Python is lexically scoped, and most variable resolution inside functions is static.</span>
<span class="comment-copy">Yeah, sorry - it's always a bit confusing with python :) It's static scoping for symbol binding, but dynamic for value resolution</span>
<span class="comment-copy">I'm not sure what you're trying to say there, with the "dynamic for value resolution" bit.</span>
<span class="comment-copy">think I should quit while I'm behind at this point :)</span>
