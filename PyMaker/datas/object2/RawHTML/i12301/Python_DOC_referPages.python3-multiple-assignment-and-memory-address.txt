<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/34147515/is-operator-behaves-unexpectedly-with-non-cached-integers">'is' operator behaves unexpectedly with non-cached integers</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>After reading <a href="https://stackoverflow.com/questions/19067252/why-multiple-assignments-and-single-assignments-behave-differently-in-python">this</a> and <a href="https://stackoverflow.com/questions/31152195/python-multiple-assignment-and-references/31153595">this</a>, which are pretty similar to my question, I still cannot understand the following behaviour:</p>
<pre><code>a = 257
b = 257
print(a is b) #False
a, b = 257, 257
print(a is b) #True
</code></pre>
<p>When printing <code>id(a)</code> and <code>id(b)</code> I can see that the variables, to which the values were assigned in separate lines, have different ids, whereas with multiple assignment both values have the same id:</p>
<pre><code>a = 257
b = 257
print(id(a)) #139828809414512
print(id(b)) #139828809414224
a, b = 257, 257
print(id(a)) #139828809414416
print(id(b)) #139828809414416
</code></pre>
<p>But it's impossible to explain this behaviour by saying that multiple assignment of same values always creates pointers to the same id since:</p>
<pre><code>a, b = -1000, -1000  
print(id(a)) #139828809414448
print(id(b)) #139828809414288
</code></pre>
<p>Is there a clear rule, which explains when the variables get the same <code>id</code> and when not?</p>
<p><strong>edit</strong></p>
<p>relevant info: The code in this question was run in interactive mode(ipython3)</p>
</div>
<div class="post-text" itemprop="text">
<p>This is due to a constant folding optimization in the bytecode compiler. When the bytecode compiler compiles a batch of statements, it <a href="https://hg.python.org/cpython/file/2.7/Python/compile.c#l942" rel="nofollow">uses a dict</a> to keep track of the constants it's seen. This dict automatically merges any equivalent constants.</p>
<p>Here's the routine responsible for recording and numbering constants (as well as a few related responsibilities):</p>
<pre><code>static int
compiler_add_o(struct compiler *c, PyObject *dict, PyObject *o)
{
    PyObject *t, *v;
    Py_ssize_t arg;

    t = _PyCode_ConstantKey(o);
    if (t == NULL)
        return -1;

    v = PyDict_GetItem(dict, t);
    if (!v) {
        arg = PyDict_Size(dict);
        v = PyInt_FromLong(arg);
        if (!v) {
            Py_DECREF(t);
            return -1;
        }
        if (PyDict_SetItem(dict, t, v) &lt; 0) {
            Py_DECREF(t);
            Py_DECREF(v);
            return -1;
        }
        Py_DECREF(v);
    }
    else
        arg = PyInt_AsLong(v);
    Py_DECREF(t);
    return arg;
}
</code></pre>
<p>You can see that it only adds a new entry and assigns a new number if it doesn't find an equivalent constant already present. (The <code>_PyCode_ConstantKey</code> bit makes sure things like <code>0.0</code>, <code>-0.0</code>, and <code>0</code> are considered inequivalent.)</p>
<p>In interactive mode, a batch ends every time the interpreter has to actually run your command, so constant folding mostly doesn't happen across commands:</p>
<pre><code>&gt;&gt;&gt; a = 1000
&gt;&gt;&gt; b = 1000
&gt;&gt;&gt; a is b
False
&gt;&gt;&gt; a = 1000; b = 1000 # 1 batch
&gt;&gt;&gt; a is b
True
</code></pre>
<p>In a script, all top-level statements are one batch, so <a href="http://ideone.com/03a4jv" rel="nofollow">more constant folding happens</a>:</p>
<pre><code>a = 257
b = 257
print a is b
</code></pre>
<p>In a script, this prints <code>True</code>.</p>
<p>A function's code gets its constants tracked separately from code outside the function, which limits constant folding:</p>
<pre><code>a = 257

def f():
    b = 257
    print a is b

f()
</code></pre>
<p><a href="http://ideone.com/QPNZyw" rel="nofollow">Even in a script</a>, this prints <code>False</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>That's because of pythons interpreter optimization at <code>UNPACK_SEQUENCE</code> time, during loading the constant values. When python encounters an iterable during the unpacking, it doesn't load the duplicate objects multiple times, instead it just keeps the first object and assigns all your duplicate variable names to one pointer (In CPython implementation). Therefore, all your variables will become same references to one object. At python level you can think of this behavior as using a dictionary as the namespace which doesn't keep duplicate keys.</p>
<p>In other words, your unpacking would be equivalent to following command:</p>
<pre><code>a = b = 257
</code></pre>
<p>And about the negative numbers, in python 2.X it doesn't make any difference but in python 3.X it seems that for numbers smaller than -5 python will create new object during unpacking:</p>
<pre><code>&gt;&gt;&gt; a, b = -6, -6
&gt;&gt;&gt; a is b
False
&gt;&gt;&gt; a, b = -5, -5
&gt;&gt;&gt; 
&gt;&gt;&gt; a is b
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Any such rule is implementation-specific. CPython, for example, pre-allocates <code>int</code> objects for small integers (-5 through 256) as a performance optimization.</p>
<p>The only general rule is to assume any use of a literal will generate a new object.</p>
</div>
<span class="comment-copy">Check out <code>[id(i) for i in (1000,1000,1000,1000)]</code> :-)</span>
<span class="comment-copy">Note: the behavior is inconsistent because it never matters. If there were any reason to care whether two <code>257</code>s were the same object, there would be a simple, sensible pattern to it.</span>
<span class="comment-copy">peephole optimizations, irrelevant how it works as it is never something you would or should ever rely on.</span>
<span class="comment-copy">thank you. I will edit my question to make clear it was tested in interactive mode.</span>
<span class="comment-copy">So what about integers smaller than <code>-5</code>  in python 3? for example <code>a, b = -6, -6</code></span>
<span class="comment-copy">@Kasramvd: The compiler compiles <code>-6</code> into a <code>LOAD_CONST</code> and a <code>UNARY_NEGATIVE</code>; there's a <a href="https://hg.python.org/cpython/file/3.5/Python/peephole.c#l242" rel="nofollow noreferrer">separate optimization</a> responsible for converting that into a <code>LOAD_CONST</code> that loads a <code>-6</code>. That optimization doesn't use the dict.</span>
<span class="comment-copy">@user2357112 indeed, but I didn't find any restriction for smaller than -5 in C code! :( is it relative to <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow noreferrer">this point</a> that negative numbers are represented in a variant of 2â€™s complement which gives the illusion of an infinite string of sign bits extending to the left?</span>
<span class="comment-copy">@Kasramvd: <code>-5</code> gets handled by yet another optimization, the small integer pool. All <code>-5</code>s are the same object, no matter how or where you create them.</span>
<span class="comment-copy">How does your answer explain the last part of my question, with     a,b=-1000, -1000 ?</span>
<span class="comment-copy">@isternberg In last part you have create your variables separately, but there is another point in negative numbers unpacking in python3 which I'll update the answer with the reason as soon as possible.</span>
<span class="comment-copy">"one LOAD_CONSTANT and 2 STORE_FAST" -- While you're correct, the <code>LOAD_CONSTANT</code> is loading a constant <code>tuple</code> which holds 2 items.  I'm not sure that it's clear to me how that explains the two values having the same IDs (when they are outside the normal range of python's interned integers).</span>
<span class="comment-copy">No, no, no! This is completely wrong. <code>UNPACK_SEQUENCE</code> has nothing to do with it. <a href="http://ideone.com/grmLXW" rel="nofollow noreferrer">Decompile <code>a, b = 257, 258</code></a> and you'll see the same 1 LOAD_CONST, 1 UNPACK_SEQUENCE behavior, but <code>a</code> and <code>b</code> are clearly different. You can also <a href="http://ideone.com/oYiqfh" rel="nofollow noreferrer">build a <code>(257, 257)</code> tuple</a> in a way that avoids the optimization, and <code>UNPACK_SEQUENCE</code> won't merge the constants.</span>
<span class="comment-copy">@Kasramvd, thx for letting me know about the mistake in my question. I fixed it.</span>
<span class="comment-copy">The number is <code>257</code> and you can see this behaviour by using larger integers too.</span>
<span class="comment-copy">I always forget the exact range.</span>
<span class="comment-copy">not "will generate", but "might generate".</span>
