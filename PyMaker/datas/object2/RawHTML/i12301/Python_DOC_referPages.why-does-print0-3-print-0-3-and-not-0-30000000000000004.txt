<div class="post-text" itemprop="text">
<p>So I think I basically understand how floating-point works and why we can't have "precise" results for some operations.</p>
<p>I got confused by <a href="https://stackoverflow.com/questions/35197598/range-with-floating-point-numbers-and-negative-steps">this SO-question</a>, where @MikeMüller suggests rounding.</p>
<hr/>
<p>My understanding is the following. 
If we write decimal places it would look like this:<br/>
<code>1000 100 10 1 . 1/10 1/100 1/1000</code></p>
<p>It would look like this in binary:<br/>
<code>8 4 2 1 . 1/2 1/4 1/8</code></p>
<p>So we store 0.5 or 0.25 or 0.125 precisely in memory but not e.g. 0.3</p>
<p>So why does python output the following:</p>
<pre><code>print(0.1)
print(0.2)
print(0.3)
print(0.1 + 0.2)

&gt;&gt;&gt;0.1
&gt;&gt;&gt;0.2
&gt;&gt;&gt;0.3
&gt;&gt;&gt;0.30000000000000004
</code></pre>
<p>I think it should output </p>
<pre><code>&gt;&gt;&gt;0.1
&gt;&gt;&gt;0.2
&gt;&gt;&gt;0.30000000000000004
&gt;&gt;&gt;0.30000000000000004
</code></pre>
<p>Where am I wrong?</p>
<hr/>
<p>My Question is NOT a duplicate of <a href="https://stackoverflow.com/questions/588004">Is floating point math broken?</a>
because OP does not understand why 0.1+0.2 != 0.3. This is not topic of my question!</p>
</div>
<div class="post-text" itemprop="text">
<p>Because they're not the same, as <code>0.1</code> and <code>0.2</code> isn't correctly represented already. So:</p>
<pre><code>&gt;&gt;&gt;print("%.20f" % (0.1+0.2))
0.30000000000000004441

&gt;&gt;&gt;print("%.20f" % 0.3)
0.29999999999999998890

&gt;&gt;&gt;print(0.29999999999999998890)
0.3
</code></pre>
<p>So it's all up to the Python rules for printing stuff, especially considering that pure <code>0.3</code> representation is much closer to actual <code>0.3</code> than <code>0.1 + 0.2</code>.</p>
<p>Here's the related excerpt from <a href="https://docs.python.org/3/tutorial/floatingpoint.html">Python docs</a>:</p>
<blockquote>
<p>Interestingly, there are many different decimal numbers that share the
  same nearest approximate binary fraction. For example, the numbers <code>0.1</code>
  and <code>0.10000000000000001</code> and
  <code>0.1000000000000000055511151231257827021181583404541015625</code> are all approximated by <code>3602879701896397 / 2 ** 55</code>. Since all of these decimal
  values share the same approximation, any one of them could be
  displayed while still preserving the invariant <code>eval(repr(x)) == x</code>.</p>
<p>Historically, the Python prompt and built-in <code>repr()</code> function would
  choose the one with 17 significant digits, <code>0.10000000000000001</code>.
  Starting with Python 3.1, Python (on most systems) is now able to
  choose the shortest of these and simply display <code>0.1</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow">the docs on floating point in Python 3</a>,</p>
<blockquote>
<p>Interestingly, there are many different decimal numbers that share the same nearest approximate binary fraction. For example, the numbers 0.1 and 0.10000000000000001 and 0.1000000000000000055511151231257827021181583404541015625 are all approximated by 3602879701896397 / 2 ** 55. Since all of these decimal values share the same approximation, any one of them could be displayed while still preserving the invariant eval(repr(x)) == x.</p>
<p>Historically, the Python prompt and built-in repr() function would choose the one with 17 significant digits, 0.10000000000000001. Starting with Python 3.1, Python (on most systems) is now able to choose the shortest of these and simply display 0.1.</p>
</blockquote>
<p>So that is why it shows <code>0.3</code> when it can -- because that is the shortest string that is stored as that binary representation. The slightly higher result of <code>0.1 + 0.2</code> cannot be shown as a shorter string than <code>0.30000000000000004</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To make the rounding problems no so visible, normally floating point numbers are printed without their last digit, which is rounded. This is exactly to hide the problems you wish to see.</p>
<p>So, 0.30000000000000004 will be rounded to 0.3.</p>
<p>But you can easily reproduce the problem if you make intentionally such a calculation which avoids this rounding. For example, multiple the result with 1e+6. And you will see, what you see.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a></span>
<span class="comment-copy">Why is that? 1/10 and 2/10 are not exactly representable as a binary fraction. Almost all machines today (July 2010) use IEEE-754 floating point arithmetic, and almost all platforms map Python floats to IEEE-754 “double precision”. 754 doubles contain 53 bits of precision, so on input the computer strives to convert 0.1 to the closest fraction it can of the form J/2**N where J is an integer containing exactly 53 bits. Rewriting  <a href="https://docs.python.org/2/tutorial/floatingpoint.html#representation-error" rel="nofollow noreferrer">docs.python.org/2/tutorial/…</a></span>
<span class="comment-copy">They are NOT duplicates, closing this is a MISTAKE!</span>
<span class="comment-copy">@peterh Thank you, I think the same...</span>
<span class="comment-copy">Thank you, I thought of something like that. Great anwser.</span>
<span class="comment-copy">Just as I found the same bit - StackOverflow, neverending race!</span>
