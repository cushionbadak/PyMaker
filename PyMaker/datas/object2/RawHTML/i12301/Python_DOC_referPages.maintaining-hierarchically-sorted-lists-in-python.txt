<div class="post-text" itemprop="text">
<p>I'm not sure if 'hierarchical' is the correct way to label this problem, but I have a series of lists of integers that I'm intending to keep in 2D numpy array that I need to keep sorted in the following way:</p>
<pre><code>array[0,:] = [1, 1, 1, 1, 2, 2, 2, 2, ...]
array[1,:] = [1, 1, 2, 2, 1, 1, 2, 2, ...]
array[2,:] = [1, 2, 1, 2, 1, 2, 1, 2, ...]
   ...
   ...
array[n,:] = [...]
</code></pre>
<p>So the first list is sorted, then the second list is broken into subsections of elements which all have the same value in the first list and those subsections are sorted, and so on down all the lists.</p>
<p>Initially each list will contain only one integer, and I'll then receive new columns that I need to insert into the array in such a way that it remains sorted as discussed above.</p>
<p>The purpose of keeping the lists in this order is that if I'm given a new column of integers I need to check whether an exact copy of that column exists in the array or not as efficiently as possible, and I assume this ordering will help me do it. It may be that there is a better way to make that check than keeping the lists like this - if you have thoughts about that please mention them!</p>
<p>I assume the correct position for a new column can be found by a series of binary searches but my attempts have been messy - any thoughts on doing this in a tidy and efficient way?</p>
<p>thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand your problem correctly, you have a bunch of sequences of numbers that you need to process, but you need to be able to tell if the latest one is a duplicate of one of the sequences you've processed before. Currently you're trying to insert the new sequences as columns in a numpy array, but that's awkward since numpy is really best with fixed-sized arrays (concatenating or inserting things is always going to be slow).</p>
<p>A much better data structure for your needs is a <code>set</code>. Membership tests and the addition of new items on a <code>set</code> are both very fast (amortized O(1) time complexity). The only limitation is that a <code>set</code>'s items must be hashable (which is true for <code>tuple</code>s, but not for <code>list</code>s or numpy arrays).</p>
<p>Here's the outline of some code you might be able to use:</p>
<pre><code>seen = set()
for seq in sequences:
    tup = tuple(sequence) # you only need to make a tuple if seq is not already hashable
    if tup not in seen:
        seen.add(tup)

        # do whatever you want with seq here, it has not been seen before

    else:
        pass # if you want to do something with duplicated sequences, do it here
</code></pre>
<p>You can also look at the <code>unique_everseen</code> recipe in <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">the <code>itertools</code> documentation</a>, which does basically the same as the above, but as a well-optimized generator function.</p>
</div>
<span class="comment-copy">You should post the code you have tried, it will make helping you much easier.</span>
<span class="comment-copy">Do you need your numbers in a numpy array for some other reason (e.g. doing computations), or could you change to, say, a <code>set</code> of <code>tuple</code>s?</span>
<span class="comment-copy">@Blckknght honestly I don't think they need to be in a numpy array, it's just that I'm fairly new to python but I'm familiar with numpy arrays so it was my go-to. If there are reasons I should be using a <code>set</code> of <code>tuples</code>s I'd love to learn about them if you have the time!</span>
<span class="comment-copy">This is extremely interesting... I'm going to check asap that using <code>sets</code>/<code>tuples</code> doesn't prevent the operations I need to perform, because this looks like a great solution. Thanks!</span>
