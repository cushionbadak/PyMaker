<div class="post-text" itemprop="text">
<p>There is a list which contains dictionaries as its elements. Each dictionary as multiple keys. I need to add values of other keys on the base of given key values. 
for example, There is a list A:</p>
<pre><code>A =
[{'count': 100, 'price': [100, 200, 300], 'quality': 'good', 'key': 'veg'}, {'count': 150, 'price': [10, 20, 30], 'quality': 'good', 'key': 'non-veg'}, {'count': 200, 'price': [1, 2, 3], 'quality': 'good', 'key': 'veg'}, {'count': 100, 'price': [110, 220, 330], 'quality': 'good', 'key': 'non-veg'}]
</code></pre>
<p>I am trying to add the values of these elements on the base of 'key' value. I need the output like:</p>
<pre><code>[{'count': 300, 'price': [100, 200, 300, 1, 2, 3], 'quality': 'good', 'key': 'veg'}, {'count': 250, 'price': [10, 20, 30, 110, 220, 330], 'quality': 'good', 'key': 'non-veg'}]
</code></pre>
<p>I tried using itertools functions groupby and map. But <strong>NOT</strong> able to get the result exactly as expected. is there any easy way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>As much as I love <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a>, I don't think is a good idea here. Your elements alternate <code>veg</code> and <code>non-veg</code>, but <code>groupby</code> expects the groups to be contiguous, which means it's only going to work if you first call <code>sorted</code>, at which point you're throwing away all the simplicity and performance benefits of doing things iteratively.</p>
<p>Meanwhile, without sorting, it'll be a lot easier to build up a dict, keyed off the key values, than a list that you have to keep searching for each key. For example:</p>
<pre><code>d = collections.defaultdict(lambda: dict(count=0, price=[], quality=''))
for entry in A:
    key = entry['key']
    target = d[key]
    target['count'] += entry['count']
    target['price'].extend(entry['price'])
    target['quality'] = 'something' # I don't know what your aggregation rule is
</code></pre>
<p>Now, <code>d</code> looks like this:</p>
<pre><code>defaultdict(&lt;function __main__.&lt;lambda&gt;&gt;,
            {'non-veg': {'count': 250,
              'price': [10, 20, 30, 110, 220, 330]],
              'quality': 'something'},
             'veg': {'count': 300,
              'price': [100, 200, 300, 1, 2, 3]],
              'quality': 'something'}})
</code></pre>
<p>And if you really need the list at the end, that's easy:</p>
<pre><code>[dict(key=key, **value) for key, value in d.items()]
</code></pre>
<p>Alternatively, if the dict structure turns out to be more useful than the list, just use that. (Use <code>dict.setdefault</code> instead of a <code>defaultdict</code>, or do <code>d = dict(d)</code> at the end, if you don't want <code>KeyError</code>s on later lookups to turn into default values, of course.)</p>
</div>
<div class="post-text" itemprop="text">
<p>For a pure Python solution, <code>collections.defaultdict</code> is likely the best option.</p>
<p>If you are willing to use a 3rd party library, this is possible via Pandas:</p>
<pre><code>import pandas as pd
import numpy as np

# create dataframe from list of dictionaries
df = pd.DataFrame(A)

print(df)

   count      key            price quality
0    100      veg  [100, 200, 300]    good
1    150  non-veg     [10, 20, 30]    good
2    200      veg        [1, 2, 3]    good
3    100  non-veg  [110, 220, 330]    good

# define aggregation rules
agg_dict = {'price': lambda x: np.array(x.values.tolist()).sum(axis=0).tolist(),
            'count': np.sum,
            'quality': 'first'}

# apply aggregation rules
res = df.groupby('key').agg(agg_dict).reset_index()

print(res)

       key            price  count quality
0  non-veg  [120, 240, 360]    250    good
1      veg  [101, 202, 303]    300    good
</code></pre>
<p>Then to produce your dictionary result:</p>
<pre><code>d = res.to_dict(orient='records')

print(d)

[{'key': 'non-veg', 'price': [120, 240, 360], 'count': 250, 'quality': 'good'},
 {'key': 'veg', 'price': [101, 202, 303], 'count': 300, 'quality': 'good'}]
</code></pre>
</div>
<span class="comment-copy"><code>groupby</code> requires the groups to be contiguous, but your data alternate <code>veg</code> and <code>non-veg</code>, so you'll probably need to call <code>sorted</code> with the same <code>key</code> function before calling <code>groupby</code>. At which point is may be simpler and/or more efficient to just build up a dict as you go along, and then convert that to a list at the end. But really, unless you show us what you're attempting, and where it goes wrong, it's very hard to show you how to fix it.</span>
<span class="comment-copy">what's the criteria to group items?</span>
<span class="comment-copy">@abarnert yes, don't use <code>sort</code> + <code>groupby</code>. This calls for <code>defaultdict</code> instead</span>
<span class="comment-copy">I mentioned the output format I am expecting.  The output I am generating is not even close to the expected output. The criteria to group the items is by the value of the key ( here "key", values are 'veg" and "non-veg"). All the unique values have to stay the same like "quality" : "good", "count" values are needed to be added and "price" needs to be appended.</span>
<span class="comment-copy">How would you aggregate "good" and "poor" quality within "veg" group?</span>
