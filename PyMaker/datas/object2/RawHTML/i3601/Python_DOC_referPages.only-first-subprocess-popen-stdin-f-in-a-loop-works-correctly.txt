<div class="post-text" itemprop="text">
<p>My main goal here is to get all the cpu charge of a list of Linux-connected computers. I have been struggling and searching on the net for some time but I must miss something as I can't find my answer.
So I defined a cpu_script.py :</p>
<pre><code>import psutil

print(psutil.cpu_percent(interval=1,percpu=True))
</code></pre>
<p>to be called in my main script, which is in the same folder, with:</p>
<pre><code>import subprocess
import os
import numpy as np
import psutil

usr = "AA"
computer = ["c1", "c2", "c3"] #list of computer which cpu load is to be tested
cpu_script = os.path.join(os.getcwd(),"cpu_script.py")

with open(cpu_script,"rb") as f:
    for c in computer:
        input(c)
        process = subprocess.Popen(["ssh","-X",usr + "@" + c,"python3","-u","-"], stdin=f, stdout=subprocess.PIPE)
        out = process.communicate()[0]
        input(out)
</code></pre>
<p>Now here is what I got from these <code>input</code> :</p>
<pre><code>&gt;&gt; c1 #first computer
&gt;&gt; &lt;subprocess.Popen object at 0x7fd210aab358&gt;
&gt;&gt; b'[1.0, 7.1, 0.0, 1.0, 2.0, 2.0, 3.0, 0.0, 0.0, 0.0, 0.0, 1.0]\n'
&gt;&gt; c2 #second computer
&gt;&gt; &lt;subprocess.Popen object at 0x7fd210aab390&gt;
&gt;&gt; b''
&gt;&gt; c3 #third computer
&gt;&gt; &lt;subprocess.Popen object at 0x7fd210aab390&gt;
&gt;&gt; b''
</code></pre>
<p>So here is my question : why are the second and third output empty ? How could I get them ? </p>
<p>I suspected that my first process was not well "closed", so I tried to add a <code>process.wait()</code> or a <code>process.kill()</code> just after the <code>input(out)</code>, but to no avail.</p>
<p>Thank you in advance for your help !</p>
<hr/>
<p>edit: <code>subprocess.check_output()</code> gives the same outputs. I also tried <code>subprocess.run</code> with:</p>
<pre><code>with open(cpu_script,"rb") as f:
    for c in computer:
        input(c)
        process = subprocess.run(["ssh","-X",usr + "@" + c,"python3","-u","-"], stdin=f, stdout=subprocess.PIPE)
        input(out)
</code></pre>
<p>and got:</p>
<pre><code>&gt;&gt; c1 #first computer
&gt;&gt; CompletedProcess(args=['ssh', '-X', 'usr@c1', 'python3', '-u', '-'], returncode=0, stdout=b'[2.0, 1.0, 1.0, 2.9, 7.0, 0.0, 2.0, 1.0, 0.0, 0.0, 0.0, 1.0]\n')
&gt;&gt; c2 #second computer
&gt;&gt; CompletedProcess(args=['ssh', '-X', 'usr@c2', 'python3', '-u', '-'], returncode=0, stdout=b'')
&gt;&gt; c3 #third computer
&gt;&gt; CompletedProcess(args=['ssh', '-X', 'usr@c3', 'python3', '-u', '-'], returncode=0, stdout=b'')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem here is that once your file has been read once, the pointer is at the end of the file, so there's nothing left to read (so the second time you pass <code>stdin=f</code> for the same file, what's left is just empty).</p>
<p>Invert your inner and outer loops to reopen the file once every time you want to use it:</p>
<pre><code>for c in computer:
    with open(cpu_script, "rb") as f:
        process = subprocess.Popen(["ssh", "-X", "-l", usr, c, "python3 -u -"],
                                   stdin=f, stdout=subprocess.PIPE)
        out = process.communicate()[0]
</code></pre>
<p>...or rewind back to the beginning between inner loops using the <code>seek()</code> function:</p>
<pre><code>with open(cpu_script, "rb") as f:
    for c in computer:
        f.seek(0)   ### &lt;- THIS RIGHT HERE
        process = subprocess.Popen(["ssh", "-X", "-l", usr, c, "python3 -u -"],
                                   stdin=f, stdout=subprocess.PIPE)
        out = process.communicate()[0]
</code></pre>
</div>
<span class="comment-copy">If all you're doing with the <code>Popen</code> object is getting the output, why not just use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer"><code>subprocess.check_output()</code></a> (or, if you have Python 3.5+, <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer"><code>subprocess.run()</code></a>) instead?</span>
<span class="comment-copy">Your remark is quite relevant, and I went with <code>subprocess.check_output()</code> at the very first, but I got the same problem. I figured out that maybe with Popen I could nastily kill the process afterward, hopefully to solve the problem (but it does not)...</span>
<span class="comment-copy">as for <code>run</code>, I have the same problem but I'll edit my question to show properly the outputs</span>
<span class="comment-copy">FYI, when you pass <code>ssh</code> a bunch of space-separated arguments (as in <code>"python3", "-u", "-"</code>), it just concatenates them with spaces and passes the result as a single string to be evaluated by a remote shell. Which is outright dangerous, as things you might <i>think</i> are safe with arbitrary code frequently aren't; <code>['echo', unknown_string]</code> is safe, f/e, but <code>['ssh', 'somehost', 'echo', unknown_string]</code> will cause you worlds of pain if your unknown_string contains <code>$(rm -rf ~)'$(rm -rf ~)'</code>. Consider <code>['ssh', 'host', ' '.join([pipes.quote(x) for x in ['echo', unknown_string]])]</code>, a safer pattern</span>
<span class="comment-copy">thanks for your comment Charles Duffy, I will look for this enhancement when my output problem is solved :)</span>
<span class="comment-copy">Thanks for your answer and explanations! I already tryed to invert the loops (when you are desperate, you know!) but I get this strange error: for c1, it works fine, for c2 I get this error <code>&lt;subprocess.Popen object at 0x7ff90913e128&gt;Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in &lt;module&gt; ImportError: No module named 'psutil'</code> and my out is <code>b''</code>. For c3 however I get a correct output. I tried to add a <code>process.wait()</code> but it doest not solve the second-call problem</span>
<span class="comment-copy">also I get the same issue with f.seek(0)</span>
<span class="comment-copy">so you need to install the psutil module on your remote machine. That's an innate problem with the whole approach you're using (of sending Python code over the wire) -- your remote system has to have the modules that code uses installed.</span>
<span class="comment-copy">...that said, I'm not quite clear why you're using psutil at all -- do you just want the load average? Why not make your command <code>["ssh", "-l", usr, c, "cat /proc/loadavg"]</code> to collect that straight from the kernel, and not use/need a Python interpreter on the remote machine at all, and thus also not need your <code>cpu_script</code> file? (There's also no reason to have <code>-X</code>, since nothing you're doing requires X11 forwarding).</span>
<span class="comment-copy">...reading through the psutil source at <a href="https://github.com/giampaolo/psutil/blob/master/psutil/_pslinux.py" rel="nofollow noreferrer">github.com/giampaolo/psutil/blob/master/psutil/_pslinux.py</a>, it looks like it gets the data to use by comparing values harvested from <code>/proc/stat</code> a second apart.</span>
