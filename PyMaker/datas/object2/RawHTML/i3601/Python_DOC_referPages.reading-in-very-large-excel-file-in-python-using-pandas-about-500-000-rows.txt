<div class="post-text" itemprop="text">
<p>I have a <a href="https://www.dropbox.com/s/dommyuein0rqvzk/OTT_Data_All_stations.xlsx?dl=0" rel="noreferrer">14MB Excel file with five worksheets</a> that I'm reading into a Pandas dataframe, and although the code below works, it takes 9 minutes!</p>
<p>Does anyone have suggestions for speeding it up?</p>
<pre><code>import pandas as pd

def OTT_read(xl,site_name):
    df = pd.read_excel(xl.io,site_name,skiprows=2,parse_dates=0,index_col=0,
                       usecols=[0,1,2],header=None,
                       names=['date_time','%s_depth'%site_name,'%s_temp'%site_name])
    return df

def make_OTT_df(FILEDIR,OTT_FILE):
    xl = pd.ExcelFile(FILEDIR + OTT_FILE)
    site_names = xl.sheet_names
    df_list = [OTT_read(xl,site_name) for site_name in site_names]
    return site_names,df_list

FILEDIR='c:/downloads/'
OTT_FILE='OTT_Data_All_stations.xlsx'
site_names_OTT,df_list_OTT = make_OTT_df(FILEDIR,OTT_FILE)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As others have suggested, csv reading is faster.  So if you are on windows and have Excel, you could call a vbscript to convert the Excel to csv and then read the csv.  I tried the script below and it took about 30 seconds.</p>
<pre><code># create a list with sheet numbers you want to process
sheets = map(str,range(1,6))

# convert each sheet to csv and then read it using read_csv
df={}
from subprocess import call
excel='C:\\Users\\rsignell\\OTT_Data_All_stations.xlsx'
for sheet in sheets:
    csv = 'C:\\Users\\rsignell\\test' + sheet + '.csv' 
    call(['cscript.exe', 'C:\\Users\\rsignell\\ExcelToCsv.vbs', excel, csv, sheet])
    df[sheet]=pd.read_csv(csv)
</code></pre>
<p>Here's a little snippet of python to create the ExcelToCsv.vbs script:</p>
<pre><code>#write vbscript to file
vbscript="""if WScript.Arguments.Count &lt; 3 Then
    WScript.Echo "Please specify the source and the destination files. Usage: ExcelToCsv &lt;xls/xlsx source file&gt; &lt;csv destination file&gt; &lt;worksheet number (starts at 1)&gt;"
    Wscript.Quit
End If

csv_format = 6

Set objFSO = CreateObject("Scripting.FileSystemObject")

src_file = objFSO.GetAbsolutePathName(Wscript.Arguments.Item(0))
dest_file = objFSO.GetAbsolutePathName(WScript.Arguments.Item(1))
worksheet_number = CInt(WScript.Arguments.Item(2))

Dim oExcel
Set oExcel = CreateObject("Excel.Application")

Dim oBook
Set oBook = oExcel.Workbooks.Open(src_file)
oBook.Worksheets(worksheet_number).Activate

oBook.SaveAs dest_file, csv_format

oBook.Close False
oExcel.Quit
""";

f = open('ExcelToCsv.vbs','w')
f.write(vbscript.encode('utf-8'))
f.close()
</code></pre>
<p>This answer benefited from <a href="https://stackoverflow.com/questions/1858195/convert-xls-to-csv-on-command-line">Convert XLS to CSV on command line</a> and  <a href="https://stackoverflow.com/questions/16182822/csv-xlsx-files-import-to-pandas-data-frame-speed-issue">csv &amp; xlsx files import to pandas data frame: speed issue</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you have less than 65536 rows (in each sheet) you can try <code>xls</code> (instead of <code>xlsx</code>. In my experience <code>xls</code> is faster than <code>xlsx</code>. It is difficult to compare to <code>csv</code> because it depends on the number of sheets.</p>
<p>Although this is not an ideal solution (<code>xls</code> is a binary old privative format), I have found it is useful if you have <strong>too many sheets</strong>, internal formulas <strong>with values that are often updated</strong>, or for whatever reason you would really like to <strong>keep the excel multisheet functionality</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this is old but in case anyone else is looking for an answer that doesn't involve VB. Pandas <code>read_csv()</code> <em>is</em> faster but you don't need a VB script to get a csv file. </p>
<p>Open your Excel file and save as *.csv (comma separated value) format. </p>
<p>Under tools you can select Web Options and under the Encoding tab you can change the encoding to whatever works for your data. I ended up using Windows, Western European because Windows UTF encoding is "special" but there's lots of ways to accomplish the same thing. Then use the encoding argument in <code>pd.read_csv()</code> to specify your encoding. </p>
<p>Encoding options are listed <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" rel="nofollow noreferrer">here</a></p>
</div>
<span class="comment-copy">Could you try saving as csv and loading it, it's possible the excel reader is not as fast as the csv one</span>
<span class="comment-copy">It has multiple worksheets though so won't that not work?</span>
<span class="comment-copy">You should still be able to save each sheet, unfortunately the pain here is that you have to save each sheet separately, 14MB is not a large size and the csv reader will eat this up very quickly. Another point maybe to try <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.ExcelFile.parse.html#pandas.ExcelFile.parse" rel="nofollow noreferrer"><code>ExcelFile.parse</code></a></span>
<span class="comment-copy">If on Linux ,what is the solution?</span>
