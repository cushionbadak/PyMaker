<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/ctypes.html#loading-shared-libraries" rel="nofollow noreferrer">https://docs.python.org/3/library/ctypes.html#loading-shared-libraries</a></p>
<blockquote>
<p>Shared libraries can also be loaded by using one of the prefabricated
  objects, which are instances of the LibraryLoader class, either <strong>by
  calling the LoadLibrary() method</strong>, or <strong>by retrieving the library as
  attribute of the loader instance</strong>.</p>
</blockquote>
<p>I found an example for the first way <a href="https://stackoverflow.com/q/21770419/156458">Free the opened ctypes library in Python</a></p>
<p>I was wondering how to use the second way? In particular, how is the attribute of the loader instance <code>cdll</code> created?  My question comes from <a href="https://stackoverflow.com/questions/50798907/why-does-loading-the-libc-shared-library-have-libraryloader-object-is-not-cal#comment88680810_50799159">Why does loading the libc shared library have "'LibraryLoader' object is not callable" error?</a></p>
<blockquote>
<p>The whole point of the LibraryLoader is that it creates the library for you when you access it. And <code>cdll.LoadLibrary("foo")</code> doesn't create <code>cdll.foo</code>.</p>
</blockquote>
<p>Is there something wrong with my experiment? Why does <code>cdll.libc</code> never exist?</p>
<pre><code>&gt;&gt;&gt; from ctypes import *
&gt;&gt;&gt; cdll.libc
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.6/ctypes/__init__.py", line 418, in __getattr__
    dll = self._dlltype(name)
  File "/usr/lib/python3.6/ctypes/__init__.py", line 348, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: libc: cannot open shared object file: No such file or directory
&gt;&gt;&gt; cdll.LoadLibrary("libc.so.6")
&lt;CDLL 'libc.so.6', handle 7f6afe03a000 at 0x7f6afc1afac8&gt;
&gt;&gt;&gt; cdll.libc
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.6/ctypes/__init__.py", line 418, in __getattr__
    dll = self._dlltype(name)
  File "/usr/lib/python3.6/ctypes/__init__.py", line 348, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: libc: cannot open shared object file: No such file or directory
&gt;&gt;&gt; libc=cdll.LoadLibrary("libc.so.6")
&gt;&gt;&gt; cdll.libc
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.6/ctypes/__init__.py", line 418, in __getattr__
    dll = self._dlltype(name)
  File "/usr/lib/python3.6/ctypes/__init__.py", line 348, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: libc: cannot open shared object file: No such file or directory
&gt;&gt;&gt; CDLL("libc.so.6")
&lt;CDLL 'libc.so.6', handle 7f6afe03a000 at 0x7f6afc1af978&gt;
&gt;&gt;&gt; cdll.libc
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.6/ctypes/__init__.py", line 418, in __getattr__
    dll = self._dlltype(name)
  File "/usr/lib/python3.6/ctypes/__init__.py", line 348, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: libc: cannot open shared object file: No such file or directory

&gt;&gt;&gt; libc=CDLL("libc.so.6")
&gt;&gt;&gt; cdll.libc
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.6/ctypes/__init__.py", line 418, in __getattr__
    dll = self._dlltype(name)
  File "/usr/lib/python3.6/ctypes/__init__.py", line 348, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: libc: cannot open shared object file: No such file or directory
&gt;&gt;&gt; cdll.__dict__
{'_dlltype': &lt;class 'ctypes.CDLL'&gt;}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Example (<strong>what</strong> happens):</p>
<blockquote>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; print("Python {:s} on {:s}".format(sys.version, sys.platform))
Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32
&gt;&gt;&gt;
&gt;&gt;&gt; [item for item in dir(ctypes.windll) if "__" not in item]
['LoadLibrary', '_dlltype', 'kernel32']
&gt;&gt;&gt;
&gt;&gt;&gt; user32_dll = ctypes.windll.LoadLibrary("user32")
&gt;&gt;&gt; user32_dll
&lt;WinDLL 'user32', handle 7ff882810000 at 0x2434399b4e0&gt;
&gt;&gt;&gt; [item for item in dir(ctypes.windll) if "__" not in item]
['LoadLibrary', '_dlltype', 'kernel32']
&gt;&gt;&gt;
&gt;&gt;&gt; user32_dll = ctypes.WinDLL("user32")
&gt;&gt;&gt; user32_dll
&lt;WinDLL 'user32', handle 7ff882810000 at 0x2434399b4a8&gt;
&gt;&gt;&gt; [item for item in dir(ctypes.windll) if "__" not in item]
['LoadLibrary', '_dlltype', 'kernel32']
&gt;&gt;&gt;
&gt;&gt;&gt; user32_dll = ctypes.windll.user32
&gt;&gt;&gt; user32_dll
&lt;WinDLL 'user32', handle 7ff882810000 at 0x24343984d68&gt;
&gt;&gt;&gt; [item for item in dir(ctypes.windll) if "__" not in item]
['LoadLibrary', '_dlltype', 'kernel32', 'user32']
&gt;&gt;&gt;
&gt;&gt;&gt; ctypes.windll.user32
&lt;WinDLL 'user32', handle 7ff882810000 at 0x24343984d68&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; ctypes.windll.user321
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "c:\install\x64\python\python\3.5\Lib\ctypes\__init__.py", line 421, in __getattr__
    dll = self._dlltype(name)
  File "c:\install\x64\python\python\3.5\Lib\ctypes\__init__.py", line 351, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: [WinError 126] The specified module could not be found
&gt;&gt;&gt;
&gt;&gt;&gt; dir(ctypes.windll)
['LoadLibrary', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattr__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_dlltype', 'kernel32', 'user32']
</code></pre>
</blockquote>
<p><strong>How</strong> it happens - it's all in <em>"${PYTHON_SRC_DIR}/Lib/ctypes/__init__.py"</em> <br/>(<a href="https://github.com/python/cpython/blob/master/Lib/ctypes/__init__.py" rel="nofollow noreferrer">[GitHub]: python/cpython - (master) cpython/Lib/ctypes/__init__.py</a>). I'm pasting code for <code>cdll</code> since <code>windll</code> (that I used in the example above) is just a wrapper over it (and would require a bit more code):</p>
<pre><code># ...

class CDLL(object):

# ...

class LibraryLoader(object):
    def __init__(self, dlltype):
        self._dlltype = dlltype

    def __getattr__(self, name):
        if name[0] == '_':
            raise AttributeError(name)
        dll = self._dlltype(name)
        setattr(self, name, dll)  # @TODO - cfati: This is the key for always returning the same instance.
        return dll

# ...

cdll = LibraryLoader(CDLL)

# ...
</code></pre>
<p><strong><em>@EDIT0</em></strong>:</p>
<p>Hmm, on <em>Ux</em> (<em>Lnx</em> at least) things aren't so nice:</p>
<blockquote>
<pre><code>[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050838633]&gt; ls
libcapi.so
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050838633]&gt; LD_LIBRARY_PATH=$(pwd) python3 -c "import ctypes; ctypes.cdll.LoadLibrary('libcapi.so')"
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050838633]&gt; LD_LIBRARY_PATH=$(pwd) python3 -c "import ctypes; ctypes.cdll.LoadLibrary('libcapi')"
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.5/ctypes/__init__.py", line 425, in LoadLibrary
    return self._dlltype(name)
  File "/usr/lib/python3.5/ctypes/__init__.py", line 347, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: libcapi: cannot open shared object file: No such file or directory
</code></pre>
</blockquote>
<p>That is because apparently (as opposed to <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175(v=vs.140).aspx" rel="nofollow noreferrer">[MSDN]: LoadLibrary function</a>), <a href="http://man7.org/linux/man-pages/man3/dlopen.3.html" rel="nofollow noreferrer">[man7]: DLOPEN(3)</a> doesn't append the (default) library extension (<em>.so</em>) to the file name (if it doesn't contain it already).</p>
<p><em>code.c</em>:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;dlfcn.h&gt;


int main(int argc, char *argv[]) {
    if (argc == 1) {
        printf("Dll name required\n");
        return 1;
    }
    void *handle = dlopen(argv[1], RTLD_NOW);
    if (handle == NULL) {
        printf("Could not load [%s]\n", argv[1]);
        return 2;
    } else {
        printf("Successfully loaded [%s]\n", argv[1]);
        dlclose(handle);
        return 0;
    }
}
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050838633]&gt; gcc code.c -Wl,-ldl
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050838633]&gt; ./a.out "libcapi.so"
Could not load [libcapi.so]
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050838633]&gt; LD_LIBRARY_PATH=$(pwd) ./a.out "libcapi.so"
Successfully loaded [libcapi.so]
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q050838633]&gt; LD_LIBRARY_PATH=$(pwd) ./a.out "libcapi"
Could not load [libcapi]
</code></pre>
</blockquote>
<p>So, the <em>Win</em> behavior can't be replicated on <em>Ux</em> (unfortunately, <code>.</code> (<em>dot</em>) can't be part of an attribute name, in order to overcome this). Or, maybe the linker could be configured to search for <em>.so</em> files implicitly? But that would only solve the problem partially as many libraries look like <em>libc.so.6</em> (or <em>AFAIK</em>, on <em>OSX</em> both <em>.so</em> and <em>.dylib</em> are <em>OK</em>).</p>
</div>
<span class="comment-copy">Thanks. See my edit for my tests.</span>
<span class="comment-copy">All <code>cdll.libc</code> statements raised <code>OSError</code> like <code>ctypes.windll.user321</code> case in which the <code>user321</code> wasn't added in <code>windll</code> attributes list. Same thing for <code>cdll.LoadLibrary("libc.so.6")</code> or <code>CDLL("libc.so.6")</code> in these situations (even if loading is successful), the attribute is not added to <code>cdll</code> (also covered by my example).</span>
<span class="comment-copy">What is the step missing to add the attribute to <code>cdll</code>?</span>
<span class="comment-copy">@Tim Since <code>cdll.libc</code> doesn't work, the only way you can make <code>cdll</code> have a <code>libc</code> attribute is by manually assigning something to that attribute. But why would you want to? <code>cdll</code> is a convenience wrapper that makes it easier to load shared libraries. If it doesn't work (like on linux), just avoid it.</span>
