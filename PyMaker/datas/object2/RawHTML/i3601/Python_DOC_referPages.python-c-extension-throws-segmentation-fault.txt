<div class="post-text" itemprop="text">
<pre><code>#include &lt;Python.h&gt;
#include &lt;math.h&gt;

static PyObject* interpolate(PyObject* self, PyObject* args) {
    const Py_ssize_t tl = 2;
    const Py_ssize_t ll = 0;
    int nx, ny, angle, distance;
    if (!PyArg_ParseTuple(args, "iiii", &amp;nx, &amp;ny, &amp;angle, &amp;distance)) {
        return NULL;
    }
    PyObject* pos_list = PyList_New(ll);
    for (int i = 0; i &lt; distance; i++) {
        double x = -i * cos(angle * M_PI / 180);
        double y = -i * sin(angle * M_PI / 180);
        PyObject *pos = PyTuple_Pack(tl, x, y);
        PyList_Append(pos_list, pos);
    }
    return pos_list;
}
</code></pre>
<p>Code keeps throwing a segmentation fault when I import the module from Python. Not too sure why this is happening as I'm really new to C and C Extensions. I'm not sure if I'm doing my setup.py code correctly either. I think the error is related to my returning the pos_list variable and math.h not being included properly. When I removed the math.h sin and cos stuff and switched to Py_BuildValue a simple integer, it works.</p>
<pre><code>from distutils.core import setup, Extension

module1 = Extension('gameMath',
                    sources = ['interpolate.c'],
                    include_dirs = ['/usr/include'],
                    libraries = ['math'])
setup (name = 'gameMath',
        version = '1.0',
        description = 'game math',
        ext_modules = [module1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There may be multiple problems here, but, assuming the module boilerplate is correct (you haven't included it), and your setup.py is correct to actually build the code (it isn't as posted), and you're calling this in the obvious way, there's at least one likely segfault here:</p>
<pre><code>PyObject *pos = PyTuple_Pack(tl, x, y);
</code></pre>
<p>As <a href="https://docs.python.org/3/c-api/tuple.html#c.PyTuple_Pack" rel="nofollow noreferrer"><code>PyTuple_Pack</code></a> documents:</p>
<blockquote>
<p>Return a new tuple object of size <em>n</em>, or <em>NULL</em> on failure. The tuple values are initialized to the subsequent <em>n</em> C arguments <strong>pointing to Python objects</strong>.</p>
</blockquote>
<p>You're not passing it pointers to Python objects, you're passing it doubles. So, it will try to interpret each double as a pointer, which is very likely to segfault.<sup>1</sup></p>
<p>You either need to construct two Python <code>float</code> objects with <a href="https://docs.python.org/3/c-api/float.html#c.PyFloat_FromDouble" rel="nofollow noreferrer"><code>PyFloat_FromDouble</code></a>, or <a href="https://docs.python.org/3/c-api/arg.html#c.Py_BuildValue" rel="nofollow noreferrer"><code>Py_BuildValue</code></a> to convert them on the fly:</p>
<pre><code>PyObject *pos = Py_BuildValue("(ff)", x, y);
</code></pre>
<hr/>
<p><a href="https://gist.github.com/abarnert/c00ea060364ae6cb88a687c5886746a8" rel="nofollow noreferrer">A completed and cleaned-up version with this fix</a> seems to work.</p>
<hr/>
<p><sub>1. If you don't know enough C, but want to know why it crashes: Assuming 64-bit here, you're asking it to interpret the 64 bits of the double as a pointer. For, say, <code>-2.0</code>, that's a pointer to <code>0xC000000000000000</code>. Which is likely to not be in allocated memory, much less a pointer to a valid <code>PyObject</code> struct whose pointers themselves point to allocated memory, and even if all such pages are allocated, it's likely that one of them pages will be readonly so, e.g., a reference count increment fails.</sub></p>
</div>
<span class="comment-copy">Are you actually building a module object, etc.? Normally I'd just assume that was all done correctly, but since you're saying you don't even know if you did the <code>setup.py</code> right, that doesn't seem like a safe assumption…</span>
<span class="comment-copy">Also,. what platform are you on that has Unix-style paths, but has <code>-lmath</code> instead of <code>-lm</code>, so this even compiles in the first place?</span>
<span class="comment-copy">@abarnert macOS. It might still be -lm, I'll give that a try. But even without the math, it still errors when I return a list.</span>
<span class="comment-copy">Also, why have you tagged this <code>c++</code> when your code is valid as C, invalid as C++, stored in a <code>.c</code> file, and compiled as C by distutils? Is your real code C++, or did you use the wrong tag? If the latter, fix it. If you <i>are</i> using C++, or even if you're just open to the possibility of switching, have you considered using PyCxx, boost::python, or one of the other wrappers that does all the annoying boilerplate stuff for you, automatically manages refcounts with RAII, etc.?</span>
<span class="comment-copy">@abarnert I only tagged it as Python. Somehow it must’ve auto tagged.</span>
<span class="comment-copy">I've made a minor change to the formatting, putting a block of text in <code>&lt;sup&gt;</code> can cause accessibility problems.</span>
<span class="comment-copy">@DietrichEpp It's a footnote, which isn't going to be interesting to most people. Displaying it in full-size is just distracting. Is there a better way to display it in unobtrusive small text that works on SO that doesn't cause the accessibility problems of using <code>sub</code>?</span>
<span class="comment-copy">I don't have a good answer for that. Feel free to revert the edit, the main reason I commented was so you would have a chance to revert if you like.</span>
<span class="comment-copy">@DietrichEpp I found <a href="https://meta.stackexchange.com/a/253759/230882">my own answer on a feature request from over 3 years ago</a>, and two years later <a href="https://meta.stackexchange.com/a/302182/230882">that feature request was declined</a>, accepting that the <code>sub</code> workaround is, while ugly, good enough for SO.</span>
<span class="comment-copy">FWIW -2.0 in bit representation is actually 0xc000000000000000 (little-endian).</span>
