<div class="post-text" itemprop="text">
<p>I've got a class that has replaced <code>__iter__</code> to hide extra unneeded data. I've made the rest of my code backwards compatible by setting <code>iteritems</code> to either <code>dict.iteritems</code> or <code>dict.items</code> depending on the python version, and I can then call <code>iteritems(class_object)</code>, but it doesn't seem to work well with my class.</p>
<p>It'll be easier to explain with an example:</p>
<pre><code>class Test(dict):
    def __init__(self, some_dict):
        self.some_dict = some_dict
        super(self.__class__, self).__init__(self.some_dict)
    def __iter__(self):
        for k, v in self.some_dict.iteritems():
            yield k, v['value']

test_dict = {
    'a': {'value': 'what',
          'hidden': 123},
    'b': {'value': 'test'}
}
</code></pre>
<p>If I do <code>Test(test_dict).__iter__()</code>, then it correctly returns <code>{'a': 'what', 'b': 'test'}</code></p>
<p>If I add <code>iteritems = __iter__</code> to the class, then it also works when doing <code>Test(test_dict).iteritems()</code></p>
<p>However, no matter what I try, doing <code>dict.iteritems(Test(test_dict))</code> defaults to the standard dict iterating, and returns <code>{'a': {'hidden': 123, 'value': 'what'}, 'b': {'value': 'test'}}</code></p>
<p>I've tried a couple of trace functions but they don't go deep enough to figure out what's going on.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>dict.iteritems()</code> method reaches straight into the internal data structures of the <code>dict</code> implementation. You passed in a subclass of <code>dict</code> so those same data structures are there for it to access. You can't override this behaviour.  </p>
<p>Not that <code>dict.iteritems()</code> would ever use <code>__iter__</code>; the latter produces <em>keys only</em>, not key-value pairs!</p>
<p>You should instead define <code>iteritems</code> differently; given a <code>PY3</code> boolean variable that is <code>False</code> for Python 2, <code>True</code> otherwise:</p>
<pre><code>from operator import methodcaller

iteritems = methodcaller('items' if PY3 else 'iteritems')
</code></pre>
<p>Now <code>iteritems(object)</code> is translated to <code>object.iteritems()</code> or <code>object.items()</code>, as needed, and the correct method is always called.</p>
<p>Next, to extend dictionary behaviour, instead of subclassing <code>dict</code>, I'd subclass <a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow noreferrer"><code>collections.MutableMapping</code></a> <sup>(*)</sup>:</p>
<pre><code>from collections import MutableMapping

class Test(MutableMapping):
    def __init__(self, some_dict):
        self.some_dict = some_dict.copy()

    def __getitem__(self, key):
        return self.some_dict[key]

    def __setitem__(self, key, value):
        self.some_dict[key] = value

    def __delitem__(self, key):
        del self.some_dict[key]

    def __len__(self):
        return len(self.some_dict)

    def __iter__(self):
        for k, v in self.some_dict.iteritems():
            yield k, v['value']
</code></pre>
<p>This implements all the same methods that <code>dict</code> provides, <em>except</em> for <code>copy</code> and the <code>dict.fromkeys()</code> class method.</p>
<p>You could instead inherit from <a href="https://docs.python.org/3/library/collections.html#collections.UserDict" rel="nofollow noreferrer"><code>collections.UserDict()</code></a>, which adds those two remaining methods:</p>
<pre><code>try:
    # Python 2
    from UserDict import UserDict
except ImportError:
    from collections import UserDict


class Test(UserDict):
    def __iter__(self):
        for k, v in self.data.iteritems():
            yield k, v['value']
</code></pre>
<p>Only an alternate <code>__iter__</code> implementation is needed in that case.</p>
<p>In either case, you <em>still can't use <code>dict.iteritems</code> on these objects</em>, because that method can only work with actual <code>dict</code> objects.</p>
<hr/>
<p><sup>(*)</sup> <code>collections.MutableMapping</code> is the Python 2 location of that class, the official Python 3 location is <code>collections.abc.MutableMapping</code> but there are aliases in place to support Python 2-compatible code.</p>
</div>
<span class="comment-copy">I'm not sure why you are inheriting from <code>dict</code> but keeping an extra reference to to the dictionary in <code>self.some_dict</code>. You could just use <code>self.iteritems()</code>. Note that normally, iteration over a dictionary only yields <i>keys</i>, not key-value pairs.</span>
<span class="comment-copy">Why do you need <code>dict.iteritems</code> to work? That's not a regular Python method, it reaches into the <code>dict</code> internals. Since you subclassed <code>dict</code> that's possible and permissible.</span>
<span class="comment-copy">@MartijnPieters Have I been doing it wrong with <code>__init__</code>? I'd like to inherit all the normal dict functions but still be able to easily access and change all the data. As to not doing <code>self.iteritems()</code>, it's mainly for keeping it consistent with the rest of the code. I've been using <code>iteritems(dict)</code> to keep it compatible with both python 2 and 3, and I'd prefer to keep this within the same style if possible.</span>
<span class="comment-copy"><code>dict.iteritems</code> is the method of the superclass. It ignores any overrides in subclasses.</span>
<span class="comment-copy">@fafl: much more importantly, its implementation doesn't use any other methods on the instance. It just reaches straight into the struct that makes up the instance state and accesses <code>ma_table</code> and other C-level data structures.</span>
<span class="comment-copy">Oh damn, that <code>methodcaller</code> works great, I've just basically been doing <code>iteritems = dict.items if PY3 else dict.iteritems</code>. My classes have already grown <a href="https://github.com/Peter92/MouseTracks/blob/master/core/ini.py" rel="nofollow noreferrer">slightly complicated</a>, but at the base of the inheritance it's sort of like <code>UserDict</code>, and <code>MutableMapping</code> could potentially be used a bit higher up, so it may not be too bad to adapt. Thanks :)</span>
<span class="comment-copy">@Peter: you could also just use <a href="https://github.com/benjaminp/six" rel="nofollow noreferrer"><code>six.py</code></a>; it is MIT licensed specifically so you can freely copy it into your project as needed, or you can make it a <code>setup.py</code> dependency.</span>
<span class="comment-copy">@Peter: <code>six</code> implements <code>iteritems()</code> as <code>iter(d.items())</code> on Python 3, as that is technically more correct.</span>
<span class="comment-copy">Oh wait a sec, I may have used the code wrong, does the <code>methodcaller</code> still completely bypass the class? The <code>iteritems</code> in <code>six.py</code> is a lot simpler than what I'd have thought though, the file would have been very useful earlier, but some of the other code is completely relying on my own compatibility file :P</span>
<span class="comment-copy"><code>methodcaller(name_of_method)(object)</code> will execute the <code>name_of_method</code> method on <code>object</code>. It doesn't matter what type of object it is. You'll need provide an implementation of <code>iteritems()</code> <i>on your class</i> if you want it called. If you subclassed <code>dict</code> but did not provide your own <code>iteritems()</code> implementation, you still would get the wrong results.</span>
