<div class="post-text" itemprop="text">
<p>So I have this class with the repr method implemented</p>
<pre><code>import reprlib

class Test:
    def __init__(self, aList):
        self.my_list = [c for c in aList]

    def __repr__(self):
#         return " ".join((str(i) for i in self.my_list))
#         return reprlib.repr(self.my_list)
#         return repr(self.my_list)  # builtin repr method
        return str(self.my_list)
</code></pre>
<p>What are the differences between the various implementations of the repr method?</p>
<p>They all have the same output.</p>
<p>Code used on all implementations:</p>
<pre><code>x = [2, 5, 11]
t = Test(x)
print(t)  # &gt;&gt; [2, 5, 11]
t  # &gt;&gt; output [2, 5, 11]
</code></pre>
<p>Edit:
The first implementation (join method) will produce the items without brackets.
Disregard that if you like. My focus is what are differences among the last three and which is the better implementation among all four implementation.</p>
<p>Edit:
This is clearly not about the differences between the repr and str methods.
It's about which implementation should I consistently adopt when implementing the repr method (or the str method for that matter). </p>
</div>
<div class="post-text" itemprop="text">
<p>First, what <em>I</em> would write:</p>
<pre><code>def __repr__(self):
    return '%s(%r)' % (self.__class__.__qualname__, self.my_list)
</code></pre>
<p>This preserves the primary purpose of a repr: to tell both the class and the important parts of the value. You could replace <code>__qualname__</code> with <code>__name__</code>, or add <code>__module__</code>, but I find this is the best balance.</p>
<p>Sometimes, for more complicated cases (mostly, whenever parts of the repr should only appear conditionally), I wrote something like:</p>
<pre><code>def __repr__(self):
    bits = []
    bits.append(...)
    return ''.join(bits)
</code></pre>
<p>All of your answers are missing the class, so I won't mention it again below.</p>
<hr/>
<pre><code>def __repr__(self):
    return " ".join((str(i) for i in self.my_list))
</code></pre>
<p>This is bad for a lot of reasons, although it can be fixed:</p>
<ul>
<li>Missing brackets. To fix, use <code>'[%s]' % ...</code></li>
<li>Missing commas. To fix, use <code>', '.join(...)</code></li>
<li>Pointless use of a generator comprehension. Generators are very slow compared to list comprehensions, so whenever you're consuming the whole value immediately, always use a list comprehension.</li>
<li>Calls <code>str</code> instead of <code>repr</code>. This will produce confusing output for things like <code>['1', '2', '3']</code></li>
</ul>
<pre><code>def __repr__(self):
    return reprlib.repr(self.my_list)
</code></pre>
<p>This will truncate the list after some number of elements. Honestly, I find this more annoying than anything else.</p>
<p>The only function I ever use from that module is the <code>reprlib.recursive_repr</code> decorator, and even that only in the rare case that I can't just call builtin repr that is already recursion-aware. Notably, <code>list</code> is, so you don't need it here.</p>
<pre><code>def __repr__(self):
    return repr(self.my_list)
</code></pre>
<p>This is as correct as any of your answers get. May cause problems for exceptionally-long lists. However, since reprs need more information than this, it often ends up being worth using <code>'%r' % ...</code> or <code>{!r}.format(...)</code></p>
<pre><code>def __repr__(self):
    return str(self.my_list)
</code></pre>
<p>This happens to produce the same output for <code>list</code>, but is semantically incorrect.</p>
<hr/>
<p>As an aside, instead of:</p>
<pre><code>self.my_list = [c for c in aList]
</code></pre>
<p>use:</p>
<pre><code>self.my_list = list(aList)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My undestanding of <code>__repr__</code> is that in the best possibility it should allow replicating the instance (perhaps even with <code>eval()</code>), and second-best is giving precise information about how to do that. </p>
<p>My preference for a mature <code>__repr__</code> would be: </p>
<pre><code>class Spammer:
    def __init__(self, members, hidden=False):
        self._list = list(members)
        self._hidden = hidden

    def __repr__(self):
        return 'Spammer(members={}, hidden={})'.format(self._list, self._hidden)

assert repr(Spammer([1,2], True)) == 'Spammer(members=[1, 2], hidden=True)'
</code></pre>
<p>The drawback of this approach is that you have to change <code>__repr__</code> each time 
you introduce changes to <code>__init__</code>. Also <code>__repr__</code>has a tendency to fail silently
in IDE without any exceptions, so explicit testing of it is necessary.</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends on what you plan on doing with the class's repr. </p>
<ul>
<li><p>If you are planning on doing custom formatting or the <code>my_list</code> attribute can be any iterable (though remember to avoid losing the data to the repr) instead of just a list, you should do something like the <code>str.join</code> method.</p></li>
<li><p>If you want to consider size and trim for that (making a large list display like <code>Test([x, y, z, ...])</code> or something), consider using <a href="https://docs.python.org/3/library/reprlib.html" rel="nofollow noreferrer">reprlib</a> since it has functionality for that.</p></li>
<li><p>If you don't have any specific requirements, stick to whichever is simplest (namely <code>repr</code>, <code>str</code> and sometimes <code>str.join</code>)</p></li>
</ul>
</div>
<span class="comment-copy"><i>"They all have the same output."</i> That's weird, they aren't all the same on my machine. The first one doesn't print any square brackets, for instance.</span>
<span class="comment-copy">How is this a duplicate of the posted question?????? It absolutely has nothing to do with the difference between str and repr. I'm asking about the different implementation of repr. Didn't even mention str or tag it. My question is about the code inside the repr method.</span>
<span class="comment-copy">The difference between your last two options is exactly the difference between <code>__str__</code> and <code>__repr__</code> since <i>that is what you are calling</i>. The fact that you've decided to potentially put them in <code>__repr__</code> for your class is almost irrelevant.  I'm guessing that your real question is actually about a design decision, but frankly using a list as an example is probably not the best since it is so simple ... and I would say rather than a duplicate it's actually just close-worthy as <i>primarily opinion-based</i>.</span>
<span class="comment-copy">@Ajean when only one small part of the question is a duplicate, it's not a duplicate</span>
<span class="comment-copy">@o11c Did you actually read my comment? I specifically said it's not a duplicate, but I was responding to OP's comment that it is completely unrelated (which it's not)</span>
<span class="comment-copy">What is semantically wrong with <code>str(self.my_list)</code>? One should not confuse <code>str</code> inside <code>__repr__</code>?</span>
<span class="comment-copy">@EvgenyPogrebnyak It's about expressing intention - and about forming good habits.</span>
<span class="comment-copy">I wish I had a advanced version of Google translate for some of your thoughts - it is very unclear. <i>Semantically incorrect</i> is...? str looks  bad inside <code>__repr__</code>? or the result of a call is bad?</span>
<span class="comment-copy">@EvgenyPogrebnyak Anybody can write a program that produces a given output. It takes discipline to consistently write programs that produce correct output <i>and</i> can be modified when requirements change. And discipline is closely tied to habit, as well as consciously following rules even when they have no immediate effect.</span>
<span class="comment-copy">the upvote on your comment is mine</span>
<span class="comment-copy">Using <code>eval</code> <i>programmatically</i> on repr is a horrible idea. More it's about "let's copy-paste this into a REPL and tweak it", at which point the <code>&lt;...&gt;</code> convention starts to matter.</span>
<span class="comment-copy">Also, the <code>attr</code> module or numerous ad-hoc module conventions eliminate the need for changing <code>__repr__</code> when <code>__init__</code> changes.</span>
<span class="comment-copy">@o11c - Can you elaborate on <i>attr module or numerous ad-hoc module conventions</i>? I do not understand what it means.</span>
