<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/5389507/iterating-over-every-two-elements-in-a-list">Iterating over every two elements in a list</a>
<span class="question-originals-answer-count">
                    18 answers
                </span>
</li>
</ul>
</div>
<p>I am looking for a nice solution, to read always two elements out of a list in Python 3. What do I need to write for ??? in the following code:</p>
<pre><code>it = [1,2,3,4,5,6]
for x, y in ??? :
    print (x, y)
</code></pre>
<p>The desired output would be:</p>
<pre><code>1 2
3 4
5 6
</code></pre>
<p>A solution proposed in an earlier post did not work : for x, y in zip(it,it):    print (x, y)</p>
<p>Also one could solve it with indexed for-loop. But this is also ugly (IMHO)</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>zip(*[iter(it)] * 2)</code>, as seen in <a href="https://stackoverflow.com/a/2631256/6597761">this answer</a>.</p>
<pre><code>it = [1,2,3,4,5,6]
for x, y in zip(*[iter(it)] * 2):
    print(x, y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another easy way without zip is:</p>
<pre><code>i = 0
while i &lt; len(it)-1:
  print(it[i], it[i+1])
  i += 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another cheap option, using indices. You might not like them, but they are fast.</p>
<pre><code>it = [1,2,3,4,5,6]
for x in range(0, len(it)-1, 2):
    print(it[x], it[x+1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is another approach which will work in <code>Python3</code>:</p>
<pre><code>def pair(a):
   # Or simply:
   # return zip(a[::2], a[1::2])
   for k, v in zip(a[::2], a[1::2]):
       yield k, v

a = [1,2,3,4,5,6]
final = list(pair(a))
print(final)
</code></pre>
<p>Output:</p>
<pre><code>[(1, 2), (3, 4), (5, 6)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Got this to work for your case:</p>
<pre><code>l = [1,2,3,4,5,6]
print(*[' '.join([str(a) for a in x]) for x in zip(l[::2],l[1:][::2])],sep='\n')
</code></pre>
<p>First I had to use l[::2] to create a list the odd numbers in the list, then l[1:][::2] to get even numbers.  Did this using slicing function which is quite useful <a href="https://coderwall.com/p/rujmya/get-odd-and-even-indexed-values-from-list-in-python" rel="nofollow noreferrer">link</a></p>
<p>Then I zipped them together to match 1st, 2nd, 3rd elements etc <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">link</a></p>
<p>Then I used list comprehension to create a list of each of those sets.  The problem is that they were sets and not text as above.  To resolve this I changed my sets to string <code>str()</code> .  </p>
<p>Now that the individual sets have been turned into string, you can join with <code>' '</code>.</p>
<p>You still have a set of 3 but you can print each line with print(*[list here],sep='\n') <a href="https://stackoverflow.com/questions/13443588/how-can-i-format-a-list-to-print-each-element-on-a-separate-line-in-python">link</a></p>
<p>Learned a few new tricks, hope this helps!</p>
</div>
<span class="comment-copy">I saw this answer too. However the anser there was mainly for python2 and the answer for python3 did not work. What do you propose?</span>
<span class="comment-copy">? The solution works just fine in python 3 if you replace <code>izip</code> with <code>zip</code>.</span>
<span class="comment-copy">Alternatively, you can scroll down past the first answer...</span>
<span class="comment-copy">use <a href="https://stackoverflow.com/a/2631256/6597761"><code>zip(*[iter(it)] * 2)</code></a></span>
<span class="comment-copy">@Ivan your code worked. Thanks</span>
<span class="comment-copy">Could you explain to me why  <b>for x, y in zip(it,it)</b> is not working?</span>
<span class="comment-copy">@MarcelSonderegger <code>zip</code> will sweeps its arguments within the same step untill the minimum length of them. So, in your case <code>zip(it, it)</code> will yield <code>(1,1), (2,2),...</code></span>
<span class="comment-copy">@ChihebNexus : whereas <code>zip(*[iter(it)] * 2)</code> takes one element and duplicates it. I got it, thanks.</span>
<span class="comment-copy">I agree it is easy, but it uses indexes: I try to avoid indexes whenever possible. But that's a matter of style</span>
<span class="comment-copy">Yes it uses indexes. I did not have read this, sorry. But maybe someone else will help this. Luckily there are enough answers which will help you.</span>
<span class="comment-copy">I compleatly agree with you. My many years of C programming and buffer overflows hurt me a lot. Anyway thanks.</span>
<span class="comment-copy">Ansering exactly the question the answer for the question marks would be: <code>zip(a[::2], a[1::2])</code> . In my opinion a very readable answer. Congratulation.</span>
<span class="comment-copy">That's unreadable. This won't pass any code review on earth.</span>
<span class="comment-copy">@aran-fey I'm sure OP is worried about peer review as he submits this to the platform he is building.  There are different approaches to solving problems on this site.  I combined a few different functions and explain and note source for each.  This site is educational and all solutions have merit</span>
<span class="comment-copy">Dear @EoinS, you made me smile when I read your code. I am sure it will work. I liked how you used a real unusual approach to solve the problem: going over strings. However, imagine yourself reunderstanding your own code in a few years. It could be difficult.</span>
