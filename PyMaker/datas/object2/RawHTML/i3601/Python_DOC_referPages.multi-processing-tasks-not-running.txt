<div class="post-text" itemprop="text">
<p>I have two threads that receive asynchronous data and want to process this data in the main thread.  the first process the main thread call (ProcessA) runs but the second is never executed. For ease of space and explanation I've simplified the threads.
The first thread is:</p>
<pre><code>import logging
import time
logging.basicConfig(filename='ProcessA.log',level=logging.DEBUG)
from multiprocessing import Queue
q = Queue()
class ProcessA(q):
    global variableA 
    logging.info('ProcessA started') 
    while (True):
        variableA = 'A' + str(time.time()) 
        q.put(variableA)
        logging.info (variableA)
        time.sleep(5)
</code></pre>
<p>The second thread is similar:</p>
<pre><code>import time
from multiprocessing import Queue
import logging
logging.basicConfig(filename='ProcessB.log',level=logging.DEBUG)
q = Queue()
class ProcessB(q):
    logging.info('ProcessB started') 
    global variableB 
    while (True):
        variableB = 'B' + str(time.time()) 
        q.put (variableB)
        logging.info (variableB)
        time.sleep(2)
</code></pre>
<p>The main calling thread is as follows:  </p>
<pre><code>import time 
from multiprocessing import  Process, Queue
import ProcessA.py
import ProcessB.py

import logging
logging.basicConfig(filename='MThread.log',level=logging.DEBUG)

if __name__ == "__main__":
    queue = Queue()
    a =Process(target=ProcessA, args=(queue,))
    a.start()

    b = Process(target=ProcessB, args=(queue,))
    b.start()

    while (True):
        if not queue.empty():
            variableC = queue.get()
            logging.info ("variableC ="+ variableC) 
            time.sleep(1)
</code></pre>
<p>When I run the program only the ProcessA runs (as I see in the log file).</p>
<p>I get the same result whether I run the code native in a Windows 7 terminal or in Spyder with 'Run&gt;Configuration ..&gt; Execute in external terminal' set</p>
<p>What can I do to get the ProcessB and the remainer of the main thread to run ? </p>
<p>UPDATE
Moving the classes from external files to internal functions works, however using external functions doesn't work. </p>
<p>That is this code works: </p>
<pre><code>import time 
from multiprocessing import  Process, Queue
import logging
logging.basicConfig(filename='MThread2.log',level=logging.DEBUG)

def ProcessA(q):
    global variableA 
    logging.info('ProcessA started') 
    while (True):
        variableA = 'A' + str(time.time()) 
        q.put(variableA)
        logging.info (variableA)
        time.sleep(5)

def ProcessB(q):
    logging.info('ProcessB started') 
    global variableB 

    while (True):
        variableB = 'B' + str(time.time()) 
        q.put (variableB)
        logging.info (variableB)
        time.sleep(2)


if __name__ == "__main__":
    queueA = Queue()
    a =Process(target=ProcessA, args=(queueA,))
    a.start()
    queueB = Queue()
    b = Process(target=ProcessB, args=(queueB,))
    b.start()

    while (True):
        if not queueA.empty():
            variableC = queueA.get()
            logging.info ("variableC ="+ variableC) 
        if not queueB.empty():
            variableC = queueB.get()
            logging.info ("variableC ="+ variableC) 


        time.sleep(1)
</code></pre>
<p>However moving the code into external functions still doesn't work either.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's hard to tell exactly what is wrong here.. I see some small errors with importing and assigning your classes... </p>
<p><em>To put you on the right path:</em> </p>
<p>ProcessA and B classes could just be functions, which have Queue as an argument, if you would like to do it that way. Otherwise, it should inherit Process (not q) and take queue in on initialization. Here's a good walkthrough (Queues and Pipes are about halfway down): <a href="https://www.geeksforgeeks.org/multiprocessing-python-set-2/" rel="nofollow noreferrer">https://www.geeksforgeeks.org/multiprocessing-python-set-2/</a></p>
<p>You might also try using a manager to share this state as well. See <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The problem was the way in which I was importing the external functions.  I didn't need the '.py' extension.  I found this out from this post: <a href="https://stackoverflow.com/questions/20309456/call-a-function-from-another-file-in-python">Call a function from another file in Python</a></p>
<p>The following code works:</p>
<pre><code>import time 
from multiprocessing import  Process, Queue
from ProcessAF import processA
from ProcessBF import processB 


import logging
logging.basicConfig(filename='MThread.log',level=logging.DEBUG)

if __name__ == "__main__":

     queueA = Queue()
     a =Process(target=processA, args=(queueA,))
     a.start()

     queueB = Queue()
     b = Process(target=processB, args=(queueB,))
     b.start()

     while (True):
        if not queueA.empty():
            variableC = queueA.get()
            logging.info ("variableC ="+ variableC) 
            if not queueB.empty():
                variableC = queueB.get()
                logging.info ("variableC ="+ variableC) 


            time.sleep(1)
</code></pre>
<p>with a function in the file called ProcessAF.py in the same directory as follows:  </p>
<pre><code>import logging
import time
logging.basicConfig(filename='ProcessA.log',level=logging.DEBUG)
from multiprocessing import Queue
q = Queue()
def processA(q):

    global variableA 
    logging.info('ProcessA started') 
    while (True):
        variableA = 'A' + str(time.time()) 
        q.put(variableA)
        logging.info (variableA)
       time.sleep(5)
</code></pre>
</div>
