<div class="post-text" itemprop="text">
<p>I have data, and each entry needs to be an instance of a class.  I'm expecting to encounter many duplicate entries in my data. I essentially want to end up with a set of all the unique entries (ie discard any duplicates).  However, instantiating the whole lot and putting them into a set after the fact is not optimal because...</p>
<ol>
<li>I have <em>many</em> entries,</li>
<li>the proportion of duplicated entries is expected to be rather high,</li>
<li>my <code>__init__()</code> method is doing quite a lot of costly computation for each unique entry, so I want to avoid redoing these computations unnecessarily.</li>
</ol>
<p>I recognize that this is basically the same question asked <a href="https://stackoverflow.com/questions/45033519/return-class-instance-instead-of-creating-a-new-one-if-already-existing">here</a> but...</p>
<ol>
<li><p>the accepted answer doesn't actually solve the problem.  If you make <code>__new__()</code> return an existing instance, it doesn't technically make a new instance, but it still calls <code>__init__()</code> which then redoes all the work you've already done, which makes overriding <code>__new__()</code> completely pointless.  (This is easily demonstrated by inserting <code>print</code> statements inside <code>__new__()</code> and <code>__init__()</code> so you can see when they run.)</p></li>
<li><p>the other answer requires calling a class method instead of calling the class itself when you want a new instance (eg: <code>x = MyClass.make_new()</code> instead of <code>x = MyClass()</code>).  This works, but it isn't ideal IMHO since it is not the normal way one would think to make a new instance.</p></li>
</ol>
<p>Can <code>__new__()</code> be overridden so that it will return an existing entity <em>without</em> running <code>__init__()</code> on it again?  If this isn't possible, is there maybe another way to go about this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you have a way of identifying duplicate instances, and a mapping of such instances, you have a few viable options:</p>
<ol>
<li><p>Use a <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>classmethod</code></a> to get your instances for you. The classmethod would serve a similar purpose to <code>__call__</code> in your metaclass (currently <code>type</code>). The main difference is that it would check if an instance with the requested key already exists before calling <code>__new__</code>:</p>
<pre><code>class QuasiSingleton:
    @classmethod
    def make_key(cls, *args, **kwargs):
        # Creates a hashable instance key from initialization parameters

    @classmethod
    def get_instance(cls, *args, **kwargs):
        key = cls.make_key(*args, **kwargs)
        if not hasattr(cls, 'instances'):
            cls.instances = {}
        if key in cls.instances:
            return cls.instances[key]
        # Only call __init__ as a last resort
        inst = cls(*args, **kwargs)
        cls.instances[key] = inst
        return inst
</code></pre>
<p>I would recommend using this base class, especially if your class is mutable in any way. You do not want modifications of one instance show up in another without making it clear that the instances are potentially the same. Doing <code>cls(*args, **kwargs)</code> implies that you are getting a different instance every time, or at least that your instances are immutable and you don't care.</p></li>
<li><p>Redefine <code>__call__</code> in your metaclass:</p>
<pre><code>class QuasiSingletonMeta(type):
    def make_key(cls, *args, **kwargs):
        ...

    def __call__(cls, *args, **kwargs):
        key = cls.make_key(*args, **kwargs)
        if not hasattr(cls, 'instances'):
            cls.instances = {}
        if key in cls.instances:
            return cls.instances[key]
        inst = super().__call__(*args, **kwargs)
        cls.instances[key] = inst
        return inst
</code></pre>
<p>Here, <code>super().__call__</code> is equivalent to calling <code>__new__</code> and <code>__init__</code> for <code>cls</code>.</p></li>
</ol>
<p>In both cases, the basic caching code is the same. The main difference is how to get a new instance from the user's perspective. Using a <code>classmethod</code> like <code>get_instance</code> intuitively informs the user that they are getting a duplicate instance. Using a normal call to the class object implies that the instance will always be new, so should only be done for immutable classes.</p>
<p>Notice that in neither case shown above is there much of a point to calling <code>__new__</code> without <code>__init__</code>.</p>
<ol start="3">
<li><p>A third, hybrid option is possible though. With this option, you would be creating a new instance, but copying over the expensive part of <code>__init__</code>'s computation from an existing instance, instead of doing it all over again. This version would not cause any problems if implemented through the metaclass, since all the instances would in fact be independent:</p>
<pre><code>class QuasiSingleton:
    @classmethod
    def make_key(cls, *args, **kwargs):
        ...

    def __new__(cls, *args, **kwargs):
        if 'cache' not in cls.__dict__:
            cls.cache = {}
        return super().__new__(cls, *args, **kwargs)

    def __init__(self, *args, **kwargs):
        key = self.make_key(*args, **kwargs)
        if key in self.cache:  # Or more accurately type(self).instances
            data = self.cache[key]
        else:
            data = # Do lengthy computation
        # Initialize self with data object
</code></pre>
<p>With this option, remember to call <code>super().__init__</code> and (<code>super().__new__</code> if you need it).</p></li>
</ol>
</div>
<span class="comment-copy">What makes you say that "it is not the normal way one would think to make a new instance."? In Python, having a classmethod as a constructor is a pretty standard practice.</span>
<span class="comment-copy"><code>MyClass.make_new()</code> is definitely the way to go. Having <code>MyClass()</code> return an existing object is non at all obvious to a developer reading the code. Avoid surprising behavior. It's a trap that C++ programmers sometimes fall into: hiding booby traps behind overloaded operators.</span>
<span class="comment-copy">It seems you want to create a singleton class: <a href="https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python" title="creating a singleton in python">stackoverflow.com/questions/6760685/…</a></span>
<span class="comment-copy">Note, generally to do what you want you could work with the metaclass <code>__call__</code> method: <a href="https://stackoverflow.com/questions/6966772/using-the-call-method-of-a-metaclass-instead-of-new" title="using the call method of a metaclass instead of new">stackoverflow.com/questions/6966772/…</a></span>
<span class="comment-copy">@MadPhysicist There are no constructors in my organization's code, nor have I been taught about them in any of the several Python MOOCs I've taken.  That's why I say that.  But I could be mistaken, since my experience is limited.</span>
<span class="comment-copy">Examples helped.  Option 2 is effectively what I was looking for.  (My class is indeed immutable).  Though I had dismissed it earlier, I now see the merits of Option 1 as well.  Thanks.</span>
<span class="comment-copy">In Option 3, why did you bother defining <code>__new__</code>?  Couldn't the cache class attribute be initialized outside of a method definition?</span>
<span class="comment-copy">@ibonyun. Putting the new dict code in <code>__new__</code> ensures that inheritance will work properly. I didn't do the check right, so that's fixed now.</span>
