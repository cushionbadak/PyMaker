<div class="post-text" itemprop="text">
<p>I've just written some code that works, but I'm not sure about the syntactic differences between the two. I'm writing code that will check to see if string inputs can be successfully casted into new variable types without ValueError.</p>
<p>I'm using decorators to make DRY code as many types needed to evaluated. </p>
<pre><code>def typeCheck(castFunc):
    def newtypeChecker(input):
        try:
            variableType = castFunc(input)
        except ValueError:
            return False
        return True
    return newtypeChecker
</code></pre>
<p>Using decorators:</p>
<pre><code>@typeCheck
def is_float(input):
    return float

@typeCheck
def is_date(input):
    return pd.to_datetime

@typeCheck
def is_int(input):
    return int
</code></pre>
<p>Not using decorators:</p>
<pre><code>is_int = typeCheck(int)
is_date = typeCheck(pd.datetime)
is_float = typeCheck(float)
</code></pre>
<p>Performance is the same:</p>
<pre><code>is_int('14x') 
is_date('2006') 
is_float('Bob')
</code></pre>
<p>Can someone explain if there are differences? Obviously decorator syntax seems cleaner.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>input</code> is never used, yet it seems that the <code>try</code>..<code>except</code> statement is written to check if casting the variable to a different type is a valid operation. Instead, declare the wrapped functions with no parameters in the signature, and then check for errors by passing the input value to the <code>newtypeChecker</code>, returned by the decorator <code>typeCheck</code> and stored as the name of the original wrapped function:</p>
<pre><code>def typeCheck(castFunc):
  def newtypeChecker(input):
    try:
        variableType = castFunc()(input)
    except ValueError:
       print(f"input value cannot be cast to type '{castFunc.__name__[3:]}'")
       return False
    return True
  return newtypeChecker

@typeCheck
def is_float():
  return float

@typeCheck
def is_date():
  import pandas as pd
  return pd.to_datetime

@typeCheck
def is_int():
  return int

print(is_date('3423'))
print(is_int('3423'))
print(is_float('3423'))
</code></pre>
<p>Output:</p>
<pre><code>input value cannot be cast to type 'date'
False
True
True
</code></pre>
</div>
<span class="comment-copy">Your examples with and without decorator syntax are <i>not</i> equivalent.</span>
<span class="comment-copy"><i>"Performance is the same"</i> Nope. Not even close. The version with a decorator always returns True. Anyway, this is not a use case for decorators. You really just need a function that takes a type and a value as parameters, and then use <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a> to create <code>is_int</code> and <code>is_float</code> etc.</span>
<span class="comment-copy">^^please clarify! exactly what i was thinking</span>
