<div class="post-text" itemprop="text">
<p>I am new to parallelization in general and concurrent.futures in particular. I want to benchmark my script and compare the differences between using threads and processes, but I found that I couldn't even get that running because when using <code>ProcessPoolExecutor</code> I cannot use my global variables. </p>
<p>The following code will output <code>Hello</code>as I expect, but when you change <code>ThreadPoolExecutor</code> for <code>ProcessPoolExecutor</code>, it will output <code>None</code>.</p>
<pre><code>from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor

greeting = None

def process():
    print(greeting)

    return None


def main():
    with ThreadPoolExecutor(max_workers=1) as executor:
        executor.submit(process)

    return None


def init():
    global greeting
    greeting = 'Hello'

    return None

if __name__ == '__main__':
    init()
    main()
</code></pre>
<p>I don't understand why this is the case. In my real program, init is used to set the global variables to CLI arguments, and there are a lot of them. Hence, passing them as arguments does not seem recommended. So how do I pass those global variables to each process/thread correctly?</p>
<p>I know that I can change things around, which will work, but I don't understand why. E.g. the following works for both Executors, but it also means that the globals initialisation has to happen for every instance. </p>
<pre><code>from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor

greeting = None

def init():
    global greeting
    greeting = 'Hello'

    return None


def main():
    with ThreadPoolExecutor(max_workers=1) as executor:
        executor.submit(process)

    return None

def process():
    init()
    print(greeting)

    return None

if __name__ == '__main__':
    main()
</code></pre>
<p>So my main question is, <strong>what is actually happening</strong>. Why does this code work with threads and not with processes? And, how do I correctly pass set globals to each process/thread without having to re-initialise them for every instance?</p>
<p>(Side note: because I have read that concurrent.futures might behave differently on Windows, I have to note that I am running Python 3.6 on Windows 10 64 bit.)</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure of the limitations of this approach, but you can pass (serializable?) objects between your main process/thread.  This would also help you get rid of the reliance on global vars:</p>
<pre><code>from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor

def process(opts):
    opts["process"] = "got here"
    print("In process():", opts)

    return None


def main(opts):
    opts["main"] = "got here"
    executor = [ProcessPoolExecutor, ThreadPoolExecutor][1]
    with executor(max_workers=1) as executor:
        executor.submit(process, opts)

    return None


def init(opts):                         # Gather CLI opts and populate dict
    opts["init"] = "got here"

    return None


if __name__ == '__main__':
    cli_opts = {"__main__": "got here"} # Initialize dict
    init(cli_opts)                      # Populate dict
    main(cli_opts)                      # Use dict
</code></pre>
<p>Works with both executor types.</p>
<p>Edit: Even though it sounds like it won't be a problem for your use case, I'll point out that with <code>ProcessPoolExecutor</code>, the <code>opts</code> dict you get inside <code>process</code> will be a frozen copy, so mutations to it will not be visible across processes nor will they be visible once you return to the <code>__main__</code> block.  <code>ThreadPoolExecutor</code>, on the other hand, will share the dict object between threads.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's image a process is a box while a thread is a worker inside a box. A worker can only access the resources in the box and cannot touch the other resources in other boxes.</p>
<p>So when you use threads, you are creating multiple workers for your current box(main process). But when you use process, you are creating another box. In this case, the global variables initialised in this box is completely different from ones in another box. That's why it doesn't work as you expect.</p>
<p>The solution given by jedwards is good enough for most situations. You can expilictly package the resources in current box(serialize variables) and deliver it to another box(transport to another process) so that the workers in that box have access to the resources.</p>
</div>
<div class="post-text" itemprop="text">
<p>A process represents activity that is run in a separate process in the OS meaning of the term while threads all run in your main process. Every process has its own unique namespace. </p>
<p>Your main process sets the value to <code>greeting</code> by calling <code>init()</code> inside your <code>__name__ == '__main__'</code>condition for its own namespace. In your new process, this does not happen (<code>__name__</code> is <code>'__mp_name__'</code> here) hence <code>greeting</code> remains None and <code>init()</code> is never actually called unless you do so explicitly in the function your process executes.</p>
<p>While sharing state between processes is generally not recommended, there are ways to do so, like outlined in @jedwards answer.</p>
<p>You might also want to check <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">Sharing State Between Processes</a> from the docs.</p>
</div>
