<div class="post-text" itemprop="text">
<p>I have a file where the content looks as follows:</p>
<pre><code>eng word1
eng word2
eng word3
ita word1
ita word2
fra word1
...
</code></pre>
<p>I want to count the number of occurrences of each word in every language. For this purpose i want to read the file in a dict. 
This is my attempt:</p>
<pre><code>data = open('file', 'r', encoding='utf8')
for line in data:
    lang = line[:3]
    ipa_string = line[3:]
    lang_and_string_dict[lang] = []
    lang_and_string_dict[lang].append(ipa_string)
print(lang_and_string_dict)
</code></pre>
<p>This gives me a dict with the right keys but only the last of the words for example for english:</p>
<pre><code>{'eng':[word1]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well each time you <strong>assign an empty list as value</strong>:</p>
<pre><code>data = open('file', 'r', encoding='utf8')
for line in data:
    lang = line[:3]
    ipa_string = line[3:]
    <b>lang_and_string_dict[lang] = []</b>
    lang_and_string_dict[lang].append(ipa_string)
print(lang_and_string_dict)</code></pre>
<p>As a result, the old list containing the previous occurrence is lost. You should only create a list if no such element exists already, like:</p>
<pre><code>data = open('file', 'r', encoding='utf8')
for line in data:
    lang = line[:3]
    ipa_string = line[3:]
    <b>if lang not in lang_and_string_dict:</b>
        lang_and_string_dict[lang] = []
    lang_and_string_dict[lang].append(ipa_string)
print(lang_and_string_dict)</code></pre>
<p>Since this pattern is rather common, you can use a <code>defaultdict</code> as well:</p>
<pre><code><b>from collection import defaultdict

<b>lang_and_string_dict = defaultdict(list)</b>
<b>with</b> open('file', 'r', encoding='utf8') as data:</b>
    for line in data:
        lang = line[:3]
        ipa_string = line[3:]
    lang_and_string_dict[lang].append(ipa_string)
print(lang_and_string_dict)</code></pre>
<p>A <code>defaultdict</code> is a subclass of <code>dict</code> that uses a factory (here <code>list</code>) in case a key is missing. So each time a key is queried that is not in the dictionary, we construct a <code>list</code>.</p>
<p>You can later convert such <code>defaultdict</code> to a <code>dict</code> with <code>dict(lang_and_string_dict)</code>.</p>
<p>Furthermore if you <code>open(..)</code> files, you better do this with a <code>with</code> block. Since if an exception for example arises, then the file is still properly closed.</p>
</div>
<div class="post-text" itemprop="text">
<p>a simple approach using dict where keys are lang and values are counters of word occurrences </p>
<pre><code>from collections import Counter, defaultdict

lang_and_string_dict = defaultdict(Counter)
with open('file', 'r', encoding='utf8') as f:
    for line in f:
        lang, word = line.split()
        lang_and_string_dict[lang].update([word])


print(lang_and_string_dict)
</code></pre>
<p>output</p>
<pre><code>defaultdict(&lt;class 'collections.Counter'&gt;, {'eng': Counter({'word1': 1, 'word2': 1, 'word3': 1}), 'ita': Counter({'word1': 1, 'word2': 1}), 'fra': Counter({'word1': 1})})
</code></pre>
<p><strong>Keep in mind</strong> the line <code>lang, word = line.split()</code> can cause an error or unexpected behaviour if the lines in the file aren't in exact <code>lang word</code> format, a exception and check is suggested </p>
</div>
<div class="post-text" itemprop="text">
<p>Another workaround would be using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>. It returns a count of numbers of words under each category:</p>
<pre><code>from collections import Counter

words = []
with open('file') as f:
    for line in f:
        words.append(line.split()[0])

print(Counter(words))
# Counter({'eng': 3, 'ita': 2, 'fra': 1})
</code></pre>
<p>To get count of each word under each category:</p>
<pre><code>from collections import Counter

words = []
with open('file.txt') as f:
    lines = f.readlines()
    prev = lines[0].split()[0]
    for line in lines:
        splitted = line.split()
        if splitted[0] != prev:
            print('{} -&gt; {}'.format(prev, Counter(words)))
            prev = splitted[0]
            words = []
        words.append(line.split()[1])

print('{} -&gt; {}'.format(prev, Counter(words)))

# eng -&gt; Counter({'word1': 1, 'word2': 1, 'word3': 1})
# ita -&gt; Counter({'word1': 1, 'word2': 1})                         
# fra -&gt; Counter({'word1': 1})                            
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Similar solution to @shahaf's, but using <code>defaultdict(int)</code> instead of <code>Counter</code>.</p>
<p>I also use <code>csv.DictReader</code> to make the logic clearer.</p>
<pre><code>from collections import defaultdict
import csv
from io import StringIO

mystr = StringIO("""eng word1
eng word2
eng word3
eng word1
ita word1
ita word2
ita word2
fra word1""")

d = defaultdict(lambda: defaultdict(int))

# replace mystr with open('file.csv', 'r')
with mystr as fin:
    reader = csv.DictReader(fin, delimiter=' ', fieldnames=['language', 'word'])
    for line in reader:
        d[line['language']][line['word']] += 1

print(d)

defaultdict({'eng': defaultdict(int, {'word1': 2, 'word2': 1, 'word3': 1}),
             'ita': defaultdict(int, {'word1': 1, 'word2': 2}),
             'fra': defaultdict(int, {'word1': 1})})
</code></pre>
</div>
<span class="comment-copy">thank you so much!</span>
<span class="comment-copy">thank you! can I use that for counting characters as well?</span>
<span class="comment-copy">yes, the <code>update</code> function receive an iterator, I pass a list containing the word <code>update([word])</code> so it will count by words, if you will pass only the word, it will threat it as an iterator and count by character like <code>update(word)</code></span>
