<div class="post-text" itemprop="text">
<p>I'm trying to read in a PDF source file, and append each individual byte to an array of 8-bit integers. This is the slowest function in my program, and I was wondering if there was a more efficient method to do so, or if my process is completely wrong and I should go about it another way. Thanks in advance!</p>
<pre><code>pagesize = 4096
arr = []
doc = ""
with open(filename, 'rb') as f:
    while doc != b'':
        doc = f.read(pagesize)
        for b in doc:
            arr.append(b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A <a href="https://docs.python.org/3/library/stdtypes.html#binaryseq" rel="nofollow noreferrer"><code>bytes</code></a> object is already a sequence of 8-bit integers:</p>
<pre><code>&gt;&gt;&gt; b = b'abc'
&gt;&gt;&gt; for byte in b: print(byte)
97
98
99
</code></pre>
<p>If you want to convert it to a different kind of sequence, like a <code>list</code>, just call the constructor:</p>
<pre><code>&gt;&gt;&gt; lst = list(b)
&gt;&gt;&gt; lst
[97, 98, 99]
&gt;&gt;&gt; arr = array.array('b', a)
&gt;&gt;&gt; arr
array('b', [97, 98, 99])
</code></pre>
<p>Or, if you need to do it a chunk at a time for some reason, just pass the whole chunk to <code>extend</code>:</p>
<pre><code>&gt;&gt;&gt; arr = list(b'abc')
&gt;&gt;&gt; arr.extend(b'def')
&gt;&gt;&gt; arr
[97, 98, 99, 100, 101, 102]
</code></pre>
<hr/>
<p>However, the most efficient thing to do is just leave it in a <code>bytes</code>:</p>
<pre><code>with open(filename, 'rb') as f:
    arr = f.read()
</code></pre>
<p>… or, if you need it to be mutable, use <code>bytearray</code>:<sup>1</sup></p>
<pre><code>pagesize=4096
arr = bytearray()
with open(filename, 'rb') as f:
    arr.extend(f.read(4096))
</code></pre>
<p>… or, if there's any chance you could benefit from speeding up elementwise operations over the whole array, use <a href="http://www.numpy.org/" rel="nofollow noreferrer">NumPy</a>:</p>
<pre><code>with open(filename, 'rb') as f:
    arr = np.fromfile(f, dtype=np.uint8)
</code></pre>
<hr/>
<p>Or, don't even <code>read</code> the file in the first place and instead <a href="https://docs.python.org/3/library/mmap.html" rel="nofollow noreferrer"><code>mmap</code></a> it, then use the <code>mmap</code> as your sequence of integers.<sup>2</sup></p>
<pre><code>with open(filename, 'rb') as f:
    arr = mmap.mmap(f, 0)
</code></pre>
<hr/>
<p>For comparison, under the covers (at least in CPython):</p>
<ul>
<li>A <code>bytes</code> (or <code>bytearray</code>, or <code>array.array('b')</code>, or <code>np.array(dtype=np.int8)</code>, etc.) is stored as an array of 8-bit integers. So, 1M bytes takes 1MB.

<ul>
<li>A <code>bytearray</code> will have a bit of extra slack at the end, increasing the size by about 6%. So, 1M bytes takes 1.06MB.</li>
</ul></li>
<li>A general-purpose sequence like a <code>tuple</code> or <code>list</code> is stored as an array of pointers to objects wrapping the 8-bit integers. The objects don't matter (there's only going to be one copy for each of the 256 values, no matter how many references there are to each), but the pointers are 8 bytes (4 bytes in 32-bit builds). So, 1M bytes takes 8MB.

<ul>
<li>A <code>list</code> has the same extra slack as <code>bytearray</code>, so it's 8.48MB.</li>
</ul></li>
<li>A <code>mmap</code> is like a <code>bytes</code> or <code>array.array('b')</code> as far as virtual memory goes, but any pages that you haven't read or written may not be mapped into physical memory at all. So, 1M bytes takes at most 1MB, but could take as little as 8KB.</li>
</ul>
<hr/>
<p><sub>1. You can speed this up. If you pre-extend the <code>bytearray</code> 4K at a time—or, even better, pre-allocate the whole thing, if you know the length of the file—you can <a href="https://docs.python.org/3/library/io.html#io.RawIOBase.readinto" rel="nofollow noreferrer"><code>readinto</code></a> a <a href="https://docs.python.org/3/library/stdtypes.html#binaryseq" rel="nofollow noreferrer"><code>memoryview</code></a> over a slice of the <code>bytearray</code>. But this is more complicated, and probably not worth it—if you need this, you should probably have been using either numpy or an <code>mmap</code>.</sub></p>
<p><sub>2. This does mean that you have to move all your <code>arr</code>-using code inside the <code>with</code>, or otherwise keep the file open as long as you need the data. Because the file itself <em>is</em> the storage for your "array"; you haven't copied the bytes into different storage in memory.</sub></p>
</div>
<span class="comment-copy">On its face, this looks like a perfect use case for memory-mapped I/O (meaning you may not even need to read the file at all until something in your code actually wants to index into it). Are you using the resulting list in a manner incompatible with that?</span>
<span class="comment-copy">Why read a pdf byte wise?</span>
<span class="comment-copy">@PatrickArtner for this particular project, I need to convert every single byte into an 8-bit int (the data, the weird &lt;A&gt;88 values, etc.)</span>
