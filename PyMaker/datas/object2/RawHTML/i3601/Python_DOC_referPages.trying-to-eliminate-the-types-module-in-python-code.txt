<div class="post-text" itemprop="text">
<p>Is saying:</p>
<pre><code>if not callable(output.write):
   raise ValueError("Output class must have a write() method")
</code></pre>
<p>The same as saying:</p>
<pre><code>if type(output.write) != types.MethodType:
   raise exceptions.ValueError("Output class must have a write() method")
</code></pre>
<p>I would rather not use the types module if I can avoid it.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, they are not the same.</p>
<p><a href="https://docs.python.org/3/library/functions.html#callable" rel="nofollow noreferrer"><code>callable(output.write)</code></a> just checks whether <code>output.write</code> is callable. Things that are callable include:</p>
<ul>
<li>Bound method objects (whose type is <code>types.MethodType</code>).</li>
<li>Plain-old functions (whose type is <code>types.FunctionType</code>)</li>
<li><code>partial</code> instances wrapping bound method objects (whose type is <code>functools.partial</code>)</li>
<li>Instances of you own custom callable class with a <code>__call__</code> method that are designed to be indistinguishable from bound method objects (whose type is your class).</li>
<li>Instances of a subclass of the bound method type (whose type is that subclass).</li>
<li>…</li>
</ul>
<p><code>type(output.write) == types.MethodType</code> accepts only the first of these. Nothing else, not even subclasses of <code>MethodType</code>, will pass. (If you want to allow subclasses, use <code>isinstance(output.write, types.MethodType)</code>.)</p>
<p>The former is almost certainly what you want. If I've monkeypatched an object to replace the <code>write</code> method with something that acts just like a <code>write</code> method when called, but isn't implemented as a bound method, why would your code want to reject my object?</p>
<hr/>
<p>As for your side question in the comments:</p>
<blockquote>
<p>I do want to know if the exceptions.ValueError is necessary</p>
</blockquote>
<p>No, it's not.</p>
<p>In Python 2.7, the builtin exceptions are also available in the <code>exceptions</code> module:</p>
<pre><code>&gt;&gt;&gt; ValueError is exceptions.ValueError
True
</code></pre>
<p>In Python 3, they were moved to <code>builtins</code> along with all the other builtins:</p>
<pre><code>&gt;&gt;&gt; ValueError is builtins.ValueError
True
</code></pre>
<p>But either way, the only reason you'd ever need to refer to its module is if you hid <code>ValueError</code> with a global of the same name in your own module.</p>
<hr/>
<p>One last thing:</p>
<p>As user2357112 points out in a comment, your solution doesn't really ensures anything useful.</p>
<p>The most common problem is almost certainly going to be <code>output.write</code> not existing at all. In which case you're going to get an <code>AttributeError</code> rather than the <code>ValueError</code> you wanted. (If this is acceptable, you don't need to check <em>anything</em>—just call the method and you'll get an <code>AttributeError</code> if it doesn't exist, and a <code>TypeError</code> if it does but isn't callable.) You could solve that by using <code>getattr(output, 'write', None)</code> instead of <code>output.write</code>, because <code>None</code> is not callable.</p>
<p>The next most common problem is probably going to be <code>output.write</code> existing, and being callable, but with the wrong signature. Which means you'll still get the same <code>TypeError</code> you were trying to avoid when you try to call it. You could solve that by, e.g., using the <code>inspect</code> module.</p>
<p>But if you really want to do all of this, you should probably be factoring it all out into an <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">ABC</a>. ABCs only have built-in support for checking that abstract methods exist as attributes; it doesn't check whether they're callable, or callable with the right signature. But it's not that hard to extend that support. (Or, maybe better, just grabbing one of the interface/protocol modules off PyPI.) And I think something like <code>isinstance(output, StringWriteable)</code> would declare your intention a lot better than a bunch of lines involving <code>getattr</code> or <code>hasattr</code>, type checking, and <code>inspect</code> grubbing.</p>
</div>
<span class="comment-copy">Yes I do realize I misspelled module and yes I do want to know if the exceptions.ValueError is necessary.</span>
<span class="comment-copy">What does "necessary" mean in that context?</span>
<span class="comment-copy">There's an edit button. If you realize you misspelled something, you can go back and fix it.</span>
<span class="comment-copy">Thanks and by "necessary" I mean is saying exceptions.ValueError the same thing as saying ValueError.</span>
<span class="comment-copy">Yes they're the same thing and you shouldn't ask two different questions at the same time.</span>
<span class="comment-copy">Thanks, any ideas about how I might make the comparison without using types.MethodType()?</span>
<span class="comment-copy">@Vysero My advice is to not do the comparison unless absolutely necessary. In fact, without seeing your code, I’d guess you don’t need to do anything at all here, and could just duck type and handle the error, but if you do need a test, <code>callable</code> is far more likely to be what you need than the exact type check.</span>
<span class="comment-copy">@Vysero If you <i>do</i> need an exact type check for some reason, you can always access the same type by calling <code>type</code> on something you know is a method. For example, define a <code>class Dummy</code> with a <code>def method</code>, then <code>type(Dummy().method)</code>. But it’s much simpler, and clearer, to use <code>types.MethodType</code>, so I can’t imagine why you’d want to avoid it.</span>
<span class="comment-copy">@Vysero In general, the way to do that in Python is to just not do that. Without your check, an <code>output</code> that doesn't  have a <code>write</code> method will raise an exception. With your check, an <code>output</code> that doesn't have a <code>write</code> method will raise an exception. Either way, the exception will show exactly what's wrong with <code>output</code> in the traceback. So, what have you gained?</span>
<span class="comment-copy">If you're going to check, you should probably also check that <code>output.write</code> actually exists, too, with <code>hasattr(output, 'write')</code>. It's much more likely that you'll receive an object with no <code>write</code> attribute than that you'll receive an object with a non-callable <code>write</code> attribute.</span>
