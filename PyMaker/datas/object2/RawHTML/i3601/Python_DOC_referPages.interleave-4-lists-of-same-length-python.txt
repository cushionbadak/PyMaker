<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/7946798/interleave-multiple-lists-of-the-same-length-in-python">Interleave multiple lists of the same length in Python</a>
<span class="question-originals-answer-count">
                    7 answers
                </span>
</li>
</ul>
</div>
<p>I want interleave 4 lists of same length in python.</p>
<p>I search this site and only see how to interleave 2 in python: 
<a href="https://stackoverflow.com/questions/7946798/interleaving-two-lists-in-python">Interleaving two lists in Python</a></p>
<p>Can give advice for 4 lists?</p>
<p>I have lists like this</p>
<pre><code>l1 = ["a","b","c","d"]
l2 = [1,2,3,4]
l3 = ["w","x","y","z"]
l4 = [5,6,7,8]
</code></pre>
<p>I want list like</p>
<pre><code>l5 = ["a",1,"w",5,"b",2,"x",6,"c",3,"y",7,"d",4,"z",8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Provided the lists are the same length, <a href="https://docs.python.org/3/library/functions.html#zip" rel="noreferrer"><strong><code>zip()</code></strong></a> can be used to interleave four lists just like it was used for interleaving two in the question you linked:</p>
<pre><code>&gt;&gt;&gt; l1 = ["a", "b", "c", "d"]
&gt;&gt;&gt; l2 = [1, 2, 3, 4]
&gt;&gt;&gt; l3 = ["w", "x", "y", "z"]
&gt;&gt;&gt; l4 = [5, 6, 7, 8]
&gt;&gt;&gt; l5 = [x for y in zip(l1, l2, l3, l4) for x in y]
&gt;&gt;&gt; l5
['a', 1, 'w', 5, 'b', 2, 'x', 6, 'c', 3, 'y', 7, 'd', 4, 'z', 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><strong><code>itertools.chain</code></strong></a> and <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><strong><code>zip</code></strong></a>:</p>
<pre><code>from itertools import chain<br/>
l1 = ["a", "b", "c", "d"]
l2 = [1, 2, 3, 4]
l3 = ["w", "x", "y", "z"]
l4 = [5, 6, 7, 8]<br/>
print(list(<b>chain(*zip</b>(l1, l2, l3, l4))))</code></pre>
<p>Or as @PatrickHaugh suggested use <a href="https://docs.python.org/2/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><strong><code>chain.from_iterable</code></strong></a>:</p>
<pre><code>list(<b>chain.from_iterable(zip</b>(l1, l2, l3, l4)))</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>From itertools recipes</h2>
<p>The <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer">itertool recipes</a> suggest a solution called <code>roundrobin</code> that allows for lists of different lengths.</p>
<pre><code>from itertools import cycle, islice

def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    num_active = len(iterables)
    nexts = cycle(iter(it).__next__ for it in iterables)
    while num_active:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            # Remove the iterator we just exhausted from the cycle.
            num_active -= 1
            nexts = cycle(islice(nexts, num_active))

print(*roundrobin(*lists)) # a 1 w 5 b 2 x 6 c 3 y 7 d 4 z 8
</code></pre>
<h2>With slicing</h2>
<p>Alternatively, here is a solution that relies solely on slicing, but requires that all lists be of equal lengths.</p>
<pre><code>l1 = ["a","b","c","d"]
l2 = [1,2,3,4]
l3 = ["w","x","y","z"]
l4 = [5,6,7,8]

lists = [l1, l2, l3, l4]

lst = [None for _ in range(sum(len(l) for l in lists))]

for i, l in enumerate(lists):
    lst[i:len(lists)*len(l):len(lists)] = l

print(lst) # ['a', 1, 'w', 5, 'b', 2, 'x', 6, 'c', 3, 'y', 7, 'd', 4, 'z', 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For additional diversity (or for if you need to do this with Pandas)</p>
<pre><code>import pandas as pd
l1 = ["a","b","c","d"]
l2 = [1,2,3,4]
l3 = ["w","x","y","z"]
l4 = [5,6,7,8]

df = pd.DataFrame([l1 ,l2, l3, l4])
result = list(df.values.flatten('A'))
</code></pre>
<blockquote>
<p>['a', 1, 'w', 5, 'b', 2, 'x', 6, 'c', 3, 'y', 7, 'd', 4, 'z', 8]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Just for the sake of diversity, <code>numpy.dstack</code> and then <code>flatten</code> can do the same trick.</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; l1 = ["a","b","c","d"]
&gt;&gt;&gt; l2 = [1,2,3,4]
&gt;&gt;&gt; l3 = ["w","x","y","z"]
&gt;&gt;&gt; l4 = [5,6,7,8]
&gt;&gt;&gt; np.dstack((np.array(l1),np.array(l2),np.array(l3),np.array(l4))).flatten()                                                                                                       
array(['a', '1', 'w', '5', 'b', '2', 'x', '6', 'c', '3', 'y', '7', 'd',                                                                                                              
       '4', 'z', '8'],                                                                                                                                                               
      dtype='|S21') 
</code></pre>
<p>BTW you actually don't need to make an array, the short version also works</p>
<pre><code>&gt;&gt;&gt; np.dstack((l1,l2,l3,l4)).flatten()                                                                                                       
array(['a', '1', 'w', '5', 'b', '2', 'x', '6', 'c', '3', 'y', '7', 'd',                                                                                                              
       '4', 'z', '8'],                                                                                                                                                               
      dtype='|S21')   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One other way may be using <code>zip</code> with <code>np.concatenate</code>:</p>
<pre><code>import numpy as np
l5 = np.concatenate(list(zip(l1, l2, l3, l4)))
print(l5)
</code></pre>
<p>Result:</p>
<pre><code>['a' '1' 'w' '5' 'b' '2' 'x' '6' 'c' '3' 'y' '7' 'd' '4' 'z' '8']
</code></pre>
<p><strong>Note</strong>: <code>l5</code> is type <code>numpy.ndarray</code>, you can convert it to <code>list</code> either with <code>list(l5)</code> or <code>l5.tolist()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>zip</code> and <code>reduce</code>:</p>
<pre><code>import functools, operator
&gt;&gt;&gt; functools.reduce(operator.add, zip(l1,l2,l3,l4))
('a', 1, 'w', 5, 'b', 2, 'x', 6, 'c', 3, 'y', 7, 'd', 4, 'z', 8)
</code></pre>
</div>
<span class="comment-copy">I'd probably use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>chain.from_iterable</code></a></span>
<span class="comment-copy">@PatrickHaugh yeah I added to my answer. Thanks for your point.</span>
<span class="comment-copy">Is there ever a reason to use <code>functools.reduce(operator.add, x)</code> instead of <code>sum(x)</code>?</span>
<span class="comment-copy">@Daerdemandt No, they're equally bad.</span>
<span class="comment-copy">Yes, because <code>sum(zip(l1,l2,l3,l4))</code> does not work: <code>TypeError: unsupported operand type(s) for +: 'int' and 'tuple'</code></span>
