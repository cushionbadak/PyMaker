<div class="post-text" itemprop="text">
<p>How do I set up logging in a Python package and the supporting unit tests so that I get a logging file out that I can look at when things go wrong?</p>
<p>Currently package logging seems to be getting captured by nose/unittest and is thrown to the console if there is a failed test; only unit test logging makes it into file.</p>
<p>In both the package and unit test source files, I'm currently getting a logger using:</p>
<pre><code>import logging
import package_under_test

log = logging.getLogger(__name__)
</code></pre>
<p>In the unit test script I have been trying to set up log handlers using the basic FileHandler, either directly in-line or via the setUp()/setUpClass() TestCase methods</p>
<p>And the logging config, currently set in the Unit test script setUp() method.</p>
<pre><code>root, ext = os.path.splitext(__file__)
log_filename = root + '.log'
log_format = (
    '%(asctime)8.8s %(filename)-12.12s %(lineno)5.5s:' 
    ' %(funcName)-32.32s %(message)s')
datefmt = "%H:%M:%S"
log_fmt = logging.Formatter(log_format, datefmt)
log_handler = logging.FileHandler(log_filename, mode='w') 
log_handler.setFormatter(log_fmt)
log.addHandler(log_handler)
log_format = '%(message)s'

log.setLevel(logging.DEBUG)

log.debug('test logging enabled: %s' % log_filename)
</code></pre>
<p>The log in the last line does end up in the file but this configuration clearly doesn't filter back into the imported package being tested.</p>
</div>
<div class="post-text" itemprop="text">
<p>Logging objects operate in a hierarchy, and log messages 'bubble up' the hierarchy chain and are passed to any handlers along the way (provided the log level of the message is at or exceeds the minimal threshold of the logger object you are logging on). Ignoring filtering and global log-level configurations, in pseudo code this is what happens:</p>
<pre><code>if record.level &lt; current_logger.level:
    return
for logger_object in (current_logger + current_logger.parents_reversed):
    for handler in logger_object.handlers:
        if record.level &gt;= handler.level:
            handler.handle(record)
    if not logger_object.propagate:
        # propagation disabled, the buck stops here.
        break
</code></pre>
<p>Where handlers are actually responsible for putting a log message into a file or write it to the console, etc.</p>
<p>The problem you have is that you added your log handlers to the <code>__name__</code> logger, where <code>__name__</code> is the current package identifier. The <code>.</code> separator in the package name are hierarchy separators, so if you run this in, say, <code>acme.tests</code> then <em>only the loggers in <code>acme.tests</code> and contained modules</em> are being sent to this handler. Any code outside of <code>acme.tests</code> will never reach these handlers.</p>
<p>Your log object hierarchy is something akin to this:</p>
<pre><code>- acme
    - frobnars
    - tests
        # logger object
        - test1
        - test2
    - widgets
</code></pre>
<p>then only log objects in <code>test1</code> and <code>test2</code> will see the same handlers.</p>
<p>You can move your logger to the root logger instead, with <code>logging.root</code> or <code>logger.getLogger()</code> (no name argument or the name set to <code>None</code>). All loggers are child nodes of the root logger, and as long as they don't set the <a href="https://docs.python.org/3/library/logging.html#logging.Logger.propagate" rel="nofollow noreferrer"><code>propagate</code> attribute</a> to <code>False</code>, log messages will reach the root handlers.</p>
<p>The other options are to get the <code>acme</code> logger object explicitly, with <code>logging.getLogger('acme')</code>, or always use a single, explicit logger name throughout your code that is the same in your tests and in your library.</p>
<p>Do take into account that Nose <a href="https://github.com/nose-devs/nose/blob/7c26ad1e6b7d308cafa328ad34736d34028c122a/nose/plugins/logcapture.py#L176-L206" rel="nofollow noreferrer">also configures handlers on the root logger</a>.</p>
</div>
<span class="comment-copy">Without a more concrete example, this is hard to answer. We don't know anything about how you have configured your logging, for example.</span>
<span class="comment-copy">Logging in both the package source and the unit test source uses:     #import logging   log = logging.getLogger(<b>name</b>)</span>
<span class="comment-copy">Right, but you didn't set up any configuration? <code>logging.basicConfig()</code> or explicit configuration set?</span>
<span class="comment-copy">Sorry - I'll add the config into the question - the formatting gets lost in a comment.</span>
<span class="comment-copy">What is <code>log</code> in that snippet?</span>
<span class="comment-copy">Perfect - thanks to everyone's help and your patience as I formulated the question correctly.</span>
<span class="comment-copy">Done - I didn't even know there WAS an accept - so thanks for pointing this out.  I should go back and take a look at my other questions when I have a few moments.</span>
<span class="comment-copy">@PaulDSmith: glad I took the leap then to ask! :-) Just remember, accepting is never mandatory, and entirely <i>your choice</i>. You can only ever mark at most one of the answers to a question as accepted.</span>
