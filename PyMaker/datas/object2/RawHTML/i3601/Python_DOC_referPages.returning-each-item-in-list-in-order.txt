<div class="post-text" itemprop="text">
<pre><code>list = ['0','1','2','3','4','5','6']

for item in list:
    return item
</code></pre>
<p>My goal:</p>
<p>1st time running this function, I would want 0<br/>
2st time running this function, I would want 1<br/>
3rd time running this function, I would want 2<br/>
.<br/>
.<br/>
.<br/>
7th time running this function, I would want 6.  </p>
<p>print (item) does this trick but is there a way to do it with return?</p>
<p>thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Try using <code>next</code>:</p>
<pre><code>&gt;&gt;&gt; l = ['0','1','2','3','4','5','6']
&gt;&gt;&gt; iter_ = iter(l)
&gt;&gt;&gt; next(iter_)
'0'
&gt;&gt;&gt; next(iter_)
'1'
&gt;&gt;&gt; next(iter_)
'2'
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you're looking for a method called pop</p>
<p>Each time that you run list.pop(0), it pops the first element in the list, so if you run it multiple times it will returning each element one by one   </p>
<pre><code>&gt;&gt;&gt; list = ['0','1','2','3','4','5','6']
&gt;&gt;&gt; list.pop(0)
'0'
&gt;&gt;&gt; list.pop(0)
'1'
&gt;&gt;&gt; list.pop(0)
'2'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a counter variable.</p>
<pre><code>counter = 0
l = ['0','1','2','3','4','5','6']

def returnVal():
  global counter
  global l
  counter = (counter + 1) % len(l)
  return l[counter]

print(returnVal())
print(returnVal())
print(returnVal())
print(returnVal())
print(returnVal())
print(returnVal())
print(returnVal())
print(returnVal())
</code></pre>
<p>Working example: <a href="https://repl.it/@LukasBach/VoluminousFrozenHexadecimal" rel="nofollow noreferrer">https://repl.it/@LukasBach/VoluminousFrozenHexadecimal</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe this would help you, you can get the next item by <code>.get_next()</code> and reset to the first item by <code>.reset()</code>. Just initialize the object with <code>Looper(items*)</code>, as you would with a list.</p>
<pre><code>class Looper(list):
    _counter = -1

    def get_next(self):
        self._counter += 1
        return self[self._counter]

    def reset_counter(self):
        self._counter = -1
</code></pre>
<p>I didn't really know what to call it so for the sake of time just chose <code>Looper</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>you are missing <code>'</code> after 2, this may work for you:  </p>
<pre><code>list = ['0', '1', '2', '3', '4', '5', '6']

def get_list_item(list, index):
    return list[index]

for index in range(0, len(list)):
    print(get_list_item(list, index))
</code></pre>
</div>
<span class="comment-copy">It sounds like you're looking for an <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">iterator</a>.  Try playing with <code>iterator = iter(my_list)</code> and then doing multiple <code>next(iterator)</code>.</span>
<span class="comment-copy">Related: <a href="https://docs.python.org/3/glossary.html#term-generator" rel="nofollow noreferrer">docs.python.org/3/glossary.html#term-generator</a></span>
<span class="comment-copy">@PatrickHaugh <code>.next()</code> removes the next item. If this is what OP wants, they may as well use <code>.pop()</code>. Otherwise, they need a counter for the function. Maybe what they are trying to do could be replaced with <code>enumerate(list)</code>?</span>
<span class="comment-copy">@spikespaz No it doesn't? Calling <code>next(iterator)</code> will destructively consume the iterator, but the list will remain unchanged.  You can always just get another iterator with <code>iter(my_list)</code>.</span>
<span class="comment-copy">What would you want for the 8th time running the function?</span>
<span class="comment-copy">This doesnt produce the same result if I return (next(iter_)) ;(</span>
<span class="comment-copy">@swpc Yes i know but why do you need <code>return</code>?</span>
<span class="comment-copy">Just want to know if there is a way to get the same effect by returning</span>
<span class="comment-copy">@swpc it should work fine, unless you are calling <code>next</code> on a new iterator in each function call. You should be calling next on the <code>same</code> iterator each time, until you reach the <code>StopIteration</code>.</span>
<span class="comment-copy">I was thinking about using the .pop but it removes the element as well. :(</span>
<span class="comment-copy">you can create a copy of the array, otherwise you'll have to use a counter as mentioned below</span>
<span class="comment-copy">This code is redundant. A list can already be iterated through using <code>enumerate(list)</code>. It can be used as <code>for i, v in enumerate(list)</code></span>
<span class="comment-copy">yes. you are right . thanks for clarification .</span>
<span class="comment-copy">Pls do not call a variable <code>list</code> -- it will overwrite the builtin function by the same name.</span>
