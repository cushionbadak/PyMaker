<div class="post-text" itemprop="text">
<pre><code>id(t+t), id(t*2)
(42838592, 42838592)

(t+t) is (t*2)
False
</code></pre>
<p>If two variable point to same object 'is' operator will return true.But first line said both have same id but 'is' operator give false value.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the first example, your objects don't overlap in time: one is created then destroyed, then another is created with the same id.</p>
<p>When you compare them with <code>is</code>, you are holding onto both objects, so they get different ids.</p>
</div>
<div class="post-text" itemprop="text">
<p>As explained by <a href="https://stackoverflow.com/a/50893268/908494">Ned Batchelder's answer</a>, and by <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">the docs for the <code>id</code> function</a>:</p>
<blockquote>
<p>Two objects with non-overlapping lifetimes may have the same <code>id()</code> value.</p>
</blockquote>
<p>And the two objects have non-overlapping lifetimes.</p>
<p>The fact that they're part of the same tuple expression doesn't change that, because it's not <code>t+t</code> and <code>t*2</code> that are part of a tuple, it's <code>id(t+t)</code> and <code>id(t*2)</code>. So, those two integer values returned by <code>id</code> have an overlapping lifetime, but the arguments passed to <code>id</code> do not.</p>
<p>One way to understand this is to look at how CPython compiles the code:</p>
<pre><code>&gt;&gt;&gt; dis.dis('id(t+t), id(t*2)')
  1           0 LOAD_NAME                0 (id)
              2 LOAD_NAME                1 (t)
              4 LOAD_NAME                1 (t)
              6 BINARY_ADD
              8 CALL_FUNCTION            1
             10 LOAD_NAME                0 (id)
             12 LOAD_NAME                1 (t)
             14 LOAD_CONST               0 (2)
             16 BINARY_MULTIPLY
             18 CALL_FUNCTION            1
             20 BUILD_TUPLE              2
             22 RETURN_VALUE
</code></pre>
<p>So, here's what happens. (I'm going to pick a value for <code>t</code>, say <code>1000</code>, just to make this a bit easier to follow.)</p>
<ul>
<li><code>id</code>, <code>1000</code>, and <code>1000</code> get pushed on the stack.</li>
<li><code>BINARY_ADD</code> creates a <code>2000</code> value at location <code>42838592</code>.</li>
<li><code>id</code> gets called on that value and returns a <code>42838592</code> value at location, say, <code>42838616</code>.</li>
<li>Since the <code>42838592</code> value is no longer on the stack and wasn't stored anywhere, <code>id</code>'s parameter was the only reference to it, so when it gets decrefed at the end of the function, it's immediately deleted.</li>
<li><code>id</code>, <code>1000</code>, and <code>2</code> get pushed on the stack.</li>
<li><code>BINARY_MULTIPLY</code> creates a new <code>2000</code> object. Since location <code>42838592</code> was just returned to the object pool, the new value reuses that location.</li>
<li><code>id</code> returns another <code>42838592</code>, this time at location, say, <code>42838640</code>.</li>
</ul>
<p>So, the two <code>int</code> values <code>4283592</code> and <code>4283592</code> have overlapping lifetimes (and the first one overlaps with the second <code>2000</code>), the two <code>2000</code>s do not overlap.</p>
<hr/>
<p>And finally, notice that if <code>t</code> is a small number, </p>
<pre><code>&gt;&gt;&gt; t = 2
&gt;&gt;&gt; (t+t) is (t*2)
True
</code></pre>
<p>… because all <code>4</code> values (except in unusual cases) are references to the same object.</p>
<p>And meanwhile, if <code>t</code> is a constant rather than a variable, <code>1000+1000 is 1000*2</code> may or may not be true, depending on your CPython version, because of the way constant folding within a compilation unit works.</p>
<p>All of which goes to show that trying to actually take advantage of whether two equal <code>int</code>s are or are not the same object is pretty much always a terrible idea. The only reason you should ever care about this question is if you're trying to learn more about the internals of CPython.</p>
<hr/>
<p>And of course this is all CPython-specific. Most other Python interpreters use some form of garbage collector instead of refcounting, so the first <code>2000</code> is unlikely to be destroyed before the second one is created. Plus, not all of them use an object pool like CPython. Not to mention that they're allowed to do completely different things for <code>id</code> as long as they can guarantee unique values for non-overlapping objects.</p>
<p>PyPy will actually usually return the same value here—but only because it folds <code>t+t</code> and <code>t*2</code> into the same object in the first place; try it with <code>t+t</code> and t*3<code>and you'll get completely different</code>id`s.</p>
</div>
<span class="comment-copy">Try storing the values: <code>t2a, t2b = t+t, t*2</code>. Then they won't have the same <code>id</code> (except when they're the same object because of the small-int optimization or compiler constant folding, of course…)</span>
<span class="comment-copy">Anyway, this is documented by the <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer"><code>id</code></a> function.</span>
<span class="comment-copy">The objects you're comparing the IDs of aren't the same as the objects you're comparing with <code>is</code> (and they're not the same as each other, either).</span>
<span class="comment-copy">@abarnert: it's not "explained". <i>"id is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value."</i> tells us nothing much unless we both understand what sort of Python object <code>t+t</code> or <code>obj.meth</code> or <code>s[0:3]</code> are, <i>and</i> know the lifetimes of each of those objects. The <code>id()</code> documentation says nothing at all about either of those.</span>
<span class="comment-copy">doesn't the comma creates a tuple with both the objects inside?</span>
<span class="comment-copy">@CIsForCookies No, the comma creates a tuple with both the ints returned by <code>id</code> inside, but not with the ints passed as arguments to <code>id</code>—those have already gone out of scope and been destroyed. See <a href="https://stackoverflow.com/a/50895475/908494">my answer</a> for details.</span>
