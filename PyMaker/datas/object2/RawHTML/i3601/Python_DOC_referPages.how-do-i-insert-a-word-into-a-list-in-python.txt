<div class="post-text" itemprop="text">
<p>I have a list.</p>
<p>I need to add a word into the list but im not sure how to do so.</p>
<p>For example, </p>
<p>I have a list = <code>['Alice', 'Amy', 'Andy', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony']</code> </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a specialist library such as <a href="http://www.grantjenks.com/docs/sortedcontainers/index.html" rel="nofollow noreferrer"><code>sortedcontainers</code></a>, which is more efficient than a naive <code>list.sort</code> after each insertion. Complexity of <a href="http://www.grantjenks.com/docs/sortedcontainers/sortedlist.html#sortedcontainers.SortedList.add" rel="nofollow noreferrer"><code>SortedList.add</code></a> is ~O(log <em>n</em>).</p>
<pre><code>from sortedcontainers import SortedList

lst = SortedList(['Alice', 'Amy', 'Andy', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony'])

lst.add('Beatrice')

print(lst)

SortedList(['Alice', 'Amy', 'Andy', 'Beatrice', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're certain you have a sorted list, you could implement a naive insertion sort</p>
<pre><code>def insertion_sort(lst, newval, key=None):
    """insertion_sort(lst, newval) modifies the pre-sorted lst by inserting
    newval in its sorted order
    """

    if key is None:
        key = type(lst[0]).__lt__

    for i, val = enumerate(lst):
        if key(val, newval):
            continue
        else:
            # newval is less than val, so we insert here
            lst.insert(i, newval)
</code></pre>
<p>Or you can, less-naively, use the stdlib <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code></a> module to insert for you.</p>
<pre><code>import bisect

l = ['Alice', 'Amy', 'Andy', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony']
bisect.insort(l, "Andrew")  # or insort_left
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>&gt;&gt;&gt; l = ['Alice', 'Amy', 'Andy', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony']
&gt;&gt;&gt; l.append('Beatrice')
&gt;&gt;&gt; l.sort()
&gt;&gt;&gt; l
['Alice', 'Amy', 'Andy', 'Beatrice', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony']
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, to "check matching letters" between two strings, all you really need is <code>&lt;</code>. Strings compare lexicographically: <code>'abc' &lt; 'abd' &lt; 'acd' &lt; 'acdd'</code>.</p>
<hr/>
<p>With a linked list, you have to search nodes from the head to find the location. Keep track of a prev and next node as you go, and as soon as you find a <code>next.head &gt; value</code>, insert the new node after <code>prev</code>. (If you're using a bare-node implementation, make sure your function returns the headâ€”otherwise, there's no way to insert before the head.)</p>
<p>Of course this automatically means linear time to find the right position (and, if you're using immutable nodes, also linear time to build the new nodes back up to the head).</p>
<p>Given your implementation, that could look like these methods on <code>SingleLinkedList</code>:</p>
<pre><code>def find_pos(self, element):
    '''Returns the position before element, or None if no such position'''
    prev, node = None, self._head
    while node:
        if node.element &gt; element:
            return prev
        prev, node = node, node.next
    return prev

def insert(self, element):
    pos = self.find_pos(element)
    if pos:
        # add it after the node we found
        node = Node(element, pos.next)
        pos.next = node
    else:
        # add it before the current head
        node = Node(element, self._head)
        self._head = node
    self._size += 1
</code></pre>
<hr/>
<p>With a random-access data structure like an array (a Python <code>list</code>), you can <a href="https://docs.python.org/3/library/bisect.html#searching-sorted-lists" rel="nofollow noreferrer"><code>bisect</code></a> to find the right location in log time. But with an array, you still need linear time to do the insert, because all of the subsequent values have to be shifted up. (Although this is usually linear with a much faster constant than the linked-list search.)</p>
<pre><code>bisect.insort(lst, value)
</code></pre>
<p>One last thing: If you're doing a ton of inserts in a row, it's often more efficient to batch them up. In fact, just calling <code>extend</code> and then <code>sort</code> may actually be faster than <code>insort</code>ing each one, if the number of elements being added is a sizable fraction of the list.</p>
<hr/>
<p>If you want to get the best of both worlds, you need a more complex data structure:</p>
<ul>
<li>A balanced binary search tree of some kind (red-black, AVL, etc.) is the traditional answer, although it tends to be pretty slow in practice.</li>
<li>A wider search tree, like any of the B-tree variants, avoids most of the performance costs of binary trees (and lets you search with a higher log base, to boot).</li>
<li>A skiplist is a linked list with log N "higher-level" linked lists threaded through it (or stacked above it), so you can bisect it. And there are other variations on this "indexed list" concept.</li>
<li>There are multiple Python implementations of complicated hybrids, like a deque/rope structure with an optional B-tree-variant stacked on top.</li>
</ul>
<p>Popular implementations include <a href="https://pypi.org/project/blist/" rel="nofollow noreferrer"><code>blist.sortedlist</code></a>, <a href="https://pypi.org/project/sortedcontainers/" rel="nofollow noreferrer"><code>sortedcontainers.SortedList</code></a>, <a href="https://pypi.org/project/pybst/" rel="nofollow noreferrer"><code>pybst.AVLTree</code></a>, etc.</p>
<p>But really, almost any implementation of any such structure you find in Python is going to have this behavior built in. So the right answer will probably just be something like this:</p>
<pre><code>lst.add(val)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>The
  <a href="https://docs.python.org/3/library/bisect.html#module-bisect" rel="nofollow noreferrer">bisect</a>
  module provides support for maintaining a list in sorted order without
  having to sort the list after each insertion.</p>
</blockquote>
<p>The <a href="https://docs.python.org/3/library/bisect.html#bisect.insort_left" rel="nofollow noreferrer">bisect.insort_left()</a> method will "insert the item in the list in sorted order":</p>
<pre><code>import bisect

a = ['Alice', 'Amy', 'Andy', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony']
x = 'Beatrice'

bisect.insort_left(a, x)

print(a)

['Alice', 'Amy', 'Andy', 'Beatrice', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In raw python, you could do:</p>
<pre><code>def ins_sorted(toIns, list): # insert a value, with respect to a sorted list
    for i in range(0, len(list)):
        if(toIns &lt; list[i]):
            list.insert(i, toIns) # insert the value to the left of the one it DOESNT match
            break # efficiency!
    return list
</code></pre>
<p>Why does this work?
Strings can be compared just like numbers in python! <code>A &lt; B</code>, <code>C &gt; B</code>, etc.</p>
<p>To be fair: It's not the most efficient option, and bisect.insort is better, but if you want your own code you can control, there you are.</p>
<p>Timing code:</p>
<pre><code>import timeit

setupStr='''def ins_sorted(toIns, list): # insert a value, with respect to a sorted list
    for i in range(0, len(list)):
        if(toIns &lt; list[i]):
            list.insert(i, toIns) # insert the value to the left of the one it DOESNT match
            break # efficiency!
    return list'''

a = timeit.timeit('ins_sorted("c", ["a", "b", "d", "e"])', number=100000, setup=setupStr)
print(a)

b = timeit.timeit('bisect.insort(["a", "b", "d", "e"], "c")', number=100000, setup='import bisect')
print(b)
</code></pre>
<p>Timing results:</p>
<pre><code>0.25098993408028036
0.05763813108205795
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a binary tree, insertion can be performed in <code>O(height_of_tree)</code>:</p>
<pre><code>class Tree:
  def __init__(self, value = None):
    self.right, self.left, self.value = None, None, value
  def __lt__(self, _node):
    return self.value &lt; getattr(_node, 'value', _node)
  def insert_val(self, _val):
    if self.value is None:
      self.value = _val
    else:
      if _val &lt; self.value:
         if self.left is None:
           self.left = Tree(_val)
         else:
           self.left.insert_val(_val)
      else:
          if self.right is None:
            self.right = Tree(_val)
          else:
            self.right.insert_val(_val)
  def flatten(self):
     return [*getattr(self.left, 'flatten', lambda :[])(), self.value, *getattr(self.right, 'flatten', lambda :[])()]

t = Tree()
l = ['Alice', 'Amy', 'Andy', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony']
for i in l:
  t.insert_val(l)

t.insert_val('Beatrice')
print(t.flatten())
</code></pre>
<p>Output:</p>
<pre><code>['Alice', 'Amy', 'Andy', 'Beatrice', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony']
</code></pre>
<hr/>
<p>With a linked-list, you can perform the <code>add</code> and <code>insert</code> operations in a single method, applying additional logic:</p>
<pre><code>class LinkedList:
  def __init__(self, value=None):
    self.value = value
    self._next = None
  def __lt__(self, _node):
    return True if self._next is None else _node[0] &gt; self._next.value[0]
  def insert_val(self, _val):
    if self.value is None:
      self.value = _val
    else:
      if self._next is None or self._next &lt; _val:
         getattr(self._next, 'insert_val', lambda x:setattr(self, '_next', LinkedList(x)))(_val)
      else:
          _temp_next = self._next._next
          self._next._next = LinkedList(_val)
          self._next._next._next = _temp_next
  def flatten(self):
     return [self.value, *getattr(self._next, 'flatten', lambda :[])()]
  @classmethod
  def load_list(cls):
    _l = cls()
    for i in ['Alice', 'Amy', 'Andy', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony']:
       _l.insert_val(i)
    return _l

l = LinkedList.load_list()
print(l.flatten())
&gt;&gt;&gt;['Alice', 'Amy', 'Andy', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony']
l.insert_val('Beatrice')
print(l.flatten())
&gt;&gt;&gt;['Alice', 'Amy', 'Andy', 'Beatrice', 'Betty', 'Eric', 'Peter', 'Richard', 'Tony']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try using the bisect library:</p>
<pre><code>&gt;&gt;&gt; import bisect
&gt;&gt;&gt; someList = ["a", "b", "d"]
&gt;&gt;&gt; bisect.insort(someList,'c')
&gt;&gt;&gt; someList
['a', 'b', 'c', 'd']
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">You should consider a different data structure...</span>
<span class="comment-copy"><a href="https://docs.python.org/3.0/library/heapq.html" rel="nofollow noreferrer">docs.python.org/3.0/library/heapq.html</a></span>
<span class="comment-copy">Why not just use a different data structure?</span>
<span class="comment-copy">Is this vastly different than <code>bisect.insort</code>?</span>
<span class="comment-copy">@AdamSmith, Seems similar; it uses <code>bisect</code> module internally. You can see <a href="https://github.com/grantjenks/python-sortedcontainers/blob/master/sortedcontainers/sortedlist.py#L1759" rel="nofollow noreferrer">the source</a> for <code>SortedList.add</code>. The main benefit is you never have to check beforehand your list is sorted.</span>
<span class="comment-copy">On large sorted list <code>bisect.insort</code> seems to perform very well compared to <code>.sort</code> after <code>append</code>. +1</span>
<span class="comment-copy">While this works it is very inefficient approach, sorting after each insertion?</span>
<span class="comment-copy">@Idos Well, if you have a ton of inserts to do at once, appending them all and then sorting can be very efficientâ€¦ but otherwise, yeah.</span>
<span class="comment-copy">I like the first part of your solution. Right now Im looping through my singlelinkedlist , setting the head to the next value every time. My question is I can compare each value in the list with my value im inserting, but how do I determine when to stop?   I dont know how to compare the lexicographically values of the current compare with previous ones?   @abarnert</span>
<span class="comment-copy">@SleepinYeti If you want us to show you how to add an <code>insert</code> function to your particular linked list implementation, you have to show us your particular linked list implementation (either edited into this question, or by creating a new question). And, ideally, you should show us the parts of that <code>insert</code> that you know how to write, just pointing at the part you left out because you're stumped.</span>
<span class="comment-copy">@abernert  I have edited my post for what code I have. I am able to insert at the start of the SLL, but dont know how to insert at a point. What I would like to do is search the list for a specific item (which I already have down) and then insert a new node right before that item. Thats the part im having trouble with. Thanks!</span>
<span class="comment-copy">this is <code>bisect.insort_left</code></span>
<span class="comment-copy">thanks, that was mentioned in the docs, indeed i missed it</span>
<span class="comment-copy">@SleepinYeti Please see my answer, as I provide a solution for insertion with a linked list.</span>
