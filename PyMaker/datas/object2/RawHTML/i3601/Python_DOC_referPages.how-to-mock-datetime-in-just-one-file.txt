<div class="post-text" itemprop="text">
<p>I have two files in which I use <code>datetime</code>. Is there a way to mock it in just one file and not the other? Following is an example of where I'm seeing a weird behavior.</p>
<p><strong>File: test_file_one.py</strong></p>
<pre><code>import datetime as dt
def print_datetime():
    print 'First: {}'.format(dt.datetime.utcnow())
</code></pre>
<p><strong>File: test_file_two.py</strong></p>
<pre><code>import datetime as dt
def print_datetime():
    print 'Second: {}'.format(dt.datetime.utcnow())
</code></pre>
<p><strong>File: main.py</strong></p>
<pre><code>import test_file_one as first
import test_file_two as second
import mock
from datetime import datetime, timedelta

@mock.patch('test_file_one.dt.datetime')
def main(mock_datetime):
    mock_datetime.utcnow.return_value = datetime.utcnow() + timedelta(days=1)
    first.print_datetime()
    second.print_datetime()

if __name__ == '__main__':
    main()
</code></pre>
<p><strong>Output</strong></p>
<pre><code>First: 2018-06-12 08:12:43.838243
Second: 2018-06-12 08:12:43.838243
</code></pre>
<p>As you see, both return the same datetime which was mocked. </p>
<ol>
<li>Why are both mocked? </li>
<li>How to limit the mock to just one file?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You can just add as many results you calls you want to do to <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow noreferrer"><code>side_effect</code></a></p>
<pre><code>mock_datetime.utcnow.side_effect = [datetime.utcnow() + timedelta(days=1), datetime.utcnow() + timedelta(days=2)] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd suggest you to reduce the scope of your mocking.</p>
<p>Now you are applying your mock to the whole method by using the decorator <code>@mock.patch('test_file_one.dt.datetime')</code></p>
<p>Instead you could try something like:</p>
<pre><code>def main(mock_datetime):
    with mock.patch('test_file_one.dt.datetime') as mock_datetime:
        mock_datetime.utcnow.return_value = datetime.utcnow() + timedelta(days=1)
        first.print_datetime()

    second.print_datetime()
</code></pre>
<p>As an alternative, you could use <code>fake_time</code> method from <code>libfaketime-tz-wrapper</code> library.</p>
<p>Then your approach would be something like:</p>
<pre><code>from libfaketime_tz_wrapper import fake_time

def main(mock_datetime):
    with fake_time(datetime.utcnow() + timedelta(days=1)):
        first.print_datetime()

    second.print_datetime()
</code></pre>
<p>I didn't test if my suggestions work, but I've been using <code>fake_time</code> a lot in the last 1,5 year and seems to be very handful on issues like this.</p>
</div>
<span class="comment-copy">Thank you! I never knew you could do this.</span>
<span class="comment-copy">Thanks for the answer. <code>fake_time</code> looks interesting. Reducing the scope is not always possible in real-case scenarios. For example, if the method in the first file calls the method in the second file (and I still want to mock the datetime just in the first file), reducing scope does not work (with <code>mock</code> or with <code>fake_time</code>). How do you go about in such a scenario?  The problem, I feel, is how the <code>mock</code> library works. When I am mocking for one file, it should not mock in another file (I guess). I'd like <code>mock</code> to be more explicit, that is, mock only in files I explicitly mention.</span>
<span class="comment-copy">I see, @Siddharth. Indeed sometimes we can't reduce scope, but wouldn't this be a bit of code smell?  The mocking library works in a way that everything under that context will be wrapped into the parameters and values defined in the mocking. So, if you mock something for a file, scope remains mocked until it ends or another mocking comes into place. Maybe rewrite the methods for a better separation of concerns?</span>
<span class="comment-copy">I wouldn't necessarily tell it's code smell in all the cases. Specially when using external libraries. Let's say you have a function that gets the <code>utcnow</code> and then constructs an object (from an external library, say <code>Schematics</code>). The underlying library could very well do something like <code>isinstance(d, datetime)</code> for type-checking. Now mocking <code>datetime</code> in my method would affect the underlying library functionality as well.</span>
<span class="comment-copy">@Siddharth what about use <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow noreferrer"><code>side-effect</code></a> feature?</span>
