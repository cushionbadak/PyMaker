<div class="post-text" itemprop="text">
<p>I seem to be having a difficult time understanding pythons asyncio. I have not written any code, as all the examples I see are for one-off runs. Create a few coroutine's, add them to an event loop, then run the loop, they run the tasks switching between them, done. Which does not seem all that helpful for me.</p>
<p>I want to use asyncio to not interrupt the operation in my application (using pyqt5). I want to create some functions that when called run in the asyncio event loop, then when they are done they do a callback.</p>
<p>What I imagine is. Create a separate thread for asyncio, create the loop and run it forever. Create some functions <code>getFile(url, fp)</code>, <code>get(url)</code>, <code>readFile(file)</code>, etc. Then in the UI, I have a text box with a submit button, user enters url, clicks submit, it downloads the file.</p>
<p>But, every example I see, I cannot see how to add a coroutine to a running loop. And I do not see how I could do what I want without adding to a running loop. </p>
<pre><code>#!/bin/python3
import asyncio
import aiohttp
import threading

loop = asyncio.get_event_loop()

def async_in_thread(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

async def _get(url, callback):
    print("get: " + url)
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            result = await response.text()
            callback(result)
            return

def get(url, callback):
    asyncio.ensure_future(_get(url, callback))

thread = threading.Thread(target=async_in_thread, args=(loop, ))

thread.start()

def stop():
    loop.close()

def callme(data):
    print(data)
    stop()

get("http://google.com", callme)

thread.join()
</code></pre>
<p>This is what I imagine, but it does not work.</p>
</div>
<div class="post-text" itemprop="text">
<p>To add a coroutine to a loop running in a different thread, use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe%60" rel="nofollow noreferrer"><code>asyncio.run_coroutine_threadsafe</code></a>:</p>
<pre><code>def get(url, callback):
    asyncio.run_coroutine_threadsafe(_get(url, callback))
</code></pre>
<p>In general, when you are interacting with the event loop from outside the thread that runs it, you must run everything through either <code>run_coroutine_threadsafe</code> (for coroutines) or <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.call_soon_threadsafe" rel="nofollow noreferrer"><code>loop.call_soon_threadsafe</code></a> (for functions). For example, to stop the loop, use <code>loop.call_soon_threadsafe(loop.stop)</code>. Also note that <code>loop.close()</code> must not be invoked inside a loop callback, so you should place that call in <code>async_in_thread</code>, right after the call to <code>run_forever()</code>, at which point the loop has definitely stopped running.</p>
<p>Another thing with asyncio is that passing explicit <code>when_done</code> callbacks isn't idiomatic because asyncio exposes the concept of futures (akin to JavaScript promises), which allow attaching callbacks to a not-yet-available result. For example, one could write <code>_get</code> like this:</p>
<pre><code>async def _get(url):
    print("get: " + url)
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()
</code></pre>
<p>It doesn't need a <code>callback</code> argument because any interested party can convert it to a task using <code>loop.create_task</code> and use <code>add_done_callback</code> to be notified when the task is complete. For example:</p>
<pre><code>def _get_with_callback(url, callback):
    loop = asyncio.get_event_loop()
    task = loop.create_task(_get(url))
    task.add_done_callback(lambda _fut: callback(task.result()))
</code></pre>
<p>In your case you're not dealing with the task directly because your code aims to communicate with the event loop from another thread. However, <code>run_coroutine_threadsafe</code> returns a very useful value - a full-fledged <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future" rel="nofollow noreferrer"><code>concurrent.futures.Future</code></a> which you can use to register done callbacks. Instead of accepting a <code>callback</code> argument, you can expose the future object to the caller:</p>
<pre><code>def get(url):
    return asyncio.run_coroutine_threadsafe(_get(url), loop)
</code></pre>
<p>Now the caller can choose a callback-based approach:</p>
<pre><code>future = get(url)
# call me when done
future.add_done_callback(some_callback)
# ... proceed with other work ...
</code></pre>
<p>or, when appropriate, they can even wait for the result:</p>
<pre><code># give me the response, I'll wait for it
result = get(url).result()
</code></pre>
<p>The latter is by definition blocking, but since the event loop is safely running in a different thread, it is not affected by the blocking call.</p>
</div>
<div class="post-text" itemprop="text">
<p>Install <a href="https://github.com/harvimt/quamash" rel="nofollow noreferrer">QualMash</a> to smooth integration between Qt and asyncio.</p>
<p>Example from the project's README gives an inspiration for how it looks like:</p>
<pre><code>import sys
import asyncio
import time

from PyQt5.QtWidgets import QApplication, QProgressBar
from quamash import QEventLoop, QThreadExecutor

app = QApplication(sys.argv)
loop = QEventLoop(app)
asyncio.set_event_loop(loop)  # NEW must set the event loop

progress = QProgressBar()
progress.setRange(0, 99)
progress.show()

async def master():
    await first_50()
    with QThreadExecutor(1) as exec:
        await loop.run_in_executor(exec, last_50)

async def first_50():
    for i in range(50):
        progress.setValue(i)
        await asyncio.sleep(.1)

def last_50():
    for i in range(50,100):
        loop.call_soon_threadsafe(progress.setValue, i)
        time.sleep(.1)

with loop: ## context manager calls .close() when loop completes, and releases all resources
    loop.run_until_complete(master())
</code></pre>
</div>
<span class="comment-copy"><code>asyncio.ensure_future()</code> will do that.</span>
<span class="comment-copy">@MartijnPieters The OP wants to add coroutines <i>from a different thread</i>, which <code>ensure_future</code> is not designed to do.</span>
<span class="comment-copy">@user4815162342: fair enough. I was focusing on the 'how do I give the asyncio event loop a new task' part.</span>
<span class="comment-copy">This is exactly what I was trying to do. I just have a followup, how do I properly close this now? I got rid of callbacks, I am using the <code>Future</code> object, get returns the <code>run_coroutine_threadsafe</code> now, <code>data = get(...)</code>  then I do <code>data.result()</code> (all this works perfectly). But, when I do <code>loop.call_soon_threadsafe(loop.close)</code> just below <code>data.result()</code> I get an error "Cannot close a running event loop". I tried wrapping a <code>loop.stop()</code> coroutine like <code>get</code> above, but that did not work either.</span>
<span class="comment-copy">@Drew Since <code>loop.stop()</code> is not a coroutine, you should use <code>loop.call_soon_threadsafe(loop.stop)</code>. As for <code>loop.close()</code>, best call it from <code>async_in_thread</code>, right after the call to <code>loop.run_forever()</code>. (<code>run_forever()</code> having completed is proof that <code>loop.stop()</code> has been processed and that the loop is no longer running.)</span>
<span class="comment-copy">Ok, that makes sense since <code>run_forever()</code> is blocking, adding <code>close()</code> does nothing, then in my exit call before shutting down application I run <code>loop.call_soon_threadsafe(loop.stop)</code> then it shuts down nicely, that worked perfectly. Thank you.</span>
<span class="comment-copy">@Drew In case of a GUI program, an equally valid option is to start the event loop thread at the beginning (with <code>daemon</code> set to true), and never bothering with stop/close. Closing the event loop is important for temporary event loops created by a library (or a test runner, and so on), where it serves to release the resources held by the loop itself. In a more typical asyncio scenario, there is only one event loop and it runs for as long as the program, and whether <code>close()</code> is called when the program is exiting anyway is of little importance.</span>
