<div class="post-text" itemprop="text">
<p>I am trying to get subnet for IP address I have.</p>
<p>Eg :</p>
<p><strong>1</strong></p>
<p>Subnet mask : <code>255.255.255.0</code></p>
<p>Input : <code>192.178.2.55</code></p>
<p>Output : <code>192.178.2.0</code></p>
<p><strong>2</strong></p>
<p>Subnet mask : <code>255.255.0.0</code></p>
<p>Input : <code>192.178.2.55</code></p>
<p>Output : <code>192.178.0.0</code></p>
<p>Currently, the way I do it (for subnet 255.255.255.0)</p>
<pre><code>ip =  '192.178.2.55'
subnet = '.'.join(ip.split('.')[:2]) + '.0.0'
subnet
'192.178.0.0'
</code></pre>
<p>I see python has <strong>ipaddress</strong> library. However I could not find a method that could do the above task.</p>
<p>Bonus : Since <strong>ipaddress</strong> supports IPv4 and IPv6, if the same function could be used for both.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/ipaddress.html#ipaddress.ip_network" rel="noreferrer"><code>ipaddress.ip_network</code></a> function can take any of the string formats that <code>IPv4Network</code> and <code>IPv6Network</code> can take, including the <code>address/mask</code> format.</p>
<p>Since you're not actually passing the network address, but an address within that network with host bits set, you need to use <code>strict=False</code>.</p>
<p>So:</p>
<pre><code>&gt;&gt;&gt; net = ipaddress.ip_network('192.178.2.55/255.255.255.0', strict=False)
&gt;&gt;&gt; net
IPv4Network('192.178.2.0/24')
&gt;&gt;&gt; net.network_address
IPv4Address('192.178.2.0')
&gt;&gt;&gt; net.netmask
IPv4Address('255.255.255.0')
</code></pre>
<hr/>
<p>Alternatively, you can use <a href="https://docs.python.org/3/library/ipaddress.html#ipaddress.ip_interface" rel="noreferrer"><code>ip_interface</code></a> and extract the network from there:</p>
<pre><code>&gt;&gt;&gt; iface = ipaddress.ip_interface('192.178.2.55/255.255.255.0')
&gt;&gt;&gt; iface
IPv4Interface('192.178.2.55/24')
&gt;&gt;&gt; iface.network
IPv4Network('192.178.2.0/24')
&gt;&gt;&gt; iface.netmask
IPv4Address('255.255.255.0')
&gt;&gt;&gt; iface.ip
IPv4Address('192.178.2.55')
&gt;&gt;&gt; iface.network.network_address
IPv4Address('192.178.2.0')
</code></pre>
<hr/>
<p>Which of the two you want depends on what exactly you're trying to represent. Notice that the Interface types are subclasses of the Address types, and of course they remember the original address that was used to construct them, while the Network classes remember the network address; one of those two is usually the deciding factor.</p>
<p>Both of them will, of course, work just as well with IPv6:</p>
<pre><code>&gt;&gt;&gt; ipaddress.ip_interface('2001:db8::1000/32')
IPv6Interface('2001:db8::1000/32')
&gt;&gt;&gt; ipaddress.ip_interface('2001:db8::1000/32').network.network_address
IPv6Address('2001:db8::')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>subnet</code> is simply a binary mask that must be <code>and</code>'ed bitwise with the IP address. You can apply the mask yourself:</p>
<pre><code>".".join(map(str, [i &amp; m # Apply the mask
          for i,m in zip(map(int, ip.split(".")),
                         map(int, subnet.split(".")))]))
#'192.178.2.0'
</code></pre>
<p>This solution works only for IPv4 addresses.</p>
</div>
<span class="comment-copy">Works perfectly for my use case. Thanks.</span>
