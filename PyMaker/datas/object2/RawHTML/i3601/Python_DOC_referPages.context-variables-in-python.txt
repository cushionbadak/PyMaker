<div class="post-text" itemprop="text">
<p>Suppose that I have a function in my Python application that define some kind of context - a <code>user_id</code> for example. This function call other functions that do not take this context as a function argument. For example:</p>
<pre><code>def f1(user, operation):
    user_id = user.id
    # somehow define user_id as a global/context variable for any function call inside this scope
    f2(operation)

def f2(operation):
    # do something, not important, and then call another function
    f3(operation)

def f3(operation):
    # get user_id if there is a variable user_id in the context, get `None` otherwise
    user_id = getcontext("user_id")
    # do something with user_id and operation
</code></pre>
<p>My questions are:</p>
<ul>
<li>Can the <a href="https://www.python.org/dev/peps/pep-0567/" rel="nofollow noreferrer">Context Variables</a> of Python 3.7 be used for this? How?</li>
<li>Is this what these Context Variables are intended for? </li>
<li>How to do this with Python v3.6 or earlier?</li>
</ul>
<p><strong>EDIT</strong></p>
<p>For multiple reasons <em>(architectural legacy, libraries, etc)</em> I can't/won't change the signature of intermediary functions like <code>f2</code>, so I can't just pass <code>user_id</code> as arguments, neither place all those functions inside the same class.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>contextvars</code> in Python 3.7 for what you're asking about. It's usually really easy:</p>
<pre><code>import contextvars

user_id = contextvars.ContextVar("user_id")

def f1(user, operation):
    user_id.set(user.id)
    f2()

def f2():
    f3()

def f3():
    print(user_id.get(default=None))  # gets the user_id value, or None if no value is set
</code></pre>
<p>The <code>set</code> method on the <code>ContextVar</code> returns a <code>Token</code> instance, which you can use to reset the variable to the value it had before the <code>set</code> operation took place. So if you wanted <code>f1</code> to restore things the way they were (not really useful for a <code>user_id</code> context variable, but more relevant for something like setting the precision in the <code>decimal</code> module), you can do:</p>
<pre><code>token = some_context_var.set(value)
try:
    do_stuff()    # can use value from some_context_var with some_context_var.get()
finally:
    some_context_var.reset(token)
</code></pre>
<p>There's more to the <code>contextvars</code> module than this, but you almost certainly don't need to deal with the other stuff. You probably only need to be creating your own contexts and running code in other contexts if you're writing your own asynchronous framework from scratch.</p>
<p>If you're just <em>using</em> an existing framework (or writing a library that you want to play nice with asynchronous code), you don't need to deal with that stuff. Just create a global <code>ContextVar</code> (or look up one already defined by your framework) and <code>get</code> and <code>set</code> values on it as shown above, and you should be good to go.</p>
<p>A lot of <code>contextvars</code> use is probably going to be in the background, as an implementation detail of various libraries that want to have a "global" state that doesn't leak changes between threads or between separate asynchronous tasks within a single thread. The example above might make more sense in this kind of situation: <code>f1</code> and <code>f3</code> are part of the same library, and <code>f2</code> is a user-supplied callback passed into the library somewhere else.</p>
</div>
<div class="post-text" itemprop="text">
<p>Essentially what you're looking for is a way to share a state between a set of function. The canonical way to do so in an object oriented language is to use a class:</p>
<pre><code>class Foo(object):
    def __init__(self, operation, user=None):
        self._operation = operation
        self._user_id = user.id if user else None

    def f1(self):
        print("in f1 : {}".format(self._user_id))
        self.f2()

    def f2(self):
        print("in f2 : {}".format(self._user_id))
        self.f3()

    def f3(self):
        print("in f3 : {}".format(self._user_id))


 f = Foo(operation, user)
 f.f1()
</code></pre>
<p>With this solution, your class instances (here <code>f</code>) are "the context" in which the functions are executed - each instance having it's own dedicated context.</p>
<p>The functional programing equivalent would be to use closures, I'm not going to give an example here since while Python supports closures, it's still first and mainly an object language so the OO solution is the most obvious.</p>
<p>And finally, the clean procedural solution is to pass this context (which can be expressed as a <code>dict</code> or any similar datatype) all along the call chain, as shown in DFE's answer. </p>
<p>As a general rule : relying on global variables or some "magic" context that could - or not - be set by you-dont-who-nor-where-nor-when makes for code that is hard if not impossible to reason about, and that can break in the most unpredictable ways (googling for "globals evil" will yield an awful lot of litterature on the topic).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use kwargs in your function calls in order to pass</p>
<pre><code>def f1(user, operation):
    user_id = user.id
    # somehow define user_id as a global/context variable for any function call inside this scope
    f2(operation, user_id=user_id)

def f2(operation, **kwargs):
    # do something, not important, and then call another function
    f3(operation, **kwargs)

def f3(operation, **kwargs):
    # get user_id if there is a variable user_id in the context, get `None` otherwise
    user_id = kwargs.get("user_id")
    # do something with user_id and operation
</code></pre>
<p>the <code>kwargs</code> dict is the equivalent to what you are looking at in context variables, but limited at a call stack. It is the same memory element passed (through pointer-like) in each function and not duplicates variables in memory.</p>
<p>In my opinion, but I would like to see what you all think, context variables is an elegant way to authorize globals variables and to control it.</p>
</div>
<span class="comment-copy">Do you have any reason not to pass <code>user_id</code> as an argument to <code>f2</code> and <code>f3</code>?</span>
<span class="comment-copy">You seem to be misled by the broad range of meanings of the word <i>context</i>; since I can't recognize anything <i>asynchronous</i> here I don't believe this is an intended use of the concept. Somewhat difficult to decide, but I strongly suggest to pass the user_id as parameter to <code>f2()</code>and <code>f3()</code> or to create a class, with f1, f2 and f3 as methods. Your use looks suspiciously similar to a globale variable.</span>
<span class="comment-copy">Does that mean that if I have more than one thread running on my application, if thread1 set the context variable <code>user_id</code> it will be only set for this thread, and not for the others?</span>
<span class="comment-copy">Yes, that's the whole purpose of using a <code>ContextVar</code>, rather than just a global variable. An in-between solution that's more backwards compatible, if you need to run on a pre-3.7 version is using <a href="https://docs.python.org/3.7/library/threading.html#thread-local-data" rel="nofollow noreferrer"><code>threading.local</code></a> to get a namespace specific to your thread (but not to your async environment).</span>
<span class="comment-copy">As I have added now to the question, I don't have the possibility to place those functions inside a class, but I take your advice concerning the dangers of this global-like variables.</span>
<span class="comment-copy">That's a pretty good solution, but you should explain the rationale behind the decision to pass kwargs between all the functions (instead of using a global context).</span>
<span class="comment-copy">Since OP wrote <code>get user_id if there is a variable user_id in the context, get 'None' otherwise</code> this should probably better be <code>user_id = kwargs.get('user_id')</code>. <code>user_id = kwargs['user_id']</code> will raise a KeyError if no such variable is set, using the <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer">get()</a> method will return any implicit or explicit default.</span>
<span class="comment-copy">@shmee Thank you for the comment, I edited it and I will take it in account in my own code!</span>
