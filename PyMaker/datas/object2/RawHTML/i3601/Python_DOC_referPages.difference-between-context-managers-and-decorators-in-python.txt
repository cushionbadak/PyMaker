<div class="post-text" itemprop="text">
<p>What is the main difference between the two? I have been studying Python and came across them. A decorator is essentially a function that wraps another function and you can do anything before and after a particular function executes.</p>
<pre><code>def my_decorator(some_function):
    def wrapper(*args, **kwargs):
        print("Do something before the function is called")
        some_function(*args, **kwargs)
        print("Do something after the function is called")

    return wrapper

@my_decorator
def addition(a, b):
    result = a+b
    print("Addition of {} and {} is {}".format(a,b,result))
</code></pre>
<p>But after studying Context Manager, I couldn't help but notice that it too has a <strong>enter</strong> and <strong>exit</strong> where you could do most similar operations. </p>
<pre><code>from contextlib import contextmanager

@contextmanager
def open_file(path, mode):
    the_file = open(path, mode)
    yield the_file
    the_file.close()

files = []

for x in range(100000):
    with open_file('foo.txt', 'w') as infile:
        files.append(infile)

for f in files:
    if not f.closed:
        print('not closed')
</code></pre>
<p>Everything before yield is taken as part of the "enter" and everything after a part of "exit". </p>
<p>Although both Context Managers and Decorators are syntactically different, their behaviors can be looked upon as similar. So what is the difference? What are the different scenarios when one should use either of them?</p>
</div>
<div class="post-text" itemprop="text">
<p>They are completely separate concepts and should not be seen in the same light.</p>
<p>A decorator lets you <em>augment or replace a function or a class when it is defined</em>. This is far broader than just executing things before or after a function call. Sure, your specific decorator lets you do something just before and after a function call, <em>provided no exception is raised, or you explicitly handle exceptions</em>. But you could also use a decorator to add an attribute to the function object, or to update some kind of registry. Or to return something entirely different and ignore the original function. Or to produce a wrapper that manipulates the arguments passed in, or the return value of the original function. A context manager can't do any of those things.</p>
<p>A context manager on the other hand lets you abstract away <a href="https://docs.python.org/3/reference/compound_stmts.html#the-try-statement" rel="noreferrer"><code>try: ... finally:</code> constructs</a>, in that <strong>no matter how the block exits</strong>, you get to execute some more code at the end of the block. Even if the block raises an exception, or uses <code>return</code> to exit a function, the context manager <code>__exit__</code> method is still going to be called, <em>regardless</em>. A context manager can even suppress any exceptions raised in the block.</p>
<p>The two concepts are otherwise not related at all. Use decorators when you require to do something to or with functions or classes when they are defined. Use context managers when you want to clean up or take other actions after a block ends.</p>
</div>
<div class="post-text" itemprop="text">
<p>they are completely different concepts.</p>
<p>context managers are objects to be used with the python <code>with</code> keyword. It runs code when entering the block and exiting the block.</p>
<p>decorators are modifications to a function or class definition. It runs code that replaces the function as it is being defined.</p>
<pre><code>@D
def Y(...):
    ...
</code></pre>
<p>is just another way of writing</p>
<pre><code>def Y(...):
    ....
Y = D(Y)
</code></pre>
</div>
<span class="comment-copy">Thank you. This cleared things up!</span>
