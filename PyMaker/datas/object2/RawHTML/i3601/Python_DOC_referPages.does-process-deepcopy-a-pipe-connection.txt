<div class="post-text" itemprop="text">
<p>In Python multiprocessing, I saw some codes doing the following</p>
<pre><code>def worker(parent_conn, child_conn):
    parent_conn.close()

    while True:
        x = child_conn.recv()

        if x == 'close':
            child_conn.close()
            break
        else:
            do something

# Following as master

parent_conn, child_conn = Pipe()
process = Process(target=worker, args=[parent_conn, child_conn])

process.start()

child_conn.close()  # not used

for _ in range(10):
    parent_conn.send(something)
    parent_conn.recv()

parent_conn.send('close')

process.join()
</code></pre>
<p>The question I have is</p>
<ol>
<li><p>Why in worker, we can directly close the parent connection, it should have broken the pipe. So does the process fork (deepcopy) both parent and child connections for the worker ?</p></li>
<li><p>Why also in master main program, we can also directly close <code>child_conn</code> with same reason as question above ?</p></li>
<li><p>If I didn't send <code>'close'</code> to the worker from parent connection, it seems the worker while loop will goes infinitely even though I do join the process in the master main program. </p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Pipe" rel="nofollow noreferrer"><code>Pipe()</code></a> creates two connections, how they are propagated to a subprocess depends on the implementation for the used OS.</p>
<p>On *nix systems,<code>fork()</code> is used to spawn a new process, which inherits all open file descriptors from the parent process. It is best practice to immediately close all inherited file descriptors which are not needed after forking, that is what is being done here. This makes less sense on systems without <code>fork()</code> (windows), where connnections are implemented differently, but it still works.</p>
<p>The parent and the worker both close the one end of the connection they are not using. As they are separate processes, calling <code>child_conn.close()</code> in the parent does have no effect on <code>child_conn</code> in the worker, it only closes one end of the connection, the other can still be used. So the worker can call <code>recv()</code> on <code>client_conn</code> to get objects sent in the parent using <code>parent_conn.send()</code> and vice versa.</p>
<p>Your example actually wouldn't work because in the main process there is a call to <code>child_conn.recv()</code> after the connnection was closed. This will raise an exception.</p>
<p><code>process.join()</code> waits for the process to finish, which it does only if the loop ends, so if you never send a <code>'close'</code> message the woker will block on <code>child_conn.recv()</code> indefinitely, and <code>join()</code> will never return. This is a typical deadlock.</p>
<p>A different way signalling the worker to exit would be to call <code>parent_conn.close()</code> instead of sending a close message. This would cause an EOF error to be raised by <code>child_conn.recv()</code>, but only if all processes, including the worker, have closed the underlying file descriptor, which is one reason why it is customary to close unneeded file descriptors.</p>
</div>
<span class="comment-copy">Thanks for the detailed answer. Just to make sure if I take it correctly, e.g. in Ubuntu, the <code>fork()</code> will make a copy of the pipe ? i.e. in parent process, there are both ends of the pipe, and in worker process, it has a copied independent version with both ends ?</span>
<span class="comment-copy">btw, if above is correct, in master-worker pattern, is it more recommended to create worker process with only <code>args=child_conn</code> instead of <code>args=[parent_conn, child_conn]</code> because the worker does not really use the copied <code>parent_conn</code></span>
<span class="comment-copy">The process inherits the open file descriptors on <code>fork()</code> in any case, the connection object passed as agument when pickled/unpickled basically only tells the process which file descriptor to use when creating the connection object. So if you don't pass the <code>parent_connection</code> you don't know which descriptor to close, which in might not be a problem im many applications. But if for example you have multiple workers using the same connection (which would need locking), calling close in the parent to signal them to stop would not work if the descriptors are still open in the workers.</span>
