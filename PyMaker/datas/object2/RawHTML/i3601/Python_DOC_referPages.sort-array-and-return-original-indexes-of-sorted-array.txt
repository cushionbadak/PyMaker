<div class="post-text" itemprop="text">
<p>Given a <code>numpy</code> array, how can I find the sequence of indices into it such that the result is sorted?</p>
<p>For example, given <code>x=[4,2,6]</code>, the result would be <code>[1,0,2]</code>, since <code>[x[1],x[0],x[2]]</code> is sorted.</p>
<p>I know there are many Python functions available like <code>argsort()</code> which can do the job but I need to implement this sorting function myself.  Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you can use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> to turn any iterable of values into an iterable of (index, value) pairs.</p>
<p>But if you just sort those, it'll sort by index which isn't very useful. You want to sort by the value in each (index, value) pair. Normally, in Python, you do that by passing a <a href="https://docs.python.org/3/howto/sorting.html#key-functions" rel="nofollow noreferrer">key function</a> to <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer"><code>sorted</code></a>. As shown in the examples in that documentation, <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>itemgetter</code></a> makes for a perfect key function here. And you can easily modify your custom sorting function to use a key function the same way <code>sorted</code> does, although it's a bit hard to show you how to do that without seeing your custom sorting function.<sup>1</sup></p>
<p>But in this case, you can use the <a href="https://docs.python.org/3/howto/sorting.html#the-old-way-using-decorate-sort-undecorate" rel="nofollow noreferrer">Decorate-Sort-Undecorate</a> idiom. You just want to sort by the values in each (index, value) pair, so all you have to do to "decorate" is reverse the pairs. And, if you only want the indexes, not the values, to "undecorate", you just drop the values.</p>
<p>So:</p>
<pre><code>indexed = enumerate(arr)
decorated = ((value, index) for index, value in indexed)
sortedpairs = my_sort_function(decorated)
indices = np.fromiter(index for (value, index) in sortedpairs)
</code></pre>
<p>… or, putting it all together:</p>
<pre><code>sortedpairs = my_sort_function((value, index) for index, value in enumerate(arr))
indices = np.fromiter(index for (value, index) in sortedpairs)
</code></pre>
<p>(Of course you can make it a one-liner, but I think two lines is the best readability balance here.)</p>
<hr/>
<p>If you're not allowed to use even <code>enumerate</code>, this is one of the easiest builtin functions to replace with your own function. In fact, the docs even show you how to do it:</p>
<pre><code>def my_enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1
</code></pre>
<p>Or, since you don't need a custom start value:</p>
<pre><code>def my_enumerate(sequence):
    n = 0
    for elem in sequence:
        yield n, elem
        n += 1
</code></pre>
<hr/>
<p>But now, can you do the same thing while still taking (at least some) advantage of numpy, keeping everything as arrays instead of using iterables?</p>
<p>Sure. We can do the same thing as <code>enumerate</code>, and even put the values on the bottom so we don't need the whole flipping step:</p>
<pre><code>decorated = np.stack((arr, np.arange(len(arr))))
</code></pre>
<p>… then sort it. I'm assuming your custom sorting function sorts columns. Maybe you need to pass in an <code>axis</code> argument, or sort <code>decorated.T</code>, or whatever; you should know the API to your own function.</p>
<pre><code>sorted_pairs = my_sorted_array_function(decorated)
</code></pre>
<p>And now, we just take the index row:</p>
<pre><code>indices = sorted_pairs[1]
</code></pre>
<hr/>
<p><sub>1. For an initial implementation, just change every <code>x &lt; y</code> to <code>key(x) &lt; key(y)</code>, and get it working. Then you can figure out how to optimize it by caching the key values so you only call <code>key</code> once per element instead of <code>log(N)</code> times per element.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>As an example, let's take bubble sort (from <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Bubble_sort#Python" rel="nofollow noreferrer">https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Bubble_sort#Python</a>) and add index tracking:</p>
<pre><code>def bubblesort(lst):
    "Sorts lst in place and returns it."
    args = list(range(len(lst))) # &lt;- initial order of indices
    for passesLeft in range(len(lst)-1, 0, -1):
        for index in range(passesLeft):
            if lst[index] &gt; lst[index + 1]:
                lst[index], lst[index + 1] = lst[index + 1], lst[index]
                args[index], args[index + 1] = args[index + 1], args[index] # swap indices too
    return lst, args
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understood your question well, you can do using <code>list-comprehension</code>, with <code>sorted</code> function.</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np_array = np.array([4, 2, 6])
&gt;&gt;&gt; sorted_index_pos = [index for index, num in sorted(enumerate(np_array), key=lambda x: x[-1])]
[1, 0, 2]
</code></pre>
</div>
<span class="comment-copy">It's little bit confusing for me, Whats the desired output?</span>
<span class="comment-copy">output should be original indexes</span>
<span class="comment-copy">When you will implement a sorting algorithm, simply keep track of indices of input values as you move list values in order to sort them.</span>
<span class="comment-copy"><code>list(map(operator.itemgetter(0), sorted(enumerate(x), key=operator.itemgetter(1))))</code></span>
<span class="comment-copy">appreciate your answer.But I can't use any inbuild function.</span>
<span class="comment-copy">@KaranPurohit You can write <code>enumerate</code> yourself trivially. I can edit to show you how. And that's the only builtin function I'm using.</span>
<span class="comment-copy">which sorting method would be good here?</span>
<span class="comment-copy">@KaranPurohit If you have to write one yourself from scratch, and your teacher gave you no constraints, and the arrays are not gigantic? I'd do an <a href="https://en.wikipedia.org/wiki/Insertion_sort" rel="nofollow noreferrer">online insertion sort</a>. It should be dead simple, and more than fast enough for moderately-sized arrays, even if technically it's average-case quadratic rather than log-linear.</span>
<span class="comment-copy">is bubblesort is optimised method here? or any other sorthing method.</span>
<span class="comment-copy">@KaranPurohit Bubble Sort is not optimal for almost any workload. Presumably AGN Gazer chose it because it's the first sort most students learn, and because it's very easy to see how he modified it to solve your problem. I suspect the arrays aren't going to be large enough that performance is a problem. If I'm wrong, insertion sort and selection sort are faster, and almost as easy to visualize (all three are things you naturally do by hand in different cases), but a bit easier to get wrong.</span>
<span class="comment-copy">@KaranPurohit No, this is not an optimal method. I simply used it, as <code>@abarnet</code> correctly noted, only as an illustration of how to implement my suggestion from my comment <a href="https://stackoverflow.com/questions/50849300/sort-array-and-return-original-indexes-of-sorted-array/50849454#comment88701570_50849300" title="sort array and return original indexes of sorted array">stackoverflow.com/questions/50849300/…</a></span>
<span class="comment-copy">@KaranPurohit Python's <code>sort</code> function is not quicksort. It's <a href="https://en.wikipedia.org/wiki/Timsort" rel="nofollow noreferrer">Timsort</a>, which is a pretty complicated hybrid of insertion sort and a modified merge sort.</span>
<span class="comment-copy">@KaranPurohit Also, quicksort may be most preferred for teaching intermediate computer science (naturally recursive, lots of obvious variations to play with, demonstrates the correspondence between sorting and binary trees, serves as a great sample problem for average-case algorithm analysis, etc.), but it hasn't been preferred in practice since about the 90s. It's only really fast if you use a much less simple and elegant pivot algorithm than the one in the textbooks, and other algorithms still usually beat it while also being stable and often allowing either in-place or online sorting.</span>
<span class="comment-copy">I cant use inbuild function</span>
