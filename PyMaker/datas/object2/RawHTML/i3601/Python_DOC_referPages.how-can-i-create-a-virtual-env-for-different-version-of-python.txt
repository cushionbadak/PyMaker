<div class="post-text" itemprop="text">
<p>I have a Debian system currently running with python 2.5.4. I got virtualenv properly installed, everything is working fine. Is there a possibility that I can use a virtualenv with a different version of Python?</p>
<p>I compiled Python 2.6.2 and would like to use it with some virtualenv. Is it enough to overwrite the binary file? Or do I have to change something in respect to the libraries?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use the <code>--python</code> (or short <code>-p</code>) option when creating your virtualenv instance to specify the Python executable you want to use, e.g.:</p>
<pre><code>virtualenv --python=/usr/bin/python2.6 &lt;path/to/new/virtualenv/&gt;
</code></pre>
<p>N.B. For <strong>Python 3.3</strong> or later, refer to The Aelfinn's <a href="https://stackoverflow.com/a/39713544/1450294">answer</a> below.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>UPDATE:</strong>  For Python3.6, the below <code>pyvenv</code> script is deprecated. Instead,
 <a href="https://docs.python.org/3/library/venv.html" rel="noreferrer" title="Python 3.6.4 documentation - Creation of virtual environments">the Python Docs suggest</a> creating the virtual environment with the following command:</p>
<pre><code>python3 -m venv &lt;myenvname&gt;
</code></pre>
<p>For python3 (3.3+), use either the above method or the <a href="https://docs.python.org/3/library/venv.html" rel="noreferrer" title="Python 3.6.4 documentation - Creation of virtual environments">script</a> <code>pyvenv</code> command.</p>
<pre><code>pyvenv /path/to/new/virtual/environment
</code></pre>
<p>Please note that <code>venv</code> does not permit creating virtualenv with other versions of Python. For that, install and use the <code>virtualenv</code> <a href="https://pypi.python.org/pypi/virtualenv" rel="noreferrer">package</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>These are steps when you are on shared hosting environment and need to install &amp; complie Python from source and then create venv from your Python version. For Python 2.7.9 you would do something along these lines:</p>
<pre><code>mkdir ~/src
wget http://www.python.org/ftp/python/2.7.9/Python-2.7.9.tgz
tar -zxvf Python-2.7.9.tgz
cd Python-2.7.9
mkdir ~/.localpython
./configure --prefix=$HOME/.localpython
make
make install
</code></pre>
<p><strong>virtual env</strong></p>
<pre><code>cd ~/src
wget https://pypi.python.org/packages/5c/79/5dae7494b9f5ed061cff9a8ab8d6e1f02db352f3facf907d9eb614fb80e9/virtualenv-15.0.2.tar.gz#md5=0ed59863994daf1292827ffdbba80a63
tar -zxvf virtualenv-15.0.2.tar.gz
cd virtualenv-15.0.2/
~/.localpython/bin/python setup.py install
virtualenv ve -p $HOME/.localpython/bin/python2.7
source ve/bin/activate   
</code></pre>
<p>Naturally this can be applicable to any situation where you want to replicate the exact environment you work and deploy on. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>virtualenv --python=/usr/bin/python2.6 &lt;path/to/myvirtualenv&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is an easier way, </p>
<pre><code>virtualenv venv --python=python2.7
</code></pre>
<p>Thanks to  a comment, this only works if you have python2.7 installed at the system level (e.g. /usr/bin/python2.7).</p>
<p>Otherwise, if you are using homebrew you can use the path to give you what you want.</p>
<pre><code>virtualenv venv --python=/usr/local/bin/python
</code></pre>
<p>You can find the path to your python installation with </p>
<pre><code>which python
</code></pre>
<p>This will also work with python 3. </p>
<pre><code>which python3
&gt;&gt; /usr/local/bin/python3
virtualenv venv --python=/usr/local/bin/python3
</code></pre>
<p>Ultimately condensing to:</p>
<pre><code>virtualenv venv -p `which python`
virtualenv venv -p `which python3`
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Under Windows for me this works:</p>
<pre><code>virtualenv --python=c:\Python25\python.exe envname
</code></pre>
<p>without the <code>python.exe</code> I got <code>WindowsError: [Error 5] Access is denied</code> 
I have Python2.7.1 installed with virtualenv 1.6.1, and I wanted python 2.5.2.</p>
</div>
<div class="post-text" itemprop="text">
<p>Mac OSX 10.6.8 (Snow Leopard):</p>
<p>1) When you do <code>pip install virtualenv</code>, the pip command is associated with one of your python versions, and <code>virtualenv</code> gets installed into that version of python.  You can do</p>
<pre><code> $ which pip   
</code></pre>
<p>to see what version of python that is.  If you see something like:</p>
<pre><code> $ which pip
 /usr/local/bin/pip
</code></pre>
<p>then do:</p>
<pre><code>$ ls -al /usr/local/bin/pip
lrwxrwxr-x  1 root  admin  65 Apr 10  2015 /usr/local/bin/pip -&gt;
../../../Library/Frameworks/Python.framework/Versions/2.7/bin/pip
</code></pre>
<p>You can see the python version in the output.</p>
<p>By default, that will be the version of python that is used for any new environment you create. However, you can specify any version of python installed on your computer to use inside a new environment with the <code>-p flag</code>:  </p>
<pre><code>$ virtualenv -p python3.2 my_env  
Running virtualenv with interpreter /usr/local/bin/python3.2  
New python executable in my_env/bin/python  
Installing setuptools, pip...done.  
</code></pre>
<blockquote>
<p><code>virtualenv my_env</code> will create a folder in the current directory which
  will contain the Python executable files, and a copy of the pip
  [command] which you can use to install other packages.</p>
</blockquote>
<p><a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" rel="nofollow noreferrer">http://docs.python-guide.org/en/latest/dev/virtualenvs/</a></p>
<p><code>virtualenv</code> just copies python from a location on your computer into the newly created my_env/bin/ directory. </p>
<p>2) The system python is in <code>/usr/bin</code>, while the various python versions I installed were, by default, installed into:</p>
<pre><code> /usr/local/bin
</code></pre>
<p>3) The various pythons I installed have names like <code>python2.7</code> or <code>python3.2</code>, and I can use those names rather than full paths. </p>
<h3>========VIRTUALENVWRAPPER=========</h3>
<p>1) I had some problems getting virtualenvwrapper to work.  This is what I ended up putting in <code>~/.bash_profile</code>:  </p>
<pre><code>export WORKON_HOME=$HOME/.virtualenvs
export PROJECT_HOME=$HOME/django_projects  #Not very important -- mkproject command uses this
#Added the following based on: 
#http://stackoverflow.com/questions/19665327/virtualenvwrapper-installation-snow-leopard-python
export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python2.7 
#source /usr/local/bin/virtualenvwrapper.sh
source /Library/Frameworks/Python.framework/Versions/2.7/bin/virtualenvwrapper.sh
</code></pre>
<p>2) The <code>-p option</code> works differently with virtualenvwrapper: I have to specify the full path to the python interpreter to be used in the new environment(when I do not want to use the default python version):  </p>
<pre><code>$ mkvirtualenv -p /usr/local/bin/python3.2 my_env
Running virtualenv with interpreter /usr/local/bin/python3
New python executable in my_env/bin/python
Installing setuptools, pip...done.
Usage: source deactivate

removes the 'bin' directory of the environment activated with 'source
activate' from PATH. 
</code></pre>
<p>Unlike virtualenv, virtualenvwrapper will create the environment at the location specified by the $WORKON_HOME environment variable.  That keeps all your environments in one place.</p>
</div>
<div class="post-text" itemprop="text">
<p>Suppose you currently have python 2.7 installed in your virtualenv. But want to make use of <code>python3.2</code>, You would have to update this with:</p>
<pre><code>$ virtualenv --python=/usr/bin/python3.2 name_of_your_virtualenv
</code></pre>
<p>Then activate your <em>virtualenv</em> by:</p>
<pre><code>$ source activate name_of_your_virtualenv
</code></pre>
<p>and then do: <code>python --version</code> in shell to check whether your version is now updated.</p>
</div>
<div class="post-text" itemprop="text">
<p>These two commands should work fine for a newbie</p>
<p><code>virtualenv -p python2 myenv</code>  (For python2)</p>
<p><code>virtualenv -p python3 myenv</code>  (For python3)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can call <code>virtualenv</code> with python version you want. For example:</p>
<pre><code>python3 -m virtualenv venv
</code></pre>
<p>Or alternatively directly point to your virtualenv path. e.g. for windows:</p>
<pre><code>c:\Python34\Scripts\virtualenv.exe venv
</code></pre>
<p>And by running:</p>
<pre><code>venv/bin/python

Python 3.5.1 (v3.5.1:37a07cee5969, Dec  5 2015, 21:12:44) 
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</code></pre>
<p>you can see the python version installed in virtual environment</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>-p</code> approach works well, but you do have to remember to use it every time.  If your goal is to switch to a newer version of Python generally, that's a pain and can also lead to mistakes.</p>
<p>Your other option is to set an environment variable that does the same thing as <code>-p</code>. Set this via your <code>~/.bashrc</code> file or wherever you manage environment variables for your login sessions:</p>
<pre><code>export VIRTUALENV_PYTHON=/path/to/desired/version
</code></pre>
<p>Then <code>virtualenv</code> will use that any time you don't specify <code>-p</code> on the command line.</p>
</div>
<div class="post-text" itemprop="text">
<p>For Mac(High Sierra), install the virtualenv on python3 and create a virtualenv for python2:</p>
<pre><code> $ python3 -m pip install virtualenv
 $ python3 -m virtualenv --python=python2 vp27
 $ source vp27/bin/activate
 (vp27)$ python --version
 Python 2.7.14
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>On the mac I use pyenv and virtualenvwrapper. I had to create a new virtualenv. You need homebrew which I'll assume you've installed if you're on a mac, but just for fun:</p>
<pre><code>ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"


brew install pyenv
pyenv install 2.7.10
pyenv global 2.7.10
export PATH=/Users/{USERNAME}/.pyenv/versions/2.7.10/bin:$PATH
mkvirtualenv -p ~/.pyenv/versions/2.7.10/bin/python  {virtual_env_name}
</code></pre>
<p>I also froze my requirements first so i could simply reinstall in the new virtualenv with:</p>
<pre><code>pip install -r requirements.txt
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Even easier, by using command substitution to find python2 for you:</p>
<p><code>virtualenv -p $(which python2) &lt;path/to/new/virtualenv/&gt;</code></p>
<p>Or when using virtualenvwrapper : </p>
<p><code>mkvirtualenv -p $(which python2) &lt;env_name&gt;</code></p>
</div>
<div class="post-text" itemprop="text">
<h2><strong>In windows subsystem for linux:</strong></h2>
<ol>
<li><p>Create environment for python3:</p>
<pre><code>virtualenv --python=/usr/bin/python3 env
</code></pre></li>
<li><p>Activate it:</p>
<pre><code>source env/bin/activate
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p><strong>Yes</strong>, the above answers are correct and works fine on Unix based systems like <strong>Linux</strong> &amp; <strong>MAC OS X</strong>.</p>
<p>I tried to create <strong>virtualenv</strong> for <strong>Python2</strong> &amp; <strong>Python3</strong> with the following commands.</p>
<p>Here I have used <strong>venv2</strong> &amp; <strong>venv3</strong> as their names for <strong>Python2</strong> &amp; <strong>Python3</strong> respectively.</p>
<blockquote>
<p>Python2 »</p>
</blockquote>
<pre><code>MacBook-Pro-2:~ admin$ virtualenv venv2 --python=`which python2`
Running virtualenv with interpreter /usr/local/bin/python2
New python executable in /Users/admin/venv2/bin/python
Installing setuptools, pip, wheel...done.
MacBook-Pro-2:~ admin$ 
MacBook-Pro-2:~ admin$ ls venv2/bin/
activate        easy_install        pip2.7          python2.7
activate.csh        easy_install-2.7    python          wheel
activate.fish       pip         python-config
activate_this.py    pip2            python2
MacBook-Pro-2:~ admin$ 
</code></pre>
<blockquote>
<p>Python3 »</p>
</blockquote>
<pre><code>MacBook-Pro-2:~ admin$ virtualenv venv3 --python=`which python3`
Running virtualenv with interpreter /usr/local/bin/python3
Using base prefix '/Library/Frameworks/Python.framework/Versions/3.6'
New python executable in /Users/admin/venv3/bin/python3
Also creating executable in /Users/admin/venv3/bin/python
Installing setuptools, pip, wheel...done.
MacBook-Pro-2:~ admin$ 
MacBook-Pro-2:~ admin$ ls venv3/bin/
activate        easy_install        pip3.6          python3.6
activate.csh        easy_install-3.6    python          wheel
activate.fish       pip         python-config
activate_this.py    pip3            python3
MacBook-Pro-2:~ admin$ 
</code></pre>
<blockquote>
<p>Checking Python installation locations</p>
</blockquote>
<pre><code>MacBook-Pro-2:~ admin$ which python2
/usr/local/bin/python2
MacBook-Pro-2:~ admin$ 
MacBook-Pro-2:~ admin$ which python3
/usr/local/bin/python3
MacBook-Pro-2:~ admin$ 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>It worked for me</strong></p>
<pre><code>sudo apt-get install python3-minimal

virtualenv --no-site-packages --distribute -p /usr/bin/python3 ~/.virtualenvs/py3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>On windows:</p>
<pre><code>py -3.4x32 -m venv venv34
</code></pre>
<p>or </p>
<pre><code>py -2.6.2 -m venv venv26
</code></pre>
<p>This uses the <a href="https://docs.python.org/3/using/windows.html#launcher" rel="nofollow noreferrer"><code>py</code> launcher</a> which will find the right python executable for you (assuming you have it installed).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>virtualenv -p python3 myenv
</code></pre>
<p><a href="http://gist.github.com/Geoyi/d9fab4f609e9f75941946be45000632b" rel="nofollow noreferrer">Link to Creating virtualenv</a></p>
</div>
<div class="post-text" itemprop="text">
<p>For Debian (debian 9) Systems in 2019, I discovered a simple solution that may solve the problem from within the virtual environment.</p>
<p>Suppose the virtual environment were created via:</p>
<pre><code>python3.7 -m venv myenv
</code></pre>
<p>but only has versions of <code>python2</code> and <code>python2.7</code>, and you need the recent features of python3.7. </p>
<p>Then, simply running the command:</p>
<pre><code>(myvenv) $ python3.7 -m venv --upgrade /home/username/path/to/myvenv/
</code></pre>
<p>will add python3.7 packages if they are already available on your system.</p>
</div>
<div class="post-text" itemprop="text">
<p>This was a bug with virtualenv.
Just upgrading your pip should be the fix.</p>
<p><code>pip install --upgrade virtualenv</code></p>
</div>
<span class="comment-copy">Just mentioning that you can do this using virtualenvwrapper too.</span>
<span class="comment-copy">Worth noting that in python 3, there is a built-in virtualenv equivalent: <a href="https://docs.python.org/3/library/venv.html" rel="nofollow noreferrer">venv</a>.</span>
<span class="comment-copy">Is it not possible to switch python version in the current environment without creating a new environment?</span>
<span class="comment-copy">I figured I'd mention that this works for virtualenvwrappers too: mkvirtualenv -p python2.6 env</span>
<span class="comment-copy">I'm missing something here - doesn't this require that 2.6 already be installed on the system? I thought the <i>point</i> of virtualenv was that I could have a version of python other than the main one (in my case, 2.4 on CentOS). I was assuming I could install virtualenv, <i>then</i> install Python 2.6 under it for packages in the env to make use of?</span>
<span class="comment-copy">@John yes, you are. That isn't the point of virtualenv: the point of that is to create a sandboxed environment for Python. You will need to install that version first - you can install it locally for your user, though.</span>
<span class="comment-copy">@JohnC You can use pythonbrew to install alternative pythons.</span>
<span class="comment-copy">If you are a tad lazy: <code>virtualenv -p `which python2.6` &lt;path/to/new/virtualenv&gt;</code></span>
<span class="comment-copy">Glad you pointed that out, it needs more promotion. One minor nit: they are now advocating running it as <code>python3 -m venv &lt;envname&gt;</code> to prevent needing stub scripts for everything.</span>
<span class="comment-copy">In fact the <code>pyvenv</code> script is <a href="https://docs.python.org/dev/whatsnew/3.6.html#deprecated-features" rel="nofollow noreferrer">deprecated</a> in Python 3.6+, though the underlying <code>venv</code> module itself is not.  So use <code>python 3 -m venv &lt;myenvname&gt;</code> as @PaulEveritt says.</span>
<span class="comment-copy">Be warned that <code>pyvenv</code> or <code>python3 -m venv ...</code> do NOT install the <code>python-config</code> script. This means that even after activating your Python3 environment the system-wide <code>python-config</code> will be invoked with confusing consequences. See this bug report from 2011 <a href="https://github.com/pypa/virtualenv/issues/169" rel="nofollow noreferrer">github.com/pypa/virtualenv/issues/169</a> and my question <a href="https://stackoverflow.com/questions/42020937/why-pyvenv-does-not-install-python-config?rq=1" title="why pyvenv does not install python config">stackoverflow.com/questions/42020937/…</a></span>
<span class="comment-copy">Could you elaborate on why to do it that way: Why install python locally? And more importantly <b>why install virtualenv using the python version you want to use with it</b>?</span>
<span class="comment-copy">sure. If you are on virtual hosting environment and the server provides older versions of python that you are not happy with -  that was my case scenario. Also if you happen to develop projects on different servers and you want to replicate these environments on your local machine.... Virtualenv creates hard links to python libs . so it's really important with version of python you are using to install and create Virtualenv from.</span>
<span class="comment-copy">Or if you are like me and am on a locked down machine at work with no sudo privileges. Local copies of libraries, SQL databases, languages and compilers galore! Thanks!</span>
<span class="comment-copy">Under virtualenv 1.9.1, I had to use <code>~/.localpython/bin/virtualenv</code> instead of just <code>virtualenv</code> for setup to complete without errors. In addition, use <code>source ve/bin/activate</code> instead of <code>source activate</code>.</span>
<span class="comment-copy">Another reason to do this would be to try out betas before they go main to make sure your projects and their dependencies still work without risking breaking your package management by clobbering something and leaving dangling files all over the place.  I like this answer.</span>
<span class="comment-copy">See my answer below for an equivalent solution using environment variables. That approach means you don't have to remember to use <code>-p</code>.</span>
<span class="comment-copy">Is there no solutions that switches between python versions without requiring to create a new virtual environment?</span>
<span class="comment-copy">Would this work, if you want to install a python version that is not installed on your system? Say you want to test out <code>python3.6</code> but dont want to touch <code>python3.5</code> installed on your computer?</span>
<span class="comment-copy">FYI, only works if you have python2.7 installed at the system level (e.g. /usr/bin/python2.7)</span>
<span class="comment-copy">I was able to do this with <code>virtualenv venv --python=python3.6</code> as well</span>
<span class="comment-copy">You can actually drop the minor version number. <code>virtualenv env --python=python2</code></span>
<span class="comment-copy">That's a proper solution, once you have all versions, you are interested in justing using the alias not the full path</span>
<span class="comment-copy"><code>which pip</code> doesn't tell me the version of Python. It gives me this- <code>/usr/local/bin/pip</code>.</span>
<span class="comment-copy">@Sankalp, If you cd to <code>/usr/local/bin</code> and do <code>$ ls -al pip</code>, you should see something like:  <code>pip -&gt; ../../../Library/Frameworks/Python.framework/Versions/2.7/bin/pip</code></span>
<span class="comment-copy">Already somewhat noted in answer, but <code>mkproject</code> is the command to use if you want it to create both the project directory and a virtual environment of a given python version.  <code>mkproject -p /usr/bin/python3.6 myNewPython36Project</code></span>
<span class="comment-copy">See my answer below for an equivalent solution using environment variables. That approach means you don't have to remember to use <code>-p</code>.</span>
<span class="comment-copy">The flag -p python2 works equivalent to looking for /usr/bin/python2. Use : virtualenv -p python2.7 myenv for 2.7 etc.</span>
<span class="comment-copy">I got this error on running the first command /usr/local/bin/python3: No module named virtualenv</span>
<span class="comment-copy">@tanvi : You need to install virtualenv into your python3 first. Run <code>pip3 install virtualenv</code> first</span>
<span class="comment-copy">This worked beautifully. Any idea why setting <code>export VIRTUALENVWRAPPER_PYTHON=/path/to/desired/version</code> per the <a href="http://virtualenvwrapper.readthedocs.io/en/latest/install.html#python-interpreter-virtualenv-and-path" rel="nofollow noreferrer">virtualenvwrapper docs</a> didn't work but this solution did work?</span>
<span class="comment-copy">That env var controls which Python <code>virtualenvwrapper</code> uses when run, nothing to do with installs.</span>
<span class="comment-copy">Install virtualenv on python3 if you don't have: <code>python3 -m pip install virtualenv</code></span>
<span class="comment-copy">Command should be <code>mkvirtualenv -p ~/.pyenv/versions/2.7.10/bin/python  {virtual_env_name}</code> versions, not version. If SO allowed short edits, I woulda fixed it.</span>
<span class="comment-copy"><code>pyenv</code> includes virtualenv support through the <code>pyenv-virtualenv</code> plugin, so I find I don't really need virtualenvwrapper.  More details in <a href="http://stackoverflow.com/questions/4324558/whats-the-proper-way-to-install-pip-virtualenv-and-distribute-for-python/43828665#43828665">my pyenv answer</a>.</span>
