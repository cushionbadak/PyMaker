<div class="post-text" itemprop="text">
<p>For every row in my dataframe, I need to create every combination of two values of column <code>a</code> <em>from a three-day sliding window ending at that row</em>. My dataframe is like this:</p>
<pre><code>import pandas as pd    
df = pd.DataFrame({'a': [1, 2, 3, 4, 5]},
                   index=[pd.Timestamp('20180101'),
                          pd.Timestamp('20180102'),
                          pd.Timestamp('20180103'),
                          pd.Timestamp('20180105'),
                          pd.Timestamp('20180106')])
</code></pre>
<p>Note that the time index is ragged (inconsistent intervals between rows). The combinations should come out to be:</p>
<pre><code>row0: None
row1: [(1, 2)]
row2: [(1, 2), (1, 3), (2, 3)]
row4: [(3, 4)]
row5: [(4, 5)]
</code></pre>
<p>I can do this easily enough <em>without</em> the window, just use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> to generate every combination of two elements of column <code>a</code> with:</p>
<pre><code>import itertools as it
combos = it.combinations(df['a'], 2)
for c in combos:
    print(c)
# (1, 2)
# (1, 3)
# (1, 4)
# (1, 5)
# etc.
</code></pre>
<p>but I need the windowed version for my application. My best bet so far is to use <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.rolling.html" rel="nofollow noreferrer"><code>df.rolling</code></a>. I can do simple things like summing the elements over a three day window with something like:</p>
<pre><code>df.rolling('3d').sum()
# get [1, 3, 6, 7, 9] which we expect
</code></pre>
<p>but I can't seem to perform more complicated operations (or return more complicated types than real numbers from an operation) on the rolling window.</p>
<hr/>
<h2>Question</h2>
<p>How do I use <code>df.rolling</code> to make combinations over my rolling window? Or is there some other tool to do this?</p>
<hr/>
<h2>Attempts</h2>
<p>My thought so far is that there is some way to use <code>df.rolling</code> and <code>df.apply</code> along with <code>it.combinations</code> to generate iterators for each window in my dataframe, and then plug that iterator into a new column of my dataframe. Something like:</p>
<pre><code>df.rolling('3d').apply(lambda x: it.combinations(x, 2))
</code></pre>
<p>which gives a <code>TypeError</code>:</p>
<blockquote>
<p>TypeError: must be real number, not itertools.combinations</p>
</blockquote>
<p>because <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.core.window.Rolling.apply.html" rel="nofollow noreferrer"><code>df.rolling.apply</code></a> requires that its argument return a single real value, not an object, nor a list.</p>
<p>I also tried using <code>it.combinations</code> directly on the rolling window:</p>
<pre><code>it.combinations(df.rolling('3d'), 2)
</code></pre>
<p>which gives:</p>
<blockquote>
<p>KeyError: 'Column not found: 0'</p>
</blockquote>
<p>and if I select column <code>a</code> explicitly:</p>
<pre><code>it.combinations(df.rolling('3d')['a'], 2)
</code></pre>
<p>I get:</p>
<blockquote>
<p>Exception: Column(s) a already selected</p>
</blockquote>
<p>So is there maybe a way to define a function that I can call with <code>df.apply</code> that plugs the iterator over my rolling window into a new column for each row of my dataframe? Can I even operate on rows other than the current row in a function passed to <code>apply</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Okay, this is a hack, but it might be useful.</p>
<p>All we want to do is reuse df.rolling's windowing facilities.  We could try to look inside some non-public parts of the code, but instead let's just take advantage of the fact we can force a function call inside apply before we return a float:</p>
<pre><code>In [28]: dummy = df.rolling("3d")["a"].apply((lambda x: print(x) or 0), raw=False)
2018-01-01    1.0
dtype: float64
2018-01-01    1.0
2018-01-02    2.0
dtype: float64
2018-01-01    1.0
2018-01-02    2.0
2018-01-03    3.0
dtype: float64
2018-01-03    3.0
2018-01-05    4.0
dtype: float64
2018-01-05    4.0
2018-01-06    5.0
dtype: float64
</code></pre>
<p>And so:</p>
<pre><code>In [29]: roll_slices = []

In [30]: dummy = df.rolling("3d")["a"].apply((lambda x: roll_slices.append(list(combinations(x, 2))) or 0), raw=False)

In [31]: roll_slices
Out[31]: 
[[],
 [(1.0, 2.0)],
 [(1.0, 2.0), (1.0, 3.0), (2.0, 3.0)],
 [(3.0, 4.0)],
 [(4.0, 5.0)]]
</code></pre>
<p>After which you can do what you like.</p>
</div>
<span class="comment-copy">WOW!  Appending to a list in side rolling apply.  Nice.  +1</span>
<span class="comment-copy">I am getting <code>TypeError: apply() got an unexpected keyword argument 'raw'</code>, I think because it is the <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.core.window.Rolling.apply.html" rel="nofollow noreferrer"><code>pandas.core.window.Rolling.apply()</code></a> method that is getting called, and not the <a href="http://pandas.pydata.org/pandas-docs/version/0.22/generated/pandas.DataFrame.apply.html" rel="nofollow noreferrer"><code>pandas.DataFrame.apply()</code></a> method. Any ideas?</span>
<span class="comment-copy">You're probably using an older version of pandas.  Does it work if you just drop the <code>raw=False</code>?  (I just got it to run in 0.19.2 after dropping it, which is the oldest version I have on hand, as well as 0.23.0, the one I'm currently using.)</span>
<span class="comment-copy">That worked, thank you!</span>
<span class="comment-copy">Just a note (wasn't in the problem statement, but I thought I'd add it here), if I want only <i>unique</i> combinations, I can use your idea but define <code>roll_slices = set()</code> and then <code>df.rolling('3d')['a'].apply(lambda x: roll_slices.update(it.combinations(x, 2)) or 0)</code>. Cool idea!</span>
