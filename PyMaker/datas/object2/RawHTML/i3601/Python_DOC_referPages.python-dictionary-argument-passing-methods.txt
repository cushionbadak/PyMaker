<div class="post-text" itemprop="text">
<p>I am trying to pass a dictionary as an argument, and see 2 approaches as seen below, what's makes it keep the dictionary value unchanged when passed with **</p>
<pre><code>def dict_test1(**d):
    d['a'] = '10'

def dict_test2(d):
    d['a'] = '10'


d = {'a': '1'}

dict_test1(**d) 
print d

dict_test2(d) 
print d
</code></pre>
<p>Output:</p>
<pre><code>{'a': '1'}

{'a': '10'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is simply that <code>(**d)</code> creates a new <code>dict</code>, while <code>(d)</code> keeps a reference to the old one:</p>
<pre><code>def dict_test1(**d):
    print d is d_global # False

def dict_test2(d):
    print d is d_global # True


d_global = {'a': '1'}

dict_test1(**d_global ) 
dict_test2(d_global) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To understand what's going on, consider this case:</p>
<pre><code>&gt;&gt;&gt; def test1(**d):
...     print(d)
&gt;&gt;&gt; test1(spam=10)
{'spam': 10}
</code></pre>
<p>Where did that <code>{'spam': 10}</code> come from? Simple: <code>**d</code> just packs up all keyword arguments that don't match any named parameters, no matter where they came from, into a new dict, and gives you that dict as <code>d</code>.</p>
<hr/>
<p>Now look at <code>**</code> on the argument side instead:</p>
<pre><code>&gt;&gt;&gt; def test2(spam, eggs):
...     print(spam, eggs)
&gt;&gt;&gt; d = {'eggs': 10, 'spam': 20}
&gt;&gt;&gt; test2(**d)
20 10
</code></pre>
<p>So Python is expanding <code>**d</code> into a bunch of separate keyword arguments, which match up with parameters exactly the same way as actual separate keyword arguments.</p>
<hr/>
<p>Finally, on both sides:</p>
<pre><code>&gt;&gt;&gt; def test3(spam, eggs, **d):
...     print(spam, eggs)
...     print(d)
&gt;&gt;&gt; d = {'spam': 10, 'cheese': 20}
&gt;&gt;&gt; test3(eggs=30, **d)
10 30
{'cheese': 20}
</code></pre>
<p>So Python is expanding the <code>**d</code> argument out into two separate keyword arguments, putting them together with the normal keyword argument <code>eggs=30</code>, matching them to the parameters <code>spam</code> and <code>eggs</code>, and storing any leftovers in a new dict in the <code>**d</code> parameter.</p>
<hr/>
<p>This is all explained loosely in <a href="https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions" rel="nofollow noreferrer">the tutorial</a>, and more rigorously in <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow noreferrer">the reference</a>.</p>
<p>There's really nothing special about the fact that you had a <code>**d</code> parameter on the definition and a <code>**d</code> argument on the call; they don't have to correspond to each other in any way.</p>
<p>Some people consider it unfortunate that Python uses the same syntax for variable-argument parameters in the definition and argument unpacking in the call, and likewise the same syntax for default parameter values in the definition and keyword arguments in the call. But, while this is confusing the first time you run into it, once you understand, it's very easy to remember, and to read. And other languages that distinguish the two with syntax like <code>...args</code> vs. <code>seq...</code> don't seem to be any less initially confusing.</p>
</div>
