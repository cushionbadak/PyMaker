<div class="post-text" itemprop="text">
<p>I am reading in words from a text file and comparing them to a set of words just to see how many times they appear in the sample document. For example, I have a text file and I want to see how many times the word "engineer" occurs. </p>
<p>The problem is that with my sample data, string comparison isn't working. I see that the program is indeed reading in what appears to be a word of <code>&lt;type 'str'&gt;</code> that looks like "engineer"; however, there is no match. When printing out the ASCII for each character in the word using <code>ord(character)</code>, there appear to be 0's in between each character. The output for the string "engineer" then looks like the following:</p>
<pre><code>0 101 0 110 0 103 0 105 0 110 0 101 0 101 0 114 0
</code></pre>
<p>Using <code>strip()</code> removes the beginning and the end 0's, but not the middle ones. Any thoughts on what format these strings are in and how I can fix it?</p>
<p>I am using Python 2.7. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is <a href="https://en.wikipedia.org/wiki/UTF-16" rel="nofollow noreferrer">UTF-16-BE</a> encoding for the string <code>engineer</code>.<sup>1</sup></p>
<p>UTF-16 uses two bytes for BMP characters (including ASCII characters), so, for example, the character <code>e</code>, which is Unicode (and ASCII) character number 101 (0x65 hex), shows up as the 16-bit code unit 101. In big-endian (that's what the <code>-BE</code> part means), the first byte is 0, and the second byte is 101. So, if your text is pure ASCII, your UTF-16 ends up looking like ASCII with an extra <code>\0</code> byte before each character.</p>
<hr/>
<p>The cleanest way to solve this is to open the file as a Unicode file. As a general rule, if you decode everything to <code>unicode</code> as part of reading it, encode back to bytes only at the very end as part of writing it, and do all the work in the middle with <code>unicode</code>, everything is simpler.</p>
<p>In Python 2.7, there are two ways to do this, <a href="https://docs.python.org/2/library/codecs.html#codecs.open" rel="nofollow noreferrer"><code>codecs.open</code></a> or <a href="https://docs.python.org/2/library/io.html#io.open" rel="nofollow noreferrer"><code>io.open</code></a>. Using <code>codecs</code> makes your code a bit easier to port to Python 2.5, using <code>io</code> makes it a bit easier to port to 3.x, but it doesn't make a difference otherwise in simple cases like this.</p>
<p>Notice that your <code>line</code> strings will now be <code>unicode</code> instead of <code>str</code>, so ideally you'll want your set of search strings to also be <code>unicode</code> values.</p>
<pre><code>d = {u'engineer': 0, u'conductor': 0, u'transit cop': 0}
with io.open(path, encoding='utf-16-be') as f:
    for line in f:
        try:
            d[line.strip()] += 1
        except KeyError:
            pass
</code></pre>
<hr/>
<p>Another alternative is to read the file as binary UTF-16-BE, and make your search strings UTF-16-BE-encoded <code>str</code> values:</p>
<pre><code>d = {u'engineer': 0, u'conductor': 0, u'transit cop': 0}
d = {key.encode('utf-16-be'): count for key, count in d.items()}
with open(path) as f:
    for line in f:
        try:
            d[line.rstrip('\n\0')] += 1
        except KeyError:
            pass
</code></pre>
<p>Notice that I had to be careful with stripping, to make sure to remove the whole two-byte <code>\0\n</code> at the end instead of just the <code>\n</code> byte, and to not strip off the <code>\0</code> byte at the start. This is just one of many ways that dealing with encoded bytes is more of a pain than dealing with Unicode. And if your final output is going to involve, say, printing these strings to your console or writing them out to a UTF-8 file, it'll get even more painful. If the final output is going to be another UTF-16-BE file, and if saving a bit of CPU is really important, it might be worth doing it this way. But otherwise, I'd go with the first.</p>
<hr/>
<p><sub>1. Actually, you've got an extra <code>\0</code> at the end. But presumably in your real data, that's actually the first byte of the next characterâ€”maybe a <code>\n</code>, which, in UTF-16-BE, of course looks like <code>\0\n</code>.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>Looks like a job for the regex library <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">https://docs.python.org/3/library/re.html</a>.  Match on a suitable regex to get the number of hits per line.  Add em all up to get the file level:</p>
<pre><code>pattern = re.compile("engine")
len(pattern.findall("engine engineers love engineering"))
&gt;&gt;&gt;
3
</code></pre>
</div>
<span class="comment-copy">Sounds like UTF-16.</span>
<span class="comment-copy">Not sure why you're getting 0's in between each character, but maybe you could split on them and reassemble your string without the 0s?</span>
<span class="comment-copy">show your code and file</span>
