<div class="post-text" itemprop="text">
<p>I am a beginner python learner, tkinter in particular. </p>
<p>I want to make a 'loading screen' of a simple python script and closes after the script ends.</p>
<p>But making a window requires a <code>mainloop</code> function which means that it will loops infinitely or wait for a user interaction(or so i think) and it will eliminate the idea of a 'loading' screen. </p>
<p>I tried something but ends up with (Put Loading Screen) -&gt; (Loading screen still have <code>mainloop</code>) -&gt; (Can't Run Script because of waiting)</p>
<p>What i wanted in detail was (Put Loading Script) -&gt; (Run Script) -&gt; (Script ends) -&gt; (Loading Screen destroy)</p>
<p>I got a lot of experience in other languages especially Java but java can just declare a frame -&gt; run other things afterwards -&gt; call a <code>frame.dispose()</code> and that's just it. Any tips or suggestions for a learner?</p>
<blockquote>
<p>EDIT: The script actually is a image processing algorithm that connects to a database and I can't just put a timed wait or sleep since the database can be expanded and it might be take longer than the allocated time.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Something along these lines might work for you. This creates the window <code>root</code>, and defines a function <code>task</code> which destroys <code>root</code> as the last thing it does. In this example, <code>task</code> just sleeps for two seconds, but you'd replace that <code>sleep</code> call with whatever code you want to run.</p>
<p>You put the <code>task</code> function into the main loop event queue with <code>root.after(200, task)</code>. This means the code will first create the <code>root</code> window, wait 200 milliseconds, then call <code>task()</code>, which sleeps for two seconds and destroys the window. At least for this example you need the 200 millisecond delay so that the main loop has enough time to draw the window before the <code>sleep</code> call halts everything (the number might be different for you; increase it if the window doesn't draw properly).</p>
<pre><code>import tkinter as tk
from time import sleep

def task():
    # The window will stay open until this function call ends.
    sleep(2) # Replace this with the code you want to run
    root.destroy()

root = tk.Tk()
root.title("Example")

label = tk.Label(root, text="Waiting for task to finish.")
label.pack()

root.after(200, task)
root.mainloop()

print("Main loop is now over and we can do other stuff.")
</code></pre>
<p>Edit: Added a comment to the code.</p>
</div>
<span class="comment-copy">you need to use <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">threading</a> or <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer">subprocess</a> module.</span>
<span class="comment-copy">thanks for the response but i really want to make it as dynamic as possible and avoid timed scenario.</span>
<span class="comment-copy">I'm not exactly sure what you mean, but this doesn't depend on any of the timing used in my example. The <code>sleep</code> call is just a dummy replacement for the computation during which you want the window to stay open. The 200 ms delay in the queueing in just to give tk some time to render the window because the <code>sleep</code> would otherwise hang it.</span>
<span class="comment-copy">It worked. I had to learn how to use it and didn't understand it at first. Thanks</span>
