<div class="post-text" itemprop="text">
<p>I have a dictionary in python that has a dictionary within it and some values are placed in an array or list. </p>
<p>I want to print the dictionary to be all lowercase without changing anything else but the only code I have only iterates through values of a plain dict, it doesn't deal with arrays or lists. Any suggestions for how to fix this? Here's the code I have so far: </p>
<pre><code>new_data = {}
for i in range (0, len(json_file)):
    try: 
        data = json_file[i]['payload']
        for key, value in data.iteritems():
            new_data[value.lower()] = value
            print (new_data)
    except:
        continue
</code></pre>
<p>And this is the nested dictionary:</p>
<pre><code>{
  "payload": {
    "existence_full": 1,
    "geo_virtual": "[\"56.9459720|-2.1971226|20|within_50m|4\"]",
    "latitude": "56.945972",
    "locality": "Stonehaven",
    "_records_touched": "{\"crawl\":8,\"lssi\":0,\"polygon_centroid\":0,\"geocoder\":0,\"user_submission\":0,\"tdc\":0,\"gov\":0}",
    "address": "The Lodge, Dunottar",
    "email": "dunnottarcastle@btconnect.com",
    "existence_ml": 0.56942382176587,
    "domain_aggregate": "",
    "name": "Dunnottar Castle",
    "search_tags": [
      "Dunnottar Castle Aberdeenshire",
      "Dunotter Castle"
    ],
    "admin_region": "Scotland",
    "existence": 1,
    "category_labels": [
      [
        "Landmarks",
        "Buildings and Structures"
      ]
    ],
    "post_town": "Stonehaven",
    "region": "Kincardineshire",
    "review_count": "719",
    "geocode_level": "within_50m",
    "tel": "01569 762173",
    "placerank": 65,
    "longitude": "-2.197123",
    "placerank_ml": 37.279160734645,
    "fax": "01330 860325",
    "category_ids_text_search": "",
    "website": "http:\/\/www.dunnottarcastle.co.uk",
    "status": "1",
    "geocode_confidence": "20",
    "postcode": "AB39 2TL",
    "category_ids": [
      108
    ],
    "country": "gb",
    "_geocode_quality": "4"
  },
  "uuid": "3867aaf3-12ab-434f-b12b-5d627b3359c3"
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Nick A pointed out an interesting shortcut in the comments: Your dict looks like it's JSON-compatible. If so, can we just convert to JSON, lowercase that string, then convert back? There are a number of slightly different JSON standards: <a href="http://www.json.org/" rel="nofollow noreferrer">json.org</a>, <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf" rel="nofollow noreferrer">ECMA 404</a>, and RFCs <a href="https://tools.ietf.org/html/rfc4627" rel="nofollow noreferrer">4627</a>, <a href="https://tools.ietf.org/html/rfc7158" rel="nofollow noreferrer">7158</a>, <a href="https://tools.ietf.org/html/rfc7159" rel="nofollow noreferrer">7159</a>, and <a href="https://tools.ietf.org/html/rfc8259" rel="nofollow noreferrer">8259</a>. And then there's the way JSON is actually used in practice. And the way it's implemented by Python's <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer"><code>json</code></a> module. But I'll summarize here:</p>
<pre><code>lowered = json.loads(json.dumps(d, ensure_ascii=False).lower())
</code></pre>
<p>â€¦Â will work as long as:</p>
<ul>
<li>Your values are all of type <code>dict</code>, <code>list</code>, <code>str</code>, <code>float</code>, <code>int</code>, <code>bool</code>, and <code>NoneType</code>.</li>
<li>Your <code>dict</code> values only have <code>str</code> keys.</li>
<li>Your <code>list</code> and <code>dict</code> values aren't circular (e.g., <code>lst = []; lst.append(lst)</code>).</li>
<li>Your <code>float</code> values will never include <code>math.inf</code> or <code>math.nan</code>.</li>
<li>You're using a recent-ish Python (3.6 is fine), or will never have any non-BMP letters like <code>ðž¤€</code>.</li>
<li>You're using a recent-ish Python (3.6 is fine), or will never have any <code>int</code> values outside <code>range(-(2**53)+1, (2**53))</code>.</li>
</ul>
<p>Notice the <code>ensure_ascii=False</code>. This is necessary if you might have any non-ASCII letters, because <code>'Ã‰'.lower()</code> is <code>'Ã©'</code>, but <code>r'\u00c9'.lower()</code> does nothing.</p>
<p>For JSON that you receive over the wire or in a file, instead of creating it yourself with <code>dumps</code>, of course you can't trust strings to not be escaped.  But you can always <code>loads</code> it first, then <code>dumps</code> it to lowercase and <code>loads</code> again. (For this case, you might want to add <code>allow_nan=False</code> to catch <code>inf</code> and <code>nan</code> values early, where they're easier to debug.)</p>
<p>Using the third-party library <a href="https://pypi.org/project/simplejson/" rel="nofollow noreferrer"><code>simplejson</code></a> (which the stdlib <code>json</code> is based on) will probably eliminate the requirements for recent Python, and may provide workarounds for some other possible issues, but I haven't tried it.</p>
<hr/>
<p>If this hack isn't acceptable for whatever reason, the cleaner way to do it is to recurse through the structure. A simple version looks like this:</p>
<pre><code>def recursive_lower(obj):
    if isinstance(obj, str):
        return obj.lower()
    elif isinstance(obj, list):
        return [recursive_lower(elem) for elem in obj]
    elif isinstance(obj, dict):
        return {key.lower(): recursive_lower(value) for key, value in obj.items()}
    else:
        return obj
</code></pre>
<p>Of course the reason you're not using JSON is presumably that your types don't all map directly to JSON, which means they probably won't work with the above. But you can easily extend it as needed. For example:</p>
<p>To handle non-string keys, replace the <code>dict</code> clause:</p>
<pre><code>    elif isinstance(obj, dict):
        return {recursive_lower(key): recursive_lower(value) for key, value in obj.items()}
</code></pre>
<p>To handle <code>tuple</code>s and other sequences that aren't <code>list</code>s, replace the <code>list</code> clause (make sure this comes after the <code>str</code> check, because <code>str</code> is a <code>Sequence</code> typeâ€¦):</p>
<pre><code>    elif isinstance(obj, collections.abc.Sequence):
        return type(obj)(map(recursive_lower, obj))
</code></pre>
<p>To handle <code>bytes</code> (as pure ASCII strings), change the <code>str</code> part:</p>
<pre><code>    if isinstance(obj, (str, bytes)):
        return obj.lower()
</code></pre>
<p>To duck-type anything with a <code>lower</code> method (<code>str</code>, <code>bytes</code>, <code>bytearray</code>, various third-party types), change the <code>str</code> part:</p>
<pre><code>    try:
        return obj.lower()
    except AttributeError:
        pass
</code></pre>
<p>And so on.</p>
</div>
<span class="comment-copy"><code>json.loads(json.dumps(dict).lower())</code>?</span>
<span class="comment-copy">@NickA If you have  <code>Infinity</code> or <code>NaN</code> values, you can <code>loads</code> those (even if it's not part of the standard, it's common, and supported by Python), but not <code>infinity</code> or <code>nan</code>. Also, I can't remember if Python supports <code>\U</code> (also nonstandard but common), but if it does, calling <code>lower</code> will break that too.</span>
<span class="comment-copy">@abarnert True!, but with location data like in this case they're more unlikely, and hence a comment not an answer :)</span>
<span class="comment-copy">Anyway, <a href="https://gist.github.com/abarnert/f53dd428ea637aaba6c8efa5498ca92c" rel="nofollow noreferrer">you can write code that recurses through a JSON-style structure trivially</a>, and it's worth learning how to do that.</span>
<span class="comment-copy">@NickA Sure; I just wanted to point out the caveats. (I think those three are the only ones there are, and all three of them are nonstandard-but-common, which means it may well be the best answer for many use cases, as long as you understand that.)</span>
