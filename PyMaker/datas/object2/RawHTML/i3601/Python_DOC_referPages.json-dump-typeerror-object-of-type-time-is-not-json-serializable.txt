<div class="post-text" itemprop="text">
<p>I have a basic dict as follows:</p>
<pre><code>sample = {}
sample['title'] = "String"
sample['somedate'] = somedatetimehere
</code></pre>
<p>When I try to do <code>jsonify(sample)</code> I get:</p>
<p><code>TypeError: datetime.datetime(2012, 8, 8, 21, 46, 24, 862000) is not JSON serializable</code></p>
<p>What can I do such that my dictionary sample can overcome the error above?</p>
<p>Note: Though it may not be relevant, the dictionaries are generated from the retrieval of records out of mongodb where when I print out <code>str(sample['somedate'])</code>, the output is <code>2012-08-08 21:46:24.862000</code>.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Updated for 2018</h1>
<p>The original answer accommodated the way MongoDB "date" fields were represented as:</p>
<p><code>{"$date": 1506816000000}</code></p>
<p>If you want a generic Python solution for serializing <code>datetime</code> to json, check out <a href="https://stackoverflow.com/a/36142844/293064">@jjmontes' answer</a> for a quick solution which requires no dependencies.</p>
<hr/>
<p>As you are using mongoengine (per comments) and pymongo is a dependency, pymongo has built-in utilities to help with json serialization:<br/>
<a href="http://api.mongodb.org/python/1.10.1/api/bson/json_util.html" rel="noreferrer">http://api.mongodb.org/python/1.10.1/api/bson/json_util.html</a></p>
<p>Example usage (serialization):</p>
<pre><code>from bson import json_util
import json

json.dumps(anObject, default=json_util.default)
</code></pre>
<p>Example usage (deserialization):</p>
<pre><code>json.loads(aJsonString, object_hook=json_util.object_hook)
</code></pre>
<hr/>
<h2>Django</h2>
<p>Django provides a native <code>DjangoJSONEncoder</code> serializer that deals with this kind of properly.</p>
<p>See <a href="https://docs.djangoproject.com/en/dev/topics/serialization/#djangojsonencoder" rel="noreferrer">https://docs.djangoproject.com/en/dev/topics/serialization/#djangojsonencoder</a></p>
<pre><code>from django.core.serializers.json import DjangoJSONEncoder

return json.dumps(
  item,
  sort_keys=True,
  indent=1,
  cls=DjangoJSONEncoder
)
</code></pre>
<p>One difference I've noticed between <code>DjangoJSONEncoder</code> and using a custom <code>default</code> like this:</p>
<pre><code>import datetime
import json

def default(o):
    if isinstance(o, (datetime.date, datetime.datetime)):
        return o.isoformat()

return json.dumps(
  item,
  sort_keys=True,
  indent=1,
  default=default
)
</code></pre>
<p>Is that Django strips a bit of the data:</p>
<pre><code> "last_login": "2018-08-03T10:51:42.990", # DjangoJSONEncoder 
 "last_login": "2018-08-03T10:51:42.990239", # default
</code></pre>
<p>So, you may need to be careful about that in some cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>Building on other answers, a simple solution based on a specific serializer that just converts <code>datetime.datetime</code> and <code>datetime.date</code> objects to strings.</p>
<pre><code>from datetime import date, datetime

def json_serial(obj):
    """JSON serializer for objects not serializable by default json code"""

    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    raise TypeError ("Type %s not serializable" % type(obj))
</code></pre>
<p>As seen, the code just checks to find out if object is of class <code>datetime.datetime</code> or <code>datetime.date</code>, and then uses <code>.isoformat()</code> to produce a serialized version of it, according to ISO 8601 format, YYYY-MM-DDTHH:MM:SS (which is easily decoded by JavaScript). If more complex serialized representations are sought, other code could be used instead of str() (see other answers to this question for examples). The code ends by raising an exception, to deal with the case it is called with a non-serializable type.</p>
<p>This json_serial function can be used as follows:</p>
<pre><code>from datetime import datetime
from json import dumps

print dumps(datetime.now(), default=json_serial)
</code></pre>
<p>The details about how the default parameter to json.dumps works can be found in <a href="http://docs.python.org/2/library/json.html#basic-usage" rel="noreferrer">Section Basic Usage of the json module documentation</a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>My quick &amp; dirty JSON dump that eats dates and everything:</p>
<pre><code>json.dumps(my_dictionary, indent=4, sort_keys=True, default=str)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have just encountered this problem and my solution is to subclass <code>json.JSONEncoder</code>:</p>
<pre><code>from datetime import datetime
import json

class DateTimeEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, datetime):
            return o.isoformat()

        return json.JSONEncoder.default(self, o)
</code></pre>
<p>In your call do something like: <code>json.dumps(yourobj, cls=DateTimeEncoder)</code> The <code>.isoformat()</code> I got from one of the answers above.</p>
</div>
<div class="post-text" itemprop="text">
<p>Convert the date to a string</p>
<pre><code>sample['somedate'] = str( datetime.utcnow() )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For others who do not need or want to use the pymongo library for this.. you can achieve datetime JSON conversion easily with this small snippet:</p>
<pre><code>def default(obj):
    """Default JSON serializer."""
    import calendar, datetime

    if isinstance(obj, datetime.datetime):
        if obj.utcoffset() is not None:
            obj = obj - obj.utcoffset()
        millis = int(
            calendar.timegm(obj.timetuple()) * 1000 +
            obj.microsecond / 1000
        )
        return millis
    raise TypeError('Not sure how to serialize %s' % (obj,))
</code></pre>
<p>Then use it like so:</p>
<pre><code>import datetime, json
print json.dumps(datetime.datetime.now(), default=default)
</code></pre>
<p>output:Â </p>
<pre><code>'1365091796124'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution:</p>
<pre><code># -*- coding: utf-8 -*-
import json


class DatetimeEncoder(json.JSONEncoder):
    def default(self, obj):
        try:
            return super(DatetimeEncoder, obj).default(obj)
        except TypeError:
            return str(obj)
</code></pre>
<p>Then you can use it like that:</p>
<pre><code>json.dumps(dictionnary, cls=DatetimeEncoder)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have an application with a similar issue; my approach was to JSONize the datetime value as a 6-item list (year, month, day, hour, minutes, seconds); you could go to microseconds as a 7-item list, but I had no need to:</p>
<pre><code>class DateTimeEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime.datetime):
            encoded_object = list(obj.timetuple())[0:6]
        else:
            encoded_object =json.JSONEncoder.default(self, obj)
        return encoded_object

sample = {}
sample['title'] = "String"
sample['somedate'] = datetime.datetime.now()

print sample
print json.dumps(sample, cls=DateTimeEncoder)
</code></pre>
<p>produces:</p>
<pre><code>{'somedate': datetime.datetime(2013, 8, 1, 16, 22, 45, 890000), 'title': 'String'}
{"somedate": [2013, 8, 1, 16, 22, 45], "title": "String"}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This Q repeats time and time again - a simple way to patch the json module such that serialization would support datetime.  </p>
<pre><code>import json
import datetime

json.JSONEncoder.default = lambda self,obj: (obj.isoformat() if isinstance(obj, datetime.datetime) else None)
</code></pre>
<p>Than use json serialization as you always do - this time with datetime being serialized as isoformat.</p>
<pre><code>json.dumps({'created':datetime.datetime.now()})
</code></pre>
<p>Resulting in: '{"created": "2015-08-26T14:21:31.853855"}'</p>
<p>See more details and some words of caution at:
<a href="https://stackoverflow.com/questions/455580/json-datetime-between-python-and-javascript/32224522#32224522">StackOverflow: JSON datetime between Python and JavaScript</a></p>
</div>
<div class="post-text" itemprop="text">
<p>My solution (with less verbosity, I think):</p>
<pre><code>def default(o):
    if type(o) is datetime.date or type(o) is datetime.datetime:
        return o.isoformat()

def jsondumps(o):
    return json.dumps(o, default=default)
</code></pre>
<p>Then use <code>jsondumps</code> instead of <code>json.dumps</code>. It will print:</p>
<pre><code>&gt;&gt;&gt; jsondumps({'today': datetime.date.today()})
'{"today": "2013-07-30"}'
</code></pre>
<p>I you want, later you can add other special cases to this with a simple twist of the <code>default</code> method. Example:  </p>
<pre><code>def default(o):
    if type(o) is datetime.date or type(o) is datetime.datetime:
        return o.isoformat()
    if type(o) is decimal.Decimal:
        return float(o)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a simple solution to over come "datetime not JSON serializable"
problem. </p>
<pre><code>enco = lambda obj: (
    obj.isoformat()
    if isinstance(obj, datetime.datetime)
    or isinstance(obj, datetime.date)
    else None
)

json.dumps({'date': datetime.datetime.now()}, default=enco)
</code></pre>
<p><b>Output:-&gt;</b> {"date": "2015-12-16T04:48:20.024609"} </p>
</div>
<div class="post-text" itemprop="text">
<p>You have to supply a custom encoder class with the <code>cls</code> parameter of <code>json.dumps</code>. To quote from the <a href="http://docs.python.org/library/json.html" rel="noreferrer">docs</a>:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; class ComplexEncoder(json.JSONEncoder):
...     def default(self, obj):
...         if isinstance(obj, complex):
...             return [obj.real, obj.imag]
...         return json.JSONEncoder.default(self, obj)
...
&gt;&gt;&gt; dumps(2 + 1j, cls=ComplexEncoder)
'[2.0, 1.0]'
&gt;&gt;&gt; ComplexEncoder().encode(2 + 1j)
'[2.0, 1.0]'
&gt;&gt;&gt; list(ComplexEncoder().iterencode(2 + 1j))
['[', '2.0', ', ', '1.0', ']']
</code></pre>
<p>This uses complex numbers as the example, but you can just as easily create a class to encode dates (except I think JSON is a little fuzzy about dates)</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use <code>.strftime()</code> method on <code>.datetime.now()</code> method to making it as a <em>serializable</em> method.</p>
<p>Here's an example:</p>
<pre><code>from datetime import datetime

time_dict = {'time': datetime.now().strftime('%Y-%m-%dT%H:%M:%S')}
sample_dict = {'a': 1, 'b': 2}
sample_dict.update(time_dict)
sample_dict
</code></pre>
<p>Output:</p>
<pre><code>Out[0]: {'a': 1, 'b': 2, 'time': '2017-10-31T15:16:30'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The simplest way to do this is to change the part of the dict that is in datetime format to isoformat. That value will effectively be a string in isoformat which json is ok with.</p>
<pre><code>v_dict = version.dict()
v_dict['created_at'] = v_dict['created_at'].isoformat()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The json.dumps method can accept an optional parameter called default which is expected to be a function. Every time JSON tries to convert a value it does not know how to convert it will call the function we passed to it. The function will receive the object in question, and it is expected to return the JSON representation of the object.</p>
<pre><code>def myconverter(o):
 if isinstance(o, datetime.datetime):
    return o.__str__()

print(json.dumps(d, default = myconverter)) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if you are using python3.7, then the best solution is using
<a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.isoformat" rel="nofollow noreferrer"><code>datetime.isoformat()</code></a> and
<a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat" rel="nofollow noreferrer"><code>datetime.fromisoformat()</code></a>; they work with both naive and
aware <code>datetime</code> objects:</p>
<pre><code>#!/usr/bin/env python3.7

from datetime import datetime
from datetime import timezone
from datetime import timedelta
import json

def default(obj):
    if isinstance(obj, datetime):
        return { '_isoformat': obj.isoformat() }
    return super().default(obj)

def object_hook(obj):
    _isoformat = obj.get('_isoformat')
    if _isoformat is not None:
        return datetime.fromisoformat(_isoformat)
    return obj

if __name__ == '__main__':
    #d = { 'now': datetime(2000, 1, 1) }
    d = { 'now': datetime(2000, 1, 1, tzinfo=timezone(timedelta(hours=-8))) }
    s = json.dumps(d, default=default)
    print(s)
    print(d == json.loads(s, object_hook=object_hook))
</code></pre>
<p>output:</p>
<pre><code>{"now": {"_isoformat": "2000-01-01T00:00:00-08:00"}}
True
</code></pre>
<p>if you are using python3.6 or below, and you only care about the time value (not
the timezone), then you can use <code>datetime.timestamp()</code> and
<code>datetime.fromtimestamp()</code> instead;</p>
<p>if you are using python3.6 or below, and you do care about the timezone, then
you can get it via <code>datetime.tzinfo</code>, but you have to serialize this field
by yourself; the easiest way to do this is to add another field <code>_tzinfo</code> in the
serialized object;</p>
<p>finally, beware of precisions in all these examples;</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using the result in a view be sure to return a proper response. According to the API, jsonify does the following:</p>
<blockquote>
<p>Creates a Response with the JSON representation of the given arguments
  with an application/json mimetype.</p>
</blockquote>
<p>To mimic this behavior with json.dumps you have to add a few extra lines of code.</p>
<pre><code>response = make_response(dumps(sample, cls=CustomEncoder))
response.headers['Content-Type'] = 'application/json'
response.headers['mimetype'] = 'application/json'
return response
</code></pre>
<p>You should also return a dict to fully replicate jsonify's response. So, the entire file will look like this</p>
<pre><code>from flask import make_response
from json import JSONEncoder, dumps


class CustomEncoder(JSONEncoder):
    def default(self, obj):
        if set(['quantize', 'year']).intersection(dir(obj)):
            return str(obj)
        elif hasattr(obj, 'next'):
            return list(obj)
        return JSONEncoder.default(self, obj)

@app.route('/get_reps/', methods=['GET'])
def get_reps():
    sample = ['some text', &lt;datetime object&gt;, 123]
    response = make_response(dumps({'result': sample}, cls=CustomEncoder))
    response.headers['Content-Type'] = 'application/json'
    response.headers['mimetype'] = 'application/json'
    return response
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my full solution for converting datetime to JSON and back..</p>
<pre><code>import calendar, datetime, json

def outputJSON(obj):
    """Default JSON serializer."""

    if isinstance(obj, datetime.datetime):
        if obj.utcoffset() is not None:
            obj = obj - obj.utcoffset()

        return obj.strftime('%Y-%m-%d %H:%M:%S.%f')
    return str(obj)

def inputJSON(obj):
    newDic = {}

    for key in obj:
        try:
            if float(key) == int(float(key)):
                newKey = int(key)
            else:
                newKey = float(key)

            newDic[newKey] = obj[key]
            continue
        except ValueError:
            pass

        try:
            newDic[str(key)] = datetime.datetime.strptime(obj[key], '%Y-%m-%d %H:%M:%S.%f')
            continue
        except TypeError:
            pass

        newDic[str(key)] = obj[key]

    return newDic

x = {'Date': datetime.datetime.utcnow(), 34: 89.9, 12.3: 90, 45: 67, 'Extra': 6}

print x

with open('my_dict.json', 'w') as fp:
    json.dump(x, fp, default=outputJSON)

with open('my_dict.json') as f:
    my_dict = json.load(f, object_hook=inputJSON)

print my_dict
</code></pre>
<p>Output</p>
<pre><code>{'Date': datetime.datetime(2013, 11, 8, 2, 30, 56, 479727), 34: 89.9, 45: 67, 12.3: 90, 'Extra': 6}
{'Date': datetime.datetime(2013, 11, 8, 2, 30, 56, 479727), 34: 89.9, 45: 67, 12.3: 90, 'Extra': 6}
</code></pre>
<p>JSON File</p>
<pre><code>{"Date": "2013-11-08 02:30:56.479727", "34": 89.9, "45": 67, "12.3": 90, "Extra": 6}
</code></pre>
<p>This has enabled me to import and export strings, ints, floats and datetime objects.
It shouldn't be to hard to extend for other types.</p>
</div>
<div class="post-text" itemprop="text">
<p>Convert the <code>date</code>  to  <code>string</code></p>
<pre><code>date = str(datetime.datetime(somedatetimehere)) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Generally there are several ways to serialize datetimes, like:</p>
<ol>
<li>ISO string, short and can include timezone info, e.g. @jgbarah's <a href="https://stackoverflow.com/a/22238613/723090">answer</a></li>
<li>Timestamp (timezone data is lost), e.g. @JayTaylor's <a href="https://stackoverflow.com/a/15823348/723090">answer</a></li>
<li>Dictionary of  properties (including timezone).</li>
</ol>
<p>If you're okay with the last way, the <a href="https://github.com/mverleg/pyjson_tricks" rel="nofollow noreferrer">json_tricks</a> package handles dates, times and datetimes including timezones.</p>
<pre><code>from datetime import datetime
from json_tricks import dumps
foo = {'title': 'String', 'datetime': datetime(2012, 8, 8, 21, 46, 24, 862000)}
dumps(foo)
</code></pre>
<p>which gives:</p>
<pre><code>{"title": "String", "datetime": {"__datetime__": null, "year": 2012, "month": 8, "day": 8, "hour": 21, "minute": 46, "second": 24, "microsecond": 862000}}
</code></pre>
<p>So all you need to do is</p>
<pre><code>`pip install json_tricks`
</code></pre>
<p>and then import from <code>json_tricks</code> instead of <code>json</code>.</p>
<p>The advantage of not storing it as a single string, int or float comes when decoding: if you encounter just a string or especially int or float, you need to know something about the data to know if it's a datetime. As a dict, you can store metadata so it can be decoded automatically, which is what <code>json_tricks</code> does for you. It's also easily editable for humans.</p>
<p>Disclaimer: it's made by me. Because I had the same problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this one with an example to parse it:</p>
<pre><code>#!/usr/bin/env python

import datetime
import json

import dateutil.parser  # pip install python-dateutil


class JSONEncoder(json.JSONEncoder):

    def default(self, obj):
        if isinstance(obj, datetime.datetime):
            return obj.isoformat()
        return super(JSONEncoder, self).default(obj)


def test():
    dts = [
        datetime.datetime.now(),
        datetime.datetime.now(datetime.timezone(-datetime.timedelta(hours=4))),
        datetime.datetime.utcnow(),
        datetime.datetime.now(datetime.timezone.utc),
    ]
    for dt in dts:
        dt_isoformat = json.loads(json.dumps(dt, cls=JSONEncoder))
        dt_parsed = dateutil.parser.parse(dt_isoformat)
        assert dt == dt_parsed
        print(f'{dt}, {dt_isoformat}, {dt_parsed}')
        # 2018-07-22 02:22:42.910637, 2018-07-22T02:22:42.910637, 2018-07-22 02:22:42.910637
        # 2018-07-22 02:22:42.910643-04:00, 2018-07-22T02:22:42.910643-04:00, 2018-07-22 02:22:42.910643-04:00
        # 2018-07-22 06:22:42.910645, 2018-07-22T06:22:42.910645, 2018-07-22 06:22:42.910645
        # 2018-07-22 06:22:42.910646+00:00, 2018-07-22T06:22:42.910646+00:00, 2018-07-22 06:22:42.910646+00:00


if __name__ == '__main__':
    test()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually it is quite simple.
If you need to often serialize dates, then work with them as strings. You can easily convert them back as datetime objects if needed.</p>
<p>If you need to work mostly as datetime objects, then convert them as strings before serializing. </p>
<pre><code>import json, datetime

date = str(datetime.datetime.now())
print(json.dumps(date))
"2018-12-01 15:44:34.409085"
print(type(date))
&lt;class 'str'&gt;

datetime_obj = datetime.datetime.strptime(date, '%Y-%m-%d %H:%M:%S.%f')
print(datetime_obj)
2018-12-01 15:44:34.409085
print(type(datetime_obj))
&lt;class 'datetime.datetime'&gt;
</code></pre>
<p>As you can see, the output is the same in both cases. Only the type is different.</p>
</div>
<div class="post-text" itemprop="text">
<p>My solution ...</p>
<pre><code>from datetime import datetime
import json

from pytz import timezone
import pytz


def json_dt_serializer(obj):
    """JSON serializer, by macm.
    """
    rsp = dict()
    if isinstance(obj, datetime):
        rsp['day'] = obj.day
        rsp['hour'] = obj.hour
        rsp['microsecond'] = obj.microsecond
        rsp['minute'] = obj.minute
        rsp['month'] = obj.month
        rsp['second'] = obj.second
        rsp['year'] = obj.year
        rsp['tzinfo'] = str(obj.tzinfo)
        return rsp
    raise TypeError("Type not serializable")


def json_dt_deserialize(obj):
    """JSON deserialize from json_dt_serializer, by macm.
    """
    if isinstance(obj, str):
        obj = json.loads(obj)
    tzone = timezone(obj['tzinfo'])
    tmp_dt = datetime(obj['year'],
                      obj['month'],
                      obj['day'],
                      hour=obj['hour'],
                      minute=obj['minute'],
                      second=obj['second'],
                      microsecond=obj['microsecond'])
    loc_dt = tzone.localize(tmp_dt)
    deserialize = loc_dt.astimezone(tzone)
    return deserialize    
</code></pre>
<p>Ok, now some tests.</p>
<pre><code># Tests
now = datetime.now(pytz.utc)

# Using this solution
rsp = json_dt_serializer(now)
tmp = json_dt_deserialize(rsp)
assert tmp == now
assert isinstance(tmp, datetime) == True
assert isinstance(now, datetime) == True

# using default from json.dumps
tmp = json.dumps(datetime.now(pytz.utc), default=json_dt_serializer)
rsp = json_dt_deserialize(tmp)
assert isinstance(rsp, datetime) == True

# Lets try another timezone
eastern = timezone('US/Eastern')
now = datetime.now(eastern)
rsp = json_dt_serializer(now)
tmp = json_dt_deserialize(rsp)

print(tmp)
# 2015-10-22 09:18:33.169302-04:00

print(now)
# 2015-10-22 09:18:33.169302-04:00

# Wow, Works!
assert tmp == now
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I got the same error message while writing the serialize decorator inside a Class  with sqlalchemy. So instead of :</p>
<pre><code>Class Puppy(Base):
    ...
    @property
    def serialize(self):
        return { 'id':self.id,
                 'date_birth':self.date_birth,
                  ...
                }
</code></pre>
<p>I  simply borrowed jgbarah's idea of using isoformat() and appended the original value with isoformat(), so that it now looks like:</p>
<pre><code>                  ...
                 'date_birth':self.date_birth.isoformat(),
                  ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A quick fix if you want your own formatting</p>
<pre><code>for key,val in sample.items():
    if isinstance(val, datetime):
        sample[key] = '{:%Y-%m-%d %H:%M:%S}'.format(val) #you can add different formating here
json.dumps(sample)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are on both sides of the communication you can use <strong>repr()</strong> and <strong>eval()</strong> functions along with json.</p>
<pre><code>import datetime, json

dt = datetime.datetime.now()
print("This is now: {}".format(dt))

dt1 = json.dumps(repr(dt))
print("This is serialised: {}".format(dt1))

dt2 = json.loads(dt1)
print("This is loaded back from json: {}".format(dt2))

dt3 = eval(dt2)
print("This is the same object as we started: {}".format(dt3))

print("Check if they are equal: {}".format(dt == dt3))
</code></pre>
<p>You shouldn't import datetime as</p>
<pre><code>from datetime import datetime
</code></pre>
<p>since eval will complain. Or you can pass datetime as a parameter to eval. In any case this should work.</p>
</div>
<div class="post-text" itemprop="text">
<p>I had encountered same problem when externalizing django model object to dump as JSON.
Here is how you can solve it.</p>
<pre><code>def externalize(model_obj):
  keys = model_obj._meta.get_all_field_names() 
  data = {}
  for key in keys:
    if key == 'date_time':
      date_time_obj = getattr(model_obj, key)
      data[key] = date_time_obj.strftime("%A %d. %B %Y")
    else:
      data[key] = getattr(model_obj, key)
  return data
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def j_serial(o):     # self contained
    from datetime import datetime, date
    return str(o).split('.')[0] if isinstance(o, (datetime, date)) else None
</code></pre>
<p>Usage of above utility:</p>
<pre><code>import datetime
serial_d = j_serial(datetime.datetime.now())
if serial_d:
    print(serial_d)  # output: 2018-02-28 02:23:15
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I may not 100% correct but,
this is the simple way to do serialize</p>
<pre><code>#!/usr/bin/python
import datetime,json

sampledict = {}
sampledict['a'] = "some string"
sampledict['b'] = datetime.datetime.now()

print sampledict   # output : {'a': 'some string', 'b': datetime.datetime(2017, 4, 15, 5, 15, 34, 652996)}

#print json.dumps(sampledict)

'''
output : 

Traceback (most recent call last):
  File "./jsonencodedecode.py", line 10, in &lt;module&gt;
    print json.dumps(sampledict)
  File "/usr/lib/python2.7/json/__init__.py", line 244, in dumps
    return _default_encoder.encode(obj)
  File "/usr/lib/python2.7/json/encoder.py", line 207, in encode
    chunks = self.iterencode(o, _one_shot=True)
  File "/usr/lib/python2.7/json/encoder.py", line 270, in iterencode
    return _iterencode(o, 0)
  File "/usr/lib/python2.7/json/encoder.py", line 184, in default
    raise TypeError(repr(o) + " is not JSON serializable")
TypeError: datetime.datetime(2017, 4, 15, 5, 16, 17, 435706) is not JSON serializable


'''

sampledict['b'] = datetime.datetime.now().strftime("%B %d, %Y %H:%M %p")

afterdump = json.dumps(sampledict)

print afterdump  #output : {"a": "some string", "b": "April 15, 2017 05:18 AM"}

print type(afterdump) #&lt;type 'str'&gt;


afterloads = json.loads(afterdump) 

print afterloads # output : {u'a': u'some string', u'b': u'April 15, 2017 05:18 AM'}


print type(afterloads) # output :&lt;type 'dict'&gt; 
</code></pre>
</div>
<span class="comment-copy">Is this specifically python in general, or possibly django?</span>
<span class="comment-copy">It technically is specifically python, I am not using django, but retrieving records out of mongodb.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/455580/json-datetime-between-python-and-javascript">JSON datetime between Python and JavaScript</a></span>
<span class="comment-copy">Are you using pymongo?</span>
<span class="comment-copy">The linked question is essentially telling you not to try to serialize the datetime object, but rather to convert it to a string in the common ISO format before serializing.</span>
<span class="comment-copy">Is it good/bad practice to be mixing multiple libraries i.e. having mongoengine for inserting docs and pymongo for query/retrieval?</span>
<span class="comment-copy">Its not bad practice, it just implies some dependency on the libraries that your main library uses. If you can't accomplish what you need from mongoengine, then you drop down to pymongo. Its the same with <code>Django MongoDB</code>. With the later, you would try to stay within the django ORM to maintain backend agnostic state. But sometimes you can't do what you need in the abstraction, so you drop down a layer. In this case, its completely unrelated to your problem since you are just using utility methods to accompany the JSON format.</span>
<span class="comment-copy">I am trying this out with Flask and it appears that by using json.dump, I am unable to put a jsonify() wrapper around it such that it returns in application/json. Attempting to do return jsonify(json.dumps(sample, default=json_util.default))</span>
<span class="comment-copy">@amit Its not so much about memorizing syntax, as it is about getting good at reading documentation and storing enough info in my head to recognise where and when I need to retrieve it again. In this case, one might say "Oh a custom object with json" and then quickly refresh on that usage</span>
<span class="comment-copy">@guyskk I haven't tracked changes in bjson or mongo since I wrote this 5 years ago. But if you want control over the serialisation of the datetime then you need to write your own default handler function as illustrated in the answer given by  jgbarah</span>
<span class="comment-copy">yeah the correct answer, more pretty import datetime and if isinstance(obj, datetime.datetime) , I lost many time because don't used from datetime import datetime , anyway thanks</span>
<span class="comment-copy">but this does not explain how to deserialise it with the correct type, isnt it ?</span>
<span class="comment-copy">No, @BlueTrin , nothing said about that. In my case, I'm deserializing in JavaScript, which works out of the box.</span>
<span class="comment-copy">This will cause unexpected behavior if the json module ever updates to include serialization of datetime objects.</span>
<span class="comment-copy">I'm worried that the error messages this replaces will be less helpful, and that it woudln't work on non-datatime values at all. I don't fully understand the api this working with. All I expect is that you'd have to call the base class in the default case like <a href="http://stackoverflow.com/a/27058505/1695680">stackoverflow.com/a/27058505/1695680</a> does.</span>
<span class="comment-copy">This is awesome, But unfortunately I did not understand what happened? Can anyone explain this answer?</span>
<span class="comment-copy">@KishorPawar: <code>default</code> is a function applied to objects that aren't serializable. In this case it's <code>str</code>, so it just converts everything it doesn't know to strings. Which is great for serialization but not so great when deserializing (hence the "quick &amp; dirty") as anything might have been string-ified without warning, e.g. a function or numpy array.</span>
<span class="comment-copy">@Mark awesome. Thanks. Useful when you know type of those non-serializable values like dates.</span>
<span class="comment-copy">I don't think you need the indent or sort_keys</span>
<span class="comment-copy">@MrMesees indeed they are not required but I kept them in the example for didactic purposes.</span>
<span class="comment-copy">upped because implementing a custom JSONEncoder should be the proper way to go</span>
<span class="comment-copy">Not only should this be the top answer, this should be part of the regular json encoder. If only decoding was less ambiguous..</span>
<span class="comment-copy">For those using Django, see <code>DjangoJSONEncoder</code>. <a href="https://docs.djangoproject.com/en/dev/topics/serialization/#djangojsonencoder" rel="nofollow noreferrer">docs.djangoproject.com/en/dev/topics/serialization/â¦</a></span>
<span class="comment-copy">Super helpful. Last line could be <code>return super(DateTimeEncoder, self).default(o)</code></span>
<span class="comment-copy">With Python 3 the last line is even simpler: <code>return super().default(o)</code></span>
<span class="comment-copy">And how could I deserialize it in Python?</span>
<span class="comment-copy">The problem is if you have many datetime objects embedded deeply in a data structure, or they are random. This isn't a reliable method.</span>
<span class="comment-copy">Simple solution, but it comes in trade of efficiency..</span>
<span class="comment-copy">to deserialize: <code>oDate = datetime.datetime.strptime(sDate, '%Y-%m-%d %H:%M:%S.%f')</code>.  Formats obtained from:  <a href="https://docs.python.org/2/library/datetime.html" rel="nofollow noreferrer">docs.python.org/2/library/datetime.html</a></span>
<span class="comment-copy">Downvoted as it ignores timezone information. Keep in mind that <code>.now()</code> uses local time, without indicating this. At least <code>.utcnow()</code> should be used (and then a +0000 or Z appended)</span>
<span class="comment-copy">Shouldn't <code>millis=</code> be indented inside the if statement? It's also probably better to use str(obj) to get the ISO format which I would think is more common.</span>
<span class="comment-copy">Why would you want it to be indented?  This snippet works and the resulting output can easily be deserialized/parsed from javascript.</span>
<span class="comment-copy">Because obj may not be a [time, date, datetime] object</span>
<span class="comment-copy">your example is incorrect if the local timezone has non-zero UTC offset (most of them). <code>datetime.now()</code> returns local time (as a naive datetime object) but your code assumes that <code>obj</code> is in UTC if it is not timezone-aware. Use <code>datetime.utcnow()</code> instead.</span>
<span class="comment-copy">Adjusted it to raise a type error if obj is unrecognized as per the Python documentation recommendation at <a href="https://docs.python.org/2/library/json.html#basic-usage" rel="nofollow noreferrer">docs.python.org/2/library/json.html#basic-usage</a>.</span>
<span class="comment-copy">agree.  Much better, at least out of the mongodb context.  You can do <code>isinstance(obj, datetime.datetime)</code> within the TypeError, add more types to handle, and finish up with the <code>str(obj)</code> or <code>repr(obj)</code>.  And all your dumps can just point to this specialized class.</span>
<span class="comment-copy">Fails to work if the time saved is saved by doing datetime.utcnow()</span>
<span class="comment-copy">What error are you seeing with datetime.utcnow()?  It works okay for me.</span>
<span class="comment-copy">Monkey patch FTW. The nasty thing is of course that this modifies the behaviour of the json module in your whole application, which may surprise others in a large application, so should generally be used with care imho.</span>
<span class="comment-copy">You should use isinstance(o, (datetime.date, datetime.datetime,)). Probably wouldn't hurt to include datetime.time too.</span>
<span class="comment-copy">I don't think this is a good solution anymore. Probably the conversions should take a more privileged place -- and also a more understandable place -- in your code, so you know what you are converting to when you put things into a database, or whatever, instead of having everything being done by a transparent function. But I don't know.</span>
<span class="comment-copy">JSON is good for serialising data for processing later. You may not know exactly what that data is. And you shouldn't need to. Serialising JSON should just work. Just like converting unicode to ascii should. Python's inability to do this without obscure functions makes it annoying to use. Database validation is a separate issue IMO.</span>
<span class="comment-copy">No, it shouldn't "just work". If you don't know how the serialization occurred and has to access the data later from another program/language, then you're lost.</span>
<span class="comment-copy">JSON is commonly used for strings, ints, floats, dates (I'm sure others use currency, temperatures, commonly too). But datetime is part of the standard library and should support de/serialisation. If it wasn't for this question, I'd still be manually searching my incredibly complex json blobs (which I didn't always create the structure for) for dates and serialising them 1 by 1.</span>
<span class="comment-copy">Thanks, worked for me!</span>
<span class="comment-copy">Question has nothing to do with flask.</span>
<span class="comment-copy">The question is about python. My answer solves the question using python. The OP did not say if the solution should include or exclude certain libraries. It is also useful for anyone else reading this question who wants an alternative to <code>pymongo</code>.</span>
<span class="comment-copy">They question is both about Python and <i>not</i> about Flask. Flask is not even needed in your answer to the question, so I suggest you remove it.</span>
<span class="comment-copy">It explodes in Python 3 with <code>TypeError: 'str' does not support the buffer interface</code>. It is because of <code>'wb'</code> open mode, should be <code>'w'</code>. It also blows in deserialization when we have data similar to date like <code>'0000891618-05-000338'</code> but not matching pattern.</span>
<span class="comment-copy">Thanks updated answer to reflect this</span>
<span class="comment-copy">jjmontes answer does exactly that, but without the necessity to do it explicitly for every date...</span>
<span class="comment-copy">And how about a decoder?</span>
<span class="comment-copy">Could use an explanation of the code...</span>
