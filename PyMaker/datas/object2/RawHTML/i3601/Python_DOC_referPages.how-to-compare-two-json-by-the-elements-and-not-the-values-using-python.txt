<div class="post-text" itemprop="text">
<p>For example, let's say I have to dictionaries:</p>
<pre><code>d_1 = {'peter': 1, 'adam': 2, 'david': 3}
</code></pre>
<p>and</p>
<pre><code>d_2 = {'peter': 14, 'adam': 44, 'david': 33, 'alan': 21}
</code></pre>
<p>What's the cleverest way to check whether the two dictionaries contain the same set of keys? In the example above it should return <code>False</code> because <code>d_2</code> contains the <code>'alan'</code> key, which <code>d_1</code> doesn't. Please note that I am not interested in checking that the associated values for each and every key are the same, just that the set of keys are the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can get the keys for a dictionary with dict.keys().</p>
<p>You can turn this into a set with set(dict.keys())</p>
<p>You can compare sets with ==</p>
<p>To sum up:</p>
<pre><code>set(d_1.keys()) == set(d_2.keys())
</code></pre>
<p>will give you what you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python2,</p>
<pre><code>set(d_1) == set(d_2)
</code></pre>
<p>In Python3, you can do this which may be a tiny bit more efficient than creating sets</p>
<pre><code>d1.keys() == d2.keys()
</code></pre>
<p>although the Python2 way would work too</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li><p>In Python 3, <a href="https://docs.python.org/3/library/stdtypes.html#dict.keys" rel="nofollow noreferrer"><code>dict.keys()</code></a> returns a "<a href="https://docs.python.org/3/library/stdtypes.html#dict-views" rel="nofollow noreferrer">view object</a>" that can be used like a set.  This is much more efficient than constructing a separate set.</p>
<pre><code>d_1.keys() == d_2.keys()
</code></pre></li>
<li><p>In Python 2.7, <a href="https://docs.python.org/2/library/stdtypes.html#dict.viewkeys" rel="nofollow noreferrer"><code>dict.viewkeys()</code></a> does the same thing.</p>
<pre><code>d_1.viewkeys() == d_2.viewkeys()
</code></pre></li>
<li><p>In Python 2.6 and below, you have to construct a set of the keys of each dict.</p>
<pre><code>set(d_1) == set(d_2)
</code></pre>
<p>Or you can iterate over the keys yourself for greater memory efficiency.</p>
<pre><code>len(d_1) == len(d_2) and all(k in d_2 for k in d_1)
</code></pre></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; not set(d_1).symmetric_difference(d_2)
False
&gt;&gt;&gt; not set(d_1).symmetric_difference(dict.fromkeys(d_1))
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way is to check for <a href="http://docs.python.org/library/sets.html" rel="nofollow noreferrer">symmetric difference</a> (new set with elements in either s or t but not both):</p>
<pre><code>set(d_1.keys()).symmetric_difference(set(d_2.keys()))
</code></pre>
<p>But a shorter way it to just compare the sets:</p>
<pre><code>set(d_1) == set(d_2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A quick option (not sure if its the most optimal)</p>
<pre><code>len(set(d_1.keys()).difference(d_2.keys())) == 0
</code></pre>
</div>
<span class="comment-copy">you don't need <code>keys</code> there.</span>
<span class="comment-copy">Even easier than this, since set(dict) gives just the keys...</span>
<span class="comment-copy">True, you don't need the keys, but if you don't use sets very often I'd say that the behaviour of set(dictionary) is non-obvious.  Does anyone know if using keys introduces a performance hit?</span>
<span class="comment-copy">@xorsyst: in Python 2 <code>iter(a_dict)</code> returns an iterator, <code>a_dict.keys()</code> returns a list; therefore, <code>set(d_1.keys())</code> incurs the creation and destruction of a temporary list of the dictionary keys. In Python 3, they're equivalent.</span>
<span class="comment-copy">@Joschua: If you are familiar with list(some_dict), then I agree set(some_dict) should be pretty obvious.  But to me, it's not at all obvious that these would work the way they do.  My first expectation is that list(some_dict) would be a list of (key, value) tuples.  I agree that returning just the keys is a useful behaviour, but I wouldn't say it was "obvious".</span>
<span class="comment-copy">+1 for the Python 3 way</span>
<span class="comment-copy">SilentGhost's reply will return false if the keys are the same but the values are different</span>
<span class="comment-copy">Checking for len == 0 is probably the most unpythonic thing.</span>
<span class="comment-copy">@Alex Nope.  Try it yourself.</span>
