<div class="post-text" itemprop="text">
<p>I wrote a Machine Learning script which I want to control from the command line. I already parsed all the options like for example --optimize 400, to perform 400 iterations over a RandomizedSearchCV grid. 
However, I'm struggeling with one thing: I want to choose my estimator, for example GradientBoostingRegressor() or Lasso(), from the command line. I tried two things:</p>
<pre><code>def cli()
    p = arg.ArgumentParser(description="Perform ML regression.")
    p.add_argument("-e","--estimator",default=Lasso(), help="Choose between Lasso() and GradientBoostingRegressor()")
return p.parse_args()
args = cli()
estimator = args.estimator
</code></pre>
<p>But when I try to open the program with:</p>
<pre><code>python script.py -e GradientBoostingRegressor()
</code></pre>
<p>I get errors, because of the "()", and also without the (), because it gets interpreted as a string.</p>
<p>Another thing I tried is: </p>
<pre><code>def cli()
    p = arg.ArgumentParser(description="Perform ML regression.")
    group = p.add_mutually_exclusive_group()
    group.add_argument("-SVR", nargs='?', default = SVR(),
                   help="Choose Suppor Vector Regression")
group.add_argument("-GBR", nargs='?', default = GradientBoostingRegressor())
return p.parse_args()
args = cli()
</code></pre>
<p>But now I dont know how to access the estimator and also it seems like  when I call the programm like this:</p>
<pre><code>python script.py -SVR
</code></pre>
<p>the namespace "args" holds SVR=None and GBR=GradientBoostingRegressor(default_GBR_options), which is exactly the opposite to what I want.</p>
<p>Ideally I could choose between -SVR and -GBR in the command line and the parser would pass it just like my other options and I could initialize an object like this: </p>
<pre><code>estimator = args.estimator
</code></pre>
<p>I hope anybody has some information on how to do that. 
Thank you very much!</p>
</div>
<div class="post-text" itemprop="text">
<p>Arguments are always just strings. You need to parse the string to get a function which you can call.</p>
<pre><code>import argparse

def Lasso():
    print("Lasso!")


def GradientBoostingRegressor():
    print("GradientBoostingRegressor!")


class GetEstimator(argparse.Action):
    estimators = {
            "Lasso": Lasso,
            "GBR": GradientBoostingRegressor,
            }
    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, self.estimators[values])


p = argparse.ArgumentParser()
p.add_argument( "-e", "--estimator", action=GetEstimator, default=Lasso, choices=GetEstimaor.estimators.keys())
args = p.parse_args()
args.estimator()    
</code></pre>
<p>(This replaces a previous answer that used the <code>type</code> parameter to map a string argument to a function. I misunderstood how <code>type</code> and <code>choices</code> interact.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you could separate input from functionality.
First collect the input from the user, then according to the input run the functionality that the user requested.</p>
<p>For example, if the user ran:</p>
<pre><code>python script.py -e GradientBoostingRegressor
</code></pre>
<p>you would do:</p>
<pre><code>if args.estimator == "GradientBoostingRegressor":
    do stuff...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While @chepner's use of <code>type</code> is a nice use of <code>argparse</code>, the approach can be difficult to get right and understand.</p>
<p>As written it raises an error in the <code>add_argument</code> method:</p>
<pre><code>Traceback (most recent call last):
  File "stack50799294.py", line 18, in &lt;module&gt;
    p.add_argument("-e", "--estimator", type=estimators.get, default=Lasso, choices=estimators.keys())
  File "/usr/lib/python3.6/argparse.py", line 1346, in add_argument
    type_func = self._registry_get('type', action.type, action.type)
  File "/usr/lib/python3.6/argparse.py", line 1288, in _registry_get
    return self._registries[registry_name].get(value, default)
TypeError: unhashable type: 'dict'
</code></pre>
<p>It's testing that the <code>type</code> parameter is either an item in the <code>registry</code>, or that it's a valid function.  I'm not sure why it's raising this error.</p>
<pre><code>def mytype(astr):
    return estimators.get(astr)
</code></pre>
<p>works better in <code>type=mytype</code>.  But there's further level of difficulty - <code>choices</code> is the <code>keys()</code>, strings.  But <code>mytype</code> returns a class, producing an error like:</p>
<pre><code>0942:~/mypy$ python3 stack50799294.py -e GBR
usage: stack50799294.py [-h] [-e {Lasso,GBR}]
stack50799294.py: error: argument -e/--estimator: invalid choice: &lt;class '__main__.GradientBoostingRegressor'&gt; (choose from 'Lasso', 'GBR')
</code></pre>
<p>To avoid those difficulties, I'd suggest separating the argument to class mapping. This should be easier to understand and to expand:</p>
<pre><code>import argparse

class Lasso():pass
class GradientBoostingRegressor():pass

# Map an easy-to-type string to each function
estimators = {
  'Lasso': Lasso,
  'GBR': GradientBoostingRegressor
}

p = argparse.ArgumentParser(description="Perform ML regression.")
p.add_argument("-e", "--estimator", default='Lasso', choices=estimators.keys())

args = p.parse_args()

print(args)
estimator = estimators.get(args.estimator, None)
if estimator is not None:
    print(type(estimator()))
</code></pre>
<p>samples:</p>
<pre><code>0946:~/mypy$ python3 stack50799294.py -e GBR
Namespace(estimator='GBR')
&lt;class '__main__.GradientBoostingRegressor'&gt;
0946:~/mypy$ python3 stack50799294.py 
Namespace(estimator='Lasso')
&lt;class '__main__.Lasso'&gt;
0946:~/mypy$ python3 stack50799294.py -e Lasso
Namespace(estimator='Lasso')
&lt;class '__main__.Lasso'&gt;
0946:~/mypy$ python3 stack50799294.py -e lasso
usage: stack50799294.py [-h] [-e {Lasso,GBR}]
stack50799294.py: error: argument -e/--estimator: invalid choice: 'lasso' (choose from 'Lasso', 'GBR')
</code></pre>
<h2><code>const</code> parameter</h2>
<p>You could use <code>store_const</code> to choose between 2 classes, a <code>default</code> and a <code>const</code>:</p>
<pre><code>parser.add_argument('-e', action='store_const', default=Lasso(), const=GradientBoostingRegressor())
</code></pre>
<p>but that can't be generalized to more.  `nargs='?' provides a 3 way choice - default, const, and user provided.  But there's still the problem of converting the commandline string to a class object.</p>
<p>Subparsers, <a href="https://docs.python.org/3/library/argparse.html#sub-commands" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#sub-commands</a>, shows how <code>set_defaults</code> can be used to set functions or classes.  But to use this you have to define a subparser for each choice.</p>
<p>In general it's better to start with the simple <code>argparse</code> approach, accepting strings and string choices, and doing the mapping after.  Using more <code>argparse</code> features can come later.</p>
<h2><code>get</code> error</h2>
<p><code>@chepner's</code> error has something to do with how Python views the <code>d.get</code> method.  Even though it looks like a method, it's somehow seeing the <code>dict</code> rather than the method:</p>
<pre><code>In [444]: d = {}
In [445]: d.get(d.get)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-445-c6d679ba4e8d&gt; in &lt;module&gt;()
----&gt; 1 d.get(d.get)

TypeError: unhashable type: 'dict'
In [446]: def foo(astr):
     ...:     return d.get(astr)
     ...: 
     ...: 
In [447]: d.get(foo)
</code></pre>
<p>That could be viewed as a basic python bug, or a argparse bug, but a user defined function or lambda is an easy work around.</p>
</div>
<span class="comment-copy">Please include the error messages in your question by editing it.</span>
<span class="comment-copy">I like this solution very much, since its easy to add additional estimators. However when I apply it I get an error:  TypeError: unhashable type: 'dict'  I think this is cause by the type=estimators.get part of the function but I dont know how to fix it.</span>
<span class="comment-copy">That error occurs during the <code>add_argument</code> call.</span>
<span class="comment-copy">Hm, not sure what causes that error. Looks like you can work around it with <code>type=lambda s: estimators[s]</code>, though.</span>
<span class="comment-copy">This workaround works only if you also set choices=estimators.values(). Other than that its great! Thank you.</span>
<span class="comment-copy"><code>choices</code> should <i>absolutely</i> be <code>estimators.keys()</code>; you want the arguments to be the (string) keys of the <code>dict</code>, not the (function) values.</span>
<span class="comment-copy">Hey thanks for the detailes answer. I think the definitino of the mytype function together with choices=estimators.values() should work as well? I decided against the possibility of doing parsing and mapping sequentially because I plan on having the mapping function outside my main program, so the dictionary estimators is not known to my parsing function and my main function. So I would have to hand it over from main to parsingfunction.</span>
