<div class="post-text" itemprop="text">
<p>I have a base class which has a <code>__init__</code> that takes two parameters. I want to create a derived class object, given that I have a base class object.
I want to do the following,</p>
<pre><code>a_obj = A(10, 'f') 
## given that I have a_obj, create b_obj
b_obj = B(a_obj)
</code></pre>
<p>and get a result such that</p>
<pre><code>type(b_obj) =&gt; B

print(b_obj.age) =&gt; 10
print(b_obj.sex) =&gt; "f"
</code></pre>
<p>I tried the following, where the <code>__new__</code> of B would call A's <code>__new__</code> and ask it to create an object of type B(an empty object). But at this point I dont know how to set B to have all the functionalities of A.</p>
<pre><code>class A:
  def __init__(self, age, sex):
    self.age = age
    self.sex = sex

class B(A):
  def __new__(cls, a_obj):
    a_class = a_obj.__class__
    b_obj = a_class.__new__(cls)
    a_class.__init__(b_obj, a_obj) #doesnt work since A's init takes 2 params
</code></pre>
<p>Is there a better way than to typecast the given A's object to B?
( i.e <code>a_obj.__classs__ = b_obj</code> )</p>
<p><strong>Edit:</strong>
  B is a dynamically created class(using type). So B wouldnt know beforehand what are the parameters that A's <code>__init__</code> would take.</p>
</div>
<div class="post-text" itemprop="text">
<p>The simple way, by passing <code>a</code>'s attributes in a call to <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">super</a></p>
<pre><code>class A:
  def __init__(self, age, sex):
      self.age = age
      self.sex = sex

class B(A):
    def __init__(self, a):
         """a is an instance of A"""
         super().__init__(a.age, a.sex)
</code></pre>
<hr/>
<p>In answer to "what if B was a dynamically generated class? B doesnt know what A's params are", that is a lot harder, and requires some true python hacking.</p>
<pre><code>class B(A):
    def __init__(self, a):
        self.__dict__.update(a.__dict__)
</code></pre>
<p>I do not endorse doing this. It is bad coding practise and possibly error prone. </p>
</div>
<div class="post-text" itemprop="text">
<p>Quite simply, pass <code>a_object.age</code> and <code>a_object.sex</code> to the parent constructor.</p>
<pre><code>class A(object):
  def __init_(self, age, sex):
    self.age = age
    self.sex = sex

class B(A):
  def __init__(self, a):
      super(B, self).__init__(a.age, a.sex)
</code></pre>
<p>Now note that one usually expects subclasses to be compatible with their parents, which is not the case here.</p>
<p>Edit: to answer the additional question "what if B is dynamically generated and doesn't know  beforehand what are the parameters that A's <strong>init</strong> would take", the canonical solution is to use varargs and keyword args:</p>
<pre><code>class B(A):
    def __init__(self, *args, **kwargs):
        super(B, self).__init__(*args, **kawargs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, with the example it's not clear whether inheritance will be used for any purpose other than a properties access.
If getting all the object fields is only thing you want, I guess, it's not necessary to use inheritance. </p>
<p>Since every object in python has <a href="https://docs.python.org/3/library/stdtypes.html#object.__dict__" rel="nofollow noreferrer"><strong>dict</strong></a> property, you can just copy it:</p>
<pre><code>class A:
    def __init__(self, age, sex):
        self.age = age
        self.sex = sex

class B:
    def __init__(self, a_obj):
        self.__dict__ = a_obj.__dict__.copy()

if __name__ == "__main__":
    a_obj = A(10, "f")
    b_obj = B(a_obj)

    print(type(b_obj)) # B

    # Works as expected.
    print(b_obj.age)
    print(b_obj.sex)
</code></pre>
<p>Although provided example will work as-well with inheritance, but in that case I'd hardly suggest to use parent constructor as described above.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe using <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><strong>getattr</strong></a>, within class B,</p>
<pre><code>class B:
    def __init__(self, a_object):
        self._a = a_object

    def __getattr__(self, item):
        return getattr(self._a, item)
</code></pre>
<p>So if <code>b_obj</code> doesn't have an <code>age</code> attribute, it will refer to the <code>age</code> within <code>a_object</code>.</p>
</div>
<span class="comment-copy">Not hard at all actually and does not require any hack - just use <code>*args</code> and <code>**kwargs</code> like you would for a decorator or any generic callable.</span>
<span class="comment-copy">@FHTMitchell chill out - your answer wasn't posted when I started writing mine, I only saw it after posting (else I wouldn't have bothered answering).</span>
<span class="comment-copy">Sorry. I'm chill +1</span>
<span class="comment-copy">@FHTMitchell and bruno, what if B was a dynamically generated class? B doesnt know what A's params are.</span>
<span class="comment-copy">@user2626431 see my answer with edit</span>
<span class="comment-copy">@user2626431 use <code>*args</code> and <code>**kwargs</code>, cf my edited answer.</span>
<span class="comment-copy">The OP wants <code>B</code> to derive from <code>A</code>.</span>
