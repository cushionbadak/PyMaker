<div class="post-text" itemprop="text">
<p>I am using Python to build a parser for a file format that has many types of small chunks. Although I expect my own parsing to be sufficient, I'd like to let clients subclass the parser class to provide custom behavior if they need to.</p>
<p>In C++, I could write something like this:</p>
<pre><code>enum ChunkTypes {
    CHUNK_FOO,
    CHUNK_BAR,
    CHUNK_BAZ,
};

class Parser {
public:
    virtual void parse_foo(size_t offset);
    virtual void parse_bar(size_t offset);
    virtual void parse_baz(size_t offset);
};

typedef void (Parser::*parse_method[])(size_t);
parse_method methods[] = {
    &amp;Parser::parse_foo,
    &amp;Parser::parse_bar,
    &amp;Parser::parse_baz,
};

Parser&amp; parser = get_parser();
while (has_more_chunks())
{
    parse_method method = methods[chunk_type()];
    size_t chunk_offset = get_chunk_offset();
    (parser.*method)(chunk_offset);
}
</code></pre>
<p>As this might not be familiar to people who don't write a lot of C++: <code>parse_method</code>, in this example, is a "pointer-to-member" to a <code>Parser</code> method which accepts a <code>size_t</code> argument. <code>(parser.*method)(chunk_offset)</code> applies the method <code>method</code> to <code>parser</code> and passes it the <code>chunk_offset</code> parameter. Note that <strong>this respects virtual dispatch</strong>: with a subclass of <code>Parser</code> that overrides <code>parse_foo</code>, <code>(parser.*method)(chunk_offset)</code> (when <code>method</code> is <code>parse_foo</code>), the subclass's implementation will be called.</p>
<p>In Python, I can write something like this:</p>
<pre><code>class Parser:
    def parse_foo(self, offset):
        # ...

    def parse_bar(self, offset):
        # ...

    def parse_baz(self, offset):
        # ...

methods = [
    Parser.parse_foo,
    Parser.parse_bar,
    Parser.parse_baz]

parser = get_parser()
while has_more_chunks():
    method = methods[chunk_type()]
    offset = get_chunk_offset()
    method(parser, offset)
</code></pre>
<p>However, <code>Parser.parse_foo</code> is a reference to <code>Parser</code>'s implementation of <code>parse_foo</code>, specifically. Even if I call it on a subclass of <code>Parser</code> that overrides it, what is called is still the original implementation.</p>
<p>Is there a way, in Python, to get a "method reference" that respects virtual dispatch? I can make per-instance tables that use <code>self.parse_foo</code>, but that seems wasteful.</p>
</div>
<div class="post-text" itemprop="text">
<p>The closest thing to a method reference is basically just a string containing the method's name. You can use that name to look up the method on the parser object with <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr</code></a> and then call it:</p>
<pre><code>methods = [
    'parse_foo',
    'parse_bar',
    'parse_baz']

parser = get_parser()
while has_more_chunks():
    method_name = methods[chunk_type()]
    method = getattr(parser, method_name)  # get the method
    offset = get_chunk_offset()
    method(offset)  # call the bound method we retrieved earlier
</code></pre>
<p>Alternatively, you can use proxy functions that call the corresponding methods:</p>
<pre><code>methods = [
    lambda parser, offset: parser.parse_foo(offset),
    lambda parser, offset: parser.parse_bar(offset),
    lambda parser, offset: parser.parse_baz(offset)]

parser = get_parser()
while has_more_chunks():
    method = methods[chunk_type()]
    offset = get_chunk_offset()
    method(parser, offset)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not a bound method, but the performance overhead is pretty minimal:</p>
<pre><code>methods = [
    lambda parser, offset: parser.parse_foo(offset),
    lambda parser, offset: parser.parse_bar(offset),
    ...]
</code></pre>
<p>If you don't want to be tied to a specific argument signature, you can write:</p>
<pre><code>lambda parser, *args, **kwargs: parser.parse_foo(*args, **kwargs)
</code></pre>
<p>Better yet, if <code>chunk_type()</code> returns a string such as <code>parse_foo</code>, you can just write:</p>
<pre><code>getattr(parser, chunk_type())(offset)
</code></pre>
<p>without the list of methods at all.</p>
</div>
<div class="post-text" itemprop="text">
<p>So you would use pointer to members in C++. The closest in Python would be to have an instance attribute that will receive a bound method. Here is some code demonstrating it:</p>
<pre><code>class A:
    def __init__(self, name):
        self.name = name  # instance identification
    # the methods
    def parse_foo(self, offset):
        print("in foo for instance {} with offset {}".format(
            self.name, offset))
    def parse_bar(self, offset):
        print("in bar for instance {} with offset {}".format(
            self.name, offset))
    def parse_baz(self, offset):
        print("in baz for instance {} with offset {}".format(
            self.name, offset))
    # an array of unbound methods
    methods = [ parse_foo, parse_bar, parse_baz ]

a = A("id_1")         # creates an A instance
a.method = getattr(a, A.methods[1].__name__)   # have a.method be a bound parse_bar method
a.method(10)
</code></pre>
<p>prints as expected:</p>
<pre><code>in bar for instance id_1 with offset 10
</code></pre>
<p>This allows different instances of A to have <code>a.method(offset)</code> invoke different methods.</p>
<hr/>
<p>Anyway, as you are asking for an <em>idiomatic</em> way, this is not very Pythonic. But what is not Pythonic is a dispatcher on an integer (the enum or index array) while Python natively allows to dispatch by names:</p>
<pre><code>a.method = getattr(a, "parse_baz")
a.method(5)
</code></pre>
<p>outputs</p>
<pre><code>in baz for instance id_1 with offset 5
</code></pre>
</div>
